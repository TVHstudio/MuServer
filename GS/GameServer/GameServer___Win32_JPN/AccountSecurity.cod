; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\AccountSecurity.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1CAccountSecurity@@QAE@XZ			; CAccountSecurity::~CAccountSecurity
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\accountsecurity.cpp
;	COMDAT ??1CAccountSecurity@@QAE@XZ
_TEXT	SEGMENT
??1CAccountSecurity@@QAE@XZ PROC			; CAccountSecurity::~CAccountSecurity, COMDAT
; _this$ = ecx

; 21   : }

  00000	c3		 ret	 0
??1CAccountSecurity@@QAE@XZ ENDP			; CAccountSecurity::~CAccountSecurity
_TEXT	ENDS
PUBLIC	?Init@CAccountSecurity@@QAEXXZ			; CAccountSecurity::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CAccountSecurity@@QAEXXZ
_TEXT	SEGMENT
?Init@CAccountSecurity@@QAEXXZ PROC			; CAccountSecurity::Init, COMDAT
; _this$ = ecx

; 25   : 	this->m_bEnable = false;

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 26   : }

  00003	c3		 ret	 0
?Init@CAccountSecurity@@QAEXXZ ENDP			; CAccountSecurity::Init
_TEXT	ENDS
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0BL@OACDLCMK@ZtData?2AccountSecurity?4ini?$AA@ ; `string'
PUBLIC	?Load@CAccountSecurity@@QAEXXZ			; CAccountSecurity::Load
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OACDLCMK@ZtData?2AccountSecurity?4ini?$AA@
CONST	SEGMENT
??_C@_0BL@OACDLCMK@ZtData?2AccountSecurity?4ini?$AA@ DB 'ZtData\AccountSe'
	DB	'curity.ini', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@CAccountSecurity@@QAEXXZ
_TEXT	SEGMENT
?Load@CAccountSecurity@@QAEXXZ PROC			; CAccountSecurity::Load, COMDAT
; _this$ = ecx

; 29   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 30   : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@CAccountSecurity@@QAEXXZ ; CAccountSecurity::Init

; 31   : 
; 32   : 	if(!g_ZtLicense.user.AccSecurity)

  00008	80 3d ef 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+239, 0
  0000f	74 29		 je	 SHORT $LN2@Load

; 33   : 	{
; 34   : 		return;
; 35   : 	}
; 36   : 
; 37   : 	this->m_bEnable = GetPrivateProfileInt("ZtTeam", "Enable", 0, gDirPath.GetNewPath("ZtData\\AccountSecurity.ini"));

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OACDLCMK@ZtData?2AccountSecurity?4ini?$AA@
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0001b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00020	50		 push	 eax
  00021	6a 00		 push	 0
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00033	85 c0		 test	 eax, eax
  00035	0f 95 c0	 setne	 al
  00038	88 06		 mov	 BYTE PTR [esi], al
$LN2@Load:
  0003a	5e		 pop	 esi

; 38   : 
; 39   : }

  0003b	c3		 ret	 0
?Load@CAccountSecurity@@QAEXXZ ENDP			; CAccountSecurity::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqLoad@CAccountSecurity@@QAEXH@Z		; CAccountSecurity::GDReqLoad
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GDReqLoad@CAccountSecurity@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqLoad@CAccountSecurity@@QAEXH@Z PROC		; CAccountSecurity::GDReqLoad, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 43   : 	if(!this->m_bEnable)

  00010	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00013	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00016	74 54		 je	 SHORT $LN3@GDReqLoad

; 44   : 	{
; 45   : 		return;
; 46   : 	}
; 47   : 
; 48   : 	if(!OBJMAX_RANGE(aIndex))

  00018	85 d2		 test	 edx, edx
  0001a	78 50		 js	 SHORT $LN3@GDReqLoad
  0001c	33 c0		 xor	 eax, eax
  0001e	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	74 41		 je	 SHORT $LN3@GDReqLoad

; 49   : 	{
; 50   : 		return;
; 51   : 	}
; 52   : 
; 53   : 	LPOBJ lpUser = &gObj[aIndex];

  0002b	8b c2		 mov	 eax, edx
  0002d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00033	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 54   : 
; 55   : 	PMSG_REQ_ACC_DATABASE_LOAD pMsg;
; 56   : 	pMsg.h.set((LPBYTE)&pMsg, 0xEF, 0x00, sizeof(pMsg));

  00039	c7 45 e8 c1 12
	ef 00		 mov	 DWORD PTR _pMsg$[ebp], 15667905 ; 00ef12c1H

; 57   : 	pMsg.aIndex = aIndex;

  00040	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 58   : 	pMsg.Account[10] = 0;

  00044	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0

; 59   : 	memcpy(pMsg.Account, lpUser->AccountID, sizeof(pMsg.Account)-1);

  00048	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0004b	89 4d ee	 mov	 DWORD PTR _pMsg$[ebp+6], ecx
  0004e	8b 50 70	 mov	 edx, DWORD PTR [eax+112]

; 60   : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  00051	6a 12		 push	 18			; 00000012H
  00053	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00056	89 55 f2	 mov	 DWORD PTR _pMsg$[ebp+10], edx
  00059	66 8b 40 74	 mov	 ax, WORD PTR [eax+116]
  0005d	51		 push	 ecx
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00063	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax
  00067	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqLoad:

; 61   : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
?GDReqLoad@CAccountSecurity@@QAEXH@Z ENDP		; CAccountSecurity::GDReqLoad
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqSave@CAccountSecurity@@QAEXH@Z		; CAccountSecurity::GDReqSave
; Function compile flags: /Ogtp
;	COMDAT ?GDReqSave@CAccountSecurity@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqSave@CAccountSecurity@@QAEXH@Z PROC		; CAccountSecurity::GDReqSave, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 112  : 	if(!this->m_bEnable)

  00010	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00013	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00016	0f 84 b4 00 00
	00		 je	 $LN3@GDReqSave

; 113  : 	{
; 114  : 		return;
; 115  : 	}
; 116  : 
; 117  : 	if(!OBJMAX_RANGE(aIndex))

  0001c	85 d2		 test	 edx, edx
  0001e	0f 88 ac 00 00
	00		 js	 $LN3@GDReqSave
  00024	33 c0		 xor	 eax, eax
  00026	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  0002c	0f 9e c0	 setle	 al
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 99 00 00
	00		 je	 $LN3@GDReqSave

; 118  : 	{
; 119  : 		return;
; 120  : 	}
; 121  : 
; 122  : 	LPOBJ lpUser = &gObj[aIndex];

  00037	8b c2		 mov	 eax, edx
  00039	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0003f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 123  : 	PMSG_REQ_ACC_DATABASE_SAVE pMsg;
; 124  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEF, 0x01, sizeof(pMsg));

  00045	c7 45 d8 c1 24
	ef 01		 mov	 DWORD PTR _pMsg$[ebp], 32449729 ; 01ef24c1H

; 125  : 	pMsg.aIndex = aIndex;

  0004c	66 89 55 dc	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 126  : 	pMsg.Account[10] = 0;

  00050	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0

; 127  : 	memcpy(pMsg.Account, lpUser->AccountID, sizeof(pMsg.Account)-1);

  00054	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00057	89 4d de	 mov	 DWORD PTR _pMsg$[ebp+6], ecx
  0005a	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  0005d	89 55 e2	 mov	 DWORD PTR _pMsg$[ebp+10], edx
  00060	66 8b 48 74	 mov	 cx, WORD PTR [eax+116]
  00064	66 89 4d e6	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 128  : 
; 129  : 	pMsg.ActivePCID = lpUser->AccountSecurity.ActivePCID;

  00068	0f b6 90 fc 29
	00 00		 movzx	 edx, BYTE PTR [eax+10748]
  0006f	88 55 e9	 mov	 BYTE PTR _pMsg$[ebp+17], dl

; 130  : 	pMsg.ProtectPCID = lpUser->AccountSecurity.ProtectPCID;

  00072	8b 88 04 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10756]
  00078	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+20], ecx

; 131  : 	pMsg.SecretNumber = lpUser->AccountSecurity.SecretNumber;

  0007b	8b 90 08 2a 00
	00		 mov	 edx, DWORD PTR [eax+10760]
  00081	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+24], edx

; 132  : 	pMsg.OnlyMyPC = lpUser->AccountSecurity.OnlyMyPC;

  00084	0f b6 88 0c 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10764]
  0008b	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+28], cl

; 133  : 	pMsg.Trade = lpUser->AccountSecurity.Trade;

  0008e	0f b6 90 0d 2a
	00 00		 movzx	 edx, BYTE PTR [eax+10765]
  00095	88 55 f5	 mov	 BYTE PTR _pMsg$[ebp+29], dl

; 134  : 	pMsg.Inventory = lpUser->AccountSecurity.Inventory;

  00098	0f b6 88 0e 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10766]
  0009f	88 4d f6	 mov	 BYTE PTR _pMsg$[ebp+30], cl

; 135  : 	pMsg.Werehouse = lpUser->AccountSecurity.Werehouse;

  000a2	0f b6 90 0f 2a
	00 00		 movzx	 edx, BYTE PTR [eax+10767]
  000a9	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+31], dl

; 136  : 	pMsg.DisconnectFriend = lpUser->AccountSecurity.DisconnectFriend;

  000ac	0f b6 88 10 2a
	00 00		 movzx	 ecx, BYTE PTR [eax+10768]
  000b3	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+32], cl

; 137  : 	pMsg.SellChar = lpUser->AccountSecurity.SellChar;

  000b6	0f b6 90 11 2a
	00 00		 movzx	 edx, BYTE PTR [eax+10769]

; 138  : 
; 139  : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  000bd	6a 24		 push	 36			; 00000024H
  000bf	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c2	50		 push	 eax
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000c8	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+33], dl
  000cb	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqSave:

; 140  : }

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d3	33 cd		 xor	 ecx, ebp
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 04 00	 ret	 4
?GDReqSave@CAccountSecurity@@QAEXH@Z ENDP		; CAccountSecurity::GDReqSave
_TEXT	ENDS
PUBLIC	?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z ; CAccountSecurity::CGRecvAccountConnect
; Function compile flags: /Ogtp
;	COMDAT ?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z PROC ; CAccountSecurity::CGRecvAccountConnect, COMDAT
; _this$ = ecx

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 159  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	74 2e		 je	 SHORT $LN3@CGRecvAcco

; 160  : 	{
; 161  : 		return;
; 162  : 	}
; 163  : 
; 164  : 	if(!OBJMAX_RANGE(aIndex))

  00008	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	78 27		 js	 SHORT $LN3@CGRecvAcco
  0000f	33 c9		 xor	 ecx, ecx
  00011	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00016	0f 9e c1	 setle	 cl
  00019	85 c9		 test	 ecx, ecx
  0001b	74 19		 je	 SHORT $LN3@CGRecvAcco

; 165  : 	{
; 166  : 		return;
; 167  : 	}
; 168  : 
; 169  : 	LPOBJ lpUser = &gObj[aIndex];
; 170  : 
; 171  : 	lpUser->AccountSecurity.ClientPCID = lpMsg->PCID;

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00020	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00026	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	89 94 08 00 2a
	00 00		 mov	 DWORD PTR [eax+ecx+10752], edx
$LN3@CGRecvAcco:

; 172  : 
; 173  : #if(DEBUG_ACCOUNT_SECURITY)
; 174  : 
; 175  : 	BYTE bResult = 1;
; 176  : 
; 177  : 	if(this->CheckOnlyMyPC(aIndex) == true)
; 178  : 	{
; 179  : 		gObj[aIndex].UserNumber = gObj[aIndex].Join_aUserNumber;
; 180  : 		gObj[aIndex].DBNumber = gObj[aIndex].Join_aDBNumber;
; 181  : 		gObj[aIndex].Connected = PLAYER_LOGGED;
; 182  : 		strcpy(gObj[aIndex].LastJoominNumber, gObj[aIndex].Join_JoominNumber);
; 183  : 		gObj[aIndex].ukn_30 = gObj[aIndex].Join_ukn_30;
; 184  : 		gObj[aIndex].m_iPcBangRoom = gObj[aIndex].Join_PcBangRoom;
; 185  : 	}
; 186  : 	else
; 187  : 	{
; 188  : 		GJPAccountFail(aIndex, gObj[aIndex].AccountID, gObj[aIndex].DBNumber , gObj[aIndex].UserNumber  );
; 189  : 		bResult  = 5;	//5 - blocked, 7 - Connection Error
; 190  : 	}
; 191  : 
; 192  : 	GCJoinResult(bResult , aIndex);
; 193  : 
; 194  : 	if(bResult == 1)
; 195  : 	{
; 196  : 		if(gObj[aIndex].LoginMsgCount > 3)
; 197  : 		{
; 198  : 			CloseClient(aIndex);
; 199  : 		}
; 200  : 
; 201  : 		return;
; 202  : 	}
; 203  : 
; 204  : 	this->GCSendAccountInfo(aIndex);
; 205  : 
; 206  : #endif
; 207  : 
; 208  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z ENDP ; CAccountSecurity::CGRecvAccountConnect
_TEXT	ENDS
PUBLIC	?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z ; CAccountSecurity::CGRecvSettingPC
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z PROC ; CAccountSecurity::CGRecvSettingPC, COMDAT
; _this$ = ecx

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 212  : 	if(!this->m_bEnable)

  00009	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0000c	74 7f		 je	 SHORT $LN1@CGRecvSett

; 213  : 	{
; 214  : 		return;
; 215  : 	}
; 216  : 
; 217  : 	if(!OBJMAX_RANGE(aIndex))

  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	85 f6		 test	 esi, esi
  00014	78 76		 js	 SHORT $LN14@CGRecvSett
  00016	33 c0		 xor	 eax, eax
  00018	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0001e	0f 9e c0	 setle	 al
  00021	85 c0		 test	 eax, eax
  00023	74 67		 je	 SHORT $LN14@CGRecvSett

; 218  : 	{
; 219  : 		return;
; 220  : 	}
; 221  : 
; 222  : 	LPOBJ lpUser = &gObj[aIndex];
; 223  : 
; 224  : 	PMSG_ANS_ACC_SETTING_PC pMsg;
; 225  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB1, sizeof(pMsg));
; 226  : 
; 227  : 	pMsg.Result = 0;
; 228  : 
; 229  : 	if(lpUser->AccountSecurity.SecretNumber == lpMsg->SecretNumber)

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00028	8b c6		 mov	 eax, esi
  0002a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00030	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	c7 45 f8 c1 05
	fb b1		 mov	 DWORD PTR _pMsg$[ebp], -1308949055 ; b1fb05c1H
  0003d	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00041	8b 90 08 2a 00
	00		 mov	 edx, DWORD PTR [eax+10760]
  00047	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0004a	75 23		 jne	 SHORT $LN12@CGRecvSett

; 230  : 	{
; 231  : 		pMsg.Result = 1;
; 232  : 
; 233  : 		lpUser->AccountSecurity.ActivePCID = lpMsg->ActivePCID;

  0004c	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00050	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  00054	0f 95 c2	 setne	 dl
  00057	88 90 fc 29 00
	00		 mov	 BYTE PTR [eax+10748], dl

; 234  : 
; 235  : 		if(lpMsg->ChangePCID)

  0005d	80 79 05 00	 cmp	 BYTE PTR [ecx+5], 0
  00061	74 0c		 je	 SHORT $LN12@CGRecvSett

; 236  : 		{
; 237  : 			lpUser->AccountSecurity.ProtectPCID = lpUser->AccountSecurity.ClientPCID;

  00063	8b 88 00 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10752]
  00069	89 88 04 2a 00
	00		 mov	 DWORD PTR [eax+10756], ecx
$LN12@CGRecvSett:

; 238  : 		}
; 239  : 	}
; 240  : 
; 241  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0006f	6a 05		 push	 5
  00071	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00074	52		 push	 edx
  00075	56		 push	 esi
  00076	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 
; 243  : 	if(pMsg.Result == 1)

  0007e	80 7d fc 01	 cmp	 BYTE PTR _pMsg$[ebp+4], 1
  00082	75 08		 jne	 SHORT $LN14@CGRecvSett

; 244  : 	{
; 245  : 		this->GDReqSave(aIndex);

  00084	56		 push	 esi
  00085	8b cf		 mov	 ecx, edi
  00087	e8 00 00 00 00	 call	 ?GDReqSave@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqSave
$LN14@CGRecvSett:
  0008c	5e		 pop	 esi
$LN1@CGRecvSett:
  0008d	5f		 pop	 edi

; 246  : 	}
; 247  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z ENDP ; CAccountSecurity::CGRecvSettingPC
_TEXT	ENDS
PUBLIC	?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z ; CAccountSecurity::CGRecvSaveNumber
; Function compile flags: /Ogtp
;	COMDAT ?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z PROC ; CAccountSecurity::CGRecvSaveNumber, COMDAT
; _this$ = ecx

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	74 3a		 je	 SHORT $LN3@CGRecvSave

; 281  : 	{
; 282  : 		return;
; 283  : 	}
; 284  : 
; 285  : 	if(!OBJMAX_RANGE(aIndex))

  00008	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	78 33		 js	 SHORT $LN3@CGRecvSave
  0000f	33 d2		 xor	 edx, edx
  00011	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00016	0f 9e c2	 setle	 dl
  00019	85 d2		 test	 edx, edx
  0001b	74 25		 je	 SHORT $LN3@CGRecvSave

; 286  : 	{
; 287  : 		return;
; 288  : 	}
; 289  : 
; 290  : 	LPOBJ lpUser = &gObj[aIndex];

  0001d	8b d0		 mov	 edx, eax
  0001f	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00025	56		 push	 esi

; 291  : 
; 292  : 	lpUser->AccountSecurity.SecretNumber = lpMsg->SecretNumber;

  00026	8b 75 0c	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00029	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0002c	57		 push	 edi
  0002d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 293  : 
; 294  : 	this->GDReqSave(aIndex);

  00033	50		 push	 eax
  00034	89 b4 3a 08 2a
	00 00		 mov	 DWORD PTR [edx+edi+10760], esi
  0003b	e8 00 00 00 00	 call	 ?GDReqSave@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqSave
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
$LN3@CGRecvSave:

; 295  : }

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z ENDP ; CAccountSecurity::CGRecvSaveNumber
_TEXT	ENDS
PUBLIC	?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckNewSecretNumber
; Function compile flags: /Ogtp
;	COMDAT ?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z PROC	; CAccountSecurity::CheckNewSecretNumber, COMDAT
; _this$ = ecx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN2@CheckNewSe

; 318  : 	{
; 319  : 		return true;

  00008	b0 01		 mov	 al, 1

; 325  : 	{
; 326  : 		return true;
; 327  : 	}
; 328  : 
; 329  : 	return false;
; 330  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@CheckNewSe:

; 320  : 	}
; 321  : 
; 322  : 	LPOBJ lpUser = &gObj[aIndex];

  0000e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 323  : 
; 324  : 	if(lpUser->AccountSecurity.SecretNumber == 0)

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00017	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0001d	83 bc 08 08 2a
	00 00 00	 cmp	 DWORD PTR [eax+ecx+10760], 0
  00025	0f 94 c0	 sete	 al

; 325  : 	{
; 326  : 		return true;
; 327  : 	}
; 328  : 
; 329  : 	return false;
; 330  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z ENDP	; CAccountSecurity::CheckNewSecretNumber
_TEXT	ENDS
PUBLIC	?CheckPCID@CAccountSecurity@@QAE_NH@Z		; CAccountSecurity::CheckPCID
; Function compile flags: /Ogtp
;	COMDAT ?CheckPCID@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckPCID@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckPCID, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 334  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN2@CheckPCID

; 335  : 	{
; 336  : 		return true;

  00008	b0 01		 mov	 al, 1

; 342  : 	{
; 343  : 		return true;
; 344  : 	}
; 345  : 
; 346  : 	return false;
; 347  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@CheckPCID:

; 337  : 	}
; 338  : 
; 339  : 	LPOBJ lpUser = &gObj[aIndex];

  0000e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00011	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00017	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 340  : 
; 341  : 	if(lpUser->AccountSecurity.ClientPCID == lpUser->AccountSecurity.ProtectPCID)

  0001d	8b 88 00 2a 00
	00		 mov	 ecx, DWORD PTR [eax+10752]
  00023	3b 88 04 2a 00
	00		 cmp	 ecx, DWORD PTR [eax+10756]
  00029	0f 94 c0	 sete	 al

; 342  : 	{
; 343  : 		return true;
; 344  : 	}
; 345  : 
; 346  : 	return false;
; 347  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?CheckPCID@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckPCID
_TEXT	ENDS
PUBLIC	?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckOnlyMyPC
; Function compile flags: /Ogtp
;	COMDAT ?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckOnlyMyPC, COMDAT
; _this$ = ecx

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 351  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 352  : 	{
; 353  : 		return true;

  00006	74 31		 je	 SHORT $LN1@CheckOnlyM

; 354  : 	}
; 355  : 
; 356  : 	LPOBJ lpUser = &gObj[aIndex];

  00008	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000b	8b d0		 mov	 edx, eax
  0000d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00013	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 357  : 
; 358  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.OnlyMyPC == true)

  00019	80 ba fc 29 00
	00 01		 cmp	 BYTE PTR [edx+10748], 1
  00020	75 17		 jne	 SHORT $LN1@CheckOnlyM
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00028	84 c0		 test	 al, al
  0002a	75 0d		 jne	 SHORT $LN1@CheckOnlyM
  0002c	80 ba 0c 2a 00
	00 01		 cmp	 BYTE PTR [edx+10764], 1
  00033	75 04		 jne	 SHORT $LN1@CheckOnlyM

; 364  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN1@CheckOnlyM:

; 359  : 	{
; 360  : 		return false;	
; 361  : 	}
; 362  : 
; 363  : 	return true;

  00039	b0 01		 mov	 al, 1

; 364  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckOnlyMyPC
_TEXT	ENDS
PUBLIC	??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@ ; `string'
PUBLIC	?CheckTrade@CAccountSecurity@@QAE_NH@Z		; CAccountSecurity::CheckTrade
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
;	COMDAT ??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@
CONST	SEGMENT
??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@ DB '[Accoun'
	DB	't Security] Trade Blocked', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckTrade@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckTrade@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckTrade, COMDAT
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 368  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN2@CheckTrade

; 369  : 	{
; 370  : 		return true;

  00008	b0 01		 mov	 al, 1

; 383  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@CheckTrade:
  0000e	56		 push	 esi

; 371  : 	}
; 372  : 
; 373  : 	LPOBJ lpUser = &gObj[aIndex];

  0000f	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	8b d6		 mov	 edx, esi
  00014	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0001a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 374  : 
; 375  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.Trade == false)

  00020	80 ba fc 29 00
	00 01		 cmp	 BYTE PTR [edx+10748], 1
  00027	75 29		 jne	 SHORT $LN1@CheckTrade
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  0002f	84 c0		 test	 al, al
  00031	75 1f		 jne	 SHORT $LN1@CheckTrade
  00033	38 82 0d 2a 00
	00		 cmp	 BYTE PTR [edx+10765], al
  00039	75 17		 jne	 SHORT $LN1@CheckTrade

; 376  : 	{
; 377  : 		GCServerMsgStringSend("[Account Security] Trade Blocked", aIndex, 0);

  0003b	6a 00		 push	 0
  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OEGIIJIK@?$FLAccount?5Security?$FN?5Trade?5Blocked@
  00043	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 378  : 
; 379  : 		return false;	

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 383  : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN1@CheckTrade:

; 380  : 	}
; 381  : 
; 382  : 	return true;

  00052	b0 01		 mov	 al, 1
  00054	5e		 pop	 esi

; 383  : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?CheckTrade@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckTrade
_TEXT	ENDS
PUBLIC	??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@ ; `string'
PUBLIC	?CheckInventory@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckInventory
;	COMDAT ??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@
CONST	SEGMENT
??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@ DB '[Accoun'
	DB	't Security] Inventory Blocked', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckInventory@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckInventory@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckInventory, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN2@CheckInven

; 388  : 	{
; 389  : 		return true;

  00008	b0 01		 mov	 al, 1

; 402  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@CheckInven:
  0000e	56		 push	 esi

; 390  : 	}
; 391  : 
; 392  : 	LPOBJ lpUser = &gObj[aIndex];

  0000f	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	8b d6		 mov	 edx, esi
  00014	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0001a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 393  : 
; 394  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.Inventory == false)

  00020	80 ba fc 29 00
	00 01		 cmp	 BYTE PTR [edx+10748], 1
  00027	75 29		 jne	 SHORT $LN1@CheckInven
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  0002f	84 c0		 test	 al, al
  00031	75 1f		 jne	 SHORT $LN1@CheckInven
  00033	38 82 0e 2a 00
	00		 cmp	 BYTE PTR [edx+10766], al
  00039	75 17		 jne	 SHORT $LN1@CheckInven

; 395  : 	{
; 396  : 		GCServerMsgStringSend("[Account Security] Inventory Blocked", aIndex, 0);

  0003b	6a 00		 push	 0
  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MOMDEFGE@?$FLAccount?5Security?$FN?5Inventory?5Blo@
  00043	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 397  : 
; 398  : 		return false;	

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 402  : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN1@CheckInven:

; 399  : 	}
; 400  : 
; 401  : 	return true;

  00052	b0 01		 mov	 al, 1
  00054	5e		 pop	 esi

; 402  : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?CheckInventory@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckInventory
_TEXT	ENDS
PUBLIC	??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@ ; `string'
PUBLIC	?CheckWerehouse@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckWerehouse
;	COMDAT ??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@
CONST	SEGMENT
??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@ DB '[Accoun'
	DB	't Security] Werehouse Blocked', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckWerehouse@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckWerehouse@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckWerehouse, COMDAT
; _this$ = ecx

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN2@CheckWereh

; 407  : 	{
; 408  : 		return true;

  00008	b0 01		 mov	 al, 1

; 421  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@CheckWereh:
  0000e	56		 push	 esi

; 409  : 	}
; 410  : 
; 411  : 	LPOBJ lpUser = &gObj[aIndex];

  0000f	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	8b d6		 mov	 edx, esi
  00014	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0001a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 412  : 
; 413  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.Werehouse == false)

  00020	80 ba fc 29 00
	00 01		 cmp	 BYTE PTR [edx+10748], 1
  00027	75 29		 jne	 SHORT $LN1@CheckWereh
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  0002f	84 c0		 test	 al, al
  00031	75 1f		 jne	 SHORT $LN1@CheckWereh
  00033	38 82 0f 2a 00
	00		 cmp	 BYTE PTR [edx+10767], al
  00039	75 17		 jne	 SHORT $LN1@CheckWereh

; 414  : 	{
; 415  : 		GCServerMsgStringSend("[Account Security] Werehouse Blocked", aIndex, 0);

  0003b	6a 00		 push	 0
  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CJMJLKJM@?$FLAccount?5Security?$FN?5Werehouse?5Blo@
  00043	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 
; 417  : 		return false;	

  0004b	32 c0		 xor	 al, al
  0004d	5e		 pop	 esi

; 421  : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN1@CheckWereh:

; 418  : 	}
; 419  : 
; 420  : 	return true;

  00052	b0 01		 mov	 al, 1
  00054	5e		 pop	 esi

; 421  : }

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?CheckWerehouse@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckWerehouse
_TEXT	ENDS
PUBLIC	??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@ ; `string'
PUBLIC	?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z ; CAccountSecurity::CheckDisconnectFriend
;	COMDAT ??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@
CONST	SEGMENT
??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@ DB '[Accoun'
	DB	't Security] Disconnect Friend Blocked', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aFriendIndex$ = 12					; size = 4
?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z PROC	; CAccountSecurity::CheckDisconnectFriend, COMDAT
; _this$ = ecx

; 424  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 425  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 426  : 	{
; 427  : 		return true;

  00006	74 45		 je	 SHORT $LN1@CheckDisco

; 428  : 	}
; 429  : 
; 430  : 	LPOBJ lpUser = &gObj[aIndex];

  00008	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000b	8b d0		 mov	 edx, eax
  0000d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00013	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 431  : 
; 432  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.DisconnectFriend == false)

  00019	80 ba fc 29 00
	00 01		 cmp	 BYTE PTR [edx+10748], 1
  00020	75 2b		 jne	 SHORT $LN1@CheckDisco
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00028	84 c0		 test	 al, al
  0002a	75 21		 jne	 SHORT $LN1@CheckDisco
  0002c	38 82 10 2a 00
	00		 cmp	 BYTE PTR [edx+10768], al
  00032	75 19		 jne	 SHORT $LN1@CheckDisco

; 433  : 	{
; 434  : 		GCServerMsgStringSend("[Account Security] Disconnect Friend Blocked", aFriendIndex, 0);

  00034	8b 45 0c	 mov	 eax, DWORD PTR _aFriendIndex$[ebp]
  00037	6a 00		 push	 0
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CFODICGM@?$FLAccount?5Security?$FN?5Disconnect?5Fr@
  0003f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : 
; 436  : 		return false;	

  00047	32 c0		 xor	 al, al

; 440  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN1@CheckDisco:

; 437  : 	}
; 438  : 
; 439  : 	return true;

  0004d	b0 01		 mov	 al, 1

; 440  : }

  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?CheckDisconnectFriend@CAccountSecurity@@QAE_NHH@Z ENDP	; CAccountSecurity::CheckDisconnectFriend
_TEXT	ENDS
PUBLIC	?CheckSellChar@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::CheckSellChar
; Function compile flags: /Ogtp
;	COMDAT ?CheckSellChar@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckSellChar@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::CheckSellChar, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 444  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 445  : 	{
; 446  : 		return true;

  00006	74 30		 je	 SHORT $LN1@CheckSellC

; 447  : 	}
; 448  : 
; 449  : 	LPOBJ lpUser = &gObj[aIndex];

  00008	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000b	8b d0		 mov	 edx, eax
  0000d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00013	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 450  : 
; 451  : 	if(lpUser->AccountSecurity.ActivePCID == true && this->CheckPCID(aIndex) == false && lpUser->AccountSecurity.SellChar == false)

  00019	80 ba fc 29 00
	00 01		 cmp	 BYTE PTR [edx+10748], 1
  00020	75 16		 jne	 SHORT $LN1@CheckSellC
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00028	84 c0		 test	 al, al
  0002a	75 0c		 jne	 SHORT $LN1@CheckSellC
  0002c	38 82 11 2a 00
	00		 cmp	 BYTE PTR [edx+10769], al
  00032	75 04		 jne	 SHORT $LN1@CheckSellC

; 457  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN1@CheckSellC:

; 452  : 	{
; 453  : 		return false;	
; 454  : 	}
; 455  : 
; 456  : 	return true;

  00038	b0 01		 mov	 al, 1

; 457  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?CheckSellChar@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::CheckSellChar
_TEXT	ENDS
PUBLIC	?SelectCharacter@CAccountSecurity@@QAE_NH@Z	; CAccountSecurity::SelectCharacter
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
; Function compile flags: /Ogtp
;	COMDAT ?SelectCharacter@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?SelectCharacter@CAccountSecurity@@QAE_NH@Z PROC	; CAccountSecurity::SelectCharacter, COMDAT
; _this$ = ecx

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 461  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN3@SelectChar

; 462  : 	{
; 463  : 		return true;

  00008	b0 01		 mov	 al, 1

; 479  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN3@SelectChar:
  0000e	56		 push	 esi

; 464  : 	}
; 465  : 
; 466  : 	if(!OBJMAX_RANGE(aIndex))

  0000f	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	85 f6		 test	 esi, esi
  00014	78 2b		 js	 SHORT $LN1@SelectChar
  00016	33 c0		 xor	 eax, eax
  00018	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0001e	0f 9e c0	 setle	 al
  00021	85 c0		 test	 eax, eax

; 467  : 	{
; 468  : 		return true;

  00023	74 1c		 je	 SHORT $LN1@SelectChar

; 469  : 	}
; 470  : 
; 471  : 	if(this->CheckOnlyMyPC(aIndex) == false)

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckOnlyMyPC
  0002b	84 c0		 test	 al, al
  0002d	75 12		 jne	 SHORT $LN1@SelectChar

; 472  : 	{
; 473  : 		GCCloseMsgSend(aIndex, 2);

  0002f	6a 02		 push	 2
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00037	83 c4 08	 add	 esp, 8

; 474  : 
; 475  : 		return false;	

  0003a	32 c0		 xor	 al, al
  0003c	5e		 pop	 esi

; 479  : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN1@SelectChar:

; 476  : 	}
; 477  : 
; 478  : 	return true;

  00041	b0 01		 mov	 al, 1
  00043	5e		 pop	 esi

; 479  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?SelectCharacter@CAccountSecurity@@QAE_NH@Z ENDP	; CAccountSecurity::SelectCharacter
_TEXT	ENDS
PUBLIC	?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z	; CAccountSecurity::CheckJoinLogin
; Function compile flags: /Ogtp
;	COMDAT ?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
_JoinResult$ = 16					; size = 1
?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z PROC	; CAccountSecurity::CheckJoinLogin, COMDAT
; _this$ = ecx

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 483  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN3@CheckJoinL
$LN6@CheckJoinL:

; 484  : 	{
; 485  : 		return false;

  00008	32 c0		 xor	 al, al

; 501  : }

  0000a	5d		 pop	 ebp
  0000b	c2 0c 00	 ret	 12			; 0000000cH
$LN3@CheckJoinL:

; 486  : 	}
; 487  : 
; 488  : 	if(Result != 1)

  0000e	80 7d 0c 01	 cmp	 BYTE PTR _Result$[ebp], 1

; 489  : 	{
; 490  : 		return false;

  00012	75 f4		 jne	 SHORT $LN6@CheckJoinL

; 491  : 	}
; 492  : 
; 493  : 	if(JoinResult == false)

  00014	80 7d 10 00	 cmp	 BYTE PTR _JoinResult$[ebp], 0

; 494  : 	{
; 495  : 		return false;

  00018	74 ee		 je	 SHORT $LN6@CheckJoinL

; 496  : 	}
; 497  : 
; 498  : 	this->GDReqLoad(aIndex);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?GDReqLoad@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqLoad

; 499  : 
; 500  : 	return true;

  00023	b0 01		 mov	 al, 1

; 501  : }

  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
?CheckJoinLogin@CAccountSecurity@@QAE_NHE_N@Z ENDP	; CAccountSecurity::CheckJoinLogin
_TEXT	ENDS
PUBLIC	?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z	; CAccountSecurity::GCReqAccountConnect
; Function compile flags: /Ogtp
;	COMDAT ?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z PROC	; CAccountSecurity::GCReqAccountConnect, COMDAT
; _this$ = ecx

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 505  : 	PMSG_REQ_ACC_LOGIN pMsg;
; 506  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB4, sizeof(pMsg));
; 507  : 	pMsg.Result = true;
; 508  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00009	6a 05		 push	 5
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	c7 45 f8 c1 05
	fb b4		 mov	 DWORD PTR _pMsg$[ebp], -1258617407 ; b4fb05c1H
  00017	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  0001b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GCReqAccountConnect@CAccountSecurity@@QAEXH@Z ENDP	; CAccountSecurity::GCReqAccountConnect
_TEXT	ENDS
PUBLIC	?GetActivePC@CAccountSecurity@@QAE_NH@Z		; CAccountSecurity::GetActivePC
; Function compile flags: /Ogtp
;	COMDAT ?GetActivePC@CAccountSecurity@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GetActivePC@CAccountSecurity@@QAE_NH@Z PROC		; CAccountSecurity::GetActivePC, COMDAT
; _this$ = ecx

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 513  : 	if(!this->m_bEnable)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	75 06		 jne	 SHORT $LN2@GetActiveP
$LN7@GetActiveP:

; 514  : 	{
; 515  : 		return false;

  00008	32 c0		 xor	 al, al

; 526  : }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN2@GetActiveP:

; 516  : 	}
; 517  : 
; 518  : 	if(!OBJMAX_RANGE(aIndex))

  0000e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00011	85 c0		 test	 eax, eax
  00013	78 f3		 js	 SHORT $LN7@GetActiveP
  00015	33 c9		 xor	 ecx, ecx
  00017	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  0001c	0f 9e c1	 setle	 cl
  0001f	85 c9		 test	 ecx, ecx

; 519  : 	{
; 520  : 		return false;

  00021	74 e5		 je	 SHORT $LN7@GetActiveP

; 521  : 	}
; 522  : 
; 523  : 	LPOBJ lpUser = &gObj[aIndex];
; 524  : 
; 525  : 	return lpUser->AccountSecurity.ActivePCID;

  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002f	8a 84 08 fc 29
	00 00		 mov	 al, BYTE PTR [eax+ecx+10748]

; 526  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?GetActivePC@CAccountSecurity@@QAE_NH@Z ENDP		; CAccountSecurity::GetActivePC
_TEXT	ENDS
PUBLIC	??0CAccountSecurity@@QAE@XZ			; CAccountSecurity::CAccountSecurity
; Function compile flags: /Ogtp
;	COMDAT ??0CAccountSecurity@@QAE@XZ
_TEXT	SEGMENT
??0CAccountSecurity@@QAE@XZ PROC			; CAccountSecurity::CAccountSecurity, COMDAT
; _this$ = ecx

; 16   : 	this->Init();

  00000	e8 00 00 00 00	 call	 ?Init@CAccountSecurity@@QAEXXZ ; CAccountSecurity::Init

; 17   : }

  00005	8b c1		 mov	 eax, ecx
  00007	c3		 ret	 0
??0CAccountSecurity@@QAE@XZ ENDP			; CAccountSecurity::CAccountSecurity
_TEXT	ENDS
PUBLIC	?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z ; CAccountSecurity::CGRecvAccountOption
; Function compile flags: /Ogtp
;	COMDAT ?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z PROC ; CAccountSecurity::CGRecvAccountOption, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 251  : 	if(!this->m_bEnable)

  00006	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00009	0f 84 8d 00 00
	00		 je	 $LN4@CGRecvAcco@2

; 252  : 	{
; 253  : 		return;
; 254  : 	}
; 255  : 
; 256  : 	if(!OBJMAX_RANGE(aIndex))

  0000f	56		 push	 esi
  00010	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 88 80 00 00
	00		 js	 $LN8@CGRecvAcco@2
  0001b	33 c0		 xor	 eax, eax
  0001d	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00023	0f 9e c0	 setle	 al
  00026	85 c0		 test	 eax, eax
  00028	74 71		 je	 SHORT $LN8@CGRecvAcco@2

; 257  : 	{
; 258  : 		return;
; 259  : 	}
; 260  : 
; 261  : 	if(!this->CheckPCID(aIndex))

  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00030	84 c0		 test	 al, al
  00032	74 67		 je	 SHORT $LN8@CGRecvAcco@2

; 262  : 	{
; 263  : 		return;
; 264  : 	}
; 265  : 
; 266  : 	LPOBJ lpUser = &gObj[aIndex];
; 267  : 
; 268  : 	lpUser->AccountSecurity.OnlyMyPC = lpMsg->OnlyMyPC;

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00037	8b c6		 mov	 eax, esi
  00039	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0003f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0

; 269  : 	lpUser->AccountSecurity.Trade = lpMsg->Trade;
; 270  : 	lpUser->AccountSecurity.Inventory = lpMsg->Inventory;
; 271  : 	lpUser->AccountSecurity.Werehouse = lpMsg->Werehouse;
; 272  : 	lpUser->AccountSecurity.DisconnectFriend = lpMsg->DisconnectFriend;
; 273  : 	lpUser->AccountSecurity.SellChar = lpMsg->SellChar;
; 274  : 
; 275  : 	this->GDReqSave(aIndex);

  00049	56		 push	 esi
  0004a	0f 95 c2	 setne	 dl
  0004d	88 90 0c 2a 00
	00		 mov	 BYTE PTR [eax+10764], dl
  00053	80 79 05 00	 cmp	 BYTE PTR [ecx+5], 0
  00057	0f 95 c2	 setne	 dl
  0005a	88 90 0d 2a 00
	00		 mov	 BYTE PTR [eax+10765], dl
  00060	80 79 06 00	 cmp	 BYTE PTR [ecx+6], 0
  00064	0f 95 c2	 setne	 dl
  00067	88 90 0e 2a 00
	00		 mov	 BYTE PTR [eax+10766], dl
  0006d	80 79 07 00	 cmp	 BYTE PTR [ecx+7], 0
  00071	0f 95 c2	 setne	 dl
  00074	88 90 0f 2a 00
	00		 mov	 BYTE PTR [eax+10767], dl
  0007a	80 79 08 00	 cmp	 BYTE PTR [ecx+8], 0
  0007e	0f 95 c2	 setne	 dl
  00081	88 90 10 2a 00
	00		 mov	 BYTE PTR [eax+10768], dl
  00087	80 79 09 00	 cmp	 BYTE PTR [ecx+9], 0
  0008b	0f 95 c1	 setne	 cl
  0008e	88 88 11 2a 00
	00		 mov	 BYTE PTR [eax+10769], cl
  00094	8b cf		 mov	 ecx, edi
  00096	e8 00 00 00 00	 call	 ?GDReqSave@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GDReqSave
$LN8@CGRecvAcco@2:
  0009b	5e		 pop	 esi
$LN4@CGRecvAcco@2:
  0009c	5f		 pop	 edi

; 276  : }

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z ENDP ; CAccountSecurity::CGRecvAccountOption
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z	; CAccountSecurity::GCSendAccountInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z PROC	; CAccountSecurity::GCSendAccountInfo, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 299  : 	LPOBJ lpUser = &gObj[aIndex];

  00014	8b d6		 mov	 edx, esi
  00016	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0001c	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 300  : 
; 301  : 	PMSG_REQ_ACC_INFO pMsg;
; 302  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xB0, sizeof(pMsg));

  00022	c7 45 ec c1 0d
	fb b0		 mov	 DWORD PTR _pMsg$[ebp], -1325724223 ; b0fb0dc1H

; 303  : 	pMsg.ActivePCID = lpUser->AccountSecurity.ActivePCID;

  00029	0f b6 82 fc 29
	00 00		 movzx	 eax, BYTE PTR [edx+10748]
  00030	57		 push	 edi

; 304  : 	pMsg.NewSecretNumber = this->CheckNewSecretNumber(aIndex);

  00031	56		 push	 esi
  00032	8b f9		 mov	 edi, ecx
  00034	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00037	e8 00 00 00 00	 call	 ?CheckNewSecretNumber@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckNewSecretNumber

; 305  : 	pMsg.CheckPCID = this->CheckPCID(aIndex);

  0003c	56		 push	 esi
  0003d	8b cf		 mov	 ecx, edi
  0003f	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00042	e8 00 00 00 00	 call	 ?CheckPCID@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckPCID
  00047	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 306  : 	pMsg.OnlyMyPC = lpUser->AccountSecurity.OnlyMyPC;

  0004a	0f b6 8a 0c 2a
	00 00		 movzx	 ecx, BYTE PTR [edx+10764]
  00051	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 307  : 	pMsg.Trade = lpUser->AccountSecurity.Trade;

  00054	0f b6 82 0d 2a
	00 00		 movzx	 eax, BYTE PTR [edx+10765]
  0005b	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 308  : 	pMsg.Inventory = lpUser->AccountSecurity.Inventory;

  0005e	0f b6 8a 0e 2a
	00 00		 movzx	 ecx, BYTE PTR [edx+10766]
  00065	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 309  : 	pMsg.Werehouse = lpUser->AccountSecurity.Werehouse;

  00068	0f b6 82 0f 2a
	00 00		 movzx	 eax, BYTE PTR [edx+10767]
  0006f	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 310  : 	pMsg.DisconnectFriend = lpUser->AccountSecurity.DisconnectFriend;

  00072	0f b6 8a 10 2a
	00 00		 movzx	 ecx, BYTE PTR [edx+10768]

; 311  : 	pMsg.SellChar = lpUser->AccountSecurity.SellChar;
; 312  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00079	6a 0d		 push	 13			; 0000000dH
  0007b	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007e	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+11], cl
  00081	8a 92 11 2a 00
	00		 mov	 dl, BYTE PTR [edx+10769]
  00087	50		 push	 eax
  00088	56		 push	 esi
  00089	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+12], dl
  0008c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 313  : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	5f		 pop	 edi
  00098	33 cd		 xor	 ecx, ebp
  0009a	5e		 pop	 esi
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z ENDP	; CAccountSecurity::GCSendAccountInfo
_TEXT	ENDS
PUBLIC	?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z ; CAccountSecurity::DGAnsLoad
; Function compile flags: /Ogtp
;	COMDAT ?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z PROC ; CAccountSecurity::DGAnsLoad, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 65   : 	int aIndex = lpMsg->aIndex;

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0000a	0f b7 71 04	 movzx	 esi, WORD PTR [ecx+4]

; 66   : 
; 67   : 	if(!OBJMAX_RANGE(aIndex))

  0000e	85 f6		 test	 esi, esi
  00010	0f 88 b3 00 00
	00		 js	 $LN3@DGAnsLoad
  00016	33 c0		 xor	 eax, eax
  00018	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0001e	0f 9e c0	 setle	 al
  00021	85 c0		 test	 eax, eax
  00023	0f 84 a0 00 00
	00		 je	 $LN3@DGAnsLoad

; 68   : 	{
; 69   : 		return;
; 70   : 	}
; 71   : 
; 72   : 	LPOBJ lpUser = &gObj[aIndex];

  00029	8b c6		 mov	 eax, esi
  0002b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00031	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 73   : 
; 74   : 	lpUser->AccountSecurity.ActivePCID = lpMsg->ActivePCID;

  00037	80 79 07 00	 cmp	 BYTE PTR [ecx+7], 0

; 75   : 	lpUser->AccountSecurity.ProtectPCID = lpMsg->ProtectPCID;
; 76   : 	lpUser->AccountSecurity.SecretNumber = lpMsg->SecretNumber;
; 77   : 	lpUser->AccountSecurity.OnlyMyPC = lpMsg->OnlyMyPC;
; 78   : 	lpUser->AccountSecurity.Trade = lpMsg->Trade;
; 79   : 	lpUser->AccountSecurity.Inventory = lpMsg->Inventory;
; 80   : 	lpUser->AccountSecurity.Werehouse = lpMsg->Werehouse;
; 81   : 	lpUser->AccountSecurity.DisconnectFriend = lpMsg->DisconnectFriend;
; 82   : 	lpUser->AccountSecurity.SellChar = lpMsg->SellChar;
; 83   : 
; 84   : #if(!DEBUG_ACCOUNT_SECURITY)
; 85   : 
; 86   : 	if(this->CheckOnlyMyPC(aIndex) == false)

  0003b	56		 push	 esi
  0003c	0f 95 c2	 setne	 dl
  0003f	88 90 fc 29 00
	00		 mov	 BYTE PTR [eax+10748], dl
  00045	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00048	89 90 04 2a 00
	00		 mov	 DWORD PTR [eax+10756], edx
  0004e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00051	89 90 08 2a 00
	00		 mov	 DWORD PTR [eax+10760], edx
  00057	80 79 10 00	 cmp	 BYTE PTR [ecx+16], 0
  0005b	0f 95 c2	 setne	 dl
  0005e	88 90 0c 2a 00
	00		 mov	 BYTE PTR [eax+10764], dl
  00064	80 79 11 00	 cmp	 BYTE PTR [ecx+17], 0
  00068	0f 95 c2	 setne	 dl
  0006b	88 90 0d 2a 00
	00		 mov	 BYTE PTR [eax+10765], dl
  00071	80 79 12 00	 cmp	 BYTE PTR [ecx+18], 0
  00075	0f 95 c2	 setne	 dl
  00078	88 90 0e 2a 00
	00		 mov	 BYTE PTR [eax+10766], dl
  0007e	80 79 13 00	 cmp	 BYTE PTR [ecx+19], 0
  00082	0f 95 c2	 setne	 dl
  00085	88 90 0f 2a 00
	00		 mov	 BYTE PTR [eax+10767], dl
  0008b	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0008f	0f 95 c2	 setne	 dl
  00092	88 90 10 2a 00
	00		 mov	 BYTE PTR [eax+10768], dl
  00098	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0009c	0f 95 c1	 setne	 cl
  0009f	88 88 11 2a 00
	00		 mov	 BYTE PTR [eax+10769], cl
  000a5	8b cf		 mov	 ecx, edi
  000a7	e8 00 00 00 00	 call	 ?CheckOnlyMyPC@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckOnlyMyPC
  000ac	84 c0		 test	 al, al
  000ae	75 11		 jne	 SHORT $LN1@DGAnsLoad

; 87   : 	{
; 88   : 		//GCServerMsgStringSend("[Account Security] Only Owner PC", aIndex, 0);
; 89   : 		//GCServerMsgStringSend("[Account Security] Only Owner PC", aIndex, 1);
; 90   : 		//GCJoinResult(0, aIndex);
; 91   : 		//gObjCloseSet(aIndex, 2);
; 92   : 		//Sleep(1000);
; 93   : 		GCCloseMsgSend(aIndex, 2);

  000b0	6a 02		 push	 2
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  000b8	83 c4 08	 add	 esp, 8
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi

; 101  : 
; 102  : #else
; 103  : 
; 104  : 	this->GCReqAccountConnect(aIndex);
; 105  : 
; 106  : #endif
; 107  : 
; 108  : }

  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
$LN1@DGAnsLoad:

; 94   : 
; 95   : 		//CloseClient(aIndex);
; 96   : 
; 97   : 		return;	
; 98   : 	}
; 99   : 
; 100  : 	this->GCSendAccountInfo(aIndex);

  000c1	56		 push	 esi
  000c2	8b cf		 mov	 ecx, edi
  000c4	e8 00 00 00 00	 call	 ?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GCSendAccountInfo
$LN3@DGAnsLoad:
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi

; 101  : 
; 102  : #else
; 103  : 
; 104  : 	this->GCReqAccountConnect(aIndex);
; 105  : 
; 106  : #endif
; 107  : 
; 108  : }

  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?DGAnsLoad@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_LOAD@@@Z ENDP ; CAccountSecurity::DGAnsLoad
_TEXT	ENDS
PUBLIC	?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z ; CAccountSecurity::DGAnsSave
; Function compile flags: /Ogtp
;	COMDAT ?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z PROC ; CAccountSecurity::DGAnsSave, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 144  : 	int aIndex = lpMsg->aIndex;

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00007	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]

; 145  : 
; 146  : 	if(!OBJMAX_RANGE(aIndex))

  0000b	85 c0		 test	 eax, eax
  0000d	78 1a		 js	 SHORT $LN1@DGAnsSave
  0000f	33 d2		 xor	 edx, edx
  00011	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00016	0f 9e c2	 setle	 dl
  00019	85 d2		 test	 edx, edx
  0001b	74 0c		 je	 SHORT $LN1@DGAnsSave

; 147  : 	{
; 148  : 		return;
; 149  : 	}
; 150  : 
; 151  : 	if(lpMsg->Result)

  0001d	80 7e 06 00	 cmp	 BYTE PTR [esi+6], 0
  00021	74 06		 je	 SHORT $LN1@DGAnsSave

; 152  : 	{
; 153  : 		this->GCSendAccountInfo(aIndex);

  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?GCSendAccountInfo@CAccountSecurity@@QAEXH@Z ; CAccountSecurity::GCSendAccountInfo
$LN1@DGAnsSave:
  00029	5e		 pop	 esi

; 154  : 	}
; 155  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?DGAnsSave@CAccountSecurity@@QAEXPAUPMSG_ANS_ACC_DATABASE_SAVE@@@Z ENDP ; CAccountSecurity::DGAnsSave
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_AccountSecurity@@YAXXZ
text$yc	SEGMENT
??__Eg_AccountSecurity@@YAXXZ PROC			; `dynamic initializer for 'g_AccountSecurity'', COMDAT

; 12   : CAccountSecurity g_AccountSecurity;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  00005	e8 00 00 00 00	 call	 ??0CAccountSecurity@@QAE@XZ ; CAccountSecurity::CAccountSecurity
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_AccountSecurity@@YAXXZ ; `dynamic atexit destructor for 'g_AccountSecurity''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_AccountSecurity@@YAXXZ ENDP			; `dynamic initializer for 'g_AccountSecurity''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_AccountSecurity@@YAXXZ
text$yd	SEGMENT
??__Fg_AccountSecurity@@YAXXZ PROC			; `dynamic atexit destructor for 'g_AccountSecurity'', COMDAT
  00000	c3		 ret	 0
??__Fg_AccountSecurity@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_AccountSecurity''
text$yd	ENDS
PUBLIC	?g_AccountSecurity@@3VCAccountSecurity@@A	; g_AccountSecurity
_BSS	SEGMENT
?g_AccountSecurity@@3VCAccountSecurity@@A DB 014H DUP (?) ; g_AccountSecurity
_BSS	ENDS
CRT$XCU	SEGMENT
_g_AccountSecurity$initializer$ DD FLAT:??__Eg_AccountSecurity@@YAXXZ
CRT$XCU	ENDS
END
