; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\AntiCheatPlus.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??0BlockHDD_DATA@@QAE@XZ			; BlockHDD_DATA::BlockHDD_DATA
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\anticheatplus.h
;	COMDAT ??0BlockHDD_DATA@@QAE@XZ
_TEXT	SEGMENT
??0BlockHDD_DATA@@QAE@XZ PROC				; BlockHDD_DATA::BlockHDD_DATA, COMDAT
; _this$ = ecx

; 98   : 	BlockHDD_DATA()

  00000	8b c1		 mov	 eax, ecx

; 99   : 	{
; 100  : 		this->hddid = 0;

  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 101  : 	}

  00008	c3		 ret	 0
??0BlockHDD_DATA@@QAE@XZ ENDP				; BlockHDD_DATA::BlockHDD_DATA
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atol:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_dwTokenNumber DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	06a4H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript_zt.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -1704					; size = 1700
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 06 00
	00		 sub	 esp, 1704		; 000006a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 28   : 	char ch;
; 29   : 	char* p;
; 30   : 	char TempString[1700];
; 31   : 
; 32   : 	TokenString[0]=0;

  00013	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  0001a	53		 push	 ebx
  0001b	eb 03 8d 49 00	 npad	 5
$LL31@GetToken:

; 33   : 
; 34   : 	do
; 35   : 	{
; 36   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 39   : 		}
; 40   : 		else
; 41   : 		{	
; 42   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 43   : 			{
; 44   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 45   : 				{
; 46   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 47   : 					{
; 48   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 49   : 					}
; 50   : 	
; 51   : 					if (ch == -1)
; 52   : 					{
; 53   : 						return END;	// End of FILE
; 54   : 					}
; 55   : 				}
; 56   : 			}
; 57   : 		}
; 58   : 	}
; 59   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 60   : 
; 61   : 	
; 62   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 47 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 37   : 		{
; 38   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 63   : 	{
; 64   : 
; 65   : 	case 0x23:	// #
; 66   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 b5 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 67   : 		break;
; 68   : 	
; 69   : 	case 0x3B:	// ;
; 70   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 ab 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 71   : 		break;
; 72   : 	
; 73   : 	case 0x2C:	// ,
; 74   : 
; 75   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 a1 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 76   : 		break;
; 77   : 	
; 78   : 	case 0x7B:	// {
; 79   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 97 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 80   : 		break;
; 81   : 
; 82   : 	case 0x7D:	// }
; 83   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 8d 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 84   : 		break;
; 85   : 	// Nice Index Table :)	by Deathway
; 86   : 	// Numbers Case
; 87   : 	case 0x2D:	//-
; 88   : 	case 0x2E:	//.
; 89   : 	case '0':	//0
; 90   : 	case '1':	//1
; 91   : 	case '2':	//2
; 92   : 	case '3':	//3
; 93   : 	case '4':	//4		
; 94   : 	case '5':	//5
; 95   : 	case '6':	//6
; 96   : 	case '7':	//7
; 97   : 	case '8':	//8
; 98   : 	case '9':	//9
; 99   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 100  : 		p = TempString;
; 101  : 		
; 102  : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d b5 58 f9 ff
	ff		 lea	 esi, DWORD PTR _TempString$[ebp]
  000f8	e8 00 00 00 00	 call	 _getc
  000fd	8a d8		 mov	 bl, al
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	80 fb ff	 cmp	 bl, -1
  00105	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00107	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  0010a	74 15		 je	 SHORT $LN11@GetToken
  0010c	0f be cb	 movsx	 ecx, bl
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _isdigit
  00115	83 c4 04	 add	 esp, 4
  00118	85 c0		 test	 eax, eax
  0011a	75 05		 jne	 SHORT $LN11@GetToken
  0011c	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011f	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  00121	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 103  : 		{
; 104  : 			*p = ch;	// Construct a String

  00127	88 1e		 mov	 BYTE PTR [esi], bl
  00129	52		 push	 edx

; 105  : 			p++;

  0012a	46		 inc	 esi
  0012b	e8 00 00 00 00	 call	 _getc
  00130	8a d8		 mov	 bl, al
  00132	83 c4 04	 add	 esp, 4
  00135	80 fb ff	 cmp	 bl, -1
  00138	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 106  : 		}		
; 107  : 		*p = 0;
; 108  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  0013a	8d 85 58 f9 ff
	ff		 lea	 eax, DWORD PTR _TempString$[ebp]
  00140	50		 push	 eax
  00141	c6 06 00	 mov	 BYTE PTR [esi], 0
  00144	e8 00 00 00 00	 call	 _atof
  00149	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 109  : 		dwTokenNumber = (DWORD)atol(TempString);

  0014f	8d 8d 58 f9 ff
	ff		 lea	 ecx, DWORD PTR _TempString$[ebp]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _atol
  0015b	83 c4 08	 add	 esp, 8
  0015e	5e		 pop	 esi
  0015f	a3 00 00 00 00	 mov	 DWORD PTR _dwTokenNumber, eax

; 110  : 		return CurrentToken  = NUMBER ;

  00164	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	5b		 pop	 ebx

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  00174	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00177	33 cd		 xor	 ecx, ebp
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
$LN10@GetToken:

; 111  : 		break;
; 112  : 
; 113  : 	case '\"':	// "	String Case
; 114  : 		p=&TokenString[0];
; 115  : 
; 116  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  00188	52		 push	 edx
  00189	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  0018e	e8 00 00 00 00	 call	 _getc
  00193	83 c4 04	 add	 esp, 4
  00196	3c ff		 cmp	 al, -1
  00198	74 23		 je	 SHORT $LN8@GetToken
  0019a	8d 9b 00 00 00
	00		 npad	 6
$LL9@GetToken:
  001a0	3c 22		 cmp	 al, 34			; 00000022H
  001a2	0f 84 a0 00 00
	00		 je	 $LN7@GetToken

; 117  : 		{
; 118  : 			*p = ch;

  001a8	88 06		 mov	 BYTE PTR [esi], al
  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001af	50		 push	 eax

; 119  : 			p++;

  001b0	46		 inc	 esi
  001b1	e8 00 00 00 00	 call	 _getc
  001b6	83 c4 04	 add	 esp, 4
  001b9	3c ff		 cmp	 al, -1
  001bb	75 e3		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 120  : 		}
; 121  : 		if (ch != 0x22 )

  001bd	3c 22		 cmp	 al, 34			; 00000022H
  001bf	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 122  : 		{
; 123  : 			ungetc(ch, SMDFile);

  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001cb	0f be d0	 movsx	 edx, al
  001ce	51		 push	 ecx
  001cf	52		 push	 edx

; 124  : 		}
; 125  : 		*p = 0;
; 126  : 		return CurrentToken = NAME;

  001d0	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 127  : 		break;
; 128  : 
; 129  : 	default:	// Others
; 130  : 		if (isalpha(ch))

  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _isalpha
  001d8	83 c4 04	 add	 esp, 4
  001db	85 c0		 test	 eax, eax
  001dd	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 131  : 		{
; 132  : 			p=&TokenString[0];
; 133  : 			*p=ch;
; 134  : 			p++;
; 135  : 
; 136  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001e8	50		 push	 eax
  001e9	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001ef	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001f4	e8 00 00 00 00	 call	 _getc
  001f9	8a d8		 mov	 bl, al
  001fb	83 c4 04	 add	 esp, 4
  001fe	80 fb ff	 cmp	 bl, -1
  00201	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  00203	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00206	74 15		 je	 SHORT $LN2@GetToken
  00208	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  0020b	74 10		 je	 SHORT $LN2@GetToken
  0020d	0f be cb	 movsx	 ecx, bl
  00210	51		 push	 ecx
  00211	e8 00 00 00 00	 call	 _isalnum
  00216	83 c4 04	 add	 esp, 4
  00219	85 c0		 test	 eax, eax
  0021b	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  0021d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 137  : 			{
; 138  : 				*p=ch;

  00223	88 1e		 mov	 BYTE PTR [esi], bl
  00225	52		 push	 edx

; 139  : 				p++;

  00226	46		 inc	 esi
  00227	e8 00 00 00 00	 call	 _getc
  0022c	8a d8		 mov	 bl, al
  0022e	83 c4 04	 add	 esp, 4
  00231	80 fb ff	 cmp	 bl, -1
  00234	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 140  : 			}
; 141  : 
; 142  : 			ungetc(ch, SMDFile);

  00236	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0023b	0f be cb	 movsx	 ecx, bl
  0023e	50		 push	 eax
  0023f	51		 push	 ecx
$LN49@GetToken:
  00240	e8 00 00 00 00	 call	 _ungetc
  00245	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 143  : 			*p=0;

  00248	c6 06 00	 mov	 BYTE PTR [esi], 0
  0024b	5e		 pop	 esi

; 144  : 			CurrentToken=NAME;

  0024c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 145  : 			return CurrentToken;

  00256	33 c0		 xor	 eax, eax
  00258	5b		 pop	 ebx

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  00259	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025c	33 cd		 xor	 ecx, ebp
  0025e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
$LN5@GetToken:

; 146  : 		}
; 147  : 		else
; 148  : 		{
; 149  : 			return CurrentToken = SMD_ERROR; // '<'

  00267	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  0026c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026f	5e		 pop	 esi
  00270	33 cd		 xor	 ecx, ebp
  00272	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  00277	5b		 pop	 ebx
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c3		 ret	 0
  00281	8d 49 00	 npad	 3
$LN50@GetToken:
  00284	00 00 00 00	 DD	 $LN10@GetToken
  00288	00 00 00 00	 DD	 $LN19@GetToken
  0028c	00 00 00 00	 DD	 $LN17@GetToken
  00290	00 00 00 00	 DD	 $LN14@GetToken
  00294	00 00 00 00	 DD	 $LN18@GetToken
  00298	00 00 00 00	 DD	 $LN16@GetToken
  0029c	00 00 00 00	 DD	 $LN15@GetToken
  002a0	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  002a4	00		 DB	 0
  002a5	01		 DB	 1
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	02		 DB	 2
  002af	03		 DB	 3
  002b0	03		 DB	 3
  002b1	07		 DB	 7
  002b2	03		 DB	 3
  002b3	03		 DB	 3
  002b4	03		 DB	 3
  002b5	03		 DB	 3
  002b6	03		 DB	 3
  002b7	03		 DB	 3
  002b8	03		 DB	 3
  002b9	03		 DB	 3
  002ba	03		 DB	 3
  002bb	03		 DB	 3
  002bc	07		 DB	 7
  002bd	04		 DB	 4
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	07		 DB	 7
  002e7	07		 DB	 7
  002e8	07		 DB	 7
  002e9	07		 DB	 7
  002ea	07		 DB	 7
  002eb	07		 DB	 7
  002ec	07		 DB	 7
  002ed	07		 DB	 7
  002ee	07		 DB	 7
  002ef	07		 DB	 7
  002f0	07		 DB	 7
  002f1	07		 DB	 7
  002f2	07		 DB	 7
  002f3	07		 DB	 7
  002f4	07		 DB	 7
  002f5	07		 DB	 7
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	05		 DB	 5
  002fe	07		 DB	 7
  002ff	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0BC@HDGCIDDF@ScanItemDupeClean?$AA@	; `string'
PUBLIC	??_C@_0BH@DEDAJLBB@ScanItemDupeDisconnect?$AA@	; `string'
PUBLIC	??_C@_0BD@KCICPOKL@ScanItemDupeActive?$AA@	; `string'
PUBLIC	??_C@_0M@EABIGHCH@ProcessTime?$AA@		; `string'
PUBLIC	??_C@_0L@FOMAPHOD@InjectTime?$AA@		; `string'
PUBLIC	??_C@_09EMOAFKHF@ClassTime?$AA@			; `string'
PUBLIC	??_C@_09LDEHLHEF@TitleTime?$AA@			; `string'
PUBLIC	??_C@_08EMEDBAFJ@DumpTime?$AA@			; `string'
PUBLIC	??_C@_09DLKGEHKE@MaxWindow?$AA@			; `string'
PUBLIC	??_C@_0BA@LMFLAIEE@EnableMaxWindow?$AA@		; `string'
PUBLIC	??_C@_0N@MKAHFHFF@MultiWindows?$AA@		; `string'
PUBLIC	??_C@_0M@EJIIM@EliteActive?$AA@			; `string'
PUBLIC	??_C@_0O@PCLOFHMC@ProcessActive?$AA@		; `string'
PUBLIC	??_C@_0N@KNCHMIBE@InjectActive?$AA@		; `string'
PUBLIC	??_C@_0M@CCFLCIPN@ClassActive?$AA@		; `string'
PUBLIC	??_C@_0M@CDKGHPGM@TitleActive?$AA@		; `string'
PUBLIC	??_C@_0L@INGDOLHO@DumpActive?$AA@		; `string'
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	?ReadConfig@AntiCheatPlus@@QAEXPAD@Z		; AntiCheatPlus::ReadConfig
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
;	COMDAT ??_C@_0BC@HDGCIDDF@ScanItemDupeClean?$AA@
; File e:\work\tranet_version\gs\gameserver\anticheatplus.cpp
CONST	SEGMENT
??_C@_0BC@HDGCIDDF@ScanItemDupeClean?$AA@ DB 'ScanItemDupeClean', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DEDAJLBB@ScanItemDupeDisconnect?$AA@
CONST	SEGMENT
??_C@_0BH@DEDAJLBB@ScanItemDupeDisconnect?$AA@ DB 'ScanItemDupeDisconnect'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCICPOKL@ScanItemDupeActive?$AA@
CONST	SEGMENT
??_C@_0BD@KCICPOKL@ScanItemDupeActive?$AA@ DB 'ScanItemDupeActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EABIGHCH@ProcessTime?$AA@
CONST	SEGMENT
??_C@_0M@EABIGHCH@ProcessTime?$AA@ DB 'ProcessTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FOMAPHOD@InjectTime?$AA@
CONST	SEGMENT
??_C@_0L@FOMAPHOD@InjectTime?$AA@ DB 'InjectTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMOAFKHF@ClassTime?$AA@
CONST	SEGMENT
??_C@_09EMOAFKHF@ClassTime?$AA@ DB 'ClassTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDEHLHEF@TitleTime?$AA@
CONST	SEGMENT
??_C@_09LDEHLHEF@TitleTime?$AA@ DB 'TitleTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMEDBAFJ@DumpTime?$AA@
CONST	SEGMENT
??_C@_08EMEDBAFJ@DumpTime?$AA@ DB 'DumpTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DLKGEHKE@MaxWindow?$AA@
CONST	SEGMENT
??_C@_09DLKGEHKE@MaxWindow?$AA@ DB 'MaxWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LMFLAIEE@EnableMaxWindow?$AA@
CONST	SEGMENT
??_C@_0BA@LMFLAIEE@EnableMaxWindow?$AA@ DB 'EnableMaxWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MKAHFHFF@MultiWindows?$AA@
CONST	SEGMENT
??_C@_0N@MKAHFHFF@MultiWindows?$AA@ DB 'MultiWindows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJIIM@EliteActive?$AA@
CONST	SEGMENT
??_C@_0M@EJIIM@EliteActive?$AA@ DB 'EliteActive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PCLOFHMC@ProcessActive?$AA@
CONST	SEGMENT
??_C@_0O@PCLOFHMC@ProcessActive?$AA@ DB 'ProcessActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNCHMIBE@InjectActive?$AA@
CONST	SEGMENT
??_C@_0N@KNCHMIBE@InjectActive?$AA@ DB 'InjectActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CCFLCIPN@ClassActive?$AA@
CONST	SEGMENT
??_C@_0M@CCFLCIPN@ClassActive?$AA@ DB 'ClassActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CDKGHPGM@TitleActive?$AA@
CONST	SEGMENT
??_C@_0M@CDKGHPGM@TitleActive?$AA@ DB 'TitleActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INGDOLHO@DumpActive?$AA@
CONST	SEGMENT
??_C@_0L@INGDOLHO@DumpActive?$AA@ DB 'DumpActive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReadConfig@AntiCheatPlus@@QAEXPAD@Z
_TEXT	SEGMENT
_File$ = 8						; size = 4
?ReadConfig@AntiCheatPlus@@QAEXPAD@Z PROC		; AntiCheatPlus::ReadConfig, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 84   : 	this->Enable = GetPrivateProfileInt("ZtTeam", "Enable", 0, File);

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetPrivateProfileIntA@16
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _File$[ebp]
  0000f	57		 push	 edi
  00010	6a 00		 push	 0
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0001c	8b f1		 mov	 esi, ecx
  0001e	ff d3		 call	 ebx

; 85   : 
; 86   : 	this->DumpActive = GetPrivateProfileInt("ZtTeam", "DumpActive", 0, File);

  00020	57		 push	 edi
  00021	6a 00		 push	 0
  00023	85 c0		 test	 eax, eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0L@INGDOLHO@DumpActive?$AA@
  0002a	0f 95 c0	 setne	 al
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00032	88 06		 mov	 BYTE PTR [esi], al
  00034	ff d3		 call	 ebx

; 87   : 	this->TitleActive = GetPrivateProfileInt("ZtTeam", "TitleActive", 0, File);

  00036	57		 push	 edi
  00037	6a 00		 push	 0
  00039	85 c0		 test	 eax, eax
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CDKGHPGM@TitleActive?$AA@
  00040	0f 95 c1	 setne	 cl
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00048	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  0004b	ff d3		 call	 ebx

; 88   : 	this->ClassActive = GetPrivateProfileInt("ZtTeam", "ClassActive", 0, File);

  0004d	57		 push	 edi
  0004e	6a 00		 push	 0
  00050	85 c0		 test	 eax, eax
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CCFLCIPN@ClassActive?$AA@
  00057	0f 95 c2	 setne	 dl
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0005f	88 56 02	 mov	 BYTE PTR [esi+2], dl
  00062	ff d3		 call	 ebx

; 89   : 	this->InjectActive = GetPrivateProfileInt("ZtTeam", "InjectActive", 0, File);

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	85 c0		 test	 eax, eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KNCHMIBE@InjectActive?$AA@
  0006e	0f 95 c0	 setne	 al
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00076	88 46 03	 mov	 BYTE PTR [esi+3], al
  00079	ff d3		 call	 ebx

; 90   : 	this->ProcessActive = GetPrivateProfileInt("ZtTeam", "ProcessActive", 0, File);

  0007b	57		 push	 edi
  0007c	6a 00		 push	 0
  0007e	85 c0		 test	 eax, eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PCLOFHMC@ProcessActive?$AA@
  00085	0f 95 c1	 setne	 cl
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0008d	88 4e 04	 mov	 BYTE PTR [esi+4], cl
  00090	ff d3		 call	 ebx

; 91   : 	this->EliteActive  = GetPrivateProfileInt("ZtTeam", "EliteActive", 0, File);

  00092	57		 push	 edi
  00093	6a 00		 push	 0
  00095	85 c0		 test	 eax, eax
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EJIIM@EliteActive?$AA@
  0009c	0f 95 c2	 setne	 dl
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  000a4	88 56 05	 mov	 BYTE PTR [esi+5], dl
  000a7	ff d3		 call	 ebx

; 92   : 	this->MultiWindows = GetPrivateProfileInt("ZtTeam", "MultiWindows", 1, File);

  000a9	57		 push	 edi
  000aa	6a 01		 push	 1
  000ac	85 c0		 test	 eax, eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MKAHFHFF@MultiWindows?$AA@
  000b3	0f 95 c0	 setne	 al
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  000bb	88 46 06	 mov	 BYTE PTR [esi+6], al
  000be	ff d3		 call	 ebx

; 93   : 
; 94   : 	this->m_EnableMaxWindow = GetPrivateProfileInt("ZtTeam", "EnableMaxWindow", 0, File);

  000c0	57		 push	 edi
  000c1	6a 00		 push	 0
  000c3	85 c0		 test	 eax, eax
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LMFLAIEE@EnableMaxWindow?$AA@
  000ca	0f 95 c1	 setne	 cl
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  000d2	88 4e 07	 mov	 BYTE PTR [esi+7], cl
  000d5	ff d3		 call	 ebx

; 95   : 	this->m_MaxWindow = GetPrivateProfileInt("ZtTeam", "MaxWindow", 100, File);

  000d7	57		 push	 edi
  000d8	6a 64		 push	 100			; 00000064H
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_09DLKGEHKE@MaxWindow?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  000e4	89 86 28 00 01
	00		 mov	 DWORD PTR [esi+65576], eax
  000ea	ff d3		 call	 ebx

; 96   : 	#if(ANTI_CHEAT_PLUS_CRC)
; 97   : 	this->CRCActive = GetPrivateProfileInt("ZtTeam", "CheckFileActive", 0, File);
; 98   : 	#endif
; 99   : 	this->DumpTime = GetPrivateProfileInt("ZtTeam", "DumpTime", 10000, File);

  000ec	57		 push	 edi
  000ed	68 10 27 00 00	 push	 10000			; 00002710H
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_08EMEDBAFJ@DumpTime?$AA@
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  000fc	89 86 2c 00 01
	00		 mov	 DWORD PTR [esi+65580], eax
  00102	ff d3		 call	 ebx

; 100  : 	this->TitleTime = GetPrivateProfileInt("ZtTeam", "TitleTime", 10000, File);

  00104	57		 push	 edi
  00105	68 10 27 00 00	 push	 10000			; 00002710H
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_09LDEHLHEF@TitleTime?$AA@
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00114	66 89 46 0c	 mov	 WORD PTR [esi+12], ax
  00118	ff d3		 call	 ebx

; 101  : 	this->ClassTime = GetPrivateProfileInt("ZtTeam", "ClassTime", 10000, File);

  0011a	57		 push	 edi
  0011b	68 10 27 00 00	 push	 10000			; 00002710H
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_09EMOAFKHF@ClassTime?$AA@
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0012a	66 89 46 0e	 mov	 WORD PTR [esi+14], ax
  0012e	ff d3		 call	 ebx

; 102  : 	this->InjectTime = GetPrivateProfileInt("ZtTeam", "InjectTime", 10000, File);

  00130	57		 push	 edi
  00131	68 10 27 00 00	 push	 10000			; 00002710H
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FOMAPHOD@InjectTime?$AA@
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00140	66 89 46 10	 mov	 WORD PTR [esi+16], ax
  00144	ff d3		 call	 ebx

; 103  : 	this->ProcessTime = GetPrivateProfileInt("ZtTeam", "ProcessTime", 10000, File);

  00146	57		 push	 edi
  00147	68 10 27 00 00	 push	 10000			; 00002710H
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EABIGHCH@ProcessTime?$AA@
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00156	66 89 46 12	 mov	 WORD PTR [esi+18], ax
  0015a	ff d3		 call	 ebx

; 104  : 	#if(SCANER_ITEM_DUPE)
; 105  : 	this->ScanItemDupeActive = GetPrivateProfileInt("ZtTeam", "ScanItemDupeActive", 0, File);

  0015c	57		 push	 edi
  0015d	6a 00		 push	 0
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KCICPOKL@ScanItemDupeActive?$AA@
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00169	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  0016d	ff d3		 call	 ebx

; 106  : 	this->ScanItemDupeDisconnect = GetPrivateProfileInt("ZtTeam", "ScanItemDupeDisconnect", 0, File);

  0016f	57		 push	 edi
  00170	6a 00		 push	 0
  00172	85 c0		 test	 eax, eax
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DEDAJLBB@ScanItemDupeDisconnect?$AA@
  00179	0f 95 c2	 setne	 dl
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00181	88 56 08	 mov	 BYTE PTR [esi+8], dl
  00184	ff d3		 call	 ebx

; 107  : 	this->ScanItemDupeClean = GetPrivateProfileInt("ZtTeam", "ScanItemDupeClean", 0, File);

  00186	57		 push	 edi
  00187	6a 00		 push	 0
  00189	85 c0		 test	 eax, eax
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HDGCIDDF@ScanItemDupeClean?$AA@
  00190	0f 95 c0	 setne	 al
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00198	88 46 09	 mov	 BYTE PTR [esi+9], al
  0019b	ff d3		 call	 ebx
  0019d	85 c0		 test	 eax, eax
  0019f	0f 95 c1	 setne	 cl
  001a2	5f		 pop	 edi
  001a3	88 4e 0a	 mov	 BYTE PTR [esi+10], cl
  001a6	5e		 pop	 esi
  001a7	5b		 pop	 ebx

; 108  : 	#endif
; 109  : }

  001a8	5d		 pop	 ebp
  001a9	c2 04 00	 ret	 4
?ReadConfig@AntiCheatPlus@@QAEXPAD@Z ENDP		; AntiCheatPlus::ReadConfig
_TEXT	ENDS
PUBLIC	??_C@_0CC@PDLFHDKE@?$FLAnti?9Cheat?$FN?5?$FLProcess?$FN?5Loaded?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CF@IFBIOADN@?$FLAnti?9Cheat?$FN?5?$FLInject?5Dll?$FN?5Loaded@ ; `string'
PUBLIC	??_C@_0CH@IEOLOGBE@?$FLAnti?9Cheat?$FN?5?$FLClass?5Window?$FN?5Load@ ; `string'
PUBLIC	??_C@_0CH@KIGGEOIK@?$FLAnti?9Cheat?$FN?5?$FLTitle?5Window?$FN?5Load@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Read@AntiCheatPlus@@QAEXHPAD@Z			; AntiCheatPlus::Read
EXTRN	_fclose:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0CC@PDLFHDKE@?$FLAnti?9Cheat?$FN?5?$FLProcess?$FN?5Loaded?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@PDLFHDKE@?$FLAnti?9Cheat?$FN?5?$FLProcess?$FN?5Loaded?3?5?$CF@ DB '['
	DB	'Anti-Cheat] [Process] Loaded: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IFBIOADN@?$FLAnti?9Cheat?$FN?5?$FLInject?5Dll?$FN?5Loaded@
CONST	SEGMENT
??_C@_0CF@IFBIOADN@?$FLAnti?9Cheat?$FN?5?$FLInject?5Dll?$FN?5Loaded@ DB '['
	DB	'Anti-Cheat] [Inject Dll] Loaded: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IEOLOGBE@?$FLAnti?9Cheat?$FN?5?$FLClass?5Window?$FN?5Load@
CONST	SEGMENT
??_C@_0CH@IEOLOGBE@?$FLAnti?9Cheat?$FN?5?$FLClass?5Window?$FN?5Load@ DB '['
	DB	'Anti-Cheat] [Class Window] Loaded: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KIGGEOIK@?$FLAnti?9Cheat?$FN?5?$FLTitle?5Window?$FN?5Load@
CONST	SEGMENT
??_C@_0CH@KIGGEOIK@?$FLAnti?9Cheat?$FN?5?$FLTitle?5Window?$FN?5Load@ DB '['
	DB	'Anti-Cheat] [Title Window] Loaded: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Read@AntiCheatPlus@@QAEXHPAD@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_File$ = 12						; size = 4
?Read@AntiCheatPlus@@QAEXHPAD@Z PROC			; AntiCheatPlus::Read, COMDAT
; _this$ = ecx

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  : 	SMDFile = fopen(File, "r");

  00003	8b 45 0c	 mov	 eax, DWORD PTR _File$[ebp]
  00006	53		 push	 ebx
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0000c	50		 push	 eax
  0000d	8b d9		 mov	 ebx, ecx
  0000f	e8 00 00 00 00	 call	 _fopen
  00014	83 c4 08	 add	 esp, 8
  00017	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 115  : 	if( SMDFile == NULL )

  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 97 01 00
	00		 je	 $LN18@Read

; 116  : 	{
; 117  : 		return;
; 118  : 	}
; 119  : 	while(true)
; 120  : 	{
; 121  : 		SMDToken Token = GetToken();

  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 122  : 		if( Token == END || !strcmp(TokenString, "end") )

  0002b	83 f8 02	 cmp	 eax, 2
  0002e	0f 84 17 01 00
	00		 je	 $LN21@Read
$LL16@Read:
  00034	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00039	b8 00 00 00 00	 mov	 eax, OFFSET _TokenString
  0003e	8b ff		 npad	 2
$LL30@Read:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00044	75 1a		 jne	 SHORT $LN31@Read
  00046	84 c9		 test	 cl, cl
  00048	74 12		 je	 SHORT $LN35@Read
  0004a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0004d	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00050	75 0e		 jne	 SHORT $LN31@Read
  00052	83 c0 02	 add	 eax, 2
  00055	83 c6 02	 add	 esi, 2
  00058	84 c9		 test	 cl, cl
  0005a	75 e4		 jne	 SHORT $LL30@Read
$LN35@Read:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN33@Read
$LN31@Read:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
$LN33@Read:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 de 00 00
	00		 je	 $LN21@Read

; 123  : 		{
; 124  : 			break;
; 125  : 		}
; 126  : 		if(type==eTitleType)

  0006d	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00070	85 c0		 test	 eax, eax
  00072	75 2f		 jne	 SHORT $LN12@Read

; 127  : 		{
; 128  : 			if(this->TitleCount >= MAX_AH_DB)

  00074	8b 83 18 00 01
	00		 mov	 eax, DWORD PTR [ebx+65560]
  0007a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0007f	0f 8d cd 00 00
	00		 jge	 $LN26@Read

; 129  : 			{
; 130  : 				break;
; 131  : 			}
; 132  : 			memcpy(this->TitleName[this->TitleCount],TokenString,sizeof(this->TitleName[this->ClassCount]));

  00085	c1 e0 06	 shl	 eax, 6
  00088	8d 7c 18 16	 lea	 edi, DWORD PTR [eax+ebx+22]
  0008c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00091	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00096	f3 a5		 rep movsd

; 133  : 			this->TitleCount++;

  00098	ff 83 18 00 01
	00		 inc	 DWORD PTR [ebx+65560]

; 134  : 		}
; 135  : 		if(type==eClassType)

  0009e	e9 9a 00 00 00	 jmp	 $LN6@Read
$LN12@Read:
  000a3	ba 01 00 00 00	 mov	 edx, 1
  000a8	3b c2		 cmp	 eax, edx
  000aa	75 2f		 jne	 SHORT $LN10@Read

; 136  : 		{
; 137  : 			if(this->ClassCount >= MAX_AH_DB)

  000ac	8b 83 1c 00 01
	00		 mov	 eax, DWORD PTR [ebx+65564]
  000b2	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  000b7	0f 8d a8 00 00
	00		 jge	 $LN27@Read

; 138  : 			{
; 139  : 				break;
; 140  : 			}
; 141  : 			memcpy(this->ClassName[this->ClassCount],TokenString,sizeof(this->ClassName[this->ClassCount]));

  000bd	c1 e0 06	 shl	 eax, 6
  000c0	8d bc 18 16 40
	00 00		 lea	 edi, DWORD PTR [eax+ebx+16406]
  000c7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000cc	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  000d1	f3 a5		 rep movsd

; 142  : 			this->ClassCount++;

  000d3	01 93 1c 00 01
	00		 add	 DWORD PTR [ebx+65564], edx

; 143  : 		}
; 144  : 		if(type==eInjectType)

  000d9	eb 62		 jmp	 SHORT $LN6@Read
$LN10@Read:
  000db	83 f8 02	 cmp	 eax, 2
  000de	75 2f		 jne	 SHORT $LN8@Read

; 145  : 		{
; 146  : 			if(this->InjectCount >= MAX_AH_DB)

  000e0	8b 83 20 00 01
	00		 mov	 eax, DWORD PTR [ebx+65568]
  000e6	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  000eb	0f 8d 87 00 00
	00		 jge	 $LN28@Read

; 147  : 			{
; 148  : 				break;
; 149  : 			}
; 150  : 			memcpy(this->InjectName[this->InjectCount],TokenString,sizeof(this->InjectName[this->InjectCount]));

  000f1	c1 e0 06	 shl	 eax, 6
  000f4	8d bc 18 16 80
	00 00		 lea	 edi, DWORD PTR [eax+ebx+32790]
  000fb	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00100	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00105	f3 a5		 rep movsd

; 151  : 			this->InjectCount++;

  00107	01 93 20 00 01
	00		 add	 DWORD PTR [ebx+65568], edx

; 152  : 		}
; 153  : 		if(type==eProcessType)

  0010d	eb 2e		 jmp	 SHORT $LN6@Read
$LN8@Read:
  0010f	83 f8 03	 cmp	 eax, 3
  00112	75 29		 jne	 SHORT $LN6@Read

; 154  : 		{
; 155  : 			if(this->ProcessCount >= MAX_AH_DB)

  00114	8b 83 24 00 01
	00		 mov	 eax, DWORD PTR [ebx+65572]
  0011a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0011f	7d 6a		 jge	 SHORT $LN29@Read

; 156  : 			{
; 157  : 				break;
; 158  : 			}
; 159  : 			memcpy(this->ProcessName[this->ProcessCount],TokenString,sizeof(this->ProcessName[this->ProcessCount]));

  00121	c1 e0 06	 shl	 eax, 6
  00124	8d bc 18 16 c0
	00 00		 lea	 edi, DWORD PTR [eax+ebx+49174]
  0012b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00130	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00135	f3 a5		 rep movsd

; 160  : 			this->ProcessCount++;

  00137	ff 83 24 00 01
	00		 inc	 DWORD PTR [ebx+65572]
$LN6@Read:

; 122  : 		if( Token == END || !strcmp(TokenString, "end") )

  0013d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00142	83 f8 02	 cmp	 eax, 2
  00145	0f 85 e9 fe ff
	ff		 jne	 $LL16@Read
$LN21@Read:

; 161  : 		}
; 162  : 	}
; 163  : 
; 164  : 	if(type==eTitleType)

  0014b	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0014e	85 c0		 test	 eax, eax
  00150	75 0e		 jne	 SHORT $LN4@Read
$LN26@Read:

; 165  : 	{
; 166  : 		LogAdd("[Anti-Cheat] [Title Window] Loaded: %d", this->TitleCount);

  00152	8b 8b 18 00 01
	00		 mov	 ecx, DWORD PTR [ebx+65560]
  00158	51		 push	 ecx
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@KIGGEOIK@?$FLAnti?9Cheat?$FN?5?$FLTitle?5Window?$FN?5Load@

; 167  : 	}
; 168  : 	if(type==eClassType)

  0015e	eb 37		 jmp	 SHORT $LN36@Read
$LN4@Read:
  00160	83 f8 01	 cmp	 eax, 1
  00163	75 0e		 jne	 SHORT $LN3@Read
$LN27@Read:

; 169  : 	{
; 170  : 		LogAdd("[Anti-Cheat] [Class Window] Loaded: %d", this->ClassCount);

  00165	8b 93 1c 00 01
	00		 mov	 edx, DWORD PTR [ebx+65564]
  0016b	52		 push	 edx
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@IEOLOGBE@?$FLAnti?9Cheat?$FN?5?$FLClass?5Window?$FN?5Load@

; 171  : 	}
; 172  : 	if(type==eInjectType)

  00171	eb 24		 jmp	 SHORT $LN36@Read
$LN3@Read:
  00173	83 f8 02	 cmp	 eax, 2
  00176	75 0e		 jne	 SHORT $LN2@Read
$LN28@Read:

; 173  : 	{
; 174  : 		LogAdd("[Anti-Cheat] [Inject Dll] Loaded: %d", this->InjectCount);

  00178	8b 83 20 00 01
	00		 mov	 eax, DWORD PTR [ebx+65568]
  0017e	50		 push	 eax
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IFBIOADN@?$FLAnti?9Cheat?$FN?5?$FLInject?5Dll?$FN?5Loaded@

; 175  : 	}
; 176  : 	if(type==eProcessType)

  00184	eb 11		 jmp	 SHORT $LN36@Read
$LN2@Read:
  00186	83 f8 03	 cmp	 eax, 3
  00189	75 15		 jne	 SHORT $LN1@Read
$LN29@Read:

; 177  : 	{
; 178  : 		LogAdd("[Anti-Cheat] [Process] Loaded: %d", this->ProcessCount);

  0018b	8b 8b 24 00 01
	00		 mov	 ecx, DWORD PTR [ebx+65572]
  00191	51		 push	 ecx
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PDLFHDKE@?$FLAnti?9Cheat?$FN?5?$FLProcess?$FN?5Loaded?3?5?$CF@
$LN36@Read:
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0019d	83 c4 08	 add	 esp, 8
$LN1@Read:

; 179  : 	}
; 180  : 
; 181  : 	fclose(SMDFile);

  001a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _fclose
  001ac	83 c4 04	 add	 esp, 4
  001af	5f		 pop	 edi

; 182  : 	SMDFile = NULL;

  001b0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SMDFile, 0
  001ba	5e		 pop	 esi
$LN18@Read:
  001bb	5b		 pop	 ebx

; 183  : }

  001bc	5d		 pop	 ebp
  001bd	c2 08 00	 ret	 8
?Read@AntiCheatPlus@@QAEXHPAD@Z ENDP			; AntiCheatPlus::Read
_TEXT	ENDS
PUBLIC	??_C@_0BE@PNIPEAML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@ ; `string'
PUBLIC	??_C@_0BO@HKOELEB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5?$CFs?$AA@ ; `string'
PUBLIC	?CG_Cheater@AntiCheatPlus@@QAEXPAUPMST_CheaterUser@@H@Z ; AntiCheatPlus::CG_Cheater
EXTRN	?SendClose@ConnectZt@@QAEXHH@Z:PROC		; ConnectZt::SendClose
EXTRN	?g_ConnectZt@@3VConnectZt@@A:QWORD		; g_ConnectZt
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BE@PNIPEAML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@PNIPEAML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?5?$CFs?$AA@ DB '['
	DB	'%s][%s][%s][%d] %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
CONST	SEGMENT
??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@ DB '..:: Anti-Che'
	DB	'at ::..', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HKOELEB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BO@HKOELEB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5?$CFs?$AA@ DB '['
	DB	'%s][%s] ip[%s] hdd[%d] -> %s', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CG_Cheater@AntiCheatPlus@@QAEXPAUPMST_CheaterUser@@H@Z
_TEXT	SEGMENT
tv174 = -4						; size = 4
tv173 = 8						; size = 4
_aRecv$ = 8						; size = 4
_UserIndex$ = 12					; size = 4
?CG_Cheater@AntiCheatPlus@@QAEXPAUPMST_CheaterUser@@H@Z PROC ; AntiCheatPlus::CG_Cheater, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 316  : 	if (UserIndex < 0 || UserIndex > OBJMAX-1 )

  00005	8b 75 0c	 mov	 esi, DWORD PTR _UserIndex$[ebp]
  00008	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0000e	0f 87 90 00 00
	00		 ja	 $LN2@CG_Cheater

; 317  : 	{
; 318  : 		return;
; 319  : 	}
; 320  : 
; 321  : 	LPOBJ lpUser = &gObj[UserIndex];

  00014	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	57		 push	 edi

; 322  : 
; 323  : 	if(aRecv->Result)

  00021	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]
  00024	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00028	74 79		 je	 SHORT $LN6@CG_Cheater

; 324  : 	{
; 325  : 		g_AntiCheatLog.Output("[%s][%s] ip[%s] hdd[%d] -> %s", lpUser->AccountID, lpUser->Name, lpUser->Ip_addr, lpUser->hdd_id, aRecv->CheatText);

  0002a	8b 96 8c 28 00
	00		 mov	 edx, DWORD PTR [esi+10380]
  00030	53		 push	 ebx
  00031	83 c7 05	 add	 edi, 5
  00034	57		 push	 edi
  00035	52		 push	 edx
  00036	8d 5e 18	 lea	 ebx, DWORD PTR [esi+24]
  00039	53		 push	 ebx
  0003a	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0003d	50		 push	 eax
  0003e	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00041	51		 push	 ecx
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HKOELEB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5?$CFs?$AA@
  00047	68 00 00 00 00	 push	 OFFSET ?g_AntiCheatLog@@3VCLogToFile@@A ; g_AntiCheatLog
  0004c	89 45 08	 mov	 DWORD PTR tv173[ebp], eax
  0004f	89 4d fc	 mov	 DWORD PTR tv174[ebp], ecx
  00052	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 326  : 		GCServerMsgStringSend("..:: Anti-Cheat ::..", lpUser->m_Index, 0);

  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	6a 00		 push	 0
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
  00061	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 327  : 		GCServerMsgStringSend(aRecv->CheatText, lpUser->m_Index, 0);

  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	6a 00		 push	 0
  0006a	51		 push	 ecx
  0006b	57		 push	 edi
  0006c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 328  : 		LogAddC(2,"[%s][%s][%s][%d] %s", lpUser->AccountID, lpUser->Name, lpUser->Ip_addr, lpUser->hdd_id, aRecv->CheatText);

  00071	8b 96 8c 28 00
	00		 mov	 edx, DWORD PTR [esi+10380]
  00077	8b 45 08	 mov	 eax, DWORD PTR tv173[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR tv174[ebp]
  0007d	57		 push	 edi
  0007e	52		 push	 edx
  0007f	53		 push	 ebx
  00080	50		 push	 eax
  00081	51		 push	 ecx
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PNIPEAML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?5?$CFs?$AA@
  00087	6a 02		 push	 2
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 329  : #ifdef _RECONNECT_				
; 330  : 		g_ConnectZt.SendClose(UserIndex,NORM_DC);

  0008f	8b 55 0c	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  00092	83 c4 50	 add	 esp, 80			; 00000050H
  00095	6a 00		 push	 0
  00097	52		 push	 edx
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  0009d	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
  000a2	5b		 pop	 ebx
$LN6@CG_Cheater:
  000a3	5f		 pop	 edi
$LN2@CG_Cheater:
  000a4	5e		 pop	 esi

; 331  : #else
; 332  : 		CloseClient(UserIndex);
; 333  : #endif
; 334  : 	}
; 335  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
?CG_Cheater@AntiCheatPlus@@QAEXPAUPMST_CheaterUser@@H@Z ENDP ; AntiCheatPlus::CG_Cheater
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GC_Config@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::GC_Config
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?GC_Config@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?GC_Config@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Config, COMDAT
; _this$ = ecx

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b c1		 mov	 eax, ecx

; 379  : 	PMSG_AH_CONFIG pMsg;
; 380  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xFF, sizeof(pMsg));
; 381  : 	pMsg.type = eAH_Config;
; 382  : 
; 383  : 	pMsg.DumpActive = this->DumpActive;

  00012	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]

; 384  : 	pMsg.TitleActive = this->TitleActive;

  00016	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  0001a	88 4d e9	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 385  : 	pMsg.ClassActive = this->ClassActive;

  0001d	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00021	88 55 ea	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 386  : 	pMsg.InjectActive = this->InjectActive;

  00024	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00028	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 387  : 	pMsg.ProcessActive = this->ProcessActive;

  0002b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0002f	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+8], dl

; 388  : 	pMsg.EliteActive = this->EliteActive;

  00032	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00036	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 389  : 	pMsg.MultiWindows = this->MultiWindows;

  00039	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0003d	88 55 ee	 mov	 BYTE PTR _pMsg$[ebp+10], dl

; 390  : 
; 391  : 	pMsg.DumpTime = this->DumpTime;

  00040	0f b7 50 0c	 movzx	 edx, WORD PTR [eax+12]
  00044	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 392  : 	pMsg.TitleTime = this->TitleTime;

  00047	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0004b	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+12], dx

; 393  : 	pMsg.ClassTime = this->ClassTime;

  0004f	0f b7 50 10	 movzx	 edx, WORD PTR [eax+16]
  00053	66 89 4d f2	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 394  : 	pMsg.InjectTime = this->InjectTime;

  00057	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0005b	66 89 55 f4	 mov	 WORD PTR _pMsg$[ebp+16], dx

; 395  : 	pMsg.ProcessTime = this->ProcessTime;

  0005f	0f b7 50 14	 movzx	 edx, WORD PTR [eax+20]

; 396  : 
; 397  : 	DataSend(UserIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00063	6a 16		 push	 22			; 00000016H
  00065	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00068	66 89 4d f6	 mov	 WORD PTR _pMsg$[ebp+18], cx
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	c7 45 e4 c1 16
	fb ff		 mov	 DWORD PTR _pMsg$[ebp], -321855 ; fffb16c1H
  00078	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0007c	66 89 55 f8	 mov	 WORD PTR _pMsg$[ebp+20], dx
  00080	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 398  : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
?GC_Config@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Config
_TEXT	ENDS
PUBLIC	?GC_Init@AntiCheatPlus@@QAEXH@Z			; AntiCheatPlus::GC_Init
; Function compile flags: /Ogtp
;	COMDAT ?GC_Init@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_UserIndex$ = 8						; size = 4
?GC_Init@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Init, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 403  : 	PMSG_AH_SUB pMsg;
; 404  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xFF, sizeof(pMsg));
; 405  : 	pMsg.type = eAH_Init;
; 406  : 	DataSend(UserIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00009	6a 05		 push	 5
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	c7 45 f8 c1 05
	fb ff		 mov	 DWORD PTR _pMsg$[ebp], -326207 ; fffb05c1H
  00017	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  0001b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 407  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GC_Init@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Init
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GC_Title@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::GC_Title
; Function compile flags: /Ogtp
;	COMDAT ?GC_Title@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -84					; size = 4
tv166 = -80						; size = 4
_pMsg$209987 = -76					; size = 69
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?GC_Title@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Title, COMDAT
; _this$ = ecx

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b c1		 mov	 eax, ecx

; 412  : 	for(int i = 0; i < this->TitleCount; i++)

  00013	33 db		 xor	 ebx, ebx

; 413  : 	{
; 414  : 		PMSG_CheatBase pMsg;
; 415  : 		pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xFF, sizeof(pMsg));

  00015	89 45 ac	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  00018	39 98 18 00 01
	00		 cmp	 DWORD PTR [eax+65560], ebx
  0001e	7e 4c		 jle	 SHORT $LN1@GC_Title

; 416  : 		pMsg.type = eAH_Title;
; 417  : 		memcpy(pMsg.Name,this->TitleName[i],sizeof(pMsg.Name));

  00020	83 c0 16	 add	 eax, 22			; 00000016H
  00023	56		 push	 esi
  00024	89 45 b0	 mov	 DWORD PTR tv166[ebp], eax
  00027	57		 push	 edi
  00028	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL10@GC_Title:
  00030	8b 75 b0	 mov	 esi, DWORD PTR tv166[ebp]
  00033	c7 45 b4 c1 45
	fb ff		 mov	 DWORD PTR _pMsg$209987[ebp], -309823 ; fffb45c1H
  0003a	c6 45 b8 02	 mov	 BYTE PTR _pMsg$209987[ebp+4], 2
  0003e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00043	8d 7d b9	 lea	 edi, DWORD PTR _pMsg$209987[ebp+5]

; 418  : 		DataSend(UserIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00046	6a 45		 push	 69			; 00000045H
  00048	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$209987[ebp]
  0004b	f3 a5		 rep movsd
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00057	8b 55 ac	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  0005a	83 45 b0 40	 add	 DWORD PTR tv166[ebp], 64 ; 00000040H
  0005e	43		 inc	 ebx
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	3b 9a 18 00 01
	00		 cmp	 ebx, DWORD PTR [edx+65560]
  00068	7c c6		 jl	 SHORT $LL10@GC_Title
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
$LN1@GC_Title:

; 419  : 	}
; 420  : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	5b		 pop	 ebx
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?GC_Title@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Title
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GC_Class@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::GC_Class
; Function compile flags: /Ogtp
;	COMDAT ?GC_Class@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -84					; size = 4
tv166 = -80						; size = 4
_pMsg$209998 = -76					; size = 69
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?GC_Class@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Class, COMDAT
; _this$ = ecx

; 424  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b c1		 mov	 eax, ecx

; 425  : 	for(int i = 0; i < this->ClassCount; i++)

  00013	33 db		 xor	 ebx, ebx

; 426  : 	{
; 427  : 		PMSG_CheatBase pMsg;
; 428  : 		pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xFF, sizeof(pMsg));

  00015	89 45 ac	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  00018	39 98 1c 00 01
	00		 cmp	 DWORD PTR [eax+65564], ebx
  0001e	7e 4c		 jle	 SHORT $LN1@GC_Class

; 429  : 		pMsg.type = eAH_Class;
; 430  : 		memcpy(pMsg.Name,this->ClassName[i],sizeof(pMsg.Name));

  00020	05 16 40 00 00	 add	 eax, 16406		; 00004016H
  00025	56		 push	 esi
  00026	89 45 b0	 mov	 DWORD PTR tv166[ebp], eax
  00029	57		 push	 edi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL10@GC_Class:
  00030	8b 75 b0	 mov	 esi, DWORD PTR tv166[ebp]
  00033	c7 45 b4 c1 45
	fb ff		 mov	 DWORD PTR _pMsg$209998[ebp], -309823 ; fffb45c1H
  0003a	c6 45 b8 03	 mov	 BYTE PTR _pMsg$209998[ebp+4], 3
  0003e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00043	8d 7d b9	 lea	 edi, DWORD PTR _pMsg$209998[ebp+5]

; 431  : 		DataSend(UserIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00046	6a 45		 push	 69			; 00000045H
  00048	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$209998[ebp]
  0004b	f3 a5		 rep movsd
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00057	8b 55 ac	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  0005a	83 45 b0 40	 add	 DWORD PTR tv166[ebp], 64 ; 00000040H
  0005e	43		 inc	 ebx
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	3b 9a 1c 00 01
	00		 cmp	 ebx, DWORD PTR [edx+65564]
  00068	7c c6		 jl	 SHORT $LL10@GC_Class
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
$LN1@GC_Class:

; 432  : 	}
; 433  : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	5b		 pop	 ebx
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?GC_Class@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Class
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GC_Inject@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::GC_Inject
; Function compile flags: /Ogtp
;	COMDAT ?GC_Inject@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -84					; size = 4
tv166 = -80						; size = 4
_pMsg$210009 = -76					; size = 69
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?GC_Inject@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Inject, COMDAT
; _this$ = ecx

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b c1		 mov	 eax, ecx

; 438  : 	for(int i = 0; i < this->InjectCount; i++)

  00013	33 db		 xor	 ebx, ebx

; 439  : 	{
; 440  : 		PMSG_CheatBase pMsg;
; 441  : 		pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xFF, sizeof(pMsg));

  00015	89 45 ac	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  00018	39 98 20 00 01
	00		 cmp	 DWORD PTR [eax+65568], ebx
  0001e	7e 4c		 jle	 SHORT $LN1@GC_Inject

; 442  : 		pMsg.type = eAH_Inject;
; 443  : 		memcpy(pMsg.Name,this->InjectName[i],sizeof(pMsg.Name));

  00020	05 16 80 00 00	 add	 eax, 32790		; 00008016H
  00025	56		 push	 esi
  00026	89 45 b0	 mov	 DWORD PTR tv166[ebp], eax
  00029	57		 push	 edi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL10@GC_Inject:
  00030	8b 75 b0	 mov	 esi, DWORD PTR tv166[ebp]
  00033	c7 45 b4 c1 45
	fb ff		 mov	 DWORD PTR _pMsg$210009[ebp], -309823 ; fffb45c1H
  0003a	c6 45 b8 04	 mov	 BYTE PTR _pMsg$210009[ebp+4], 4
  0003e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00043	8d 7d b9	 lea	 edi, DWORD PTR _pMsg$210009[ebp+5]

; 444  : 		DataSend(UserIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00046	6a 45		 push	 69			; 00000045H
  00048	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$210009[ebp]
  0004b	f3 a5		 rep movsd
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00057	8b 55 ac	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  0005a	83 45 b0 40	 add	 DWORD PTR tv166[ebp], 64 ; 00000040H
  0005e	43		 inc	 ebx
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	3b 9a 20 00 01
	00		 cmp	 ebx, DWORD PTR [edx+65568]
  00068	7c c6		 jl	 SHORT $LL10@GC_Inject
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
$LN1@GC_Inject:

; 445  : 	}
; 446  : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	5b		 pop	 ebx
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?GC_Inject@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Inject
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GC_Process@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::GC_Process
; Function compile flags: /Ogtp
;	COMDAT ?GC_Process@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -84					; size = 4
tv166 = -80						; size = 4
_pMsg$210020 = -76					; size = 69
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?GC_Process@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Process, COMDAT
; _this$ = ecx

; 450  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b c1		 mov	 eax, ecx

; 451  : 	for(int i = 0; i < this->ProcessCount; i++)

  00013	33 db		 xor	 ebx, ebx

; 452  : 	{
; 453  : 		PMSG_CheatBase pMsg;
; 454  : 		pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xFF, sizeof(pMsg));

  00015	89 45 ac	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  00018	39 98 24 00 01
	00		 cmp	 DWORD PTR [eax+65572], ebx
  0001e	7e 4c		 jle	 SHORT $LN1@GC_Process

; 455  : 		pMsg.type = eAH_Process;
; 456  : 		memcpy(pMsg.Name,this->ProcessName[i],sizeof(pMsg.Name));

  00020	05 16 c0 00 00	 add	 eax, 49174		; 0000c016H
  00025	56		 push	 esi
  00026	89 45 b0	 mov	 DWORD PTR tv166[ebp], eax
  00029	57		 push	 edi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL10@GC_Process:
  00030	8b 75 b0	 mov	 esi, DWORD PTR tv166[ebp]
  00033	c7 45 b4 c1 45
	fb ff		 mov	 DWORD PTR _pMsg$210020[ebp], -309823 ; fffb45c1H
  0003a	c6 45 b8 05	 mov	 BYTE PTR _pMsg$210020[ebp+4], 5
  0003e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00043	8d 7d b9	 lea	 edi, DWORD PTR _pMsg$210020[ebp+5]

; 457  : 		DataSend(UserIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00046	6a 45		 push	 69			; 00000045H
  00048	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$210020[ebp]
  0004b	f3 a5		 rep movsd
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _UserIndex$[ebp]
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00057	8b 55 ac	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  0005a	83 45 b0 40	 add	 DWORD PTR tv166[ebp], 64 ; 00000040H
  0005e	43		 inc	 ebx
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	3b 9a 24 00 01
	00		 cmp	 ebx, DWORD PTR [edx+65572]
  00068	7c c6		 jl	 SHORT $LL10@GC_Process
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
$LN1@GC_Process:

; 458  : 	}
; 459  : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	5b		 pop	 ebx
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?GC_Process@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Process
_TEXT	ENDS
PUBLIC	??_C@_0BG@KPMHEGCJ@Multi?5Windows?5Blocked?$AA@	; `string'
PUBLIC	?CheckMultiWindow@AntiCheatPlus@@QAEXH@Z	; AntiCheatPlus::CheckMultiWindow
;	COMDAT ??_C@_0BG@KPMHEGCJ@Multi?5Windows?5Blocked?$AA@
CONST	SEGMENT
??_C@_0BG@KPMHEGCJ@Multi?5Windows?5Blocked?$AA@ DB 'Multi Windows Blocked'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckMultiWindow@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_n$210032 = 8						; size = 4
_UserIndex$ = 8						; size = 4
?CheckMultiWindow@AntiCheatPlus@@QAEXH@Z PROC		; AntiCheatPlus::CheckMultiWindow, COMDAT
; _this$ = ecx

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 485  : 	if(!this->Enable || this->MultiWindows)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	0f 84 b6 00 00
	00		 je	 $LN10@CheckMulti
  0000c	80 79 07 00	 cmp	 BYTE PTR [ecx+7], 0
  00010	0f 85 ac 00 00
	00		 jne	 $LN10@CheckMulti

; 486  : 	{
; 487  : 		return;
; 488  : 	}
; 489  : 
; 490  : 	if(OBJMAX_RANGE(UserIndex) == FALSE)

  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _UserIndex$[ebp]
  0001a	85 db		 test	 ebx, ebx
  0001c	0f 88 9f 00 00
	00		 js	 $LN20@CheckMulti
  00022	33 c0		 xor	 eax, eax
  00024	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 8c 00 00
	00		 je	 $LN20@CheckMulti

; 491  : 	{
; 492  : 		return;
; 493  : 	}
; 494  : 
; 495  : 	LPOBJ lpUser = &gObj[UserIndex];

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003a	56		 push	 esi
  0003b	8b f3		 mov	 esi, ebx
  0003d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00043	03 f0		 add	 esi, eax

; 496  : 
; 497  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00045	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  00049	7c 75		 jl	 SHORT $LN21@CheckMulti

; 498  : 	{
; 499  : 		return;
; 500  : 	}	
; 501  : 
; 502  : 	for(int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  0004b	57		 push	 edi
  0004c	c7 45 08 b0 36
	00 00		 mov	 DWORD PTR _n$210032[ebp], 14000 ; 000036b0H
  00053	bf 00 a7 40 09	 mov	 edi, 155232000		; 0940a700H
$LL19@CheckMulti:

; 503  : 	{
; 504  : 		LPOBJ lpTempObj = &gObj[n];
; 505  : 
; 506  : 		if(lpTempObj->Connected < PLAYER_PLAYING)

  00058	83 7c 07 04 03	 cmp	 DWORD PTR [edi+eax+4], 3
  0005d	7c 4f		 jl	 SHORT $LN6@CheckMulti

; 507  : 		{
; 508  : 			continue;
; 509  : 		}	
; 510  : 
; 511  : 		if(lpTempObj->Type != OBJ_USER)

  0005f	66 83 7c 07 68
	01		 cmp	 WORD PTR [edi+eax+104], 1
  00065	75 47		 jne	 SHORT $LN6@CheckMulti

; 512  : 		{
; 513  : 			continue;
; 514  : 		}
; 515  : 
; 516  : 		if(UserIndex == n)

  00067	3b 5d 08	 cmp	 ebx, DWORD PTR _n$210032[ebp]
  0006a	74 42		 je	 SHORT $LN6@CheckMulti

; 517  : 		{
; 518  : 			continue;
; 519  : 		}
; 520  : 
; 521  : 		if(lpUser->hdd_id != lpTempObj->hdd_id)

  0006c	8b 8e 8c 28 00
	00		 mov	 ecx, DWORD PTR [esi+10380]
  00072	3b 8c 07 8c 28
	00 00		 cmp	 ecx, DWORD PTR [edi+eax+10380]
  00079	75 33		 jne	 SHORT $LN6@CheckMulti

; 522  : 		{
; 523  : 			continue;
; 524  : 		}
; 525  : 
; 526  : 		GCServerMsgStringSend("..:: Anti-Cheat ::..", lpUser->m_Index, 0);

  0007b	8b 16		 mov	 edx, DWORD PTR [esi]
  0007d	6a 00		 push	 0
  0007f	52		 push	 edx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
  00085	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 527  : 		GCServerMsgStringSend("Multi Windows Blocked", lpUser->m_Index, 0);

  0008a	8b 06		 mov	 eax, DWORD PTR [esi]
  0008c	6a 00		 push	 0
  0008e	50		 push	 eax
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KPMHEGCJ@Multi?5Windows?5Blocked?$AA@
  00094	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00099	83 c4 18	 add	 esp, 24			; 00000018H

; 528  : #ifdef _RECONNECT_				
; 529  : 		g_ConnectZt.SendClose(UserIndex,NORM_DC);

  0009c	6a 00		 push	 0
  0009e	53		 push	 ebx
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  000a4	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN6@CheckMulti:

; 498  : 	{
; 499  : 		return;
; 500  : 	}	
; 501  : 
; 502  : 	for(int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  000ae	ff 45 08	 inc	 DWORD PTR _n$210032[ebp]
  000b1	81 c7 50 2b 00
	00		 add	 edi, 11088		; 00002b50H
  000b7	81 ff 80 d7 e9
	09		 cmp	 edi, 166320000		; 09e9d780H
  000bd	7c 99		 jl	 SHORT $LL19@CheckMulti
  000bf	5f		 pop	 edi
$LN21@CheckMulti:
  000c0	5e		 pop	 esi
$LN20@CheckMulti:
  000c1	5b		 pop	 ebx
$LN10@CheckMulti:

; 530  : #else
; 531  : 		CloseClient(UserIndex);
; 532  : #endif
; 533  : 	}
; 534  : }

  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
?CheckMultiWindow@AntiCheatPlus@@QAEXH@Z ENDP		; AntiCheatPlus::CheckMultiWindow
_TEXT	ENDS
PUBLIC	?WraitLog@AntiCheatPlus@@QAEXPAD@Z		; AntiCheatPlus::WraitLog
; Function compile flags: /Ogtp
;	COMDAT ?WraitLog@AntiCheatPlus@@QAEXPAD@Z
_TEXT	SEGMENT
_Text$ = 8						; size = 4
?WraitLog@AntiCheatPlus@@QAEXPAD@Z PROC			; AntiCheatPlus::WraitLog, COMDAT
; _this$ = ecx

; 639  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 640  : 	g_AntiCheatLog.Output(Text);

  00003	8b 45 08	 mov	 eax, DWORD PTR _Text$[ebp]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ?g_AntiCheatLog@@3VCLogToFile@@A ; g_AntiCheatLog
  0000c	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00011	83 c4 08	 add	 esp, 8

; 641  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?WraitLog@AntiCheatPlus@@QAEXPAD@Z ENDP			; AntiCheatPlus::WraitLog
_TEXT	ENDS
PUBLIC	??_C@_0BG@LEABKPHO@Max?5Windows?5Count?3?5?$CFd?$AA@ ; `string'
PUBLIC	_UserIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckMaxWindow@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::CheckMaxWindow
EXTRN	_sprintf:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BG@LEABKPHO@Max?5Windows?5Count?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BG@LEABKPHO@Max?5Windows?5Count?3?5?$CFd?$AA@ DB 'Max Windows Coun'
	DB	't: %d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckMaxWindow@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_UserIndex$GSCopy$ = -272				; size = 4
_this$GSCopy$ = -268					; size = 4
tv859 = -264						; size = 4
_szTemp$210063 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_UserIndex$ = 8						; size = 4
?CheckMaxWindow@AntiCheatPlus@@QAEXH@Z PROC		; AntiCheatPlus::CheckMaxWindow, COMDAT
; _this$ = ecx

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 646  : 	//return;
; 647  : 
; 648  : 	//if(!this->Enable)
; 649  : 	//{
; 650  : 	//	return;
; 651  : 	//}
; 652  : 
; 653  : 	if(!this->m_EnableMaxWindow)

  00013	83 b9 28 00 01
	00 00		 cmp	 DWORD PTR [ecx+65576], 0
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _UserIndex$[ebp]

; 659  : 	{
; 660  : 		return;
; 661  : 	}
; 662  : 
; 663  : 	LPOBJ lpUser = &gObj[UserIndex];

  0001e	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00024	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _UserIndex$GSCopy$[ebp], esi
  0002a	0f 84 66 01 00
	00		 je	 $LN1@CheckMaxWi

; 654  : 	{
; 655  : 		return;
; 656  : 	}
; 657  : 
; 658  : 	if(OBJMAX_RANGE(UserIndex) == FALSE)

  00030	85 f6		 test	 esi, esi
  00032	0f 88 5e 01 00
	00		 js	 $LN1@CheckMaxWi
  00038	33 c0		 xor	 eax, eax
  0003a	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00040	0f 9e c0	 setle	 al
  00043	85 c0		 test	 eax, eax
  00045	0f 84 4b 01 00
	00		 je	 $LN1@CheckMaxWi

; 659  : 	{
; 660  : 		return;
; 661  : 	}
; 662  : 
; 663  : 	LPOBJ lpUser = &gObj[UserIndex];

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00050	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00056	57		 push	 edi

; 664  : 
; 665  : 	int iWaxCount = 0;

  00057	33 d2		 xor	 edx, edx
  00059	03 f0		 add	 esi, eax
  0005b	05 b8 d2 40 09	 add	 eax, 155243192		; 0940d2b8H
  00060	c7 85 f8 fe ff
	ff c8 00 00 00	 mov	 DWORD PTR tv859[ebp], 200 ; 000000c8H
  0006a	b9 03 00 00 00	 mov	 ecx, 3
  0006f	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  00072	53		 push	 ebx
$LL7@CheckMaxWi:

; 668  : 	{
; 669  : 		LPOBJ lpTempObj = &gObj[n];
; 670  : 
; 671  : 		if(lpTempObj->Connected < PLAYER_PLAYING)

  00073	39 88 4c d4 ff
	ff		 cmp	 DWORD PTR [eax-11188], ecx
  00079	7c 19		 jl	 SHORT $LN6@CheckMaxWi

; 672  : 		{
; 673  : 			continue;
; 674  : 		}	
; 675  : 
; 676  : 		if(lpTempObj->Type != OBJ_USER)

  0007b	66 39 b8 b0 d4
	ff ff		 cmp	 WORD PTR [eax-11088], di
  00082	75 10		 jne	 SHORT $LN6@CheckMaxWi

; 677  : 		{
; 678  : 			continue;
; 679  : 		}
; 680  : 
; 681  : 		//if(lpTempObj->OffTrade != 0)
; 682  : 		//{
; 683  : 		//	continue;
; 684  : 		//}
; 685  : 
; 686  : 		//if(lpTempObj->OffTrade != 0)
; 687  : 		//{
; 688  : 		//	continue;
; 689  : 		//}
; 690  : 
; 691  : 		//if(lpTempObj->OffExp != 0)
; 692  : 		//{
; 693  : 		//	continue;
; 694  : 		//}
; 695  : 
; 696  : 		//if(lpTempObj->m_OfflineMode != 0)
; 697  : 		//{
; 698  : 		//	continue;
; 699  : 		//}
; 700  : 
; 701  : 		if(lpUser->hdd_id == lpTempObj->hdd_id)

  00084	8b 9e 8c 28 00
	00		 mov	 ebx, DWORD PTR [esi+10380]
  0008a	3b 98 d4 fc ff
	ff		 cmp	 ebx, DWORD PTR [eax-812]
  00090	75 02		 jne	 SHORT $LN6@CheckMaxWi

; 702  : 		{
; 703  : 			iWaxCount++;

  00092	03 d7		 add	 edx, edi
$LN6@CheckMaxWi:

; 668  : 	{
; 669  : 		LPOBJ lpTempObj = &gObj[n];
; 670  : 
; 671  : 		if(lpTempObj->Connected < PLAYER_PLAYING)

  00094	39 48 9c	 cmp	 DWORD PTR [eax-100], ecx
  00097	7c 15		 jl	 SHORT $LN22@CheckMaxWi

; 672  : 		{
; 673  : 			continue;
; 674  : 		}	
; 675  : 
; 676  : 		if(lpTempObj->Type != OBJ_USER)

  00099	66 39 38	 cmp	 WORD PTR [eax], di
  0009c	75 10		 jne	 SHORT $LN22@CheckMaxWi

; 677  : 		{
; 678  : 			continue;
; 679  : 		}
; 680  : 
; 681  : 		//if(lpTempObj->OffTrade != 0)
; 682  : 		//{
; 683  : 		//	continue;
; 684  : 		//}
; 685  : 
; 686  : 		//if(lpTempObj->OffTrade != 0)
; 687  : 		//{
; 688  : 		//	continue;
; 689  : 		//}
; 690  : 
; 691  : 		//if(lpTempObj->OffExp != 0)
; 692  : 		//{
; 693  : 		//	continue;
; 694  : 		//}
; 695  : 
; 696  : 		//if(lpTempObj->m_OfflineMode != 0)
; 697  : 		//{
; 698  : 		//	continue;
; 699  : 		//}
; 700  : 
; 701  : 		if(lpUser->hdd_id == lpTempObj->hdd_id)

  0009e	8b 9e 8c 28 00
	00		 mov	 ebx, DWORD PTR [esi+10380]
  000a4	3b 98 24 28 00
	00		 cmp	 ebx, DWORD PTR [eax+10276]
  000aa	75 02		 jne	 SHORT $LN22@CheckMaxWi

; 702  : 		{
; 703  : 			iWaxCount++;

  000ac	03 d7		 add	 edx, edi
$LN22@CheckMaxWi:

; 668  : 	{
; 669  : 		LPOBJ lpTempObj = &gObj[n];
; 670  : 
; 671  : 		if(lpTempObj->Connected < PLAYER_PLAYING)

  000ae	39 88 ec 2a 00
	00		 cmp	 DWORD PTR [eax+10988], ecx
  000b4	7c 19		 jl	 SHORT $LN23@CheckMaxWi

; 672  : 		{
; 673  : 			continue;
; 674  : 		}	
; 675  : 
; 676  : 		if(lpTempObj->Type != OBJ_USER)

  000b6	66 39 b8 50 2b
	00 00		 cmp	 WORD PTR [eax+11088], di
  000bd	75 10		 jne	 SHORT $LN23@CheckMaxWi

; 677  : 		{
; 678  : 			continue;
; 679  : 		}
; 680  : 
; 681  : 		//if(lpTempObj->OffTrade != 0)
; 682  : 		//{
; 683  : 		//	continue;
; 684  : 		//}
; 685  : 
; 686  : 		//if(lpTempObj->OffTrade != 0)
; 687  : 		//{
; 688  : 		//	continue;
; 689  : 		//}
; 690  : 
; 691  : 		//if(lpTempObj->OffExp != 0)
; 692  : 		//{
; 693  : 		//	continue;
; 694  : 		//}
; 695  : 
; 696  : 		//if(lpTempObj->m_OfflineMode != 0)
; 697  : 		//{
; 698  : 		//	continue;
; 699  : 		//}
; 700  : 
; 701  : 		if(lpUser->hdd_id == lpTempObj->hdd_id)

  000bf	8b 9e 8c 28 00
	00		 mov	 ebx, DWORD PTR [esi+10380]
  000c5	3b 98 74 53 00
	00		 cmp	 ebx, DWORD PTR [eax+21364]
  000cb	75 02		 jne	 SHORT $LN23@CheckMaxWi

; 702  : 		{
; 703  : 			iWaxCount++;

  000cd	03 d7		 add	 edx, edi
$LN23@CheckMaxWi:

; 668  : 	{
; 669  : 		LPOBJ lpTempObj = &gObj[n];
; 670  : 
; 671  : 		if(lpTempObj->Connected < PLAYER_PLAYING)

  000cf	39 88 3c 56 00
	00		 cmp	 DWORD PTR [eax+22076], ecx
  000d5	7c 19		 jl	 SHORT $LN24@CheckMaxWi

; 672  : 		{
; 673  : 			continue;
; 674  : 		}	
; 675  : 
; 676  : 		if(lpTempObj->Type != OBJ_USER)

  000d7	66 39 b8 a0 56
	00 00		 cmp	 WORD PTR [eax+22176], di
  000de	75 10		 jne	 SHORT $LN24@CheckMaxWi

; 677  : 		{
; 678  : 			continue;
; 679  : 		}
; 680  : 
; 681  : 		//if(lpTempObj->OffTrade != 0)
; 682  : 		//{
; 683  : 		//	continue;
; 684  : 		//}
; 685  : 
; 686  : 		//if(lpTempObj->OffTrade != 0)
; 687  : 		//{
; 688  : 		//	continue;
; 689  : 		//}
; 690  : 
; 691  : 		//if(lpTempObj->OffExp != 0)
; 692  : 		//{
; 693  : 		//	continue;
; 694  : 		//}
; 695  : 
; 696  : 		//if(lpTempObj->m_OfflineMode != 0)
; 697  : 		//{
; 698  : 		//	continue;
; 699  : 		//}
; 700  : 
; 701  : 		if(lpUser->hdd_id == lpTempObj->hdd_id)

  000e0	8b 9e 8c 28 00
	00		 mov	 ebx, DWORD PTR [esi+10380]
  000e6	3b 98 c4 7e 00
	00		 cmp	 ebx, DWORD PTR [eax+32452]
  000ec	75 02		 jne	 SHORT $LN24@CheckMaxWi

; 702  : 		{
; 703  : 			iWaxCount++;

  000ee	03 d7		 add	 edx, edi
$LN24@CheckMaxWi:

; 668  : 	{
; 669  : 		LPOBJ lpTempObj = &gObj[n];
; 670  : 
; 671  : 		if(lpTempObj->Connected < PLAYER_PLAYING)

  000f0	39 88 8c 81 00
	00		 cmp	 DWORD PTR [eax+33164], ecx
  000f6	7c 19		 jl	 SHORT $LN25@CheckMaxWi

; 672  : 		{
; 673  : 			continue;
; 674  : 		}	
; 675  : 
; 676  : 		if(lpTempObj->Type != OBJ_USER)

  000f8	66 39 b8 f0 81
	00 00		 cmp	 WORD PTR [eax+33264], di
  000ff	75 10		 jne	 SHORT $LN25@CheckMaxWi

; 677  : 		{
; 678  : 			continue;
; 679  : 		}
; 680  : 
; 681  : 		//if(lpTempObj->OffTrade != 0)
; 682  : 		//{
; 683  : 		//	continue;
; 684  : 		//}
; 685  : 
; 686  : 		//if(lpTempObj->OffTrade != 0)
; 687  : 		//{
; 688  : 		//	continue;
; 689  : 		//}
; 690  : 
; 691  : 		//if(lpTempObj->OffExp != 0)
; 692  : 		//{
; 693  : 		//	continue;
; 694  : 		//}
; 695  : 
; 696  : 		//if(lpTempObj->m_OfflineMode != 0)
; 697  : 		//{
; 698  : 		//	continue;
; 699  : 		//}
; 700  : 
; 701  : 		if(lpUser->hdd_id == lpTempObj->hdd_id)

  00101	8b 9e 8c 28 00
	00		 mov	 ebx, DWORD PTR [esi+10380]
  00107	3b 98 14 aa 00
	00		 cmp	 ebx, DWORD PTR [eax+43540]
  0010d	75 02		 jne	 SHORT $LN25@CheckMaxWi

; 702  : 		{
; 703  : 			iWaxCount++;

  0010f	03 d7		 add	 edx, edi
$LN25@CheckMaxWi:

; 659  : 	{
; 660  : 		return;
; 661  : 	}
; 662  : 
; 663  : 	LPOBJ lpUser = &gObj[UserIndex];

  00111	05 90 d8 00 00	 add	 eax, 55440		; 0000d890H

; 666  : 
; 667  : 	for(int n = OBJ_STARTUSERINDZT; n < OBJMAX; n++)

  00116	29 bd f8 fe ff
	ff		 sub	 DWORD PTR tv859[ebp], edi
  0011c	0f 85 51 ff ff
	ff		 jne	 $LL7@CheckMaxWi

; 704  : 		}
; 705  : 	}
; 706  : 
; 707  : 	if(iWaxCount > this->m_MaxWindow)

  00122	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00128	8b b8 2c 00 01
	00		 mov	 edi, DWORD PTR [eax+65580]
  0012e	5b		 pop	 ebx
  0012f	3b d7		 cmp	 edx, edi
  00131	7e 62		 jle	 SHORT $LN26@CheckMaxWi

; 708  : 	{
; 709  : 		char szTemp[256] = { 0 };

  00133	68 ff 00 00 00	 push	 255			; 000000ffH
  00138	8d 8d fd fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$210063[ebp+1]
  0013e	6a 00		 push	 0
  00140	51		 push	 ecx
  00141	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR _szTemp$210063[ebp], 0
  00148	e8 00 00 00 00	 call	 _memset

; 710  : 		sprintf(szTemp, "Max Windows Count: %d", this->m_MaxWindow);

  0014d	57		 push	 edi
  0014e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$210063[ebp]
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LEABKPHO@Max?5Windows?5Count?3?5?$CFd?$AA@
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 _sprintf

; 711  : 		GCServerMsgStringSend("..:: Anti-Cheat ::..", lpUser->m_Index, 0);

  0015f	8b 06		 mov	 eax, DWORD PTR [esi]
  00161	6a 00		 push	 0
  00163	50		 push	 eax
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
  00169	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 712  : 		GCServerMsgStringSend(szTemp, lpUser->m_Index, 0);

  0016e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00170	6a 00		 push	 0
  00172	51		 push	 ecx
  00173	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$210063[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 713  : 
; 714  : 		#ifdef _RECONNECT_				
; 715  : 		g_ConnectZt.SendClose(UserIndex,NORM_DC);

  0017f	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _UserIndex$GSCopy$[ebp]
  00185	83 c4 30	 add	 esp, 48			; 00000030H
  00188	6a 00		 push	 0
  0018a	50		 push	 eax
  0018b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00190	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
$LN26@CheckMaxWi:
  00195	5f		 pop	 edi
$LN1@CheckMaxWi:

; 716  : 		#else
; 717  : 		CloseClient(UserIndex);
; 718  : 		#endif
; 719  : 	}
; 720  : }

  00196	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00199	33 cd		 xor	 ecx, ebp
  0019b	5e		 pop	 esi
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c2 04 00	 ret	 4
?CheckMaxWindow@AntiCheatPlus@@QAEXH@Z ENDP		; AntiCheatPlus::CheckMaxWindow
_TEXT	ENDS
PUBLIC	?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z	; AntiCheatPlus::CheckItemSerial
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
; Function compile flags: /Ogtp
;	COMDAT ?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z
_TEXT	SEGMENT
_ItemType$ = 8						; size = 4
?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z PROC		; AntiCheatPlus::CheckItemSerial, COMDAT
; _this$ = ecx

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 935  : 	if(!ItemAttribute[ItemType].Serial)

  00003	8b 45 08	 mov	 eax, DWORD PTR _ItemType$[ebp]
  00006	6b c0 70	 imul	 eax, 112		; 00000070H
  00009	80 b8 25 00 00
	00 00		 cmp	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+37], 0
  00010	0f 95 c0	 setne	 al

; 936  : 	{
; 937  : 		return false;
; 938  : 	}
; 939  : 
; 940  : 	return true;
; 941  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z ENDP		; AntiCheatPlus::CheckItemSerial
_TEXT	ENDS
PUBLIC	?size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEAAUBlockHDD_DATA@@I@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEAAUBlockHDD_DATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEAAUBlockHDD_DATA@@I@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEAAUBlockHDD_DATA@@I@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBE_NPBUBlockHDD_DATA@@@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBE_NPBUBlockHDD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBE_NPBUBlockHDD_DATA@@@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBE_NPBUBlockHDD_DATA@@@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXPAUBlockHDD_DATA@@0@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXPAUBlockHDD_DATA@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXPAUBlockHDD_DATA@@0@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXPAUBlockHDD_DATA@@0@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::~_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::~_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::~_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBlockHDD_DATA@@@std@@QAE@XZ	; std::allocator<BlockHDD_DATA>::allocator<BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBlockHDD_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UBlockHDD_DATA@@@std@@QAE@XZ PROC	; std::allocator<BlockHDD_DATA>::allocator<BlockHDD_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UBlockHDD_DATA@@@std@@QAE@XZ ENDP	; std::allocator<BlockHDD_DATA>::allocator<BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXXZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UBlockHDD_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<BlockHDD_DATA>::allocator<BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBlockHDD_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UBlockHDD_DATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<BlockHDD_DATA>::allocator<BlockHDD_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UBlockHDD_DATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<BlockHDD_DATA>::allocator<BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@I@Z ; std::allocator<BlockHDD_DATA>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@I@Z PROC ; std::allocator<BlockHDD_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@I@Z ENDP ; std::allocator<BlockHDD_DATA>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBlockHDD_DATA@@@std@@QBEIXZ ; std::allocator<BlockHDD_DATA>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UBlockHDD_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UBlockHDD_DATA@@@std@@QBEIXZ PROC	; std::allocator<BlockHDD_DATA>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UBlockHDD_DATA@@@std@@QBEIXZ ENDP	; std::allocator<BlockHDD_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Compat
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUBlockHDD_DATA@@@std@@YAPBUBlockHDD_DATA@@ABU1@@Z ; std::addressof<BlockHDD_DATA const >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUBlockHDD_DATA@@@std@@YAPBUBlockHDD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUBlockHDD_DATA@@@std@@YAPBUBlockHDD_DATA@@ABU1@@Z PROC ; std::addressof<BlockHDD_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUBlockHDD_DATA@@@std@@YAPBUBlockHDD_DATA@@ABU1@@Z ENDP ; std::addressof<BlockHDD_DATA const >
_TEXT	ENDS
PUBLIC	??$forward@AAUBlockHDD_DATA@@@std@@YAAAUBlockHDD_DATA@@AAU1@@Z ; std::forward<BlockHDD_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUBlockHDD_DATA@@@std@@YAAAUBlockHDD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUBlockHDD_DATA@@@std@@YAAAUBlockHDD_DATA@@AAU1@@Z PROC ; std::forward<BlockHDD_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUBlockHDD_DATA@@@std@@YAAAUBlockHDD_DATA@@AAU1@@Z ENDP ; std::forward<BlockHDD_DATA &>
_TEXT	ENDS
PUBLIC	??$construct@AAUBlockHDD_DATA@@@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@AAU2@@Z ; std::allocator<BlockHDD_DATA>::construct<BlockHDD_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUBlockHDD_DATA@@@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUBlockHDD_DATA@@@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@AAU2@@Z PROC ; std::allocator<BlockHDD_DATA>::construct<BlockHDD_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@construct:

; 209  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@AAUBlockHDD_DATA@@@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@AAU2@@Z ENDP ; std::allocator<BlockHDD_DATA>::construct<BlockHDD_DATA &>
_TEXT	ENDS
PUBLIC	??$forward@ABUBlockHDD_DATA@@@std@@YAABUBlockHDD_DATA@@ABU1@@Z ; std::forward<BlockHDD_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUBlockHDD_DATA@@@std@@YAABUBlockHDD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBlockHDD_DATA@@@std@@YAABUBlockHDD_DATA@@ABU1@@Z PROC ; std::forward<BlockHDD_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUBlockHDD_DATA@@@std@@YAABUBlockHDD_DATA@@ABU1@@Z ENDP ; std::forward<BlockHDD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UBlockHDD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBlockHDD_DATA@@0@Z ; std::_Ptr_cat<BlockHDD_DATA,BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UBlockHDD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBlockHDD_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UBlockHDD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBlockHDD_DATA@@0@Z PROC ; std::_Ptr_cat<BlockHDD_DATA,BlockHDD_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UBlockHDD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBlockHDD_DATA@@0@Z ENDP ; std::_Ptr_cat<BlockHDD_DATA,BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@UBlockHDD_DATA@@ABU1@@std@@YAXPAUBlockHDD_DATA@@ABU1@@Z ; std::_Construct<BlockHDD_DATA,BlockHDD_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@UBlockHDD_DATA@@ABU1@@std@@YAXPAUBlockHDD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBlockHDD_DATA@@ABU1@@std@@YAXPAUBlockHDD_DATA@@ABU1@@Z PROC ; std::_Construct<BlockHDD_DATA,BlockHDD_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Construct:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@UBlockHDD_DATA@@ABU1@@std@@YAXPAUBlockHDD_DATA@@ABU1@@Z ENDP ; std::_Construct<BlockHDD_DATA,BlockHDD_DATA const &>
_TEXT	ENDS
PUBLIC	??$move@AAUBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z ; std::move<BlockHDD_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z PROC ; std::move<BlockHDD_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z ENDP ; std::move<BlockHDD_DATA &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@PAU1@@Z ; std::_Val_type<BlockHDD_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@PAU1@@Z PROC ; std::_Val_type<BlockHDD_DATA *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@PAU1@@Z ENDP ; std::_Val_type<BlockHDD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy@UBlockHDD_DATA@@@std@@YAXPAUBlockHDD_DATA@@@Z ; std::_Destroy<BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UBlockHDD_DATA@@@std@@YAXPAUBlockHDD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UBlockHDD_DATA@@@std@@YAXPAUBlockHDD_DATA@@@Z PROC ; std::_Destroy<BlockHDD_DATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UBlockHDD_DATA@@@std@@YAXPAUBlockHDD_DATA@@@Z ENDP ; std::_Destroy<BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	??$forward@UBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z ; std::forward<BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z PROC ; std::forward<BlockHDD_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UBlockHDD_DATA@@@std@@YA$$QAUBlockHDD_DATA@@AAU1@@Z ENDP ; std::forward<BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?GC_Cheat@AntiCheatPlus@@QAEXH@Z		; AntiCheatPlus::GC_Cheat
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\anticheatplus.cpp
;	COMDAT ?GC_Cheat@AntiCheatPlus@@QAEXH@Z
_TEXT	SEGMENT
_UserIndex$ = 8						; size = 4
?GC_Cheat@AntiCheatPlus@@QAEXH@Z PROC			; AntiCheatPlus::GC_Cheat, COMDAT
; _this$ = ecx

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 298  : 	if(!this->Enable)

  00006	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00009	74 33		 je	 SHORT $LN2@GC_Cheat

; 299  : 	{
; 300  : 		return;
; 301  : 	}
; 302  : 	this->GC_Init(UserIndex);

  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _UserIndex$[ebp]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ?GC_Init@AntiCheatPlus@@QAEXH@Z ; AntiCheatPlus::GC_Init

; 303  : 	this->GC_Config(UserIndex);

  00015	57		 push	 edi
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?GC_Config@AntiCheatPlus@@QAEXH@Z ; AntiCheatPlus::GC_Config

; 304  : 	this->GC_Title(UserIndex);

  0001d	57		 push	 edi
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?GC_Title@AntiCheatPlus@@QAEXH@Z ; AntiCheatPlus::GC_Title

; 305  : 	this->GC_Class(UserIndex);

  00025	57		 push	 edi
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?GC_Class@AntiCheatPlus@@QAEXH@Z ; AntiCheatPlus::GC_Class

; 306  : 	this->GC_Inject(UserIndex);

  0002d	57		 push	 edi
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?GC_Inject@AntiCheatPlus@@QAEXH@Z ; AntiCheatPlus::GC_Inject

; 307  : 	this->GC_Process(UserIndex);

  00035	57		 push	 edi
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?GC_Process@AntiCheatPlus@@QAEXH@Z ; AntiCheatPlus::GC_Process
  0003d	5f		 pop	 edi
$LN2@GC_Cheat:
  0003e	5e		 pop	 esi

; 308  : #if(ANTI_CHEAT_PLUS_CRC)
; 309  : 	this->GC_Crc(UserIndex);
; 310  : #endif
; 311  : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?GC_Cheat@AntiCheatPlus@@QAEXH@Z ENDP			; AntiCheatPlus::GC_Cheat
_TEXT	ENDS
PUBLIC	?CG_HddSend@AntiCheatPlus@@QAEXPAUCG_PMSG_HDDKEY@@H@Z ; AntiCheatPlus::CG_HddSend
; Function compile flags: /Ogtp
;	COMDAT ?CG_HddSend@AntiCheatPlus@@QAEXPAUCG_PMSG_HDDKEY@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_UserIndex$ = 12					; size = 4
?CG_HddSend@AntiCheatPlus@@QAEXPAUCG_PMSG_HDDKEY@@H@Z PROC ; AntiCheatPlus::CG_HddSend, COMDAT
; _this$ = ecx

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 340  : 	if(!aRecv)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 84 82 00 00
	00		 je	 $LN2@CG_HddSend

; 341  : 	{
; 342  : 		return;
; 343  : 	}
; 344  : 
; 345  : 	if(OBJMAX_RANGE(UserIndex) == 0)

  00011	8b 55 0c	 mov	 edx, DWORD PTR _UserIndex$[ebp]
  00014	85 d2		 test	 edx, edx
  00016	78 7b		 js	 SHORT $LN2@CG_HddSend
  00018	33 c0		 xor	 eax, eax
  0001a	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00020	0f 9e c0	 setle	 al
  00023	85 c0		 test	 eax, eax
  00025	74 6c		 je	 SHORT $LN2@CG_HddSend

; 346  : 	{
; 347  : 		return;
; 348  : 	}
; 349  : 
; 350  : 	LPOBJ lpUser = &gObj[UserIndex];
; 351  : 
; 352  : 	lpUser->hdd_id = aRecv->hdd_id;

  00027	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002a	56		 push	 esi
  0002b	8b f2		 mov	 esi, edx
  0002d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00033	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	89 86 8c 28 00
	00		 mov	 DWORD PTR [esi+10380], eax

; 353  : 
; 354  : 	if(!this->Enable)

  0003f	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00042	74 4e		 je	 SHORT $LN18@CG_HddSend

; 355  : 	{
; 356  : 		return;
; 357  : 	}
; 358  : 
; 359  : 	for(int i = 0; i < this->blockhdd.size(); i++)

  00044	8b 87 30 00 01
	00		 mov	 eax, DWORD PTR [edi+65584]
  0004a	8b 8f 34 00 01
	00		 mov	 ecx, DWORD PTR [edi+65588]
  00050	2b c8		 sub	 ecx, eax
  00052	53		 push	 ebx
  00053	c1 f9 02	 sar	 ecx, 2
  00056	33 db		 xor	 ebx, ebx
  00058	85 c9		 test	 ecx, ecx
  0005a	74 35		 je	 SHORT $LN19@CG_HddSend
  0005c	8d 64 24 00	 npad	 4
$LL4@CG_HddSend:

; 360  : 	{
; 361  : 		BlockHDD_DATA & CheckList = this->blockhdd[i];
; 362  : 		if(CheckList.hddid != lpUser->hdd_id)

  00060	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00063	3b 86 8c 28 00
	00		 cmp	 eax, DWORD PTR [esi+10380]
  00069	75 10		 jne	 SHORT $LN3@CG_HddSend

; 363  : 		{
; 364  : 			continue;
; 365  : 		}
; 366  : 		//GCServerMsgStringSend("..:: Anti-Cheat ::..", lpUser->m_Index, 0);
; 367  : 		//GCServerMsgStringSend("PC Block List", lpUser->m_Index, 0);
; 368  : #ifdef _RECONNECT_				
; 369  : 		g_ConnectZt.SendClose(UserIndex,NORM_DC);

  0006b	6a 00		 push	 0
  0006d	52		 push	 edx
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00073	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
  00078	8b 55 0c	 mov	 edx, DWORD PTR _UserIndex$[ebp]
$LN3@CG_HddSend:

; 355  : 	{
; 356  : 		return;
; 357  : 	}
; 358  : 
; 359  : 	for(int i = 0; i < this->blockhdd.size(); i++)

  0007b	8b 87 30 00 01
	00		 mov	 eax, DWORD PTR [edi+65584]
  00081	8b 8f 34 00 01
	00		 mov	 ecx, DWORD PTR [edi+65588]
  00087	2b c8		 sub	 ecx, eax
  00089	43		 inc	 ebx
  0008a	c1 f9 02	 sar	 ecx, 2
  0008d	3b d9		 cmp	 ebx, ecx
  0008f	72 cf		 jb	 SHORT $LL4@CG_HddSend
$LN19@CG_HddSend:
  00091	5b		 pop	 ebx
$LN18@CG_HddSend:
  00092	5e		 pop	 esi
$LN2@CG_HddSend:
  00093	5f		 pop	 edi

; 370  : #else
; 371  : 		CloseClient(UserIndex);
; 372  : #endif
; 373  : 	}
; 374  : }

  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
?CG_HddSend@AntiCheatPlus@@QAEXPAUCG_PMSG_HDDKEY@@H@Z ENDP ; AntiCheatPlus::CG_HddSend
_TEXT	ENDS
PUBLIC	?CheckItemDupe@AntiCheatPlus@@QAE_NHHH@Z	; AntiCheatPlus::CheckItemDupe
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckItemDupe@AntiCheatPlus@@QAE_NHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_UserIndex$ = 8						; size = 4
_ItemSerial$ = 12					; size = 4
_ItemPos$ = 16						; size = 4
?CheckItemDupe@AntiCheatPlus@@QAE_NHHH@Z PROC		; AntiCheatPlus::CheckItemDupe, COMDAT
; _this$ = ecx

; 833  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 834  : 	LPOBJ lpUser = &gObj[UserIndex];

  00006	8b 75 08	 mov	 esi, DWORD PTR _UserIndex$[ebp]
  00009	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0000f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	57		 push	 edi

; 835  : 
; 836  : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  00016	33 db		 xor	 ebx, ebx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001b	33 ff		 xor	 edi, edi
  0001d	8d 49 00	 npad	 3
$LL13@CheckItemD:

; 837  : 	{
; 838  : 		if(ItemPos == n)

  00020	39 5d 10	 cmp	 DWORD PTR _ItemPos$[ebp], ebx
  00023	74 38		 je	 SHORT $LN12@CheckItemD

; 839  : 		{
; 840  : 			continue;
; 841  : 		}
; 842  : 
; 843  : 		if(!lpUser->pInventory[n].IsItem())

  00025	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0002b	03 cf		 add	 ecx, edi
  0002d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00032	85 c0		 test	 eax, eax
  00034	74 27		 je	 SHORT $LN12@CheckItemD

; 844  : 		{
; 845  : 			continue;
; 846  : 		}
; 847  : 
; 848  : 		if(!this->CheckItemSerial(lpUser->pInventory[n].m_Type))

  00036	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  0003c	0f bf 4c 07 06	 movsx	 ecx, WORD PTR [edi+eax+6]
  00041	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z ; AntiCheatPlus::CheckItemSerial
  0004d	84 c0		 test	 al, al
  0004f	74 0c		 je	 SHORT $LN12@CheckItemD

; 849  : 		{
; 850  : 			continue;
; 851  : 		}
; 852  : 
; 853  : 		int iNextSerial = lpUser->pInventory[n].GetNumber();

  00051	8b ca		 mov	 ecx, edx
  00053	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 854  : 
; 855  : 		if(ItemSerial == iNextSerial)

  00058	39 45 0c	 cmp	 DWORD PTR _ItemSerial$[ebp], eax
  0005b	74 63		 je	 SHORT $LN18@CheckItemD
$LN12@CheckItemD:

; 835  : 
; 836  : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  0005d	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00063	43		 inc	 ebx
  00064	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  0006a	7c b4		 jl	 SHORT $LL13@CheckItemD

; 860  : 		}
; 861  : 	}
; 862  : 
; 863  : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  0006c	33 ff		 xor	 edi, edi
  0006e	8b ff		 npad	 2
$LL6@CheckItemD:

; 864  : 	{
; 865  : 		if(!lpUser->pWarehouse[n].IsItem())

  00070	8b 8e 5c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3676]
  00076	03 cf		 add	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0007d	85 c0		 test	 eax, eax
  0007f	74 26		 je	 SHORT $LN5@CheckItemD

; 866  : 		{
; 867  : 			continue;
; 868  : 		}
; 869  : 
; 870  : 		if(!this->CheckItemSerial(lpUser->pWarehouse[n].m_Type))

  00081	8b 96 5c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3676]
  00087	0f bf 44 3a 06	 movsx	 eax, WORD PTR [edx+edi+6]
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	03 d7		 add	 edx, edi
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z ; AntiCheatPlus::CheckItemSerial
  00097	84 c0		 test	 al, al
  00099	74 0c		 je	 SHORT $LN5@CheckItemD

; 871  : 		{
; 872  : 			continue;
; 873  : 		}
; 874  : 
; 875  : 		int iNextSerial = lpUser->pWarehouse[n].GetNumber();

  0009b	8b ca		 mov	 ecx, edx
  0009d	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 876  : 
; 877  : 		if(ItemSerial == iNextSerial)

  000a2	39 45 0c	 cmp	 DWORD PTR _ItemSerial$[ebp], eax
  000a5	74 19		 je	 SHORT $LN18@CheckItemD
$LN5@CheckItemD:

; 860  : 		}
; 861  : 	}
; 862  : 
; 863  : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  000a7	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000ad	81 ff c0 c6 00
	00		 cmp	 edi, 50880		; 0000c6c0H
  000b3	7c bb		 jl	 SHORT $LL6@CheckItemD

; 878  : 		{
; 879  : 			return false;
; 880  : 		}
; 881  : 	}
; 882  : 
; 883  : 	return true;

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	b0 01		 mov	 al, 1
  000b9	5b		 pop	 ebx

; 884  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
$LN18@CheckItemD:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi

; 856  : 		{
; 857  : 			//MsgOutput(UserIndex, "%d = %d ( %d , %d )", ItemPos, n, ItemSerial, iNextSerial);
; 858  : 
; 859  : 			return false;

  000c2	32 c0		 xor	 al, al
  000c4	5b		 pop	 ebx

; 884  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 0c 00	 ret	 12			; 0000000cH
?CheckItemDupe@AntiCheatPlus@@QAE_NHHH@Z ENDP		; AntiCheatPlus::CheckItemDupe
_TEXT	ENDS
PUBLIC	?CheckWareDupe@AntiCheatPlus@@QAE_NHHH@Z	; AntiCheatPlus::CheckWareDupe
; Function compile flags: /Ogtp
;	COMDAT ?CheckWareDupe@AntiCheatPlus@@QAE_NHHH@Z
_TEXT	SEGMENT
_UserIndex$ = 8						; size = 4
_ItemSerial$ = 12					; size = 4
_WarePos$ = 16						; size = 4
?CheckWareDupe@AntiCheatPlus@@QAE_NHHH@Z PROC		; AntiCheatPlus::CheckWareDupe, COMDAT
; _this$ = ecx

; 887  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 888  : 	LPOBJ lpUser = &gObj[UserIndex];

  00006	8b 7d 08	 mov	 edi, DWORD PTR _UserIndex$[ebp]
  00009	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0000f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	8b d9		 mov	 ebx, ecx
  00017	33 f6		 xor	 esi, esi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL12@CheckWareD:

; 891  : 	{
; 892  : 		if(!lpUser->pInventory[n].IsItem())

  00020	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	85 c0		 test	 eax, eax
  0002f	74 25		 je	 SHORT $LN11@CheckWareD

; 893  : 		{
; 894  : 			continue;
; 895  : 		}
; 896  : 
; 897  : 		if(!this->CheckItemSerial(lpUser->pInventory[n].m_Type))

  00031	8b 97 24 0e 00
	00		 mov	 edx, DWORD PTR [edi+3620]
  00037	0f bf 4c 32 06	 movsx	 ecx, WORD PTR [edx+esi+6]
  0003c	03 d6		 add	 edx, esi
  0003e	51		 push	 ecx
  0003f	8b cb		 mov	 ecx, ebx
  00041	e8 00 00 00 00	 call	 ?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z ; AntiCheatPlus::CheckItemSerial
  00046	84 c0		 test	 al, al
  00048	74 0c		 je	 SHORT $LN11@CheckWareD

; 898  : 		{
; 899  : 			continue;
; 900  : 		}
; 901  : 
; 902  : 		int iNextSerial = lpUser->pInventory[n].GetNumber();

  0004a	8b ca		 mov	 ecx, edx
  0004c	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 903  : 
; 904  : 		if(ItemSerial == iNextSerial)

  00051	39 45 0c	 cmp	 DWORD PTR _ItemSerial$[ebp], eax
  00054	74 52		 je	 SHORT $LN17@CheckWareD
$LN11@CheckWareD:

; 889  : 
; 890  : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  00056	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  0005c	81 fe 70 c3 00
	00		 cmp	 esi, 50032		; 0000c370H
  00062	7c bc		 jl	 SHORT $LL12@CheckWareD

; 907  : 		}
; 908  : 	}
; 909  : 
; 910  : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  00064	33 db		 xor	 ebx, ebx
  00066	33 f6		 xor	 esi, esi
$LL6@CheckWareD:

; 911  : 	{
; 912  : 		if(WarePos == n)

  00068	39 5d 10	 cmp	 DWORD PTR _WarePos$[ebp], ebx
  0006b	74 23		 je	 SHORT $LN5@CheckWareD

; 913  : 		{
; 914  : 			continue;
; 915  : 		}
; 916  : 
; 917  : 		if(!lpUser->pWarehouse[n].IsItem())

  0006d	8b 8f 5c 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3676]
  00073	03 ce		 add	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0007a	85 c0		 test	 eax, eax
  0007c	74 12		 je	 SHORT $LN5@CheckWareD

; 918  : 		{
; 919  : 			continue;
; 920  : 		}
; 921  : 
; 922  : 		int iNextSerial = lpUser->pWarehouse[n].GetNumber();

  0007e	8b 8f 5c 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3676]
  00084	03 ce		 add	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 923  : 
; 924  : 		if(ItemSerial == iNextSerial)

  0008b	39 45 0c	 cmp	 DWORD PTR _ItemSerial$[ebp], eax
  0008e	74 18		 je	 SHORT $LN17@CheckWareD
$LN5@CheckWareD:

; 907  : 		}
; 908  : 	}
; 909  : 
; 910  : 	for(int n = 0; n < WAREHOUSE_SIZE; n++)

  00090	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00096	43		 inc	 ebx
  00097	81 fe c0 c6 00
	00		 cmp	 esi, 50880		; 0000c6c0H
  0009d	7c c9		 jl	 SHORT $LL6@CheckWareD

; 925  : 		{
; 926  : 			return false;
; 927  : 		}
; 928  : 	}
; 929  : 
; 930  : 	return true;

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	b0 01		 mov	 al, 1
  000a3	5b		 pop	 ebx

; 931  : }

  000a4	5d		 pop	 ebp
  000a5	c2 0c 00	 ret	 12			; 0000000cH
$LN17@CheckWareD:
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 905  : 		{
; 906  : 			return false;

  000aa	32 c0		 xor	 al, al
  000ac	5b		 pop	 ebx

; 931  : }

  000ad	5d		 pop	 ebp
  000ae	c2 0c 00	 ret	 12			; 0000000cH
?CheckWareDupe@AntiCheatPlus@@QAE_NHHH@Z ENDP		; AntiCheatPlus::CheckWareDupe
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@V?$allocator@UBlockHDD_DATA@@@1@@Z ; std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@V?$allocator@UBlockHDD_DATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@V?$allocator@UBlockHDD_DATA@@@1@@Z PROC ; std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@V?$allocator@UBlockHDD_DATA@@@1@@Z ENDP ; std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEII@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000d	c1 f8 02	 sar	 eax, 2
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@AAU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@AAU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@AAU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Cons_val:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@AAU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA &>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@IPAU1@@Z ; std::_Allocate<BlockHDD_DATA>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T211517 = -12						; size = 12
$T211522 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@IPAU1@@Z PROC ; std::_Allocate<BlockHDD_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T211522[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T211517[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T211522[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T211517[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T211517[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@UBlockHDD_DATA@@@std@@YAPAUBlockHDD_DATA@@IPAU1@@Z ENDP ; std::_Allocate<BlockHDD_DATA>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@ABU3@@Z ; std::allocator<BlockHDD_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@ABU3@@Z PROC ; std::allocator<BlockHDD_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN5@construct@2:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@ABU3@@Z ENDP ; std::allocator<BlockHDD_DATA>::construct
_TEXT	ENDS
PUBLIC	??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<BlockHDD_DATA *,BlockHDD_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<BlockHDD_DATA *,BlockHDD_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 10		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c1 04	 add	 ecx, 4
  00018	83 c0 04	 add	 eax, 4
  0001b	3b ca		 cmp	 ecx, edx
  0001d	75 f2		 jne	 SHORT $LL3@Move
  0001f	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<BlockHDD_DATA *,BlockHDD_DATA *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@@Z ; std::allocator<BlockHDD_DATA>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@@Z PROC ; std::allocator<BlockHDD_DATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@@Z ENDP ; std::allocator<BlockHDD_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@$$QAU3@@Z ; std::allocator<BlockHDD_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@$$QAU3@@Z PROC ; std::allocator<BlockHDD_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@construct@3:

; 203  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@UBlockHDD_DATA@@@std@@QAEXPAUBlockHDD_DATA@@$$QAU3@@Z ENDP ; std::allocator<BlockHDD_DATA>::construct
_TEXT	ENDS
PUBLIC	??_C@_0BE@DHHNDLAO@Warehouse?5Item?5Dupe?$AA@	; `string'
PUBLIC	??_C@_0BE@CPHCFFNO@Inventory?5Item?5Dupe?$AA@	; `string'
PUBLIC	?RunItemDupe@AntiCheatPlus@@QAEXXZ		; AntiCheatPlus::RunItemDupe
EXTRN	?gObjWarehouseDeleteItem@@YAEHH@Z:PROC		; gObjWarehouseDeleteItem
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
;	COMDAT ??_C@_0BE@DHHNDLAO@Warehouse?5Item?5Dupe?$AA@
; File e:\work\tranet_version\gs\gameserver\anticheatplus.cpp
CONST	SEGMENT
??_C@_0BE@DHHNDLAO@Warehouse?5Item?5Dupe?$AA@ DB 'Warehouse Item Dupe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPHCFFNO@Inventory?5Item?5Dupe?$AA@
CONST	SEGMENT
??_C@_0BE@CPHCFFNO@Inventory?5Item?5Dupe?$AA@ DB 'Inventory Item Dupe', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RunItemDupe@AntiCheatPlus@@QAEXXZ
_TEXT	SEGMENT
tv346 = -16						; size = 4
_i$210087 = -12						; size = 4
_aIndex$210069 = -8					; size = 4
_this$ = -4						; size = 4
?RunItemDupe@AntiCheatPlus@@QAEXXZ PROC			; AntiCheatPlus::RunItemDupe, COMDAT
; _this$ = ecx

; 726  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 727  : 	if(!this->ScanItemDupeActive)

  00006	80 79 08 00	 cmp	 BYTE PTR [ecx+8], 0
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	0f 84 cf 01 00
	00		 je	 $LN20@RunItemDup

; 728  : 	{
; 729  : 		return;
; 730  : 	}
; 731  : 
; 732  : 	for(int aIndex = OBJ_STARTUSERINDZT; aIndex < OBJMAX; aIndex++)

  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	bb 00 a7 40 09	 mov	 ebx, 155232000		; 0940a700H
  0001a	57		 push	 edi
  0001b	c7 45 f8 b0 36
	00 00		 mov	 DWORD PTR _aIndex$210069[ebp], 14000 ; 000036b0H
  00022	89 5d f0	 mov	 DWORD PTR tv346[ebp], ebx
  00025	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL22@RunItemDup:

; 733  : 	{
; 734  : 		LPOBJ lpUser = &gObj[aIndex];

  00030	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 735  : 
; 736  : 		if(lpUser->Connected < PLAYER_PLAYING)

  00036	83 7b 04 03	 cmp	 DWORD PTR [ebx+4], 3
  0003a	0f 8c 84 01 00
	00		 jl	 $LN21@RunItemDup

; 737  : 		{
; 738  : 			continue;
; 739  : 		}
; 740  : 
; 741  : 		for(int i = 0; i < INVENTORY_SIZE; i++)

  00040	33 ff		 xor	 edi, edi
  00042	33 f6		 xor	 esi, esi
  00044	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL18@RunItemDup:

; 742  : 		{
; 743  : 			if(!lpUser->pInventory[i].IsItem())

  00050	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00056	03 ce		 add	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	85 c0		 test	 eax, eax
  0005f	74 38		 je	 SHORT $LN17@RunItemDup

; 744  : 			{
; 745  : 				continue;
; 746  : 			}
; 747  : 
; 748  : 			if(!this->CheckItemSerial(lpUser->pInventory[i].m_Type))

  00061	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00067	0f bf 44 0e 06	 movsx	 eax, WORD PTR [esi+ecx+6]
  0006c	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z ; AntiCheatPlus::CheckItemSerial
  00078	84 c0		 test	 al, al
  0007a	74 1d		 je	 SHORT $LN17@RunItemDup

; 749  : 			{
; 750  : 				continue;
; 751  : 			}
; 752  : 
; 753  : 			int iItemSerial = lpUser->pInventory[i].GetNumber();

  0007c	8b ca		 mov	 ecx, edx
  0007e	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 754  : 
; 755  : 			if(iItemSerial == 0)

  00083	85 c0		 test	 eax, eax
  00085	74 12		 je	 SHORT $LN17@RunItemDup

; 756  : 			{
; 757  : 				continue;
; 758  : 			}
; 759  : 
; 760  : 			if(!this->CheckItemDupe(aIndex, iItemSerial, i))

  00087	8b 4d f8	 mov	 ecx, DWORD PTR _aIndex$210069[ebp]
  0008a	57		 push	 edi
  0008b	50		 push	 eax
  0008c	51		 push	 ecx
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?CheckItemDupe@AntiCheatPlus@@QAE_NHHH@Z ; AntiCheatPlus::CheckItemDupe
  00095	84 c0		 test	 al, al
  00097	74 11		 je	 SHORT $LN29@RunItemDup
$LN17@RunItemDup:

; 737  : 		{
; 738  : 			continue;
; 739  : 		}
; 740  : 
; 741  : 		for(int i = 0; i < INVENTORY_SIZE; i++)

  00099	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  0009f	47		 inc	 edi
  000a0	81 fe 70 c3 00
	00		 cmp	 esi, 50032		; 0000c370H
  000a6	7c a8		 jl	 SHORT $LL18@RunItemDup

; 800  : 			{
; 801  : 				continue;
; 802  : 			}
; 803  : 
; 804  : 			if(!this->CheckWareDupe(aIndex, iNextSerial, i))

  000a8	eb 71		 jmp	 SHORT $LN35@RunItemDup
$LN29@RunItemDup:

; 761  : 			{
; 762  : 				GCServerMsgStringSend("..:: Anti-Cheat ::..", aIndex, 0);

  000aa	8b 75 f8	 mov	 esi, DWORD PTR _aIndex$210069[ebp]
  000ad	6a 00		 push	 0
  000af	56		 push	 esi
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
  000b5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 763  : 				GCServerMsgStringSend("Inventory Item Dupe", aIndex, 0);

  000ba	6a 00		 push	 0
  000bc	56		 push	 esi
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CPHCFFNO@Inventory?5Item?5Dupe?$AA@
  000c2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 764  : 
; 765  : 				if(this->ScanItemDupeClean)

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ca	83 c4 18	 add	 esp, 24			; 00000018H
  000cd	80 7a 0a 00	 cmp	 BYTE PTR [edx+10], 0
  000d1	74 32		 je	 SHORT $LN11@RunItemDup

; 766  : 				{
; 767  : 					gObjInventoryItemSet(lpUser->m_Index, i, -1);

  000d3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d5	68 ff 00 00 00	 push	 255			; 000000ffH
  000da	57		 push	 edi
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 768  : 					lpUser->pInventory[i].Clear();

  000e1	8b cf		 mov	 ecx, edi
  000e3	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  000e9	03 8b 24 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3620]
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 769  : 					GCInventoryItemDeleteSend(lpUser->m_Index, i, 1);

  000f7	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f9	6a 01		 push	 1
  000fb	57		 push	 edi
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@RunItemDup:

; 770  : 				}
; 771  : 
; 772  : 				if(this->ScanItemDupeDisconnect)

  00105	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00108	80 7a 09 00	 cmp	 BYTE PTR [edx+9], 0
  0010c	74 0d		 je	 SHORT $LN35@RunItemDup

; 773  : 				{
; 774  : 					#ifdef _RECONNECT_				
; 775  : 					g_ConnectZt.SendClose(aIndex,NORM_DC);

  0010e	6a 00		 push	 0
  00110	56		 push	 esi
  00111	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00116	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
$LN35@RunItemDup:

; 776  : 					#else
; 777  : 					CloseClient(UserIndex);
; 778  : 					#endif		
; 779  : 				}
; 780  : 
; 781  : 				break;	
; 782  : 			}
; 783  : 		}
; 784  : 
; 785  : 		for(int i = 0; i < WAREHOUSE_SIZE; i++)

  0011b	33 f6		 xor	 esi, esi
  0011d	89 75 f4	 mov	 DWORD PTR _i$210087[ebp], esi
$LL9@RunItemDup:

; 786  : 		{
; 787  : 			if(!lpUser->pWarehouse[i].IsItem())

  00120	8b 8b 5c 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3676]
  00126	03 ce		 add	 ecx, esi
  00128	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0012d	85 c0		 test	 eax, eax
  0012f	74 3a		 je	 SHORT $LN8@RunItemDup

; 788  : 			{
; 789  : 				continue;
; 790  : 			}
; 791  : 
; 792  : 			if(!this->CheckItemSerial(lpUser->pWarehouse[i].m_Type))

  00131	8b 93 5c 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3676]
  00137	0f bf 4c 32 06	 movsx	 ecx, WORD PTR [edx+esi+6]
  0013c	03 d6		 add	 edx, esi
  0013e	51		 push	 ecx
  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00142	e8 00 00 00 00	 call	 ?CheckItemSerial@AntiCheatPlus@@QAE_NH@Z ; AntiCheatPlus::CheckItemSerial
  00147	84 c0		 test	 al, al
  00149	74 20		 je	 SHORT $LN8@RunItemDup

; 793  : 			{
; 794  : 				continue;
; 795  : 			}
; 796  : 
; 797  : 			int iNextSerial = lpUser->pWarehouse[i].GetNumber();

  0014b	8b ca		 mov	 ecx, edx
  0014d	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 798  : 
; 799  : 			if(iNextSerial == 0)

  00152	85 c0		 test	 eax, eax
  00154	74 15		 je	 SHORT $LN8@RunItemDup

; 800  : 			{
; 801  : 				continue;
; 802  : 			}
; 803  : 
; 804  : 			if(!this->CheckWareDupe(aIndex, iNextSerial, i))

  00156	8b 55 f4	 mov	 edx, DWORD PTR _i$210087[ebp]
  00159	8b 7d f8	 mov	 edi, DWORD PTR _aIndex$210069[ebp]
  0015c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	52		 push	 edx
  00160	50		 push	 eax
  00161	57		 push	 edi
  00162	e8 00 00 00 00	 call	 ?CheckWareDupe@AntiCheatPlus@@QAE_NHHH@Z ; AntiCheatPlus::CheckWareDupe
  00167	84 c0		 test	 al, al
  00169	74 13		 je	 SHORT $LN30@RunItemDup
$LN8@RunItemDup:

; 776  : 					#else
; 777  : 					CloseClient(UserIndex);
; 778  : 					#endif		
; 779  : 				}
; 780  : 
; 781  : 				break;	
; 782  : 			}
; 783  : 		}
; 784  : 
; 785  : 		for(int i = 0; i < WAREHOUSE_SIZE; i++)

  0016b	ff 45 f4	 inc	 DWORD PTR _i$210087[ebp]
  0016e	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00174	81 fe c0 c6 00
	00		 cmp	 esi, 50880		; 0000c6c0H
  0017a	7c a4		 jl	 SHORT $LL9@RunItemDup

; 800  : 			{
; 801  : 				continue;
; 802  : 			}
; 803  : 
; 804  : 			if(!this->CheckWareDupe(aIndex, iNextSerial, i))

  0017c	eb 46		 jmp	 SHORT $LN21@RunItemDup
$LN30@RunItemDup:

; 805  : 			{
; 806  : 				GCServerMsgStringSend("..:: Anti-Cheat ::..", aIndex, 0);

  0017e	6a 00		 push	 0
  00180	57		 push	 edi
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
  00186	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 807  : 				GCServerMsgStringSend("Warehouse Item Dupe", aIndex, 0);

  0018b	6a 00		 push	 0
  0018d	57		 push	 edi
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DHHNDLAO@Warehouse?5Item?5Dupe?$AA@
  00193	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 808  : 
; 809  : 				if(this->ScanItemDupeClean)

  00198	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0019b	83 c4 18	 add	 esp, 24			; 00000018H
  0019e	80 7e 0a 00	 cmp	 BYTE PTR [esi+10], 0
  001a2	74 0d		 je	 SHORT $LN2@RunItemDup

; 810  : 				{
; 811  : 					//gObjInventoryItemSet(lpUser->m_Index, i, -1);
; 812  : 					//lpUser->pWarehouse[i].Clear();
; 813  : 					//GCInventoryItemDeleteSend(lpUser->m_Index, i, 1);
; 814  : 					gObjWarehouseDeleteItem(aIndex,i);

  001a4	8b 45 f4	 mov	 eax, DWORD PTR _i$210087[ebp]
  001a7	50		 push	 eax
  001a8	57		 push	 edi
  001a9	e8 00 00 00 00	 call	 ?gObjWarehouseDeleteItem@@YAEHH@Z ; gObjWarehouseDeleteItem
  001ae	83 c4 08	 add	 esp, 8
$LN2@RunItemDup:

; 815  : 				}
; 816  : 
; 817  : 				if(this->ScanItemDupeDisconnect)

  001b1	80 7e 09 00	 cmp	 BYTE PTR [esi+9], 0
  001b5	74 0d		 je	 SHORT $LN21@RunItemDup

; 818  : 				{
; 819  : 					#ifdef _RECONNECT_				
; 820  : 					g_ConnectZt.SendClose(aIndex,NORM_DC);

  001b7	6a 00		 push	 0
  001b9	57		 push	 edi
  001ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  001bf	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
$LN21@RunItemDup:

; 728  : 	{
; 729  : 		return;
; 730  : 	}
; 731  : 
; 732  : 	for(int aIndex = OBJ_STARTUSERINDZT; aIndex < OBJMAX; aIndex++)

  001c4	8b 5d f0	 mov	 ebx, DWORD PTR tv346[ebp]
  001c7	ff 45 f8	 inc	 DWORD PTR _aIndex$210069[ebp]
  001ca	81 c3 50 2b 00
	00		 add	 ebx, 11088		; 00002b50H
  001d0	89 5d f0	 mov	 DWORD PTR tv346[ebp], ebx
  001d3	81 fb 80 d7 e9
	09		 cmp	 ebx, 166320000		; 09e9d780H
  001d9	0f 8c 51 fe ff
	ff		 jl	 $LL22@RunItemDup
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5b		 pop	 ebx
$LN20@RunItemDup:

; 821  : 					#else
; 822  : 					CloseClient(UserIndex);
; 823  : 					#endif		
; 824  : 				}
; 825  : 
; 826  : 				break;	
; 827  : 			}
; 828  : 		}
; 829  : 	}
; 830  : }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c3		 ret	 0
?RunItemDupe@AntiCheatPlus@@QAEXXZ ENDP			; AntiCheatPlus::RunItemDupe
_TEXT	ENDS
PUBLIC	??0?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Vector_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Vector_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QAE@PAUBlockHDD_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::_Vector_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BlockHDD_DATA,std::allocator<BlockHDD_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UBlockHDD_DATA@@@std@@QAEPAUBlockHDD_DATA@@I@Z ; std::allocator<BlockHDD_DATA>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UBlockHDD_DATA@@@std@@QAEPAUBlockHDD_DATA@@I@Z
_TEXT	SEGMENT
$T211637 = -12						; size = 12
$T211635 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UBlockHDD_DATA@@@std@@QAEPAUBlockHDD_DATA@@I@Z PROC ; std::allocator<BlockHDD_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T211635[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T211637[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T211635[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T211637[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T211637[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@UBlockHDD_DATA@@@std@@QAEPAUBlockHDD_DATA@@I@Z ENDP ; std::allocator<BlockHDD_DATA>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@ABU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@ABU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@ABU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Cons_val@2:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@ABU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00@Z ; std::_Move<BlockHDD_DATA *,BlockHDD_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00@Z PROC ; std::_Move<BlockHDD_DATA *,BlockHDD_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 10		 je	 SHORT $LN5@Move@2
  00010	56		 push	 esi
$LL7@Move@2:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	83 c1 04	 add	 ecx, 4
  00018	83 c0 04	 add	 eax, 4
  0001b	3b ca		 cmp	 ecx, edx
  0001d	75 f2		 jne	 SHORT $LL7@Move@2
  0001f	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Move@PAUBlockHDD_DATA@@PAU1@@std@@YAPAUBlockHDD_DATA@@PAU1@00@Z ENDP ; std::_Move<BlockHDD_DATA *,BlockHDD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@@Z ; std::_Dest_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@@Z PROC ; std::_Dest_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@U3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@U3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@U3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Cons_val@3:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@U3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<BlockHDD_DATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA>,BlockHDD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA>,BlockHDD_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@U3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA>
  0001e	83 c6 04	 add	 esi, 4
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 04	 add	 edi, 4
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA>,BlockHDD_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BlockHDD_DATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAXPAUBlockHDD_DATA@@0AAV?$allocator@UBlockHDD_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@@Z ; std::_Uninitialized_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@@Z
_TEXT	SEGMENT
__Cat$211829 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@@Z PROC ; std::_Uninitialized_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$211829[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA>,BlockHDD_DATA>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXPAUBlockHDD_DATA@@0@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXPAUBlockHDD_DATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXPAUBlockHDD_DATA@@0@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXPAUBlockHDD_DATA@@0@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUBlockHDD_DATA@@@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEPAUBlockHDD_DATA@@PAU2@00@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Umove<BlockHDD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUBlockHDD_DATA@@@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEPAUBlockHDD_DATA@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$211851 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUBlockHDD_DATA@@@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEPAUBlockHDD_DATA@@PAU2@00@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Umove<BlockHDD_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$211851[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA>,BlockHDD_DATA>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUBlockHDD_DATA@@@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEPAUBlockHDD_DATA@@PAU2@00@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Umove<BlockHDD_DATA *>
_TEXT	ENDS
PUBLIC	?erase@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@0@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 20		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 14		 je	 SHORT $LN30@erase
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	83 c2 04	 add	 edx, 4
  00027	83 c6 04	 add	 esi, 4
  0002a	3b d7		 cmp	 edx, edi
  0002c	75 f2		 jne	 SHORT $LL32@erase
  0002e	5b		 pop	 ebx
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  0002f	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00032	5f		 pop	 edi
$LN1@erase:
  00033	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXXZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::reserve
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$210392 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$212022 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 02	 sar	 ecx, 2
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UBlockHDD_DATA@@@std@@QAEPAUBlockHDD_DATA@@I@Z ; std::allocator<BlockHDD_DATA>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$212022[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$210392[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBlockHDD_DATA@@PAU1@V?$allocator@UBlockHDD_DATA@@@std@@U1@@std@@YAPAUBlockHDD_DATA@@PAU1@00AAV?$allocator@UBlockHDD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BlockHDD_DATA *,BlockHDD_DATA *,std::allocator<BlockHDD_DATA>,BlockHDD_DATA>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 02	 sar	 edi, 2

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 bb	 lea	 edx, DWORD PTR [ebx+edi*4]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$210392[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::reserve
PUBLIC	??1?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::~vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::~vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::~vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXXZ ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::clear, COMDAT
; _this$ = ecx

; 1218 : 		erase(begin(), end());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	8b 31		 mov	 esi, DWORD PTR [ecx]
  00006	3b f2		 cmp	 esi, edx
  00008	74 19		 je	 SHORT $LN19@clear
  0000a	8b c2		 mov	 eax, edx
  0000c	3b d2		 cmp	 edx, edx
  0000e	74 10		 je	 SHORT $LN48@clear
  00010	57		 push	 edi
$LL50@clear:
  00011	8b 38		 mov	 edi, DWORD PTR [eax]
  00013	89 3e		 mov	 DWORD PTR [esi], edi
  00015	83 c0 04	 add	 eax, 4
  00018	83 c6 04	 add	 esi, 4
  0001b	3b c2		 cmp	 eax, edx
  0001d	75 f2		 jne	 SHORT $LL50@clear
  0001f	5f		 pop	 edi
$LN48@clear:
  00020	89 71 04	 mov	 DWORD PTR [ecx+4], esi
$LN19@clear:
  00023	5e		 pop	 esi

; 1219 : 		}

  00024	c3		 ret	 0
?clear@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  00014	c1 f8 02	 sar	 eax, 2
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 02	 sar	 edx, 2
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::reserve
$LN1@Reserve:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	??0AntiCheatPlus@@QAE@XZ			; AntiCheatPlus::AntiCheatPlus
; Function compile flags: /Ogtp
;	COMDAT ??0AntiCheatPlus@@QAE@XZ
_TEXT	SEGMENT
??0AntiCheatPlus@@QAE@XZ PROC				; AntiCheatPlus::AntiCheatPlus, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 88 30 00 01
	00		 mov	 DWORD PTR [eax+65584], ecx
  0000a	89 88 34 00 01
	00		 mov	 DWORD PTR [eax+65588], ecx
  00010	89 88 38 00 01
	00		 mov	 DWORD PTR [eax+65592], ecx
  00016	c3		 ret	 0
??0AntiCheatPlus@@QAE@XZ ENDP				; AntiCheatPlus::AntiCheatPlus
_TEXT	ENDS
PUBLIC	??1AntiCheatPlus@@QAE@XZ			; AntiCheatPlus::~AntiCheatPlus
; Function compile flags: /Ogtp
;	COMDAT ??1AntiCheatPlus@@QAE@XZ
_TEXT	SEGMENT
??1AntiCheatPlus@@QAE@XZ PROC				; AntiCheatPlus::~AntiCheatPlus, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 86 30 00 01
	00		 mov	 eax, DWORD PTR [esi+65584]
  00009	85 c0		 test	 eax, eax
  0000b	74 09		 je	 SHORT $LN11@AntiCheatP
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00013	83 c4 04	 add	 esp, 4
$LN11@AntiCheatP:
  00016	c7 86 30 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65584], 0
  00020	c7 86 34 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65588], 0
  0002a	c7 86 38 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65592], 0
  00034	5e		 pop	 esi
  00035	c3		 ret	 0
??1AntiCheatPlus@@QAE@XZ ENDP				; AntiCheatPlus::~AntiCheatPlus
_TEXT	ENDS
PUBLIC	?Init@AntiCheatPlus@@QAEXXZ			; AntiCheatPlus::Init
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\anticheatplus.cpp
;	COMDAT ?Init@AntiCheatPlus@@QAEXXZ
_TEXT	SEGMENT
?Init@AntiCheatPlus@@QAEXXZ PROC			; AntiCheatPlus::Init, COMDAT
; _this$ = ecx

; 22   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 23   : 	ZeroMemory(&this->TitleName, sizeof(this->TitleName));

  00004	68 00 40 00 00	 push	 16384			; 00004000H
  00009	33 db		 xor	 ebx, ebx
  0000b	8d 46 16	 lea	 eax, DWORD PTR [esi+22]
  0000e	53		 push	 ebx
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _memset

; 24   : 	ZeroMemory(&this->ClassName, sizeof(this->ClassName));

  00015	68 00 40 00 00	 push	 16384			; 00004000H
  0001a	8d 8e 16 40 00
	00		 lea	 ecx, DWORD PTR [esi+16406]
  00020	53		 push	 ebx
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _memset

; 25   : 	ZeroMemory(&this->InjectName, sizeof(this->InjectName));

  00027	68 00 40 00 00	 push	 16384			; 00004000H
  0002c	8d 96 16 80 00
	00		 lea	 edx, DWORD PTR [esi+32790]
  00032	53		 push	 ebx
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _memset

; 26   : 	ZeroMemory(&this->ProcessName, sizeof(this->ProcessName));

  00039	68 00 40 00 00	 push	 16384			; 00004000H
  0003e	8d 86 16 c0 00
	00		 lea	 eax, DWORD PTR [esi+49174]
  00044	53		 push	 ebx
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _memset

; 27   : 
; 28   : 	//ZeroMemory(&this->blockhdd, sizeof(this->blockhdd));
; 29   : 	this->blockhdd.clear();

  0004b	8b 96 30 00 01
	00		 mov	 edx, DWORD PTR [esi+65584]
  00051	8b 86 34 00 01
	00		 mov	 eax, DWORD PTR [esi+65588]
  00057	83 c4 30	 add	 esp, 48			; 00000030H
  0005a	3b d0		 cmp	 edx, eax
  0005c	74 1c		 je	 SHORT $LN21@Init
  0005e	8b c8		 mov	 ecx, eax
  00060	3b c0		 cmp	 eax, eax
  00062	74 10		 je	 SHORT $LN50@Init
  00064	57		 push	 edi
$LL52@Init:
  00065	8b 39		 mov	 edi, DWORD PTR [ecx]
  00067	89 3a		 mov	 DWORD PTR [edx], edi
  00069	83 c1 04	 add	 ecx, 4
  0006c	83 c2 04	 add	 edx, 4
  0006f	3b c8		 cmp	 ecx, eax
  00071	75 f2		 jne	 SHORT $LL52@Init
  00073	5f		 pop	 edi
$LN50@Init:
  00074	89 96 34 00 01
	00		 mov	 DWORD PTR [esi+65588], edx
$LN21@Init:

; 30   : #if(ANTI_CHEAT_PLUS_CRC)
; 31   : 	this->CrcData.clear();
; 32   : #endif
; 33   : 
; 34   : 	this->TitleCount = 0;
; 35   : 	this->ClassCount = 0;
; 36   : 	this->InjectCount = 0;
; 37   : 	this->ProcessCount = 0;
; 38   : 
; 39   : 	this->Enable = false;
; 40   : 
; 41   : 	this->DumpActive = false;
; 42   : 	this->TitleActive = false;
; 43   : 	this->ClassActive = false;
; 44   : 	this->InjectActive = false;
; 45   : 	this->ProcessActive = false;
; 46   : 	this->EliteActive = true;
; 47   : 	this->MultiWindows = true;
; 48   : #if(ANTI_CHEAT_PLUS_CRC)
; 49   : 	this->CRCActive = false;
; 50   : #endif
; 51   : 
; 52   : 	this->DumpTime = 10000;
; 53   : 	this->TitleTime = 10000;
; 54   : 	this->ClassTime = 10000;
; 55   : 	this->InjectTime = 10000;
; 56   : 	this->ProcessTime = 10000;

  0007a	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  0007f	89 9e 18 00 01
	00		 mov	 DWORD PTR [esi+65560], ebx
  00085	89 9e 1c 00 01
	00		 mov	 DWORD PTR [esi+65564], ebx
  0008b	89 9e 20 00 01
	00		 mov	 DWORD PTR [esi+65568], ebx
  00091	89 9e 24 00 01
	00		 mov	 DWORD PTR [esi+65572], ebx
  00097	89 1e		 mov	 DWORD PTR [esi], ebx
  00099	c7 46 04 00 00
	01 01		 mov	 DWORD PTR [esi+4], 16842752 ; 01010000H
  000a0	c7 46 0c 10 27
	10 27		 mov	 DWORD PTR [esi+12], 655370000 ; 27102710H
  000a7	c7 46 10 10 27
	10 27		 mov	 DWORD PTR [esi+16], 655370000 ; 27102710H
  000ae	66 89 56 14	 mov	 WORD PTR [esi+20], dx
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 57   : }

  000b4	c3		 ret	 0
?Init@AntiCheatPlus@@QAEXXZ ENDP			; AntiCheatPlus::Init
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXABUBlockHDD_DATA@@@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::push_back
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXABUBlockHDD_DATA@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXABUBlockHDD_DATA@@@Z PROC ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@AAU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@ABU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXABUBlockHDD_DATA@@@Z ENDP ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ReadBlockHdd@AntiCheatPlus@@QAEXPAD@Z		; AntiCheatPlus::ReadBlockHdd
EXTRN	_sscanf_s:PROC
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\anticheatplus.cpp
CONST	ENDS
;	COMDAT ?ReadBlockHdd@AntiCheatPlus@@QAEXPAD@Z
_TEXT	SEGMENT
_this$GSCopy$ = -268					; size = 4
_List$209931 = -264					; size = 4
_szHwnd$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?ReadBlockHdd@AntiCheatPlus@@QAEXPAD@Z PROC		; AntiCheatPlus::ReadBlockHdd, COMDAT
; _this$ = ecx

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]

; 188  : 	char szHwnd[256] = { 0 };

  00017	68 ff 00 00 00	 push	 255			; 000000ffH
  0001c	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _szHwnd$[ebp+1]
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  0002b	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR _szHwnd$[ebp], 0
  00032	e8 00 00 00 00	 call	 _memset

; 189  : 
; 190  : 	SMDFile = fopen(filename, "r");

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _fopen
  00042	83 c4 14	 add	 esp, 20			; 00000014H
  00045	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 191  : 
; 192  : 	if( SMDFile == NULL )

  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 c8 01 00
	00		 je	 $LN6@ReadBlockH

; 193  : 	{
; 194  : 		return;
; 195  : 	}
; 196  : 
; 197  : 	while(true)
; 198  : 	{
; 199  : 		SMDToken Token = GetToken();

  00052	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 200  : 
; 201  : 		if( Token == END || !strcmp(TokenString, "end") )

  00057	83 f8 02	 cmp	 eax, 2
  0005a	0f 84 a2 01 00
	00		 je	 $LN1@ReadBlockH
  00060	53		 push	 ebx
  00061	bb 04 00 00 00	 mov	 ebx, 4
  00066	57		 push	 edi
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL4@ReadBlockH:
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00075	b8 00 00 00 00	 mov	 eax, OFFSET _TokenString
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL99@ReadBlockH:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN100@ReadBlockH
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN101@ReadBlockH
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN100@ReadBlockH
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL99@ReadBlockH
$LN101@ReadBlockH:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN102@ReadBlockH
$LN100@ReadBlockH:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 d8 ff	 sbb	 eax, -1
$LN102@ReadBlockH:
  000a5	85 c0		 test	 eax, eax
  000a7	0f 84 53 01 00
	00		 je	 $LN105@ReadBlockH

; 202  : 		{
; 203  : 			break;
; 204  : 		}
; 205  : 
; 206  : 		BlockHDD_DATA List;
; 207  : 
; 208  : 		memcpy(szHwnd, TokenString, sizeof(szHwnd));

  000ad	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000b2	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  000b7	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR _szHwnd$[ebp]
  000bd	f3 a5		 rep movsd

; 209  : 
; 210  : 		sscanf_s(szHwnd, "%u", &List.hddid);

  000bf	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _List$209931[ebp]
  000c5	51		 push	 ecx
  000c6	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szHwnd$[ebp]
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
  000d1	52		 push	 edx
  000d2	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _List$209931[ebp], 0
  000dc	e8 00 00 00 00	 call	 _sscanf_s

; 211  : 
; 212  : 		this->blockhdd.push_back(List);

  000e1	8b b5 f4 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  000e7	8b 86 34 00 01
	00		 mov	 eax, DWORD PTR [esi+65588]
  000ed	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _List$209931[ebp]
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	3b c8		 cmp	 ecx, eax
  000f8	0f 83 80 00 00
	00		 jae	 $LN13@ReadBlockH
  000fe	8b 96 30 00 01
	00		 mov	 edx, DWORD PTR [esi+65584]
  00104	3b d1		 cmp	 edx, ecx
  00106	77 76		 ja	 SHORT $LN13@ReadBlockH
  00108	8b f9		 mov	 edi, ecx
  0010a	8b 8e 38 00 01
	00		 mov	 ecx, DWORD PTR [esi+65592]
  00110	2b fa		 sub	 edi, edx
  00112	c1 ff 02	 sar	 edi, 2
  00115	3b c1		 cmp	 eax, ecx
  00117	75 46		 jne	 SHORT $LN24@ReadBlockH
  00119	2b c2		 sub	 eax, edx
  0011b	c1 f8 02	 sar	 eax, 2
  0011e	3d fe ff ff 3f	 cmp	 eax, 1073741822		; 3ffffffeH
  00123	0f 87 02 01 00
	00		 ja	 $LN96@ReadBlockH
  00129	2b ca		 sub	 ecx, edx
  0012b	40		 inc	 eax
  0012c	c1 f9 02	 sar	 ecx, 2
  0012f	3b c1		 cmp	 eax, ecx
  00131	76 2c		 jbe	 SHORT $LN24@ReadBlockH
  00133	8b d1		 mov	 edx, ecx
  00135	d1 ea		 shr	 edx, 1
  00137	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  0013c	2b da		 sub	 ebx, edx
  0013e	3b d9		 cmp	 ebx, ecx
  00140	73 04		 jae	 SHORT $LN46@ReadBlockH
  00142	33 c9		 xor	 ecx, ecx
  00144	eb 02		 jmp	 SHORT $LN47@ReadBlockH
$LN46@ReadBlockH:
  00146	03 ca		 add	 ecx, edx
$LN47@ReadBlockH:
  00148	3b c8		 cmp	 ecx, eax
  0014a	73 02		 jae	 SHORT $LN43@ReadBlockH
  0014c	8b c8		 mov	 ecx, eax
$LN43@ReadBlockH:
  0014e	51		 push	 ecx
  0014f	8d 8e 30 00 01
	00		 lea	 ecx, DWORD PTR [esi+65584]
  00155	e8 00 00 00 00	 call	 ?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::reserve
  0015a	bb 04 00 00 00	 mov	 ebx, 4
$LN24@ReadBlockH:
  0015f	8b 96 30 00 01
	00		 mov	 edx, DWORD PTR [esi+65584]
  00165	8b 8e 34 00 01
	00		 mov	 ecx, DWORD PTR [esi+65588]
  0016b	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
  0016e	50		 push	 eax
  0016f	51		 push	 ecx
  00170	8d 96 3c 00 01
	00		 lea	 edx, DWORD PTR [esi+65596]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@AAU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA &>
  0017c	eb 6b		 jmp	 SHORT $LN107@ReadBlockH
$LN13@ReadBlockH:
  0017e	8b 8e 38 00 01
	00		 mov	 ecx, DWORD PTR [esi+65592]
  00184	3b c1		 cmp	 eax, ecx
  00186	75 47		 jne	 SHORT $LN59@ReadBlockH
  00188	8b 96 30 00 01
	00		 mov	 edx, DWORD PTR [esi+65584]
  0018e	2b c2		 sub	 eax, edx
  00190	c1 f8 02	 sar	 eax, 2
  00193	3d fe ff ff 3f	 cmp	 eax, 1073741822		; 3ffffffeH
  00198	0f 87 8d 00 00
	00		 ja	 $LN96@ReadBlockH
  0019e	2b ca		 sub	 ecx, edx
  001a0	40		 inc	 eax
  001a1	c1 f9 02	 sar	 ecx, 2
  001a4	3b c1		 cmp	 eax, ecx
  001a6	76 27		 jbe	 SHORT $LN59@ReadBlockH
  001a8	8b d1		 mov	 edx, ecx
  001aa	d1 ea		 shr	 edx, 1
  001ac	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  001b1	2b fa		 sub	 edi, edx
  001b3	3b f9		 cmp	 edi, ecx
  001b5	73 04		 jae	 SHORT $LN81@ReadBlockH
  001b7	33 c9		 xor	 ecx, ecx
  001b9	eb 02		 jmp	 SHORT $LN82@ReadBlockH
$LN81@ReadBlockH:
  001bb	03 ca		 add	 ecx, edx
$LN82@ReadBlockH:
  001bd	3b c8		 cmp	 ecx, eax
  001bf	73 02		 jae	 SHORT $LN78@ReadBlockH
  001c1	8b c8		 mov	 ecx, eax
$LN78@ReadBlockH:
  001c3	51		 push	 ecx
  001c4	8d 8e 30 00 01
	00		 lea	 ecx, DWORD PTR [esi+65584]
  001ca	e8 00 00 00 00	 call	 ?reserve@?$vector@UBlockHDD_DATA@@V?$allocator@UBlockHDD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<BlockHDD_DATA,std::allocator<BlockHDD_DATA> >::reserve
$LN59@ReadBlockH:
  001cf	8b 8e 34 00 01
	00		 mov	 ecx, DWORD PTR [esi+65588]
  001d5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _List$209931[ebp]
  001db	50		 push	 eax
  001dc	51		 push	 ecx
  001dd	8d 96 3c 00 01
	00		 lea	 edx, DWORD PTR [esi+65596]
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBlockHDD_DATA@@@std@@UBlockHDD_DATA@@ABU3@@std@@YAXAAV?$allocator@UBlockHDD_DATA@@@0@PAUBlockHDD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<BlockHDD_DATA>,BlockHDD_DATA,BlockHDD_DATA const &>
$LN107@ReadBlockH:
  001e9	01 9e 34 00 01
	00		 add	 DWORD PTR [esi+65588], ebx
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001f7	83 f8 02	 cmp	 eax, 2
  001fa	0f 85 70 fe ff
	ff		 jne	 $LL4@ReadBlockH
$LN105@ReadBlockH:
  00200	5f		 pop	 edi
  00201	5b		 pop	 ebx
$LN1@ReadBlockH:

; 213  : 	}
; 214  : 
; 215  : 	fclose(SMDFile);

  00202	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00207	50		 push	 eax
  00208	e8 00 00 00 00	 call	 _fclose
  0020d	83 c4 04	 add	 esp, 4

; 216  : 	SMDFile = NULL;

  00210	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SMDFile, 0
$LN6@ReadBlockH:

; 217  : }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	33 cd		 xor	 ecx, ebp
  0021f	5e		 pop	 esi
  00220	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c2 04 00	 ret	 4
$LN96@ReadBlockH:

; 211  : 
; 212  : 		this->blockhdd.push_back(List);

  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00230	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN108@ReadBlockH:
$LN106@ReadBlockH:
  00235	cc		 int	 3
?ReadBlockHdd@AntiCheatPlus@@QAEXPAD@Z ENDP		; AntiCheatPlus::ReadBlockHdd
_TEXT	ENDS
PUBLIC	??_C@_0CE@CGPBJLBI@?4?4?2AntiCheat?2BlackList?2HDD_Data?4@ ; `string'
PUBLIC	??_C@_0CI@IMANMEJK@?4?4?2AntiCheat?2CheatBase?2ProcessCh@ ; `string'
PUBLIC	??_C@_0CH@HGOBGJCL@?4?4?2AntiCheat?2CheatBase?2InjectChe@ ; `string'
PUBLIC	??_C@_0CG@IDFNCNLL@?4?4?2AntiCheat?2CheatBase?2ClassChea@ ; `string'
PUBLIC	??_C@_0CG@EJHKLKEP@?4?4?2AntiCheat?2CheatBase?2TitleChea@ ; `string'
PUBLIC	??_C@_0BP@FBLBMIMG@?4?4?2AntiCheat?2AntiCheatMain?4ini?$AA@ ; `string'
PUBLIC	?Load@AntiCheatPlus@@QAEXXZ			; AntiCheatPlus::Load
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
;	COMDAT ??_C@_0CE@CGPBJLBI@?4?4?2AntiCheat?2BlackList?2HDD_Data?4@
CONST	SEGMENT
??_C@_0CE@CGPBJLBI@?4?4?2AntiCheat?2BlackList?2HDD_Data?4@ DB '..\AntiChe'
	DB	'at\BlackList\HDD_Data.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IMANMEJK@?4?4?2AntiCheat?2CheatBase?2ProcessCh@
CONST	SEGMENT
??_C@_0CI@IMANMEJK@?4?4?2AntiCheat?2CheatBase?2ProcessCh@ DB '..\AntiChea'
	DB	't\CheatBase\ProcessCheat.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HGOBGJCL@?4?4?2AntiCheat?2CheatBase?2InjectChe@
CONST	SEGMENT
??_C@_0CH@HGOBGJCL@?4?4?2AntiCheat?2CheatBase?2InjectChe@ DB '..\AntiChea'
	DB	't\CheatBase\InjectCheat.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IDFNCNLL@?4?4?2AntiCheat?2CheatBase?2ClassChea@
CONST	SEGMENT
??_C@_0CG@IDFNCNLL@?4?4?2AntiCheat?2CheatBase?2ClassChea@ DB '..\AntiChea'
	DB	't\CheatBase\ClassCheat.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EJHKLKEP@?4?4?2AntiCheat?2CheatBase?2TitleChea@
CONST	SEGMENT
??_C@_0CG@EJHKLKEP@?4?4?2AntiCheat?2CheatBase?2TitleChea@ DB '..\AntiChea'
	DB	't\CheatBase\TitleCheat.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FBLBMIMG@?4?4?2AntiCheat?2AntiCheatMain?4ini?$AA@
CONST	SEGMENT
??_C@_0BP@FBLBMIMG@?4?4?2AntiCheat?2AntiCheatMain?4ini?$AA@ DB '..\AntiCh'
	DB	'eat\AntiCheatMain.ini', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@AntiCheatPlus@@QAEXXZ
_TEXT	SEGMENT
?Load@AntiCheatPlus@@QAEXXZ PROC			; AntiCheatPlus::Load, COMDAT
; _this$ = ecx

; 61   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 62   : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@AntiCheatPlus@@QAEXXZ ; AntiCheatPlus::Init

; 63   : 
; 64   : 	if(!g_ZtLicense.user.AntiCheatPlus)

  00008	80 3d da 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+218, 0
  0000f	74 50		 je	 SHORT $LN2@Load

; 65   : 	{
; 66   : 		return;
; 67   : 	}
; 68   : 	
; 69   : 	this->ReadConfig("..\\AntiCheat\\AntiCheatMain.ini");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FBLBMIMG@?4?4?2AntiCheat?2AntiCheatMain?4ini?$AA@
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?ReadConfig@AntiCheatPlus@@QAEXPAD@Z ; AntiCheatPlus::ReadConfig

; 70   : 	this->Read(eTitleType, "..\\AntiCheat\\CheatBase\\TitleCheat.txt");

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EJHKLKEP@?4?4?2AntiCheat?2CheatBase?2TitleChea@
  00022	6a 00		 push	 0
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?Read@AntiCheatPlus@@QAEXHPAD@Z ; AntiCheatPlus::Read

; 71   : 	this->Read(eClassType, "..\\AntiCheat\\CheatBase\\ClassCheat.txt");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IDFNCNLL@?4?4?2AntiCheat?2CheatBase?2ClassChea@
  00030	6a 01		 push	 1
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?Read@AntiCheatPlus@@QAEXHPAD@Z ; AntiCheatPlus::Read

; 72   : 	this->Read(eInjectType, "..\\AntiCheat\\CheatBase\\InjectCheat.txt");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@HGOBGJCL@?4?4?2AntiCheat?2CheatBase?2InjectChe@
  0003e	6a 02		 push	 2
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?Read@AntiCheatPlus@@QAEXHPAD@Z ; AntiCheatPlus::Read

; 73   : 	this->Read(eProcessType, "..\\AntiCheat\\CheatBase\\ProcessCheat.txt");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IMANMEJK@?4?4?2AntiCheat?2CheatBase?2ProcessCh@
  0004c	6a 03		 push	 3
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?Read@AntiCheatPlus@@QAEXHPAD@Z ; AntiCheatPlus::Read

; 74   : 
; 75   : 	this->ReadBlockHdd("..\\AntiCheat\\BlackList\\HDD_Data.txt");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CGPBJLBI@?4?4?2AntiCheat?2BlackList?2HDD_Data?4@
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?ReadBlockHdd@AntiCheatPlus@@QAEXPAD@Z ; AntiCheatPlus::ReadBlockHdd
$LN2@Load:
  00061	5e		 pop	 esi

; 76   : #if(ANTI_CHEAT_PLUS_CRC)
; 77   : 	this->ReadCRC("../AntiCheat/CheckFiles");
; 78   : #endif
; 79   : }

  00062	c3		 ret	 0
?Load@AntiCheatPlus@@QAEXXZ ENDP			; AntiCheatPlus::Load
_TEXT	ENDS
PUBLIC	??_C@_09OBKIGJOH@AntiCheat?$AA@			; `string'
PUBLIC	??_C@_0BB@NOKADJEH@?4?4?2AntiCheat?2LOG?$AA@	; `string'
EXTRN	_atexit:PROC
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
;	COMDAT ??_C@_09OBKIGJOH@AntiCheat?$AA@
CONST	SEGMENT
??_C@_09OBKIGJOH@AntiCheat?$AA@ DB 'AntiCheat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOKADJEH@?4?4?2AntiCheat?2LOG?$AA@
CONST	SEGMENT
??_C@_0BB@NOKADJEH@?4?4?2AntiCheat?2LOG?$AA@ DB '..\AntiCheat\LOG', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_AntiCheatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_AntiCheatLog@@YAXXZ PROC				; `dynamic initializer for 'g_AntiCheatLog'', COMDAT

; 15   : CLogToFile g_AntiCheatLog("AntiCheat", "..\\AntiCheat\\LOG", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NOKADJEH@?4?4?2AntiCheat?2LOG?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_09OBKIGJOH@AntiCheat?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AntiCheatLog@@3VCLogToFile@@A ; g_AntiCheatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_AntiCheatLog@@YAXXZ ; `dynamic atexit destructor for 'g_AntiCheatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_AntiCheatLog@@YAXXZ ENDP				; `dynamic initializer for 'g_AntiCheatLog''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Eg_AntiCheatPlus@@YAXXZ
text$yc	SEGMENT
??__Eg_AntiCheatPlus@@YAXXZ PROC			; `dynamic initializer for 'g_AntiCheatPlus'', COMDAT

; 18   : AntiCheatPlus g_AntiCheatPlus;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_AntiCheatPlus@@YAXXZ ; `dynamic atexit destructor for 'g_AntiCheatPlus''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Eg_AntiCheatPlus@@YAXXZ ENDP			; `dynamic initializer for 'g_AntiCheatPlus''
text$yc	ENDS
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_AntiCheatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_AntiCheatLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_AntiCheatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AntiCheatLog@@3VCLogToFile@@A ; g_AntiCheatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_AntiCheatLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_AntiCheatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_AntiCheatPlus@@YAXXZ
text$yd	SEGMENT
??__Fg_AntiCheatPlus@@YAXXZ PROC			; `dynamic atexit destructor for 'g_AntiCheatPlus'', COMDAT
  00000	a1 30 00 01 00	 mov	 eax, DWORD PTR ?g_AntiCheatPlus@@3VAntiCheatPlus@@A+65584
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN12@dynamic
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN12@dynamic:
  00012	c7 05 30 00 01
	00 00 00 00 00	 mov	 DWORD PTR ?g_AntiCheatPlus@@3VAntiCheatPlus@@A+65584, 0
  0001c	c7 05 34 00 01
	00 00 00 00 00	 mov	 DWORD PTR ?g_AntiCheatPlus@@3VAntiCheatPlus@@A+65588, 0
  00026	c7 05 38 00 01
	00 00 00 00 00	 mov	 DWORD PTR ?g_AntiCheatPlus@@3VAntiCheatPlus@@A+65592, 0
  00030	c3		 ret	 0
??__Fg_AntiCheatPlus@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_AntiCheatPlus''
text$yd	ENDS
PUBLIC	?g_AntiCheatPlus@@3VAntiCheatPlus@@A		; g_AntiCheatPlus
PUBLIC	?g_AntiCheatLog@@3VCLogToFile@@A		; g_AntiCheatLog
_BSS	SEGMENT
?g_AntiCheatPlus@@3VAntiCheatPlus@@A DB 010040H DUP (?)	; g_AntiCheatPlus
?g_AntiCheatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_AntiCheatLog
_BSS	ENDS
CRT$XCU	SEGMENT
_g_AntiCheatLog$initializer$ DD FLAT:??__Eg_AntiCheatLog@@YAXXZ
_g_AntiCheatPlus$initializer$ DD FLAT:??__Eg_AntiCheatPlus@@YAXXZ
CRT$XCU	ENDS
END
