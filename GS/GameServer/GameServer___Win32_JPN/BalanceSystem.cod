; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\BalanceSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?Refflect@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; cBalanceSystem::Refflect
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\balancesystem.cpp
;	COMDAT ?Refflect@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?Refflect@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; cBalanceSystem::Refflect, COMDAT
; _this$ = ecx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 453  : 	if(this->m_EnableRefflect == true)

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	38 81 f0 00 00
	00		 cmp	 BYTE PTR [ecx+240], al
  0000e	0f 85 c5 00 00
	00		 jne	 $LN8@Refflect

; 454  : 	{
; 455  : 		if(lpObj->Type == OBJ_USER)

  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00018	66 39 46 68	 cmp	 WORD PTR [esi+104], ax
  0001c	0f 85 b6 00 00
	00		 jne	 $LN14@Refflect

; 456  : 		{
; 457  : 			//switch(lpObj->Class)
; 458  : 			//{
; 459  : 			//	case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->m_DKRefflectPercent ) / 100; break;
; 460  : 			//	case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->m_DWRefflectPercent ) / 100; break;
; 461  : 			//	case CLASS_ELF:			AttackDamage = ( AttackDamage * this->m_FERefflectPercent ) / 100; break;
; 462  : 			//	case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->m_SURefflectPercent ) / 100; break;
; 463  : 			//	case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->m_MGRefflectPercent ) / 100; break;
; 464  : 			//	case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->m_DLRefflectPercent ) / 100; break;
; 465  : 			//	case CLASS_MONK:		AttackDamage = ( AttackDamage * this->m_RFRefflectPercent ) / 100; break;
; 466  : 			//}
; 467  : 
; 468  : 			switch(lpObj->Class)

  00022	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00029	83 f8 06	 cmp	 eax, 6
  0002c	0f 87 a6 00 00
	00		 ja	 $LN14@Refflect
  00032	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN17@Refflect[eax*4]
$LN7@Refflect:

; 469  : 			{
; 470  : 			case CLASS_KNIGHT:		lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_DKRefflectPercent ) / 100; break;

  00039	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  00040	0f af 91 f8 00
	00 00		 imul	 edx, DWORD PTR [ecx+248]
  00047	eb 78		 jmp	 SHORT $LN15@Refflect
$LN6@Refflect:

; 471  : 				case CLASS_WIZARD:		lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_DWRefflectPercent ) / 100; break;

  00049	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  00050	0f af 91 f4 00
	00 00		 imul	 edx, DWORD PTR [ecx+244]
  00057	eb 3e		 jmp	 SHORT $LN16@Refflect
$LN5@Refflect:

; 472  : 				case CLASS_ELF:			lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_FERefflectPercent ) / 100; break;

  00059	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  00060	0f af 91 fc 00
	00 00		 imul	 edx, DWORD PTR [ecx+252]
  00067	eb 58		 jmp	 SHORT $LN15@Refflect
$LN4@Refflect:

; 473  : 				case CLASS_SUMMONER:	lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_SURefflectPercent ) / 100; break;

  00069	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  00070	0f af 91 08 01
	00 00		 imul	 edx, DWORD PTR [ecx+264]
  00077	eb 1e		 jmp	 SHORT $LN16@Refflect
$LN3@Refflect:

; 474  : 				case CLASS_MAGUMSA:		lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_MGRefflectPercent ) / 100; break;

  00079	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  00080	0f af 91 00 01
	00 00		 imul	 edx, DWORD PTR [ecx+256]
  00087	eb 38		 jmp	 SHORT $LN15@Refflect
$LN2@Refflect:

; 475  : 				case CLASS_DARKLORD:	lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_DLRefflectPercent ) / 100; break;

  00089	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  00090	0f af 91 04 01
	00 00		 imul	 edx, DWORD PTR [ecx+260]
$LN16@Refflect:
  00097	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0009c	f7 ea		 imul	 edx
  0009e	c1 fa 05	 sar	 edx, 5
  000a1	8b ca		 mov	 ecx, edx
  000a3	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000a6	03 ca		 add	 ecx, edx
  000a8	88 8e 71 01 00
	00		 mov	 BYTE PTR [esi+369], cl
  000ae	5e		 pop	 esi

; 477  : 			}
; 478  : 		}
; 479  : 	}
; 480  : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
$LN1@Refflect:

; 476  : 				case CLASS_MONK:		lpObj->DamageReflect = ( lpObj->DamageReflect * this->m_RFRefflectPercent ) / 100; break;

  000b3	0f b6 96 71 01
	00 00		 movzx	 edx, BYTE PTR [esi+369]
  000ba	0f af 91 0c 01
	00 00		 imul	 edx, DWORD PTR [ecx+268]
$LN15@Refflect:
  000c1	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000c6	f7 ea		 imul	 edx
  000c8	c1 fa 05	 sar	 edx, 5
  000cb	8b c2		 mov	 eax, edx
  000cd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000d0	03 c2		 add	 eax, edx
  000d2	88 86 71 01 00
	00		 mov	 BYTE PTR [esi+369], al
$LN14@Refflect:
  000d8	5e		 pop	 esi
$LN8@Refflect:

; 477  : 			}
; 478  : 		}
; 479  : 	}
; 480  : }

  000d9	5d		 pop	 ebp
  000da	c2 04 00	 ret	 4
  000dd	8d 49 00	 npad	 3
$LN17@Refflect:
  000e0	00 00 00 00	 DD	 $LN6@Refflect
  000e4	00 00 00 00	 DD	 $LN7@Refflect
  000e8	00 00 00 00	 DD	 $LN5@Refflect
  000ec	00 00 00 00	 DD	 $LN3@Refflect
  000f0	00 00 00 00	 DD	 $LN2@Refflect
  000f4	00 00 00 00	 DD	 $LN4@Refflect
  000f8	00 00 00 00	 DD	 $LN1@Refflect
?Refflect@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; cBalanceSystem::Refflect
_TEXT	ENDS
PUBLIC	?size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 05	 sar	 eax, 5

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEAAUBALANS_RESET_DAMAGE@@I@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEAAUBALANS_RESET_DAMAGE@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEAAUBALANS_RESET_DAMAGE@@I@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	c1 e0 05	 shl	 eax, 5
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEAAUBALANS_RESET_DAMAGE@@I@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBE_NPBUBALANS_RESET_DAMAGE@@@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBE_NPBUBALANS_RESET_DAMAGE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBE_NPBUBALANS_RESET_DAMAGE@@@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBE_NPBUBALANS_RESET_DAMAGE@@@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXPAUBALANS_RESET_DAMAGE@@0@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXPAUBALANS_RESET_DAMAGE@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXPAUBALANS_RESET_DAMAGE@@0@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXPAUBALANS_RESET_DAMAGE@@0@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ ; std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::~_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::~_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::~_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@XZ ; std::allocator<BALANS_RESET_DAMAGE>::allocator<BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@XZ PROC	; std::allocator<BALANS_RESET_DAMAGE>::allocator<BALANS_RESET_DAMAGE>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@XZ ENDP	; std::allocator<BALANS_RESET_DAMAGE>::allocator<BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 05	 sar	 eax, 5

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXXZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXXZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEXXZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@ABV01@@Z ; std::allocator<BALANS_RESET_DAMAGE>::allocator<BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@ABV01@@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::allocator<BALANS_RESET_DAMAGE>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::allocator<BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@I@Z ; std::allocator<BALANS_RESET_DAMAGE>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@I@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@I@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QBEIXZ ; std::allocator<BALANS_RESET_DAMAGE>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QBEIXZ PROC ; std::allocator<BALANS_RESET_DAMAGE>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QBEIXZ ENDP ; std::allocator<BALANS_RESET_DAMAGE>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Compat
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUBALANS_RESET_DAMAGE@@@std@@YAPBUBALANS_RESET_DAMAGE@@ABU1@@Z ; std::addressof<BALANS_RESET_DAMAGE const >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUBALANS_RESET_DAMAGE@@@std@@YAPBUBALANS_RESET_DAMAGE@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUBALANS_RESET_DAMAGE@@@std@@YAPBUBALANS_RESET_DAMAGE@@ABU1@@Z PROC ; std::addressof<BALANS_RESET_DAMAGE const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUBALANS_RESET_DAMAGE@@@std@@YAPBUBALANS_RESET_DAMAGE@@ABU1@@Z ENDP ; std::addressof<BALANS_RESET_DAMAGE const >
_TEXT	ENDS
PUBLIC	??$forward@AAUBALANS_RESET_DAMAGE@@@std@@YAAAUBALANS_RESET_DAMAGE@@AAU1@@Z ; std::forward<BALANS_RESET_DAMAGE &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUBALANS_RESET_DAMAGE@@@std@@YAAAUBALANS_RESET_DAMAGE@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUBALANS_RESET_DAMAGE@@@std@@YAAAUBALANS_RESET_DAMAGE@@AAU1@@Z PROC ; std::forward<BALANS_RESET_DAMAGE &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUBALANS_RESET_DAMAGE@@@std@@YAAAUBALANS_RESET_DAMAGE@@AAU1@@Z ENDP ; std::forward<BALANS_RESET_DAMAGE &>
_TEXT	ENDS
PUBLIC	??$construct@AAUBALANS_RESET_DAMAGE@@@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@AAU2@@Z ; std::allocator<BALANS_RESET_DAMAGE>::construct<BALANS_RESET_DAMAGE &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUBALANS_RESET_DAMAGE@@@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUBALANS_RESET_DAMAGE@@@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@AAU2@@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::construct<BALANS_RESET_DAMAGE &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct:
  00017	5f		 pop	 edi

; 209  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@AAUBALANS_RESET_DAMAGE@@@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@AAU2@@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::construct<BALANS_RESET_DAMAGE &>
_TEXT	ENDS
PUBLIC	??$forward@ABUBALANS_RESET_DAMAGE@@@std@@YAABUBALANS_RESET_DAMAGE@@ABU1@@Z ; std::forward<BALANS_RESET_DAMAGE const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUBALANS_RESET_DAMAGE@@@std@@YAABUBALANS_RESET_DAMAGE@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBALANS_RESET_DAMAGE@@@std@@YAABUBALANS_RESET_DAMAGE@@ABU1@@Z PROC ; std::forward<BALANS_RESET_DAMAGE const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUBALANS_RESET_DAMAGE@@@std@@YAABUBALANS_RESET_DAMAGE@@ABU1@@Z ENDP ; std::forward<BALANS_RESET_DAMAGE const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UBALANS_RESET_DAMAGE@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBALANS_RESET_DAMAGE@@0@Z ; std::_Ptr_cat<BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UBALANS_RESET_DAMAGE@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBALANS_RESET_DAMAGE@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UBALANS_RESET_DAMAGE@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBALANS_RESET_DAMAGE@@0@Z PROC ; std::_Ptr_cat<BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UBALANS_RESET_DAMAGE@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUBALANS_RESET_DAMAGE@@0@Z ENDP ; std::_Ptr_cat<BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	??$_Construct@UBALANS_RESET_DAMAGE@@ABU1@@std@@YAXPAUBALANS_RESET_DAMAGE@@ABU1@@Z ; std::_Construct<BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@UBALANS_RESET_DAMAGE@@ABU1@@std@@YAXPAUBALANS_RESET_DAMAGE@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBALANS_RESET_DAMAGE@@ABU1@@std@@YAXPAUBALANS_RESET_DAMAGE@@ABU1@@Z PROC ; std::_Construct<BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@Construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@Construct:
  00017	5f		 pop	 edi

; 49   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Construct@UBALANS_RESET_DAMAGE@@ABU1@@std@@YAXPAUBALANS_RESET_DAMAGE@@ABU1@@Z ENDP ; std::_Construct<BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>
_TEXT	ENDS
PUBLIC	??$move@AAUBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z ; std::move<BALANS_RESET_DAMAGE &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z PROC ; std::move<BALANS_RESET_DAMAGE &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z ENDP ; std::move<BALANS_RESET_DAMAGE &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@@Z ; std::_Val_type<BALANS_RESET_DAMAGE *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@@Z PROC ; std::_Val_type<BALANS_RESET_DAMAGE *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@@Z ENDP ; std::_Val_type<BALANS_RESET_DAMAGE *>
_TEXT	ENDS
PUBLIC	??$_Destroy@UBALANS_RESET_DAMAGE@@@std@@YAXPAUBALANS_RESET_DAMAGE@@@Z ; std::_Destroy<BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UBALANS_RESET_DAMAGE@@@std@@YAXPAUBALANS_RESET_DAMAGE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UBALANS_RESET_DAMAGE@@@std@@YAXPAUBALANS_RESET_DAMAGE@@@Z PROC ; std::_Destroy<BALANS_RESET_DAMAGE>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UBALANS_RESET_DAMAGE@@@std@@YAXPAUBALANS_RESET_DAMAGE@@@Z ENDP ; std::_Destroy<BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	??$forward@UBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z ; std::forward<BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z PROC ; std::forward<BALANS_RESET_DAMAGE>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UBALANS_RESET_DAMAGE@@@std@@YA$$QAUBALANS_RESET_DAMAGE@@AAU1@@Z ENDP ; std::forward<BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?Main@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@0AAH@Z ; cBalanceSystem::Main
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\balancesystem.cpp
;	COMDAT ?Main@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@0AAH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTarget$ = 12						; size = 4
_i$209999 = 16						; size = 4
_AttackDamage$ = 16					; size = 4
?Main@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@0AAH@Z PROC	; cBalanceSystem::Main, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 299  : 	if(this->Enable)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTarget$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _AttackDamage$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	80 7f 04 00	 cmp	 BYTE PTR [edi+4], 0
  00012	0f 84 3f 05 00
	00		 je	 $LN27@Main

; 300  : 	{
; 301  : 		if(lpObj->Type == OBJ_USER && lpTarget->Type == OBJ_USER)

  00018	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001b	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  00020	0f 85 31 05 00
	00		 jne	 $LN27@Main
  00026	66 83 7b 68 01	 cmp	 WORD PTR [ebx+104], 1
  0002b	0f 85 26 05 00
	00		 jne	 $LN27@Main

; 302  : 		{
; 303  : 			if(lpObj->Class == CLASS_KNIGHT)

  00031	8b c8		 mov	 ecx, eax
  00033	0f b7 81 b8 00
	00 00		 movzx	 eax, WORD PTR [ecx+184]
  0003a	83 f8 01	 cmp	 eax, 1
  0003d	0f 85 91 00 00
	00		 jne	 $LN106@Main

; 304  : 			{
; 305  : 				switch(lpTarget->Class)

  00043	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  0004a	83 f8 06	 cmp	 eax, 6
  0004d	0f 87 97 04 00
	00		 ja	 $LN38@Main
  00053	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN137@Main[eax*4]
$LN103@Main:

; 306  : 				{
; 307  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->DKvsDK ) / 100; break;

  0005a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0005d	e9 72 04 00 00	 jmp	 $LN134@Main
$LN102@Main:

; 308  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->DKvsDW ) / 100; break;

  00062	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00065	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00068	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0006d	f7 e9		 imul	 ecx
  0006f	c1 fa 05	 sar	 edx, 5
  00072	8b ca		 mov	 ecx, edx
  00074	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00077	03 ca		 add	 ecx, edx
  00079	89 0e		 mov	 DWORD PTR [esi], ecx
  0007b	e9 6a 04 00 00	 jmp	 $LN38@Main
$LN101@Main:

; 309  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->DKvsELF) / 100; break;

  00080	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00083	e9 4c 04 00 00	 jmp	 $LN134@Main
$LN100@Main:

; 310  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->DKvsSUM) / 100; break;

  00088	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0008b	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  0008e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00093	f7 e9		 imul	 ecx
  00095	c1 fa 05	 sar	 edx, 5
  00098	8b ca		 mov	 ecx, edx
  0009a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009d	03 ca		 add	 ecx, edx
  0009f	89 0e		 mov	 DWORD PTR [esi], ecx
  000a1	e9 44 04 00 00	 jmp	 $LN38@Main
$LN99@Main:

; 311  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->DKvsMG ) / 100; break;

  000a6	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  000a9	e9 26 04 00 00	 jmp	 $LN134@Main
$LN98@Main:

; 312  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->DKvsDL ) / 100; break;

  000ae	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000b1	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  000b4	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000b9	f7 e9		 imul	 ecx
  000bb	c1 fa 05	 sar	 edx, 5
  000be	8b ca		 mov	 ecx, edx
  000c0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000c3	03 ca		 add	 ecx, edx
  000c5	89 0e		 mov	 DWORD PTR [esi], ecx
  000c7	e9 1e 04 00 00	 jmp	 $LN38@Main
$LN97@Main:

; 313  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->DKvsRF ) / 100; break;

  000cc	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]

; 314  : 				}
; 315  : 			}
; 316  : 			else if(lpObj->Class == CLASS_WIZARD)

  000cf	e9 00 04 00 00	 jmp	 $LN134@Main
$LN106@Main:
  000d4	66 85 c0	 test	 ax, ax
  000d7	0f 85 a7 00 00
	00		 jne	 $LN95@Main

; 317  : 			{
; 318  : 				switch(lpTarget->Class)

  000dd	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  000e4	83 f8 06	 cmp	 eax, 6
  000e7	0f 87 fd 03 00
	00		 ja	 $LN38@Main
  000ed	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN138@Main[eax*4]
$LN92@Main:

; 319  : 				{
; 320  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->DWvsDW ) / 100; break;

  000f4	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  000f7	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  000fa	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000ff	f7 e9		 imul	 ecx
  00101	c1 fa 05	 sar	 edx, 5
  00104	8b ca		 mov	 ecx, edx
  00106	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00109	03 ca		 add	 ecx, edx
  0010b	89 0e		 mov	 DWORD PTR [esi], ecx
  0010d	e9 d8 03 00 00	 jmp	 $LN38@Main
$LN91@Main:

; 321  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->DWvsDK ) / 100; break;

  00112	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00115	e9 ba 03 00 00	 jmp	 $LN134@Main
$LN90@Main:

; 322  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->DWvsELF) / 100; break;

  0011a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0011d	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00120	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00125	f7 e9		 imul	 ecx
  00127	c1 fa 05	 sar	 edx, 5
  0012a	8b ca		 mov	 ecx, edx
  0012c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0012f	03 ca		 add	 ecx, edx
  00131	89 0e		 mov	 DWORD PTR [esi], ecx
  00133	e9 b2 03 00 00	 jmp	 $LN38@Main
$LN89@Main:

; 323  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->DWvsSUM) / 100; break;

  00138	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  0013b	e9 94 03 00 00	 jmp	 $LN134@Main
$LN88@Main:

; 324  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->DWvsMG ) / 100; break;

  00140	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00143	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00146	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0014b	f7 e9		 imul	 ecx
  0014d	c1 fa 05	 sar	 edx, 5
  00150	8b ca		 mov	 ecx, edx
  00152	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00155	03 ca		 add	 ecx, edx
  00157	89 0e		 mov	 DWORD PTR [esi], ecx
  00159	e9 8c 03 00 00	 jmp	 $LN38@Main
$LN87@Main:

; 325  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->DWvsDL ) / 100; break;

  0015e	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00161	e9 6e 03 00 00	 jmp	 $LN134@Main
$LN86@Main:

; 326  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->DWvsRF ) / 100; break;

  00166	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  00169	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  0016c	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00171	f7 e9		 imul	 ecx
  00173	c1 fa 05	 sar	 edx, 5
  00176	8b ca		 mov	 ecx, edx
  00178	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0017b	03 ca		 add	 ecx, edx
  0017d	89 0e		 mov	 DWORD PTR [esi], ecx

; 327  : 				}
; 328  : 			}
; 329  : 			else if(lpObj->Class == CLASS_ELF)

  0017f	e9 66 03 00 00	 jmp	 $LN38@Main
$LN95@Main:
  00184	83 f8 02	 cmp	 eax, 2
  00187	0f 85 91 00 00
	00		 jne	 $LN84@Main

; 330  : 			{
; 331  : 				switch(lpTarget->Class)

  0018d	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  00194	83 f8 06	 cmp	 eax, 6
  00197	0f 87 4d 03 00
	00		 ja	 $LN38@Main
  0019d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN139@Main[eax*4]
$LN81@Main:

; 332  : 				{
; 333  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->ELFvsELF ) / 100; break;

  001a4	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  001a7	e9 28 03 00 00	 jmp	 $LN134@Main
$LN80@Main:

; 334  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->ELFvsDK ) / 100; break;

  001ac	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]
  001af	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  001b2	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  001b7	f7 e9		 imul	 ecx
  001b9	c1 fa 05	 sar	 edx, 5
  001bc	8b ca		 mov	 ecx, edx
  001be	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001c1	03 ca		 add	 ecx, edx
  001c3	89 0e		 mov	 DWORD PTR [esi], ecx
  001c5	e9 20 03 00 00	 jmp	 $LN38@Main
$LN79@Main:

; 335  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->ELFvsDW ) / 100; break;

  001ca	8b 4f 48	 mov	 ecx, DWORD PTR [edi+72]
  001cd	e9 02 03 00 00	 jmp	 $LN134@Main
$LN78@Main:

; 336  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->ELFvsSUM) / 100; break;

  001d2	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  001d5	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  001d8	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  001dd	f7 e9		 imul	 ecx
  001df	c1 fa 05	 sar	 edx, 5
  001e2	8b ca		 mov	 ecx, edx
  001e4	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001e7	03 ca		 add	 ecx, edx
  001e9	89 0e		 mov	 DWORD PTR [esi], ecx
  001eb	e9 fa 02 00 00	 jmp	 $LN38@Main
$LN77@Main:

; 337  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->ELFvsMG ) / 100; break;

  001f0	8b 4f 50	 mov	 ecx, DWORD PTR [edi+80]
  001f3	e9 dc 02 00 00	 jmp	 $LN134@Main
$LN76@Main:

; 338  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->ELFvsDL ) / 100; break;

  001f8	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  001fb	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  001fe	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00203	f7 e9		 imul	 ecx
  00205	c1 fa 05	 sar	 edx, 5
  00208	8b ca		 mov	 ecx, edx
  0020a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0020d	03 ca		 add	 ecx, edx
  0020f	89 0e		 mov	 DWORD PTR [esi], ecx
  00211	e9 d4 02 00 00	 jmp	 $LN38@Main
$LN75@Main:

; 339  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->ELFvsRF ) / 100; break;

  00216	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]

; 340  : 				}
; 341  : 			}
; 342  : 			else if(lpObj->Class == CLASS_SUMMONER)

  00219	e9 b6 02 00 00	 jmp	 $LN134@Main
$LN84@Main:
  0021e	83 f8 05	 cmp	 eax, 5
  00221	0f 85 a7 00 00
	00		 jne	 $LN73@Main

; 343  : 			{
; 344  : 				switch(lpTarget->Class)

  00227	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  0022e	83 f8 06	 cmp	 eax, 6
  00231	0f 87 b3 02 00
	00		 ja	 $LN38@Main
  00237	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN140@Main[eax*4]
$LN70@Main:

; 345  : 				{
; 346  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->SUMvsSUM ) / 100; break;

  0023e	8b 4f 5c	 mov	 ecx, DWORD PTR [edi+92]
  00241	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00244	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00249	f7 e9		 imul	 ecx
  0024b	c1 fa 05	 sar	 edx, 5
  0024e	8b ca		 mov	 ecx, edx
  00250	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00253	03 ca		 add	 ecx, edx
  00255	89 0e		 mov	 DWORD PTR [esi], ecx
  00257	e9 8e 02 00 00	 jmp	 $LN38@Main
$LN69@Main:

; 347  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->SUMvsDK ) / 100; break;

  0025c	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0025f	e9 70 02 00 00	 jmp	 $LN134@Main
$LN68@Main:

; 348  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->SUMvsDW ) / 100; break;

  00264	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00267	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  0026a	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0026f	f7 e9		 imul	 ecx
  00271	c1 fa 05	 sar	 edx, 5
  00274	8b ca		 mov	 ecx, edx
  00276	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00279	03 ca		 add	 ecx, edx
  0027b	89 0e		 mov	 DWORD PTR [esi], ecx
  0027d	e9 68 02 00 00	 jmp	 $LN38@Main
$LN67@Main:

; 349  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->SUMvsELF) / 100; break;

  00282	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00285	e9 4a 02 00 00	 jmp	 $LN134@Main
$LN66@Main:

; 350  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->SUMvsMG ) / 100; break;

  0028a	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  0028d	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00290	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00295	f7 e9		 imul	 ecx
  00297	c1 fa 05	 sar	 edx, 5
  0029a	8b ca		 mov	 ecx, edx
  0029c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0029f	03 ca		 add	 ecx, edx
  002a1	89 0e		 mov	 DWORD PTR [esi], ecx
  002a3	e9 42 02 00 00	 jmp	 $LN38@Main
$LN65@Main:

; 351  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->SUMvsDL ) / 100; break;

  002a8	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  002ab	e9 24 02 00 00	 jmp	 $LN134@Main
$LN64@Main:

; 352  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->SUMvsRF ) / 100; break;

  002b0	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  002b3	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  002b6	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  002bb	f7 e9		 imul	 ecx
  002bd	c1 fa 05	 sar	 edx, 5
  002c0	8b ca		 mov	 ecx, edx
  002c2	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002c5	03 ca		 add	 ecx, edx
  002c7	89 0e		 mov	 DWORD PTR [esi], ecx

; 353  : 				}
; 354  : 			}
; 355  : 			else if(lpObj->Class == CLASS_MAGUMSA)

  002c9	e9 1c 02 00 00	 jmp	 $LN38@Main
$LN73@Main:
  002ce	83 f8 03	 cmp	 eax, 3
  002d1	0f 85 a0 00 00
	00		 jne	 $LN62@Main

; 356  : 			{
; 357  : 				switch(lpTarget->Class)

  002d7	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  002de	83 f8 06	 cmp	 eax, 6
  002e1	0f 87 03 02 00
	00		 ja	 $LN38@Main
  002e7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN141@Main[eax*4]
$LN59@Main:

; 358  : 				{
; 359  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->MGvsMG ) / 100; break;

  002ee	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  002f1	e9 de 01 00 00	 jmp	 $LN134@Main
$LN58@Main:

; 360  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->MGvsDK ) / 100; break;

  002f6	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  002f9	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  002fc	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00301	f7 e9		 imul	 ecx
  00303	c1 fa 05	 sar	 edx, 5
  00306	8b ca		 mov	 ecx, edx
  00308	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0030b	03 ca		 add	 ecx, edx
  0030d	89 0e		 mov	 DWORD PTR [esi], ecx
  0030f	e9 d6 01 00 00	 jmp	 $LN38@Main
$LN57@Main:

; 361  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->MGvsDW ) / 100; break;

  00314	8b 8f 80 00 00
	00		 mov	 ecx, DWORD PTR [edi+128]
  0031a	e9 b5 01 00 00	 jmp	 $LN134@Main
$LN56@Main:

; 362  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->MGvsELF) / 100; break;

  0031f	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  00325	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00328	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0032d	f7 e9		 imul	 ecx
  0032f	c1 fa 05	 sar	 edx, 5
  00332	8b ca		 mov	 ecx, edx
  00334	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00337	03 ca		 add	 ecx, edx
  00339	89 0e		 mov	 DWORD PTR [esi], ecx
  0033b	e9 aa 01 00 00	 jmp	 $LN38@Main
$LN55@Main:

; 363  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->MGvsSUM) / 100; break;

  00340	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00346	e9 89 01 00 00	 jmp	 $LN134@Main
$LN54@Main:

; 364  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->MGvsDL ) / 100; break;

  0034b	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  00351	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00354	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00359	f7 e9		 imul	 ecx
  0035b	c1 fa 05	 sar	 edx, 5
  0035e	8b ca		 mov	 ecx, edx
  00360	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00363	03 ca		 add	 ecx, edx
  00365	89 0e		 mov	 DWORD PTR [esi], ecx
  00367	e9 7e 01 00 00	 jmp	 $LN38@Main
$LN53@Main:

; 365  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->MGvsRF ) / 100; break;

  0036c	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]

; 366  : 				}
; 367  : 			}
; 368  : 			else if(lpObj->Class == CLASS_DARKLORD)

  00372	e9 5d 01 00 00	 jmp	 $LN134@Main
$LN62@Main:
  00377	83 f8 04	 cmp	 eax, 4
  0037a	0f 85 bc 00 00
	00		 jne	 $LN51@Main

; 369  : 			{
; 370  : 				switch(lpTarget->Class)

  00380	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  00387	83 f8 06	 cmp	 eax, 6
  0038a	0f 87 5a 01 00
	00		 ja	 $LN38@Main
  00390	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN142@Main[eax*4]
$LN48@Main:

; 371  : 				{
; 372  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->DLvsDL ) / 100; break;

  00397	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0039d	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  003a0	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  003a5	f7 e9		 imul	 ecx
  003a7	c1 fa 05	 sar	 edx, 5
  003aa	8b ca		 mov	 ecx, edx
  003ac	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  003af	03 ca		 add	 ecx, edx
  003b1	89 0e		 mov	 DWORD PTR [esi], ecx
  003b3	e9 32 01 00 00	 jmp	 $LN38@Main
$LN47@Main:

; 373  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->DLvsDK ) / 100; break;

  003b8	8b 8f 98 00 00
	00		 mov	 ecx, DWORD PTR [edi+152]
  003be	e9 11 01 00 00	 jmp	 $LN134@Main
$LN46@Main:

; 374  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->DLvsDW ) / 100; break;

  003c3	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  003c9	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  003cc	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  003d1	f7 e9		 imul	 ecx
  003d3	c1 fa 05	 sar	 edx, 5
  003d6	8b ca		 mov	 ecx, edx
  003d8	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  003db	03 ca		 add	 ecx, edx
  003dd	89 0e		 mov	 DWORD PTR [esi], ecx
  003df	e9 06 01 00 00	 jmp	 $LN38@Main
$LN45@Main:

; 375  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->DLvsELF) / 100; break;

  003e4	8b 8f a0 00 00
	00		 mov	 ecx, DWORD PTR [edi+160]
  003ea	e9 e5 00 00 00	 jmp	 $LN134@Main
$LN44@Main:

; 376  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->DLvsSUM) / 100; break;

  003ef	8b 8f a4 00 00
	00		 mov	 ecx, DWORD PTR [edi+164]
  003f5	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  003f8	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  003fd	f7 e9		 imul	 ecx
  003ff	c1 fa 05	 sar	 edx, 5
  00402	8b ca		 mov	 ecx, edx
  00404	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00407	03 ca		 add	 ecx, edx
  00409	89 0e		 mov	 DWORD PTR [esi], ecx
  0040b	e9 da 00 00 00	 jmp	 $LN38@Main
$LN43@Main:

; 377  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->DLvsMG ) / 100; break;

  00410	8b 8f a8 00 00
	00		 mov	 ecx, DWORD PTR [edi+168]
  00416	e9 b9 00 00 00	 jmp	 $LN134@Main
$LN42@Main:

; 378  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->DLvsRF ) / 100; break;

  0041b	8b 8f ac 00 00
	00		 mov	 ecx, DWORD PTR [edi+172]
  00421	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00424	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00429	f7 e9		 imul	 ecx
  0042b	c1 fa 05	 sar	 edx, 5
  0042e	8b ca		 mov	 ecx, edx
  00430	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00433	03 ca		 add	 ecx, edx
  00435	89 0e		 mov	 DWORD PTR [esi], ecx

; 379  : 				}
; 380  : 			}
; 381  : 			else if(lpObj->Class == CLASS_MONK)

  00437	e9 ae 00 00 00	 jmp	 $LN38@Main
$LN51@Main:
  0043c	83 f8 06	 cmp	 eax, 6
  0043f	0f 85 a5 00 00
	00		 jne	 $LN38@Main

; 382  : 			{
; 383  : 				switch(lpTarget->Class)

  00445	0f b7 83 b8 00
	00 00		 movzx	 eax, WORD PTR [ebx+184]
  0044c	83 f8 06	 cmp	 eax, 6
  0044f	0f 87 95 00 00
	00		 ja	 $LN38@Main
  00455	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN143@Main[eax*4]
$LN37@Main:

; 384  : 				{
; 385  : 					case CLASS_MONK:		AttackDamage = ( AttackDamage * this->RFvsRF ) / 100; break;

  0045c	8b 8f b0 00 00
	00		 mov	 ecx, DWORD PTR [edi+176]
  00462	eb 70		 jmp	 SHORT $LN134@Main
$LN36@Main:

; 386  : 					case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->RFvsDK ) / 100; break;

  00464	8b 8f b4 00 00
	00		 mov	 ecx, DWORD PTR [edi+180]
  0046a	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  0046d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00472	f7 e9		 imul	 ecx
  00474	c1 fa 05	 sar	 edx, 5
  00477	8b ca		 mov	 ecx, edx
  00479	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0047c	03 ca		 add	 ecx, edx
  0047e	89 0e		 mov	 DWORD PTR [esi], ecx
  00480	eb 68		 jmp	 SHORT $LN38@Main
$LN35@Main:

; 387  : 					case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->RFvsDW ) / 100; break;

  00482	8b 8f b8 00 00
	00		 mov	 ecx, DWORD PTR [edi+184]
  00488	eb 4a		 jmp	 SHORT $LN134@Main
$LN34@Main:

; 388  : 					case CLASS_ELF:			AttackDamage = ( AttackDamage * this->RFvsELF) / 100; break;

  0048a	8b 8f bc 00 00
	00		 mov	 ecx, DWORD PTR [edi+188]
  00490	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00493	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00498	f7 e9		 imul	 ecx
  0049a	c1 fa 05	 sar	 edx, 5
  0049d	8b ca		 mov	 ecx, edx
  0049f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004a2	03 ca		 add	 ecx, edx
  004a4	89 0e		 mov	 DWORD PTR [esi], ecx
  004a6	eb 42		 jmp	 SHORT $LN38@Main
$LN33@Main:

; 389  : 					case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->RFvsSUM) / 100; break;

  004a8	8b 8f c0 00 00
	00		 mov	 ecx, DWORD PTR [edi+192]
  004ae	eb 24		 jmp	 SHORT $LN134@Main
$LN32@Main:

; 390  : 					case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->RFvsMG ) / 100; break;

  004b0	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  004b6	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  004b9	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  004be	f7 e9		 imul	 ecx
  004c0	c1 fa 05	 sar	 edx, 5
  004c3	8b ca		 mov	 ecx, edx
  004c5	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004c8	03 ca		 add	 ecx, edx
  004ca	89 0e		 mov	 DWORD PTR [esi], ecx
  004cc	eb 1c		 jmp	 SHORT $LN38@Main
$LN31@Main:

; 391  : 					case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->RFvsDL ) / 100; break;

  004ce	8b 8f c8 00 00
	00		 mov	 ecx, DWORD PTR [edi+200]
$LN134@Main:
  004d4	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  004d7	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  004dc	f7 e9		 imul	 ecx
  004de	c1 fa 05	 sar	 edx, 5
  004e1	8b c2		 mov	 eax, edx
  004e3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004e6	03 c2		 add	 eax, edx
  004e8	89 06		 mov	 DWORD PTR [esi], eax
$LN38@Main:

; 392  : 				}
; 393  : 			}
; 394  : 
; 395  : 			if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::GredyLocal) || g_ZtLicense.CheckUser(eZtUB::Gredy2))

  004ea	6a 20		 push	 32			; 00000020H
  004ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004f1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004f6	84 c0		 test	 al, al
  004f8	75 20		 jne	 SHORT $LN29@Main
  004fa	6a 21		 push	 33			; 00000021H
  004fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00501	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00506	84 c0		 test	 al, al
  00508	75 10		 jne	 SHORT $LN29@Main
  0050a	6a 22		 push	 34			; 00000022H
  0050c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00511	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00516	84 c0		 test	 al, al
  00518	74 3d		 je	 SHORT $LN27@Main
$LN29@Main:

; 396  : 			{
; 397  : 				if(lpObj->Class == CLASS_KNIGHT)

  0051a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051d	66 83 b8 b8 00
	00 00 01	 cmp	 WORD PTR [eax+184], 1
  00525	75 30		 jne	 SHORT $LN27@Main

; 398  : 				{
; 399  : 					if(lpObj->pInventory[8].m_Type == ITEMGET(13,37))

  00527	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  0052d	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  00532	66 39 91 a6 06
	00 00		 cmp	 WORD PTR [ecx+1702], dx
  00539	75 1c		 jne	 SHORT $LN27@Main

; 400  : 					{
; 401  : 						AttackDamage = ( AttackDamage * this->m_DKFenrirDamagePercent ) / 100;

  0053b	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  00541	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  00544	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00549	f7 e9		 imul	 ecx
  0054b	c1 fa 05	 sar	 edx, 5
  0054e	8b c2		 mov	 eax, edx
  00550	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00553	03 c2		 add	 eax, edx
  00555	89 06		 mov	 DWORD PTR [esi], eax
$LN27@Main:

; 402  : 					}
; 403  : 				}
; 404  : 			}
; 405  : 		}
; 406  : 	}
; 407  : 
; 408  : 	if(this->m_EnableMonster)

  00557	80 bf cc 00 00
	00 00		 cmp	 BYTE PTR [edi+204], 0
  0055e	0f 84 be 00 00
	00		 je	 $LN132@Main

; 409  : 	{
; 410  : 		if(lpObj->Type == OBJ_USER && lpTarget->Type == OBJ_MONSTER)

  00564	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00567	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  0056c	0f 85 b0 00 00
	00		 jne	 $LN132@Main
  00572	66 83 7b 68 02	 cmp	 WORD PTR [ebx+104], 2
  00577	0f 85 a5 00 00
	00		 jne	 $LN132@Main

; 411  : 		{
; 412  : 			switch(lpObj->Class)

  0057d	0f b7 80 b8 00
	00 00		 movzx	 eax, WORD PTR [eax+184]
  00584	83 f8 06	 cmp	 eax, 6
  00587	0f 87 95 00 00
	00		 ja	 $LN132@Main
  0058d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN144@Main[eax*4]
$LN22@Main:

; 413  : 			{
; 414  : 				case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->m_DKvsMonster ) / 100; break;

  00594	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  0059a	eb 70		 jmp	 SHORT $LN135@Main
$LN21@Main:

; 415  : 				case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->m_DWvsMonster ) / 100; break;

  0059c	8b 8f d4 00 00
	00		 mov	 ecx, DWORD PTR [edi+212]
  005a2	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  005a5	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  005aa	f7 e9		 imul	 ecx
  005ac	c1 fa 05	 sar	 edx, 5
  005af	8b c2		 mov	 eax, edx
  005b1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005b4	03 c2		 add	 eax, edx
  005b6	89 06		 mov	 DWORD PTR [esi], eax
  005b8	eb 68		 jmp	 SHORT $LN132@Main
$LN20@Main:

; 416  : 				case CLASS_ELF:			AttackDamage = ( AttackDamage * this->m_ELFvsMonster) / 100; break;

  005ba	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  005c0	eb 4a		 jmp	 SHORT $LN135@Main
$LN19@Main:

; 417  : 				case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->m_SUMvsMonster) / 100; break;

  005c2	8b 8f dc 00 00
	00		 mov	 ecx, DWORD PTR [edi+220]
  005c8	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  005cb	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  005d0	f7 e9		 imul	 ecx
  005d2	c1 fa 05	 sar	 edx, 5
  005d5	8b c2		 mov	 eax, edx
  005d7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005da	03 c2		 add	 eax, edx
  005dc	89 06		 mov	 DWORD PTR [esi], eax
  005de	eb 42		 jmp	 SHORT $LN132@Main
$LN18@Main:

; 418  : 				case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->m_MGvsMonster ) / 100; break;

  005e0	8b 8f e0 00 00
	00		 mov	 ecx, DWORD PTR [edi+224]
  005e6	eb 24		 jmp	 SHORT $LN135@Main
$LN17@Main:

; 419  : 				case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->m_DLvsMonster ) / 100; break;

  005e8	8b 8f e4 00 00
	00		 mov	 ecx, DWORD PTR [edi+228]
  005ee	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  005f1	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  005f6	f7 e9		 imul	 ecx
  005f8	c1 fa 05	 sar	 edx, 5
  005fb	8b c2		 mov	 eax, edx
  005fd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00600	03 c2		 add	 eax, edx
  00602	89 06		 mov	 DWORD PTR [esi], eax
  00604	eb 1c		 jmp	 SHORT $LN132@Main
$LN16@Main:

; 420  : 				case CLASS_MONK:		AttackDamage = ( AttackDamage * this->m_RFvsMonster ) / 100; break;

  00606	8b 8f e8 00 00
	00		 mov	 ecx, DWORD PTR [edi+232]
$LN135@Main:
  0060c	0f af 0e	 imul	 ecx, DWORD PTR [esi]
  0060f	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00614	f7 e9		 imul	 ecx
  00616	c1 fa 05	 sar	 edx, 5
  00619	8b ca		 mov	 ecx, edx
  0061b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0061e	03 ca		 add	 ecx, edx
  00620	89 0e		 mov	 DWORD PTR [esi], ecx
$LN132@Main:

; 421  : 			}
; 422  : 		}
; 423  : 	}
; 424  : 
; 425  : 	if(this->m_EnableDamagePercent)

  00622	33 c9		 xor	 ecx, ecx
  00624	39 8f 10 01 00
	00		 cmp	 DWORD PTR [edi+272], ecx
  0062a	0f 84 b8 00 00
	00		 je	 $LN11@Main

; 426  : 	{
; 427  : 		if(lpObj->Type == OBJ_USER && lpTarget->Type == OBJ_MONSTER)

  00630	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00633	66 83 7a 68 01	 cmp	 WORD PTR [edx+104], 1
  00638	0f 85 aa 00 00
	00		 jne	 $LN11@Main
  0063e	66 83 7b 68 02	 cmp	 WORD PTR [ebx+104], 2
  00643	0f 85 9f 00 00
	00		 jne	 $LN11@Main

; 428  : 		{
; 429  : 			for(int i = 0; i < this->m_vResetDamage.size(); i++)

  00649	8b 87 14 01 00
	00		 mov	 eax, DWORD PTR [edi+276]
  0064f	8b 97 18 01 00
	00		 mov	 edx, DWORD PTR [edi+280]
  00655	2b d0		 sub	 edx, eax
  00657	c1 fa 05	 sar	 edx, 5
  0065a	89 4d 10	 mov	 DWORD PTR _i$209999[ebp], ecx
  0065d	85 d2		 test	 edx, edx
  0065f	0f 84 83 00 00
	00		 je	 $LN11@Main
  00665	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00668	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL131@Main:

; 430  : 			{
; 431  : 				if(lpObj->Reset == this->m_vResetDamage[i].ResetNumber)

  00670	8b 93 90 22 00
	00		 mov	 edx, DWORD PTR [ebx+8848]
  00676	3b 14 08	 cmp	 edx, DWORD PTR [eax+ecx]
  00679	75 51		 jne	 SHORT $LN12@Main

; 432  : 				{
; 433  : 					switch(lpObj->Class)

  0067b	0f b7 93 b8 00
	00 00		 movzx	 edx, WORD PTR [ebx+184]
  00682	83 fa 06	 cmp	 edx, 6
  00685	77 45		 ja	 SHORT $LN12@Main
  00687	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN145@Main[edx*4]
$LN7@Main:

; 434  : 					{
; 435  : 						case CLASS_WIZARD:		AttackDamage = ( AttackDamage * this->m_vResetDamage[i].DWDamagePercent ) / 100; break;

  0068e	8b 54 08 04	 mov	 edx, DWORD PTR [eax+ecx+4]
  00692	eb 22		 jmp	 SHORT $LN136@Main
$LN6@Main:

; 436  : 						case CLASS_KNIGHT:		AttackDamage = ( AttackDamage * this->m_vResetDamage[i].DKDamagePercent ) / 100; break;

  00694	8b 54 08 08	 mov	 edx, DWORD PTR [eax+ecx+8]
  00698	eb 1c		 jmp	 SHORT $LN136@Main
$LN5@Main:

; 437  : 						case CLASS_ELF:			AttackDamage = ( AttackDamage * this->m_vResetDamage[i].FEDamagePercent) / 100; break;

  0069a	8b 54 08 0c	 mov	 edx, DWORD PTR [eax+ecx+12]
  0069e	eb 16		 jmp	 SHORT $LN136@Main
$LN4@Main:

; 438  : 						case CLASS_SUMMONER:	AttackDamage = ( AttackDamage * this->m_vResetDamage[i].SUDamagePercent) / 100; break;

  006a0	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  006a4	eb 10		 jmp	 SHORT $LN136@Main
$LN3@Main:

; 439  : 						case CLASS_MAGUMSA:		AttackDamage = ( AttackDamage * this->m_vResetDamage[i].MGDamagePercent ) / 100; break;

  006a6	8b 54 08 10	 mov	 edx, DWORD PTR [eax+ecx+16]
  006aa	eb 0a		 jmp	 SHORT $LN136@Main
$LN2@Main:

; 440  : 						case CLASS_DARKLORD:	AttackDamage = ( AttackDamage * this->m_vResetDamage[i].DLDamagePercent ) / 100; break;

  006ac	8b 54 08 14	 mov	 edx, DWORD PTR [eax+ecx+20]
  006b0	eb 04		 jmp	 SHORT $LN136@Main
$LN1@Main:

; 441  : 						case CLASS_MONK:		AttackDamage = ( AttackDamage * this->m_vResetDamage[i].RFDamagePercent ) / 100; break;

  006b2	8b 54 08 1c	 mov	 edx, DWORD PTR [eax+ecx+28]
$LN136@Main:
  006b6	0f af 16	 imul	 edx, DWORD PTR [esi]
  006b9	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  006be	f7 ea		 imul	 edx
  006c0	c1 fa 05	 sar	 edx, 5
  006c3	8b c2		 mov	 eax, edx
  006c5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  006c8	03 c2		 add	 eax, edx
  006ca	89 06		 mov	 DWORD PTR [esi], eax
$LN12@Main:

; 428  : 		{
; 429  : 			for(int i = 0; i < this->m_vResetDamage.size(); i++)

  006cc	8b 87 14 01 00
	00		 mov	 eax, DWORD PTR [edi+276]
  006d2	8b 97 18 01 00
	00		 mov	 edx, DWORD PTR [edi+280]
  006d8	ff 45 10	 inc	 DWORD PTR _i$209999[ebp]
  006db	2b d0		 sub	 edx, eax
  006dd	c1 fa 05	 sar	 edx, 5
  006e0	83 c1 20	 add	 ecx, 32			; 00000020H
  006e3	39 55 10	 cmp	 DWORD PTR _i$209999[ebp], edx
  006e6	72 88		 jb	 SHORT $LL131@Main
$LN11@Main:
  006e8	5f		 pop	 edi
  006e9	5e		 pop	 esi
  006ea	5b		 pop	 ebx

; 442  : 					}
; 443  : 				}
; 444  : 			}
; 445  : 
; 446  : 
; 447  : 		}
; 448  : 	}
; 449  : }

  006eb	5d		 pop	 ebp
  006ec	c2 0c 00	 ret	 12			; 0000000cH
  006ef	90		 npad	 1
$LN137@Main:
  006f0	00 00 00 00	 DD	 $LN102@Main
  006f4	00 00 00 00	 DD	 $LN103@Main
  006f8	00 00 00 00	 DD	 $LN101@Main
  006fc	00 00 00 00	 DD	 $LN99@Main
  00700	00 00 00 00	 DD	 $LN98@Main
  00704	00 00 00 00	 DD	 $LN100@Main
  00708	00 00 00 00	 DD	 $LN97@Main
$LN138@Main:
  0070c	00 00 00 00	 DD	 $LN92@Main
  00710	00 00 00 00	 DD	 $LN91@Main
  00714	00 00 00 00	 DD	 $LN90@Main
  00718	00 00 00 00	 DD	 $LN88@Main
  0071c	00 00 00 00	 DD	 $LN87@Main
  00720	00 00 00 00	 DD	 $LN89@Main
  00724	00 00 00 00	 DD	 $LN86@Main
$LN139@Main:
  00728	00 00 00 00	 DD	 $LN79@Main
  0072c	00 00 00 00	 DD	 $LN80@Main
  00730	00 00 00 00	 DD	 $LN81@Main
  00734	00 00 00 00	 DD	 $LN77@Main
  00738	00 00 00 00	 DD	 $LN76@Main
  0073c	00 00 00 00	 DD	 $LN78@Main
  00740	00 00 00 00	 DD	 $LN75@Main
$LN140@Main:
  00744	00 00 00 00	 DD	 $LN68@Main
  00748	00 00 00 00	 DD	 $LN69@Main
  0074c	00 00 00 00	 DD	 $LN67@Main
  00750	00 00 00 00	 DD	 $LN66@Main
  00754	00 00 00 00	 DD	 $LN65@Main
  00758	00 00 00 00	 DD	 $LN70@Main
  0075c	00 00 00 00	 DD	 $LN64@Main
$LN141@Main:
  00760	00 00 00 00	 DD	 $LN57@Main
  00764	00 00 00 00	 DD	 $LN58@Main
  00768	00 00 00 00	 DD	 $LN56@Main
  0076c	00 00 00 00	 DD	 $LN59@Main
  00770	00 00 00 00	 DD	 $LN54@Main
  00774	00 00 00 00	 DD	 $LN55@Main
  00778	00 00 00 00	 DD	 $LN53@Main
$LN142@Main:
  0077c	00 00 00 00	 DD	 $LN46@Main
  00780	00 00 00 00	 DD	 $LN47@Main
  00784	00 00 00 00	 DD	 $LN45@Main
  00788	00 00 00 00	 DD	 $LN43@Main
  0078c	00 00 00 00	 DD	 $LN48@Main
  00790	00 00 00 00	 DD	 $LN44@Main
  00794	00 00 00 00	 DD	 $LN42@Main
$LN143@Main:
  00798	00 00 00 00	 DD	 $LN35@Main
  0079c	00 00 00 00	 DD	 $LN36@Main
  007a0	00 00 00 00	 DD	 $LN34@Main
  007a4	00 00 00 00	 DD	 $LN32@Main
  007a8	00 00 00 00	 DD	 $LN31@Main
  007ac	00 00 00 00	 DD	 $LN33@Main
  007b0	00 00 00 00	 DD	 $LN37@Main
$LN144@Main:
  007b4	00 00 00 00	 DD	 $LN21@Main
  007b8	00 00 00 00	 DD	 $LN22@Main
  007bc	00 00 00 00	 DD	 $LN20@Main
  007c0	00 00 00 00	 DD	 $LN18@Main
  007c4	00 00 00 00	 DD	 $LN17@Main
  007c8	00 00 00 00	 DD	 $LN19@Main
  007cc	00 00 00 00	 DD	 $LN16@Main
$LN145@Main:
  007d0	00 00 00 00	 DD	 $LN7@Main
  007d4	00 00 00 00	 DD	 $LN6@Main
  007d8	00 00 00 00	 DD	 $LN5@Main
  007dc	00 00 00 00	 DD	 $LN3@Main
  007e0	00 00 00 00	 DD	 $LN2@Main
  007e4	00 00 00 00	 DD	 $LN4@Main
  007e8	00 00 00 00	 DD	 $LN1@Main
?Main@cBalanceSystem@@QAEXPAUOBJECTSTRUCT@@0AAH@Z ENDP	; cBalanceSystem::Main
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@V?$allocator@UBALANS_RESET_DAMAGE@@@1@@Z ; std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@V?$allocator@UBALANS_RESET_DAMAGE@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@V?$allocator@UBALANS_RESET_DAMAGE@@@1@@Z PROC ; std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@V?$allocator@UBALANS_RESET_DAMAGE@@@1@@Z ENDP ; std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBEIXZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEII@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEII@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 07	 mov	 edx, 134217727		; 07ffffffH
  0000d	c1 f8 05	 sar	 eax, 5
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IBEII@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@AAU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@AAU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@AAU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@AAU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@AAU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE &>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@IPAU1@@Z ; std::_Allocate<BALANS_RESET_DAMAGE>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@IPAU1@@Z
_TEXT	SEGMENT
$T211329 = -12						; size = 12
$T211334 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@IPAU1@@Z PROC ; std::_Allocate<BALANS_RESET_DAMAGE>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 40		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	07		 cmp	 ecx, 134217727		; 07ffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate
  00017	c1 e1 05	 shl	 ecx, 5
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	8d 45 08	 lea	 eax, DWORD PTR $T211334[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T211329[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T211334[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T211329[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T211329[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@UBALANS_RESET_DAMAGE@@@std@@YAPAUBALANS_RESET_DAMAGE@@IPAU1@@Z ENDP ; std::_Allocate<BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@ABU3@@Z ; std::allocator<BALANS_RESET_DAMAGE>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@ABU3@@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 197  : 		_Construct(_Ptr, _Val);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN5@construct@2
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN5@construct@2:
  00017	5f		 pop	 edi

; 198  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@ABU3@@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::construct
_TEXT	ENDS
PUBLIC	??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 19		 je	 SHORT $LN1@Move
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax
  00017	83 c2 20	 add	 edx, 32			; 00000020H
  0001a	b9 08 00 00 00	 mov	 ecx, 8
  0001f	83 c0 20	 add	 eax, 32			; 00000020H
  00022	f3 a5		 rep movsd
  00024	3b d3		 cmp	 edx, ebx
  00026	75 eb		 jne	 SHORT $LL3@Move
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$LN1@Move:
  0002a	5b		 pop	 ebx

; 2515 : 	return (_Dest);
; 2516 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@@Z ; std::allocator<BALANS_RESET_DAMAGE>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@$$QAU3@@Z ; std::allocator<BALANS_RESET_DAMAGE>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@$$QAU3@@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@3
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@3:
  00017	5f		 pop	 edi

; 203  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEXPAUBALANS_RESET_DAMAGE@@$$QAU3@@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::construct
_TEXT	ENDS
PUBLIC	??0?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Vector_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Vector_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QAE@PAUBALANS_RESET_DAMAGE@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::_Vector_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> > >::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEPAUBALANS_RESET_DAMAGE@@I@Z ; std::allocator<BALANS_RESET_DAMAGE>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEPAUBALANS_RESET_DAMAGE@@I@Z
_TEXT	SEGMENT
$T211437 = -12						; size = 12
$T211435 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEPAUBALANS_RESET_DAMAGE@@I@Z PROC ; std::allocator<BALANS_RESET_DAMAGE>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 40		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	07		 cmp	 ecx, 134217727		; 07ffffffH
  00015	77 10		 ja	 SHORT $LN3@allocate
  00017	c1 e1 05	 shl	 ecx, 5
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00027	8d 45 08	 lea	 eax, DWORD PTR $T211435[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T211437[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T211435[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T211437[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T211437[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEPAUBALANS_RESET_DAMAGE@@I@Z ENDP ; std::allocator<BALANS_RESET_DAMAGE>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@ABU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@ABU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@ABU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@ABU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN9@Cons_val@2
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN9@Cons_val@2:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@ABU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00@Z ; std::_Move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00@Z PROC ; std::_Move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 19		 je	 SHORT $LN5@Move@2
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL7@Move@2:
  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax
  00017	83 c2 20	 add	 edx, 32			; 00000020H
  0001a	b9 08 00 00 00	 mov	 ecx, 8
  0001f	83 c0 20	 add	 eax, 32			; 00000020H
  00022	f3 a5		 rep movsd
  00024	3b d3		 cmp	 edx, ebx
  00026	75 eb		 jne	 SHORT $LL7@Move@2
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$LN5@Move@2:
  0002a	5b		 pop	 ebx

; 2536 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Move@PAUBALANS_RESET_DAMAGE@@PAU1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00@Z ENDP ; std::_Move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@@Z ; std::_Dest_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@@Z PROC ; std::_Dest_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@@Z ENDP ; std::_Dest_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@U3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@$$QAU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@U3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@U3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@3
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 08 00 00 00	 mov	 ecx, 8
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@3:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@U3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@XZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<BALANS_RESET_DAMAGE> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@U3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@$$QAU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE>
  0001e	83 c6 20	 add	 esi, 32			; 00000020H
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 20	 add	 edi, 32			; 00000020H
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z ; std::_Destroy_range<std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BALANS_RESET_DAMAGE> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAXPAUBALANS_RESET_DAMAGE@@0AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z ; std::_Uninitialized_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z
_TEXT	SEGMENT
__Cat$211630 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z PROC ; std::_Uninitialized_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$211630[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@@Z ENDP ; std::_Uninitialized_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXPAUBALANS_RESET_DAMAGE@@0@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXPAUBALANS_RESET_DAMAGE@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXPAUBALANS_RESET_DAMAGE@@0@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXPAUBALANS_RESET_DAMAGE@@0@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUBALANS_RESET_DAMAGE@@@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEPAUBALANS_RESET_DAMAGE@@PAU2@00@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Umove<BALANS_RESET_DAMAGE *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUBALANS_RESET_DAMAGE@@@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEPAUBALANS_RESET_DAMAGE@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$211652 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUBALANS_RESET_DAMAGE@@@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEPAUBALANS_RESET_DAMAGE@@PAU2@00@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Umove<BALANS_RESET_DAMAGE *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$211652[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUBALANS_RESET_DAMAGE@@@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEPAUBALANS_RESET_DAMAGE@@PAU2@00@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Umove<BALANS_RESET_DAMAGE *>
_TEXT	ENDS
PUBLIC	?erase@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@0@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@0@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR __First_arg$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00012	89 1e		 mov	 DWORD PTR [esi], ebx
  00014	3b da		 cmp	 ebx, edx
  00016	74 27		 je	 SHORT $LN39@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00018	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001b	3b d0		 cmp	 edx, eax
  0001d	74 1d		 je	 SHORT $LN30@erase
  0001f	57		 push	 edi
$LL32@erase:
  00020	8b f2		 mov	 esi, edx
  00022	8b fb		 mov	 edi, ebx
  00024	83 c2 20	 add	 edx, 32			; 00000020H
  00027	b9 08 00 00 00	 mov	 ecx, 8
  0002c	83 c3 20	 add	 ebx, 32			; 00000020H
  0002f	f3 a5		 rep movsd
  00031	3b d0		 cmp	 edx, eax
  00033	75 eb		 jne	 SHORT $LL32@erase
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	5f		 pop	 edi
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  0003c	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN39@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 1214 : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@@2@0@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXXZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXXZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXXZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::reserve
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$210273 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$211823 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 07	 cmp	 eax, 134217727		; 07ffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 05	 sar	 ecx, 5
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 57		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UBALANS_RESET_DAMAGE@@@std@@QAEPAUBALANS_RESET_DAMAGE@@I@Z ; std::allocator<BALANS_RESET_DAMAGE>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$211823[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$210273[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUBALANS_RESET_DAMAGE@@PAU1@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@U1@@std@@YAPAUBALANS_RESET_DAMAGE@@PAU1@00AAV?$allocator@UBALANS_RESET_DAMAGE@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<BALANS_RESET_DAMAGE *,BALANS_RESET_DAMAGE *,std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	83 c4 18	 add	 esp, 24			; 00000018H
  00080	2b f8		 sub	 edi, eax

; 761  : 			if (this->_Myfirst != 0)

  00082	85 c0		 test	 eax, eax
  00084	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008c	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  0008f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00092	c1 e0 05	 shl	 eax, 5
  00095	03 c3		 add	 eax, ebx

; 770  : 			this->_Mylast = _Ptr + _Size;

  00097	83 e7 e0	 and	 edi, -32		; ffffffe0H
  0009a	03 fb		 add	 edi, ebx
  0009c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0009f	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 771  : 			this->_Myfirst = _Ptr;

  000a2	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ae	59		 pop	 ecx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b8	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$210273[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c1	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c4	6a 00		 push	 0
  000c6	6a 00		 push	 0
  000c8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  000cd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::reserve
PUBLIC	??1?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::~vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::~vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAE@XZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::~vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXXZ ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXXZ PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	53		 push	 ebx
  00008	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	3b da		 cmp	 ebx, edx
  0000f	74 2c		 je	 SHORT $LN19@clear
  00011	8b c2		 mov	 eax, edx
  00013	3b d2		 cmp	 edx, edx
  00015	74 23		 je	 SHORT $LN48@clear
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL50@clear:
  00020	8b f0		 mov	 esi, eax
  00022	8b fb		 mov	 edi, ebx
  00024	83 c0 20	 add	 eax, 32			; 00000020H
  00027	b9 08 00 00 00	 mov	 ecx, 8
  0002c	83 c3 20	 add	 ebx, 32			; 00000020H
  0002f	f3 a5		 rep movsd
  00031	3b c2		 cmp	 eax, edx
  00033	75 eb		 jne	 SHORT $LL50@clear
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
$LN48@clear:
  0003a	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN19@clear:
  0003d	5b		 pop	 ebx

; 1219 : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?clear@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXXZ ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXI@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 07	 mov	 edi, 134217727		; 07ffffffH
  00014	c1 f8 05	 sar	 eax, 5
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 05	 sar	 edx, 5
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 07	 mov	 edi, 134217727		; 07ffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::reserve
$LN1@Reserve:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXI@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Reserve
_TEXT	ENDS
PUBLIC	??_7cBalanceSystem@@6B@				; cBalanceSystem::`vftable'
PUBLIC	??1cBalanceSystem@@UAE@XZ			; cBalanceSystem::~cBalanceSystem
PUBLIC	??_R4cBalanceSystem@@6B@			; cBalanceSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcBalanceSystem@@@8			; cBalanceSystem `RTTI Type Descriptor'
PUBLIC	??_R3cBalanceSystem@@8				; cBalanceSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2cBalanceSystem@@8				; cBalanceSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@cBalanceSystem@@8			; cBalanceSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EcBalanceSystem@@UAEPAXI@Z:PROC		; cBalanceSystem::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@cBalanceSystem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@cBalanceSystem@@8 DD FLAT:??_R0?AVcBalanceSystem@@@8 ; cBalanceSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3cBalanceSystem@@8
rdata$r	ENDS
;	COMDAT ??_R2cBalanceSystem@@8
rdata$r	SEGMENT
??_R2cBalanceSystem@@8 DD FLAT:??_R1A@?0A@EA@cBalanceSystem@@8 ; cBalanceSystem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3cBalanceSystem@@8
rdata$r	SEGMENT
??_R3cBalanceSystem@@8 DD 00H				; cBalanceSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2cBalanceSystem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcBalanceSystem@@@8
_DATA	SEGMENT
??_R0?AVcBalanceSystem@@@8 DD FLAT:??_7type_info@@6B@	; cBalanceSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcBalanceSystem@@', 00H
_DATA	ENDS
;	COMDAT ??_R4cBalanceSystem@@6B@
rdata$r	SEGMENT
??_R4cBalanceSystem@@6B@ DD 00H				; cBalanceSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcBalanceSystem@@@8
	DD	FLAT:??_R3cBalanceSystem@@8
rdata$r	ENDS
;	COMDAT ??_7cBalanceSystem@@6B@
CONST	SEGMENT
??_7cBalanceSystem@@6B@ DD FLAT:??_R4cBalanceSystem@@6B@ ; cBalanceSystem::`vftable'
	DD	FLAT:??_EcBalanceSystem@@UAEPAXI@Z
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\balancesystem.cpp
CONST	ENDS
;	COMDAT ??1cBalanceSystem@@UAE@XZ
_TEXT	SEGMENT
??1cBalanceSystem@@UAE@XZ PROC				; cBalanceSystem::~cBalanceSystem, COMDAT
; _this$ = ecx

; 21   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7cBalanceSystem@@6B@

; 22   : }

  00009	8b 86 14 01 00
	00		 mov	 eax, DWORD PTR [esi+276]
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN11@cBalanceSy
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
$LN11@cBalanceSy:
  0001c	c7 86 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+276], 0
  00026	c7 86 18 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+280], 0
  00030	c7 86 1c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+284], 0
  0003a	5e		 pop	 esi
  0003b	c3		 ret	 0
??1cBalanceSystem@@UAE@XZ ENDP				; cBalanceSystem::~cBalanceSystem
_TEXT	ENDS
PUBLIC	?Init@cBalanceSystem@@QAEXXZ			; cBalanceSystem::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@cBalanceSystem@@QAEXXZ
_TEXT	SEGMENT
$T212320 = -4						; size = 4
?Init@cBalanceSystem@@QAEXXZ PROC			; cBalanceSystem::Init, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c1		 mov	 eax, ecx

; 26   : 	this->Enable	= true;
; 27   : 
; 28   : 	this->DKvsDK	= 100;

  00006	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H

; 29   : 	this->DKvsDW	= 100;
; 30   : 	this->DKvsELF	= 100;
; 31   : 	this->DKvsSUM	= 100;
; 32   : 	this->DKvsMG	= 100;
; 33   : 	this->DKvsDL	= 100;
; 34   : 	this->DKvsRF	= 100;
; 35   : 
; 36   : 	this->DWvsDW	= 100;
; 37   : 	this->DWvsDK	= 100;
; 38   : 	this->DWvsELF	= 100;
; 39   : 	this->DWvsSUM	= 100;
; 40   : 	this->DWvsMG	= 100;
; 41   : 	this->DWvsDL	= 100;
; 42   : 	this->DWvsRF	= 100;
; 43   : 
; 44   : 	this->ELFvsELF	= 100;
; 45   : 	this->ELFvsDK	= 100;
; 46   : 	this->ELFvsDW	= 100;
; 47   : 	this->ELFvsSUM	= 100;
; 48   : 	this->ELFvsMG	= 100;
; 49   : 	this->ELFvsDL	= 100;
; 50   : 	this->ELFvsRF	= 100;
; 51   : 
; 52   : 	this->SUMvsSUM	= 100;
; 53   : 	this->SUMvsDK	= 100;
; 54   : 	this->SUMvsDW	= 100;
; 55   : 	this->SUMvsELF	= 100;
; 56   : 	this->SUMvsMG	= 100;
; 57   : 	this->SUMvsDL	= 100;
; 58   : 	this->SUMvsRF	= 100;
; 59   : 
; 60   : 	this->MGvsMG	= 100;
; 61   : 	this->MGvsDK	= 100;
; 62   : 	this->MGvsDW	= 100;
; 63   : 	this->MGvsELF	= 100;
; 64   : 	this->MGvsSUM	= 100;
; 65   : 	this->MGvsDL	= 100;
; 66   : 	this->MGvsRF	= 100;
; 67   : 
; 68   : 	this->DLvsDL	= 100;
; 69   : 	this->DLvsDK	= 100;
; 70   : 	this->DLvsDW	= 100;
; 71   : 	this->DLvsELF	= 100;
; 72   : 	this->DLvsSUM	= 100;
; 73   : 	this->DLvsMG	= 100;
; 74   : 	this->DLvsRF	= 100;
; 75   : 
; 76   : 	this->RFvsRF	= 100;
; 77   : 	this->RFvsDK	= 100;
; 78   : 	this->RFvsDW	= 100;
; 79   : 	this->RFvsELF	= 100;
; 80   : 	this->RFvsSUM	= 100;
; 81   : 	this->RFvsMG	= 100;
; 82   : 	this->RFvsDL	= 100;
; 83   : 
; 84   : 	this->m_EnableMonster = false;

  0000b	33 d2		 xor	 edx, edx
  0000d	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00014	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00017	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001a	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0001d	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00020	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00023	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00026	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  00029	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  0002c	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  0002f	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  00032	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00035	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00038	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  0003b	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  0003e	89 48 44	 mov	 DWORD PTR [eax+68], ecx
  00041	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00044	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00047	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  0004a	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  0004d	89 48 58	 mov	 DWORD PTR [eax+88], ecx
  00050	89 48 5c	 mov	 DWORD PTR [eax+92], ecx
  00053	89 48 60	 mov	 DWORD PTR [eax+96], ecx
  00056	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00059	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  0005c	89 48 6c	 mov	 DWORD PTR [eax+108], ecx
  0005f	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  00062	89 48 74	 mov	 DWORD PTR [eax+116], ecx
  00065	89 48 78	 mov	 DWORD PTR [eax+120], ecx
  00068	89 48 7c	 mov	 DWORD PTR [eax+124], ecx
  0006b	89 88 80 00 00
	00		 mov	 DWORD PTR [eax+128], ecx
  00071	89 88 84 00 00
	00		 mov	 DWORD PTR [eax+132], ecx
  00077	89 88 88 00 00
	00		 mov	 DWORD PTR [eax+136], ecx
  0007d	89 88 8c 00 00
	00		 mov	 DWORD PTR [eax+140], ecx
  00083	89 88 90 00 00
	00		 mov	 DWORD PTR [eax+144], ecx
  00089	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx
  0008f	89 88 98 00 00
	00		 mov	 DWORD PTR [eax+152], ecx
  00095	89 88 9c 00 00
	00		 mov	 DWORD PTR [eax+156], ecx
  0009b	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx
  000a1	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx
  000a7	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx
  000ad	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx
  000b3	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
  000b9	89 88 b4 00 00
	00		 mov	 DWORD PTR [eax+180], ecx
  000bf	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx
  000c5	89 88 bc 00 00
	00		 mov	 DWORD PTR [eax+188], ecx
  000cb	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  000d1	89 88 c4 00 00
	00		 mov	 DWORD PTR [eax+196], ecx
  000d7	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  000dd	88 90 cc 00 00
	00		 mov	 BYTE PTR [eax+204], dl

; 85   : 
; 86   : 	this->m_DKvsMonster = 100;

  000e3	89 88 d0 00 00
	00		 mov	 DWORD PTR [eax+208], ecx

; 87   : 	this->m_DWvsMonster = 100;

  000e9	89 88 d4 00 00
	00		 mov	 DWORD PTR [eax+212], ecx

; 88   : 	this->m_ELFvsMonster = 100;

  000ef	89 88 d8 00 00
	00		 mov	 DWORD PTR [eax+216], ecx

; 89   : 	this->m_SUMvsMonster = 100;

  000f5	89 88 dc 00 00
	00		 mov	 DWORD PTR [eax+220], ecx

; 90   : 	this->m_MGvsMonster = 100;

  000fb	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx

; 91   : 	this->m_DLvsMonster = 100;

  00101	89 88 e4 00 00
	00		 mov	 DWORD PTR [eax+228], ecx

; 92   : 	this->m_RFvsMonster = 100;

  00107	89 88 e8 00 00
	00		 mov	 DWORD PTR [eax+232], ecx

; 93   : 
; 94   : 	this->m_EnableRefflect = 0;

  0010d	88 90 f0 00 00
	00		 mov	 BYTE PTR [eax+240], dl

; 95   : 	this->m_DWRefflectPercent = 100;

  00113	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx

; 96   : 	this->m_DKRefflectPercent = 100;

  00119	89 88 f8 00 00
	00		 mov	 DWORD PTR [eax+248], ecx

; 97   : 	this->m_FERefflectPercent = 100;

  0011f	89 88 fc 00 00
	00		 mov	 DWORD PTR [eax+252], ecx

; 98   : 	this->m_MGRefflectPercent = 100;

  00125	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx

; 99   : 	this->m_DLRefflectPercent = 100;

  0012b	89 88 04 01 00
	00		 mov	 DWORD PTR [eax+260], ecx

; 100  : 	this->m_SURefflectPercent = 100;

  00131	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx

; 101  : 	this->m_RFRefflectPercent = 100;

  00137	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 102  : 
; 103  : 	this->m_EnableDamagePercent = false;

  0013d	89 90 10 01 00
	00		 mov	 DWORD PTR [eax+272], edx

; 104  : 	this->m_vResetDamage.clear();

  00143	8b 88 14 01 00
	00		 mov	 ecx, DWORD PTR [eax+276]
  00149	53		 push	 ebx
  0014a	8b 98 18 01 00
	00		 mov	 ebx, DWORD PTR [eax+280]
  00150	3b cb		 cmp	 ecx, ebx
  00152	74 2e		 je	 SHORT $LN21@Init
  00154	89 4d fc	 mov	 DWORD PTR $T212320[ebp], ecx
  00157	8b d3		 mov	 edx, ebx
  00159	3b db		 cmp	 ebx, ebx
  0015b	74 1c		 je	 SHORT $LN50@Init
  0015d	56		 push	 esi
  0015e	57		 push	 edi
  0015f	90		 npad	 1
$LL59@Init:
  00160	8b 7d fc	 mov	 edi, DWORD PTR $T212320[ebp]
  00163	83 45 fc 20	 add	 DWORD PTR $T212320[ebp], 32 ; 00000020H
  00167	8b f2		 mov	 esi, edx
  00169	83 c2 20	 add	 edx, 32			; 00000020H
  0016c	b9 08 00 00 00	 mov	 ecx, 8
  00171	f3 a5		 rep movsd
  00173	3b d3		 cmp	 edx, ebx
  00175	75 e9		 jne	 SHORT $LL59@Init
  00177	5f		 pop	 edi
  00178	5e		 pop	 esi
$LN50@Init:
  00179	8b 4d fc	 mov	 ecx, DWORD PTR $T212320[ebp]
  0017c	89 88 18 01 00
	00		 mov	 DWORD PTR [eax+280], ecx
$LN21@Init:
  00182	5b		 pop	 ebx

; 105  : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
?Init@cBalanceSystem@@QAEXXZ ENDP			; cBalanceSystem::Init
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXABUBALANS_RESET_DAMAGE@@@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::push_back
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXABUBALANS_RESET_DAMAGE@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXABUBALANS_RESET_DAMAGE@@@Z PROC ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 36		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 30		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx

; 980  : 			if (this->_Mylast == this->_Myend)

  00019	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001c	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0001e	6a 01		 push	 1
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	83 e7 e0	 and	 edi, -32		; ffffffe0H
  0002d	03 3e		 add	 edi, DWORD PTR [esi]
  0002f	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00032	57		 push	 edi
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@AAU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@AAU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  0003d	83 46 04 20	 add	 DWORD PTR [esi+4], 32	; 00000020H
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00047	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004a	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0004c	6a 01		 push	 1
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@IAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00055	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00058	57		 push	 edi
  00059	52		 push	 edx
  0005a	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@ABU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@ABU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00066	83 46 04 20	 add	 DWORD PTR [esi+4], 32	; 00000020H
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
?push_back@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXABUBALANS_RESET_DAMAGE@@@Z ENDP ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::push_back
_TEXT	ENDS
PUBLIC	??0cBalanceSystem@@QAE@XZ			; cBalanceSystem::cBalanceSystem
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\balancesystem.cpp
;	COMDAT ??0cBalanceSystem@@QAE@XZ
_TEXT	SEGMENT
??0cBalanceSystem@@QAE@XZ PROC				; cBalanceSystem::cBalanceSystem, COMDAT
; _this$ = ecx

; 16   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	33 c0		 xor	 eax, eax
  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7cBalanceSystem@@6B@
  0000b	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  00011	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00017	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax

; 17   : 	this->Init();

  0001d	e8 00 00 00 00	 call	 ?Init@cBalanceSystem@@QAEXXZ ; cBalanceSystem::Init

; 18   : }

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??0cBalanceSystem@@QAE@XZ ENDP				; cBalanceSystem::cBalanceSystem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GcBalanceSystem@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GcBalanceSystem@@UAEPAXI@Z PROC			; cBalanceSystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1cBalanceSystem@@UAE@XZ ; cBalanceSystem::~cBalanceSystem
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GcBalanceSystem@@UAEPAXI@Z ENDP			; cBalanceSystem::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CA@PAICKKOH@?$FLAncent?5Drop?$FN?5?$CFs?5file?5not?5found?$AA@ ; `string'
PUBLIC	_filename$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ReadResetDamage@cBalanceSystem@@QAEXPAD@Z	; cBalanceSystem::ReadResetDamage
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PAICKKOH@?$FLAncent?5Drop?$FN?5?$CFs?5file?5not?5found?$AA@
CONST	SEGMENT
??_C@_0CA@PAICKKOH@?$FLAncent?5Drop?$FN?5?$CFs?5file?5not?5found?$AA@ DB '['
	DB	'Ancent Drop] %s file not found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\balancesystem.cpp
CONST	ENDS
;	COMDAT ?ReadResetDamage@cBalanceSystem@@QAEXPAD@Z
_TEXT	SEGMENT
_filename$GSCopy$ = -48					; size = 4
_iType$209839 = -44					; size = 4
_this$GSCopy$ = -40					; size = 4
_List$209852 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?ReadResetDamage@cBalanceSystem@@QAEXPAD@Z PROC		; cBalanceSystem::ReadResetDamage, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]

; 209  : 	SMDToken Token;
; 210  : 
; 211  : 	SMDFile = fopen(filename, "r");

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00019	56		 push	 esi
  0001a	89 4d d8	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 281  : 
; 282  : 				this->m_vResetDamage.push_back(List);

  0001d	89 75 d0	 mov	 DWORD PTR _filename$GSCopy$[ebp], esi
  00020	e8 00 00 00 00	 call	 _fopen
  00025	83 c4 08	 add	 esp, 8
  00028	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 1f		 jne	 SHORT $LN100@ReadResetD

; 212  : 
; 213  : 	if(!SMDFile)
; 214  : 	{
; 215  : 		MsgBox("[Ancent Drop] %s file not found", filename);

  00031	56		 push	 esi
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PAICKKOH@?$FLAncent?5Drop?$FN?5?$CFs?5file?5not?5found?$AA@
  00037	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0003c	83 c4 08	 add	 esp, 8
  0003f	5e		 pop	 esi

; 289  : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
$LN100@ReadResetD:

; 216  : 		return;
; 217  : 	}
; 218  : 
; 219  : 	while(true)
; 220  : 	{
; 221  : 		Token = GetToken();

  00050	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 222  : 
; 223  : 		if( Token == END )

  00055	83 f8 02	 cmp	 eax, 2
  00058	0f 84 78 02 00
	00		 je	 $LN107@ReadResetD
  0005e	53		 push	 ebx
  0005f	57		 push	 edi
$LL11@ReadResetD:

; 224  : 		{
; 225  : 			break;
; 226  : 		}
; 227  : 
; 228  : 		int iType = (int)TokenNumber;

  00060	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00066	e8 00 00 00 00	 call	 __ftol2_sse
  0006b	8b d8		 mov	 ebx, eax
  0006d	89 5d d4	 mov	 DWORD PTR _iType$209839[ebp], ebx

; 229  : 
; 230  : 		if(iType != 0 && iType != 1)

  00070	85 db		 test	 ebx, ebx
  00072	74 10		 je	 SHORT $LN133@ReadResetD
  00074	83 fb 01	 cmp	 ebx, 1
  00077	0f 85 57 02 00
	00		 jne	 $LN129@ReadResetD
  0007d	8d 49 00	 npad	 3
$LL7@ReadResetD:

; 231  : 		{
; 232  : 			break;
; 233  : 		}
; 234  : 
; 235  : 		while(true)
; 236  : 		{
; 237  : 			if(iType == 0)

  00080	85 db		 test	 ebx, ebx
  00082	75 52		 jne	 SHORT $LN5@ReadResetD
$LN133@ReadResetD:

; 238  : 			{
; 239  : 				Token = GetToken();

  00084	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 240  : 
; 241  : 				if(!strcmp("end", TokenString))

  00089	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0008e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL127@ReadResetD:
  00093	8a 10		 mov	 dl, BYTE PTR [eax]
  00095	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00097	75 1a		 jne	 SHORT $LN112@ReadResetD
  00099	84 d2		 test	 dl, dl
  0009b	74 12		 je	 SHORT $LN124@ReadResetD
  0009d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000a0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a3	75 0e		 jne	 SHORT $LN112@ReadResetD
  000a5	83 c0 02	 add	 eax, 2
  000a8	83 c1 02	 add	 ecx, 2
  000ab	84 d2		 test	 dl, dl
  000ad	75 e4		 jne	 SHORT $LL127@ReadResetD
$LN124@ReadResetD:
  000af	33 c0		 xor	 eax, eax
  000b1	eb 05		 jmp	 SHORT $LN114@ReadResetD
$LN112@ReadResetD:
  000b3	1b c0		 sbb	 eax, eax
  000b5	83 d8 ff	 sbb	 eax, -1
$LN114@ReadResetD:
  000b8	85 c0		 test	 eax, eax
  000ba	0f 84 06 02 00
	00		 je	 $LN103@ReadResetD

; 242  : 				{
; 243  : 					break;
; 244  : 				}
; 245  : 
; 246  : 				this->m_EnableDamagePercent = (int)TokenNumber;

  000c0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000c6	e8 00 00 00 00	 call	 __ftol2_sse
  000cb	8b 4d d8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000ce	89 81 10 01 00
	00		 mov	 DWORD PTR [ecx+272], eax
  000d4	eb aa		 jmp	 SHORT $LL7@ReadResetD
$LN5@ReadResetD:

; 247  : 			}
; 248  : 			else if(iType == 1)

  000d6	83 fb 01	 cmp	 ebx, 1
  000d9	75 a5		 jne	 SHORT $LL7@ReadResetD

; 249  : 			{
; 250  : 				Token = GetToken();

  000db	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 251  : 
; 252  : 				if(!strcmp("end", TokenString))

  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  000e5	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL128@ReadResetD:
  000f0	8a 10		 mov	 dl, BYTE PTR [eax]
  000f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f4	75 1a		 jne	 SHORT $LN116@ReadResetD
  000f6	84 d2		 test	 dl, dl
  000f8	74 12		 je	 SHORT $LN125@ReadResetD
  000fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00100	75 0e		 jne	 SHORT $LN116@ReadResetD
  00102	83 c0 02	 add	 eax, 2
  00105	83 c1 02	 add	 ecx, 2
  00108	84 d2		 test	 dl, dl
  0010a	75 e4		 jne	 SHORT $LL128@ReadResetD
$LN125@ReadResetD:
  0010c	33 c0		 xor	 eax, eax
  0010e	eb 05		 jmp	 SHORT $LN118@ReadResetD
$LN116@ReadResetD:
  00110	1b c0		 sbb	 eax, eax
  00112	83 d8 ff	 sbb	 eax, -1
$LN118@ReadResetD:
  00115	85 c0		 test	 eax, eax
  00117	0f 84 a9 01 00
	00		 je	 $LN103@ReadResetD

; 253  : 				{
; 254  : 					break;
; 255  : 				}
; 256  : 
; 257  : 				BALANS_RESET_DAMAGE List;
; 258  : 
; 259  : 				List.ResetNumber = (int)TokenNumber;

  0011d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00123	e8 00 00 00 00	 call	 __ftol2_sse
  00128	89 45 dc	 mov	 DWORD PTR _List$209852[ebp], eax

; 260  : 
; 261  : 				Token = GetToken();

  0012b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 262  : 				List.DWDamagePercent = (int)TokenNumber;

  00130	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00136	e8 00 00 00 00	 call	 __ftol2_sse
  0013b	89 45 e0	 mov	 DWORD PTR _List$209852[ebp+4], eax

; 263  : 
; 264  : 				Token = GetToken();

  0013e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 265  : 				List.DKDamagePercent = (int)TokenNumber;

  00143	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00149	e8 00 00 00 00	 call	 __ftol2_sse
  0014e	89 45 e4	 mov	 DWORD PTR _List$209852[ebp+8], eax

; 266  : 
; 267  : 				Token = GetToken();

  00151	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 268  : 				List.FEDamagePercent = (int)TokenNumber;

  00156	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0015c	e8 00 00 00 00	 call	 __ftol2_sse
  00161	89 45 e8	 mov	 DWORD PTR _List$209852[ebp+12], eax

; 269  : 
; 270  : 				Token = GetToken();

  00164	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 271  : 				List.MGDamagePercent = (int)TokenNumber;

  00169	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0016f	e8 00 00 00 00	 call	 __ftol2_sse
  00174	89 45 ec	 mov	 DWORD PTR _List$209852[ebp+16], eax

; 272  : 
; 273  : 				Token = GetToken();

  00177	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 274  : 				List.DLDamagePercent = (int)TokenNumber;

  0017c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00182	e8 00 00 00 00	 call	 __ftol2_sse
  00187	89 45 f0	 mov	 DWORD PTR _List$209852[ebp+20], eax

; 275  : 
; 276  : 				Token = GetToken();

  0018a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 277  : 				List.SUDamagePercent = (int)TokenNumber;

  0018f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00195	e8 00 00 00 00	 call	 __ftol2_sse
  0019a	89 45 f4	 mov	 DWORD PTR _List$209852[ebp+24], eax

; 278  : 
; 279  : 				Token = GetToken();

  0019d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 280  : 				List.RFDamagePercent = (int)TokenNumber;

  001a2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a8	e8 00 00 00 00	 call	 __ftol2_sse

; 281  : 
; 282  : 				this->m_vResetDamage.push_back(List);

  001ad	8b 75 d8	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  001b0	89 45 f8	 mov	 DWORD PTR _List$209852[ebp+28], eax
  001b3	8b 86 18 01 00
	00		 mov	 eax, DWORD PTR [esi+280]
  001b9	8d 55 dc	 lea	 edx, DWORD PTR _List$209852[ebp]
  001bc	3b d0		 cmp	 edx, eax
  001be	0f 83 8b 00 00
	00		 jae	 $LN18@ReadResetD
  001c4	8b 96 14 01 00
	00		 mov	 edx, DWORD PTR [esi+276]
  001ca	8d 4d dc	 lea	 ecx, DWORD PTR _List$209852[ebp]
  001cd	3b d1		 cmp	 edx, ecx
  001cf	77 7e		 ja	 SHORT $LN18@ReadResetD
  001d1	8b f9		 mov	 edi, ecx
  001d3	8b 8e 1c 01 00
	00		 mov	 ecx, DWORD PTR [esi+284]
  001d9	2b fa		 sub	 edi, edx
  001db	3b c1		 cmp	 eax, ecx
  001dd	75 44		 jne	 SHORT $LN29@ReadResetD
  001df	2b c2		 sub	 eax, edx
  001e1	c1 f8 05	 sar	 eax, 5
  001e4	3d fe ff ff 07	 cmp	 eax, 134217726		; 07fffffeH
  001e9	0f 87 16 01 00
	00		 ja	 $LN105@ReadResetD
  001ef	2b ca		 sub	 ecx, edx
  001f1	40		 inc	 eax
  001f2	c1 f9 05	 sar	 ecx, 5
  001f5	3b c1		 cmp	 eax, ecx
  001f7	76 2a		 jbe	 SHORT $LN29@ReadResetD
  001f9	8b d1		 mov	 edx, ecx
  001fb	d1 ea		 shr	 edx, 1
  001fd	bb ff ff ff 07	 mov	 ebx, 134217727		; 07ffffffH
  00202	2b da		 sub	 ebx, edx
  00204	3b d9		 cmp	 ebx, ecx
  00206	73 04		 jae	 SHORT $LN51@ReadResetD
  00208	33 c9		 xor	 ecx, ecx
  0020a	eb 02		 jmp	 SHORT $LN52@ReadResetD
$LN51@ReadResetD:
  0020c	03 ca		 add	 ecx, edx
$LN52@ReadResetD:
  0020e	3b c8		 cmp	 ecx, eax
  00210	73 02		 jae	 SHORT $LN48@ReadResetD
  00212	8b c8		 mov	 ecx, eax
$LN48@ReadResetD:
  00214	51		 push	 ecx
  00215	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  0021b	e8 00 00 00 00	 call	 ?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::reserve
  00220	8b 5d d4	 mov	 ebx, DWORD PTR _iType$209839[ebp]
$LN29@ReadResetD:
  00223	8b 96 18 01 00
	00		 mov	 edx, DWORD PTR [esi+280]
  00229	83 e7 e0	 and	 edi, -32		; ffffffe0H
  0022c	03 be 14 01 00
	00		 add	 edi, DWORD PTR [esi+276]
  00232	8d 86 20 01 00
	00		 lea	 eax, DWORD PTR [esi+288]
  00238	57		 push	 edi
  00239	52		 push	 edx
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@AAU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@AAU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE &>
  00240	83 c4 0c	 add	 esp, 12			; 0000000cH
  00243	83 86 18 01 00
	00 20		 add	 DWORD PTR [esi+280], 32	; 00000020H
  0024a	e9 31 fe ff ff	 jmp	 $LL7@ReadResetD
$LN18@ReadResetD:
  0024f	8b 8e 1c 01 00
	00		 mov	 ecx, DWORD PTR [esi+284]
  00255	3b c1		 cmp	 eax, ecx
  00257	75 47		 jne	 SHORT $LN64@ReadResetD
  00259	8b 96 14 01 00
	00		 mov	 edx, DWORD PTR [esi+276]
  0025f	2b c2		 sub	 eax, edx
  00261	c1 f8 05	 sar	 eax, 5
  00264	3d fe ff ff 07	 cmp	 eax, 134217726		; 07fffffeH
  00269	0f 87 96 00 00
	00		 ja	 $LN105@ReadResetD
  0026f	2b ca		 sub	 ecx, edx
  00271	40		 inc	 eax
  00272	c1 f9 05	 sar	 ecx, 5
  00275	3b c1		 cmp	 eax, ecx
  00277	76 27		 jbe	 SHORT $LN64@ReadResetD
  00279	8b d1		 mov	 edx, ecx
  0027b	d1 ea		 shr	 edx, 1
  0027d	bf ff ff ff 07	 mov	 edi, 134217727		; 07ffffffH
  00282	2b fa		 sub	 edi, edx
  00284	3b f9		 cmp	 edi, ecx
  00286	73 04		 jae	 SHORT $LN86@ReadResetD
  00288	33 c9		 xor	 ecx, ecx
  0028a	eb 02		 jmp	 SHORT $LN87@ReadResetD
$LN86@ReadResetD:
  0028c	03 ca		 add	 ecx, edx
$LN87@ReadResetD:
  0028e	3b c8		 cmp	 ecx, eax
  00290	73 02		 jae	 SHORT $LN83@ReadResetD
  00292	8b c8		 mov	 ecx, eax
$LN83@ReadResetD:
  00294	51		 push	 ecx
  00295	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  0029b	e8 00 00 00 00	 call	 ?reserve@?$vector@UBALANS_RESET_DAMAGE@@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@@std@@QAEXI@Z ; std::vector<BALANS_RESET_DAMAGE,std::allocator<BALANS_RESET_DAMAGE> >::reserve
$LN64@ReadResetD:
  002a0	8b 96 18 01 00
	00		 mov	 edx, DWORD PTR [esi+280]
  002a6	8d 4d dc	 lea	 ecx, DWORD PTR _List$209852[ebp]
  002a9	51		 push	 ecx
  002aa	52		 push	 edx
  002ab	8d 86 20 01 00
	00		 lea	 eax, DWORD PTR [esi+288]
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBALANS_RESET_DAMAGE@@@std@@UBALANS_RESET_DAMAGE@@ABU3@@std@@YAXAAV?$allocator@UBALANS_RESET_DAMAGE@@@0@PAUBALANS_RESET_DAMAGE@@ABU2@@Z ; std::_Cons_val<std::allocator<BALANS_RESET_DAMAGE>,BALANS_RESET_DAMAGE,BALANS_RESET_DAMAGE const &>
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ba	83 86 18 01 00
	00 20		 add	 DWORD PTR [esi+280], 32	; 00000020H

; 283  : 			}
; 284  : 		}

  002c1	e9 ba fd ff ff	 jmp	 $LL7@ReadResetD
$LN103@ReadResetD:

; 216  : 		return;
; 217  : 	}
; 218  : 
; 219  : 	while(true)
; 220  : 	{
; 221  : 		Token = GetToken();

  002c6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 222  : 
; 223  : 		if( Token == END )

  002cb	83 f8 02	 cmp	 eax, 2
  002ce	0f 85 8c fd ff
	ff		 jne	 $LL11@ReadResetD
$LN129@ReadResetD:
  002d4	5f		 pop	 edi
  002d5	5b		 pop	 ebx
$LN107@ReadResetD:

; 285  : 	}
; 286  : 
; 287  : 	fclose(SMDFile);

  002d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  002dc	51		 push	 ecx
  002dd	e8 00 00 00 00	 call	 _fclose

; 288  : 	LogAdd("%s file load!", filename);

  002e2	8b 55 d0	 mov	 edx, DWORD PTR _filename$GSCopy$[ebp]
  002e5	52		 push	 edx
  002e6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 289  : }

  002f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f7	33 cd		 xor	 ecx, ebp
  002f9	5e		 pop	 esi
  002fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ff	8b e5		 mov	 esp, ebp
  00301	5d		 pop	 ebp
  00302	c2 04 00	 ret	 4
$LN105@ReadResetD:

; 281  : 
; 282  : 				this->m_vResetDamage.push_back(List);

  00305	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0030a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN134@ReadResetD:
$LN131@ReadResetD:
  0030f	cc		 int	 3
?ReadResetDamage@cBalanceSystem@@QAEXPAD@Z ENDP		; cBalanceSystem::ReadResetDamage
_TEXT	ENDS
PUBLIC	??_C@_0BJ@EEILPBMP@ZtData?2BalanceDamage?4dat?$AA@ ; `string'
PUBLIC	??_C@_0BB@NPNFBGBF@RFReflectPercent?$AA@	; `string'
PUBLIC	??_C@_0BB@JHJMFHDK@SUReflectPercent?$AA@	; `string'
PUBLIC	??_C@_0BB@JLADICEM@DLReflectPercent?$AA@	; `string'
PUBLIC	??_C@_0BB@KAGOCNCM@MGReflectPercent?$AA@	; `string'
PUBLIC	??_C@_0BB@JCEEBMFF@FEReflectPercent?$AA@	; `string'
PUBLIC	??_C@_0BB@GGPKHKDJ@DKReflectPercent?$AA@	; `string'
PUBLIC	??_C@_0BB@CHPPJHGP@DWReflectPercent?$AA@	; `string'
PUBLIC	??_C@_07NLAFAPNO@Reflect?$AA@			; `string'
PUBLIC	??_C@_0O@DIPDMJIJ@EnableReflect?$AA@		; `string'
PUBLIC	??_C@_03BAPJJKHI@Pet?$AA@			; `string'
PUBLIC	??_C@_0BG@BDENJGAH@DKFenrirDamagePercent?$AA@	; `string'
PUBLIC	??_C@_0M@KMEMBOBB@RFvsMonster?$AA@		; `string'
PUBLIC	??_C@_0M@KNMGAOIJ@DLvsMonster?$AA@		; `string'
PUBLIC	??_C@_0M@BDEOLDFM@MGvsMonster?$AA@		; `string'
PUBLIC	??_C@_0N@DLBEKLII@SUMvsMonster?$AA@		; `string'
PUBLIC	??_C@_0N@JNGGICKG@ELFvsMonster?$AA@		; `string'
PUBLIC	??_C@_0M@CABBENAG@DWvsMonster?$AA@		; `string'
PUBLIC	??_C@_0M@IEPNBLAK@DKvsMonster?$AA@		; `string'
PUBLIC	??_C@_07GOHPBKOH@Monster?$AA@			; `string'
PUBLIC	??_C@_0O@INIJNMLA@EnableMonster?$AA@		; `string'
PUBLIC	??_C@_06CLJPAOGG@RFvsDL?$AA@			; `string'
PUBLIC	??_C@_06MHLKOMCC@RFvsMG?$AA@			; `string'
PUBLIC	??_C@_07DPBEJNPC@RFvsSUM?$AA@			; `string'
PUBLIC	??_C@_07LKGFNEIF@RFvsELF?$AA@			; `string'
PUBLIC	??_C@_06ICKJMFPM@RFvsDW?$AA@			; `string'
PUBLIC	??_C@_06GENOJIKB@RFvsDK?$AA@			; `string'
PUBLIC	??_C@_06MJNLDJCO@RFvsRF?$AA@			; `string'
PUBLIC	??_C@_06GMEOLDLM@DLvsRF?$AA@			; `string'
PUBLIC	??_C@_06GCCPGGLA@DLvsMG?$AA@			; `string'
PUBLIC	??_C@_07CBLAPKBA@DLvsSUM?$AA@			; `string'
PUBLIC	??_C@_07KEMBLDGH@DLvsELF?$AA@			; `string'
PUBLIC	??_C@_06CHDMEPGO@DLvsDW?$AA@			; `string'
PUBLIC	??_C@_06MBELBCDD@DLvsDK?$AA@			; `string'
PUBLIC	??_C@_06IOAKIEPE@DLvsDL?$AA@			; `string'
PUBLIC	??_C@_06JDBBAGKM@MGvsRF?$AA@			; `string'
PUBLIC	??_C@_06HBFFDBOE@MGvsDL?$AA@			; `string'
PUBLIC	??_C@_07DMPILFMB@MGvsSUM?$AA@			; `string'
PUBLIC	??_C@_07LJIJPMLG@MGvsELF?$AA@			; `string'
PUBLIC	??_C@_06NIGDPKHO@MGvsDW?$AA@			; `string'
PUBLIC	??_C@_06DOBEKHCD@MGvsDK?$AA@			; `string'
PUBLIC	??_C@_06JNHANDKA@MGvsMG?$AA@			; `string'
PUBLIC	??_C@_07EFFMADFB@SUMvsRF?$AA@			; `string'
PUBLIC	??_C@_07KHBIDEBJ@SUMvsDL?$AA@			; `string'
PUBLIC	??_C@_07ELDNNGFN@SUMvsMG?$AA@			; `string'
PUBLIC	??_C@_08HKFDDPBC@SUMvsELF?$AA@			; `string'
PUBLIC	??_C@_07OCOPPID@SUMvsDW?$AA@			; `string'
PUBLIC	??_C@_07OIFJKCNO@SUMvsDK?$AA@			; `string'
PUBLIC	??_C@_08PPCCHGGF@SUMvsSUM?$AA@			; `string'
PUBLIC	??_C@_07GHAJBCCD@ELFvsRF?$AA@			; `string'
PUBLIC	??_C@_07IFENCFGL@ELFvsDL?$AA@			; `string'
PUBLIC	??_C@_08DODMHBDM@ELFvsMG?5?$AA@			; `string'
PUBLIC	??_C@_08EBALDDGE@ELFvsSUM?$AA@			; `string'
PUBLIC	??_C@_07CMHLOOPB@ELFvsDW?$AA@			; `string'
PUBLIC	??_C@_07MKAMLDKM@ELFvsDK?$AA@			; `string'
PUBLIC	??_C@_08MEHKHKBD@ELFvsELF?$AA@			; `string'
PUBLIC	??_C@_06FFPEBOE@DWvsRF?$AA@			; `string'
PUBLIC	??_C@_06OHBLHGKM@DWvsDL?$AA@			; `string'
PUBLIC	??_C@_06LDOJEOI@DWvsMG?$AA@			; `string'
PUBLIC	??_C@_07EEGJDCCE@DWvsSUM?$AA@			; `string'
PUBLIC	??_C@_07MBBIHLFD@DWvsELF?$AA@			; `string'
PUBLIC	??_C@_06KIFKOAGL@DWvsDK?$AA@			; `string'
PUBLIC	??_C@_06EOCNLNDG@DWvsDW?$AA@			; `string'
PUBLIC	??_C@_06HBELIDAE@DKvsRF?$AA@			; `string'
PUBLIC	??_C@_06JDAPLEEM@DKvsDL?$AA@			; `string'
PUBLIC	??_C@_06HPCKFGAI@DKvsMG?$AA@			; `string'
PUBLIC	??_C@_07OEBHMEJO@DKvsSUM?$AA@			; `string'
PUBLIC	??_C@_07GBGGINOJ@DKvsELF?$AA@			; `string'
PUBLIC	??_C@_06DKDJHPNG@DKvsDW?$AA@			; `string'
PUBLIC	??_C@_06NMEOCCIL@DKvsDK?$AA@			; `string'
PUBLIC	??_C@_06POMJKEPM@Common?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	?ReadConfigs@cBalanceSystem@@QAEXPAD@Z		; cBalanceSystem::ReadConfigs
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?CheckFile@@YA_NPAD@Z:PROC			; CheckFile
;	COMDAT ??_C@_0BJ@EEILPBMP@ZtData?2BalanceDamage?4dat?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
CONST	SEGMENT
??_C@_0BJ@EEILPBMP@ZtData?2BalanceDamage?4dat?$AA@ DB 'ZtData\BalanceDama'
	DB	'ge.dat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NPNFBGBF@RFReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@NPNFBGBF@RFReflectPercent?$AA@ DB 'RFReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JHJMFHDK@SUReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@JHJMFHDK@SUReflectPercent?$AA@ DB 'SUReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JLADICEM@DLReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@JLADICEM@DLReflectPercent?$AA@ DB 'DLReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KAGOCNCM@MGReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@KAGOCNCM@MGReflectPercent?$AA@ DB 'MGReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCEEBMFF@FEReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@JCEEBMFF@FEReflectPercent?$AA@ DB 'FEReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGPKHKDJ@DKReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@GGPKHKDJ@DKReflectPercent?$AA@ DB 'DKReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHPPJHGP@DWReflectPercent?$AA@
CONST	SEGMENT
??_C@_0BB@CHPPJHGP@DWReflectPercent?$AA@ DB 'DWReflectPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NLAFAPNO@Reflect?$AA@
CONST	SEGMENT
??_C@_07NLAFAPNO@Reflect?$AA@ DB 'Reflect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DIPDMJIJ@EnableReflect?$AA@
CONST	SEGMENT
??_C@_0O@DIPDMJIJ@EnableReflect?$AA@ DB 'EnableReflect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BAPJJKHI@Pet?$AA@
CONST	SEGMENT
??_C@_03BAPJJKHI@Pet?$AA@ DB 'Pet', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDENJGAH@DKFenrirDamagePercent?$AA@
CONST	SEGMENT
??_C@_0BG@BDENJGAH@DKFenrirDamagePercent?$AA@ DB 'DKFenrirDamagePercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KMEMBOBB@RFvsMonster?$AA@
CONST	SEGMENT
??_C@_0M@KMEMBOBB@RFvsMonster?$AA@ DB 'RFvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KNMGAOIJ@DLvsMonster?$AA@
CONST	SEGMENT
??_C@_0M@KNMGAOIJ@DLvsMonster?$AA@ DB 'DLvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BDEOLDFM@MGvsMonster?$AA@
CONST	SEGMENT
??_C@_0M@BDEOLDFM@MGvsMonster?$AA@ DB 'MGvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLBEKLII@SUMvsMonster?$AA@
CONST	SEGMENT
??_C@_0N@DLBEKLII@SUMvsMonster?$AA@ DB 'SUMvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNGGICKG@ELFvsMonster?$AA@
CONST	SEGMENT
??_C@_0N@JNGGICKG@ELFvsMonster?$AA@ DB 'ELFvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CABBENAG@DWvsMonster?$AA@
CONST	SEGMENT
??_C@_0M@CABBENAG@DWvsMonster?$AA@ DB 'DWvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IEPNBLAK@DKvsMonster?$AA@
CONST	SEGMENT
??_C@_0M@IEPNBLAK@DKvsMonster?$AA@ DB 'DKvsMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOHPBKOH@Monster?$AA@
CONST	SEGMENT
??_C@_07GOHPBKOH@Monster?$AA@ DB 'Monster', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@INIJNMLA@EnableMonster?$AA@
CONST	SEGMENT
??_C@_0O@INIJNMLA@EnableMonster?$AA@ DB 'EnableMonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CLJPAOGG@RFvsDL?$AA@
CONST	SEGMENT
??_C@_06CLJPAOGG@RFvsDL?$AA@ DB 'RFvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MHLKOMCC@RFvsMG?$AA@
CONST	SEGMENT
??_C@_06MHLKOMCC@RFvsMG?$AA@ DB 'RFvsMG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPBEJNPC@RFvsSUM?$AA@
CONST	SEGMENT
??_C@_07DPBEJNPC@RFvsSUM?$AA@ DB 'RFvsSUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKGFNEIF@RFvsELF?$AA@
CONST	SEGMENT
??_C@_07LKGFNEIF@RFvsELF?$AA@ DB 'RFvsELF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICKJMFPM@RFvsDW?$AA@
CONST	SEGMENT
??_C@_06ICKJMFPM@RFvsDW?$AA@ DB 'RFvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GENOJIKB@RFvsDK?$AA@
CONST	SEGMENT
??_C@_06GENOJIKB@RFvsDK?$AA@ DB 'RFvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJNLDJCO@RFvsRF?$AA@
CONST	SEGMENT
??_C@_06MJNLDJCO@RFvsRF?$AA@ DB 'RFvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMEOLDLM@DLvsRF?$AA@
CONST	SEGMENT
??_C@_06GMEOLDLM@DLvsRF?$AA@ DB 'DLvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GCCPGGLA@DLvsMG?$AA@
CONST	SEGMENT
??_C@_06GCCPGGLA@DLvsMG?$AA@ DB 'DLvsMG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBLAPKBA@DLvsSUM?$AA@
CONST	SEGMENT
??_C@_07CBLAPKBA@DLvsSUM?$AA@ DB 'DLvsSUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEMBLDGH@DLvsELF?$AA@
CONST	SEGMENT
??_C@_07KEMBLDGH@DLvsELF?$AA@ DB 'DLvsELF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHDMEPGO@DLvsDW?$AA@
CONST	SEGMENT
??_C@_06CHDMEPGO@DLvsDW?$AA@ DB 'DLvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MBELBCDD@DLvsDK?$AA@
CONST	SEGMENT
??_C@_06MBELBCDD@DLvsDK?$AA@ DB 'DLvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IOAKIEPE@DLvsDL?$AA@
CONST	SEGMENT
??_C@_06IOAKIEPE@DLvsDL?$AA@ DB 'DLvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JDBBAGKM@MGvsRF?$AA@
CONST	SEGMENT
??_C@_06JDBBAGKM@MGvsRF?$AA@ DB 'MGvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBFFDBOE@MGvsDL?$AA@
CONST	SEGMENT
??_C@_06HBFFDBOE@MGvsDL?$AA@ DB 'MGvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DMPILFMB@MGvsSUM?$AA@
CONST	SEGMENT
??_C@_07DMPILFMB@MGvsSUM?$AA@ DB 'MGvsSUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LJIJPMLG@MGvsELF?$AA@
CONST	SEGMENT
??_C@_07LJIJPMLG@MGvsELF?$AA@ DB 'MGvsELF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NIGDPKHO@MGvsDW?$AA@
CONST	SEGMENT
??_C@_06NIGDPKHO@MGvsDW?$AA@ DB 'MGvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOBEKHCD@MGvsDK?$AA@
CONST	SEGMENT
??_C@_06DOBEKHCD@MGvsDK?$AA@ DB 'MGvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNHANDKA@MGvsMG?$AA@
CONST	SEGMENT
??_C@_06JNHANDKA@MGvsMG?$AA@ DB 'MGvsMG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFFMADFB@SUMvsRF?$AA@
CONST	SEGMENT
??_C@_07EFFMADFB@SUMvsRF?$AA@ DB 'SUMvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHBIDEBJ@SUMvsDL?$AA@
CONST	SEGMENT
??_C@_07KHBIDEBJ@SUMvsDL?$AA@ DB 'SUMvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ELDNNGFN@SUMvsMG?$AA@
CONST	SEGMENT
??_C@_07ELDNNGFN@SUMvsMG?$AA@ DB 'SUMvsMG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HKFDDPBC@SUMvsELF?$AA@
CONST	SEGMENT
??_C@_08HKFDDPBC@SUMvsELF?$AA@ DB 'SUMvsELF', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCOPPID@SUMvsDW?$AA@
CONST	SEGMENT
??_C@_07OCOPPID@SUMvsDW?$AA@ DB 'SUMvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OIFJKCNO@SUMvsDK?$AA@
CONST	SEGMENT
??_C@_07OIFJKCNO@SUMvsDK?$AA@ DB 'SUMvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPCCHGGF@SUMvsSUM?$AA@
CONST	SEGMENT
??_C@_08PPCCHGGF@SUMvsSUM?$AA@ DB 'SUMvsSUM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHAJBCCD@ELFvsRF?$AA@
CONST	SEGMENT
??_C@_07GHAJBCCD@ELFvsRF?$AA@ DB 'ELFvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IFENCFGL@ELFvsDL?$AA@
CONST	SEGMENT
??_C@_07IFENCFGL@ELFvsDL?$AA@ DB 'ELFvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DODMHBDM@ELFvsMG?5?$AA@
CONST	SEGMENT
??_C@_08DODMHBDM@ELFvsMG?5?$AA@ DB 'ELFvsMG ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBALDDGE@ELFvsSUM?$AA@
CONST	SEGMENT
??_C@_08EBALDDGE@ELFvsSUM?$AA@ DB 'ELFvsSUM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMHLOOPB@ELFvsDW?$AA@
CONST	SEGMENT
??_C@_07CMHLOOPB@ELFvsDW?$AA@ DB 'ELFvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKAMLDKM@ELFvsDK?$AA@
CONST	SEGMENT
??_C@_07MKAMLDKM@ELFvsDK?$AA@ DB 'ELFvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MEHKHKBD@ELFvsELF?$AA@
CONST	SEGMENT
??_C@_08MEHKHKBD@ELFvsELF?$AA@ DB 'ELFvsELF', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFPEBOE@DWvsRF?$AA@
CONST	SEGMENT
??_C@_06FFPEBOE@DWvsRF?$AA@ DB 'DWvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHBLHGKM@DWvsDL?$AA@
CONST	SEGMENT
??_C@_06OHBLHGKM@DWvsDL?$AA@ DB 'DWvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LDOJEOI@DWvsMG?$AA@
CONST	SEGMENT
??_C@_06LDOJEOI@DWvsMG?$AA@ DB 'DWvsMG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEGJDCCE@DWvsSUM?$AA@
CONST	SEGMENT
??_C@_07EEGJDCCE@DWvsSUM?$AA@ DB 'DWvsSUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MBBIHLFD@DWvsELF?$AA@
CONST	SEGMENT
??_C@_07MBBIHLFD@DWvsELF?$AA@ DB 'DWvsELF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KIFKOAGL@DWvsDK?$AA@
CONST	SEGMENT
??_C@_06KIFKOAGL@DWvsDK?$AA@ DB 'DWvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOCNLNDG@DWvsDW?$AA@
CONST	SEGMENT
??_C@_06EOCNLNDG@DWvsDW?$AA@ DB 'DWvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBELIDAE@DKvsRF?$AA@
CONST	SEGMENT
??_C@_06HBELIDAE@DKvsRF?$AA@ DB 'DKvsRF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JDAPLEEM@DKvsDL?$AA@
CONST	SEGMENT
??_C@_06JDAPLEEM@DKvsDL?$AA@ DB 'DKvsDL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPCKFGAI@DKvsMG?$AA@
CONST	SEGMENT
??_C@_06HPCKFGAI@DKvsMG?$AA@ DB 'DKvsMG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEBHMEJO@DKvsSUM?$AA@
CONST	SEGMENT
??_C@_07OEBHMEJO@DKvsSUM?$AA@ DB 'DKvsSUM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GBGGINOJ@DKvsELF?$AA@
CONST	SEGMENT
??_C@_07GBGGINOJ@DKvsELF?$AA@ DB 'DKvsELF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKDJHPNG@DKvsDW?$AA@
CONST	SEGMENT
??_C@_06DKDJHPNG@DKvsDW?$AA@ DB 'DKvsDW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMEOCCIL@DKvsDK?$AA@
CONST	SEGMENT
??_C@_06NMEOCCIL@DKvsDK?$AA@ DB 'DKvsDK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06POMJKEPM@Common?$AA@
CONST	SEGMENT
??_C@_06POMJKEPM@Common?$AA@ DB 'Common', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\balancesystem.cpp
CONST	ENDS
;	COMDAT ?ReadConfigs@cBalanceSystem@@QAEXPAD@Z
_TEXT	SEGMENT
$T212993 = 8						; size = 4
_File$ = 8						; size = 4
?ReadConfigs@cBalanceSystem@@QAEXPAD@Z PROC		; cBalanceSystem::ReadConfigs, COMDAT
; _this$ = ecx

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 109  : 	CheckFile(File);

  00005	8b 75 08	 mov	 esi, DWORD PTR _File$[ebp]
  00008	57		 push	 edi
  00009	56		 push	 esi
  0000a	8b d9		 mov	 ebx, ecx
  0000c	e8 00 00 00 00	 call	 ?CheckFile@@YA_NPAD@Z	; CheckFile

; 110  : 
; 111  : 	this->Enable	= GetPrivateProfileInt("Common", "Enable", 0, File);

  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00017	83 c4 04	 add	 esp, 4
  0001a	56		 push	 esi
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00027	ff d7		 call	 edi

; 112  : 
; 113  : 	this->DKvsDK	= GetPrivateProfileInt("Common", "DKvsDK", 100, File);

  00029	56		 push	 esi
  0002a	6a 64		 push	 100			; 00000064H
  0002c	85 c0		 test	 eax, eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_06NMEOCCIL@DKvsDK?$AA@
  00033	0f 95 c0	 setne	 al
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0003b	88 43 04	 mov	 BYTE PTR [ebx+4], al
  0003e	ff d7		 call	 edi

; 114  : 	this->DKvsDW	= GetPrivateProfileInt("Common", "DKvsDW", 100, File);

  00040	56		 push	 esi
  00041	6a 64		 push	 100			; 00000064H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_06DKDJHPNG@DKvsDW?$AA@
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0004d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00050	ff d7		 call	 edi

; 115  : 	this->DKvsELF	= GetPrivateProfileInt("Common", "DKvsELF", 100, File);

  00052	56		 push	 esi
  00053	6a 64		 push	 100			; 00000064H
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_07GBGGINOJ@DKvsELF?$AA@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0005f	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00062	ff d7		 call	 edi

; 116  : 	this->DKvsSUM	= GetPrivateProfileInt("Common", "DKvsSUM", 100, File);

  00064	56		 push	 esi
  00065	6a 64		 push	 100			; 00000064H
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_07OEBHMEJO@DKvsSUM?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00071	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00074	ff d7		 call	 edi

; 117  : 	this->DKvsMG	= GetPrivateProfileInt("Common", "DKvsMG", 100, File);

  00076	56		 push	 esi
  00077	6a 64		 push	 100			; 00000064H
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_06HPCKFGAI@DKvsMG?$AA@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00083	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  00086	ff d7		 call	 edi

; 118  : 	this->DKvsDL	= GetPrivateProfileInt("Common", "DKvsDL", 100, File);

  00088	56		 push	 esi
  00089	6a 64		 push	 100			; 00000064H
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_06JDAPLEEM@DKvsDL?$AA@
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00095	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00098	ff d7		 call	 edi

; 119  : 	this->DKvsRF	= GetPrivateProfileInt("Common", "DKvsRF", 100, File);

  0009a	56		 push	 esi
  0009b	6a 64		 push	 100			; 00000064H
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_06HBELIDAE@DKvsRF?$AA@
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000a7	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  000aa	ff d7		 call	 edi

; 120  : 
; 121  : 	this->DWvsDW	= GetPrivateProfileInt("Common", "DWvsDW", 100, File);

  000ac	56		 push	 esi
  000ad	6a 64		 push	 100			; 00000064H
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_06EOCNLNDG@DWvsDW?$AA@
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000b9	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  000bc	ff d7		 call	 edi

; 122  : 	this->DWvsDK	= GetPrivateProfileInt("Common", "DWvsDK", 100, File);

  000be	56		 push	 esi
  000bf	6a 64		 push	 100			; 00000064H
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_06KIFKOAGL@DWvsDK?$AA@
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000cb	89 43 24	 mov	 DWORD PTR [ebx+36], eax
  000ce	ff d7		 call	 edi

; 123  : 	this->DWvsELF	= GetPrivateProfileInt("Common", "DWvsELF", 100, File);

  000d0	56		 push	 esi
  000d1	6a 64		 push	 100			; 00000064H
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_07MBBIHLFD@DWvsELF?$AA@
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000dd	89 43 28	 mov	 DWORD PTR [ebx+40], eax
  000e0	ff d7		 call	 edi

; 124  : 	this->DWvsSUM	= GetPrivateProfileInt("Common", "DWvsSUM", 100, File);

  000e2	56		 push	 esi
  000e3	6a 64		 push	 100			; 00000064H
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_07EEGJDCCE@DWvsSUM?$AA@
  000ea	89 43 2c	 mov	 DWORD PTR [ebx+44], eax
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000f2	ff d7		 call	 edi

; 125  : 	this->DWvsMG	= GetPrivateProfileInt("Common", "DWvsMG", 100, File);

  000f4	56		 push	 esi
  000f5	6a 64		 push	 100			; 00000064H
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_06LDOJEOI@DWvsMG?$AA@
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00101	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  00104	ff d7		 call	 edi

; 126  : 	this->DWvsDL	= GetPrivateProfileInt("Common", "DWvsDL", 100, File);

  00106	56		 push	 esi
  00107	6a 64		 push	 100			; 00000064H
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_06OHBLHGKM@DWvsDL?$AA@
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00113	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00116	ff d7		 call	 edi

; 127  : 	this->DWvsRF	= GetPrivateProfileInt("Common", "DWvsRF", 100, File);

  00118	56		 push	 esi
  00119	6a 64		 push	 100			; 00000064H
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_06FFPEBOE@DWvsRF?$AA@
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00125	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00128	ff d7		 call	 edi

; 128  : 
; 129  : 	this->ELFvsELF	= GetPrivateProfileInt("Common", "ELFvsELF", 100, File);

  0012a	56		 push	 esi
  0012b	6a 64		 push	 100			; 00000064H
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_08MEHKHKBD@ELFvsELF?$AA@
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00137	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0013a	ff d7		 call	 edi

; 130  : 	this->ELFvsDK	= GetPrivateProfileInt("Common", "ELFvsDK", 100, File);

  0013c	56		 push	 esi
  0013d	6a 64		 push	 100			; 00000064H
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_07MKAMLDKM@ELFvsDK?$AA@
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00149	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  0014c	ff d7		 call	 edi

; 131  : 	this->ELFvsDW	= GetPrivateProfileInt("Common", "ELFvsDW", 100, File);

  0014e	56		 push	 esi
  0014f	6a 64		 push	 100			; 00000064H
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_07CMHLOOPB@ELFvsDW?$AA@
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0015b	89 43 44	 mov	 DWORD PTR [ebx+68], eax
  0015e	ff d7		 call	 edi

; 132  : 	this->ELFvsSUM	= GetPrivateProfileInt("Common", "ELFvsSUM", 100, File);

  00160	56		 push	 esi
  00161	6a 64		 push	 100			; 00000064H
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_08EBALDDGE@ELFvsSUM?$AA@
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0016d	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  00170	ff d7		 call	 edi

; 133  : 	this->ELFvsMG	= GetPrivateProfileInt("Common", "ELFvsMG ", 100, File);

  00172	56		 push	 esi
  00173	6a 64		 push	 100			; 00000064H
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_08DODMHBDM@ELFvsMG?5?$AA@
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0017f	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
  00182	ff d7		 call	 edi

; 134  : 	this->ELFvsDL	= GetPrivateProfileInt("Common", "ELFvsDL", 100, File);

  00184	56		 push	 esi
  00185	6a 64		 push	 100			; 00000064H
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_07IFENCFGL@ELFvsDL?$AA@
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00191	89 43 50	 mov	 DWORD PTR [ebx+80], eax
  00194	ff d7		 call	 edi

; 135  : 	this->ELFvsRF	= GetPrivateProfileInt("Common", "ELFvsRF", 100, File);

  00196	56		 push	 esi
  00197	6a 64		 push	 100			; 00000064H
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_07GHAJBCCD@ELFvsRF?$AA@
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  001a3	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  001a6	ff d7		 call	 edi

; 136  : 
; 137  : 	this->SUMvsSUM	= GetPrivateProfileInt("Common", "SUMvsSUM", 100, File);

  001a8	56		 push	 esi
  001a9	6a 64		 push	 100			; 00000064H
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_08PPCCHGGF@SUMvsSUM?$AA@
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  001b5	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  001b8	ff d7		 call	 edi

; 138  : 	this->SUMvsDK	= GetPrivateProfileInt("Common", "SUMvsDK", 100, File);

  001ba	56		 push	 esi
  001bb	6a 64		 push	 100			; 00000064H
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_07OIFJKCNO@SUMvsDK?$AA@
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  001c7	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  001ca	ff d7		 call	 edi

; 139  : 	this->SUMvsDW	= GetPrivateProfileInt("Common", "SUMvsDW", 100, File);

  001cc	56		 push	 esi
  001cd	6a 64		 push	 100			; 00000064H
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_07OCOPPID@SUMvsDW?$AA@
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  001d9	89 43 60	 mov	 DWORD PTR [ebx+96], eax
  001dc	ff d7		 call	 edi
  001de	89 43 64	 mov	 DWORD PTR [ebx+100], eax

; 140  : 	this->SUMvsELF	= GetPrivateProfileInt("Common", "SUMvsELF", 100, File);

  001e1	56		 push	 esi
  001e2	6a 64		 push	 100			; 00000064H
  001e4	68 00 00 00 00	 push	 OFFSET ??_C@_08HKFDDPBC@SUMvsELF?$AA@
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  001ee	ff d7		 call	 edi

; 141  : 	this->SUMvsMG	= GetPrivateProfileInt("Common", "SUMvsMG", 100, File);

  001f0	56		 push	 esi
  001f1	6a 64		 push	 100			; 00000064H
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_07ELDNNGFN@SUMvsMG?$AA@
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  001fd	89 43 68	 mov	 DWORD PTR [ebx+104], eax
  00200	ff d7		 call	 edi

; 142  : 	this->SUMvsDL	= GetPrivateProfileInt("Common", "SUMvsDL", 100, File);

  00202	56		 push	 esi
  00203	6a 64		 push	 100			; 00000064H
  00205	68 00 00 00 00	 push	 OFFSET ??_C@_07KHBIDEBJ@SUMvsDL?$AA@
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0020f	89 43 6c	 mov	 DWORD PTR [ebx+108], eax
  00212	ff d7		 call	 edi

; 143  : 	this->SUMvsRF	= GetPrivateProfileInt("Common", "SUMvsRF", 100, File);

  00214	56		 push	 esi
  00215	6a 64		 push	 100			; 00000064H
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_07EFFMADFB@SUMvsRF?$AA@
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00221	89 43 70	 mov	 DWORD PTR [ebx+112], eax
  00224	ff d7		 call	 edi

; 144  : 
; 145  : 	this->MGvsMG	= GetPrivateProfileInt("Common", "MGvsMG", 100, File);

  00226	56		 push	 esi
  00227	6a 64		 push	 100			; 00000064H
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_06JNHANDKA@MGvsMG?$AA@
  0022e	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00233	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  00236	ff d7		 call	 edi

; 146  : 	this->MGvsDK	= GetPrivateProfileInt("Common", "MGvsDK", 100, File);

  00238	56		 push	 esi
  00239	6a 64		 push	 100			; 00000064H
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_06DOBEKHCD@MGvsDK?$AA@
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00245	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  00248	ff d7		 call	 edi

; 147  : 	this->MGvsDW	= GetPrivateProfileInt("Common", "MGvsDW", 100, File);

  0024a	56		 push	 esi
  0024b	6a 64		 push	 100			; 00000064H
  0024d	68 00 00 00 00	 push	 OFFSET ??_C@_06NIGDPKHO@MGvsDW?$AA@
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00257	89 43 7c	 mov	 DWORD PTR [ebx+124], eax
  0025a	ff d7		 call	 edi

; 148  : 	this->MGvsELF	= GetPrivateProfileInt("Common", "MGvsELF", 100, File);

  0025c	56		 push	 esi
  0025d	6a 64		 push	 100			; 00000064H
  0025f	68 00 00 00 00	 push	 OFFSET ??_C@_07LJIJPMLG@MGvsELF?$AA@
  00264	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00269	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax
  0026f	ff d7		 call	 edi

; 149  : 	this->MGvsSUM	= GetPrivateProfileInt("Common", "MGvsSUM", 100, File);

  00271	56		 push	 esi
  00272	6a 64		 push	 100			; 00000064H
  00274	68 00 00 00 00	 push	 OFFSET ??_C@_07DMPILFMB@MGvsSUM?$AA@
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0027e	89 83 84 00 00
	00		 mov	 DWORD PTR [ebx+132], eax
  00284	ff d7		 call	 edi

; 150  : 	this->MGvsDL	= GetPrivateProfileInt("Common", "MGvsDL", 100, File);

  00286	56		 push	 esi
  00287	6a 64		 push	 100			; 00000064H
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_06HBFFDBOE@MGvsDL?$AA@
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00293	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00299	ff d7		 call	 edi

; 151  : 	this->MGvsRF	= GetPrivateProfileInt("Common", "MGvsRF", 100, File);

  0029b	56		 push	 esi
  0029c	6a 64		 push	 100			; 00000064H
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_06JDBBAGKM@MGvsRF?$AA@
  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  002a8	89 83 8c 00 00
	00		 mov	 DWORD PTR [ebx+140], eax
  002ae	ff d7		 call	 edi

; 152  : 
; 153  : 	this->DLvsDL	= GetPrivateProfileInt("Common", "DLvsDL", 100, File);

  002b0	56		 push	 esi
  002b1	6a 64		 push	 100			; 00000064H
  002b3	68 00 00 00 00	 push	 OFFSET ??_C@_06IOAKIEPE@DLvsDL?$AA@
  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  002bd	89 83 90 00 00
	00		 mov	 DWORD PTR [ebx+144], eax
  002c3	ff d7		 call	 edi

; 154  : 	this->DLvsDK	= GetPrivateProfileInt("Common", "DLvsDK", 100, File);

  002c5	56		 push	 esi
  002c6	6a 64		 push	 100			; 00000064H
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_06MBELBCDD@DLvsDK?$AA@
  002cd	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  002d2	89 83 94 00 00
	00		 mov	 DWORD PTR [ebx+148], eax
  002d8	ff d7		 call	 edi

; 155  : 	this->DLvsDW	= GetPrivateProfileInt("Common", "DLvsDW", 100, File);

  002da	56		 push	 esi
  002db	6a 64		 push	 100			; 00000064H
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_06CHDMEPGO@DLvsDW?$AA@
  002e2	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax
  002e8	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  002ed	ff d7		 call	 edi

; 156  : 	this->DLvsELF	= GetPrivateProfileInt("Common", "DLvsELF", 100, File);

  002ef	56		 push	 esi
  002f0	6a 64		 push	 100			; 00000064H
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_07KEMBLDGH@DLvsELF?$AA@
  002f7	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  002fc	89 83 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], eax
  00302	ff d7		 call	 edi

; 157  : 	this->DLvsSUM	= GetPrivateProfileInt("Common", "DLvsSUM", 100, File);

  00304	56		 push	 esi
  00305	6a 64		 push	 100			; 00000064H
  00307	68 00 00 00 00	 push	 OFFSET ??_C@_07CBLAPKBA@DLvsSUM?$AA@
  0030c	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00311	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax
  00317	ff d7		 call	 edi

; 158  : 	this->DLvsMG	= GetPrivateProfileInt("Common", "DLvsMG", 100, File);

  00319	56		 push	 esi
  0031a	6a 64		 push	 100			; 00000064H
  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_06GCCPGGLA@DLvsMG?$AA@
  00321	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00326	89 83 a4 00 00
	00		 mov	 DWORD PTR [ebx+164], eax
  0032c	ff d7		 call	 edi

; 159  : 	this->DLvsRF	= GetPrivateProfileInt("Common", "DLvsRF", 100, File);

  0032e	56		 push	 esi
  0032f	6a 64		 push	 100			; 00000064H
  00331	68 00 00 00 00	 push	 OFFSET ??_C@_06GMEOLDLM@DLvsRF?$AA@
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0033b	89 83 a8 00 00
	00		 mov	 DWORD PTR [ebx+168], eax
  00341	ff d7		 call	 edi

; 160  : 
; 161  : 	this->RFvsRF	= GetPrivateProfileInt("Common", "RFvsRF", 100, File);

  00343	56		 push	 esi
  00344	6a 64		 push	 100			; 00000064H
  00346	68 00 00 00 00	 push	 OFFSET ??_C@_06MJNLDJCO@RFvsRF?$AA@
  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00350	89 83 ac 00 00
	00		 mov	 DWORD PTR [ebx+172], eax
  00356	ff d7		 call	 edi

; 162  : 	this->RFvsDK	= GetPrivateProfileInt("Common", "RFvsDK", 100, File);

  00358	56		 push	 esi
  00359	6a 64		 push	 100			; 00000064H
  0035b	68 00 00 00 00	 push	 OFFSET ??_C@_06GENOJIKB@RFvsDK?$AA@
  00360	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00365	89 83 b0 00 00
	00		 mov	 DWORD PTR [ebx+176], eax
  0036b	ff d7		 call	 edi

; 163  : 	this->RFvsDW	= GetPrivateProfileInt("Common", "RFvsDW", 100, File);

  0036d	56		 push	 esi
  0036e	6a 64		 push	 100			; 00000064H
  00370	68 00 00 00 00	 push	 OFFSET ??_C@_06ICKJMFPM@RFvsDW?$AA@
  00375	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0037a	89 83 b4 00 00
	00		 mov	 DWORD PTR [ebx+180], eax
  00380	ff d7		 call	 edi

; 164  : 	this->RFvsELF	= GetPrivateProfileInt("Common", "RFvsELF", 100, File);

  00382	56		 push	 esi
  00383	6a 64		 push	 100			; 00000064H
  00385	68 00 00 00 00	 push	 OFFSET ??_C@_07LKGFNEIF@RFvsELF?$AA@
  0038a	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0038f	89 83 b8 00 00
	00		 mov	 DWORD PTR [ebx+184], eax
  00395	ff d7		 call	 edi

; 165  : 	this->RFvsSUM	= GetPrivateProfileInt("Common", "RFvsSUM", 100, File);

  00397	56		 push	 esi
  00398	6a 64		 push	 100			; 00000064H
  0039a	68 00 00 00 00	 push	 OFFSET ??_C@_07DPBEJNPC@RFvsSUM?$AA@
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  003a4	89 83 bc 00 00
	00		 mov	 DWORD PTR [ebx+188], eax
  003aa	ff d7		 call	 edi

; 166  : 	this->RFvsMG	= GetPrivateProfileInt("Common", "RFvsMG", 100, File);

  003ac	56		 push	 esi
  003ad	6a 64		 push	 100			; 00000064H
  003af	68 00 00 00 00	 push	 OFFSET ??_C@_06MHLKOMCC@RFvsMG?$AA@
  003b4	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  003b9	89 83 c0 00 00
	00		 mov	 DWORD PTR [ebx+192], eax
  003bf	ff d7		 call	 edi

; 167  : 	this->RFvsDL	= GetPrivateProfileInt("Common", "RFvsDL", 100, File);

  003c1	56		 push	 esi
  003c2	6a 64		 push	 100			; 00000064H
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_06CLJPAOGG@RFvsDL?$AA@
  003c9	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  003ce	89 83 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], eax
  003d4	ff d7		 call	 edi

; 168  : 
; 169  : 	if( g_ZtLicense.CheckUser(MedoniAndrei) || 
; 170  : 		g_ZtLicense.CheckUser(Gredy) || g_ZtLicense.CheckUser(Gredy2) || g_ZtLicense.CheckUser(GredyLocal) ||
; 171  : 		g_ZtLicense.CheckUser(ulasevich) || g_ZtLicense.CheckUser(ulasevich2) ||
; 172  : 		g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2))

  003d6	6a 32		 push	 50			; 00000032H
  003d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003dd	89 83 c8 00 00
	00		 mov	 DWORD PTR [ebx+200], eax
  003e3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003e8	84 c0		 test	 al, al
  003ea	75 74		 jne	 SHORT $LN65@ReadConfig
  003ec	6a 20		 push	 32			; 00000020H
  003ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003f3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003f8	84 c0		 test	 al, al
  003fa	75 64		 jne	 SHORT $LN65@ReadConfig
  003fc	6a 22		 push	 34			; 00000022H
  003fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00403	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00408	84 c0		 test	 al, al
  0040a	75 54		 jne	 SHORT $LN65@ReadConfig
  0040c	6a 21		 push	 33			; 00000021H
  0040e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00413	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00418	84 c0		 test	 al, al
  0041a	75 44		 jne	 SHORT $LN65@ReadConfig
  0041c	6a 17		 push	 23			; 00000017H
  0041e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00423	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00428	84 c0		 test	 al, al
  0042a	75 34		 jne	 SHORT $LN65@ReadConfig
  0042c	6a 24		 push	 36			; 00000024H
  0042e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00433	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00438	84 c0		 test	 al, al
  0043a	75 24		 jne	 SHORT $LN65@ReadConfig
  0043c	6a 30		 push	 48			; 00000030H
  0043e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00443	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00448	84 c0		 test	 al, al
  0044a	75 14		 jne	 SHORT $LN65@ReadConfig
  0044c	6a 31		 push	 49			; 00000031H
  0044e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00453	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00458	84 c0		 test	 al, al
  0045a	0f 84 ad 00 00
	00		 je	 $LN6@ReadConfig
$LN65@ReadConfig:

; 173  : 	{
; 174  : 		this->m_EnableMonster = GetPrivateProfileInt("Monster", "EnableMonster", 1, File);

  00460	56		 push	 esi
  00461	6a 01		 push	 1
  00463	68 00 00 00 00	 push	 OFFSET ??_C@_0O@INIJNMLA@EnableMonster?$AA@
  00468	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  0046d	ff d7		 call	 edi

; 175  : 
; 176  : 		this->m_DKvsMonster = GetPrivateProfileInt("Monster", "DKvsMonster", 100, File);

  0046f	56		 push	 esi
  00470	6a 64		 push	 100			; 00000064H
  00472	85 c0		 test	 eax, eax
  00474	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IEPNBLAK@DKvsMonster?$AA@
  00479	0f 95 c1	 setne	 cl
  0047c	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  00481	88 8b cc 00 00
	00		 mov	 BYTE PTR [ebx+204], cl
  00487	ff d7		 call	 edi

; 177  : 		this->m_DWvsMonster = GetPrivateProfileInt("Monster", "DWvsMonster", 100, File);

  00489	56		 push	 esi
  0048a	6a 64		 push	 100			; 00000064H
  0048c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CABBENAG@DWvsMonster?$AA@
  00491	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  00496	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  0049c	ff d7		 call	 edi

; 178  : 		this->m_ELFvsMonster = GetPrivateProfileInt("Monster", "ELFvsMonster", 100, File);

  0049e	56		 push	 esi
  0049f	6a 64		 push	 100			; 00000064H
  004a1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JNGGICKG@ELFvsMonster?$AA@
  004a6	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  004ab	89 83 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], eax
  004b1	ff d7		 call	 edi

; 179  : 		this->m_SUMvsMonster = GetPrivateProfileInt("Monster", "SUMvsMonster", 100, File);

  004b3	56		 push	 esi
  004b4	6a 64		 push	 100			; 00000064H
  004b6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DLBEKLII@SUMvsMonster?$AA@
  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  004c0	89 83 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], eax
  004c6	ff d7		 call	 edi

; 180  : 		this->m_MGvsMonster = GetPrivateProfileInt("Monster", "MGvsMonster", 100, File);

  004c8	56		 push	 esi
  004c9	6a 64		 push	 100			; 00000064H
  004cb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BDEOLDFM@MGvsMonster?$AA@
  004d0	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  004d5	89 83 dc 00 00
	00		 mov	 DWORD PTR [ebx+220], eax
  004db	ff d7		 call	 edi

; 181  : 		this->m_DLvsMonster = GetPrivateProfileInt("Monster", "DLvsMonster", 100, File);

  004dd	56		 push	 esi
  004de	6a 64		 push	 100			; 00000064H
  004e0	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KNMGAOIJ@DLvsMonster?$AA@
  004e5	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  004ea	89 83 e0 00 00
	00		 mov	 DWORD PTR [ebx+224], eax
  004f0	ff d7		 call	 edi

; 182  : 		this->m_RFvsMonster = GetPrivateProfileInt("Monster", "RFvsMonster", 100, File);

  004f2	56		 push	 esi
  004f3	6a 64		 push	 100			; 00000064H
  004f5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KMEMBOBB@RFvsMonster?$AA@
  004fa	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster?$AA@
  004ff	89 83 e4 00 00
	00		 mov	 DWORD PTR [ebx+228], eax
  00505	ff d7		 call	 edi
  00507	89 83 e8 00 00
	00		 mov	 DWORD PTR [ebx+232], eax
$LN6@ReadConfig:

; 183  : 	}
; 184  : 
; 185  : 	if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::GredyLocal) || g_ZtLicense.CheckUser(eZtUB::Gredy2))

  0050d	6a 20		 push	 32			; 00000020H
  0050f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00514	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00519	84 c0		 test	 al, al
  0051b	75 24		 jne	 SHORT $LN3@ReadConfig
  0051d	6a 21		 push	 33			; 00000021H
  0051f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00524	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00529	84 c0		 test	 al, al
  0052b	75 14		 jne	 SHORT $LN3@ReadConfig
  0052d	6a 22		 push	 34			; 00000022H
  0052f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00534	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00539	84 c0		 test	 al, al
  0053b	0f 84 c2 00 00
	00		 je	 $LN4@ReadConfig
$LN3@ReadConfig:

; 186  : 	{
; 187  : 		this->m_DKFenrirDamagePercent = GetPrivateProfileInt("Pet", "DKFenrirDamagePercent", 100, File);

  00541	56		 push	 esi
  00542	6a 64		 push	 100			; 00000064H
  00544	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BDENJGAH@DKFenrirDamagePercent?$AA@
  00549	68 00 00 00 00	 push	 OFFSET ??_C@_03BAPJJKHI@Pet?$AA@
  0054e	ff d7		 call	 edi

; 188  : 
; 189  : 		this->m_EnableRefflect = GetPrivateProfileInt("Reflect", "EnableReflect", 1, File);

  00550	56		 push	 esi
  00551	6a 01		 push	 1
  00553	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DIPDMJIJ@EnableReflect?$AA@
  00558	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  0055d	89 83 ec 00 00
	00		 mov	 DWORD PTR [ebx+236], eax
  00563	ff d7		 call	 edi

; 190  : 		this->m_DWRefflectPercent = GetPrivateProfileInt("Reflect", "DWReflectPercent", 100, File);

  00565	56		 push	 esi
  00566	6a 64		 push	 100			; 00000064H
  00568	85 c0		 test	 eax, eax
  0056a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CHPPJHGP@DWReflectPercent?$AA@
  0056f	0f 95 c2	 setne	 dl
  00572	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  00577	88 93 f0 00 00
	00		 mov	 BYTE PTR [ebx+240], dl
  0057d	ff d7		 call	 edi

; 191  : 		this->m_DKRefflectPercent = GetPrivateProfileInt("Reflect", "DKReflectPercent", 100, File);

  0057f	56		 push	 esi
  00580	6a 64		 push	 100			; 00000064H
  00582	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GGPKHKDJ@DKReflectPercent?$AA@
  00587	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  0058c	89 83 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], eax
  00592	ff d7		 call	 edi

; 192  : 		this->m_FERefflectPercent = GetPrivateProfileInt("Reflect", "FEReflectPercent", 100, File);

  00594	56		 push	 esi
  00595	6a 64		 push	 100			; 00000064H
  00597	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JCEEBMFF@FEReflectPercent?$AA@
  0059c	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  005a1	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax
  005a7	ff d7		 call	 edi

; 193  : 		this->m_MGRefflectPercent = GetPrivateProfileInt("Reflect", "MGReflectPercent", 100, File);

  005a9	56		 push	 esi
  005aa	6a 64		 push	 100			; 00000064H
  005ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KAGOCNCM@MGReflectPercent?$AA@
  005b1	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  005b6	89 83 fc 00 00
	00		 mov	 DWORD PTR [ebx+252], eax
  005bc	ff d7		 call	 edi

; 194  : 		this->m_DLRefflectPercent = GetPrivateProfileInt("Reflect", "DLReflectPercent", 100, File);

  005be	56		 push	 esi
  005bf	6a 64		 push	 100			; 00000064H
  005c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JLADICEM@DLReflectPercent?$AA@
  005c6	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  005cb	89 83 00 01 00
	00		 mov	 DWORD PTR [ebx+256], eax
  005d1	ff d7		 call	 edi

; 195  : 		this->m_SURefflectPercent = GetPrivateProfileInt("Reflect", "SUReflectPercent", 100, File);

  005d3	56		 push	 esi
  005d4	6a 64		 push	 100			; 00000064H
  005d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JHJMFHDK@SUReflectPercent?$AA@
  005db	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  005e0	89 83 04 01 00
	00		 mov	 DWORD PTR [ebx+260], eax
  005e6	ff d7		 call	 edi

; 196  : 		this->m_RFRefflectPercent = GetPrivateProfileInt("Reflect", "RFReflectPercent", 100, File);

  005e8	56		 push	 esi
  005e9	6a 64		 push	 100			; 00000064H
  005eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NPNFBGBF@RFReflectPercent?$AA@
  005f0	68 00 00 00 00	 push	 OFFSET ??_C@_07NLAFAPNO@Reflect?$AA@
  005f5	89 83 08 01 00
	00		 mov	 DWORD PTR [ebx+264], eax
  005fb	ff d7		 call	 edi
  005fd	89 83 0c 01 00
	00		 mov	 DWORD PTR [ebx+268], eax
$LN4@ReadConfig:

; 197  : 	}
; 198  : 
; 199  : 	if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  00603	6a 17		 push	 23			; 00000017H
  00605	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0060a	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0060f	84 c0		 test	 al, al
  00611	75 10		 jne	 SHORT $LN1@ReadConfig
  00613	6a 24		 push	 36			; 00000024H
  00615	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0061a	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0061f	84 c0		 test	 al, al
  00621	74 54		 je	 SHORT $LN2@ReadConfig
$LN1@ReadConfig:

; 200  : 	{
; 201  : 		this->m_vResetDamage.clear();

  00623	8b 83 14 01 00
	00		 mov	 eax, DWORD PTR [ebx+276]
  00629	8b 93 18 01 00
	00		 mov	 edx, DWORD PTR [ebx+280]
  0062f	3b c2		 cmp	 eax, edx
  00631	74 2d		 je	 SHORT $LN27@ReadConfig
  00633	89 45 08	 mov	 DWORD PTR $T212993[ebp], eax
  00636	8b c2		 mov	 eax, edx
  00638	3b d2		 cmp	 edx, edx
  0063a	74 1b		 je	 SHORT $LN56@ReadConfig
  0063c	8d 64 24 00	 npad	 4
$LL66@ReadConfig:
  00640	8b 7d 08	 mov	 edi, DWORD PTR $T212993[ebp]
  00643	83 45 08 20	 add	 DWORD PTR $T212993[ebp], 32 ; 00000020H
  00647	8b f0		 mov	 esi, eax
  00649	83 c0 20	 add	 eax, 32			; 00000020H
  0064c	b9 08 00 00 00	 mov	 ecx, 8
  00651	f3 a5		 rep movsd
  00653	3b c2		 cmp	 eax, edx
  00655	75 e9		 jne	 SHORT $LL66@ReadConfig
$LN56@ReadConfig:
  00657	8b 45 08	 mov	 eax, DWORD PTR $T212993[ebp]
  0065a	89 83 18 01 00
	00		 mov	 DWORD PTR [ebx+280], eax
$LN27@ReadConfig:

; 202  : 		this->ReadResetDamage(gDirPath.GetNewPath("ZtData\\BalanceDamage.dat"));

  00660	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EEILPBMP@ZtData?2BalanceDamage?4dat?$AA@
  00665	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0066a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0066f	50		 push	 eax
  00670	8b cb		 mov	 ecx, ebx
  00672	e8 00 00 00 00	 call	 ?ReadResetDamage@cBalanceSystem@@QAEXPAD@Z ; cBalanceSystem::ReadResetDamage
$LN2@ReadConfig:
  00677	5f		 pop	 edi
  00678	5e		 pop	 esi
  00679	5b		 pop	 ebx

; 203  : 	}
; 204  : 
; 205  : }

  0067a	5d		 pop	 ebp
  0067b	c2 04 00	 ret	 4
?ReadConfigs@cBalanceSystem@@QAEXPAD@Z ENDP		; cBalanceSystem::ReadConfigs
_TEXT	ENDS
PUBLIC	??_C@_0BL@PKECCBGN@?4?2ZtData?2BalanceSystem?4ini?$AA@ ; `string'
PUBLIC	?Load@cBalanceSystem@@QAEXXZ			; cBalanceSystem::Load
;	COMDAT ??_C@_0BL@PKECCBGN@?4?2ZtData?2BalanceSystem?4ini?$AA@
CONST	SEGMENT
??_C@_0BL@PKECCBGN@?4?2ZtData?2BalanceSystem?4ini?$AA@ DB '.\ZtData\Balan'
	DB	'ceSystem.ini', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@cBalanceSystem@@QAEXXZ
_TEXT	SEGMENT
?Load@cBalanceSystem@@QAEXXZ PROC			; cBalanceSystem::Load, COMDAT
; _this$ = ecx

; 292  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 293  : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@cBalanceSystem@@QAEXXZ ; cBalanceSystem::Init

; 294  : 	this->ReadConfigs(gDirPath.GetNewPath(BALANCESYSTEM_DIR));

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PKECCBGN@?4?2ZtData?2BalanceSystem?4ini?$AA@
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00012	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00017	50		 push	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?ReadConfigs@cBalanceSystem@@QAEXPAD@Z ; cBalanceSystem::ReadConfigs
  0001f	5e		 pop	 esi

; 295  : }

  00020	c3		 ret	 0
?Load@cBalanceSystem@@QAEXXZ ENDP			; cBalanceSystem::Load
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgBalanceSystem@@YAXXZ
text$yc	SEGMENT
??__EgBalanceSystem@@YAXXZ PROC				; `dynamic initializer for 'gBalanceSystem'', COMDAT

; 13   : cBalanceSystem gBalanceSystem;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBalanceSystem@@3VcBalanceSystem@@A ; gBalanceSystem
  00005	e8 00 00 00 00	 call	 ??0cBalanceSystem@@QAE@XZ ; cBalanceSystem::cBalanceSystem
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgBalanceSystem@@YAXXZ ; `dynamic atexit destructor for 'gBalanceSystem''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgBalanceSystem@@YAXXZ ENDP				; `dynamic initializer for 'gBalanceSystem''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgBalanceSystem@@YAXXZ
text$yd	SEGMENT
??__FgBalanceSystem@@YAXXZ PROC				; `dynamic atexit destructor for 'gBalanceSystem'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBalanceSystem@@3VcBalanceSystem@@A ; gBalanceSystem
  00005	e9 00 00 00 00	 jmp	 ??1cBalanceSystem@@UAE@XZ ; cBalanceSystem::~cBalanceSystem
??__FgBalanceSystem@@YAXXZ ENDP				; `dynamic atexit destructor for 'gBalanceSystem''
text$yd	ENDS
PUBLIC	?gBalanceSystem@@3VcBalanceSystem@@A		; gBalanceSystem
_BSS	SEGMENT
?gBalanceSystem@@3VcBalanceSystem@@A DB 0124H DUP (?)	; gBalanceSystem
_BSS	ENDS
CRT$XCU	SEGMENT
_gBalanceSystem$initializer$ DD FLAT:??__EgBalanceSystem@@YAXXZ
CRT$XCU	ENDS
END
