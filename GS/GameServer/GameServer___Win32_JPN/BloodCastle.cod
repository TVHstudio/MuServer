; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\BloodCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_g_btCastleEntranceMapXY DB 0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
_g_btCastleBridgeMapXY DB 0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
_g_btCastleDoorMapXY DB 0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
_g_iQuestWinExpendZEN DD 04e20H
	DD	02710H
	DD	0c350H
	DD	061a8H
	DD	0186a0H
	DD	0c350H
	DD	0249f0H
	DD	013880H
	DD	030d40H
	DD	0186a0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
_g_iBC_ChoasMixSuccessRate DD 050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
_g_iBC_ChoasMixMoney DD 0c350H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	0927c0H
	DD	0cf850H
	DD	0100590H
_g_iBC_EventScore DD 0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
_g_iBC_EventScore_Fail DD 0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
_g_iBC_Add_Exp DD 04e20H
	DD	04e20H
	DD	01388H
	DD	0a0H
	DD	0c350H
	DD	0c350H
	DD	02710H
	DD	0b4H
	DD	013880H
	DD	013880H
	DD	03a98H
	DD	0c8H
	DD	015f90H
	DD	015f90H
	DD	04e20H
	DD	0dcH
	DD	0186a0H
	DD	0186a0H
	DD	061a8H
	DD	0f0H
	DD	01adb0H
	DD	01adb0H
	DD	07530H
	DD	0104H
	DD	01d4c0H
	DD	01d4c0H
	DD	088b8H
	DD	0118H
	DD	01fbd0H
	DD	01fbd0H
	DD	09c40H
	DD	012cH
_g_iBC_Party_EventPoint DD 05H
	DD	0aH
	DD	0fH
	DD	014H
	DD	01eH
	DD	023H
	DD	028H
	DD	02dH
	DD	032H
	DD	037H
_g_iBC_MONSTER_CHANGE_STATE DD 0aH
	DD	014H
	DD	0fffffff2H
	DD	014H
	DD	028H
	DD	0ffffffe0H
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$ = eax

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 117  : #pragma warning( pop )
; 118  : }

  00009	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tnotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 9    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00007	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  0000b	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0000f	c1 e0 08	 shl	 eax, 8
  00012	03 c1		 add	 eax, ecx
  00014	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00018	c1 e0 08	 shl	 eax, 8
  0001b	03 c2		 add	 eax, edx
  0001d	c1 e0 08	 shl	 eax, 8
  00020	03 c1		 add	 eax, ecx
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
PUBLIC	??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@		; `string'
PUBLIC	??_C@_0O@PBCFFJJH@StoneDropRate?$AA@		; `string'
PUBLIC	??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@	; `string'
PUBLIC	??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@	; `string'
PUBLIC	?LoadItemDropRate@CBloodCastle@@QAEXXZ		; CBloodCastle::LoadItemDropRate
EXTRN	?g_bStoneItemDrop@@3HA:DWORD			; g_bStoneItemDrop
EXTRN	?g_iStoneDropRate@@3HA:DWORD			; g_iStoneDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
CONST	SEGMENT
??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@ DB 'StoneItemDrop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
CONST	SEGMENT
??_C@_0O@PBCFFJJH@StoneDropRate?$AA@ DB 'StoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
CONST	SEGMENT
??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@ DB 'BloodBoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
CONST	SEGMENT
??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@ DB 'AngelKingsPaperDropRa'
	DB	'te', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
CONST	SEGMENT
??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@ DB 'BloodCastleEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@ DB 'commonserver.cfg', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadItemDropRate@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
?LoadItemDropRate@CBloodCastle@@QAEXXZ PROC		; CBloodCastle::LoadItemDropRate, COMDAT
; _this$ = ecx

; 352  : {

  00000	56		 push	 esi

; 353  : 	g_bBloodCastle=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodCastleEvent", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0000b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00010	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00023	ff d6		 call	 esi

; 354  : 	g_iAngelKingsPaperDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "AngelKingsPaperDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0002f	a3 00 00 00 00	 mov	 DWORD PTR ?g_bBloodCastle@@3HA, eax ; g_bBloodCastle
  00034	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00039	50		 push	 eax
  0003a	6a 00		 push	 0
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00046	ff d6		 call	 esi

; 355  : 	g_iBloodBoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodBoneDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA, eax ; g_iAngelKingsPaperDropRate
  00057	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00069	ff d6		 call	 esi

; 356  : 	g_iStoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneDropRate", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?g_iBloodBoneDropRate@@3HA, eax ; g_iBloodBoneDropRate
  0007a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0007f	50		 push	 eax
  00080	6a 00		 push	 0
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0008c	ff d6		 call	 esi

; 357  : 	g_bStoneItemDrop=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneItemDrop", 0, gDirPath.GetNewPath(COMMONSERVER_FILE));

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?g_iStoneDropRate@@3HA, eax ; g_iStoneDropRate
  0009d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000a2	50		 push	 eax
  000a3	6a 00		 push	 0
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000af	ff d6		 call	 esi
  000b1	a3 00 00 00 00	 mov	 DWORD PTR ?g_bStoneItemDrop@@3HA, eax ; g_bStoneItemDrop
  000b6	5e		 pop	 esi

; 358  : }

  000b7	c3		 ret	 0
?LoadItemDropRate@CBloodCastle@@QAEXXZ ENDP		; CBloodCastle::LoadItemDropRate
_TEXT	ENDS
PUBLIC	?ClearBridgeData@CBloodCastle@@IAEXH@Z		; CBloodCastle::ClearBridgeData
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?ClearBridgeData@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv3846 = 8						; size = 4
tv3841 = 8						; size = 4
tv3836 = 8						; size = 4
tv3831 = 8						; size = 4
tv3826 = 8						; size = 4
tv3821 = 8						; size = 4
tv3751 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ClearBridgeData, COMDAT
; _this$ = ecx

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 464  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	3b c2		 cmp	 eax, edx
  0000d	0f 8c 0e 04 00
	00		 jl	 $LN12@ClearBridg
  00013	33 c9		 xor	 ecx, ecx
  00015	83 f8 07	 cmp	 eax, 7
  00018	0f 9e c1	 setle	 cl
  0001b	3b ca		 cmp	 ecx, edx
  0001d	0f 84 fe 03 00
	00		 je	 $LN12@ClearBridg

; 465  : 	{
; 466  : 		return;
; 467  : 	}
; 468  : 
; 469  : 	this->m_BridgeData[iBridgeIndex].m_iTOTAL_EXP = 0;

  00023	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00029	03 c6		 add	 eax, esi
  0002b	89 90 94 03 00
	00		 mov	 DWORD PTR [eax+916], edx

; 470  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = 0;

  00031	89 90 cc 03 00
	00		 mov	 DWORD PTR [eax+972], edx

; 471  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;

  00037	89 90 d0 03 00
	00		 mov	 DWORD PTR [eax+976], edx

; 472  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT = 0;

  0003d	89 90 d4 03 00
	00		 mov	 DWORD PTR [eax+980], edx

; 473  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = 0;

  00043	89 90 dc 03 00
	00		 mov	 DWORD PTR [eax+988], edx

; 474  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  00049	89 90 e0 03 00
	00		 mov	 DWORD PTR [eax+992], edx

; 475  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT = 0;

  0004f	89 90 e4 03 00
	00		 mov	 DWORD PTR [eax+996], edx

; 476  : 	this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = 0;

  00055	88 90 f0 03 00
	00		 mov	 BYTE PTR [eax+1008], dl

; 477  : 	this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1;
; 478  : 	this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = -1;
; 479  : 	this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1;
; 480  : 	this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = -1;
; 481  : 	this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = -1;
; 482  : 	this->m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE = TRUE;

  0005b	c7 80 a4 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+932], 1

; 483  : 	this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = false;

  00065	89 90 be 03 00
	00		 mov	 DWORD PTR [eax+958], edx

; 484  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = false;
; 485  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = false;
; 486  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = false;
; 487  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT = false;

  0006b	88 90 c2 03 00
	00		 mov	 BYTE PTR [eax+962], dl

; 488  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  00071	66 89 90 bb 03
	00 00		 mov	 WORD PTR [eax+955], dx

; 489  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;
; 490  : 	this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = false;

  00078	88 90 bd 03 00
	00		 mov	 BYTE PTR [eax+957], dl

; 491  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE = false;

  0007e	66 89 90 b8 03
	00 00		 mov	 WORD PTR [eax+952], dx

; 492  : 	this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE = false;
; 493  : 	this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE = false;

  00085	88 90 ba 03 00
	00		 mov	 BYTE PTR [eax+954], dl

; 494  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index = -10;

  0008b	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
  00090	89 88 fc 03 00
	00		 mov	 DWORD PTR [eax+1020], ecx

; 495  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party = -10;

  00096	89 88 f8 03 00
	00		 mov	 DWORD PTR [eax+1016], ecx

; 496  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index = -10;

  0009c	89 88 1c 04 00
	00		 mov	 DWORD PTR [eax+1052], ecx

; 497  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party = -10;

  000a2	89 88 18 04 00
	00		 mov	 DWORD PTR [eax+1048], ecx

; 498  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index = -10;

  000a8	89 88 3c 04 00
	00		 mov	 DWORD PTR [eax+1084], ecx

; 499  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party = -10;

  000ae	89 88 38 04 00
	00		 mov	 DWORD PTR [eax+1080], ecx

; 500  : 
; 501  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName , 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName));

  000b4	33 c9		 xor	 ecx, ecx
  000b6	89 4d 08	 mov	 DWORD PTR tv3846[ebp], ecx
  000b9	53		 push	 ebx
  000ba	83 cb ff	 or	 ebx, -1
  000bd	89 98 d8 03 00
	00		 mov	 DWORD PTR [eax+984], ebx
  000c3	89 98 e8 03 00
	00		 mov	 DWORD PTR [eax+1000], ebx
  000c9	89 98 ec 03 00
	00		 mov	 DWORD PTR [eax+1004], ebx
  000cf	89 98 a0 03 00
	00		 mov	 DWORD PTR [eax+928], ebx
  000d5	89 98 b4 03 00
	00		 mov	 DWORD PTR [eax+948], ebx
  000db	89 88 0b 04 00
	00		 mov	 DWORD PTR [eax+1035], ecx
  000e1	89 88 0f 04 00
	00		 mov	 DWORD PTR [eax+1039], ecx
  000e7	0f b7 c9	 movzx	 ecx, cx
  000ea	66 89 88 13 04
	00 00		 mov	 WORD PTR [eax+1043], cx
  000f1	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3846[ebp]
  000f5	88 88 15 04 00
	00		 mov	 BYTE PTR [eax+1045], cl

; 502  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName));

  000fb	33 c9		 xor	 ecx, ecx
  000fd	89 88 20 04 00
	00		 mov	 DWORD PTR [eax+1056], ecx
  00103	89 88 24 04 00
	00		 mov	 DWORD PTR [eax+1060], ecx
  00109	89 4d 08	 mov	 DWORD PTR tv3841[ebp], ecx
  0010c	0f b7 c9	 movzx	 ecx, cx
  0010f	66 89 88 28 04
	00 00		 mov	 WORD PTR [eax+1064], cx
  00116	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3841[ebp]
  0011a	88 88 2a 04 00
	00		 mov	 BYTE PTR [eax+1066], cl

; 503  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName));

  00120	33 c9		 xor	 ecx, ecx
  00122	89 88 40 04 00
	00		 mov	 DWORD PTR [eax+1088], ecx
  00128	89 88 44 04 00
	00		 mov	 DWORD PTR [eax+1092], ecx
  0012e	89 4d 08	 mov	 DWORD PTR tv3836[ebp], ecx
  00131	0f b7 c9	 movzx	 ecx, cx
  00134	66 89 88 48 04
	00 00		 mov	 WORD PTR [eax+1096], cx
  0013b	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3836[ebp]
  0013f	88 88 4a 04 00
	00		 mov	 BYTE PTR [eax+1098], cl

; 504  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID));

  00145	33 c9		 xor	 ecx, ecx
  00147	89 88 00 04 00
	00		 mov	 DWORD PTR [eax+1024], ecx
  0014d	89 88 04 04 00
	00		 mov	 DWORD PTR [eax+1028], ecx
  00153	89 4d 08	 mov	 DWORD PTR tv3831[ebp], ecx
  00156	0f b7 c9	 movzx	 ecx, cx
  00159	66 89 88 08 04
	00 00		 mov	 WORD PTR [eax+1032], cx
  00160	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3831[ebp]
  00164	88 88 0a 04 00
	00		 mov	 BYTE PTR [eax+1034], cl

; 505  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID));

  0016a	33 c9		 xor	 ecx, ecx
  0016c	89 88 2b 04 00
	00		 mov	 DWORD PTR [eax+1067], ecx
  00172	89 88 2f 04 00
	00		 mov	 DWORD PTR [eax+1071], ecx
  00178	89 4d 08	 mov	 DWORD PTR tv3826[ebp], ecx
  0017b	0f b7 c9	 movzx	 ecx, cx
  0017e	66 89 88 33 04
	00 00		 mov	 WORD PTR [eax+1075], cx
  00185	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3826[ebp]
  00189	88 88 35 04 00
	00		 mov	 BYTE PTR [eax+1077], cl

; 506  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID));

  0018f	33 c9		 xor	 ecx, ecx
  00191	89 88 4b 04 00
	00		 mov	 DWORD PTR [eax+1099], ecx
  00197	89 88 4f 04 00
	00		 mov	 DWORD PTR [eax+1103], ecx
  0019d	89 4d 08	 mov	 DWORD PTR tv3821[ebp], ecx
  001a0	0f b7 c9	 movzx	 ecx, cx
  001a3	66 89 88 53 04
	00 00		 mov	 WORD PTR [eax+1107], cx
  001aa	0f b6 4d 08	 movzx	 ecx, BYTE PTR tv3821[ebp]
  001ae	88 88 55 04 00
	00		 mov	 BYTE PTR [eax+1109], cl
  001b4	57		 push	 edi
  001b5	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]

; 465  : 	{
; 466  : 		return;
; 467  : 	}
; 468  : 
; 469  : 	this->m_BridgeData[iBridgeIndex].m_iTOTAL_EXP = 0;

  001b8	c7 45 08 08 00
	00 00		 mov	 DWORD PTR tv3751[ebp], 8
  001bf	90		 npad	 1
$LL4@ClearBridg:

; 507  : 	
; 508  : 
; 509  : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)
; 510  : 	{
; 511  : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  001c0	8b 31		 mov	 esi, DWORD PTR [ecx]
  001c2	3b f3		 cmp	 esi, ebx
  001c4	74 52		 je	 SHORT $LN1@ClearBridg

; 512  : 		{
; 513  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  001c6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001cc	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001d2	89 94 3e a0 0e
	00 00		 mov	 DWORD PTR [esi+edi+3744], edx

; 514  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  001d9	8b 31		 mov	 esi, DWORD PTR [ecx]
  001db	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e1	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001e7	88 9c 3e 9e 0e
	00 00		 mov	 BYTE PTR [esi+edi+3742], bl

; 515  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  001ee	8b 31		 mov	 esi, DWORD PTR [ecx]
  001f0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f6	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001fc	88 9c 3e 9f 0e
	00 00		 mov	 BYTE PTR [esi+edi+3743], bl

; 516  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00203	8b 31		 mov	 esi, DWORD PTR [ecx]
  00205	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00211	88 94 3e a4 0e
	00 00		 mov	 BYTE PTR [esi+edi+3748], dl
$LN1@ClearBridg:

; 517  : 		}
; 518  : 
; 519  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00218	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 520  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0021b	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 521  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0021e	89 19		 mov	 DWORD PTR [ecx], ebx

; 522  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00220	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 523  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00223	66 89 51 10	 mov	 WORD PTR [ecx+16], dx

; 524  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 525  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00227	89 98 58 04 00
	00		 mov	 DWORD PTR [eax+1112], ebx

; 526  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX = -1; //season 2.5 add-on

  0022d	89 98 5c 04 00
	00		 mov	 DWORD PTR [eax+1116], ebx
  00233	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00236	3b f3		 cmp	 esi, ebx
  00238	74 55		 je	 SHORT $LN13@ClearBridg

; 512  : 		{
; 513  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  0023a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00240	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00246	89 94 3e a0 0e
	00 00		 mov	 DWORD PTR [esi+edi+3744], edx

; 514  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  0024d	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00250	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00256	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0025c	88 9c 3e 9e 0e
	00 00		 mov	 BYTE PTR [esi+edi+3742], bl

; 515  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00263	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00266	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00272	88 9c 3e 9f 0e
	00 00		 mov	 BYTE PTR [esi+edi+3743], bl

; 516  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00279	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  0027c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00282	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00288	88 94 3e a4 0e
	00 00		 mov	 BYTE PTR [esi+edi+3748], dl
$LN13@ClearBridg:

; 517  : 		}
; 518  : 
; 519  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0028f	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 520  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00292	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 521  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00295	89 59 14	 mov	 DWORD PTR [ecx+20], ebx

; 522  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00298	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 523  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  0029b	66 89 51 24	 mov	 WORD PTR [ecx+36], dx

; 524  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 525  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  0029f	89 98 58 04 00
	00		 mov	 DWORD PTR [eax+1112], ebx

; 526  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX = -1; //season 2.5 add-on

  002a5	89 98 5c 04 00
	00		 mov	 DWORD PTR [eax+1116], ebx
  002ab	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  002ae	3b f3		 cmp	 esi, ebx
  002b0	74 55		 je	 SHORT $LN14@ClearBridg

; 512  : 		{
; 513  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  002b2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b8	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  002be	89 94 3e a0 0e
	00 00		 mov	 DWORD PTR [esi+edi+3744], edx

; 514  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  002c5	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  002c8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ce	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  002d4	88 9c 3e 9e 0e
	00 00		 mov	 BYTE PTR [esi+edi+3742], bl

; 515  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  002db	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  002de	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e4	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  002ea	88 9c 3e 9f 0e
	00 00		 mov	 BYTE PTR [esi+edi+3743], bl

; 516  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  002f1	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  002f4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fa	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00300	88 94 3e a4 0e
	00 00		 mov	 BYTE PTR [esi+edi+3748], dl
$LN14@ClearBridg:

; 517  : 		}
; 518  : 
; 519  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00307	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 520  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0030a	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 521  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0030d	89 59 28	 mov	 DWORD PTR [ecx+40], ebx

; 522  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00310	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 523  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00313	66 89 51 38	 mov	 WORD PTR [ecx+56], dx

; 524  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 525  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00317	89 98 58 04 00
	00		 mov	 DWORD PTR [eax+1112], ebx

; 526  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX = -1; //season 2.5 add-on

  0031d	89 98 5c 04 00
	00		 mov	 DWORD PTR [eax+1116], ebx
  00323	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00326	3b f3		 cmp	 esi, ebx
  00328	74 55		 je	 SHORT $LN15@ClearBridg

; 512  : 		{
; 513  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  0032a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00330	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00336	89 94 3e a0 0e
	00 00		 mov	 DWORD PTR [esi+edi+3744], edx

; 514  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  0033d	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00340	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00346	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0034c	88 9c 3e 9e 0e
	00 00		 mov	 BYTE PTR [esi+edi+3742], bl

; 515  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00353	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00356	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00362	88 9c 3e 9f 0e
	00 00		 mov	 BYTE PTR [esi+edi+3743], bl

; 516  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00369	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  0036c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00372	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00378	88 94 3e a4 0e
	00 00		 mov	 BYTE PTR [esi+edi+3748], dl
$LN15@ClearBridg:

; 517  : 		}
; 518  : 
; 519  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0037f	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 520  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00382	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 521  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00385	89 59 3c	 mov	 DWORD PTR [ecx+60], ebx

; 522  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00388	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 523  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  0038b	66 89 51 4c	 mov	 WORD PTR [ecx+76], dx

; 524  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 525  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  0038f	89 98 58 04 00
	00		 mov	 DWORD PTR [eax+1112], ebx

; 526  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX = -1; //season 2.5 add-on

  00395	89 98 5c 04 00
	00		 mov	 DWORD PTR [eax+1116], ebx
  0039b	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  0039e	3b f3		 cmp	 esi, ebx
  003a0	74 55		 je	 SHORT $LN16@ClearBridg

; 512  : 		{
; 513  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  003a2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a8	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  003ae	89 94 3e a0 0e
	00 00		 mov	 DWORD PTR [esi+edi+3744], edx

; 514  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  003b5	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  003b8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003be	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  003c4	88 9c 3e 9e 0e
	00 00		 mov	 BYTE PTR [esi+edi+3742], bl

; 515  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  003cb	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  003ce	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d4	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  003da	88 9c 3e 9f 0e
	00 00		 mov	 BYTE PTR [esi+edi+3743], bl

; 516  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  003e1	8b 71 50	 mov	 esi, DWORD PTR [ecx+80]
  003e4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ea	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  003f0	88 94 3e a4 0e
	00 00		 mov	 BYTE PTR [esi+edi+3748], dl
$LN16@ClearBridg:

; 517  : 		}
; 518  : 
; 519  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  003f7	89 51 54	 mov	 DWORD PTR [ecx+84], edx

; 520  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  003fa	89 51 58	 mov	 DWORD PTR [ecx+88], edx

; 521  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  003fd	89 59 50	 mov	 DWORD PTR [ecx+80], ebx

; 522  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00400	89 51 5c	 mov	 DWORD PTR [ecx+92], edx

; 523  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00403	66 89 51 60	 mov	 WORD PTR [ecx+96], dx

; 526  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX = -1; //season 2.5 add-on

  00407	83 c1 64	 add	 ecx, 100		; 00000064H
  0040a	ff 4d 08	 dec	 DWORD PTR tv3751[ebp]
  0040d	89 98 58 04 00
	00		 mov	 DWORD PTR [eax+1112], ebx
  00413	89 98 5c 04 00
	00		 mov	 DWORD PTR [eax+1116], ebx
  00419	0f 85 a1 fd ff
	ff		 jne	 $LL4@ClearBridg
  0041f	5f		 pop	 edi
  00420	5b		 pop	 ebx
$LN12@ClearBridg:
  00421	5e		 pop	 esi

; 527  : 	}
; 528  : }

  00422	5d		 pop	 ebp
  00423	c2 04 00	 ret	 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ClearBridgeData
_TEXT	ENDS
PUBLIC	?ProcState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_None
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?ProcState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_None, COMDAT
; _this$ = ecx

; 599  : }

  00000	c2 04 00	 ret	 4
?ProcState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_None
_TEXT	ENDS
PUBLIC	?GetCurrentState@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetCurrentState
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentState@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentState@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentState, COMDAT
; _this$ = ecx

; 964  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 965  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@GetCurrent
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN1@GetCurrent
$LN6@GetCurrent:

; 966  : 	{
; 967  : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 971  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetCurrent:

; 968  : 	}
; 969  : 
; 970  : 	return this->m_BridgeData[iBridgeIndex].m_iBC_STATE;

  0001d	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00023	8b 84 08 a8 03
	00 00		 mov	 eax, DWORD PTR [eax+ecx+936]

; 971  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetCurrentState@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentState
_TEXT	ENDS
PUBLIC	?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentRemainSec
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentRemainSec, COMDAT
; _this$ = ecx

; 974  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 975  : 	return this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0000c	8b 8c 08 ac 03
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+940]
  00013	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00018	f7 e9		 imul	 ecx
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx

; 976  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentRemainSec
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z		; CBloodCastle::CheckEnterLevel
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CheckEnterLevel, COMDAT
; _this$ = ecx

; 979  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 980  : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 88 ba 00 00
	00		 js	 $LN10@CheckEnter
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx

; 981  : 	{
; 982  : 		return 2;

  0001a	0f 84 a8 00 00
	00		 je	 $LN10@CheckEnter

; 983  : 	}
; 984  : 
; 985  : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00020	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00026	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  00031	0f 85 91 00 00
	00		 jne	 $LN10@CheckEnter
  00037	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0003b	0f 8e 87 00 00
	00		 jle	 $LN10@CheckEnter

; 988  : 	}
; 989  : 
; 990  : 	if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 991  : #ifdef MONK
; 992  : 		|| gObj[iIndex].Class == CLASS_MONK
; 993  : #endif
; 994  : 		|| gObj[iIndex].Class == CLASS_MAGUMSA )

  00041	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00048	83 f9 04	 cmp	 ecx, 4
  0004b	74 3e		 je	 SHORT $LN8@CheckEnter
  0004d	83 f9 06	 cmp	 ecx, 6
  00050	74 39		 je	 SHORT $LN8@CheckEnter
  00052	83 f9 03	 cmp	 ecx, 3
  00055	74 34		 je	 SHORT $LN8@CheckEnter

; 1009 : 		}
; 1010 : 	}
; 1011 : 	else
; 1012 : 	{
; 1013 : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00057	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00061	c1 e0 04	 shl	 eax, 4
  00064	8b 90 f0 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-16]
  0006a	3b ca		 cmp	 ecx, edx
  0006c	7c 46		 jl	 SHORT $LN21@CheckEnter
  0006e	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-12]

; 1014 : 		{
; 1015 : 			return 0;

  00074	7e 34		 jle	 SHORT $LN22@CheckEnter

; 1016 : 		}
; 1017 : 
; 1018 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  00076	3b ca		 cmp	 ecx, edx

; 1019 : 		{
; 1020 : 			return -1;

  00078	7c 3a		 jl	 SHORT $LN21@CheckEnter

; 1021 : 		}
; 1022 : 
; 1023 : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  0007a	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-12]
  00080	7e 46		 jle	 SHORT $LN10@CheckEnter

; 1024 : 		{
; 1025 : 			return 1;

  00082	b8 01 00 00 00	 mov	 eax, 1

; 1026 : 		}
; 1027 : 	}
; 1028 : 
; 1029 : 	return 2;
; 1030 : }

  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
$LN8@CheckEnter:

; 995  : 	{
; 996  : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  0008b	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00092	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00095	c1 e0 04	 shl	 eax, 4
  00098	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-8]
  0009e	3b ca		 cmp	 ecx, edx
  000a0	7c 12		 jl	 SHORT $LN21@CheckEnter
  000a2	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-4]
  000a8	7f 06		 jg	 SHORT $LN7@CheckEnter
$LN22@CheckEnter:

; 997  : 		{
; 998  : 			return 0;

  000aa	33 c0		 xor	 eax, eax

; 1026 : 		}
; 1027 : 	}
; 1028 : 
; 1029 : 	return 2;
; 1030 : }

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN7@CheckEnter:

; 999  : 		}
; 1000 : 
; 1001 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  000b0	3b ca		 cmp	 ecx, edx
  000b2	7d 07		 jge	 SHORT $LN6@CheckEnter
$LN21@CheckEnter:

; 1002 : 		{
; 1003 : 			return -1;

  000b4	83 c8 ff	 or	 eax, -1

; 1026 : 		}
; 1027 : 	}
; 1028 : 
; 1029 : 	return 2;
; 1030 : }

  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
$LN6@CheckEnter:

; 1004 : 		}
; 1005 : 
; 1006 : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  000bb	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttBLOODCASTLE_LEVEL[eax-4]

; 1007 : 		{
; 1008 : 			return 1;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	7f 05		 jg	 SHORT $LN13@CheckEnter
$LN10@CheckEnter:

; 986  : 	{
; 987  : 		return 2;

  000c8	b8 02 00 00 00	 mov	 eax, 2
$LN13@CheckEnter:

; 1026 : 		}
; 1027 : 	}
; 1028 : 
; 1029 : 	return 2;
; 1030 : }

  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEnterFreeTicket
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckEnterFreeTicket, COMDAT
; _this$ = ecx

; 1033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1034 : 	if ( !OBJMAX_RANGE(iIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0f		 js	 SHORT $LN16@CheckEnter@2
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 07		 jne	 SHORT $LN8@CheckEnter@2
$LN16@CheckEnter@2:

; 1035 : 		return false;

  0001a	32 c0		 xor	 al, al
  0001c	5f		 pop	 edi

; 1052 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN8@CheckEnter@2:

; 1036 : 
; 1037 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0002c	66 83 7c 07 68
	01		 cmp	 WORD PTR [edi+eax+104], 1
  00032	75 e6		 jne	 SHORT $LN16@CheckEnter@2
  00034	83 7c 07 04 02	 cmp	 DWORD PTR [edi+eax+4], 2
  00039	7e df		 jle	 SHORT $LN16@CheckEnter@2

; 1038 : 		return false;
; 1039 : 
; 1040 : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0003b	56		 push	 esi
  0003c	33 f6		 xor	 esi, esi
  0003e	8b ff		 npad	 2
$LL5@CheckEnter@2:

; 1041 : 	{
; 1042 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00040	8b 8c 07 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3620]
  00047	03 ce		 add	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004e	83 f8 01	 cmp	 eax, 1
  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	75 13		 jne	 SHORT $LN4@CheckEnter@2

; 1043 : 		{
; 1044 : 			if ( gObj[iIndex].pInventory [x].m_Type == ITEMGET(13,47) )

  00058	8b 8c 07 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3620]
  0005f	ba 2f 1a 00 00	 mov	 edx, 6703		; 00001a2fH
  00064	66 39 54 31 06	 cmp	 WORD PTR [ecx+esi+6], dx
  00069	74 16		 je	 SHORT $LN14@CheckEnter@2
$LN4@CheckEnter@2:

; 1038 : 		return false;
; 1039 : 
; 1040 : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0006b	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00071	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  00077	7c c7		 jl	 SHORT $LL5@CheckEnter@2

; 1047 : 			}
; 1048 : 		}
; 1049 : 	}
; 1050 : 
; 1051 : 	return false;

  00079	5e		 pop	 esi
  0007a	32 c0		 xor	 al, al
  0007c	5f		 pop	 edi

; 1052 : }

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN14@CheckEnter@2:
  00081	5e		 pop	 esi

; 1045 : 			{
; 1046 : 				return true;

  00082	b0 01		 mov	 al, 1
  00084	5f		 pop	 edi

; 1052 : }

  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckEnterFreeTicket
_TEXT	ENDS
PUBLIC	?CheckChoasMixItem@CBloodCastle@@QAEHH@Z	; CBloodCastle::CheckChoasMixItem
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CheckChoasMixItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_bIsChaosGemExist$ = -28				; size = 4
_iBloodBoneLevel$ = -24					; size = 4
_iAngelKingPaperLevel$ = -20				; size = 4
_bIsAngelKingPaperExist$ = -16				; size = 4
_bIsOtherItemExist$ = -12				; size = 4
_bIsBloodBoneExist$ = -8				; size = 4
_iCharmOfLuckCount$ = -4				; size = 4
_iEventItemCount$ = 8					; size = 4
_iIndex$ = 8						; size = 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckChoasMixItem, COMDAT
; _this$ = ecx

; 1218 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi

; 1219 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	3b f7		 cmp	 esi, edi
  0000f	0f 8c 13 01 00
	00		 jl	 $LN41@CheckChoas
  00015	33 c0		 xor	 eax, eax
  00017	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0001d	0f 9e c0	 setle	 al
  00020	3b c7		 cmp	 eax, edi

; 1220 : 	{
; 1221 : 		return false;

  00022	0f 84 00 01 00
	00		 je	 $LN41@CheckChoas

; 1222 : 	}
; 1223 : 
; 1224 : 	int iCHAOS_MIX_LEVEL = 0;
; 1225 : 	BOOL bIsChaosGemExist = FALSE;

  00028	53		 push	 ebx
  00029	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	89 7d e4	 mov	 DWORD PTR _bIsChaosGemExist$[ebp], edi

; 1226 : 	BOOL bIsAngelKingPaperExist = FALSE;

  00038	89 7d f0	 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], edi

; 1227 : 	BOOL bIsBloodBoneExist = FALSE;

  0003b	89 7d f8	 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], edi

; 1228 : 	BOOL bIsOtherItemExist = FALSE;

  0003e	89 7d f4	 mov	 DWORD PTR _bIsOtherItemExist$[ebp], edi

; 1229 : 	int iEventItemCount = 0;

  00041	89 7d 08	 mov	 DWORD PTR _iEventItemCount$[ebp], edi

; 1230 : 	int iAngelKingPaperLevel = 0;

  00044	89 7d ec	 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], edi

; 1231 : 	int iBloodBoneLevel = 0;

  00047	89 7d e8	 mov	 DWORD PTR _iBloodBoneLevel$[ebp], edi

; 1232 : 	int iCharmOfLuckCount=0;

  0004a	89 7d fc	 mov	 DWORD PTR _iCharmOfLuckCount$[ebp], edi
  0004d	8d 49 00	 npad	 3
$LL28@CheckChoas:

; 1235 : 	{
; 1236 : 		if ( gObj[iIndex].pChaosBox[i].IsItem() == TRUE )

  00050	8b 8c 1e 78 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ebx+3704]
  00057	03 cf		 add	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	83 f8 01	 cmp	 eax, 1
  00067	0f 85 7b 00 00
	00		 jne	 $LN27@CheckChoas

; 1237 : 		{
; 1238 : 			if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(12,15) )

  0006d	8b 84 1e 78 0e
	00 00		 mov	 eax, DWORD PTR [esi+ebx+3704]
  00074	0f b7 4c 38 06	 movzx	 ecx, WORD PTR [eax+edi+6]
  00079	03 c7		 add	 eax, edi
  0007b	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00080	66 3b ca	 cmp	 cx, dx
  00083	75 09		 jne	 SHORT $LN24@CheckChoas

; 1239 : 			{
; 1240 : 				bIsChaosGemExist = TRUE;

  00085	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$[ebp], 1
  0008c	eb 5a		 jmp	 SHORT $LN27@CheckChoas
$LN24@CheckChoas:

; 1241 : 			}
; 1242 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,16) )

  0008e	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  00093	66 3b ca	 cmp	 cx, dx
  00096	75 14		 jne	 SHORT $LN22@CheckChoas

; 1243 : 			{
; 1244 : 				int iSCROLL_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;
; 1245 : 				iEventItemCount++;
; 1246 : 				bIsAngelKingPaperExist = TRUE;
; 1247 : 				iAngelKingPaperLevel = iSCROLL_LEVEL;

  00098	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  0009c	b9 01 00 00 00	 mov	 ecx, 1
  000a1	01 4d 08	 add	 DWORD PTR _iEventItemCount$[ebp], ecx
  000a4	89 4d f0	 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], ecx
  000a7	89 45 ec	 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], eax
  000aa	eb 3c		 jmp	 SHORT $LN27@CheckChoas
$LN22@CheckChoas:

; 1248 : 			}
; 1249 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,17) )

  000ac	ba 11 1a 00 00	 mov	 edx, 6673		; 00001a11H
  000b1	66 3b ca	 cmp	 cx, dx
  000b4	75 14		 jne	 SHORT $LN20@CheckChoas

; 1250 : 			{
; 1251 : 				int iBLOOD_BONE_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;
; 1252 : 				iEventItemCount++;
; 1253 : 				bIsBloodBoneExist = TRUE;
; 1254 : 				iBloodBoneLevel = iBLOOD_BONE_LEVEL;

  000b6	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	01 4d 08	 add	 DWORD PTR _iEventItemCount$[ebp], ecx
  000c2	89 4d f8	 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], ecx
  000c5	89 45 e8	 mov	 DWORD PTR _iBloodBoneLevel$[ebp], eax
  000c8	eb 1e		 jmp	 SHORT $LN27@CheckChoas
$LN20@CheckChoas:

; 1255 : 			}
; 1256 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(14,53) )

  000ca	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000cf	66 3b ca	 cmp	 cx, dx
  000d2	75 0d		 jne	 SHORT $LN18@CheckChoas

; 1257 : 			{
; 1258 : 				iCharmOfLuckCount += (int)gObj[iIndex].pChaosBox[i].m_Durability;

  000d4	d9 40 24	 fld	 DWORD PTR [eax+36]
  000d7	e8 00 00 00 00	 call	 __ftol2_sse
  000dc	01 45 fc	 add	 DWORD PTR _iCharmOfLuckCount$[ebp], eax

; 1259 : 			}
; 1260 : 			else

  000df	eb 07		 jmp	 SHORT $LN27@CheckChoas
$LN18@CheckChoas:

; 1261 : 			{
; 1262 : 				bIsOtherItemExist = TRUE;

  000e1	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$[ebp], 1
$LN27@CheckChoas:

; 1233 : 
; 1234 : 	for ( int i=0;i<CHAOS_BOX_SIZE;i++)

  000e8	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000ee	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  000f4	0f 8c 56 ff ff
	ff		 jl	 $LL28@CheckChoas

; 1263 : 			}
; 1264 : 		}
; 1265 : 	}
; 1266 : 
; 1267 : 	gObj[iIndex].ChaosSuccessRate = iCharmOfLuckCount;
; 1268 : 
; 1269 : 	if ( bIsOtherItemExist != FALSE )

  000fa	83 7d f4 00	 cmp	 DWORD PTR _bIsOtherItemExist$[ebp], 0
  000fe	8b 45 fc	 mov	 eax, DWORD PTR _iCharmOfLuckCount$[ebp]
  00101	89 84 1e 84 0e
	00 00		 mov	 DWORD PTR [esi+ebx+3716], eax
  00108	5b		 pop	 ebx
  00109	74 0d		 je	 SHORT $LN16@CheckChoas

; 1270 : 	{
; 1271 : 		return 8;

  0010b	5f		 pop	 edi
  0010c	b8 08 00 00 00	 mov	 eax, 8
  00111	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 04 00	 ret	 4
$LN16@CheckChoas:

; 1272 : 	}
; 1273 : 
; 1274 : 	if ( bIsAngelKingPaperExist == FALSE && bIsBloodBoneExist == FALSE )

  00118	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  0011c	75 14		 jne	 SHORT $LN40@CheckChoas
  0011e	83 7d f8 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  00122	0f 85 ee 00 00
	00		 jne	 $LN13@CheckChoas
$LN41@CheckChoas:
  00128	5f		 pop	 edi

; 1275 : 	{
; 1276 : 		return 0;

  00129	33 c0		 xor	 eax, eax
  0012b	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 04 00	 ret	 4
$LN40@CheckChoas:

; 1277 : 	}
; 1278 : 
; 1279 : 	if ( bIsAngelKingPaperExist == FALSE || bIsBloodBoneExist == FALSE )

  00132	83 7d f8 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  00136	0f 84 da 00 00
	00		 je	 $LN13@CheckChoas

; 1282 : 	}
; 1283 : 
; 1284 : 	if ( iEventItemCount > 2 )

  0013c	83 7d 08 02	 cmp	 DWORD PTR _iEventItemCount$[ebp], 2
  00140	7e 0d		 jle	 SHORT $LN12@CheckChoas

; 1285 : 	{
; 1286 : 		return 12;

  00142	5f		 pop	 edi
  00143	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00148	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 04 00	 ret	 4
$LN12@CheckChoas:

; 1287 : 	}
; 1288 : 
; 1289 : 	if ( iCharmOfLuckCount > 10 )

  0014f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00152	7e 0d		 jle	 SHORT $LN11@CheckChoas

; 1290 : 	{
; 1291 : 		return 15;

  00154	5f		 pop	 edi
  00155	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0015a	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 04 00	 ret	 4
$LN11@CheckChoas:

; 1292 : 	}
; 1293 : 
; 1294 : 	if ( iAngelKingPaperLevel != iBloodBoneLevel )

  00161	8b 7d ec	 mov	 edi, DWORD PTR _iAngelKingPaperLevel$[ebp]
  00164	8b 4d e8	 mov	 ecx, DWORD PTR _iBloodBoneLevel$[ebp]
  00167	3b f9		 cmp	 edi, ecx
  00169	74 0d		 je	 SHORT $LN10@CheckChoas
$LN42@CheckChoas:
  0016b	5f		 pop	 edi

; 1295 : 	{
; 1296 : 		return 9;

  0016c	b8 09 00 00 00	 mov	 eax, 9
  00171	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c2 04 00	 ret	 4
$LN10@CheckChoas:

; 1297 : 	}
; 1298 : 
; 1299 : 	if ( BC_BRIDGE_RANGE(iAngelKingPaperLevel-1) == FALSE )

  00178	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0017b	85 c0		 test	 eax, eax
  0017d	78 ec		 js	 SHORT $LN42@CheckChoas
  0017f	33 d2		 xor	 edx, edx
  00181	83 f8 07	 cmp	 eax, 7
  00184	0f 9e c2	 setle	 dl
  00187	8b c2		 mov	 eax, edx
  00189	85 c0		 test	 eax, eax

; 1300 : 	{
; 1301 : 		return 9;

  0018b	74 de		 je	 SHORT $LN42@CheckChoas

; 1302 : 	}
; 1303 : 
; 1304 : 	if ( BC_BRIDGE_RANGE(iBloodBoneLevel-1) == FALSE )

  0018d	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00190	85 c0		 test	 eax, eax
  00192	78 d7		 js	 SHORT $LN42@CheckChoas
  00194	33 c9		 xor	 ecx, ecx
  00196	83 f8 07	 cmp	 eax, 7
  00199	0f 9e c1	 setle	 cl
  0019c	8b c1		 mov	 eax, ecx
  0019e	85 c0		 test	 eax, eax

; 1305 : 	{
; 1306 : 		return 9;

  001a0	74 c9		 je	 SHORT $LN42@CheckChoas

; 1307 : 	}
; 1308 : 
; 1309 : 	if ( bIsChaosGemExist == FALSE )

  001a2	83 7d e4 00	 cmp	 DWORD PTR _bIsChaosGemExist$[ebp], 0
  001a6	75 0d		 jne	 SHORT $LN7@CheckChoas

; 1310 : 	{
; 1311 : 		return 10;

  001a8	5f		 pop	 edi
  001a9	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  001ae	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c2 04 00	 ret	 4
$LN7@CheckChoas:

; 1312 : 	}
; 1313 : 
; 1314 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 1315 : #ifdef MONK
; 1316 : 		|| gObj[iIndex].Class == CLASS_MONK
; 1317 : #endif
; 1318 : 		|| gObj[iIndex].Class == CLASS_MAGUMSA )

  001b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bb	0f b7 84 0e b8
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+184]
  001c3	83 f8 04	 cmp	 eax, 4
  001c6	74 27		 je	 SHORT $LN5@CheckChoas
  001c8	83 f8 06	 cmp	 eax, 6
  001cb	74 22		 je	 SHORT $LN5@CheckChoas
  001cd	83 f8 03	 cmp	 eax, 3
  001d0	74 1d		 je	 SHORT $LN5@CheckChoas

; 1323 : 		}
; 1324 : 	}
; 1325 : 	else
; 1326 : 	{
; 1327 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND )

  001d2	0f bf 94 0e be
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+190]
  001da	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _g_sttBLOODCASTLE_LEVEL
  001e0	7d 2a		 jge	 SHORT $LN4@CheckChoas

; 1328 : 		{
; 1329 : 			return 14;

  001e2	5f		 pop	 edi
  001e3	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  001e8	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 04 00	 ret	 4
$LN5@CheckChoas:

; 1319 : 	{
; 1320 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND_MAGUMSA )

  001ef	0f bf 84 0e be
	00 00 00	 movsx	 eax, WORD PTR [esi+ecx+190]
  001f7	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_sttBLOODCASTLE_LEVEL+8
  001fd	7d 0d		 jge	 SHORT $LN4@CheckChoas

; 1321 : 		{
; 1322 : 			return 14;

  001ff	5f		 pop	 edi
  00200	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00205	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 04 00	 ret	 4
$LN4@CheckChoas:

; 1330 : 		}
; 1331 : 	}
; 1332 : 
; 1333 : 	if ( bIsChaosGemExist != FALSE && bIsAngelKingPaperExist != FALSE && bIsBloodBoneExist != FALSE )
; 1334 : 	{
; 1335 : 		return iAngelKingPaperLevel;

  0020c	8b c7		 mov	 eax, edi
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c2 04 00	 ret	 4
$LN13@CheckChoas:
  00216	5f		 pop	 edi

; 1280 : 	{
; 1281 : 		return 11;

  00217	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0021c	5e		 pop	 esi

; 1336 : 	}
; 1337 : 
; 1338 : 	return 0;
; 1339 : }

  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c2 04 00	 ret	 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckChoasMixItem
_TEXT	ENDS
PUBLIC	?CheckEnterItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckEnterItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckEnterItem, COMDAT
; _this$ = ecx

; 1342 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 1343 : 	int iITEM_LEVEL = 0;
; 1344 : 
; 1345 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	85 ff		 test	 edi, edi
  0000c	78 0f		 js	 SHORT $LN21@CheckEnter@3
  0000e	33 c0		 xor	 eax, eax
  00010	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN11@CheckEnter@3
$LN21@CheckEnter@3:
  0001d	5f		 pop	 edi

; 1346 : 	{
; 1347 : 		return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	5b		 pop	 ebx

; 1383 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN11@CheckEnter@3:

; 1348 : 	}
; 1349 : 
; 1350 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00030	66 83 7c 07 68
	01		 cmp	 WORD PTR [edi+eax+104], 1
  00036	75 e5		 jne	 SHORT $LN21@CheckEnter@3
  00038	83 7c 07 04 02	 cmp	 DWORD PTR [edi+eax+4], 2
  0003d	7e de		 jle	 SHORT $LN21@CheckEnter@3

; 1351 : 	{
; 1352 : 		return 0;
; 1353 : 	}
; 1354 : 
; 1355 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0003f	56		 push	 esi
  00040	33 f6		 xor	 esi, esi
  00042	eb 11		 jmp	 SHORT $LN8@CheckEnter@3
  00044	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL24@CheckEnter@3:
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN8@CheckEnter@3:

; 1356 : 	{
; 1357 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00055	8b 8c 07 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3620]
  0005c	03 ce		 add	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00063	83 f8 01	 cmp	 eax, 1
  00066	75 47		 jne	 SHORT $LN7@CheckEnter@3

; 1358 : 		{
; 1359 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,18) )

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	8b 84 07 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+eax+3620]
  00074	0f b7 4c 30 06	 movzx	 ecx, WORD PTR [eax+esi+6]
  00079	ba 12 1a 00 00	 mov	 edx, 6674		; 00001a12H
  0007e	66 3b ca	 cmp	 cx, dx
  00081	75 1d		 jne	 SHORT $LN2@CheckEnter@3

; 1360 : 			{
; 1361 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  00083	0f bf 5c 30 08	 movsx	 ebx, WORD PTR [eax+esi+8]

; 1362 : 
; 1363 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CLOACK_LEVEL) == FALSE )

  00088	85 db		 test	 ebx, ebx
  0008a	78 0c		 js	 SHORT $LN22@CheckEnter@3
  0008c	33 c0		 xor	 eax, eax
  0008e	83 fb 08	 cmp	 ebx, 8
  00091	0f 9e c0	 setle	 al
  00094	85 c0		 test	 eax, eax
  00096	75 04		 jne	 SHORT $LN3@CheckEnter@3
$LN22@CheckEnter@3:

; 1364 : 				{
; 1365 : 					iITEM_LEVEL = 0;

  00098	33 db		 xor	 ebx, ebx

; 1366 : 
; 1367 : 				}
; 1368 : 
; 1369 : 				if ( iITEM_LEVEL != 0 )

  0009a	eb 04		 jmp	 SHORT $LN2@CheckEnter@3
$LN3@CheckEnter@3:
  0009c	85 db		 test	 ebx, ebx
  0009e	75 1d		 jne	 SHORT $LN6@CheckEnter@3
$LN2@CheckEnter@3:

; 1370 : 				{
; 1371 : 					return iITEM_LEVEL;
; 1372 : 				}
; 1373 : 			}
; 1374 : 			
; 1375 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,47) )

  000a0	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  000a5	66 3b c8	 cmp	 cx, ax
  000a8	75 05		 jne	 SHORT $LN7@CheckEnter@3

; 1376 : 			{
; 1377 : 				iITEM_LEVEL = 10;

  000aa	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
$LN7@CheckEnter@3:

; 1351 : 	{
; 1352 : 		return 0;
; 1353 : 	}
; 1354 : 
; 1355 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  000af	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000b5	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  000bb	7c 93		 jl	 SHORT $LL24@CheckEnter@3
$LN6@CheckEnter@3:
  000bd	5e		 pop	 esi
  000be	5f		 pop	 edi

; 1378 : 			}
; 1379 : 		}
; 1380 : 	}
; 1381 : 
; 1382 : 	return iITEM_LEVEL;

  000bf	8b c3		 mov	 eax, ebx
  000c1	5b		 pop	 ebx

; 1383 : }

  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckEnterItem
_TEXT	ENDS
PUBLIC	?CheckWalk@CBloodCastle@@QAE_NHHH@Z		; CBloodCastle::CheckWalk
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?CheckWalk@CBloodCastle@@QAE_NHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iMoveX$ = 12						; size = 4
_iMoveY$ = 16						; size = 4
?CheckWalk@CBloodCastle@@QAE_NHHH@Z PROC		; CBloodCastle::CheckWalk, COMDAT
; _this$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1439 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN15@CheckWalk
  0000a	33 d2		 xor	 edx, edx
  0000c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00011	0f 9e c2	 setle	 dl
  00014	85 d2		 test	 edx, edx
  00016	75 06		 jne	 SHORT $LN6@CheckWalk
$LN15@CheckWalk:

; 1440 : 	{
; 1441 : 		return false;

  00018	32 c0		 xor	 al, al

; 1461 : 		}
; 1462 : 	}
; 1463 : 
; 1464 : 	return false;
; 1465 : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN6@CheckWalk:

; 1442 : 	}
; 1443 : 	
; 1444 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00024	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002a	56		 push	 esi
  0002b	8d 34 10	 lea	 esi, DWORD PTR [eax+edx]
  0002e	8a 86 49 01 00
	00		 mov	 al, BYTE PTR [esi+329]
  00034	3c 34		 cmp	 al, 52			; 00000034H
  00036	74 10		 je	 SHORT $LN5@CheckWalk
  00038	3c 0b		 cmp	 al, 11			; 0000000bH
  0003a	72 4d		 jb	 SHORT $LN3@CheckWalk
  0003c	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  00041	3a d0		 cmp	 dl, al
  00043	1b d2		 sbb	 edx, edx
  00045	42		 inc	 edx

; 1445 : 	{
; 1446 : 		return false;

  00046	74 41		 je	 SHORT $LN3@CheckWalk
$LN5@CheckWalk:

; 1447 : 	}
; 1448 : 
; 1449 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00048	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  0004d	75 3a		 jne	 SHORT $LN3@CheckWalk
  0004f	83 7e 04 02	 cmp	 DWORD PTR [esi+4], 2
  00053	7e 34		 jle	 SHORT $LN3@CheckWalk

; 1452 : 	}
; 1453 : 
; 1454 : 	if ( this->GetCurrentState(gObj[iIndex].MapNumber) == TRUE )

  00055	0f b6 f0	 movzx	 esi, al
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 26		 jne	 SHORT $LN3@CheckWalk

; 1455 : 	{
; 1456 : 		BYTE btMapAttr = MapC[gObj[iIndex].MapNumber].GetAttr(iMoveX, iMoveY);

  00063	8b 45 10	 mov	 eax, DWORD PTR _iMoveY$[ebp]
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _iMoveX$[ebp]
  00069	50		 push	 eax
  0006a	51		 push	 ecx
  0006b	8b ce		 mov	 ecx, esi
  0006d	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00073	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00079	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 1457 : 
; 1458 : 		if ( (btMapAttr&1) != 1 )

  0007e	a8 01		 test	 al, 1
  00080	75 07		 jne	 SHORT $LN3@CheckWalk

; 1459 : 		{
; 1460 : 			return true;

  00082	b0 01		 mov	 al, 1
  00084	5e		 pop	 esi

; 1461 : 		}
; 1462 : 	}
; 1463 : 
; 1464 : 	return false;
; 1465 : }

  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
$LN3@CheckWalk:

; 1450 : 	{
; 1451 : 		return false;

  00089	32 c0		 xor	 al, al
  0008b	5e		 pop	 esi

; 1461 : 		}
; 1462 : 	}
; 1463 : 
; 1464 : 	return false;
; 1465 : }

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH
?CheckWalk@CBloodCastle@@QAE_NHHH@Z ENDP		; CBloodCastle::CheckWalk
_TEXT	ENDS
PUBLIC	?CheckCanEnter@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanEnter
; Function compile flags: /Ogtp
;	COMDAT ?CheckCanEnter@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanEnter, COMDAT
; _this$ = ecx

; 1468 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1469 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckCanEn
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckCanEn
$LN6@CheckCanEn:

; 1470 : 	{
; 1471 : 		return false;

  00016	32 c0		 xor	 al, al

; 1475 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckCanEn:

; 1472 : 	}
; 1473 : 
; 1474 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER;

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	8a 84 08 bb 03
	00 00		 mov	 al, BYTE PTR [eax+ecx+955]

; 1475 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanEnter
_TEXT	ENDS
PUBLIC	?CheckCanParty@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanParty
; Function compile flags: /Ogtp
;	COMDAT ?CheckCanParty@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanParty, COMDAT
; _this$ = ecx

; 1478 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1479 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckCanPa
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckCanPa
$LN6@CheckCanPa:

; 1480 : 	{
; 1481 : 		return false;

  00016	32 c0		 xor	 al, al

; 1485 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckCanPa:

; 1482 : 	}
; 1483 : 
; 1484 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY;

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	8a 84 08 bc 03
	00 00		 mov	 al, BYTE PTR [eax+ecx+956]

; 1485 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanParty
_TEXT	ENDS
PUBLIC	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
; Function compile flags: /Ogtp
;	COMDAT ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_lpItem$ = 12						; size = 4
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z PROC ; CBloodCastle::CheckQuestItemSerial, COMDAT
; _this$ = ecx

; 1488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1489 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN13@CheckQuest
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN6@CheckQuest
$LN13@CheckQuest:

; 1490 : 	{
; 1491 : 		return false;

  00016	32 c0		 xor	 al, al

; 1517 : 
; 1518 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN6@CheckQuest:

; 1492 : 	}
; 1493 : 
; 1494 : 	if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	83 bc 08 e8 03
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+1000], -1
  0002a	53		 push	 ebx
  0002b	8d 9c 08 e8 03
	00 00		 lea	 ebx, DWORD PTR [eax+ecx+1000]
  00032	75 07		 jne	 SHORT $LN5@CheckQuest

; 1495 : 	{
; 1496 : 		return false;

  00034	32 c0		 xor	 al, al
  00036	5b		 pop	 ebx

; 1517 : 
; 1518 : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN5@CheckQuest:
  0003b	56		 push	 esi

; 1497 : 	}
; 1498 : 	
; 1499 : 	if ( lpItem->IsItem() == TRUE )

  0003c	8b 75 0c	 mov	 esi, DWORD PTR _lpItem$[ebp]
  0003f	57		 push	 edi
  00040	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00043	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00048	83 f8 01	 cmp	 eax, 1
  0004b	75 31		 jne	 SHORT $LN1@CheckQuest

; 1500 : 	{
; 1501 : 		if ( lpItem->m_Type == ITEMGET(13,19) )

  0004d	b8 13 1a 00 00	 mov	 eax, 6675		; 00001a13H
  00052	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  00056	75 26		 jne	 SHORT $LN1@CheckQuest

; 1502 : 		{
; 1503 : 			int iLEVEL = lpItem->m_Level;

  00058	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]

; 1504 : 
; 1505 : 			if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  0005c	85 c0		 test	 eax, eax
  0005e	78 1e		 js	 SHORT $LN1@CheckQuest
  00060	33 c9		 xor	 ecx, ecx
  00062	83 f8 02	 cmp	 eax, 2
  00065	0f 9e c1	 setle	 cl
  00068	8b c1		 mov	 eax, ecx
  0006a	85 c0		 test	 eax, eax
  0006c	74 10		 je	 SHORT $LN1@CheckQuest

; 1506 : 			{
; 1507 : 				if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == lpItem->m_Number )

  0006e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00070	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00073	75 09		 jne	 SHORT $LN1@CheckQuest

; 1508 : 				{
; 1509 : 					return true;

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	b0 01		 mov	 al, 1
  00079	5b		 pop	 ebx

; 1517 : 
; 1518 : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN1@CheckQuest:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 1510 : 				}
; 1511 : 			}
; 1512 : 		}
; 1513 : 	}
; 1514 : 	
; 1515 : 
; 1516 : 	return false;

  00080	32 c0		 xor	 al, al
  00082	5b		 pop	 ebx

; 1517 : 
; 1518 : }

  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ENDP ; CBloodCastle::CheckQuestItemSerial
_TEXT	ENDS
PUBLIC	?CheckPlayStart@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPlayStart
; Function compile flags: /Ogtp
;	COMDAT ?CheckPlayStart@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPlayStart, COMDAT
; _this$ = ecx

; 1521 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1522 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckPlayS
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckPlayS
$LN6@CheckPlayS:

; 1523 : 	{
; 1524 : 		return false;

  00016	32 c0		 xor	 al, al

; 1528 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckPlayS:

; 1525 : 	}
; 1526 : 
; 1527 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START;

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	8a 84 08 bd 03
	00 00		 mov	 al, BYTE PTR [eax+ecx+957]

; 1528 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPlayStart
_TEXT	ENDS
PUBLIC	?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z	; CBloodCastle::LeaveUserBridge
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iBridgeSubIndex$ = 12					; size = 4
_iUserIndex$ = 16					; size = 4
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z PROC		; CBloodCastle::LeaveUserBridge, COMDAT
; _this$ = ecx

; 1853 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1854 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 0c		 js	 SHORT $LN10@LeaveUserB
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 07	 cmp	 esi, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN3@LeaveUserB
$LN10@LeaveUserB:
  0001a	5f		 pop	 edi

; 1855 : 	{
; 1856 : 		return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5e		 pop	 esi

; 1880 : }

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
$LN3@LeaveUserB:

; 1857 : 	}
; 1858 : 
; 1859 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  00023	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  00026	85 c0		 test	 eax, eax
  00028	78 f0		 js	 SHORT $LN10@LeaveUserB
  0002a	33 c9		 xor	 ecx, ecx
  0002c	83 f8 27	 cmp	 eax, 39			; 00000027H
  0002f	0f 9e c1	 setle	 cl
  00032	8b c1		 mov	 eax, ecx
  00034	85 c0		 test	 eax, eax

; 1860 : 	{
; 1861 : 		return -1;

  00036	74 e2		 je	 SHORT $LN10@LeaveUserB

; 1862 : 	}
; 1863 : 
; 1864 : 	int iRET_VAL = -1;
; 1865 : 
; 1866 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00038	8b d6		 mov	 edx, esi
  0003a	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  00040	53		 push	 ebx
  00041	8d 44 3a 04	 lea	 eax, DWORD PTR [edx+edi+4]
  00045	50		 push	 eax
  00046	83 cb ff	 or	 ebx, -1
  00049	89 45 08	 mov	 DWORD PTR tv200[ebp], eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1867 : 
; 1868 : 	if ( this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex == iUserIndex )

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeSubIndex$[ebp]
  00055	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  0005c	2b c6		 sub	 eax, esi
  0005e	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00061	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00064	8d 0c 97	 lea	 ecx, DWORD PTR [edi+edx*4]
  00067	8b 55 10	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  0006a	39 51 1c	 cmp	 DWORD PTR [ecx+28], edx
  0006d	75 18		 jne	 SHORT $LN1@LeaveUserB

; 1869 : 	{
; 1870 : 		iRET_VAL = iUserIndex;

  0006f	8b da		 mov	 ebx, edx

; 1871 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex = -1;
; 1872 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iEXP = 0;

  00071	33 d2		 xor	 edx, edx

; 1873 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iScore = 0;
; 1874 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  00073	8d 44 80 0a	 lea	 eax, DWORD PTR [eax+eax*4+10]
  00077	c7 41 1c ff ff
	ff ff		 mov	 DWORD PTR [ecx+28], -1
  0007e	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00081	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00084	89 14 87	 mov	 DWORD PTR [edi+eax*4], edx
$LN1@LeaveUserB:

; 1875 : 	}
; 1876 : 
; 1877 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00087	8b 4d 08	 mov	 ecx, DWORD PTR tv200[ebp]
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1878 : 
; 1879 : 	return iRET_VAL;

  00091	8b c3		 mov	 eax, ebx
  00093	5b		 pop	 ebx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi

; 1880 : }

  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z ENDP		; CBloodCastle::LeaveUserBridge
_TEXT	ENDS
PUBLIC	?EnterUserBridge@CBloodCastle@@QAEHHH@Z		; CBloodCastle::EnterUserBridge
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
; Function compile flags: /Ogtp
;	COMDAT ?EnterUserBridge@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv229 = -4						; size = 4
_iRET_VAL$ = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserBridge@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::EnterUserBridge, COMDAT
; _this$ = ecx

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 1884 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	78 0c		 js	 SHORT $LN23@EnterUserB
  0000f	33 c0		 xor	 eax, eax
  00011	83 ff 07	 cmp	 edi, 7
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	75 0b		 jne	 SHORT $LN12@EnterUserB
$LN23@EnterUserB:
  0001b	5f		 pop	 edi

; 1885 : 	{
; 1886 : 		return -1;

  0001c	83 c8 ff	 or	 eax, -1
  0001f	5b		 pop	 ebx

; 1935 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN12@EnterUserB:

; 1887 : 	}
; 1888 : 
; 1889 : 	int iRET_VAL = -1;
; 1890 : 
; 1891 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00026	8b c7		 mov	 eax, edi
  00028	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002e	8d 44 18 04	 lea	 eax, DWORD PTR [eax+ebx+4]
  00032	56		 push	 esi
  00033	50		 push	 eax
  00034	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1
  0003b	89 45 fc	 mov	 DWORD PTR tv229[ebp], eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1892 : 
; 1893 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00044	33 f6		 xor	 esi, esi
  00046	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL11@EnterUserB:

; 1894 : 	{
; 1895 : 		if(g_ZtLicense.CheckUser(Gredy) || g_ZtLicense.CheckUser(Gredy2) || g_ZtLicense.CheckUser(GredyLocal))

  00050	6a 20		 push	 32			; 00000020H
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00057	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0005c	84 c0		 test	 al, al
  0005e	75 25		 jne	 SHORT $LN7@EnterUserB
  00060	6a 22		 push	 34			; 00000022H
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00067	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0006c	84 c0		 test	 al, al
  0006e	75 15		 jne	 SHORT $LN7@EnterUserB
  00070	6a 21		 push	 33			; 00000021H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00077	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0007c	84 c0		 test	 al, al
  0007e	75 05		 jne	 SHORT $LN7@EnterUserB

; 1898 : 			{
; 1899 : 				break;
; 1900 : 			}
; 1901 : 		}
; 1902 : 		else
; 1903 : 		{
; 1904 : 			if( i > 20)

  00080	83 fe 14	 cmp	 esi, 20			; 00000014H
  00083	eb 06		 jmp	 SHORT $LN26@EnterUserB
$LN7@EnterUserB:

; 1896 : 		{
; 1897 : 			if( i > ZtConfig.m_iBloodCastleMaxUser)

  00085	3b 35 a0 0d 00
	00		 cmp	 esi, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+3488
$LN26@EnterUserB:
  0008b	7f 6c		 jg	 SHORT $LN25@EnterUserB

; 1905 : 			{
; 1906 : 				break;
; 1907 : 			}
; 1908 : 		}
; 1909 : 
; 1910 : 
; 1911 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  0008d	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  00094	2b cf		 sub	 ecx, edi
  00096	8d 04 ce	 lea	 eax, DWORD PTR [esi+ecx*8]
  00099	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  0009c	8b 44 93 1c	 mov	 eax, DWORD PTR [ebx+edx*4+28]

; 1912 : 		{
; 1913 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iUserIndex )

  000a0	8b 55 0c	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	74 16		 je	 SHORT $LN21@EnterUserB
  000a8	3b c2		 cmp	 eax, edx
  000aa	74 0d		 je	 SHORT $LN20@EnterUserB

; 1917 : 			}
; 1918 : 		}
; 1919 : 
; 1920 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  000ac	83 f8 ff	 cmp	 eax, -1
  000af	74 0d		 je	 SHORT $LN21@EnterUserB

; 1892 : 
; 1893 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000b1	46		 inc	 esi
  000b2	83 fe 28	 cmp	 esi, 40			; 00000028H
  000b5	7c 99		 jl	 SHORT $LL11@EnterUserB

; 1917 : 			}
; 1918 : 		}
; 1919 : 
; 1920 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  000b7	eb 40		 jmp	 SHORT $LN25@EnterUserB
$LN20@EnterUserB:

; 1914 : 			{
; 1915 : 				iRET_VAL = i;

  000b9	89 75 08	 mov	 DWORD PTR _iRET_VAL$[ebp], esi

; 1916 : 				break;

  000bc	eb 3b		 jmp	 SHORT $LN25@EnterUserB
$LN21@EnterUserB:

; 1921 : 		{
; 1922 : 			iRET_VAL = i;
; 1923 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = iUserIndex;

  000be	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  000c5	2b c7		 sub	 eax, edi
  000c7	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  000ca	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000cd	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  000d0	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  000d3	89 75 08	 mov	 DWORD PTR _iRET_VAL$[ebp], esi

; 1924 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  000d6	33 f6		 xor	 esi, esi

; 1925 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;
; 1926 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;
; 1927 : 			gObj[iUserIndex].m_bBloodCastleComplete = false;

  000d8	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000de	8d 44 80 0a	 lea	 eax, DWORD PTR [eax+eax*4+10]
  000e2	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  000e5	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  000e8	89 34 83	 mov	 DWORD PTR [ebx+eax*4], esi
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	c6 84 0a a4 0e
	00 00 00	 mov	 BYTE PTR [edx+ecx+3748], 0
$LN25@EnterUserB:

; 1928 : 			break;
; 1929 : 		}
; 1930 : 	}
; 1931 : 
; 1932 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  000f9	8b 55 fc	 mov	 edx, DWORD PTR tv229[ebp]
  000fc	52		 push	 edx
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1933 : 
; 1934 : 	return iRET_VAL;

  00103	8b 45 08	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  00106	5e		 pop	 esi
  00107	5f		 pop	 edi
  00108	5b		 pop	 ebx

; 1935 : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
?EnterUserBridge@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::EnterUserBridge
_TEXT	ENDS
PUBLIC	??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?LevelUp@CBloodCastle@@QAEHHHH@Z		; CBloodCastle::LevelUp
EXTRN	?LevelUp@CAchievements@@QAEXH@Z:PROC		; CAchievements::LevelUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	_sprintf:PROC
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
EXTRN	?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z:PROC ; CMasterLevelSystem::MasterLevelUp
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
;	COMDAT ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ DB ',(%s)(%s) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
CONST	SEGMENT
??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ DB '4'
	DB	'00 LevelUp (%s)(%s) Party ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LevelUp@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iIndex$GSCopy$ = -268					; size = 4
tv311 = -264						; size = 4
_szMsg$219317 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CBloodCastle@@QAEHHHH@Z PROC			; CBloodCastle::LevelUp, COMDAT
; _this$ = ecx

; 1938 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 2037 : 		}
; 2038 : 	}
; 2039 : #ifndef FIX_DS_CRASH
; 2040 : 	GJSetCharacterInfo(&gObj[iIndex], gObj[iIndex].m_Index, 0);
; 2041 : #endif	
; 2042 : #if(SYSTEM_ACHIEVEMENTS)
; 2043 : 	g_Achievements.LevelUp(iIndex);

  00017	89 bd f4 fe ff
	ff		 mov	 DWORD PTR _iIndex$GSCopy$[ebp], edi
  0001d	85 ff		 test	 edi, edi
  0001f	78 0f		 js	 SHORT $LN21@LevelUp

; 1939 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00021	33 c0		 xor	 eax, eax
  00023	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00029	0f 9e c0	 setle	 al
  0002c	85 c0		 test	 eax, eax
  0002e	75 13		 jne	 SHORT $LN14@LevelUp
$LN21@LevelUp:

; 1940 : 	{
; 1941 : 		return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5f		 pop	 edi

; 2044 : #endif
; 2045 : 	return iLEFT_EXP;
; 2046 : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
$LN14@LevelUp:

; 1942 : 	}
; 1943 : 
; 1944 : 	int iLEFT_EXP = 0;
; 1945 : 
; 1946 : 	if(g_MasterLevelSystem.MasterLevelUp(&gObj[iIndex], (__int64&)iAddExp,1,0) != 0) //season3 add-on

  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	8b f7		 mov	 esi, edi
  0004d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00053	33 db		 xor	 ebx, ebx
  00055	53		 push	 ebx
  00056	6a 01		 push	 1
  00058	8d 45 0c	 lea	 eax, DWORD PTR _iAddExp$[ebp]
  0005b	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0005e	50		 push	 eax
  0005f	52		 push	 edx
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00065	e8 00 00 00 00	 call	 ?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z ; CMasterLevelSystem::MasterLevelUp
  0006a	85 c0		 test	 eax, eax

; 1947 : 	{
; 1948 : 		return 0;

  0006c	0f 85 88 00 00
	00		 jne	 $LN25@LevelUp

; 1949 : 	}
; 1950 : 
; 1951 : 
; 1952 : 	::gObjSetExpPetItem(iIndex, iAddExp);

  00072	8b 45 0c	 mov	 eax, DWORD PTR _iAddExp$[ebp]
  00075	50		 push	 eax
  00076	57		 push	 edi
  00077	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem

; 1953 : 
; 1954 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d", gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].X, gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level, gObj[iIndex].Experience, iAddExp, 0, iEventType);

  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00081	8b 55 10	 mov	 edx, DWORD PTR _iEventType$[ebp]
  00084	0f bf 8c 06 44
	01 00 00	 movsx	 ecx, WORD PTR [esi+eax+324]
  0008c	52		 push	 edx
  0008d	8b 55 0c	 mov	 edx, DWORD PTR _iAddExp$[ebp]
  00090	53		 push	 ebx
  00091	52		 push	 edx
  00092	8b 94 06 c8 00
	00 00		 mov	 edx, DWORD PTR [esi+eax+200]
  00099	52		 push	 edx
  0009a	0f bf 94 06 be
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+190]
  000a2	52		 push	 edx
  000a3	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000a7	52		 push	 edx
  000a8	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000ac	0f b6 84 06 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+329]
  000b4	52		 push	 edx
  000b5	51		 push	 ecx
  000b6	51		 push	 ecx
  000b7	50		 push	 eax
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1955 : 
; 1956 : 	#if(ENABLE_CHARLVL1000)
; 1957 : 
; 1958 : 	if ( gObj[iIndex].Level >= ZtConfig.ZtCustom.MaxLevel )

  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c9	0f bf 94 0e be
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+190]
  000d1	83 c4 34	 add	 esp, 52			; 00000034H
  000d4	3b 15 24 00 00
	00		 cmp	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+36
  000da	7c 33		 jl	 SHORT $LN12@LevelUp

; 1959 : 	{
; 1960 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iIndex].m_Index, 1);

  000dc	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  000df	6a 01		 push	 1
  000e1	50		 push	 eax
  000e2	68 70 04 00 00	 push	 1136			; 00000470H
  000e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ec	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@LevelUp:

; 1961 : 		return 0;

  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	33 c0		 xor	 eax, eax
  000fe	5f		 pop	 edi

; 2044 : #endif
; 2045 : 	return iLEFT_EXP;
; 2046 : }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 0c 00	 ret	 12			; 0000000cH
$LN12@LevelUp:

; 1962 : 	}
; 1963 : 
; 1964 : 	#else
; 1965 : 
; 1966 : 	if ( gObj[iIndex].Level >= MAX_CHAR_LEVEL )
; 1967 : 	{
; 1968 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iIndex].m_Index, 1);
; 1969 : 		return 0;
; 1970 : 	}
; 1971 : 
; 1972 : 	#endif
; 1973 : 
; 1974 : 	if ( (gObj[iIndex].Experience + iAddExp) < gObj[iIndex].NextExp )

  0010f	8b bc 0e c8 00
	00 00		 mov	 edi, DWORD PTR [esi+ecx+200]
  00116	8b 55 0c	 mov	 edx, DWORD PTR _iAddExp$[ebp]
  00119	8d 84 0e c8 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+200]
  00120	8d 8c 0e cc 00
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+204]
  00127	03 fa		 add	 edi, edx
  00129	3b 39		 cmp	 edi, DWORD PTR [ecx]
  0012b	73 07		 jae	 SHORT $LN11@LevelUp

; 1975 : 	{
; 1976 : 		gObj[iIndex].Experience += iAddExp;

  0012d	01 10		 add	 DWORD PTR [eax], edx

; 1977 : 	}
; 1978 : 	else

  0012f	e9 39 02 00 00	 jmp	 $LN5@LevelUp
$LN11@LevelUp:

; 1979 : 	{
; 1980 : 		iLEFT_EXP = gObj[iIndex].Experience + iAddExp - gObj[iIndex].NextExp;

  00134	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00136	8b 18		 mov	 ebx, DWORD PTR [eax]

; 1981 : 		gObj[iIndex].Experience = gObj[iIndex].NextExp;

  00138	89 08		 mov	 DWORD PTR [eax], ecx

; 1982 : 		gObj[iIndex].Level++;

  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013f	66 ff 84 06 be
	00 00 00	 inc	 WORD PTR [esi+eax+190]
  00147	2b d9		 sub	 ebx, ecx

; 1983 : 
; 1984 : 		if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 1985 : #ifdef MONK
; 1986 : 			|| gObj[iIndex].Class == CLASS_MONK
; 1987 : #endif
; 1988 : 			|| gObj[iIndex].Class == CLASS_MAGUMSA )

  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014f	0f b7 84 0e b8
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+184]
  00157	03 da		 add	 ebx, edx
  00159	83 f8 04	 cmp	 eax, 4
  0015c	74 1b		 je	 SHORT $LN8@LevelUp
  0015e	83 f8 06	 cmp	 eax, 6
  00161	74 16		 je	 SHORT $LN8@LevelUp
  00163	83 f8 03	 cmp	 eax, 3
  00166	74 11		 je	 SHORT $LN8@LevelUp

; 1991 : 		}
; 1992 : 		else
; 1993 : 		{
; 1994 : 			gObj[iIndex].LevelUpPoint += 5;

  00168	83 84 0e c0 00
	00 00 05	 add	 DWORD PTR [esi+ecx+192], 5
  00170	8d 84 0e c0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+192]
  00177	eb 0f		 jmp	 SHORT $LN7@LevelUp
$LN8@LevelUp:

; 1989 : 		{
; 1990 : 			gObj[iIndex].LevelUpPoint += 7;

  00179	83 84 0e c0 00
	00 00 07	 add	 DWORD PTR [esi+ecx+192], 7
  00181	8d 84 0e c0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+192]
$LN7@LevelUp:

; 1995 : 		}
; 1996 : 
; 1997 : 		if ( gObj[iIndex].PlusStatQuestClear != false )

  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018e	80 bc 0e a5 00
	00 00 00	 cmp	 BYTE PTR [esi+ecx+165], 0
  00196	74 39		 je	 SHORT $LN6@LevelUp

; 1998 : 		{
; 1999 : 			gObj[iIndex].LevelUpPoint++;

  00198	ff 84 0e c0 00
	00 00		 inc	 DWORD PTR [esi+ecx+192]
  0019f	8d 84 0e c0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+192]

; 2000 : 
; 2001 : 			LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 2002 : 				gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].LevelUpPoint);

  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ab	8b 8c 06 c0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+192]
  001b2	51		 push	 ecx
  001b3	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  001b7	52		 push	 edx
  001b8	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  001bc	50		 push	 eax
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ce	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@LevelUp:

; 2003 : 		}
; 2004 : 
; 2005 : 		gObj[iIndex].MaxLife += DCInfo.DefClass[gObj[iIndex].Class].LevelLife;

  001d1	8d 84 0e 00 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+256]
  001d8	0f b7 8c 0e b8
	00 00 00	 movzx	 ecx, WORD PTR [esi+ecx+184]
  001e0	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  001e6	d9 81 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+16]
  001ec	d8 00		 fadd	 DWORD PTR [eax]
  001ee	d9 18		 fstp	 DWORD PTR [eax]

; 2006 : 		gObj[iIndex].MaxMana += DCInfo.DefClass[gObj[iIndex].Class].LevelMana;

  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f6	0f b7 94 0e b8
	00 00 00	 movzx	 edx, WORD PTR [esi+ecx+184]
  001fe	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  00204	8d 84 0e 14 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+276]
  0020b	d9 82 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+28]
  00211	d8 00		 fadd	 DWORD PTR [eax]
  00213	d9 18		 fstp	 DWORD PTR [eax]

; 2007 : 		gObj[iIndex].Life = gObj[iIndex].MaxLife;

  00215	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021a	d9 84 06 00 01
	00 00		 fld	 DWORD PTR [esi+eax+256]
  00221	d9 9c 06 fc 00
	00 00		 fstp	 DWORD PTR [esi+eax+252]

; 2008 : 		gObj[iIndex].Mana = gObj[iIndex].MaxMana;

  00228	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022d	d9 84 06 14 01
	00 00		 fld	 DWORD PTR [esi+eax+276]
  00234	d9 9c 06 10 01
	00 00		 fstp	 DWORD PTR [esi+eax+272]

; 2009 : 		gObjNextExpCal(&gObj[iIndex]);

  0023b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00240	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00243	51		 push	 ecx
  00244	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal

; 2010 : 		gObjSetBP(gObj[iIndex].m_Index);

  00249	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024f	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 2011 : 
; 2012 : 		GCLevelUpMsgSend(gObj[iIndex].m_Index, 1);

  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025e	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  00261	6a 01		 push	 1
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend

; 2013 : 
; 2014 : 		gObjCalcMaxLifePower(gObj[iIndex].m_Index);

  00269	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026e	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 2015 : 		LogAddTD(lMsg.Get(MSGGET(2, 8)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level);

  00277	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0027c	0f bf 94 06 be
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+190]
  00284	83 c4 14	 add	 esp, 20			; 00000014H
  00287	52		 push	 edx
  00288	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0028c	51		 push	 ecx
  0028d	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00291	52		 push	 edx
  00292	68 08 02 00 00	 push	 520			; 00000208H
  00297	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0029c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002a1	50		 push	 eax
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2016 : 
; 2017 : 		//----------------------------------------------------------------------------------------------
; 2018 : 
; 2019 : 		if( gObj[iIndex].Level == 400 && gObj[iIndex].PartyNumber >= 0 ) //Season 2.5 add-on (Party Level 400 Display)

  002a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ad	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  002b2	83 c4 10	 add	 esp, 16			; 00000010H
  002b5	66 39 8c 06 be
	00 00 00	 cmp	 WORD PTR [esi+eax+190], cx
  002bd	0f 85 aa 00 00
	00		 jne	 $LN5@LevelUp
  002c3	83 bc 06 2c 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1068], 0
  002cb	0f 8c 9c 00 00
	00		 jl	 $LN5@LevelUp

; 2020 : 		{
; 2021 : 			int iPartyNumber = gObj[iIndex].PartyNumber;

  002d1	8b bc 06 2c 04
	00 00		 mov	 edi, DWORD PTR [esi+eax+1068]

; 2022 : 			char szMsg[256];
; 2023 : 			sprintf(szMsg,"400 LevelUp (%s)(%s) Party ",gObj[iIndex].AccountID,gObj[iIndex].Name);

  002d8	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  002dc	52		 push	 edx
  002dd	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  002e1	50		 push	 eax
  002e2	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$219317[ebp]
  002e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 _sprintf
  002f3	6b ff 68	 imul	 edi, 104		; 00000068H
  002f6	83 c4 10	 add	 esp, 16			; 00000010H
  002f9	81 c7 0c 00 00
	00		 add	 edi, OFFSET ?gParty@@3VPartyClass@@A+12
  002ff	c7 85 f8 fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv311[ebp], 10 ; 0000000aH
  00309	8d a4 24 00 00
	00 00		 npad	 7
$LL4@LevelUp:

; 2027 : 			{
; 2028 : 				iPartyNumIndex = gParty.m_PartyS[iPartyNumber].Number[i];

  00310	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2029 : 
; 2030 : 				if( iPartyNumIndex >= 0  )

  00312	85 c9		 test	 ecx, ecx
  00314	78 3c		 js	 SHORT $LN3@LevelUp

; 2031 : 				{
; 2032 : 					int iSize = strlen(szMsg);

  00316	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$219317[ebp]
  0031c	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0031f	90		 npad	 1
$LL22@LevelUp:
  00320	8a 10		 mov	 dl, BYTE PTR [eax]
  00322	40		 inc	 eax
  00323	84 d2		 test	 dl, dl
  00325	75 f9		 jne	 SHORT $LL22@LevelUp

; 2033 : 					sprintf(&szMsg[iSize],",(%s)(%s) ",gObj[iPartyNumIndex].AccountID,gObj[iPartyNumIndex].Name);

  00327	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0032d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00333	2b c6		 sub	 eax, esi
  00335	8d 51 77	 lea	 edx, DWORD PTR [ecx+119]
  00338	52		 push	 edx
  00339	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0033c	51		 push	 ecx
  0033d	8d 84 05 fc fe
	ff ff		 lea	 eax, DWORD PTR _szMsg$219317[ebp+eax]
  00344	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 _sprintf
  0034f	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@LevelUp:

; 2024 : 			int iPartyNumIndex;
; 2025 : 
; 2026 : 			for( int i = 0; i<MAX_USER_IN_PARTY; i++ )

  00352	83 c7 04	 add	 edi, 4
  00355	ff 8d f8 fe ff
	ff		 dec	 DWORD PTR tv311[ebp]
  0035b	75 b3		 jne	 SHORT $LL4@LevelUp

; 2034 : 				}
; 2035 : 			}
; 2036 : 			LogAddTD(szMsg);

  0035d	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$219317[ebp]
  00363	51		 push	 ecx
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0036a	83 c4 04	 add	 esp, 4
$LN5@LevelUp:

; 2037 : 		}
; 2038 : 	}
; 2039 : #ifndef FIX_DS_CRASH
; 2040 : 	GJSetCharacterInfo(&gObj[iIndex], gObj[iIndex].m_Index, 0);
; 2041 : #endif	
; 2042 : #if(SYSTEM_ACHIEVEMENTS)
; 2043 : 	g_Achievements.LevelUp(iIndex);

  0036d	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  00373	52		 push	 edx
  00374	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00379	e8 00 00 00 00	 call	 ?LevelUp@CAchievements@@QAEXH@Z ; CAchievements::LevelUp

; 2044 : #endif
; 2045 : 	return iLEFT_EXP;
; 2046 : }

  0037e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00381	5e		 pop	 esi
  00382	8b c3		 mov	 eax, ebx
  00384	5b		 pop	 ebx
  00385	33 cd		 xor	 ecx, ebp
  00387	5f		 pop	 edi
  00388	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038d	8b e5		 mov	 esp, ebp
  0038f	5d		 pop	 ebp
  00390	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CBloodCastle@@QAEHHHH@Z ENDP			; CBloodCastle::LevelUp
_TEXT	ENDS
PUBLIC	?AddExperience@CBloodCastle@@QAE_NHH@Z		; CBloodCastle::AddExperience
; Function compile flags: /Ogtp
;	COMDAT ?AddExperience@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?AddExperience@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::AddExperience, COMDAT
; _this$ = ecx

; 2081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2082 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00004	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	85 c0		 test	 eax, eax
  0000c	78 0e		 js	 SHORT $LN13@AddExperie
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx
  0001a	75 08		 jne	 SHORT $LN4@AddExperie
$LN13@AddExperie:

; 2083 : 	{
; 2084 : 		return false;

  0001c	32 c0		 xor	 al, al

; 2104 : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN4@AddExperie:

; 2085 : 	}
; 2086 : 
; 2087 : 	if ( BC_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleIndex) == FALSE )

  00024	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	8a 94 30 9e 0e
	00 00		 mov	 dl, BYTE PTR [eax+esi+3742]
  00039	8d 9c 30 9e 0e
	00 00		 lea	 ebx, DWORD PTR [eax+esi+3742]
  00040	84 d2		 test	 dl, dl
  00042	78 0c		 js	 SHORT $LN14@AddExperie
  00044	33 c9		 xor	 ecx, ecx
  00046	80 fa 07	 cmp	 dl, 7
  00049	0f 9e c1	 setle	 cl
  0004c	85 c9		 test	 ecx, ecx
  0004e	75 0a		 jne	 SHORT $LN3@AddExperie
$LN14@AddExperie:
  00050	5e		 pop	 esi

; 2088 : 	{
; 2089 : 		return false;

  00051	32 c0		 xor	 al, al
  00053	5b		 pop	 ebx

; 2104 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
$LN3@AddExperie:

; 2090 : 	}
; 2091 : 
; 2092 : 	if ( BC_SUB_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleSubIndex) == FALSE )

  0005a	8a 8c 30 9f 0e
	00 00		 mov	 cl, BYTE PTR [eax+esi+3743]
  00061	57		 push	 edi
  00062	8d bc 30 9f 0e
	00 00		 lea	 edi, DWORD PTR [eax+esi+3743]
  00069	84 c9		 test	 cl, cl
  0006b	78 0e		 js	 SHORT $LN15@AddExperie
  0006d	33 d2		 xor	 edx, edx
  0006f	80 f9 27	 cmp	 cl, 39			; 00000027H
  00072	0f 9e c2	 setle	 dl
  00075	8b ca		 mov	 ecx, edx
  00077	85 c9		 test	 ecx, ecx
  00079	75 0b		 jne	 SHORT $LN2@AddExperie
$LN15@AddExperie:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 2093 : 	{
; 2094 : 		return false;

  0007d	32 c0		 xor	 al, al
  0007f	5b		 pop	 ebx

; 2104 : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
$LN2@AddExperie:

; 2095 : 	}
; 2096 : 
; 2097 : 	if ( iEXP > 0 )

  00086	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
  00089	85 f6		 test	 esi, esi
  0008b	7e 2d		 jle	 SHORT $LN1@AddExperie

; 2098 : 	{
; 2099 : 		this->m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_UserData[gObj[iIndex].m_cBloodCastleSubIndex].m_iEXP += iEXP;

  0008d	0f be 13	 movsx	 edx, BYTE PTR [ebx]
  00090	8d 0c d5 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*8]
  00097	2b ca		 sub	 ecx, edx
  00099	0f be 17	 movsx	 edx, BYTE PTR [edi]
  0009c	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  0009f	8d 0c 92	 lea	 ecx, DWORD PTR [edx+edx*4]
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	01 74 8a 20	 add	 DWORD PTR [edx+ecx*4+32], esi
  000a9	8d 4c 8a 20	 lea	 ecx, DWORD PTR [edx+ecx*4+32]

; 2100 : 		gObj[iIndex].m_iBloodCastleEXP += iEXP;

  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b3	01 b4 08 a0 0e
	00 00		 add	 DWORD PTR [eax+ecx+3744], esi
$LN1@AddExperie:

; 2101 : 	}
; 2102 : 
; 2103 : 	return true;

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	b0 01		 mov	 al, 1
  000be	5b		 pop	 ebx

; 2104 : }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
?AddExperience@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::AddExperience
_TEXT	ENDS
PUBLIC	?BlockSector@CBloodCastle@@IAEXHHHHH@Z		; CBloodCastle::BlockSector
; Function compile flags: /Ogtp
;	COMDAT ?BlockSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?BlockSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::BlockSector, COMDAT
; _this$ = ecx

; 2231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2232 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 f8 34	 cmp	 eax, 52			; 00000034H
  00009	74 11		 je	 SHORT $LN18@BlockSecto
  0000b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0000e	7c 5c		 jl	 SHORT $LN4@BlockSecto
  00010	33 c9		 xor	 ecx, ecx
  00012	83 f8 11	 cmp	 eax, 17			; 00000011H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx
  0001a	74 50		 je	 SHORT $LN4@BlockSecto
$LN18@BlockSecto:
  0001c	57		 push	 edi

; 2233 : 	{
; 2234 : 		return;
; 2235 : 	}
; 2236 : 
; 2237 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _iSTART_X$[ebp]
  00020	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  00023	7f 46		 jg	 SHORT $LN19@BlockSecto
  00025	53		 push	 ebx
  00026	8b 5d 10	 mov	 ebx, DWORD PTR _iSTART_Y$[ebp]
  00029	56		 push	 esi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL6@BlockSecto:

; 2238 : 	{
; 2239 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00030	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  00033	3b da		 cmp	 ebx, edx
  00035	7f 2c		 jg	 SHORT $LN5@BlockSecto
  00037	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0003d	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00043	8b c3		 mov	 eax, ebx
  00045	2b d3		 sub	 edx, ebx
  00047	c1 e0 08	 shl	 eax, 8
  0004a	42		 inc	 edx
  0004b	eb 03 8d 49 00	 npad	 5
$LL3@BlockSecto:

; 2240 : 		{
; 2241 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] |= 4;

  00050	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00052	03 c8		 add	 ecx, eax
  00054	80 0c 39 04	 or	 BYTE PTR [ecx+edi], 4
  00058	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0005d	4a		 dec	 edx
  0005e	75 f0		 jne	 SHORT $LL3@BlockSecto

; 2238 : 	{
; 2239 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00060	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
$LN5@BlockSecto:

; 2233 : 	{
; 2234 : 		return;
; 2235 : 	}
; 2236 : 
; 2237 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00063	47		 inc	 edi
  00064	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  00067	7e c7		 jle	 SHORT $LL6@BlockSecto
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
$LN19@BlockSecto:
  0006b	5f		 pop	 edi
$LN4@BlockSecto:

; 2242 : 		}
; 2243 : 	}
; 2244 : }

  0006c	5d		 pop	 ebp
  0006d	c2 14 00	 ret	 20			; 00000014H
?BlockSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::BlockSector
_TEXT	ENDS
PUBLIC	?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z	; CBloodCastle::ReleaseSector
; Function compile flags: /Ogtp
;	COMDAT ?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::ReleaseSector, COMDAT
; _this$ = ecx

; 2247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2248 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 f8 34	 cmp	 eax, 52			; 00000034H
  00009	74 11		 je	 SHORT $LN18@ReleaseSec
  0000b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0000e	7c 5c		 jl	 SHORT $LN4@ReleaseSec
  00010	33 c9		 xor	 ecx, ecx
  00012	83 f8 11	 cmp	 eax, 17			; 00000011H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx
  0001a	74 50		 je	 SHORT $LN4@ReleaseSec
$LN18@ReleaseSec:
  0001c	57		 push	 edi

; 2249 : 	{
; 2250 : 		return;
; 2251 : 	}
; 2252 : 
; 2253 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _iSTART_X$[ebp]
  00020	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  00023	7f 46		 jg	 SHORT $LN19@ReleaseSec
  00025	53		 push	 ebx
  00026	8b 5d 10	 mov	 ebx, DWORD PTR _iSTART_Y$[ebp]
  00029	56		 push	 esi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL6@ReleaseSec:

; 2254 : 	{
; 2255 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00030	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  00033	3b da		 cmp	 ebx, edx
  00035	7f 2c		 jg	 SHORT $LN5@ReleaseSec
  00037	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0003d	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00043	8b c3		 mov	 eax, ebx
  00045	2b d3		 sub	 edx, ebx
  00047	c1 e0 08	 shl	 eax, 8
  0004a	42		 inc	 edx
  0004b	eb 03 8d 49 00	 npad	 5
$LL3@ReleaseSec:

; 2256 : 		{
; 2257 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] &= ~4;

  00050	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00052	03 c8		 add	 ecx, eax
  00054	80 24 39 fb	 and	 BYTE PTR [ecx+edi], 251	; 000000fbH
  00058	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0005d	4a		 dec	 edx
  0005e	75 f0		 jne	 SHORT $LL3@ReleaseSec

; 2254 : 	{
; 2255 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00060	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]
$LN5@ReleaseSec:

; 2249 : 	{
; 2250 : 		return;
; 2251 : 	}
; 2252 : 
; 2253 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00063	47		 inc	 edi
  00064	3b 7d 14	 cmp	 edi, DWORD PTR _iEND_X$[ebp]
  00067	7e c7		 jle	 SHORT $LL6@ReleaseSec
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
$LN19@ReleaseSec:
  0006b	5f		 pop	 edi
$LN4@ReleaseSec:

; 2258 : 		}
; 2259 : 	}
; 2260 : }

  0006c	5d		 pop	 ebp
  0006d	c2 14 00	 ret	 20			; 00000014H
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::ReleaseSector
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z	; CBloodCastle::SendNoticeMessage
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z PROC	; CBloodCastle::SendNoticeMessage, COMDAT
; _this$ = ecx

; 2387 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx

; 2388 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001d	85 f6		 test	 esi, esi
  0001f	78 7c		 js	 SHORT $LN5@SendNotice
  00021	33 c9		 xor	 ecx, ecx
  00023	83 fe 07	 cmp	 esi, 7
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	74 70		 je	 SHORT $LN5@SendNotice

; 2389 : 	{
; 2390 : 		return;
; 2391 : 	}
; 2392 : 
; 2393 : 	PMSG_NOTICE pNotice;
; 2394 : 
; 2395 : 	TNotice::MakeNoticeMsg( &pNotice, 0, lpszMSG);

  0002d	53		 push	 ebx
  0002e	50		 push	 eax
  0002f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00035	6a 00		 push	 0
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0003d	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	8d 74 3e 1c	 lea	 esi, DWORD PTR [esi+edi+28]
  0004a	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  0004f	83 cb ff	 or	 ebx, -1
$LL7@SendNotice:

; 2398 : 	{
; 2399 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00052	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00054	3b cb		 cmp	 ecx, ebx
  00056	74 3e		 je	 SHORT $LN6@SendNotice

; 2400 : 		{
; 2401 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	8b d1		 mov	 edx, ecx
  0005f	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00065	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  0006a	7e 2a		 jle	 SHORT $LN6@SendNotice

; 2402 : 			{
; 2403 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  0006c	38 9c 10 9e 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3742], bl
  00073	74 21		 je	 SHORT $LN6@SendNotice

; 2404 : 				{
; 2405 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  00075	38 9c 10 9f 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3743], bl
  0007c	74 18		 je	 SHORT $LN6@SendNotice

; 2406 : 					{
; 2407 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  0007e	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  00085	52		 push	 edx
  00086	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0008c	50		 push	 eax
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendNotice:

; 2396 : 
; 2397 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00096	83 c6 14	 add	 esi, 20			; 00000014H
  00099	4f		 dec	 edi
  0009a	75 b6		 jne	 SHORT $LL7@SendNotice
  0009c	5b		 pop	 ebx
$LN5@SendNotice:

; 2408 : 					}
; 2409 : 				}
; 2410 : 			}
; 2411 : 		}
; 2412 : 	}
; 2413 : }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	5f		 pop	 edi
  000a1	33 cd		 xor	 ecx, ebp
  000a3	5e		 pop	 esi
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ENDP	; CBloodCastle::SendNoticeMessage
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeScore@CBloodCastle@@QAEXH@Z		; CBloodCastle::SendNoticeScore
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeScore@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SendNoticeScore, COMDAT
; _this$ = ecx

; 2416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]

; 2417 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 ff		 test	 edi, edi
  00019	0f 88 a7 00 00
	00		 js	 $LN5@SendNotice@2
  0001f	33 c0		 xor	 eax, eax
  00021	83 ff 07	 cmp	 edi, 7
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 97 00 00
	00		 je	 $LN5@SendNotice@2

; 2418 : 	{
; 2419 : 		return;
; 2420 : 	}
; 2421 : 
; 2422 : 	PMSG_NOTICE pNotice;
; 2423 : 	pNotice.type = 0;

  0002f	8b c7		 mov	 eax, edi
  00031	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00037	53		 push	 ebx
  00038	56		 push	 esi
  00039	c6 85 ef fe ff
	ff 00		 mov	 BYTE PTR _pNotice$[ebp+3], 0
  00040	8d 74 08 1c	 lea	 esi, DWORD PTR [eax+ecx+28]
  00044	bb 28 00 00 00	 mov	 ebx, 40			; 00000028H
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL7@SendNotice@2:

; 2426 : 	{
; 2427 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	74 67		 je	 SHORT $LN6@SendNotice@2

; 2428 : 		{
; 2429 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00063	83 7c 08 04 02	 cmp	 DWORD PTR [eax+ecx+4], 2
  00068	7e 54		 jle	 SHORT $LN6@SendNotice@2

; 2430 : 			{
; 2431 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  0006a	80 bc 08 9e 0e
	00 00 ff	 cmp	 BYTE PTR [eax+ecx+3742], -1
  00072	74 4a		 je	 SHORT $LN6@SendNotice@2

; 2432 : 				{
; 2433 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  00074	80 bc 08 9f 0e
	00 00 ff	 cmp	 BYTE PTR [eax+ecx+3743], -1
  0007c	74 40		 je	 SHORT $LN6@SendNotice@2

; 2434 : 					{
; 2435 : 						TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4, 140)), iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP);

  0007e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00081	52		 push	 edx
  00082	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00085	50		 push	 eax
  00086	68 8c 04 00 00	 push	 1164			; 0000048cH
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00090	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00095	50		 push	 eax
  00096	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0009c	6a 00		 push	 0
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 2436 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  000a4	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  000ab	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ad	52		 push	 edx
  000ae	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  000b4	50		 push	 eax
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000bb	83 c4 20	 add	 esp, 32			; 00000020H
$LN6@SendNotice@2:

; 2424 : 
; 2425 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000be	83 c6 14	 add	 esi, 20			; 00000014H
  000c1	4b		 dec	 ebx
  000c2	75 8c		 jne	 SHORT $LL7@SendNotice@2
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
$LN5@SendNotice@2:

; 2437 : 					}
; 2438 : 				}
; 2439 : 			}
; 2440 : 		}
; 2441 : 	}
; 2442 : }

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c9	33 cd		 xor	 ecx, ebp
  000cb	5f		 pop	 edi
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SendNoticeScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SendNoticeState
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SendNoticeState, COMDAT
; _this$ = ecx

; 2445 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx

; 2446 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 dd 00 00
	00		 js	 $LN5@SendNotice@3
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 07	 cmp	 esi, 7
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 cd 00 00
	00		 je	 $LN5@SendNotice@3

; 2447 : 	{
; 2448 : 		return;
; 2449 : 	}
; 2450 : 
; 2451 : 	PMSG_STATEBLOODCASTLE pMsg;
; 2452 : 
; 2453 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0002f	53		 push	 ebx
  00030	6a 0e		 push	 14			; 0000000eH
  00032	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00035	68 9b 00 00 00	 push	 155			; 0000009bH
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2454 : 	pMsg.btPlayState = iPlayState;
; 2455 : 	pMsg.wRemainSec = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00040	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00046	8b 5d 0c	 mov	 ebx, DWORD PTR _iPlayState$[ebp]
  00049	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  0004c	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00051	f7 a9 ac 03 00
	00		 imul	 DWORD PTR [ecx+940]
  00057	c1 fa 06	 sar	 edx, 6
  0005a	8b c2		 mov	 eax, edx
  0005c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005f	03 c2		 add	 eax, edx
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	88 5d ef	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  00067	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2456 : 
; 2457 : 	if ( iPlayState == 4 )

  0006b	83 fb 04	 cmp	 ebx, 4
  0006e	75 10		 jne	 SHORT $LN9@SendNotice@3

; 2458 : 	{
; 2459 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT;

  00070	66 8b 91 dc 03
	00 00		 mov	 dx, WORD PTR [ecx+988]

; 2460 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT;

  00077	66 8b 81 e0 03
	00 00		 mov	 ax, WORD PTR [ecx+992]

; 2461 : 	}
; 2462 : 	else

  0007e	eb 0e		 jmp	 SHORT $LN17@SendNotice@3
$LN9@SendNotice@3:

; 2463 : 	{
; 2464 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT;

  00080	66 8b 91 cc 03
	00 00		 mov	 dx, WORD PTR [ecx+972]

; 2465 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT;

  00087	66 8b 81 d0 03
	00 00		 mov	 ax, WORD PTR [ecx+976]
$LN17@SendNotice@3:
  0008e	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 2466 : 	}
; 2467 : 
; 2468 : 	pMsg.wUserHaveWeapon = this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX;
; 2469 : 	pMsg.btWeaponNum = this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;

  00092	8a 81 f0 03 00
	00		 mov	 al, BYTE PTR [ecx+1008]
  00098	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+6], dx
  0009c	66 8b 91 ec 03
	00 00		 mov	 dx, WORD PTR [ecx+1004]
  000a3	fe c0		 inc	 al
  000a5	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+10], dx
  000a9	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  000ac	8d 71 1c	 lea	 esi, DWORD PTR [ecx+28]
  000af	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  000b4	83 cb ff	 or	 ebx, -1
$LL7@SendNotice@3:

; 2472 : 	{
; 2473 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000b7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b9	3b cb		 cmp	 ecx, ebx
  000bb	74 38		 je	 SHORT $LN6@SendNotice@3

; 2474 : 		{
; 2475 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c2	8b d1		 mov	 edx, ecx
  000c4	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000ca	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  000cf	7e 24		 jle	 SHORT $LN6@SendNotice@3

; 2476 : 			{
; 2477 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  000d1	38 9c 10 9e 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3742], bl
  000d8	74 1b		 je	 SHORT $LN6@SendNotice@3

; 2478 : 				{
; 2479 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  000da	38 9c 10 9f 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3743], bl
  000e1	74 12		 je	 SHORT $LN6@SendNotice@3

; 2480 : 					{
; 2481 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e3	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000e7	52		 push	 edx
  000e8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000eb	50		 push	 eax
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendNotice@3:

; 2470 : 
; 2471 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000f5	83 c6 14	 add	 esi, 20			; 00000014H
  000f8	4f		 dec	 edi
  000f9	75 bc		 jne	 SHORT $LL7@SendNotice@3
  000fb	5b		 pop	 ebx
$LN5@SendNotice@3:

; 2482 : 					}
; 2483 : 				}
; 2484 : 			}
; 2485 : 		}
; 2486 : 	}
; 2487 : }

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	5f		 pop	 edi
  00100	33 cd		 xor	 ecx, ebp
  00102	5e		 pop	 esi
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 08 00	 ret	 8
?SendNoticeState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SendNoticeState
_TEXT	ENDS
PUBLIC	?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserBridgeMember
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserBridgeMember, COMDAT
; _this$ = ecx

; 2490 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2491 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN16@CheckUserB
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 06		 jne	 SHORT $LN6@CheckUserB
$LN16@CheckUserB:

; 2492 : 	{
; 2493 : 		return false;

  00016	32 c0		 xor	 al, al

; 2510 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN6@CheckUserB:
  0001c	56		 push	 esi

; 2494 : 	}
; 2495 : 
; 2496 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001d	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00020	85 f6		 test	 esi, esi
  00022	78 29		 js	 SHORT $LN2@CheckUserB
  00024	33 c0		 xor	 eax, eax
  00026	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0002c	0f 9e c0	 setle	 al
  0002f	85 c0		 test	 eax, eax

; 2497 : 	{
; 2498 : 		return false;

  00031	74 1a		 je	 SHORT $LN2@CheckUserB

; 2499 : 	}
; 2500 : 
; 2501 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00033	33 c0		 xor	 eax, eax
  00035	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0003b	8d 4c 0a 1c	 lea	 ecx, DWORD PTR [edx+ecx+28]
  0003f	90		 npad	 1
$LL4@CheckUserB:

; 2502 : 	{
; 2503 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iIndex )

  00040	39 31		 cmp	 DWORD PTR [ecx], esi
  00042	74 10		 je	 SHORT $LN14@CheckUserB

; 2499 : 	}
; 2500 : 
; 2501 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00044	40		 inc	 eax
  00045	83 c1 14	 add	 ecx, 20			; 00000014H
  00048	83 f8 28	 cmp	 eax, 40			; 00000028H
  0004b	7c f3		 jl	 SHORT $LL4@CheckUserB
$LN2@CheckUserB:

; 2506 : 		}
; 2507 : 	}
; 2508 : 
; 2509 : 	return false;

  0004d	32 c0		 xor	 al, al
  0004f	5e		 pop	 esi

; 2510 : }

  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
$LN14@CheckUserB:

; 2504 : 		{
; 2505 : 			return true;

  00054	b0 01		 mov	 al, 1
  00056	5e		 pop	 esi

; 2510 : }

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserBridgeMember
_TEXT	ENDS
PUBLIC	?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z	; CBloodCastle::GetAliveUserTotalEXP
; Function compile flags: /Ogtp
;	COMDAT ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z
_TEXT	SEGMENT
tv1588 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z PROC	; CBloodCastle::GetAliveUserTotalEXP, COMDAT
; _this$ = ecx

; 2513 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2514 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN39@GetAliveUs
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 06		 jne	 SHORT $LN7@GetAliveUs
$LN39@GetAliveUs:

; 2515 : 	{
; 2516 : 		return 0;

  00016	33 c0		 xor	 eax, eax

; 2536 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN7@GetAliveUs:
  0001c	53		 push	 ebx
  0001d	56		 push	 esi

; 2517 : 	}
; 2518 : 
; 2519 : 	int iRET_EXP = 0;

  0001e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00024	57		 push	 edi
  00025	33 ff		 xor	 edi, edi
  00027	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0002d	8d 54 0a 1c	 lea	 edx, DWORD PTR [edx+ecx+28]
  00031	c7 45 08 08 00
	00 00		 mov	 DWORD PTR tv1588[ebp], 8
  00038	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  0003b	eb 03 8d 49 00	 npad	 5
$LL50@GetAliveUs:

; 2522 : 	{
; 2523 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	83 f9 ff	 cmp	 ecx, -1
  00045	74 2a		 je	 SHORT $LN5@GetAliveUs

; 2524 : 		{
; 2525 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00047	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0004d	39 44 31 04	 cmp	 DWORD PTR [ecx+esi+4], eax
  00051	7e 1e		 jle	 SHORT $LN5@GetAliveUs

; 2526 : 			{
; 2527 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00053	0f b6 8c 31 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+esi+329]
  0005b	80 f9 34	 cmp	 cl, 52			; 00000034H
  0005e	74 0e		 je	 SHORT $LN40@GetAliveUs
  00060	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00063	72 0c		 jb	 SHORT $LN5@GetAliveUs
  00065	b3 11		 mov	 bl, 17			; 00000011H
  00067	3a d9		 cmp	 bl, cl
  00069	1b c9		 sbb	 ecx, ecx
  0006b	41		 inc	 ecx
  0006c	74 03		 je	 SHORT $LN5@GetAliveUs
$LN40@GetAliveUs:

; 2528 : 				{
; 2529 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  0006e	03 7a 04	 add	 edi, DWORD PTR [edx+4]
$LN5@GetAliveUs:

; 2522 : 	{
; 2523 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00071	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00074	83 f9 ff	 cmp	 ecx, -1
  00077	74 2a		 je	 SHORT $LN46@GetAliveUs

; 2524 : 		{
; 2525 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00079	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0007f	39 44 31 04	 cmp	 DWORD PTR [ecx+esi+4], eax
  00083	7e 1e		 jle	 SHORT $LN46@GetAliveUs

; 2526 : 			{
; 2527 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00085	0f b6 8c 31 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+esi+329]
  0008d	80 f9 34	 cmp	 cl, 52			; 00000034H
  00090	74 0e		 je	 SHORT $LN41@GetAliveUs
  00092	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00095	72 0c		 jb	 SHORT $LN46@GetAliveUs
  00097	b3 11		 mov	 bl, 17			; 00000011H
  00099	3a d9		 cmp	 bl, cl
  0009b	1b c9		 sbb	 ecx, ecx
  0009d	41		 inc	 ecx
  0009e	74 03		 je	 SHORT $LN46@GetAliveUs
$LN41@GetAliveUs:

; 2528 : 				{
; 2529 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  000a0	03 7a 18	 add	 edi, DWORD PTR [edx+24]
$LN46@GetAliveUs:

; 2522 : 	{
; 2523 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000a3	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  000a6	83 f9 ff	 cmp	 ecx, -1
  000a9	74 2a		 je	 SHORT $LN47@GetAliveUs

; 2524 : 		{
; 2525 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000ab	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000b1	39 44 31 04	 cmp	 DWORD PTR [ecx+esi+4], eax
  000b5	7e 1e		 jle	 SHORT $LN47@GetAliveUs

; 2526 : 			{
; 2527 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000b7	0f b6 8c 31 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+esi+329]
  000bf	80 f9 34	 cmp	 cl, 52			; 00000034H
  000c2	74 0e		 je	 SHORT $LN42@GetAliveUs
  000c4	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000c7	72 0c		 jb	 SHORT $LN47@GetAliveUs
  000c9	b3 11		 mov	 bl, 17			; 00000011H
  000cb	3a d9		 cmp	 bl, cl
  000cd	1b c9		 sbb	 ecx, ecx
  000cf	41		 inc	 ecx
  000d0	74 03		 je	 SHORT $LN47@GetAliveUs
$LN42@GetAliveUs:

; 2528 : 				{
; 2529 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  000d2	03 7a 2c	 add	 edi, DWORD PTR [edx+44]
$LN47@GetAliveUs:

; 2522 : 	{
; 2523 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000d5	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  000d8	83 f9 ff	 cmp	 ecx, -1
  000db	74 2a		 je	 SHORT $LN48@GetAliveUs

; 2524 : 		{
; 2525 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000dd	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000e3	39 44 31 04	 cmp	 DWORD PTR [ecx+esi+4], eax
  000e7	7e 1e		 jle	 SHORT $LN48@GetAliveUs

; 2526 : 			{
; 2527 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000e9	0f b6 8c 31 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+esi+329]
  000f1	80 f9 34	 cmp	 cl, 52			; 00000034H
  000f4	74 0e		 je	 SHORT $LN43@GetAliveUs
  000f6	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000f9	72 0c		 jb	 SHORT $LN48@GetAliveUs
  000fb	b3 11		 mov	 bl, 17			; 00000011H
  000fd	3a d9		 cmp	 bl, cl
  000ff	1b c9		 sbb	 ecx, ecx
  00101	41		 inc	 ecx
  00102	74 03		 je	 SHORT $LN48@GetAliveUs
$LN43@GetAliveUs:

; 2528 : 				{
; 2529 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  00104	03 7a 40	 add	 edi, DWORD PTR [edx+64]
$LN48@GetAliveUs:

; 2522 : 	{
; 2523 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00107	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  0010a	83 f9 ff	 cmp	 ecx, -1
  0010d	74 2a		 je	 SHORT $LN49@GetAliveUs

; 2524 : 		{
; 2525 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0010f	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00115	39 44 31 04	 cmp	 DWORD PTR [ecx+esi+4], eax
  00119	7e 1e		 jle	 SHORT $LN49@GetAliveUs

; 2526 : 			{
; 2527 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  0011b	0f b6 8c 31 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+esi+329]
  00123	80 f9 34	 cmp	 cl, 52			; 00000034H
  00126	74 0e		 je	 SHORT $LN44@GetAliveUs
  00128	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0012b	72 0c		 jb	 SHORT $LN49@GetAliveUs
  0012d	b3 11		 mov	 bl, 17			; 00000011H
  0012f	3a d9		 cmp	 bl, cl
  00131	1b c9		 sbb	 ecx, ecx
  00133	41		 inc	 ecx
  00134	74 03		 je	 SHORT $LN49@GetAliveUs
$LN44@GetAliveUs:

; 2528 : 				{
; 2529 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  00136	03 7a 54	 add	 edi, DWORD PTR [edx+84]
$LN49@GetAliveUs:

; 2517 : 	}
; 2518 : 
; 2519 : 	int iRET_EXP = 0;

  00139	83 c2 64	 add	 edx, 100		; 00000064H

; 2520 : 
; 2521 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0013c	ff 4d 08	 dec	 DWORD PTR tv1588[ebp]
  0013f	0f 85 fb fe ff
	ff		 jne	 $LL50@GetAliveUs

; 2530 : 				}
; 2531 : 			}
; 2532 : 		}
; 2533 : 	}
; 2534 : 
; 2535 : 	return iRET_EXP;

  00145	8b c7		 mov	 eax, edi
  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx

; 2536 : }

  0014a	5d		 pop	 ebp
  0014b	c2 04 00	 ret	 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ENDP	; CBloodCastle::GetAliveUserTotalEXP
_TEXT	ENDS
PUBLIC	??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
;	COMDAT ??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Delete Angel Kin'
	DB	'g''s Weapon (%d) [Serial:%u]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iLEVEL$219631 = -4					; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDeleteQuestItem, COMDAT
; _this$ = ecx

; 2539 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2540 : 	if ( gObjIsConnected(iIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	0f 84 cc 00 00
	00		 je	 $LN4@SearchUser

; 2541 : 	{
; 2542 : 		return;
; 2543 : 	}
; 2544 : 
; 2545 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  00019	53		 push	 ebx
  0001a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00020	57		 push	 edi
  00021	33 ff		 xor	 edi, edi
  00023	33 db		 xor	 ebx, ebx
  00025	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@SearchUser:

; 2546 : 	{
; 2547 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  0003c	03 cb		 add	 ecx, ebx
  0003e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00043	83 f8 01	 cmp	 eax, 1
  00046	0f 85 84 00 00
	00		 jne	 $LN5@SearchUser

; 2548 : 		{
; 2549 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	8b 84 0e 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+ecx+3620]
  00059	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  0005e	66 39 4c 18 06	 cmp	 WORD PTR [eax+ebx+6], cx
  00063	75 6b		 jne	 SHORT $LN5@SearchUser

; 2550 : 			{
; 2551 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  00065	0f bf 44 18 08	 movsx	 eax, WORD PTR [eax+ebx+8]
  0006a	89 45 fc	 mov	 DWORD PTR _iLEVEL$219631[ebp], eax

; 2552 : 
; 2553 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  0006d	85 c0		 test	 eax, eax
  0006f	78 5f		 js	 SHORT $LN5@SearchUser
  00071	33 d2		 xor	 edx, edx
  00073	83 f8 02	 cmp	 eax, 2
  00076	0f 9e c2	 setle	 dl
  00079	8b c2		 mov	 eax, edx
  0007b	85 c0		 test	 eax, eax
  0007d	74 51		 je	 SHORT $LN5@SearchUser

; 2554 : 				{
; 2555 : 					::gObjInventoryItemSet(iIndex, x, -1);

  0007f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00082	68 ff 00 00 00	 push	 255			; 000000ffH
  00087	57		 push	 edi
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 2556 : 					::gObjInventoryDeleteItem(iIndex, x);

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00091	57		 push	 edi
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 2557 : 					::GCInventoryItemDeleteSend(iIndex, x, TRUE);

  00098	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0009b	6a 01		 push	 1
  0009d	57		 push	 edi
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 2558 : 
; 2559 : 					LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Delete Angel King's Weapon (%d) [Serial:%u]", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, gObj[iIndex].pInventory[x].m_Number);

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a9	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  000b0	8b 14 19	 mov	 edx, DWORD PTR [ecx+ebx]
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _iLEVEL$219631[ebp]
  000b6	52		 push	 edx
  000b7	51		 push	 ecx
  000b8	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000bc	52		 push	 edx
  000bd	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  000c1	50		 push	 eax
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@KGCEHODG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cd	83 c4 34	 add	 esp, 52			; 00000034H
$LN5@SearchUser:

; 2541 : 	{
; 2542 : 		return;
; 2543 : 	}
; 2544 : 
; 2545 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  000d0	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  000d6	47		 inc	 edi
  000d7	81 fb 70 c3 00
	00		 cmp	 ebx, 50032		; 0000c370H
  000dd	0f 8c 4d ff ff
	ff		 jl	 $LL6@SearchUser
  000e3	5f		 pop	 edi
  000e4	5b		 pop	 ebx
$LN4@SearchUser:
  000e5	5e		 pop	 esi

; 2560 : 				}
; 2561 : 			}
; 2562 : 		}
; 2563 : 	}
; 2564 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 04 00	 ret	 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDeleteQuestItem
_TEXT	ENDS
PUBLIC	?SetUserState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetUserState
; Function compile flags: /Ogtp
;	COMDAT ?SetUserState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv1219 = -4						; size = 4
_iBridgeSubIndex$ = 8					; size = 4
_iIndex$ = 8						; size = 4
tv1353 = 12						; size = 4
tv1330 = 12						; size = 4
tv1307 = 12						; size = 4
tv1284 = 12						; size = 4
tv1256 = 12						; size = 4
_iState$ = 12						; size = 4
?SetUserState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SetUserState, COMDAT
; _this$ = ecx

; 2624 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2625 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00004	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 c0		 test	 eax, eax
  0000c	0f 88 d3 03 00
	00		 js	 $LN15@SetUserSta
  00012	33 c9		 xor	 ecx, ecx
  00014	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00019	0f 9e c1	 setle	 cl
  0001c	85 c9		 test	 ecx, ecx
  0001e	0f 84 c1 03 00
	00		 je	 $LN15@SetUserSta

; 2626 : 	{
; 2627 : 		return;
; 2628 : 	}
; 2629 : 
; 2630 : 	int iBridgeIndex = gObj[iIndex].m_cBloodCastleIndex; //2

  00024	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002a	53		 push	 ebx
  0002b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	0f be 8c 18 9e
	0e 00 00	 movsx	 ecx, BYTE PTR [eax+ebx+3742]
  00039	57		 push	 edi

; 2631 : 	int iBridgeSubIndex = gObj[iIndex].m_cBloodCastleSubIndex; //3

  0003a	0f be bc 18 9f
	0e 00 00	 movsx	 edi, BYTE PTR [eax+ebx+3743]
  00042	89 45 fc	 mov	 DWORD PTR tv1219[ebp], eax
  00045	89 7d 08	 mov	 DWORD PTR _iBridgeSubIndex$[ebp], edi

; 2632 : 
; 2633 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00048	85 c9		 test	 ecx, ecx
  0004a	0f 88 93 03 00
	00		 js	 $LN71@SetUserSta
  00050	33 d2		 xor	 edx, edx
  00052	83 f9 07	 cmp	 ecx, 7
  00055	0f 9e c2	 setle	 dl
  00058	85 d2		 test	 edx, edx
  0005a	0f 84 83 03 00
	00		 je	 $LN71@SetUserSta

; 2634 : 	{
; 2635 : 		return;
; 2636 : 	}
; 2637 : 
; 2638 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  00060	85 ff		 test	 edi, edi
  00062	0f 88 7b 03 00
	00		 js	 $LN71@SetUserSta
  00068	33 d2		 xor	 edx, edx
  0006a	83 ff 27	 cmp	 edi, 39			; 00000027H
  0006d	0f 9e c2	 setle	 dl
  00070	85 d2		 test	 edx, edx
  00072	0f 84 6b 03 00
	00		 je	 $LN71@SetUserSta

; 2639 : 	{
; 2640 : 		return;
; 2641 : 	}
; 2642 : 
; 2643 : 	switch ( iState )

  00078	8b 55 0c	 mov	 edx, DWORD PTR _iState$[ebp]
  0007b	83 fa 04	 cmp	 edx, 4
  0007e	0f 87 5f 03 00
	00		 ja	 $LN71@SetUserSta
  00084	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN73@SetUserSta[edx*4]
$LN14@SetUserSta:

; 2644 : 	{
; 2645 : 		case 0:
; 2646 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  0008b	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00092	2b c1		 sub	 eax, ecx
  00094	8d 44 c7 02	 lea	 eax, DWORD PTR [edi+eax*8+2]
  00098	5f		 pop	 edi
  00099	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0009c	5b		 pop	 ebx
  0009d	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0
  000a4	5e		 pop	 esi

; 2692 : 			break;
; 2693 : 	}
; 2694 : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN13@SetUserSta:

; 2647 : 			break;
; 2648 : 
; 2649 : 		case 1:
; 2650 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 1;

  000ab	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  000b2	2b d1		 sub	 edx, ecx
  000b4	8d 44 d7 02	 lea	 eax, DWORD PTR [edi+edx*8+2]
  000b8	5f		 pop	 edi
  000b9	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000bc	5b		 pop	 ebx
  000bd	c7 04 86 01 00
	00 00		 mov	 DWORD PTR [esi+eax*4], 1
  000c4	5e		 pop	 esi

; 2692 : 			break;
; 2693 : 	}
; 2694 : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
$LN12@SetUserSta:

; 2651 : 			break;
; 2652 : 
; 2653 : 		case 2:
; 2654 : 			if ( gObj[iIndex].PartyNumber >= 0 )

  000cb	83 bc 18 2c 04
	00 00 00	 cmp	 DWORD PTR [eax+ebx+1068], 0
  000d3	0f 8c a6 02 00
	00		 jl	 $LN34@SetUserSta

; 2655 : 			{
; 2656 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++) //4

  000d9	33 c0		 xor	 eax, eax
  000db	eb 09		 jmp	 SHORT $LN10@SetUserSta
  000dd	8d 49 00	 npad	 3
$LL69@SetUserSta:
  000e0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@SetUserSta:

; 2657 : 				{
; 2658 : 					if ( i == iBridgeSubIndex )

  000e6	3b c7		 cmp	 eax, edi
  000e8	74 76		 je	 SHORT $LN9@SetUserSta

; 2659 : 					{
; 2660 : 						continue;
; 2661 : 					}
; 2662 : 
; 2663 : 					if(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) //season 4 add-on

  000ea	8d 3c cd 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*8]
  000f1	2b f9		 sub	 edi, ecx
  000f3	03 ff		 add	 edi, edi
  000f5	03 ff		 add	 edi, edi
  000f7	03 ff		 add	 edi, edi
  000f9	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  000fc	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  000ff	8b 54 96 1c	 mov	 edx, DWORD PTR [esi+edx*4+28]
  00103	83 fa ff	 cmp	 edx, -1
  00106	74 58		 je	 SHORT $LN9@SetUserSta

; 2664 : 					{
; 2665 : 						continue;
; 2666 : 					}
; 2667 : 
; 2668 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  00108	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0010e	03 d3		 add	 edx, ebx
  00110	89 55 0c	 mov	 DWORD PTR tv1256[ebp], edx
  00113	8b 55 fc	 mov	 edx, DWORD PTR tv1219[ebp]
  00116	8b 9c 1a 2c 04
	00 00		 mov	 ebx, DWORD PTR [edx+ebx+1068]
  0011d	8b 55 0c	 mov	 edx, DWORD PTR tv1256[ebp]
  00120	3b 9a 2c 04 00
	00		 cmp	 ebx, DWORD PTR [edx+1068]
  00126	75 38		 jne	 SHORT $LN9@SetUserSta

; 2669 : 					{
; 2670 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  00128	0f b6 92 49 01
	00 00		 movzx	 edx, BYTE PTR [edx+329]
  0012f	80 fa 34	 cmp	 dl, 52			; 00000034H
  00132	74 0e		 je	 SHORT $LN59@SetUserSta
  00134	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  00137	72 19		 jb	 SHORT $LN4@SetUserSta
  00139	b3 11		 mov	 bl, 17			; 00000011H
  0013b	3a da		 cmp	 bl, dl
  0013d	1b d2		 sbb	 edx, edx
  0013f	42		 inc	 edx
  00140	74 10		 je	 SHORT $LN4@SetUserSta
$LN59@SetUserSta:

; 2671 : 						{
; 2672 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00142	8d 7c 07 02	 lea	 edi, DWORD PTR [edi+eax+2]
  00146	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  00149	c7 04 96 03 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 3

; 2673 : 						}
; 2674 : 						else

  00150	eb 0e		 jmp	 SHORT $LN9@SetUserSta
$LN4@SetUserSta:

; 2675 : 						{
; 2676 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00152	8d 7c 07 02	 lea	 edi, DWORD PTR [edi+eax+2]
  00156	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  00159	c7 04 96 04 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 4
$LN9@SetUserSta:

; 2657 : 				{
; 2658 : 					if ( i == iBridgeSubIndex )

  00160	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00163	3b 55 08	 cmp	 edx, DWORD PTR _iBridgeSubIndex$[ebp]
  00166	74 7c		 je	 SHORT $LN65@SetUserSta

; 2659 : 					{
; 2660 : 						continue;
; 2661 : 					}
; 2662 : 
; 2663 : 					if(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) //season 4 add-on

  00168	8d 3c cd 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*8]
  0016f	2b f9		 sub	 edi, ecx
  00171	03 ff		 add	 edi, edi
  00173	03 ff		 add	 edi, edi
  00175	03 ff		 add	 edi, edi
  00177	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  0017a	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  0017d	8b 54 96 30	 mov	 edx, DWORD PTR [esi+edx*4+48]
  00181	83 fa ff	 cmp	 edx, -1
  00184	74 5e		 je	 SHORT $LN65@SetUserSta

; 2664 : 					{
; 2665 : 						continue;
; 2666 : 					}
; 2667 : 
; 2668 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  00186	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018c	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00192	03 d3		 add	 edx, ebx
  00194	89 55 0c	 mov	 DWORD PTR tv1284[ebp], edx
  00197	8b 55 fc	 mov	 edx, DWORD PTR tv1219[ebp]
  0019a	8b 9c 1a 2c 04
	00 00		 mov	 ebx, DWORD PTR [edx+ebx+1068]
  001a1	8b 55 0c	 mov	 edx, DWORD PTR tv1284[ebp]
  001a4	3b 9a 2c 04 00
	00		 cmp	 ebx, DWORD PTR [edx+1068]
  001aa	75 38		 jne	 SHORT $LN65@SetUserSta

; 2669 : 					{
; 2670 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  001ac	0f b6 92 49 01
	00 00		 movzx	 edx, BYTE PTR [edx+329]
  001b3	80 fa 34	 cmp	 dl, 52			; 00000034H
  001b6	74 0e		 je	 SHORT $LN60@SetUserSta
  001b8	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  001bb	72 19		 jb	 SHORT $LN39@SetUserSta
  001bd	b3 11		 mov	 bl, 17			; 00000011H
  001bf	3a da		 cmp	 bl, dl
  001c1	1b d2		 sbb	 edx, edx
  001c3	42		 inc	 edx
  001c4	74 10		 je	 SHORT $LN39@SetUserSta
$LN60@SetUserSta:

; 2671 : 						{
; 2672 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  001c6	8d 7c 07 03	 lea	 edi, DWORD PTR [edi+eax+3]
  001ca	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  001cd	c7 04 96 03 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 3

; 2673 : 						}
; 2674 : 						else

  001d4	eb 0e		 jmp	 SHORT $LN65@SetUserSta
$LN39@SetUserSta:

; 2675 : 						{
; 2676 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  001d6	8d 7c 07 03	 lea	 edi, DWORD PTR [edi+eax+3]
  001da	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  001dd	c7 04 96 04 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 4
$LN65@SetUserSta:

; 2657 : 				{
; 2658 : 					if ( i == iBridgeSubIndex )

  001e4	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  001e7	3b 55 08	 cmp	 edx, DWORD PTR _iBridgeSubIndex$[ebp]
  001ea	74 7c		 je	 SHORT $LN66@SetUserSta

; 2659 : 					{
; 2660 : 						continue;
; 2661 : 					}
; 2662 : 
; 2663 : 					if(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) //season 4 add-on

  001ec	8d 3c cd 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*8]
  001f3	2b f9		 sub	 edi, ecx
  001f5	03 ff		 add	 edi, edi
  001f7	03 ff		 add	 edi, edi
  001f9	03 ff		 add	 edi, edi
  001fb	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  001fe	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00201	8b 54 96 44	 mov	 edx, DWORD PTR [esi+edx*4+68]
  00205	83 fa ff	 cmp	 edx, -1
  00208	74 5e		 je	 SHORT $LN66@SetUserSta

; 2664 : 					{
; 2665 : 						continue;
; 2666 : 					}
; 2667 : 
; 2668 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  0020a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00210	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00216	03 d3		 add	 edx, ebx
  00218	89 55 0c	 mov	 DWORD PTR tv1307[ebp], edx
  0021b	8b 55 fc	 mov	 edx, DWORD PTR tv1219[ebp]
  0021e	8b 9c 1a 2c 04
	00 00		 mov	 ebx, DWORD PTR [edx+ebx+1068]
  00225	8b 55 0c	 mov	 edx, DWORD PTR tv1307[ebp]
  00228	3b 9a 2c 04 00
	00		 cmp	 ebx, DWORD PTR [edx+1068]
  0022e	75 38		 jne	 SHORT $LN66@SetUserSta

; 2669 : 					{
; 2670 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  00230	0f b6 92 49 01
	00 00		 movzx	 edx, BYTE PTR [edx+329]
  00237	80 fa 34	 cmp	 dl, 52			; 00000034H
  0023a	74 0e		 je	 SHORT $LN61@SetUserSta
  0023c	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  0023f	72 19		 jb	 SHORT $LN45@SetUserSta
  00241	b3 11		 mov	 bl, 17			; 00000011H
  00243	3a da		 cmp	 bl, dl
  00245	1b d2		 sbb	 edx, edx
  00247	42		 inc	 edx
  00248	74 10		 je	 SHORT $LN45@SetUserSta
$LN61@SetUserSta:

; 2671 : 						{
; 2672 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  0024a	8d 7c 07 04	 lea	 edi, DWORD PTR [edi+eax+4]
  0024e	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  00251	c7 04 96 03 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 3

; 2673 : 						}
; 2674 : 						else

  00258	eb 0e		 jmp	 SHORT $LN66@SetUserSta
$LN45@SetUserSta:

; 2675 : 						{
; 2676 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0025a	8d 7c 07 04	 lea	 edi, DWORD PTR [edi+eax+4]
  0025e	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  00261	c7 04 96 04 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 4
$LN66@SetUserSta:

; 2657 : 				{
; 2658 : 					if ( i == iBridgeSubIndex )

  00268	8d 50 03	 lea	 edx, DWORD PTR [eax+3]
  0026b	3b 55 08	 cmp	 edx, DWORD PTR _iBridgeSubIndex$[ebp]
  0026e	74 7c		 je	 SHORT $LN67@SetUserSta

; 2659 : 					{
; 2660 : 						continue;
; 2661 : 					}
; 2662 : 
; 2663 : 					if(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) //season 4 add-on

  00270	8d 3c cd 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*8]
  00277	2b f9		 sub	 edi, ecx
  00279	03 ff		 add	 edi, edi
  0027b	03 ff		 add	 edi, edi
  0027d	03 ff		 add	 edi, edi
  0027f	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00282	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00285	8b 54 96 58	 mov	 edx, DWORD PTR [esi+edx*4+88]
  00289	83 fa ff	 cmp	 edx, -1
  0028c	74 5e		 je	 SHORT $LN67@SetUserSta

; 2664 : 					{
; 2665 : 						continue;
; 2666 : 					}
; 2667 : 
; 2668 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  0028e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00294	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0029a	03 d3		 add	 edx, ebx
  0029c	89 55 0c	 mov	 DWORD PTR tv1330[ebp], edx
  0029f	8b 55 fc	 mov	 edx, DWORD PTR tv1219[ebp]
  002a2	8b 9c 1a 2c 04
	00 00		 mov	 ebx, DWORD PTR [edx+ebx+1068]
  002a9	8b 55 0c	 mov	 edx, DWORD PTR tv1330[ebp]
  002ac	3b 9a 2c 04 00
	00		 cmp	 ebx, DWORD PTR [edx+1068]
  002b2	75 38		 jne	 SHORT $LN67@SetUserSta

; 2669 : 					{
; 2670 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  002b4	0f b6 92 49 01
	00 00		 movzx	 edx, BYTE PTR [edx+329]
  002bb	80 fa 34	 cmp	 dl, 52			; 00000034H
  002be	74 0e		 je	 SHORT $LN62@SetUserSta
  002c0	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  002c3	72 19		 jb	 SHORT $LN51@SetUserSta
  002c5	b3 11		 mov	 bl, 17			; 00000011H
  002c7	3a da		 cmp	 bl, dl
  002c9	1b d2		 sbb	 edx, edx
  002cb	42		 inc	 edx
  002cc	74 10		 je	 SHORT $LN51@SetUserSta
$LN62@SetUserSta:

; 2671 : 						{
; 2672 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  002ce	8d 7c 07 05	 lea	 edi, DWORD PTR [edi+eax+5]
  002d2	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  002d5	c7 04 96 03 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 3

; 2673 : 						}
; 2674 : 						else

  002dc	eb 0e		 jmp	 SHORT $LN67@SetUserSta
$LN51@SetUserSta:

; 2675 : 						{
; 2676 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  002de	8d 7c 07 05	 lea	 edi, DWORD PTR [edi+eax+5]
  002e2	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  002e5	c7 04 96 04 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 4
$LN67@SetUserSta:

; 2657 : 				{
; 2658 : 					if ( i == iBridgeSubIndex )

  002ec	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  002ef	3b 55 08	 cmp	 edx, DWORD PTR _iBridgeSubIndex$[ebp]
  002f2	74 7c		 je	 SHORT $LN68@SetUserSta

; 2659 : 					{
; 2660 : 						continue;
; 2661 : 					}
; 2662 : 
; 2663 : 					if(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) //season 4 add-on

  002f4	8d 3c cd 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*8]
  002fb	2b f9		 sub	 edi, ecx
  002fd	03 ff		 add	 edi, edi
  002ff	03 ff		 add	 edi, edi
  00301	03 ff		 add	 edi, edi
  00303	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00306	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00309	8b 54 96 6c	 mov	 edx, DWORD PTR [esi+edx*4+108]
  0030d	83 fa ff	 cmp	 edx, -1
  00310	74 5e		 je	 SHORT $LN68@SetUserSta

; 2664 : 					{
; 2665 : 						continue;
; 2666 : 					}
; 2667 : 
; 2668 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  00312	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00318	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0031e	03 d3		 add	 edx, ebx
  00320	89 55 0c	 mov	 DWORD PTR tv1353[ebp], edx
  00323	8b 55 fc	 mov	 edx, DWORD PTR tv1219[ebp]
  00326	8b 9c 1a 2c 04
	00 00		 mov	 ebx, DWORD PTR [edx+ebx+1068]
  0032d	8b 55 0c	 mov	 edx, DWORD PTR tv1353[ebp]
  00330	3b 9a 2c 04 00
	00		 cmp	 ebx, DWORD PTR [edx+1068]
  00336	75 38		 jne	 SHORT $LN68@SetUserSta

; 2669 : 					{
; 2670 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  00338	0f b6 92 49 01
	00 00		 movzx	 edx, BYTE PTR [edx+329]
  0033f	80 fa 34	 cmp	 dl, 52			; 00000034H
  00342	74 0e		 je	 SHORT $LN63@SetUserSta
  00344	80 fa 0b	 cmp	 dl, 11			; 0000000bH
  00347	72 19		 jb	 SHORT $LN57@SetUserSta
  00349	b3 11		 mov	 bl, 17			; 00000011H
  0034b	3a da		 cmp	 bl, dl
  0034d	1b d2		 sbb	 edx, edx
  0034f	42		 inc	 edx
  00350	74 10		 je	 SHORT $LN57@SetUserSta
$LN63@SetUserSta:

; 2671 : 						{
; 2672 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00352	8d 7c 07 06	 lea	 edi, DWORD PTR [edi+eax+6]
  00356	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  00359	c7 04 96 03 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 3

; 2673 : 						}
; 2674 : 						else

  00360	eb 0e		 jmp	 SHORT $LN68@SetUserSta
$LN57@SetUserSta:

; 2675 : 						{
; 2676 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00362	8d 7c 07 06	 lea	 edi, DWORD PTR [edi+eax+6]
  00366	8d 14 bf	 lea	 edx, DWORD PTR [edi+edi*4]
  00369	c7 04 96 04 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 4
$LN68@SetUserSta:

; 2655 : 			{
; 2656 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++) //4

  00370	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeSubIndex$[ebp]
  00373	83 c0 05	 add	 eax, 5
  00376	83 f8 28	 cmp	 eax, 40			; 00000028H
  00379	0f 8c 61 fd ff
	ff		 jl	 $LL69@SetUserSta
$LN34@SetUserSta:

; 2677 : 						}
; 2678 : 					}
; 2679 : 				}
; 2680 : 			}
; 2681 : 
; 2682 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 2;

  0037f	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00386	2b c1		 sub	 eax, ecx

; 2683 : 			this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = iBridgeSubIndex;

  00388	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0038e	8d 44 c7 02	 lea	 eax, DWORD PTR [edi+eax*8+2]
  00392	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00395	c7 04 96 02 00
	00 00		 mov	 DWORD PTR [esi+edx*4], 2
  0039c	89 bc 31 a0 03
	00 00		 mov	 DWORD PTR [ecx+esi+928], edi
  003a3	5f		 pop	 edi
  003a4	5b		 pop	 ebx
  003a5	5e		 pop	 esi

; 2692 : 			break;
; 2693 : 	}
; 2694 : }

  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c2 08 00	 ret	 8
$LN2@SetUserSta:

; 2684 : 			break;
; 2685 : 
; 2686 : 		case 3:
; 2687 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 3;

  003ac	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  003b3	2b c1		 sub	 eax, ecx
  003b5	8d 44 c7 02	 lea	 eax, DWORD PTR [edi+eax*8+2]
  003b9	5f		 pop	 edi
  003ba	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  003bd	5b		 pop	 ebx
  003be	c7 04 8e 03 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 3
  003c5	5e		 pop	 esi

; 2692 : 			break;
; 2693 : 	}
; 2694 : }

  003c6	8b e5		 mov	 esp, ebp
  003c8	5d		 pop	 ebp
  003c9	c2 08 00	 ret	 8
$LN1@SetUserSta:

; 2688 : 			break;
; 2689 : 
; 2690 : 		case 4:
; 2691 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 4;

  003cc	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  003d3	2b d1		 sub	 edx, ecx
  003d5	8d 44 d7 02	 lea	 eax, DWORD PTR [edi+edx*8+2]
  003d9	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  003dc	c7 04 86 04 00
	00 00		 mov	 DWORD PTR [esi+eax*4], 4
$LN71@SetUserSta:
  003e3	5f		 pop	 edi
  003e4	5b		 pop	 ebx
$LN15@SetUserSta:
  003e5	5e		 pop	 esi

; 2692 : 			break;
; 2693 : 	}
; 2694 : }

  003e6	8b e5		 mov	 esp, ebp
  003e8	5d		 pop	 ebp
  003e9	c2 08 00	 ret	 8
$LN73@SetUserSta:
  003ec	00 00 00 00	 DD	 $LN14@SetUserSta
  003f0	00 00 00 00	 DD	 $LN13@SetUserSta
  003f4	00 00 00 00	 DD	 $LN12@SetUserSta
  003f8	00 00 00 00	 DD	 $LN2@SetUserSta
  003fc	00 00 00 00	 DD	 $LN1@SetUserSta
?SetUserState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SetUserState
_TEXT	ENDS
PUBLIC	?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardEXP
EXTRN	?GCKillPlayerExtSend@@YAXHH_JHH@Z:PROC		; GCKillPlayerExtSend
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z:PROC ; gObjUserSetExp
EXTRN	?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; gObjSealUserSetExp
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	__ftol2:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iRET_EXP$ = -16					; size = 8
_iCAL_EXP$ = -8						; size = 8
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardEXP, COMDAT
; _this$ = ecx

; 2972 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2973 : 	if ( iEXP <= 0 )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iEXP$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	7f 09		 jg	 SHORT $LN9@CalcSendRe

; 2974 : 	{
; 2975 : 		return 0;

  00010	33 c0		 xor	 eax, eax
  00012	5f		 pop	 edi

; 3021 : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
$LN9@CalcSendRe:

; 2976 : 	}
; 2977 : 
; 2978 : 	__int64 iRET_EXP = 0; //loc3
; 2979 : 	__int64 iCAL_EXP = iEXP; //loc2

  00019	99		 cdq

; 2980 : 	
; 2981 : 	if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty )

  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0001f	89 45 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  00022	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  00025	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	75 36		 jne	 SHORT $LN21@CalcSendRe
  0002f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  00036	74 2d		 je	 SHORT $LN21@CalcSendRe

; 2982 : 	{
; 2983 : 		iCAL_EXP = iCAL_EXP * g_CrywolfSync.GetGettingExpPenaltyRate() / 100; //season 2.5 changed

  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0003d	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp+4]
  00045	51		 push	 ecx
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp]
  00049	99		 cdq
  0004a	51		 push	 ecx
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __allmul
  00052	6a 00		 push	 0
  00054	6a 64		 push	 100			; 00000064H
  00056	52		 push	 edx
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __alldiv
  0005d	89 45 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  00060	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  00063	eb 06		 jmp	 SHORT $LN8@CalcSendRe
$LN21@CalcSendRe:
  00065	8b 55 fc	 mov	 edx, DWORD PTR _iCAL_EXP$[ebp+4]
  00068	8b 45 f8	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
$LN8@CalcSendRe:

; 2984 : 	}
; 2985 : 
; 2986 : 	if ( OBJMAX_RANGE(iIndex) == FALSE ) //loc6

  0006b	56		 push	 esi
  0006c	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0006f	85 f6		 test	 esi, esi
  00071	78 22		 js	 SHORT $LN16@CalcSendRe
  00073	33 c9		 xor	 ecx, ecx
  00075	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0007b	0f 9e c1	 setle	 cl
  0007e	85 c9		 test	 ecx, ecx

; 2987 : 	{
; 2988 : 		return 0;

  00080	74 13		 je	 SHORT $LN16@CalcSendRe

; 2989 : 	}
; 2990 : 
; 2991 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00088	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0008e	83 7c 0e 04 03	 cmp	 DWORD PTR [esi+ecx+4], 3
  00093	7d 0a		 jge	 SHORT $LN6@CalcSendRe
$LN16@CalcSendRe:
  00095	5e		 pop	 esi

; 2992 : 	{
; 2993 : 		return 0;

  00096	33 c0		 xor	 eax, eax
  00098	5f		 pop	 edi

; 3021 : }

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 08 00	 ret	 8
$LN6@CalcSendRe:

; 2994 : 	}
; 2995 : 
; 2996 : 	iRET_EXP = iCAL_EXP;
; 2997 : 
; 2998 : 	if ( gObj[iIndex].Type == OBJ_USER )

  0009f	66 83 7c 0e 68
	01		 cmp	 WORD PTR [esi+ecx+104], 1
  000a5	53		 push	 ebx
  000a6	89 45 f0	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  000a9	8b da		 mov	 ebx, edx
  000ab	0f 85 d8 00 00
	00		 jne	 $LN25@CalcSendRe

; 2999 : 	{
; 3000 : 		while ( iCAL_EXP > 0 )

  000b1	85 d2		 test	 edx, edx
  000b3	0f 8c a7 00 00
	00		 jl	 $LN24@CalcSendRe
  000b9	7f 29		 jg	 SHORT $LN18@CalcSendRe
  000bb	85 c0		 test	 eax, eax
  000bd	0f 84 9d 00 00
	00		 je	 $LN24@CalcSendRe
  000c3	eb 11		 jmp	 SHORT $LN4@CalcSendRe
  000c5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL22@CalcSendRe:
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN4@CalcSendRe:

; 3001 : 		{
; 3002 : 			if ( iCAL_EXP > 0 )

  000d6	85 d2		 test	 edx, edx
  000d8	0f 8c 82 00 00
	00		 jl	 $LN24@CalcSendRe
  000de	7f 04		 jg	 SHORT $LN18@CalcSendRe
  000e0	85 c0		 test	 eax, eax
  000e2	74 7c		 je	 SHORT $LN24@CalcSendRe
$LN18@CalcSendRe:

; 3003 : 			{
; 3004 : 				gObjSealUserSetExp(&gObj[iIndex], iCAL_EXP, TRUE); //Seal Exp

  000e4	6a 01		 push	 1
  000e6	8d 55 f8	 lea	 edx, DWORD PTR _iCAL_EXP$[ebp]
  000e9	52		 push	 edx
  000ea	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp

; 3005 : 				gObjUserSetExp(&gObj[iIndex],iCAL_EXP);	//Panda Use

  000f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f9	8d 4d f8	 lea	 ecx, DWORD PTR _iCAL_EXP$[ebp]
  000fc	51		 push	 ecx
  000fd	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp

; 3006 : 
; 3007 : 				iCAL_EXP = (__int64)((int)(iCAL_EXP) * this->m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_iBC_REWARD_EXP); //season 4.5 add-on

  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010c	0f be 94 0e 9e
	0e 00 00	 movsx	 edx, BYTE PTR [esi+ecx+3742]
  00114	42		 inc	 edx
  00115	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0011b	83 c4 14	 add	 esp, 20			; 00000014H
  0011e	d9 04 3a	 fld	 DWORD PTR [edx+edi]
  00121	da 4d f8	 fimul	 DWORD PTR _iCAL_EXP$[ebp]
  00124	e8 00 00 00 00	 call	 __ftol2
  00129	8b c8		 mov	 ecx, eax
  0012b	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx

; 3008 : 				iRET_EXP = (int)(iCAL_EXP); //season 4.5 changed + fix

  0012e	99		 cdq

; 3009 : 
; 3010 : 				iCAL_EXP = this->LevelUp(iIndex, iCAL_EXP, 4);

  0012f	6a 04		 push	 4
  00131	89 45 f0	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  00134	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00137	51		 push	 ecx
  00138	89 4d f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], ecx
  0013b	50		 push	 eax
  0013c	8b cf		 mov	 ecx, edi
  0013e	8b da		 mov	 ebx, edx
  00140	e8 00 00 00 00	 call	 ?LevelUp@CBloodCastle@@QAEHHHH@Z ; CBloodCastle::LevelUp
  00145	99		 cdq
  00146	89 45 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  00149	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  0014c	85 d2		 test	 edx, edx
  0014e	7f 80		 jg	 SHORT $LL22@CalcSendRe

; 2999 : 	{
; 3000 : 		while ( iCAL_EXP > 0 )

  00150	7c 08		 jl	 SHORT $LN23@CalcSendRe
  00152	85 c0		 test	 eax, eax
  00154	0f 85 76 ff ff
	ff		 jne	 $LL22@CalcSendRe
$LN23@CalcSendRe:
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN24@CalcSendRe:

; 3011 : 			}
; 3012 : 		}
; 3013 : 
; 3014 : 		if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iIndex]) == FALSE) //season3 add-on

  00160	03 f1		 add	 esi, ecx
  00162	56		 push	 esi
  00163	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00168	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  0016d	85 c0		 test	 eax, eax
  0016f	75 18		 jne	 SHORT $LN25@CalcSendRe

; 3015 : 		{
; 3016 : 			GCKillPlayerExtSend(iIndex, (WORD)-1, iRET_EXP, 0, 0);

  00171	8b 4d f0	 mov	 ecx, DWORD PTR _iRET_EXP$[ebp]
  00174	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00177	50		 push	 eax
  00178	50		 push	 eax
  00179	53		 push	 ebx
  0017a	51		 push	 ecx
  0017b	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 ?GCKillPlayerExtSend@@YAXHH_JHH@Z ; GCKillPlayerExtSend
  00186	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@CalcSendRe:

; 3017 : 		}
; 3018 : 	}
; 3019 : 
; 3020 : 	return iRET_EXP;

  00189	8b 45 f0	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
  0018c	5b		 pop	 ebx
  0018d	5e		 pop	 esi
  0018e	5f		 pop	 edi

; 3021 : }

  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 08 00	 ret	 8
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardEXP
_TEXT	ENDS
PUBLIC	?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardZEN
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
; Function compile flags: /Ogtp
;	COMDAT ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iZEN$ = 12						; size = 4
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardZEN, COMDAT
; _this$ = ecx

; 3024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3025 : 	if ( iZEN <= 0 )

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iZEN$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	7f 07		 jg	 SHORT $LN4@CalcSendRe@2

; 3026 : 	{
; 3027 : 		return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5b		 pop	 ebx

; 3055 : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN4@CalcSendRe@2:
  00012	57		 push	 edi

; 3028 : 	}
; 3029 : 
; 3030 : 	int iRET_ZEN = 0;
; 3031 : 
; 3032 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00013	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00016	85 ff		 test	 edi, edi
  00018	78 0f		 js	 SHORT $LN9@CalcSendRe@2
  0001a	33 c0		 xor	 eax, eax
  0001c	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00022	0f 9e c0	 setle	 al
  00025	85 c0		 test	 eax, eax
  00027	75 08		 jne	 SHORT $LN3@CalcSendRe@2
$LN9@CalcSendRe@2:
  00029	5f		 pop	 edi

; 3033 : 	{
; 3034 : 		return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	5b		 pop	 ebx

; 3055 : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN3@CalcSendRe@2:

; 3035 : 	}
; 3036 : 
; 3037 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	56		 push	 esi
  00037	8b f7		 mov	 esi, edi
  00039	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0003f	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00044	7d 09		 jge	 SHORT $LN2@CalcSendRe@2

; 3038 : 	{
; 3039 : 		return 0;

  00046	5e		 pop	 esi
  00047	5f		 pop	 edi
  00048	33 c0		 xor	 eax, eax
  0004a	5b		 pop	 ebx

; 3055 : }

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN2@CalcSendRe@2:

; 3040 : 	}
; 3041 : 
; 3042 : 	if ( gObjCheckMaxZen(iIndex, iZEN) == FALSE )

  0004f	53		 push	 ebx
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00056	83 c4 08	 add	 esp, 8
  00059	85 c0		 test	 eax, eax
  0005b	75 24		 jne	 SHORT $LN1@CalcSendRe@2

; 3043 : 	{
; 3044 : 		iRET_ZEN = MAX_ZEN - gObj[iIndex].Money;

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	8b 8c 16 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+edx+240]
  0006a	b8 00 94 35 77	 mov	 eax, 2000000000		; 77359400H
  0006f	2b c1		 sub	 eax, ecx

; 3045 : 		gObj[iIndex].Money += iRET_ZEN;

  00071	03 c8		 add	 ecx, eax
  00073	89 8c 16 f0 00
	00 00		 mov	 DWORD PTR [esi+edx+240], ecx
  0007a	5e		 pop	 esi
  0007b	5f		 pop	 edi
  0007c	5b		 pop	 ebx

; 3055 : }

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
$LN1@CalcSendRe@2:

; 3046 : 
; 3047 : 		return iRET_ZEN;
; 3048 : 	}
; 3049 : 
; 3050 : 	gObj[iIndex].Money += iZEN;

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	01 9c 06 f0 00
	00 00		 add	 DWORD PTR [esi+eax+240], ebx

; 3051 : 	iRET_ZEN = iZEN;
; 3052 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	8b 94 0e f0 00
	00 00		 mov	 edx, DWORD PTR [esi+ecx+240]
  0009a	52		 push	 edx
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000a1	83 c4 08	 add	 esp, 8
  000a4	5e		 pop	 esi
  000a5	5f		 pop	 edi

; 3053 : 
; 3054 : 	return iRET_ZEN;

  000a6	8b c3		 mov	 eax, ebx
  000a8	5b		 pop	 ebx

; 3055 : }

  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardZEN
_TEXT	ENDS
PUBLIC	?DropChaosGem@CBloodCastle@@QAEXH@Z		; CBloodCastle::DropChaosGem
EXTRN	?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z:PROC ; gObjLevelUp
EXTRN	?gLevelExperience@@3PAKA:BYTE			; gLevelExperience
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?GenExcOpt@@YAHH@Z:PROC				; GenExcOpt
EXTRN	?Main@cBloodCastleRewardItem@@QAE_NH@Z:PROC	; cBloodCastleRewardItem::Main
EXTRN	?gBloodCastleRewardItem@@3VcBloodCastleRewardItem@@A:BYTE ; gBloodCastleRewardItem
EXTRN	?CompleteBC@CAchievements@@QAEXH@Z:PROC		; CAchievements::CompleteBC
; Function compile flags: /Ogtp
;	COMDAT ?DropChaosGem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_exp$219875 = -8					; size = 8
_Exe1$ = -4						; size = 4
_Anc1$ = 8						; size = 4
_iIndex$ = 8						; size = 4
?DropChaosGem@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::DropChaosGem, COMDAT
; _this$ = ecx

; 3059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 3060 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	0f 88 89 01 00
	00		 js	 $LN1@DropChaosG
  00012	33 c0		 xor	 eax, eax
  00014	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 76 01 00
	00		 je	 $LN1@DropChaosG

; 3061 : 	{
; 3062 : 		return;
; 3063 : 	}
; 3064 : 
; 3065 : #if(SYSTEM_ACHIEVEMENTS)
; 3066 : 	g_Achievements.CompleteBC(iIndex);

  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	53		 push	 ebx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  0002d	e8 00 00 00 00	 call	 ?CompleteBC@CAchievements@@QAEXH@Z ; CAchievements::CompleteBC

; 3067 : #endif
; 3068 : 
; 3069 : 	int iMaxHitUser = iIndex;
; 3070 : 	//int iType = ::ItemGetNumberMake(12, 15);
; 3071 : 
; 3072 : 	int iMapNumber = -1;
; 3073 : 
; 3074 : 	switch(gObj[iIndex].MapNumber)

  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	8b f3		 mov	 esi, ebx
  0003a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00040	0f b6 84 0e 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+329]
  00048	83 c0 f5	 add	 eax, -11		; fffffff5H
  0004b	83 cf ff	 or	 edi, -1
  0004e	83 f8 29	 cmp	 eax, 41			; 00000029H
  00051	77 44		 ja	 SHORT $LN16@DropChaosG
  00053	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN25@DropChaosG[eax]
  0005a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN29@DropChaosG[eax*4]
$LN15@DropChaosG:

; 3075 : 	{
; 3076 : 	case MAP_INDEX_BLOODCASTLE1:
; 3077 : 		iMapNumber = 238;

  00061	bf ee 00 00 00	 mov	 edi, 238		; 000000eeH

; 3078 : 		break;

  00066	eb 2f		 jmp	 SHORT $LN16@DropChaosG
$LN14@DropChaosG:

; 3079 : 	case MAP_INDEX_BLOODCASTLE2:
; 3080 : 		iMapNumber = 239;

  00068	bf ef 00 00 00	 mov	 edi, 239		; 000000efH

; 3081 : 		break;

  0006d	eb 28		 jmp	 SHORT $LN16@DropChaosG
$LN13@DropChaosG:

; 3082 : 	case MAP_INDEX_BLOODCASTLE3:
; 3083 : 		iMapNumber = 240;

  0006f	bf f0 00 00 00	 mov	 edi, 240		; 000000f0H

; 3084 : 		break;

  00074	eb 21		 jmp	 SHORT $LN16@DropChaosG
$LN12@DropChaosG:

; 3085 : 	case MAP_INDEX_BLOODCASTLE4:
; 3086 : 		iMapNumber = 241;

  00076	bf f1 00 00 00	 mov	 edi, 241		; 000000f1H

; 3087 : 		break;

  0007b	eb 1a		 jmp	 SHORT $LN16@DropChaosG
$LN11@DropChaosG:

; 3088 : 	case MAP_INDEX_BLOODCASTLE5:
; 3089 : 		iMapNumber = 242;

  0007d	bf f2 00 00 00	 mov	 edi, 242		; 000000f2H

; 3090 : 		break;

  00082	eb 13		 jmp	 SHORT $LN16@DropChaosG
$LN10@DropChaosG:

; 3091 : 	case MAP_INDEX_BLOODCASTLE6:
; 3092 : 		iMapNumber = 243;

  00084	bf f3 00 00 00	 mov	 edi, 243		; 000000f3H

; 3093 : 		break;

  00089	eb 0c		 jmp	 SHORT $LN16@DropChaosG
$LN9@DropChaosG:

; 3094 : 	case MAP_INDEX_BLOODCASTLE7:
; 3095 : 		iMapNumber = 244;

  0008b	bf f4 00 00 00	 mov	 edi, 244		; 000000f4H

; 3096 : 		break;

  00090	eb 05		 jmp	 SHORT $LN16@DropChaosG
$LN8@DropChaosG:

; 3097 : 	case MAP_INDEX_BLOODCASTLE8:
; 3098 : 		iMapNumber = 245;

  00092	bf f5 00 00 00	 mov	 edi, 245		; 000000f5H
$LN16@DropChaosG:

; 3099 : 		break;
; 3100 : 	}
; 3101 : 
; 3102 : 	////Configs
; 3103 : 	//int Zt_BCDropType	= GetPrivateProfileInt("BloodCastle","BCDropType",12,"..\\Data\\ZtData\\Events.ini");
; 3104 : 	//int Zt_BCDropID		= GetPrivateProfileInt("BloodCastle","BCDropID",15,"..\\Data\\ZtData\\Events.ini");
; 3105 : 	//int Zt_BCDropLevel	= GetPrivateProfileInt("BloodCastle","BCDropLevel",0,"..\\Data\\ZtData\\Events.ini");
; 3106 : 	//int Zt_BCDropSkill	= GetPrivateProfileInt("BloodCastle","BCDropSkill",0,"..\\Data\\ZtData\\Events.ini");
; 3107 : 	//int Zt_BCDropLuck	= GetPrivateProfileInt("BloodCastle","BCDropLuck",0,"..\\Data\\ZtData\\Events.ini");
; 3108 : 	//int Zt_BCDropOpt	= GetPrivateProfileInt("BloodCastle","BCDropOpt",0,"..\\Data\\ZtData\\Events.ini");
; 3109 : 	//int Zt_BCDropExcOpt	= GetPrivateProfileInt("BloodCastle","BCDropExcOpt",0,"..\\Data\\ZtData\\Events.ini");
; 3110 : 	//int Zt_BCDropAncOpt	= GetPrivateProfileInt("BloodCastle","BCDropAncOpt",0,"..\\Data\\ZtData\\Events.ini");
; 3111 : 
; 3112 : 
; 3113 : 
; 3114 : 	//Zt_BCDropLuck_DRYNEA
; 3115 : 	int Exe1 = 0;
; 3116 : 	int Anc1 = 0;
; 3117 : 
; 3118 : #ifdef BC_LVL_DROP
; 3119 : 	//if(g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::Local2) || g_ZtLicense.CheckUser(eZtUB::Local))
; 3120 : 	//{
; 3121 : 	//	switch(gObj[iIndex].MapNumber)
; 3122 : 	//	{
; 3123 : 	//	case MAP_INDEX_BLOODCASTLE1:
; 3124 : 	//		{
; 3125 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[1] > 0 )
; 3126 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[1]);
; 3127 : 
; 3128 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[1] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[1] == 10 )
; 3129 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[1];
; 3130 : 
; 3131 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[1], ZtConfig.Event.Zt_BCDropID_DRYNEA[1]);
; 3132 : 
; 3133 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3134 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[1], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[1], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[1], 
; 3135 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[1], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3136 : 	//		}
; 3137 : 	//		break;
; 3138 : 	//	case MAP_INDEX_BLOODCASTLE2:
; 3139 : 	//		{
; 3140 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[2] > 0 )
; 3141 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[2]);
; 3142 : 
; 3143 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[2] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[2] == 10 )
; 3144 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[2];
; 3145 : 
; 3146 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[2], ZtConfig.Event.Zt_BCDropID_DRYNEA[2]);
; 3147 : 
; 3148 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3149 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[2], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[2], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[2], 
; 3150 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[2], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3151 : 	//		}
; 3152 : 	//		break;
; 3153 : 	//	case MAP_INDEX_BLOODCASTLE3:
; 3154 : 	//		{
; 3155 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[3] > 0 )
; 3156 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[3]);
; 3157 : 
; 3158 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[3] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[3] == 10 )
; 3159 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[3];
; 3160 : 
; 3161 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[3], ZtConfig.Event.Zt_BCDropID_DRYNEA[3]);
; 3162 : 
; 3163 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3164 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[3], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[3], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[3], 
; 3165 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[3], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3166 : 	//		}
; 3167 : 	//		break;
; 3168 : 	//	case MAP_INDEX_BLOODCASTLE4:
; 3169 : 	//		{
; 3170 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[4] > 0 )
; 3171 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[4]);
; 3172 : 
; 3173 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[4] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[4] == 10 )
; 3174 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[4];
; 3175 : 
; 3176 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[4], ZtConfig.Event.Zt_BCDropID_DRYNEA[4]);
; 3177 : 
; 3178 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3179 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[4], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[4], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[4], 
; 3180 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[4], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3181 : 	//		}
; 3182 : 	//		break;
; 3183 : 	//	case MAP_INDEX_BLOODCASTLE5:
; 3184 : 	//		{
; 3185 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[5] > 0 )
; 3186 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[5]);
; 3187 : 
; 3188 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[5] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[5] == 10 )
; 3189 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[5];
; 3190 : 
; 3191 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[5], ZtConfig.Event.Zt_BCDropID_DRYNEA[5]);
; 3192 : 
; 3193 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3194 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[5], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[5], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[5], 
; 3195 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[5], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3196 : 	//		}
; 3197 : 	//		break;
; 3198 : 	//	case MAP_INDEX_BLOODCASTLE6:
; 3199 : 	//		{
; 3200 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[6] > 0 )
; 3201 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[6]);
; 3202 : 
; 3203 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[6] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[6] == 10 )
; 3204 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[6];
; 3205 : 
; 3206 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[6], ZtConfig.Event.Zt_BCDropID_DRYNEA[6]);
; 3207 : 
; 3208 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3209 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[6], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[6], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[6], 
; 3210 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[6], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3211 : 	//		}
; 3212 : 	//		break;
; 3213 : 	//	case MAP_INDEX_BLOODCASTLE7:
; 3214 : 	//		{
; 3215 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[7] > 0 )
; 3216 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[7]);
; 3217 : 
; 3218 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[7] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[7] == 10 )
; 3219 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[7];
; 3220 : 
; 3221 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[7], ZtConfig.Event.Zt_BCDropID_DRYNEA[7]);
; 3222 : 
; 3223 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3224 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[7], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[7], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[7], 
; 3225 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[7], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3226 : 	//		}
; 3227 : 	//		break;
; 3228 : 	//	case MAP_INDEX_BLOODCASTLE8:
; 3229 : 	//		{
; 3230 : 	//			if ( ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[8] > 0 )
; 3231 : 	//			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt_DRYNEA[8]);
; 3232 : 
; 3233 : 	//			if ( ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[8] == 5 || ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[8] == 10 )
; 3234 : 	//			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt_DRYNEA[8];
; 3235 : 
; 3236 : 	//			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType_DRYNEA[8], ZtConfig.Event.Zt_BCDropID_DRYNEA[8]);
; 3237 : 
; 3238 : 	//			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3239 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropLevel_DRYNEA[8], 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill_DRYNEA[8], (BYTE)ZtConfig.Event.Zt_BCDropLuck_DRYNEA[8], 
; 3240 : 	//			(BYTE)ZtConfig.Event.Zt_BCDropOpt_DRYNEA[8], iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3241 : 	//		}
; 3242 : 	//		break;
; 3243 : 	//	}
; 3244 : 	//}
; 3245 : 	//else
; 3246 : 	{
; 3247 : 		if (!gBloodCastleRewardItem.Main(gObj[iIndex].m_Index))

  00097	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  0009a	33 c0		 xor	 eax, eax
  0009c	51		 push	 ecx
  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBloodCastleRewardItem@@3VcBloodCastleRewardItem@@A ; gBloodCastleRewardItem
  000a2	89 45 fc	 mov	 DWORD PTR _Exe1$[ebp], eax
  000a5	89 45 08	 mov	 DWORD PTR _Anc1$[ebp], eax
  000a8	e8 00 00 00 00	 call	 ?Main@cBloodCastleRewardItem@@QAE_NH@Z ; cBloodCastleRewardItem::Main
  000ad	84 c0		 test	 al, al
  000af	0f 85 8a 00 00
	00		 jne	 $LN26@DropChaosG

; 3248 : 		{
; 3249 : 			if ( ZtConfig.Event.Zt_BCDropExcOpt > 0 )

  000b5	a1 30 07 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1840
  000ba	85 c0		 test	 eax, eax
  000bc	7e 0c		 jle	 SHORT $LN6@DropChaosG

; 3250 : 			Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt);

  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?GenExcOpt@@YAHH@Z	; GenExcOpt
  000c4	83 c4 04	 add	 esp, 4
  000c7	89 45 fc	 mov	 DWORD PTR _Exe1$[ebp], eax
$LN6@DropChaosG:

; 3251 : 
; 3252 : 			if ( ZtConfig.Event.Zt_BCDropAncOpt == 5 || ZtConfig.Event.Zt_BCDropAncOpt == 10 )

  000ca	a1 34 07 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1844
  000cf	83 f8 05	 cmp	 eax, 5
  000d2	74 05		 je	 SHORT $LN4@DropChaosG
  000d4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000d7	75 03		 jne	 SHORT $LN5@DropChaosG
$LN4@DropChaosG:

; 3253 : 			Anc1 = ZtConfig.Event.Zt_BCDropAncOpt;

  000d9	89 45 08	 mov	 DWORD PTR _Anc1$[ebp], eax
$LN5@DropChaosG:

; 3254 : 
; 3255 : 			int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType, ZtConfig.Event.Zt_BCDropID);

  000dc	8b 15 1c 07 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1820
  000e2	a1 18 07 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1816
  000e7	52		 push	 edx
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 3256 : 
; 3257 : 			ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3258 : 			(BYTE)ZtConfig.Event.Zt_BCDropLevel, 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill, (BYTE)ZtConfig.Event.Zt_BCDropLuck, 
; 3259 : 			(BYTE)ZtConfig.Event.Zt_BCDropOpt, iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);

  000ee	8b 55 08	 mov	 edx, DWORD PTR _Anc1$[ebp]
  000f1	52		 push	 edx
  000f2	8b 55 fc	 mov	 edx, DWORD PTR _Exe1$[ebp]
  000f5	52		 push	 edx
  000f6	0f b6 15 2c 07
	00 00		 movzx	 edx, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+1836
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00103	53		 push	 ebx
  00104	52		 push	 edx
  00105	0f b6 15 28 07
	00 00		 movzx	 edx, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+1832
  0010c	52		 push	 edx
  0010d	0f b6 15 24 07
	00 00		 movzx	 edx, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+1828
  00114	52		 push	 edx
  00115	0f b6 15 20 07
	00 00		 movzx	 edx, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+1824
  0011c	6a 00		 push	 0
  0011e	52		 push	 edx
  0011f	0f b6 94 0e 44
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+324]
  00127	50		 push	 eax
  00128	0f b6 84 0e 46
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+326]
  00130	50		 push	 eax
  00131	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  00134	52		 push	 edx
  00135	57		 push	 edi
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0013c	83 c4 3c	 add	 esp, 60			; 0000003cH
$LN26@DropChaosG:

; 3260 : 		}
; 3261 : 	}
; 3262 : 
; 3263 : #else
; 3264 : 	if ( ZtConfig.Event.Zt_BCDropExcOpt > 0 )
; 3265 : 		Exe1 = GenExcOpt(ZtConfig.Event.Zt_BCDropExcOpt);
; 3266 : 
; 3267 : 	if ( ZtConfig.Event.Zt_BCDropAncOpt == 5 || ZtConfig.Event.Zt_BCDropAncOpt == 10 )
; 3268 : 		Anc1 = ZtConfig.Event.Zt_BCDropAncOpt;
; 3269 : 
; 3270 : 	int iType = ItemGetNumberMake(ZtConfig.Event.Zt_BCDropType, ZtConfig.Event.Zt_BCDropID);
; 3271 : 
; 3272 : 	ItemSerialCreateSend(gObj[iIndex].m_Index, (BYTE)iMapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 
; 3273 : 		(BYTE)ZtConfig.Event.Zt_BCDropLevel, 0, (BYTE)ZtConfig.Event.Zt_BCDropSkill, (BYTE)ZtConfig.Event.Zt_BCDropLuck, 
; 3274 : 		(BYTE)ZtConfig.Event.Zt_BCDropOpt, iMaxHitUser, (BYTE)Exe1, (BYTE)Anc1);
; 3275 : #endif
; 3276 : 
; 3277 : 	#if(ENABLE_NSGAME_UPDATE)
; 3278 : 	for(int i = 0; i < ZtConfig.Event.Zt_BCRewardLevelUp; i++)

  0013f	33 db		 xor	 ebx, ebx
  00141	33 ff		 xor	 edi, edi
  00143	39 1d 3c 07 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1852, ebx
  00149	7e 4e		 jle	 SHORT $LN27@DropChaosG
  0014b	eb 03 8d 49 00	 npad	 5
$LL3@DropChaosG:

; 3279 : 	{
; 3280 : 		__int64 exp = gLevelExperience[gObj[iIndex].Level];

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00155	0f bf 8c 06 be
	00 00 00	 movsx	 ecx, WORD PTR [esi+eax+190]
  0015d	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  00164	89 4d f8	 mov	 DWORD PTR _exp$219875[ebp], ecx
  00167	89 5d fc	 mov	 DWORD PTR _exp$219875[ebp+4], ebx

; 3281 : 		gObj[iIndex].Experience = exp;

  0016a	89 8c 06 c8 00
	00 00		 mov	 DWORD PTR [esi+eax+200], ecx

; 3282 : 		gObjLevelUp(&gObj[iIndex], exp, gObj[iIndex].Class, 0);

  00171	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00176	0f b7 94 06 b8
	00 00 00	 movzx	 edx, WORD PTR [esi+eax+184]
  0017e	53		 push	 ebx
  0017f	52		 push	 edx
  00180	8d 4d f8	 lea	 ecx, DWORD PTR _exp$219875[ebp]
  00183	51		 push	 ecx
  00184	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z ; gObjLevelUp
  0018d	47		 inc	 edi
  0018e	83 c4 10	 add	 esp, 16			; 00000010H
  00191	3b 3d 3c 07 00
	00		 cmp	 edi, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1852
  00197	7c b7		 jl	 SHORT $LL3@DropChaosG
$LN27@DropChaosG:
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
$LN1@DropChaosG:
  0019b	5b		 pop	 ebx

; 3283 : 	}
; 3284 : 	#endif
; 3285 : 
; 3286 : }

  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c2 04 00	 ret	 4
  001a2	8b ff		 npad	 2
$LN29@DropChaosG:
  001a4	00 00 00 00	 DD	 $LN15@DropChaosG
  001a8	00 00 00 00	 DD	 $LN14@DropChaosG
  001ac	00 00 00 00	 DD	 $LN13@DropChaosG
  001b0	00 00 00 00	 DD	 $LN12@DropChaosG
  001b4	00 00 00 00	 DD	 $LN11@DropChaosG
  001b8	00 00 00 00	 DD	 $LN10@DropChaosG
  001bc	00 00 00 00	 DD	 $LN9@DropChaosG
  001c0	00 00 00 00	 DD	 $LN8@DropChaosG
  001c4	00 00 00 00	 DD	 $LN16@DropChaosG
$LN25@DropChaosG:
  001c8	00		 DB	 0
  001c9	01		 DB	 1
  001ca	02		 DB	 2
  001cb	03		 DB	 3
  001cc	04		 DB	 4
  001cd	05		 DB	 5
  001ce	06		 DB	 6
  001cf	08		 DB	 8
  001d0	08		 DB	 8
  001d1	08		 DB	 8
  001d2	08		 DB	 8
  001d3	08		 DB	 8
  001d4	08		 DB	 8
  001d5	08		 DB	 8
  001d6	08		 DB	 8
  001d7	08		 DB	 8
  001d8	08		 DB	 8
  001d9	08		 DB	 8
  001da	08		 DB	 8
  001db	08		 DB	 8
  001dc	08		 DB	 8
  001dd	08		 DB	 8
  001de	08		 DB	 8
  001df	08		 DB	 8
  001e0	08		 DB	 8
  001e1	08		 DB	 8
  001e2	08		 DB	 8
  001e3	08		 DB	 8
  001e4	08		 DB	 8
  001e5	08		 DB	 8
  001e6	08		 DB	 8
  001e7	08		 DB	 8
  001e8	08		 DB	 8
  001e9	08		 DB	 8
  001ea	08		 DB	 8
  001eb	08		 DB	 8
  001ec	08		 DB	 8
  001ed	08		 DB	 8
  001ee	08		 DB	 8
  001ef	08		 DB	 8
  001f0	08		 DB	 8
  001f1	07		 DB	 7
?DropChaosGem@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::DropChaosGem
_TEXT	ENDS
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SendRewardScore@CBloodCastle@@QAEXHHHH@Z	; CBloodCastle::SendRewardScore
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ DB 'Can not co'
	DB	'nnect Ranking Server', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSCORE$ = 12						; size = 4
_iLeftTime$ = 16					; size = 4
_iAlivePartyCount$ = 20					; size = 4
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z PROC		; CBloodCastle::SendRewardScore, COMDAT
; _this$ = ecx

; 3302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 3303 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00013	85 c0		 test	 eax, eax
  00015	0f 88 0f 01 00
	00		 js	 $LN1@SendReward
  0001b	33 c9		 xor	 ecx, ecx
  0001d	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00022	0f 9e c1	 setle	 cl
  00025	85 c9		 test	 ecx, ecx
  00027	0f 84 fd 00 00
	00		 je	 $LN1@SendReward

; 3304 : 	{
; 3305 : 		return;
; 3306 : 	}
; 3307 : 
; 3308 : 	PMSG_ANS_BLOODCASTLESCORE_5TH pMsg;
; 3309 : 
; 3310 : 	pMsg.h.c = 0xC1;
; 3311 : 	pMsg.h.headcode = 0x0D;
; 3312 : 	pMsg.h.size = sizeof(pMsg);
; 3313 : 	pMsg.Score = iSCORE;

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _iSCORE$[ebp]

; 3314 : 	pMsg.BridgeNum = gObj[iIndex].m_cBloodCastleIndex;

  00030	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00036	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+28], ecx
  0003f	c6 45 cc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00043	66 c7 45 cd 30
	0d		 mov	 WORD PTR _pMsg$[ebp+1], 3376 ; 00000d30H
  00049	0f be 88 9e 0e
	00 00		 movsx	 ecx, BYTE PTR [eax+3742]
  00050	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 3315 : 	pMsg.Class = gObj[iIndex].Class;

  00053	0f b7 90 b8 00
	00 00		 movzx	 edx, WORD PTR [eax+184]

; 3316 : 	pMsg.ServerCode = gGameServerCode;

  0005a	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00061	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+32], edx

; 3317 : 	pMsg.iLeftTime = iLeftTime;

  00064	8b 55 10	 mov	 edx, DWORD PTR _iLeftTime$[ebp]
  00067	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+24], ecx
  0006a	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+40], edx

; 3318 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, MAX_ACCOUNT_LEN);

  0006d	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00070	89 4d cf	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  00073	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00076	89 55 d3	 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00079	66 8b 48 74	 mov	 cx, WORD PTR [eax+116]
  0007d	66 89 4d d7	 mov	 WORD PTR _pMsg$[ebp+11], cx

; 3319 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, MAX_ACCOUNT_LEN);

  00081	8b 50 77	 mov	 edx, DWORD PTR [eax+119]
  00084	89 55 d9	 mov	 DWORD PTR _pMsg$[ebp+13], edx
  00087	8b 48 7b	 mov	 ecx, DWORD PTR [eax+123]
  0008a	89 4d dd	 mov	 DWORD PTR _pMsg$[ebp+17], ecx
  0008d	66 8b 50 7f	 mov	 dx, WORD PTR [eax+127]

; 3320 : 	pMsg.iAlivePartyCount = iAlivePartyCount;

  00091	8b 45 14	 mov	 eax, DWORD PTR _iAlivePartyCount$[ebp]
  00094	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+44], eax

; 3321 : 
; 3322 : 	if( ::IsDevilSquareEventConnected == FALSE && ::DevilSquareEventConnect == FALSE )

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?IsDevilSquareEventConnected@@3HA ; IsDevilSquareEventConnected
  0009c	66 89 55 e1	 mov	 WORD PTR _pMsg$[ebp+21], dx
  000a0	85 c0		 test	 eax, eax
  000a2	75 66		 jne	 SHORT $LN3@SendReward
  000a4	39 05 00 00 00
	00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, eax ; DevilSquareEventConnect
  000aa	75 7e		 jne	 SHORT $LN1@SendReward

; 3323 : 	{
; 3324 : 		wsRServerCli.Close();

  000ac	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000b1	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 3325 : 		wsRServerCli.CreateSocket(ghWnd);

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000bc	51		 push	 ecx
  000bd	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000c2	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 3326 : 
; 3327 : 		if ( GMRankingServerConnect(gDevilSquareEventServerIp, WM_GM_RANKING_CLIENT_MSG_PROC) == FALSE )

  000c7	68 0c 04 00 00	 push	 1036			; 0000040cH
  000cc	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  000d1	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000d6	83 c4 08	 add	 esp, 8
  000d9	85 c0		 test	 eax, eax
  000db	75 23		 jne	 SHORT $LN2@SendReward

; 3328 : 		{
; 3329 : 			::IsDevilSquareEventConnected = FALSE;
; 3330 : 			LogAddTD("Can not connect Ranking Server");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
  000e2	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ed	83 c4 04	 add	 esp, 4

; 3341 : 	}
; 3342 : }

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f3	33 cd		 xor	 ecx, ebp
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 10 00	 ret	 16			; 00000010H
$LN2@SendReward:

; 3331 : 
; 3332 : 			return;
; 3333 : 		}
; 3334 : 
; 3335 : 		::IsDevilSquareEventConnected = TRUE;

  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
$LN3@SendReward:

; 3336 : 	}
; 3337 : 
; 3338 : 	if ( ::DevilSquareEventConnect == FALSE && ::IsDevilSquareEventConnected != FALSE )

  0010a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  00111	75 17		 jne	 SHORT $LN1@SendReward
  00113	85 c0		 test	 eax, eax
  00115	74 13		 je	 SHORT $LN1@SendReward

; 3339 : 	{
; 3340 : 		wsRServerCli.DataSend((char *)&pMsg, pMsg.h.size);

  00117	0f b6 55 cd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0011b	52		 push	 edx
  0011c	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0011f	50		 push	 eax
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  00125	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@SendReward:

; 3341 : 	}
; 3342 : }

  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 10 00	 ret	 16			; 00000010H
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ENDP		; CBloodCastle::SendRewardScore
_TEXT	ENDS
PUBLIC	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z	; CBloodCastle::SendBridgeAnyMsg
; Function compile flags: /Ogtp
;	COMDAT ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iBridgeIndex$ = 16					; size = 4
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z PROC	; CBloodCastle::SendBridgeAnyMsg, COMDAT
; _this$ = ecx

; 3345 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3346 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 10	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 6d		 js	 SHORT $LN4@SendBridge
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 61		 je	 SHORT $LN4@SendBridge

; 3347 : 	{
; 3348 : 		return;
; 3349 : 	}
; 3350 : 
; 3351 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00016	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0001c	53		 push	 ebx
  0001d	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	8d 74 08 1c	 lea	 esi, DWORD PTR [eax+ecx+28]
  00026	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  0002b	eb 03 8d 49 00	 npad	 5
$LL6@SendBridge:

; 3352 : 	{
; 3353 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00032	83 f9 ff	 cmp	 ecx, -1
  00035	74 37		 je	 SHORT $LN5@SendBridge

; 3354 : 		{
; 3355 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected == PLAYER_PLAYING )

  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	8b c1		 mov	 eax, ecx
  0003f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00045	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  0004a	75 22		 jne	 SHORT $LN5@SendBridge

; 3356 : 			{
; 3357 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  0004c	80 bc 10 9e 0e
	00 00 ff	 cmp	 BYTE PTR [eax+edx+3742], -1
  00054	74 18		 je	 SHORT $LN5@SendBridge
  00056	80 bc 10 9f 0e
	00 00 ff	 cmp	 BYTE PTR [eax+edx+3743], -1
  0005e	74 0e		 je	 SHORT $LN5@SendBridge

; 3358 : 				{
; 3359 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  00060	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00063	53		 push	 ebx
  00064	50		 push	 eax
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendBridge:

; 3347 : 	{
; 3348 : 		return;
; 3349 : 	}
; 3350 : 
; 3351 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0006e	83 c6 14	 add	 esi, 20			; 00000014H
  00071	4f		 dec	 edi
  00072	75 bc		 jne	 SHORT $LL6@SendBridge
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
$LN4@SendBridge:

; 3360 : 				}
; 3361 : 			}
; 3362 : 		}
; 3363 : 	}
; 3364 : 
; 3365 : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ENDP	; CBloodCastle::SendBridgeAnyMsg
_TEXT	ENDS
PUBLIC	?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z	; CBloodCastle::SendAllUserAnyMsg
; Function compile flags: /Ogtp
;	COMDAT ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z PROC	; CBloodCastle::SendAllUserAnyMsg, COMDAT
; _this$ = ecx

; 3368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3369 : 	for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00013	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL5@SendAllUse:

; 3370 : 	{
; 3371 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 1b		 jne	 SHORT $LN4@SendAllUse

; 3372 : 		{
; 3373 : 			if ( gObj[i].Type == OBJ_USER )

  0001f	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00025	75 13		 jne	 SHORT $LN4@SendAllUse

; 3374 : 			{
; 3375 : 				DataSend(i, lpMsg, iSize);

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002a	53		 push	 ebx
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendAllUse:

; 3369 : 	for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0003a	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00040	47		 inc	 edi
  00041	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00047	7c cf		 jl	 SHORT $LL5@SendAllUse
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 3376 : 			}
; 3377 : 		}
; 3378 : 	}
; 3379 : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ENDP	; CBloodCastle::SendAllUserAnyMsg
_TEXT	ENDS
PUBLIC	??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ ; `string'
PUBLIC	?SetMonsterKillCount@CBloodCastle@@QAEXH@Z	; CBloodCastle::SetMonsterKillCount
;	COMDAT ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
CONST	SEGMENT
??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ DB '['
	DB	'Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Curre'
	DB	'nt Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv640 = -16						; size = 4
tv86 = -12						; size = 4
tv1154 = -8						; size = 4
_iLIVE_USER_COUNT$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetMonsterKillCount, COMDAT
; _this$ = ecx

; 3382 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	57		 push	 edi

; 3383 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 a1 01 00
	00		 js	 $LN10@SetMonster
  00012	33 c0		 xor	 eax, eax
  00014	83 ff 07	 cmp	 edi, 7
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 91 01 00
	00		 je	 $LN10@SetMonster

; 3384 : 	{
; 3385 : 		return;
; 3386 : 	}
; 3387 : 
; 3388 : 	int iTOT_USER_COUNT = 0;

  00022	69 ff 60 04 00
	00		 imul	 edi, 1120		; 00000460H
  00028	03 cf		 add	 ecx, edi
  0002a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	53		 push	 ebx
  00031	56		 push	 esi
  00032	33 f6		 xor	 esi, esi

; 3389 : 	int iLIVE_USER_COUNT = 0;
; 3390 : 	int iKILL_USER_COUNT = 0;

  00034	33 d2		 xor	 edx, edx
  00036	89 4d f0	 mov	 DWORD PTR tv640[ebp], ecx
  00039	83 c1 30	 add	 ecx, 48			; 00000030H
  0003c	89 75 fc	 mov	 DWORD PTR _iLIVE_USER_COUNT$[ebp], esi
  0003f	89 4d f8	 mov	 DWORD PTR tv1154[ebp], ecx
  00042	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR tv86[ebp], 8
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL63@SetMonster:

; 3393 : 	{
; 3394 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 45 f8	 mov	 eax, DWORD PTR tv1154[ebp]
  00053	8b 40 ec	 mov	 eax, DWORD PTR [eax-20]
  00056	83 f8 ff	 cmp	 eax, -1
  00059	74 2e		 je	 SHORT $LN7@SetMonster

; 3395 : 		{
; 3396 : 			iTOT_USER_COUNT++;
; 3397 : 
; 3398 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  0005b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00061	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00064	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  0006b	46		 inc	 esi
  0006c	3c 34		 cmp	 al, 52			; 00000034H
  0006e	74 0d		 je	 SHORT $LN53@SetMonster
  00070	3c 0b		 cmp	 al, 11			; 0000000bH
  00072	72 14		 jb	 SHORT $LN58@SetMonster
  00074	b3 11		 mov	 bl, 17			; 00000011H
  00076	3a d8		 cmp	 bl, al
  00078	1b c0		 sbb	 eax, eax
  0007a	40		 inc	 eax
  0007b	74 0b		 je	 SHORT $LN58@SetMonster
$LN53@SetMonster:

; 3399 : 			{
; 3400 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0007d	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  00081	7e 05		 jle	 SHORT $LN58@SetMonster

; 3401 : 				{
; 3402 : 					iLIVE_USER_COUNT++;

  00083	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3403 : 				}
; 3404 : 				else

  00086	eb 01		 jmp	 SHORT $LN7@SetMonster
$LN58@SetMonster:

; 3405 : 				{
; 3406 : 					iKILL_USER_COUNT++;
; 3407 : 				}
; 3408 : 			}
; 3409 : 			else
; 3410 : 			{
; 3411 : 				iKILL_USER_COUNT++;

  00088	42		 inc	 edx
$LN7@SetMonster:

; 3393 : 	{
; 3394 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00089	8b 4d f8	 mov	 ecx, DWORD PTR tv1154[ebp]
  0008c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008e	83 f8 ff	 cmp	 eax, -1
  00091	74 2e		 je	 SHORT $LN28@SetMonster

; 3395 : 		{
; 3396 : 			iTOT_USER_COUNT++;
; 3397 : 
; 3398 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00093	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00099	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0009c	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  000a3	46		 inc	 esi
  000a4	3c 34		 cmp	 al, 52			; 00000034H
  000a6	74 0d		 je	 SHORT $LN54@SetMonster
  000a8	3c 0b		 cmp	 al, 11			; 0000000bH
  000aa	72 14		 jb	 SHORT $LN59@SetMonster
  000ac	b3 11		 mov	 bl, 17			; 00000011H
  000ae	3a d8		 cmp	 bl, al
  000b0	1b c0		 sbb	 eax, eax
  000b2	40		 inc	 eax
  000b3	74 0b		 je	 SHORT $LN59@SetMonster
$LN54@SetMonster:

; 3399 : 			{
; 3400 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000b5	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  000b9	7e 05		 jle	 SHORT $LN59@SetMonster

; 3401 : 				{
; 3402 : 					iLIVE_USER_COUNT++;

  000bb	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3403 : 				}
; 3404 : 				else

  000be	eb 01		 jmp	 SHORT $LN28@SetMonster
$LN59@SetMonster:

; 3405 : 				{
; 3406 : 					iKILL_USER_COUNT++;
; 3407 : 				}
; 3408 : 			}
; 3409 : 			else
; 3410 : 			{
; 3411 : 				iKILL_USER_COUNT++;

  000c0	42		 inc	 edx
$LN28@SetMonster:

; 3393 : 	{
; 3394 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000c1	8b 45 f8	 mov	 eax, DWORD PTR tv1154[ebp]
  000c4	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	74 2e		 je	 SHORT $LN36@SetMonster

; 3395 : 		{
; 3396 : 			iTOT_USER_COUNT++;
; 3397 : 
; 3398 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  000cc	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000d2	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000d5	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  000dc	46		 inc	 esi
  000dd	3c 34		 cmp	 al, 52			; 00000034H
  000df	74 0d		 je	 SHORT $LN55@SetMonster
  000e1	3c 0b		 cmp	 al, 11			; 0000000bH
  000e3	72 14		 jb	 SHORT $LN60@SetMonster
  000e5	b3 11		 mov	 bl, 17			; 00000011H
  000e7	3a d8		 cmp	 bl, al
  000e9	1b c0		 sbb	 eax, eax
  000eb	40		 inc	 eax
  000ec	74 0b		 je	 SHORT $LN60@SetMonster
$LN55@SetMonster:

; 3399 : 			{
; 3400 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000ee	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  000f2	7e 05		 jle	 SHORT $LN60@SetMonster

; 3401 : 				{
; 3402 : 					iLIVE_USER_COUNT++;

  000f4	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3403 : 				}
; 3404 : 				else

  000f7	eb 01		 jmp	 SHORT $LN36@SetMonster
$LN60@SetMonster:

; 3405 : 				{
; 3406 : 					iKILL_USER_COUNT++;
; 3407 : 				}
; 3408 : 			}
; 3409 : 			else
; 3410 : 			{
; 3411 : 				iKILL_USER_COUNT++;

  000f9	42		 inc	 edx
$LN36@SetMonster:

; 3393 : 	{
; 3394 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000fa	8b 4d f8	 mov	 ecx, DWORD PTR tv1154[ebp]
  000fd	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00100	83 f8 ff	 cmp	 eax, -1
  00103	74 2e		 je	 SHORT $LN44@SetMonster

; 3395 : 		{
; 3396 : 			iTOT_USER_COUNT++;
; 3397 : 
; 3398 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00105	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0010b	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0010e	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  00115	46		 inc	 esi
  00116	3c 34		 cmp	 al, 52			; 00000034H
  00118	74 0d		 je	 SHORT $LN56@SetMonster
  0011a	3c 0b		 cmp	 al, 11			; 0000000bH
  0011c	72 14		 jb	 SHORT $LN61@SetMonster
  0011e	b3 11		 mov	 bl, 17			; 00000011H
  00120	3a d8		 cmp	 bl, al
  00122	1b c0		 sbb	 eax, eax
  00124	40		 inc	 eax
  00125	74 0b		 je	 SHORT $LN61@SetMonster
$LN56@SetMonster:

; 3399 : 			{
; 3400 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00127	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  0012b	7e 05		 jle	 SHORT $LN61@SetMonster

; 3401 : 				{
; 3402 : 					iLIVE_USER_COUNT++;

  0012d	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3403 : 				}
; 3404 : 				else

  00130	eb 01		 jmp	 SHORT $LN44@SetMonster
$LN61@SetMonster:

; 3405 : 				{
; 3406 : 					iKILL_USER_COUNT++;
; 3407 : 				}
; 3408 : 			}
; 3409 : 			else
; 3410 : 			{
; 3411 : 				iKILL_USER_COUNT++;

  00132	42		 inc	 edx
$LN44@SetMonster:

; 3393 : 	{
; 3394 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00133	8b 45 f8	 mov	 eax, DWORD PTR tv1154[ebp]
  00136	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00139	83 f8 ff	 cmp	 eax, -1
  0013c	74 2e		 je	 SHORT $LN52@SetMonster

; 3395 : 		{
; 3396 : 			iTOT_USER_COUNT++;
; 3397 : 
; 3398 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  0013e	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00144	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00147	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  0014e	46		 inc	 esi
  0014f	3c 34		 cmp	 al, 52			; 00000034H
  00151	74 0d		 je	 SHORT $LN57@SetMonster
  00153	3c 0b		 cmp	 al, 11			; 0000000bH
  00155	72 14		 jb	 SHORT $LN62@SetMonster
  00157	b3 11		 mov	 bl, 17			; 00000011H
  00159	3a d8		 cmp	 bl, al
  0015b	1b c0		 sbb	 eax, eax
  0015d	40		 inc	 eax
  0015e	74 0b		 je	 SHORT $LN62@SetMonster
$LN57@SetMonster:

; 3399 : 			{
; 3400 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00160	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  00164	7e 05		 jle	 SHORT $LN62@SetMonster

; 3401 : 				{
; 3402 : 					iLIVE_USER_COUNT++;

  00166	ff 45 fc	 inc	 DWORD PTR _iLIVE_USER_COUNT$[ebp]

; 3403 : 				}
; 3404 : 				else

  00169	eb 01		 jmp	 SHORT $LN52@SetMonster
$LN62@SetMonster:

; 3405 : 				{
; 3406 : 					iKILL_USER_COUNT++;
; 3407 : 				}
; 3408 : 			}
; 3409 : 			else
; 3410 : 			{
; 3411 : 				iKILL_USER_COUNT++;

  0016b	42		 inc	 edx
$LN52@SetMonster:

; 3384 : 	{
; 3385 : 		return;
; 3386 : 	}
; 3387 : 
; 3388 : 	int iTOT_USER_COUNT = 0;

  0016c	83 45 f8 64	 add	 DWORD PTR tv1154[ebp], 100 ; 00000064H

; 3391 : 
; 3392 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00170	ff 4d f4	 dec	 DWORD PTR tv86[ebp]
  00173	0f 85 d7 fe ff
	ff		 jne	 $LL63@SetMonster

; 3412 : 			}
; 3413 : 
; 3414 : 		}
; 3415 : 	}
; 3416 : 
; 3417 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = iLIVE_USER_COUNT * 40;

  00179	8b 4d fc	 mov	 ecx, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  0017c	8b 7d f0	 mov	 edi, DWORD PTR tv640[ebp]

; 3418 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;
; 3419 : 
; 3420 : 	LogAddTD("[Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Current Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT, iTOT_USER_COUNT, iLIVE_USER_COUNT, iKILL_USER_COUNT);

  0017f	52		 push	 edx
  00180	51		 push	 ecx
  00181	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00184	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00187	03 c0		 add	 eax, eax
  00189	56		 push	 esi
  0018a	03 c0		 add	 eax, eax
  0018c	03 c0		 add	 eax, eax
  0018e	6a 00		 push	 0
  00190	50		 push	 eax
  00191	41		 inc	 ecx
  00192	51		 push	 ecx
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
  00198	89 87 cc 03 00
	00		 mov	 DWORD PTR [edi+972], eax
  0019e	c7 87 d0 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+976], 0
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001ae	83 c4 1c	 add	 esp, 28			; 0000001cH
  001b1	5e		 pop	 esi
  001b2	5b		 pop	 ebx
$LN10@SetMonster:
  001b3	5f		 pop	 edi

; 3421 : }

  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c2 04 00	 ret	 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetMonsterKillCount
_TEXT	ENDS
PUBLIC	??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillCount
;	COMDAT ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max K'
	DB	'ill Count:%d / Kill Count:%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillCount, COMDAT
; _this$ = ecx

; 3424 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3425 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 3e		 js	 SHORT $LN1@CheckMonst
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax

; 3426 : 	{
; 3427 : 		return false;

  00014	74 32		 je	 SHORT $LN1@CheckMonst

; 3428 : 	}
; 3429 : 
; 3430 : 	if( this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT )

  00016	8b c2		 mov	 eax, edx
  00018	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0001e	03 c1		 add	 eax, ecx
  00020	8b 88 d0 03 00
	00		 mov	 ecx, DWORD PTR [eax+976]
  00026	8b 80 cc 03 00
	00		 mov	 eax, DWORD PTR [eax+972]
  0002c	3b c8		 cmp	 ecx, eax
  0002e	7c 18		 jl	 SHORT $LN1@CheckMonst

; 3431 : 	{
; 3432 : 		LogAddTD("[Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max Kill Count:%d / Kill Count:%d)", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT);

  00030	51		 push	 ecx
  00031	50		 push	 eax
  00032	42		 inc	 edx
  00033	52		 push	 edx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 3433 : 		return true;

  00042	b0 01		 mov	 al, 1

; 3437 : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN1@CheckMonst:

; 3434 : 	}
; 3435 : 
; 3436 : 	return false;

  00048	32 c0		 xor	 al, al

; 3437 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillCount
_TEXT	ENDS
PUBLIC	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillSuccess
; Function compile flags: /Ogtp
;	COMDAT ?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillSuccess, COMDAT
; _this$ = ecx

; 3440 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3441 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckMonst@2
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckMonst@2
$LN6@CheckMonst@2:

; 3442 : 	{
; 3443 : 		return false;

  00016	32 c0		 xor	 al, al

; 3447 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckMonst@2:

; 3444 : 	}
; 3445 : 
; 3446 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE;

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	8a 84 08 b8 03
	00 00		 mov	 al, BYTE PTR [eax+ecx+952]

; 3447 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillSuccess
_TEXT	ENDS
PUBLIC	??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillCount
;	COMDAT ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success('
	DB	'Max Boss Kill Count:%d / Boss Kill Count:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckBossKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckBossKillCount, COMDAT
; _this$ = ecx

; 3450 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3451 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 3e		 js	 SHORT $LN1@CheckBossK
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax

; 3452 : 	{
; 3453 : 		return false;

  00014	74 32		 je	 SHORT $LN1@CheckBossK

; 3454 : 	}
; 3455 : 
; 3456 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT )

  00016	8b c2		 mov	 eax, edx
  00018	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0001e	03 c1		 add	 eax, ecx
  00020	8b 88 e0 03 00
	00		 mov	 ecx, DWORD PTR [eax+992]
  00026	8b 80 dc 03 00
	00		 mov	 eax, DWORD PTR [eax+988]
  0002c	3b c8		 cmp	 ecx, eax
  0002e	7c 18		 jl	 SHORT $LN1@CheckBossK

; 3457 : 	{
; 3458 : 		LogAddTD("[Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success(Max Boss Kill Count:%d / Boss Kill Count:%d)", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT, this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);

  00030	51		 push	 ecx
  00031	50		 push	 eax
  00032	42		 inc	 edx
  00033	52		 push	 edx
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 3459 : 		return true;

  00042	b0 01		 mov	 al, 1

; 3463 : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN1@CheckBossK:

; 3460 : 	}
; 3461 : 
; 3462 : 	return false;

  00048	32 c0		 xor	 al, al

; 3463 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckBossKillCount
_TEXT	ENDS
PUBLIC	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillSuccess
; Function compile flags: /Ogtp
;	COMDAT ?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckBossKillSuccess, COMDAT
; _this$ = ecx

; 3466 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3467 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckBossK@2
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckBossK@2
$LN6@CheckBossK@2:

; 3468 : 	{
; 3469 : 		return false;

  00016	32 c0		 xor	 al, al

; 3473 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckBossK@2:

; 3470 : 	}
; 3471 : 
; 3472 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE;

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	8a 84 08 b9 03
	00 00		 mov	 al, BYTE PTR [eax+ecx+953]

; 3473 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckBossKillSuccess
_TEXT	ENDS
PUBLIC	?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetWhoGotUltimateWeapon
; Function compile flags: /Ogtp
;	COMDAT ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$220026 = -16					; size = 4
tv275 = -12						; size = 4
_iBridgeUserIndex$ = -8					; size = 4
tv79 = -4						; size = 4
tv389 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWhoGotUltimateWeapon, COMDAT
; _this$ = ecx

; 3584 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3585 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	85 c0		 test	 eax, eax
  0000b	78 0c		 js	 SHORT $LN34@GetWhoGotU
  0000d	33 d2		 xor	 edx, edx
  0000f	83 f8 07	 cmp	 eax, 7
  00012	0f 9e c2	 setle	 dl
  00015	85 d2		 test	 edx, edx
  00017	75 09		 jne	 SHORT $LN16@GetWhoGotU
$LN34@GetWhoGotU:

; 3586 : 	{
; 3587 : 		return -1;

  00019	83 c8 ff	 or	 eax, -1

; 3637 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN16@GetWhoGotU:

; 3588 : 	}
; 3589 : 
; 3590 : 	int iBridgeUserIndex = -1;

  00022	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002e	03 c1		 add	 eax, ecx
  00030	53		 push	 ebx
  00031	89 45 f4	 mov	 DWORD PTR tv275[ebp], eax
  00034	83 c0 1c	 add	 eax, 28			; 0000001cH
  00037	56		 push	 esi
  00038	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iBridgeUserIndex$[ebp], -1
  0003f	89 45 08	 mov	 DWORD PTR tv389[ebp], eax
  00042	c7 45 fc 28 00
	00 00		 mov	 DWORD PTR tv79[ebp], 40	; 00000028H
  00049	b9 01 00 00 00	 mov	 ecx, 1
  0004e	57		 push	 edi
  0004f	90		 npad	 1
$LL15@GetWhoGotU:

; 3593 : 	{
; 3594 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00050	8b 30		 mov	 esi, DWORD PTR [eax]
  00052	89 75 f0	 mov	 DWORD PTR _iIndex$220026[ebp], esi

; 3595 : 
; 3596 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00055	85 f6		 test	 esi, esi
  00057	0f 88 bf 00 00
	00		 js	 $LN14@GetWhoGotU
  0005d	33 c0		 xor	 eax, eax
  0005f	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00065	0f 9e c0	 setle	 al
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 ac 00 00
	00		 je	 $LN14@GetWhoGotU

; 3597 : 		{
; 3598 : 			continue;
; 3599 : 		}
; 3600 : 
; 3601 : 		if( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00070	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00076	66 39 4c 16 68	 cmp	 WORD PTR [esi+edx+104], cx
  0007b	0f 85 9b 00 00
	00		 jne	 $LN14@GetWhoGotU
  00081	83 7c 16 04 02	 cmp	 DWORD PTR [esi+edx+4], 2
  00086	0f 8e 90 00 00
	00		 jle	 $LN14@GetWhoGotU

; 3602 : 		{
; 3603 : 			continue;
; 3604 : 		}
; 3605 : 
; 3606 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0008c	0f b6 84 16 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+329]
  00094	3c 34		 cmp	 al, 52			; 00000034H
  00096	74 11		 je	 SHORT $LN35@GetWhoGotU
  00098	3c 0b		 cmp	 al, 11			; 0000000bH
  0009a	0f 82 7c 00 00
	00		 jb	 $LN14@GetWhoGotU
  000a0	b1 11		 mov	 cl, 17			; 00000011H
  000a2	3a c8		 cmp	 cl, al
  000a4	1b c0		 sbb	 eax, eax
  000a6	40		 inc	 eax
  000a7	74 73		 je	 SHORT $LN14@GetWhoGotU
$LN35@GetWhoGotU:

; 3607 : 		{
; 3608 : 			continue;
; 3609 : 		}
; 3610 : 
; 3611 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  000a9	33 ff		 xor	 edi, edi
  000ab	eb 03 8d 49 00	 npad	 5
$LL37@GetWhoGotU:

; 3612 : 		{
; 3613 : 			if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  000b0	8b 8c 16 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+edx+3620]
  000b7	03 cf		 add	 ecx, edi
  000b9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	83 f8 01	 cmp	 eax, 1
  000c7	75 3d		 jne	 SHORT $LN7@GetWhoGotU

; 3614 : 			{
; 3615 : 				if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  000c9	8b 84 16 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+edx+3620]
  000d0	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  000d5	66 39 4c 38 06	 cmp	 WORD PTR [eax+edi+6], cx
  000da	75 2a		 jne	 SHORT $LN7@GetWhoGotU

; 3616 : 				{
; 3617 : 					int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  000dc	0f bf 4c 38 08	 movsx	 ecx, WORD PTR [eax+edi+8]

; 3618 : 
; 3619 : 					if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  000e1	85 c9		 test	 ecx, ecx
  000e3	78 21		 js	 SHORT $LN7@GetWhoGotU
  000e5	33 db		 xor	 ebx, ebx
  000e7	83 f9 02	 cmp	 ecx, 2
  000ea	0f 9e c3	 setle	 bl
  000ed	8b cb		 mov	 ecx, ebx
  000ef	85 c9		 test	 ecx, ecx
  000f1	74 13		 je	 SHORT $LN7@GetWhoGotU

; 3620 : 					{
; 3621 : 						if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1 )

  000f3	8b 4d f4	 mov	 ecx, DWORD PTR tv275[ebp]
  000f6	8b 89 e8 03 00
	00		 mov	 ecx, DWORD PTR [ecx+1000]
  000fc	83 f9 ff	 cmp	 ecx, -1
  000ff	74 05		 je	 SHORT $LN7@GetWhoGotU

; 3622 : 						{
; 3623 : 							if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  00101	3b 0c 38	 cmp	 ecx, DWORD PTR [eax+edi]
  00104	74 10		 je	 SHORT $LN31@GetWhoGotU
$LN7@GetWhoGotU:

; 3607 : 		{
; 3608 : 			continue;
; 3609 : 		}
; 3610 : 
; 3611 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  00106	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0010c	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  00112	7c 9c		 jl	 SHORT $LL37@GetWhoGotU

; 3622 : 						{
; 3623 : 							if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  00114	eb 06		 jmp	 SHORT $LN14@GetWhoGotU
$LN31@GetWhoGotU:

; 3624 : 							{
; 3625 : 								iBridgeUserIndex = iIndex;

  00116	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$220026[ebp]
  00119	89 45 f8	 mov	 DWORD PTR _iBridgeUserIndex$[ebp], eax
$LN14@GetWhoGotU:

; 3591 : 
; 3592 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0011c	8b 45 08	 mov	 eax, DWORD PTR tv389[ebp]
  0011f	83 c0 14	 add	 eax, 20			; 00000014H
  00122	b9 01 00 00 00	 mov	 ecx, 1
  00127	29 4d fc	 sub	 DWORD PTR tv79[ebp], ecx
  0012a	89 45 08	 mov	 DWORD PTR tv389[ebp], eax
  0012d	0f 85 1d ff ff
	ff		 jne	 $LL15@GetWhoGotU

; 3626 : 								break;
; 3627 : 							}
; 3628 : 						}
; 3629 : 					}
; 3630 : 				}
; 3631 : 			}
; 3632 : 		}
; 3633 : 
; 3634 : 	}
; 3635 : 
; 3636 : 	return iBridgeUserIndex;

  00133	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeUserIndex$[ebp]
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx

; 3637 : }

  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 04 00	 ret	 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWhoGotUltimateWeapon
_TEXT	ENDS
PUBLIC	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentLiveUserCount
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv650 = -4						; size = 4
_iRetLiveUserCount$ = 8					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetCurrentLiveUserCount, COMDAT
; _this$ = ecx

; 3640 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3641 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 d2		 test	 edx, edx
  00009	78 0c		 js	 SHORT $LN50@GetCurrent@2
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fa 07	 cmp	 edx, 7
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 09		 jne	 SHORT $LN8@GetCurrent@2
$LN50@GetCurrent@2:

; 3642 : 	{
; 3643 : 		return -1;

  00017	83 c8 ff	 or	 eax, -1

; 3674 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN8@GetCurrent@2:

; 3644 : 	}
; 3645 : 
; 3646 : 	int iRetLiveUserCount = 0;

  00020	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	57		 push	 edi
  0002f	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iRetLiveUserCount$[ebp], 0
  00036	8d 7c 0a 30	 lea	 edi, DWORD PTR [edx+ecx+48]
  0003a	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR tv650[ebp], 8
  00041	bb 01 00 00 00	 mov	 ebx, 1
$LL61@GetCurrent@2:

; 3649 : 	{
; 3650 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00046	8b 4f ec	 mov	 ecx, DWORD PTR [edi-20]

; 3651 : 
; 3652 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00049	85 c9		 test	 ecx, ecx
  0004b	78 41		 js	 SHORT $LN6@GetCurrent@2
  0004d	33 d2		 xor	 edx, edx
  0004f	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00055	0f 9e c2	 setle	 dl
  00058	85 d2		 test	 edx, edx
  0005a	74 32		 je	 SHORT $LN6@GetCurrent@2

; 3653 : 		{
; 3654 : 			continue;
; 3655 : 		}
; 3656 : 
; 3657 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0005c	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00062	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00065	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  0006c	80 f9 34	 cmp	 cl, 52			; 00000034H
  0006f	74 0e		 je	 SHORT $LN51@GetCurrent@2
  00071	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00074	72 18		 jb	 SHORT $LN6@GetCurrent@2
  00076	b0 11		 mov	 al, 17			; 00000011H
  00078	3a c1		 cmp	 al, cl
  0007a	1b c9		 sbb	 ecx, ecx
  0007c	41		 inc	 ecx
  0007d	74 0f		 je	 SHORT $LN6@GetCurrent@2
$LN51@GetCurrent@2:

; 3658 : 		{
; 3659 : 			continue;
; 3660 : 		}
; 3661 : 
; 3662 : 		if( gObj[iIndex].Type != OBJ_USER  )

  0007f	66 39 5a 68	 cmp	 WORD PTR [edx+104], bx
  00083	75 09		 jne	 SHORT $LN6@GetCurrent@2

; 3663 : 		{
; 3664 : 			continue;
; 3665 : 		}
; 3666 : 
; 3667 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  00085	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  00089	7e 03		 jle	 SHORT $LN6@GetCurrent@2

; 3668 : 		{
; 3669 : 			iRetLiveUserCount++;

  0008b	01 5d 08	 add	 DWORD PTR _iRetLiveUserCount$[ebp], ebx
$LN6@GetCurrent@2:

; 3649 : 	{
; 3650 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  0008e	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 3651 : 
; 3652 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00090	85 c9		 test	 ecx, ecx
  00092	78 41		 js	 SHORT $LN57@GetCurrent@2
  00094	33 d2		 xor	 edx, edx
  00096	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0009c	0f 9e c2	 setle	 dl
  0009f	85 d2		 test	 edx, edx
  000a1	74 32		 je	 SHORT $LN57@GetCurrent@2

; 3653 : 		{
; 3654 : 			continue;
; 3655 : 		}
; 3656 : 
; 3657 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  000a3	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000a9	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  000ac	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  000b3	80 f9 34	 cmp	 cl, 52			; 00000034H
  000b6	74 0e		 je	 SHORT $LN52@GetCurrent@2
  000b8	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000bb	72 18		 jb	 SHORT $LN57@GetCurrent@2
  000bd	b0 11		 mov	 al, 17			; 00000011H
  000bf	3a c1		 cmp	 al, cl
  000c1	1b c9		 sbb	 ecx, ecx
  000c3	41		 inc	 ecx
  000c4	74 0f		 je	 SHORT $LN57@GetCurrent@2
$LN52@GetCurrent@2:

; 3658 : 		{
; 3659 : 			continue;
; 3660 : 		}
; 3661 : 
; 3662 : 		if( gObj[iIndex].Type != OBJ_USER  )

  000c6	66 39 5a 68	 cmp	 WORD PTR [edx+104], bx
  000ca	75 09		 jne	 SHORT $LN57@GetCurrent@2

; 3663 : 		{
; 3664 : 			continue;
; 3665 : 		}
; 3666 : 
; 3667 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  000cc	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  000d0	7e 03		 jle	 SHORT $LN57@GetCurrent@2

; 3668 : 		{
; 3669 : 			iRetLiveUserCount++;

  000d2	01 5d 08	 add	 DWORD PTR _iRetLiveUserCount$[ebp], ebx
$LN57@GetCurrent@2:

; 3649 : 	{
; 3650 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  000d5	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]

; 3651 : 
; 3652 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  000d8	85 c9		 test	 ecx, ecx
  000da	78 41		 js	 SHORT $LN58@GetCurrent@2
  000dc	33 d2		 xor	 edx, edx
  000de	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  000e4	0f 9e c2	 setle	 dl
  000e7	85 d2		 test	 edx, edx
  000e9	74 32		 je	 SHORT $LN58@GetCurrent@2

; 3653 : 		{
; 3654 : 			continue;
; 3655 : 		}
; 3656 : 
; 3657 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  000eb	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000f1	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  000f4	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  000fb	80 f9 34	 cmp	 cl, 52			; 00000034H
  000fe	74 0e		 je	 SHORT $LN53@GetCurrent@2
  00100	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00103	72 18		 jb	 SHORT $LN58@GetCurrent@2
  00105	b0 11		 mov	 al, 17			; 00000011H
  00107	3a c1		 cmp	 al, cl
  00109	1b c9		 sbb	 ecx, ecx
  0010b	41		 inc	 ecx
  0010c	74 0f		 je	 SHORT $LN58@GetCurrent@2
$LN53@GetCurrent@2:

; 3658 : 		{
; 3659 : 			continue;
; 3660 : 		}
; 3661 : 
; 3662 : 		if( gObj[iIndex].Type != OBJ_USER  )

  0010e	66 39 5a 68	 cmp	 WORD PTR [edx+104], bx
  00112	75 09		 jne	 SHORT $LN58@GetCurrent@2

; 3663 : 		{
; 3664 : 			continue;
; 3665 : 		}
; 3666 : 
; 3667 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  00114	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  00118	7e 03		 jle	 SHORT $LN58@GetCurrent@2

; 3668 : 		{
; 3669 : 			iRetLiveUserCount++;

  0011a	01 5d 08	 add	 DWORD PTR _iRetLiveUserCount$[ebp], ebx
$LN58@GetCurrent@2:

; 3649 : 	{
; 3650 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  0011d	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]

; 3651 : 
; 3652 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00120	85 c9		 test	 ecx, ecx
  00122	78 41		 js	 SHORT $LN59@GetCurrent@2
  00124	33 d2		 xor	 edx, edx
  00126	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0012c	0f 9e c2	 setle	 dl
  0012f	85 d2		 test	 edx, edx
  00131	74 32		 je	 SHORT $LN59@GetCurrent@2

; 3653 : 		{
; 3654 : 			continue;
; 3655 : 		}
; 3656 : 
; 3657 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  00133	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00139	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  0013c	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  00143	80 f9 34	 cmp	 cl, 52			; 00000034H
  00146	74 0e		 je	 SHORT $LN54@GetCurrent@2
  00148	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0014b	72 18		 jb	 SHORT $LN59@GetCurrent@2
  0014d	b0 11		 mov	 al, 17			; 00000011H
  0014f	3a c1		 cmp	 al, cl
  00151	1b c9		 sbb	 ecx, ecx
  00153	41		 inc	 ecx
  00154	74 0f		 je	 SHORT $LN59@GetCurrent@2
$LN54@GetCurrent@2:

; 3658 : 		{
; 3659 : 			continue;
; 3660 : 		}
; 3661 : 
; 3662 : 		if( gObj[iIndex].Type != OBJ_USER  )

  00156	66 39 5a 68	 cmp	 WORD PTR [edx+104], bx
  0015a	75 09		 jne	 SHORT $LN59@GetCurrent@2

; 3663 : 		{
; 3664 : 			continue;
; 3665 : 		}
; 3666 : 
; 3667 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  0015c	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  00160	7e 03		 jle	 SHORT $LN59@GetCurrent@2

; 3668 : 		{
; 3669 : 			iRetLiveUserCount++;

  00162	01 5d 08	 add	 DWORD PTR _iRetLiveUserCount$[ebp], ebx
$LN59@GetCurrent@2:

; 3649 : 	{
; 3650 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00165	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]

; 3651 : 
; 3652 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00168	85 c9		 test	 ecx, ecx
  0016a	78 41		 js	 SHORT $LN60@GetCurrent@2
  0016c	33 d2		 xor	 edx, edx
  0016e	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00174	0f 9e c2	 setle	 dl
  00177	85 d2		 test	 edx, edx
  00179	74 32		 je	 SHORT $LN60@GetCurrent@2

; 3653 : 		{
; 3654 : 			continue;
; 3655 : 		}
; 3656 : 
; 3657 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0017b	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00181	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00184	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  0018b	80 f9 34	 cmp	 cl, 52			; 00000034H
  0018e	74 0e		 je	 SHORT $LN55@GetCurrent@2
  00190	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00193	72 18		 jb	 SHORT $LN60@GetCurrent@2
  00195	b0 11		 mov	 al, 17			; 00000011H
  00197	3a c1		 cmp	 al, cl
  00199	1b c9		 sbb	 ecx, ecx
  0019b	41		 inc	 ecx
  0019c	74 0f		 je	 SHORT $LN60@GetCurrent@2
$LN55@GetCurrent@2:

; 3658 : 		{
; 3659 : 			continue;
; 3660 : 		}
; 3661 : 
; 3662 : 		if( gObj[iIndex].Type != OBJ_USER  )

  0019e	66 39 5a 68	 cmp	 WORD PTR [edx+104], bx
  001a2	75 09		 jne	 SHORT $LN60@GetCurrent@2

; 3663 : 		{
; 3664 : 			continue;
; 3665 : 		}
; 3666 : 
; 3667 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  001a4	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  001a8	7e 03		 jle	 SHORT $LN60@GetCurrent@2

; 3668 : 		{
; 3669 : 			iRetLiveUserCount++;

  001aa	01 5d 08	 add	 DWORD PTR _iRetLiveUserCount$[ebp], ebx
$LN60@GetCurrent@2:

; 3644 : 	}
; 3645 : 
; 3646 : 	int iRetLiveUserCount = 0;

  001ad	83 c7 64	 add	 edi, 100		; 00000064H

; 3647 : 
; 3648 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  001b0	29 5d fc	 sub	 DWORD PTR tv650[ebp], ebx
  001b3	0f 85 8d fe ff
	ff		 jne	 $LL61@GetCurrent@2

; 3670 : 		}
; 3671 : 	}
; 3672 : 
; 3673 : 	return iRetLiveUserCount;

  001b9	8b 45 08	 mov	 eax, DWORD PTR _iRetLiveUserCount$[ebp]
  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx

; 3674 : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c2 04 00	 ret	 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetCurrentLiveUserCount
_TEXT	ENDS
PUBLIC	?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckUserHaveUlimateWeapon
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckUserHaveUlimateWeapon, COMDAT
; _this$ = ecx

; 3767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 3768 : 	if ( OBJMAX_RANGE(iIndex ) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 88 a2 00 00
	00		 js	 $LN7@CheckUserH
  0000f	33 c0		 xor	 eax, eax
  00011	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax

; 3769 : 	{
; 3770 : 		return false;

  0001c	0f 84 8f 00 00
	00		 je	 $LN7@CheckUserH

; 3771 : 	}
; 3772 : 
; 3773 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0002e	66 83 7c 0f 68
	01		 cmp	 WORD PTR [edi+ecx+104], 1
  00034	75 7b		 jne	 SHORT $LN7@CheckUserH
  00036	83 7c 0f 04 02	 cmp	 DWORD PTR [edi+ecx+4], 2
  0003b	7e 74		 jle	 SHORT $LN7@CheckUserH

; 3776 : 	}
; 3777 : 
; 3778 : 	bool bRetVal = false;

  0003d	53		 push	 ebx
  0003e	56		 push	 esi
  0003f	32 db		 xor	 bl, bl
  00041	33 f6		 xor	 esi, esi
  00043	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL6@CheckUserH:

; 3781 : 	{
; 3782 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00050	8b 8c 0f 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+3620]
  00057	03 ce		 add	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	83 f8 01	 cmp	 eax, 1
  00067	75 26		 jne	 SHORT $LN5@CheckUserH

; 3783 : 		{
; 3784 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(0,19) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(5,10) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(4,18) )

  00069	8b 84 0f 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3620]
  00070	0f b7 44 30 06	 movzx	 eax, WORD PTR [eax+esi+6]
  00075	66 83 f8 13	 cmp	 ax, 19			; 00000013H
  00079	74 2b		 je	 SHORT $LN1@CheckUserH
  0007b	ba 0a 0a 00 00	 mov	 edx, 2570		; 00000a0aH
  00080	66 3b c2	 cmp	 ax, dx
  00083	74 21		 je	 SHORT $LN1@CheckUserH
  00085	ba 12 08 00 00	 mov	 edx, 2066		; 00000812H
  0008a	66 3b c2	 cmp	 ax, dx
  0008d	74 17		 je	 SHORT $LN1@CheckUserH
$LN5@CheckUserH:

; 3779 : 
; 3780 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  0008f	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00095	81 fe 70 c3 00
	00		 cmp	 esi, 50032		; 0000c370H
  0009b	7c b3		 jl	 SHORT $LL6@CheckUserH

; 3787 : 				break;
; 3788 : 			}
; 3789 : 		}
; 3790 : 	}
; 3791 : 
; 3792 : 	return bRetVal;

  0009d	5e		 pop	 esi
  0009e	8a c3		 mov	 al, bl
  000a0	5b		 pop	 ebx
  000a1	5f		 pop	 edi

; 3793 : }

  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
$LN1@CheckUserH:

; 3785 : 			{
; 3786 : 				bRetVal = true;

  000a6	b3 01		 mov	 bl, 1
  000a8	5e		 pop	 esi

; 3787 : 				break;
; 3788 : 			}
; 3789 : 		}
; 3790 : 	}
; 3791 : 
; 3792 : 	return bRetVal;

  000a9	8a c3		 mov	 al, bl
  000ab	5b		 pop	 ebx
  000ac	5f		 pop	 edi

; 3793 : }

  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN7@CheckUserH:

; 3774 : 	{
; 3775 : 		return false;

  000b1	32 c0		 xor	 al, al
  000b3	5f		 pop	 edi

; 3793 : }

  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckUserHaveUlimateWeapon
_TEXT	ENDS
PUBLIC	?CheckWinnerExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerExist
; Function compile flags: /Ogtp
;	COMDAT ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerExist, COMDAT
; _this$ = ecx

; 3796 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3797 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN7@CheckWinne
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN2@CheckWinne
$LN7@CheckWinne:

; 3798 : 		return false;

  00016	32 c0		 xor	 al, al

; 3801 : 		return true;
; 3802 : 
; 3803 : 	return false;
; 3804 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@CheckWinne:

; 3799 : 
; 3800 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX != -1 )

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	83 bc 08 58 04
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+1112], -1
  0002a	0f 95 c0	 setne	 al

; 3801 : 		return true;
; 3802 : 
; 3803 : 	return false;
; 3804 : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerExist
_TEXT	ENDS
PUBLIC	??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	?CheckWinnerValid@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerValid
;	COMDAT ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m'
	DB	'_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBlood'
	DB	'CastleIndex == -1) ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_US'
	DB	'ER_INDEX].MapNumber)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIs'
	DB	'Connected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDE'
	DB	'X)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_Bridg'
	DB	'eData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerValid, COMDAT
; _this$ = ecx

; 3807 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 3808 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0c		 js	 SHORT $LN15@CheckWinne@2
  0000b	33 c0		 xor	 eax, eax
  0000d	83 ff 07	 cmp	 edi, 7
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 17		 jne	 SHORT $LN6@CheckWinne@2
$LN15@CheckWinne@2:

; 3809 : 	{
; 3810 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)", iBridgeIndex+1);

  00017	47		 inc	 edi
  00018	57		 push	 edi
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00024	83 c4 08	 add	 esp, 8

; 3811 : 		return false;

  00027	32 c0		 xor	 al, al
  00029	5f		 pop	 edi

; 3839 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN6@CheckWinne@2:

; 3812 : 	}
; 3813 : 
; 3814 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1 )

  0002e	8b c7		 mov	 eax, edi
  00030	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00036	56		 push	 esi
  00037	8d b4 08 58 04
	00 00		 lea	 esi, DWORD PTR [eax+ecx+1112]
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	83 f8 ff	 cmp	 eax, -1
  00043	75 18		 jne	 SHORT $LN5@CheckWinne@2

; 3815 : 	{
; 3816 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1", iBridgeIndex+1);

  00045	47		 inc	 edi
  00046	57		 push	 edi
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 3827 : 	{
; 3828 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...", iBridgeIndex+1);

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00052	83 c4 08	 add	 esp, 8
  00055	5e		 pop	 esi

; 3829 : 		return false;

  00056	32 c0		 xor	 al, al
  00058	5f		 pop	 edi

; 3839 : }

  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN5@CheckWinne@2:

; 3817 : 		return false;
; 3818 : 	}
; 3819 : 
; 3820 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) )

  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00063	83 c4 04	 add	 esp, 4
  00066	85 c0		 test	 eax, eax
  00068	75 18		 jne	 SHORT $LN4@CheckWinne@2

; 3821 : 	{
; 3822 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)", iBridgeIndex+1);

  0006a	47		 inc	 edi
  0006b	57		 push	 edi
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 3827 : 	{
; 3828 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...", iBridgeIndex+1);

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00077	83 c4 08	 add	 esp, 8
  0007a	5e		 pop	 esi

; 3829 : 		return false;

  0007b	32 c0		 xor	 al, al
  0007d	5f		 pop	 edi

; 3839 : }

  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN4@CheckWinne@2:

; 3823 : 		return false;
; 3824 : 	}
; 3825 : 
; 3826 : 	if ( gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleSubIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex != iBridgeIndex )

  00082	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00084	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008a	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00090	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00093	8a 88 9e 0e 00
	00		 mov	 cl, BYTE PTR [eax+3742]
  00099	80 f9 ff	 cmp	 cl, -1
  0009c	74 48		 je	 SHORT $LN2@CheckWinne@2
  0009e	80 b8 9f 0e 00
	00 ff		 cmp	 BYTE PTR [eax+3743], -1
  000a5	74 3f		 je	 SHORT $LN2@CheckWinne@2
  000a7	0f be c9	 movsx	 ecx, cl
  000aa	3b cf		 cmp	 ecx, edi
  000ac	75 38		 jne	 SHORT $LN2@CheckWinne@2

; 3830 : 	}
; 3831 : 
; 3832 : 	if ( !BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber) )

  000ae	0f b6 80 49 01
	00 00		 movzx	 eax, BYTE PTR [eax+329]
  000b5	3c 34		 cmp	 al, 52			; 00000034H
  000b7	74 25		 je	 SHORT $LN1@CheckWinne@2
  000b9	3c 0b		 cmp	 al, 11			; 0000000bH
  000bb	72 09		 jb	 SHORT $LN16@CheckWinne@2
  000bd	b2 11		 mov	 dl, 17			; 00000011H
  000bf	3a d0		 cmp	 dl, al
  000c1	1b c0		 sbb	 eax, eax
  000c3	40		 inc	 eax
  000c4	75 18		 jne	 SHORT $LN1@CheckWinne@2
$LN16@CheckWinne@2:

; 3833 : 	{
; 3834 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)", iBridgeIndex+1);

  000c6	47		 inc	 edi
  000c7	57		 push	 edi
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d3	83 c4 08	 add	 esp, 8
  000d6	5e		 pop	 esi
  000d7	32 c0		 xor	 al, al
  000d9	5f		 pop	 edi

; 3839 : }

  000da	5d		 pop	 ebp
  000db	c2 04 00	 ret	 4
$LN1@CheckWinne@2:
  000de	5e		 pop	 esi

; 3835 : 		return false;
; 3836 : 	}
; 3837 : 
; 3838 : 	return true;

  000df	b0 01		 mov	 al, 1
  000e1	5f		 pop	 edi

; 3839 : }

  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
$LN2@CheckWinne@2:

; 3827 : 	{
; 3828 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...", iBridgeIndex+1);

  000e6	47		 inc	 edi
  000e7	57		 push	 edi
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f3	83 c4 08	 add	 esp, 8
  000f6	5e		 pop	 esi

; 3829 : 		return false;

  000f7	32 c0		 xor	 al, al
  000f9	5f		 pop	 edi

; 3839 : }

  000fa	5d		 pop	 ebp
  000fb	c2 04 00	 ret	 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerValid
_TEXT	ENDS
PUBLIC	?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserWinnerParty
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserWinnerParty, COMDAT
; _this$ = ecx

; 3842 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3843 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN11@CheckUserW
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN4@CheckUserW
$LN11@CheckUserW:

; 3844 : 		return false;

  00016	32 c0		 xor	 al, al

; 3859 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN4@CheckUserW:

; 3845 : 
; 3846 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) == FALSE )

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	57		 push	 edi
  00023	8d bc 08 58 04
	00 00		 lea	 edi, DWORD PTR [eax+ecx+1112]
  0002a	8b 07		 mov	 eax, DWORD PTR [edi]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN3@CheckUserW

; 3847 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	5f		 pop	 edi

; 3859 : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN3@CheckUserW:
  00040	56		 push	 esi

; 3848 : 
; 3849 : 	if ( gObjIsConnected(iIndex) == FALSE )

  00041	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004a	83 c4 04	 add	 esp, 4
  0004d	85 c0		 test	 eax, eax

; 3850 : 		return false;

  0004f	74 40		 je	 SHORT $LN1@CheckUserW

; 3851 : 
; 3852 : 	int iPartyIndex1 = gObj[iIndex].PartyNumber;
; 3853 : 	int iPartyIndex2 = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00051	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00053	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00064	8b b4 06 2c 04
	00 00		 mov	 esi, DWORD PTR [esi+eax+1068]
  0006b	8b 84 01 2c 04
	00 00		 mov	 eax, DWORD PTR [ecx+eax+1068]

; 3854 : 
; 3855 : 	if ( OBJMAX_RANGE(iPartyIndex1) != FALSE && iPartyIndex1 == iPartyIndex2 )

  00072	85 f6		 test	 esi, esi
  00074	78 1b		 js	 SHORT $LN1@CheckUserW
  00076	33 c9		 xor	 ecx, ecx
  00078	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0007e	0f 9e c1	 setle	 cl
  00081	85 c9		 test	 ecx, ecx
  00083	74 0c		 je	 SHORT $LN1@CheckUserW
  00085	3b f0		 cmp	 esi, eax
  00087	75 08		 jne	 SHORT $LN1@CheckUserW

; 3856 : 		return true;

  00089	5e		 pop	 esi
  0008a	b0 01		 mov	 al, 1
  0008c	5f		 pop	 edi

; 3859 : }

  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
$LN1@CheckUserW:
  00091	5e		 pop	 esi

; 3857 : 
; 3858 : 	return false;

  00092	32 c0		 xor	 al, al
  00094	5f		 pop	 edi

; 3859 : }

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserWinnerParty
_TEXT	ENDS
PUBLIC	?CheckPartyExist@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPartyExist
; Function compile flags: /Ogtp
;	COMDAT ?CheckPartyExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPartyExist, COMDAT
; _this$ = ecx

; 3862 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3863 : 	if ( !gObjIsConnected(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 07		 jne	 SHORT $LN9@CheckParty
$LN23@CheckParty:

; 3864 : 		return false;

  00014	32 c0		 xor	 al, al
  00016	5e		 pop	 esi

; 3892 : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN9@CheckParty:

; 3865 : 
; 3866 : 	int iPartyIndex = gObj[iIndex].PartyNumber;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00026	8b 84 06 2c 04
	00 00		 mov	 eax, DWORD PTR [esi+eax+1068]

; 3867 : 	int iUserIndex;
; 3868 : 
; 3869 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0002d	85 c0		 test	 eax, eax
  0002f	78 e3		 js	 SHORT $LN23@CheckParty
  00031	33 c9		 xor	 ecx, ecx
  00033	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00038	0f 9e c1	 setle	 cl
  0003b	85 c9		 test	 ecx, ecx

; 3870 : 		return false;

  0003d	74 d5		 je	 SHORT $LN23@CheckParty

; 3871 : 
; 3872 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  0003f	6b c0 68	 imul	 eax, 104		; 00000068H
  00042	53		 push	 ebx
  00043	57		 push	 edi
  00044	33 ff		 xor	 edi, edi
  00046	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  0004b	8b d8		 mov	 ebx, eax
  0004d	8d 49 00	 npad	 3
$LL7@CheckParty:

; 3873 : 	{
; 3874 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00050	8b 33		 mov	 esi, DWORD PTR [ebx]

; 3875 : 
; 3876 : 		if ( gObjIsConnected(iUserIndex))

  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00058	83 c4 04	 add	 esp, 4
  0005b	85 c0		 test	 eax, eax
  0005d	74 4d		 je	 SHORT $LN6@CheckParty

; 3877 : 		{
; 3878 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00065	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0006b	0f b6 84 31 49
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+329]
  00073	03 ce		 add	 ecx, esi
  00075	3c 34		 cmp	 al, 52			; 00000034H
  00077	74 0d		 je	 SHORT $LN24@CheckParty
  00079	3c 0b		 cmp	 al, 11			; 0000000bH
  0007b	72 2f		 jb	 SHORT $LN6@CheckParty
  0007d	b2 11		 mov	 dl, 17			; 00000011H
  0007f	3a d0		 cmp	 dl, al
  00081	1b c0		 sbb	 eax, eax
  00083	40		 inc	 eax
  00084	74 26		 je	 SHORT $LN6@CheckParty
$LN24@CheckParty:
  00086	8a 81 9e 0e 00
	00		 mov	 al, BYTE PTR [ecx+3742]
  0008c	84 c0		 test	 al, al
  0008e	78 1c		 js	 SHORT $LN6@CheckParty
  00090	33 d2		 xor	 edx, edx
  00092	3c 07		 cmp	 al, 7
  00094	0f 9e c2	 setle	 dl
  00097	8b c2		 mov	 eax, edx
  00099	85 c0		 test	 eax, eax
  0009b	74 0f		 je	 SHORT $LN6@CheckParty

; 3879 : 			{
; 3880 : 				if ( gObj[iUserIndex].Live == 1 )

  0009d	80 79 6a 01	 cmp	 BYTE PTR [ecx+106], 1
  000a1	75 09		 jne	 SHORT $LN6@CheckParty

; 3881 : 				{
; 3882 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  000a3	80 b9 a4 0e 00
	00 00		 cmp	 BYTE PTR [ecx+3748], 0
  000aa	74 12		 je	 SHORT $LN21@CheckParty
$LN6@CheckParty:

; 3871 : 
; 3872 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000ac	47		 inc	 edi
  000ad	83 c3 04	 add	 ebx, 4
  000b0	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  000b3	7c 9b		 jl	 SHORT $LL7@CheckParty

; 3885 : 					}
; 3886 : 				}
; 3887 : 			}
; 3888 : 		}
; 3889 : 	}
; 3890 : 
; 3891 : 	return false;

  000b5	5f		 pop	 edi
  000b6	5b		 pop	 ebx
  000b7	32 c0		 xor	 al, al
  000b9	5e		 pop	 esi

; 3892 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN21@CheckParty:
  000be	5f		 pop	 edi
  000bf	5b		 pop	 ebx

; 3883 : 					{
; 3884 : 						return true;

  000c0	b0 01		 mov	 al, 1
  000c2	5e		 pop	 esi

; 3892 : }

  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPartyExist
_TEXT	ENDS
PUBLIC	?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
; Function compile flags: /Ogtp
;	COMDAT ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckWinnerPartyComplete, COMDAT
; _this$ = ecx

; 3895 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3896 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN26@CheckWinne@3
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN10@CheckWinne@3
$LN26@CheckWinne@3:

; 3897 : 		return false;

  00016	32 c0		 xor	 al, al

; 3928 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN10@CheckWinne@3:

; 3898 : 
; 3899 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	56		 push	 esi
  00023	8d b4 08 58 04
	00 00		 lea	 esi, DWORD PTR [eax+ecx+1112]
  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN9@CheckWinne@3

; 3900 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 3928 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN9@CheckWinne@3:

; 3901 : 
; 3902 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00040	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0004e	8b 84 11 2c 04
	00 00		 mov	 eax, DWORD PTR [ecx+edx+1068]

; 3903 : 	int iUserIndex;
; 3904 : 
; 3905 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  00055	85 c0		 test	 eax, eax
  00057	78 0e		 js	 SHORT $LN27@CheckWinne@3
  00059	33 c9		 xor	 ecx, ecx
  0005b	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00060	0f 9e c1	 setle	 cl
  00063	85 c9		 test	 ecx, ecx
  00065	75 07		 jne	 SHORT $LN8@CheckWinne@3
$LN27@CheckWinne@3:

; 3906 : 		return true;

  00067	b0 01		 mov	 al, 1
  00069	5e		 pop	 esi

; 3928 : }

  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN8@CheckWinne@3:

; 3907 : 
; 3908 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  0006e	6b c0 68	 imul	 eax, 104		; 00000068H
  00071	53		 push	 ebx
  00072	57		 push	 edi
  00073	33 ff		 xor	 edi, edi
  00075	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  0007a	8b d8		 mov	 ebx, eax
  0007c	8d 64 24 00	 npad	 4
$LL7@CheckWinne@3:

; 3909 : 	{
; 3910 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00080	8b 33		 mov	 esi, DWORD PTR [ebx]

; 3911 : 
; 3912 : 		if ( gObjIsConnected(iUserIndex))

  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00088	83 c4 04	 add	 esp, 4
  0008b	85 c0		 test	 eax, eax
  0008d	74 4c		 je	 SHORT $LN6@CheckWinne@3

; 3913 : 		{
; 3914 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00094	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0009a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0009d	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  000a4	3c 34		 cmp	 al, 52			; 00000034H
  000a6	74 0d		 je	 SHORT $LN28@CheckWinne@3
  000a8	3c 0b		 cmp	 al, 11			; 0000000bH
  000aa	72 2f		 jb	 SHORT $LN6@CheckWinne@3
  000ac	b2 11		 mov	 dl, 17			; 00000011H
  000ae	3a d0		 cmp	 dl, al
  000b0	1b c0		 sbb	 eax, eax
  000b2	40		 inc	 eax
  000b3	74 26		 je	 SHORT $LN6@CheckWinne@3
$LN28@CheckWinne@3:
  000b5	8a 81 9e 0e 00
	00		 mov	 al, BYTE PTR [ecx+3742]
  000bb	84 c0		 test	 al, al
  000bd	78 1c		 js	 SHORT $LN6@CheckWinne@3
  000bf	33 d2		 xor	 edx, edx
  000c1	3c 07		 cmp	 al, 7
  000c3	0f 9e c2	 setle	 dl
  000c6	8b c2		 mov	 eax, edx
  000c8	85 c0		 test	 eax, eax
  000ca	74 0f		 je	 SHORT $LN6@CheckWinne@3

; 3915 : 			{
; 3916 : 				if ( gObj[iUserIndex].Live == 1 )

  000cc	80 79 6a 01	 cmp	 BYTE PTR [ecx+106], 1
  000d0	75 09		 jne	 SHORT $LN6@CheckWinne@3

; 3917 : 				{
; 3918 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  000d2	80 b9 a4 0e 00
	00 00		 cmp	 BYTE PTR [ecx+3748], 0
  000d9	74 12		 je	 SHORT $LN24@CheckWinne@3
$LN6@CheckWinne@3:

; 3907 : 
; 3908 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000db	47		 inc	 edi
  000dc	83 c3 04	 add	 ebx, 4
  000df	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  000e2	7c 9c		 jl	 SHORT $LL7@CheckWinne@3

; 3921 : 					}
; 3922 : 				}
; 3923 : 			}
; 3924 : 		}
; 3925 : 	}
; 3926 : 
; 3927 : 	return true;

  000e4	5f		 pop	 edi
  000e5	5b		 pop	 ebx
  000e6	b0 01		 mov	 al, 1
  000e8	5e		 pop	 esi

; 3928 : }

  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
$LN24@CheckWinne@3:
  000ed	5f		 pop	 edi
  000ee	5b		 pop	 ebx

; 3919 : 					{
; 3920 : 						return false;

  000ef	32 c0		 xor	 al, al
  000f1	5e		 pop	 esi

; 3928 : }

  000f2	5d		 pop	 ebp
  000f3	c2 04 00	 ret	 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckWinnerPartyComplete
_TEXT	ENDS
PUBLIC	?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::SetBridgeWinner
; Function compile flags: /Ogtp
;	COMDAT ?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::SetBridgeWinner, COMDAT
; _this$ = ecx

; 3931 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3932 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN13@SetBridgeW
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN4@SetBridgeW
$LN13@SetBridgeW:

; 3933 : 		return false;

  00016	32 c0		 xor	 al, al

; 3947 : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN4@SetBridgeW:

; 3934 : 
; 3935 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) != 0 )

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	56		 push	 esi
  00023	8d b4 08 58 04
	00 00		 lea	 esi, DWORD PTR [eax+ecx+1112]
  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	74 07		 je	 SHORT $LN3@SetBridgeW

; 3936 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 3947 : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN3@SetBridgeW:
  00040	57		 push	 edi

; 3937 : 
; 3938 : 	if ( !gObjIsConnected(iIndex))

  00041	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00044	57		 push	 edi
  00045	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004a	83 c4 04	 add	 esp, 4
  0004d	85 c0		 test	 eax, eax

; 3939 : 		return false;

  0004f	74 27		 je	 SHORT $LN14@SetBridgeW

; 3940 : 
; 3941 : 	if ( !BC_MAP_RANGE(gObj[iIndex].MapNumber))

  00051	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	8b cf		 mov	 ecx, edi
  00059	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0005f	0f b6 84 11 49
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edx+329]
  00067	3c 34		 cmp	 al, 52			; 00000034H
  00069	74 15		 je	 SHORT $LN1@SetBridgeW
  0006b	3c 0b		 cmp	 al, 11			; 0000000bH
  0006d	72 09		 jb	 SHORT $LN14@SetBridgeW
  0006f	b1 11		 mov	 cl, 17			; 00000011H
  00071	3a c8		 cmp	 cl, al
  00073	1b c0		 sbb	 eax, eax
  00075	40		 inc	 eax
  00076	75 08		 jne	 SHORT $LN1@SetBridgeW
$LN14@SetBridgeW:
  00078	5f		 pop	 edi

; 3942 : 		return false;

  00079	32 c0		 xor	 al, al
  0007b	5e		 pop	 esi

; 3947 : }

  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN1@SetBridgeW:

; 3943 : 
; 3944 : 	this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = iIndex;

  00080	89 3e		 mov	 DWORD PTR [esi], edi
  00082	5f		 pop	 edi

; 3945 : 
; 3946 : 	return true;

  00083	b0 01		 mov	 al, 1
  00085	5e		 pop	 esi

; 3947 : }

  00086	5d		 pop	 ebp
  00087	c2 08 00	 ret	 8
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::SetBridgeWinner
_TEXT	ENDS
PUBLIC	?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
; Function compile flags: /Ogtp
;	COMDAT ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iPartyComplete$ = 8					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompleteCount, COMDAT
; _this$ = ecx

; 3950 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3951 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN25@GetWinnerP
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN10@GetWinnerP
$LN25@GetWinnerP:

; 3952 : 		return false;

  00016	33 c0		 xor	 eax, eax

; 3985 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN10@GetWinnerP:

; 3953 : 
; 3954 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	56		 push	 esi
  00023	8d b4 08 58 04
	00 00		 lea	 esi, DWORD PTR [eax+ecx+1112]
  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax

; 3955 : 		return false;

  00037	74 27		 je	 SHORT $LN26@GetWinnerP

; 3956 : 
; 3957 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00039	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00041	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00047	8b 84 11 2c 04
	00 00		 mov	 eax, DWORD PTR [ecx+edx+1068]

; 3958 : 	
; 3959 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0004e	85 c0		 test	 eax, eax
  00050	78 0e		 js	 SHORT $LN26@GetWinnerP
  00052	33 c9		 xor	 ecx, ecx
  00054	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00059	0f 9e c1	 setle	 cl
  0005c	85 c9		 test	 ecx, ecx
  0005e	75 07		 jne	 SHORT $LN8@GetWinnerP
$LN26@GetWinnerP:

; 3960 : 		return false;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 3985 : }

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
$LN8@GetWinnerP:

; 3961 : 
; 3962 : 	int iPartyComplete=0;

  00067	6b c0 68	 imul	 eax, 104		; 00000068H
  0006a	53		 push	 ebx
  0006b	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  00070	57		 push	 edi
  00071	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iPartyComplete$[ebp], 0
  00078	8b f8		 mov	 edi, eax
  0007a	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  0007f	90		 npad	 1
$LL7@GetWinnerP:

; 3966 : 	{
; 3967 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00080	8b 37		 mov	 esi, DWORD PTR [edi]

; 3968 : 
; 3969 : 		if ( gObjIsConnected(iUserIndex))

  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00088	83 c4 04	 add	 esp, 4
  0008b	85 c0		 test	 eax, eax
  0008d	74 4f		 je	 SHORT $LN6@GetWinnerP

; 3970 : 		{
; 3971 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00094	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0009a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0009d	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  000a4	3c 34		 cmp	 al, 52			; 00000034H
  000a6	74 0d		 je	 SHORT $LN27@GetWinnerP
  000a8	3c 0b		 cmp	 al, 11			; 0000000bH
  000aa	72 32		 jb	 SHORT $LN6@GetWinnerP
  000ac	b2 11		 mov	 dl, 17			; 00000011H
  000ae	3a d0		 cmp	 dl, al
  000b0	1b c0		 sbb	 eax, eax
  000b2	40		 inc	 eax
  000b3	74 29		 je	 SHORT $LN6@GetWinnerP
$LN27@GetWinnerP:
  000b5	8a 81 9e 0e 00
	00		 mov	 al, BYTE PTR [ecx+3742]
  000bb	84 c0		 test	 al, al
  000bd	78 1f		 js	 SHORT $LN6@GetWinnerP
  000bf	33 d2		 xor	 edx, edx
  000c1	3c 07		 cmp	 al, 7
  000c3	0f 9e c2	 setle	 dl
  000c6	8b c2		 mov	 eax, edx
  000c8	85 c0		 test	 eax, eax
  000ca	74 12		 je	 SHORT $LN6@GetWinnerP

; 3972 : 			{
; 3973 : 				if ( gObj[iUserIndex].Live == 1 )

  000cc	80 79 6a 01	 cmp	 BYTE PTR [ecx+106], 1
  000d0	75 0c		 jne	 SHORT $LN6@GetWinnerP

; 3974 : 				{
; 3975 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == true )

  000d2	80 b9 a4 0e 00
	00 01		 cmp	 BYTE PTR [ecx+3748], 1
  000d9	75 03		 jne	 SHORT $LN6@GetWinnerP

; 3976 : 					{
; 3977 : 						iPartyComplete++;

  000db	ff 45 08	 inc	 DWORD PTR _iPartyComplete$[ebp]
$LN6@GetWinnerP:

; 3963 : 	int iUserIndex;
; 3964 : 
; 3965 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000de	83 c7 04	 add	 edi, 4
  000e1	4b		 dec	 ebx
  000e2	75 9c		 jne	 SHORT $LL7@GetWinnerP

; 3978 : 					}
; 3979 : 				}
; 3980 : 			}
; 3981 : 		}
; 3982 : 	}
; 3983 : 
; 3984 : 	return iPartyComplete;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  000e7	5f		 pop	 edi
  000e8	5b		 pop	 ebx
  000e9	5e		 pop	 esi

; 3985 : }

  000ea	5d		 pop	 ebp
  000eb	c2 04 00	 ret	 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompleteCount
_TEXT	ENDS
PUBLIC	?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
; Function compile flags: /Ogtp
;	COMDAT ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompletePoint, COMDAT
; _this$ = ecx

; 3988 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3989 : 	int iPartyComplete = this->GetWinnerPartyCompleteCount(iBridgeIndex);

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount

; 3990 : 	iPartyComplete--;

  0000c	48		 dec	 eax

; 3991 : 
; 3992 : 	if ( CHECK_LIMIT(iPartyComplete, MAX_USER_IN_PARTY) )

  0000d	78 17		 js	 SHORT $LN1@GetWinnerP@2
  0000f	33 c9		 xor	 ecx, ecx
  00011	83 f8 09	 cmp	 eax, 9
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	74 0b		 je	 SHORT $LN1@GetWinnerP@2

; 3993 : 		return g_iBC_Party_EventPoint[iPartyComplete];

  0001b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _g_iBC_Party_EventPoint[eax*4]

; 3996 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN1@GetWinnerP@2:

; 3994 : 
; 3995 : 	return 0;

  00026	33 c0		 xor	 eax, eax

; 3996 : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompletePoint
_TEXT	ENDS
PUBLIC	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z	; CBloodCastle::ChangeMonsterState
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
; Function compile flags: /Ogtp
;	COMDAT ?ChangeMonsterState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iAddDefense$ = 8					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::ChangeMonsterState, COMDAT
; _this$ = ecx

; 3999 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4000 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	3b c7		 cmp	 eax, edi
  0000b	0f 8c ad 00 00
	00		 jl	 $LN6@ChangeMons
  00011	33 d2		 xor	 edx, edx
  00013	83 f8 07	 cmp	 eax, 7
  00016	0f 9e c2	 setle	 dl
  00019	3b d7		 cmp	 edx, edi
  0001b	0f 84 9d 00 00
	00		 je	 $LN6@ChangeMons

; 4001 : 		return;
; 4002 : 
; 4003 : 	int iAddDamageMax = 0;
; 4004 : 	int iAddDamageMin = 0;
; 4005 : 	int iAddDefense = 0;
; 4006 : 
; 4007 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 300000 )

  00021	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00027	8b 84 08 ac 03
	00 00		 mov	 eax, DWORD PTR [eax+ecx+940]
  0002e	53		 push	 ebx
  0002f	33 db		 xor	 ebx, ebx
  00031	89 7d 08	 mov	 DWORD PTR _iAddDefense$[ebp], edi
  00034	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  00039	7d 0f		 jge	 SHORT $LN4@ChangeMons

; 4008 : 	{
; 4009 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[1][0];

  0003b	8d 7b 14	 lea	 edi, DWORD PTR [ebx+20]

; 4010 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[1][1];

  0003e	8d 5f 14	 lea	 ebx, DWORD PTR [edi+20]

; 4011 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[1][2];

  00041	c7 45 08 e0 ff
	ff ff		 mov	 DWORD PTR _iAddDefense$[ebp], -32 ; ffffffe0H
  00048	eb 16		 jmp	 SHORT $LN2@ChangeMons
$LN4@ChangeMons:

; 4012 : 	}
; 4013 : 	else if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 600000 )

  0004a	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0004f	7d 0f		 jge	 SHORT $LN2@ChangeMons

; 4014 : 	{
; 4015 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[0][0];

  00051	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 4016 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[0][1];

  00056	8d 5f 0a	 lea	 ebx, DWORD PTR [edi+10]

; 4017 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[0][2];

  00059	c7 45 08 f2 ff
	ff ff		 mov	 DWORD PTR _iAddDefense$[ebp], -14 ; fffffff2H
$LN2@ChangeMons:

; 4018 : 	}
; 4019 : 
; 4020 : 	LPMONSTER_ATTRIBUTE lpMA = gMAttr.GetAttr(gObj[iIndex].Class);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00065	56		 push	 esi
  00066	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00069	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0006f	0f b7 8c 06 b8
	00 00 00	 movzx	 ecx, WORD PTR [esi+eax+184]
  00077	51		 push	 ecx
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0007d	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 4021 : 
; 4022 : 	if ( lpMA == NULL )

  00082	85 c0		 test	 eax, eax
  00084	74 36		 je	 SHORT $LN11@ChangeMons

; 4023 : 		return;
; 4024 : 
; 4025 : 	gObj[iIndex].m_AttackDamageMin = lpMA->m_DamageMin + iAddDamageMin;

  00086	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008f	03 d7		 add	 edx, edi
  00091	89 94 0e 60 04
	00 00		 mov	 DWORD PTR [esi+ecx+1120], edx

; 4026 : 	gObj[iIndex].m_AttackDamageMax = lpMA->m_DamageMax + iAddDamageMax;

  00098	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a1	03 d3		 add	 edx, ebx
  000a3	89 94 0e 64 04
	00 00		 mov	 DWORD PTR [esi+ecx+1124], edx

; 4027 : 	gObj[iIndex].m_Defense = lpMA->m_Defense + iAddDefense;

  000aa	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  000ad	03 55 08	 add	 edx, DWORD PTR _iAddDefense$[ebp]
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b5	89 94 06 94 04
	00 00		 mov	 DWORD PTR [esi+eax+1172], edx
$LN11@ChangeMons:
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
$LN6@ChangeMons:
  000be	5f		 pop	 edi

; 4028 : }

  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::ChangeMonsterState
_TEXT	ENDS
PUBLIC	??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	__real@00000000
PUBLIC	?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateWin
;	COMDAT ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_i$220241 = -12						; size = 4
tv722 = -8						; size = 4
tv452 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateWin, COMDAT
; _this$ = ecx

; 4031 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 4032 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0000f	85 c9		 test	 ecx, ecx
  00011	0f 88 ee 02 00
	00		 js	 $LN26@FixUsersPl
  00017	33 c0		 xor	 eax, eax
  00019	83 f9 07	 cmp	 ecx, 7
  0001c	0f 9e c0	 setle	 al
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 de 02 00
	00		 je	 $LN26@FixUsersPl

; 4033 : 		return;
; 4034 : 
; 4035 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  00027	8b c1		 mov	 eax, ecx
  00029	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002f	03 c7		 add	 eax, edi
  00031	83 b8 a0 03 00
	00 ff		 cmp	 DWORD PTR [eax+928], -1
  00038	89 45 fc	 mov	 DWORD PTR tv452[ebp], eax
  0003b	0f 84 c4 02 00
	00		 je	 $LN26@FixUsersPl

; 4036 : 	{
; 4037 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00041	d9 ee		 fldz
  00043	53		 push	 ebx
  00044	8d 1c cd 00 00
	00 00		 lea	 ebx, DWORD PTR [ecx*8]
  0004b	2b d9		 sub	 ebx, ecx
  0004d	03 db		 add	 ebx, ebx
  0004f	33 d2		 xor	 edx, edx
  00051	03 db		 add	 ebx, ebx
  00053	03 db		 add	 ebx, ebx
  00055	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  00058	8d 44 8f 1c	 lea	 eax, DWORD PTR [edi+ecx*4+28]
  0005c	56		 push	 esi
  0005d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	89 55 f4	 mov	 DWORD PTR _i$220241[ebp], edx
  00066	89 45 f8	 mov	 DWORD PTR tv722[ebp], eax
$LN28@FixUsersPl:

; 4038 : 		{
; 4039 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00069	8b 4d f8	 mov	 ecx, DWORD PTR tv722[ebp]
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	83 f8 ff	 cmp	 eax, -1
  00071	0f 84 79 02 00
	00		 je	 $LN27@FixUsersPl

; 4040 : 				continue;
; 4041 : 
; 4042 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  00077	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0007d	83 7c 30 04 03	 cmp	 DWORD PTR [eax+esi+4], 3
  00082	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00085	0f 8c 65 02 00
	00		 jl	 $LN27@FixUsersPl

; 4043 : 				continue;
; 4044 : 
; 4045 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4046 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||
; 4047 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  0008b	8a 81 9e 0e 00
	00		 mov	 al, BYTE PTR [ecx+3742]
  00091	3c ff		 cmp	 al, -1
  00093	0f 84 57 02 00
	00		 je	 $LN27@FixUsersPl
  00099	80 b9 9f 0e 00
	00 ff		 cmp	 BYTE PTR [ecx+3743], -1
  000a0	0f 84 4a 02 00
	00		 je	 $LN27@FixUsersPl
  000a6	0f be c0	 movsx	 eax, al
  000a9	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ac	0f 85 3e 02 00
	00		 jne	 $LN27@FixUsersPl

; 4048 : 				continue;
; 4049 : 
; 4050 : 			LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];
; 4051 : 
; 4052 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  000b2	8d 44 13 02	 lea	 eax, DWORD PTR [ebx+edx+2]
  000b6	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  000b9	8b 04 97	 mov	 eax, DWORD PTR [edi+edx*4]
  000bc	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]
  000bf	83 f8 04	 cmp	 eax, 4
  000c2	0f 87 fa 01 00
	00		 ja	 $LN88@FixUsersPl
  000c8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN151@FixUsersPl[eax*4]
$LN19@FixUsersPl:

; 4053 : 			{
; 4054 : 				case 0:
; 4055 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  000cf	8b 81 2c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1068]
  000d5	85 c0		 test	 eax, eax
  000d7	78 69		 js	 SHORT $LN65@FixUsersPl
  000d9	33 d2		 xor	 edx, edx
  000db	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  000e0	0f 9e c2	 setle	 dl
  000e3	85 d2		 test	 edx, edx
  000e5	74 5b		 je	 SHORT $LN65@FixUsersPl
  000e7	8b 55 fc	 mov	 edx, DWORD PTR tv452[ebp]
  000ea	8b 92 58 04 00
	00		 mov	 edx, DWORD PTR [edx+1112]
  000f0	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000f6	3b 84 32 2c 04
	00 00		 cmp	 eax, DWORD PTR [edx+esi+1068]
  000fd	75 43		 jne	 SHORT $LN65@FixUsersPl

; 4056 : 					{
; 4057 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  000ff	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  00106	3c 34		 cmp	 al, 52			; 00000034H
  00108	74 0d		 je	 SHORT $LN61@FixUsersPl
  0010a	3c 0b		 cmp	 al, 11			; 0000000bH
  0010c	72 27		 jb	 SHORT $LN108@FixUsersPl
  0010e	b2 11		 mov	 dl, 17			; 00000011H
  00110	3a d0		 cmp	 dl, al
  00112	1b c0		 sbb	 eax, eax
  00114	40		 inc	 eax
  00115	74 1e		 je	 SHORT $LN108@FixUsersPl
$LN61@FixUsersPl:
  00117	80 79 6a 01	 cmp	 BYTE PTR [ecx+106], 1
  0011b	75 18		 jne	 SHORT $LN108@FixUsersPl
  0011d	d8 99 fc 00 00
	00		 fcomp	 DWORD PTR [ecx+252]
  00123	df e0		 fnstsw	 ax
  00125	f6 c4 05	 test	 ah, 5
  00128	7a 0d		 jp	 SHORT $LN17@FixUsersPl

; 4058 : 						{
; 4059 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  0012a	c7 07 03 00 00
	00		 mov	 DWORD PTR [edi], 3

; 4060 : 						}
; 4061 : 						else

  00130	e9 8f 01 00 00	 jmp	 $LN70@FixUsersPl
$LN108@FixUsersPl:

; 4056 : 					{
; 4057 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  00135	dd d8		 fstp	 ST(0)
$LN17@FixUsersPl:

; 4062 : 						{
; 4063 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00137	c7 07 04 00 00
	00		 mov	 DWORD PTR [edi], 4

; 4064 : 						}
; 4065 : 					}
; 4066 : 					else 

  0013d	e9 82 01 00 00	 jmp	 $LN70@FixUsersPl
$LN65@FixUsersPl:

; 4067 : 					{
; 4068 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  00142	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  00149	3c 34		 cmp	 al, 52			; 00000034H
  0014b	74 0d		 je	 SHORT $LN62@FixUsersPl
  0014d	3c 0b		 cmp	 al, 11			; 0000000bH
  0014f	72 2b		 jb	 SHORT $LN118@FixUsersPl
  00151	b2 11		 mov	 dl, 17			; 00000011H
  00153	3a d0		 cmp	 dl, al
  00155	1b c0		 sbb	 eax, eax
  00157	40		 inc	 eax
  00158	74 22		 je	 SHORT $LN118@FixUsersPl
$LN62@FixUsersPl:
  0015a	80 79 6a 00	 cmp	 BYTE PTR [ecx+106], 0
  0015e	74 1c		 je	 SHORT $LN118@FixUsersPl
  00160	d8 99 fc 00 00
	00		 fcomp	 DWORD PTR [ecx+252]
  00166	df e0		 fnstsw	 ax
  00168	f6 c4 01	 test	 ah, 1
  0016b	0f 85 53 01 00
	00		 jne	 $LN70@FixUsersPl

; 4069 : 						{
; 4070 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00171	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1

; 4071 : 						}
; 4072 : 					}
; 4073 : 					break;

  00177	e9 48 01 00 00	 jmp	 $LN70@FixUsersPl
$LN118@FixUsersPl:

; 4067 : 					{
; 4068 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  0017c	dd d8		 fstp	 ST(0)
$LN66@FixUsersPl:

; 4069 : 						{
; 4070 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0017e	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1

; 4071 : 						}
; 4072 : 					}
; 4073 : 					break;

  00184	e9 3b 01 00 00	 jmp	 $LN70@FixUsersPl
$LN90@FixUsersPl:

; 4074 : 				case 1:
; 4075 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00189	8b 81 2c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1068]

; 4102 : 					{
; 4103 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0018f	dd d8		 fstp	 ST(0)
  00191	85 c0		 test	 eax, eax
  00193	0f 88 2b 01 00
	00		 js	 $LN70@FixUsersPl

; 4074 : 				case 1:
; 4075 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00199	33 d2		 xor	 edx, edx
  0019b	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  001a0	0f 9e c2	 setle	 dl
  001a3	85 d2		 test	 edx, edx
  001a5	0f 84 19 01 00
	00		 je	 $LN70@FixUsersPl
  001ab	8b 55 fc	 mov	 edx, DWORD PTR tv452[ebp]
  001ae	8b 92 58 04 00
	00		 mov	 edx, DWORD PTR [edx+1112]
  001b4	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  001ba	3b 84 32 2c 04
	00 00		 cmp	 eax, DWORD PTR [edx+esi+1068]
  001c1	0f 85 fd 00 00
	00		 jne	 $LN70@FixUsersPl

; 4076 : 					{
; 4077 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  001c7	c7 07 04 00 00
	00		 mov	 DWORD PTR [edi], 4

; 4078 : 					}
; 4079 : 					break;

  001cd	e9 f2 00 00 00	 jmp	 $LN70@FixUsersPl
$LN10@FixUsersPl:

; 4080 : 				case 3:
; 4081 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  001d2	8b 81 2c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1068]
  001d8	85 c0		 test	 eax, eax
  001da	78 69		 js	 SHORT $LN67@FixUsersPl
  001dc	33 d2		 xor	 edx, edx
  001de	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  001e3	0f 9e c2	 setle	 dl
  001e6	85 d2		 test	 edx, edx
  001e8	74 5b		 je	 SHORT $LN67@FixUsersPl
  001ea	8b 55 fc	 mov	 edx, DWORD PTR tv452[ebp]
  001ed	8b 92 58 04 00
	00		 mov	 edx, DWORD PTR [edx+1112]
  001f3	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  001f9	3b 84 32 2c 04
	00 00		 cmp	 eax, DWORD PTR [edx+esi+1068]
  00200	75 43		 jne	 SHORT $LN67@FixUsersPl

; 4082 : 					{
; 4083 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  00202	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  00209	3c 34		 cmp	 al, 52			; 00000034H
  0020b	74 15		 je	 SHORT $LN63@FixUsersPl
  0020d	3c 0b		 cmp	 al, 11			; 0000000bH
  0020f	0f 82 20 ff ff
	ff		 jb	 $LN108@FixUsersPl
  00215	b2 11		 mov	 dl, 17			; 00000011H
  00217	3a d0		 cmp	 dl, al
  00219	1b c0		 sbb	 eax, eax
  0021b	40		 inc	 eax
  0021c	0f 84 13 ff ff
	ff		 je	 $LN108@FixUsersPl
$LN63@FixUsersPl:
  00222	80 79 6a 00	 cmp	 BYTE PTR [ecx+106], 0
  00226	0f 84 09 ff ff
	ff		 je	 $LN108@FixUsersPl
  0022c	d8 99 fc 00 00
	00		 fcomp	 DWORD PTR [ecx+252]
  00232	df e0		 fnstsw	 ax
  00234	f6 c4 01	 test	 ah, 1
  00237	0f 85 87 00 00
	00		 jne	 $LN70@FixUsersPl

; 4062 : 						{
; 4063 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0023d	c7 07 04 00 00
	00		 mov	 DWORD PTR [edi], 4

; 4064 : 						}
; 4065 : 					}
; 4066 : 					else 

  00243	eb 7f		 jmp	 SHORT $LN70@FixUsersPl
$LN67@FixUsersPl:

; 4084 : 						{
; 4085 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;
; 4086 : 						}
; 4087 : 					}
; 4088 : 					else 
; 4089 : 					{
; 4090 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  00245	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  0024c	3c 34		 cmp	 al, 52			; 00000034H
  0024e	74 15		 je	 SHORT $LN64@FixUsersPl
  00250	3c 0b		 cmp	 al, 11			; 0000000bH
  00252	0f 82 24 ff ff
	ff		 jb	 $LN118@FixUsersPl
  00258	b2 11		 mov	 dl, 17			; 00000011H
  0025a	3a d0		 cmp	 dl, al
  0025c	1b c0		 sbb	 eax, eax
  0025e	40		 inc	 eax
  0025f	0f 84 17 ff ff
	ff		 je	 $LN118@FixUsersPl
$LN64@FixUsersPl:
  00265	80 79 6a 01	 cmp	 BYTE PTR [ecx+106], 1
  00269	0f 85 0d ff ff
	ff		 jne	 $LN118@FixUsersPl
  0026f	d8 99 fc 00 00
	00		 fcomp	 DWORD PTR [ecx+252]
  00275	df e0		 fnstsw	 ax
  00277	f6 c4 05	 test	 ah, 5
  0027a	0f 8a fe fe ff
	ff		 jp	 $LN66@FixUsersPl

; 4091 : 						{
; 4092 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  00280	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 4093 : 						}
; 4094 : 						else

  00286	eb 3c		 jmp	 SHORT $LN70@FixUsersPl
$LN89@FixUsersPl:

; 4095 : 						{
; 4096 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4097 : 						}
; 4098 : 					}
; 4099 : 					break;
; 4100 : 				case 4:
; 4101 : 					if ( !OBJMAX_RANGE(lpObj->PartyNumber) || lpObj->PartyNumber != gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00288	8b 81 2c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1068]

; 4102 : 					{
; 4103 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0028e	dd d8		 fstp	 ST(0)
  00290	85 c0		 test	 eax, eax
  00292	78 26		 js	 SHORT $LN69@FixUsersPl

; 4095 : 						{
; 4096 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4097 : 						}
; 4098 : 					}
; 4099 : 					break;
; 4100 : 				case 4:
; 4101 : 					if ( !OBJMAX_RANGE(lpObj->PartyNumber) || lpObj->PartyNumber != gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00294	33 d2		 xor	 edx, edx
  00296	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  0029b	0f 9e c2	 setle	 dl
  0029e	85 d2		 test	 edx, edx
  002a0	74 18		 je	 SHORT $LN69@FixUsersPl
  002a2	8b 55 fc	 mov	 edx, DWORD PTR tv452[ebp]
  002a5	8b 92 58 04 00
	00		 mov	 edx, DWORD PTR [edx+1112]
  002ab	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  002b1	3b 84 32 2c 04
	00 00		 cmp	 eax, DWORD PTR [edx+esi+1068]
  002b8	74 0a		 je	 SHORT $LN70@FixUsersPl
$LN69@FixUsersPl:

; 4102 : 					{
; 4103 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  002ba	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  002c0	eb 02		 jmp	 SHORT $LN70@FixUsersPl
$LN88@FixUsersPl:
  002c2	dd d8		 fstp	 ST(0)
$LN70@FixUsersPl:

; 4104 : 					}
; 4105 : 					break;
; 4106 : 			}
; 4107 : 
; 4108 : 			LogAddTD("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : %d", iBridgeIndex+1, lpObj->AccountID, lpObj->Name, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);

  002c4	8b 07		 mov	 eax, DWORD PTR [edi]
  002c6	50		 push	 eax
  002c7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  002ca	8d 51 77	 lea	 edx, DWORD PTR [ecx+119]
  002cd	52		 push	 edx
  002ce	83 c1 6c	 add	 ecx, 108		; 0000006cH
  002d1	51		 push	 ecx
  002d2	40		 inc	 eax
  002d3	50		 push	 eax
  002d4	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  002d9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002df	d9 ee		 fldz
  002e1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e7	8b 7d f0	 mov	 edi, DWORD PTR _this$[ebp]
  002ea	8b 55 f4	 mov	 edx, DWORD PTR _i$220241[ebp]
  002ed	83 c4 14	 add	 esp, 20			; 00000014H
$LN27@FixUsersPl:

; 4036 : 	{
; 4037 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  002f0	83 45 f8 14	 add	 DWORD PTR tv722[ebp], 20 ; 00000014H
  002f4	42		 inc	 edx
  002f5	89 55 f4	 mov	 DWORD PTR _i$220241[ebp], edx
  002f8	83 fa 28	 cmp	 edx, 40			; 00000028H
  002fb	0f 8c 68 fd ff
	ff		 jl	 $LN28@FixUsersPl
  00301	5e		 pop	 esi
  00302	dd d8		 fstp	 ST(0)
  00304	5b		 pop	 ebx
$LN26@FixUsersPl:
  00305	5f		 pop	 edi

; 4109 : 		}
; 4110 : 	}
; 4111 : }

  00306	8b e5		 mov	 esp, ebp
  00308	5d		 pop	 ebp
  00309	c2 04 00	 ret	 4
$LN151@FixUsersPl:
  0030c	00 00 00 00	 DD	 $LN19@FixUsersPl
  00310	00 00 00 00	 DD	 $LN90@FixUsersPl
  00314	00 00 00 00	 DD	 $LN88@FixUsersPl
  00318	00 00 00 00	 DD	 $LN10@FixUsersPl
  0031c	00 00 00 00	 DD	 $LN89@FixUsersPl
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateWin
_TEXT	ENDS
PUBLIC	??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateFail
;	COMDAT ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State :'
	DB	' %d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv491 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateFail, COMDAT
; _this$ = ecx

; 4114 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4115 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00006	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 ae 00 00
	00		 js	 $LN12@FixUsersPl@2
  00014	33 c0		 xor	 eax, eax
  00016	83 fa 07	 cmp	 edx, 7
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 9e 00 00
	00		 je	 $LN12@FixUsersPl@2

; 4116 : 		return;
; 4117 : 
; 4118 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	8d 3c d5 00 00
	00 00		 lea	 edi, DWORD PTR [edx*8]
  0002e	2b fa		 sub	 edi, edx
  00030	03 ff		 add	 edi, edi
  00032	03 ff		 add	 edi, edi
  00034	33 db		 xor	 ebx, ebx
  00036	03 ff		 add	 edi, edi
  00038	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  0003b	8d 44 81 1c	 lea	 eax, DWORD PTR [ecx+eax*4+28]
  0003f	89 45 fc	 mov	 DWORD PTR tv491[ebp], eax
$LL14@FixUsersPl@2:

; 4119 : 	{
; 4120 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00042	8b 45 fc	 mov	 eax, DWORD PTR tv491[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	83 f8 ff	 cmp	 eax, -1
  0004a	74 69		 je	 SHORT $LN13@FixUsersPl@2

; 4121 : 			continue;
; 4122 : 
; 4123 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  0004c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00058	03 f0		 add	 esi, eax
  0005a	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  0005e	7c 55		 jl	 SHORT $LN13@FixUsersPl@2

; 4124 : 			continue;
; 4125 : 
; 4126 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4127 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||
; 4128 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  00060	8a 86 9e 0e 00
	00		 mov	 al, BYTE PTR [esi+3742]
  00066	3c ff		 cmp	 al, -1
  00068	74 4b		 je	 SHORT $LN13@FixUsersPl@2
  0006a	80 be 9f 0e 00
	00 ff		 cmp	 BYTE PTR [esi+3743], -1
  00071	74 42		 je	 SHORT $LN13@FixUsersPl@2
  00073	0f be c0	 movsx	 eax, al
  00076	3b c2		 cmp	 eax, edx
  00078	75 3b		 jne	 SHORT $LN13@FixUsersPl@2

; 4129 : 			continue;
; 4130 : 
; 4131 : 		LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];
; 4132 : 
; 4133 : 		switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  0007a	8d 44 1f 02	 lea	 eax, DWORD PTR [edi+ebx+2]
  0007e	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00081	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00084	8b 01		 mov	 eax, DWORD PTR [ecx]
  00086	83 e8 03	 sub	 eax, 3
  00089	74 3d		 je	 SHORT $LN5@FixUsersPl@2
  0008b	48		 dec	 eax
  0008c	75 06		 jne	 SHORT $LN2@FixUsersPl@2
$LN3@FixUsersPl@2:

; 4137 : 				{
; 4138 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  0008e	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
$LN2@FixUsersPl@2:

; 4143 : 				}
; 4144 : 				break;
; 4145 : 			case 4:
; 4146 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4147 : 				break;
; 4148 : 		}
; 4149 : 
; 4150 : 		LogAddTD("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State : %d",	iBridgeIndex+1, lpObj->AccountID, lpObj->Name,	this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);

  00094	8b 01		 mov	 eax, DWORD PTR [ecx]
  00096	50		 push	 eax
  00097	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0009a	51		 push	 ecx
  0009b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0009e	56		 push	 esi
  0009f	42		 inc	 edx
  000a0	52		 push	 edx
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ac	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@FixUsersPl@2:

; 4116 : 		return;
; 4117 : 
; 4118 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000b5	83 45 fc 14	 add	 DWORD PTR tv491[ebp], 20 ; 00000014H
  000b9	43		 inc	 ebx
  000ba	83 fb 28	 cmp	 ebx, 40			; 00000028H
  000bd	7c 83		 jl	 SHORT $LL14@FixUsersPl@2
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
$LN12@FixUsersPl@2:

; 4151 : 	}
; 4152 : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 04 00	 ret	 4
$LN5@FixUsersPl@2:

; 4134 : 		{
; 4135 : 			case 3:
; 4136 : 				if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  000c8	0f b6 86 49 01
	00 00		 movzx	 eax, BYTE PTR [esi+329]
  000cf	3c 34		 cmp	 al, 52			; 00000034H
  000d1	74 10		 je	 SHORT $LN28@FixUsersPl@2
  000d3	3c 0b		 cmp	 al, 11			; 0000000bH
  000d5	72 b7		 jb	 SHORT $LN3@FixUsersPl@2
  000d7	b2 11		 mov	 dl, 17			; 00000011H
  000d9	3a d0		 cmp	 dl, al
  000db	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000de	1b c0		 sbb	 eax, eax
  000e0	40		 inc	 eax
  000e1	74 ab		 je	 SHORT $LN3@FixUsersPl@2
$LN28@FixUsersPl@2:
  000e3	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0
  000e7	74 a5		 je	 SHORT $LN3@FixUsersPl@2
  000e9	d9 ee		 fldz
  000eb	d8 9e fc 00 00
	00		 fcomp	 DWORD PTR [esi+252]
  000f1	df e0		 fnstsw	 ax
  000f3	f6 c4 01	 test	 ah, 1
  000f6	74 96		 je	 SHORT $LN3@FixUsersPl@2

; 4139 : 				}
; 4140 : 				else
; 4141 : 				{
; 4142 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  000f8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000fe	eb 94		 jmp	 SHORT $LN2@FixUsersPl@2
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateFail
_TEXT	ENDS
PUBLIC	?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetBridgeMapNumber
; Function compile flags: /Ogtp
;	COMDAT ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetBridgeMapNumber, COMDAT
; _this$ = ecx

; 4156 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4157 : 	int iMapNumber = 0;
; 4158 : 
; 4159 : 	switch(iBridgeIndex)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	83 f9 07	 cmp	 ecx, 7
  0000b	77 4b		 ja	 SHORT $LN9@GetBridgeM
  0000d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetBridgeM[ecx*4]
$LN8@GetBridgeM:

; 4160 : 	{
; 4161 : 	case 0:
; 4162 : 		iMapNumber = MAP_INDEX_BLOODCASTLE1;

  00014	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN7@GetBridgeM:

; 4163 : 		break;
; 4164 : 	case 1:
; 4165 : 		iMapNumber = MAP_INDEX_BLOODCASTLE2;

  0001d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN6@GetBridgeM:

; 4166 : 		break;
; 4167 : 	case 2:
; 4168 : 		iMapNumber = MAP_INDEX_BLOODCASTLE3;

  00026	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN5@GetBridgeM:

; 4169 : 		break;
; 4170 : 	case 3:
; 4171 : 		iMapNumber = MAP_INDEX_BLOODCASTLE4;

  0002f	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@GetBridgeM:

; 4172 : 		break;
; 4173 : 	case 4:
; 4174 : 		iMapNumber = MAP_INDEX_BLOODCASTLE5;

  00038	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN3@GetBridgeM:

; 4175 : 		break;
; 4176 : 	case 5:
; 4177 : 		iMapNumber = MAP_INDEX_BLOODCASTLE6;

  00041	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN2@GetBridgeM:

; 4178 : 		break;
; 4179 : 	case 6:
; 4180 : 		iMapNumber = MAP_INDEX_BLOODCASTLE7;

  0004a	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN1@GetBridgeM:

; 4181 : 		break;
; 4182 : 	case 7:
; 4183 : 		iMapNumber = MAP_INDEX_BLOODCASTLE8;

  00053	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN9@GetBridgeM:

; 4184 : 		break;
; 4185 : 	}
; 4186 : 
; 4187 : 	return iMapNumber;
; 4188 : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN13@GetBridgeM:
  0005c	00 00 00 00	 DD	 $LN8@GetBridgeM
  00060	00 00 00 00	 DD	 $LN7@GetBridgeM
  00064	00 00 00 00	 DD	 $LN6@GetBridgeM
  00068	00 00 00 00	 DD	 $LN5@GetBridgeM
  0006c	00 00 00 00	 DD	 $LN4@GetBridgeM
  00070	00 00 00 00	 DD	 $LN3@GetBridgeM
  00074	00 00 00 00	 DD	 $LN2@GetBridgeM
  00078	00 00 00 00	 DD	 $LN1@GetBridgeM
?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetBridgeMapNumber
_TEXT	ENDS
PUBLIC	?GetBridgeIndex@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetBridgeIndex
; Function compile flags: /Ogtp
;	COMDAT ?GetBridgeIndex@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
?GetBridgeIndex@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetBridgeIndex, COMDAT
; _this$ = ecx

; 4192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4193 : 	int iBridgeIndex = -1;
; 4194 : 
; 4195 : 	switch(iMAP_NUM)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 c1 f5	 add	 ecx, -11		; fffffff5H
  00009	83 c8 ff	 or	 eax, -1
  0000c	83 f9 29	 cmp	 ecx, 41			; 00000029H
  0000f	77 4f		 ja	 SHORT $LN9@GetBridgeI
  00011	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN13@GetBridgeI[ecx]
  00018	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN14@GetBridgeI[ecx*4]
$LN8@GetBridgeI:

; 4196 : 	{
; 4197 : 	case MAP_INDEX_BLOODCASTLE1:
; 4198 : 		iBridgeIndex = 0;

  0001f	33 c0		 xor	 eax, eax

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN7@GetBridgeI:

; 4199 : 		break;
; 4200 : 	case MAP_INDEX_BLOODCASTLE2:
; 4201 : 		iBridgeIndex = 1;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN6@GetBridgeI:

; 4202 : 		break;
; 4203 : 	case MAP_INDEX_BLOODCASTLE3:
; 4204 : 		iBridgeIndex = 2;

  0002e	b8 02 00 00 00	 mov	 eax, 2

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN5@GetBridgeI:

; 4205 : 		break;
; 4206 : 	case MAP_INDEX_BLOODCASTLE4:
; 4207 : 		iBridgeIndex = 3;

  00037	b8 03 00 00 00	 mov	 eax, 3

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN4@GetBridgeI:

; 4208 : 		break;
; 4209 : 	case MAP_INDEX_BLOODCASTLE5:
; 4210 : 		iBridgeIndex = 4;

  00040	b8 04 00 00 00	 mov	 eax, 4

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN3@GetBridgeI:

; 4211 : 		break;
; 4212 : 	case MAP_INDEX_BLOODCASTLE6:
; 4213 : 		iBridgeIndex = 5;

  00049	b8 05 00 00 00	 mov	 eax, 5

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN2@GetBridgeI:

; 4214 : 		break;
; 4215 : 	case MAP_INDEX_BLOODCASTLE7:
; 4216 : 		iBridgeIndex = 6;

  00052	b8 06 00 00 00	 mov	 eax, 6

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN1@GetBridgeI:

; 4217 : 		break;
; 4218 : 	case MAP_INDEX_BLOODCASTLE8:
; 4219 : 		iBridgeIndex = 7;

  0005b	b8 07 00 00 00	 mov	 eax, 7
$LN9@GetBridgeI:

; 4220 : 		break;
; 4221 : 	}
; 4222 : 
; 4223 : 	return iBridgeIndex;
; 4224 : }

  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
$LN14@GetBridgeI:
  00064	00 00 00 00	 DD	 $LN8@GetBridgeI
  00068	00 00 00 00	 DD	 $LN7@GetBridgeI
  0006c	00 00 00 00	 DD	 $LN6@GetBridgeI
  00070	00 00 00 00	 DD	 $LN5@GetBridgeI
  00074	00 00 00 00	 DD	 $LN4@GetBridgeI
  00078	00 00 00 00	 DD	 $LN3@GetBridgeI
  0007c	00 00 00 00	 DD	 $LN2@GetBridgeI
  00080	00 00 00 00	 DD	 $LN1@GetBridgeI
  00084	00 00 00 00	 DD	 $LN9@GetBridgeI
$LN13@GetBridgeI:
  00088	00		 DB	 0
  00089	01		 DB	 1
  0008a	02		 DB	 2
  0008b	03		 DB	 3
  0008c	04		 DB	 4
  0008d	05		 DB	 5
  0008e	06		 DB	 6
  0008f	08		 DB	 8
  00090	08		 DB	 8
  00091	08		 DB	 8
  00092	08		 DB	 8
  00093	08		 DB	 8
  00094	08		 DB	 8
  00095	08		 DB	 8
  00096	08		 DB	 8
  00097	08		 DB	 8
  00098	08		 DB	 8
  00099	08		 DB	 8
  0009a	08		 DB	 8
  0009b	08		 DB	 8
  0009c	08		 DB	 8
  0009d	08		 DB	 8
  0009e	08		 DB	 8
  0009f	08		 DB	 8
  000a0	08		 DB	 8
  000a1	08		 DB	 8
  000a2	08		 DB	 8
  000a3	08		 DB	 8
  000a4	08		 DB	 8
  000a5	08		 DB	 8
  000a6	08		 DB	 8
  000a7	08		 DB	 8
  000a8	08		 DB	 8
  000a9	08		 DB	 8
  000aa	08		 DB	 8
  000ab	08		 DB	 8
  000ac	08		 DB	 8
  000ad	08		 DB	 8
  000ae	08		 DB	 8
  000af	08		 DB	 8
  000b0	08		 DB	 8
  000b1	07		 DB	 7
?GetBridgeIndex@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetBridgeIndex
_TEXT	ENDS
PUBLIC	?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetItemMapNumberFirst
; Function compile flags: /Ogtp
;	COMDAT ?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetItemMapNumberFirst, COMDAT
; _this$ = ecx

; 4228 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4229 : 	int iMapNumber = iMAP_NUM;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]

; 4230 : 
; 4231 : 	switch(iMAP_NUM)

  00006	8d 88 12 ff ff
	ff		 lea	 ecx, DWORD PTR [eax-238]
  0000c	83 f9 07	 cmp	 ecx, 7
  0000f	77 4b		 ja	 SHORT $LN9@GetItemMap
  00011	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetItemMap[ecx*4]
$LN8@GetItemMap:

; 4232 : 	{
; 4233 : 	case 238:
; 4234 : 		iMapNumber = MAP_INDEX_BLOODCASTLE1;

  00018	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN7@GetItemMap:

; 4235 : 		break;
; 4236 : 	case 239:
; 4237 : 		iMapNumber = MAP_INDEX_BLOODCASTLE2;

  00021	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN6@GetItemMap:

; 4238 : 		break;
; 4239 : 	case 240:
; 4240 : 		iMapNumber = MAP_INDEX_BLOODCASTLE3;

  0002a	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN5@GetItemMap:

; 4241 : 		break;
; 4242 : 	case 241:
; 4243 : 		iMapNumber = MAP_INDEX_BLOODCASTLE4;

  00033	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN4@GetItemMap:

; 4244 : 		break;
; 4245 : 	case 242:
; 4246 : 		iMapNumber = MAP_INDEX_BLOODCASTLE5;

  0003c	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN3@GetItemMap:

; 4247 : 		break;
; 4248 : 	case 243:
; 4249 : 		iMapNumber = MAP_INDEX_BLOODCASTLE6;

  00045	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN2@GetItemMap:

; 4250 : 		break;
; 4251 : 	case 244:
; 4252 : 		iMapNumber = MAP_INDEX_BLOODCASTLE7;

  0004e	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN1@GetItemMap:

; 4253 : 		break;
; 4254 : 	case 245:
; 4255 : 		iMapNumber = MAP_INDEX_BLOODCASTLE8;

  00057	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN9@GetItemMap:

; 4256 : 		break;
; 4257 : 	}
; 4258 : 
; 4259 : 	return iMapNumber;
; 4260 : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN13@GetItemMap:
  00060	00 00 00 00	 DD	 $LN8@GetItemMap
  00064	00 00 00 00	 DD	 $LN7@GetItemMap
  00068	00 00 00 00	 DD	 $LN6@GetItemMap
  0006c	00 00 00 00	 DD	 $LN5@GetItemMap
  00070	00 00 00 00	 DD	 $LN4@GetItemMap
  00074	00 00 00 00	 DD	 $LN3@GetItemMap
  00078	00 00 00 00	 DD	 $LN2@GetItemMap
  0007c	00 00 00 00	 DD	 $LN1@GetItemMap
?GetItemMapNumberFirst@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetItemMapNumberFirst
_TEXT	ENDS
PUBLIC	?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetItemMapNumberSecond
; Function compile flags: /Ogtp
;	COMDAT ?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetItemMapNumberSecond, COMDAT
; _this$ = ecx

; 4264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4265 : 	int iMapNumber = iMAP_NUM;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMAP_NUM$[ebp]

; 4266 : 
; 4267 : 	switch(iMAP_NUM)

  00006	8d 88 0a ff ff
	ff		 lea	 ecx, DWORD PTR [eax-246]
  0000c	83 f9 07	 cmp	 ecx, 7
  0000f	77 4b		 ja	 SHORT $LN9@GetItemMap@2
  00011	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetItemMap@2[ecx*4]
$LN8@GetItemMap@2:

; 4268 : 	{
; 4269 : 	case 246:
; 4270 : 		iMapNumber = MAP_INDEX_BLOODCASTLE1;

  00018	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN7@GetItemMap@2:

; 4271 : 		break;
; 4272 : 	case 247:
; 4273 : 		iMapNumber = MAP_INDEX_BLOODCASTLE2;

  00021	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN6@GetItemMap@2:

; 4274 : 		break;
; 4275 : 	case 248:
; 4276 : 		iMapNumber = MAP_INDEX_BLOODCASTLE3;

  0002a	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN5@GetItemMap@2:

; 4277 : 		break;
; 4278 : 	case 249:
; 4279 : 		iMapNumber = MAP_INDEX_BLOODCASTLE4;

  00033	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN4@GetItemMap@2:

; 4280 : 		break;
; 4281 : 	case 250:
; 4282 : 		iMapNumber = MAP_INDEX_BLOODCASTLE5;

  0003c	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN3@GetItemMap@2:

; 4283 : 		break;
; 4284 : 	case 251:
; 4285 : 		iMapNumber = MAP_INDEX_BLOODCASTLE6;

  00045	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN2@GetItemMap@2:

; 4286 : 		break;
; 4287 : 	case 252:
; 4288 : 		iMapNumber = MAP_INDEX_BLOODCASTLE7;

  0004e	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN1@GetItemMap@2:

; 4289 : 		break;
; 4290 : 	case 253:
; 4291 : 		iMapNumber = MAP_INDEX_BLOODCASTLE8;

  00057	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN9@GetItemMap@2:

; 4292 : 		break;
; 4293 : 	}
; 4294 : 
; 4295 : 	return iMapNumber;
; 4296 : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN13@GetItemMap@2:
  00060	00 00 00 00	 DD	 $LN8@GetItemMap@2
  00064	00 00 00 00	 DD	 $LN7@GetItemMap@2
  00068	00 00 00 00	 DD	 $LN6@GetItemMap@2
  0006c	00 00 00 00	 DD	 $LN5@GetItemMap@2
  00070	00 00 00 00	 DD	 $LN4@GetItemMap@2
  00074	00 00 00 00	 DD	 $LN3@GetItemMap@2
  00078	00 00 00 00	 DD	 $LN2@GetItemMap@2
  0007c	00 00 00 00	 DD	 $LN1@GetItemMap@2
?GetItemMapNumberSecond@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetItemMapNumberSecond
_TEXT	ENDS
PUBLIC	?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size, COMDAT
; _this$ = ecx

; 877  : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 878  : 		}

  00003	c3		 ret	 0
?size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::size
_TEXT	ENDS
PUBLIC	??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 281  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 296  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 299  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 301  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
; Function compile flags: /Ogtp
;	COMDAT ?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode, COMDAT

; 560  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 562  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Nextnode
_TEXT	ENDS
PUBLIC	??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ PROC ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@XZ ENDP ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 221  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 238  : 		return (*this);
; 239  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
; Function compile flags: /Ogtp
;	COMDAT ?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode, COMDAT

; 565  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 567  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Prevnode
_TEXT	ENDS
PUBLIC	?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval, COMDAT

; 570  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 572  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@SAAAUBLOODCASTLE_START_TIME@@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<BLOODCASTLE_START_TIME>::allocator<BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 36   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 37   : 		}

  00008	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 93   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 94   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<BLOODCASTLE_START_TIME>::max_size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<BLOODCASTLE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<BLOODCASTLE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z ; std::addressof<BLOODCASTLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z PROC ; std::addressof<BLOODCASTLE_START_TIME>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UBLOODCASTLE_START_TIME@@@std@@YAPAUBLOODCASTLE_START_TIME@@AAU1@@Z ENDP ; std::addressof<BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0UBLOODCASTLE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node><BLOODCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::forward<BLOODCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z PROC ; std::forward<BLOODCASTLE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUBLOODCASTLE_START_TIME@@@std@@YAABUBLOODCASTLE_START_TIME@@ABU1@@Z ENDP ; std::forward<BLOODCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z PROC ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UBLOODCASTLE_START_TIME@@ABU1@@std@@YAXPAUBLOODCASTLE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ ; `string'
PUBLIC	??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ ; `string'
PUBLIC	??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	_iLEVEL$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::BloodCastleChaosMix
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	_rand:PROC
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?g_iCrywolfApplyMvpBenefit@@3HA:DWORD		; g_iCrywolfApplyMvpBenefit
EXTRN	?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CMixSystem::LogChaosItem
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
CONST	SEGMENT
??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Nam'
	DB	'e:%s, Level:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
CONST	SEGMENT
??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@ DB '['
	DB	0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix] [%s][%s'
	DB	'] CBMix Fail %d Money : %d-%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
CONST	SEGMENT
??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@ DB '['
	DB	0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix] [%s][%s'
	DB	'] CBMix Success %d Money : %d-%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s'
	DB	', Level:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Le'
	DB	'vel:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@ DB 0c5H, 0f5H, 0b8H
	DB	0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix,%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iLEVEL$GSCopy$ = -48					; size = 4
_iMIX_NEED_MONEY$ = -44					; size = 4
_pMsg$ = -40						; size = 16
_szTemp$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iLEVEL$ = 12						; size = 4
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::BloodCastleChaosMix, COMDAT
; _this$ = ecx

; 1059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iLEVEL$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 1149 : 	}
; 1150 : 	else
; 1151 : 	{
; 1152 : 		g_MixSystem.ChaosBoxInit(&gObj[iIndex]);

  00018	89 5d d0	 mov	 DWORD PTR _iLEVEL$GSCopy$[ebp], ebx
  0001b	85 ff		 test	 edi, edi
  0001d	78 0f		 js	 SHORT $LN21@BloodCastl

; 1060 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001f	33 c0		 xor	 eax, eax
  00021	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	75 14		 jne	 SHORT $LN12@BloodCastl
$LN21@BloodCastl:
  0002e	5f		 pop	 edi

; 1061 : 	{
; 1062 : 		return false;

  0002f	32 c0		 xor	 al, al
  00031	5b		 pop	 ebx

; 1162 : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN12@BloodCastl:

; 1063 : 	}
; 1064 : 
; 1065 : 	int iMapNumber = this->GetBridgeMapNumber(iLEVEL-1); //Season3 add-on

  00042	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber

; 1066 : 
; 1067 : 	if ( BC_MAP_RANGE(iMapNumber)  == FALSE ) //season3 changed

  0004b	83 f8 34	 cmp	 eax, 52			; 00000034H
  0004e	74 13		 je	 SHORT $LN11@BloodCastl
  00050	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00053	7c d9		 jl	 SHORT $LN21@BloodCastl
  00055	33 c9		 xor	 ecx, ecx
  00057	83 f8 11	 cmp	 eax, 17			; 00000011H
  0005a	0f 9e c1	 setle	 cl
  0005d	8b c1		 mov	 eax, ecx
  0005f	85 c0		 test	 eax, eax

; 1068 : 	{
; 1069 : 		return false;

  00061	74 cb		 je	 SHORT $LN21@BloodCastl
$LN11@BloodCastl:
  00063	56		 push	 esi

; 1070 : 	}
; 1071 : 
; 1072 : 	BOOL bMIX_RESULT = FALSE;
; 1073 : 
; 1074 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1075 : 
; 1076 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00064	6a 10		 push	 16			; 00000010H
  00066	8d 55 d8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00069	68 86 00 00 00	 push	 134			; 00000086H
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1077 : 	pMsg.Result = CB_ERROR; //
; 1078 : 	gObj[iIndex].ChaosLock = TRUE;

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00079	8b f7		 mov	 esi, edi
  0007b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00081	c6 45 db 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00085	c7 84 06 88 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+3720], 1

; 1079 : 
; 1080 : 	LogAddTD("[Blood Castle]  Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00095	53		 push	 ebx
  00096	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0009a	51		 push	 ecx
  0009b	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0009f	52		 push	 edx
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1081 : 
; 1082 : 	char szTemp[17];
; 1083 : 	wsprintf(szTemp, " Mix,%d", iLEVEL); //Season 2.5 add-on

  000ab	53		 push	 ebx
  000ac	8d 45 e8	 lea	 eax, DWORD PTR _szTemp$[ebp]
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JGACLMIM@?E?u?$LI?m?$LI?A?E?d?5Mix?0?$CFd?$AA@
  000b4	50		 push	 eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1084 : 
; 1085 : 	g_MixSystem.LogChaosItem(&gObj[iIndex], szTemp);

  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	83 c4 28	 add	 esp, 40			; 00000028H
  000c4	8d 4d e8	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  000c7	51		 push	 ecx
  000c8	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000cb	50		 push	 eax
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  000d1	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 1086 : 
; 1087 : 	int iMIX_SUCCESS_RATE = g_iBC_ChoasMixSuccessRate[iLEVEL - 1];

  000d6	8b 1c 9d fc ff
	ff ff		 mov	 ebx, DWORD PTR _g_iBC_ChoasMixSuccessRate[ebx*4-4]

; 1088 : 
; 1089 : 	if ( iMIX_SUCCESS_RATE < 0 || iMIX_SUCCESS_RATE > 100 )

  000dd	83 fb 64	 cmp	 ebx, 100		; 00000064H
  000e0	0f 87 13 02 00
	00		 ja	 $LN9@BloodCastl

; 1093 : 		return false;
; 1094 : 	}
; 1095 : 
; 1096 : 	if ( g_CrywolfSync.GetOccupationState() == 0 && g_iCrywolfApplyMvpBenefit )

  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  000eb	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  000f0	85 c0		 test	 eax, eax
  000f2	75 14		 jne	 SHORT $LN23@BloodCastl
  000f4	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpBenefit@@3HA, eax ; g_iCrywolfApplyMvpBenefit
  000fa	74 0c		 je	 SHORT $LN23@BloodCastl

; 1097 : 	{
; 1098 : 		iMIX_SUCCESS_RATE += g_CrywolfSync.GetPlusChaosRate();

  000fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00101	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate
  00106	03 d8		 add	 ebx, eax
$LN23@BloodCastl:

; 1099 : 	}
; 1100 : 
; 1101 : 	if ( iMIX_SUCCESS_RATE > 80 )

  00108	83 fb 50	 cmp	 ebx, 80			; 00000050H
  0010b	7e 05		 jle	 SHORT $LN7@BloodCastl

; 1102 : 	{
; 1103 : 		iMIX_SUCCESS_RATE = 80;

  0010d	bb 50 00 00 00	 mov	 ebx, 80			; 00000050H
$LN7@BloodCastl:

; 1104 : 	}
; 1105 : 
; 1106 : 	if ( gObj[iIndex].ChaosSuccessRate > 10 )

  00112	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00117	83 bc 06 84 0e
	00 00 0a	 cmp	 DWORD PTR [esi+eax+3716], 10 ; 0000000aH
  0011f	7e 26		 jle	 SHORT $LN6@BloodCastl

; 1107 : 	{
; 1108 : 		pMsg.Result = 0xF0;

  00121	c6 45 db f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H

; 1109 : 		gObj[iIndex].ChaosLock = FALSE;

  00125	c7 84 06 88 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+3720], 0

; 1110 : 
; 1111 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00130	0f b6 4d d9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00134	51		 push	 ecx
  00135	8d 55 d8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00138	52		 push	 edx
  00139	57		 push	 edi
  0013a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@BloodCastl:

; 1112 : 	}
; 1113 : 
; 1114 : 	iMIX_SUCCESS_RATE += gObj[iIndex].ChaosSuccessRate;

  00147	03 9c 06 84 0e
	00 00		 add	 ebx, DWORD PTR [esi+eax+3716]

; 1115 : 	int iMIX_NEED_MONEY = g_iBC_ChoasMixMoney[iLEVEL - 1];

  0014e	8b 45 d0	 mov	 eax, DWORD PTR _iLEVEL$GSCopy$[ebp]
  00151	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR _g_iBC_ChoasMixMoney[eax*4-4]
  00158	89 4d d4	 mov	 DWORD PTR _iMIX_NEED_MONEY$[ebp], ecx

; 1116 : 	int iChaosTaxMoney = (int)((__int64)(iMIX_NEED_MONEY) * (__int64)(g_CastleSiegeSync.GetTaxRateChaos(iIndex)) / (__int64)100);

  0015b	57		 push	 edi
  0015c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00161	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00166	f7 6d d4	 imul	 DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00169	6a 00		 push	 0
  0016b	6a 64		 push	 100			; 00000064H
  0016d	52		 push	 edx
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 __alldiv

; 1117 : 
; 1118 : 	if ( iChaosTaxMoney < 0 )

  00174	85 c0		 test	 eax, eax
  00176	79 02		 jns	 SHORT $LN5@BloodCastl

; 1119 : 	{
; 1120 : 		iChaosTaxMoney = 0;

  00178	33 c0		 xor	 eax, eax
$LN5@BloodCastl:

; 1121 : 	}
; 1122 : 
; 1123 : 	iMIX_NEED_MONEY += iChaosTaxMoney;

  0017a	01 45 d4	 add	 DWORD PTR _iMIX_NEED_MONEY$[ebp], eax

; 1124 : 
; 1125 : 	if ( iMIX_NEED_MONEY <  0 )

  0017d	79 2c		 jns	 SHORT $LN4@BloodCastl

; 1126 : 	{
; 1127 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0017f	0f b6 55 d9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00183	52		 push	 edx
  00184	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00187	50		 push	 eax
  00188	57		 push	 edi
  00189	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1128 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  0018e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00193	8b 4d d0	 mov	 ecx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  00196	51		 push	 ecx
  00197	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0019b	52		 push	 edx
  0019c	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  001a0	50		 push	 eax
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@

; 1129 : 		return false;

  001a6	e9 75 01 00 00	 jmp	 $LN25@BloodCastl
$LN4@BloodCastl:

; 1130 : 	}
; 1131 : 
; 1132 : 	if ( (gObj[iIndex].Money - iMIX_NEED_MONEY) < 0 )

  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b1	8b 94 0e f0 00
	00 00		 mov	 edx, DWORD PTR [esi+ecx+240]
  001b8	2b 55 d4	 sub	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  001bb	79 30		 jns	 SHORT $LN3@BloodCastl

; 1133 : 	{
; 1134 : 		pMsg.Result = CB_BC_NOT_ENOUGH_ZEN;
; 1135 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  001bd	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001c1	50		 push	 eax
  001c2	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001c5	51		 push	 ecx
  001c6	57		 push	 edi
  001c7	c6 45 db 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH
  001cb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1136 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  001d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d5	8b 55 d0	 mov	 edx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  001d8	52		 push	 edx
  001d9	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  001dd	51		 push	 ecx
  001de	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  001e2	52		 push	 edx
  001e3	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@

; 1137 : 		return false;

  001e8	e9 33 01 00 00	 jmp	 $LN25@BloodCastl
$LN3@BloodCastl:

; 1138 : 	}
; 1139 : 
; 1140 : 	gObj[iIndex].Money -= iMIX_NEED_MONEY;

  001ed	8b 55 d4	 mov	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  001f0	29 94 0e f0 00
	00 00		 sub	 DWORD PTR [esi+ecx+240], edx

; 1141 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001f7	50		 push	 eax
  001f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001fd	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1142 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  00202	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00207	8b 8c 06 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+240]
  0020e	51		 push	 ecx
  0020f	57		 push	 edi
  00210	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00215	83 c4 08	 add	 esp, 8

; 1143 : 
; 1144 : 	if ( (rand()%100) < iMIX_SUCCESS_RATE )

  00218	e8 00 00 00 00	 call	 _rand
  0021d	99		 cdq
  0021e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00223	f7 f9		 idiv	 ecx
  00225	3b d3		 cmp	 edx, ebx
  00227	7d 71		 jge	 SHORT $LN2@BloodCastl

; 1145 : 	{
; 1146 : 		int item_num = ITEMGET(13,18);
; 1147 : 		ItemSerialCreateSend(iIndex, -1, 0, 0, item_num, (BYTE)iLEVEL, 255, 0, 0, 0, -1, 0, 0);

  00229	8b 55 d0	 mov	 edx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  0022c	6a 00		 push	 0
  0022e	6a 00		 push	 0
  00230	6a ff		 push	 -1
  00232	6a 00		 push	 0
  00234	6a 00		 push	 0
  00236	6a 00		 push	 0
  00238	68 ff 00 00 00	 push	 255			; 000000ffH
  0023d	52		 push	 edx
  0023e	68 12 1a 00 00	 push	 6674			; 00001a12H
  00243	6a 00		 push	 0
  00245	6a 00		 push	 0
  00247	68 ff 00 00 00	 push	 255			; 000000ffH
  0024c	57		 push	 edi
  0024d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1148 : 		LogAddTD("[ Mix] [%s][%s] CBMix Success %d Money : %d-%d", gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);

  00252	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00257	8b 4d d4	 mov	 ecx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0025a	8b 94 06 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax+240]
  00261	51		 push	 ecx
  00262	52		 push	 edx
  00263	53		 push	 ebx
  00264	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00268	51		 push	 ecx
  00269	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0026d	52		 push	 edx
  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Su@
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00279	83 c4 4c	 add	 esp, 76			; 0000004cH

; 1157 : 	}
; 1158 : 
; 1159 : 	::gObjInventoryCommit(iIndex);

  0027c	57		 push	 edi
  0027d	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00282	83 c4 04	 add	 esp, 4
  00285	5e		 pop	 esi
  00286	5f		 pop	 edi

; 1160 : 
; 1161 : 	return true;

  00287	b0 01		 mov	 al, 1
  00289	5b		 pop	 ebx

; 1162 : }

  0028a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028d	33 cd		 xor	 ecx, ebp
  0028f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00294	8b e5		 mov	 esp, ebp
  00296	5d		 pop	 ebp
  00297	c2 08 00	 ret	 8
$LN2@BloodCastl:

; 1149 : 	}
; 1150 : 	else
; 1151 : 	{
; 1152 : 		g_MixSystem.ChaosBoxInit(&gObj[iIndex]);

  0029a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029f	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  002a2	51		 push	 ecx
  002a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  002a8	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 1153 : 		GCUserChaosBoxSend(&gObj[iIndex], 0);

  002ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b3	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  002b6	6a 00		 push	 0
  002b8	50		 push	 eax
  002b9	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1154 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  002be	0f b6 4d d9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  002c2	51		 push	 ecx
  002c3	8d 55 d8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002c6	52		 push	 edx
  002c7	57		 push	 edi
  002c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1155 : 		LogAddTD("[ Mix] [%s][%s] CBMix Fail %d Money : %d-%d", gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);

  002cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d2	8b 4d d4	 mov	 ecx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  002d5	8b 94 06 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax+240]
  002dc	51		 push	 ecx
  002dd	52		 push	 edx
  002de	53		 push	 ebx
  002df	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  002e3	51		 push	 ecx
  002e4	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  002e8	52		 push	 edx
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fa@
  002ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002f4	83 c4 2c	 add	 esp, 44			; 0000002cH

; 1156 : 		return false;

  002f7	eb 30		 jmp	 SHORT $LN26@BloodCastl
$LN9@BloodCastl:

; 1090 : 	{
; 1091 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  002f9	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002fd	50		 push	 eax
  002fe	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00301	51		 push	 ecx
  00302	57		 push	 edi
  00303	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1092 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Name:%s, Level:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0030d	8b 55 d0	 mov	 edx, DWORD PTR _iLEVEL$GSCopy$[ebp]
  00310	52		 push	 edx
  00311	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00315	51		 push	 ecx
  00316	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0031a	52		 push	 edx
  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
$LN25@BloodCastl:
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00326	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN26@BloodCastl:

; 1162 : }

  00329	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032c	5e		 pop	 esi
  0032d	5f		 pop	 edi
  0032e	33 cd		 xor	 ecx, ebp
  00330	32 c0		 xor	 al, al
  00332	5b		 pop	 ebx
  00333	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00338	8b e5		 mov	 esp, ebp
  0033a	5d		 pop	 ebp
  0033b	c2 08 00	 ret	 8
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::BloodCastleChaosMix
_TEXT	ENDS
PUBLIC	?CheckQuestItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckQuestItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckQuestItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iITEM_LEVEL$ = -4					; size = 4
tv240 = 8						; size = 4
_iIndex$ = 8						; size = 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckQuestItem, COMDAT
; _this$ = ecx

; 1387 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1388 : 	int iITEM_LEVEL = -1;
; 1389 : 
; 1390 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1
  00012	85 ff		 test	 edi, edi
  00014	0f 88 06 01 00
	00		 js	 $LN9@CheckQuest@2
  0001a	33 c0		 xor	 eax, eax
  0001c	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00022	0f 9e c0	 setle	 al
  00025	85 c0		 test	 eax, eax

; 1391 : 	{
; 1392 : 		return -1;

  00027	0f 84 f3 00 00
	00		 je	 $LN9@CheckQuest@2

; 1393 : 	}
; 1394 : 
; 1395 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  0002d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00039	8a 84 17 49 01
	00 00		 mov	 al, BYTE PTR [edi+edx+329]
  00040	3c 34		 cmp	 al, 52			; 00000034H
  00042	74 18		 je	 SHORT $LN12@CheckQuest@2
  00044	3c 0b		 cmp	 al, 11			; 0000000bH
  00046	0f 82 d4 00 00
	00		 jb	 $LN9@CheckQuest@2
  0004c	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00051	3a c8		 cmp	 cl, al
  00053	1b c9		 sbb	 ecx, ecx
  00055	41		 inc	 ecx

; 1396 : 	{
; 1397 : 		return -1;

  00056	0f 84 c4 00 00
	00		 je	 $LN9@CheckQuest@2
$LN12@CheckQuest@2:

; 1398 : 	}
; 1399 : 
; 1400 : 	int iBridgeIndex = this->GetBridgeIndex(gObj[iIndex].MapNumber); //season3 add-on

  0005c	0f b6 c0	 movzx	 eax, al
  0005f	50		 push	 eax
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex

; 1401 : 
; 1402 : 	if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  00067	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0006d	83 bc 30 e8 03
	00 00 ff	 cmp	 DWORD PTR [eax+esi+1000], -1
  00075	8d 84 30 e8 03
	00 00		 lea	 eax, DWORD PTR [eax+esi+1000]
  0007c	89 45 08	 mov	 DWORD PTR tv240[ebp], eax

; 1403 : 	{
; 1404 : 		return -1;

  0007f	0f 84 9b 00 00
	00		 je	 $LN9@CheckQuest@2

; 1405 : 	}
; 1406 : 
; 1407 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00085	66 83 7c 17 68
	01		 cmp	 WORD PTR [edi+edx+104], 1
  0008b	0f 85 8f 00 00
	00		 jne	 $LN9@CheckQuest@2
  00091	83 7c 17 04 02	 cmp	 DWORD PTR [edi+edx+4], 2
  00096	0f 8e 84 00 00
	00		 jle	 $LN9@CheckQuest@2

; 1410 : 	}
; 1411 : 
; 1412 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  0009c	53		 push	 ebx
  0009d	33 db		 xor	 ebx, ebx
  0009f	33 f6		 xor	 esi, esi
$LL8@CheckQuest@2:

; 1413 : 	{
; 1414 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  000a1	8b 8c 17 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+edx+3620]
  000a8	03 ce		 add	 ecx, esi
  000aa	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b5	83 f8 01	 cmp	 eax, 1
  000b8	75 1d		 jne	 SHORT $LN7@CheckQuest@2

; 1415 : 		{
; 1416 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  000ba	8b 84 17 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+edx+3620]
  000c1	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  000c6	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  000cb	75 0a		 jne	 SHORT $LN7@CheckQuest@2

; 1417 : 			{
; 1418 : 				if ( gObj[iIndex].pInventory[x].m_Number == this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL )

  000cd	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR tv240[ebp]
  000d3	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000d5	74 1b		 je	 SHORT $LN23@CheckQuest@2
$LN7@CheckQuest@2:

; 1410 : 	}
; 1411 : 
; 1412 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  000d7	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000dd	43		 inc	 ebx
  000de	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  000e4	7c bb		 jl	 SHORT $LL8@CheckQuest@2

; 1423 : 					{
; 1424 : 						iITEM_LEVEL = -1;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  000e9	5b		 pop	 ebx
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi

; 1425 : 						
; 1426 : 					}
; 1427 : 
; 1428 : 					break;
; 1429 : 				}
; 1430 : 			}
; 1431 : 		}
; 1432 : 	}
; 1433 : 
; 1434 : 	return iITEM_LEVEL;
; 1435 : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 04 00	 ret	 4
$LN23@CheckQuest@2:

; 1419 : 				{
; 1420 : 					iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  000f2	8b 94 17 24 0e
	00 00		 mov	 edx, DWORD PTR [edi+edx+3620]
  000f9	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  000ff	0f bf 44 1a 08	 movsx	 eax, WORD PTR [edx+ebx+8]

; 1421 : 
; 1422 : 					if ( iITEM_LEVEL < 0 || iITEM_LEVEL > 2 )

  00104	85 c0		 test	 eax, eax
  00106	78 05		 js	 SHORT $LN1@CheckQuest@2
  00108	83 f8 02	 cmp	 eax, 2
  0010b	7e 0a		 jle	 SHORT $LN2@CheckQuest@2
$LN1@CheckQuest@2:

; 1423 : 					{
; 1424 : 						iITEM_LEVEL = -1;

  0010d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1
  00114	8b 45 fc	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
$LN2@CheckQuest@2:
  00117	5b		 pop	 ebx
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi

; 1425 : 						
; 1426 : 					}
; 1427 : 
; 1428 : 					break;
; 1429 : 				}
; 1430 : 			}
; 1431 : 		}
; 1432 : 	}
; 1433 : 
; 1434 : 	return iITEM_LEVEL;
; 1435 : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 04 00	 ret	 4
$LN9@CheckQuest@2:
  00120	5f		 pop	 edi

; 1408 : 	{
; 1409 : 		return -1;

  00121	83 c8 ff	 or	 eax, -1
  00124	5e		 pop	 esi

; 1425 : 						
; 1426 : 					}
; 1427 : 
; 1428 : 					break;
; 1429 : 				}
; 1430 : 			}
; 1431 : 		}
; 1432 : 	}
; 1433 : 
; 1434 : 	return iITEM_LEVEL;
; 1435 : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 04 00	 ret	 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckQuestItem
_TEXT	ENDS
PUBLIC	?ClearMonster@CBloodCastle@@QAEXH_N@Z		; CBloodCastle::ClearMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Ogtp
;	COMDAT ?ClearMonster@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_bClearCastleDoor$ = 12					; size = 1
?ClearMonster@CBloodCastle@@QAEXH_N@Z PROC		; CBloodCastle::ClearMonster, COMDAT
; _this$ = ecx

; 1628 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1629 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 76		 js	 SHORT $LN4@ClearMonst
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 6a		 je	 SHORT $LN4@ClearMonst

; 1635 : 	{
; 1636 : 		if ( gObj[n].MapNumber == this->GetBridgeMapNumber(iBridgeIndex))

  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	50		 push	 eax
  0001a	33 ff		 xor	 edi, edi
  0001c	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00021	8b d8		 mov	 ebx, eax
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	33 f6		 xor	 esi, esi
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL6@ClearMonst:
  00030	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00038	3b cb		 cmp	 ecx, ebx
  0003a	75 32		 jne	 SHORT $LN5@ClearMonst

; 1637 : 		{
; 1638 : 			if ( bClearCastleDoor == false && gObj[n].Class == 131)

  0003c	80 7d 0c 00	 cmp	 BYTE PTR _bClearCastleDoor$[ebp], 0
  00040	75 0f		 jne	 SHORT $LN2@ClearMonst
  00042	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  00047	66 39 94 06 b8
	00 00 00	 cmp	 WORD PTR [esi+eax+184], dx
  0004f	74 1d		 je	 SHORT $LN5@ClearMonst
$LN2@ClearMonst:

; 1639 : 			{
; 1640 : 				continue;
; 1641 : 			}
; 1642 : 
; 1643 : 			if ( gObj[n].Class == 232 )

  00051	b9 e8 00 00 00	 mov	 ecx, 232		; 000000e8H
  00056	66 39 8c 06 b8
	00 00 00	 cmp	 WORD PTR [esi+eax+184], cx
  0005e	74 0e		 je	 SHORT $LN5@ClearMonst

; 1644 : 			{
; 1645 : 				continue;
; 1646 : 			}
; 1647 : 
; 1648 : 			gObjDel(n);

  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	83 c4 04	 add	 esp, 4
$LN5@ClearMonst:

; 1630 : 	{
; 1631 : 		return;
; 1632 : 	}
; 1633 : 
; 1634 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0006e	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00074	47		 inc	 edi
  00075	81 fe 80 76 97
	08		 cmp	 esi, 144144000		; 08977680H
  0007b	7c b3		 jl	 SHORT $LL6@ClearMonst
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
$LN4@ClearMonst:

; 1649 : 		}
; 1650 : 	}
; 1651 : }

  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?ClearMonster@CBloodCastle@@QAEXH_N@Z ENDP		; CBloodCastle::ClearMonster
_TEXT	ENDS
PUBLIC	??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@ ; `string'
PUBLIC	??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ ; `string'
PUBLIC	??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ ; `string'
PUBLIC	?SetMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
;	COMDAT ??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@
CONST	SEGMENT
??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@ DB '['
	DB	'Blood Castle] (%d) Door monster type Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
CONST	SEGMENT
??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Create Door Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
CONST	SEGMENT
??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Create Door Successfuly : Index(%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv498 = -12						; size = 4
_n$219217 = -8						; size = 4
_btBridgeIndex$219224 = -1				; size = 1
_btBloodCastleIndex$ = -1				; size = 1
_iBridgeIndex$ = 8					; size = 4
?SetMonster@CBloodCastle@@QAEXH@Z PROC			; CBloodCastle::SetMonster, COMDAT
; _this$ = ecx

; 1655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1656 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	85 f6		 test	 esi, esi
  0000f	0f 88 b1 03 00
	00		 js	 $LN9@SetMonster@2
  00015	33 c0		 xor	 eax, eax
  00017	83 fe 07	 cmp	 esi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 a1 03 00
	00		 je	 $LN9@SetMonster@2

; 1657 : 	{
; 1658 : 		return;
; 1659 : 	}
; 1660 : 
; 1661 : 	this->SetMonsterKillCount(iBridgeIndex);

  00025	57		 push	 edi
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonsterKillCount

; 1662 : 	int nCastleDoorPosNum = this->m_BridgeData[iBridgeIndex].m_nCastleDoorPosNum;

  0002c	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00032	8b bc 1e 90 03
	00 00		 mov	 edi, DWORD PTR [esi+ebx+912]

; 1663 : 
; 1664 : 	WORD wMonsterType = gMSetBase.m_Mp[nCastleDoorPosNum].m_Type; //season3 changed

  00039	8b c7		 mov	 eax, edi
  0003b	c1 e0 04	 shl	 eax, 4

; 1665 : 	BYTE btMapNumber = gMSetBase.m_Mp[nCastleDoorPosNum].m_MapNumber;
; 1666 : 	BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  0003e	0f b6 90 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00045	0f b7 b0 06 00
	00 00		 movzx	 esi, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  0004c	52		 push	 edx
  0004d	8b cb		 mov	 ecx, ebx
  0004f	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  00054	88 45 ff	 mov	 BYTE PTR _btBloodCastleIndex$[ebp], al

; 1667 : 
; 1668 : 	if ( nCastleDoorPosNum != -1 )

  00057	83 ff ff	 cmp	 edi, -1
  0005a	0f 84 28 01 00
	00		 je	 $LN33@SetMonster@2

; 1669 : 	{
; 1670 : 		if ( wMonsterType == 131 )

  00060	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00065	66 3b f1	 cmp	 si, cx
  00068	0f 85 07 01 00
	00		 jne	 $LN15@SetMonster@2

; 1671 : 		{
; 1672 : 			int iIndex = ::gObjAddMonster(btMapNumber);

  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00074	0f bf f0	 movsx	 esi, ax
  00077	83 c4 04	 add	 esp, 4

; 1673 : 
; 1674 : 			if ( iIndex >= 0 )

  0007a	85 f6		 test	 esi, esi
  0007c	0f 88 e6 00 00
	00		 js	 $LN14@SetMonster@2

; 1675 : 			{
; 1676 : 				::gObjSetPosMonster(iIndex, nCastleDoorPosNum);

  00082	57		 push	 edi
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1677 : 				::gObjSetMonster(iIndex, wMonsterType);

  00089	68 83 00 00 00	 push	 131			; 00000083H
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1678 : 
; 1679 : 				gObj[iIndex].m_cBloodCastleIndex = btBloodCastleIndex;

  00094	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	8a 4d ff	 mov	 cl, BYTE PTR _btBloodCastleIndex$[ebp]
  0009d	8b c6		 mov	 eax, esi
  0009f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000a5	88 8c 10 9e 0e
	00 00		 mov	 BYTE PTR [eax+edx+3742], cl

; 1680 : 				gObj[iIndex].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  000ac	66 8b 93 14 23
	00 00		 mov	 dx, WORD PTR [ebx+8980]
  000b3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b9	66 89 94 38 b8
	04 00 00	 mov	 WORD PTR [eax+edi+1208], dx

; 1681 : 				gObj[iIndex].Dir = 1;

  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c7	c6 84 10 48 01
	00 00 01	 mov	 BYTE PTR [eax+edx+328], 1

; 1682 : 				gObj[iIndex].m_PosNum = -1;

  000cf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d5	83 ca ff	 or	 edx, -1
  000d8	66 89 94 38 b0
	03 00 00	 mov	 WORD PTR [eax+edi+944], dx

; 1683 : 				gObj[iIndex].Live = TRUE;

  000e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e6	c6 44 10 6a 01	 mov	 BYTE PTR [eax+edx+106], 1

; 1684 : 				gObj[iIndex].DieRegen = FALSE;

  000eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	c6 84 10 a2 03
	00 00 00	 mov	 BYTE PTR [eax+edx+930], 0

; 1685 : 				gObj[iIndex].m_State = 1;

  000f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	c7 84 10 20 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [eax+edx+544], 1

; 1686 : 				gObj[iIndex].MaxRegenTime = 0;

  0010a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00110	c7 84 10 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+940], 0

; 1687 : 				gObj[iIndex].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  0011b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00121	0f b6 d1	 movzx	 edx, cl
  00124	8b ca		 mov	 ecx, edx
  00126	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H

; 1688 : 				gObj[iIndex].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;
; 1689 : 
; 1690 : 				LogAddTD("[Blood Castle] (%d) Create Door Successfuly : Index(%d)", btBloodCastleIndex+1, this->m_BridgeData[btBloodCastleIndex].m_iBC_DOOR_MONSTER_INDEX = iIndex); //season 2.5 add-on

  0012c	56		 push	 esi
  0012d	42		 inc	 edx
  0012e	d9 84 19 c4 03
	00 00		 fld	 DWORD PTR [ecx+ebx+964]
  00135	52		 push	 edx
  00136	d9 9c 38 00 01
	00 00		 fstp	 DWORD PTR [eax+edi+256]
  0013d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00143	d9 84 19 c4 03
	00 00		 fld	 DWORD PTR [ecx+ebx+964]
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
  0014f	d9 9c 38 fc 00
	00 00		 fstp	 DWORD PTR [eax+edi+252]
  00156	89 b4 19 5c 04
	00 00		 mov	 DWORD PTR [ecx+ebx+1116], esi
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00163	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1691 : 			}
; 1692 : 			else

  00166	eb 20		 jmp	 SHORT $LN33@SetMonster@2
$LN14@SetMonster@2:

; 1693 : 			{
; 1694 : 				LogAddTD("[Blood Castle] (%d) Create Door Fail", btBloodCastleIndex+1); //season 2.5 add-on

  00168	0f b6 55 ff	 movzx	 edx, BYTE PTR _btBloodCastleIndex$[ebp]
  0016c	42		 inc	 edx
  0016d	52		 push	 edx
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@

; 1695 : 			}
; 1696 : 		}
; 1697 : 		else

  00173	eb 0a		 jmp	 SHORT $LN38@SetMonster@2
$LN15@SetMonster@2:

; 1698 : 		{
; 1699 : 			LogAddTD("[Blood Castle] (%d) Door monster type Error", btBloodCastleIndex+1); //season 2.5 add-on

  00175	0f b6 c0	 movzx	 eax, al
  00178	40		 inc	 eax
  00179	50		 push	 eax
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@
$LN38@SetMonster@2:
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00185	83 c4 08	 add	 esp, 8
$LN33@SetMonster@2:

; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	int result;
; 1704 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  00188	83 3d 84 2c 03
	00 00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, 0
  0018f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$219217[ebp], 0
  00196	0f 8e 29 02 00
	00		 jle	 $LN36@SetMonster@2
  0019c	bf 08 00 00 00	 mov	 edi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
$LL35@SetMonster@2:

; 1705 : 	{
; 1706 : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE  )

  001a1	8a 07		 mov	 al, BYTE PTR [edi]
  001a3	3c 34		 cmp	 al, 52			; 00000034H
  001a5	74 18		 je	 SHORT $LN30@SetMonster@2
  001a7	3c 0b		 cmp	 al, 11			; 0000000bH
  001a9	0f 82 00 02 00
	00		 jb	 $LN10@SetMonster@2
  001af	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  001b4	3a c8		 cmp	 cl, al
  001b6	1b c9		 sbb	 ecx, ecx
  001b8	41		 inc	 ecx
  001b9	0f 84 f0 01 00
	00		 je	 $LN10@SetMonster@2
$LN30@SetMonster@2:

; 1707 : 		{
; 1708 : 			WORD wIndex = gMSetBase.m_Mp[n].m_Type;

  001bf	0f b7 57 fe	 movzx	 edx, WORD PTR [edi-2]
  001c3	0f b6 f0	 movzx	 esi, al

; 1709 : 			BYTE btMap   = gMSetBase.m_Mp[n].m_MapNumber;
; 1710 : 			BYTE btBridgeIndex = this->GetBridgeIndex(btMap); //season3 changed

  001c6	56		 push	 esi
  001c7	8b cb		 mov	 ecx, ebx
  001c9	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  001ce	88 45 ff	 mov	 BYTE PTR _btBridgeIndex$219224[ebp], al

; 1711 : 			
; 1712 : 			if ( btBridgeIndex != iBridgeIndex )

  001d1	0f b6 c0	 movzx	 eax, al
  001d4	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001d7	0f 85 d2 01 00
	00		 jne	 $LN10@SetMonster@2

; 1713 : 			{
; 1714 : 				continue;
; 1715 : 			}
; 1716 : 
; 1717 : 			if ( wIndex == 232 )

  001dd	b9 e8 00 00 00	 mov	 ecx, 232		; 000000e8H
  001e2	66 3b d1	 cmp	 dx, cx
  001e5	0f 84 c4 01 00
	00		 je	 $LN10@SetMonster@2

; 1718 : 			{
; 1719 : 				continue;
; 1720 : 			}
; 1721 : 
; 1722 : 			if ( wIndex == 131 )

  001eb	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  001f0	66 3b d0	 cmp	 dx, ax
  001f3	0f 84 b6 01 00
	00		 je	 $LN10@SetMonster@2

; 1723 : 			{
; 1724 : 				continue;
; 1725 : 			}
; 1726 : 
; 1727 : 			if ( wIndex == 89 || wIndex == 95 || wIndex == 112  || wIndex == 118 || wIndex == 124 || wIndex == 130 || wIndex == 143 || wIndex == 433 ) //season3 changed

  001f9	83 fa 59	 cmp	 edx, 89			; 00000059H
  001fc	0f 84 ad 01 00
	00		 je	 $LN10@SetMonster@2
  00202	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  00205	0f 84 a4 01 00
	00		 je	 $LN10@SetMonster@2
  0020b	83 fa 70	 cmp	 edx, 112		; 00000070H
  0020e	0f 84 9b 01 00
	00		 je	 $LN10@SetMonster@2
  00214	83 fa 76	 cmp	 edx, 118		; 00000076H
  00217	0f 84 92 01 00
	00		 je	 $LN10@SetMonster@2
  0021d	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  00220	0f 84 89 01 00
	00		 je	 $LN10@SetMonster@2
  00226	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  0022b	66 3b d1	 cmp	 dx, cx
  0022e	0f 84 7b 01 00
	00		 je	 $LN10@SetMonster@2
  00234	b8 8f 00 00 00	 mov	 eax, 143		; 0000008fH
  00239	66 3b d0	 cmp	 dx, ax
  0023c	0f 84 6d 01 00
	00		 je	 $LN10@SetMonster@2
  00242	b9 b1 01 00 00	 mov	 ecx, 433		; 000001b1H
  00247	66 3b d1	 cmp	 dx, cx
  0024a	0f 84 5f 01 00
	00		 je	 $LN10@SetMonster@2

; 1728 : 			{
; 1729 : 				continue;
; 1730 : 			}
; 1731 : 
; 1732 : 			if ( BC_STATUE_RANGE(wIndex-132) != FALSE )

  00250	8b c2		 mov	 eax, edx
  00252	89 45 f4	 mov	 DWORD PTR tv498[ebp], eax
  00255	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  0025a	78 12		 js	 SHORT $LN31@SetMonster@2
  0025c	33 d2		 xor	 edx, edx
  0025e	83 f8 02	 cmp	 eax, 2
  00261	0f 9e c2	 setle	 dl
  00264	8b c2		 mov	 eax, edx
  00266	85 c0		 test	 eax, eax
  00268	0f 85 41 01 00
	00		 jne	 $LN10@SetMonster@2
$LN31@SetMonster@2:

; 1733 : 			{
; 1734 : 				continue;
; 1735 : 			}
; 1736 : 
; 1737 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  0026e	56		 push	 esi
  0026f	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00274	98		 cwde
  00275	83 c4 04	 add	 esp, 4

; 1738 : 
; 1739 : 			if ( result >= 0 )

  00278	85 c0		 test	 eax, eax
  0027a	0f 88 2f 01 00
	00		 js	 $LN10@SetMonster@2

; 1740 : 			{
; 1741 : 				gObj[result].m_PosNum = n;

  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00286	0f b7 55 f8	 movzx	 edx, WORD PTR _n$219217[ebp]
  0028a	8b f0		 mov	 esi, eax
  0028c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00292	66 89 94 0e b0
	03 00 00	 mov	 WORD PTR [esi+ecx+944], dx

; 1742 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;

  0029a	0f b6 4f 02	 movzx	 ecx, BYTE PTR [edi+2]
  0029e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a4	66 89 8c 16 44
	01 00 00	 mov	 WORD PTR [esi+edx+324], cx

; 1743 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;

  002ac	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  002b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b6	66 89 8c 16 46
	01 00 00	 mov	 WORD PTR [esi+edx+326], cx

; 1744 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  002be	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c7	88 8c 16 49 01
	00 00		 mov	 BYTE PTR [esi+edx+329], cl

; 1745 : 				gObj[result].TX = gObj[result].X;

  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d4	0f b7 94 0e 44
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+324]
  002dc	66 89 94 0e 7c
	01 00 00	 mov	 WORD PTR [esi+ecx+380], dx

; 1746 : 				gObj[result].TY = gObj[result].Y;

  002e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ea	0f b7 94 0e 46
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+326]
  002f2	66 89 94 0e 7e
	01 00 00	 mov	 WORD PTR [esi+ecx+382], dx

; 1747 : 				gObj[result].m_OldX = gObj[result].X;

  002fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00300	0f b7 94 0e 44
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+324]
  00308	66 89 94 0e 78
	01 00 00	 mov	 WORD PTR [esi+ecx+376], dx

; 1748 : 				gObj[result].m_OldY = gObj[result].Y;

  00310	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00316	0f b7 94 0e 46
	01 00 00	 movzx	 edx, WORD PTR [esi+ecx+326]
  0031e	66 89 94 0e 7a
	01 00 00	 mov	 WORD PTR [esi+ecx+378], dx

; 1749 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;

  00326	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0032a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00330	88 8c 16 48 01
	00 00		 mov	 BYTE PTR [esi+edx+328], cl

; 1750 : 				gObj[result].StartX = gObj[result].X;

  00337	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033d	0f b6 94 0e 44
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+324]
  00345	88 94 0e 76 01
	00 00		 mov	 BYTE PTR [esi+ecx+374], dl

; 1751 : 				gObj[result].StartY = gObj[result].Y;

  0034c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00352	0f b6 94 0e 46
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+326]
  0035a	88 94 0e 77 01
	00 00		 mov	 BYTE PTR [esi+ecx+375], dl

; 1752 : 				gObjSetMonster(result, wIndex);

  00361	8b 4d f4	 mov	 ecx, DWORD PTR tv498[ebp]
  00364	51		 push	 ecx
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1753 : 				gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  0036b	8b 93 1c 23 00
	00		 mov	 edx, DWORD PTR [ebx+8988]
  00371	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00376	89 94 06 ac 03
	00 00		 mov	 DWORD PTR [esi+eax+940], edx

; 1754 : 				gObj[result].m_cBloodCastleIndex = btBridgeIndex;

  0037d	0f b6 55 ff	 movzx	 edx, BYTE PTR _btBridgeIndex$219224[ebp]
  00381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00387	83 c4 08	 add	 esp, 8
  0038a	88 94 0e 9e 0e
	00 00		 mov	 BYTE PTR [esi+ecx+3742], dl

; 1755 : 				gObj[result].Dir = rand() % 8;

  00391	e8 00 00 00 00	 call	 _rand
  00396	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0039b	79 05		 jns	 SHORT $LN37@SetMonster@2
  0039d	48		 dec	 eax
  0039e	83 c8 f8	 or	 eax, -8			; fffffff8H
  003a1	40		 inc	 eax
$LN37@SetMonster@2:
  003a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a8	88 84 0e 48 01
	00 00		 mov	 BYTE PTR [esi+ecx+328], al
$LN10@SetMonster@2:

; 1700 : 		}
; 1701 : 	}
; 1702 : 
; 1703 : 	int result;
; 1704 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  003af	8b 45 f8	 mov	 eax, DWORD PTR _n$219217[ebp]
  003b2	40		 inc	 eax
  003b3	83 c7 10	 add	 edi, 16			; 00000010H
  003b6	89 45 f8	 mov	 DWORD PTR _n$219217[ebp], eax
  003b9	3b 05 84 2c 03
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  003bf	0f 8c dc fd ff
	ff		 jl	 $LL35@SetMonster@2
$LN36@SetMonster@2:
  003c5	5f		 pop	 edi
$LN9@SetMonster@2:
  003c6	5e		 pop	 esi
  003c7	5b		 pop	 ebx

; 1756 : 			}
; 1757 : 		}
; 1758 : 	}
; 1759 : 	
; 1760 : }

  003c8	8b e5		 mov	 esp, ebp
  003ca	5d		 pop	 ebp
  003cb	c2 04 00	 ret	 4
?SetMonster@CBloodCastle@@QAEXH@Z ENDP			; CBloodCastle::SetMonster
_TEXT	ENDS
PUBLIC	?SetBossMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetBossMonster
; Function compile flags: /Ogtp
;	COMDAT ?SetBossMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv302 = -16						; size = 4
tv170 = -12						; size = 4
_this$ = -8						; size = 4
tv299 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetBossMonster@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetBossMonster, COMDAT
; _this$ = ecx

; 1764 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 1765 : 	int result;
; 1766 : 
; 1767 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 f6		 test	 esi, esi
  0000f	0f 88 31 01 00
	00		 js	 $LN6@SetBossMon
  00015	33 c0		 xor	 eax, eax
  00017	83 fe 07	 cmp	 esi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 21 01 00
	00		 je	 $LN6@SetBossMon

; 1768 : 	{
; 1769 : 		return;
; 1770 : 	}
; 1771 : 
; 1772 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  00025	8b c6		 mov	 eax, esi
  00027	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002d	53		 push	 ebx
  0002e	8d 94 08 3c 03
	00 00		 lea	 edx, DWORD PTR [eax+ecx+828]
  00035	57		 push	 edi
  00036	89 55 fc	 mov	 DWORD PTR tv299[ebp], edx
  00039	c7 45 f4 14 00
	00 00		 mov	 DWORD PTR tv170[ebp], 20 ; 00000014H
  00040	eb 06		 jmp	 SHORT $LN8@SetBossMon
$LL17@SetBossMon:
  00042	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
$LN8@SetBossMon:

; 1773 : 	{
; 1774 : 		if ( this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x] != -1 )

  00048	8b 45 fc	 mov	 eax, DWORD PTR tv299[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	89 45 f0	 mov	 DWORD PTR tv302[ebp], eax
  00050	83 f8 ff	 cmp	 eax, -1
  00053	0f 84 de 00 00
	00		 je	 $LN7@SetBossMon

; 1775 : 		{
; 1776 : 			int nBossMonsterPosNum = this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x];
; 1777 : 
; 1778 : 			WORD wMonsterType = gMSetBase.m_Mp[nBossMonsterPosNum].m_Type; //season3 changed

  00059	c1 e0 04	 shl	 eax, 4

; 1779 : 			BYTE btMapNumber = gMSetBase.m_Mp[nBossMonsterPosNum].m_MapNumber;
; 1780 : 			BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  0005c	0f b6 90 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00063	0f b7 b8 06 00
	00 00		 movzx	 edi, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  00070	8a d8		 mov	 bl, al

; 1781 : 
; 1782 : 			if ( btBloodCastleIndex != iBridgeIndex )

  00072	0f b6 cb	 movzx	 ecx, bl
  00075	3b ce		 cmp	 ecx, esi
  00077	0f 85 ba 00 00
	00		 jne	 $LN7@SetBossMon

; 1783 : 			{
; 1784 : 				continue;
; 1785 : 			}
; 1786 : 
; 1787 : 			if ( wMonsterType == 89 || wMonsterType == 95 || wMonsterType == 112 || wMonsterType == 118 || wMonsterType == 124 || wMonsterType == 130 || wMonsterType == 143 || wMonsterType == 433)

  0007d	83 ff 59	 cmp	 edi, 89			; 00000059H
  00080	74 36		 je	 SHORT $LN2@SetBossMon
  00082	83 ff 5f	 cmp	 edi, 95			; 0000005fH
  00085	74 31		 je	 SHORT $LN2@SetBossMon
  00087	83 ff 70	 cmp	 edi, 112		; 00000070H
  0008a	74 2c		 je	 SHORT $LN2@SetBossMon
  0008c	83 ff 76	 cmp	 edi, 118		; 00000076H
  0008f	74 27		 je	 SHORT $LN2@SetBossMon
  00091	83 ff 7c	 cmp	 edi, 124		; 0000007cH
  00094	74 22		 je	 SHORT $LN2@SetBossMon
  00096	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  0009b	66 3b f8	 cmp	 di, ax
  0009e	74 18		 je	 SHORT $LN2@SetBossMon
  000a0	b9 8f 00 00 00	 mov	 ecx, 143		; 0000008fH
  000a5	66 3b f9	 cmp	 di, cx
  000a8	74 0e		 je	 SHORT $LN2@SetBossMon
  000aa	b8 b1 01 00 00	 mov	 eax, 433		; 000001b1H
  000af	66 3b f8	 cmp	 di, ax
  000b2	0f 85 7f 00 00
	00		 jne	 $LN7@SetBossMon
$LN2@SetBossMon:

; 1788 : 			{
; 1789 : 				result = ::gObjAddMonster(btMapNumber);

  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000be	0f bf f0	 movsx	 esi, ax
  000c1	83 c4 04	 add	 esp, 4

; 1790 : 
; 1791 : 				if ( result >= 0 )

  000c4	85 f6		 test	 esi, esi
  000c6	78 6f		 js	 SHORT $LN7@SetBossMon

; 1792 : 				{
; 1793 : 					::gObjSetPosMonster(result, nBossMonsterPosNum);

  000c8	8b 4d f0	 mov	 ecx, DWORD PTR tv302[ebp]
  000cb	51		 push	 ecx
  000cc	56		 push	 esi
  000cd	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1794 : 					::gObjSetMonster(result, wMonsterType);

  000d2	57		 push	 edi
  000d3	56		 push	 esi
  000d4	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1795 : 					gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  000d9	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000df	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	8b 88 1c 23 00
	00		 mov	 ecx, DWORD PTR [eax+8988]
  000e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	89 8c 16 ac 03
	00 00		 mov	 DWORD PTR [esi+edx+940], ecx

; 1796 : 					gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fb	88 9c 0e 9e 0e
	00 00		 mov	 BYTE PTR [esi+ecx+3742], bl

; 1797 : 					gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  00102	66 8b 90 14 23
	00 00		 mov	 dx, WORD PTR [eax+8980]
  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	83 c4 10	 add	 esp, 16			; 00000010H
  00111	66 89 94 06 b8
	04 00 00	 mov	 WORD PTR [esi+eax+1208], dx

; 1798 : 					gObj[result].Dir = rand() % 8;

  00119	e8 00 00 00 00	 call	 _rand
  0011e	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00123	79 05		 jns	 SHORT $LN18@SetBossMon
  00125	48		 dec	 eax
  00126	83 c8 f8	 or	 eax, -8			; fffffff8H
  00129	40		 inc	 eax
$LN18@SetBossMon:
  0012a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00130	88 84 0e 48 01
	00 00		 mov	 BYTE PTR [esi+ecx+328], al
$LN7@SetBossMon:

; 1768 : 	{
; 1769 : 		return;
; 1770 : 	}
; 1771 : 
; 1772 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  00137	83 45 fc 04	 add	 DWORD PTR tv299[ebp], 4
  0013b	ff 4d f4	 dec	 DWORD PTR tv170[ebp]
  0013e	0f 85 fe fe ff
	ff		 jne	 $LL17@SetBossMon
  00144	5f		 pop	 edi
  00145	5b		 pop	 ebx
$LN6@SetBossMon:
  00146	5e		 pop	 esi

; 1799 : 				}
; 1800 : 			}
; 1801 : 		}
; 1802 : 	}
; 1803 : }

  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
?SetBossMonster@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetBossMonster
_TEXT	ENDS
PUBLIC	??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@ ; `string'
PUBLIC	?SetSaintStatue@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetSaintStatue
;	COMDAT ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) It''s not Saint Statue( Map:%d'
	DB	', BloodCastleIndex:%d, Type:%d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@
CONST	SEGMENT
??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@ DB '['
	DB	'Blood Castle] (%d) Saint Status be created.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetSaintStatue@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv272 = -8						; size = 4
tv274 = -4						; size = 4
_wMonsterType$ = -4					; size = 2
_iBridgeIndex$ = 8					; size = 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetSaintStatue, COMDAT
; _this$ = ecx

; 1807 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1808 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	85 f6		 test	 esi, esi
  0000f	0f 88 a1 01 00
	00		 js	 $LN1@SetSaintSt
  00015	33 c0		 xor	 eax, eax
  00017	83 fe 07	 cmp	 esi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 91 01 00
	00		 je	 $LN1@SetSaintSt

; 1809 : 	{
; 1810 : 		return;
; 1811 : 	}
; 1812 : 
; 1813 : 	int nSaintStatuePosNum = this->m_BridgeData[iBridgeIndex].m_nSaintStatuePosNum;

  00025	8b c6		 mov	 eax, esi
  00027	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002d	53		 push	 ebx
  0002e	8b 9c 38 8c 03
	00 00		 mov	 ebx, DWORD PTR [eax+edi+908]

; 1814 : 
; 1815 : 	WORD wMonsterType = gMSetBase.m_Mp[nSaintStatuePosNum].m_Type; //season3 changed

  00035	8b c3		 mov	 eax, ebx
  00037	c1 e0 04	 shl	 eax, 4
  0003a	0f b7 88 06 00
	00 00		 movzx	 ecx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]

; 1816 : 	BYTE btMapNumber = gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber;
; 1817 : 	BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  00041	0f b6 90 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00048	89 4d fc	 mov	 DWORD PTR _wMonsterType$[ebp], ecx
  0004b	52		 push	 edx
  0004c	8b cf		 mov	 ecx, edi
  0004e	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  00053	89 45 f8	 mov	 DWORD PTR tv272[ebp], eax

; 1818 : 
; 1819 : 	if ( nSaintStatuePosNum != -1 )

  00056	83 fb ff	 cmp	 ebx, -1
  00059	0f 84 56 01 00
	00		 je	 $LN13@SetSaintSt

; 1820 : 	{
; 1821 : 		if ( BC_STATUE_RANGE(wMonsterType-132) != FALSE )

  0005f	0f b7 4d fc	 movzx	 ecx, WORD PTR _wMonsterType$[ebp]
  00063	8d 81 7c ff ff
	ff		 lea	 eax, DWORD PTR [ecx-132]
  00069	89 4d fc	 mov	 DWORD PTR tv274[ebp], ecx
  0006c	85 c0		 test	 eax, eax
  0006e	0f 88 2b 01 00
	00		 js	 $LN3@SetSaintSt
  00074	33 c9		 xor	 ecx, ecx
  00076	83 f8 02	 cmp	 eax, 2
  00079	0f 9e c1	 setle	 cl
  0007c	8b c1		 mov	 eax, ecx
  0007e	85 c0		 test	 eax, eax
  00080	0f 84 16 01 00
	00		 je	 $LN12@SetSaintSt

; 1822 : 		{
; 1823 : 			int result = gObjAddMonster(btMapNumber);

  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0008c	0f bf f0	 movsx	 esi, ax
  0008f	83 c4 04	 add	 esp, 4

; 1824 : 
; 1825 : 			if ( result >= 0 )

  00092	85 f6		 test	 esi, esi
  00094	0f 88 1b 01 00
	00		 js	 $LN13@SetSaintSt

; 1826 : 			{
; 1827 : 				::gObjSetPosMonster(result, nSaintStatuePosNum);

  0009a	53		 push	 ebx
  0009b	56		 push	 esi
  0009c	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1828 : 				::gObjSetMonster(result, wMonsterType);

  000a1	8b 55 fc	 mov	 edx, DWORD PTR tv274[ebp]
  000a4	52		 push	 edx
  000a5	56		 push	 esi
  000a6	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1829 : 				gObj[result].Class = rand() % 3 + 132;

  000ab	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000b1	e8 00 00 00 00	 call	 _rand
  000b6	99		 cdq
  000b7	b9 03 00 00 00	 mov	 ecx, 3
  000bc	f7 f9		 idiv	 ecx
  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1830 : 				gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  000c3	8a 4d f8	 mov	 cl, BYTE PTR tv272[ebp]
  000c6	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  000cc	66 89 94 06 b8
	00 00 00	 mov	 WORD PTR [esi+eax+184], dx
  000d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000da	88 8c 16 9e 0e
	00 00		 mov	 BYTE PTR [esi+edx+3742], cl

; 1831 : 				gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  000e1	66 8b 87 14 23
	00 00		 mov	 ax, WORD PTR [edi+8980]
  000e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	66 89 84 16 b8
	04 00 00	 mov	 WORD PTR [esi+edx+1208], ax

; 1832 : 				gObj[result].Dir = 1;

  000f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fc	b8 01 00 00 00	 mov	 eax, 1
  00101	88 84 16 48 01
	00 00		 mov	 BYTE PTR [esi+edx+328], al

; 1833 : 				gObj[result].m_PosNum = -1;

  00108	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	83 ca ff	 or	 edx, -1
  00111	66 89 94 1e b0
	03 00 00	 mov	 WORD PTR [esi+ebx+944], dx

; 1834 : 				gObj[result].Live = TRUE;

  00119	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	88 44 16 6a	 mov	 BYTE PTR [esi+edx+106], al

; 1835 : 				gObj[result].DieRegen = 0;

  00123	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1836 : 				gObj[result].m_State = 1;
; 1837 : 				gObj[result].MaxRegenTime = 0;
; 1838 : 				gObj[result].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  00129	0f b6 c9	 movzx	 ecx, cl
  0012c	c6 84 16 a2 03
	00 00 00	 mov	 BYTE PTR [esi+edx+930], 0
  00134	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  0013a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00140	89 84 16 20 02
	00 00		 mov	 DWORD PTR [esi+edx+544], eax
  00147	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014c	c7 84 06 ac 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+940], 0
  00157	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015d	d9 84 39 c4 03
	00 00		 fld	 DWORD PTR [ecx+edi+964]
  00164	8d 84 39 c4 03
	00 00		 lea	 eax, DWORD PTR [ecx+edi+964]

; 1839 : 				gObj[result].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;
; 1840 : 
; 1841 : 				LogAddTD("[Blood Castle] (%d) Saint Status be created.", iBridgeIndex+1); //season 2.5 add-on

  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0016e	d9 9c 16 00 01
	00 00		 fstp	 DWORD PTR [esi+edx+256]
  00175	41		 inc	 ecx
  00176	d9 00		 fld	 DWORD PTR [eax]
  00178	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017d	51		 push	 ecx
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@
  00183	d9 9c 06 fc 00
	00 00		 fstp	 DWORD PTR [esi+eax+252]
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00190	83 c4 18	 add	 esp, 24			; 00000018H
  00193	5b		 pop	 ebx
  00194	5f		 pop	 edi
  00195	5e		 pop	 esi

; 1847 : 		}
; 1848 : 	}
; 1849 : 
; 1850 : }

  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 04 00	 ret	 4
$LN12@SetSaintSt:

; 1820 : 	{
; 1821 : 		if ( BC_STATUE_RANGE(wMonsterType-132) != FALSE )

  0019c	8b 4d fc	 mov	 ecx, DWORD PTR tv274[ebp]
$LN3@SetSaintSt:

; 1842 : 			}
; 1843 : 		}
; 1844 : 		else
; 1845 : 		{
; 1846 : 			LogAddTD("[Blood Castle][Bug Tracer] (%d) It's not Saint Statue( Map:%d, BloodCastleIndex:%d, Type:%d )", iBridgeIndex+1, btMapNumber, this->GetBridgeIndex(btMapNumber), wMonsterType); //season3 changed

  0019f	8b 45 f8	 mov	 eax, DWORD PTR tv272[ebp]
  001a2	51		 push	 ecx
  001a3	50		 push	 eax
  001a4	52		 push	 edx
  001a5	46		 inc	 esi
  001a6	56		 push	 esi
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b2	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@SetSaintSt:
  001b5	5b		 pop	 ebx
$LN1@SetSaintSt:
  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi

; 1847 : 		}
; 1848 : 	}
; 1849 : 
; 1850 : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 04 00	 ret	 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetSaintStatue
_TEXT	ENDS
PUBLIC	?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z	; CBloodCastle::CheckUsersOnConnect
; Function compile flags: /Ogtp
;	COMDAT ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv197 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::CheckUsersOnConnect, COMDAT
; _this$ = ecx

; 2050 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2051 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 ff		 test	 edi, edi
  0000d	0f 88 7c 00 00
	00		 js	 $LN9@CheckUsers
  00013	33 c0		 xor	 eax, eax
  00015	83 ff 07	 cmp	 edi, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 70		 je	 SHORT $LN9@CheckUsers

; 2052 : 	{
; 2053 : 		return;
; 2054 : 	}
; 2055 : 
; 2056 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	8b f7		 mov	 esi, edi
  00023	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00029	03 f1		 add	 esi, ecx
  0002b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002e	50		 push	 eax
  0002f	89 45 08	 mov	 DWORD PTR tv197[ebp], eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00038	83 c6 1c	 add	 esi, 28			; 0000001cH
  0003b	bb 28 00 00 00	 mov	 ebx, 40			; 00000028H
$LL7@CheckUsers:

; 2059 : 	{
; 2060 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 36		 je	 SHORT $LN6@CheckUsers

; 2061 : 		{
; 2062 : 			if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004d	83 c4 04	 add	 esp, 4
  00050	85 c0		 test	 eax, eax

; 2063 : 			{
; 2064 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;
; 2065 : 			}
; 2066 : 			else

  00052	74 23		 je	 SHORT $LN15@CheckUsers

; 2067 : 			{
; 2068 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber != this->GetBridgeMapNumber(iBridgeIndex) ) //season3 changed

  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	57		 push	 edi
  00058	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0005d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00065	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0006b	0f b6 8c 11 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+edx+329]
  00073	3b c8		 cmp	 ecx, eax
  00075	74 06		 je	 SHORT $LN6@CheckUsers
$LN15@CheckUsers:

; 2069 : 				{
; 2070 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00077	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN6@CheckUsers:

; 2057 : 
; 2058 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0007d	83 c6 14	 add	 esi, 20			; 00000014H
  00080	4b		 dec	 ebx
  00081	75 bd		 jne	 SHORT $LL7@CheckUsers

; 2071 : 				}
; 2072 : 			}
; 2073 : 		}
; 2074 : 	}
; 2075 : 
; 2076 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00083	8b 55 08	 mov	 edx, DWORD PTR tv197[ebp]
  00086	52		 push	 edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
$LN9@CheckUsers:
  0008f	5f		 pop	 edi

; 2077 : 
; 2078 : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::CheckUsersOnConnect
_TEXT	ENDS
PUBLIC	?BlockCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleEntrance
; Function compile flags: /Ogtp
;	COMDAT ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleEntrance, COMDAT
; _this$ = ecx

; 2108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2109 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	0f 88 81 00 00
	00		 js	 $LN4@BlockCastl
  00013	33 c0		 xor	 eax, eax
  00015	83 fb 07	 cmp	 ebx, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 75		 je	 SHORT $LN4@BlockCastl

; 2110 : 	{
; 2111 : 		return;
; 2112 : 	}
; 2113 : 
; 2114 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  0001f	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  00027	57		 push	 edi
  00028	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleEntranceMapXY[ebx*4]
  00030	3b f8		 cmp	 edi, eax
  00032	7f 5f		 jg	 SHORT $LN17@BlockCastl
  00034	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  0003c	56		 push	 esi
  0003d	8d 49 00	 npad	 3
$LL16@BlockCastl:

; 2115 : 	{
; 2116 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 39		 jg	 SHORT $LN5@BlockCastl

; 2117 : 		{
; 2118 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00055	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0005b	8b ca		 mov	 ecx, edx
  0005d	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00063	c1 e1 08	 shl	 ecx, 8
$LL3@BlockCastl:

; 2119 : 
; 2120 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] |= 4; //season3 changed

  00066	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00068	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0006b	80 0c 18 04	 or	 BYTE PTR [eax+ebx], 4
  0006f	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00072	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  0007a	42		 inc	 edx
  0007b	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00081	3b d0		 cmp	 edx, eax
  00083	7e e1		 jle	 SHORT $LL3@BlockCastl
$LN5@BlockCastl:

; 2110 : 	{
; 2111 : 		return;
; 2112 : 	}
; 2113 : 
; 2114 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00085	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  0008d	47		 inc	 edi
  0008e	3b f9		 cmp	 edi, ecx
  00090	7e ae		 jle	 SHORT $LL16@BlockCastl
  00092	5e		 pop	 esi
$LN17@BlockCastl:
  00093	5f		 pop	 edi
$LN4@BlockCastl:
  00094	5b		 pop	 ebx

; 2121 : 		}
; 2122 : 	}
; 2123 : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleEntrance
_TEXT	ENDS
PUBLIC	?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleEntrance
; Function compile flags: /Ogtp
;	COMDAT ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::ReleaseCastleEntrance, COMDAT
; _this$ = ecx

; 2127 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2128 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	0f 88 81 00 00
	00		 js	 $LN4@ReleaseCas
  00013	33 c0		 xor	 eax, eax
  00015	83 fb 07	 cmp	 ebx, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 75		 je	 SHORT $LN4@ReleaseCas

; 2129 : 	{
; 2130 : 		return;
; 2131 : 	}
; 2132 : 
; 2133 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  0001f	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  00027	57		 push	 edi
  00028	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleEntranceMapXY[ebx*4]
  00030	3b f8		 cmp	 edi, eax
  00032	7f 5f		 jg	 SHORT $LN17@ReleaseCas
  00034	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  0003c	56		 push	 esi
  0003d	8d 49 00	 npad	 3
$LL16@ReleaseCas:

; 2134 : 	{
; 2135 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 39		 jg	 SHORT $LN5@ReleaseCas

; 2136 : 		{
; 2137 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00055	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0005b	8b ca		 mov	 ecx, edx
  0005d	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00063	c1 e1 08	 shl	 ecx, 8
$LL3@ReleaseCas:

; 2138 : 
; 2139 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] &= ~4; //season3 changed

  00066	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00068	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0006b	80 24 18 fb	 and	 BYTE PTR [eax+ebx], 251	; 000000fbH
  0006f	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00072	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+3]
  0007a	42		 inc	 edx
  0007b	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00081	3b d0		 cmp	 edx, eax
  00083	7e e1		 jle	 SHORT $LL3@ReleaseCas
$LN5@ReleaseCas:

; 2129 : 	{
; 2130 : 		return;
; 2131 : 	}
; 2132 : 
; 2133 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00085	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleEntranceMapXY[ebx*4+2]
  0008d	47		 inc	 edi
  0008e	3b f9		 cmp	 edi, ecx
  00090	7e ae		 jle	 SHORT $LL16@ReleaseCas
  00092	5e		 pop	 esi
$LN17@ReleaseCas:
  00093	5f		 pop	 edi
$LN4@ReleaseCas:
  00094	5b		 pop	 ebx

; 2140 : 		}
; 2141 : 	}
; 2142 : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::ReleaseCastleEntrance
_TEXT	ENDS
PUBLIC	?BlockCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleBridge
; Function compile flags: /Ogtp
;	COMDAT ?BlockCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleBridge, COMDAT
; _this$ = ecx

; 2146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2147 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	0f 88 81 00 00
	00		 js	 $LN4@BlockCastl@2
  00013	33 c0		 xor	 eax, eax
  00015	83 fb 07	 cmp	 ebx, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 75		 je	 SHORT $LN4@BlockCastl@2

; 2148 : 	{
; 2149 : 		return;
; 2150 : 	}
; 2151 : 
; 2152 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  0001f	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+2]
  00027	57		 push	 edi
  00028	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleBridgeMapXY[ebx*4]
  00030	3b f8		 cmp	 edi, eax
  00032	7f 5f		 jg	 SHORT $LN17@BlockCastl@2
  00034	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+3]
  0003c	56		 push	 esi
  0003d	8d 49 00	 npad	 3
$LL16@BlockCastl@2:

; 2153 : 	{
; 2154 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 14 9d 01
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+1]
  00048	3b d0		 cmp	 edx, eax
  0004a	7f 39		 jg	 SHORT $LN5@BlockCastl@2

; 2155 : 		{
; 2156 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00055	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0005b	8b ca		 mov	 ecx, edx
  0005d	8d b0 10 00 00
	00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00063	c1 e1 08	 shl	 ecx, 8
$LL3@BlockCastl@2:

; 2157 : 
; 2158 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] |= 8; //season3 changed

  00066	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00068	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0006b	80 0c 18 08	 or	 BYTE PTR [eax+ebx], 8
  0006f	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00072	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+3]
  0007a	42		 inc	 edx
  0007b	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00081	3b d0		 cmp	 edx, eax
  00083	7e e1		 jle	 SHORT $LL3@BlockCastl@2
$LN5@BlockCastl@2:

; 2148 : 	{
; 2149 : 		return;
; 2150 : 	}
; 2151 : 
; 2152 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00085	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+2]
  0008d	47		 inc	 edi
  0008e	3b f9		 cmp	 edi, ecx
  00090	7e ae		 jle	 SHORT $LL16@BlockCastl@2
  00092	5e		 pop	 esi
$LN17@BlockCastl@2:
  00093	5f		 pop	 edi
$LN4@BlockCastl@2:
  00094	5b		 pop	 ebx

; 2159 : 		}
; 2160 : 	}
; 2161 : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleBridge
_TEXT	ENDS
PUBLIC	??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ ; `string'
PUBLIC	??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@ ; `string'
PUBLIC	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleBridge
;	COMDAT ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
CONST	SEGMENT
??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ DB '['
	DB	'Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@
CONST	SEGMENT
??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Castle Door Subsist', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv216 = -12						; size = 4
_this$ = -8						; size = 4
_i$219396 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleBridge, COMDAT
; _this$ = ecx

; 2165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 2166 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 88 c6 00 00
	00		 js	 $LN4@ReleaseCas@2
  00015	33 c0		 xor	 eax, eax
  00017	83 fb 07	 cmp	 ebx, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 b6 00 00
	00		 je	 $LN4@ReleaseCas@2

; 2167 : 	{
; 2168 : 		return;
; 2169 : 	}
; 2170 : 
; 2171 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00025	0f b6 14 9d 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleBridgeMapXY[ebx*4]
  0002d	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+2]
  00035	89 55 fc	 mov	 DWORD PTR _i$219396[ebp], edx
  00038	3b d0		 cmp	 edx, eax
  0003a	0f 8f 9b 00 00
	00		 jg	 $LN4@ReleaseCas@2
  00040	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+3]
  00048	56		 push	 esi
  00049	57		 push	 edi
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL17@ReleaseCas@2:

; 2172 : 	{
; 2173 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  00050	0f b6 3c 9d 01
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+1]
  00058	3b f8		 cmp	 edi, eax
  0005a	7f 69		 jg	 SHORT $LN5@ReleaseCas@2

; 2174 : 		{
; 2175 : 			int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	53		 push	 ebx
  00060	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00065	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0006b	8d 88 10 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00071	8b f7		 mov	 esi, edi
  00073	43		 inc	 ebx
  00074	89 4d f4	 mov	 DWORD PTR tv216[ebp], ecx
  00077	c1 e6 08	 shl	 esi, 8
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL16@ReleaseCas@2:

; 2176 : 
; 2177 : 			MapC[iMapNumber].m_attrbuf[j * 256 + i] &= ~8; //season3 changed

  00080	8b 45 f4	 mov	 eax, DWORD PTR tv216[ebp]
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	03 d6		 add	 edx, esi
  00087	80 24 0a f7	 and	 BYTE PTR [edx+ecx], 247	; 000000f7H
  0008b	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2178 : 
; 2179 : 			LogAddTD("[Blood Castle] (%d) Castle Door Subsist", iBridgeIndex+1); //season 2.5 add-on

  0008e	53		 push	 ebx
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2180 : 
; 2181 : 			LogAddTD("[Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d", iBridgeIndex+1);

  0009a	53		 push	 ebx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a6	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000a9	0f b6 04 95 03
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleBridgeMapXY[edx*4+3]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _i$219396[ebp]
  000b4	47		 inc	 edi
  000b5	83 c4 10	 add	 esp, 16			; 00000010H
  000b8	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  000be	3b f8		 cmp	 edi, eax
  000c0	7e be		 jle	 SHORT $LL16@ReleaseCas@2

; 2172 : 	{
; 2173 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  000c2	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@ReleaseCas@2:

; 2167 : 	{
; 2168 : 		return;
; 2169 : 	}
; 2170 : 
; 2171 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  000c5	0f b6 0c 9d 02
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleBridgeMapXY[ebx*4+2]
  000cd	42		 inc	 edx
  000ce	89 55 fc	 mov	 DWORD PTR _i$219396[ebp], edx
  000d1	3b d1		 cmp	 edx, ecx
  000d3	0f 8e 77 ff ff
	ff		 jle	 $LL17@ReleaseCas@2
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
$LN4@ReleaseCas@2:
  000db	5b		 pop	 ebx

; 2182 : 		}
; 2183 : 	}
; 2184 : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 04 00	 ret	 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleBridge
_TEXT	ENDS
PUBLIC	?BlockCastleDoor@CBloodCastle@@QAEXH@Z		; CBloodCastle::BlockCastleDoor
; Function compile flags: /Ogtp
;	COMDAT ?BlockCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv407 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleDoor, COMDAT
; _this$ = ecx

; 2188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2189 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 7f		 js	 SHORT $LN7@BlockCastl@3
  00010	33 c0		 xor	 eax, eax
  00012	83 f9 07	 cmp	 ecx, 7
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	74 73		 je	 SHORT $LN7@BlockCastl@3

; 2190 : 	{
; 2191 : 		return;
; 2192 : 	}
; 2193 : 
; 2194 : 	for ( int x=0;x<3;x++)

  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	8d 34 49	 lea	 esi, DWORD PTR [ecx+ecx*2]
  00021	57		 push	 edi
  00022	8d 34 b5 03 00
	00 00		 lea	 esi, DWORD PTR _g_btCastleDoorMapXY[esi*4+3]
  00029	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR tv407[ebp], 3
$LL9@BlockCastl@3:

; 2195 : 	{
; 2196 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00030	0f b6 5e fd	 movzx	 ebx, BYTE PTR [esi-3]
  00034	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00038	3b d8		 cmp	 ebx, eax
  0003a	7f 48		 jg	 SHORT $LN8@BlockCastl@3
  0003c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0003f	90		 npad	 1
$LL21@BlockCastl@3:

; 2197 : 		{
; 2198 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00040	0f b6 56 fe	 movzx	 edx, BYTE PTR [esi-2]
  00044	3b d0		 cmp	 edx, eax
  00046	7f 33		 jg	 SHORT $LN5@BlockCastl@3

; 2199 : 			{
; 2200 : 				int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  00048	51		 push	 ecx
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00051	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00057	8b ca		 mov	 ecx, edx
  00059	8d b8 10 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0005f	c1 e1 08	 shl	 ecx, 8
$LL3@BlockCastl@3:

; 2201 : 
; 2202 : 				MapC[iMapNumber].m_attrbuf[z * 256 + y] |= 4; //season3 changed

  00062	8b 07		 mov	 eax, DWORD PTR [edi]
  00064	03 c1		 add	 eax, ecx
  00066	80 0c 18 04	 or	 BYTE PTR [eax+ebx], 4
  0006a	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0006d	42		 inc	 edx
  0006e	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00074	3b d0		 cmp	 edx, eax
  00076	7e ea		 jle	 SHORT $LL3@BlockCastl@3

; 2197 : 		{
; 2198 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@BlockCastl@3:

; 2195 : 	{
; 2196 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  0007b	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  0007f	43		 inc	 ebx
  00080	3b da		 cmp	 ebx, edx
  00082	7e bc		 jle	 SHORT $LL21@BlockCastl@3
$LN8@BlockCastl@3:

; 2190 : 	{
; 2191 : 		return;
; 2192 : 	}
; 2193 : 
; 2194 : 	for ( int x=0;x<3;x++)

  00084	83 c6 04	 add	 esi, 4
  00087	ff 4d fc	 dec	 DWORD PTR tv407[ebp]
  0008a	75 a4		 jne	 SHORT $LL9@BlockCastl@3
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
$LN7@BlockCastl@3:

; 2203 : 			}
; 2204 : 		}
; 2205 : 	}
; 2206 : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleDoor
_TEXT	ENDS
PUBLIC	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleDoor
; Function compile flags: /Ogtp
;	COMDAT ?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv407 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleDoor, COMDAT
; _this$ = ecx

; 2210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2211 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 7f		 js	 SHORT $LN7@ReleaseCas@3
  00010	33 c0		 xor	 eax, eax
  00012	83 f9 07	 cmp	 ecx, 7
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	74 73		 je	 SHORT $LN7@ReleaseCas@3

; 2212 : 	{
; 2213 : 		return;
; 2214 : 	}
; 2215 : 
; 2216 : 	for ( int x=0;x<3;x++)

  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	8d 34 49	 lea	 esi, DWORD PTR [ecx+ecx*2]
  00021	57		 push	 edi
  00022	8d 34 b5 03 00
	00 00		 lea	 esi, DWORD PTR _g_btCastleDoorMapXY[esi*4+3]
  00029	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR tv407[ebp], 3
$LL9@ReleaseCas@3:

; 2217 : 	{
; 2218 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00030	0f b6 5e fd	 movzx	 ebx, BYTE PTR [esi-3]
  00034	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00038	3b d8		 cmp	 ebx, eax
  0003a	7f 48		 jg	 SHORT $LN8@ReleaseCas@3
  0003c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0003f	90		 npad	 1
$LL21@ReleaseCas@3:

; 2219 : 		{
; 2220 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00040	0f b6 56 fe	 movzx	 edx, BYTE PTR [esi-2]
  00044	3b d0		 cmp	 edx, eax
  00046	7f 33		 jg	 SHORT $LN5@ReleaseCas@3

; 2221 : 			{
; 2222 : 				int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  00048	51		 push	 ecx
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00051	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00057	8b ca		 mov	 ecx, edx
  00059	8d b8 10 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0005f	c1 e1 08	 shl	 ecx, 8
$LL3@ReleaseCas@3:

; 2223 : 
; 2224 : 				MapC[iMapNumber].m_attrbuf[z * 256 + y] &= ~4; //season3 changed

  00062	8b 07		 mov	 eax, DWORD PTR [edi]
  00064	03 c1		 add	 eax, ecx
  00066	80 24 18 fb	 and	 BYTE PTR [eax+ebx], 251	; 000000fbH
  0006a	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0006d	42		 inc	 edx
  0006e	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00074	3b d0		 cmp	 edx, eax
  00076	7e ea		 jle	 SHORT $LL3@ReleaseCas@3

; 2219 : 		{
; 2220 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@ReleaseCas@3:

; 2217 : 	{
; 2218 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  0007b	0f b6 56 ff	 movzx	 edx, BYTE PTR [esi-1]
  0007f	43		 inc	 ebx
  00080	3b da		 cmp	 ebx, edx
  00082	7e bc		 jle	 SHORT $LL21@ReleaseCas@3
$LN8@ReleaseCas@3:

; 2212 : 	{
; 2213 : 		return;
; 2214 : 	}
; 2215 : 
; 2216 : 	for ( int x=0;x<3;x++)

  00084	83 c6 04	 add	 esi, 4
  00087	ff 4d fc	 dec	 DWORD PTR tv407[ebp]
  0008a	75 a4		 jne	 SHORT $LL9@ReleaseCas@3
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
$LN7@ReleaseCas@3:

; 2225 : 			}
; 2226 : 		}
; 2227 : 	}
; 2228 : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleDoor
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z PROC ; CBloodCastle::SendCastleEntranceBlockInfo, COMDAT
; _this$ = ecx

; 2264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 2265 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00015	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 d0 00 00
	00		 js	 $LN3@SendCastle
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 07	 cmp	 esi, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 c0 00 00
	00		 je	 $LN3@SendCastle

; 2266 : 	{
; 2267 : 		return;
; 2268 : 	}
; 2269 : 
; 2270 : 	char cTEMP_BUF[256];
; 2271 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2272 : 
; 2273 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	57		 push	 edi
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2274 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2275 : 	lpMsg->btType = 0;
; 2276 : 	lpMsg->btCount = 1;
; 2277 : 	lpMsg->btMapAttr = 4;
; 2278 : 	(bLive)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);
; 2279 : 
; 2280 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  00043	0f b6 14 b5 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4]

; 2281 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;

  0004b	8a 04 b5 01 00
	00 00		 mov	 al, BYTE PTR _g_btCastleEntranceMapXY[esi*4+1]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0
  00059	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2282 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;
; 2283 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;

  0005f	0f b6 14 b5 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4+3]
  00067	0f 94 c1	 sete	 cl
  0006a	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl
  00070	8a 0c b5 02 00
	00 00		 mov	 cl, BYTE PTR _g_btCastleEntranceMapXY[esi*4+2]
  00077	88 8d 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], cl

; 2286 : 	{
; 2287 : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0007d	56		 push	 esi
  0007e	8b cb		 mov	 ecx, ebx
  00080	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  00087	66 c7 85 ff fe
	ff ff 00 04	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 1024 ; 00000400H
  00090	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  00096	88 95 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], dl
  0009c	bf c8 32 00 00	 mov	 edi, 13000		; 000032c8H
  000a1	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  000a6	8b d8		 mov	 ebx, eax
  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ad	be 80 76 97 08	 mov	 esi, 144144000		; 08977680H
$LL5@SendCastle:

; 2288 : 
; 2289 : 		if ( gObj[i].MapNumber == iMapNumber ) //season3 changed

  000b2	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  000ba	3b cb		 cmp	 ecx, ebx
  000bc	75 24		 jne	 SHORT $LN4@SendCastle

; 2290 : 		{
; 2291 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000be	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  000c3	7e 1d		 jle	 SHORT $LN4@SendCastle

; 2292 : 			{
; 2293 : 				DataSend(i,(LPBYTE)lpMsg, lpMsg->h.size);

  000c5	0f b6 95 fd fe
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+1]
  000cc	52		 push	 edx
  000cd	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  000d3	50		 push	 eax
  000d4	57		 push	 edi
  000d5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendCastle:

; 2284 : 
; 2285 : 	for (int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  000e2	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  000e8	47		 inc	 edi
  000e9	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  000ef	7c c1		 jl	 SHORT $LL5@SendCastle
  000f1	5f		 pop	 edi
$LN3@SendCastle:

; 2294 : 			}
; 2295 : 		}
; 2296 : 	}
; 2297 : 
; 2298 : }

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f5	5e		 pop	 esi
  000f6	33 cd		 xor	 ecx, ebp
  000f8	5b		 pop	 ebx
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP ; CBloodCastle::SendCastleEntranceBlockInfo
_TEXT	ENDS
PUBLIC	??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo
;	COMDAT ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
CONST	SEGMENT
??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ DB '['
	DB	'Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:'
	DB	'%d/Live:%d, (%d,%d,%d,%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv225 = -264						; size = 4
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleBridgeBlockInfo, COMDAT
; _this$ = ecx

; 2302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 2303 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 16 01 00
	00		 js	 $LN3@SendCastle@2
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 07	 cmp	 esi, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 06 01 00
	00		 je	 $LN3@SendCastle@2

; 2304 : 	{
; 2305 : 		return;
; 2306 : 	}
; 2307 : 
; 2308 : 	char cTEMP_BUF[256];
; 2309 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2310 : 
; 2311 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	53		 push	 ebx
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2312 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2313 : 	lpMsg->btType = 0;
; 2314 : 	lpMsg->btCount = 1;
; 2315 : 	lpMsg->btMapAttr = 8;
; 2316 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;
; 2317 : 
; 2318 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  00043	0f b6 14 b5 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4]

; 2319 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;

  0004b	8a 04 b5 01 00
	00 00		 mov	 al, BYTE PTR _g_btCastleEntranceMapXY[esi*4+1]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0
  00059	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2320 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;
; 2321 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;

  0005f	0f b6 14 b5 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleEntranceMapXY[esi*4+3]
  00067	0f 94 c1	 sete	 cl
  0006a	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl
  00070	8a 0c b5 02 00
	00 00		 mov	 cl, BYTE PTR _g_btCastleEntranceMapXY[esi*4+2]
  00077	88 8d 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], cl

; 2324 : 	{
; 2325 : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  0007d	56		 push	 esi
  0007e	8b cf		 mov	 ecx, edi
  00080	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  00087	66 c7 85 ff fe
	ff ff 00 08	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 2048 ; 00000800H
  00090	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  00096	88 95 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], dl
  0009c	bb c8 32 00 00	 mov	 ebx, 13000		; 000032c8H
  000a1	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  000a6	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv225[ebp], eax
  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b1	bf 80 76 97 08	 mov	 edi, 144144000		; 08977680H
  000b6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL15@SendCastle@2:

; 2326 : 
; 2327 : 		if ( gObj[i].MapNumber == iMapNumber ) //season3 changed

  000c0	0f b6 8c 07 49
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+329]
  000c8	3b 8d f8 fe ff
	ff		 cmp	 ecx, DWORD PTR tv225[ebp]
  000ce	75 58		 jne	 SHORT $LN4@SendCastle@2

; 2328 : 		{
; 2329 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000d0	83 7c 07 04 02	 cmp	 DWORD PTR [edi+eax+4], 2
  000d5	7e 51		 jle	 SHORT $LN4@SendCastle@2

; 2330 : 			{
; 2331 : 				DataSend(i, (LPBYTE)lpMsg, lpMsg->h.size);

  000d7	0f b6 95 fd fe
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+1]
  000de	52		 push	 edx
  000df	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  000e5	50		 push	 eax
  000e6	53		 push	 ebx
  000e7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2332 : 
; 2333 : 				LogAddTD("[Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:%d/Live:%d, (%d,%d,%d,%d)", iBridgeIndex+1, bLive, lpMsgBody[0].btX, lpMsgBody[0].btY, lpMsgBody[1].btX, lpMsgBody[1].btY);

  000ec	0f b6 8d 06 ff
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+10]
  000f3	0f b6 95 05 ff
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+9]
  000fa	0f b6 85 04 ff
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+8]
  00101	51		 push	 ecx
  00102	0f b6 8d 03 ff
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+7]
  00109	52		 push	 edx
  0010a	0f b6 55 0c	 movzx	 edx, BYTE PTR _bLive$[ebp]
  0010e	50		 push	 eax
  0010f	51		 push	 ecx
  00110	52		 push	 edx
  00111	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00114	50		 push	 eax
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00125	83 c4 28	 add	 esp, 40			; 00000028H
$LN4@SendCastle@2:

; 2322 : 
; 2323 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00128	81 c7 50 2b 00
	00		 add	 edi, 11088		; 00002b50H
  0012e	43		 inc	 ebx
  0012f	81 ff 80 d7 e9
	09		 cmp	 edi, 166320000		; 09e9d780H
  00135	7c 89		 jl	 SHORT $LL15@SendCastle@2
  00137	5b		 pop	 ebx
$LN3@SendCastle@2:

; 2334 : 			}
; 2335 : 		}
; 2336 : 	}
; 2337 : }

  00138	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013b	5f		 pop	 edi
  0013c	33 cd		 xor	 ecx, ebp
  0013e	5e		 pop	 esi
  0013f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c2 08 00	 ret	 8
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleBridgeBlockInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleDoorBlockInfo, COMDAT
; _this$ = ecx

; 2341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 2342 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00015	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 3e 01 00
	00		 js	 $LN3@SendCastle@3
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 07	 cmp	 esi, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 2e 01 00
	00		 je	 $LN3@SendCastle@3

; 2343 : 	{
; 2344 : 		return;
; 2345 : 	}
; 2346 : 
; 2347 : 	char cTEMP_BUF[256];
; 2348 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2349 : 
; 2350 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	57		 push	 edi
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2351 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2352 : 	lpMsg->btType = 0;
; 2353 : 	lpMsg->btCount = 3;
; 2354 : 	lpMsg->btMapAttr = 4;
; 2355 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;

  00046	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0

; 2356 : 
; 2357 : 	lpMsgBody[0].btX = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartX;

  0004a	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0004d	0f 94 c1	 sete	 cl
  00050	03 c0		 add	 eax, eax
  00052	0f b6 94 00 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+eax]
  0005a	03 c0		 add	 eax, eax
  0005c	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl

; 2358 : 	lpMsgBody[0].btY = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartY;

  00062	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+1]
  00069	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2359 : 	lpMsgBody[1].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndX;

  0006f	0f b6 90 02 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+2]
  00076	88 8d 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], cl

; 2360 : 	lpMsgBody[1].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndY;

  0007c	0f b6 88 03 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+3]
  00083	88 95 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], dl

; 2361 : 
; 2362 : 	lpMsgBody[2].btX = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartX;

  00089	0f b6 90 04 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+4]
  00090	88 8d 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], cl

; 2363 : 	lpMsgBody[2].btY = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartY;

  00096	0f b6 88 05 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+5]
  0009d	88 95 07 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+11], dl

; 2364 : 	lpMsgBody[3].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndX;

  000a3	0f b6 90 06 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+6]
  000aa	88 8d 08 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+12], cl

; 2365 : 	lpMsgBody[3].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndY;

  000b0	0f b6 88 07 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+7]
  000b7	88 95 09 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+13], dl

; 2366 : 
; 2367 : 	lpMsgBody[4].btX = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartX;

  000bd	0f b6 90 08 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+8]
  000c4	88 8d 0a ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+14], cl

; 2368 : 	lpMsgBody[4].btY = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartY;

  000ca	0f b6 88 09 00
	00 00		 movzx	 ecx, BYTE PTR _g_btCastleDoorMapXY[eax+9]
  000d1	88 95 0b ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+15], dl

; 2369 : 	lpMsgBody[5].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndX;

  000d7	0f b6 90 0a 00
	00 00		 movzx	 edx, BYTE PTR _g_btCastleDoorMapXY[eax+10]

; 2370 : 	lpMsgBody[5].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndY;

  000de	8a 80 0b 00 00
	00		 mov	 al, BYTE PTR _g_btCastleDoorMapXY[eax+11]
  000e4	88 8d 0c ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+16], cl

; 2373 : 	{
; 2374 : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  000ea	56		 push	 esi
  000eb	8b cb		 mov	 ecx, ebx
  000ed	c6 85 02 ff ff
	ff 03		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 3
  000f4	66 c7 85 ff fe
	ff ff 00 04	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 1024 ; 00000400H
  000fd	88 95 0d ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+17], dl
  00103	88 85 0e ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+18], al
  00109	bf c8 32 00 00	 mov	 edi, 13000		; 000032c8H
  0010e	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00113	8b d8		 mov	 ebx, eax
  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011a	be 80 76 97 08	 mov	 esi, 144144000		; 08977680H
  0011f	90		 npad	 1
$LL5@SendCastle@3:

; 2375 : 
; 2376 : 		if ( gObj[i].MapNumber == iMapNumber ) //season3 changed

  00120	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00128	3b cb		 cmp	 ecx, ebx
  0012a	75 24		 jne	 SHORT $LN4@SendCastle@3

; 2377 : 		{
; 2378 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  0012c	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  00131	7e 1d		 jle	 SHORT $LN4@SendCastle@3

; 2379 : 			{
; 2380 : 				DataSend(i, (LPBYTE)lpMsg, lpMsg->h.size);

  00133	0f b6 95 fd fe
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+1]
  0013a	52		 push	 edx
  0013b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00141	50		 push	 eax
  00142	57		 push	 edi
  00143	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendCastle@3:

; 2371 : 
; 2372 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00150	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00156	47		 inc	 edi
  00157	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  0015d	7c c1		 jl	 SHORT $LL5@SendCastle@3
  0015f	5f		 pop	 edi
$LN3@SendCastle@3:

; 2381 : 			}
; 2382 : 		}
; 2383 : 	}
; 2384 : }

  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	5e		 pop	 esi
  00164	33 cd		 xor	 ecx, ebp
  00166	5b		 pop	 ebx
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c2 08 00	 ret	 8
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleDoorBlockInfo
_TEXT	ENDS
PUBLIC	??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ ; `string'
PUBLIC	_iIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GiveReward_Win@CBloodCastle@@QAEXHH@Z		; CBloodCastle::GiveReward_Win
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
;	COMDAT ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
; File e:\work\tranet_version\gs\gameserver\tnotice.h
CONST	SEGMENT
??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:'
	DB	'%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:'
	DB	'%d, MapNumber:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
CONST	SEGMENT
??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete - All Alive User''s Total E'
	DB	'XP:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
CONST	SEGMENT
??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ DB '['
	DB	'Blood Castle] (%d) Winner Party Point - Alive Party Member : '
	DB	'%d, Alive Party Point : %d', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
CONST	ENDS
;	COMDAT ?GiveReward_Win@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv1247 = -1568						; size = 4
_iADD_PARTYPOINT$ = -1564				; size = 4
_iALIVE_PARTYCOUNT$ = -1560				; size = 4
_iIndex$GSCopy$ = -1556					; size = 4
_i$219730 = -1556					; size = 4
tv2181 = -1552						; size = 4
tv2150 = -1548						; size = 4
_iLEFT_TIME$ = -1544					; size = 4
_iREWARD_EXP$ = -1540					; size = 4
_iREWARD_ZEN$ = -1536					; size = 4
tv1217 = -1532						; size = 4
_this$GSCopy$ = -1528					; size = 4
_pMsg$219765 = -1524					; size = 989
_pNotice$219738 = -532					; size = 272
_szNOTIFY_MSG$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iBridgeIndex$ = 12					; size = 4
?GiveReward_Win@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::GiveReward_Win, COMDAT
; _this$ = ecx

; 2717 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 06 00
	00		 sub	 esp, 1568		; 00000620H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx

; 2718 : 	this->FixUsersPlayStateWin(iBridgeIndex);

  0001e	56		 push	 esi

; 2719 : 	char szNOTIFY_MSG[256];
; 2720 : 	int iREWARD_EXP = 0;

  0001f	89 bd 08 fa ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi

; 2755 : 	{
; 2756 : 		int iTOTAL_EXP = this->GetAliveUserTotalEXP(iBridgeIndex);

  00025	89 85 ec f9 ff
	ff		 mov	 DWORD PTR _iIndex$GSCopy$[ebp], eax
  0002b	e8 00 00 00 00	 call	 ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateWin
  00030	8b c6		 mov	 eax, esi
  00032	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00038	8b 8c 38 ac 03
	00 00		 mov	 ecx, DWORD PTR [eax+edi+940]
  0003f	03 c7		 add	 eax, edi
  00041	89 85 04 fa ff
	ff		 mov	 DWORD PTR tv1217[ebp], eax
  00047	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0004c	f7 e9		 imul	 ecx
  0004e	c1 fa 06	 sar	 edx, 6
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00056	33 db		 xor	 ebx, ebx
  00058	03 c2		 add	 eax, edx
  0005a	56		 push	 esi
  0005b	8b cf		 mov	 ecx, edi
  0005d	89 9d fc f9 ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], ebx
  00063	89 9d 00 fa ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], ebx
  00069	89 85 f8 f9 ff
	ff		 mov	 DWORD PTR _iLEFT_TIME$[ebp], eax
  0006f	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
  00074	56		 push	 esi
  00075	8b cf		 mov	 ecx, edi
  00077	89 85 e8 f9 ff
	ff		 mov	 DWORD PTR _iALIVE_PARTYCOUNT$[ebp], eax
  0007d	e8 00 00 00 00	 call	 ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
  00082	8b 95 e8 f9 ff
	ff		 mov	 edx, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00088	50		 push	 eax
  00089	52		 push	 edx
  0008a	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0008d	51		 push	 ecx
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
  00093	89 85 e4 f9 ff
	ff		 mov	 DWORD PTR _iADD_PARTYPOINT$[ebp], eax
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0009f	8b 85 ec f9 ff
	ff		 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  000a5	83 c4 10	 add	 esp, 16			; 00000010H
  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 55 07 00
	00		 js	 $LN29@GiveReward

; 2721 : 	int iREWARD_ZEN = 0;
; 2722 : 	int iREWARD_SCR = 0;
; 2723 : 	int iLEFT_TIME = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;
; 2724 : 	int iALIVE_PARTYCOUNT = this->GetWinnerPartyCompleteCount(iBridgeIndex);
; 2725 : 	int iADD_PARTYPOINT = this->GetWinnerPartyCompletePoint(iBridgeIndex);
; 2726 : 
; 2727 : 	LogAddTD("[Blood Castle] (%d) Winner Party Point - Alive Party Member : %d, Alive Party Point : %d", iBridgeIndex+1, iALIVE_PARTYCOUNT, iADD_PARTYPOINT);
; 2728 : 
; 2729 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  000b0	33 c9		 xor	 ecx, ecx
  000b2	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  000b7	0f 9e c1	 setle	 cl
  000ba	85 c9		 test	 ecx, ecx
  000bc	0f 84 43 07 00
	00		 je	 $LN29@GiveReward

; 2730 : 	{
; 2731 : 		return;
; 2732 : 	}
; 2733 : 
; 2734 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  000c2	85 f6		 test	 esi, esi
  000c4	0f 88 3b 07 00
	00		 js	 $LN29@GiveReward
  000ca	33 c9		 xor	 ecx, ecx
  000cc	83 fe 07	 cmp	 esi, 7
  000cf	0f 9e c1	 setle	 cl
  000d2	85 c9		 test	 ecx, ecx
  000d4	0f 84 2b 07 00
	00		 je	 $LN29@GiveReward

; 2735 : 	{
; 2736 : 		return;
; 2737 : 	}
; 2738 : 	
; 2739 : 	if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED != false )

  000da	8b 8d 04 fa ff
	ff		 mov	 ecx, DWORD PTR tv1217[ebp]
  000e0	38 99 be 03 00
	00		 cmp	 BYTE PTR [ecx+958], bl
  000e6	0f 85 19 07 00
	00		 jne	 $LN29@GiveReward

; 2740 : 	{
; 2741 : 		return;
; 2742 : 	}
; 2743 : 
; 2744 : 	if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f2	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000f8	83 7c 08 04 02	 cmp	 DWORD PTR [eax+ecx+4], 2
  000fd	7e 34		 jle	 SHORT $LN31@GiveReward

; 2745 : 	{
; 2746 : 		gObj[iIndex].Name[MAX_ACCOUNT_LEN] = 0;

  000ff	88 9c 08 81 00
	00 00		 mov	 BYTE PTR [eax+ecx+129], bl

; 2747 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 141)), gObj[iIndex].Name);

  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010c	8d 44 10 77	 lea	 eax, DWORD PTR [eax+edx+119]
  00110	50		 push	 eax
  00111	68 8d 04 00 00	 push	 1165			; 0000048dH
  00116	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00120	50		 push	 eax
  00121	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szNOTIFY_MSG$[ebp]
  00127	51		 push	 ecx
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2748 : 	}
; 2749 : 	else

  00131	eb 20		 jmp	 SHORT $LN30@GiveReward
$LN31@GiveReward:

; 2750 : 	{
; 2751 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 142)));

  00133	68 8e 04 00 00	 push	 1166			; 0000048eH
  00138	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0013d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00142	50		 push	 eax
  00143	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szNOTIFY_MSG$[ebp]
  00149	52		 push	 edx
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00150	83 c4 08	 add	 esp, 8
$LN30@GiveReward:

; 2752 : 	}
; 2753 : 
; 2754 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  00153	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR tv1217[ebp]
  00159	83 b8 a0 03 00
	00 ff		 cmp	 DWORD PTR [eax+928], -1
  00160	0f 84 9f 06 00
	00		 je	 $LN29@GiveReward

; 2755 : 	{
; 2756 : 		int iTOTAL_EXP = this->GetAliveUserTotalEXP(iBridgeIndex);

  00166	56		 push	 esi
  00167	8b cf		 mov	 ecx, edi
  00169	e8 00 00 00 00	 call	 ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ; CBloodCastle::GetAliveUserTotalEXP

; 2757 : 		LogAddTD("[Blood Castle] (%d) Quest Complete - All Alive User's Total EXP:%d", iBridgeIndex+1, iTOTAL_EXP);

  0016e	50		 push	 eax
  0016f	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00172	50		 push	 eax
  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2758 : 
; 2759 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0017e	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00185	2b c6		 sub	 eax, esi
  00187	03 c0		 add	 eax, eax
  00189	03 c0		 add	 eax, eax
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018e	03 c0		 add	 eax, eax
  00190	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00193	89 9d ec f9 ff
	ff		 mov	 DWORD PTR _i$219730[ebp], ebx
  00199	89 85 e0 f9 ff
	ff		 mov	 DWORD PTR tv1247[ebp], eax
  0019f	8d 7c 8f 1c	 lea	 edi, DWORD PTR [edi+ecx*4+28]
$LL28@GiveReward:

; 2760 : 		{
; 2761 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  001a3	8b 07		 mov	 eax, DWORD PTR [edi]
  001a5	83 f8 ff	 cmp	 eax, -1
  001a8	0f 84 31 06 00
	00		 je	 $LN27@GiveReward

; 2762 : 			{
; 2763 : 				continue;
; 2764 : 			}
; 2765 : 
; 2766 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  001ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b4	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  001ba	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  001bf	0f 8c 1a 06 00
	00		 jl	 $LN27@GiveReward

; 2767 : 			{
; 2768 : 				continue;
; 2769 : 			}
; 2770 : 
; 2771 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||  gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  001c5	8a 8c 10 9e 0e
	00 00		 mov	 cl, BYTE PTR [eax+edx+3742]
  001cc	80 f9 ff	 cmp	 cl, -1
  001cf	0f 84 0a 06 00
	00		 je	 $LN27@GiveReward
  001d5	80 bc 10 9f 0e
	00 00 ff	 cmp	 BYTE PTR [eax+edx+3743], -1
  001dd	0f 84 fc 05 00
	00		 je	 $LN27@GiveReward
  001e3	0f be c1	 movsx	 eax, cl
  001e6	3b c6		 cmp	 eax, esi
  001e8	0f 85 f1 05 00
	00		 jne	 $LN27@GiveReward

; 2772 : 			{
; 2773 : 				continue;
; 2774 : 			}
; 2775 : 
; 2776 : 			PMSG_NOTICE pNotice;
; 2777 : 			TNotice::MakeNoticeMsg(&pNotice, 10, szNOTIFY_MSG);

  001ee	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szNOTIFY_MSG$[ebp]
  001f4	51		 push	 ecx
  001f5	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _pNotice$219738[ebp]
  001fb	6a 0a		 push	 10			; 0000000aH
  001fd	52		 push	 edx
  001fe	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 2778 : 			TNotice::SetNoticeProperty(&pNotice, 10, _ARGB(255, 128, 149, 196), 1, 0, 20);

  00203	6a 14		 push	 20			; 00000014H
  00205	6a 00		 push	 0
  00207	6a 01		 push	 1
  00209	68 80 95 c4 ff	 push	 -3893888		; ffc49580H
  0020e	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$219738[ebp]
  00214	6a 0a		 push	 10			; 0000000aH
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty

; 2779 : 			TNotice::SendNoticeToUser(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (TNotice*)&pNotice);

  0021c	8b 17		 mov	 edx, DWORD PTR [edi]
  0021e	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$219738[ebp]
  00224	51		 push	 ecx
  00225	52		 push	 edx
  00226	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser

; 2780 : 
; 2781 : 			int iADD_EXP = 0;
; 2782 : 
; 2783 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  0022b	8b 07		 mov	 eax, DWORD PTR [edi]
  0022d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00233	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00239	8b 84 10 2c 04
	00 00		 mov	 eax, DWORD PTR [eax+edx+1068]
  00240	8b 95 04 fa ff
	ff		 mov	 edx, DWORD PTR tv1217[ebp]
  00246	83 c4 2c	 add	 esp, 44			; 0000002cH
  00249	33 c9		 xor	 ecx, ecx
  0024b	89 85 f0 f9 ff
	ff		 mov	 DWORD PTR tv2181[ebp], eax
  00251	83 f8 ff	 cmp	 eax, -1
  00254	74 08		 je	 SHORT $LN19@GiveReward
  00256	3b 82 f8 03 00
	00		 cmp	 eax, DWORD PTR [edx+1016]
  0025c	74 10		 je	 SHORT $LN20@GiveReward
$LN19@GiveReward:
  0025e	8b 07		 mov	 eax, DWORD PTR [edi]
  00260	3b 82 fc 03 00
	00		 cmp	 eax, DWORD PTR [edx+1020]
  00266	75 13		 jne	 SHORT $LN21@GiveReward
  00268	8b 85 f0 f9 ff
	ff		 mov	 eax, DWORD PTR tv2181[ebp]
$LN20@GiveReward:

; 2784 : 			{
; 2785 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  0026e	8b ce		 mov	 ecx, esi
  00270	c1 e1 04	 shl	 ecx, 4
  00273	8b 89 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iBC_Add_Exp[ecx]

; 2786 : 			}
; 2787 : 			else

  00279	eb 2c		 jmp	 SHORT $LN16@GiveReward
$LN21@GiveReward:

; 2788 : 			{
; 2789 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  0027b	83 bd f0 f9 ff
	ff ff		 cmp	 DWORD PTR tv2181[ebp], -1
  00282	74 1d		 je	 SHORT $LN58@GiveReward

; 2790 : 				{
; 2791 : 					if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  00284	38 4f 11	 cmp	 BYTE PTR [edi+17], cl
  00287	74 18		 je	 SHORT $LN58@GiveReward

; 2792 : 					{
; 2793 : 						iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  00289	8b d6		 mov	 edx, esi
  0028b	c1 e2 04	 shl	 edx, 4
  0028e	8b 82 00 00 00
	00		 mov	 eax, DWORD PTR _g_iBC_Add_Exp[edx]
  00294	99		 cdq
  00295	2b c2		 sub	 eax, edx
  00297	8b 95 04 fa ff
	ff		 mov	 edx, DWORD PTR tv1217[ebp]
  0029d	8b c8		 mov	 ecx, eax
  0029f	d1 f9		 sar	 ecx, 1
$LN58@GiveReward:
  002a1	8b 85 f0 f9 ff
	ff		 mov	 eax, DWORD PTR tv2181[ebp]
$LN16@GiveReward:

; 2794 : 					}
; 2795 : 				}
; 2796 : 			}
; 2797 : 
; 2798 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  002a7	83 f8 ff	 cmp	 eax, -1
  002aa	74 08		 je	 SHORT $LN13@GiveReward
  002ac	3b 82 18 04 00
	00		 cmp	 eax, DWORD PTR [edx+1048]
  002b2	74 10		 je	 SHORT $LN14@GiveReward
$LN13@GiveReward:
  002b4	8b 07		 mov	 eax, DWORD PTR [edi]
  002b6	3b 82 1c 04 00
	00		 cmp	 eax, DWORD PTR [edx+1052]
  002bc	8b 85 f0 f9 ff
	ff		 mov	 eax, DWORD PTR tv2181[ebp]
  002c2	75 11		 jne	 SHORT $LN15@GiveReward
$LN14@GiveReward:

; 2799 : 			{
; 2800 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  002c4	8b d6		 mov	 edx, esi
  002c6	c1 e2 04	 shl	 edx, 4
  002c9	03 8a 04 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[edx+4]
  002cf	8b 95 04 fa ff
	ff		 mov	 edx, DWORD PTR tv1217[ebp]
$LN15@GiveReward:

; 2801 : 			}
; 2802 : 
; 2803 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index)

  002d5	83 f8 ff	 cmp	 eax, -1
  002d8	74 08		 je	 SHORT $LN10@GiveReward
  002da	3b 82 38 04 00
	00		 cmp	 eax, DWORD PTR [edx+1080]
  002e0	74 0a		 je	 SHORT $LN11@GiveReward
$LN10@GiveReward:
  002e2	8b 07		 mov	 eax, DWORD PTR [edi]
  002e4	3b 82 3c 04 00
	00		 cmp	 eax, DWORD PTR [edx+1084]
  002ea	75 0b		 jne	 SHORT $LN12@GiveReward
$LN11@GiveReward:

; 2804 : 			{
; 2805 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk8;

  002ec	8b d6		 mov	 edx, esi
  002ee	c1 e2 04	 shl	 edx, 4
  002f1	03 8a 08 00 00
	00		 add	 ecx, DWORD PTR _g_iBC_Add_Exp[edx+8]
$LN12@GiveReward:

; 2806 : 			}
; 2807 : 
; 2808 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState  )

  002f7	8b 95 ec f9 ff
	ff		 mov	 edx, DWORD PTR _i$219730[ebp]
  002fd	8b 85 e0 f9 ff
	ff		 mov	 eax, DWORD PTR tv1247[ebp]
  00303	8d 44 10 02	 lea	 eax, DWORD PTR [eax+edx+2]
  00307	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  0030d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00310	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00313	83 f8 04	 cmp	 eax, 4
  00316	0f 87 41 04 00
	00		 ja	 $LN8@GiveReward
  0031c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@GiveReward[eax*4]
$LN7@GiveReward:

; 2809 : 			{
; 2810 : 				case 0:
; 2811 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  00323	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR tv1217[ebp]
  00329	8b 90 ac 03 00
	00		 mov	 edx, DWORD PTR [eax+940]
  0032f	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00334	f7 ea		 imul	 edx
  00336	c1 fa 06	 sar	 edx, 6
  00339	8b c2		 mov	 eax, edx
  0033b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0033e	8b de		 mov	 ebx, esi
  00340	03 c2		 add	 eax, edx
  00342	c1 e3 04	 shl	 ebx, 4
  00345	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]
  0034c	03 c8		 add	 ecx, eax

; 2812 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0034e	51		 push	 ecx
  0034f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00351	51		 push	 ecx
  00352	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00358	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2813 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  0035d	8b 14 f5 04 00
	00 00		 mov	 edx, DWORD PTR _g_iQuestWinExpendZEN[esi*8+4]
  00364	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0036a	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  00370	8b 07		 mov	 eax, DWORD PTR [edi]
  00372	52		 push	 edx
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2814 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk0;
; 2815 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  00379	8b 95 f8 f9 ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  0037f	6a 00		 push	 0
  00381	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00384	8b 1c 8d 00 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[ecx*4]
  0038b	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00391	52		 push	 edx
  00392	89 85 00 fa ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00398	8b 07		 mov	 eax, DWORD PTR [edi]
  0039a	53		 push	 ebx
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2816 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 0, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  003a1	8b 07		 mov	 eax, DWORD PTR [edi]
  003a3	8b 95 f8 f9 ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  003a9	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  003af	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b5	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  003bc	51		 push	 ecx
  003bd	8b 8d 00 fa ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  003c3	52		 push	 edx
  003c4	8b 95 fc f9 ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  003ca	53		 push	 ebx
  003cb	51		 push	 ecx
  003cc	8b 88 a0 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3744]
  003d2	52		 push	 edx
  003d3	51		 push	 ecx
  003d4	6a 00		 push	 0

; 2817 : 					break;

  003d6	e9 68 03 00 00	 jmp	 $LN62@GiveReward
$LN6@GiveReward:

; 2818 : 
; 2819 : 				case 1:
; 2820 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  003db	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR tv1217[ebp]
  003e1	8b 90 ac 03 00
	00		 mov	 edx, DWORD PTR [eax+940]
  003e7	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  003ec	f7 ea		 imul	 edx
  003ee	c1 fa 06	 sar	 edx, 6
  003f1	8b c2		 mov	 eax, edx
  003f3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003f6	8b de		 mov	 ebx, esi
  003f8	03 c2		 add	 eax, edx
  003fa	c1 e3 04	 shl	 ebx, 4
  003fd	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]
  00404	03 c8		 add	 ecx, eax

; 2821 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  00406	51		 push	 ecx
  00407	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00409	51		 push	 ecx
  0040a	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00410	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2822 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  00415	8b 14 f5 04 00
	00 00		 mov	 edx, DWORD PTR _g_iQuestWinExpendZEN[esi*8+4]
  0041c	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00422	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  00428	8b 07		 mov	 eax, DWORD PTR [edi]
  0042a	52		 push	 edx
  0042b	50		 push	 eax
  0042c	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2823 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk4;
; 2824 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  00431	8b 95 f8 f9 ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  00437	6a 00		 push	 0
  00439	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  0043c	8b 1c 8d 04 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[ecx*4+4]
  00443	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00449	52		 push	 edx
  0044a	89 85 00 fa ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00450	8b 07		 mov	 eax, DWORD PTR [edi]
  00452	53		 push	 ebx
  00453	50		 push	 eax
  00454	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2825 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  00459	8b 07		 mov	 eax, DWORD PTR [edi]
  0045b	8b 95 f8 f9 ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  00461	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00467	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046d	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00474	51		 push	 ecx
  00475	8b 8d 00 fa ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  0047b	52		 push	 edx
  0047c	8b 95 fc f9 ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  00482	53		 push	 ebx
  00483	51		 push	 ecx
  00484	8b 88 a0 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3744]
  0048a	52		 push	 edx
  0048b	51		 push	 ecx
  0048c	6a 01		 push	 1

; 2826 : 					break;

  0048e	e9 b0 02 00 00	 jmp	 $LN62@GiveReward
$LN5@GiveReward:

; 2827 : 
; 2828 : 				case 2:
; 2829 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  00493	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR tv1217[ebp]
  00499	8b 90 ac 03 00
	00		 mov	 edx, DWORD PTR [eax+940]
  0049f	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  004a4	f7 ea		 imul	 edx
  004a6	c1 fa 06	 sar	 edx, 6
  004a9	8b c2		 mov	 eax, edx
  004ab	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004ae	8b de		 mov	 ebx, esi
  004b0	03 c2		 add	 eax, edx
  004b2	c1 e3 04	 shl	 ebx, 4
  004b5	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]
  004bc	03 c8		 add	 ecx, eax

; 2830 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  004be	51		 push	 ecx
  004bf	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004c1	51		 push	 ecx
  004c2	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  004c8	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2831 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  004cd	8b 14 f5 00 00
	00 00		 mov	 edx, DWORD PTR _g_iQuestWinExpendZEN[esi*8]
  004d4	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  004da	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  004e0	8b 07		 mov	 eax, DWORD PTR [edi]
  004e2	52		 push	 edx
  004e3	50		 push	 eax
  004e4	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2832 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk8;

  004e9	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]

; 2833 : 					iREWARD_SCR += iADD_PARTYPOINT;

  004ec	8b 1c 8d 08 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[ecx*4+8]

; 2834 : 
; 2835 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  004f3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004f5	03 9d e4 f9 ff
	ff		 add	 ebx, DWORD PTR _iADD_PARTYPOINT$[ebp]
  004fb	8b d1		 mov	 edx, ecx
  004fd	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00503	89 85 00 fa ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00509	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0050e	0f b6 84 02 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+eax+329]
  00516	3c 34		 cmp	 al, 52			; 00000034H
  00518	74 0d		 je	 SHORT $LN53@GiveReward
  0051a	3c 0b		 cmp	 al, 11			; 0000000bH
  0051c	72 15		 jb	 SHORT $LN4@GiveReward
  0051e	b2 11		 mov	 dl, 17			; 00000011H
  00520	3a d0		 cmp	 dl, al
  00522	1b c0		 sbb	 eax, eax
  00524	40		 inc	 eax
  00525	74 0c		 je	 SHORT $LN4@GiveReward
$LN53@GiveReward:

; 2836 : 					{
; 2837 : 						this->DropChaosGem(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  00527	51		 push	 ecx
  00528	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0052e	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropChaosGem
$LN4@GiveReward:

; 2838 : 					}
; 2839 : 
; 2840 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  00533	8b 85 e8 f9 ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00539	8b 8d f8 f9 ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0053f	8b 17		 mov	 edx, DWORD PTR [edi]
  00541	50		 push	 eax
  00542	51		 push	 ecx
  00543	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00549	53		 push	 ebx
  0054a	52		 push	 edx
  0054b	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2841 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 2, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  00550	8b 07		 mov	 eax, DWORD PTR [edi]
  00552	8b 8d f8 f9 ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00558	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0055e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00564	0f b6 90 49 01
	00 00		 movzx	 edx, BYTE PTR [eax+329]
  0056b	52		 push	 edx
  0056c	8b 95 00 fa ff
	ff		 mov	 edx, DWORD PTR _iREWARD_ZEN$[ebp]
  00572	51		 push	 ecx
  00573	8b 8d fc f9 ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  00579	53		 push	 ebx
  0057a	52		 push	 edx
  0057b	8b 90 a0 0e 00
	00		 mov	 edx, DWORD PTR [eax+3744]
  00581	51		 push	 ecx
  00582	52		 push	 edx
  00583	6a 02		 push	 2
  00585	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00588	51		 push	 ecx

; 2842 : 					break;

  00589	e9 b9 01 00 00	 jmp	 $LN63@GiveReward
$LN3@GiveReward:

; 2843 : 
; 2844 : 				case 3:
; 2845 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0058e	8b 95 04 fa ff
	ff		 mov	 edx, DWORD PTR tv1217[ebp]
  00594	8b 92 ac 03 00
	00		 mov	 edx, DWORD PTR [edx+940]
  0059a	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0059f	f7 ea		 imul	 edx
  005a1	c1 fa 06	 sar	 edx, 6
  005a4	8b c2		 mov	 eax, edx
  005a6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005a9	8b de		 mov	 ebx, esi
  005ab	03 c2		 add	 eax, edx
  005ad	c1 e3 04	 shl	 ebx, 4
  005b0	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]
  005b7	03 c8		 add	 ecx, eax

; 2846 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  005b9	51		 push	 ecx
  005ba	8b 0f		 mov	 ecx, DWORD PTR [edi]
  005bc	51		 push	 ecx
  005bd	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  005c3	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2847 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  005c8	8b 14 f5 00 00
	00 00		 mov	 edx, DWORD PTR _g_iQuestWinExpendZEN[esi*8]
  005cf	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  005d5	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  005db	8b 07		 mov	 eax, DWORD PTR [edi]
  005dd	52		 push	 edx
  005de	50		 push	 eax
  005df	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2848 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unkC;

  005e4	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]

; 2849 : 					iREWARD_SCR += iADD_PARTYPOINT;

  005e7	8b 1c 8d 0c 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[ecx*4+12]

; 2850 : 
; 2851 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  005ee	8b 0f		 mov	 ecx, DWORD PTR [edi]
  005f0	03 9d e4 f9 ff
	ff		 add	 ebx, DWORD PTR _iADD_PARTYPOINT$[ebp]
  005f6	8b d1		 mov	 edx, ecx
  005f8	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  005fe	89 85 00 fa ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  00604	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00609	0f b6 84 02 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+eax+329]
  00611	3c 34		 cmp	 al, 52			; 00000034H
  00613	74 0d		 je	 SHORT $LN54@GiveReward
  00615	3c 0b		 cmp	 al, 11			; 0000000bH
  00617	72 15		 jb	 SHORT $LN2@GiveReward
  00619	b2 11		 mov	 dl, 17			; 00000011H
  0061b	3a d0		 cmp	 dl, al
  0061d	1b c0		 sbb	 eax, eax
  0061f	40		 inc	 eax
  00620	74 0c		 je	 SHORT $LN2@GiveReward
$LN54@GiveReward:

; 2852 : 					{
; 2853 : 						this->DropChaosGem(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  00622	51		 push	 ecx
  00623	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00629	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropChaosGem
$LN2@GiveReward:

; 2854 : 					}
; 2855 : 
; 2856 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  0062e	8b 85 e8 f9 ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00634	8b 8d f8 f9 ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0063a	8b 17		 mov	 edx, DWORD PTR [edi]
  0063c	50		 push	 eax
  0063d	51		 push	 ecx
  0063e	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00644	53		 push	 ebx
  00645	52		 push	 edx
  00646	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2857 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 3, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  0064b	8b 07		 mov	 eax, DWORD PTR [edi]
  0064d	8b 8d f8 f9 ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00653	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00659	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0065f	0f b6 90 49 01
	00 00		 movzx	 edx, BYTE PTR [eax+329]
  00666	52		 push	 edx
  00667	8b 95 00 fa ff
	ff		 mov	 edx, DWORD PTR _iREWARD_ZEN$[ebp]
  0066d	51		 push	 ecx
  0066e	8b 8d fc f9 ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  00674	53		 push	 ebx
  00675	52		 push	 edx
  00676	8b 90 a0 0e 00
	00		 mov	 edx, DWORD PTR [eax+3744]
  0067c	51		 push	 ecx
  0067d	52		 push	 edx
  0067e	6a 03		 push	 3
  00680	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00683	51		 push	 ecx

; 2858 : 					break;

  00684	e9 be 00 00 00	 jmp	 $LN63@GiveReward
$LN1@GiveReward:

; 2859 : 
; 2860 : 				case 4:
; 2861 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  00689	8b 95 04 fa ff
	ff		 mov	 edx, DWORD PTR tv1217[ebp]
  0068f	8b 92 ac 03 00
	00		 mov	 edx, DWORD PTR [edx+940]
  00695	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0069a	f7 ea		 imul	 edx
  0069c	c1 fa 06	 sar	 edx, 6
  0069f	8b c2		 mov	 eax, edx
  006a1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  006a4	8b de		 mov	 ebx, esi
  006a6	03 c2		 add	 eax, edx
  006a8	c1 e3 04	 shl	 ebx, 4
  006ab	0f af 83 0c 00
	00 00		 imul	 eax, DWORD PTR _g_iBC_Add_Exp[ebx+12]
  006b2	03 c8		 add	 ecx, eax

; 2862 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  006b4	51		 push	 ecx
  006b5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  006b7	51		 push	 ecx
  006b8	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  006be	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2863 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  006c3	8b 14 f5 00 00
	00 00		 mov	 edx, DWORD PTR _g_iQuestWinExpendZEN[esi*8]
  006ca	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  006d0	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax
  006d6	8b 07		 mov	 eax, DWORD PTR [edi]
  006d8	52		 push	 edx
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 2864 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk10;
; 2865 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  006df	8b 95 e8 f9 ff
	ff		 mov	 edx, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  006e5	52		 push	 edx
  006e6	89 85 00 fa ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax
  006ec	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _iLEFT_TIME$[ebp]
  006f2	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  006f5	8b 1c 8d 10 00
	00 00		 mov	 ebx, DWORD PTR _g_iBC_EventScore[ecx*4+16]
  006fc	8b 0f		 mov	 ecx, DWORD PTR [edi]
  006fe	50		 push	 eax
  006ff	53		 push	 ebx
  00700	51		 push	 ecx
  00701	8b 8d 08 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00707	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2866 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 4, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP, iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  0070c	8b 17		 mov	 edx, DWORD PTR [edi]
  0070e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00713	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00719	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  00721	03 c2		 add	 eax, edx
  00723	8b 95 f8 f9 ff
	ff		 mov	 edx, DWORD PTR _iLEFT_TIME$[ebp]
  00729	51		 push	 ecx
  0072a	8b 8d 00 fa ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]
  00730	52		 push	 edx
  00731	8b 95 fc f9 ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  00737	53		 push	 ebx
  00738	51		 push	 ecx
  00739	8b 88 a0 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3744]
  0073f	52		 push	 edx
  00740	51		 push	 ecx
  00741	6a 04		 push	 4
$LN62@GiveReward:
  00743	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  00746	52		 push	 edx
$LN63@GiveReward:
  00747	83 c0 6c	 add	 eax, 108		; 0000006cH
  0074a	50		 push	 eax
  0074b	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0074e	50		 push	 eax
  0074f	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  00754	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0075a	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN8@GiveReward:

; 2867 : 					break;
; 2868 : 			}
; 2869 : 
; 2870 : 			GCS_BC_GIVE_REWARD pMsg;
; 2871 : 
; 2872 : 			pMsg.bWinner = true;
; 2873 : 			pMsg.btType = -1;
; 2874 : 			memcpy(pMsg.m_stBCCharScore[0].CharName , gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  0075d	8b 07		 mov	 eax, DWORD PTR [edi]
  0075f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00765	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0076b	8d 44 08 77	 lea	 eax, DWORD PTR [eax+ecx+119]
  0076f	66 c7 85 0f fa
	ff ff 01 ff	 mov	 WORD PTR _pMsg$219765[ebp+3], 65281 ; 0000ff01H
  00778	8b 10		 mov	 edx, DWORD PTR [eax]
  0077a	89 95 11 fa ff
	ff		 mov	 DWORD PTR _pMsg$219765[ebp+5], edx
  00780	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00783	89 8d 15 fa ff
	ff		 mov	 DWORD PTR _pMsg$219765[ebp+9], ecx
  00789	66 8b 50 08	 mov	 dx, WORD PTR [eax+8]

; 2875 : 			pMsg.m_stBCCharScore[0].iEXP = iREWARD_EXP;

  0078d	8b 85 fc f9 ff
	ff		 mov	 eax, DWORD PTR _iREWARD_EXP$[ebp]

; 2876 : 			pMsg.m_stBCCharScore[0].iZEN = iREWARD_ZEN;

  00793	8b 8d 00 fa ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_ZEN$[ebp]

; 2877 : 			pMsg.m_stBCCharScore[0].iSCORE = iREWARD_SCR;
; 2878 : 			PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  00799	6a 35		 push	 53			; 00000035H
  0079b	66 89 95 19 fa
	ff ff		 mov	 WORD PTR _pMsg$219765[ebp+13], dx
  007a2	8d 95 0c fa ff
	ff		 lea	 edx, DWORD PTR _pMsg$219765[ebp]
  007a8	68 93 00 00 00	 push	 147			; 00000093H
  007ad	52		 push	 edx
  007ae	89 85 21 fa ff
	ff		 mov	 DWORD PTR _pMsg$219765[ebp+21], eax
  007b4	89 8d 25 fa ff
	ff		 mov	 DWORD PTR _pMsg$219765[ebp+25], ecx
  007ba	89 9d 1d fa ff
	ff		 mov	 DWORD PTR _pMsg$219765[ebp+17], ebx
  007c0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2879 : 
; 2880 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.PHeader.uSize);

  007c5	0f b6 85 0d fa
	ff ff		 movzx	 eax, BYTE PTR _pMsg$219765[ebp+1]
  007cc	8b 17		 mov	 edx, DWORD PTR [edi]
  007ce	50		 push	 eax
  007cf	8d 8d 0c fa ff
	ff		 lea	 ecx, DWORD PTR _pMsg$219765[ebp]
  007d5	51		 push	 ecx
  007d6	52		 push	 edx
  007d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007dc	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@GiveReward:

; 2758 : 
; 2759 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  007df	8b 85 ec f9 ff
	ff		 mov	 eax, DWORD PTR _i$219730[ebp]
  007e5	40		 inc	 eax
  007e6	83 c7 14	 add	 edi, 20			; 00000014H
  007e9	89 85 ec f9 ff
	ff		 mov	 DWORD PTR _i$219730[ebp], eax
  007ef	83 f8 28	 cmp	 eax, 40			; 00000028H
  007f2	0f 8c ab f9 ff
	ff		 jl	 $LL28@GiveReward

; 2881 : 		}
; 2882 : 
; 2883 : 		this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = true;

  007f8	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR tv1217[ebp]
  007fe	c6 80 be 03 00
	00 01		 mov	 BYTE PTR [eax+958], 1
$LN29@GiveReward:

; 2884 : 	}
; 2885 : }

  00805	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00808	5f		 pop	 edi
  00809	5e		 pop	 esi
  0080a	33 cd		 xor	 ecx, ebp
  0080c	5b		 pop	 ebx
  0080d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00812	8b e5		 mov	 esp, ebp
  00814	5d		 pop	 ebp
  00815	c2 08 00	 ret	 8
$LN64@GiveReward:
  00818	00 00 00 00	 DD	 $LN7@GiveReward
  0081c	00 00 00 00	 DD	 $LN6@GiveReward
  00820	00 00 00 00	 DD	 $LN5@GiveReward
  00824	00 00 00 00	 DD	 $LN3@GiveReward
  00828	00 00 00 00	 DD	 $LN1@GiveReward
?GiveReward_Win@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::GiveReward_Win
_TEXT	ENDS
PUBLIC	??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ ; `string'
PUBLIC	??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ ; `string'
PUBLIC	??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GiveReward_Fail@CBloodCastle@@QAEXH@Z		; CBloodCastle::GiveReward_Fail
;	COMDAT ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
CONST	SEGMENT
??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ DB '['
	DB	'Blood Castle] (%d) Send User Quest Fail Message (Account:%s, '
	DB	'Name:%s [State:%d], MapNumber:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
CONST	SEGMENT
??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ DB '['
	DB	'Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, '
	DB	'Score:%d, ExtEXP:%d, LeftTime:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon '
	DB	'(%d) but Failed - Time Out', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GiveReward_Fail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv531 = -1016						; size = 4
_i$219779 = -1012					; size = 4
tv520 = -1008						; size = 4
tv957 = -1004						; size = 4
_this$GSCopy$ = -1000					; size = 4
_pMsg$219798 = -996					; size = 989
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::GiveReward_Fail, COMDAT
; _this$ = ecx

; 2888 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 2889 : 	this->FixUsersPlayStateFail(iBridgeIndex);

  0001a	56		 push	 esi

; 2944 : 		}
; 2945 : 
; 2946 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0001b	89 bd 18 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00021	e8 00 00 00 00	 call	 ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateFail
  00026	85 f6		 test	 esi, esi
  00028	0f 88 da 02 00
	00		 js	 $LN15@GiveReward@2

; 2890 : 
; 2891 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0002e	33 c0		 xor	 eax, eax
  00030	83 fe 07	 cmp	 esi, 7
  00033	0f 9e c0	 setle	 al
  00036	85 c0		 test	 eax, eax
  00038	0f 84 ca 02 00
	00		 je	 $LN15@GiveReward@2

; 2892 : 	{
; 2893 : 		return;
; 2894 : 	}
; 2895 : 
; 2896 : 	int iUserWhoGotUltimateWeapon = -1;
; 2897 : 	iUserWhoGotUltimateWeapon = this->GetWhoGotUltimateWeapon(iBridgeIndex);

  0003e	56		 push	 esi
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWhoGotUltimateWeapon

; 2898 : 
; 2899 : 	if ( iUserWhoGotUltimateWeapon != -1 )

  00046	83 f8 ff	 cmp	 eax, -1
  00049	74 49		 je	 SHORT $LN18@GiveReward@2

; 2900 : 	{
; 2901 : 		if ( OBJMAX_RANGE(iUserWhoGotUltimateWeapon) != FALSE )

  0004b	85 c0		 test	 eax, eax
  0004d	78 45		 js	 SHORT $LN18@GiveReward@2
  0004f	33 c9		 xor	 ecx, ecx
  00051	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00056	0f 9e c1	 setle	 cl
  00059	85 c9		 test	 ecx, ecx
  0005b	74 37		 je	 SHORT $LN18@GiveReward@2

; 2902 : 		{
; 2903 : 			LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon (%d) but Failed - Time Out", iBridgeIndex+1, gObj[iUserWhoGotUltimateWeapon].AccountID, gObj[iUserWhoGotUltimateWeapon].Name, this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER);

  0005d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00063	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	8b d6		 mov	 edx, esi
  0006b	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  00071	0f b6 8c 3a f0
	03 00 00	 movzx	 ecx, BYTE PTR [edx+edi+1008]
  00079	51		 push	 ecx
  0007a	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  0007d	52		 push	 edx
  0007e	83 c0 6c	 add	 eax, 108		; 0000006cH
  00081	50		 push	 eax
  00082	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00091	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@GiveReward@2:

; 2904 : 		}
; 2905 : 	}
; 2906 : 
; 2907 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00094	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  0009b	2b c6		 sub	 eax, esi
  0009d	03 c0		 add	 eax, eax
  0009f	03 c0		 add	 eax, eax
  000a1	03 c0		 add	 eax, eax
  000a3	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000a6	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$219779[ebp], 0

; 2944 : 		}
; 2945 : 
; 2946 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  000b0	89 85 08 fc ff
	ff		 mov	 DWORD PTR tv531[ebp], eax
  000b6	8d 7c 8f 1c	 lea	 edi, DWORD PTR [edi+ecx*4+28]
  000ba	53		 push	 ebx
  000bb	eb 03 8d 49 00	 npad	 5
$LL36@GiveReward@2:

; 2908 : 	{
; 2909 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  000c0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c2	83 f9 ff	 cmp	 ecx, -1
  000c5	0f 84 23 02 00
	00		 je	 $LN16@GiveReward@2

; 2910 : 		{
; 2911 : 			continue;
; 2912 : 		}
; 2913 : 
; 2914 : 		if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d0	8b d1		 mov	 edx, ecx
  000d2	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000d8	03 c2		 add	 eax, edx
  000da	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  000de	0f 8c 0a 02 00
	00		 jl	 $LN16@GiveReward@2

; 2915 : 		{
; 2916 : 			continue;
; 2917 : 		}
; 2918 : 
; 2919 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 )

  000e4	80 b8 9e 0e 00
	00 ff		 cmp	 BYTE PTR [eax+3742], -1
  000eb	0f 84 fd 01 00
	00		 je	 $LN16@GiveReward@2
  000f1	80 b8 9f 0e 00
	00 ff		 cmp	 BYTE PTR [eax+3743], -1
  000f8	0f 84 f0 01 00
	00		 je	 $LN16@GiveReward@2

; 2920 : 		{
; 2921 : 			continue;
; 2922 : 		}	
; 2923 : 
; 2924 : 		int iADD_EXP = 0;
; 2925 : 
; 2926 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  000fe	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  00104	33 db		 xor	 ebx, ebx
  00106	89 85 14 fc ff
	ff		 mov	 DWORD PTR tv957[ebp], eax
  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	74 1e		 je	 SHORT $LN29@GiveReward@2
  00111	8b 85 18 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00117	8b d6		 mov	 edx, esi
  00119	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0011f	03 c2		 add	 eax, edx
  00121	8b 95 14 fc ff
	ff		 mov	 edx, DWORD PTR tv957[ebp]
  00127	3b 90 f8 03 00
	00		 cmp	 edx, DWORD PTR [eax+1016]
  0012d	74 1c		 je	 SHORT $LN9@GiveReward@2
$LN29@GiveReward@2:
  0012f	8b c6		 mov	 eax, esi
  00131	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00137	03 85 18 fc ff
	ff		 add	 eax, DWORD PTR _this$GSCopy$[ebp]
  0013d	89 85 10 fc ff
	ff		 mov	 DWORD PTR tv520[ebp], eax
  00143	3b 88 fc 03 00
	00		 cmp	 ecx, DWORD PTR [eax+1020]
  00149	75 0d		 jne	 SHORT $LN10@GiveReward@2
$LN9@GiveReward@2:

; 2927 : 		{
; 2928 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  0014b	8b d6		 mov	 edx, esi
  0014d	c1 e2 04	 shl	 edx, 4
  00150	8b 9a 00 00 00
	00		 mov	 ebx, DWORD PTR _g_iBC_Add_Exp[edx]

; 2929 : 		}
; 2930 : 		else

  00156	eb 26		 jmp	 SHORT $LN5@GiveReward@2
$LN10@GiveReward@2:

; 2931 : 		{
; 2932 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  00158	83 bd 14 fc ff
	ff ff		 cmp	 DWORD PTR tv957[ebp], -1
  0015f	74 1d		 je	 SHORT $LN5@GiveReward@2

; 2933 : 			{
; 2934 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  00161	38 5f 11	 cmp	 BYTE PTR [edi+17], bl
  00164	74 18		 je	 SHORT $LN5@GiveReward@2

; 2935 : 				{
; 2936 : 					iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  00166	8b c6		 mov	 eax, esi
  00168	c1 e0 04	 shl	 eax, 4
  0016b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _g_iBC_Add_Exp[eax]
  00171	99		 cdq
  00172	2b c2		 sub	 eax, edx
  00174	8b d8		 mov	 ebx, eax
  00176	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR tv520[ebp]
  0017c	d1 fb		 sar	 ebx, 1
$LN5@GiveReward@2:

; 2937 : 				}
; 2938 : 			}
; 2939 : 		}
; 2940 : 
; 2941 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  0017e	8b 95 14 fc ff
	ff		 mov	 edx, DWORD PTR tv957[ebp]
  00184	83 fa ff	 cmp	 edx, -1
  00187	74 08		 je	 SHORT $LN35@GiveReward@2
  00189	3b 90 18 04 00
	00		 cmp	 edx, DWORD PTR [eax+1048]
  0018f	74 08		 je	 SHORT $LN34@GiveReward@2
$LN35@GiveReward@2:
  00191	3b 88 1c 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1052]
  00197	75 0b		 jne	 SHORT $LN4@GiveReward@2
$LN34@GiveReward@2:

; 2942 : 		{
; 2943 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  00199	8b d6		 mov	 edx, esi
  0019b	c1 e2 04	 shl	 edx, 4
  0019e	03 9a 04 00 00
	00		 add	 ebx, DWORD PTR _g_iBC_Add_Exp[edx+4]
$LN4@GiveReward@2:

; 2944 : 		}
; 2945 : 
; 2946 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  001a4	53		 push	 ebx
  001a5	51		 push	 ecx
  001a6	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001ac	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 2947 : 		this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iBC_EventScore_Fail[iBridgeIndex], 0, 0);

  001b1	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR _g_iBC_EventScore_Fail[esi*4]
  001b8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001ba	6a 00		 push	 0
  001bc	6a 00		 push	 0
  001be	50		 push	 eax
  001bf	51		 push	 ecx
  001c0	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001c6	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 2948 : 
; 2949 : 		LogAddTD("[Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, Score:%d, ExtEXP:%d, LeftTime:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, ::g_iBC_EventScore_Fail[iBridgeIndex], iADD_EXP, 0);

  001cb	8b 17		 mov	 edx, DWORD PTR [edi]
  001cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d2	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  001d8	6a 00		 push	 0
  001da	03 c2		 add	 eax, edx
  001dc	8b 14 b5 00 00
	00 00		 mov	 edx, DWORD PTR _g_iBC_EventScore_Fail[esi*4]
  001e3	53		 push	 ebx
  001e4	52		 push	 edx
  001e5	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  001e8	52		 push	 edx
  001e9	83 c0 6c	 add	 eax, 108		; 0000006cH
  001ec	50		 push	 eax
  001ed	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  001f0	51		 push	 ecx
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2950 : 
; 2951 : 		GCS_BC_GIVE_REWARD pMsg;
; 2952 : 
; 2953 : 		pMsg.bWinner = false;
; 2954 : 		pMsg.btType = -1;
; 2955 : 		memcpy(pMsg.m_stBCCharScore[0].CharName, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  001fc	8b 07		 mov	 eax, DWORD PTR [edi]
  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00204	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0020a	8d 44 08 77	 lea	 eax, DWORD PTR [eax+ecx+119]
  0020e	66 c7 85 1f fc
	ff ff 00 ff	 mov	 WORD PTR _pMsg$219798[ebp+3], 65280 ; 0000ff00H
  00217	8b 10		 mov	 edx, DWORD PTR [eax]
  00219	89 95 21 fc ff
	ff		 mov	 DWORD PTR _pMsg$219798[ebp+5], edx
  0021f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00222	89 8d 25 fc ff
	ff		 mov	 DWORD PTR _pMsg$219798[ebp+9], ecx
  00228	66 8b 50 08	 mov	 dx, WORD PTR [eax+8]

; 2956 : 		pMsg.m_stBCCharScore[0].iEXP = iADD_EXP;
; 2957 : 		pMsg.m_stBCCharScore[0].iZEN = 0;
; 2958 : 		pMsg.m_stBCCharScore[0].iSCORE = g_iBC_EventScore_Fail[iBridgeIndex];

  0022c	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR _g_iBC_EventScore_Fail[esi*4]

; 2959 : 		PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  00233	6a 35		 push	 53			; 00000035H
  00235	8d 8d 1c fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$219798[ebp]
  0023b	68 93 00 00 00	 push	 147			; 00000093H
  00240	51		 push	 ecx
  00241	66 89 95 29 fc
	ff ff		 mov	 WORD PTR _pMsg$219798[ebp+13], dx
  00248	89 9d 31 fc ff
	ff		 mov	 DWORD PTR _pMsg$219798[ebp+21], ebx
  0024e	c7 85 35 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pMsg$219798[ebp+25], 0
  00258	89 85 2d fc ff
	ff		 mov	 DWORD PTR _pMsg$219798[ebp+17], eax
  0025e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2960 : 
; 2961 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  00263	8b 07		 mov	 eax, DWORD PTR [edi]
  00265	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026b	8b d0		 mov	 edx, eax
  0026d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00273	83 c4 28	 add	 esp, 40			; 00000028H
  00276	80 bc 11 9e 0e
	00 00 ff	 cmp	 BYTE PTR [ecx+edx+3742], -1
  0027e	74 6e		 je	 SHORT $LN16@GiveReward@2
  00280	80 bc 11 9f 0e
	00 00 ff	 cmp	 BYTE PTR [ecx+edx+3743], -1
  00288	74 64		 je	 SHORT $LN16@GiveReward@2

; 2962 : 		{
; 2963 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.PHeader.uSize);			

  0028a	0f b6 95 1d fc
	ff ff		 movzx	 edx, BYTE PTR _pMsg$219798[ebp+1]
  00291	52		 push	 edx
  00292	8d 8d 1c fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$219798[ebp]
  00298	51		 push	 ecx
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2964 : 
; 2965 : 			LogAddTD("[Blood Castle] (%d) Send User Quest Fail Message (Account:%s, Name:%s [State:%d], MapNumber:%d)", iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);

  0029f	8b 17		 mov	 edx, DWORD PTR [edi]
  002a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a6	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  002ac	0f b6 8c 10 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+329]
  002b4	03 c2		 add	 eax, edx
  002b6	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR tv531[ebp]
  002bc	51		 push	 ecx
  002bd	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _i$219779[ebp]
  002c3	8d 4c 0a 02	 lea	 ecx, DWORD PTR [edx+ecx+2]
  002c7	8d 14 89	 lea	 edx, DWORD PTR [ecx+ecx*4]
  002ca	8b 8d 18 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002d0	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  002d3	52		 push	 edx
  002d4	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  002d7	51		 push	 ecx
  002d8	83 c0 6c	 add	 eax, 108		; 0000006cH
  002db	50		 push	 eax
  002dc	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  002df	50		 push	 eax
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002eb	83 c4 24	 add	 esp, 36			; 00000024H
$LN16@GiveReward@2:

; 2904 : 		}
; 2905 : 	}
; 2906 : 
; 2907 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  002ee	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _i$219779[ebp]
  002f4	40		 inc	 eax
  002f5	83 c7 14	 add	 edi, 20			; 00000014H
  002f8	89 85 0c fc ff
	ff		 mov	 DWORD PTR _i$219779[ebp], eax
  002fe	83 f8 28	 cmp	 eax, 40			; 00000028H
  00301	0f 8c b9 fd ff
	ff		 jl	 $LL36@GiveReward@2
  00307	5b		 pop	 ebx
$LN15@GiveReward@2:

; 2966 : 		}	
; 2967 : 	}
; 2968 : }

  00308	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030b	5f		 pop	 edi
  0030c	33 cd		 xor	 ecx, ebp
  0030e	5e		 pop	 esi
  0030f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00314	8b e5		 mov	 esp, ebp
  00316	5d		 pop	 ebp
  00317	c2 04 00	 ret	 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::GiveReward_Fail
_TEXT	ENDS
PUBLIC	??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ ; `string'
PUBLIC	??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEveryUserDie
;	COMDAT ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
CONST	SEGMENT
??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
CONST	SEGMENT
??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -32					; size = 4
_i$219979 = -28						; size = 4
_bRET_VAL$ = -21					; size = 1
_pMsg$219992 = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckEveryUserDie, COMDAT
; _this$ = ecx

; 3477 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00014	8b c1		 mov	 eax, ecx

; 3481 : 	}
; 3482 : 
; 3483 : 	bool bRET_VAL = true;
; 3484 : 
; 3485 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00016	89 45 e0	 mov	 DWORD PTR _this$GSCopy$[ebp], eax
  00019	85 db		 test	 ebx, ebx
  0001b	78 0c		 js	 SHORT $LN20@CheckEvery

; 3478 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001d	33 c9		 xor	 ecx, ecx
  0001f	83 fb 07	 cmp	 ebx, 7
  00022	0f 9e c1	 setle	 cl
  00025	85 c9		 test	 ecx, ecx
  00027	75 13		 jne	 SHORT $LN11@CheckEvery
$LN20@CheckEvery:

; 3479 : 	{
; 3480 : 		return false;

  00029	32 c0		 xor	 al, al
  0002b	5b		 pop	 ebx

; 3523 : 				}
; 3524 : 			}
; 3525 : 		}
; 3526 : 	}
; 3527 : 
; 3528 : 	return bRET_VAL;
; 3529 : }

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002f	33 cd		 xor	 ecx, ebp
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN11@CheckEvery:
  0003c	56		 push	 esi
  0003d	57		 push	 edi

; 3481 : 	}
; 3482 : 
; 3483 : 	bool bRET_VAL = true;
; 3484 : 
; 3485 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0003e	33 ff		 xor	 edi, edi
  00040	8b cb		 mov	 ecx, ebx
  00042	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  00048	c6 45 eb 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1
  0004c	89 7d e4	 mov	 DWORD PTR _i$219979[ebp], edi
  0004f	8d 74 01 1c	 lea	 esi, DWORD PTR [ecx+eax+28]
$LL10@CheckEvery:

; 3486 : 	{
; 3487 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00053	8b 16		 mov	 edx, DWORD PTR [esi]
  00055	83 fa ff	 cmp	 edx, -1
  00058	0f 84 b3 00 00
	00		 je	 $LN9@CheckEvery

; 3488 : 		{
; 3489 : 			if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  0005e	85 d2		 test	 edx, edx
  00060	78 0f		 js	 SHORT $LN21@CheckEvery
  00062	33 c0		 xor	 eax, eax
  00064	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  0006a	0f 9e c0	 setle	 al
  0006d	85 c0		 test	 eax, eax
  0006f	75 19		 jne	 SHORT $LN6@CheckEvery
$LN21@CheckEvery:

; 3490 : 			{
; 3491 : 				LogAddTD("error-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d, SubIndex:%d", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  00071	57		 push	 edi
  00072	52		 push	 edx
  00073	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00076	52		 push	 edx
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00082	83 c4 10	 add	 esp, 16			; 00000010H

; 3492 : 				continue;

  00085	e9 87 00 00 00	 jmp	 $LN9@CheckEvery
$LN6@CheckEvery:

; 3493 : 			}
; 3494 : 
; 3495 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber == this->GetBridgeMapNumber(iBridgeIndex) ) //season3 changed

  0008a	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0008d	8b fa		 mov	 edi, edx
  0008f	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00095	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009b	53		 push	 ebx
  0009c	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  000a1	0f b6 8f 49 01
	00 00		 movzx	 ecx, BYTE PTR [edi+329]
  000a8	3b c8		 cmp	 ecx, eax
  000aa	75 25		 jne	 SHORT $LN5@CheckEvery

; 3496 : 			{
; 3497 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000ac	83 7f 04 02	 cmp	 DWORD PTR [edi+4], 2
  000b0	7e 06		 jle	 SHORT $LN4@CheckEvery

; 3498 : 				{
; 3499 : 					bRET_VAL = false;

  000b2	c6 45 eb 00	 mov	 BYTE PTR _bRET_VAL$[ebp], 0

; 3500 : 				}
; 3501 : 				else

  000b6	eb 59		 jmp	 SHORT $LN9@CheckEvery
$LN4@CheckEvery:

; 3502 : 				{
; 3503 : 					LogAddTD("error-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d, SubIndex:%d", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  000b8	8b 45 e4	 mov	 eax, DWORD PTR _i$219979[ebp]
  000bb	50		 push	 eax
  000bc	52		 push	 edx
  000bd	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  000c0	51		 push	 ecx
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cc	83 c4 10	 add	 esp, 16			; 00000010H

; 3504 : 				}
; 3505 : 			}
; 3506 : 			else

  000cf	eb 40		 jmp	 SHORT $LN9@CheckEvery
$LN5@CheckEvery:

; 3507 : 			{
; 3508 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg == false )

  000d1	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  000d5	75 3a		 jne	 SHORT $LN9@CheckEvery

; 3509 : 				{
; 3510 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = true;
; 3511 : 
; 3512 : 					PMSG_STATEBLOODCASTLE pMsg;
; 3513 : 
; 3514 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  000d7	6a 0e		 push	 14			; 0000000eH
  000d9	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$219992[ebp]
  000dc	68 9b 00 00 00	 push	 155			; 0000009bH
  000e1	52		 push	 edx
  000e2	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
  000e6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3515 : 					pMsg.btPlayState = 2;
; 3516 : 					pMsg.wRemainSec = 0;
; 3517 : 					pMsg.wMaxKillMonster = 0;
; 3518 : 					pMsg.wCurKillMonster = 0;
; 3519 : 					pMsg.wUserHaveWeapon = 0;
; 3520 : 					pMsg.btWeaponNum = -1;
; 3521 : 
; 3522 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000eb	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$219992[ebp+1]
  000ef	33 d2		 xor	 edx, edx
  000f1	33 c0		 xor	 eax, eax
  000f3	89 55 f4	 mov	 DWORD PTR _pMsg$219992[ebp+8], edx
  000f6	51		 push	 ecx
  000f7	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$219992[ebp]
  000fa	89 45 f0	 mov	 DWORD PTR _pMsg$219992[ebp+4], eax
  000fd	8b 06		 mov	 eax, DWORD PTR [esi]
  000ff	52		 push	 edx
  00100	50		 push	 eax
  00101	c6 45 ef 02	 mov	 BYTE PTR _pMsg$219992[ebp+3], 2
  00105	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$219992[ebp+12], 255 ; 000000ffH
  00109	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0010e	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@CheckEvery:

; 3481 : 	}
; 3482 : 
; 3483 : 	bool bRET_VAL = true;
; 3484 : 
; 3485 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00111	8b 7d e4	 mov	 edi, DWORD PTR _i$219979[ebp]
  00114	47		 inc	 edi
  00115	83 c6 14	 add	 esi, 20			; 00000014H
  00118	89 7d e4	 mov	 DWORD PTR _i$219979[ebp], edi
  0011b	83 ff 28	 cmp	 edi, 40			; 00000028H
  0011e	0f 8c 2f ff ff
	ff		 jl	 $LL10@CheckEvery

; 3523 : 				}
; 3524 : 			}
; 3525 : 		}
; 3526 : 	}
; 3527 : 
; 3528 : 	return bRET_VAL;
; 3529 : }

  00124	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00127	8a 45 eb	 mov	 al, BYTE PTR _bRET_VAL$[ebp]
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	33 cd		 xor	 ecx, ebp
  0012e	5b		 pop	 ebx
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 04 00	 ret	 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckEveryUserDie
_TEXT	ENDS
PUBLIC	??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ ; `string'
PUBLIC	??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ ; `string'
PUBLIC	?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckAngelKingExist
;	COMDAT ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
CONST	SEGMENT
??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ DB '['
	DB	'Blood Castle] (%d) Angel King - gObjAdd() failed (no space to'
	DB	' add monster, result:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
CONST	SEGMENT
??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ DB '['
	DB	'Blood Castle] (%d) Angel King''s Monster Position Doesn''t Ex'
	DB	'ist', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv197 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckAngelKingExist, COMDAT
; _this$ = ecx

; 3533 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 3534 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	78 38		 js	 SHORT $LN19@CheckAngel
  0000e	33 c0		 xor	 eax, eax
  00010	83 ff 07	 cmp	 edi, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 3535 : 	{
; 3536 : 		return false;

  00018	74 2c		 je	 SHORT $LN19@CheckAngel

; 3537 : 	}
; 3538 : 
; 3539 : 	bool bRET_VAL = false;
; 3540 : 
; 3541 : 	if ( this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum == -1 )

  0001a	8b c7		 mov	 eax, edi
  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	83 bc 18 f4 03
	00 00 ff	 cmp	 DWORD PTR [eax+ebx+1012], -1
  0002a	8d 84 18 f4 03
	00 00		 lea	 eax, DWORD PTR [eax+ebx+1012]
  00031	89 45 08	 mov	 DWORD PTR tv197[ebp], eax
  00034	75 18		 jne	 SHORT $LN10@CheckAngel

; 3542 : 	{
; 3543 : 		LogAddTD("[Blood Castle] (%d) Angel King's Monster Position Doesn't Exist", iBridgeIndex+1);

  00036	47		 inc	 edi
  00037	57		 push	 edi
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00043	83 c4 08	 add	 esp, 8
$LN19@CheckAngel:

; 3544 : 		return false;

  00046	5f		 pop	 edi
  00047	32 c0		 xor	 al, al
  00049	5b		 pop	 ebx

; 3581 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN10@CheckAngel:

; 3545 : 	}
; 3546 : 
; 3547 : 	for ( int i=0;i<OBJ_STARTUSERINDZT;i++)

  0004e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00054	56		 push	 esi
  00055	33 f6		 xor	 esi, esi
  00057	83 c2 68	 add	 edx, 104		; 00000068H
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL9@CheckAngel:

; 3548 : 	{
; 3549 : 		if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_NPC )

  00060	83 7a 9c 03	 cmp	 DWORD PTR [edx-100], 3
  00064	75 24		 jne	 SHORT $LN8@CheckAngel
  00066	66 83 3a 03	 cmp	 WORD PTR [edx], 3
  0006a	75 1e		 jne	 SHORT $LN8@CheckAngel

; 3550 : 		{
; 3551 : 			if ( gObj[i].Class == 232 )

  0006c	b9 e8 00 00 00	 mov	 ecx, 232		; 000000e8H
  00071	66 39 4a 50	 cmp	 WORD PTR [edx+80], cx
  00075	75 13		 jne	 SHORT $LN8@CheckAngel

; 3552 : 			{
; 3553 : 				if (gObj[i].MapNumber == this->GetBridgeMapNumber(iBridgeIndex) ) //season3 changed

  00077	57		 push	 edi
  00078	8b cb		 mov	 ecx, ebx
  0007a	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0007f	0f b6 8a e1 00
	00 00		 movzx	 ecx, BYTE PTR [edx+225]
  00086	3b c8		 cmp	 ecx, eax
  00088	74 66		 je	 SHORT $LN1@CheckAngel
$LN8@CheckAngel:

; 3545 : 	}
; 3546 : 
; 3547 : 	for ( int i=0;i<OBJ_STARTUSERINDZT;i++)

  0008a	46		 inc	 esi
  0008b	81 c2 50 2b 00
	00		 add	 edx, 11088		; 00002b50H
  00091	81 fe b0 36 00
	00		 cmp	 esi, 14000		; 000036b0H
  00097	7c c7		 jl	 SHORT $LL9@CheckAngel

; 3554 : 				{
; 3555 : 					bRET_VAL = true;
; 3556 : 					break;
; 3557 : 				}
; 3558 : 			}
; 3559 : 		}
; 3560 : 	}
; 3561 : 
; 3562 : 	if ( bRET_VAL == false )
; 3563 : 	{
; 3564 : 		int result = gObjAddMonster(this->GetBridgeMapNumber(iBridgeIndex)); //season3 changed

  00099	57		 push	 edi
  0009a	8b cb		 mov	 ecx, ebx
  0009c	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000a7	0f bf f0	 movsx	 esi, ax
  000aa	83 c4 04	 add	 esp, 4

; 3565 : 
; 3566 : 		if ( result >= 0 )

  000ad	85 f6		 test	 esi, esi
  000af	78 48		 js	 SHORT $LN2@CheckAngel

; 3567 : 		{
; 3568 : 			gObjSetPosMonster(result, this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum);

  000b1	8b 55 08	 mov	 edx, DWORD PTR tv197[ebp]
  000b4	8b 02		 mov	 eax, DWORD PTR [edx]
  000b6	50		 push	 eax
  000b7	56		 push	 esi
  000b8	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 3569 : 			gObjSetMonster(result, 232);

  000bd	68 e8 00 00 00	 push	 232			; 000000e8H
  000c2	56		 push	 esi
  000c3	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 3570 : 			gObj[result].m_cBloodCastleIndex = this->GetBridgeIndex(gObj[result].MapNumber);

  000c8	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	0f b6 84 0e 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+329]
  000dc	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000df	83 c4 10	 add	 esp, 16			; 00000010H
  000e2	50		 push	 eax
  000e3	8b cb		 mov	 ecx, ebx
  000e5	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  000ea	88 82 9e 0e 00
	00		 mov	 BYTE PTR [edx+3742], al
$LN1@CheckAngel:

; 3577 : 		}
; 3578 : 	}
; 3579 : 
; 3580 : 	return bRET_VAL;

  000f0	5e		 pop	 esi
  000f1	5f		 pop	 edi
  000f2	b0 01		 mov	 al, 1
  000f4	5b		 pop	 ebx

; 3581 : }

  000f5	5d		 pop	 ebp
  000f6	c2 04 00	 ret	 4
$LN2@CheckAngel:

; 3571 : 			bRET_VAL = true;
; 3572 : 		}
; 3573 : 		else
; 3574 : 		{
; 3575 : 			LogAddTD("[Blood Castle] (%d) Angel King - gObjAdd() failed (no space to add monster, result:%d)", iBridgeIndex+1, result);

  000f9	56		 push	 esi
  000fa	47		 inc	 edi
  000fb	57		 push	 edi
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	5e		 pop	 esi
  0010b	5f		 pop	 edi

; 3576 : 			return false;

  0010c	32 c0		 xor	 al, al
  0010e	5b		 pop	 ebx

; 3581 : }

  0010f	5d		 pop	 ebp
  00110	c2 04 00	 ret	 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckAngelKingExist
_TEXT	ENDS
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ ; `string'
PUBLIC	_iItemPos$GSCopy$
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z	; CBloodCastle::DropItemDirectly
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEQAEE@Z:PROC ; MapClass::ItemDrop
EXTRN	?GetActiveSocketOption@CSocketOption@@QAEXPAVCItem@@PAEAAE@Z:PROC ; CSocketOption::GetActiveSocketOption
EXTRN	?g_SocketOption@@3VCSocketOption@@A:BYTE	; g_SocketOption
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
EXTRN	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	_memset:PROC
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
CONST	SEGMENT
??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ DB '['
	DB	'Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeInde'
	DB	'x wrong - %d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_PetLevel$ = -172					; size = 4
_item_number$ = -168					; size = 4
_s_num$ = -164						; size = 4
_PetExp$ = -160						; size = 4
_NOption$ = -156					; size = 1
_Option3$ = -152					; size = 1
_type$ = -148						; size = 4
_dur$ = -144						; size = 4
_Option2$ = -140					; size = 1
_SOption$ = -136					; size = 1
_SocketIndex$ = -132					; size = 1
_ItemEffectEx$ = -128					; size = 1
_Option1$ = -124					; size = 1
_level$ = -120						; size = 4
_iItemPos$GSCopy$ = -116				; size = 4
_pResult$ = -112					; size = 5
_ItemExOption$ = -101					; size = 1
_iIndex$GSCopy$ = -100					; size = 4
_ItemExLevel$ = -93					; size = 1
_pMsg$220098 = -92					; size = 17
_szItemName$ = -72					; size = 50
_NewOption$ = -20					; size = 8
_SocketOption$ = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_iItemType$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z PROC		; CBloodCastle::DropItemDirectly, COMDAT
; _this$ = ecx

; 3678 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 14	 mov	 ebx, DWORD PTR _iItemPos$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	57		 push	 edi

; 3679 : 	if ( BC_MAP_RANGE(this->GetBridgeMapNumber(iBridgeIndex)) == FALSE )

  0001c	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  0001f	57		 push	 edi

; 3745 : 			}
; 3746 : 
; 3747 : 			::gObjMakePreviewCharSet(iIndex);

  00020	89 75 9c	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], esi
  00023	89 5d 8c	 mov	 DWORD PTR _iItemPos$GSCopy$[ebp], ebx
  00026	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  0002b	83 f8 34	 cmp	 eax, 52			; 00000034H
  0002e	74 4e		 je	 SHORT $LN15@DropItemDi

; 3679 : 	if ( BC_MAP_RANGE(this->GetBridgeMapNumber(iBridgeIndex)) == FALSE )

  00030	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00033	7c 0e		 jl	 SHORT $LN14@DropItemDi
  00035	33 c9		 xor	 ecx, ecx
  00037	83 f8 11	 cmp	 eax, 17			; 00000011H
  0003a	0f 9e c1	 setle	 cl
  0003d	8b c1		 mov	 eax, ecx
  0003f	85 c0		 test	 eax, eax
  00041	75 3b		 jne	 SHORT $LN15@DropItemDi
$LN14@DropItemDi:

; 3680 : 	{
; 3681 : 		LogAddTD("[Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeIndex wrong - %d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, iBridgeIndex);

  00043	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0004f	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00052	57		 push	 edi
  00053	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00056	51		 push	 ecx
  00057	83 c0 6c	 add	 eax, 108		; 0000006cH
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00066	83 c4 10	 add	 esp, 16			; 00000010H

; 3682 : 		return FALSE;

  00069	33 c0		 xor	 eax, eax

; 3760 : 		}
; 3761 : 	}
; 3762 : 
; 3763 : 	return (pResult.Result);
; 3764 : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 10 00	 ret	 16			; 00000010H
$LN15@DropItemDi:

; 3683 : 	}
; 3684 : 
; 3685 : 	PMSG_ITEMTHROW_RESULT pResult;
; 3686 : 
; 3687 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  0007e	6a 05		 push	 5
  00080	8d 55 90	 lea	 edx, DWORD PTR _pResult$[ebp]
  00083	6a 23		 push	 35			; 00000023H
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3688 : 	pResult.Result = TRUE;
; 3689 : 	pResult.Ipos = iItemPos;
; 3690 : 	int map_num = gObj[iIndex].MapNumber;
; 3691 : 	int type = gObj[iIndex].pInventory[iItemPos].m_Type;

  0008b	8b 7d 8c	 mov	 edi, DWORD PTR _iItemPos$GSCopy$[ebp]
  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00099	88 5d 94	 mov	 BYTE PTR _pResult$[ebp+4], bl
  0009c	8b de		 mov	 ebx, esi
  0009e	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  000a4	c6 45 93 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  000a8	8b 8c 03 24 0e
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+3620]
  000af	0f b6 b4 03 49
	01 00 00	 movzx	 esi, BYTE PTR [ebx+eax+329]

; 3692 : 	int level = gObj[iIndex].pInventory[iItemPos].m_Level;
; 3693 : 	float dur = gObj[iIndex].pInventory[iItemPos].m_Durability;

  000b7	d9 44 39 24	 fld	 DWORD PTR [ecx+edi+36]
  000bb	0f bf 54 39 06	 movsx	 edx, WORD PTR [ecx+edi+6]
  000c0	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _dur$[ebp]
  000c6	0f bf 44 39 08	 movsx	 eax, WORD PTR [ecx+edi+8]
  000cb	03 cf		 add	 ecx, edi
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	89 95 6c ff ff
	ff		 mov	 DWORD PTR _type$[ebp], edx
  000d6	89 45 88	 mov	 DWORD PTR _level$[ebp], eax

; 3694 : 	BOOL ret = gObj[iIndex].pInventory[iItemPos].IsItem();

  000d9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 3695 : 	BYTE Option1 = gObj[iIndex].pInventory[iItemPos].m_Option1;

  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e4	8b 84 0b 24 0e
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+3620]
  000eb	0f b6 8c 38 94
	00 00 00	 movzx	 ecx, BYTE PTR [eax+edi+148]

; 3696 : 	BYTE Option2 = gObj[iIndex].pInventory[iItemPos].m_Option2;

  000f3	0f b6 94 38 95
	00 00 00	 movzx	 edx, BYTE PTR [eax+edi+149]
  000fb	03 c7		 add	 eax, edi
  000fd	88 4d 84	 mov	 BYTE PTR _Option1$[ebp], cl

; 3697 : 	BYTE Option3 = gObj[iIndex].pInventory[iItemPos].m_Option3;

  00100	0f b6 88 96 00
	00 00		 movzx	 ecx, BYTE PTR [eax+150]
  00107	88 8d 68 ff ff
	ff		 mov	 BYTE PTR _Option3$[ebp], cl

; 3698 : 	BYTE NOption = gObj[iIndex].pInventory[iItemPos].m_NewOption;
; 3699 : 	DWORD s_num = gObj[iIndex].pInventory[iItemPos].m_Number;

  0010d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010f	88 95 74 ff ff
	ff		 mov	 BYTE PTR _Option2$[ebp], dl
  00115	0f b6 90 97 00
	00 00		 movzx	 edx, BYTE PTR [eax+151]
  0011c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _s_num$[ebp], ecx

; 3700 : 	BYTE ItemExOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(&gObj[iIndex].pInventory[iItemPos]);

  00122	50		 push	 eax
  00123	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00128	88 95 64 ff ff
	ff		 mov	 BYTE PTR _NOption$[ebp], dl
  0012e	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption

; 3701 : 	BYTE ItemExLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel(&gObj[iIndex].pInventory[iItemPos]);

  00133	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00139	88 45 9b	 mov	 BYTE PTR _ItemExOption$[ebp], al
  0013c	8b 84 13 24 0e
	00 00		 mov	 eax, DWORD PTR [ebx+edx+3620]
  00143	03 c7		 add	 eax, edi
  00145	50		 push	 eax
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0014b	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel

; 3702 : 
; 3703 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 3704 : 	::ItemIsBufExOption(NewOption, &gObj[iIndex].pInventory[iItemPos]);

  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00156	8b 94 0b 24 0e
	00 00		 mov	 edx, DWORD PTR [ebx+ecx+3620]
  0015d	03 d7		 add	 edx, edi
  0015f	88 45 a3	 mov	 BYTE PTR _ItemExLevel$[ebp], al
  00162	52		 push	 edx
  00163	8d 45 ec	 lea	 eax, DWORD PTR _NewOption$[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3705 : 	int PetLevel = gObj[iIndex].pInventory[iItemPos].m_PetItem_Level;

  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00172	8b 94 0b 24 0e
	00 00		 mov	 edx, DWORD PTR [ebx+ecx+3620]
  00179	8b 8c 17 bc 00
	00 00		 mov	 ecx, DWORD PTR [edi+edx+188]
  00180	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]

; 3706 : 	int PetExp = gObj[iIndex].pInventory[iItemPos].m_PetItem_Exp;

  00183	8b 90 c0 00 00
	00		 mov	 edx, DWORD PTR [eax+192]
  00189	89 95 60 ff ff
	ff		 mov	 DWORD PTR _PetExp$[ebp], edx

; 3707 : 	BYTE SOption = gObj[iIndex].pInventory[iItemPos].m_SetOption;
; 3708 : 	BYTE ItemEffectEx = gObj[iIndex].pInventory[iItemPos].m_ItemOptionEx;

  0018f	0f b6 90 ca 00
	00 00		 movzx	 edx, BYTE PTR [eax+202]
  00196	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _PetLevel$[ebp], ecx
  0019c	0f b6 88 ae 00
	00 00		 movzx	 ecx, BYTE PTR [eax+174]

; 3709 : 	int item_number = gObj[iIndex].pInventory[iItemPos].m_Number;

  001a3	8b 00		 mov	 eax, DWORD PTR [eax]
  001a5	88 55 80	 mov	 BYTE PTR _ItemEffectEx$[ebp], dl

; 3710 : 	char szItemName[50] = "Item";

  001a8	0f b6 15 04 00
	00 00		 movzx	 edx, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  001af	6a 2d		 push	 45			; 0000002dH
  001b1	89 85 58 ff ff
	ff		 mov	 DWORD PTR _item_number$[ebp], eax
  001b7	88 8d 78 ff ff
	ff		 mov	 BYTE PTR _SOption$[ebp], cl
  001bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  001c3	8d 45 bd	 lea	 eax, DWORD PTR _szItemName$[ebp+5]
  001c6	6a 00		 push	 0
  001c8	50		 push	 eax
  001c9	89 4d b8	 mov	 DWORD PTR _szItemName$[ebp], ecx
  001cc	88 55 bc	 mov	 BYTE PTR _szItemName$[ebp+4], dl
  001cf	e8 00 00 00 00	 call	 _memset

; 3711 : 	int aAntiLootIndex = -1; //loc38
; 3712 : 
; 3713 : 	//Season 4 add-on
; 3714 : 	BYTE SocketOption[5]; //
; 3715 : 	SocketOption[0] = 0xFF;

  001d4	b0 ff		 mov	 al, 255			; 000000ffH
  001d6	83 c4 14	 add	 esp, 20			; 00000014H
  001d9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _SocketOption$[ebp], -1

; 3716 : 	SocketOption[1] = 0xFF;
; 3717 : 	SocketOption[2] = 0xFF;
; 3718 : 	SocketOption[3] = 0xFF;
; 3719 : 	SocketOption[4] = 0xFF;

  001e0	88 45 f8	 mov	 BYTE PTR _SocketOption$[ebp+4], al

; 3720 : 
; 3721 : 	BYTE SocketIndex = 0; //

  001e3	c6 85 7c ff ff
	ff 00		 mov	 BYTE PTR _SocketIndex$[ebp], 0

; 3722 : 
; 3723 : 	g_SocketOption.GetActiveSocketOption(&gObj[iIndex].pInventory[iItemPos],SocketOption,SocketIndex);

  001ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ef	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _SocketIndex$[ebp]
  001f5	51		 push	 ecx
  001f6	8b 8c 03 24 0e
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+3620]
  001fd	8d 55 f4	 lea	 edx, DWORD PTR _SocketOption$[ebp]
  00200	03 cf		 add	 ecx, edi
  00202	52		 push	 edx
  00203	51		 push	 ecx
  00204	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  00209	e8 00 00 00 00	 call	 ?GetActiveSocketOption@CSocketOption@@QAEXPAVCItem@@PAEAAE@Z ; CSocketOption::GetActiveSocketOption

; 3724 : 
; 3725 : 	if ( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y,Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx, SocketOption, SocketIndex) == TRUE )

  0020e	d9 85 70 ff ff
	ff		 fld	 DWORD PTR _dur$[ebp]
  00214	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _SocketIndex$[ebp]
  0021a	52		 push	 edx
  0021b	8b 55 80	 mov	 edx, DWORD PTR _ItemEffectEx$[ebp]
  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00223	8d 4d f4	 lea	 ecx, DWORD PTR _SocketOption$[ebp]
  00226	51		 push	 ecx
  00227	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _PetExp$[ebp]
  0022d	52		 push	 edx
  0022e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _PetLevel$[ebp]
  00234	51		 push	 ecx
  00235	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _item_number$[ebp]
  0023b	52		 push	 edx
  0023c	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _SOption$[ebp]
  00242	6a ff		 push	 -1
  00244	51		 push	 ecx
  00245	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _NOption$[ebp]
  0024b	52		 push	 edx
  0024c	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _Option3$[ebp]
  00252	51		 push	 ecx
  00253	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _Option2$[ebp]
  00259	52		 push	 edx
  0025a	8b 55 84	 mov	 edx, DWORD PTR _Option1$[ebp]
  0025d	51		 push	 ecx
  0025e	0f bf 8c 03 46
	01 00 00	 movsx	 ecx, WORD PTR [ebx+eax+326]
  00266	52		 push	 edx
  00267	0f bf 94 03 44
	01 00 00	 movsx	 edx, WORD PTR [ebx+eax+324]
  0026f	8b 45 88	 mov	 eax, DWORD PTR _level$[ebp]
  00272	51		 push	 ecx
  00273	52		 push	 edx
  00274	51		 push	 ecx
  00275	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  0027b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0027e	50		 push	 eax
  0027f	51		 push	 ecx
  00280	8b ce		 mov	 ecx, esi
  00282	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00288	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0028e	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEQAEE@Z ; MapClass::ItemDrop
  00293	83 f8 01	 cmp	 eax, 1
  00296	0f 85 ce 00 00
	00		 jne	 $LN6@DropItemDi

; 3726 : 	{
; 3727 : 		::gObjInventoryDeleteItem(iIndex, iItemPos);

  0029c	8b 55 8c	 mov	 edx, DWORD PTR _iItemPos$GSCopy$[ebp]
  0029f	8b 45 9c	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  002a2	52		 push	 edx
  002a3	50		 push	 eax
  002a4	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 3728 : 		pResult.Result = TRUE;
; 3729 : 		LogAddTD(lMsg.Get(MSGGET(1, 223)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].Y, s_num, szItemName, type, level, Option1, Option2, Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], SOption, ItemEffectEx>>7, ItemExOption, ItemExLevel);

  002a9	d9 85 70 ff ff
	ff		 fld	 DWORD PTR _dur$[ebp]
  002af	0f b6 4d a3	 movzx	 ecx, BYTE PTR _ItemExLevel$[ebp]
  002b3	0f b6 55 9b	 movzx	 edx, BYTE PTR _ItemExOption$[ebp]
  002b7	0f b6 45 80	 movzx	 eax, BYTE PTR _ItemEffectEx$[ebp]
  002bb	83 c4 08	 add	 esp, 8
  002be	51		 push	 ecx
  002bf	0f b6 8d 78 ff
	ff ff		 movzx	 ecx, BYTE PTR _SOption$[ebp]
  002c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cc	52		 push	 edx
  002cd	0f b6 55 f2	 movzx	 edx, BYTE PTR _NewOption$[ebp+6]
  002d1	c1 e8 07	 shr	 eax, 7
  002d4	50		 push	 eax
  002d5	0f b6 45 f1	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  002d9	51		 push	 ecx
  002da	0f b6 4d f0	 movzx	 ecx, BYTE PTR _NewOption$[ebp+4]
  002de	52		 push	 edx
  002df	0f b6 55 ef	 movzx	 edx, BYTE PTR _NewOption$[ebp+3]
  002e3	50		 push	 eax
  002e4	0f b6 45 ee	 movzx	 eax, BYTE PTR _NewOption$[ebp+2]
  002e8	51		 push	 ecx
  002e9	0f b6 4d ed	 movzx	 ecx, BYTE PTR _NewOption$[ebp+1]
  002ed	52		 push	 edx
  002ee	0f b6 55 ec	 movzx	 edx, BYTE PTR _NewOption$[ebp]
  002f2	50		 push	 eax
  002f3	51		 push	 ecx
  002f4	52		 push	 edx
  002f5	c6 45 93 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  002f9	e8 00 00 00 00	 call	 __ftol2_sse
  002fe	0f b6 8d 74 ff
	ff ff		 movzx	 ecx, BYTE PTR _Option2$[ebp]
  00305	0f b6 55 84	 movzx	 edx, BYTE PTR _Option1$[ebp]
  00309	50		 push	 eax
  0030a	0f b6 85 68 ff
	ff ff		 movzx	 eax, BYTE PTR _Option3$[ebp]
  00311	50		 push	 eax
  00312	8b 45 88	 mov	 eax, DWORD PTR _level$[ebp]
  00315	51		 push	 ecx
  00316	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  0031c	52		 push	 edx
  0031d	50		 push	 eax
  0031e	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _s_num$[ebp]
  00324	51		 push	 ecx
  00325	0f bf 8c 33 46
	01 00 00	 movsx	 ecx, WORD PTR [ebx+esi+326]
  0032d	8d 55 b8	 lea	 edx, DWORD PTR _szItemName$[ebp]
  00330	52		 push	 edx
  00331	0f bf 94 33 44
	01 00 00	 movsx	 edx, WORD PTR [ebx+esi+324]
  00339	50		 push	 eax
  0033a	0f b6 84 33 49
	01 00 00	 movzx	 eax, BYTE PTR [ebx+esi+329]
  00342	51		 push	 ecx
  00343	52		 push	 edx
  00344	50		 push	 eax
  00345	8d 4c 33 77	 lea	 ecx, DWORD PTR [ebx+esi+119]
  00349	51		 push	 ecx
  0034a	8d 54 33 6c	 lea	 edx, DWORD PTR [ebx+esi+108]
  0034e	52		 push	 edx
  0034f	68 df 01 00 00	 push	 479			; 000001dfH
  00354	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00359	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0035e	50		 push	 eax
  0035f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00365	83 c4 64	 add	 esp, 100		; 00000064H

; 3730 : 	}
; 3731 : 	else

  00368	eb 04		 jmp	 SHORT $LN5@DropItemDi
$LN6@DropItemDi:

; 3732 : 	{
; 3733 : 		pResult.Result = FALSE;

  0036a	c6 45 93 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN5@DropItemDi:

; 3734 : 	}
; 3735 : 
; 3736 : 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0036e	0f b6 45 91	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00372	8b 55 9c	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  00375	50		 push	 eax
  00376	8d 4d 90	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00379	51		 push	 ecx
  0037a	52		 push	 edx
  0037b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00380	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3737 : 
; 3738 : 	if ( pResult.Result == TRUE )

  00383	80 7d 93 01	 cmp	 BYTE PTR _pResult$[ebp+3], 1
  00387	0f 85 b9 00 00
	00		 jne	 $LN3@DropItemDi

; 3739 : 	{
; 3740 : 		if ( iItemPos < INVENTORY_BAG_START )

  0038d	8b 45 8c	 mov	 eax, DWORD PTR _iItemPos$GSCopy$[ebp]
  00390	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00393	0f 8d ad 00 00
	00		 jge	 $LN3@DropItemDi

; 3741 : 		{
; 3742 : 			if ( iItemPos== 10 || iItemPos == 11 )

  00399	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0039c	74 05		 je	 SHORT $LN1@DropItemDi
  0039e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  003a1	75 0e		 jne	 SHORT $LN2@DropItemDi
$LN1@DropItemDi:

; 3743 : 			{
; 3744 : 				gObjUseSkill.SkillChangeUse(iIndex);

  003a3	8b 45 9c	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  003a6	50		 push	 eax
  003a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  003ac	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN2@DropItemDi:

; 3745 : 			}
; 3746 : 
; 3747 : 			::gObjMakePreviewCharSet(iIndex);

  003b1	8b 4d 9c	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  003b4	51		 push	 ecx
  003b5	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 3748 : 
; 3749 : 			PMSG_USEREQUIPMENTCHANGED pMsg;
; 3750 : 
; 3751 : 			PHeadSetB((LPBYTE)&pMsg, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  003ba	6a 11		 push	 17			; 00000011H
  003bc	8d 55 a4	 lea	 edx, DWORD PTR _pMsg$220098[ebp]
  003bf	6a 25		 push	 37			; 00000025H
  003c1	52		 push	 edx
  003c2	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3752 : 			pMsg.NumberH = SET_NUMBERH(iIndex);

  003c7	8b 45 9c	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]

; 3753 : 			pMsg.NumberL = SET_NUMBERL(iIndex);
; 3754 : 			ItemByteConvert(pMsg.ItemInfo, gObj[iIndex].pInventory[iItemPos]);

  003ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d0	8b c8		 mov	 ecx, eax
  003d2	c1 e9 08	 shr	 ecx, 8
  003d5	88 4d a7	 mov	 BYTE PTR _pMsg$220098[ebp+3], cl
  003d8	88 45 a8	 mov	 BYTE PTR _pMsg$220098[ebp+4], al
  003db	8b b4 13 24 0e
	00 00		 mov	 esi, DWORD PTR [ebx+edx+3620]
  003e2	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  003e8	03 f7		 add	 esi, edi
  003ea	8d 45 a9	 lea	 eax, DWORD PTR _pMsg$220098[ebp+5]
  003ed	8b fc		 mov	 edi, esp
  003ef	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  003f4	50		 push	 eax
  003f5	f3 a5		 rep movsd
  003f7	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 3755 : 			pMsg.ItemInfo[1] = iItemPos<<4;

  003fc	8b 45 8c	 mov	 eax, DWORD PTR _iItemPos$GSCopy$[ebp]

; 3756 : 			pMsg.ItemInfo[1] |= LevelSmallConvert(iIndex, iItemPos) & 0x0F;

  003ff	8b 55 9c	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  00402	8a c8		 mov	 cl, al
  00404	50		 push	 eax
  00405	c0 e1 04	 shl	 cl, 4
  00408	52		 push	 edx
  00409	88 4d aa	 mov	 BYTE PTR _pMsg$220098[ebp+6], cl
  0040c	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert

; 3757 : 
; 3758 : 			DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00411	8b 55 9c	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  00414	24 0f		 and	 al, 15			; 0000000fH
  00416	08 45 aa	 or	 BYTE PTR _pMsg$220098[ebp+6], al
  00419	0f b6 45 a5	 movzx	 eax, BYTE PTR _pMsg$220098[ebp+1]
  0041d	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00423	50		 push	 eax
  00424	8d 4d a4	 lea	 ecx, DWORD PTR _pMsg$220098[ebp]
  00427	51		 push	 ecx
  00428	52		 push	 edx
  00429	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3759 : 			MsgSendV2(&gObj[iIndex], (LPBYTE)&pMsg, pMsg.h.size);

  0042e	0f b6 45 a5	 movzx	 eax, BYTE PTR _pMsg$220098[ebp+1]
  00432	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00438	50		 push	 eax
  00439	8d 4d a4	 lea	 ecx, DWORD PTR _pMsg$220098[ebp]
  0043c	51		 push	 ecx
  0043d	53		 push	 ebx
  0043e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00443	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@DropItemDi:

; 3760 : 		}
; 3761 : 	}
; 3762 : 
; 3763 : 	return (pResult.Result);
; 3764 : }

  00446	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00449	0f b6 45 93	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  0044d	5f		 pop	 edi
  0044e	5e		 pop	 esi
  0044f	33 cd		 xor	 ecx, ebp
  00451	5b		 pop	 ebx
  00452	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00457	8b e5		 mov	 esp, ebp
  00459	5d		 pop	 ebp
  0045a	c2 10 00	 ret	 16			; 00000010H
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ENDP		; CBloodCastle::DropItemDirectly
_TEXT	ENDS
PUBLIC	??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 369  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 370  : 		++(*(_Mybase *)this);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 371  : 		return (*this);
; 372  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 375  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 376  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 377  : 		++*this;

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
  0000c	89 11		 mov	 DWORD PTR [ecx], edx

; 378  : 		return (_Tmp);
; 379  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
??E?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 502  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	50		 push	 eax
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 503  : 		}

  00009	c3		 ret	 0
??1?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 179  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 180  : 		}

  00008	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 218  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUBLOODCASTLE_START_TIME@@XZ ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z PROC ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 438  : 		{	// construct allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 439  : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ENDP ; std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 882  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 883  : 		}

  00005	c3		 ret	 0
?max_size@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T222386 = -12						; size = 12
$T222391 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 40		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	8d 45 08	 lea	 eax, DWORD PTR $T222391[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T222386[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T222391[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T222386[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T222386[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z ; std::allocator<BLOODCASTLE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z PROC ; std::allocator<BLOODCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UBLOODCASTLE_START_TIME@@@std@@QAEXPAUBLOODCASTLE_START_TIME@@ABU3@@Z ENDP ; std::allocator<BLOODCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?SetState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_None
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
;	COMDAT ?SetState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv170 = -4						; size = 4
_n$218844 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_None, COMDAT
; _this$ = ecx

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 848  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	0f 88 ae 00 00
	00		 js	 $LN6@SetState_N
  00013	33 c0		 xor	 eax, eax
  00015	83 ff 07	 cmp	 edi, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 9e 00 00
	00		 je	 $LN6@SetState_N

; 849  : 	{
; 850  : 		return;
; 851  : 	}
; 852  : 
; 853  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = -1;

  00023	8b c7		 mov	 eax, edi
  00025	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002b	56		 push	 esi
  0002c	83 c9 ff	 or	 ecx, -1

; 854  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = -1;
; 855  : 	this->SendNoticeState(iBridgeIndex, 2);

  0002f	6a 02		 push	 2
  00031	89 8c 18 ac 03
	00 00		 mov	 DWORD PTR [eax+ebx+940], ecx
  00038	89 8c 18 b0 03
	00 00		 mov	 DWORD PTR [eax+ebx+944], ecx
  0003f	57		 push	 edi
  00040	8b cb		 mov	 ecx, ebx
  00042	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 856  : 	this->ClearBridgeData(iBridgeIndex);

  00047	57		 push	 edi
  00048	8b cb		 mov	 ecx, ebx
  0004a	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 857  : 	this->ClearMonster(iBridgeIndex, 1);

  0004f	6a 01		 push	 1
  00051	57		 push	 edi
  00052	8b cb		 mov	 ecx, ebx
  00054	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 860  : 	{
; 861  : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  00059	57		 push	 edi
  0005a	8b cb		 mov	 ecx, ebx
  0005c	c7 45 08 b0 36
	00 00		 mov	 DWORD PTR _n$218844[ebp], 14000 ; 000036b0H
  00063	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00068	89 45 fc	 mov	 DWORD PTR tv170[ebp], eax
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  00075	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL13@SetState_N:

; 862  : 
; 863  : 		if ( gObj[n].MapNumber == iMapNumber && gObj[n].Connected == PLAYER_PLAYING ) //season3 changed

  00080	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00088	3b 4d fc	 cmp	 ecx, DWORD PTR tv170[ebp]
  0008b	75 1a		 jne	 SHORT $LN3@SetState_N
  0008d	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00092	75 13		 jne	 SHORT $LN3@SetState_N

; 864  : 		{
; 865  : 			gObjMoveGate(n, 22);

  00094	8b 55 08	 mov	 edx, DWORD PTR _n$218844[ebp]
  00097	6a 16		 push	 22			; 00000016H
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	83 c4 08	 add	 esp, 8
$LN3@SetState_N:

; 858  : 
; 859  : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  000a7	ff 45 08	 inc	 DWORD PTR _n$218844[ebp]
  000aa	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  000b0	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  000b6	7c c8		 jl	 SHORT $LL13@SetState_N

; 866  : 		}
; 867  : 	}
; 868  : 
; 869  : 	this->BlockCastleDoor(iBridgeIndex);

  000b8	57		 push	 edi
  000b9	8b cb		 mov	 ecx, ebx
  000bb	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor
  000c0	5e		 pop	 esi
$LN6@SetState_N:
  000c1	5f		 pop	 edi
  000c2	5b		 pop	 ebx

; 870  : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
?SetState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_None
_TEXT	ENDS
PUBLIC	??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SetState_Playing@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Playing
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
;	COMDAT ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYING', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv209 = -292						; size = 4
tv205 = -288						; size = 4
_ServerCmd$ = -284					; size = 7
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Playing, COMDAT
; _this$ = ecx

; 905  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]

; 906  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00018	33 db		 xor	 ebx, ebx
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx
  0001d	3b f3		 cmp	 esi, ebx
  0001f	0f 8c 23 01 00
	00		 jl	 $LN6@SetState_P
  00025	33 c0		 xor	 eax, eax
  00027	83 fe 07	 cmp	 esi, 7
  0002a	0f 9e c0	 setle	 al
  0002d	3b c3		 cmp	 eax, ebx
  0002f	0f 84 13 01 00
	00		 je	 $LN6@SetState_P

; 907  : 	{
; 908  : 		return;
; 909  : 	}
; 910  : 
; 911  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  00035	8b c6		 mov	 eax, esi
  00037	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0003d	88 9c 38 bb 03
	00 00		 mov	 BYTE PTR [eax+edi+955], bl

; 912  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_PLAY*60*1000;

  00044	8b 8f 0c 23 00
	00		 mov	 ecx, DWORD PTR [edi+8972]
  0004a	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  00050	89 8c 38 ac 03
	00 00		 mov	 DWORD PTR [eax+edi+940], ecx

; 913  : 	this->CheckUsersOnConnect(iBridgeIndex);

  00057	56		 push	 esi
  00058	8b cf		 mov	 ecx, edi
  0005a	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ; CBloodCastle::CheckUsersOnConnect

; 914  : 
; 915  : 	PMSG_NOTICE pNotice;
; 916  : 
; 917  : 	TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 139)), iBridgeIndex+1, 60);

  0005f	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00062	6a 3c		 push	 60			; 0000003cH
  00064	50		 push	 eax
  00065	68 8b 04 00 00	 push	 1163			; 0000048bH
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0006f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv205[ebp], eax
  00075	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0007a	50		 push	 eax
  0007b	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  00081	6a 01		 push	 1
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 918  : 	this->SendBridgeAnyMsg((LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  00089	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  00090	83 c4 14	 add	 esp, 20			; 00000014H
  00093	56		 push	 esi
  00094	50		 push	 eax
  00095	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0009b	51		 push	 ecx
  0009c	8b cf		 mov	 ecx, edi
  0009e	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 919  : 
; 920  : 	PMSG_SERVERCMD ServerCmd;
; 921  : 
; 922  : 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  000a3	6a 07		 push	 7
  000a5	6a 40		 push	 64			; 00000040H
  000a7	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _ServerCmd$[ebp]
  000ad	68 f3 00 00 00	 push	 243			; 000000f3H
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 923  : 	ServerCmd.CmdType = 1;
; 924  : 	ServerCmd.X = 45;
; 925  : 	ServerCmd.Y = 0;
; 926  : 
; 927  : 	this->SendBridgeAnyMsg((LPBYTE)&ServerCmd, ServerCmd.h.size, iBridgeIndex);

  000b8	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _ServerCmd$[ebp+1]
  000bf	83 c4 10	 add	 esp, 16			; 00000010H
  000c2	56		 push	 esi
  000c3	50		 push	 eax
  000c4	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$[ebp]
  000ca	51		 push	 ecx
  000cb	8b cf		 mov	 ecx, edi
  000cd	66 c7 85 e8 fe
	ff ff 01 2d	 mov	 WORD PTR _ServerCmd$[ebp+4], 11521 ; 00002d01H
  000d6	88 9d ea fe ff
	ff		 mov	 BYTE PTR _ServerCmd$[ebp+6], bl
  000dc	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 930  : 	{
; 931  : 		if ( gObj[n].MapNumber == this->GetBridgeMapNumber(iBridgeIndex) && gObj[n].Connected > PLAYER_LOGGED ) //season3 changed

  000e1	56		 push	 esi
  000e2	8b cf		 mov	 ecx, edi
  000e4	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  000e9	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  000ee	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv209[ebp], eax
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f9	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  000fe	8b ff		 npad	 2
$LL12@SetState_P:
  00100	0f b6 94 06 49
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+329]
  00108	3b 95 dc fe ff
	ff		 cmp	 edx, DWORD PTR tv209[ebp]
  0010e	75 14		 jne	 SHORT $LN3@SetState_P
  00110	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  00115	7e 0d		 jle	 SHORT $LN3@SetState_P

; 932  : 		{
; 933  : 			this->SearchUserDeleteQuestItem(n);

  00117	53		 push	 ebx
  00118	8b cf		 mov	 ecx, edi
  0011a	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
  0011f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@SetState_P:

; 928  : 
; 929  : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00124	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0012a	43		 inc	 ebx
  0012b	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00131	7c cd		 jl	 SHORT $LL12@SetState_P

; 934  : 		}
; 935  : 	}
; 936  : 
; 937  : 	LogAddTD("[Blood Castle] (%d) SetState PLAYING", iBridgeIndex+1);

  00133	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00145	83 c4 08	 add	 esp, 8
$LN6@SetState_P:

; 938  : }

  00148	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	33 cd		 xor	 ecx, ebp
  0014f	5b		 pop	 ebx
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 04 00	 ret	 4
?SetState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Playing
_TEXT	ENDS
PUBLIC	??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	?SetState_PlayEnd@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_PlayEnd
;	COMDAT ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYEND', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_PlayEnd, COMDAT
; _this$ = ecx

; 941  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 942  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 7d		 js	 SHORT $LN2@SetState_P@2
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 07	 cmp	 esi, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 71		 je	 SHORT $LN2@SetState_P@2

; 943  : 	{
; 944  : 		return;
; 945  : 	}
; 946  : 
; 947  : 	this->SendNoticeState(iBridgeIndex, 2);

  0001a	57		 push	 edi
  0001b	6a 02		 push	 2
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 948  : 	this->ClearMonster(iBridgeIndex, 0);

  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	8b cb		 mov	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 949  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  0002d	8b fe		 mov	 edi, esi
  0002f	69 ff 60 04 00
	00		 imul	 edi, 1120		; 00000460H
  00035	03 fb		 add	 edi, ebx
  00037	c6 87 bb 03 00
	00 00		 mov	 BYTE PTR [edi+955], 0

; 950  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_REST*60*1000;

  0003e	8b 8b 10 23 00
	00		 mov	 ecx, DWORD PTR [ebx+8976]
  00044	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H

; 951  : 
; 952  : 	LogAddTD("[Blood Castle] (%d) SetState PLAYEND", iBridgeIndex+1);

  0004a	46		 inc	 esi
  0004b	56		 push	 esi
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00051	89 8f ac 03 00
	00		 mov	 DWORD PTR [edi+940], ecx
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0005d	83 c4 08	 add	 esp, 8
  00060	83 c7 1c	 add	 edi, 28			; 0000001cH
  00063	be 28 00 00 00	 mov	 esi, 40			; 00000028H
$LL4@SetState_P@2:

; 955  : 	{
; 956  : 		if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex) != FALSE )

  00068	8b 07		 mov	 eax, DWORD PTR [edi]
  0006a	85 c0		 test	 eax, eax
  0006c	78 16		 js	 SHORT $LN3@SetState_P@2
  0006e	33 c9		 xor	 ecx, ecx
  00070	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00075	0f 9e c1	 setle	 cl
  00078	85 c9		 test	 ecx, ecx
  0007a	74 08		 je	 SHORT $LN3@SetState_P@2

; 957  : 		{
; 958  : 			this->SearchUserDeleteQuestItem(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex);

  0007c	50		 push	 eax
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN3@SetState_P@2:

; 953  : 
; 954  : 	for (int n=0;n<MAX_BLOOD_CASTLE_SUB_BRIDGE;n++)

  00084	83 c7 14	 add	 edi, 20			; 00000014H
  00087	4e		 dec	 esi
  00088	75 de		 jne	 SHORT $LL4@SetState_P@2
  0008a	5f		 pop	 edi
$LN2@SetState_P@2:
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 959  : 		}
; 960  : 	}
; 961  : }

  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_PlayEnd
_TEXT	ENDS
PUBLIC	??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z	; CBloodCastle::SearchUserDropQuestItem
;	COMDAT ??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%u]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%u-%u]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv366 = -8						; size = 4
_iLEVEL$219647 = -4					; size = 4
_x$219641 = 8						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDropQuestItem, COMDAT
; _this$ = ecx

; 2568 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2569 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	8b d9		 mov	 ebx, ecx
  00010	3b f7		 cmp	 esi, edi
  00012	0f 8c a3 01 00
	00		 jl	 $LN11@SearchUser@2
  00018	33 c0		 xor	 eax, eax
  0001a	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00020	0f 9e c0	 setle	 al
  00023	3b c7		 cmp	 eax, edi
  00025	0f 84 90 01 00
	00		 je	 $LN11@SearchUser@2

; 2570 : 	{
; 2571 : 		return;
; 2572 : 	}
; 2573 : 
; 2574 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00036	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  0003c	0f 85 79 01 00
	00		 jne	 $LN11@SearchUser@2
  00042	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  00047	0f 8e 6e 01 00
	00		 jle	 $LN11@SearchUser@2

; 2575 : 	{
; 2576 : 		return;
; 2577 : 	}
; 2578 : 
; 2579 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  0004d	89 7d 08	 mov	 DWORD PTR _x$219641[ebp], edi
$LL10@SearchUser@2:

; 2580 : 	{
; 2581 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00050	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  00057	03 cf		 add	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	83 f8 01	 cmp	 eax, 1

; 2582 : 		{
; 2583 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	0f 85 3a 01 00
	00		 jne	 $LN9@SearchUser@2
  0006c	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  00073	ba 13 1a 00 00	 mov	 edx, 6675		; 00001a13H
  00078	66 39 54 39 06	 cmp	 WORD PTR [ecx+edi+6], dx
  0007d	0f 85 23 01 00
	00		 jne	 $LN9@SearchUser@2

; 2584 : 			{
; 2585 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  00083	0f bf 4c 39 08	 movsx	 ecx, WORD PTR [ecx+edi+8]
  00088	89 4d fc	 mov	 DWORD PTR _iLEVEL$219647[ebp], ecx

; 2586 : 
; 2587 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  0008b	85 c9		 test	 ecx, ecx
  0008d	0f 88 13 01 00
	00		 js	 $LN9@SearchUser@2
  00093	33 d2		 xor	 edx, edx
  00095	83 f9 02	 cmp	 ecx, 2
  00098	0f 9e c2	 setle	 dl
  0009b	8b ca		 mov	 ecx, edx
  0009d	85 c9		 test	 ecx, ecx
  0009f	0f 84 01 01 00
	00		 je	 $LN9@SearchUser@2

; 2588 : 				{
; 2589 : 					BYTE pMsg[6];
; 2590 : 					pMsg[5] = x;
; 2591 : 					pMsg[3] = gObj[iIndex].X;
; 2592 : 					pMsg[4] = gObj[iIndex].Y;
; 2593 : 
; 2594 : 					int iBC_INDEX = this->GetBridgeIndex(gObj[iIndex].MapNumber); //season3 add-on
; 2595 : 
; 2596 : 					this->DropItemDirectly(iBC_INDEX, gObj[iIndex].m_Index, ITEMGET(13, 19), x); //season3 add-on

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _x$219641[ebp]
  000a8	8b 14 06	 mov	 edx, DWORD PTR [esi+eax]
  000ab	0f b6 84 06 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+329]
  000b3	51		 push	 ecx
  000b4	68 13 1a 00 00	 push	 6675			; 00001a13H
  000b9	52		 push	 edx
  000ba	50		 push	 eax
  000bb	8b cb		 mov	 ecx, ebx
  000bd	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  000c2	50		 push	 eax
  000c3	8b cb		 mov	 ecx, ebx
  000c5	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2597 : 					this->DropItemDirectly(gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1,	gObj[iIndex].m_Index, ITEMGET(13, 19), x); //remove this

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	8b 14 06	 mov	 edx, DWORD PTR [esi+eax]
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _x$219641[ebp]
  000d5	0f b6 84 06 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+329]
  000dd	51		 push	 ecx
  000de	68 13 1a 00 00	 push	 6675			; 00001a13H
  000e3	52		 push	 edx
  000e4	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000e7	50		 push	 eax
  000e8	8b cb		 mov	 ecx, ebx
  000ea	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2598 : 
; 2599 : 					if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) != FALSE )

  000ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	8a 84 16 49 01
	00 00		 mov	 al, BYTE PTR [esi+edx+329]
  000fc	3c 34		 cmp	 al, 52			; 00000034H
  000fe	74 10		 je	 SHORT $LN26@SearchUser@2
  00100	3c 0b		 cmp	 al, 11			; 0000000bH
  00102	72 76		 jb	 SHORT $LN4@SearchUser@2
  00104	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00109	3a c8		 cmp	 cl, al
  0010b	1b c9		 sbb	 ecx, ecx
  0010d	41		 inc	 ecx
  0010e	74 6a		 je	 SHORT $LN4@SearchUser@2
$LN26@SearchUser@2:

; 2600 : 					{
; 2601 : 						int iBC_INDEX = this->GetBridgeIndex(gObj[iIndex].MapNumber);

  00110	0f b6 c0	 movzx	 eax, al
  00113	50		 push	 eax
  00114	8b cb		 mov	 ecx, ebx
  00116	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex

; 2602 : 
; 2603 : 						if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL != -1 )

  0011b	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00121	03 c3		 add	 eax, ebx
  00123	89 45 f8	 mov	 DWORD PTR tv366[ebp], eax
  00126	8b 80 e8 03 00
	00		 mov	 eax, DWORD PTR [eax+1000]
  0012c	83 f8 ff	 cmp	 eax, -1
  0012f	74 1f		 je	 SHORT $LN2@SearchUser@2

; 2604 : 						{
; 2605 : 							if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  00131	8b 8c 16 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+edx+3620]
  00138	3b 04 0f	 cmp	 eax, DWORD PTR [edi+ecx]
  0013b	75 13		 jne	 SHORT $LN2@SearchUser@2

; 2606 : 							{
; 2607 : 								this->m_BridgeData[iBC_INDEX].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  0013d	8b 55 f8	 mov	 edx, DWORD PTR tv366[ebp]
  00140	c7 82 ec 03 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+1004], -1
  0014a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@SearchUser@2:

; 2608 : 							}
; 2609 : 						}
; 2610 : 
; 2611 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%u-%u]", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL, gObj[iIndex].pInventory[x].m_Number);

  00150	8b 8c 16 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+edx+3620]
  00157	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  0015a	51		 push	 ecx
  0015b	50		 push	 eax
  0015c	8b 45 fc	 mov	 eax, DWORD PTR _iLEVEL$219647[ebp]
  0015f	50		 push	 eax
  00160	8d 4c 16 77	 lea	 ecx, DWORD PTR [esi+edx+119]
  00164	51		 push	 ecx
  00165	8d 54 16 6c	 lea	 edx, DWORD PTR [esi+edx+108]
  00169	52		 push	 edx
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@GIMHNEOG@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00175	83 c4 18	 add	 esp, 24			; 00000018H

; 2612 : 					}
; 2613 : 					else

  00178	eb 27		 jmp	 SHORT $LN29@SearchUser@2
$LN4@SearchUser@2:

; 2614 : 					{
; 2615 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%u]", gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, gObj[iIndex].pInventory[x].m_Number);

  0017a	8b 84 16 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+edx+3620]
  00181	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  00184	8b 45 fc	 mov	 eax, DWORD PTR _iLEVEL$219647[ebp]
  00187	51		 push	 ecx
  00188	50		 push	 eax
  00189	8d 4c 16 77	 lea	 ecx, DWORD PTR [esi+edx+119]
  0018d	51		 push	 ecx
  0018e	8d 54 16 6c	 lea	 edx, DWORD PTR [esi+edx+108]
  00192	52		 push	 edx
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@BDGGPIDE@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0019e	83 c4 14	 add	 esp, 20			; 00000014H
$LN29@SearchUser@2:
  001a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN9@SearchUser@2:

; 2575 : 	{
; 2576 : 		return;
; 2577 : 	}
; 2578 : 
; 2579 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  001a6	ff 45 08	 inc	 DWORD PTR _x$219641[ebp]
  001a9	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  001af	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  001b5	0f 8c 95 fe ff
	ff		 jl	 $LL10@SearchUser@2
$LN11@SearchUser@2:
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx

; 2616 : 					}
; 2617 : 				}
; 2618 : 			}
; 2619 : 		}
; 2620 : 	}
; 2621 : }

  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 04 00	 ret	 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDropQuestItem
_TEXT	ENDS
PUBLIC	??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 336  : 	_List_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 337  : 		{	// construct with null node
; 338  : 		}

  00008	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 360  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 361  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_START_TIME@@XZ ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
CONST	ENDS
;	COMDAT ?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize, COMDAT
; _this$ = ecx

; 1519 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	be fe ff ff 1f	 mov	 esi, 536870910		; 1ffffffeH
  0000f	2b f0		 sub	 esi, eax
  00011	3b f2		 cmp	 esi, edx
  00013	5e		 pop	 esi
  00014	73 0a		 jae	 SHORT $LN1@Incsize

; 1521 : 			_Xlength_error("list<T> too long");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0001b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN11@Incsize:
$LN1@Incsize:

; 1522 : 		this->_Mysize += _Count;

  00020	03 c2		 add	 eax, edx
  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1523 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN10@Incsize:
?_Incsize@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Incsize
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
$T222521 = -12						; size = 12
$T222519 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 40		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 10		 ja	 SHORT $LN3@allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00027	8d 45 08	 lea	 eax, DWORD PTR $T222519[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T222521[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T222519[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T222521[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T222521[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_const_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>,std::_List_nod<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
$T222632 = -16						; size = 12
$T222616 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 493  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 10		 push	 16			; 00000010H
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 12		 je	 SHORT $LN13@List_val
  0001e	89 06		 mov	 DWORD PTR [esi], eax

; 496  : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00020	89 00		 mov	 DWORD PTR [eax], eax

; 497  : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 498  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN13@List_val:
  00030	8d 45 fc	 lea	 eax, DWORD PTR $T222616[ebp]
  00033	50		 push	 eax
  00034	8d 4d f0	 lea	 ecx, DWORD PTR $T222632[ebp]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T222616[ebp], 0
  0003e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00043	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T222632[ebp]
  0004b	51		 push	 ecx
  0004c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T222632[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@List_val:
$LN28@List_val:
  00058	cc		 int	 3
??0?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UBLOODCASTLE_START_TIME@@@1@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@PBV?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >::_List_iterator<std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear, COMDAT
; _this$ = ecx

; 1096 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1097 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1098 : 		this->_Orphan_ptr(*this, 0);
; 1099 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1100 : 
; 1101 : 		_Nodeptr _Pnext;
; 1102 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1103 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00007	89 09		 mov	 DWORD PTR [ecx], ecx

; 1104 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 1105 : 		this->_Mysize = 0;

  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1106 : 
; 1107 : 		for (; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	74 19		 je	 SHORT $LN1@clear
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL3@clear:

; 1108 : 			{	// delete an element
; 1109 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 38		 mov	 edi, DWORD PTR [eax]

; 1110 : 
; 1111 : 			_Dest_val(this->_Alnod, _Pnode);
; 1112 : 			this->_Alnod.deallocate(_Pnode, 1);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c7		 mov	 eax, edi
  0002d	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0002f	75 ef		 jne	 SHORT $LL3@clear
  00031	5f		 pop	 edi
$LN1@clear:
  00032	5e		 pop	 esi

; 1113 : 			}
; 1114 : 		}

  00033	c3		 ret	 0
?clear@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
; Function compile flags: /Ogtp
;	COMDAT ?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
$T222721 = -12						; size = 12
$T222705 = 8						; size = 4
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z PROC ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode, COMDAT
; _this$ = ecx

; 507  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00008	6a 10		 push	 16			; 00000010H
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	83 c4 04	 add	 esp, 4
  00016	85 f6		 test	 esi, esi
  00018	74 29		 je	 SHORT $LN10@Buynode

; 509  : 
; 510  : 		_TRY_BEGIN
; 511  : 		this->_Nextnode(_Pnode) = _Next;

  0001a	8b 45 08	 mov	 eax, DWORD PTR __Next$[ebp]

; 512  : 		this->_Prevnode(_Pnode) = _Prev;
; 513  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Pnode)), _Val);

  0001d	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR __Prev$[ebp]
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	52		 push	 edx
  00026	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00029	50		 push	 eax
  0002a	83 c7 09	 add	 edi, 9
  0002d	57		 push	 edi
  0002e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00031	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@UBLOODCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UBLOODCASTLE_START_TIME@@@0@PAUBLOODCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<BLOODCASTLE_START_TIME>,BLOODCASTLE_START_TIME,BLOODCASTLE_START_TIME const &>
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	5f		 pop	 edi

; 514  : 		_CATCH_ALL
; 515  : 		this->_Alnod.deallocate(_Pnode, 1);
; 516  : 		_RERAISE;
; 517  : 		_CATCH_END
; 518  : 
; 519  : 		return (_Pnode);

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 520  : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

$LN10@Buynode:
  00043	8d 4d 08	 lea	 ecx, DWORD PTR $T222705[ebp]
  00046	51		 push	 ecx
  00047	8d 4d f4	 lea	 ecx, DWORD PTR $T222721[ebp]
  0004a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T222705[ebp], 0
  00051	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00056	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005b	8d 55 f4	 lea	 edx, DWORD PTR $T222721[ebp]
  0005e	52		 push	 edx
  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T222721[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00066	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@Buynode:
$LN32@Buynode:
  0006b	cc		 int	 3
?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ENDP ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T222838 = -16						; size = 12
$T222789 = -4						; size = 4
??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 607  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 10		 push	 16			; 00000010H
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 10		 je	 SHORT $LN18@list
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	89 00		 mov	 DWORD PTR [eax], eax
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 608  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0

; 607  : 		{	// construct empty list

$LN18@list:
  0002e	8d 45 fc	 lea	 eax, DWORD PTR $T222789[ebp]
  00031	50		 push	 eax
  00032	8d 4d f0	 lea	 ecx, DWORD PTR $T222838[ebp]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T222789[ebp], 0
  0003c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00041	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00046	8d 4d f0	 lea	 ecx, DWORD PTR $T222838[ebp]
  00049	51		 push	 ecx
  0004a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T222838[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN35@list:
$LN34@list:
  00056	cc		 int	 3
??0?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
; Function compile flags: /Ogtp
;	COMDAT ?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Myhead, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::end
_TEXT	ENDS
PUBLIC	?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert, COMDAT
; _this$ = ecx

; 967  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 968  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 969  : 		if (_Where._Getcont() != this)
; 970  : 			_DEBUG_ERROR("list insert iterator outside range");
; 971  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 972  : 
; 973  : 		_Nodeptr _Pnode = _Where._Mynode();
; 974  : 		_Nodeptr _Newnode =
; 975  : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode), _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00013	51		 push	 ecx
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode

; 976  : 		_Incsize(1);

  0001d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00020	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00025	2b d1		 sub	 edx, ecx
  00027	83 fa 01	 cmp	 edx, 1
  0002a	73 0a		 jae	 SHORT $LN7@Insert
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN24@Insert:
$LN7@Insert:
  00036	41		 inc	 ecx
  00037	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 977  : 		this->_Prevnode(_Pnode) = _Newnode;

  0003a	89 07		 mov	 DWORD PTR [edi], eax

; 978  : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	5f		 pop	 edi
  00040	89 01		 mov	 DWORD PTR [ecx], eax
  00042	5e		 pop	 esi

; 979  : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN23@Insert:
?_Insert@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@@2@ABUBLOODCASTLE_START_TIME@@@Z ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1496 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1497 : 		clear();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]
  00007	89 09		 mov	 DWORD PTR [ecx], ecx
  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	74 19		 je	 SHORT $LN3@Tidy
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@Tidy:
  00020	8b 38		 mov	 edi, DWORD PTR [eax]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c7		 mov	 eax, edi
  0002d	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0002f	75 ef		 jne	 SHORT $LL5@Tidy
  00031	5f		 pop	 edi
$LN3@Tidy:
  00032	5e		 pop	 esi

; 1498 : 		}

  00033	c3		 ret	 0
?_Tidy@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Tidy
_TEXT	ENDS
PUBLIC	??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@ ; `string'
PUBLIC	??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@ ; `string'
PUBLIC	?CheckSync@CBloodCastle@@IAEXH@Z		; CBloodCastle::CheckSync
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@
CONST	SEGMENT
??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@ DB '['
	DB	'Blood Castle] (%d) Sync Open Time. [%d] min remain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@
CONST	SEGMENT
??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@ DB 'Error : Bl'
	DB	'ood Castle StartTime size is 0', 00H	; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
CONST	ENDS
;	COMDAT ?CheckSync@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_ltime$ = -44						; size = 8
_WebzenVar1$ = -36					; size = 8
_WebzenVar2$ = -28					; size = 8
_this$ = -20						; size = 4
_BaseTime$ = -16					; size = 4
_loc12$ = -12						; size = 4
_today$ = -12						; size = 4
tv644 = -8						; size = 4
_CurrentTime$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckSync@CBloodCastle@@IAEXH@Z PROC			; CBloodCastle::CheckSync, COMDAT
; _this$ = ecx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 362  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00006	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0000f	85 c0		 test	 eax, eax
  00011	0f 88 b7 01 00
	00		 js	 $LN18@CheckSync
  00017	33 c9		 xor	 ecx, ecx
  00019	83 f8 07	 cmp	 eax, 7
  0001c	0f 9e c1	 setle	 cl
  0001f	85 c9		 test	 ecx, ecx
  00021	0f 84 a7 01 00
	00		 je	 $LN18@CheckSync

; 363  : 	{
; 364  : 		return;
; 365  : 	}
; 366  : 
; 367  : 	std::list<BLOODCASTLE_START_TIME>::iterator it;
; 368  : 	BLOODCASTLE_START_TIME WebzenVar1;
; 369  : 	BLOODCASTLE_START_TIME WebzenVar2;
; 370  : 	int BaseTime = 0; //7
; 371  : 	int CheckTime = 0; //8
; 372  : 	DWORD CurrentTime = 0; //9
; 373  : 	
; 374  : 	tm * today; //10
; 375  : 	time_t ltime; //11
; 376  : 
; 377  : 	int loc12;
; 378  : 	int loc13;
; 379  : 
; 380  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00027	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  0002d	57		 push	 edi
  0002e	8d 3c 30	 lea	 edi, DWORD PTR [eax+esi]
  00031	89 7d f8	 mov	 DWORD PTR tv644[ebp], edi
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003a	89 87 b0 03 00
	00		 mov	 DWORD PTR [edi+944], eax

; 381  : 
; 382  : 	if(this->m_listBloodCastleOpenTime.size() == 0)

  00040	83 be 24 23 00
	00 00		 cmp	 DWORD PTR [esi+8996], 0
  00047	75 15		 jne	 SHORT $LN16@CheckSync

; 383  : 	{
; 384  : 		MsgBox("Error : Blood Castle StartTime size is 0");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@
  0004e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00053	83 c4 04	 add	 esp, 4
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 460  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN16@CheckSync:

; 385  : 		return;
; 386  : 	}
; 387  : 
; 388  : 	time(&ltime);

  0005e	8d 45 d4	 lea	 eax, DWORD PTR _ltime$[ebp]
  00061	53		 push	 ebx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __time64

; 389  : 	today = localtime(&ltime);

  00068	8d 4d d4	 lea	 ecx, DWORD PTR _ltime$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 __localtime64

; 390  : 
; 391  : 	
; 392  : 	CurrentTime = (today->tm_hour * 60) + today->tm_min;
; 393  : 	WebzenVar1 = *this->m_listBloodCastleOpenTime.begin();

  00071	8b b6 20 23 00
	00		 mov	 esi, DWORD PTR [esi+8992]
  00077	8b d8		 mov	 ebx, eax
  00079	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007c	8b d0		 mov	 edx, eax
  0007e	c1 e2 04	 shl	 edx, 4
  00081	2b d0		 sub	 edx, eax
  00083	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00086	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00089	8b 06		 mov	 eax, DWORD PTR [esi]
  0008b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0008e	83 c4 08	 add	 esp, 8
  00091	89 4d fc	 mov	 DWORD PTR _CurrentTime$[ebp], ecx
  00094	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00097	89 5d f4	 mov	 DWORD PTR _today$[ebp], ebx
  0009a	89 55 e0	 mov	 DWORD PTR _WebzenVar1$[ebp+4], edx

; 394  : 
; 395  : 	for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it )

  0009d	3b c6		 cmp	 eax, esi
  0009f	0f 84 99 00 00
	00		 je	 $LN166@CheckSync
$LL66@CheckSync:

; 396  : 	{
; 397  : 		WebzenVar2 = *it;

  000a5	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]

; 398  : 		BaseTime = (WebzenVar1.m_iHour * 60) + WebzenVar1.m_iMinute;

  000a8	8b 5d e0	 mov	 ebx, DWORD PTR _WebzenVar1$[ebp+4]
  000ab	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ae	89 7d e8	 mov	 DWORD PTR _WebzenVar2$[ebp+4], edi
  000b1	8b f9		 mov	 edi, ecx
  000b3	c1 e7 04	 shl	 edi, 4
  000b6	2b f9		 sub	 edi, ecx
  000b8	8d 3c bb	 lea	 edi, DWORD PTR [ebx+edi*4]

; 399  : 		CheckTime =	(WebzenVar2.m_iHour * 60) + WebzenVar2.m_iMinute;

  000bb	8b 5d e8	 mov	 ebx, DWORD PTR _WebzenVar2$[ebp+4]
  000be	89 7d f0	 mov	 DWORD PTR _BaseTime$[ebp], edi
  000c1	8b fa		 mov	 edi, edx
  000c3	c1 e7 04	 shl	 edi, 4
  000c6	2b fa		 sub	 edi, edx
  000c8	8d 3c bb	 lea	 edi, DWORD PTR [ebx+edi*4]

; 400  : 
; 401  : 		if( BaseTime == CheckTime )

  000cb	8b 5d f0	 mov	 ebx, DWORD PTR _BaseTime$[ebp]
  000ce	3b df		 cmp	 ebx, edi
  000d0	75 4d		 jne	 SHORT $LN12@CheckSync

; 402  : 		{
; 403  : 			if( CurrentTime < CheckTime )

  000d2	39 7d fc	 cmp	 DWORD PTR _CurrentTime$[ebp], edi
  000d5	73 5b		 jae	 SHORT $LN14@CheckSync

; 404  : 			{
; 405  : 				WebzenVar2 = *it;

  000d7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000da	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp+4], ecx
$LN167@CheckSync:
  000dd	8b 7d f8	 mov	 edi, DWORD PTR tv644[ebp]
  000e0	8b 5d f4	 mov	 ebx, DWORD PTR _today$[ebp]
$LN163@CheckSync:

; 418  : 		}
; 419  : 	}
; 420  : 
; 421  : 	for(loc12 = 2;loc12--;)

  000e3	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _loc12$[ebp], 2
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL8@CheckSync:
  000f0	ff 4d f4	 dec	 DWORD PTR _loc12$[ebp]

; 422  : 	{
; 423  : 		if(it == this->m_listBloodCastleOpenTime.end())

  000f3	3b c6		 cmp	 eax, esi
  000f5	75 0b		 jne	 SHORT $LN169@CheckSync

; 424  : 		{
; 425  : 			it = this->m_listBloodCastleOpenTime.begin();

  000f7	8b 06		 mov	 eax, DWORD PTR [esi]

; 426  : 
; 427  : 			WebzenVar2 = (*it);

  000f9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000fc	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ff	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp+4], ecx
$LN169@CheckSync:

; 428  : 		}
; 429  : 
; 430  : 		CheckTime = WebzenVar2.m_iHour*60+WebzenVar2.m_iMinute;

  00102	8b 75 e8	 mov	 esi, DWORD PTR _WebzenVar2$[ebp+4]
  00105	8b ca		 mov	 ecx, edx
  00107	c1 e1 04	 shl	 ecx, 4
  0010a	2b ca		 sub	 ecx, edx
  0010c	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]

; 431  : 
; 432  : 		if(today->tm_hour <= WebzenVar2.m_iHour && CheckTime > CurrentTime)

  0010f	8b 75 fc	 mov	 esi, DWORD PTR _CurrentTime$[ebp]
  00112	39 53 08	 cmp	 DWORD PTR [ebx+8], edx
  00115	7f 2c		 jg	 SHORT $LN5@CheckSync
  00117	3b ce		 cmp	 ecx, esi
  00119	76 28		 jbe	 SHORT $LN5@CheckSync

; 433  : 		{
; 434  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((CheckTime - CurrentTime)*60)*1000;

  0011b	2b ce		 sub	 ecx, esi

; 435  : 		}
; 436  : 		else

  0011d	eb 2c		 jmp	 SHORT $LN172@CheckSync
$LN12@CheckSync:

; 406  : 				break;
; 407  : 			}
; 408  : 			continue;
; 409  : 		}
; 410  : 		
; 411  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _CurrentTime$[ebp]
  00122	3b cb		 cmp	 ecx, ebx
  00124	72 04		 jb	 SHORT $LN10@CheckSync
  00126	3b cf		 cmp	 ecx, edi
  00128	72 b3		 jb	 SHORT $LN167@CheckSync
$LN10@CheckSync:

; 412  : 		{
; 413  : 			break;
; 414  : 		}
; 415  : 		else
; 416  : 		{
; 417  : 			WebzenVar1 = *it;

  0012a	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0012d	8b ca		 mov	 ecx, edx
  0012f	89 7d e0	 mov	 DWORD PTR _WebzenVar1$[ebp+4], edi
$LN14@CheckSync:

; 394  : 
; 395  : 	for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it )

  00132	8b 00		 mov	 eax, DWORD PTR [eax]
  00134	3b c6		 cmp	 eax, esi
  00136	0f 85 69 ff ff
	ff		 jne	 $LL66@CheckSync

; 406  : 				break;
; 407  : 			}
; 408  : 			continue;
; 409  : 		}
; 410  : 		
; 411  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  0013c	eb 9f		 jmp	 SHORT $LN167@CheckSync
$LN166@CheckSync:

; 404  : 			{
; 405  : 				WebzenVar2 = *it;

  0013e	8b 55 e4	 mov	 edx, DWORD PTR _WebzenVar2$[ebp]
  00141	eb a0		 jmp	 SHORT $LN163@CheckSync
$LN5@CheckSync:

; 437  : 		{
; 438  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((1440-CurrentTime+CheckTime)*60)*1000;

  00143	2b ce		 sub	 ecx, esi
  00145	81 c1 a0 05 00
	00		 add	 ecx, 1440		; 000005a0H
$LN172@CheckSync:
  0014b	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  00151	89 8f ac 03 00
	00		 mov	 DWORD PTR [edi+940], ecx

; 439  : 		}
; 440  : 
; 441  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ))

  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	8b b1 08 23 00
	00		 mov	 esi, DWORD PTR [ecx+8968]
  00160	69 f6 60 ea 00
	00		 imul	 esi, 60000		; 0000ea60H
  00166	39 b7 ac 03 00
	00		 cmp	 DWORD PTR [edi+940], esi
  0016c	7f 1f		 jg	 SHORT $LN3@CheckSync

; 442  : 		{
; 443  : 			it++;

  0016e	8b 00		 mov	 eax, DWORD PTR [eax]

; 444  : 
; 445  : 			if(it != this->m_listBloodCastleOpenTime.end())

  00170	8b b1 20 23 00
	00		 mov	 esi, DWORD PTR [ecx+8992]
  00176	3b c6		 cmp	 eax, esi
  00178	74 09		 je	 SHORT $LN2@CheckSync

; 446  : 			{
; 447  : 				WebzenVar2 = (*it);

  0017a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0017d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00180	89 4d e8	 mov	 DWORD PTR _WebzenVar2$[ebp+4], ecx
$LN2@CheckSync:

; 418  : 		}
; 419  : 	}
; 420  : 
; 421  : 	for(loc12 = 2;loc12--;)

  00183	83 7d f4 00	 cmp	 DWORD PTR _loc12$[ebp], 0
  00187	0f 85 63 ff ff
	ff		 jne	 $LL8@CheckSync
$LN3@CheckSync:

; 448  : 			}
; 449  : 		}
; 450  : 		else
; 451  : 		{
; 452  : 			break;
; 453  : 		}
; 454  : 	}
; 455  : 
; 456  : 	loc13 = GetTickCount();

  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 457  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= today->tm_sec * 1000;

  00193	8b 13		 mov	 edx, DWORD PTR [ebx]
  00195	69 d2 18 fc ff
	ff		 imul	 edx, -1000		; fffffc18H
  0019b	01 97 ac 03 00
	00		 add	 DWORD PTR [edi+940], edx
  001a1	8b bf ac 03 00
	00		 mov	 edi, DWORD PTR [edi+940]

; 458  : 
; 459  : 	LogAddTD("[Blood Castle] (%d) Sync Open Time. [%d] min remain", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000);

  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  001aa	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  001af	f7 ef		 imul	 edi
  001b1	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  001b4	8b c2		 mov	 eax, edx
  001b6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001b9	03 c2		 add	 eax, edx
  001bb	50		 push	 eax
  001bc	41		 inc	 ecx
  001bd	51		 push	 ecx
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Ti@
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	5b		 pop	 ebx
  001cd	5f		 pop	 edi
$LN18@CheckSync:
  001ce	5e		 pop	 esi

; 460  : }

  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 04 00	 ret	 4
?CheckSync@CBloodCastle@@IAEXH@Z ENDP			; CBloodCastle::CheckSync
_TEXT	ENDS
PUBLIC	??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
PUBLIC	?SetState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Closed
;	COMDAT ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
CONST	SEGMENT
??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Blood Castle] (%d) SetState CLOSED', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv164 = -4						; size = 4
_n$218855 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Closed, COMDAT
; _this$ = ecx

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 875  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	0f 88 c3 00 00
	00		 js	 $LN6@SetState_C
  00013	33 c0		 xor	 eax, eax
  00015	83 ff 07	 cmp	 edi, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 b3 00 00
	00		 je	 $LN6@SetState_C

; 876  : 	{
; 877  : 		return;
; 878  : 	}
; 879  : 
; 880  : 	this->SendNoticeState(iBridgeIndex, 2);

  00023	53		 push	 ebx
  00024	6a 02		 push	 2
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 881  : 	this->ClearBridgeData(iBridgeIndex);

  0002c	57		 push	 edi
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 882  : 	this->ClearMonster(iBridgeIndex, 1);

  00034	6a 01		 push	 1
  00036	57		 push	 edi
  00037	8b ce		 mov	 ecx, esi
  00039	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 883  : 	this->CheckAngelKingExist(iBridgeIndex);

  0003e	57		 push	 edi
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckAngelKingExist

; 886  : 	{
; 887  : 		int iMapNumber = this->GetBridgeMapNumber(iBridgeIndex); //season3 add-on

  00046	57		 push	 edi
  00047	8b ce		 mov	 ecx, esi
  00049	c7 45 08 b0 36
	00 00		 mov	 DWORD PTR _n$218855[ebp], 14000 ; 000036b0H
  00050	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber
  00055	89 45 fc	 mov	 DWORD PTR tv164[ebp], eax
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	bb 00 a7 40 09	 mov	 ebx, 155232000		; 0940a700H
$LL13@SetState_C:

; 888  : 
; 889  : 		if ( gObj[n].MapNumber == iMapNumber && gObj[n].Connected > PLAYER_LOGGED ) //season3 changed

  00062	0f b6 8c 03 49
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+329]
  0006a	3b 4d fc	 cmp	 ecx, DWORD PTR tv164[ebp]
  0006d	75 25		 jne	 SHORT $LN3@SetState_C
  0006f	83 7c 03 04 02	 cmp	 DWORD PTR [ebx+eax+4], 2
  00074	7e 1e		 jle	 SHORT $LN3@SetState_C

; 890  : 		{
; 891  : 			this->SearchUserDeleteQuestItem(n);

  00076	8b 55 08	 mov	 edx, DWORD PTR _n$218855[ebp]
  00079	52		 push	 edx
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 892  : 			gObjMoveGate(n, 22);

  00081	8b 45 08	 mov	 eax, DWORD PTR _n$218855[ebp]
  00084	6a 16		 push	 22			; 00000016H
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00091	83 c4 08	 add	 esp, 8
$LN3@SetState_C:

; 884  : 
; 885  : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00094	ff 45 08	 inc	 DWORD PTR _n$218855[ebp]
  00097	81 c3 50 2b 00
	00		 add	 ebx, 11088		; 00002b50H
  0009d	81 fb 80 d7 e9
	09		 cmp	 ebx, 166320000		; 09e9d780H
  000a3	7c bd		 jl	 SHORT $LL13@SetState_C

; 893  : 		}
; 894  : 	}
; 895  : 
; 896  : 	this->BlockCastleDoor(iBridgeIndex);

  000a5	57		 push	 edi
  000a6	8b ce		 mov	 ecx, esi
  000a8	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor

; 897  : 	this->BlockCastleBridge(iBridgeIndex);

  000ad	57		 push	 edi
  000ae	8b ce		 mov	 ecx, esi
  000b0	e8 00 00 00 00	 call	 ?BlockCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleBridge

; 898  : 	this->BlockCastleEntrance(iBridgeIndex);

  000b5	57		 push	 edi
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleEntrance

; 899  : 	this->CheckSync(iBridgeIndex);

  000bd	57		 push	 edi
  000be	8b ce		 mov	 ecx, esi
  000c0	e8 00 00 00 00	 call	 ?CheckSync@CBloodCastle@@IAEXH@Z ; CBloodCastle::CheckSync

; 900  : 	LogAddTD("[Blood Castle] (%d) SetState CLOSED", iBridgeIndex+1);

  000c5	47		 inc	 edi
  000c6	57		 push	 edi
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d2	83 c4 08	 add	 esp, 8
  000d5	5b		 pop	 ebx
$LN6@SetState_C:
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi

; 901  : }

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 04 00	 ret	 4
?SetState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Closed
_TEXT	ENDS
PUBLIC	?GetRemainTime@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetRemainTime
; Function compile flags: /Ogtp
;	COMDAT ?GetRemainTime@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_ltime$219159 = -36					; size = 8
_WebzenVar1$219153 = -28				; size = 8
_today$219158 = -20					; size = 4
tv632 = -16						; size = 4
_this$ = -12						; size = 4
tv630 = -8						; size = 4
_CurrentTime$219157 = -4				; size = 4
tv611 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetRemainTime@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetRemainTime, COMDAT
; _this$ = ecx

; 1531 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1532 : 	int iREMAIN_MINUTE = 0;
; 1533 : 
; 1534 : 	if ( this->GetCurrentState(iBridgeIndex) == 1 )

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	89 75 f4	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00016	83 f8 01	 cmp	 eax, 1
  00019	75 2d		 jne	 SHORT $LN17@GetRemainT

; 1535 : 	{
; 1536 : 		iREMAIN_MINUTE = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000 - this->m_iBC_TIME_MIN_OPEN + 1;

  0001b	69 ff 60 04 00
	00		 imul	 edi, 1120		; 00000460H
  00021	8b bc 37 ac 03
	00 00		 mov	 edi, DWORD PTR [edi+esi+940]
  00028	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0002d	f7 ef		 imul	 edi
  0002f	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00032	8b c2		 mov	 eax, edx
  00034	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00037	03 c2		 add	 eax, edx
  00039	2b 86 08 23 00
	00		 sub	 eax, DWORD PTR [esi+8968]
  0003f	5f		 pop	 edi
  00040	40		 inc	 eax
  00041	5e		 pop	 esi

; 1621 : 	}
; 1622 : 
; 1623 : 	return iREMAIN_MINUTE;
; 1624 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN17@GetRemainT:

; 1537 : 	}
; 1538 : 	else
; 1539 : 	{
; 1540 : 		std::list<BLOODCASTLE_START_TIME>::iterator it; //loc3 -> ebp C
; 1541 : 		BLOODCASTLE_START_TIME WebzenVar1; //loc 4-5 -> ebp 14
; 1542 : 		BLOODCASTLE_START_TIME WebzenVar2; //loc 6-7 -> epb 18
; 1543 : 		int BaseTime = 0; // loc8 -> ebp 1C
; 1544 : 		int CheckTime = 0; // loc9 -> ebp 20
; 1545 : 		DWORD CurrentTime = 0;	// loc10-> ebp 24
; 1546 : 		
; 1547 : 		tm * today; //loc11 -> ebp 28
; 1548 : 		time_t ltime; //loc12 -> ebp 2C
; 1549 : 
; 1550 : 		int loc13; //ebp 34
; 1551 : 		int loc14; //ebp 38
; 1552 : 
; 1553 : 		time(&ltime); //

  00048	8d 4d dc	 lea	 ecx, DWORD PTR _ltime$219159[ebp]
  0004b	53		 push	 ebx
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 __time64

; 1554 : 		today = localtime(&ltime); //

  00052	8d 55 dc	 lea	 edx, DWORD PTR _ltime$219159[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 __localtime64

; 1555 : 		
; 1556 : 		CurrentTime = (today->tm_hour * 60) + today->tm_min;
; 1557 : 		WebzenVar1 = *this->m_listBloodCastleOpenTime.begin();

  0005b	8b 9e 20 23 00
	00		 mov	 ebx, DWORD PTR [esi+8992]
  00061	8b c8		 mov	 ecx, eax
  00063	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00066	8b d0		 mov	 edx, eax
  00068	c1 e2 04	 shl	 edx, 4
  0006b	2b d0		 sub	 edx, eax
  0006d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00070	89 4d ec	 mov	 DWORD PTR _today$219158[ebp], ecx
  00073	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00076	89 4d fc	 mov	 DWORD PTR _CurrentTime$219157[ebp], ecx
  00079	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0007b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0007e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00081	89 45 e8	 mov	 DWORD PTR _WebzenVar1$219153[ebp+4], eax

; 1558 : 
; 1559 : 		for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it ) //for identical

  00084	8b c1		 mov	 eax, ecx
  00086	83 c4 08	 add	 esp, 8
  00089	89 5d f8	 mov	 DWORD PTR tv630[ebp], ebx
  0008c	89 4d f0	 mov	 DWORD PTR tv632[ebp], ecx
  0008f	3b c3		 cmp	 eax, ebx
  00091	74 32		 je	 SHORT $LN164@GetRemainT
$LL62@GetRemainT:

; 1560 : 		{
; 1561 : 			WebzenVar2 = *it; // loc5-6

  00093	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1562 : 			BaseTime = (WebzenVar1.m_iHour * 60) + WebzenVar1.m_iMinute;

  00096	8b 5d e8	 mov	 ebx, DWORD PTR _WebzenVar1$219153[ebp+4]
  00099	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0009c	8b f2		 mov	 esi, edx
  0009e	c1 e6 04	 shl	 esi, 4
  000a1	2b f2		 sub	 esi, edx
  000a3	8d 34 b3	 lea	 esi, DWORD PTR [ebx+esi*4]

; 1563 : 			CheckTime =	(WebzenVar2.m_iHour * 60) + WebzenVar2.m_iMinute;

  000a6	8b d9		 mov	 ebx, ecx
  000a8	c1 e3 04	 shl	 ebx, 4
  000ab	2b d9		 sub	 ebx, ecx
  000ad	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 1564 : 
; 1565 : 			if( BaseTime == CheckTime )

  000b0	3b f1		 cmp	 esi, ecx
  000b2	75 66		 jne	 SHORT $LN12@GetRemainT

; 1566 : 			{
; 1567 : 				if( CurrentTime < CheckTime )

  000b4	39 4d fc	 cmp	 DWORD PTR _CurrentTime$219157[ebp], ecx
  000b7	73 74		 jae	 SHORT $LN14@GetRemainT
$LN162@GetRemainT:

; 1558 : 
; 1559 : 		for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it ) //for identical

  000b9	8b 5d f8	 mov	 ebx, DWORD PTR tv630[ebp]
$LN163@GetRemainT:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv632[ebp]
  000bf	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  000c2	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
$LN164@GetRemainT:

; 1582 : 			}
; 1583 : 		}
; 1584 : 
; 1585 : 		for(loc13 = 2;loc13--;) //good ->func identical so far

  000c5	69 ff 60 04 00
	00		 imul	 edi, 1120		; 00000460H
  000cb	8d bc 37 ac 03
	00 00		 lea	 edi, DWORD PTR [edi+esi+940]
  000d2	8b b6 08 23 00
	00		 mov	 esi, DWORD PTR [esi+8968]

; 1606 : 			{
; 1607 : 				it++;

  000d8	89 7d 08	 mov	 DWORD PTR tv611[ebp], edi
  000db	69 f6 60 ea 00
	00		 imul	 esi, 60000		; 0000ea60H
  000e1	8b 3f		 mov	 edi, DWORD PTR [edi]
  000e3	ba 02 00 00 00	 mov	 edx, 2
$LL8@GetRemainT:

; 1586 : 		{
; 1587 : 			if(it == this->m_listBloodCastleOpenTime.end())

  000e8	4a		 dec	 edx
  000e9	3b c3		 cmp	 eax, ebx
  000eb	75 02		 jne	 SHORT $LN6@GetRemainT

; 1588 : 			{
; 1589 : 				it = this->m_listBloodCastleOpenTime.begin();

  000ed	8b c1		 mov	 eax, ecx
$LN6@GetRemainT:

; 1590 : 
; 1591 : 				WebzenVar2 = (*it);
; 1592 : 			}
; 1593 : 
; 1594 : 			CheckTime = WebzenVar2.m_iHour*60+WebzenVar2.m_iMinute;
; 1595 : 
; 1596 : 			if(today->tm_hour <= WebzenVar2.m_iHour && CheckTime > CurrentTime)
; 1597 : 			{
; 1598 : 				iREMAIN_MINUTE = ((CheckTime - CurrentTime)*60)*1000;
; 1599 : 			}
; 1600 : 			else
; 1601 : 			{
; 1602 : 				iREMAIN_MINUTE = ((1440-CurrentTime+CheckTime)*60)*1000;
; 1603 : 			}
; 1604 : 
; 1605 : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 )) //should be if ( iREMAIN_MINUTE <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ))

  000ef	3b fe		 cmp	 edi, esi
  000f1	7f 06		 jg	 SHORT $LN3@GetRemainT

; 1606 : 			{
; 1607 : 				it++;

  000f3	8b 00		 mov	 eax, DWORD PTR [eax]
  000f5	85 d2		 test	 edx, edx
  000f7	75 ef		 jne	 SHORT $LL8@GetRemainT
$LN3@GetRemainT:

; 1608 : 
; 1609 : 				if(it != this->m_listBloodCastleOpenTime.end())
; 1610 : 				{
; 1611 : 					WebzenVar2 = (*it);
; 1612 : 				}
; 1613 : 			}
; 1614 : 			else
; 1615 : 			{
; 1616 : 				break;
; 1617 : 			}
; 1618 : 		}
; 1619 : 		loc14 = GetTickCount();

  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1620 : 		iREMAIN_MINUTE = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC - today->tm_sec * 1000;

  000ff	8b 55 ec	 mov	 edx, DWORD PTR _today$219158[ebp]
  00102	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00104	8b 55 08	 mov	 edx, DWORD PTR tv611[ebp]
  00107	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  0010d	8b 02		 mov	 eax, DWORD PTR [edx]
  0010f	5b		 pop	 ebx
  00110	5f		 pop	 edi
  00111	2b c1		 sub	 eax, ecx
  00113	5e		 pop	 esi

; 1621 : 	}
; 1622 : 
; 1623 : 	return iREMAIN_MINUTE;
; 1624 : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 04 00	 ret	 4
$LN12@GetRemainT:

; 1568 : 				{
; 1569 : 					WebzenVar2 = *it;
; 1570 : 					break;
; 1571 : 				}
; 1572 : 				continue;
; 1573 : 			}
; 1574 : 			
; 1575 : 			if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  0011a	8b 55 fc	 mov	 edx, DWORD PTR _CurrentTime$219157[ebp]
  0011d	3b d6		 cmp	 edx, esi
  0011f	72 04		 jb	 SHORT $LN10@GetRemainT
  00121	3b d1		 cmp	 edx, ecx
  00123	72 94		 jb	 SHORT $LN162@GetRemainT
$LN10@GetRemainT:

; 1576 : 			{
; 1577 : 				break;
; 1578 : 			}
; 1579 : 			else
; 1580 : 			{
; 1581 : 				WebzenVar1 = *it;

  00125	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00128	8b cf		 mov	 ecx, edi
  0012a	89 4d e8	 mov	 DWORD PTR _WebzenVar1$219153[ebp+4], ecx
$LN14@GetRemainT:

; 1558 : 
; 1559 : 		for( it = this->m_listBloodCastleOpenTime.begin(); it != this->m_listBloodCastleOpenTime.end(); ++it ) //for identical

  0012d	8b 00		 mov	 eax, DWORD PTR [eax]
  0012f	8b 5d f8	 mov	 ebx, DWORD PTR tv630[ebp]
  00132	3b c3		 cmp	 eax, ebx
  00134	0f 85 59 ff ff
	ff		 jne	 $LL62@GetRemainT
  0013a	eb 80		 jmp	 SHORT $LN163@GetRemainT
?GetRemainTime@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetRemainTime
_TEXT	ENDS
PUBLIC	??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 769  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 770  : 		_Tidy();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]
  00007	89 09		 mov	 DWORD PTR [ecx], ecx
  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	74 19		 je	 SHORT $LN6@list@2
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL8@list@2:
  00020	8b 38		 mov	 edi, DWORD PTR [eax]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c7		 mov	 eax, edi
  0002d	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0002f	75 ef		 jne	 SHORT $LL8@list@2
  00031	5f		 pop	 edi
$LN6@list@2:

; 771  : 		}

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4
  0003d	5e		 pop	 esi
  0003e	c3		 ret	 0
??1?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::~list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z PROC ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 926  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 927  : 		_Insert(end(), _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00021	2b d1		 sub	 edx, ecx
  00023	83 fa 01	 cmp	 edx, 1
  00026	73 0a		 jae	 SHORT $LN19@push_back
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@push_back:
$LN19@push_back:
  00032	41		 inc	 ecx
  00033	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00036	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	5f		 pop	 edi
  0003d	89 01		 mov	 DWORD PTR [ecx], eax
  0003f	5e		 pop	 esi

; 928  : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN36@push_back:
?push_back@?$list@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEXABUBLOODCASTLE_START_TIME@@@Z ENDP ; std::list<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	??_7CBloodCastle@@6B@				; CBloodCastle::`vftable'
PUBLIC	??0CBloodCastle@@QAE@XZ				; CBloodCastle::CBloodCastle
PUBLIC	??_R4CBloodCastle@@6B@				; CBloodCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBloodCastle@@@8			; CBloodCastle `RTTI Type Descriptor'
PUBLIC	??_R3CBloodCastle@@8				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBloodCastle@@8				; CBloodCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBloodCastle@@8			; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	??_ECBloodCastle@@UAEPAXI@Z:PROC		; CBloodCastle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CBloodCastle@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBloodCastle@@8 DD FLAT:??_R0?AVCBloodCastle@@@8 ; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CBloodCastle@@8
rdata$r	SEGMENT
??_R2CBloodCastle@@8 DD FLAT:??_R1A@?0A@EA@CBloodCastle@@8 ; CBloodCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBloodCastle@@8
rdata$r	SEGMENT
??_R3CBloodCastle@@8 DD 00H				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBloodCastle@@@8
_DATA	SEGMENT
??_R0?AVCBloodCastle@@@8 DD FLAT:??_7type_info@@6B@	; CBloodCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBloodCastle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CBloodCastle@@6B@
rdata$r	SEGMENT
??_R4CBloodCastle@@6B@ DD 00H				; CBloodCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBloodCastle@@@8
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_7CBloodCastle@@6B@
CONST	SEGMENT
??_7CBloodCastle@@6B@ DD FLAT:??_R4CBloodCastle@@6B@	; CBloodCastle::`vftable'
	DD	FLAT:??_ECBloodCastle@@UAEPAXI@Z
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
CONST	ENDS
;	COMDAT ??0CBloodCastle@@QAE@XZ
_TEXT	SEGMENT
$T224174 = -16						; size = 12
$T224085 = -4						; size = 4
??0CBloodCastle@@QAE@XZ PROC				; CBloodCastle::CBloodCastle, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CBloodCastle@@6B@
  00011	33 ff		 xor	 edi, edi
  00013	6a 10		 push	 16			; 00000010H
  00015	89 bb 24 23 00
	00		 mov	 DWORD PTR [ebx+8996], edi
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	3b c7		 cmp	 eax, edi
  00025	0f 84 9d 00 00
	00		 je	 $LN24@CBloodCast
  0002b	89 83 20 23 00
	00		 mov	 DWORD PTR [ebx+8992], eax
  00031	89 00		 mov	 DWORD PTR [eax], eax
  00033	8b 83 20 23 00
	00		 mov	 eax, DWORD PTR [ebx+8992]
  00039	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 123  : 	this->m_bBC_EVENT_ENABLE = false;

  0003c	c6 83 04 23 00
	00 00		 mov	 BYTE PTR [ebx+8964], 0

; 124  : 	this->m_iBC_TIME_MIN_OPEN = 10;

  00043	c7 83 08 23 00
	00 0a 00 00 00	 mov	 DWORD PTR [ebx+8968], 10 ; 0000000aH

; 125  : 	this->m_iBC_NORMAL_ITEM_DROP = 100;

  0004d	c7 83 14 23 00
	00 64 00 00 00	 mov	 DWORD PTR [ebx+8980], 100 ; 00000064H

; 126  : 	this->m_iBC_EXCEL_ITEM_DROP = 1200;

  00057	c7 83 18 23 00
	00 b0 04 00 00	 mov	 DWORD PTR [ebx+8984], 1200 ; 000004b0H

; 127  : 	this->m_iBC_MONSTER_REGEN = 0;

  00061	89 bb 1c 23 00
	00		 mov	 DWORD PTR [ebx+8988], edi
  00067	8d b3 98 03 00
	00		 lea	 esi, DWORD PTR [ebx+920]
  0006d	8d 49 00	 npad	 3
$LL43@CBloodCast:

; 128  : 
; 129  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )
; 130  : 	{
; 131  : 		this->m_BridgeData[i].m_iBC_STATE = BC_STATE_NONE;
; 132  : 		this->m_BridgeData[i].m_iMapNumber = this->GetBridgeMapNumber(i);

  00070	57		 push	 edi
  00071	8b cb		 mov	 ecx, ebx
  00073	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0007a	e8 00 00 00 00	 call	 ?GetBridgeMapNumber@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeMapNumber

; 133  : 		this->m_BridgeData[i].m_iBridgeIndex = i;
; 134  : 		this->m_BridgeData[i].m_iBC_REMAIN_MSEC = -1;
; 135  : 		this->m_BridgeData[i].m_iBC_TICK_COUNT = -1;
; 136  : 		this->m_BridgeData[i].m_nSaintStatuePosNum = -1;
; 137  : 		this->m_BridgeData[i].m_nCastleDoorPosNum = -1;
; 138  : 		this->m_BridgeData[i].m_iAngelKingPosNum = -1;
; 139  : 		this->m_BridgeData[i].m_iBC_REWARD_EXP = 1.0f; //season 4.5 add-on

  0007f	d9 e8		 fld1
  00081	89 06		 mov	 DWORD PTR [esi], eax
  00083	d9 9e c8 00 00
	00		 fstp	 DWORD PTR [esi+200]
  00089	83 c8 ff	 or	 eax, -1
  0008c	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0008f	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00092	89 46 f4	 mov	 DWORD PTR [esi-12], eax
  00095	89 46 f8	 mov	 DWORD PTR [esi-8], eax
  00098	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 140  : 		InitializeCriticalSection(&this->m_BridgeData[i].m_critUserData);

  0009b	8d 86 6c fc ff
	ff		 lea	 eax, DWORD PTR [esi-916]
  000a1	50		 push	 eax
  000a2	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 141  : 		this->ClearBridgeData(i);

  000ab	57		 push	 edi
  000ac	8b cb		 mov	 ecx, ebx
  000ae	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData
  000b3	47		 inc	 edi
  000b4	81 c6 60 04 00
	00		 add	 esi, 1120		; 00000460H
  000ba	83 ff 08	 cmp	 edi, 8
  000bd	7c b1		 jl	 SHORT $LL43@CBloodCast

; 142  : 	}
; 143  : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	8b c3		 mov	 eax, ebx
  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0

; 122  : {

$LN24@CBloodCast:
  000c8	8d 4d fc	 lea	 ecx, DWORD PTR $T224085[ebp]
  000cb	51		 push	 ecx
  000cc	8d 4d f0	 lea	 ecx, DWORD PTR $T224174[ebp]
  000cf	89 7d fc	 mov	 DWORD PTR $T224085[ebp], edi
  000d2	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000d7	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000dc	8d 55 f0	 lea	 edx, DWORD PTR $T224174[ebp]
  000df	52		 push	 edx
  000e0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T224174[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@CBloodCast:
$LN44@CBloodCast:
  000ec	cc		 int	 3
??0CBloodCastle@@QAE@XZ ENDP				; CBloodCastle::CBloodCastle
_TEXT	ENDS
PUBLIC	??1CBloodCastle@@UAE@XZ				; CBloodCastle::~CBloodCastle
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ??1CBloodCastle@@UAE@XZ
_TEXT	SEGMENT
??1CBloodCastle@@UAE@XZ PROC				; CBloodCastle::~CBloodCastle, COMDAT
; _this$ = ecx

; 146  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi
  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CBloodCastle@@6B@
  0000b	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0000e	bb 08 00 00 00	 mov	 ebx, 8
$LL3@CBloodCast@2:

; 147  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )
; 148  : 	{
; 149  : 		DeleteCriticalSection(&this->m_BridgeData[i].m_critUserData);

  00013	57		 push	 edi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0001a	81 c7 60 04 00
	00		 add	 edi, 1120		; 00000460H
  00020	4b		 dec	 ebx
  00021	75 f0		 jne	 SHORT $LL3@CBloodCast@2

; 150  : 	}
; 151  : }

  00023	8b 8e 20 23 00
	00		 mov	 ecx, DWORD PTR [esi+8992]
  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	89 09		 mov	 DWORD PTR [ecx], ecx
  0002d	8b 8e 20 23 00
	00		 mov	 ecx, DWORD PTR [esi+8992]
  00033	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00036	89 9e 24 23 00
	00		 mov	 DWORD PTR [esi+8996], ebx
  0003c	3b 86 20 23 00
	00		 cmp	 eax, DWORD PTR [esi+8992]
  00042	74 15		 je	 SHORT $LN11@CBloodCast@2
$LL13@CBloodCast@2:
  00044	8b 38		 mov	 edi, DWORD PTR [eax]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
  0004f	8b c7		 mov	 eax, edi
  00051	3b be 20 23 00
	00		 cmp	 edi, DWORD PTR [esi+8992]
  00057	75 eb		 jne	 SHORT $LL13@CBloodCast@2
$LN11@CBloodCast@2:
  00059	8b 86 20 23 00
	00		 mov	 eax, DWORD PTR [esi+8992]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00065	83 c4 04	 add	 esp, 4
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	c3		 ret	 0
??1CBloodCastle@@UAE@XZ ENDP				; CBloodCastle::~CBloodCastle
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CBloodCastle@@QAEXPAD@Z			; CBloodCastle::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@ DB '[Bloo'
	DB	'd Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodcastle.cpp
CONST	ENDS
;	COMDAT ?Load@CBloodCastle@@QAEXPAD@Z
_TEXT	SEGMENT
_Schedule$218495 = -12					; size = 8
_type$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CBloodCastle@@QAEXPAD@Z PROC			; CBloodCastle::Load, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 217  : 	int Token;
; 218  : 	int type;
; 219  : 	int BridgeCount;
; 220  : 	int iBridgeNum;
; 221  : 	SMDFile=fopen(filename, "r");

  00008	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00010	56		 push	 esi
  00011	8b d9		 mov	 ebx, ecx
  00013	e8 00 00 00 00	 call	 _fopen
  00018	83 c4 08	 add	 esp, 8
  0001b	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 222  : 
; 223  : 	if (SMDFile == 0)

  00020	85 c0		 test	 eax, eax
  00022	75 16		 jne	 SHORT $LN24@Load

; 224  : 	{
; 225  : 		MsgBox("[Blood Castle] Info file Load Fail [%s]", filename);

  00024	56		 push	 esi
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@
  0002a	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002f	83 c4 08	 add	 esp, 8
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 349  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN24@Load:

; 226  : 		return;
; 227  : 	}
; 228  : 
; 229  : 	type=-1;
; 230  : 	BridgeCount=-1;
; 231  : 
; 232  : 	while ( true )
; 233  : 	{
; 234  : 		Token=GetToken();

  0003a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 235  : 
; 236  : 		if ( Token == 2 )

  0003f	83 f8 02	 cmp	 eax, 2
  00042	0f 84 f7 02 00
	00		 je	 $LN77@Load
  00048	57		 push	 edi
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL23@Load:

; 237  : 		{
; 238  : 			break;
; 239  : 		}
; 240  : 
; 241  : 		type=(int)TokenNumber;

  00050	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00056	e8 00 00 00 00	 call	 __ftol2_sse
  0005b	8b f8		 mov	 edi, eax
  0005d	89 7d fc	 mov	 DWORD PTR _type$[ebp], edi
$LL20@Load:

; 242  : 
; 243  : 		while ( true )
; 244  : 		{
; 245  : 			if ( type == 0 )

  00060	85 ff		 test	 edi, edi
  00062	75 7b		 jne	 SHORT $LN18@Load

; 246  : 			{
; 247  : 				Token=GetToken();

  00064	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 248  : 
; 249  : 				if (strcmp("end", &TokenString[0]) == 0)

  00069	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0006e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL78@Load:
  00073	8a 10		 mov	 dl, BYTE PTR [eax]
  00075	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00077	75 1a		 jne	 SHORT $LN79@Load
  00079	84 d2		 test	 dl, dl
  0007b	74 12		 je	 SHORT $LN80@Load
  0007d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00080	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00083	75 0e		 jne	 SHORT $LN79@Load
  00085	83 c0 02	 add	 eax, 2
  00088	83 c1 02	 add	 ecx, 2
  0008b	84 d2		 test	 dl, dl
  0008d	75 e4		 jne	 SHORT $LL78@Load
$LN80@Load:
  0008f	33 c0		 xor	 eax, eax
  00091	eb 05		 jmp	 SHORT $LN81@Load
$LN79@Load:
  00093	1b c0		 sbb	 eax, eax
  00095	83 d8 ff	 sbb	 eax, -1
$LN81@Load:
  00098	85 c0		 test	 eax, eax
  0009a	0f 84 8d 02 00
	00		 je	 $LN98@Load

; 250  : 				{
; 251  : 					break;
; 252  : 				}
; 253  : 
; 254  : 				this->m_iBC_TIME_MIN_OPEN = (int)TokenNumber;

  000a0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000a6	e8 00 00 00 00	 call	 __ftol2_sse
  000ab	89 83 08 23 00
	00		 mov	 DWORD PTR [ebx+8968], eax

; 255  : 
; 256  : 				Token = GetToken();

  000b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 257  : 				this->m_iBC_TIME_MIN_PLAY =(int)TokenNumber;

  000b6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000bc	e8 00 00 00 00	 call	 __ftol2_sse
  000c1	89 83 0c 23 00
	00		 mov	 DWORD PTR [ebx+8972], eax

; 258  : 
; 259  : 				Token = GetToken();

  000c7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 260  : 				this->m_iBC_TIME_MIN_REST = (int)TokenNumber;

  000cc	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000d2	e8 00 00 00 00	 call	 __ftol2_sse
  000d7	89 83 10 23 00
	00		 mov	 DWORD PTR [ebx+8976], eax
  000dd	eb 81		 jmp	 SHORT $LL20@Load
$LN18@Load:

; 261  : 			}
; 262  : 			else if ( type == 1 )

  000df	83 ff 01	 cmp	 edi, 1
  000e2	75 7e		 jne	 SHORT $LN15@Load

; 263  : 			{
; 264  : 				Token = GetToken();

  000e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 265  : 
; 266  : 				if (strcmp("end", &TokenString[0]) == 0)

  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  000ee	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL82@Load:
  000f3	8a 10		 mov	 dl, BYTE PTR [eax]
  000f5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f7	75 1a		 jne	 SHORT $LN83@Load
  000f9	84 d2		 test	 dl, dl
  000fb	74 12		 je	 SHORT $LN84@Load
  000fd	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00100	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00103	75 0e		 jne	 SHORT $LN83@Load
  00105	83 c0 02	 add	 eax, 2
  00108	83 c1 02	 add	 ecx, 2
  0010b	84 d2		 test	 dl, dl
  0010d	75 e4		 jne	 SHORT $LL82@Load
$LN84@Load:
  0010f	33 c0		 xor	 eax, eax
  00111	eb 05		 jmp	 SHORT $LN85@Load
$LN83@Load:
  00113	1b c0		 sbb	 eax, eax
  00115	83 d8 ff	 sbb	 eax, -1
$LN85@Load:
  00118	85 c0		 test	 eax, eax
  0011a	0f 84 0d 02 00
	00		 je	 $LN98@Load

; 267  : 				{
; 268  : 					break;
; 269  : 				}
; 270  : 
; 271  : 				this->m_iBC_NORMAL_ITEM_DROP = (int)TokenNumber;

  00120	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00126	e8 00 00 00 00	 call	 __ftol2_sse
  0012b	89 83 14 23 00
	00		 mov	 DWORD PTR [ebx+8980], eax

; 272  : 
; 273  : 				Token = GetToken();

  00131	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 274  : 				this->m_iBC_EXCEL_ITEM_DROP = (int)TokenNumber;

  00136	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0013c	e8 00 00 00 00	 call	 __ftol2_sse
  00141	89 83 18 23 00
	00		 mov	 DWORD PTR [ebx+8984], eax

; 275  : 
; 276  : 				Token = GetToken();

  00147	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 277  : 				this->m_iBC_MONSTER_REGEN = (int)TokenNumber;

  0014c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00152	e8 00 00 00 00	 call	 __ftol2_sse
  00157	89 83 1c 23 00
	00		 mov	 DWORD PTR [ebx+8988], eax
  0015d	e9 fe fe ff ff	 jmp	 $LL20@Load
$LN15@Load:

; 278  : 			}
; 279  : 			else if ( type == 2 )

  00162	83 ff 02	 cmp	 edi, 2
  00165	0f 85 9d 00 00
	00		 jne	 $LN12@Load

; 280  : 			{
; 281  : 				Token = GetToken();

  0016b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 282  : 
; 283  : 				if (strcmp("end", &TokenString[0]) == 0)

  00170	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00175	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0017a	8d 9b 00 00 00
	00		 npad	 6
$LL86@Load:
  00180	8a 10		 mov	 dl, BYTE PTR [eax]
  00182	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00184	75 1a		 jne	 SHORT $LN87@Load
  00186	84 d2		 test	 dl, dl
  00188	74 12		 je	 SHORT $LN88@Load
  0018a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0018d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00190	75 0e		 jne	 SHORT $LN87@Load
  00192	83 c0 02	 add	 eax, 2
  00195	83 c1 02	 add	 ecx, 2
  00198	84 d2		 test	 dl, dl
  0019a	75 e4		 jne	 SHORT $LL86@Load
$LN88@Load:
  0019c	33 c0		 xor	 eax, eax
  0019e	eb 05		 jmp	 SHORT $LN89@Load
$LN87@Load:
  001a0	1b c0		 sbb	 eax, eax
  001a2	83 d8 ff	 sbb	 eax, -1
$LN89@Load:
  001a5	85 c0		 test	 eax, eax
  001a7	0f 84 80 01 00
	00		 je	 $LN98@Load

; 284  : 				{
; 285  : 					break;
; 286  : 				}
; 287  : 			
; 288  : 				iBridgeNum = (int)TokenNumber;

  001ad	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001b3	e8 00 00 00 00	 call	 __ftol2_sse
  001b8	8b f0		 mov	 esi, eax

; 289  : 
; 290  : 				if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  001ba	85 f6		 test	 esi, esi
  001bc	78 3b		 js	 SHORT $LN10@Load
  001be	33 c0		 xor	 eax, eax
  001c0	83 fe 07	 cmp	 esi, 7
  001c3	0f 9e c0	 setle	 al
  001c6	85 c0		 test	 eax, eax
  001c8	74 2f		 je	 SHORT $LN10@Load

; 291  : 				{
; 292  : 					Token = GetToken();

  001ca	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 293  : 					this->m_BridgeData[iBridgeNum].m_iCastleStatueHealth = TokenNumber;

  001cf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d5	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  001db	d9 9c 1e c4 03
	00 00		 fstp	 DWORD PTR [esi+ebx+964]

; 294  : 
; 295  : 					Token = GetToken();

  001e2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 296  : 					this->m_BridgeData[iBridgeNum].m_iCastleDoorHealth = TokenNumber;

  001e7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ed	d9 9c 1e c8 03
	00 00		 fstp	 DWORD PTR [esi+ebx+968]

; 297  : 				}
; 298  : 				else

  001f4	e9 67 fe ff ff	 jmp	 $LL20@Load
$LN10@Load:

; 299  : 				{
; 300  : 					Token = GetToken();

  001f9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
$LN5@Load:

; 301  : 					Token = GetToken();

  001fe	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 302  : 				}

  00203	e9 58 fe ff ff	 jmp	 $LL20@Load
$LN12@Load:

; 303  : 			}
; 304  : 			else if ( type == 3 )

  00208	83 ff 03	 cmp	 edi, 3
  0020b	75 77		 jne	 SHORT $LN7@Load

; 305  : 			{
; 306  : 				Token = GetToken();

  0020d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 307  : 
; 308  : 				if (strcmp("end", &TokenString[0]) == 0)

  00212	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00217	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0021c	8d 64 24 00	 npad	 4
$LL90@Load:
  00220	8a 10		 mov	 dl, BYTE PTR [eax]
  00222	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00224	75 1a		 jne	 SHORT $LN91@Load
  00226	84 d2		 test	 dl, dl
  00228	74 12		 je	 SHORT $LN92@Load
  0022a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0022d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00230	75 0e		 jne	 SHORT $LN91@Load
  00232	83 c0 02	 add	 eax, 2
  00235	83 c1 02	 add	 ecx, 2
  00238	84 d2		 test	 dl, dl
  0023a	75 e4		 jne	 SHORT $LL90@Load
$LN92@Load:
  0023c	33 c0		 xor	 eax, eax
  0023e	eb 05		 jmp	 SHORT $LN93@Load
$LN91@Load:
  00240	1b c0		 sbb	 eax, eax
  00242	83 d8 ff	 sbb	 eax, -1
$LN93@Load:
  00245	85 c0		 test	 eax, eax
  00247	0f 84 e0 00 00
	00		 je	 $LN98@Load

; 309  : 				{
; 310  : 					break;
; 311  : 				}
; 312  : 			
; 313  : 				iBridgeNum = (int)TokenNumber;

  0024d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00253	e8 00 00 00 00	 call	 __ftol2_sse
  00258	8b f0		 mov	 esi, eax

; 314  : 
; 315  : 				if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  0025a	85 f6		 test	 esi, esi
  0025c	78 a0		 js	 SHORT $LN5@Load
  0025e	33 c0		 xor	 eax, eax
  00260	83 fe 07	 cmp	 esi, 7
  00263	0f 9e c0	 setle	 al
  00266	85 c0		 test	 eax, eax
  00268	74 94		 je	 SHORT $LN5@Load

; 316  : 				{
; 317  : 					Token = GetToken();

  0026a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 318  : 					this->m_BridgeData[iBridgeNum].m_iBC_REWARD_EXP = TokenNumber;

  0026f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00275	46		 inc	 esi
  00276	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  0027c	d9 1c 1e	 fstp	 DWORD PTR [esi+ebx]

; 319  : 				}
; 320  : 				else

  0027f	e9 dc fd ff ff	 jmp	 $LL20@Load
$LN7@Load:

; 321  : 				{
; 322  : 					Token = GetToken();
; 323  : 				}
; 324  : 			}
; 325  : 			else if ( type == 4 )

  00284	83 ff 04	 cmp	 edi, 4
  00287	0f 85 d3 fd ff
	ff		 jne	 $LL20@Load

; 326  : 			{
; 327  : 				Token = GetToken();

  0028d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 328  : 
; 329  : 				if (strcmp("end", &TokenString[0]) == 0)

  00292	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00297	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0029c	8d 64 24 00	 npad	 4
$LL94@Load:
  002a0	8a 10		 mov	 dl, BYTE PTR [eax]
  002a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002a4	75 1a		 jne	 SHORT $LN95@Load
  002a6	84 d2		 test	 dl, dl
  002a8	74 12		 je	 SHORT $LN96@Load
  002aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002b0	75 0e		 jne	 SHORT $LN95@Load
  002b2	83 c0 02	 add	 eax, 2
  002b5	83 c1 02	 add	 ecx, 2
  002b8	84 d2		 test	 dl, dl
  002ba	75 e4		 jne	 SHORT $LL94@Load
$LN96@Load:
  002bc	33 c0		 xor	 eax, eax
  002be	eb 05		 jmp	 SHORT $LN97@Load
$LN95@Load:
  002c0	1b c0		 sbb	 eax, eax
  002c2	83 d8 ff	 sbb	 eax, -1
$LN97@Load:
  002c5	85 c0		 test	 eax, eax
  002c7	74 64		 je	 SHORT $LN98@Load

; 330  : 				{
; 331  : 					break;
; 332  : 				}
; 333  : 
; 334  : 				BLOODCASTLE_START_TIME Schedule;
; 335  : 
; 336  : 				Schedule.m_iHour = (int)TokenNumber;

  002c9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002cf	e8 00 00 00 00	 call	 __ftol2_sse
  002d4	89 45 f4	 mov	 DWORD PTR _Schedule$218495[ebp], eax

; 337  : 
; 338  : 				Token = GetToken();

  002d7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 339  : 				Schedule.m_iMinute = (int)TokenNumber;

  002dc	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002e2	e8 00 00 00 00	 call	 __ftol2_sse

; 340  : 
; 341  : 				this->m_listBloodCastleOpenTime.push_back(Schedule);

  002e7	8b bb 20 23 00
	00		 mov	 edi, DWORD PTR [ebx+8992]
  002ed	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  002f0	89 45 f8	 mov	 DWORD PTR _Schedule$218495[ebp+4], eax
  002f3	8d 45 f4	 lea	 eax, DWORD PTR _Schedule$218495[ebp]
  002f6	50		 push	 eax
  002f7	51		 push	 ecx
  002f8	57		 push	 edi
  002f9	8d 8b 20 23 00
	00		 lea	 ecx, DWORD PTR [ebx+8992]
  002ff	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UBLOODCASTLE_START_TIME@@V?$allocator@UBLOODCASTLE_START_TIME@@@std@@@2@PAU342@0ABUBLOODCASTLE_START_TIME@@@Z ; std::_List_val<BLOODCASTLE_START_TIME,std::allocator<BLOODCASTLE_START_TIME> >::_Buynode
  00304	8b 8b 24 23 00
	00		 mov	 ecx, DWORD PTR [ebx+8996]
  0030a	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0030f	2b d1		 sub	 edx, ecx
  00311	83 fa 01	 cmp	 edx, 1
  00314	72 4c		 jb	 SHORT $LN76@Load
  00316	41		 inc	 ecx
  00317	89 8b 24 23 00
	00		 mov	 DWORD PTR [ebx+8996], ecx
  0031d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00320	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 342  : 			}
; 343  : 		}

  00323	8b 7d fc	 mov	 edi, DWORD PTR _type$[ebp]
  00326	89 01		 mov	 DWORD PTR [ecx], eax
  00328	e9 33 fd ff ff	 jmp	 $LL20@Load
$LN98@Load:

; 226  : 		return;
; 227  : 	}
; 228  : 
; 229  : 	type=-1;
; 230  : 	BridgeCount=-1;
; 231  : 
; 232  : 	while ( true )
; 233  : 	{
; 234  : 		Token=GetToken();

  0032d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 235  : 
; 236  : 		if ( Token == 2 )

  00332	83 f8 02	 cmp	 eax, 2
  00335	0f 85 15 fd ff
	ff		 jne	 $LL23@Load
  0033b	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0033e	5f		 pop	 edi
$LN77@Load:

; 344  : 	}
; 345  : 
; 346  : 	fclose(SMDFile);

  0033f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  00345	52		 push	 edx
  00346	e8 00 00 00 00	 call	 _fclose

; 347  : 
; 348  : 	LogAdd("%s file load!", filename);

  0034b	56		 push	 esi
  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035a	5e		 pop	 esi
  0035b	5b		 pop	 ebx

; 349  : }

  0035c	8b e5		 mov	 esp, ebp
  0035e	5d		 pop	 ebp
  0035f	c2 04 00	 ret	 4
$LN76@Load:

; 340  : 
; 341  : 				this->m_listBloodCastleOpenTime.push_back(Schedule);

  00362	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00367	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN100@Load:
$LN99@Load:
  0036c	cc		 int	 3
?Load@CBloodCastle@@QAEXPAD@Z ENDP			; CBloodCastle::Load
_TEXT	ENDS
PUBLIC	?SetState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetState
; Function compile flags: /Ogtp
;	COMDAT ?SetState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iBC_STATE$ = 12					; size = 4
?SetState@CBloodCastle@@QAEXHH@Z PROC			; CBloodCastle::SetState, COMDAT
; _this$ = ecx

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 532  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 55		 js	 SHORT $LN7@SetState
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 49		 je	 SHORT $LN7@SetState

; 533  : 	{
; 534  : 		return;
; 535  : 	}
; 536  : 
; 537  : 	if ( iBC_STATE < BC_STATE_NONE || iBC_STATE > BC_STATE_PLAYEND )

  00016	8b 55 0c	 mov	 edx, DWORD PTR _iBC_STATE$[ebp]
  00019	83 fa 03	 cmp	 edx, 3
  0001c	77 41		 ja	 SHORT $LN7@SetState

; 538  : 	{
; 539  : 		return;
; 540  : 	}
; 541  : 
; 542  : 	this->m_BridgeData[iBridgeIndex].m_iBC_STATE = iBC_STATE;

  0001e	56		 push	 esi
  0001f	8b f0		 mov	 esi, eax
  00021	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00027	89 94 0e a8 03
	00 00		 mov	 DWORD PTR [esi+ecx+936], edx
  0002e	5e		 pop	 esi

; 543  : 
; 544  : 	switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  0002f	83 fa 03	 cmp	 edx, 3
  00032	77 2b		 ja	 SHORT $LN7@SetState
  00034	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@SetState[edx*4]
$LN4@SetState:

; 545  : 	{
; 546  : 		case BC_STATE_NONE:
; 547  : 			this->SetState_None(iBridgeIndex);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?SetState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_None

; 560  : 			break;
; 561  : 	}
; 562  : }

  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
$LN3@SetState:

; 548  : 			break;
; 549  : 
; 550  : 		case BC_STATE_CLOSED:
; 551  : 			this->SetState_Closed(iBridgeIndex);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?SetState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Closed

; 560  : 			break;
; 561  : 	}
; 562  : }

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN2@SetState:

; 552  : 			break;
; 553  : 
; 554  : 		case BC_STATE_PLAYING:
; 555  : 			this->SetState_Playing(iBridgeIndex);

  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?SetState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Playing

; 560  : 			break;
; 561  : 	}
; 562  : }

  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
$LN1@SetState:

; 556  : 			break;
; 557  : 
; 558  : 		case BC_STATE_PLAYEND:
; 559  : 			this->SetState_PlayEnd(iBridgeIndex);

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_PlayEnd
$LN7@SetState:

; 560  : 			break;
; 561  : 	}
; 562  : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
  00063	90		 npad	 1
$LN14@SetState:
  00064	00 00 00 00	 DD	 $LN4@SetState
  00068	00 00 00 00	 DD	 $LN3@SetState
  0006c	00 00 00 00	 DD	 $LN2@SetState
  00070	00 00 00 00	 DD	 $LN1@SetState
?SetState@CBloodCastle@@QAEXHH@Z ENDP			; CBloodCastle::SetState
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	_iBridgeIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_Closed
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -288					; size = 4
_pMsg$218767 = -284					; size = 4
_iBridgeIndex$GSCopy$ = -280				; size = 4
_pNotice$218763 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Closed, COMDAT
; _this$ = ecx

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]

; 641  : 
; 642  : 					for (int i= OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00016	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], eax
  0001c	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0002a	8b d9		 mov	 ebx, ecx
  0002c	57		 push	 edi
  0002d	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  00033	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00036	ff d6		 call	 esi
  00038	2b 87 b0 03 00
	00		 sub	 eax, DWORD PTR [edi+944]
  0003e	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00043	0f 8c 95 01 00
	00		 jl	 $LN35@ProcState_

; 603  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;
; 604  : 
; 605  : 	if ( iTICK_MSEC >= 1000 )
; 606  : 	{
; 607  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;
; 608  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00049	29 87 ac 03 00
	00		 sub	 DWORD PTR [edi+940], eax
  0004f	ff d6		 call	 esi
  00051	89 87 b0 03 00
	00		 mov	 DWORD PTR [edi+944], eax

; 609  : 
; 610  : 		if ( g_bBloodCastle != FALSE )

  00057	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  0005e	0f 84 7a 01 00
	00		 je	 $LN35@ProcState_

; 611  : 		{
; 612  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER == false)

  00064	8b 83 08 23 00
	00		 mov	 eax, DWORD PTR [ebx+8968]
  0006a	8b 8f ac 03 00
	00		 mov	 ecx, DWORD PTR [edi+940]
  00070	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00076	3b c8		 cmp	 ecx, eax
  00078	7f 12		 jg	 SHORT $LN14@ProcState_
  0007a	80 bf bb 03 00
	00 00		 cmp	 BYTE PTR [edi+955], 0
  00081	75 09		 jne	 SHORT $LN14@ProcState_

; 613  : 			{
; 614  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = true;

  00083	66 c7 87 bb 03
	00 00 01 01	 mov	 WORD PTR [edi+955], 257	; 00000101H
$LN14@ProcState_:

; 615  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = true;
; 616  : 			}
; 617  : 
; 618  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && (this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000) !=this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT)

  0008c	8b 93 08 23 00
	00		 mov	 edx, DWORD PTR [ebx+8968]
  00092	69 d2 60 ea 00
	00		 imul	 edx, 60000		; 0000ea60H
  00098	3b ca		 cmp	 ecx, edx
  0009a	7f 6b		 jg	 SHORT $LN31@ProcState_
  0009c	85 c9		 test	 ecx, ecx
  0009e	7e 67		 jle	 SHORT $LN31@ProcState_
  000a0	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  000a5	f7 e9		 imul	 ecx
  000a7	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  000aa	8b c2		 mov	 eax, edx
  000ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000af	03 c2		 add	 eax, edx
  000b1	3b 87 b4 03 00
	00		 cmp	 eax, DWORD PTR [edi+948]
  000b7	74 4e		 je	 SHORT $LN31@ProcState_

; 619  : 			{
; 620  : 				this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000;
; 621  : 
; 622  : 				if ( iBridgeIndex == 0 )

  000b9	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], 0
  000c0	89 87 b4 03 00
	00		 mov	 DWORD PTR [edi+948], eax
  000c6	75 3f		 jne	 SHORT $LN31@ProcState_

; 623  : 				{
; 624  : 					PMSG_NOTICE pNotice;
; 625  : 
; 626  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 136)), this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT+1);

  000c8	8b 83 b4 03 00
	00		 mov	 eax, DWORD PTR [ebx+948]
  000ce	40		 inc	 eax
  000cf	50		 push	 eax
  000d0	68 88 04 00 00	 push	 1160			; 00000488H
  000d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000da	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000df	50		 push	 eax
  000e0	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$218763[ebp]
  000e6	6a 00		 push	 0
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 627  : 					this->SendAllUserAnyMsg((LPBYTE)&pNotice, pNotice.h.size);

  000ee	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$218763[ebp+1]
  000f5	83 c4 10	 add	 esp, 16			; 00000010H
  000f8	52		 push	 edx
  000f9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$218763[ebp]
  000ff	50		 push	 eax
  00100	8b cb		 mov	 ecx, ebx
  00102	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ; CBloodCastle::SendAllUserAnyMsg
$LN31@ProcState_:

; 628  : 				}
; 629  : 			}
; 630  : 
; 631  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER == false )

  00107	8b 87 ac 03 00
	00		 mov	 eax, DWORD PTR [edi+940]
  0010d	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00112	0f 8f c6 00 00
	00		 jg	 $LN35@ProcState_
  00118	85 c0		 test	 eax, eax
  0011a	0f 8e be 00 00
	00		 jle	 $LN35@ProcState_
  00120	80 bf bf 03 00
	00 00		 cmp	 BYTE PTR [edi+959], 0
  00127	0f 85 b1 00 00
	00		 jne	 $LN35@ProcState_

; 632  : 			{
; 633  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = true;
; 634  : 
; 635  : 				if ( iBridgeIndex == 0 )

  0012d	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iBridgeIndex$GSCopy$[ebp], 0
  00134	c6 87 bf 03 00
	00 01		 mov	 BYTE PTR [edi+959], 1
  0013b	0f 85 9d 00 00
	00		 jne	 $LN35@ProcState_

; 636  : 				{
; 637  : 					PMSG_SET_DEVILSQUARE pMsg;
; 638  : 
; 639  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00141	6a 04		 push	 4
  00143	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$218767[ebp]
  00149	68 92 00 00 00	 push	 146			; 00000092H
  0014e	51		 push	 ecx
  0014f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00154	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 640  : 					pMsg.Type = 3;

  0015d	c6 85 e7 fe ff
	ff 03		 mov	 BYTE PTR _pMsg$218767[ebp+3], 3

; 641  : 
; 642  : 					for (int i= OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00164	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  00169	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  0016e	8b ff		 npad	 2
$LL9@ProcState_:

; 643  : 					{
; 644  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00170	83 7c 16 04 03	 cmp	 DWORD PTR [esi+edx+4], 3
  00175	75 52		 jne	 SHORT $LN8@ProcState_
  00177	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  0017d	75 4a		 jne	 SHORT $LN8@ProcState_

; 645  : 						{
; 646  : 							if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  0017f	8a 84 16 49 01
	00 00		 mov	 al, BYTE PTR [esi+edx+329]
  00186	3c 34		 cmp	 al, 52			; 00000034H
  00188	74 3f		 je	 SHORT $LN8@ProcState_
  0018a	3c 0b		 cmp	 al, 11			; 0000000bH
  0018c	72 0c		 jb	 SHORT $LN29@ProcState_
  0018e	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00193	3a c8		 cmp	 cl, al
  00195	1b c9		 sbb	 ecx, ecx
  00197	41		 inc	 ecx
  00198	75 2f		 jne	 SHORT $LN8@ProcState_
$LN29@ProcState_:

; 647  : 							{
; 648  : 								if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  0019a	3c 35		 cmp	 al, 53			; 00000035H
  0019c	74 2b		 je	 SHORT $LN8@ProcState_
  0019e	3c 12		 cmp	 al, 18			; 00000012H
  001a0	72 09		 jb	 SHORT $LN30@ProcState_
  001a2	b1 17		 mov	 cl, 23			; 00000017H
  001a4	3a c8		 cmp	 cl, al
  001a6	1b c0		 sbb	 eax, eax
  001a8	40		 inc	 eax
  001a9	75 1e		 jne	 SHORT $LN8@ProcState_
$LN30@ProcState_:

; 649  : 								{
; 650  : 									DataSend(i,(LPBYTE)&pMsg, pMsg.h.size);

  001ab	0f b6 95 e5 fe
	ff ff		 movzx	 edx, BYTE PTR _pMsg$218767[ebp+1]
  001b2	52		 push	 edx
  001b3	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$218767[ebp]
  001b9	50		 push	 eax
  001ba	53		 push	 ebx
  001bb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@ProcState_:

; 641  : 
; 642  : 					for (int i= OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  001c9	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  001cf	43		 inc	 ebx
  001d0	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  001d6	7c 98		 jl	 SHORT $LL9@ProcState_
  001d8	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN35@ProcState_:

; 651  : 								}
; 652  : 							}
; 653  : 						}
; 654  : 					}
; 655  : 				}
; 656  : 			}
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  001de	83 bf ac 03 00
	00 00		 cmp	 DWORD PTR [edi+940], 0
  001e5	7f 24		 jg	 SHORT $LN1@ProcState_

; 661  : 	{
; 662  : 		if ( g_bBloodCastle != FALSE )

  001e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  001ee	74 0b		 je	 SHORT $LN2@ProcState_

; 663  : 		{
; 664  : 			this->SetState(iBridgeIndex, BC_STATE_PLAYING);

  001f0	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iBridgeIndex$GSCopy$[ebp]
  001f6	6a 02		 push	 2
  001f8	51		 push	 ecx

; 665  : 		}
; 666  : 		else

  001f9	eb 09		 jmp	 SHORT $LN37@ProcState_
$LN2@ProcState_:

; 667  : 		{
; 668  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  001fb	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _iBridgeIndex$GSCopy$[ebp]
  00201	6a 01		 push	 1
  00203	52		 push	 edx
$LN37@ProcState_:
  00204	8b cb		 mov	 ecx, ebx
  00206	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_:

; 669  : 		}
; 670  : 	}
; 671  : }

  0020b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	33 cd		 xor	 ecx, ebp
  00212	5b		 pop	 ebx
  00213	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c2 04 00	 ret	 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ ; `string'
PUBLIC	??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ ; `string'
PUBLIC	??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@ ; `string'
PUBLIC	??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@ ; `string'
PUBLIC	??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Playing@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_Playing
;	COMDAT ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Time Out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
CONST	SEGMENT
??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
CONST	SEGMENT
??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == '
	DB	'true', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Every User Ou'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Saint Status [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Castle Door [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@
CONST	SEGMENT
??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@ DB '['
	DB	'Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@
CONST	SEGMENT
??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@ DB '['
	DB	'Blood Castle] (%d) Door Not Subsist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
CONST	SEGMENT
??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ DB '['
	DB	'Blood Castle] (%d) Bridge Change Bridge Attribute -> Open', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProcState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$218805 = -280					; size = 4
_pMsg$218788 = -280					; size = 4
_pNotice$218809 = -276					; size = 272
_pNotice$218800 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Playing, COMDAT
; _this$ = ecx

; 674  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]

; 675  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  00019	8b f7		 mov	 esi, edi
  0001b	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00021	8b d9		 mov	 ebx, ecx
  00023	03 f3		 add	 esi, ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002b	2b 86 b0 03 00
	00		 sub	 eax, DWORD PTR [esi+944]

; 676  : 
; 677  : 	if ( iTICK_MSEC >= 1000 )

  00031	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00036	0f 8c 74 03 00
	00		 jl	 $LN3@ProcState_@2

; 678  : 	{
; 679  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  0003c	29 86 ac 03 00
	00		 sub	 DWORD PTR [esi+940], eax

; 680  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00048	89 86 b0 03 00
	00		 mov	 DWORD PTR [esi+944], eax

; 681  : 
; 682  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-30)*1000) )

  0004e	8b 8b 0c 23 00
	00		 mov	 ecx, DWORD PTR [ebx+8972]
  00054	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  0005a	81 e9 30 75 00
	00		 sub	 ecx, 30000		; 00007530H
  00060	39 8e ac 03 00
	00		 cmp	 DWORD PTR [esi+940], ecx
  00066	7f 3e		 jg	 SHORT $LN20@ProcState_@2

; 683  : 		{
; 684  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY == false )

  00068	80 be c0 03 00
	00 00		 cmp	 BYTE PTR [esi+960], 0
  0006f	75 35		 jne	 SHORT $LN20@ProcState_@2

; 685  : 			{
; 686  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = true;
; 687  : 				
; 688  : 				PMSG_SET_DEVILSQUARE pMsg;
; 689  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00071	6a 04		 push	 4
  00073	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$218788[ebp]
  00079	68 92 00 00 00	 push	 146			; 00000092H
  0007e	52		 push	 edx
  0007f	c6 86 c0 03 00
	00 01		 mov	 BYTE PTR [esi+960], 1
  00086	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 690  : 				pMsg.Type = 4;
; 691  : 				this->SendBridgeAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iBridgeIndex);

  0008e	57		 push	 edi
  0008f	6a 04		 push	 4
  00091	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$218788[ebp]
  00097	50		 push	 eax
  00098	8b cb		 mov	 ecx, ebx
  0009a	c6 85 eb fe ff
	ff 04		 mov	 BYTE PTR _pMsg$218788[ebp+3], 4
  000a1	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN20@ProcState_@2:

; 692  : 			}
; 693  : 		}
; 694  : 
; 695  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE != false	)

  000a6	80 be b8 03 00
	00 00		 cmp	 BYTE PTR [esi+952], 0
  000ad	0f 84 95 00 00
	00		 je	 $LN25@ProcState_@2

; 696  : 		{
; 697  : 			if ( this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN != -1 )

  000b3	83 be d8 03 00
	00 ff		 cmp	 DWORD PTR [esi+984], -1
  000ba	0f 84 88 00 00
	00		 je	 $LN25@ProcState_@2

; 698  : 			{
; 699  : 				if ( GetTickCount() > this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN )

  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000c6	3b 86 d8 03 00
	00		 cmp	 eax, DWORD PTR [esi+984]
  000cc	76 7a		 jbe	 SHORT $LN25@ProcState_@2

; 700  : 				{
; 701  : 					this->ReleaseCastleBridge(iBridgeIndex);

  000ce	57		 push	 edi
  000cf	8b cb		 mov	 ecx, ebx
  000d1	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 702  : 					this->SendCastleBridgeBlockInfo(iBridgeIndex, 0);

  000d6	6a 00		 push	 0
  000d8	57		 push	 edi
  000d9	8b cb		 mov	 ecx, ebx
  000db	e8 00 00 00 00	 call	 ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo

; 703  : 					LogAddTD("[Blood Castle] (%d) Bridge Change Bridge Attribute -> Open", iBridgeIndex+1);

  000e0	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000e3	50		 push	 eax
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 704  : 					this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1; // Prevent multiple openings
; 705  : 
; 706  : 					if(this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX == -1) //season 2.5 add-on

  000ef	8b 86 5c 04 00
	00		 mov	 eax, DWORD PTR [esi+1116]
  000f5	83 c4 08	 add	 esp, 8
  000f8	c7 86 d8 03 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+984], -1
  00102	83 f8 ff	 cmp	 eax, -1
  00105	75 14		 jne	 SHORT $LN16@ProcState_@2

; 707  : 					{
; 708  : 						LogAddTD("[Blood Castle] (%d) Door Not Subsist", iBridgeIndex+1);

  00107	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0010a	50		 push	 eax
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00116	83 c4 08	 add	 esp, 8

; 709  : 					}
; 710  : 					else

  00119	eb 2d		 jmp	 SHORT $LN25@ProcState_@2
$LN16@ProcState_@2:

; 711  : 					{
; 712  : 						LogAddTD("[Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX, gObj[this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX].Name, gObj[this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_MONSTER_INDEX].DieRegen);

  0011b	8b c8		 mov	 ecx, eax
  0011d	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00123	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00129	0f be 91 a2 03
	00 00		 movsx	 edx, BYTE PTR [ecx+930]
  00130	52		 push	 edx
  00131	83 c1 77	 add	 ecx, 119		; 00000077H
  00134	51		 push	 ecx
  00135	50		 push	 eax
  00136	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00145	83 c4 14	 add	 esp, 20			; 00000014H
$LN25@ProcState_@2:

; 713  : 					}
; 714  : 				}
; 715  : 			}
; 716  : 		}
; 717  : 
; 718  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-60)*1000) && this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START == false )

  00148	8b 83 0c 23 00
	00		 mov	 eax, DWORD PTR [ebx+8972]
  0014e	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00154	8d 88 a0 15 ff
	ff		 lea	 ecx, DWORD PTR [eax-60000]
  0015a	39 8e ac 03 00
	00		 cmp	 DWORD PTR [esi+940], ecx
  00160	0f 8f 93 00 00
	00		 jg	 $LN14@ProcState_@2
  00166	80 be bd 03 00
	00 00		 cmp	 BYTE PTR [esi+957], 0
  0016d	0f 85 86 00 00
	00		 jne	 $LN14@ProcState_@2

; 719  : 		{
; 720  : 			PMSG_NOTICE pNotice;
; 721  : 
; 722  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (this->m_iBC_TIME_MIN_PLAY*60)*1000;

  00173	89 86 ac 03 00
	00		 mov	 DWORD PTR [esi+940], eax

; 723  : 			this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;
; 724  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4, 137)), iBridgeIndex+1);

  00179	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0017c	50		 push	 eax
  0017d	68 89 04 00 00	 push	 1161			; 00000489H
  00182	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00187	c6 86 bc 03 00
	00 00		 mov	 BYTE PTR [esi+956], 0
  0018e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00193	50		 push	 eax
  00194	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$218800[ebp]
  0019a	6a 00		 push	 0
  0019c	52		 push	 edx
  0019d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 725  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  001a2	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$218800[ebp+1]
  001a9	83 c4 10	 add	 esp, 16			; 00000010H
  001ac	57		 push	 edi
  001ad	50		 push	 eax
  001ae	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$218800[ebp]
  001b4	51		 push	 ecx
  001b5	8b cb		 mov	 ecx, ebx
  001b7	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 726  : 			this->ReleaseCastleEntrance(iBridgeIndex);

  001bc	57		 push	 edi
  001bd	8b cb		 mov	 ecx, ebx
  001bf	e8 00 00 00 00	 call	 ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleEntrance

; 727  : 			this->SendCastleEntranceBlockInfo(iBridgeIndex, 0);

  001c4	6a 00		 push	 0
  001c6	57		 push	 edi
  001c7	8b cb		 mov	 ecx, ebx
  001c9	e8 00 00 00 00	 call	 ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo

; 728  : 			this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = true;
; 729  : 			this->SetMonster(iBridgeIndex);

  001ce	57		 push	 edi
  001cf	8b cb		 mov	 ecx, ebx
  001d1	c6 86 bd 03 00
	00 01		 mov	 BYTE PTR [esi+957], 1
  001d8	e8 00 00 00 00	 call	 ?SetMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonster

; 730  : 			this->SendNoticeState(iBridgeIndex, false);

  001dd	6a 00		 push	 0
  001df	57		 push	 edi
  001e0	8b cb		 mov	 ecx, ebx
  001e2	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 731  : 
; 732  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Start", iBridgeIndex+1);

  001e7	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  001ea	50		 push	 eax
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001f6	83 c4 08	 add	 esp, 8
$LN14@ProcState_@2:

; 733  : 		}
; 734  : 
; 735  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END == false)	// Set counter to kick

  001f9	8b 86 ac 03 00
	00		 mov	 eax, DWORD PTR [esi+940]
  001ff	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00204	7f 42		 jg	 SHORT $LN13@ProcState_@2
  00206	85 c0		 test	 eax, eax
  00208	7e 3e		 jle	 SHORT $LN13@ProcState_@2
  0020a	80 be c1 03 00
	00 00		 cmp	 BYTE PTR [esi+961], 0
  00211	75 35		 jne	 SHORT $LN13@ProcState_@2

; 736  : 		{
; 737  : 			this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = true;
; 738  : 			PMSG_SET_DEVILSQUARE pMsg;
; 739  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00213	6a 04		 push	 4
  00215	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$218805[ebp]
  0021b	68 92 00 00 00	 push	 146			; 00000092H
  00220	52		 push	 edx
  00221	c6 86 c1 03 00
	00 01		 mov	 BYTE PTR [esi+961], 1
  00228	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 740  : 			pMsg.Type = 5;
; 741  : 			this->SendBridgeAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iBridgeIndex);

  00230	57		 push	 edi
  00231	6a 04		 push	 4
  00233	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$218805[ebp]
  00239	50		 push	 eax
  0023a	8b cb		 mov	 ecx, ebx
  0023c	c6 85 eb fe ff
	ff 05		 mov	 BYTE PTR _pMsg$218805[ebp+3], 5
  00243	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN13@ProcState_@2:

; 742  : 		}
; 743  : 
; 744  : 		if ( this->CheckEveryUserDie(iBridgeIndex) != false )

  00248	57		 push	 edi
  00249	8b cb		 mov	 ecx, ebx
  0024b	e8 00 00 00 00	 call	 ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckEveryUserDie
  00250	84 c0		 test	 al, al
  00252	0f 84 9b 00 00
	00		 je	 $LN12@ProcState_@2

; 745  : 		{
; 746  : 			PMSG_NOTICE pNotice;
; 747  : 
; 748  : 			TNotice::MakeNoticeMsg(&pNotice, 0, lMsg.Get(MSGGET(4, 138)));

  00258	68 8a 04 00 00	 push	 1162			; 0000048aH
  0025d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00262	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00267	50		 push	 eax
  00268	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$218809[ebp]
  0026e	6a 00		 push	 0
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 749  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  00276	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$218809[ebp+1]
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00280	57		 push	 edi
  00281	52		 push	 edx
  00282	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$218809[ebp]
  00288	50		 push	 eax
  00289	8b cb		 mov	 ecx, ebx
  0028b	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 750  : 
; 751  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);

  00290	8d 96 0b 04 00
	00		 lea	 edx, DWORD PTR [esi+1035]
  00296	52		 push	 edx
  00297	8d 86 00 04 00
	00		 lea	 eax, DWORD PTR [esi+1024]
  0029d	50		 push	 eax
  0029e	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  002a1	51		 push	 ecx
  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  002a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 752  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);

  002ad	8d 86 20 04 00
	00		 lea	 eax, DWORD PTR [esi+1056]
  002b3	50		 push	 eax
  002b4	8d 86 00 04 00
	00		 lea	 eax, DWORD PTR [esi+1024]
  002ba	50		 push	 eax
  002bb	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  002be	50		 push	 eax
  002bf	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ca	83 c4 20	 add	 esp, 32			; 00000020H

; 753  : 
; 754  : 			this->GiveReward_Fail(iBridgeIndex);

  002cd	57		 push	 edi
  002ce	8b cb		 mov	 ecx, ebx
  002d0	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 755  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  002d5	6a 01		 push	 1
  002d7	57		 push	 edi
  002d8	8b cb		 mov	 ecx, ebx
  002da	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 756  : 
; 757  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Failed -> Every User Out", iBridgeIndex+1);

  002df	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  002e2	50		 push	 eax
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ee	83 c4 08	 add	 esp, 8

; 758  : 		}
; 759  : 		else

  002f1	eb 29		 jmp	 SHORT $LN7@ProcState_@2
$LN12@ProcState_@2:

; 760  : 		{
; 761  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START != false )

  002f3	80 be bd 03 00
	00 00		 cmp	 BYTE PTR [esi+957], 0
  002fa	74 20		 je	 SHORT $LN7@ProcState_@2

; 762  : 			{
; 763  : 				if ( this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE == false || this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE != false )

  002fc	80 be ba 03 00
	00 00		 cmp	 BYTE PTR [esi+954], 0
  00303	74 0d		 je	 SHORT $LN8@ProcState_@2
  00305	80 be b9 03 00
	00 00		 cmp	 BYTE PTR [esi+953], 0
  0030c	75 04		 jne	 SHORT $LN8@ProcState_@2

; 766  : 				}
; 767  : 				else
; 768  : 				{
; 769  : 					this->SendNoticeState(iBridgeIndex, 4);

  0030e	6a 04		 push	 4
  00310	eb 02		 jmp	 SHORT $LN26@ProcState_@2
$LN8@ProcState_@2:

; 764  : 				{
; 765  : 					this->SendNoticeState(iBridgeIndex, 1);

  00312	6a 01		 push	 1
$LN26@ProcState_@2:
  00314	57		 push	 edi
  00315	8b cb		 mov	 ecx, ebx
  00317	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState
$LN7@ProcState_@2:

; 770  : 				}
; 771  : 			}
; 772  : 		}
; 773  : 
; 774  : 		if ( this->CheckWinnerExist(iBridgeIndex) == true )

  0031c	57		 push	 edi
  0031d	8b cb		 mov	 ecx, ebx
  0031f	e8 00 00 00 00	 call	 ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerExist
  00324	3c 01		 cmp	 al, 1
  00326	0f 85 84 00 00
	00		 jne	 $LN3@ProcState_@2

; 775  : 		{
; 776  : 			if ( this->CheckWinnerValid(iBridgeIndex) == true )

  0032c	57		 push	 edi
  0032d	e8 00 00 00 00	 call	 ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerValid

; 777  : 			{
; 778  : 				if ( this->CheckWinnerPartyComplete(iBridgeIndex) == true )

  00332	57		 push	 edi
  00333	8b cb		 mov	 ecx, ebx
  00335	3c 01		 cmp	 al, 1
  00337	75 45		 jne	 SHORT $LN5@ProcState_@2
  00339	e8 00 00 00 00	 call	 ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
  0033e	3c 01		 cmp	 al, 1
  00340	75 6e		 jne	 SHORT $LN3@ProcState_@2

; 779  : 				{
; 780  : 					this->GiveReward_Win(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX, iBridgeIndex);

  00342	8b 8e 58 04 00
	00		 mov	 ecx, DWORD PTR [esi+1112]
  00348	57		 push	 edi
  00349	51		 push	 ecx
  0034a	8b cb		 mov	 ecx, ebx
  0034c	e8 00 00 00 00	 call	 ?GiveReward_Win@CBloodCastle@@QAEXHH@Z ; CBloodCastle::GiveReward_Win

; 781  : 					this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  00351	6a 03		 push	 3
  00353	57		 push	 edi
  00354	8b cb		 mov	 ecx, ebx
  00356	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 782  : 
; 783  : 					LogAddTD("[Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == true", iBridgeIndex+1);

  0035b	47		 inc	 edi
  0035c	57		 push	 edi
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00368	83 c4 08	 add	 esp, 8
  0036b	5f		 pop	 edi
  0036c	5e		 pop	 esi
  0036d	5b		 pop	 ebx

; 812  : 	}
; 813  : }

  0036e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00371	33 cd		 xor	 ecx, ebp
  00373	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00378	8b e5		 mov	 esp, ebp
  0037a	5d		 pop	 ebp
  0037b	c2 04 00	 ret	 4
$LN5@ProcState_@2:

; 784  : 					return;
; 785  : 				}
; 786  : 			}
; 787  : 			else
; 788  : 			{
; 789  : 				this->GiveReward_Fail(iBridgeIndex);

  0037e	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 790  : 				this->SetState(iBridgeIndex, BC_STATE_PLAYEND); 

  00383	6a 03		 push	 3
  00385	57		 push	 edi
  00386	8b cb		 mov	 ecx, ebx
  00388	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 791  : 
; 792  : 				LogAddTD("[Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false", iBridgeIndex+1);

  0038d	47		 inc	 edi
  0038e	57		 push	 edi
  0038f	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
  00394	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0039a	83 c4 08	 add	 esp, 8
  0039d	5f		 pop	 edi
  0039e	5e		 pop	 esi
  0039f	5b		 pop	 ebx

; 812  : 	}
; 813  : }

  003a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a3	33 cd		 xor	 ecx, ebp
  003a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003aa	8b e5		 mov	 esp, ebp
  003ac	5d		 pop	 ebp
  003ad	c2 04 00	 ret	 4
$LN3@ProcState_@2:

; 793  : 				return;
; 794  : 			}
; 795  : 		}
; 796  : 	}
; 797  : 
; 798  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  003b0	83 be ac 03 00
	00 00		 cmp	 DWORD PTR [esi+940], 0
  003b7	7f 67		 jg	 SHORT $LN2@ProcState_@2

; 799  : 	{
; 800  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED == false )

  003b9	80 be be 03 00
	00 00		 cmp	 BYTE PTR [esi+958], 0
  003c0	75 54		 jne	 SHORT $LN1@ProcState_@2

; 801  : 		{
; 802  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);

  003c2	8d 96 0b 04 00
	00		 lea	 edx, DWORD PTR [esi+1035]
  003c8	52		 push	 edx
  003c9	8d 8e 00 04 00
	00		 lea	 ecx, DWORD PTR [esi+1024]
  003cf	51		 push	 ecx
  003d0	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  003d3	50		 push	 eax
  003d4	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  003d9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 803  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]", iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);

  003df	8d 96 20 04 00
	00		 lea	 edx, DWORD PTR [esi+1056]
  003e5	52		 push	 edx
  003e6	81 c6 2b 04 00
	00		 add	 esi, 1067		; 0000042bH
  003ec	56		 push	 esi
  003ed	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  003f0	56		 push	 esi
  003f1	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  003f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003fc	83 c4 20	 add	 esp, 32			; 00000020H

; 804  : 
; 805  : 			this->GiveReward_Fail(iBridgeIndex);

  003ff	57		 push	 edi
  00400	8b cb		 mov	 ecx, ebx
  00402	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 806  : 
; 807  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Failed -> Time Out", iBridgeIndex+1);

  00407	56		 push	 esi
  00408	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  0040d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00413	83 c4 08	 add	 esp, 8
$LN1@ProcState_@2:

; 808  : 			
; 809  : 		}
; 810  : 
; 811  : 		this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  00416	6a 03		 push	 3
  00418	57		 push	 edi
  00419	8b cb		 mov	 ecx, ebx
  0041b	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN2@ProcState_@2:

; 812  : 	}
; 813  : }

  00420	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00423	5f		 pop	 edi
  00424	5e		 pop	 esi
  00425	33 cd		 xor	 ecx, ebp
  00427	5b		 pop	 ebx
  00428	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0042d	8b e5		 mov	 esp, ebp
  0042f	5d		 pop	 ebp
  00430	c2 04 00	 ret	 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Playing
_TEXT	ENDS
PUBLIC	?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_PlayEnd
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$218835 = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_PlayEnd, COMDAT
; _this$ = ecx

; 816  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 817  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000f	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00015	57		 push	 edi
  00016	8b f9		 mov	 edi, ecx
  00018	03 f7		 add	 esi, edi
  0001a	ff d3		 call	 ebx
  0001c	2b 86 b0 03 00
	00		 sub	 eax, DWORD PTR [esi+944]

; 818  : 
; 819  : 	if ( iTICK_MSEC >= 1000 )

  00022	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00027	7c 57		 jl	 SHORT $LN6@ProcState_@3

; 820  : 	{
; 821  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00029	29 86 ac 03 00
	00		 sub	 DWORD PTR [esi+940], eax

; 822  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0002f	ff d3		 call	 ebx
  00031	89 86 b0 03 00
	00		 mov	 DWORD PTR [esi+944], eax

; 823  : 
; 824  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT == false)

  00037	8b 86 ac 03 00
	00		 mov	 eax, DWORD PTR [esi+940]
  0003d	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00042	7f 3c		 jg	 SHORT $LN6@ProcState_@3
  00044	85 c0		 test	 eax, eax
  00046	7e 38		 jle	 SHORT $LN6@ProcState_@3
  00048	80 be c2 03 00
	00 00		 cmp	 BYTE PTR [esi+962], 0
  0004f	75 2f		 jne	 SHORT $LN6@ProcState_@3

; 825  : 		{
; 826  : 			this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT = true;
; 827  : 
; 828  : 			PMSG_SET_DEVILSQUARE pMsg;
; 829  : 
; 830  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00051	6a 04		 push	 4
  00053	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$218835[ebp]
  00056	68 92 00 00 00	 push	 146			; 00000092H
  0005b	51		 push	 ecx
  0005c	c6 86 c2 03 00
	00 01		 mov	 BYTE PTR [esi+962], 1
  00063	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 831  : 			pMsg.Type = 6;
; 832  : 
; 833  : 			this->SendBridgeAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iBridgeIndex);

  00068	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	52		 push	 edx
  0006f	6a 04		 push	 4
  00071	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$218835[ebp]
  00074	50		 push	 eax
  00075	8b cf		 mov	 ecx, edi
  00077	c6 45 ff 06	 mov	 BYTE PTR _pMsg$218835[ebp+3], 6
  0007b	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN6@ProcState_@3:

; 834  : 		}
; 835  : 
; 836  : 
; 837  : 	}
; 838  : 
; 839  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  00080	83 be ac 03 00
	00 00		 cmp	 DWORD PTR [esi+940], 0
  00087	7f 0d		 jg	 SHORT $LN1@ProcState_@3

; 840  : 	{
; 841  : 		this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  00089	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0008c	6a 01		 push	 1
  0008e	51		 push	 ecx
  0008f	8b cf		 mov	 ecx, edi
  00091	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_@3:
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 842  : 	}
; 843  : }

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 04 00	 ret	 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_PlayEnd
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCBloodCastle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBloodCastle@@UAEPAXI@Z PROC			; CBloodCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCBloodCastle@@UAEPAXI@Z ENDP			; CBloodCastle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Init@CBloodCastle@@QAEX_N@Z			; CBloodCastle::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CBloodCastle@@QAEX_N@Z
_TEXT	SEGMENT
tv539 = 8						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CBloodCastle@@QAEX_N@Z PROC			; CBloodCastle::Init, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 157  : 	this->m_bBC_EVENT_ENABLE = bEVENT_ENABLE;

  00003	8a 45 08	 mov	 al, BYTE PTR _bEVENT_ENABLE$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	88 87 04 23 00
	00		 mov	 BYTE PTR [edi+8964], al
  00010	8d 8f 3c 03 00
	00		 lea	 ecx, DWORD PTR [edi+828]
  00016	be 08 00 00 00	 mov	 esi, 8
  0001b	eb 03 8d 49 00	 npad	 5
$LL22@Init:

; 160  : 	{
; 161  : 		for ( int n=0;n<MAX_BLOOD_CASTLE_BOSS_MONSTER;n++)

  00020	8b c1		 mov	 eax, ecx
  00022	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00027	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL19@Init:

; 162  : 		{
; 163  : 			this->m_BridgeData[i].m_iAngelKingPosNum = -1;

  00030	c7 81 b8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+184], -1

; 164  : 			this->m_BridgeData[i].m_nBossMonsterPosNum[n] = -1;

  0003a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00040	83 c0 04	 add	 eax, 4
  00043	4a		 dec	 edx
  00044	75 ea		 jne	 SHORT $LL19@Init

; 158  : 
; 159  : 	for ( int i=0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  00046	81 c1 60 04 00
	00		 add	 ecx, 1120		; 00000460H
  0004c	4e		 dec	 esi
  0004d	75 d1		 jne	 SHORT $LL22@Init

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	for ( int n =0; n<gMSetBase.m_Count;n++)

  0004f	39 35 84 2c 03
	00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, esi
  00055	0f 8e 1f 01 00
	00		 jle	 $LN14@Init
  0005b	ba 08 00 00 00	 mov	 edx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
  00060	89 55 08	 mov	 DWORD PTR tv539[ebp], edx
  00063	53		 push	 ebx
$LL45@Init:

; 169  : 	{
; 170  : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber ) != FALSE )

  00064	8a 02		 mov	 al, BYTE PTR [edx]
  00066	3c 34		 cmp	 al, 52			; 00000034H
  00068	74 18		 je	 SHORT $LN46@Init
  0006a	3c 0b		 cmp	 al, 11			; 0000000bH
  0006c	0f 82 f1 00 00
	00		 jb	 $LN15@Init
  00072	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00077	3a c8		 cmp	 cl, al
  00079	1b c9		 sbb	 ecx, ecx
  0007b	41		 inc	 ecx
  0007c	0f 84 e1 00 00
	00		 je	 $LN15@Init
$LN46@Init:

; 171  : 		{
; 172  : 			WORD wMonsterType = gMSetBase.m_Mp[n].m_Type; //season3 changed

  00082	0f b7 52 fe	 movzx	 edx, WORD PTR [edx-2]

; 173  : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 174  : 			BYTE btBloodCastleIndex = this->GetBridgeIndex(btMapNumber); //season3 changed

  00086	0f b6 c0	 movzx	 eax, al
  00089	50		 push	 eax
  0008a	8b cf		 mov	 ecx, edi
  0008c	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex

; 175  : 
; 176  : 			if ( wMonsterType == 232 )

  00091	b9 e8 00 00 00	 mov	 ecx, 232		; 000000e8H
  00096	66 3b d1	 cmp	 dx, cx
  00099	75 15		 jne	 SHORT $LN12@Init

; 177  : 			{
; 178  : 				this->m_BridgeData[btBloodCastleIndex].m_iAngelKingPosNum = n;

  0009b	0f b6 d0	 movzx	 edx, al
  0009e	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  000a4	89 b4 3a f4 03
	00 00		 mov	 DWORD PTR [edx+edi+1012], esi

; 179  : 				continue;

  000ab	e9 b3 00 00 00	 jmp	 $LN15@Init
$LN12@Init:

; 180  : 			}
; 181  : 			
; 182  : 			if ( BC_STATUE_RANGE(wMonsterType - 132) != FALSE )

  000b0	8b ca		 mov	 ecx, edx
  000b2	81 c1 7c ff ff
	ff		 add	 ecx, -132		; ffffff7cH
  000b8	78 23		 js	 SHORT $LN43@Init
  000ba	33 db		 xor	 ebx, ebx
  000bc	83 f9 02	 cmp	 ecx, 2
  000bf	0f 9e c3	 setle	 bl
  000c2	8b cb		 mov	 ecx, ebx
  000c4	85 c9		 test	 ecx, ecx
  000c6	74 15		 je	 SHORT $LN43@Init

; 183  : 			{
; 184  : 				this->m_BridgeData[btBloodCastleIndex].m_nSaintStatuePosNum = n;

  000c8	0f b6 c0	 movzx	 eax, al
  000cb	69 c0 60 04 00
	00		 imul	 eax, 1120		; 00000460H
  000d1	89 b4 38 8c 03
	00 00		 mov	 DWORD PTR [eax+edi+908], esi

; 185  : 				continue;

  000d8	e9 86 00 00 00	 jmp	 $LN15@Init
$LN43@Init:

; 186  : 			}
; 187  : 			
; 188  : 			if ( wMonsterType == 131 )

  000dd	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  000e2	66 3b d1	 cmp	 dx, cx
  000e5	75 12		 jne	 SHORT $LN10@Init

; 189  : 			{
; 190  : 				this->m_BridgeData[btBloodCastleIndex].m_nCastleDoorPosNum = n;

  000e7	0f b6 d0	 movzx	 edx, al
  000ea	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  000f0	89 b4 3a 90 03
	00 00		 mov	 DWORD PTR [edx+edi+912], esi

; 191  : 				continue;

  000f7	eb 6a		 jmp	 SHORT $LN15@Init
$LN10@Init:

; 192  : 			}
; 193  : 			
; 194  : 			if ( wMonsterType == 89 || wMonsterType == 95 || wMonsterType == 112 || wMonsterType == 118 || wMonsterType == 124 || wMonsterType == 130 || wMonsterType == 143 || wMonsterType == 433 )

  000f9	83 fa 59	 cmp	 edx, 89			; 00000059H
  000fc	74 32		 je	 SHORT $LN8@Init
  000fe	83 fa 5f	 cmp	 edx, 95			; 0000005fH
  00101	74 2d		 je	 SHORT $LN8@Init
  00103	83 fa 70	 cmp	 edx, 112		; 00000070H
  00106	74 28		 je	 SHORT $LN8@Init
  00108	83 fa 76	 cmp	 edx, 118		; 00000076H
  0010b	74 23		 je	 SHORT $LN8@Init
  0010d	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  00110	74 1e		 je	 SHORT $LN8@Init
  00112	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00117	66 3b d1	 cmp	 dx, cx
  0011a	74 14		 je	 SHORT $LN8@Init
  0011c	b9 8f 00 00 00	 mov	 ecx, 143		; 0000008fH
  00121	66 3b d1	 cmp	 dx, cx
  00124	74 0a		 je	 SHORT $LN8@Init
  00126	b9 b1 01 00 00	 mov	 ecx, 433		; 000001b1H
  0012b	66 3b d1	 cmp	 dx, cx
  0012e	75 33		 jne	 SHORT $LN15@Init
$LN8@Init:

; 195  : 			{
; 196  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  00130	0f b6 c0	 movzx	 eax, al
  00133	8b d0		 mov	 edx, eax
  00135	33 c9		 xor	 ecx, ecx
  00137	69 d2 60 04 00
	00		 imul	 edx, 1120		; 00000460H
  0013d	8d 94 3a 3c 03
	00 00		 lea	 edx, DWORD PTR [edx+edi+828]
$LL7@Init:

; 197  : 				{
; 198  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  00144	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00147	74 0b		 je	 SHORT $LN36@Init

; 195  : 			{
; 196  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  00149	41		 inc	 ecx
  0014a	83 c2 04	 add	 edx, 4
  0014d	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00150	7c f2		 jl	 SHORT $LL7@Init

; 197  : 				{
; 198  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  00152	eb 0f		 jmp	 SHORT $LN15@Init
$LN36@Init:

; 199  : 					{
; 200  : 						this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] = n;

  00154	69 c0 18 01 00
	00		 imul	 eax, 280		; 00000118H
  0015a	03 c1		 add	 eax, ecx
  0015c	89 b4 87 3c 03
	00 00		 mov	 DWORD PTR [edi+eax*4+828], esi
$LN15@Init:

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	for ( int n =0; n<gMSetBase.m_Count;n++)

  00163	8b 55 08	 mov	 edx, DWORD PTR tv539[ebp]
  00166	46		 inc	 esi
  00167	83 c2 10	 add	 edx, 16			; 00000010H
  0016a	89 55 08	 mov	 DWORD PTR tv539[ebp], edx
  0016d	3b 35 84 2c 03
	00		 cmp	 esi, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  00173	0f 8c eb fe ff
	ff		 jl	 $LL45@Init
  00179	5b		 pop	 ebx
$LN14@Init:

; 201  : 						break;
; 202  : 					}
; 203  : 				}
; 204  : 			}
; 205  : 		}
; 206  : 
; 207  : 	}
; 208  : 
; 209  : 	for (int i=0;i<MAX_BLOOD_CASTLE_LEVEL;i++)

  0017a	33 f6		 xor	 esi, esi
  0017c	8d 64 24 00	 npad	 4
$LL3@Init:

; 210  : 	{
; 211  : 		this->SetState(i, BC_STATE_CLOSED);

  00180	6a 01		 push	 1
  00182	56		 push	 esi
  00183	8b cf		 mov	 ecx, edi
  00185	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
  0018a	46		 inc	 esi
  0018b	83 fe 08	 cmp	 esi, 8
  0018e	7c f0		 jl	 SHORT $LL3@Init
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi

; 212  : 	}
; 213  : }

  00192	5d		 pop	 ebp
  00193	c2 04 00	 ret	 4
?Init@CBloodCastle@@QAEX_N@Z ENDP			; CBloodCastle::Init
_TEXT	ENDS
PUBLIC	?Run@CBloodCastle@@QAEXXZ			; CBloodCastle::Run
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
; Function compile flags: /Ogtp
;	COMDAT ?Run@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
?Run@CBloodCastle@@QAEXXZ PROC				; CBloodCastle::Run, COMDAT
; _this$ = ecx

; 565  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 566  : 	if ( this->m_bBC_EVENT_ENABLE != false )

  00003	80 bb 04 23 00
	00 00		 cmp	 BYTE PTR [ebx+8964], 0
  0000a	74 51		 je	 SHORT $LN1@Run

; 567  : 	{
; 568  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 f6		 xor	 esi, esi
  00010	8d bb a8 03 00
	00		 lea	 edi, DWORD PTR [ebx+936]
$LL10@Run:

; 569  : 		{
; 570  : 			switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  00016	8b 07		 mov	 eax, DWORD PTR [edi]
  00018	83 f8 03	 cmp	 eax, 3
  0001b	77 23		 ja	 SHORT $LN9@Run
  0001d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@Run[eax*4]
$LN4@Run:

; 571  : 			{
; 572  : 				case BC_STATE_NONE:
; 573  : 					this->ProcState_None(iBridgeIndex);
; 574  : 					break;
; 575  : 
; 576  : 				case BC_STATE_CLOSED:
; 577  : 					this->ProcState_Closed(iBridgeIndex);

  00024	56		 push	 esi
  00025	8b cb		 mov	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ?ProcState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Closed

; 578  : 					break;

  0002c	eb 12		 jmp	 SHORT $LN9@Run
$LN3@Run:

; 579  : 
; 580  : 				case BC_STATE_PLAYING:
; 581  : 					this->ProcState_Playing(iBridgeIndex);

  0002e	56		 push	 esi
  0002f	8b cb		 mov	 ecx, ebx
  00031	e8 00 00 00 00	 call	 ?ProcState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Playing

; 582  : 					break;

  00036	eb 08		 jmp	 SHORT $LN9@Run
$LN2@Run:

; 583  : 
; 584  : 				case BC_STATE_PLAYEND:
; 585  : 					this->ProcState_PlayEnd(iBridgeIndex);

  00038	56		 push	 esi
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_PlayEnd
$LN9@Run:

; 567  : 	{
; 568  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  00040	46		 inc	 esi
  00041	81 c7 60 04 00
	00		 add	 edi, 1120		; 00000460H
  00047	83 fe 08	 cmp	 esi, 8
  0004a	7c ca		 jl	 SHORT $LL10@Run

; 586  : 					break;
; 587  : 			}
; 588  : 		}
; 589  : 		if ( szAuthKey[13] != AUTHKEY13 )

  0004c	80 3d 0d 00 00
	00 bb		 cmp	 BYTE PTR ?szAuthKey@@3PADA+13, -69 ; ffffffbbH
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	74 06		 je	 SHORT $LN1@Run
  00057	5b		 pop	 ebx

; 590  : 		{
; 591  : 			DestroyGIocp();

  00058	e9 00 00 00 00	 jmp	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN1@Run:
  0005d	5b		 pop	 ebx

; 592  : 		}
; 593  : 	}
; 594  : 
; 595  : }

  0005e	c3		 ret	 0
  0005f	90		 npad	 1
$LN18@Run:
  00060	00 00 00 00	 DD	 $LN9@Run
  00064	00 00 00 00	 DD	 $LN4@Run
  00068	00 00 00 00	 DD	 $LN3@Run
  0006c	00 00 00 00	 DD	 $LN2@Run
?Run@CBloodCastle@@QAEXXZ ENDP				; CBloodCastle::Run
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_BloodCastle@@YAXXZ
text$yc	SEGMENT
??__Eg_BloodCastle@@YAXXZ PROC				; `dynamic initializer for 'g_BloodCastle'', COMDAT

; 29   : CBloodCastle g_BloodCastle;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00005	e8 00 00 00 00	 call	 ??0CBloodCastle@@QAE@XZ	; CBloodCastle::CBloodCastle
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_BloodCastle@@YAXXZ ; `dynamic atexit destructor for 'g_BloodCastle''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_BloodCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_BloodCastle''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_BloodCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_BloodCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_BloodCastle'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00005	e9 00 00 00 00	 jmp	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
??__Fg_BloodCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_BloodCastle''
text$yd	ENDS
PUBLIC	?g_BloodCastle@@3VCBloodCastle@@A		; g_BloodCastle
_BSS	SEGMENT
?g_BloodCastle@@3VCBloodCastle@@A DB 0232cH DUP (?)	; g_BloodCastle
_BSS	ENDS
CRT$XCU	SEGMENT
_g_BloodCastle$initializer$ DD FLAT:??__Eg_BloodCastle@@YAXXZ
CRT$XCU	ENDS
END
