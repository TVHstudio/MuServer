; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\BloodCastleRewardItem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gBloodCastleRewardItem@@3VcBloodCastleRewardItem@@A ; gBloodCastleRewardItem
_BSS	SEGMENT
?gBloodCastleRewardItem@@3VcBloodCastleRewardItem@@A DB 0e12cH DUP (?) ; gBloodCastleRewardItem
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0BA@CDGAONCL@RewardItemCount?$AA@		; `string'
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0CJ@DAFGNNGB@?4?4?2Data?2ZtData?2BloodCastleReward@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cBloodCastleRewardItem@@QAEXXZ		; cBloodCastleRewardItem::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\bloodcastlerewarditem.cpp
CONST	SEGMENT
??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB ' '
	DB	'%d %d %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CDGAONCL@RewardItemCount?$AA@
CONST	SEGMENT
??_C@_0BA@CDGAONCL@RewardItemCount?$AA@ DB 'RewardItemCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DAFGNNGB@?4?4?2Data?2ZtData?2BloodCastleReward@
CONST	SEGMENT
??_C@_0CJ@DAFGNNGB@?4?4?2Data?2ZtData?2BloodCastleReward@ DB '..\Data\ZtD'
	DB	'ata\BloodCastleRewardItem.ini', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@cBloodCastleRewardItem@@QAEXXZ
_TEXT	SEGMENT
_file$ = -300						; size = 4
_Flag$ = -296						; size = 4
_n$203207 = -292					; size = 32
_Buff$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?Load@cBloodCastleRewardItem@@QAEXXZ PROC		; cBloodCastleRewardItem::Load, COMDAT
; _this$ = ecx

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 13   : 	this->Enable = GetPrivateProfileInt("ZtTeam","Enable",0,BC_REWARD_ITEM_DIR);

  00016	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileIntA@16
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DAFGNNGB@?4?4?2Data?2ZtData?2BloodCastleReward@
  00021	33 f6		 xor	 esi, esi
  00023	56		 push	 esi
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0002e	8b d9		 mov	 ebx, ecx
  00030	ff d7		 call	 edi

; 14   : 	this->m_iRewardItemCount = GetPrivateProfileInt("ZtTeam","RewardItemCount",0,BC_REWARD_ITEM_DIR);

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DAFGNNGB@?4?4?2Data?2ZtData?2BloodCastleReward@
  00037	56		 push	 esi
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CDGAONCL@RewardItemCount?$AA@
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00042	89 03		 mov	 DWORD PTR [ebx], eax
  00044	ff d7		 call	 edi
  00046	89 83 28 e1 00
	00		 mov	 DWORD PTR [ebx+57640], eax

; 17   : 	{
; 18   : 		for(int i=0;i<MAX_BC_REWARD_ITEM;i++)

  0004c	8d 53 28	 lea	 edx, DWORD PTR [ebx+40]
  0004f	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
$LL18@Load:
  00052	8b c2		 mov	 eax, edx
  00054	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL15@Load:

; 19   : 		{
; 20   : 			this->Reward[i][j].Type	= 0;

  00060	89 70 fc	 mov	 DWORD PTR [eax-4], esi

; 21   : 			this->Reward[i][j].Index	= 0;

  00063	89 30		 mov	 DWORD PTR [eax], esi

; 22   : 			this->Reward[i][j].Level	= 0;

  00065	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 23   : 			this->Reward[i][j].Skill	= 0;

  00068	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 24   : 			this->Reward[i][j].Luck	= 0;

  0006b	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 25   : 			this->Reward[i][j].Opt		= 0;

  0006e	89 70 10	 mov	 DWORD PTR [eax+16], esi

; 26   : 			this->Reward[i][j].Exl		= 0;

  00071	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 27   : 			this->Reward[i][j].Anc		= 0;

  00074	89 70 18	 mov	 DWORD PTR [eax+24], esi
  00077	05 20 01 00 00	 add	 eax, 288		; 00000120H
  0007c	49		 dec	 ecx
  0007d	75 e1		 jne	 SHORT $LL15@Load

; 15   : 
; 16   : 	for (int j = 1; j < 9; j++)

  0007f	83 c2 20	 add	 edx, 32			; 00000020H
  00082	4f		 dec	 edi
  00083	75 cd		 jne	 SHORT $LL18@Load

; 28   : 		}
; 29   : 	}
; 30   : 
; 31   : 	//CheckFile(BC_REWARD_ITEM_DIR);
; 32   : 
; 33   : 	FILE *file = fopen(BC_REWARD_ITEM_DIR,"r");

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DAFGNNGB@?4?4?2Data?2ZtData?2BloodCastleReward@
  0008f	e8 00 00 00 00	 call	 _fopen
  00094	8b f8		 mov	 edi, eax
  00096	83 c4 08	 add	 esp, 8
  00099	89 bd d4 fe ff
	ff		 mov	 DWORD PTR _file$[ebp], edi

; 34   : 
; 35   : 	if(file == NULL)

  0009f	3b fe		 cmp	 edi, esi
  000a1	75 13		 jne	 SHORT $LN12@Load

; 36   : 	{
; 37   : 		this->Enable = 0;

  000a3	5f		 pop	 edi
  000a4	89 33		 mov	 DWORD PTR [ebx], esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 81   : }

  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN12@Load:

; 38   : 		return;
; 39   : 	}
; 40   : 
; 41   : 	char Buff[256];
; 42   : 	int Flag = 0;
; 43   : 	for (int j = 1; j < 9; j++)
; 44   : 	{
; 45   : 		this->Count[j] = 0;
; 46   : 	}
; 47   : 	
; 48   : 	while(!feof(file))

  000b6	57		 push	 edi
  000b7	89 b5 d8 fe ff
	ff		 mov	 DWORD PTR _Flag$[ebp], esi
  000bd	89 b3 08 e1 00
	00		 mov	 DWORD PTR [ebx+57608], esi
  000c3	89 b3 0c e1 00
	00		 mov	 DWORD PTR [ebx+57612], esi
  000c9	89 b3 10 e1 00
	00		 mov	 DWORD PTR [ebx+57616], esi
  000cf	89 b3 14 e1 00
	00		 mov	 DWORD PTR [ebx+57620], esi
  000d5	89 b3 18 e1 00
	00		 mov	 DWORD PTR [ebx+57624], esi
  000db	89 b3 1c e1 00
	00		 mov	 DWORD PTR [ebx+57628], esi
  000e1	89 b3 20 e1 00
	00		 mov	 DWORD PTR [ebx+57632], esi
  000e7	89 b3 24 e1 00
	00		 mov	 DWORD PTR [ebx+57636], esi
  000ed	e8 00 00 00 00	 call	 _feof
  000f2	83 c4 04	 add	 esp, 4
  000f5	85 c0		 test	 eax, eax
  000f7	0f 85 6a 01 00
	00		 jne	 $LN7@Load
  000fd	8d 49 00	 npad	 3
$LL8@Load:

; 49   : 	{
; 50   : 		fgets(Buff,256,file);	

  00100	57		 push	 edi
  00101	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00107	68 00 01 00 00	 push	 256			; 00000100H
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _fgets

; 51   : 		if(Zt_IsBadFileLine(Buff, Flag))	

  00112	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _Flag$[ebp]
  00118	51		 push	 ecx
  00119	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  00125	83 c4 14	 add	 esp, 20			; 00000014H
  00128	84 c0		 test	 al, al
  0012a	0f 85 26 01 00
	00		 jne	 $LN27@Load

; 52   : 			continue;
; 53   : 		for (int j = 1; j < 9; j++)

  00130	bf 01 00 00 00	 mov	 edi, 1
  00135	8d b3 08 e1 00
	00		 lea	 esi, DWORD PTR [ebx+57608]
  0013b	eb 03 8d 49 00	 npad	 5
$LL5@Load:

; 54   : 		{
; 55   : 			if(Flag == j)

  00140	39 bd d8 fe ff
	ff		 cmp	 DWORD PTR _Flag$[ebp], edi
  00146	0f 85 f7 00 00
	00		 jne	 $LN4@Load

; 56   : 			{
; 57   : 				int n[8];
; 58   : 
; 59   : 				sscanf(Buff," %d %d %d %d %d %d %d %d %d",&n[0],&n[1],&n[2],&n[3],&n[4],&n[5],&n[6],&n[7]);

  0014c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _n$203207[ebp+28]
  00152	50		 push	 eax
  00153	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$203207[ebp+24]
  00159	51		 push	 ecx
  0015a	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _n$203207[ebp+20]
  00160	52		 push	 edx
  00161	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _n$203207[ebp+16]
  00167	50		 push	 eax
  00168	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$203207[ebp+12]
  0016e	51		 push	 ecx
  0016f	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _n$203207[ebp+8]
  00175	52		 push	 edx
  00176	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _n$203207[ebp+4]
  0017c	50		 push	 eax
  0017d	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _n$203207[ebp]
  00183	51		 push	 ecx
  00184	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0018f	52		 push	 edx
  00190	e8 00 00 00 00	 call	 _sscanf

; 60   : 
; 61   : 				this->Reward[this->Count[j]][j].Type		= n[0];

  00195	8b 06		 mov	 eax, DWORD PTR [esi]
  00197	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp]
  0019d	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  001a0	03 c8		 add	 ecx, eax
  001a2	c1 e1 05	 shl	 ecx, 5
  001a5	89 54 19 04	 mov	 DWORD PTR [ecx+ebx+4], edx

; 62   : 				this->Reward[this->Count[j]][j].Index		= n[1];

  001a9	8b 06		 mov	 eax, DWORD PTR [esi]
  001ab	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp+4]
  001b1	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  001b4	03 c8		 add	 ecx, eax
  001b6	c1 e1 05	 shl	 ecx, 5
  001b9	89 54 19 08	 mov	 DWORD PTR [ecx+ebx+8], edx

; 63   : 				this->Reward[this->Count[j]][j].Level		= n[2];

  001bd	8b 06		 mov	 eax, DWORD PTR [esi]
  001bf	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp+8]
  001c5	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  001c8	03 c8		 add	 ecx, eax
  001ca	c1 e1 05	 shl	 ecx, 5
  001cd	89 54 19 0c	 mov	 DWORD PTR [ecx+ebx+12], edx

; 64   : 				this->Reward[this->Count[j]][j].Skill		= n[3];

  001d1	8b 06		 mov	 eax, DWORD PTR [esi]
  001d3	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp+12]
  001d9	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  001dc	03 c8		 add	 ecx, eax
  001de	c1 e1 05	 shl	 ecx, 5
  001e1	89 54 19 10	 mov	 DWORD PTR [ecx+ebx+16], edx

; 65   : 				this->Reward[this->Count[j]][j].Luck		= n[4];

  001e5	8b 06		 mov	 eax, DWORD PTR [esi]
  001e7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp+16]
  001ed	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  001f0	03 c8		 add	 ecx, eax
  001f2	c1 e1 05	 shl	 ecx, 5
  001f5	89 54 19 14	 mov	 DWORD PTR [ecx+ebx+20], edx

; 66   : 				this->Reward[this->Count[j]][j].Opt		= n[5];

  001f9	8b 06		 mov	 eax, DWORD PTR [esi]
  001fb	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp+20]
  00201	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  00204	03 c8		 add	 ecx, eax
  00206	c1 e1 05	 shl	 ecx, 5
  00209	89 54 19 18	 mov	 DWORD PTR [ecx+ebx+24], edx

; 67   : 				this->Reward[this->Count[j]][j].Exl		= n[6];

  0020d	8b 06		 mov	 eax, DWORD PTR [esi]
  0020f	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$203207[ebp+24]
  00215	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  00218	03 c8		 add	 ecx, eax
  0021a	c1 e1 05	 shl	 ecx, 5
  0021d	89 54 19 1c	 mov	 DWORD PTR [ecx+ebx+28], edx

; 68   : 				this->Reward[this->Count[j]][j].Anc		= n[7];

  00221	8b 06		 mov	 eax, DWORD PTR [esi]
  00223	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  00226	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  0022a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _n$203207[ebp+28]
  00230	c1 e2 05	 shl	 edx, 5
  00233	89 04 1a	 mov	 DWORD PTR [edx+ebx], eax

; 69   : 
; 70   : 				this->Count[j]++;

  00236	ff 06		 inc	 DWORD PTR [esi]
  00238	83 c4 28	 add	 esp, 40			; 00000028H

; 71   : 
; 72   : 				if (this->Count[j]>=MAX_BC_REWARD_ITEM)

  0023b	81 3e c8 00 00
	00		 cmp	 DWORD PTR [esi], 200	; 000000c8H
  00241	7d 0d		 jge	 SHORT $LN41@Load
$LN4@Load:

; 52   : 			continue;
; 53   : 		for (int j = 1; j < 9; j++)

  00243	47		 inc	 edi
  00244	83 c6 04	 add	 esi, 4
  00247	83 ff 09	 cmp	 edi, 9
  0024a	0f 8c f0 fe ff
	ff		 jl	 $LL5@Load
$LN41@Load:
  00250	8b bd d4 fe ff
	ff		 mov	 edi, DWORD PTR _file$[ebp]
$LN27@Load:

; 38   : 		return;
; 39   : 	}
; 40   : 
; 41   : 	char Buff[256];
; 42   : 	int Flag = 0;
; 43   : 	for (int j = 1; j < 9; j++)
; 44   : 	{
; 45   : 		this->Count[j] = 0;
; 46   : 	}
; 47   : 	
; 48   : 	while(!feof(file))

  00256	57		 push	 edi
  00257	e8 00 00 00 00	 call	 _feof
  0025c	83 c4 04	 add	 esp, 4
  0025f	85 c0		 test	 eax, eax
  00261	0f 84 99 fe ff
	ff		 je	 $LL8@Load
$LN7@Load:

; 73   : 				{
; 74   : 					break;
; 75   : 				}
; 76   : 			}
; 77   : 		
; 78   : 		}
; 79   : 	}
; 80   : 	fclose(file);

  00267	57		 push	 edi
  00268	e8 00 00 00 00	 call	 _fclose

; 81   : }

  0026d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00270	83 c4 04	 add	 esp, 4
  00273	5f		 pop	 edi
  00274	5e		 pop	 esi
  00275	33 cd		 xor	 ecx, ebp
  00277	5b		 pop	 ebx
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c3		 ret	 0
?Load@cBloodCastleRewardItem@@QAEXXZ ENDP		; cBloodCastleRewardItem::Load
_TEXT	ENDS
PUBLIC	?Main@cBloodCastleRewardItem@@QAE_NH@Z		; cBloodCastleRewardItem::Main
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?Main@cBloodCastleRewardItem@@QAE_NH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?Main@cBloodCastleRewardItem@@QAE_NH@Z PROC		; cBloodCastleRewardItem::Main, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 85   : 	
; 86   : 	if(!this->Enable) return false;

  00004	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	75 08		 jne	 SHORT $LN11@Main
  0000c	32 c0		 xor	 al, al

; 117  : }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
$LN11@Main:
  00014	53		 push	 ebx

; 87   : 	LPOBJ lpObj = &gObj[aIndex];

  00015	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00018	56		 push	 esi
  00019	8b f3		 mov	 esi, ebx
  0001b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00021	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	57		 push	 edi

; 88   : 	
; 89   : 	for (int j = 1; j < 9; j++)

  00028	0f be 86 9e 0e
	00 00		 movsx	 eax, BYTE PTR [esi+3742]
  0002f	bf 01 00 00 00	 mov	 edi, 1
  00034	40		 inc	 eax
$LL10@Main:

; 90   : 	{
; 91   : 		if ((lpObj->m_cBloodCastleIndex+1) == j)

  00035	3b c7		 cmp	 eax, edi
  00037	74 11		 je	 SHORT $LN15@Main

; 88   : 	
; 89   : 	for (int j = 1; j < 9; j++)

  00039	47		 inc	 edi
  0003a	83 ff 09	 cmp	 edi, 9
  0003d	7c f6		 jl	 SHORT $LL10@Main
$LN8@Main:
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 114  : 		}
; 115  : 	}
; 116  : 	return false;

  00041	32 c0		 xor	 al, al
  00043	5b		 pop	 ebx

; 117  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN15@Main:

; 92   : 		{
; 93   : 			//srand(time(NULL));
; 94   : 			if (this->Count[j] == 0)

  0004a	83 bc b9 04 e1
	00 00 00	 cmp	 DWORD PTR [ecx+edi*4+57604], 0

; 95   : 			{
; 96   : 				return false;

  00052	74 eb		 je	 SHORT $LN8@Main

; 97   : 			}
; 98   : 
; 99   : 			if(THINNAKORN_MAC)
; 100  : 			{
; 101  : 				for(int i = 0; i < this->m_iRewardItemCount; i++)
; 102  : 				{
; 103  : 					int itemId = rand()%this->Count[j];
; 104  : 					ItemSerialCreateSend(aIndex,lpObj->MapNumber,lpObj->X,lpObj->Y,ITEMGET(this->Reward[itemId][j].Type,this->Reward[itemId][j].Index),this->Reward[itemId][j].Level,0,this->Reward[itemId][j].Skill,this->Reward[itemId][j].Luck,this->Reward[itemId][j].Opt,aIndex,this->Reward[itemId][j].Exl,this->Reward[itemId][j].Anc);
; 105  : 				}
; 106  : 			}
; 107  : 			else
; 108  : 			{
; 109  : 				int itemId = rand()%this->Count[j];

  00054	e8 00 00 00 00	 call	 _rand
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	99		 cdq
  0005d	f7 bc b9 04 e1
	00 00		 idiv	 DWORD PTR [ecx+edi*4+57604]

; 110  : 				ItemSerialCreateSend(aIndex,lpObj->MapNumber,lpObj->X,lpObj->Y,ITEMGET(this->Reward[itemId][j].Type,this->Reward[itemId][j].Index),this->Reward[itemId][j].Level,0,this->Reward[itemId][j].Skill,this->Reward[itemId][j].Luck,this->Reward[itemId][j].Opt,aIndex,this->Reward[itemId][j].Exl,this->Reward[itemId][j].Anc);

  00064	8d 04 d7	 lea	 eax, DWORD PTR [edi+edx*8]
  00067	03 c2		 add	 eax, edx
  00069	c1 e0 05	 shl	 eax, 5
  0006c	0f b6 54 08 1c	 movzx	 edx, BYTE PTR [eax+ecx+28]
  00071	03 c1		 add	 eax, ecx
  00073	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  00077	51		 push	 ecx
  00078	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  0007c	52		 push	 edx
  0007d	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  00081	53		 push	 ebx
  00082	51		 push	 ecx
  00083	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00087	52		 push	 edx
  00088	0f b6 50 0c	 movzx	 edx, BYTE PTR [eax+12]
  0008c	51		 push	 ecx
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	6a 00		 push	 0
  00092	52		 push	 edx
  00093	0f b6 96 46 01
	00 00		 movzx	 edx, BYTE PTR [esi+326]
  0009a	c1 e1 09	 shl	 ecx, 9
  0009d	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000a0	0f b6 86 44 01
	00 00		 movzx	 eax, BYTE PTR [esi+324]
  000a7	51		 push	 ecx
  000a8	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000af	52		 push	 edx
  000b0	50		 push	 eax
  000b1	51		 push	 ecx
  000b2	53		 push	 ebx
  000b3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  000b8	83 c4 34	 add	 esp, 52			; 00000034H
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi

; 111  : 			}
; 112  : 
; 113  : 			return true;	

  000bd	b0 01		 mov	 al, 1
  000bf	5b		 pop	 ebx

; 117  : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
?Main@cBloodCastleRewardItem@@QAE_NH@Z ENDP		; cBloodCastleRewardItem::Main
_TEXT	ENDS
END
