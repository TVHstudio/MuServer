; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\BloodHound.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BloodHound@@3VcBloodHound@@A			; BloodHound
_BSS	SEGMENT
?BloodHound@@3VcBloodHound@@A DB 0fbabcH DUP (?)	; BloodHound
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BE@JNJNPECB@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CC?$CF?$FL?$FO?$CC?$FN?$CC?$AA@ ; `string'
PUBLIC	??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_09OHFGCBJB@EventTime?$AA@			; `string'
PUBLIC	??_C@_05MGEEICMI@NPC_Y?$AA@			; `string'
PUBLIC	??_C@_05NPFPLDIJ@NPC_X?$AA@			; `string'
PUBLIC	??_C@_07LJMEGBCH@NPC_Map?$AA@			; `string'
PUBLIC	??_C@_03BCJIDNJL@NPC?$AA@			; `string'
PUBLIC	??_C@_06POMJKEPM@Common?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ReedConfig@cBloodHound@@QAEXXZ			; cBloodHound::ReedConfig
EXTRN	_fclose:PROC
EXTRN	_sprintf:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\bloodhound.cpp
CONST	SEGMENT
??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%'
	DB	'd %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JNJNPECB@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CC?$CF?$FL?$FO?$CC?$FN?$CC?$AA@
CONST	SEGMENT
??_C@_0BE@JNJNPECB@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CC?$CF?$FL?$FO?$CC?$FN?$CC?$AA@ DB '%'
	DB	'd %d %d %d "%[^"]"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@ DB '%d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09OHFGCBJB@EventTime?$AA@
CONST	SEGMENT
??_C@_09OHFGCBJB@EventTime?$AA@ DB 'EventTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGEEICMI@NPC_Y?$AA@
CONST	SEGMENT
??_C@_05MGEEICMI@NPC_Y?$AA@ DB 'NPC_Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NPFPLDIJ@NPC_X?$AA@
CONST	SEGMENT
??_C@_05NPFPLDIJ@NPC_X?$AA@ DB 'NPC_X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LJMEGBCH@NPC_Map?$AA@
CONST	SEGMENT
??_C@_07LJMEGBCH@NPC_Map?$AA@ DB 'NPC_Map', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BCJIDNJL@NPC?$AA@
CONST	SEGMENT
??_C@_03BCJIDNJL@NPC?$AA@ DB 'NPC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06POMJKEPM@Common?$AA@
CONST	SEGMENT
??_C@_06POMJKEPM@Common?$AA@ DB 'Common', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
CONST	SEGMENT
??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@ DB '..\Data\Zt'
	DB	'Data\Events\BloodHoundEvent.ini', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReedConfig@cBloodHound@@QAEXXZ
_TEXT	SEGMENT
_Flag$ = -360						; size = 4
_n$203291 = -356					; size = 12
_n$203299 = -344					; size = 32
_n$203294 = -332					; size = 20
_Buff$ = -312						; size = 256
_ItemName$203295 = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
?ReedConfig@cBloodHound@@QAEXXZ PROC			; cBloodHound::ReedConfig, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	57		 push	 edi

; 22   : 	for (int i=0;i<MAX_ITEMS_BH;i++)

  00018	8d 86 3c ae 0f
	00		 lea	 eax, DWORD PTR [esi+1027644]
  0001e	8d 8e a8 93 0f
	00		 lea	 ecx, DWORD PTR [esi+1020840]
  00024	8d 96 84 90 0f
	00		 lea	 edx, DWORD PTR [esi+1020036]
  0002a	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
  0002f	33 db		 xor	 ebx, ebx
$LL11@ReedConfig:

; 23   : 	{
; 24   : 		sTime[i].Hour = 0;

  00031	89 5a fc	 mov	 DWORD PTR [edx-4], ebx

; 25   : 		sTime[i].Minute = 0;

  00034	89 1a		 mov	 DWORD PTR [edx], ebx

; 26   : 
; 27   : 		sItem[i].Type = 0;

  00036	89 59 fc	 mov	 DWORD PTR [ecx-4], ebx

; 28   : 		sItem[i].Index = 0;

  00039	89 19		 mov	 DWORD PTR [ecx], ebx

; 29   : 		sItem[i].Level = 0;

  0003b	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 30   : 		sItem[i].Count = 0;

  0003e	89 59 08	 mov	 DWORD PTR [ecx+8], ebx

; 31   : 
; 32   : 		iReward[i].Type = 0;

  00041	89 58 fc	 mov	 DWORD PTR [eax-4], ebx

; 33   : 		iReward[i].Index = 0;

  00044	89 18		 mov	 DWORD PTR [eax], ebx

; 34   : 		iReward[i].Level = 0;

  00046	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 35   : 		iReward[i].Skill = 0;

  00049	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 36   : 		iReward[i].Luck = 0;

  0004c	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 37   : 		iReward[i].Opt = 0;

  0004f	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 38   : 		iReward[i].Exl = 0;

  00052	89 58 14	 mov	 DWORD PTR [eax+20], ebx

; 39   : 		iReward[i].Anc = 0;

  00055	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  00058	83 c2 08	 add	 edx, 8
  0005b	83 c1 44	 add	 ecx, 68			; 00000044H
  0005e	83 c0 20	 add	 eax, 32			; 00000020H
  00061	4f		 dec	 edi
  00062	75 cd		 jne	 SHORT $LL11@ReedConfig

; 40   : 	}
; 41   : 
; 42   : 	this->Enable = 0;

  00064	89 1e		 mov	 DWORD PTR [esi], ebx

; 43   : 
; 44   : 	if(!g_ZtLicense.user.BloodHound)

  00066	38 1d cf 00 00
	00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+207, bl
  0006c	0f 84 71 03 00
	00		 je	 $LN12@ReedConfig

; 45   : 	{
; 46   : 		return;
; 47   : 	}
; 48   : 
; 49   : 	this->Enable = GetPrivateProfileInt("Common","Enable",0,BLOODHOND_DIR);

  00072	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  0007d	53		 push	 ebx
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  00088	ff d7		 call	 edi

; 50   : 	this->NPC = GetPrivateProfileInt("Common","NPC",0,BLOODHOND_DIR);

  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  0008f	53		 push	 ebx
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_03BCJIDNJL@NPC?$AA@
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  0009a	89 06		 mov	 DWORD PTR [esi], eax
  0009c	ff d7		 call	 edi

; 51   : 	this->NPC_Map = GetPrivateProfileInt("Common","NPC_Map",0,BLOODHOND_DIR);

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  000a3	53		 push	 ebx
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_07LJMEGBCH@NPC_Map?$AA@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000ae	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000b1	ff d7		 call	 edi

; 52   : 	this->NPC_X = GetPrivateProfileInt("Common","NPC_X",0,BLOODHOND_DIR);

  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  000b8	53		 push	 ebx
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_05NPFPLDIJ@NPC_X?$AA@
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000c3	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000c6	ff d7		 call	 edi

; 53   : 	this->NPC_Y = GetPrivateProfileInt("Common","NPC_Y",0,BLOODHOND_DIR);

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  000cd	53		 push	 ebx
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_05MGEEICMI@NPC_Y?$AA@
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000d8	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000db	ff d7		 call	 edi

; 54   : 
; 55   : 	this->EventTime = GetPrivateProfileInt("Common","EventTime",0,BLOODHOND_DIR);

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  000e2	53		 push	 ebx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_09OHFGCBJB@EventTime?$AA@
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_06POMJKEPM@Common?$AA@
  000ed	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000f0	ff d7		 call	 edi

; 56   : 
; 57   : 	this->StartEvent = false;
; 58   : 
; 59   : 	FILE *file;
; 60   : 	file = fopen(BLOODHOND_DIR,"r");

  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  000fc	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000ff	88 5e 18	 mov	 BYTE PTR [esi+24], bl
  00102	e8 00 00 00 00	 call	 _fopen
  00107	8b f8		 mov	 edi, eax
  00109	83 c4 08	 add	 esp, 8

; 61   : 	if(file == NULL)

  0010c	3b fb		 cmp	 edi, ebx
  0010e	75 23		 jne	 SHORT $LN7@ReedConfig

; 62   : 	{
; 63   : 		MessageBoxA(0,BLOODHOND_DIR,"LOAD FILE ERROR",0);

  00110	53		 push	 ebx
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KGJMACPH@?4?4?2Data?2ZtData?2Events?2BloodHound@
  0011b	53		 push	 ebx
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx

; 115  : }

  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	33 cd		 xor	 ecx, ebp
  0012a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
$LN7@ReedConfig:

; 64   : 		//ExitProcess(1);
; 65   : 		return;
; 66   : 	}
; 67   : 	char Buff[256];
; 68   : 	int Flag = 0;
; 69   : 
; 70   : 	this->tCount = 0;
; 71   : 	this->sCount = 0;
; 72   : 	this->rCount = 0;
; 73   : 
; 74   : 	while(!feof(file)) // Проверяем есть ли строка ?документ?

  00133	57		 push	 edi
  00134	89 9d 98 fe ff
	ff		 mov	 DWORD PTR _Flag$[ebp], ebx
  0013a	89 9e a0 93 0f
	00		 mov	 DWORD PTR [esi+1020832], ebx
  00140	89 9e 34 ae 0f
	00		 mov	 DWORD PTR [esi+1027636], ebx
  00146	89 9e b8 ba 0f
	00		 mov	 DWORD PTR [esi+1030840], ebx
  0014c	e8 00 00 00 00	 call	 _feof
  00151	83 c4 04	 add	 esp, 4
  00154	85 c0		 test	 eax, eax
  00156	0f 85 7e 02 00
	00		 jne	 $LN5@ReedConfig
  0015c	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  0015f	90		 npad	 1
$LL6@ReedConfig:

; 75   : 	{
; 76   : 		fgets(Buff,256,file);//Функция читает текущу?строку

  00160	57		 push	 edi
  00161	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00167	68 00 01 00 00	 push	 256			; 00000100H
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _fgets

; 77   : 		if(Zt_IsBadFileLine(Buff, Flag)) //Вспомогательная функция

  00172	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _Flag$[ebp]
  00178	51		 push	 ecx
  00179	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  0017f	52		 push	 edx
  00180	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  00185	83 c4 14	 add	 esp, 20			; 00000014H
  00188	84 c0		 test	 al, al
  0018a	0f 85 39 02 00
	00		 jne	 $LN1@ReedConfig

; 78   : 			continue;
; 79   : 		if(Flag == 1)

  00190	39 9d 98 fe ff
	ff		 cmp	 DWORD PTR _Flag$[ebp], ebx
  00196	75 4e		 jne	 SHORT $LN3@ReedConfig

; 80   : 		{
; 81   : 			int n[3];
; 82   : 			sscanf(Buff,"%d %d",&n[0],&n[1]);

  00198	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _n$203291[ebp+4]
  0019e	50		 push	 eax
  0019f	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _n$203291[ebp]
  001a5	51		 push	 ecx
  001a6	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  001b1	52		 push	 edx
  001b2	e8 00 00 00 00	 call	 _sscanf

; 83   : 			this->sTime[this->tCount].Hour = n[0];

  001b7	8b 86 a0 93 0f
	00		 mov	 eax, DWORD PTR [esi+1020832]
  001bd	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _n$203291[ebp]
  001c3	89 8c c6 80 90
	0f 00		 mov	 DWORD PTR [esi+eax*8+1020032], ecx

; 84   : 			this->sTime[this->tCount].Minute = n[1];

  001ca	8b 96 a0 93 0f
	00		 mov	 edx, DWORD PTR [esi+1020832]
  001d0	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _n$203291[ebp+4]
  001d6	83 c4 10	 add	 esp, 16			; 00000010H
  001d9	89 84 d6 84 90
	0f 00		 mov	 DWORD PTR [esi+edx*8+1020036], eax

; 85   : 			this->tCount++;

  001e0	01 9e a0 93 0f
	00		 add	 DWORD PTR [esi+1020832], ebx
$LN3@ReedConfig:

; 86   : 		}
; 87   : 		if(Flag == 2)

  001e6	83 bd 98 fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  001ed	0f 85 c5 00 00
	00		 jne	 $LN2@ReedConfig

; 88   : 		{
; 89   : 			int n[5];
; 90   : 			char ItemName[50];
; 91   : 			sscanf(Buff,"%d %d %d %d \"%[^\"]\"",&n[0],&n[1],&n[2],&n[3],&ItemName);

  001f3	8d 4d c8	 lea	 ecx, DWORD PTR _ItemName$203295[ebp]
  001f6	51		 push	 ecx
  001f7	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _n$203294[ebp+12]
  001fd	52		 push	 edx
  001fe	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _n$203294[ebp+8]
  00204	50		 push	 eax
  00205	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$203294[ebp+4]
  0020b	51		 push	 ecx
  0020c	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _n$203294[ebp]
  00212	52		 push	 edx
  00213	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00219	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JNJNPECB@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CC?$CF?$FL?$FO?$CC?$FN?$CC?$AA@
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _sscanf

; 92   : 			this->sItem[this->sCount].Type  = n[0];

  00224	8b 86 34 ae 0f
	00		 mov	 eax, DWORD PTR [esi+1027636]
  0022a	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _n$203294[ebp]
  00230	8b c8		 mov	 ecx, eax
  00232	c1 e1 04	 shl	 ecx, 4
  00235	03 c8		 add	 ecx, eax
  00237	89 94 8e a4 93
	0f 00		 mov	 DWORD PTR [esi+ecx*4+1020836], edx

; 93   : 			this->sItem[this->sCount].Index = n[1];

  0023e	8b 86 34 ae 0f
	00		 mov	 eax, DWORD PTR [esi+1027636]
  00244	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _n$203294[ebp+4]
  0024a	8b c8		 mov	 ecx, eax
  0024c	c1 e1 04	 shl	 ecx, 4
  0024f	03 c8		 add	 ecx, eax
  00251	89 94 8e a8 93
	0f 00		 mov	 DWORD PTR [esi+ecx*4+1020840], edx

; 94   : 			this->sItem[this->sCount].Level = n[2];

  00258	8b 86 34 ae 0f
	00		 mov	 eax, DWORD PTR [esi+1027636]
  0025e	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR _n$203294[ebp+8]
  00264	8b c8		 mov	 ecx, eax
  00266	c1 e1 04	 shl	 ecx, 4
  00269	03 c8		 add	 ecx, eax
  0026b	89 94 8e ac 93
	0f 00		 mov	 DWORD PTR [esi+ecx*4+1020844], edx

; 95   : 			this->sItem[this->sCount].Count  = n[3];

  00272	8b 86 34 ae 0f
	00		 mov	 eax, DWORD PTR [esi+1027636]
  00278	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _n$203294[ebp+12]
  0027e	8b c8		 mov	 ecx, eax
  00280	c1 e1 04	 shl	 ecx, 4
  00283	03 c8		 add	 ecx, eax
  00285	89 94 8e b0 93
	0f 00		 mov	 DWORD PTR [esi+ecx*4+1020848], edx

; 96   : 			sprintf(this->sItem[this->sCount].Name,"%s",ItemName);

  0028c	8d 45 c8	 lea	 eax, DWORD PTR _ItemName$203295[ebp]
  0028f	50		 push	 eax
  00290	8b 86 34 ae 0f
	00		 mov	 eax, DWORD PTR [esi+1027636]
  00296	8b c8		 mov	 ecx, eax
  00298	c1 e1 04	 shl	 ecx, 4
  0029b	03 c8		 add	 ecx, eax
  0029d	8d 94 8e b4 93
	0f 00		 lea	 edx, DWORD PTR [esi+ecx*4+1020852]
  002a4	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  002a9	52		 push	 edx
  002aa	e8 00 00 00 00	 call	 _sprintf
  002af	83 c4 28	 add	 esp, 40			; 00000028H

; 97   : 			this->sCount++;

  002b2	01 9e 34 ae 0f
	00		 add	 DWORD PTR [esi+1027636], ebx
$LN2@ReedConfig:

; 98   : 		}
; 99   : 		if(Flag == 3)

  002b8	83 bd 98 fe ff
	ff 03		 cmp	 DWORD PTR _Flag$[ebp], 3
  002bf	0f 85 04 01 00
	00		 jne	 $LN1@ReedConfig

; 100  : 		{
; 101  : 			int n[8];
; 102  : 			sscanf(Buff,"%d %d %d %d %d %d %d %d",&n[0],&n[1],&n[2],&n[3],&n[4],&n[5],&n[6],&n[7]);

  002c5	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _n$203299[ebp+28]
  002cb	50		 push	 eax
  002cc	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _n$203299[ebp+24]
  002d2	51		 push	 ecx
  002d3	8d 95 bc fe ff
	ff		 lea	 edx, DWORD PTR _n$203299[ebp+20]
  002d9	52		 push	 edx
  002da	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _n$203299[ebp+16]
  002e0	50		 push	 eax
  002e1	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$203299[ebp+12]
  002e7	51		 push	 ecx
  002e8	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _n$203299[ebp+8]
  002ee	52		 push	 edx
  002ef	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _n$203299[ebp+4]
  002f5	50		 push	 eax
  002f6	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$203299[ebp]
  002fc	51		 push	 ecx
  002fd	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HDMMBKBM@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00308	52		 push	 edx
  00309	e8 00 00 00 00	 call	 _sscanf

; 103  : 			this->iReward[this->rCount].Type= n[0];

  0030e	8b 86 b8 ba 0f
	00		 mov	 eax, DWORD PTR [esi+1030840]
  00314	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _n$203299[ebp]
  0031a	c1 e0 05	 shl	 eax, 5
  0031d	89 8c 30 38 ae
	0f 00		 mov	 DWORD PTR [eax+esi+1027640], ecx

; 104  : 			this->iReward[this->rCount].Index = n[1];

  00324	8b 96 b8 ba 0f
	00		 mov	 edx, DWORD PTR [esi+1030840]
  0032a	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _n$203299[ebp+4]
  00330	c1 e2 05	 shl	 edx, 5
  00333	89 84 32 3c ae
	0f 00		 mov	 DWORD PTR [edx+esi+1027644], eax

; 105  : 			this->iReward[this->rCount].Level = n[2];

  0033a	8b 8e b8 ba 0f
	00		 mov	 ecx, DWORD PTR [esi+1030840]
  00340	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _n$203299[ebp+8]
  00346	81 c1 72 7d 00
	00		 add	 ecx, 32114		; 00007d72H
  0034c	c1 e1 05	 shl	 ecx, 5
  0034f	89 14 31	 mov	 DWORD PTR [ecx+esi], edx

; 106  : 			this->iReward[this->rCount].Skill = n[3];

  00352	8b 86 b8 ba 0f
	00		 mov	 eax, DWORD PTR [esi+1030840]
  00358	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$203299[ebp+12]
  0035e	c1 e0 05	 shl	 eax, 5
  00361	89 8c 30 44 ae
	0f 00		 mov	 DWORD PTR [eax+esi+1027652], ecx

; 107  : 			this->iReward[this->rCount].Luck = n[4];

  00368	8b 96 b8 ba 0f
	00		 mov	 edx, DWORD PTR [esi+1030840]
  0036e	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _n$203299[ebp+16]
  00374	c1 e2 05	 shl	 edx, 5
  00377	89 84 32 48 ae
	0f 00		 mov	 DWORD PTR [edx+esi+1027656], eax

; 108  : 			this->iReward[this->rCount].Opt = n[5];

  0037e	8b 8e b8 ba 0f
	00		 mov	 ecx, DWORD PTR [esi+1030840]
  00384	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR _n$203299[ebp+20]
  0038a	c1 e1 05	 shl	 ecx, 5
  0038d	89 94 31 4c ae
	0f 00		 mov	 DWORD PTR [ecx+esi+1027660], edx

; 109  : 			this->iReward[this->rCount].Exl = n[6];

  00394	8b 86 b8 ba 0f
	00		 mov	 eax, DWORD PTR [esi+1030840]
  0039a	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _n$203299[ebp+24]
  003a0	c1 e0 05	 shl	 eax, 5
  003a3	89 8c 30 50 ae
	0f 00		 mov	 DWORD PTR [eax+esi+1027664], ecx

; 110  : 			this->iReward[this->rCount].Anc = n[7];

  003aa	8b 96 b8 ba 0f
	00		 mov	 edx, DWORD PTR [esi+1030840]
  003b0	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _n$203299[ebp+28]
  003b6	c1 e2 05	 shl	 edx, 5
  003b9	83 c4 28	 add	 esp, 40			; 00000028H
  003bc	89 84 32 54 ae
	0f 00		 mov	 DWORD PTR [edx+esi+1027668], eax

; 111  : 			this->rCount++;

  003c3	01 9e b8 ba 0f
	00		 add	 DWORD PTR [esi+1030840], ebx
$LN1@ReedConfig:

; 64   : 		//ExitProcess(1);
; 65   : 		return;
; 66   : 	}
; 67   : 	char Buff[256];
; 68   : 	int Flag = 0;
; 69   : 
; 70   : 	this->tCount = 0;
; 71   : 	this->sCount = 0;
; 72   : 	this->rCount = 0;
; 73   : 
; 74   : 	while(!feof(file)) // Проверяем есть ли строка ?документ?

  003c9	57		 push	 edi
  003ca	e8 00 00 00 00	 call	 _feof
  003cf	83 c4 04	 add	 esp, 4
  003d2	85 c0		 test	 eax, eax
  003d4	0f 84 86 fd ff
	ff		 je	 $LL6@ReedConfig
$LN5@ReedConfig:

; 112  : 		}
; 113  : 	}
; 114  : 	fclose(file);

  003da	57		 push	 edi
  003db	e8 00 00 00 00	 call	 _fclose
  003e0	83 c4 04	 add	 esp, 4
$LN12@ReedConfig:

; 115  : }

  003e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e6	5f		 pop	 edi
  003e7	5e		 pop	 esi
  003e8	33 cd		 xor	 ecx, ebp
  003ea	5b		 pop	 ebx
  003eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f0	8b e5		 mov	 esp, ebp
  003f2	5d		 pop	 ebp
  003f3	c3		 ret	 0
?ReedConfig@cBloodHound@@QAEXXZ ENDP			; cBloodHound::ReedConfig
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?UserStart@cBloodHound@@QAEXH@Z			; cBloodHound::UserStart
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodhound.cpp
;	COMDAT ?UserStart@cBloodHound@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?UserStart@cBloodHound@@QAEXH@Z PROC			; cBloodHound::UserStart, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 119  : 	this->UserCheck[aIndex] = false;

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	c6 44 08 20 00	 mov	 BYTE PTR [eax+ecx+32], 0

; 120  : 	this->UserEvent[aIndex] = false;

  0000b	c6 84 08 b8 3a
	00 00 00	 mov	 BYTE PTR [eax+ecx+15032], 0

; 121  : 	this->iUserType[aIndex] = -1;

  00013	83 ca ff	 or	 edx, -1
  00016	89 94 81 50 75
	00 00		 mov	 DWORD PTR [ecx+eax*4+30032], edx

; 122  : 	this->iUserIndex[aIndex] = -1;

  0001d	89 94 81 b0 5f
	01 00		 mov	 DWORD PTR [ecx+eax*4+90032], edx

; 123  : 	this->iUserLevel[aIndex] = -1;

  00024	89 94 81 10 4a
	02 00		 mov	 DWORD PTR [ecx+eax*4+150032], edx

; 124  : 	this->iUserCount[aIndex] = -1;

  0002b	89 94 81 70 34
	03 00		 mov	 DWORD PTR [ecx+eax*4+210032], edx

; 125  : 	this->iUserName[aIndex][0] = NULL;

  00032	6b c0 32	 imul	 eax, 50			; 00000032H
  00035	c6 84 08 d0 1e
	04 00 00	 mov	 BYTE PTR [eax+ecx+270032], 0

; 126  : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?UserStart@cBloodHound@@QAEXH@Z ENDP			; cBloodHound::UserStart
_TEXT	ENDS
PUBLIC	??_C@_0CD@DIPFOAC@?$FLBloodHound?$FN?5Need?3?5?$CFs?$CL?$CFd?5Count?3?5@ ; `string'
PUBLIC	?TakeJob@cBloodHound@@QAEXH@Z			; cBloodHound::TakeJob
EXTRN	?MessageChat@@YAXHPADZZ:PROC			; MessageChat
EXTRN	_rand:PROC
EXTRN	_srand:PROC
;	COMDAT ??_C@_0CD@DIPFOAC@?$FLBloodHound?$FN?5Need?3?5?$CFs?$CL?$CFd?5Count?3?5@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0CD@DIPFOAC@?$FLBloodHound?$FN?5Need?3?5?$CFs?$CL?$CFd?5Count?3?5@ DB '['
	DB	'BloodHound] Need: %s+%d Count: %d', 00H	; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodhound.cpp
CONST	ENDS
;	COMDAT ?TakeJob@cBloodHound@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?TakeJob@cBloodHound@@QAEXH@Z PROC			; cBloodHound::TakeJob, COMDAT
; _this$ = ecx

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 151  : 	//OBJECTSTRUCT * gObj = (OBJECTSTRUCT*)OBJECT_POINTER(aIndex);
; 152  : 	srand(time(NULL));

  00006	6a 00		 push	 0
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 __time64
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _srand
  00015	83 c4 08	 add	 esp, 8

; 153  : 	int n = rand()%this->sCount;

  00018	e8 00 00 00 00	 call	 _rand
  0001d	99		 cdq
  0001e	f7 be 34 ae 0f
	00		 idiv	 DWORD PTR [esi+1027636]

; 154  : 	
; 155  : 	this->UserEvent[aIndex] = true;

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00027	c6 84 31 b8 3a
	00 00 01	 mov	 BYTE PTR [ecx+esi+15032], 1

; 156  : 	this->iUserType[aIndex] = this->sItem[n].Type;

  0002f	8b c2		 mov	 eax, edx
  00031	c1 e0 04	 shl	 eax, 4
  00034	03 c2		 add	 eax, edx
  00036	8b 94 86 a4 93
	0f 00		 mov	 edx, DWORD PTR [esi+eax*4+1020836]
  0003d	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00040	89 94 8e 50 75
	00 00		 mov	 DWORD PTR [esi+ecx*4+30032], edx

; 157  : 	this->iUserIndex[aIndex] = this->sItem[n].Index;

  00047	8b 90 a8 93 0f
	00		 mov	 edx, DWORD PTR [eax+1020840]
  0004d	89 94 8e b0 5f
	01 00		 mov	 DWORD PTR [esi+ecx*4+90032], edx

; 158  : 	this->iUserLevel[aIndex] = this->sItem[n].Level;

  00054	8b 90 ac 93 0f
	00		 mov	 edx, DWORD PTR [eax+1020844]
  0005a	89 94 8e 10 4a
	02 00		 mov	 DWORD PTR [esi+ecx*4+150032], edx

; 159  : 	this->iUserCount[aIndex] = this->sItem[n].Count;

  00061	8b 90 b0 93 0f
	00		 mov	 edx, DWORD PTR [eax+1020848]
  00067	89 94 8e 70 34
	03 00		 mov	 DWORD PTR [esi+ecx*4+210032], edx

; 160  : 	strcpy(this->iUserName[aIndex],this->sItem[n].Name);

  0006e	8b d1		 mov	 edx, ecx
  00070	6b d2 32	 imul	 edx, 50			; 00000032H
  00073	8d 98 b4 93 0f
	00		 lea	 ebx, DWORD PTR [eax+1020852]
  00079	8d b4 32 d0 1e
	04 00		 lea	 esi, DWORD PTR [edx+esi+270032]
  00080	8b fb		 mov	 edi, ebx
  00082	2b f3		 sub	 esi, ebx
$LL3@TakeJob:
  00084	8a 17		 mov	 dl, BYTE PTR [edi]
  00086	88 14 3e	 mov	 BYTE PTR [esi+edi], dl
  00089	47		 inc	 edi
  0008a	84 d2		 test	 dl, dl
  0008c	75 f6		 jne	 SHORT $LL3@TakeJob

; 161  : 
; 162  : 	MessageChat(aIndex,"[BloodHound] Need: %s+%d Count: %d",this->sItem[n].Name,this->sItem[n].Level,this->sItem[n].Count);

  0008e	8b 90 b0 93 0f
	00		 mov	 edx, DWORD PTR [eax+1020848]
  00094	8b 80 ac 93 0f
	00		 mov	 eax, DWORD PTR [eax+1020844]
  0009a	52		 push	 edx
  0009b	50		 push	 eax
  0009c	53		 push	 ebx
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DIPFOAC@?$FLBloodHound?$FN?5Need?3?5?$CFs?$CL?$CFd?5Count?3?5@
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 163  : }

  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
?TakeJob@cBloodHound@@QAEXH@Z ENDP			; cBloodHound::TakeJob
_TEXT	ENDS
PUBLIC	??_C@_0CA@BJFBFPBN@?$FLBloodHound?$FN?5Need?3?5?$CFs?5Count?3?5?$CFd?$AA@ ; `string'
PUBLIC	?RunJob@cBloodHound@@QAEXH@Z			; cBloodHound::RunJob
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?GenExcOpt@@YAHH@Z:PROC				; GenExcOpt
EXTRN	?gObjDeleteItemsCount@@YAHHFFH@Z:PROC		; gObjDeleteItemsCount
EXTRN	?gObjGetItemCountInInventory@@YAHHHH@Z:PROC	; gObjGetItemCountInInventory
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0CA@BJFBFPBN@?$FLBloodHound?$FN?5Need?3?5?$CFs?5Count?3?5?$CFd?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0CA@BJFBFPBN@?$FLBloodHound?$FN?5Need?3?5?$CFs?5Count?3?5?$CFd?$AA@ DB '['
	DB	'BloodHound] Need: %s Count: %d', 00H	; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\bloodhound.cpp
CONST	ENDS
;	COMDAT ?RunJob@cBloodHound@@QAEXH@Z
_TEXT	SEGMENT
_lpUser$ = -20						; size = 4
_Type$ = -16						; size = 4
_iLevel$ = -12						; size = 4
_iLuck$ = -8						; size = 4
_NeedIndex$ = -8					; size = 4
_iSkill$ = -4						; size = 4
_NeedLevel$ = -4					; size = 4
_iOpt$ = 8						; size = 4
_NeedCount$ = 8						; size = 4
_aIndex$ = 8						; size = 4
?RunJob@cBloodHound@@QAEXH@Z PROC			; cBloodHound::RunJob, COMDAT
; _this$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 166  : 	LPOBJ lpUser = &gObj[aIndex];

  00008	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00013	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	57		 push	 edi
  0001a	8b f9		 mov	 edi, ecx

; 167  : 
; 168  : 	int NeedType = this->iUserType[aIndex];
; 169  : 	int NeedIndex = this->iUserIndex[aIndex];
; 170  : 	int NeedLevel = this->iUserLevel[aIndex];

  0001c	8b 8c b7 10 4a
	02 00		 mov	 ecx, DWORD PTR [edi+esi*4+150032]
  00023	8b 9c b7 50 75
	00 00		 mov	 ebx, DWORD PTR [edi+esi*4+30032]

; 171  : 	int NeedCount = this->iUserCount[aIndex];

  0002a	8b 94 b7 70 34
	03 00		 mov	 edx, DWORD PTR [edi+esi*4+210032]

; 172  : 
; 173  : 	if(gObjGetItemCountInInventory(aIndex,ITEMGET(NeedType,NeedIndex),NeedLevel) < NeedCount)

  00031	51		 push	 ecx
  00032	89 4d fc	 mov	 DWORD PTR _NeedLevel$[ebp], ecx
  00035	89 45 ec	 mov	 DWORD PTR _lpUser$[ebp], eax
  00038	8b 84 b7 b0 5f
	01 00		 mov	 eax, DWORD PTR [edi+esi*4+90032]
  0003f	8b cb		 mov	 ecx, ebx
  00041	c1 e1 09	 shl	 ecx, 9
  00044	03 c8		 add	 ecx, eax
  00046	51		 push	 ecx
  00047	56		 push	 esi
  00048	89 45 f8	 mov	 DWORD PTR _NeedIndex$[ebp], eax
  0004b	89 55 08	 mov	 DWORD PTR _NeedCount$[ebp], edx
  0004e	e8 00 00 00 00	 call	 ?gObjGetItemCountInInventory@@YAHHHH@Z ; gObjGetItemCountInInventory
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _NeedCount$[ebp]
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b c1		 cmp	 eax, ecx
  0005b	7d 5c		 jge	 SHORT $LN5@RunJob

; 174  : 	{
; 175  : 		if(this->iUserLevel[aIndex] == 0)

  0005d	8b 84 b7 10 4a
	02 00		 mov	 eax, DWORD PTR [edi+esi*4+150032]

; 176  : 			MessageChat(aIndex,"[BloodHound] Need: %s Count: %d",this->iUserName[aIndex],this->iUserCount[aIndex]);

  00064	8b 94 b7 70 34
	03 00		 mov	 edx, DWORD PTR [edi+esi*4+210032]
  0006b	52		 push	 edx
  0006c	85 c0		 test	 eax, eax
  0006e	75 24		 jne	 SHORT $LN4@RunJob
  00070	8b c6		 mov	 eax, esi
  00072	6b c0 32	 imul	 eax, 50			; 00000032H
  00075	8d 8c 38 d0 1e
	04 00		 lea	 ecx, DWORD PTR [eax+edi+270032]
  0007c	51		 push	 ecx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BJFBFPBN@?$FLBloodHound?$FN?5Need?3?5?$CFs?5Count?3?5?$CFd?$AA@
  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  00088	83 c4 10	 add	 esp, 16			; 00000010H
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 208  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
$LN4@RunJob:

; 177  : 		else
; 178  : 			MessageChat(aIndex,"[BloodHound] Need: %s+%d Count: %d",this->iUserName[aIndex],this->iUserLevel[aIndex],this->iUserCount[aIndex]);

  00094	50		 push	 eax
  00095	8b c6		 mov	 eax, esi
  00097	6b c0 32	 imul	 eax, 50			; 00000032H
  0009a	8d 8c 38 d0 1e
	04 00		 lea	 ecx, DWORD PTR [eax+edi+270032]
  000a1	51		 push	 ecx
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DIPFOAC@?$FLBloodHound?$FN?5Need?3?5?$CFs?$CL?$CFd?5Count?3?5@
  000a7	56		 push	 esi
  000a8	e8 00 00 00 00	 call	 ?MessageChat@@YAXHPADZZ	; MessageChat
  000ad	83 c4 14	 add	 esp, 20			; 00000014H
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx

; 208  : }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 04 00	 ret	 4
$LN5@RunJob:

; 179  : 		return;
; 180  : 	}
; 181  : 
; 182  : 	gObjDeleteItemsCount(aIndex,ITEMGET(NeedType,NeedIndex),NeedLevel,NeedCount);

  000b9	8b 55 fc	 mov	 edx, DWORD PTR _NeedLevel$[ebp]
  000bc	51		 push	 ecx
  000bd	c1 e3 09	 shl	 ebx, 9
  000c0	03 5d f8	 add	 ebx, DWORD PTR _NeedIndex$[ebp]
  000c3	52		 push	 edx
  000c4	53		 push	 ebx
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?gObjDeleteItemsCount@@YAHHFFH@Z ; gObjDeleteItemsCount

; 183  : 
; 184  : 	srand(time(NULL));

  000cb	6a 00		 push	 0
  000cd	e8 00 00 00 00	 call	 __time64
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _srand

; 185  : 	int n = rand()%this->rCount;

  000d8	e8 00 00 00 00	 call	 _rand
  000dd	99		 cdq
  000de	f7 bf b8 ba 0f
	00		 idiv	 DWORD PTR [edi+1030840]

; 186  : 
; 187  : 	int Type = ITEMGET(iReward[n].Type,iReward[n].Index);

  000e4	8b da		 mov	 ebx, edx
  000e6	c1 e3 05	 shl	 ebx, 5
  000e9	8b 84 3b 38 ae
	0f 00		 mov	 eax, DWORD PTR [ebx+edi+1027640]
  000f0	03 df		 add	 ebx, edi

; 188  : 	int iLevel = iReward[n].Level;

  000f2	81 c2 72 7d 00
	00		 add	 edx, 32114		; 00007d72H
  000f8	c1 e2 05	 shl	 edx, 5
  000fb	8b 0c 3a	 mov	 ecx, DWORD PTR [edx+edi]

; 189  : 	int iSkill	= iReward[n].Skill;

  000fe	8b 93 44 ae 0f
	00		 mov	 edx, DWORD PTR [ebx+1027652]
  00104	c1 e0 09	 shl	 eax, 9
  00107	03 83 3c ae 0f
	00		 add	 eax, DWORD PTR [ebx+1027644]
  0010d	89 55 fc	 mov	 DWORD PTR _iSkill$[ebp], edx

; 190  : 	int iLuck	= iReward[n].Luck;
; 191  : 	int iOpt = iReward[n].Opt;
; 192  : 	int iExe	= GenExcOpt(iReward[n].Exl);

  00110	8b 93 50 ae 0f
	00		 mov	 edx, DWORD PTR [ebx+1027664]
  00116	89 45 f0	 mov	 DWORD PTR _Type$[ebp], eax
  00119	8b 83 48 ae 0f
	00		 mov	 eax, DWORD PTR [ebx+1027656]
  0011f	89 4d f4	 mov	 DWORD PTR _iLevel$[ebp], ecx
  00122	8b 8b 4c ae 0f
	00		 mov	 ecx, DWORD PTR [ebx+1027660]
  00128	52		 push	 edx
  00129	89 45 f8	 mov	 DWORD PTR _iLuck$[ebp], eax
  0012c	89 4d 08	 mov	 DWORD PTR _iOpt$[ebp], ecx
  0012f	e8 00 00 00 00	 call	 ?GenExcOpt@@YAHH@Z	; GenExcOpt

; 193  : 	int iAnc	= 0;
; 194  : 
; 195  : 	if(iReward[n].Anc == 5 || iReward[n].Anc == 10)

  00134	8b 9b 54 ae 0f
	00		 mov	 ebx, DWORD PTR [ebx+1027668]
  0013a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0013d	33 c9		 xor	 ecx, ecx
  0013f	83 fb 05	 cmp	 ebx, 5
  00142	74 05		 je	 SHORT $LN1@RunJob
  00144	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00147	75 02		 jne	 SHORT $LN2@RunJob
$LN1@RunJob:

; 196  : 	{
; 197  : 		iAnc = iReward[n].Anc;

  00149	8b cb		 mov	 ecx, ebx
$LN2@RunJob:

; 198  : 	}
; 199  : 
; 200  : 	ItemSerialCreateSend(aIndex,lpUser->MapNumber,lpUser->X,lpUser->Y,Type,iLevel,0,iSkill,iLuck,iOpt,aIndex,iExe,iAnc);

  0014b	8b 55 fc	 mov	 edx, DWORD PTR _iSkill$[ebp]
  0014e	51		 push	 ecx
  0014f	8b 4d f8	 mov	 ecx, DWORD PTR _iLuck$[ebp]
  00152	50		 push	 eax
  00153	8b 45 08	 mov	 eax, DWORD PTR _iOpt$[ebp]
  00156	56		 push	 esi
  00157	50		 push	 eax
  00158	8b 45 f4	 mov	 eax, DWORD PTR _iLevel$[ebp]
  0015b	51		 push	 ecx
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR _Type$[ebp]
  0015f	52		 push	 edx
  00160	6a 00		 push	 0
  00162	50		 push	 eax
  00163	8b 45 ec	 mov	 eax, DWORD PTR _lpUser$[ebp]
  00166	0f b6 90 46 01
	00 00		 movzx	 edx, BYTE PTR [eax+326]
  0016d	51		 push	 ecx
  0016e	0f b6 88 44 01
	00 00		 movzx	 ecx, BYTE PTR [eax+324]
  00175	52		 push	 edx
  00176	0f b6 90 49 01
	00 00		 movzx	 edx, BYTE PTR [eax+329]
  0017d	51		 push	 ecx
  0017e	52		 push	 edx
  0017f	56		 push	 esi
  00180	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 201  : 
; 202  : 	this->UserEvent[aIndex] = false;

  00185	c6 84 3e b8 3a
	00 00 00	 mov	 BYTE PTR [esi+edi+15032], 0

; 203  : 	this->iUserType[aIndex] = -1;

  0018d	83 c8 ff	 or	 eax, -1
  00190	83 c4 34	 add	 esp, 52			; 00000034H
  00193	89 84 b7 50 75
	00 00		 mov	 DWORD PTR [edi+esi*4+30032], eax

; 204  : 	this->iUserIndex[aIndex] = -1;

  0019a	89 84 b7 b0 5f
	01 00		 mov	 DWORD PTR [edi+esi*4+90032], eax

; 205  : 	this->iUserLevel[aIndex] = -1;

  001a1	89 84 b7 10 4a
	02 00		 mov	 DWORD PTR [edi+esi*4+150032], eax

; 206  : 	this->iUserCount[aIndex] = -1;

  001a8	89 84 b7 70 34
	03 00		 mov	 DWORD PTR [edi+esi*4+210032], eax

; 207  : 	this->iUserName[aIndex][0] = NULL;

  001af	6b f6 32	 imul	 esi, 50			; 00000032H
  001b2	c6 84 3e d0 1e
	04 00 00	 mov	 BYTE PTR [esi+edi+270032], 0
  001ba	5f		 pop	 edi
  001bb	5e		 pop	 esi
  001bc	5b		 pop	 ebx

; 208  : }

  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c2 04 00	 ret	 4
?RunJob@cBloodHound@@QAEXH@Z ENDP			; cBloodHound::RunJob
_TEXT	ENDS
PUBLIC	??_C@_0BE@GAKEJDCP@?$FLBloodHound?$FN?5Start?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BC@MJHHMLN@?$FLBloodHound?$FN?5End?$CB?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Times@cBloodHound@@QAEXXZ			; cBloodHound::Times
EXTRN	?MessaageAllGlobal@@YAXPADZZ:PROC		; MessaageAllGlobal
EXTRN	?GetSecond@CTimerZt@@QAEHXZ:PROC		; CTimerZt::GetSecond
EXTRN	?g_TimerZt@@3VCTimerZt@@A:DWORD			; g_TimerZt
EXTRN	__imp__GetLocalTime@4:PROC
;	COMDAT ??_C@_0BE@GAKEJDCP@?$FLBloodHound?$FN?5Start?$CB?$AA@
CONST	SEGMENT
??_C@_0BE@GAKEJDCP@?$FLBloodHound?$FN?5Start?$CB?$AA@ DB '[BloodHound] St'
	DB	'art!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MJHHMLN@?$FLBloodHound?$FN?5End?$CB?$AA@
CONST	SEGMENT
??_C@_0BC@MJHHMLN@?$FLBloodHound?$FN?5End?$CB?$AA@ DB '[BloodHound] End!', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Times@cBloodHound@@QAEXXZ
_TEXT	SEGMENT
_t$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?Times@cBloodHound@@QAEXXZ PROC				; cBloodHound::Times, COMDAT
; _this$ = ecx

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b f1		 mov	 esi, ecx

; 212  : 	if(!this->Enable)

  00014	33 db		 xor	 ebx, ebx
  00016	39 1e		 cmp	 DWORD PTR [esi], ebx
  00018	0f 84 08 01 00
	00		 je	 $LN6@Times

; 213  : 		return;
; 214  : 
; 215  : 	if(this->StartEvent == true)

  0001e	80 7e 18 01	 cmp	 BYTE PTR [esi+24], 1
  00022	57		 push	 edi
  00023	75 6d		 jne	 SHORT $LN14@Times

; 216  : 	{
; 217  : 		this->TickEvent++;

  00025	ff 46 1c	 inc	 DWORD PTR [esi+28]
  00028	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 218  : 		if(this->TickEvent >= this->EventTime)

  0002b	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0002e	0f 8c f1 00 00
	00		 jl	 $LN25@Times

; 219  : 		{
; 220  : 			this->StartEvent = false;

  00034	88 5e 18	 mov	 BYTE PTR [esi+24], bl

; 221  : 			this->TickEvent = 0;

  00037	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  0003a	8d 8e 80 6d 00
	00		 lea	 ecx, DWORD PTR [esi+28032]
  00040	8d 96 e0 09 0e
	00		 lea	 edx, DWORD PTR [esi+920032]
  00046	8d 86 d0 2a 02
	00		 lea	 eax, DWORD PTR [esi+142032]
  0004c	bf d0 07 00 00	 mov	 edi, 2000		; 000007d0H
  00051	83 ce ff	 or	 esi, -1
  00054	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL12@Times:

; 222  : 			for(int i=OBJ_MAXMONSTER; i<OBJMAX; i++)
; 223  : 			{
; 224  : 				this->UserCheck[i] = false;

  00060	88 99 68 c5 ff
	ff		 mov	 BYTE PTR [ecx-15000], bl

; 225  : 				this->UserEvent[i] = false;

  00066	88 19		 mov	 BYTE PTR [ecx], bl

; 226  : 				this->iUserType[i] = -1;

  00068	89 b0 a0 15 ff
	ff		 mov	 DWORD PTR [eax-60000], esi

; 227  : 				this->iUserIndex[i] = -1;

  0006e	89 30		 mov	 DWORD PTR [eax], esi

; 228  : 				this->iUserLevel[i] = -1;

  00070	89 b0 60 ea 00
	00		 mov	 DWORD PTR [eax+60000], esi

; 229  : 				this->iUserCount[i] = -1;

  00076	89 b0 c0 d4 01
	00		 mov	 DWORD PTR [eax+120000], esi

; 230  : 				this->iUserName[i][0] = NULL;

  0007c	88 1a		 mov	 BYTE PTR [edx], bl
  0007e	83 c0 04	 add	 eax, 4
  00081	41		 inc	 ecx
  00082	83 c2 32	 add	 edx, 50			; 00000032H
  00085	4f		 dec	 edi
  00086	75 d8		 jne	 SHORT $LL12@Times

; 231  : 			}
; 232  : 			
; 233  : 			MessaageAllGlobal("[BloodHound] End!");

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MJHHMLN@?$FLBloodHound?$FN?5End?$CB?$AA@

; 234  : 		}
; 235  : 		return;

  0008d	e9 8b 00 00 00	 jmp	 $LN26@Times
$LN14@Times:

; 236  : 	}
; 237  : 
; 238  : 	SYSTEMTIME t;
; 239  : 	GetLocalTime(&t);

  00092	8d 45 ec	 lea	 eax, DWORD PTR _t$[ebp]
  00095	50		 push	 eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 240  : 
; 241  : #if(NEWTIMEREX)
; 242  : 	if(g_TimerZt.GetSecond() == 00)

  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TimerZt@@3VCTimerZt@@A ; g_TimerZt
  000a1	e8 00 00 00 00	 call	 ?GetSecond@CTimerZt@@QAEHXZ ; CTimerZt::GetSecond
  000a6	85 c0		 test	 eax, eax
  000a8	75 7b		 jne	 SHORT $LN25@Times

; 243  : #else
; 244  : 	if(t.wSecond == 00)
; 245  : #endif
; 246  : 	{
; 247  : 		for(int i = 0; i < this->tCount; i++)

  000aa	33 c9		 xor	 ecx, ecx
  000ac	39 9e a0 93 0f
	00		 cmp	 DWORD PTR [esi+1020832], ebx
  000b2	7e 71		 jle	 SHORT $LN25@Times
  000b4	0f b7 55 f4	 movzx	 edx, WORD PTR _t$[ebp+8]
  000b8	66 8b 7d f6	 mov	 di, WORD PTR _t$[ebp+10]
  000bc	8d 86 84 90 0f
	00		 lea	 eax, DWORD PTR [esi+1020036]
$LL8@Times:

; 248  : 		{
; 249  : 			if(this->sTime[i].Hour == t.wHour && this->sTime[i].Minute == t.wMinute)

  000c2	39 50 fc	 cmp	 DWORD PTR [eax-4], edx
  000c5	75 07		 jne	 SHORT $LN7@Times
  000c7	0f b7 df	 movzx	 ebx, di
  000ca	39 18		 cmp	 DWORD PTR [eax], ebx
  000cc	74 1d		 je	 SHORT $LN21@Times
$LN7@Times:

; 243  : #else
; 244  : 	if(t.wSecond == 00)
; 245  : #endif
; 246  : 	{
; 247  : 		for(int i = 0; i < this->tCount; i++)

  000ce	41		 inc	 ecx
  000cf	83 c0 08	 add	 eax, 8
  000d2	3b 8e a0 93 0f
	00		 cmp	 ecx, DWORD PTR [esi+1020832]
  000d8	7c e8		 jl	 SHORT $LL8@Times
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx

; 260  : 
; 261  : 				return;
; 262  : 			}
; 263  : 		}
; 264  : 	}
; 265  : }

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	33 cd		 xor	 ecx, ebp
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
$LN21@Times:

; 250  : 			{
; 251  : 				this->StartEvent = true;

  000eb	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1

; 252  : 				for(int i=OBJ_MAXMONSTER; i<OBJMAX; i++)

  000ef	b8 c8 32 00 00	 mov	 eax, 13000		; 000032c8H
  000f4	b9 03 00 00 00	 mov	 ecx, 3
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL4@Times:

; 253  : 				{
; 254  : 					LPOBJ lpUser = &gObj[i];
; 255  : 					if(gObj->Connected != PLAYER_PLAYING)

  00100	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00106	39 4a 04	 cmp	 DWORD PTR [edx+4], ecx
  00109	75 05		 jne	 SHORT $LN3@Times

; 256  : 						continue;
; 257  : 					this->UserCheck[i] = true;

  0010b	c6 44 06 20 01	 mov	 BYTE PTR [esi+eax+32], 1
$LN3@Times:

; 252  : 				for(int i=OBJ_MAXMONSTER; i<OBJMAX; i++)

  00110	40		 inc	 eax
  00111	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00116	7c e8		 jl	 SHORT $LL4@Times

; 258  : 				}
; 259  : 				MessaageAllGlobal("[BloodHound] Start!");

  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GAKEJDCP@?$FLBloodHound?$FN?5Start?$CB?$AA@
$LN26@Times:
  0011d	e8 00 00 00 00	 call	 ?MessaageAllGlobal@@YAXPADZZ ; MessaageAllGlobal
  00122	83 c4 04	 add	 esp, 4
$LN25@Times:
  00125	5f		 pop	 edi
$LN6@Times:

; 260  : 
; 261  : 				return;
; 262  : 			}
; 263  : 		}
; 264  : 	}
; 265  : }

  00126	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00129	5e		 pop	 esi
  0012a	33 cd		 xor	 ecx, ebp
  0012c	5b		 pop	 ebx
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
?Times@cBloodHound@@QAEXXZ ENDP				; cBloodHound::Times
_TEXT	ENDS
PUBLIC	?NPCClick@cBloodHound@@QAEXHH@Z			; cBloodHound::NPCClick
; Function compile flags: /Ogtp
;	COMDAT ?NPCClick@cBloodHound@@QAEXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aNPC$ = 12						; size = 4
?NPCClick@cBloodHound@@QAEXHH@Z PROC			; cBloodHound::NPCClick, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 130  : 	if(!this->Enable)	return;

  00003	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00006	74 6b		 je	 SHORT $LN1@NPCClick

; 131  : 	if(!this->StartEvent)	return;

  00008	80 79 18 00	 cmp	 BYTE PTR [ecx+24], 0
  0000c	74 65		 je	 SHORT $LN1@NPCClick

; 132  : 	if(!this->UserCheck[aIndex]) return;

  0000e	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00011	80 7c 0a 20 00	 cmp	 BYTE PTR [edx+ecx+32], 0
  00016	74 5b		 je	 SHORT $LN1@NPCClick

; 133  : 
; 134  : 	LPOBJ lpUser = &gObj[aIndex];
; 135  : 	LPOBJ lpNpc = &gObj[aNPC];

  00018	8b 45 0c	 mov	 eax, DWORD PTR _aNPC$[ebp]
  0001b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00021	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	56		 push	 esi

; 136  : 	if ((lpNpc->Class == this->NPC) && (lpNpc->MapNumber == this->NPC_Map) && (lpNpc->X == this->NPC_X) && (lpNpc->Y == this->NPC_Y))

  00028	0f b7 b0 b8 00
	00 00		 movzx	 esi, WORD PTR [eax+184]
  0002f	3b 71 04	 cmp	 esi, DWORD PTR [ecx+4]
  00032	75 3e		 jne	 SHORT $LN9@NPCClick
  00034	0f b6 b0 49 01
	00 00		 movzx	 esi, BYTE PTR [eax+329]
  0003b	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
  0003e	75 32		 jne	 SHORT $LN9@NPCClick
  00040	0f bf b0 44 01
	00 00		 movsx	 esi, WORD PTR [eax+324]
  00047	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0004a	75 26		 jne	 SHORT $LN9@NPCClick
  0004c	0f bf 80 46 01
	00 00		 movsx	 eax, WORD PTR [eax+326]
  00053	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00056	75 1a		 jne	 SHORT $LN9@NPCClick

; 137  : 	{
; 138  : 		if(this->UserEvent[aIndex] == false)

  00058	80 bc 0a b8 3a
	00 00 00	 cmp	 BYTE PTR [edx+ecx+15032], 0

; 139  : 		{
; 140  : 			this->TakeJob(aIndex);

  00060	52		 push	 edx
  00061	75 0a		 jne	 SHORT $LN2@NPCClick
  00063	e8 00 00 00 00	 call	 ?TakeJob@cBloodHound@@QAEXH@Z ; cBloodHound::TakeJob
  00068	5e		 pop	 esi

; 145  : 		}
; 146  : 	}
; 147  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
$LN2@NPCClick:

; 141  : 		}
; 142  : 		else
; 143  : 		{
; 144  : 			this->RunJob(aIndex);

  0006d	e8 00 00 00 00	 call	 ?RunJob@cBloodHound@@QAEXH@Z ; cBloodHound::RunJob
$LN9@NPCClick:
  00072	5e		 pop	 esi
$LN1@NPCClick:

; 145  : 		}
; 146  : 	}
; 147  : }

  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
?NPCClick@cBloodHound@@QAEXHH@Z ENDP			; cBloodHound::NPCClick
_TEXT	ENDS
END
