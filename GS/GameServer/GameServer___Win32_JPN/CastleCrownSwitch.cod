; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\CastleCrownSwitch.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetRegCrownAvailable@CCastleSiege@@QAEHXZ	; CCastleSiege::GetRegCrownAvailable
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
;	COMDAT ?GetRegCrownAvailable@CCastleSiege@@QAEHXZ
_TEXT	SEGMENT
?GetRegCrownAvailable@CCastleSiege@@QAEHXZ PROC		; CCastleSiege::GetRegCrownAvailable, COMDAT
; _this$ = ecx

; 347  : 	BOOL GetRegCrownAvailable(){return m_bRegCrownAvailable;}

  00000	8b 81 e8 01 00
	00		 mov	 eax, DWORD PTR [ecx+488]
  00006	c3		 ret	 0
?GetRegCrownAvailable@CCastleSiege@@QAEHXZ ENDP		; CCastleSiege::GetRegCrownAvailable
_TEXT	ENDS
PUBLIC	?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z	; CCastleSiege::SetRegCrownAvailable
; Function compile flags: /Ogtp
;	COMDAT ?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_bRegCrownAvailable$ = 8				; size = 4
?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z PROC	; CCastleSiege::SetRegCrownAvailable, COMDAT
; _this$ = ecx

; 348  : 	void SetRegCrownAvailable(BOOL bRegCrownAvailable){m_bRegCrownAvailable = bRegCrownAvailable;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _bRegCrownAvailable$[ebp]
  00006	89 81 e8 01 00
	00		 mov	 DWORD PTR [ecx+488], eax
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetRegCrownAvailable@CCastleSiege@@QAEXH@Z ENDP	; CCastleSiege::SetRegCrownAvailable
_TEXT	ENDS
PUBLIC	??_7CCastleCrownSwitch@@6B@			; CCastleCrownSwitch::`vftable'
PUBLIC	??0CCastleCrownSwitch@@QAE@XZ			; CCastleCrownSwitch::CCastleCrownSwitch
PUBLIC	??_R4CCastleCrownSwitch@@6B@			; CCastleCrownSwitch::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCastleCrownSwitch@@@8			; CCastleCrownSwitch `RTTI Type Descriptor'
PUBLIC	??_R3CCastleCrownSwitch@@8			; CCastleCrownSwitch::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCastleCrownSwitch@@8			; CCastleCrownSwitch::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCastleCrownSwitch@@8		; CCastleCrownSwitch::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECCastleCrownSwitch@@UAEPAXI@Z:PROC		; CCastleCrownSwitch::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCastleCrownSwitch@@8
; File e:\work\tranet_version\gs\gameserver\castlecrownswitch.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CCastleCrownSwitch@@8 DD FLAT:??_R0?AVCCastleCrownSwitch@@@8 ; CCastleCrownSwitch::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCastleCrownSwitch@@8
rdata$r	ENDS
;	COMDAT ??_R2CCastleCrownSwitch@@8
rdata$r	SEGMENT
??_R2CCastleCrownSwitch@@8 DD FLAT:??_R1A@?0A@EA@CCastleCrownSwitch@@8 ; CCastleCrownSwitch::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CCastleCrownSwitch@@8
rdata$r	SEGMENT
??_R3CCastleCrownSwitch@@8 DD 00H			; CCastleCrownSwitch::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CCastleCrownSwitch@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCastleCrownSwitch@@@8
_DATA	SEGMENT
??_R0?AVCCastleCrownSwitch@@@8 DD FLAT:??_7type_info@@6B@ ; CCastleCrownSwitch `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCastleCrownSwitch@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCastleCrownSwitch@@6B@
rdata$r	SEGMENT
??_R4CCastleCrownSwitch@@6B@ DD 00H			; CCastleCrownSwitch::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCastleCrownSwitch@@@8
	DD	FLAT:??_R3CCastleCrownSwitch@@8
rdata$r	ENDS
;	COMDAT ??_7CCastleCrownSwitch@@6B@
CONST	SEGMENT
??_7CCastleCrownSwitch@@6B@ DD FLAT:??_R4CCastleCrownSwitch@@6B@ ; CCastleCrownSwitch::`vftable'
	DD	FLAT:??_ECCastleCrownSwitch@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CCastleCrownSwitch@@QAE@XZ
_TEXT	SEGMENT
??0CCastleCrownSwitch@@QAE@XZ PROC			; CCastleCrownSwitch::CCastleCrownSwitch, COMDAT
; _this$ = ecx

; 19   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCastleCrownSwitch@@6B@

; 20   : 	return;
; 21   : }

  00008	c3		 ret	 0
??0CCastleCrownSwitch@@QAE@XZ ENDP			; CCastleCrownSwitch::CCastleCrownSwitch
_TEXT	ENDS
PUBLIC	??1CCastleCrownSwitch@@UAE@XZ			; CCastleCrownSwitch::~CCastleCrownSwitch
; Function compile flags: /Ogtp
;	COMDAT ??1CCastleCrownSwitch@@UAE@XZ
_TEXT	SEGMENT
??1CCastleCrownSwitch@@UAE@XZ PROC			; CCastleCrownSwitch::~CCastleCrownSwitch, COMDAT
; _this$ = ecx

; 24   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCastleCrownSwitch@@6B@

; 25   : 	return;
; 26   : }

  00006	c3		 ret	 0
??1CCastleCrownSwitch@@UAE@XZ ENDP			; CCastleCrownSwitch::~CCastleCrownSwitch
_TEXT	ENDS
PUBLIC	??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@ ; `string'
PUBLIC	?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z ; CCastleCrownSwitch::CastleCrownSwitchAct
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?GCAnsCsAccessSwitchState@@YAXHHHE@Z:PROC	; GCAnsCsAccessSwitchState
EXTRN	?NotifyCrownSwitchInfo@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifyCrownSwitchInfo
EXTRN	?NotifyCrownState@CCastleSiege@@QAEXE@Z:PROC	; CCastleSiege::NotifyCrownState
EXTRN	?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::ResetCrownSwitchUserIndex
EXTRN	?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::GetCrownSwitchUserIndex
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
;	COMDAT ??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@ DB '['
	DB	'CastleSiege] [%s][%s] Push Castle Crown Switch Canceled (GUIL'
	DB	'D:%s) - CS X:%d/Y:%d', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\castlecrownswitch.cpp
CONST	ENDS
;	COMDAT ?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z PROC	; CCastleCrownSwitch::CastleCrownSwitchAct, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 30   : 	if ( !gObjIsConnected(iIndex))

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	0f 84 82 02 00
	00		 je	 $LN12@CastleCrow

; 31   : 		return;
; 32   : 
; 33   : 	if ( gObj[iIndex].Type != OBJ_NPC ||
; 34   : 		((gObj[iIndex].Class < 217 )?FALSE:(gObj[iIndex].Class > 219-1 )?FALSE:TRUE)==FALSE )

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00023	66 83 7c 07 68
	03		 cmp	 WORD PTR [edi+eax+104], 3
  00029	0f 85 6b 02 00
	00		 jne	 $LN12@CastleCrow
  0002f	0f b7 8c 07 b8
	00 00 00	 movzx	 ecx, WORD PTR [edi+eax+184]
  00037	b8 d9 00 00 00	 mov	 eax, 217		; 000000d9H
  0003c	66 3b c8	 cmp	 cx, ax
  0003f	0f 82 55 02 00
	00		 jb	 $LN12@CastleCrow
  00045	ba da 00 00 00	 mov	 edx, 218		; 000000daH
  0004a	66 3b d1	 cmp	 dx, cx
  0004d	1b c0		 sbb	 eax, eax
  0004f	40		 inc	 eax
  00050	0f 84 44 02 00
	00		 je	 $LN12@CastleCrow

; 35   : 		return;
; 36   : 
; 37   : 	if ( !gObjIsConnected(g_CastleSiege.GetCrownSwitchUserIndex(gObj[iIndex].Class)) )

  00056	51		 push	 ecx
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0005c	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	75 41		 jne	 SHORT $LN11@CastleCrow

; 38   : 	{
; 39   : 		g_CastleSiege.ResetCrownSwitchUserIndex(gObj[iIndex].Class);

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00074	0f b7 94 0f b8
	00 00 00	 movzx	 edx, WORD PTR [edi+ecx+184]
  0007c	52		 push	 edx
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00082	e8 00 00 00 00	 call	 ?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::ResetCrownSwitchUserIndex

; 40   : 
; 41   : 		if ( g_CastleSiege.GetRegCrownAvailable() == 1 )

  00087	83 3d e8 01 00
	00 01		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 1
  0008e	0f 85 06 02 00
	00		 jne	 $LN12@CastleCrow

; 42   : 		{
; 43   : 			g_CastleSiege.SetRegCrownAvailable(FALSE);
; 44   : 			g_CastleSiege.NotifyCrownState(1);

  00094	6a 01		 push	 1
  00096	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009b	c7 05 e8 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 0
  000a5	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
  000aa	5f		 pop	 edi

; 100  : 		}
; 101  : 	}
; 102  : }

  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
$LN11@CastleCrow:

; 45   : 		}
; 46   : 
; 47   : 		return;
; 48   : 	}
; 49   : 	
; 50   : 	LPOBJ lpObj= &gObj[iIndex];

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 51   : 	LPOBJ lpUserObj = &gObj[g_CastleSiege.GetCrownSwitchUserIndex(gObj[iIndex].Class)];

  000b4	0f b7 8c 07 b8
	00 00 00	 movzx	 ecx, WORD PTR [edi+eax+184]
  000bc	53		 push	 ebx
  000bd	8d 1c 07	 lea	 ebx, DWORD PTR [edi+eax]
  000c0	56		 push	 esi
  000c1	51		 push	 ecx
  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000c7	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex

; 52   : 	g_CastleSiege.NotifyCrownSwitchInfo(iIndex);

  000cc	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000cf	8b f0		 mov	 esi, eax
  000d1	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000d7	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000dd	52		 push	 edx
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000e3	e8 00 00 00 00	 call	 ?NotifyCrownSwitchInfo@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifyCrownSwitchInfo

; 53   : 
; 54   : 	if ( lpUserObj->MapNumber == MAP_INDEX_CASTLESIEGE &&
; 55   : 		 lpUserObj->m_btCsJoinSide >= 2 )

  000e8	80 be 49 01 00
	00 1e		 cmp	 BYTE PTR [esi+329], 30	; 0000001eH
  000ef	0f 85 5a 01 00
	00		 jne	 $LN9@CastleCrow
  000f5	80 be 02 1c 00
	00 02		 cmp	 BYTE PTR [esi+7170], 2
  000fc	0f 82 4d 01 00
	00		 jb	 $LN9@CastleCrow

; 56   : 	{
; 57   : 		if ( abs(lpObj->Y - lpUserObj->Y) <= 3 &&
; 58   : 			 abs(lpObj->X - lpUserObj->X) <= 3 )

  00102	0f bf 8e 46 01
	00 00		 movsx	 ecx, WORD PTR [esi+326]
  00109	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  00110	2b c1		 sub	 eax, ecx
  00112	99		 cdq
  00113	33 c2		 xor	 eax, edx
  00115	2b c2		 sub	 eax, edx
  00117	83 f8 03	 cmp	 eax, 3
  0011a	0f 8f b1 00 00
	00		 jg	 $LN8@CastleCrow
  00120	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  00127	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  0012e	2b c2		 sub	 eax, edx
  00130	99		 cdq
  00131	33 c2		 xor	 eax, edx
  00133	2b c2		 sub	 eax, edx
  00135	83 f8 03	 cmp	 eax, 3
  00138	0f 8f 93 00 00
	00		 jg	 $LN8@CastleCrow

; 59   : 		{
; 60   : 			int iCrownIndex1 = g_CastleSiege.GetCrownSwitchUserIndex(217);

  0013e	68 d9 00 00 00	 push	 217			; 000000d9H
  00143	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00148	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex

; 61   : 			int iCrownIndex2 = g_CastleSiege.GetCrownSwitchUserIndex(218);

  0014d	68 da 00 00 00	 push	 218			; 000000daH
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00157	8b f0		 mov	 esi, eax
  00159	e8 00 00 00 00	 call	 ?GetCrownSwitchUserIndex@CCastleSiege@@QAEHH@Z ; CCastleSiege::GetCrownSwitchUserIndex

; 62   : 
; 63   : 			if (gObjIsConnected(iCrownIndex1) && gObjIsConnected(iCrownIndex2) )

  0015e	56		 push	 esi
  0015f	8b f8		 mov	 edi, eax
  00161	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00166	83 c4 04	 add	 esp, 4
  00169	85 c0		 test	 eax, eax
  0016b	0f 84 27 01 00
	00		 je	 $LN35@CastleCrow
  00171	57		 push	 edi
  00172	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00177	83 c4 04	 add	 esp, 4
  0017a	85 c0		 test	 eax, eax
  0017c	0f 84 16 01 00
	00		 je	 $LN35@CastleCrow

; 64   : 			{
; 65   : 				if ( gObj[iCrownIndex1].m_btCsJoinSide == gObj[iCrownIndex2].m_btCsJoinSide )

  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00187	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0018d	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00193	8a 8c 06 02 1c
	00 00		 mov	 cl, BYTE PTR [esi+eax+7170]
  0019a	3a 8c 07 02 1c
	00 00		 cmp	 cl, BYTE PTR [edi+eax+7170]
  001a1	0f 85 f1 00 00
	00		 jne	 $LN35@CastleCrow

; 66   : 				{
; 67   : 					if ( g_CastleSiege.GetRegCrownAvailable() == 0 )

  001a7	83 3d e8 01 00
	00 00		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 0
  001ae	0f 85 e4 00 00
	00		 jne	 $LN35@CastleCrow

; 68   : 					{
; 69   : 						g_CastleSiege.SetRegCrownAvailable(TRUE);
; 70   : 						g_CastleSiege.NotifyCrownState(0);

  001b4	6a 00		 push	 0

; 97   : 		{
; 98   : 			g_CastleSiege.SetRegCrownAvailable(FALSE);
; 99   : 			g_CastleSiege.NotifyCrownState(1);

  001b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  001bb	c7 05 e8 01 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 1
  001c5	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
  001ca	5e		 pop	 esi
  001cb	5b		 pop	 ebx
  001cc	5f		 pop	 edi

; 100  : 		}
; 101  : 	}
; 102  : }

  001cd	5d		 pop	 ebp
  001ce	c2 04 00	 ret	 4
$LN8@CastleCrow:

; 71   : 					}
; 72   : 				}
; 73   : 			}
; 74   : 		}
; 75   : 		else
; 76   : 		{
; 77   : 			GCAnsCsAccessSwitchState(lpUserObj->m_Index, lpObj->m_Index, -1, 0);

  001d1	8b 13		 mov	 edx, DWORD PTR [ebx]
  001d3	8b 06		 mov	 eax, DWORD PTR [esi]
  001d5	6a 00		 push	 0
  001d7	6a ff		 push	 -1
  001d9	52		 push	 edx
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ?GCAnsCsAccessSwitchState@@YAXHHHE@Z ; GCAnsCsAccessSwitchState

; 78   : 			g_CastleSiege.ResetCrownSwitchUserIndex(gObj[iIndex].Class);

  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e6	0f b7 94 0f b8
	00 00 00	 movzx	 edx, WORD PTR [edi+ecx+184]
  001ee	83 c4 10	 add	 esp, 16			; 00000010H
  001f1	52		 push	 edx
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  001f7	e8 00 00 00 00	 call	 ?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::ResetCrownSwitchUserIndex

; 79   : 
; 80   : 			if ( g_CastleSiege.GetRegCrownAvailable() == 1 )

  001fc	83 3d e8 01 00
	00 01		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 1
  00203	75 16		 jne	 SHORT $LN3@CastleCrow

; 81   : 			{
; 82   : 				g_CastleSiege.SetRegCrownAvailable(FALSE);
; 83   : 				g_CastleSiege.NotifyCrownState(1);

  00205	6a 01		 push	 1
  00207	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0020c	c7 05 e8 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 0
  00216	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
$LN3@CastleCrow:

; 84   : 			}
; 85   : 
; 86   : 			LogAddTD("[CastleSiege] [%s][%s] Push Castle Crown Switch Canceled (GUILD:%s) - CS X:%d/Y:%d",
; 87   : 				lpUserObj->AccountID, lpUserObj->Name, lpUserObj->GuildName, lpObj->X, lpObj->Y);

  0021b	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  00222	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00229	50		 push	 eax
  0022a	51		 push	 ecx
  0022b	8d 96 3c 04 00
	00		 lea	 edx, DWORD PTR [esi+1084]
  00231	52		 push	 edx
  00232	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00235	50		 push	 eax
  00236	83 c6 6c	 add	 esi, 108		; 0000006cH
  00239	56		 push	 esi
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@POFOJJJE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Push?5Cast@
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00245	83 c4 18	 add	 esp, 24			; 00000018H
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	5f		 pop	 edi

; 100  : 		}
; 101  : 	}
; 102  : }

  0024b	5d		 pop	 ebp
  0024c	c2 04 00	 ret	 4
$LN9@CastleCrow:

; 88   : 		}
; 89   : 	}
; 90   : 	else
; 91   : 	{
; 92   : 		GCAnsCsAccessSwitchState(lpUserObj->m_Index, lpObj->m_Index, -1, 0);

  0024f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00251	8b 16		 mov	 edx, DWORD PTR [esi]
  00253	6a 00		 push	 0
  00255	6a ff		 push	 -1
  00257	51		 push	 ecx
  00258	52		 push	 edx
  00259	e8 00 00 00 00	 call	 ?GCAnsCsAccessSwitchState@@YAXHHHE@Z ; GCAnsCsAccessSwitchState

; 93   : 
; 94   : 		g_CastleSiege.ResetCrownSwitchUserIndex(gObj[iIndex].Class);

  0025e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00263	0f b7 8c 07 b8
	00 00 00	 movzx	 ecx, WORD PTR [edi+eax+184]
  0026b	83 c4 10	 add	 esp, 16			; 00000010H
  0026e	51		 push	 ecx
  0026f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00274	e8 00 00 00 00	 call	 ?ResetCrownSwitchUserIndex@CCastleSiege@@QAEXH@Z ; CCastleSiege::ResetCrownSwitchUserIndex

; 95   : 
; 96   : 		if ( g_CastleSiege.GetRegCrownAvailable() == 1 )

  00279	83 3d e8 01 00
	00 01		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 1
  00280	75 16		 jne	 SHORT $LN35@CastleCrow

; 97   : 		{
; 98   : 			g_CastleSiege.SetRegCrownAvailable(FALSE);
; 99   : 			g_CastleSiege.NotifyCrownState(1);

  00282	6a 01		 push	 1
  00284	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00289	c7 05 e8 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+488, 0
  00293	e8 00 00 00 00	 call	 ?NotifyCrownState@CCastleSiege@@QAEXE@Z ; CCastleSiege::NotifyCrownState
$LN35@CastleCrow:
  00298	5e		 pop	 esi
  00299	5b		 pop	 ebx
$LN12@CastleCrow:
  0029a	5f		 pop	 edi

; 100  : 		}
; 101  : 	}
; 102  : }

  0029b	5d		 pop	 ebp
  0029c	c2 04 00	 ret	 4
?CastleCrownSwitchAct@CCastleCrownSwitch@@QAEXH@Z ENDP	; CCastleCrownSwitch::CastleCrownSwitchAct
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCCastleCrownSwitch@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCCastleCrownSwitch@@UAEPAXI@Z PROC			; CCastleCrownSwitch::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CCastleCrownSwitch@@UAE@XZ ; CCastleCrownSwitch::~CCastleCrownSwitch
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCCastleCrownSwitch@@UAEPAXI@Z ENDP			; CCastleCrownSwitch::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ
text$yc	SEGMENT
??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ PROC		; `dynamic initializer for 'g_CsNPC_CastleCrownSwitch'', COMDAT

; 13   : CCastleCrownSwitch g_CsNPC_CastleCrownSwitch;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A ; g_CsNPC_CastleCrownSwitch
  00005	e8 00 00 00 00	 call	 ??0CCastleCrownSwitch@@QAE@XZ ; CCastleCrownSwitch::CCastleCrownSwitch
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ ; `dynamic atexit destructor for 'g_CsNPC_CastleCrownSwitch''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ ENDP		; `dynamic initializer for 'g_CsNPC_CastleCrownSwitch''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ
text$yd	SEGMENT
??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ PROC		; `dynamic atexit destructor for 'g_CsNPC_CastleCrownSwitch'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A ; g_CsNPC_CastleCrownSwitch
  00005	e9 00 00 00 00	 jmp	 ??1CCastleCrownSwitch@@UAE@XZ ; CCastleCrownSwitch::~CCastleCrownSwitch
??__Fg_CsNPC_CastleCrownSwitch@@YAXXZ ENDP		; `dynamic atexit destructor for 'g_CsNPC_CastleCrownSwitch''
text$yd	ENDS
PUBLIC	?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A ; g_CsNPC_CastleCrownSwitch
_BSS	SEGMENT
?g_CsNPC_CastleCrownSwitch@@3VCCastleCrownSwitch@@A DD 01H DUP (?) ; g_CsNPC_CastleCrownSwitch
_BSS	ENDS
CRT$XCU	SEGMENT
_g_CsNPC_CastleCrownSwitch$initializer$ DD FLAT:??__Eg_CsNPC_CastleCrownSwitch@@YAXXZ
CRT$XCU	ENDS
END
