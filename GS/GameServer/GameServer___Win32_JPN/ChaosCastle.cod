; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\ChaosCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_iChaosCastle_OffLineGiftRate@@3HA		; g_iChaosCastle_OffLineGiftRate
CONST	SEGMENT
_g_btCastleSafetyZoneMapXY DB 017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
	DB	017H
	DB	04bH
	DB	02cH
	DB	06cH
_g_btCastleCenterHollowZoneMapXY DB 020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
	DB	020H
	DB	054H
	DB	023H
	DB	057H
	DB	020H
	DB	060H
	DB	023H
	DB	063H
_g_iChaosCastle_ExpTable DD 01388H
	DD	03e8H
	DD	03e8H
	DD	05dcH
	DD	05dcH
	DD	07d0H
	DD	07d0H
	DD	09c4H
	DD	09c4H
	DD	0bb8H
	DD	0bb8H
	DD	0dacH
	DD	0fa0H
	DD	01388H
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
?g_iChaosCastle_OffLineGiftRate@@3HA DD 02H		; g_iChaosCastle_OffLineGiftRate
_DATA	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0_MONSTER_ITEM_DROP@@QAE@XZ			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.h
;	COMDAT ??0_MONSTER_ITEM_DROP@@QAE@XZ
_TEXT	SEGMENT
??0_MONSTER_ITEM_DROP@@QAE@XZ PROC			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP, COMDAT
; _this$ = ecx

; 141  : 	_MONSTER_ITEM_DROP()	// line : 229

  00000	8b c1		 mov	 eax, ecx

; 142  : 	{
; 143  : 		this->m_iIndex = -1;

  00002	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 144  : 		this->m_iItemKind = -1;

  00008	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 145  : 	};	// line : 232

  0000f	c3		 ret	 0
??0_MONSTER_ITEM_DROP@@QAE@XZ ENDP			; _MONSTER_ITEM_DROP::_MONSTER_ITEM_DROP
_TEXT	ENDS
PUBLIC	?Clear@_CHAOSCASTLE_USER@@QAEXXZ		; _CHAOSCASTLE_USER::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@_CHAOSCASTLE_USER@@QAEXXZ
_TEXT	SEGMENT
?Clear@_CHAOSCASTLE_USER@@QAEXXZ PROC			; _CHAOSCASTLE_USER::Clear, COMDAT
; _this$ = ecx

; 164  : 		this->m_iIndex = -1;
; 165  : 		this->m_iEXP = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 166  : 		this->m_iScore = 0;

  0000b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 167  : 		this->m_iUserState = 0;

  0000e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 168  : 		this->m_bSendQuitMsg = false;

  00011	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 169  : 	};	// line : 348

  00014	c3		 ret	 0
?Clear@_CHAOSCASTLE_USER@@QAEXXZ ENDP			; _CHAOSCASTLE_USER::Clear
_TEXT	ENDS
PUBLIC	?Clear@CHAOSCASTLE_REWARD@@QAEXXZ		; CHAOSCASTLE_REWARD::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CHAOSCASTLE_REWARD@@QAEXXZ
_TEXT	SEGMENT
?Clear@CHAOSCASTLE_REWARD@@QAEXXZ PROC			; CHAOSCASTLE_REWARD::Clear, COMDAT
; _this$ = ecx

; 250  : 			this->AncientRate	= 0;

  00000	33 c0		 xor	 eax, eax
  00002	89 01		 mov	 DWORD PTR [ecx], eax

; 251  : 			this->AncientCount	= 0;

  00004	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 252  : 			this->ItemCount		= 0;
; 253  : 			this->ItemID		= -1;

  00008	c7 41 06 ff ff
	ff ff		 mov	 DWORD PTR [ecx+6], -1

; 254  : 			this->ItemIndex		= -1;
; 255  : 			this->ItemLevel		= 0;

  0000f	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 256  : 		};

  00013	c3		 ret	 0
?Clear@CHAOSCASTLE_REWARD@@QAEXXZ ENDP			; CHAOSCASTLE_REWARD::Clear
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?ProcState_None@CChaosCastle@@IAEXH@Z		; CChaosCastle::ProcState_None
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
;	COMDAT ?ProcState_None@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_None@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_None, COMDAT
; _this$ = ecx

; 386  : 	return;
; 387  : }

  00000	c2 04 00	 ret	 4
?ProcState_None@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_None
_TEXT	ENDS
PUBLIC	?SetState_None@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_None
; Function compile flags: /Ogtp
;	COMDAT ?SetState_None@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?SetState_None@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_None, COMDAT
; _this$ = ecx

; 966  : 	return;
; 967  : }

  00000	c2 04 00	 ret	 4
?SetState_None@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_None
_TEXT	ENDS
PUBLIC	?AddMonsterList@CChaosCastle@@QAEXHH@Z		; CChaosCastle::AddMonsterList
EXTRN	__imp__InterlockedExchange@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?AddMonsterList@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
?AddMonsterList@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::AddMonsterList, COMDAT
; _this$ = ecx

; 1141 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1142 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 4a		 js	 SHORT $LN2@AddMonster
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 06	 cmp	 esi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 3e		 je	 SHORT $LN2@AddMonster

; 1143 : 	{
; 1144 : 		return;
; 1145 : 	}
; 1146 : 
; 1147 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  00017	8b d6		 mov	 edx, esi
  00019	33 c0		 xor	 eax, eax
  0001b	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  00021	8d 94 0a e4 05
	00 00		 lea	 edx, DWORD PTR [edx+ecx+1508]
$LL4@AddMonster:

; 1148 : 	{
; 1149 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  00028	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0002b	74 0e		 je	 SHORT $LN11@AddMonster

; 1143 : 	{
; 1144 : 		return;
; 1145 : 	}
; 1146 : 
; 1147 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  0002d	40		 inc	 eax
  0002e	83 c2 04	 add	 edx, 4
  00031	83 f8 64	 cmp	 eax, 100		; 00000064H
  00034	7c f2		 jl	 SHORT $LL4@AddMonster
  00036	5e		 pop	 esi

; 1152 : 			break;
; 1153 : 		}
; 1154 : 	}
; 1155 : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN11@AddMonster:

; 1150 : 		{
; 1151 : 			InterlockedExchange((LPLONG)&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON], iMonsterIndex);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  0003e	69 f6 1c 02 00
	00		 imul	 esi, 540		; 0000021cH
  00044	03 f0		 add	 esi, eax
  00046	52		 push	 edx
  00047	8d 84 b1 e4 05
	00 00		 lea	 eax, DWORD PTR [ecx+esi*4+1508]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8
$LN2@AddMonster:
  00055	5e		 pop	 esi

; 1152 : 			break;
; 1153 : 		}
; 1154 : 	}
; 1155 : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?AddMonsterList@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::AddMonsterList
_TEXT	ENDS
PUBLIC	??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ ; `string'
PUBLIC	??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ ; `string'
PUBLIC	?DelMonsterList@CChaosCastle@@QAEXHH@Z		; CChaosCastle::DelMonsterList
EXTRN	__imp__InterlockedDecrement@4:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
CONST	SEGMENT
??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ DB '['
	DB	'Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : OUT - '
	DB	'Index(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
CONST	SEGMENT
??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@ DB '['
	DB	'Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : ENTER '
	DB	'- Index(%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DelMonsterList@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv200 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
?DelMonsterList@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::DelMonsterList, COMDAT
; _this$ = ecx

; 1158 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1159 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 f6		 test	 esi, esi
  0000d	0f 88 9b 00 00
	00		 js	 $LN7@DelMonster
  00013	33 c0		 xor	 eax, eax
  00015	83 fe 06	 cmp	 esi, 6
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 8b 00 00
	00		 je	 $LN7@DelMonster

; 1160 : 	{
; 1161 : 		return;
; 1162 : 	}
; 1163 : 
; 1164 : 	LogAddTD("[Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : ENTER - Index(%d)",
; 1165 : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT, iMonsterIndex);

  00023	53		 push	 ebx
  00024	57		 push	 edi
  00025	8b fe		 mov	 edi, esi
  00027	69 ff 70 08 00
	00		 imul	 edi, 2160		; 00000870H
  0002d	03 f9		 add	 edi, ecx
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _iMonsterIndex$[ebp]
  00032	8b 57 60	 mov	 edx, DWORD PTR [edi+96]
  00035	51		 push	 ecx
  00036	8d 5f 60	 lea	 ebx, DWORD PTR [edi+96]
  00039	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0003c	52		 push	 edx
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BMJDNMGE@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
  00043	89 45 08	 mov	 DWORD PTR tv200[ebp], eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 1166 : 
; 1167 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  0004f	33 c0		 xor	 eax, eax
  00051	8d 8f e4 05 00
	00		 lea	 ecx, DWORD PTR [edi+1508]
$LL5@DelMonster:

; 1168 : 	{
; 1169 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == iMonsterIndex )

  00057	8b 7d 0c	 mov	 edi, DWORD PTR _iMonsterIndex$[ebp]
  0005a	39 39		 cmp	 DWORD PTR [ecx], edi
  0005c	74 0b		 je	 SHORT $LN12@DelMonster

; 1166 : 
; 1167 : 	for ( int iMON =0;iMON<MAX_CC_MONSTERS;iMON++)

  0005e	40		 inc	 eax
  0005f	83 c1 04	 add	 ecx, 4
  00062	83 f8 64	 cmp	 eax, 100		; 00000064H
  00065	7c f0		 jl	 SHORT $LL5@DelMonster

; 1168 : 	{
; 1169 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == iMonsterIndex )

  00067	eb 1b		 jmp	 SHORT $LN3@DelMonster
$LN12@DelMonster:

; 1170 : 		{
; 1171 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON], -1);

  00069	69 f6 1c 02 00
	00		 imul	 esi, 540		; 0000021cH
  0006f	03 f0		 add	 esi, eax
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	6a ff		 push	 -1
  00076	8d 8c b0 e4 05
	00 00		 lea	 ecx, DWORD PTR [eax+esi*4+1508]
  0007d	51		 push	 ecx
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8
$LN3@DelMonster:

; 1172 : 			break;
; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	InterlockedDecrement(&this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  00084	53		 push	 ebx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 1177 : 
; 1178 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT < 0 )

  0008b	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0008e	7d 06		 jge	 SHORT $LN1@DelMonster

; 1179 : 	{
; 1180 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT = 0;

  00090	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN1@DelMonster:

; 1181 : 	}
; 1182 : 
; 1183 : 	LogAddTD("[Chaos Castle][Bug Tracer] MONSTER DEL (%d) Count(%d) : OUT - Index(%d)",
; 1184 : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT, iMonsterIndex);

  00096	8b 13		 mov	 edx, DWORD PTR [ebx]
  00098	8b 45 08	 mov	 eax, DWORD PTR tv200[ebp]
  0009b	57		 push	 edi
  0009c	52		 push	 edx
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EFJJJNMJ@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5MONST@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a9	83 c4 10	 add	 esp, 16			; 00000010H
  000ac	5f		 pop	 edi
  000ad	5b		 pop	 ebx
$LN7@DelMonster:
  000ae	5e		 pop	 esi

; 1185 : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8
?DelMonsterList@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::DelMonsterList
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?GetMonsterListCount@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetMonsterListCount
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetMonsterListCount@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetMonsterListCount@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetMonsterListCount, COMDAT
; _this$ = ecx

; 1188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1189 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN22@GetMonster
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN9@GetMonster
$LN22@GetMonster:

; 1190 : 	{
; 1191 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 1224 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN9@GetMonster:

; 1192 : 	}
; 1193 : 
; 1194 : 	int iAliveMonsterCount = 0;

  0001d	d9 ee		 fldz
  0001f	33 d2		 xor	 edx, edx
  00021	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00027	53		 push	 ebx
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8d b4 08 e4 05
	00 00		 lea	 esi, DWORD PTR [eax+ecx+1508]
  00031	8d 7a 64	 lea	 edi, DWORD PTR [edx+100]
$LN26@GetMonster:

; 1197 : 	{
; 1198 : 		if(this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] == -1)

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	83 f8 ff	 cmp	 eax, -1
  00039	74 55		 je	 SHORT $LN7@GetMonster

; 1199 : 		{
; 1200 : 			continue;
; 1201 : 		}
; 1202 : 
; 1203 : 		int CC_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i]; //loc4
; 1204 : 					
; 1205 : 		if ( ((CC_MONSTER_COUNT<0)?FALSE:(CC_MONSTER_COUNT>OBJ_MAXMONSTER-1)?FALSE:TRUE) == FALSE ) 

  0003b	85 c0		 test	 eax, eax
  0003d	78 0e		 js	 SHORT $LN23@GetMonster
  0003f	33 c9		 xor	 ecx, ecx
  00041	3d c7 32 00 00	 cmp	 eax, 12999		; 000032c7H
  00046	0f 9e c1	 setle	 cl
  00049	85 c9		 test	 ecx, ecx
  0004b	75 08		 jne	 SHORT $LN4@GetMonster
$LN23@GetMonster:

; 1206 : 		{
; 1207 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] = -1;

  0004d	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 1208 : 			continue;

  00053	eb 3b		 jmp	 SHORT $LN7@GetMonster
$LN4@GetMonster:

; 1209 : 		}
; 1210 : 
; 1211 : 		if(gObj[CC_MONSTER_COUNT].Life > 0.0f)

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00061	d8 94 01 fc 00
	00 00		 fcom	 DWORD PTR [ecx+eax+252]
  00068	03 c8		 add	 ecx, eax
  0006a	df e0		 fnstsw	 ax
  0006c	f6 c4 05	 test	 ah, 5
  0006f	7a 1f		 jp	 SHORT $LN7@GetMonster

; 1212 : 		{
; 1213 : 			if(CC_MAP_RANGE(gObj[CC_MONSTER_COUNT].MapNumber) != FALSE)

  00071	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  00078	3c 35		 cmp	 al, 53			; 00000035H
  0007a	74 0d		 je	 SHORT $LN24@GetMonster
  0007c	3c 12		 cmp	 al, 18			; 00000012H
  0007e	72 10		 jb	 SHORT $LN7@GetMonster
  00080	b3 17		 mov	 bl, 23			; 00000017H
  00082	3a d8		 cmp	 bl, al
  00084	1b c0		 sbb	 eax, eax
  00086	40		 inc	 eax
  00087	74 07		 je	 SHORT $LN7@GetMonster
$LN24@GetMonster:

; 1214 : 			{
; 1215 : 				if(gObj[CC_MONSTER_COUNT].Connected > 0)

  00089	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0008d	7e 01		 jle	 SHORT $LN7@GetMonster

; 1216 : 				{
; 1217 : 					iAliveMonsterCount++;

  0008f	42		 inc	 edx
$LN7@GetMonster:

; 1195 : 
; 1196 : 	for ( int i=0;i<MAX_CHAOSCASTLE_MONSTER;i++) //loc3

  00090	83 c6 04	 add	 esi, 4
  00093	4f		 dec	 edi
  00094	75 9e		 jne	 SHORT $LN26@GetMonster
  00096	5f		 pop	 edi
  00097	dd d8		 fstp	 ST(0)
  00099	5e		 pop	 esi

; 1218 : 				}
; 1219 : 			}
; 1220 : 		}
; 1221 : 	}
; 1222 : 	
; 1223 : 	return iAliveMonsterCount;

  0009a	8b c2		 mov	 eax, edx
  0009c	5b		 pop	 ebx

; 1224 : }

  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
?GetMonsterListCount@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetMonsterListCount
_TEXT	ENDS
PUBLIC	?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z	; CChaosCastle::SendAllUserAnyMsg
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z PROC	; CChaosCastle::SendAllUserAnyMsg, COMDAT
; _this$ = ecx

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1335 : 	for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00013	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL5@SendAllUse:

; 1336 : 	{
; 1337 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 1b		 jne	 SHORT $LN4@SendAllUse

; 1338 : 		{
; 1339 : 			if ( gObj[i].Type == OBJ_USER )

  0001f	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00025	75 13		 jne	 SHORT $LN4@SendAllUse

; 1340 : 			{
; 1341 : 				DataSend(i, lpMsg, iSize);

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002a	53		 push	 ebx
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendAllUse:

; 1335 : 	for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0003a	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00040	47		 inc	 edi
  00041	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00047	7c cf		 jl	 SHORT $LL5@SendAllUse
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1342 : 			}
; 1343 : 		}
; 1344 : 	}
; 1345 : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z ENDP	; CChaosCastle::SendAllUserAnyMsg
_TEXT	ENDS
PUBLIC	?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iChaosCastleIndex$ = 16				; size = 4
?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z PROC	; CChaosCastle::SendChaosCastleAnyMsg, COMDAT
; _this$ = ecx

; 1348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1349 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 10	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 75		 js	 SHORT $LN4@SendChaosC
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 69		 je	 SHORT $LN4@SendChaosC

; 1350 : 	{
; 1351 : 		return;
; 1352 : 	}
; 1353 : 
; 1354 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00016	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  00023	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  00028	83 cb ff	 or	 ebx, -1
  0002b	eb 03 8d 49 00	 npad	 5
$LL6@SendChaosC:

; 1355 : 	{
; 1356 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	3b c3		 cmp	 eax, ebx
  00034	74 40		 je	 SHORT $LN5@SendChaosC

; 1357 : 		{
; 1358 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) != FALSE )

  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	74 33		 je	 SHORT $LN5@SendChaosC

; 1359 : 			{
; 1360 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004b	8b c8		 mov	 ecx, eax
  0004d	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00053	38 9c 11 a5 0e
	00 00		 cmp	 BYTE PTR [ecx+edx+3749], bl
  0005a	74 1a		 je	 SHORT $LN5@SendChaosC
  0005c	38 9c 11 a6 0e
	00 00		 cmp	 BYTE PTR [ecx+edx+3750], bl
  00063	74 11		 je	 SHORT $LN5@SendChaosC

; 1361 : 				{
; 1362 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _iSize$[ebp]
  00068	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0006b	51		 push	 ecx
  0006c	52		 push	 edx
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendChaosC:

; 1350 : 	{
; 1351 : 		return;
; 1352 : 	}
; 1353 : 
; 1354 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00076	83 c6 14	 add	 esi, 20			; 00000014H
  00079	4f		 dec	 edi
  0007a	75 b4		 jne	 SHORT $LL6@SendChaosC
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
$LN4@SendChaosC:

; 1363 : 				}
; 1364 : 			}
; 1365 : 		}
; 1366 : 	}
; 1367 : }

  0007f	5d		 pop	 ebp
  00080	c2 0c 00	 ret	 12			; 0000000cH
?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ENDP	; CChaosCastle::SendChaosCastleAnyMsg
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z	; CChaosCastle::SendNoticeMessage
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z PROC	; CChaosCastle::SendNoticeMessage, COMDAT
; _this$ = ecx

; 1370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0001a	57		 push	 edi
  0001b	8b f9		 mov	 edi, ecx

; 1371 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0001d	85 f6		 test	 esi, esi
  0001f	78 7c		 js	 SHORT $LN4@SendNotice
  00021	33 c9		 xor	 ecx, ecx
  00023	83 fe 06	 cmp	 esi, 6
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	74 70		 je	 SHORT $LN4@SendNotice

; 1372 : 	{
; 1373 : 		return;
; 1374 : 	}
; 1375 : 
; 1376 : 	PMSG_NOTICE pNotice;
; 1377 : 	TNotice::MakeNoticeMsgEx((TNotice *)&pNotice, 0, lpszMSG);

  0002d	53		 push	 ebx
  0002e	50		 push	 eax
  0002f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00035	6a 00		 push	 0
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  0003d	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	8d 74 3e 6c	 lea	 esi, DWORD PTR [esi+edi+108]
  0004a	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  0004f	83 cb ff	 or	 ebx, -1
$LL6@SendNotice:

; 1380 : 	{
; 1381 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00052	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00054	3b cb		 cmp	 ecx, ebx
  00056	74 3e		 je	 SHORT $LN5@SendNotice

; 1382 : 		{
; 1383 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	8b d1		 mov	 edx, ecx
  0005f	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00065	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  0006a	7e 2a		 jle	 SHORT $LN5@SendNotice

; 1384 : 			{
; 1385 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  0006c	38 9c 10 a5 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3749], bl
  00073	74 21		 je	 SHORT $LN5@SendNotice
  00075	38 9c 10 a6 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3750], bl
  0007c	74 18		 je	 SHORT $LN5@SendNotice

; 1386 : 				{
; 1387 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  0007e	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  00085	52		 push	 edx
  00086	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0008c	50		 push	 eax
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendNotice:

; 1378 : 
; 1379 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00096	83 c6 14	 add	 esi, 20			; 00000014H
  00099	4f		 dec	 edi
  0009a	75 b6		 jne	 SHORT $LL6@SendNotice
  0009c	5b		 pop	 ebx
$LN4@SendNotice:

; 1388 : 				}
; 1389 : 			}
; 1390 : 		}
; 1391 : 	}
; 1392 : 
; 1393 : }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	5f		 pop	 edi
  000a1	33 cd		 xor	 ecx, ebp
  000a3	5e		 pop	 esi
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8
?SendNoticeMessage@CChaosCastle@@QAEXHPAD@Z ENDP	; CChaosCastle::SendNoticeMessage
_TEXT	ENDS
PUBLIC	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z	; CChaosCastle::EnterUserChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iRET_VAL$ = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::EnterUserChaosCastle, COMDAT
; _this$ = ecx

; 1515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1516 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 0c		 js	 SHORT $LN17@EnterUserC
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 06	 cmp	 esi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	75 08		 jne	 SHORT $LN8@EnterUserC
$LN17@EnterUserC:

; 1517 : 	{
; 1518 : 		return -1;

  00017	83 c8 ff	 or	 eax, -1
  0001a	5e		 pop	 esi

; 1547 : 			}
; 1548 : 
; 1549 : 			break;
; 1550 : 		}
; 1551 : 	}
; 1552 : 
; 1553 : 	return iRET_VAL;
; 1554 : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
$LN8@EnterUserC:
  0001f	53		 push	 ebx
  00020	57		 push	 edi

; 1519 : 	}
; 1520 : 
; 1521 : 	int iRET_VAL = -1;

  00021	8b fe		 mov	 edi, esi
  00023	69 ff 70 08 00
	00		 imul	 edi, 2160		; 00000870H

; 1522 : 
; 1523 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00029	33 d2		 xor	 edx, edx
  0002b	03 f9		 add	 edi, ecx
  0002d	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1
  00034	8d 5f 6c	 lea	 ebx, DWORD PTR [edi+108]
$LL18@EnterUserC:

; 1524 : 	{
; 1525 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00037	8b 03		 mov	 eax, DWORD PTR [ebx]
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	74 21		 je	 SHORT $LN15@EnterUserC

; 1526 : 		{
; 1527 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  0003e	3b 45 0c	 cmp	 eax, DWORD PTR _iUserIndex$[ebp]
  00041	74 13		 je	 SHORT $LN14@EnterUserC

; 1522 : 
; 1523 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00043	42		 inc	 edx
  00044	83 c3 14	 add	 ebx, 20			; 00000014H
  00047	83 fa 46	 cmp	 edx, 70			; 00000046H
  0004a	7c eb		 jl	 SHORT $LL18@EnterUserC

; 1530 : 				break;
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == -1 )

  0004c	8b 45 08	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  0004f	5f		 pop	 edi
  00050	5b		 pop	 ebx
  00051	5e		 pop	 esi

; 1547 : 			}
; 1548 : 
; 1549 : 			break;
; 1550 : 		}
; 1551 : 	}
; 1552 : 
; 1553 : 	return iRET_VAL;
; 1554 : }

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN14@EnterUserC:
  00056	5f		 pop	 edi
  00057	5b		 pop	 ebx

; 1528 : 			{
; 1529 : 				iRET_VAL = i;

  00058	8b c2		 mov	 eax, edx
  0005a	5e		 pop	 esi

; 1547 : 			}
; 1548 : 
; 1549 : 			break;
; 1550 : 		}
; 1551 : 	}
; 1552 : 
; 1553 : 	return iRET_VAL;
; 1554 : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN15@EnterUserC:

; 1535 : 		{
; 1536 : 			iRET_VAL = i;
; 1537 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex = iUserIndex;

  0005f	8b 5d 0c	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  00062	6b f6 6c	 imul	 esi, 108		; 0000006cH
  00065	8b c2		 mov	 eax, edx
  00067	03 d6		 add	 edx, esi
  00069	8d 34 92	 lea	 esi, DWORD PTR [edx+edx*4]
  0006c	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  0006f	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx

; 1538 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iEXP = 0;

  00072	33 db		 xor	 ebx, ebx

; 1539 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iScore = 0;
; 1540 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState = 0;

  00074	8d 54 92 1e	 lea	 edx, DWORD PTR [edx+edx*4+30]
  00078	89 1c 91	 mov	 DWORD PTR [ecx+edx*4], ebx
  0007b	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  0007e	89 5e 74	 mov	 DWORD PTR [esi+116], ebx

; 1541 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = false;

  00081	88 5e 7c	 mov	 BYTE PTR [esi+124], bl

; 1542 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER++;

  00084	ff 47 54	 inc	 DWORD PTR [edi+84]

; 1543 : 	
; 1544 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER > MAX_CHAOSCASTLE_USER)

  00087	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  0008c	39 4f 54	 cmp	 DWORD PTR [edi+84], ecx
  0008f	7e 03		 jle	 SHORT $LN1@EnterUserC

; 1545 : 			{
; 1546 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = MAX_CHAOSCASTLE_USER;

  00091	89 4f 54	 mov	 DWORD PTR [edi+84], ecx
$LN1@EnterUserC:
  00094	5f		 pop	 edi
  00095	5b		 pop	 ebx
  00096	5e		 pop	 esi

; 1547 : 			}
; 1548 : 
; 1549 : 			break;
; 1550 : 		}
; 1551 : 	}
; 1552 : 
; 1553 : 	return iRET_VAL;
; 1554 : }

  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::EnterUserChaosCastle
_TEXT	ENDS
PUBLIC	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z	; CChaosCastle::LeaveUserChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iRET_VAL$ = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::LeaveUserChaosCastle, COMDAT
; _this$ = ecx

; 1557 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1558 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN14@LeaveUserC
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 06	 cmp	 edx, 6
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	75 07		 jne	 SHORT $LN6@LeaveUserC
$LN14@LeaveUserC:

; 1559 : 	{
; 1560 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 1580 : 			}
; 1581 : 
; 1582 : 			break;
; 1583 : 		}
; 1584 : 	}
; 1585 : 
; 1586 : 	return iRET_VAL;
; 1587 : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN6@LeaveUserC:
  0001d	53		 push	 ebx

; 1561 : 	}
; 1562 : 
; 1563 : 	int iRET_VAL = -1;

  0001e	8b 5d 0c	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	8b fa		 mov	 edi, edx
  00025	69 ff 70 08 00
	00		 imul	 edi, 2160		; 00000870H

; 1564 : 
; 1565 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0002b	33 f6		 xor	 esi, esi
  0002d	03 f9		 add	 edi, ecx
  0002f	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1
  00036	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL5@LeaveUserC:

; 1566 : 	{
; 1567 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  00040	39 18		 cmp	 DWORD PTR [eax], ebx
  00042	74 13		 je	 SHORT $LN12@LeaveUserC

; 1564 : 
; 1565 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00044	46		 inc	 esi
  00045	83 c0 14	 add	 eax, 20			; 00000014H
  00048	83 fe 46	 cmp	 esi, 70			; 00000046H
  0004b	7c f3		 jl	 SHORT $LL5@LeaveUserC

; 1566 : 	{
; 1567 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == iUserIndex )

  0004d	8b 45 08	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 1580 : 			}
; 1581 : 
; 1582 : 			break;
; 1583 : 		}
; 1584 : 	}
; 1585 : 
; 1586 : 	return iRET_VAL;
; 1587 : }

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
$LN12@LeaveUserC:

; 1568 : 		{
; 1569 : 			iRET_VAL = iUserIndex;
; 1570 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex = -1;

  00057	6b d2 6c	 imul	 edx, 108		; 0000006cH
  0005a	03 d6		 add	 edx, esi
  0005c	8d 34 92	 lea	 esi, DWORD PTR [edx+edx*4]
  0005f	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  00062	8b c3		 mov	 eax, ebx

; 1571 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iEXP = 0;

  00064	33 db		 xor	 ebx, ebx

; 1572 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iScore = 0;
; 1573 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState = 0;

  00066	8d 54 92 1e	 lea	 edx, DWORD PTR [edx+edx*4+30]
  0006a	c7 46 6c ff ff
	ff ff		 mov	 DWORD PTR [esi+108], -1
  00071	89 5e 70	 mov	 DWORD PTR [esi+112], ebx
  00074	89 5e 74	 mov	 DWORD PTR [esi+116], ebx
  00077	89 1c 91	 mov	 DWORD PTR [ecx+edx*4], ebx

; 1574 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = false;

  0007a	88 5e 7c	 mov	 BYTE PTR [esi+124], bl

; 1575 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER--;

  0007d	ff 4f 54	 dec	 DWORD PTR [edi+84]

; 1576 : 	
; 1577 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER < 0)

  00080	79 03		 jns	 SHORT $LN1@LeaveUserC

; 1578 : 			{
; 1579 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = 0;

  00082	89 5f 54	 mov	 DWORD PTR [edi+84], ebx
$LN1@LeaveUserC:
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 1580 : 			}
; 1581 : 
; 1582 : 			break;
; 1583 : 		}
; 1584 : 	}
; 1585 : 
; 1586 : 	return iRET_VAL;
; 1587 : }

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::LeaveUserChaosCastle
_TEXT	ENDS
PUBLIC	?AddFallUser@CChaosCastle@@QAEXHH@Z		; CChaosCastle::AddFallUser
; Function compile flags: /Ogtp
;	COMDAT ?AddFallUser@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?AddFallUser@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::AddFallUser, COMDAT
; _this$ = ecx

; 1590 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1591 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 4a		 js	 SHORT $LN2@AddFallUse
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 06	 cmp	 esi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 3e		 je	 SHORT $LN2@AddFallUse

; 1592 : 	{
; 1593 : 		return;
; 1594 : 	}
; 1595 : 
; 1596 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  00017	8b d6		 mov	 edx, esi
  00019	33 c0		 xor	 eax, eax
  0001b	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  00021	8d 94 0a 74 07
	00 00		 lea	 edx, DWORD PTR [edx+ecx+1908]
$LL4@AddFallUse:

; 1597 : 	{
; 1598 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL] == -1 )

  00028	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0002b	74 0e		 je	 SHORT $LN11@AddFallUse

; 1592 : 	{
; 1593 : 		return;
; 1594 : 	}
; 1595 : 
; 1596 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  0002d	40		 inc	 eax
  0002e	83 c2 04	 add	 edx, 4
  00031	83 f8 46	 cmp	 eax, 70			; 00000046H
  00034	7c f2		 jl	 SHORT $LL4@AddFallUse
  00036	5e		 pop	 esi

; 1601 : 			break;
; 1602 : 		}
; 1603 : 	}
; 1604 : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN11@AddFallUse:

; 1599 : 		{
; 1600 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL], iUserIndex);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _iUserIndex$[ebp]
  0003e	69 f6 1c 02 00
	00		 imul	 esi, 540		; 0000021cH
  00044	03 f0		 add	 esi, eax
  00046	52		 push	 edx
  00047	8d 84 b1 74 07
	00 00		 lea	 eax, DWORD PTR [ecx+esi*4+1908]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8
$LN2@AddFallUse:
  00055	5e		 pop	 esi

; 1601 : 			break;
; 1602 : 		}
; 1603 : 	}
; 1604 : }

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?AddFallUser@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::AddFallUser
_TEXT	ENDS
PUBLIC	?SetUserState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SetUserState
; Function compile flags: /Ogtp
;	COMDAT ?SetUserState@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iState$ = 12						; size = 4
?SetUserState@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SetUserState, COMDAT
; _this$ = ecx

; 1636 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1637 : 	if ( !OBJMAX_RANGE(iUserIndex))

  00003	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 c0		 test	 eax, eax
  0000b	0f 88 84 00 00
	00		 js	 $LN3@SetUserSta
  00011	33 d2		 xor	 edx, edx
  00013	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00018	0f 9e c2	 setle	 dl
  0001b	85 d2		 test	 edx, edx
  0001d	74 76		 je	 SHORT $LN3@SetUserSta

; 1638 : 		return;
; 1639 : 
; 1640 : 	int iChaosCastleIndex = gObj[iUserIndex].m_cChaosCastleIndex;

  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002b	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0002e	0f be 82 a5 0e
	00 00		 movsx	 eax, BYTE PTR [edx+3749]

; 1641 : 	int iChaosCastleSubIndex = gObj[iUserIndex].m_cChaosCastleSubIndex;

  00035	0f be 92 a6 0e
	00 00		 movsx	 edx, BYTE PTR [edx+3750]

; 1642 : 
; 1643 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003c	85 c0		 test	 eax, eax
  0003e	78 55		 js	 SHORT $LN3@SetUserSta
  00040	33 c9		 xor	 ecx, ecx
  00042	83 f8 06	 cmp	 eax, 6
  00045	0f 9e c1	 setle	 cl
  00048	56		 push	 esi
  00049	8b f1		 mov	 esi, ecx
  0004b	85 f6		 test	 esi, esi
  0004d	74 45		 je	 SHORT $LN16@SetUserSta

; 1644 : 		return;
; 1645 : 
; 1646 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  0004f	85 d2		 test	 edx, edx
  00051	78 41		 js	 SHORT $LN16@SetUserSta
  00053	33 c9		 xor	 ecx, ecx
  00055	83 fa 45	 cmp	 edx, 69			; 00000045H
  00058	0f 9e c1	 setle	 cl
  0005b	8b f1		 mov	 esi, ecx
  0005d	85 f6		 test	 esi, esi
  0005f	74 33		 je	 SHORT $LN16@SetUserSta

; 1647 : 		return;
; 1648 : 
; 1649 : 	switch ( iState )

  00061	8b 75 0c	 mov	 esi, DWORD PTR _iState$[ebp]
  00064	83 ee 00	 sub	 esi, 0
  00067	74 1a		 je	 SHORT $LN2@SetUserSta
  00069	4e		 dec	 esi
  0006a	75 28		 jne	 SHORT $LN16@SetUserSta

; 1653 : 			break;
; 1654 : 		case 1:
; 1655 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iUserState = 1;

  0006c	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0006f	8d 44 10 06	 lea	 eax, DWORD PTR [eax+edx+6]
  00073	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00076	5e		 pop	 esi
  00077	c7 04 97 01 00
	00 00		 mov	 DWORD PTR [edi+edx*4], 1
  0007e	5f		 pop	 edi

; 1656 : 	}
; 1657 : }

  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
$LN2@SetUserSta:

; 1650 : 	{
; 1651 : 		case 0:
; 1652 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iUserState = 0;

  00083	6b c0 6c	 imul	 eax, 108		; 0000006cH
  00086	8d 44 10 06	 lea	 eax, DWORD PTR [eax+edx+6]
  0008a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0008d	c7 04 87 00 00
	00 00		 mov	 DWORD PTR [edi+eax*4], 0
$LN16@SetUserSta:
  00094	5e		 pop	 esi
$LN3@SetUserSta:
  00095	5f		 pop	 edi

; 1656 : 	}
; 1657 : }

  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
?SetUserState@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SetUserState
_TEXT	ENDS
PUBLIC	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetUserLevelToEnter
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
; Function compile flags: /Ogtp
;	COMDAT ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iENTER_LEVEL$ = 8					; size = 4
_iUserIndex$ = 8					; size = 4
?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetUserLevelToEnter, COMDAT
; _this$ = ecx

; 1715 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1716 : 	if ( !gObjIsConnected(iUserIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 08		 jne	 SHORT $LN11@GetUserLev

; 1717 : 	{
; 1718 : 		return -1;

  00014	83 c8 ff	 or	 eax, -1
  00017	5e		 pop	 esi

; 1755 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN11@GetUserLev:

; 1719 : 	}
; 1720 : 
; 1721 : 	int iENTER_LEVEL = -1;
; 1722 : 
; 1723 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iUserIndex]) != FALSE) //Season3 add-on

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00027	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002a	51		 push	 ecx
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00030	c7 45 08 ff ff
	ff ff		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], -1
  00037	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  0003c	85 c0		 test	 eax, eax
  0003e	74 0f		 je	 SHORT $LN10@GetUserLev

; 1724 : 	{
; 1725 : 		iENTER_LEVEL = 6;

  00040	c7 45 08 06 00
	00 00		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], 6

; 1746 : 				{
; 1747 : 					iENTER_LEVEL = i;
; 1748 : 					break;
; 1749 : 				}
; 1750 : 			}
; 1751 : 		}
; 1752 : 	}	
; 1753 : 			 
; 1754 : 	return iENTER_LEVEL;

  00047	8b 45 08	 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  0004a	5e		 pop	 esi

; 1755 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN10@GetUserLev:

; 1726 : 	}
; 1727 : 	else
; 1728 : 	{
; 1729 : 		for(int i=0;i<MAX_CHAOSCASTLE_LEVEL-1;i++) //exclude last floor

  0004f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	53		 push	 ebx
  00056	0f b7 9c 16 b8
	00 00 00	 movzx	 ebx, WORD PTR [esi+edx+184]
  0005e	57		 push	 edi
  0005f	33 ff		 xor	 edi, edi
  00061	b8 04 00 00 00	 mov	 eax, OFFSET _g_sttCHAOSCASTLE_LEVEL+4
$LL8@GetUserLev:

; 1730 : 		{
; 1731 : 			if ( gObj[iUserIndex].Class == CLASS_DARKLORD 
; 1732 : #ifdef MONK
; 1733 : 				|| gObj[iUserIndex].Class == CLASS_MONK
; 1734 : #endif
; 1735 : 				|| gObj[iUserIndex].Class == CLASS_MAGUMSA )

  00066	83 fb 04	 cmp	 ebx, 4
  00069	74 1b		 je	 SHORT $LN4@GetUserLev
  0006b	83 fb 06	 cmp	 ebx, 6
  0006e	74 16		 je	 SHORT $LN4@GetUserLev
  00070	83 fb 03	 cmp	 ebx, 3
  00073	74 11		 je	 SHORT $LN4@GetUserLev

; 1740 : 					break;
; 1741 : 				}
; 1742 : 			}
; 1743 : 			else
; 1744 : 			{
; 1745 : 				if ( gObj[iUserIndex].Level >= g_sttCHAOSCASTLE_LEVEL[i].iLOWER_BOUND && gObj[iUserIndex].Level <= g_sttCHAOSCASTLE_LEVEL[i].iUPPER_BOUND )

  00075	0f bf 8c 16 be
	00 00 00	 movsx	 ecx, WORD PTR [esi+edx+190]
  0007d	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  00080	7c 16		 jl	 SHORT $LN7@GetUserLev
  00082	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00084	eb 10		 jmp	 SHORT $LN20@GetUserLev
$LN4@GetUserLev:

; 1736 : 			{
; 1737 : 				if ( gObj[iUserIndex].Level >= g_sttCHAOSCASTLE_LEVEL[i].iLOWER_BOUND_MAGUMSA && gObj[iUserIndex].Level <= g_sttCHAOSCASTLE_LEVEL[i].iUPPER_BOUND_MAGUMSA )

  00086	0f bf 8c 16 be
	00 00 00	 movsx	 ecx, WORD PTR [esi+edx+190]
  0008e	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00091	7c 05		 jl	 SHORT $LN7@GetUserLev
  00093	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
$LN20@GetUserLev:
  00096	7e 15		 jle	 SHORT $LN16@GetUserLev
$LN7@GetUserLev:

; 1726 : 	}
; 1727 : 	else
; 1728 : 	{
; 1729 : 		for(int i=0;i<MAX_CHAOSCASTLE_LEVEL-1;i++) //exclude last floor

  00098	83 c0 10	 add	 eax, 16			; 00000010H
  0009b	47		 inc	 edi
  0009c	3d 64 00 00 00	 cmp	 eax, OFFSET _g_sttCHAOSCASTLE_LEVEL+100
  000a1	7c c3		 jl	 SHORT $LL8@GetUserLev

; 1746 : 				{
; 1747 : 					iENTER_LEVEL = i;
; 1748 : 					break;
; 1749 : 				}
; 1750 : 			}
; 1751 : 		}
; 1752 : 	}	
; 1753 : 			 
; 1754 : 	return iENTER_LEVEL;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  000a6	5f		 pop	 edi
  000a7	5b		 pop	 ebx
  000a8	5e		 pop	 esi

; 1755 : }

  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
$LN16@GetUserLev:

; 1738 : 				{
; 1739 : 					iENTER_LEVEL = i;

  000ad	89 7d 08	 mov	 DWORD PTR _iENTER_LEVEL$[ebp], edi

; 1746 : 				{
; 1747 : 					iENTER_LEVEL = i;
; 1748 : 					break;
; 1749 : 				}
; 1750 : 			}
; 1751 : 		}
; 1752 : 	}	
; 1753 : 			 
; 1754 : 	return iENTER_LEVEL;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  000b3	5f		 pop	 edi
  000b4	5b		 pop	 ebx
  000b5	5e		 pop	 esi

; 1755 : }

  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetUserLevelToEnter
_TEXT	ENDS
PUBLIC	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z	; CChaosCastle::CheckUserEnterMoney
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iEnterLevel$ = 12					; size = 4
?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z PROC	; CChaosCastle::CheckUserEnterMoney, COMDAT
; _this$ = ecx

; 1758 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1759 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN10@CheckUserE
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN3@CheckUserE
$LN10@CheckUserE:

; 1760 : 	{
; 1761 : 		return FALSE;

  00018	33 c0		 xor	 eax, eax

; 1770 : 	{
; 1771 : 		return TRUE;
; 1772 : 	}
; 1773 : 
; 1774 : 	return FALSE;
; 1775 : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN3@CheckUserE:

; 1762 : 	}
; 1763 : 
; 1764 : 	if ( CC_FLOOR_RANGE(iEnterLevel) == FALSE )

  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _iEnterLevel$[ebp]
  00021	85 c9		 test	 ecx, ecx
  00023	78 f3		 js	 SHORT $LN10@CheckUserE
  00025	33 d2		 xor	 edx, edx
  00027	83 f9 06	 cmp	 ecx, 6
  0002a	0f 9e c2	 setle	 dl
  0002d	85 d2		 test	 edx, edx

; 1765 : 	{
; 1766 : 		return FALSE;

  0002f	74 e7		 je	 SHORT $LN10@CheckUserE

; 1767 : 	}
; 1768 : 
; 1769 : 	if ( gObj[iUserIndex].Money >= ::g_iChaosCastle_EnterCost[iEnterLevel] )

  00031	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0003d	8b 84 10 f0 00
	00 00		 mov	 eax, DWORD PTR [eax+edx+240]
  00044	33 d2		 xor	 edx, edx
  00046	3b 04 8d 00 00
	00 00		 cmp	 eax, DWORD PTR _g_iChaosCastle_EnterCost[ecx*4]
  0004d	0f 9d c2	 setge	 dl
  00050	8b c2		 mov	 eax, edx

; 1770 : 	{
; 1771 : 		return TRUE;
; 1772 : 	}
; 1773 : 
; 1774 : 	return FALSE;
; 1775 : }

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ENDP	; CChaosCastle::CheckUserEnterMoney
_TEXT	ENDS
PUBLIC	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z	; CChaosCastle::PayUserEnterMoney
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
; Function compile flags: /Ogtp
;	COMDAT ?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iEnterLevel$ = 12					; size = 4
?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z PROC		; CChaosCastle::PayUserEnterMoney, COMDAT
; _this$ = ecx

; 1778 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1779 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 68		 js	 SHORT $LN1@PayUserEnt
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 1780 : 	{
; 1781 : 		return FALSE;

  00018	74 59		 je	 SHORT $LN1@PayUserEnt

; 1782 : 	}
; 1783 : 
; 1784 : 	if ( CC_FLOOR_RANGE(iEnterLevel) == FALSE )

  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _iEnterLevel$[ebp]
  0001d	85 c9		 test	 ecx, ecx
  0001f	78 52		 js	 SHORT $LN1@PayUserEnt
  00021	33 c0		 xor	 eax, eax
  00023	83 f9 06	 cmp	 ecx, 6
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax

; 1785 : 	{
; 1786 : 		return FALSE;

  0002b	74 46		 je	 SHORT $LN1@PayUserEnt

; 1787 : 	}
; 1788 : 
; 1789 : 	if ( gObj[iUserIndex].Money >= ::g_iChaosCastle_EnterCost[iEnterLevel] )

  0002d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iChaosCastle_EnterCost[ecx*4]
  0003a	8b c6		 mov	 eax, esi
  0003c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00042	39 8c 10 f0 00
	00 00		 cmp	 DWORD PTR [eax+edx+240], ecx
  00049	7c 28		 jl	 SHORT $LN1@PayUserEnt

; 1790 : 	{
; 1791 : 		gObj[iUserIndex].Money -= ::g_iChaosCastle_EnterCost[iEnterLevel];

  0004b	29 8c 10 f0 00
	00 00		 sub	 DWORD PTR [eax+edx+240], ecx

; 1792 : 		GCMoneySend(iUserIndex, gObj[iUserIndex].Money);

  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	8b 94 08 f0 00
	00 00		 mov	 edx, DWORD PTR [eax+ecx+240]
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00066	83 c4 08	 add	 esp, 8

; 1793 : 		return TRUE;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	5e		 pop	 esi

; 1797 : }

  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
$LN1@PayUserEnt:

; 1794 : 	}
; 1795 : 
; 1796 : 	return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	5e		 pop	 esi

; 1797 : }

  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ENDP		; CChaosCastle::PayUserEnterMoney
_TEXT	ENDS
PUBLIC	_iUserIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GiveUserDamage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::GiveUserDamage
EXTRN	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z:PROC ; GCDiePlayerSend
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?GiveUserDamage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iUserIndex$GSCopy$ = -44				; size = 4
_pResult$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_iUserIndex$ = 8					; size = 4
_iDamage$ = 12						; size = 4
?GiveUserDamage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::GiveUserDamage, COMDAT
; _this$ = ecx

; 1800 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]

; 1801 : 	if ( !gObjIsConnected(iUserIndex))

  00014	53		 push	 ebx

; 1835 : 	{
; 1836 : 		gObj[iUserIndex].Life = 0;

  00015	89 5d d4	 mov	 DWORD PTR _iUserIndex$GSCopy$[ebp], ebx
  00018	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001d	83 c4 04	 add	 esp, 4
  00020	85 c0		 test	 eax, eax
  00022	0f 84 30 01 00
	00		 je	 $LN1@GiveUserDa

; 1802 : 		return;
; 1803 : 
; 1804 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  00028	d9 ee		 fldz
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	56		 push	 esi
  00030	8b f3		 mov	 esi, ebx
  00032	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00038	d8 9c 06 fc 00
	00 00		 fcomp	 DWORD PTR [esi+eax+252]
  0003f	df e0		 fnstsw	 ax
  00041	f6 c4 01	 test	 ah, 1
  00044	0f 84 0d 01 00
	00		 je	 $LN7@GiveUserDa

; 1805 : 		return;
; 1806 : 
; 1807 : 	PMSG_ATTACKRESULT pResult;
; 1808 : 
; 1809 : 	PHeadSetB((LPBYTE)&pResult, PROTOCOL_ATTACK, sizeof(pResult));

  0004a	6a 24		 push	 36			; 00000024H
  0004c	8d 4d d8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0004f	6a 11		 push	 17			; 00000011H
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1810 : 	pResult.NumberH = SET_NUMBERH(iUserIndex);
; 1811 : 	pResult.NumberL = SET_NUMBERL(iUserIndex);
; 1812 : 	pResult.DamageH = SET_NUMBERH(iDamage);

  00057	8b 45 0c	 mov	 eax, DWORD PTR _iDamage$[ebp]
  0005a	8b d3		 mov	 edx, ebx
  0005c	8b c8		 mov	 ecx, eax
  0005e	88 5d dc	 mov	 BYTE PTR _pResult$[ebp+4], bl

; 1813 : 	pResult.DamageL = SET_NUMBERL(iDamage);
; 1814 : 	pResult.btShieldDamageH = 0;

  00061	33 db		 xor	 ebx, ebx
  00063	c1 ea 08	 shr	 edx, 8
  00066	c1 e9 08	 shr	 ecx, 8
  00069	88 45 de	 mov	 BYTE PTR _pResult$[ebp+6], al

; 1815 : 	pResult.btShieldDamageL = 0;
; 1816 : 
; 1817 : 	//Fix HP/SD Bug
; 1818 : #if(FIX_HPSDBAR)
; 1819 : 	pResult.AttackDamage = iDamage;

  0006c	89 45 ec	 mov	 DWORD PTR _pResult$[ebp+20], eax

; 1820 : 	pResult.iShieldDamage = 0;
; 1821 : 	pResult.Life	= 0;
; 1822 : 	pResult.MaxLife = 0;
; 1823 : 	pResult.SD	= 0;
; 1824 : 	pResult.MaxSD = 0;
; 1825 : #endif
; 1826 : 
; 1827 : 	if ( gObj[iUserIndex].Type == OBJ_USER )

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	88 55 db	 mov	 BYTE PTR _pResult$[ebp+3], dl
  0007a	88 4d dd	 mov	 BYTE PTR _pResult$[ebp+5], cl
  0007d	66 89 5d e0	 mov	 WORD PTR _pResult$[ebp+8], bx
  00081	89 5d f0	 mov	 DWORD PTR _pResult$[ebp+24], ebx
  00084	89 5d e4	 mov	 DWORD PTR _pResult$[ebp+12], ebx
  00087	89 5d e8	 mov	 DWORD PTR _pResult$[ebp+16], ebx
  0008a	89 5d f4	 mov	 DWORD PTR _pResult$[ebp+28], ebx
  0008d	89 5d f8	 mov	 DWORD PTR _pResult$[ebp+32], ebx
  00090	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00096	75 1a		 jne	 SHORT $LN2@GiveUserDa

; 1828 : 	{
; 1829 : 		DataSend(iUserIndex, (LPBYTE)&pResult, pResult.h.size);

  00098	0f b6 55 d9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0009c	8b 4d d4	 mov	 ecx, DWORD PTR _iUserIndex$GSCopy$[ebp]
  0009f	52		 push	 edx
  000a0	8d 45 d8	 lea	 eax, DWORD PTR _pResult$[ebp]
  000a3	50		 push	 eax
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GiveUserDa:

; 1830 : 	}
; 1831 : 
; 1832 : 	gObj[iUserIndex].Life -= iDamage;

  000b2	d9 84 06 fc 00
	00 00		 fld	 DWORD PTR [esi+eax+252]
  000b9	da 65 0c	 fisub	 DWORD PTR _iDamage$[ebp]
  000bc	d9 9c 06 fc 00
	00 00		 fstp	 DWORD PTR [esi+eax+252]

; 1833 : 
; 1834 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c9	d9 ee		 fldz
  000cb	d8 94 0e fc 00
	00 00		 fcom	 DWORD PTR [esi+ecx+252]
  000d2	df e0		 fnstsw	 ax
  000d4	f6 c4 01	 test	 ah, 1
  000d7	75 7c		 jne	 SHORT $LN9@GiveUserDa

; 1835 : 	{
; 1836 : 		gObj[iUserIndex].Life = 0;

  000d9	d9 9c 0e fc 00
	00 00		 fstp	 DWORD PTR [esi+ecx+252]

; 1837 : 		gObj[iUserIndex].m_State = 4;

  000e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e6	c7 84 16 20 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [esi+edx+544], 4

; 1838 : 		gObj[iUserIndex].KillerType = 1;

  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f6	c6 84 06 a1 03
	00 00 01	 mov	 BYTE PTR [esi+eax+929], 1

; 1839 : 		gObj[iUserIndex].RegenTime = GetTickCount();

  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010a	89 84 0e a8 03
	00 00		 mov	 DWORD PTR [esi+ecx+936], eax

; 1840 : 		gObj[iUserIndex].DieRegen = 1;

  00111	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00117	c6 84 16 a2 03
	00 00 01	 mov	 BYTE PTR [esi+edx+930], 1

; 1841 : 		gObj[iUserIndex].PathCount = 0;

  0011f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00124	89 9c 06 84 01
	00 00		 mov	 DWORD PTR [esi+eax+388], ebx

; 1842 : 		
; 1843 : 		GCDiePlayerSend(&gObj[iUserIndex], gObj[iUserIndex].m_Index, 0, 0);

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  00134	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00137	53		 push	 ebx
  00138	53		 push	 ebx
  00139	52		 push	 edx
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  00140	83 c4 10	 add	 esp, 16			; 00000010H
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx

; 1844 : 	}
; 1845 : }

  00145	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00148	33 cd		 xor	 ecx, ebp
  0014a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 08 00	 ret	 8
$LN9@GiveUserDa:

; 1833 : 
; 1834 : 	if ( gObj[iUserIndex].Life <= 0.0 )

  00155	dd d8		 fstp	 ST(0)
$LN7@GiveUserDa:
  00157	5e		 pop	 esi
$LN1@GiveUserDa:

; 1844 : 	}
; 1845 : }

  00158	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015b	33 cd		 xor	 ecx, ebp
  0015d	5b		 pop	 ebx
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c2 08 00	 ret	 8
?GiveUserDamage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::GiveUserDamage
_TEXT	ENDS
PUBLIC	??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	_iUserIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?LevelUp@CChaosCastle@@QAEHHHH@Z		; CChaosCastle::LevelUp
EXTRN	?LevelUp@CAchievements@@QAEXH@Z:PROC		; CAchievements::LevelUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	_sprintf:PROC
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
EXTRN	?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z:PROC ; CMasterLevelSystem::MasterLevelUp
;	COMDAT ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ DB ',(%s)(%s) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
CONST	SEGMENT
??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ DB '4'
	DB	'00 LevelUp (%s)(%s) Party ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LevelUp@CChaosCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iUserIndex$GSCopy$ = -268				; size = 4
tv311 = -264						; size = 4
_szMsg$220298 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iUserIndex$ = 8					; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CChaosCastle@@QAEHHHH@Z PROC			; CChaosCastle::LevelUp, COMDAT
; _this$ = ecx

; 1848 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _iUserIndex$[ebp]

; 1946 : 		}
; 1947 : 	}
; 1948 : 
; 1949 : #if(SYSTEM_ACHIEVEMENTS)
; 1950 : 	g_Achievements.LevelUp(iUserIndex);

  00017	89 bd f4 fe ff
	ff		 mov	 DWORD PTR _iUserIndex$GSCopy$[ebp], edi
  0001d	85 ff		 test	 edi, edi
  0001f	78 0f		 js	 SHORT $LN21@LevelUp

; 1849 : 	if ( OBJMAX_RANGE(iUserIndex) == FALSE )

  00021	33 c0		 xor	 eax, eax
  00023	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00029	0f 9e c0	 setle	 al
  0002c	85 c0		 test	 eax, eax
  0002e	75 13		 jne	 SHORT $LN14@LevelUp
$LN21@LevelUp:

; 1850 : 	{
; 1851 : 		return 0;

  00030	33 c0		 xor	 eax, eax
  00032	5f		 pop	 edi

; 1951 : #endif
; 1952 : 
; 1953 : 	return iLEFT_EXP;
; 1954 : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
$LN14@LevelUp:

; 1852 : 	}
; 1853 : 
; 1854 : 	int iLEFT_EXP = 0;
; 1855 : 
; 1856 : 	if(g_MasterLevelSystem.MasterLevelUp(&gObj[iUserIndex], (__int64&)iAddExp,1,0) != 0) //season3 add-on

  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	8b f7		 mov	 esi, edi
  0004d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00053	33 db		 xor	 ebx, ebx
  00055	53		 push	 ebx
  00056	6a 01		 push	 1
  00058	8d 45 0c	 lea	 eax, DWORD PTR _iAddExp$[ebp]
  0005b	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0005e	50		 push	 eax
  0005f	52		 push	 edx
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00065	e8 00 00 00 00	 call	 ?MasterLevelUp@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@AA_J_NH@Z ; CMasterLevelSystem::MasterLevelUp
  0006a	85 c0		 test	 eax, eax

; 1857 : 	{
; 1858 : 		return 0;

  0006c	0f 85 90 00 00
	00		 jne	 $LN25@LevelUp

; 1859 : 	}
; 1860 : 
; 1861 : 	::gObjSetExpPetItem(iUserIndex, iAddExp);

  00072	8b 45 0c	 mov	 eax, DWORD PTR _iAddExp$[ebp]
  00075	50		 push	 eax
  00076	57		 push	 edi
  00077	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem

; 1862 : 
; 1863 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d", gObj[iUserIndex].MapNumber, gObj[iUserIndex].X, gObj[iUserIndex].Y, gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].Level, gObj[iUserIndex].Experience, iAddExp, 0, iEventType);

  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00081	8b 4d 10	 mov	 ecx, DWORD PTR _iEventType$[ebp]
  00084	8b 55 0c	 mov	 edx, DWORD PTR _iAddExp$[ebp]
  00087	51		 push	 ecx
  00088	8b 8c 06 c8 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+200]
  0008f	53		 push	 ebx
  00090	52		 push	 edx
  00091	0f bf 94 06 be
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+190]
  00099	51		 push	 ecx
  0009a	52		 push	 edx
  0009b	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0009f	51		 push	 ecx
  000a0	0f bf 8c 06 46
	01 00 00	 movsx	 ecx, WORD PTR [esi+eax+326]
  000a8	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000ac	52		 push	 edx
  000ad	0f bf 94 06 44
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+324]
  000b5	0f b6 84 06 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+329]
  000bd	51		 push	 ecx
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1864 : 
; 1865 : #if(ENABLE_CHARLVL1000)
; 1866 : 
; 1867 : 	if ( gObj[iUserIndex].Level >= ZtConfig.ZtCustom.MaxLevel )

  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d1	0f bf 94 0e be
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+190]
  000d9	83 c4 34	 add	 esp, 52			; 00000034H
  000dc	3b 15 24 00 00
	00		 cmp	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+36
  000e2	7c 33		 jl	 SHORT $LN12@LevelUp

; 1868 : 	{
; 1869 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iUserIndex].m_Index, 1);

  000e4	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  000e7	6a 01		 push	 1
  000e9	50		 push	 eax
  000ea	68 70 04 00 00	 push	 1136			; 00000470H
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@LevelUp:

; 1870 : 		return 0;

  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	33 c0		 xor	 eax, eax
  00106	5f		 pop	 edi

; 1951 : #endif
; 1952 : 
; 1953 : 	return iLEFT_EXP;
; 1954 : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 0c 00	 ret	 12			; 0000000cH
$LN12@LevelUp:

; 1871 : 	}
; 1872 : 
; 1873 : #else
; 1874 : 
; 1875 : 	if ( gObj[iUserIndex].Level >= MAX_CHAR_LEVEL )
; 1876 : 	{
; 1877 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iUserIndex].m_Index, 1);
; 1878 : 		return 0;
; 1879 : 	}
; 1880 : 
; 1881 : #endif
; 1882 : 
; 1883 : 
; 1884 : 
; 1885 : 	if ( (gObj[iUserIndex].Experience + iAddExp) < gObj[iUserIndex].NextExp )

  00117	8b bc 0e c8 00
	00 00		 mov	 edi, DWORD PTR [esi+ecx+200]
  0011e	8b 55 0c	 mov	 edx, DWORD PTR _iAddExp$[ebp]
  00121	8d 84 0e c8 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+200]
  00128	8d 8c 0e cc 00
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+204]
  0012f	03 fa		 add	 edi, edx
  00131	3b 39		 cmp	 edi, DWORD PTR [ecx]
  00133	73 07		 jae	 SHORT $LN11@LevelUp

; 1886 : 	{
; 1887 : 		gObj[iUserIndex].Experience += iAddExp;

  00135	01 10		 add	 DWORD PTR [eax], edx

; 1888 : 	}
; 1889 : 	else

  00137	e9 31 02 00 00	 jmp	 $LN5@LevelUp
$LN11@LevelUp:

; 1890 : 	{
; 1891 : 		iLEFT_EXP = gObj[iUserIndex].Experience + iAddExp - gObj[iUserIndex].NextExp;

  0013c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013e	8b 18		 mov	 ebx, DWORD PTR [eax]

; 1892 : 		gObj[iUserIndex].Experience = gObj[iUserIndex].NextExp;

  00140	89 08		 mov	 DWORD PTR [eax], ecx

; 1893 : 		gObj[iUserIndex].Level++;

  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00147	66 ff 84 06 be
	00 00 00	 inc	 WORD PTR [esi+eax+190]
  0014f	2b d9		 sub	 ebx, ecx

; 1894 : 
; 1895 : 		if ( gObj[iUserIndex].Class == CLASS_DARKLORD 
; 1896 : #ifdef MONK
; 1897 : 			|| gObj[iUserIndex].Class == CLASS_MONK
; 1898 : #endif
; 1899 : 			|| gObj[iUserIndex].Class == CLASS_MAGUMSA )

  00151	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00157	0f b7 84 0e b8
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+184]
  0015f	03 da		 add	 ebx, edx
  00161	83 f8 04	 cmp	 eax, 4
  00164	74 1b		 je	 SHORT $LN8@LevelUp
  00166	83 f8 06	 cmp	 eax, 6
  00169	74 16		 je	 SHORT $LN8@LevelUp
  0016b	83 f8 03	 cmp	 eax, 3
  0016e	74 11		 je	 SHORT $LN8@LevelUp

; 1902 : 		}
; 1903 : 		else
; 1904 : 		{
; 1905 : 			gObj[iUserIndex].LevelUpPoint += 5;

  00170	83 84 0e c0 00
	00 00 05	 add	 DWORD PTR [esi+ecx+192], 5
  00178	8d 84 0e c0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+192]
  0017f	eb 0f		 jmp	 SHORT $LN7@LevelUp
$LN8@LevelUp:

; 1900 : 		{
; 1901 : 			gObj[iUserIndex].LevelUpPoint += 7;

  00181	83 84 0e c0 00
	00 00 07	 add	 DWORD PTR [esi+ecx+192], 7
  00189	8d 84 0e c0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+192]
$LN7@LevelUp:

; 1906 : 		}
; 1907 : 
; 1908 : 		if ( gObj[iUserIndex].PlusStatQuestClear != false )

  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00196	80 bc 0e a5 00
	00 00 00	 cmp	 BYTE PTR [esi+ecx+165], 0
  0019e	74 39		 je	 SHORT $LN6@LevelUp

; 1909 : 		{
; 1910 : 			gObj[iUserIndex].LevelUpPoint++;

  001a0	ff 84 0e c0 00
	00 00		 inc	 DWORD PTR [esi+ecx+192]
  001a7	8d 84 0e c0 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+192]

; 1911 : 
; 1912 : 			LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 1913 : 				gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].LevelUpPoint);

  001ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b3	8b 8c 06 c0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+192]
  001ba	51		 push	 ecx
  001bb	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  001bf	52		 push	 edx
  001c0	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  001c4	50		 push	 eax
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5C@
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d6	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@LevelUp:

; 1914 : 		}
; 1915 : 
; 1916 : 		gObj[iUserIndex].MaxLife += DCInfo.DefClass[gObj[iUserIndex].Class].LevelLife;

  001d9	8d 84 0e 00 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+256]
  001e0	0f b7 8c 0e b8
	00 00 00	 movzx	 ecx, WORD PTR [esi+ecx+184]
  001e8	69 c9 c8 0b 00
	00		 imul	 ecx, 3016		; 00000bc8H
  001ee	d9 81 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+16]
  001f4	d8 00		 fadd	 DWORD PTR [eax]
  001f6	d9 18		 fstp	 DWORD PTR [eax]

; 1917 : 		gObj[iUserIndex].MaxMana += DCInfo.DefClass[gObj[iUserIndex].Class].LevelMana;

  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fe	0f b7 94 0e b8
	00 00 00	 movzx	 edx, WORD PTR [esi+ecx+184]
  00206	69 d2 c8 0b 00
	00		 imul	 edx, 3016		; 00000bc8H
  0020c	8d 84 0e 14 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+276]
  00213	d9 82 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+28]
  00219	d8 00		 fadd	 DWORD PTR [eax]
  0021b	d9 18		 fstp	 DWORD PTR [eax]

; 1918 : 		gObj[iUserIndex].Life = gObj[iUserIndex].MaxLife;

  0021d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00222	d9 84 06 00 01
	00 00		 fld	 DWORD PTR [esi+eax+256]
  00229	d9 9c 06 fc 00
	00 00		 fstp	 DWORD PTR [esi+eax+252]

; 1919 : 		gObj[iUserIndex].Mana = gObj[iUserIndex].MaxMana;

  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00235	d9 84 06 14 01
	00 00		 fld	 DWORD PTR [esi+eax+276]
  0023c	d9 9c 06 10 01
	00 00		 fstp	 DWORD PTR [esi+eax+272]

; 1920 : 		gObjNextExpCal(&gObj[iUserIndex]);

  00243	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00248	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal

; 1921 : 		gObjSetBP(gObj[iUserIndex].m_Index);

  00251	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00257	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 1922 : 		GCLevelUpMsgSend(gObj[iUserIndex].m_Index, 1);

  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00266	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  00269	6a 01		 push	 1
  0026b	52		 push	 edx
  0026c	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend

; 1923 : 		gObjCalcMaxLifePower(gObj[iUserIndex].m_Index);

  00271	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00276	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00279	51		 push	 ecx
  0027a	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 1924 : 		LogAddTD(lMsg.Get(MSGGET(2, 8)), gObj[iUserIndex].AccountID, gObj[iUserIndex].Name, gObj[iUserIndex].Level);

  0027f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00284	0f bf 94 06 be
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+190]
  0028c	83 c4 14	 add	 esp, 20			; 00000014H
  0028f	52		 push	 edx
  00290	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00294	51		 push	 ecx
  00295	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00299	52		 push	 edx
  0029a	68 08 02 00 00	 push	 520			; 00000208H
  0029f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002a4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002a9	50		 push	 eax
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1925 : 
; 1926 : 		//----------------------------------------------------------------------------------------------
; 1927 : 
; 1928 : 		if( gObj[iUserIndex].Level == 400 && gObj[iUserIndex].PartyNumber >= 0 ) //Season 2.5 add-on (Party Level 400 Display)

  002b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b5	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  002ba	83 c4 10	 add	 esp, 16			; 00000010H
  002bd	66 39 8c 06 be
	00 00 00	 cmp	 WORD PTR [esi+eax+190], cx
  002c5	0f 85 a2 00 00
	00		 jne	 $LN5@LevelUp
  002cb	83 bc 06 2c 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1068], 0
  002d3	0f 8c 94 00 00
	00		 jl	 $LN5@LevelUp

; 1929 : 		{
; 1930 : 			int iPartyNumber = gObj[iUserIndex].PartyNumber;

  002d9	8b bc 06 2c 04
	00 00		 mov	 edi, DWORD PTR [esi+eax+1068]

; 1931 : 			char szMsg[256];
; 1932 : 			sprintf(szMsg,"400 LevelUp (%s)(%s) Party ",gObj[iUserIndex].AccountID,gObj[iUserIndex].Name);

  002e0	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  002e4	52		 push	 edx
  002e5	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  002e9	50		 push	 eax
  002ea	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$220298[ebp]
  002f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
  002f5	51		 push	 ecx
  002f6	e8 00 00 00 00	 call	 _sprintf
  002fb	6b ff 68	 imul	 edi, 104		; 00000068H
  002fe	83 c4 10	 add	 esp, 16			; 00000010H
  00301	81 c7 0c 00 00
	00		 add	 edi, OFFSET ?gParty@@3VPartyClass@@A+12
  00307	c7 85 f8 fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv311[ebp], 10 ; 0000000aH
$LL4@LevelUp:

; 1936 : 			{
; 1937 : 				iPartyNumIndex = gParty.m_PartyS[iPartyNumber].Number[i];

  00311	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1938 : 
; 1939 : 				if( iPartyNumIndex >= 0  )

  00313	85 c9		 test	 ecx, ecx
  00315	78 3b		 js	 SHORT $LN3@LevelUp

; 1940 : 				{
; 1941 : 					int iSize = strlen(szMsg);

  00317	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$220298[ebp]
  0031d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL22@LevelUp:
  00320	8a 10		 mov	 dl, BYTE PTR [eax]
  00322	40		 inc	 eax
  00323	84 d2		 test	 dl, dl
  00325	75 f9		 jne	 SHORT $LL22@LevelUp

; 1942 : 					sprintf(&szMsg[iSize],",(%s)(%s) ",gObj[iPartyNumIndex].AccountID,gObj[iPartyNumIndex].Name);

  00327	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0032d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00333	2b c6		 sub	 eax, esi
  00335	8d 51 77	 lea	 edx, DWORD PTR [ecx+119]
  00338	52		 push	 edx
  00339	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0033c	51		 push	 ecx
  0033d	8d 84 05 fc fe
	ff ff		 lea	 eax, DWORD PTR _szMsg$220298[ebp+eax]
  00344	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 _sprintf
  0034f	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@LevelUp:

; 1933 : 			int iPartyNumIndex;
; 1934 : 
; 1935 : 			for( int i = 0; i<MAX_USER_IN_PARTY; i++ )

  00352	83 c7 04	 add	 edi, 4
  00355	ff 8d f8 fe ff
	ff		 dec	 DWORD PTR tv311[ebp]
  0035b	75 b4		 jne	 SHORT $LL4@LevelUp

; 1943 : 				}
; 1944 : 			}
; 1945 : 			LogAddTD(szMsg);

  0035d	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$220298[ebp]
  00363	51		 push	 ecx
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0036a	83 c4 04	 add	 esp, 4
$LN5@LevelUp:

; 1946 : 		}
; 1947 : 	}
; 1948 : 
; 1949 : #if(SYSTEM_ACHIEVEMENTS)
; 1950 : 	g_Achievements.LevelUp(iUserIndex);

  0036d	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iUserIndex$GSCopy$[ebp]
  00373	52		 push	 edx
  00374	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00379	e8 00 00 00 00	 call	 ?LevelUp@CAchievements@@QAEXH@Z ; CAchievements::LevelUp

; 1951 : #endif
; 1952 : 
; 1953 : 	return iLEFT_EXP;
; 1954 : }

  0037e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00381	5e		 pop	 esi
  00382	8b c3		 mov	 eax, ebx
  00384	5b		 pop	 ebx
  00385	33 cd		 xor	 ecx, ebp
  00387	5f		 pop	 edi
  00388	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038d	8b e5		 mov	 esp, ebp
  0038f	5d		 pop	 ebp
  00390	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CChaosCastle@@QAEHHHH@Z ENDP			; CChaosCastle::LevelUp
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CChaosCastle@@QAEHHH@Z		; CChaosCastle::CheckEnterLevel
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterLevel@CChaosCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CChaosCastle@@QAEHHH@Z PROC		; CChaosCastle::CheckEnterLevel, COMDAT
; _this$ = ecx

; 2005 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2006 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 88 ba 00 00
	00		 js	 $LN10@CheckEnter
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx

; 2007 : 	{
; 2008 : 		return 2;

  0001a	0f 84 a8 00 00
	00		 je	 $LN10@CheckEnter

; 2009 : 	}
; 2010 : 
; 2011 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00020	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00026	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  00031	0f 85 91 00 00
	00		 jne	 $LN10@CheckEnter
  00037	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0003b	0f 8e 87 00 00
	00		 jle	 $LN10@CheckEnter

; 2014 : 	}
; 2015 : 
; 2016 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD 
; 2017 : #ifdef MONK
; 2018 : 		|| gObj[iIndex].Class == CLASS_MONK
; 2019 : #endif
; 2020 : 		|| gObj[iIndex].Class == CLASS_MAGUMSA )

  00041	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00048	83 f9 04	 cmp	 ecx, 4
  0004b	74 3e		 je	 SHORT $LN8@CheckEnter
  0004d	83 f9 06	 cmp	 ecx, 6
  00050	74 39		 je	 SHORT $LN8@CheckEnter
  00052	83 f9 03	 cmp	 ecx, 3
  00055	74 34		 je	 SHORT $LN8@CheckEnter

; 2035 : 		}
; 2036 : 	}
; 2037 : 	else
; 2038 : 	{
; 2039 : 		if ( gObj[iIndex].Level >= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00057	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00061	c1 e0 04	 shl	 eax, 4
  00064	8b 90 f0 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-16]
  0006a	3b ca		 cmp	 ecx, edx
  0006c	7c 46		 jl	 SHORT $LN21@CheckEnter
  0006e	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-12]

; 2040 : 		{
; 2041 : 			return 0;

  00074	7e 34		 jle	 SHORT $LN22@CheckEnter

; 2042 : 		}
; 2043 : 
; 2044 : 		if ( gObj[iIndex].Level < g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  00076	3b ca		 cmp	 ecx, edx

; 2045 : 		{
; 2046 : 			return -1;

  00078	7c 3a		 jl	 SHORT $LN21@CheckEnter

; 2047 : 		}
; 2048 : 
; 2049 : 		if ( gObj[iIndex].Level > g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  0007a	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-12]
  00080	7e 46		 jle	 SHORT $LN10@CheckEnter

; 2050 : 		{
; 2051 : 			return 1;

  00082	b8 01 00 00 00	 mov	 eax, 1

; 2052 : 		}
; 2053 : 	}
; 2054 : 
; 2055 : 	return 2;
; 2056 : }

  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
$LN8@CheckEnter:

; 2021 : 	{
; 2022 : 		if ( gObj[iIndex].Level >= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  0008b	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  00092	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00095	c1 e0 04	 shl	 eax, 4
  00098	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-8]
  0009e	3b ca		 cmp	 ecx, edx
  000a0	7c 12		 jl	 SHORT $LN21@CheckEnter
  000a2	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-4]
  000a8	7f 06		 jg	 SHORT $LN7@CheckEnter
$LN22@CheckEnter:

; 2023 : 		{
; 2024 : 			return 0;

  000aa	33 c0		 xor	 eax, eax

; 2052 : 		}
; 2053 : 	}
; 2054 : 
; 2055 : 	return 2;
; 2056 : }

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN7@CheckEnter:

; 2025 : 		}
; 2026 : 
; 2027 : 		if ( gObj[iIndex].Level < g_sttCHAOSCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  000b0	3b ca		 cmp	 ecx, edx
  000b2	7d 07		 jge	 SHORT $LN6@CheckEnter
$LN21@CheckEnter:

; 2028 : 		{
; 2029 : 			return -1;

  000b4	83 c8 ff	 or	 eax, -1

; 2052 : 		}
; 2053 : 	}
; 2054 : 
; 2055 : 	return 2;
; 2056 : }

  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
$LN6@CheckEnter:

; 2030 : 		}
; 2031 : 
; 2032 : 		if ( gObj[iIndex].Level > g_sttCHAOSCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  000bb	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR _g_sttCHAOSCASTLE_LEVEL[eax-4]

; 2033 : 		{
; 2034 : 			return 1;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	7f 05		 jg	 SHORT $LN13@CheckEnter
$LN10@CheckEnter:

; 2012 : 	{
; 2013 : 		return 2;

  000c8	b8 02 00 00 00	 mov	 eax, 2
$LN13@CheckEnter:

; 2052 : 		}
; 2053 : 	}
; 2054 : 
; 2055 : 	return 2;
; 2056 : }

  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
?CheckEnterLevel@CChaosCastle@@QAEHHH@Z ENDP		; CChaosCastle::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?CheckEnterItem@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckEnterItem
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterItem@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterItem@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckEnterItem, COMDAT
; _this$ = ecx

; 2059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 2060 : 	int iITEM_LEVEL = 0;
; 2061 : 
; 2062 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	85 ff		 test	 edi, edi
  0000c	78 0f		 js	 SHORT $LN20@CheckEnter@2
  0000e	33 c0		 xor	 eax, eax
  00010	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN10@CheckEnter@2
$LN20@CheckEnter@2:
  0001d	5f		 pop	 edi

; 2063 : 	{
; 2064 : 		return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	5b		 pop	 ebx

; 2094 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN10@CheckEnter@2:

; 2065 : 	}
; 2066 : 
; 2067 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00031	66 83 7c 0f 68
	01		 cmp	 WORD PTR [edi+ecx+104], 1
  00037	75 e4		 jne	 SHORT $LN20@CheckEnter@2
  00039	83 7c 0f 04 02	 cmp	 DWORD PTR [edi+ecx+4], 2
  0003e	7e dd		 jle	 SHORT $LN20@CheckEnter@2

; 2068 : 	{
; 2069 : 		return 0;
; 2070 : 	}
; 2071 : 
; 2072 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00040	56		 push	 esi
  00041	33 f6		 xor	 esi, esi
  00043	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL7@CheckEnter@2:

; 2073 : 	{
; 2074 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00050	8b 8c 0f 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+3620]
  00057	03 ce		 add	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	83 f8 01	 cmp	 eax, 1
  00067	75 30		 jne	 SHORT $LN6@CheckEnter@2

; 2075 : 		{
; 2076 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,29) )

  00069	8b 84 0f 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3620]
  00070	ba 1d 1a 00 00	 mov	 edx, 6685		; 00001a1dH
  00075	66 39 54 30 06	 cmp	 WORD PTR [eax+esi+6], dx
  0007a	75 1d		 jne	 SHORT $LN6@CheckEnter@2

; 2077 : 			{
; 2078 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  0007c	0f bf 5c 30 08	 movsx	 ebx, WORD PTR [eax+esi+8]

; 2079 : 
; 2080 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CHAOSCASTLE_LEVEL+1) == FALSE )

  00081	85 db		 test	 ebx, ebx
  00083	78 0c		 js	 SHORT $LN21@CheckEnter@2
  00085	33 c0		 xor	 eax, eax
  00087	83 fb 07	 cmp	 ebx, 7
  0008a	0f 9e c0	 setle	 al
  0008d	85 c0		 test	 eax, eax
  0008f	75 04		 jne	 SHORT $LN2@CheckEnter@2
$LN21@CheckEnter@2:

; 2081 : 				{
; 2082 : 					iITEM_LEVEL = 0;

  00091	33 db		 xor	 ebx, ebx

; 2083 : 				}
; 2084 : 
; 2085 : 				if ( iITEM_LEVEL != 0 )

  00093	eb 04		 jmp	 SHORT $LN6@CheckEnter@2
$LN2@CheckEnter@2:
  00095	85 db		 test	 ebx, ebx
  00097	75 0e		 jne	 SHORT $LN5@CheckEnter@2
$LN6@CheckEnter@2:

; 2068 : 	{
; 2069 : 		return 0;
; 2070 : 	}
; 2071 : 
; 2072 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00099	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  0009f	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  000a5	7c a9		 jl	 SHORT $LL7@CheckEnter@2
$LN5@CheckEnter@2:
  000a7	5e		 pop	 esi
  000a8	5f		 pop	 edi

; 2086 : 				{
; 2087 : 					return iITEM_LEVEL;
; 2088 : 				}
; 2089 : 			}
; 2090 : 		}
; 2091 : 	}
; 2092 : 
; 2093 : 	return iITEM_LEVEL;

  000a9	8b c3		 mov	 eax, ebx
  000ab	5b		 pop	 ebx

; 2094 : }

  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
?CheckEnterItem@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckEnterItem
_TEXT	ENDS
PUBLIC	?CheckCanEnter@CChaosCastle@@QAE_NH@Z		; CChaosCastle::CheckCanEnter
; Function compile flags: /Ogtp
;	COMDAT ?CheckCanEnter@CChaosCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckCanEnter@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckCanEnter, COMDAT
; _this$ = ecx

; 2120 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2121 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckCanEn
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckCanEn
$LN6@CheckCanEn:

; 2122 : 	{
; 2123 : 		return false;

  00016	32 c0		 xor	 al, al

; 2127 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckCanEn:

; 2124 : 	}
; 2125 : 
; 2126 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER;

  0001c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00022	8a 44 08 4c	 mov	 al, BYTE PTR [eax+ecx+76]

; 2127 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckCanEnter@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckCanEnter
_TEXT	ENDS
PUBLIC	?CheckPlayStart@CChaosCastle@@QAE_NH@Z		; CChaosCastle::CheckPlayStart
; Function compile flags: /Ogtp
;	COMDAT ?CheckPlayStart@CChaosCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckPlayStart@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckPlayStart, COMDAT
; _this$ = ecx

; 2130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2131 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@CheckPlayS
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 06		 jne	 SHORT $LN1@CheckPlayS
$LN6@CheckPlayS:

; 2132 : 	{
; 2133 : 		return false;

  00016	32 c0		 xor	 al, al

; 2137 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@CheckPlayS:

; 2134 : 	}
; 2135 : 
; 2136 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START;

  0001c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00022	8a 44 08 4e	 mov	 al, BYTE PTR [eax+ecx+78]

; 2137 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?CheckPlayStart@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckPlayStart
_TEXT	ENDS
PUBLIC	?GetCurrentState@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetCurrentState
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentState@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentState@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentState, COMDAT
; _this$ = ecx

; 2159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2160 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@GetCurrent
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN1@GetCurrent
$LN6@GetCurrent:

; 2161 : 	{
; 2162 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 2166 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetCurrent:

; 2163 : 	}
; 2164 : 
; 2165 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE;

  0001d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00023	8b 44 08 30	 mov	 eax, DWORD PTR [eax+ecx+48]

; 2166 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetCurrentState@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentState
_TEXT	ENDS
PUBLIC	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurEnteredUser
; Function compile flags: /Ogtp
;	COMDAT ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetCurEnteredUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurEnteredUser, COMDAT
; _this$ = ecx

; 2169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2170 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0c		 js	 SHORT $LN6@GetCurEnte
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	75 07		 jne	 SHORT $LN1@GetCurEnte
$LN6@GetCurEnte:

; 2171 : 	{
; 2172 : 		return -1;

  00016	83 c8 ff	 or	 eax, -1

; 2176 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetCurEnte:

; 2173 : 	}
; 2174 : 
; 2175 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER;

  0001d	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00023	8b 44 08 54	 mov	 eax, DWORD PTR [eax+ecx+84]

; 2176 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurEnteredUser
_TEXT	ENDS
PUBLIC	?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurrentRemainSec
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentRemainSec, COMDAT
; _this$ = ecx

; 2276 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2277 : 	return this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 1000;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0000c	8b 4c 08 40	 mov	 ecx, DWORD PTR [eax+ecx+64]
  00010	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00015	f7 e9		 imul	 ecx
  00017	c1 fa 06	 sar	 edx, 6
  0001a	8b c2		 mov	 eax, edx
  0001c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001f	03 c2		 add	 eax, edx

; 2278 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetCurrentRemainSec@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentRemainSec
_TEXT	ENDS
PUBLIC	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z		; CChaosCastle::ObjSetPosition
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_pMove2$ = -12						; size = 7
tv291 = -4						; size = 4
_iIndex$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
tv345 = 18						; size = 4
?ObjSetPosition@CChaosCastle@@QAEHHHH@Z PROC		; CChaosCastle::ObjSetPosition, COMDAT
; _this$ = ecx

; 2281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 2282 : 	if ( !OBJMAX_RANGE(iIndex))

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 0f		 js	 SHORT $LN15@ObjSetPosi
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 0c		 jne	 SHORT $LN6@ObjSetPosi
$LN15@ObjSetPosi:

; 2283 : 		return TRUE;

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	5e		 pop	 esi

; 2343 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
$LN6@ObjSetPosi:

; 2284 : 
; 2285 : 	LPOBJ lpObj = &gObj[iIndex];

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00034	89 75 fc	 mov	 DWORD PTR tv291[ebp], esi
  00037	03 f0		 add	 esi, eax

; 2286 : 
; 2287 : 	if ( !CC_MAP_RANGE(lpObj->MapNumber))

  00039	8a 86 49 01 00
	00		 mov	 al, BYTE PTR [esi+329]
  0003f	3c 35		 cmp	 al, 53			; 00000035H
  00041	74 19		 je	 SHORT $LN5@ObjSetPosi
  00043	3c 12		 cmp	 al, 18			; 00000012H
  00045	72 0c		 jb	 SHORT $LN16@ObjSetPosi
  00047	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  0004c	3a c8		 cmp	 cl, al
  0004e	1b c9		 sbb	 ecx, ecx
  00050	41		 inc	 ecx
  00051	75 09		 jne	 SHORT $LN5@ObjSetPosi
$LN16@ObjSetPosi:

; 2288 : 		return FALSE;

  00053	33 c0		 xor	 eax, eax
  00055	5e		 pop	 esi

; 2343 : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
$LN5@ObjSetPosi:

; 2289 : 
; 2290 : 	if ( lpObj->Teleport )

  0005c	80 be a0 03 00
	00 00		 cmp	 BYTE PTR [esi+928], 0

; 2291 : 		return TRUE;

  00063	75 b8		 jne	 SHORT $LN15@ObjSetPosi

; 2292 : 
; 2293 : 	BYTE btMapAttr = MapC[lpObj->MapNumber].GetAttr(iX, iY);

  00065	8b 55 0c	 mov	 edx, DWORD PTR _iX$[ebp]
  00068	0f b6 c8	 movzx	 ecx, al
  0006b	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00071	53		 push	 ebx
  00072	8b 5d 10	 mov	 ebx, DWORD PTR _iY$[ebp]
  00075	53		 push	 ebx
  00076	52		 push	 edx
  00077	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0007d	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 2294 : 
; 2295 : 	if ( (btMapAttr&2) == 2 || (btMapAttr&4) == 4 )

  00082	a8 06		 test	 al, 6
  00084	0f 85 76 01 00
	00		 jne	 $LN2@ObjSetPosi

; 2297 : 
; 2298 : 	PMSG_POSISTION_SET pMove;
; 2299 : 
; 2300 : 	pMove.h.c = 0xC1;
; 2301 : 	pMove.h.headcode = PROTOCOL_POSITION;
; 2302 : 	pMove.h.size = sizeof(pMove);
; 2303 : 	pMove.X = iX;
; 2304 : 	pMove.Y = iY;
; 2305 : 
; 2306 : 	lpObj->m_Rest = 0;
; 2307 : 
; 2308 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX,lpObj->m_OldY);

  0008a	0f bf 86 7a 01
	00 00		 movsx	 eax, WORD PTR [esi+378]
  00091	0f bf 8e 78 01
	00 00		 movsx	 ecx, WORD PTR [esi+376]
  00098	57		 push	 edi
  00099	50		 push	 eax
  0009a	51		 push	 ecx
  0009b	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000a2	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000a8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000ae	c6 86 25 02 00
	00 00		 mov	 BYTE PTR [esi+549], 0
  000b5	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2309 : 	MapC[lpObj->MapNumber].SetStandAttr(iX,iY);

  000ba	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000c1	8b 55 0c	 mov	 edx, DWORD PTR _iX$[ebp]
  000c4	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000ca	53		 push	 ebx
  000cb	52		 push	 edx
  000cc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000d2	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2310 : 
; 2311 : 	lpObj->m_OldX = iX;

  000d7	8b 45 0c	 mov	 eax, DWORD PTR _iX$[ebp]

; 2312 : 	lpObj->m_OldY = iY;
; 2313 : 
; 2314 : 	lpObj->X = pMove.X;

  000da	0f b6 f8	 movzx	 edi, al
  000dd	66 89 86 78 01
	00 00		 mov	 WORD PTR [esi+376], ax

; 2315 : 	lpObj->Y = pMove.Y;

  000e4	0f b6 c3	 movzx	 eax, bl

; 2316 : 
; 2317 : 	PMSG_RECV_POSISTION_SET pMove2;
; 2318 : 
; 2319 : 	PHeadSetB((LPBYTE)&pMove2, PROTOCOL_POSITION, sizeof(pMove2));

  000e7	6a 07		 push	 7
  000e9	66 89 45 12	 mov	 WORD PTR tv345[ebp], ax
  000ed	66 89 86 46 01
	00 00		 mov	 WORD PTR [esi+326], ax
  000f4	8d 45 f4	 lea	 eax, DWORD PTR _pMove2$[ebp]
  000f7	6a 15		 push	 21			; 00000015H
  000f9	50		 push	 eax
  000fa	66 89 9e 7a 01
	00 00		 mov	 WORD PTR [esi+378], bx
  00101	66 89 be 44 01
	00 00		 mov	 WORD PTR [esi+324], di
  00108	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2320 : 	pMove2.NumberH = SET_NUMBERH(iIndex);

  0010d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 2321 : 	pMove2.NumberL = SET_NUMBERL(iIndex);
; 2322 : 	pMove2.X = pMove.X;

  00110	8a 55 0c	 mov	 dl, BYTE PTR _iX$[ebp]
  00113	8b c8		 mov	 ecx, eax
  00115	c1 e9 08	 shr	 ecx, 8
  00118	88 4d f7	 mov	 BYTE PTR _pMove2$[ebp+3], cl

; 2323 : 	pMove2.Y = pMove.Y;
; 2324 : 	lpObj->TX = pMove.X;
; 2325 : 	lpObj->TY = pMove.Y;

  0011b	66 8b 4d 12	 mov	 cx, WORD PTR tv345[ebp]
  0011f	88 45 f8	 mov	 BYTE PTR _pMove2$[ebp+4], al
  00122	88 55 f9	 mov	 BYTE PTR _pMove2$[ebp+5], dl
  00125	88 5d fa	 mov	 BYTE PTR _pMove2$[ebp+6], bl

; 2326 : 
; 2327 : 	CreateFrustrum(lpObj->X, lpObj->Y, iIndex);

  00128	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  0012f	50		 push	 eax
  00130	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  00137	52		 push	 edx
  00138	50		 push	 eax
  00139	66 89 be 7c 01
	00 00		 mov	 WORD PTR [esi+380], di
  00140	66 89 8e 7e 01
	00 00		 mov	 WORD PTR [esi+382], cx
  00147	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0014c	83 c4 18	 add	 esp, 24			; 00000018H

; 2328 : 
; 2329 : 	if ( lpObj->Type == OBJ_USER )

  0014f	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00154	5f		 pop	 edi
  00155	75 15		 jne	 SHORT $LN1@ObjSetPosi

; 2330 : 	{
; 2331 : 		DataSend(iIndex, (LPBYTE)&pMove2, pMove2.h.size);

  00157	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pMove2$[ebp+1]
  0015b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0015e	51		 push	 ecx
  0015f	8d 55 f4	 lea	 edx, DWORD PTR _pMove2$[ebp]
  00162	52		 push	 edx
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ObjSetPosi:

; 2332 : 	}
; 2333 : 
; 2334 : 	MsgSendV2(&gObj[iIndex], (LPBYTE)&pMove2, pMove2.h.size);

  0016c	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pMove2$[ebp+1]
  00170	51		 push	 ecx
  00171	8b 4d fc	 mov	 ecx, DWORD PTR tv291[ebp]
  00174	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017a	8d 55 f4	 lea	 edx, DWORD PTR _pMove2$[ebp]
  0017d	52		 push	 edx
  0017e	51		 push	 ecx
  0017f	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 2335 : 
; 2336 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00184	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  0018b	0f bf 96 7a 01
	00 00		 movsx	 edx, WORD PTR [esi+378]
  00192	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00198	0f bf 86 78 01
	00 00		 movsx	 eax, WORD PTR [esi+376]
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a2	52		 push	 edx
  001a3	50		 push	 eax
  001a4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001aa	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2337 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  001af	0f bf 8e 7e 01
	00 00		 movsx	 ecx, WORD PTR [esi+382]
  001b6	0f bf 96 7c 01
	00 00		 movsx	 edx, WORD PTR [esi+380]
  001bd	51		 push	 ecx
  001be	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  001c5	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  001cb	52		 push	 edx
  001cc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001d2	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2338 : 
; 2339 : 	lpObj->m_OldX = lpObj->TX;

  001d7	66 8b 86 7c 01
	00 00		 mov	 ax, WORD PTR [esi+380]

; 2340 : 	lpObj->m_OldY = lpObj->TY;

  001de	66 8b 8e 7e 01
	00 00		 mov	 cx, WORD PTR [esi+382]
  001e5	66 89 86 78 01
	00 00		 mov	 WORD PTR [esi+376], ax
  001ec	5b		 pop	 ebx
  001ed	66 89 8e 7a 01
	00 00		 mov	 WORD PTR [esi+378], cx

; 2341 : 
; 2342 : 	return TRUE;

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	5e		 pop	 esi

; 2343 : }

  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c2 0c 00	 ret	 12			; 0000000cH
$LN2@ObjSetPosi:
  00200	5b		 pop	 ebx

; 2296 : 		return FALSE;

  00201	33 c0		 xor	 eax, eax
  00203	5e		 pop	 esi

; 2343 : }

  00204	8b e5		 mov	 esp, ebp
  00206	5d		 pop	 ebp
  00207	c2 0c 00	 ret	 12			; 0000000cH
?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ENDP		; CChaosCastle::ObjSetPosition
_TEXT	ENDS
PUBLIC	?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z	; CChaosCastle::BlowObjsToPoint
; Function compile flags: /Ogtp
;	COMDAT ?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iMapNumber$ = 12					; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z PROC		; CChaosCastle::BlowObjsToPoint, COMDAT
; _this$ = ecx

; 2521 : 	return TRUE;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 2522 : }

  00005	c2 10 00	 ret	 16			; 00000010H
?BlowObjsToPoint@CChaosCastle@@QAEHHHHH@Z ENDP		; CChaosCastle::BlowObjsToPoint
_TEXT	ENDS
PUBLIC	?CheckWearingMOPH@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckWearingMOPH
; Function compile flags: /Ogtp
;	COMDAT ?CheckWearingMOPH@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
?CheckWearingMOPH@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckWearingMOPH, COMDAT
; _this$ = ecx

; 2960 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2961 : 	if (  gObjIsConnected(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax

; 2962 : 	{
; 2963 : 		return FALSE;

  00012	0f 84 d4 00 00
	00		 je	 $LN1@CheckWeari

; 2964 : 	}
; 2965 : 
; 2966 : 	if ( gObj[iUserIndex].pInventory[10].IsItem()  )

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00023	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  0002a	81 c1 48 08 00
	00		 add	 ecx, 2120		; 00000848H
  00030	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	85 c0		 test	 eax, eax
  0003d	74 4a		 je	 SHORT $LN7@CheckWeari

; 2967 : 	{
; 2968 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,10) ) // Tranformation Ring

  0003f	8b 94 0e 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+ecx+3620]
  00046	0f b7 82 4e 08
	00 00		 movzx	 eax, WORD PTR [edx+2126]
  0004d	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00052	66 3b c2	 cmp	 ax, dx
  00055	75 0a		 jne	 SHORT $LN11@CheckWeari
$LN16@CheckWeari:

; 2969 : 		{
; 2970 : 			return TRUE;

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	5e		 pop	 esi

; 3023 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN11@CheckWeari:

; 2971 : 		}
; 2972 : 
; 2973 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,39) ) 

  00061	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  00066	66 3b c2	 cmp	 ax, dx

; 2974 : 		{
; 2975 : 			return TRUE;

  00069	74 ec		 je	 SHORT $LN16@CheckWeari

; 2976 : 		}
; 2977 : 
; 2978 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,40) ) //Second Edition

  0006b	ba 28 1a 00 00	 mov	 edx, 6696		; 00001a28H
  00070	66 3b c2	 cmp	 ax, dx

; 2979 : 		{
; 2980 : 			return TRUE;

  00073	74 e2		 je	 SHORT $LN16@CheckWeari

; 2981 : 		}
; 2982 : 
; 2983 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,41) ) //season 2.5 add-on

  00075	ba 29 1a 00 00	 mov	 edx, 6697		; 00001a29H
  0007a	66 3b c2	 cmp	 ax, dx

; 2984 : 		{
; 2985 : 			return TRUE;

  0007d	74 d8		 je	 SHORT $LN16@CheckWeari

; 2986 : 		}
; 2987 : 
; 2988 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,68) ) //season 4.0 add-on

  0007f	ba 44 1a 00 00	 mov	 edx, 6724		; 00001a44H
  00084	66 3b c2	 cmp	 ax, dx

; 2989 : 		{
; 2990 : 			return TRUE;

  00087	74 ce		 je	 SHORT $LN16@CheckWeari
$LN7@CheckWeari:

; 2991 : 		}
; 2992 : 	}
; 2993 : 
; 2994 : 	if ( gObj[iUserIndex].pInventory[11].IsItem() )

  00089	8b 8c 0e 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3620]
  00090	81 c1 1c 09 00
	00		 add	 ecx, 2332		; 0000091cH
  00096	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0009b	85 c0		 test	 eax, eax
  0009d	74 4d		 je	 SHORT $LN1@CheckWeari

; 2995 : 	{
; 2996 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,10) ) // Tranformation Ring

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  000ab	0f b7 81 22 09
	00 00		 movzx	 eax, WORD PTR [ecx+2338]
  000b2	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  000b7	66 3b c2	 cmp	 ax, dx

; 2997 : 		{
; 2998 : 			return TRUE;

  000ba	74 9b		 je	 SHORT $LN16@CheckWeari

; 2999 : 		}
; 3000 : 
; 3001 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,39) ) 

  000bc	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  000c1	66 3b c1	 cmp	 ax, cx

; 3002 : 		{
; 3003 : 			return TRUE;

  000c4	74 91		 je	 SHORT $LN16@CheckWeari

; 3004 : 		}
; 3005 : 
; 3006 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,40) ) //Second Edition

  000c6	ba 28 1a 00 00	 mov	 edx, 6696		; 00001a28H
  000cb	66 3b c2	 cmp	 ax, dx

; 3007 : 		{
; 3008 : 			return TRUE;

  000ce	74 87		 je	 SHORT $LN16@CheckWeari

; 3009 : 		}
; 3010 : 
; 3011 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,41) ) //season 2.5 add-on

  000d0	b9 29 1a 00 00	 mov	 ecx, 6697		; 00001a29H
  000d5	66 3b c1	 cmp	 ax, cx

; 3012 : 		{
; 3013 : 			return TRUE;

  000d8	0f 84 79 ff ff
	ff		 je	 $LN16@CheckWeari

; 3014 : 		}
; 3015 : 
; 3016 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,68) ) //season 4.0 add-on

  000de	ba 44 1a 00 00	 mov	 edx, 6724		; 00001a44H
  000e3	66 3b c2	 cmp	 ax, dx

; 3017 : 		{
; 3018 : 			return TRUE;

  000e6	0f 84 6b ff ff
	ff		 je	 $LN16@CheckWeari
$LN1@CheckWeari:

; 3019 : 		}
; 3020 : 	}
; 3021 : 
; 3022 : 	return FALSE;

  000ec	33 c0		 xor	 eax, eax
  000ee	5e		 pop	 esi

; 3023 : }

  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?CheckWearingMOPH@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckWearingMOPH
_TEXT	ENDS
PUBLIC	??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	?GiveWinnerItem@CChaosCastle@@QAEXHH@Z		; CChaosCastle::GiveWinnerItem
EXTRN	?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z:PROC ; gObjLevelUp
EXTRN	?gLevelExperience@@3PAKA:BYTE			; gLevelExperience
EXTRN	?Main@CChaosCastleRewardItem@@QAE_NHH@Z:PROC	; CChaosCastleRewardItem::Main
EXTRN	?gChaosCastleRewardItem@@3VCChaosCastleRewardItem@@A:BYTE ; gChaosCastleRewardItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?MakeRandomSetItem@@YAXH@Z:PROC			; MakeRandomSetItem
EXTRN	_rand:PROC
EXTRN	?WinCC@CAchievements@@QAEXH@Z:PROC		; CAchievements::WinCC
;	COMDAT ??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
CONST	SEGMENT
??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Winner Item - Set Item', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_exp$220840 = -8					; size = 8
tv335 = -4						; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_i$220830 = 12						; size = 4
_i$220823 = 12						; size = 4
_iWinnerIndex$ = 12					; size = 4
?GiveWinnerItem@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::GiveWinnerItem, COMDAT
; _this$ = ecx

; 3028 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3029 : 	if( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	89 7d fc	 mov	 DWORD PTR _this$[ebp], edi
  00010	85 f6		 test	 esi, esi
  00012	0f 88 f6 01 00
	00		 js	 $LN1@GiveWinner
  00018	33 c0		 xor	 eax, eax
  0001a	83 fe 06	 cmp	 esi, 6
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 e6 01 00
	00		 je	 $LN1@GiveWinner

; 3030 : 	{
; 3031 : 		return;
; 3032 : 	}
; 3033 : 	// ----
; 3034 : 	if( !gObjIsConnected(iWinnerIndex) )

  00028	53		 push	 ebx
  00029	8b 5d 0c	 mov	 ebx, DWORD PTR _iWinnerIndex$[ebp]
  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	0f 84 d0 01 00
	00		 je	 $LN27@GiveWinner

; 3035 : 	{
; 3036 : 		return;
; 3037 : 	}
; 3038 : 
; 3039 : #if(SYSTEM_ACHIEVEMENTS)
; 3040 : 	g_Achievements.WinCC(iWinnerIndex);

  0003d	53		 push	 ebx
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00043	e8 00 00 00 00	 call	 ?WinCC@CAchievements@@QAEXH@Z ; CAchievements::WinCC

; 3041 : #endif
; 3042 : 
; 3043 : 	if( this->m_RewardData[iChaosCastleIndex].AncientCount > 0 )

  00048	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0004b	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  0004e	8a 87 44 3b 00
	00		 mov	 al, BYTE PTR [edi+15172]
  00054	84 c0		 test	 al, al
  00056	74 6e		 je	 SHORT $LN26@GiveWinner

; 3044 : 	{
; 3045 : 		for( int i = 0; i < this->m_RewardData[iChaosCastleIndex].AncientCount; i++ )

  00058	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8d 8c 76 d0 0e
	00 00		 lea	 ecx, DWORD PTR [esi+esi*2+3792]
  00062	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00065	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _i$220823[ebp], 0
  0006c	89 45 fc	 mov	 DWORD PTR tv335[ebp], eax
  0006f	90		 npad	 1
$LL12@GiveWinner:

; 3046 : 		{
; 3047 : 			if( rand()%100 < this->m_RewardData[iChaosCastleIndex].AncientRate )

  00070	e8 00 00 00 00	 call	 _rand
  00075	99		 cdq
  00076	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0007b	f7 f9		 idiv	 ecx
  0007d	8b 45 fc	 mov	 eax, DWORD PTR tv335[ebp]
  00080	3b 10		 cmp	 edx, DWORD PTR [eax]
  00082	7d 30		 jge	 SHORT $LN11@GiveWinner

; 3048 : 			{
; 3049 : 				MakeRandomSetItem(iWinnerIndex);

  00084	53		 push	 ebx
  00085	e8 00 00 00 00	 call	 ?MakeRandomSetItem@@YAXH@Z ; MakeRandomSetItem

; 3050 : 				LogAddTD("[Chaos Castle] (%d) [%s][%s] Winner Item - Set Item", 
; 3051 : 					iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name);

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	8b c3		 mov	 eax, ebx
  00092	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00098	8d 54 08 77	 lea	 edx, DWORD PTR [eax+ecx+119]
  0009c	52		 push	 edx
  0009d	8d 44 08 6c	 lea	 eax, DWORD PTR [eax+ecx+108]
  000a1	50		 push	 eax
  000a2	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  000a5	51		 push	 ecx
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HBELAIG@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@GiveWinner:

; 3044 : 	{
; 3045 : 		for( int i = 0; i < this->m_RewardData[iChaosCastleIndex].AncientCount; i++ )

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _i$220823[ebp]
  000b7	0f b6 97 44 3b
	00 00		 movzx	 edx, BYTE PTR [edi+15172]
  000be	40		 inc	 eax
  000bf	89 45 0c	 mov	 DWORD PTR _i$220823[ebp], eax
  000c2	3b c2		 cmp	 eax, edx
  000c4	7c aa		 jl	 SHORT $LL12@GiveWinner
$LN26@GiveWinner:

; 3052 : 			}
; 3053 : 		}
; 3054 : 	}
; 3055 : 	// ----
; 3056 : 	if( this->m_RewardData[iChaosCastleIndex].ItemCount > 0 )

  000c6	8a 87 45 3b 00
	00		 mov	 al, BYTE PTR [edi+15173]
  000cc	84 c0		 test	 al, al
  000ce	0f 84 bd 00 00
	00		 je	 $LN5@GiveWinner

; 3057 : 	{
; 3058 : 		for( int i = 0; i < this->m_RewardData[iChaosCastleIndex].ItemCount; i++ )

  000d4	8b f3		 mov	 esi, ebx
  000d6	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _i$220830[ebp], 0
  000dd	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000e3	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL7@GiveWinner:

; 3059 : 		{
; 3060 : 			ItemSerialCreateSend(gObj[iWinnerIndex].m_Index, gObj[iWinnerIndex].MapNumber, 
; 3061 : 				gObj[iWinnerIndex].X, gObj[iWinnerIndex].Y, 
; 3062 : 				ITEMGET(this->m_RewardData[iChaosCastleIndex].ItemID, this->m_RewardData[iChaosCastleIndex].ItemIndex), 
; 3063 : 				this->m_RewardData[iChaosCastleIndex].ItemLevel, 0, 0, 0, 0, iWinnerIndex, 0, 0);

  000f0	0f b7 8f 46 3b
	00 00		 movzx	 ecx, WORD PTR [edi+15174]
  000f7	0f b6 87 4a 3b
	00 00		 movzx	 eax, BYTE PTR [edi+15178]
  000fe	0f b7 97 48 3b
	00 00		 movzx	 edx, WORD PTR [edi+15176]
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	53		 push	 ebx
  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	50		 push	 eax
  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	c1 e1 09	 shl	 ecx, 9
  0011b	03 ca		 add	 ecx, edx
  0011d	0f b6 94 06 44
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+324]
  00125	51		 push	 ecx
  00126	0f b6 8c 06 46
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+326]
  0012e	51		 push	 ecx
  0012f	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00137	52		 push	 edx
  00138	8b 14 06	 mov	 edx, DWORD PTR [esi+eax]
  0013b	51		 push	 ecx
  0013c	52		 push	 edx
  0013d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 3064 : 			LogAddTD("[Chaos Castle] (%d) [%s][%s] Winner Item - %d", 
; 3065 : 				iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name, 
; 3066 : 				ITEMGET(this->m_RewardData[iChaosCastleIndex].ItemID, this->m_RewardData[iChaosCastleIndex].ItemIndex));

  00142	0f b7 87 46 3b
	00 00		 movzx	 eax, WORD PTR [edi+15174]
  00149	0f b7 8f 48 3b
	00 00		 movzx	 ecx, WORD PTR [edi+15176]
  00150	c1 e0 09	 shl	 eax, 9
  00153	03 c1		 add	 eax, ecx
  00155	50		 push	 eax
  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015b	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0015f	52		 push	 edx
  00160	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00164	50		 push	 eax
  00165	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00168	40		 inc	 eax
  00169	50		 push	 eax
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@OHBGNAEJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00175	8b 45 0c	 mov	 eax, DWORD PTR _i$220830[ebp]
  00178	0f b6 8f 45 3b
	00 00		 movzx	 ecx, BYTE PTR [edi+15173]
  0017f	40		 inc	 eax
  00180	83 c4 48	 add	 esp, 72			; 00000048H
  00183	89 45 0c	 mov	 DWORD PTR _i$220830[ebp], eax
  00186	3b c1		 cmp	 eax, ecx
  00188	0f 8c 62 ff ff
	ff		 jl	 $LL7@GiveWinner

; 3057 : 	{
; 3058 : 		for( int i = 0; i < this->m_RewardData[iChaosCastleIndex].ItemCount; i++ )

  0018e	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@GiveWinner:

; 3067 : 		}
; 3068 : 	}
; 3069 : 
; 3070 : 	// -> Chaos castle win
; 3071 : 	gChaosCastleRewardItem.Main(iWinnerIndex, iChaosCastleIndex);

  00191	56		 push	 esi
  00192	53		 push	 ebx
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ?gChaosCastleRewardItem@@3VCChaosCastleRewardItem@@A ; gChaosCastleRewardItem
  00198	e8 00 00 00 00	 call	 ?Main@CChaosCastleRewardItem@@QAE_NHH@Z ; CChaosCastleRewardItem::Main

; 3072 : 
; 3073 : 	if(ZtConfig.Event.Zt_CCRewardLevelUp)

  0019d	83 3d 40 07 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1856, 0
  001a4	74 67		 je	 SHORT $LN27@GiveWinner

; 3074 : 	{
; 3075 : 		#if(ENABLE_NSGAME_UPDATE)
; 3076 : 		for(int i = 0; i < ZtConfig.Event.Zt_BCRewardLevelUp; i++)

  001a6	33 ff		 xor	 edi, edi
  001a8	39 3d 3c 07 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1852, edi
  001ae	7e 5d		 jle	 SHORT $LN27@GiveWinner
  001b0	8b f3		 mov	 esi, ebx
  001b2	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001b8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL3@GiveWinner:

; 3077 : 		{
; 3078 : 			__int64 exp = gLevelExperience[gObj[iWinnerIndex].Level];

  001c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c5	0f bf 94 06 be
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+190]
  001cd	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?gLevelExperience@@3PAKA[edx*4]
  001d4	89 4d f8	 mov	 DWORD PTR _exp$220840[ebp], ecx
  001d7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _exp$220840[ebp+4], 0

; 3079 : 			gObj[iWinnerIndex].Experience = exp;

  001de	89 8c 06 c8 00
	00 00		 mov	 DWORD PTR [esi+eax+200], ecx

; 3080 : 			gObjLevelUp(&gObj[iWinnerIndex], exp, gObj[iWinnerIndex].Class, 0);

  001e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ea	0f b7 8c 06 b8
	00 00 00	 movzx	 ecx, WORD PTR [esi+eax+184]
  001f2	6a 00		 push	 0
  001f4	51		 push	 ecx
  001f5	8d 55 f8	 lea	 edx, DWORD PTR _exp$220840[ebp]
  001f8	52		 push	 edx
  001f9	03 c6		 add	 eax, esi
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z ; gObjLevelUp
  00201	47		 inc	 edi
  00202	83 c4 10	 add	 esp, 16			; 00000010H
  00205	3b 3d 3c 07 00
	00		 cmp	 edi, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1852
  0020b	7c b3		 jl	 SHORT $LL3@GiveWinner
$LN27@GiveWinner:
  0020d	5b		 pop	 ebx
$LN1@GiveWinner:
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi

; 3081 : 		}
; 3082 : 		#endif
; 3083 : 	}
; 3084 : 
; 3085 : }

  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c2 08 00	 ret	 8
?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::GiveWinnerItem
_TEXT	ENDS
PUBLIC	?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckRegisterOfflineGift
EXTRN	?EGReqRegCCOfflineGift@@YAXH@Z:PROC		; EGReqRegCCOfflineGift
; Function compile flags: /Ogtp
;	COMDAT ?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z PROC	; CChaosCastle::CheckRegisterOfflineGift, COMDAT
; _this$ = ecx

; 3302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3303 : 	if ( gObjIsConnected(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 1e		 je	 SHORT $LN1@CheckRegis

; 3304 : 	{
; 3305 : 		return;
; 3306 : 	}
; 3307 : 
; 3308 : 	int iGiftRate = rand() % 10000;

  00014	e8 00 00 00 00	 call	 _rand
  00019	99		 cdq
  0001a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0001f	f7 f9		 idiv	 ecx

; 3309 : 
; 3310 : 	if ( iGiftRate < ::g_iChaosCastle_OffLineGiftRate )

  00021	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA ; g_iChaosCastle_OffLineGiftRate
  00027	7d 09		 jge	 SHORT $LN1@CheckRegis

; 3311 : 	{
; 3312 : 		EGReqRegCCOfflineGift(iUserIndex);

  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?EGReqRegCCOfflineGift@@YAXH@Z ; EGReqRegCCOfflineGift
  0002f	83 c4 04	 add	 esp, 4
$LN1@CheckRegis:
  00032	5e		 pop	 esi

; 3313 : 	}
; 3314 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z ENDP	; CChaosCastle::CheckRegisterOfflineGift
_TEXT	ENDS
PUBLIC	?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetChaosCastleMapNumber
; Function compile flags: /Ogtp
;	COMDAT ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z PROC	; CChaosCastle::GetChaosCastleMapNumber, COMDAT
; _this$ = ecx

; 3317 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3318 : 	int iMapNumber = 0;
; 3319 : 
; 3320 : 	switch(iChaosCastleIndex)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	83 f9 06	 cmp	 ecx, 6
  0000b	77 42		 ja	 SHORT $LN8@GetChaosCa
  0000d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN12@GetChaosCa[ecx*4]
$LN7@GetChaosCa:

; 3321 : 	{
; 3322 : 	case 0:
; 3323 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE1;

  00014	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN6@GetChaosCa:

; 3324 : 		break;
; 3325 : 	case 1:
; 3326 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE2;

  0001d	b8 13 00 00 00	 mov	 eax, 19			; 00000013H

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN5@GetChaosCa:

; 3327 : 		break;
; 3328 : 	case 2:
; 3329 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE3;

  00026	b8 14 00 00 00	 mov	 eax, 20			; 00000014H

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN4@GetChaosCa:

; 3330 : 		break;
; 3331 : 	case 3:
; 3332 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE4;

  0002f	b8 15 00 00 00	 mov	 eax, 21			; 00000015H

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN3@GetChaosCa:

; 3333 : 		break;
; 3334 : 	case 4:
; 3335 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE5;

  00038	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN2@GetChaosCa:

; 3336 : 		break;
; 3337 : 	case 5:
; 3338 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE6;

  00041	b8 17 00 00 00	 mov	 eax, 23			; 00000017H

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN1@GetChaosCa:

; 3339 : 		break;
; 3340 : 	case 6:
; 3341 : 		iMapNumber = MAP_INDEX_CHAOSCASTLE7;

  0004a	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
$LN8@GetChaosCa:

; 3342 : 		break;
; 3343 : 	}
; 3344 : 
; 3345 : 	return iMapNumber;
; 3346 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
  00053	90		 npad	 1
$LN12@GetChaosCa:
  00054	00 00 00 00	 DD	 $LN7@GetChaosCa
  00058	00 00 00 00	 DD	 $LN6@GetChaosCa
  0005c	00 00 00 00	 DD	 $LN5@GetChaosCa
  00060	00 00 00 00	 DD	 $LN4@GetChaosCa
  00064	00 00 00 00	 DD	 $LN3@GetChaosCa
  00068	00 00 00 00	 DD	 $LN2@GetChaosCa
  0006c	00 00 00 00	 DD	 $LN1@GetChaosCa
?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ENDP	; CChaosCastle::GetChaosCastleMapNumber
_TEXT	ENDS
PUBLIC	?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetChaosCastleIndex
; Function compile flags: /Ogtp
;	COMDAT ?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetChaosCastleIndex, COMDAT
; _this$ = ecx

; 3349 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3350 : 	int iChaosCastleIndex = -1;
; 3351 : 
; 3352 : 	switch(iMAP_NUM)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 c1 ee	 add	 ecx, -18		; ffffffeeH
  00009	83 c8 ff	 or	 eax, -1
  0000c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0000f	77 46		 ja	 SHORT $LN8@GetChaosCa@2
  00011	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN12@GetChaosCa@2[ecx]
  00018	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@GetChaosCa@2[ecx*4]
$LN7@GetChaosCa@2:

; 3353 : 	{
; 3354 : 	case MAP_INDEX_CHAOSCASTLE1:
; 3355 : 		iChaosCastleIndex = 0;

  0001f	33 c0		 xor	 eax, eax

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN6@GetChaosCa@2:

; 3356 : 		break;
; 3357 : 	case MAP_INDEX_CHAOSCASTLE2:
; 3358 : 		iChaosCastleIndex = 1;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN5@GetChaosCa@2:

; 3359 : 		break;
; 3360 : 	case MAP_INDEX_CHAOSCASTLE3:
; 3361 : 		iChaosCastleIndex = 2;

  0002e	b8 02 00 00 00	 mov	 eax, 2

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN4@GetChaosCa@2:

; 3362 : 		break;
; 3363 : 	case MAP_INDEX_CHAOSCASTLE4:
; 3364 : 		iChaosCastleIndex = 3;

  00037	b8 03 00 00 00	 mov	 eax, 3

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN3@GetChaosCa@2:

; 3365 : 		break;
; 3366 : 	case MAP_INDEX_CHAOSCASTLE5:
; 3367 : 		iChaosCastleIndex = 4;

  00040	b8 04 00 00 00	 mov	 eax, 4

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN2@GetChaosCa@2:

; 3368 : 		break;
; 3369 : 	case MAP_INDEX_CHAOSCASTLE6:
; 3370 : 		iChaosCastleIndex = 5;

  00049	b8 05 00 00 00	 mov	 eax, 5

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN1@GetChaosCa@2:

; 3371 : 		break;
; 3372 : 	case MAP_INDEX_CHAOSCASTLE7:
; 3373 : 		iChaosCastleIndex = 6;

  00052	b8 06 00 00 00	 mov	 eax, 6
$LN8@GetChaosCa@2:

; 3374 : 		break;
; 3375 : 	}
; 3376 : 
; 3377 : 	return iChaosCastleIndex;
; 3378 : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
  0005b	90		 npad	 1
$LN13@GetChaosCa@2:
  0005c	00 00 00 00	 DD	 $LN7@GetChaosCa@2
  00060	00 00 00 00	 DD	 $LN6@GetChaosCa@2
  00064	00 00 00 00	 DD	 $LN5@GetChaosCa@2
  00068	00 00 00 00	 DD	 $LN4@GetChaosCa@2
  0006c	00 00 00 00	 DD	 $LN3@GetChaosCa@2
  00070	00 00 00 00	 DD	 $LN2@GetChaosCa@2
  00074	00 00 00 00	 DD	 $LN1@GetChaosCa@2
  00078	00 00 00 00	 DD	 $LN8@GetChaosCa@2
$LN12@GetChaosCa@2:
  0007c	00		 DB	 0
  0007d	01		 DB	 1
  0007e	02		 DB	 2
  0007f	03		 DB	 3
  00080	04		 DB	 4
  00081	05		 DB	 5
  00082	07		 DB	 7
  00083	07		 DB	 7
  00084	07		 DB	 7
  00085	07		 DB	 7
  00086	07		 DB	 7
  00087	07		 DB	 7
  00088	07		 DB	 7
  00089	07		 DB	 7
  0008a	07		 DB	 7
  0008b	07		 DB	 7
  0008c	07		 DB	 7
  0008d	07		 DB	 7
  0008e	07		 DB	 7
  0008f	07		 DB	 7
  00090	07		 DB	 7
  00091	07		 DB	 7
  00092	07		 DB	 7
  00093	07		 DB	 7
  00094	07		 DB	 7
  00095	07		 DB	 7
  00096	07		 DB	 7
  00097	07		 DB	 7
  00098	07		 DB	 7
  00099	07		 DB	 7
  0009a	07		 DB	 7
  0009b	07		 DB	 7
  0009c	07		 DB	 7
  0009d	07		 DB	 7
  0009e	07		 DB	 7
  0009f	06		 DB	 6
?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetChaosCastleIndex
_TEXT	ENDS
PUBLIC	?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	33 d2		 xor	 edx, edx
  00004	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::empty
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
; Function compile flags: /Ogtp
;	COMDAT ?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	33 d2		 xor	 edx, edx
  00004	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBE_NXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::empty
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000f	0f 9c c0	 setl	 al

; 126  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBE_NPBUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXPAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@XZ ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int> >::_Inside
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z PROC ; std::vector<int,std::allocator<int> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@2
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@2
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@2:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with null pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 41   : 		}

  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEABUCHAOSCASTLE_START_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@3
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@3
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@3:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBE_NPBUtagPOINT@@@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXPAUtagPOINT@@0@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::~_Vector_val<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagPOINT@@@std@@QAE@XZ		; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UtagPOINT@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UtagPOINT@@@std@@QAE@XZ PROC		; std::allocator<tagPOINT>::allocator<tagPOINT>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UtagPOINT@@@std@@QAE@XZ ENDP		; std::allocator<tagPOINT>::allocator<tagPOINT>
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 19	 add	 eax, 25			; 00000019H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEXXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocator<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@I@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000a	cc		 int	 3
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat
; Function compile flags: /Ogtp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
; Function compile flags: /Ogtp
;	COMDAT ?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::size
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@3:
$LN3@Xlen@3:
  0000a	cc		 int	 3
?_Xlen@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z	; std::allocator<tagPOINT>::allocator<tagPOINT>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z PROC	; std::allocator<tagPOINT>::allocator<tagPOINT>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UtagPOINT@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<tagPOINT>::allocator<tagPOINT>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z PROC ; std::allocator<tagPOINT>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@I@Z ENDP ; std::allocator<tagPOINT>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEABUtagPOINT@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 18	 add	 eax, 24			; 00000018H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ; std::allocator<CHAOSCASTLE_START_TIME>::max_size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<CHAOSCASTLE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ	; std::allocator<tagPOINT>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ PROC	; std::allocator<tagPOINT>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UtagPOINT@@@std@@QBEIXZ ENDP	; std::allocator<tagPOINT>::max_size
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max
  0000f	90		 npad	 1
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=, COMDAT
; _this$ = ecx

; 151  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 		if (this->_Getcont() == 0
; 154  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 155  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 156  : 			{	// report error
; 157  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 158  : 			_SCL_SECURE_OUT_OF_RANGE;
; 159  : 			}
; 160  : 
; 161  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 162  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 163  : 		_SCL_SECURE_VALIDATE_RANGE(
; 164  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 165  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 166  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 167  : 
; 168  : 		_Ptr += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0000f	01 10		 add	 DWORD PTR [eax], edx

; 169  : 		return (*this);
; 170  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00008	75 40		 jne	 SHORT $LN3@operator

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00011	75 1a		 jne	 SHORT $LN34@operator

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00034	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00046	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::addressof<CHAOSCASTLE_START_TIME const >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::addressof<CHAOSCASTLE_START_TIME const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUCHAOSCASTLE_START_TIME@@@std@@YAPBUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::addressof<CHAOSCASTLE_START_TIME const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBH@std@@YAPBHABH@Z		; std::addressof<int const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBH@std@@YAPBHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBH@std@@YAPBHABH@Z PROC			; std::addressof<int const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBH@std@@YAPBHABH@Z ENDP			; std::addressof<int const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ; std::addressof<tagPOINT const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z PROC ; std::addressof<tagPOINT const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUtagPOINT@@@std@@YAPBUtagPOINT@@ABU1@@Z ENDP ; std::addressof<tagPOINT const >
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBHU_MONSTER_ITEM_DROP@@@?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0>::_Kfn<int const ,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node><std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00008	74 06		 je	 SHORT $LN8@operator@2

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@2:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00016	75 17		 jne	 SHORT $LN40@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@2
$LL22@operator@2:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@2

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@2:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00036	75 11		 jne	 SHORT $LN3@operator@2
$LL4@operator@2:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@2

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 19 00	 cmp	 BYTE PTR [edx+25], 0
  00047	74 ef		 je	 SHORT $LL4@operator@2
$LN3@operator@2:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@2:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@2:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
PUBLIC	??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z PROC ; std::forward<_MONSTER_ITEM_DROP &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU_MONSTER_ITEM_DROP@@@std@@YAAAU_MONSTER_ITEM_DROP@@AAU1@@Z ENDP ; std::forward<_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z PROC ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 164  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$_Pair_base@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::_Pair_base<int,_MONSTER_ITEM_DROP>::_Pair_base<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@std@@YA$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUCHAOSCASTLE_START_TIME@@@std@@YAAAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@AAUCHAOSCASTLE_START_TIME@@@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@AAU2@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::forward<CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUCHAOSCASTLE_START_TIME@@@std@@YAABUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UCHAOSCASTLE_START_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::_Ptr_cat<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z PROC	; std::allocator<int>::construct<int &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@construct@2:

; 209  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@AAH@?$allocator@H@std@@QAEXPAHAAH@Z ENDP	; std::allocator<int>::construct<int &>
_TEXT	ENDS
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
PUBLIC	??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z PROC ; std::forward<tagPOINT &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUtagPOINT@@@std@@YAAAUtagPOINT@@AAU1@@Z ENDP ; std::forward<tagPOINT &>
_TEXT	ENDS
PUBLIC	??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ; std::allocator<tagPOINT>::construct<tagPOINT &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z PROC ; std::allocator<tagPOINT>::construct<tagPOINT &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@3:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@AAUtagPOINT@@@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@AAU2@@Z ENDP ; std::allocator<tagPOINT>::construct<tagPOINT &>
_TEXT	ENDS
PUBLIC	??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ; std::forward<tagPOINT const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z PROC ; std::forward<tagPOINT const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUtagPOINT@@@std@@YAABUtagPOINT@@ABU1@@Z ENDP ; std::forward<tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ; std::_Ptr_cat<tagPOINT,tagPOINT>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z PROC ; std::_Ptr_cat<tagPOINT,tagPOINT>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UtagPOINT@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtagPOINT@@0@Z ENDP ; std::_Ptr_cat<tagPOINT,tagPOINT>
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@YAXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z PROC ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UCHAOSCASTLE_START_TIME@@ABU1@@std@@YAXPAUCHAOSCASTLE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Construct@2:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ; std::_Construct<tagPOINT,tagPOINT const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z PROC ; std::_Construct<tagPOINT,tagPOINT const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct@3:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UtagPOINT@@ABU1@@std@@YAXPAUtagPOINT@@ABU1@@Z ENDP ; std::_Construct<tagPOINT,tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z	; std::_Destroy<tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z PROC	; std::_Destroy<tagPOINT>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UtagPOINT@@@std@@YAXPAUtagPOINT@@@Z ENDP	; std::_Destroy<tagPOINT>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::move<CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::move<CHAOSCASTLE_START_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::move<CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ; std::_Val_type<CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z PROC ; std::_Val_type<CHAOSCASTLE_START_TIME *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@@Z ENDP ; std::_Val_type<CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAH@std@@YAPAHPAH@Z		; std::_Val_type<int *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Val_type<int *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Val_type<int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>
EXTRN	_memmove:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<int,int,int>, COMDAT

; 456  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 457  : 	_DEBUG_RANGE(_First, _Last);
; 458  : 	_DEBUG_POINTER(_Dest);
; 459  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2

; 460  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 461  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 462  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Uninit_move@HHH@std@@YAPAHPAH00AAV?$allocator@H@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int,int,int>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ; std::_Val_type<tagPOINT *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z PROC ; std::_Val_type<tagPOINT *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUtagPOINT@@@std@@YAPAUtagPOINT@@PAU1@@Z ENDP ; std::_Val_type<tagPOINT *>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ; std::_Destroy<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::_Destroy<CHAOSCASTLE_START_TIME>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UCHAOSCASTLE_START_TIME@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::_Destroy<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ; std::forward<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z PROC ; std::forward<CHAOSCASTLE_START_TIME>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UCHAOSCASTLE_START_TIME@@@std@@YA$$QAUCHAOSCASTLE_START_TIME@@AAU1@@Z ENDP ; std::forward<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ; std::forward<tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z PROC ; std::forward<tagPOINT>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UtagPOINT@@@std@@YA$$QAUtagPOINT@@AAU1@@Z ENDP ; std::forward<tagPOINT>
_TEXT	ENDS
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
PUBLIC	??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ; std::forward<_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z PROC ; std::forward<_MONSTER_ITEM_DROP>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_MONSTER_ITEM_DROP@@@std@@YA$$QAU_MONSTER_ITEM_DROP@@AAU1@@Z ENDP ; std::forward<_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z PROC ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 164  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$?0HU_MONSTER_ITEM_DROP@@@?$_Pair_base@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAH$$QAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::_Pair_base<int const ,_MONSTER_ITEM_DROP>::_Pair_base<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??0_CHAOSCASTLE_USER@@QAE@XZ			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.h
;	COMDAT ??0_CHAOSCASTLE_USER@@QAE@XZ
_TEXT	SEGMENT
??0_CHAOSCASTLE_USER@@QAE@XZ PROC			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER, COMDAT
; _this$ = ecx

; 157  : 	_CHAOSCASTLE_USER()	// line : 338

  00000	8b c1		 mov	 eax, ecx

; 158  : 	{
; 159  : 		this->Clear();

  00002	33 c9		 xor	 ecx, ecx
  00004	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00013	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 160  : 	};	// line : 340

  00016	c3		 ret	 0
??0_CHAOSCASTLE_USER@@QAE@XZ ENDP			; _CHAOSCASTLE_USER::_CHAOSCASTLE_USER
_TEXT	ENDS
PUBLIC	?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z	; CChaosCastle::SetMapAttrHollow
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
;	COMDAT ?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
tv417 = 12						; size = 4
_iTRAP_STEP$ = 12					; size = 4
?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SetMapAttrHollow, COMDAT
; _this$ = ecx

; 844  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 845  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	85 c9		 test	 ecx, ecx
  0000c	0f 88 98 00 00
	00		 js	 $LN7@SetMapAttr
  00012	33 c0		 xor	 eax, eax
  00014	83 f9 06	 cmp	 ecx, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 88 00 00
	00		 je	 $LN7@SetMapAttr

; 846  : 	{
; 847  : 		return;
; 848  : 	}
; 849  : 
; 850  : 	if ( CC_TRAP_STEP_RANGE(iTRAP_STEP) == FALSE )

  00022	56		 push	 esi
  00023	8b 75 0c	 mov	 esi, DWORD PTR _iTRAP_STEP$[ebp]
  00026	85 f6		 test	 esi, esi
  00028	78 7f		 js	 SHORT $LN26@SetMapAttr
  0002a	33 c0		 xor	 eax, eax
  0002c	83 fe 03	 cmp	 esi, 3
  0002f	0f 9e c0	 setle	 al
  00032	85 c0		 test	 eax, eax
  00034	74 73		 je	 SHORT $LN26@SetMapAttr

; 851  : 	{
; 852  : 		return;
; 853  : 	}
; 854  : 
; 855  : 	if ( iTRAP_STEP == 0 )

  00036	85 f6		 test	 esi, esi
  00038	74 6f		 je	 SHORT $LN26@SetMapAttr

; 856  : 	{
; 857  : 		return;
; 858  : 	}
; 859  : 
; 860  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  0003a	c1 e6 06	 shl	 esi, 6
  0003d	53		 push	 ebx
  0003e	81 c6 0c 00 00
	00		 add	 esi, OFFSET _g_iChaosCastle_MapHollowZone+12
  00044	c7 45 0c 04 00
	00 00		 mov	 DWORD PTR tv417[ebp], 4
  0004b	57		 push	 edi
  0004c	8d 64 24 00	 npad	 4
$LL9@SetMapAttr:

; 861  : 	{
; 862  : 		for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00050	8b 5e f4	 mov	 ebx, DWORD PTR [esi-12]
  00053	3b 5e fc	 cmp	 ebx, DWORD PTR [esi-4]
  00056	7f 47		 jg	 SHORT $LN8@SetMapAttr

; 856  : 	{
; 857  : 		return;
; 858  : 	}
; 859  : 
; 860  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL25@SetMapAttr:

; 863  : 		{
; 864  : 			for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  00060	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  00063	3b d0		 cmp	 edx, eax
  00065	7f 32		 jg	 SHORT $LN5@SetMapAttr

; 865  : 			{
; 866  : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  00067	51		 push	 ecx
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00070	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00076	8b ca		 mov	 ecx, edx
  00078	8d b8 10 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0007e	c1 e1 08	 shl	 ecx, 8
$LL3@SetMapAttr:

; 867  : 				MapC[iMapNumber].m_attrbuf[ c * 256 + b] |= 8;

  00081	8b 07		 mov	 eax, DWORD PTR [edi]
  00083	03 c1		 add	 eax, ecx
  00085	80 0c 18 08	 or	 BYTE PTR [eax+ebx], 8
  00089	8b 06		 mov	 eax, DWORD PTR [esi]
  0008b	42		 inc	 edx
  0008c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00092	3b d0		 cmp	 edx, eax
  00094	7e eb		 jle	 SHORT $LL3@SetMapAttr

; 863  : 		{
; 864  : 			for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  00096	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@SetMapAttr:

; 861  : 	{
; 862  : 		for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00099	43		 inc	 ebx
  0009a	3b 5e fc	 cmp	 ebx, DWORD PTR [esi-4]
  0009d	7e c1		 jle	 SHORT $LL25@SetMapAttr
$LN8@SetMapAttr:

; 856  : 	{
; 857  : 		return;
; 858  : 	}
; 859  : 
; 860  : 	for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  0009f	83 c6 10	 add	 esi, 16			; 00000010H
  000a2	ff 4d 0c	 dec	 DWORD PTR tv417[ebp]
  000a5	75 a9		 jne	 SHORT $LL9@SetMapAttr
  000a7	5f		 pop	 edi
  000a8	5b		 pop	 ebx
$LN26@SetMapAttr:
  000a9	5e		 pop	 esi
$LN7@SetMapAttr:

; 868  : 			}
; 869  : 		}
; 870  : 	}
; 871  : 	
; 872  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SetMapAttrHollow
_TEXT	ENDS
PUBLIC	?SetMapAttrFill@CChaosCastle@@QAEXH@Z		; CChaosCastle::SetMapAttrFill
; Function compile flags: /Ogtp
;	COMDAT ?SetMapAttrFill@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv408 = -8						; size = 4
_b$219156 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetMapAttrFill@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SetMapAttrFill, COMDAT
; _this$ = ecx

; 875  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	0f 88 89 00 00
	00		 js	 $LN10@SetMapAttr@2
  00014	33 c0		 xor	 eax, eax
  00016	83 f9 06	 cmp	 ecx, 6
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 79 00 00
	00		 je	 $LN10@SetMapAttr@2

; 877  : 	{
; 878  : 		return;
; 879  : 	}
; 880  : 	
; 881  : 	for ( int iTRAP_STEP=1;iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	be 4c 00 00 00	 mov	 esi, OFFSET _g_iChaosCastle_MapHollowZone+76
  0002c	8d 64 24 00	 npad	 4
$LL12@SetMapAttr@2:

; 882  : 	{
; 883  : 		for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  00030	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR tv408[ebp], 4
$LL9@SetMapAttr@2:

; 884  : 		{
; 885  : 			for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00037	8b 5e f4	 mov	 ebx, DWORD PTR [esi-12]
  0003a	89 5d fc	 mov	 DWORD PTR _b$219156[ebp], ebx
  0003d	3b 5e fc	 cmp	 ebx, DWORD PTR [esi-4]
  00040	7f 48		 jg	 SHORT $LN8@SetMapAttr@2
  00042	8b 06		 mov	 eax, DWORD PTR [esi]
$LL27@SetMapAttr@2:

; 886  : 			{
; 887  : 				for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  00044	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  00047	3b d0		 cmp	 edx, eax
  00049	7f 36		 jg	 SHORT $LN5@SetMapAttr@2

; 888  : 				{
; 889  : 					int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  0004b	51		 push	 ecx
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00054	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  0005a	8b ca		 mov	 ecx, edx
  0005c	8d b8 10 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00062	c1 e1 08	 shl	 ecx, 8
$LL26@SetMapAttr@2:

; 890  : 					MapC[iMapNumber].m_attrbuf[ c * 256 + b] &= ~8;

  00065	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00068	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0006a	80 24 18 f7	 and	 BYTE PTR [eax+ebx], 247	; 000000f7H
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 5d fc	 mov	 ebx, DWORD PTR _b$219156[ebp]
  00073	42		 inc	 edx
  00074	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  0007a	3b d0		 cmp	 edx, eax
  0007c	7e e7		 jle	 SHORT $LL26@SetMapAttr@2

; 886  : 			{
; 887  : 				for ( int c=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][1] ; c<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][3] ; c++)

  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
$LN5@SetMapAttr@2:

; 884  : 		{
; 885  : 			for ( int b=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][0] ; b<=::g_iChaosCastle_MapHollowZone[iTRAP_STEP][a][2] ; b++)

  00081	43		 inc	 ebx
  00082	89 5d fc	 mov	 DWORD PTR _b$219156[ebp], ebx
  00085	3b 5e fc	 cmp	 ebx, DWORD PTR [esi-4]
  00088	7e ba		 jle	 SHORT $LL27@SetMapAttr@2
$LN8@SetMapAttr@2:

; 882  : 	{
; 883  : 		for ( int a=0;a<MAX_CC_HOLLOW_ZONE;a++)

  0008a	83 c6 10	 add	 esi, 16			; 00000010H
  0008d	ff 4d f8	 dec	 DWORD PTR tv408[ebp]
  00090	75 a5		 jne	 SHORT $LL9@SetMapAttr@2

; 877  : 	{
; 878  : 		return;
; 879  : 	}
; 880  : 	
; 881  : 	for ( int iTRAP_STEP=1;iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00092	81 fe 0c 01 00
	00		 cmp	 esi, OFFSET _g_iChaosCastle_MapHollowZone+268
  00098	7c 96		 jl	 SHORT $LL12@SetMapAttr@2
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
$LN10@SetMapAttr@2:

; 891  : 				}
; 892  : 			}
; 893  : 		}
; 894  : 	}
; 895  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?SetMapAttrFill@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SetMapAttrFill
_TEXT	ENDS
PUBLIC	?ClearMonster@CChaosCastle@@QAEXH@Z		; CChaosCastle::ClearMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Ogtp
;	COMDAT ?ClearMonster@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ClearMonster@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ClearMonster, COMDAT
; _this$ = ecx

; 1063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1064 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 52		 js	 SHORT $LN2@ClearMonst
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 46		 je	 SHORT $LN2@ClearMonst

; 1070 : 	{
; 1071 : 		if ( gObj[n].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex))

  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	50		 push	 eax
  0001a	33 ff		 xor	 edi, edi
  0001c	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00021	8b d8		 mov	 ebx, eax
  00023	33 f6		 xor	 esi, esi
  00025	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL4@ClearMonst:
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  0003d	3b cb		 cmp	 ecx, ebx
  0003f	75 09		 jne	 SHORT $LN3@ClearMonst

; 1072 : 		{
; 1073 : 			gObjDel(n);

  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00047	83 c4 04	 add	 esp, 4
$LN3@ClearMonst:

; 1065 : 	{
; 1066 : 		return;
; 1067 : 	}
; 1068 : 
; 1069 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0004a	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00050	47		 inc	 edi
  00051	81 fe 80 76 97
	08		 cmp	 esi, 144144000		; 08977680H
  00057	7c d7		 jl	 SHORT $LL4@ClearMonst
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
$LN2@ClearMonst:

; 1074 : 		}
; 1075 : 	}
; 1076 : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?ClearMonster@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ClearMonster
_TEXT	ENDS
PUBLIC	?ProcessFallUser@CChaosCastle@@QAEXH@Z		; CChaosCastle::ProcessFallUser
; Function compile flags: /Ogtp
;	COMDAT ?ProcessFallUser@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv177 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcessFallUser@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ProcessFallUser, COMDAT
; _this$ = ecx

; 1607 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1608 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00006	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	85 c0		 test	 eax, eax
  0000e	0f 88 14 01 00
	00		 js	 $LN3@ProcessFal
  00014	33 d2		 xor	 edx, edx
  00016	83 f8 06	 cmp	 eax, 6
  00019	0f 9e c2	 setle	 dl
  0001c	85 d2		 test	 edx, edx
  0001e	0f 84 04 01 00
	00		 je	 $LN3@ProcessFal

; 1609 : 	{
; 1610 : 		return;
; 1611 : 	}
; 1612 : 
; 1613 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  00024	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	8d 9c 08 74 07
	00 00		 lea	 ebx, DWORD PTR [eax+ecx+1908]
  00034	c7 45 fc 46 00
	00 00		 mov	 DWORD PTR tv177[ebp], 70 ; 00000046H
  0003b	eb 03 8d 49 00	 npad	 5
$LL5@ProcessFal:

; 1614 : 	{
; 1615 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL] != -1 )

  00040	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00042	83 ff ff	 cmp	 edi, -1
  00045	0f 84 ce 00 00
	00		 je	 $LN4@ProcessFal

; 1616 : 		{
; 1617 : 			int iFALL_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL];
; 1618 : 			InterlockedExchange(&this->m_stChaosCastleData[iChaosCastleIndex].m_lFallUser[iFALL], -1);

  0004b	6a ff		 push	 -1
  0004d	53		 push	 ebx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 1619 : 
; 1620 : 			if ( (gObj[iFALL_INDEX].MapNumber) == this->GetChaosCastleMapNumber(iChaosCastleIndex) &&  gObjIsConnected(iFALL_INDEX) &&  gObj[iFALL_INDEX].Life > 0 )

  00054	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b f7		 mov	 esi, edi
  0005c	50		 push	 eax
  0005d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00063	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	0f b6 94 0e 49
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+329]
  00076	3b d0		 cmp	 edx, eax
  00078	0f 85 9b 00 00
	00		 jne	 $LN4@ProcessFal
  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	0f 84 8a 00 00
	00		 je	 $LN4@ProcessFal
  0008f	d9 ee		 fldz
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00097	d8 94 0e fc 00
	00 00		 fcom	 DWORD PTR [esi+ecx+252]
  0009e	df e0		 fnstsw	 ax
  000a0	f6 c4 05	 test	 ah, 5
  000a3	7a 72		 jp	 SHORT $LN16@ProcessFal

; 1621 : 			{
; 1622 : 				gObj[iFALL_INDEX].Life = 0;

  000a5	d9 9c 0e fc 00
	00 00		 fstp	 DWORD PTR [esi+ecx+252]

; 1623 : 				gObj[iFALL_INDEX].m_State = 4;

  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b1	c7 84 06 20 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [esi+eax+544], 4

; 1624 : 				gObj[iFALL_INDEX].KillerType = 1;

  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c2	c6 84 0e a1 03
	00 00 01	 mov	 BYTE PTR [esi+ecx+929], 1

; 1625 : 				gObj[iFALL_INDEX].RegenTime = GetTickCount();

  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d6	89 84 16 a8 03
	00 00		 mov	 DWORD PTR [esi+edx+936], eax

; 1626 : 				gObj[iFALL_INDEX].DieRegen = 1;

  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	c6 84 06 a2 03
	00 00 01	 mov	 BYTE PTR [esi+eax+930], 1

; 1627 : 				gObj[iFALL_INDEX].PathCount = 0;

  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f0	c7 84 0e 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+388], 0

; 1628 : 				
; 1629 : 				GCDiePlayerSend(&gObj[iFALL_INDEX], gObj[iFALL_INDEX].m_Index, 0, 0);

  000fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00101	8b 0c 16	 mov	 ecx, DWORD PTR [esi+edx]
  00104	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	51		 push	 ecx
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  00112	83 c4 10	 add	 esp, 16			; 00000010H
  00115	eb 02		 jmp	 SHORT $LN4@ProcessFal
$LN16@ProcessFal:
  00117	dd d8		 fstp	 ST(0)
$LN4@ProcessFal:

; 1609 : 	{
; 1610 : 		return;
; 1611 : 	}
; 1612 : 
; 1613 : 	for ( int iFALL=0;iFALL<MAX_CHAOSCASTLE_USER;iFALL++)

  00119	83 c3 04	 add	 ebx, 4
  0011c	ff 4d fc	 dec	 DWORD PTR tv177[ebp]
  0011f	0f 85 1b ff ff
	ff		 jne	 $LL5@ProcessFal
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx
$LN3@ProcessFal:

; 1630 : 			}
; 1631 : 		}
; 1632 : 	}
; 1633 : }

  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 04 00	 ret	 4
?ProcessFallUser@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ProcessFallUser
_TEXT	ENDS
PUBLIC	?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z	; CChaosCastle::CalcSendRewardEXP
EXTRN	?GCKillPlayerExtSend@@YAXHH_JHH@Z:PROC		; GCKillPlayerExtSend
EXTRN	?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z:PROC ; gObjUserSetExp
EXTRN	?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; gObjSealUserSetExp
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	__ftol2:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_iRET_EXP$ = -16					; size = 8
_iCAL_EXP$ = -8						; size = 8
_iUserIndex$ = 8					; size = 4
_iMAX_LEVCOUNT$ = 12					; size = 4
_iEXP$ = 12						; size = 4
_iKILLCOUNT_USER$ = 16					; size = 4
_iKILLCOUNT_MONSTER$ = 20				; size = 4
?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z PROC	; CChaosCastle::CalcSendRewardEXP, COMDAT
; _this$ = ecx

; 1660 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 1661 : 	if ( iEXP <= 0 )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	85 f6		 test	 esi, esi
  0000f	7f 0a		 jg	 SHORT $LN9@CalcSendRe

; 1662 : 	{
; 1663 : 		return 0;

  00011	5f		 pop	 edi
  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 1712 : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
$LN9@CalcSendRe:

; 1664 : 	}
; 1665 : 
; 1666 : 	if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty )

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00020	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  00025	83 f8 01	 cmp	 eax, 1
  00028	75 29		 jne	 SHORT $LN8@CalcSendRe
  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  00031	74 20		 je	 SHORT $LN8@CalcSendRe

; 1667 : 	{
; 1668 : 		iEXP = iEXP * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;

  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00038	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  0003d	8b c8		 mov	 ecx, eax
  0003f	0f af ce	 imul	 ecx, esi
  00042	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00047	f7 e9		 imul	 ecx
  00049	c1 fa 05	 sar	 edx, 5
  0004c	8b f2		 mov	 esi, edx
  0004e	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00051	03 f2		 add	 esi, edx
$LN8@CalcSendRe:

; 1669 : 	}
; 1670 : 
; 1671 : 	__int64 iRET_EXP = 0;
; 1672 : 	__int64 iCAL_EXP = iEXP;
; 1673 : 
; 1674 : 	int iMAX_LEVCOUNT = 0;
; 1675 : 
; 1676 : 	if ( !gObjIsConnected(iUserIndex))

  00053	53		 push	 ebx
  00054	8b 5d 08	 mov	 ebx, DWORD PTR _iUserIndex$[ebp]
  00057	8b c6		 mov	 eax, esi
  00059	99		 cdq
  0005a	53		 push	 ebx
  0005b	89 45 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  0005e	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  00061	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _iMAX_LEVCOUNT$[ebp], 0
  00068	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0006d	83 c4 04	 add	 esp, 4
  00070	85 c0		 test	 eax, eax
  00072	75 09		 jne	 SHORT $LN7@CalcSendRe
  00074	5b		 pop	 ebx
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 1712 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 10 00	 ret	 16			; 00000010H
$LN7@CalcSendRe:

; 1677 : 	{
; 1678 : 		return 0;
; 1679 : 	}
; 1680 : 
; 1681 : 	iRET_EXP = iCAL_EXP;
; 1682 : 
; 1683 : 	if ( gObj[iUserIndex].Type == OBJ_USER )

  0007d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	8b 45 f8	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  00086	8b 55 fc	 mov	 edx, DWORD PTR _iCAL_EXP$[ebp+4]
  00089	8b f3		 mov	 esi, ebx
  0008b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00091	66 83 7c 0e 68
	01		 cmp	 WORD PTR [esi+ecx+104], 1
  00097	89 45 f0	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  0009a	89 55 f4	 mov	 DWORD PTR _iRET_EXP$[ebp+4], edx
  0009d	0f 85 d3 00 00
	00		 jne	 $LN20@CalcSendRe

; 1684 : 	{
; 1685 : 		while ( iCAL_EXP > 0 )

  000a3	85 d2		 test	 edx, edx
  000a5	0f 8c 9e 00 00
	00		 jl	 $LN19@CalcSendRe
  000ab	7f 12		 jg	 SHORT $LN15@CalcSendRe
  000ad	85 c0		 test	 eax, eax
  000af	0f 84 94 00 00
	00		 je	 $LN19@CalcSendRe
$LL5@CalcSendRe:

; 1686 : 		{
; 1687 : 			if ( iCAL_EXP > 0 )

  000b5	85 d2		 test	 edx, edx
  000b7	7c 73		 jl	 SHORT $LN3@CalcSendRe
  000b9	7f 04		 jg	 SHORT $LN15@CalcSendRe
  000bb	85 c0		 test	 eax, eax
  000bd	74 6d		 je	 SHORT $LN3@CalcSendRe
$LN15@CalcSendRe:

; 1688 : 			{
; 1689 : 				gObjSealUserSetExp(&gObj[iUserIndex], iCAL_EXP, TRUE); //Seal Exp

  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	6a 01		 push	 1
  000c6	8d 55 f8	 lea	 edx, DWORD PTR _iCAL_EXP$[ebp]
  000c9	52		 push	 edx
  000ca	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp

; 1690 : 				gObjUserSetExp(&gObj[iUserIndex],iCAL_EXP);	//Panda Use

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d8	8d 55 f8	 lea	 edx, DWORD PTR _iCAL_EXP$[ebp]
  000db	52		 push	 edx
  000dc	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp

; 1691 : 
; 1692 : 				iCAL_EXP = (__int64)((int)(iCAL_EXP) * this->m_stChaosCastleData[gObj[iUserIndex].m_cChaosCastleIndex].m_iCC_REWARD_EXP); //season 4.5 add-on

  000e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000eb	0f be 84 16 a5
	0e 00 00	 movsx	 eax, BYTE PTR [esi+edx+3749]
  000f3	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  000f9	83 c4 14	 add	 esp, 20			; 00000014H
  000fc	d9 84 38 9c 08
	00 00		 fld	 DWORD PTR [eax+edi+2204]
  00103	da 4d f8	 fimul	 DWORD PTR _iCAL_EXP$[ebp]
  00106	e8 00 00 00 00	 call	 __ftol2
  0010b	8b c8		 mov	 ecx, eax

; 1693 : 				iRET_EXP = (int)(iCAL_EXP); //season 4.5 changed + fix
; 1694 : 				iCAL_EXP = this->LevelUp(iUserIndex, iCAL_EXP, 3);

  0010d	6a 03		 push	 3
  0010f	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  00112	99		 cdq
  00113	51		 push	 ecx
  00114	89 4d f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], ecx
  00117	53		 push	 ebx
  00118	8b cf		 mov	 ecx, edi
  0011a	89 45 f0	 mov	 DWORD PTR _iRET_EXP$[ebp], eax
  0011d	89 55 f4	 mov	 DWORD PTR _iRET_EXP$[ebp+4], edx
  00120	e8 00 00 00 00	 call	 ?LevelUp@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::LevelUp
  00125	99		 cdq
  00126	89 45 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  00129	89 55 fc	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
$LN3@CalcSendRe:

; 1695 : 			}
; 1696 : 
; 1697 : 			iMAX_LEVCOUNT++;

  0012c	8b 4d 0c	 mov	 ecx, DWORD PTR _iMAX_LEVCOUNT$[ebp]
  0012f	41		 inc	 ecx
  00130	89 4d 0c	 mov	 DWORD PTR _iMAX_LEVCOUNT$[ebp], ecx

; 1698 : 
; 1699 : 			if ( iMAX_LEVCOUNT > 1000 )

  00133	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00139	7f 0e		 jg	 SHORT $LN19@CalcSendRe

; 1684 : 	{
; 1685 : 		while ( iCAL_EXP > 0 )

  0013b	85 d2		 test	 edx, edx
  0013d	7f 80		 jg	 SHORT $LN15@CalcSendRe
  0013f	7c 08		 jl	 SHORT $LN19@CalcSendRe
  00141	85 c0		 test	 eax, eax
  00143	0f 85 6c ff ff
	ff		 jne	 $LL5@CalcSendRe
$LN19@CalcSendRe:

; 1700 : 			{
; 1701 : 				break;
; 1702 : 			}
; 1703 : 		}
; 1704 : 
; 1705 : 		if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iUserIndex]) == FALSE) //season3 add-on

  00149	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00154	56		 push	 esi
  00155	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  0015a	85 c0		 test	 eax, eax
  0015c	75 18		 jne	 SHORT $LN20@CalcSendRe

; 1706 : 		{
; 1707 : 			GCKillPlayerExtSend(iUserIndex, (WORD)-1, iRET_EXP, 0, 0);

  0015e	8b 55 f4	 mov	 edx, DWORD PTR _iRET_EXP$[ebp+4]
  00161	50		 push	 eax
  00162	50		 push	 eax
  00163	8b 45 f0	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0016d	53		 push	 ebx
  0016e	e8 00 00 00 00	 call	 ?GCKillPlayerExtSend@@YAXHH_JHH@Z ; GCKillPlayerExtSend
  00173	83 c4 18	 add	 esp, 24			; 00000018H
$LN20@CalcSendRe:

; 1708 : 		}
; 1709 : 	}
; 1710 : 
; 1711 : 	return iRET_EXP;

  00176	8b 45 f0	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
  00179	5b		 pop	 ebx
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi

; 1712 : }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c2 10 00	 ret	 16			; 00000010H
?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z ENDP	; CChaosCastle::CalcSendRewardEXP
_TEXT	ENDS
PUBLIC	?GetCurPlayUser@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetCurPlayUser
; Function compile flags: /Ogtp
;	COMDAT ?GetCurPlayUser@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iPlayUser$ = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurPlayUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurPlayUser, COMDAT
; _this$ = ecx

; 2179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2180 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	85 ff		 test	 edi, edi
  0000d	78 0c		 js	 SHORT $LN13@GetCurPlay
  0000f	33 c0		 xor	 eax, eax
  00011	83 ff 06	 cmp	 edi, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	75 0a		 jne	 SHORT $LN6@GetCurPlay
$LN13@GetCurPlay:

; 2181 : 	{
; 2182 : 		return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5f		 pop	 edi

; 2200 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN6@GetCurPlay:

; 2183 : 	}
; 2184 : 
; 2185 : 	int iPlayUser = 0;

  00025	8b c7		 mov	 eax, edi
  00027	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0002d	53		 push	 ebx
  0002e	56		 push	 esi
  0002f	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iPlayUser$[ebp], 0
  00036	8d 74 08 6c	 lea	 esi, DWORD PTR [eax+ecx+108]
  0003a	bb 46 00 00 00	 mov	 ebx, 70			; 00000046H
  0003f	90		 npad	 1
$LL5@GetCurPlay:

; 2188 : 	{
; 2189 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 34		 je	 SHORT $LN4@GetCurPlay

; 2190 : 		{
; 2191 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 2192 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004d	83 c4 04	 add	 esp, 4
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 26		 jne	 SHORT $LN4@GetCurPlay
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  0005e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0006c	0f b6 8c 11 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+edx+329]
  00074	3b c8		 cmp	 ecx, eax
  00076	75 03		 jne	 SHORT $LN4@GetCurPlay

; 2193 : 			{
; 2194 : 				iPlayUser++;

  00078	ff 45 08	 inc	 DWORD PTR _iPlayUser$[ebp]
$LN4@GetCurPlay:

; 2186 : 
; 2187 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0007b	83 c6 14	 add	 esi, 20			; 00000014H
  0007e	4b		 dec	 ebx
  0007f	75 bf		 jne	 SHORT $LL5@GetCurPlay

; 2195 : 			}
; 2196 : 		}
; 2197 : 	}
; 2198 : 
; 2199 : 	return iPlayUser;

  00081	8b 45 08	 mov	 eax, DWORD PTR _iPlayUser$[ebp]
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	5f		 pop	 edi

; 2200 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?GetCurPlayUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurPlayUser
_TEXT	ENDS
PUBLIC	?CalDistance@CChaosCastle@@QAEHHHHH@Z		; CChaosCastle::CalDistance
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CalDistance@CChaosCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
tv170 = 8						; size = 4
tv167 = 8						; size = 4
tv138 = 8						; size = 4
tv136 = 8						; size = 4
_fTY$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_fTX$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?CalDistance@CChaosCastle@@QAEHHHHH@Z PROC		; CChaosCastle::CalDistance, COMDAT
; _this$ = ecx

; 2525 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2526 : 	if ( iX1 == iX2 && iY1 == iY2 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iX1$[ebp]
  00006	8b 55 10	 mov	 edx, DWORD PTR _iX2$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iY1$[ebp]
  0000c	56		 push	 esi
  0000d	8b 75 14	 mov	 esi, DWORD PTR _iY2$[ebp]
  00010	3b c2		 cmp	 eax, edx
  00012	75 0b		 jne	 SHORT $LN1@CalDistanc
  00014	3b ce		 cmp	 ecx, esi
  00016	75 07		 jne	 SHORT $LN1@CalDistanc

; 2527 : 	{
; 2528 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	5e		 pop	 esi

; 2535 : }

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
$LN1@CalDistanc:

; 2529 : 	}
; 2530 : 
; 2531 : 	float fTX = (float)(iX1 - iX2);

  0001f	2b c2		 sub	 eax, edx
  00021	89 45 08	 mov	 DWORD PTR tv170[ebp], eax
  00024	db 45 08	 fild	 DWORD PTR tv170[ebp]

; 2532 : 	float fTY = (float)(iY1 - iY2);

  00027	2b ce		 sub	 ecx, esi
  00029	89 4d 08	 mov	 DWORD PTR tv167[ebp], ecx
  0002c	d9 5d 10	 fstp	 DWORD PTR _fTX$[ebp]
  0002f	db 45 08	 fild	 DWORD PTR tv167[ebp]
  00032	d9 5d 08	 fstp	 DWORD PTR _fTY$[ebp]

; 2533 : 
; 2534 : 	return (int)sqrt( (fTX * fTX) + (fTY * fTY) );

  00035	d9 45 08	 fld	 DWORD PTR _fTY$[ebp]
  00038	d9 45 10	 fld	 DWORD PTR _fTX$[ebp]
  0003b	dc c8		 fmul	 ST(0), ST(0)
  0003d	d9 c1		 fld	 ST(1)
  0003f	de ca		 fmulp	 ST(2), ST(0)
  00041	de c1		 faddp	 ST(1), ST(0)
  00043	d9 5d 08	 fstp	 DWORD PTR tv138[ebp]
  00046	d9 45 08	 fld	 DWORD PTR tv138[ebp]
  00049	e8 00 00 00 00	 call	 __CIsqrt
  0004e	d9 5d 08	 fstp	 DWORD PTR tv136[ebp]
  00051	d9 45 08	 fld	 DWORD PTR tv136[ebp]
  00054	e8 00 00 00 00	 call	 __ftol2_sse
  00059	5e		 pop	 esi

; 2535 : }

  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
?CalDistance@CChaosCastle@@QAEHHHHH@Z ENDP		; CChaosCastle::CalDistance
_TEXT	ENDS
PUBLIC	?SafetyCastleZone@CChaosCastle@@QAEXH@Z		; CChaosCastle::SafetyCastleZone
; Function compile flags: /Ogtp
;	COMDAT ?SafetyCastleZone@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv280 = -8						; size = 4
_iMapNumber$ = -4					; size = 4
tv250 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SafetyCastleZone@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SafetyCastleZone, COMDAT
; _this$ = ecx

; 2560 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2561 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	0f 88 fb 00 00
	00		 js	 $LN7@SafetyCast
  00012	33 c0		 xor	 eax, eax
  00014	83 fb 06	 cmp	 ebx, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 eb 00 00
	00		 je	 $LN7@SafetyCast

; 2562 : 	{
; 2563 : 		return;
; 2564 : 	}
; 2565 : 
; 2566 : 	int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber

; 2567 : 
; 2568 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  0002a	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4]
  00032	89 45 fc	 mov	 DWORD PTR _iMapNumber$[ebp], eax
  00035	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  0003d	3b f8		 cmp	 edi, eax
  0003f	7f 5b		 jg	 SHORT $LN13@SafetyCast
  00041	0f b6 0c 9d 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL33@SafetyCast:

; 2569 : 	{
; 2570 : 		for(int j=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1] ; j <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3] ; j++ )

  00050	0f b6 34 9d 01
	00 00 00	 movzx	 esi, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+1]
  00058	3b f1		 cmp	 esi, ecx
  0005a	7f 33		 jg	 SHORT $LN14@SafetyCast
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  0005f	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00065	8b d6		 mov	 edx, esi
  00067	8d 80 10 00 00
	00		 lea	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0006d	c1 e2 08	 shl	 edx, 8
$LL12@SafetyCast:

; 2571 : 		{
; 2572 : 			MapC[iMapNumber].m_attrbuf[ j * 256 + i] |= 1;

  00070	8b 18		 mov	 ebx, DWORD PTR [eax]
  00072	8d 0c 3a	 lea	 ecx, DWORD PTR [edx+edi]
  00075	80 0c 19 01	 or	 BYTE PTR [ecx+ebx], 1
  00079	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  0007c	0f b6 0c 9d 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  00084	46		 inc	 esi
  00085	81 c2 00 01 00
	00		 add	 edx, 256		; 00000100H
  0008b	3b f1		 cmp	 esi, ecx
  0008d	7e e1		 jle	 SHORT $LL12@SafetyCast
$LN14@SafetyCast:

; 2567 : 
; 2568 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  0008f	0f b6 14 9d 02
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  00097	47		 inc	 edi
  00098	3b fa		 cmp	 edi, edx
  0009a	7e b4		 jle	 SHORT $LL33@SafetyCast
$LN13@SafetyCast:

; 2573 : 		}
; 2574 : 	}
; 2575 : 
; 2576 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  0009c	8d 3c dd 03 00
	00 00		 lea	 edi, DWORD PTR _g_btCastleCenterHollowZoneMapXY[ebx*8+3]
  000a3	c7 45 08 02 00
	00 00		 mov	 DWORD PTR tv250[ebp], 2
  000aa	8d 9b 00 00 00
	00		 npad	 6
$LL9@SafetyCast:

; 2577 : 	{
; 2578 : 		for(int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  000b0	0f b6 5f fd	 movzx	 ebx, BYTE PTR [edi-3]
  000b4	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  000b8	3b d8		 cmp	 ebx, eax
  000ba	7f 47		 jg	 SHORT $LN8@SafetyCast
  000bc	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000bf	90		 npad	 1
$LL34@SafetyCast:

; 2579 : 		{
; 2580 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  000c0	0f b6 77 fe	 movzx	 esi, BYTE PTR [edi-2]
  000c4	3b f1		 cmp	 esi, ecx
  000c6	7f 32		 jg	 SHORT $LN5@SafetyCast
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  000cb	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000d1	8d 91 10 00 00
	00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  000d7	89 55 f8	 mov	 DWORD PTR tv280[ebp], edx
  000da	8b d6		 mov	 edx, esi
  000dc	c1 e2 08	 shl	 edx, 8
  000df	90		 npad	 1
$LL31@SafetyCast:

; 2581 : 			{
; 2582 : 				MapC[iMapNumber].m_attrbuf[ j * 256 + i] |= 8;

  000e0	8b 4d f8	 mov	 ecx, DWORD PTR tv280[ebp]
  000e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e5	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000e8	80 0c 01 08	 or	 BYTE PTR [ecx+eax], 8
  000ec	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000ef	46		 inc	 esi
  000f0	81 c2 00 01 00
	00		 add	 edx, 256		; 00000100H
  000f6	3b f1		 cmp	 esi, ecx
  000f8	7e e6		 jle	 SHORT $LL31@SafetyCast
$LN5@SafetyCast:

; 2577 : 	{
; 2578 : 		for(int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  000fa	0f b6 57 ff	 movzx	 edx, BYTE PTR [edi-1]
  000fe	43		 inc	 ebx
  000ff	3b da		 cmp	 ebx, edx
  00101	7e bd		 jle	 SHORT $LL34@SafetyCast
$LN8@SafetyCast:

; 2573 : 		}
; 2574 : 	}
; 2575 : 
; 2576 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  00103	83 c7 04	 add	 edi, 4
  00106	ff 4d 08	 dec	 DWORD PTR tv250[ebp]
  00109	75 a5		 jne	 SHORT $LL9@SafetyCast
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
$LN7@SafetyCast:
  0010d	5b		 pop	 ebx

; 2583 : 			}
; 2584 : 		}
; 2585 : 	}
; 2586 : }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 04 00	 ret	 4
?SafetyCastleZone@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SafetyCastleZone
_TEXT	ENDS
PUBLIC	?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z	; CChaosCastle::UnSafetyCastleZone
; Function compile flags: /Ogtp
;	COMDAT ?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv280 = -8						; size = 4
_iMapNumber$ = -4					; size = 4
tv250 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::UnSafetyCastleZone, COMDAT
; _this$ = ecx

; 2589 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2590 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	0f 88 fb 00 00
	00		 js	 $LN7@UnSafetyCa
  00012	33 c0		 xor	 eax, eax
  00014	83 fb 06	 cmp	 ebx, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 eb 00 00
	00		 je	 $LN7@UnSafetyCa

; 2591 : 	{
; 2592 : 		return;
; 2593 : 	}
; 2594 : 
; 2595 : 	int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	53		 push	 ebx
  00025	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber

; 2596 : 
; 2597 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  0002a	0f b6 3c 9d 00
	00 00 00	 movzx	 edi, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4]
  00032	89 45 fc	 mov	 DWORD PTR _iMapNumber$[ebp], eax
  00035	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  0003d	3b f8		 cmp	 edi, eax
  0003f	7f 5b		 jg	 SHORT $LN13@UnSafetyCa
  00041	0f b6 0c 9d 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL33@UnSafetyCa:

; 2598 : 	{
; 2599 : 		for(int j=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1] ; j <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3] ; j++ )

  00050	0f b6 34 9d 01
	00 00 00	 movzx	 esi, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+1]
  00058	3b f1		 cmp	 esi, ecx
  0005a	7f 33		 jg	 SHORT $LN14@UnSafetyCa
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  0005f	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00065	8b d6		 mov	 edx, esi
  00067	8d 80 10 00 00
	00		 lea	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0006d	c1 e2 08	 shl	 edx, 8
$LL12@UnSafetyCa:

; 2600 : 		{
; 2601 : 			MapC[iMapNumber].m_attrbuf[ j * 256 + i] &= ~1;

  00070	8b 18		 mov	 ebx, DWORD PTR [eax]
  00072	8d 0c 3a	 lea	 ecx, DWORD PTR [edx+edi]
  00075	80 24 19 fe	 and	 BYTE PTR [ecx+ebx], 254	; 000000feH
  00079	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  0007c	0f b6 0c 9d 03
	00 00 00	 movzx	 ecx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+3]
  00084	46		 inc	 esi
  00085	81 c2 00 01 00
	00		 add	 edx, 256		; 00000100H
  0008b	3b f1		 cmp	 esi, ecx
  0008d	7e e1		 jle	 SHORT $LL12@UnSafetyCa
$LN14@UnSafetyCa:

; 2596 : 
; 2597 : 	for ( int i=g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0] ; i <= g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2] ; i++ )

  0008f	0f b6 14 9d 02
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[ebx*4+2]
  00097	47		 inc	 edi
  00098	3b fa		 cmp	 edi, edx
  0009a	7e b4		 jle	 SHORT $LL33@UnSafetyCa
$LN13@UnSafetyCa:

; 2602 : 		}
; 2603 : 	}
; 2604 : 
; 2605 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  0009c	8d 3c dd 03 00
	00 00		 lea	 edi, DWORD PTR _g_btCastleCenterHollowZoneMapXY[ebx*8+3]
  000a3	c7 45 08 02 00
	00 00		 mov	 DWORD PTR tv250[ebp], 2
  000aa	8d 9b 00 00 00
	00		 npad	 6
$LL9@UnSafetyCa:

; 2606 : 	{
; 2607 : 		for(int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  000b0	0f b6 5f fd	 movzx	 ebx, BYTE PTR [edi-3]
  000b4	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  000b8	3b d8		 cmp	 ebx, eax
  000ba	7f 47		 jg	 SHORT $LN8@UnSafetyCa
  000bc	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000bf	90		 npad	 1
$LL34@UnSafetyCa:

; 2608 : 		{
; 2609 : 			for (int j=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][1] ; j<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][3] ; j++ )

  000c0	0f b6 77 fe	 movzx	 esi, BYTE PTR [edi-2]
  000c4	3b f1		 cmp	 esi, ecx
  000c6	7f 32		 jg	 SHORT $LN5@UnSafetyCa
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  000cb	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000d1	8d 91 10 00 00
	00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  000d7	89 55 f8	 mov	 DWORD PTR tv280[ebp], edx
  000da	8b d6		 mov	 edx, esi
  000dc	c1 e2 08	 shl	 edx, 8
  000df	90		 npad	 1
$LL31@UnSafetyCa:

; 2610 : 			{
; 2611 : 				MapC[iMapNumber].m_attrbuf[ j * 256 + i] |= 8;

  000e0	8b 4d f8	 mov	 ecx, DWORD PTR tv280[ebp]
  000e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e5	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000e8	80 0c 01 08	 or	 BYTE PTR [ecx+eax], 8
  000ec	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  000ef	46		 inc	 esi
  000f0	81 c2 00 01 00
	00		 add	 edx, 256		; 00000100H
  000f6	3b f1		 cmp	 esi, ecx
  000f8	7e e6		 jle	 SHORT $LL31@UnSafetyCa
$LN5@UnSafetyCa:

; 2606 : 	{
; 2607 : 		for(int i=g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][0] ; i<= g_btCastleCenterHollowZoneMapXY[iChaosCastleIndex][iHOLE_NUM][2] ; i++ )

  000fa	0f b6 57 ff	 movzx	 edx, BYTE PTR [edi-1]
  000fe	43		 inc	 ebx
  000ff	3b da		 cmp	 ebx, edx
  00101	7e bd		 jle	 SHORT $LL34@UnSafetyCa
$LN8@UnSafetyCa:

; 2602 : 		}
; 2603 : 	}
; 2604 : 
; 2605 : 	for ( int iHOLE_NUM = 0; iHOLE_NUM <2;iHOLE_NUM++)

  00103	83 c7 04	 add	 edi, 4
  00106	ff 4d 08	 dec	 DWORD PTR tv250[ebp]
  00109	75 a5		 jne	 SHORT $LL9@UnSafetyCa
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
$LN7@UnSafetyCa:
  0010d	5b		 pop	 ebx

; 2612 : 			}
; 2613 : 		}
; 2614 : 	}
; 2615 : }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 04 00	 ret	 4
?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::UnSafetyCastleZone
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_bDoSet$ = 12						; size = 1
?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z PROC	; CChaosCastle::SendCastleZoneSafetyInfo, COMDAT
; _this$ = ecx

; 2618 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 2619 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00015	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 d0 00 00
	00		 js	 $LN3@SendCastle
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 06	 cmp	 esi, 6
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 c0 00 00
	00		 je	 $LN3@SendCastle

; 2620 : 	{
; 2621 : 		return ;
; 2622 : 	}
; 2623 : 
; 2624 : 	char cTEMP_BUF[256];
; 2625 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2626 : 
; 2627 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	57		 push	 edi
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2628 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2629 : 
; 2630 : 	lpMsg->btType = 0;
; 2631 : 	lpMsg->btCount = 1;
; 2632 : 	lpMsg->btMapAttr = 1;
; 2633 : 
; 2634 : 	(bDoSet)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);
; 2635 : 
; 2636 : 	lpMsgBody[0].btX = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][0];

  00043	0f b6 14 b5 00
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4]

; 2637 : 	lpMsgBody[0].btY = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][1];

  0004b	8a 04 b5 01 00
	00 00		 mov	 al, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4+1]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	80 7d 0c 00	 cmp	 BYTE PTR _bDoSet$[ebp], 0
  00059	88 95 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], dl

; 2638 : 	lpMsgBody[1].btX   = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][2];
; 2639 : 	lpMsgBody[1].btY   = ::g_btCastleSafetyZoneMapXY[iChaosCastleIndex][3];

  0005f	0f b6 14 b5 03
	00 00 00	 movzx	 edx, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4+3]
  00067	0f 94 c1	 sete	 cl
  0006a	88 8d 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], cl
  00070	8a 0c b5 02 00
	00 00		 mov	 cl, BYTE PTR _g_btCastleSafetyZoneMapXY[esi*4+2]
  00077	88 8d 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], cl

; 2642 : 	{
; 2643 : 		if ( gObj[i].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  0007d	56		 push	 esi
  0007e	8b cb		 mov	 ecx, ebx
  00080	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  00087	66 c7 85 ff fe
	ff ff 00 01	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 256 ; 00000100H
  00090	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  00096	88 95 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], dl
  0009c	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  000a1	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  000a6	8b d8		 mov	 ebx, eax
  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ad	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL5@SendCastle:
  000b2	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  000ba	3b cb		 cmp	 ecx, ebx
  000bc	75 24		 jne	 SHORT $LN4@SendCastle

; 2644 : 		{
; 2645 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000be	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  000c3	7e 1d		 jle	 SHORT $LN4@SendCastle

; 2646 : 			{
; 2647 : 				DataSend(i, (LPBYTE)lpMsg, lpMsg->h.size);

  000c5	0f b6 95 fd fe
	ff ff		 movzx	 edx, BYTE PTR _cTEMP_BUF$[ebp+1]
  000cc	52		 push	 edx
  000cd	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  000d3	50		 push	 eax
  000d4	57		 push	 edi
  000d5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendCastle:

; 2640 : 
; 2641 : 	for (int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  000e2	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  000e8	47		 inc	 edi
  000e9	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  000ef	7c c1		 jl	 SHORT $LL5@SendCastle
  000f1	5f		 pop	 edi
$LN3@SendCastle:

; 2648 : 			}
; 2649 : 		}
; 2650 : 	}
; 2651 : }

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f5	5e		 pop	 esi
  000f6	33 cd		 xor	 ecx, ebp
  000f8	5b		 pop	 ebx
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ENDP	; CChaosCastle::SendCastleZoneSafetyInfo
_TEXT	ENDS
PUBLIC	??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PlayFailedRollBack@CChaosCastle@@QAEXH@Z	; CChaosCastle::PlayFailedRollBack
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
;	COMDAT ??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@
CONST	SEGMENT
??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Payback to User ChaosCastle Money'
	DB	' (FIRST:%d, PAYBACK:%d, FINAL:%d)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PlayFailedRollBack@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv614 = -292						; size = 4
_this$GSCopy$ = -288					; size = 4
_iPAYBACK_MONEY$220740 = -284				; size = 4
tv166 = -280						; size = 4
_Notice$220742 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?PlayFailedRollBack@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::PlayFailedRollBack, COMDAT
; _this$ = ecx

; 2786 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx

; 2798 : 			{
; 2799 : 				int iFIRST_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  0001a	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  00020	85 ff		 test	 edi, edi
  00022	0f 88 58 01 00
	00		 js	 $LN3@PlayFailed

; 2787 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00028	33 c0		 xor	 eax, eax
  0002a	83 ff 06	 cmp	 edi, 6
  0002d	0f 9e c0	 setle	 al
  00030	85 c0		 test	 eax, eax
  00032	0f 84 48 01 00
	00		 je	 $LN3@PlayFailed

; 2788 : 	{
; 2789 : 		return;
; 2790 : 	}
; 2791 : 
; 2792 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00038	8b c7		 mov	 eax, edi
  0003a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00040	56		 push	 esi
  00041	8d 74 18 6c	 lea	 esi, DWORD PTR [eax+ebx+108]
  00045	c7 85 e8 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv166[ebp], 70 ; 00000046H
  0004f	90		 npad	 1
$LL5@PlayFailed:

; 2793 : 	{
; 2794 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 06		 mov	 eax, DWORD PTR [esi]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	0f 84 15 01 00
	00		 je	 $LN4@PlayFailed

; 2795 : 		{
; 2796 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2797 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00061	83 c4 04	 add	 esp, 4
  00064	83 f8 01	 cmp	 eax, 1
  00067	0f 85 03 01 00
	00		 jne	 $LN4@PlayFailed
  0006d	57		 push	 edi
  0006e	8b cb		 mov	 ecx, ebx
  00070	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00075	8b 16		 mov	 edx, DWORD PTR [esi]
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00083	0f b6 94 0a 49
	01 00 00	 movzx	 edx, BYTE PTR [edx+ecx+329]
  0008b	3b d0		 cmp	 edx, eax
  0008d	0f 85 dd 00 00
	00		 jne	 $LN4@PlayFailed

; 2798 : 			{
; 2799 : 				int iFIRST_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  00093	8b 06		 mov	 eax, DWORD PTR [esi]

; 2800 : 				int iPAYBACK_MONEY = g_iChaosCastle_EnterCost[iChaosCastleIndex] + g_iChaosCastle_GuardSetValue[iChaosCastleIndex];

  00095	8b 14 bd 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_EnterCost[edi*4]
  0009c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000a2	8b 9c 08 f0 00
	00 00		 mov	 ebx, DWORD PTR [eax+ecx+240]
  000a9	8d 84 08 f0 00
	00 00		 lea	 eax, DWORD PTR [eax+ecx+240]
  000b0	8b 0c bd 00 00
	00 00		 mov	 ecx, DWORD PTR _g_iChaosCastle_GuardSetValue[edi*4]
  000b7	03 d1		 add	 edx, ecx
  000b9	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _iPAYBACK_MONEY$220740[ebp], edx

; 2801 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money += g_iChaosCastle_EnterCost[iChaosCastleIndex] + g_iChaosCastle_GuardSetValue[iChaosCastleIndex];

  000bf	8b 14 bd 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_EnterCost[edi*4]
  000c6	03 d3		 add	 edx, ebx
  000c8	03 d1		 add	 edx, ecx
  000ca	89 10		 mov	 DWORD PTR [eax], edx

; 2802 : 				int iNOW_MONEY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money;

  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	8b c8		 mov	 ecx, eax
  000d6	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000dc	8b 8c 11 f0 00
	00 00		 mov	 ecx, DWORD PTR [ecx+edx+240]

; 2803 : 
; 2804 : 				GCMoneySend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Money);

  000e3	51		 push	 ecx
  000e4	50		 push	 eax
  000e5	89 8d dc fe ff
	ff		 mov	 DWORD PTR tv614[ebp], ecx
  000eb	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 2805 : 				gObjMoveGate(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 22);

  000f0	8b 06		 mov	 eax, DWORD PTR [esi]
  000f2	6a 16		 push	 22			; 00000016H
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000fa	83 c4 10	 add	 esp, 16			; 00000010H

; 2806 : 
; 2807 : 				PMSG_NOTICE Notice;
; 2808 : 
; 2809 : 				TNotice::MakeNoticeMsgEx(&Notice, 1, lMsg.Get(MSGGET(4,212)));

  000fd	68 d4 04 00 00	 push	 1236			; 000004d4H
  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00107	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0010c	50		 push	 eax
  0010d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _Notice$220742[ebp]
  00113	6a 01		 push	 1
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 2810 : 
; 2811 : 				DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&Notice, Notice.h.size);

  0011b	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _Notice$220742[ebp+1]
  00122	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00124	52		 push	 edx
  00125	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _Notice$220742[ebp]
  0012b	50		 push	 eax
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2812 : 
; 2813 : 				LogAddTD("[Chaos Castle] (%d) [%s][%s] Payback to User ChaosCastle Money (FIRST:%d, PAYBACK:%d, FINAL:%d)",
; 2814 : 					iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2815 : 					gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2816 : 					iFIRST_MONEY, iPAYBACK_MONEY, iNOW_MONEY);

  00132	8b 16		 mov	 edx, DWORD PTR [esi]
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00139	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0013f	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv614[ebp]
  00145	51		 push	 ecx
  00146	03 c2		 add	 eax, edx
  00148	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _iPAYBACK_MONEY$220740[ebp]
  0014e	52		 push	 edx
  0014f	53		 push	 ebx
  00150	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00153	51		 push	 ecx
  00154	83 c0 6c	 add	 eax, 108		; 0000006cH
  00157	50		 push	 eax
  00158	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  0015b	52		 push	 edx
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JMGLBJMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pay@
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00167	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  0016d	83 c4 34	 add	 esp, 52			; 00000034H
$LN4@PlayFailed:

; 2788 : 	{
; 2789 : 		return;
; 2790 : 	}
; 2791 : 
; 2792 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00170	83 c6 14	 add	 esi, 20			; 00000014H
  00173	ff 8d e8 fe ff
	ff		 dec	 DWORD PTR tv166[ebp]
  00179	0f 85 d1 fe ff
	ff		 jne	 $LL5@PlayFailed
  0017f	5e		 pop	 esi
$LN3@PlayFailed:

; 2817 : 
; 2818 : 			}
; 2819 : 		}
; 2820 : 	}
; 2821 : }

  00180	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00183	5f		 pop	 edi
  00184	33 cd		 xor	 ecx, ebp
  00186	5b		 pop	 ebx
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 04 00	 ret	 4
?PlayFailedRollBack@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::PlayFailedRollBack
_TEXT	ENDS
PUBLIC	??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@ ; `string'
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RewardUserEXP@CChaosCastle@@QAEXHHH@Z		; CChaosCastle::RewardUserEXP
;	COMDAT ??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@
CONST	SEGMENT
??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Reward User EXP (USER_KILL:%d, MO'
	DB	'N_KILL:%d, TOT_EXP:%d, TOT_REWARD_EXP:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z
_TEXT	SEGMENT
_iKILLCOUNT_MONSTER$220759 = -288			; size = 4
_iChaosCastleIndex$GSCopy$ = -284			; size = 4
_this$GSCopy$ = -280					; size = 4
_iREWARD_EXP$220761 = -280				; size = 4
_pMsg$220762 = -276					; size = 269
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iChaosCastleSubIndex$ = 12				; size = 4
_bWinner$ = 16						; size = 4
?RewardUserEXP@CChaosCastle@@QAEXHHH@Z PROC		; CChaosCastle::RewardUserEXP, COMDAT
; _this$ = ecx

; 2835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _iChaosCastleSubIndex$[ebp]

; 2852 : 			{
; 2853 : 				return;
; 2854 : 			}
; 2855 : 
; 2856 : 			int iKILLCOUNT_USER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillUserCount;

  0001d	89 bd e8 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00023	89 b5 e4 fe ff
	ff		 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], esi
  00029	85 f6		 test	 esi, esi
  0002b	0f 88 8c 01 00
	00		 js	 $LN1@RewardUser

; 2836 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00031	33 c0		 xor	 eax, eax
  00033	83 fe 06	 cmp	 esi, 6
  00036	0f 9e c0	 setle	 al
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 7c 01 00
	00		 je	 $LN1@RewardUser

; 2837 : 	{
; 2838 : 		return;
; 2839 : 	}
; 2840 : 
; 2841 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  00041	85 c9		 test	 ecx, ecx
  00043	0f 88 74 01 00
	00		 js	 $LN1@RewardUser
  00049	33 c0		 xor	 eax, eax
  0004b	83 f9 45	 cmp	 ecx, 69			; 00000045H
  0004e	0f 9e c0	 setle	 al
  00051	85 c0		 test	 eax, eax
  00053	0f 84 64 01 00
	00		 je	 $LN1@RewardUser

; 2842 : 	{
; 2843 : 		return;
; 2844 : 	}
; 2845 : 
; 2846 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex != -1 )

  00059	8b c6		 mov	 eax, esi
  0005b	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0005e	03 c1		 add	 eax, ecx
  00060	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00063	8d 7c 87 6c	 lea	 edi, DWORD PTR [edi+eax*4+108]
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	53		 push	 ebx
  0006a	83 cb ff	 or	 ebx, -1
  0006d	3b c3		 cmp	 eax, ebx
  0006f	0f 84 47 01 00
	00		 je	 $LN13@RewardUser

; 2847 : 	{
; 2848 : 		if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex) ==TRUE )

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007b	83 c4 04	 add	 esp, 4
  0007e	83 f8 01	 cmp	 eax, 1
  00081	0f 85 35 01 00
	00		 jne	 $LN13@RewardUser

; 2849 : 		{
; 2850 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleIndex == -1 ||
; 2851 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleSubIndex == -1 )

  00087	8b 07		 mov	 eax, DWORD PTR [edi]
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00095	38 9c 08 a5 0e
	00 00		 cmp	 BYTE PTR [eax+ecx+3749], bl
  0009c	0f 84 1a 01 00
	00		 je	 $LN13@RewardUser
  000a2	38 9c 08 a6 0e
	00 00		 cmp	 BYTE PTR [eax+ecx+3750], bl
  000a9	0f 84 0d 01 00
	00		 je	 $LN13@RewardUser

; 2852 : 			{
; 2853 : 				return;
; 2854 : 			}
; 2855 : 
; 2856 : 			int iKILLCOUNT_USER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillUserCount;

  000af	8b 07		 mov	 eax, DWORD PTR [edi]

; 2857 : 			int iKILLCOUNT_MONSTER = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cKillMonsterCount;
; 2858 : 			int iTOT_EXP = iKILLCOUNT_USER * g_iChaosCastle_ExpTable[iChaosCastleIndex][0] + iKILLCOUNT_MONSTER * g_iChaosCastle_ExpTable[iChaosCastleIndex][1];

  000b1	8b 34 f5 04 00
	00 00		 mov	 esi, DWORD PTR _g_iChaosCastle_ExpTable[esi*8+4]
  000b8	8b d0		 mov	 edx, eax
  000ba	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000c0	0f be 9c 11 ac
	0e 00 00	 movsx	 ebx, BYTE PTR [ecx+edx+3756]
  000c8	0f be 8c 11 ad
	0e 00 00	 movsx	 ecx, BYTE PTR [ecx+edx+3757]
  000d0	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  000d6	0f af f1	 imul	 esi, ecx
  000d9	8b 14 d5 00 00
	00 00		 mov	 edx, DWORD PTR _g_iChaosCastle_ExpTable[edx*8]
  000e0	0f af d3	 imul	 edx, ebx

; 2859 : 
; 2860 : 			int iREWARD_EXP = this->CalcSendRewardEXP(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex, iTOT_EXP, iKILLCOUNT_USER, iKILLCOUNT_MONSTER);

  000e3	51		 push	 ecx
  000e4	53		 push	 ebx
  000e5	03 f2		 add	 esi, edx
  000e7	56		 push	 esi
  000e8	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _iKILLCOUNT_MONSTER$220759[ebp], ecx
  000ee	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CChaosCastle@@QAEHHHHH@Z ; CChaosCastle::CalcSendRewardEXP

; 2861 : 
; 2862 : 			PMSG_DEVILSQUARERESULT pMsg;
; 2863 : 
; 2864 : 			pMsg.MyRank = bWinner;
; 2865 : 			pMsg.Count = 0xFE;
; 2866 : 			memcpy(pMsg.Score[0].Name, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].Name, 10);

  000fa	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00102	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00108	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$220761[ebp], eax
  0010e	8a 45 10	 mov	 al, BYTE PTR _bWinner$[ebp]
  00111	88 85 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$220762[ebp+3], al
  00117	8d 44 11 77	 lea	 eax, DWORD PTR [ecx+edx+119]
  0011b	c6 85 f0 fe ff
	ff fe		 mov	 BYTE PTR _pMsg$220762[ebp+4], 254 ; 000000feH
  00122	8b 08		 mov	 ecx, DWORD PTR [eax]
  00124	89 8d f1 fe ff
	ff		 mov	 DWORD PTR _pMsg$220762[ebp+5], ecx
  0012a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 2867 : 			pMsg.Score[0].BonusExp = iTOT_EXP;
; 2868 : 			pMsg.Score[0].BonusZen = iKILLCOUNT_USER;
; 2869 : 			pMsg.Score[0].TotalScore = iKILLCOUNT_MONSTER;

  0012d	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _iKILLCOUNT_MONSTER$220759[ebp]
  00133	89 95 f5 fe ff
	ff		 mov	 DWORD PTR _pMsg$220762[ebp+9], edx
  00139	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]

; 2870 : 			PHeadSetB((LPBYTE)&pMsg, 0x93, 0x35);

  0013d	6a 35		 push	 53			; 00000035H
  0013f	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$220762[ebp]
  00145	68 93 00 00 00	 push	 147			; 00000093H
  0014a	52		 push	 edx
  0014b	66 89 85 f9 fe
	ff ff		 mov	 WORD PTR _pMsg$220762[ebp+13], ax
  00152	89 b5 01 ff ff
	ff		 mov	 DWORD PTR _pMsg$220762[ebp+21], esi
  00158	89 9d 05 ff ff
	ff		 mov	 DWORD PTR _pMsg$220762[ebp+25], ebx
  0015e	89 8d fd fe ff
	ff		 mov	 DWORD PTR _pMsg$220762[ebp+17], ecx
  00164	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2871 : 
; 2872 : 			DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00169	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$220762[ebp+1]
  00170	8b 17		 mov	 edx, DWORD PTR [edi]
  00172	50		 push	 eax
  00173	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$220762[ebp]
  00179	51		 push	 ecx
  0017a	52		 push	 edx
  0017b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2873 : 
; 2874 : 			LogAddTD("[Chaos Castle] (%d) [%s][%s] Reward User EXP (USER_KILL:%d, MON_KILL:%d, TOT_EXP:%d, TOT_REWARD_EXP:%d)",
; 2875 : 				iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].AccountID,
; 2876 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].Name,
; 2877 : 				iKILLCOUNT_USER, iKILLCOUNT_MONSTER, iTOT_EXP, iREWARD_EXP);

  00180	8b 07		 mov	 eax, DWORD PTR [edi]
  00182	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$220761[ebp]
  00188	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0018e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00194	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _iKILLCOUNT_MONSTER$220759[ebp]
  0019a	52		 push	 edx
  0019b	56		 push	 esi
  0019c	51		 push	 ecx
  0019d	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  001a0	53		 push	 ebx
  001a1	52		 push	 edx
  001a2	83 c0 6c	 add	 eax, 108		; 0000006cH
  001a5	50		 push	 eax
  001a6	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001ac	40		 inc	 eax
  001ad	50		 push	 eax
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LIKADFKD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Rew@
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b9	83 c4 38	 add	 esp, 56			; 00000038H
$LN13@RewardUser:
  001bc	5b		 pop	 ebx
$LN1@RewardUser:

; 2878 : 		}
; 2879 : 	}
; 2880 : }

  001bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	5f		 pop	 edi
  001c1	33 cd		 xor	 ecx, ebp
  001c3	5e		 pop	 esi
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 0c 00	 ret	 12			; 0000000cH
?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ENDP		; CChaosCastle::RewardUserEXP
_TEXT	ENDS
PUBLIC	?CalUsersInTrap@CChaosCastle@@QAEXH@Z		; CChaosCastle::CalUsersInTrap
EXTRN	?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjApplyBuffEffectDuration
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
; Function compile flags: /Ogtp
;	COMDAT ?CalUsersInTrap@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv295 = -8						; size = 4
tv152 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CalUsersInTrap@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::CalUsersInTrap, COMDAT
; _this$ = ecx

; 2911 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 2912 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iChaosCastleIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	0f 88 68 01 00
	00		 js	 $LN6@CalUsersIn
  00014	33 c0		 xor	 eax, eax
  00016	83 f9 06	 cmp	 ecx, 6
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 58 01 00
	00		 je	 $LN6@CalUsersIn

; 2913 : 		return;
; 2914 : 
; 2915 : 	if (this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS== 0 )

  00024	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  0002a	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0002d	56		 push	 esi
  0002e	8b 70 64	 mov	 esi, DWORD PTR [eax+100]
  00031	89 75 f8	 mov	 DWORD PTR tv295[ebp], esi
  00034	85 f6		 test	 esi, esi
  00036	0f 84 3f 01 00
	00		 je	 $LN22@CalUsersIn

; 2916 : 		return;
; 2917 : 
; 2918 : 	if ( !CHECK_LIMIT(this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS, 4))

  0003c	0f 88 39 01 00
	00		 js	 $LN22@CalUsersIn
  00042	33 c9		 xor	 ecx, ecx
  00044	83 fe 03	 cmp	 esi, 3
  00047	0f 9e c1	 setle	 cl
  0004a	85 c9		 test	 ecx, ecx
  0004c	0f 84 29 01 00
	00		 je	 $LN22@CalUsersIn

; 2919 : 		return;
; 2920 : 
; 2921 : 	int iTRAP_STEP = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS;

  00052	57		 push	 edi
  00053	8d 78 6c	 lea	 edi, DWORD PTR [eax+108]
  00056	c7 45 fc 46 00
	00 00		 mov	 DWORD PTR tv152[ebp], 70 ; 00000046H
  0005d	8d 49 00	 npad	 3
$LL8@CalUsersIn:

; 2924 : 	{
; 2925 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00060	8b 07		 mov	 eax, DWORD PTR [edi]
  00062	83 f8 ff	 cmp	 eax, -1
  00065	0f 84 03 01 00
	00		 je	 $LN7@CalUsersIn

; 2926 : 		{
; 2927 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 2928 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00071	83 c4 04	 add	 esp, 4
  00074	83 f8 01	 cmp	 eax, 1
  00077	0f 85 f1 00 00
	00		 jne	 $LN7@CalUsersIn
  0007d	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00080	8b 37		 mov	 esi, DWORD PTR [edi]
  00082	50		 push	 eax
  00083	8b cb		 mov	 ecx, ebx
  00085	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	8b d6		 mov	 edx, esi
  00092	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00098	0f b6 94 0a 49
	01 00 00	 movzx	 edx, BYTE PTR [edx+ecx+329]
  000a0	3b d0		 cmp	 edx, eax
  000a2	0f 85 c6 00 00
	00		 jne	 $LN7@CalUsersIn

; 2929 : 			{
; 2930 : 				int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  000a8	8b c6		 mov	 eax, esi
  000aa	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H

; 2931 : 				int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;

  000b0	0f bf 94 08 46
	01 00 00	 movsx	 edx, WORD PTR [eax+ecx+326]
  000b8	03 c1		 add	 eax, ecx
  000ba	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]

; 2932 : 				
; 2933 : 				if ( iSX >= g_iChaosCastle_GroundAxis[0] &&
; 2934 : 					 iSX <= g_iChaosCastle_GroundAxis[2] &&
; 2935 : 					 iSY >= g_iChaosCastle_GroundAxis[1] &&
; 2936 : 					 iSY <= g_iChaosCastle_GroundAxis[3] &&
; 2937 : 					 ( iSX < g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ||
; 2938 : 					   iSX > g_iChaosCastle_DamageAxis[iTRAP_STEP][2] ||
; 2939 : 					   iSY < g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ||
; 2940 : 					   iSY > g_iChaosCastle_DamageAxis[iTRAP_STEP][3] ) )

  000c1	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_GroundAxis
  000c7	0f 8c a1 00 00
	00		 jl	 $LN7@CalUsersIn
  000cd	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_GroundAxis+8
  000d3	0f 8f 95 00 00
	00		 jg	 $LN7@CalUsersIn
  000d9	3b 15 04 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_GroundAxis+4
  000df	0f 8c 89 00 00
	00		 jl	 $LN7@CalUsersIn
  000e5	3b 15 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_GroundAxis+12
  000eb	0f 8f 7d 00 00
	00		 jg	 $LN7@CalUsersIn
  000f1	8b 45 f8	 mov	 eax, DWORD PTR tv295[ebp]
  000f4	c1 e0 04	 shl	 eax, 4
  000f7	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  000fd	7c 18		 jl	 SHORT $LN2@CalUsersIn
  000ff	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  00105	7f 10		 jg	 SHORT $LN2@CalUsersIn
  00107	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  0010d	7c 08		 jl	 SHORT $LN2@CalUsersIn
  0010f	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  00115	7e 57		 jle	 SHORT $LN7@CalUsersIn
$LN2@CalUsersIn:

; 2941 : 				{
; 2942 : 					this->GiveUserDamage(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 10);

  00117	6a 0a		 push	 10			; 0000000aH
  00119	56		 push	 esi
  0011a	8b cb		 mov	 ecx, ebx
  0011c	e8 00 00 00 00	 call	 ?GiveUserDamage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveUserDamage

; 2943 : 
; 2944 : 					LPOBJ lpObj = &gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex];

  00121	8b 37		 mov	 esi, DWORD PTR [edi]
  00123	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00129	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2945 : 
; 2946 : 					if(gObjSearchActiveEffect(lpObj, AT_ICE) == FALSE)

  0012f	6a 38		 push	 56			; 00000038H
  00131	56		 push	 esi
  00132	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00137	83 c4 08	 add	 esp, 8
  0013a	84 c0		 test	 al, al
  0013c	75 30		 jne	 SHORT $LN7@CalUsersIn

; 2947 : 					{
; 2948 : 						lpObj->DelayActionTime = 800;
; 2949 : 						lpObj->DelayLevel = 1;
; 2950 : 						lpObj->lpAttackObj = NULL;
; 2951 : 						gObjApplyBuffEffectDuration(lpObj, AT_ICE, 0, 0, 0, 0, 3);

  0013e	6a 03		 push	 3
  00140	6a 00		 push	 0
  00142	6a 00		 push	 0
  00144	6a 00		 push	 0
  00146	6a 00		 push	 0
  00148	6a 38		 push	 56			; 00000038H
  0014a	56		 push	 esi
  0014b	c7 86 c0 03 00
	00 20 03 00 00	 mov	 DWORD PTR [esi+960], 800 ; 00000320H
  00155	c6 86 c4 03 00
	00 01		 mov	 BYTE PTR [esi+964], 1
  0015c	c7 86 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+980], 0
  00166	e8 00 00 00 00	 call	 ?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjApplyBuffEffectDuration
  0016b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN7@CalUsersIn:

; 2922 : 
; 2923 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0016e	83 c7 14	 add	 edi, 20			; 00000014H
  00171	ff 4d fc	 dec	 DWORD PTR tv152[ebp]
  00174	0f 85 e6 fe ff
	ff		 jne	 $LL8@CalUsersIn
  0017a	5f		 pop	 edi
$LN22@CalUsersIn:
  0017b	5e		 pop	 esi
$LN6@CalUsersIn:
  0017c	5b		 pop	 ebx

; 2952 : 					}
; 2953 : 				}
; 2954 : 			}
; 2955 : 		}
; 2956 : 	}
; 2957 : }

  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 04 00	 ret	 4
?CalUsersInTrap@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::CalUsersInTrap
_TEXT	ENDS
PUBLIC	?ReCalcUserCount@CChaosCastle@@QAEHH@Z		; CChaosCastle::ReCalcUserCount
; Function compile flags: /Ogtp
;	COMDAT ?ReCalcUserCount@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ReCalcUserCount@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::ReCalcUserCount, COMDAT
; _this$ = ecx

; 3196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3197 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 0c		 js	 SHORT $LN8@ReCalcUser
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 06	 cmp	 esi, 6
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 09		 jne	 SHORT $LN3@ReCalcUser
$LN8@ReCalcUser:
  0001a	5f		 pop	 edi

; 3198 : 		return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	5e		 pop	 esi

; 3212 : 	}
; 3213 : 	return iRET_VAL;
; 3214 : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN3@ReCalcUser:

; 3199 : 
; 3200 : 	int iRET_VAL = 0;
; 3201 : 	int iPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 3202 : 
; 3203 : 	if ( iPlayUser > 0 )
; 3204 : 	{
; 3205 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = iPlayUser;

  00029	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  0002f	85 c0		 test	 eax, eax
  00031	7e 0a		 jle	 SHORT $LN2@ReCalcUser
  00033	89 44 3e 54	 mov	 DWORD PTR [esi+edi+84], eax
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 3212 : 	}
; 3213 : 	return iRET_VAL;
; 3214 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN2@ReCalcUser:

; 3206 : 		iRET_VAL = iPlayUser;
; 3207 : 	}
; 3208 : 	else
; 3209 : 	{
; 3210 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_ENTERED_USER = 0;

  0003d	c7 44 3e 54 00
	00 00 00	 mov	 DWORD PTR [esi+edi+84], 0
  00045	5f		 pop	 edi

; 3211 : 		iRET_VAL = 0;

  00046	33 c0		 xor	 eax, eax
  00048	5e		 pop	 esi

; 3212 : 	}
; 3213 : 	return iRET_VAL;
; 3214 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?ReCalcUserCount@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::ReCalcUserCount
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 298  : 	_Vector_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 299  : 		{	// construct with null vector pointer
; 300  : 		}

  00008	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBEAAUCHAOSCASTLE_START_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Root
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z PROC ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@V?$allocator@UCHAOSCASTLE_START_TIME@@@1@@Z ENDP ; std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 08	 add	 DWORD PTR [eax], 8

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z PROC ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@V?$allocator@UtagPOINT@@@1@@Z ENDP ; std::_Vector_val<tagPOINT,std::allocator<tagPOINT> >::_Vector_val<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBEAAUtagPOINT@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator*
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	7d 05		 jge	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IBEII@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z PROC ; std::vector<int,std::allocator<int> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000d	c1 f8 02	 sar	 eax, 2
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@2
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to@2:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QBEIXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@3
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@3:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to@3

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to@3:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IBEII@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=, COMDAT
; _this$ = ecx

; 357  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 358  : 		*(_Mybase *)this += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0000f	01 10		 add	 DWORD PTR [eax], edx

; 359  : 		return (*this);
; 360  : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_const_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z PROC ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 248  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$?0AAHAAU_MONSTER_ITEM_DROP@@@?$pair@HU_MONSTER_ITEM_DROP@@@std@@QAE@AAHAAU_MONSTER_ITEM_DROP@@@Z ENDP ; std::pair<int,_MONSTER_ITEM_DROP>::pair<int,_MONSTER_ITEM_DROP><int &,_MONSTER_ITEM_DROP &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Cons_val@2:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@3:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T225485 = -12						; size = 12
$T225490 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 4a		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN1@Allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002f	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T225490[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T225485[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T225490[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T225485[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T225485[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ; std::_Allocate<CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z
_TEXT	SEGMENT
$T225498 = -12						; size = 12
$T225502 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z PROC ; std::_Allocate<CHAOSCASTLE_START_TIME>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T225502[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T225498[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T225502[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T225498[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T225498[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@UCHAOSCASTLE_START_TIME@@@std@@YAPAUCHAOSCASTLE_START_TIME@@IPAU1@@Z ENDP ; std::_Allocate<CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T225507 = -12						; size = 12
$T225511 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@3
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T225511[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T225507[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T225511[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T225507[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T225507[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ; std::_Allocate<tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z
_TEXT	SEGMENT
$T225516 = -12						; size = 12
$T225520 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z PROC ; std::_Allocate<tagPOINT>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@4

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@4
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T225520[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T225516[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T225520[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T225516[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T225516[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@4:
$LN5@Allocate@4:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@4:
??$_Allocate@UtagPOINT@@@std@@YAPAUtagPOINT@@IPAU1@@Z ENDP ; std::_Allocate<tagPOINT>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@4
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@4:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@ABU3@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct@5
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN5@construct@5:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ; std::allocator<tagPOINT>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z PROC ; std::allocator<tagPOINT>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@6
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@6:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@ABU3@@Z ENDP ; std::allocator<tagPOINT>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ; std::allocator<tagPOINT>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z PROC ; std::allocator<tagPOINT>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@@Z ENDP ; std::allocator<tagPOINT>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL3@Move
  00025	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 472  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ; std::allocator<CHAOSCASTLE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@7
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@7:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEXPAUCHAOSCASTLE_START_TIME@@$$QAU3@@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ; std::allocator<tagPOINT>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z PROC ; std::allocator<tagPOINT>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@8
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@8:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UtagPOINT@@@std@@QAEXPAUtagPOINT@@$$QAU3@@Z ENDP ; std::allocator<tagPOINT>::construct
_TEXT	ENDS
PUBLIC	??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00012	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00015	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 256  : 		}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??$?0HU_MONSTER_ITEM_DROP@@@?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@QAE@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::pair<int const ,_MONSTER_ITEM_DROP>::pair<int const ,_MONSTER_ITEM_DROP><int,_MONSTER_ITEM_DROP>
_TEXT	ENDS
PUBLIC	?SetMonster@CChaosCastle@@QAEHH@Z		; CChaosCastle::SetMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
;	COMDAT ?SetMonster@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_wMonsterIndex$219258 = -24				; size = 2
_iMAX_ADDABLE_MONSTER_COUNT$ = -20			; size = 4
_n$219252 = -16						; size = 4
_this$ = -12						; size = 4
_iNOW_ADDED_MONSTER_COUNT$ = -8				; size = 4
_btChaosCastleIndex$219260 = -1				; size = 1
_iChaosCastleIndex$ = 8					; size = 4
?SetMonster@CChaosCastle@@QAEHH@Z PROC			; CChaosCastle::SetMonster, COMDAT
; _this$ = ecx

; 1079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1080 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 5d f4	 mov	 DWORD PTR _this$[ebp], ebx
  00013	3b f7		 cmp	 esi, edi
  00015	7c 0c		 jl	 SHORT $LN21@SetMonster
  00017	33 c0		 xor	 eax, eax
  00019	83 fe 06	 cmp	 esi, 6
  0001c	0f 9e c0	 setle	 al
  0001f	3b c7		 cmp	 eax, edi
  00021	75 0c		 jne	 SHORT $LN9@SetMonster
$LN21@SetMonster:
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 1081 : 	{
; 1082 : 		return -1;

  00025	83 c8 ff	 or	 eax, -1
  00028	5b		 pop	 ebx

; 1138 : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN9@SetMonster:

; 1083 : 	}
; 1084 : 
; 1085 : 	int iNOW_ADDED_MONSTER_COUNT = 0;
; 1086 : 	int iMAX_ADDABLE_MONSTER_COUNT = MAX_CC_MONSTERS - this->GetCurPlayUser(iChaosCastleIndex);

  0002f	56		 push	 esi
  00030	89 7d f8	 mov	 DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp], edi
  00033	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00038	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0003d	2b c8		 sub	 ecx, eax
  0003f	89 4d ec	 mov	 DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp], ecx

; 1087 : 	int result;
; 1088 : 
; 1089 : 	if ( iMAX_ADDABLE_MONSTER_COUNT < 0 )

  00042	79 03		 jns	 SHORT $LN8@SetMonster

; 1090 : 	{
; 1091 : 		iMAX_ADDABLE_MONSTER_COUNT = 0;

  00044	89 7d ec	 mov	 DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp], edi
$LN8@SetMonster:

; 1092 : 	}
; 1093 : 
; 1094 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  00047	89 7d f0	 mov	 DWORD PTR _n$219252[ebp], edi
  0004a	39 3d 84 2c 03
	00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, edi
  00050	0f 8e bb 01 00
	00		 jle	 $LN26@SetMonster
  00056	bf 08 00 00 00	 mov	 edi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
  0005b	eb 06		 jmp	 SHORT $LN7@SetMonster
  0005d	8d 49 00	 npad	 3
$LL25@SetMonster:
  00060	8b 5d f4	 mov	 ebx, DWORD PTR _this$[ebp]
$LN7@SetMonster:

; 1095 : 	{
; 1096 : 		if ( iNOW_ADDED_MONSTER_COUNT >= iMAX_ADDABLE_MONSTER_COUNT )

  00063	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  00066	3b 45 ec	 cmp	 eax, DWORD PTR _iMAX_ADDABLE_MONSTER_COUNT$[ebp]
  00069	0f 8d a2 01 00
	00		 jge	 $LN26@SetMonster

; 1097 : 		{
; 1098 : 			break;
; 1099 : 		}
; 1100 : 
; 1101 : 		if ( CC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE )

  0006f	8a 07		 mov	 al, BYTE PTR [edi]
  00071	3c 35		 cmp	 al, 53			; 00000035H
  00073	74 18		 je	 SHORT $LN22@SetMonster
  00075	3c 12		 cmp	 al, 18			; 00000012H
  00077	0f 82 7e 01 00
	00		 jb	 $LN6@SetMonster
  0007d	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00082	3a c8		 cmp	 cl, al
  00084	1b c9		 sbb	 ecx, ecx
  00086	41		 inc	 ecx
  00087	0f 84 6e 01 00
	00		 je	 $LN6@SetMonster
$LN22@SetMonster:

; 1102 : 		{
; 1103 : 			WORD wMonsterIndex = gMSetBase.m_Mp[n].m_Type;

  0008d	0f b7 57 fe	 movzx	 edx, WORD PTR [edi-2]
  00091	89 55 e8	 mov	 DWORD PTR _wMonsterIndex$219258[ebp], edx

; 1104 : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 1105 : 			BYTE btChaosCastleIndex = this->GetChaosCastleIndex(btMapNumber);

  00094	0f b6 d0	 movzx	 edx, al
  00097	52		 push	 edx
  00098	8b cb		 mov	 ecx, ebx
  0009a	e8 00 00 00 00	 call	 ?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleIndex
  0009f	88 45 ff	 mov	 BYTE PTR _btChaosCastleIndex$219260[ebp], al

; 1106 : 
; 1107 : 			if ( btChaosCastleIndex != iChaosCastleIndex )

  000a2	0f b6 c0	 movzx	 eax, al
  000a5	3b c6		 cmp	 eax, esi
  000a7	0f 85 4e 01 00
	00		 jne	 $LN6@SetMonster

; 1108 : 			{
; 1109 : 				continue;
; 1110 : 			}
; 1111 : 
; 1112 : 			result = gObjAddMonster(btMapNumber);

  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000b3	0f bf d8	 movsx	 ebx, ax
  000b6	83 c4 04	 add	 esp, 4

; 1113 : 
; 1114 : 			if ( result >= 0 )

  000b9	85 db		 test	 ebx, ebx
  000bb	0f 88 3a 01 00
	00		 js	 $LN6@SetMonster

; 1115 : 			{
; 1116 : 				gObj[result].m_PosNum = n;

  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c7	0f b7 55 f0	 movzx	 edx, WORD PTR _n$219252[ebp]
  000cb	8b f3		 mov	 esi, ebx
  000cd	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000d3	66 89 94 0e b0
	03 00 00	 mov	 WORD PTR [esi+ecx+944], dx

; 1117 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;

  000db	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e5	66 89 84 0e 44
	01 00 00	 mov	 WORD PTR [esi+ecx+324], ax

; 1118 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;

  000ed	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f6	66 89 94 06 46
	01 00 00	 mov	 WORD PTR [esi+eax+326], dx

; 1119 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  000fe	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00101	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00107	88 8c 16 49 01
	00 00		 mov	 BYTE PTR [esi+edx+329], cl

; 1120 : 				gObj[result].TX = gObj[result].X;

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00113	0f b7 8c 06 44
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+324]
  0011b	66 89 8c 06 7c
	01 00 00	 mov	 WORD PTR [esi+eax+380], cx

; 1121 : 				gObj[result].TY = gObj[result].Y;

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00128	0f b7 94 06 46
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+326]
  00130	66 89 94 06 7e
	01 00 00	 mov	 WORD PTR [esi+eax+382], dx

; 1122 : 				gObj[result].m_OldX = gObj[result].X;

  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013d	0f b7 8c 06 44
	01 00 00	 movzx	 ecx, WORD PTR [esi+eax+324]
  00145	66 89 8c 06 78
	01 00 00	 mov	 WORD PTR [esi+eax+376], cx

; 1123 : 				gObj[result].m_OldY = gObj[result].Y;

  0014d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00152	0f b7 94 06 46
	01 00 00	 movzx	 edx, WORD PTR [esi+eax+326]
  0015a	66 89 94 06 7a
	01 00 00	 mov	 WORD PTR [esi+eax+378], dx

; 1124 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;

  00162	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016b	88 84 0e 48 01
	00 00		 mov	 BYTE PTR [esi+ecx+328], al

; 1125 : 				gObj[result].StartX = gObj[result].X;

  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00177	8a 94 06 44 01
	00 00		 mov	 dl, BYTE PTR [esi+eax+324]
  0017e	88 94 06 76 01
	00 00		 mov	 BYTE PTR [esi+eax+374], dl

; 1126 : 				gObj[result].StartY = gObj[result].Y;

  00185	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1127 : 				gObjSetMonster(result, wMonsterIndex);

  0018a	0f b7 55 e8	 movzx	 edx, WORD PTR _wMonsterIndex$219258[ebp]
  0018e	0f b6 8c 06 46
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+326]
  00196	52		 push	 edx
  00197	53		 push	 ebx
  00198	88 8c 06 77 01
	00 00		 mov	 BYTE PTR [esi+eax+375], cl
  0019f	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1128 : 				gObj[result].MaxRegenTime = this->m_iCC_MONSTER_REGEN;

  001a4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b0	89 8c 16 ac 03
	00 00		 mov	 DWORD PTR [esi+edx+940], ecx

; 1129 : 				gObj[result].m_cChaosCastleIndex = btChaosCastleIndex;

  001b7	0f b6 4d ff	 movzx	 ecx, BYTE PTR _btChaosCastleIndex$219260[ebp]
  001bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c0	83 c4 08	 add	 esp, 8
  001c3	88 8c 06 a5 0e
	00 00		 mov	 BYTE PTR [esi+eax+3749], cl

; 1130 : 				gObj[result].Dir = rand() % 8;

  001ca	e8 00 00 00 00	 call	 _rand
  001cf	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001d4	79 05		 jns	 SHORT $LN28@SetMonster
  001d6	48		 dec	 eax
  001d7	83 c8 f8	 or	 eax, -8			; fffffff8H
  001da	40		 inc	 eax
$LN28@SetMonster:
  001db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1131 : 				iNOW_ADDED_MONSTER_COUNT++;
; 1132 : 				this->AddMonsterList(iChaosCastleIndex, result);

  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	ff 45 f8	 inc	 DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  001e7	88 84 16 48 01
	00 00		 mov	 BYTE PTR [esi+edx+328], al
  001ee	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  001f1	53		 push	 ebx
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?AddMonsterList@CChaosCastle@@QAEXHH@Z ; CChaosCastle::AddMonsterList
  001f8	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
$LN6@SetMonster:

; 1092 : 	}
; 1093 : 
; 1094 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  001fb	8b 45 f0	 mov	 eax, DWORD PTR _n$219252[ebp]
  001fe	40		 inc	 eax
  001ff	83 c7 10	 add	 edi, 16			; 00000010H
  00202	89 45 f0	 mov	 DWORD PTR _n$219252[ebp], eax
  00205	3b 05 84 2c 03
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  0020b	0f 8c 4f fe ff
	ff		 jl	 $LL25@SetMonster
$LN26@SetMonster:

; 1133 : 			}
; 1134 : 		}
; 1135 : 	}
; 1136 : 
; 1137 : 	return iNOW_ADDED_MONSTER_COUNT;

  00211	8b 45 f8	 mov	 eax, DWORD PTR _iNOW_ADDED_MONSTER_COUNT$[ebp]
  00214	5f		 pop	 edi
  00215	5e		 pop	 esi
  00216	5b		 pop	 ebx

; 1138 : }

  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c2 04 00	 ret	 4
?SetMonster@CChaosCastle@@QAEHH@Z ENDP			; CChaosCastle::SetMonster
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendNoticeState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendNoticeState
; Function compile flags: /Ogtp
;	COMDAT ?SendNoticeState@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv403 = -24						; size = 4
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendNoticeState, COMDAT
; _this$ = ecx

; 1396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00015	8b d9		 mov	 ebx, ecx

; 1397 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00017	85 ff		 test	 edi, edi
  00019	0f 88 d7 00 00
	00		 js	 $LN4@SendNotice@2
  0001f	33 c0		 xor	 eax, eax
  00021	83 ff 06	 cmp	 edi, 6
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 c7 00 00
	00		 je	 $LN4@SendNotice@2

; 1398 : 	{
; 1399 : 		return;
; 1400 : 	}
; 1401 : 
; 1402 : 	PMSG_STATEBLOODCASTLE pMsg;
; 1403 : 
; 1404 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0002f	56		 push	 esi
  00030	6a 0e		 push	 14			; 0000000eH
  00032	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00035	68 9b 00 00 00	 push	 155			; 0000009bH
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1405 : 	pMsg.btPlayState = iPlayState;

  00040	8a 4d 0c	 mov	 cl, BYTE PTR _iPlayState$[ebp]

; 1406 : 	pMsg.wRemainSec = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 1000;

  00043	8b f7		 mov	 esi, edi
  00045	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  0004b	03 f3		 add	 esi, ebx
  0004d	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00052	f7 6e 40	 imul	 DWORD PTR [esi+64]
  00055	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 1407 : 	pMsg.wMaxKillMonster = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_USER_COUNT + this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_MONSTER_COUNT;

  00058	66 8b 4e 5c	 mov	 cx, WORD PTR [esi+92]
  0005c	66 03 4e 58	 add	 cx, WORD PTR [esi+88]
  00060	c1 fa 06	 sar	 edx, 6
  00063	8b c2		 mov	 eax, edx
  00065	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	03 c2		 add	 eax, edx
  0006d	66 89 4d f2	 mov	 WORD PTR _pMsg$[ebp+6], cx

; 1408 : 	pMsg.wCurKillMonster = this->GetCurPlayUser(iChaosCastleIndex) + this->GetMonsterListCount(iChaosCastleIndex);

  00071	57		 push	 edi
  00072	8b cb		 mov	 ecx, ebx
  00074	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00078	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  0007d	57		 push	 edi
  0007e	8b cb		 mov	 ecx, ebx
  00080	89 45 e8	 mov	 DWORD PTR tv403[ebp], eax
  00083	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00088	8b 4d e8	 mov	 ecx, DWORD PTR tv403[ebp]
  0008b	03 c8		 add	 ecx, eax

; 1409 : 	pMsg.wUserHaveWeapon = -1;

  0008d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00092	83 c6 6c	 add	 esi, 108		; 0000006cH
  00095	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+8], cx
  00099	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 1410 : 	pMsg.btWeaponNum = -1;

  0009d	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$[ebp+12], 255 ; 000000ffH
  000a1	bf 46 00 00 00	 mov	 edi, 70			; 00000046H
  000a6	83 cb ff	 or	 ebx, -1
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL6@SendNotice@2:

; 1413 : 	{
; 1414 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  000b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b2	3b cb		 cmp	 ecx, ebx
  000b4	74 39		 je	 SHORT $LN5@SendNotice@2

; 1415 : 		{
; 1416 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bc	8b c1		 mov	 eax, ecx
  000be	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000c4	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  000c9	7e 24		 jle	 SHORT $LN5@SendNotice@2

; 1417 : 			{
; 1418 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex != -1 )

  000cb	38 9c 10 a5 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3749], bl
  000d2	74 1b		 je	 SHORT $LN5@SendNotice@2
  000d4	38 9c 10 a6 0e
	00 00		 cmp	 BYTE PTR [eax+edx+3750], bl
  000db	74 12		 je	 SHORT $LN5@SendNotice@2

; 1419 : 				{
; 1420 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000dd	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000e1	50		 push	 eax
  000e2	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000e5	52		 push	 edx
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendNotice@2:

; 1411 : 
; 1412 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000ef	83 c6 14	 add	 esi, 20			; 00000014H
  000f2	4f		 dec	 edi
  000f3	75 bb		 jne	 SHORT $LL6@SendNotice@2
  000f5	5e		 pop	 esi
$LN4@SendNotice@2:

; 1421 : 				}
; 1422 : 			}
; 1423 : 		}
; 1424 : 	}
; 1425 : }

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	5f		 pop	 edi
  000fa	33 cd		 xor	 ecx, ebp
  000fc	5b		 pop	 ebx
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 08 00	 ret	 8
?SendNoticeState@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendNoticeState
_TEXT	ENDS
PUBLIC	?SendWinMessage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendWinMessage
; Function compile flags: /Ogtp
;	COMDAT ?SendWinMessage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?SendWinMessage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendWinMessage, COMDAT
; _this$ = ecx

; 1428 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1429 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 88 88 00 00
	00		 js	 $LN5@SendWinMes
  0000f	33 c0		 xor	 eax, eax
  00011	83 ff 06	 cmp	 edi, 6
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	74 7c		 je	 SHORT $LN5@SendWinMes

; 1430 : 	{
; 1431 : 		return;
; 1432 : 	}
; 1433 : 
; 1434 : 	if ( OBJMAX_RANGE(iWinnerIndex) == FALSE )

  0001b	53		 push	 ebx
  0001c	8b 5d 0c	 mov	 ebx, DWORD PTR _iWinnerIndex$[ebp]
  0001f	85 db		 test	 ebx, ebx
  00021	78 73		 js	 SHORT $LN13@SendWinMes
  00023	33 c0		 xor	 eax, eax
  00025	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0002b	0f 9e c0	 setle	 al
  0002e	85 c0		 test	 eax, eax
  00030	74 64		 je	 SHORT $LN13@SendWinMes

; 1435 : 	{
; 1436 : 		return;
; 1437 : 	}
; 1438 : 
; 1439 : 	int iChaosCastleSubIndex = gObj[iWinnerIndex].m_cChaosCastleSubIndex;

  00032	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	8b c3		 mov	 eax, ebx
  0003a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00040	0f be 94 10 a6
	0e 00 00	 movsx	 edx, BYTE PTR [eax+edx+3750]

; 1440 : 
; 1441 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  00048	85 d2		 test	 edx, edx
  0004a	78 4a		 js	 SHORT $LN13@SendWinMes
  0004c	33 c0		 xor	 eax, eax
  0004e	83 fa 45	 cmp	 edx, 69			; 00000045H
  00051	0f 9e c0	 setle	 al
  00054	85 c0		 test	 eax, eax
  00056	74 3e		 je	 SHORT $LN13@SendWinMes

; 1442 : 	{
; 1443 : 		return;
; 1444 : 	}
; 1445 : 
; 1446 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg == true )

  00058	8b c7		 mov	 eax, edi
  0005a	6b c0 6c	 imul	 eax, 108		; 0000006cH
  0005d	03 c2		 add	 eax, edx
  0005f	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00062	80 7c 81 7c 01	 cmp	 BYTE PTR [ecx+eax*4+124], 1
  00067	56		 push	 esi
  00068	8d 74 81 7c	 lea	 esi, DWORD PTR [ecx+eax*4+124]
  0006c	74 27		 je	 SHORT $LN14@SendWinMes

; 1447 : 	{
; 1448 : 		return;
; 1449 : 	}
; 1450 : 
; 1451 : 	this->RewardUserEXP(iChaosCastleIndex, gObj[iWinnerIndex].m_cChaosCastleSubIndex, true );

  0006e	6a 01		 push	 1
  00070	52		 push	 edx
  00071	57		 push	 edi
  00072	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1452 : 	::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 210)), iWinnerIndex, 1);

  00077	6a 01		 push	 1
  00079	53		 push	 ebx
  0007a	68 d2 04 00 00	 push	 1234			; 000004d2H
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00084	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1453 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg = true;

  00092	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN14@SendWinMes:
  00095	5e		 pop	 esi
$LN13@SendWinMes:
  00096	5b		 pop	 ebx
$LN5@SendWinMes:
  00097	5f		 pop	 edi

; 1454 : }

  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
?SendWinMessage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendWinMessage
_TEXT	ENDS
PUBLIC	?SendFailMessage@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SendFailMessage
; Function compile flags: /Ogtp
;	COMDAT ?SendFailMessage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iLoserIndex$ = 12					; size = 4
?SendFailMessage@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::SendFailMessage, COMDAT
; _this$ = ecx

; 1457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1458 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 7e		 js	 SHORT $LN5@SendFailMe
  0000b	33 c0		 xor	 eax, eax
  0000d	83 ff 06	 cmp	 edi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 72		 je	 SHORT $LN5@SendFailMe

; 1459 : 	{
; 1460 : 		return;
; 1461 : 	}
; 1462 : 
; 1463 : 	if ( OBJMAX_RANGE(iLoserIndex) == FALSE )

  00017	8b 45 0c	 mov	 eax, DWORD PTR _iLoserIndex$[ebp]
  0001a	85 c0		 test	 eax, eax
  0001c	78 6b		 js	 SHORT $LN5@SendFailMe
  0001e	33 d2		 xor	 edx, edx
  00020	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00025	0f 9e c2	 setle	 dl
  00028	85 d2		 test	 edx, edx
  0002a	74 5d		 je	 SHORT $LN5@SendFailMe

; 1464 : 	{
; 1465 : 		return;
; 1466 : 	}
; 1467 : 
; 1468 : 	int iChaosCastleSubIndex = gObj[iLoserIndex].m_cChaosCastleSubIndex;

  0002c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00038	0f be 94 10 a6
	0e 00 00	 movsx	 edx, BYTE PTR [eax+edx+3750]

; 1469 : 
; 1470 : 	if ( CC_SUB_FLOOR_RANGE(iChaosCastleSubIndex) == FALSE )

  00040	85 d2		 test	 edx, edx
  00042	78 45		 js	 SHORT $LN5@SendFailMe
  00044	33 c0		 xor	 eax, eax
  00046	83 fa 45	 cmp	 edx, 69			; 00000045H
  00049	0f 9e c0	 setle	 al
  0004c	85 c0		 test	 eax, eax
  0004e	74 39		 je	 SHORT $LN5@SendFailMe

; 1471 : 	{
; 1472 : 		return;
; 1473 : 	}
; 1474 : 
; 1475 : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg == true )

  00050	8b c7		 mov	 eax, edi
  00052	6b c0 6c	 imul	 eax, 108		; 0000006cH
  00055	03 c2		 add	 eax, edx
  00057	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0005a	80 7c 81 7c 01	 cmp	 BYTE PTR [ecx+eax*4+124], 1
  0005f	56		 push	 esi
  00060	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00063	74 23		 je	 SHORT $LN13@SendFailMe

; 1476 : 	{
; 1477 : 		return;
; 1478 : 	}
; 1479 : 
; 1480 : 	this->RewardUserEXP(iChaosCastleIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_iIndex].m_cChaosCastleSubIndex, false );

  00065	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00073	0f be 94 02 a6
	0e 00 00	 movsx	 edx, BYTE PTR [edx+eax+3750]
  0007b	6a 00		 push	 0
  0007d	52		 push	 edx
  0007e	57		 push	 edi
  0007f	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1481 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[iChaosCastleSubIndex].m_bSendQuitMsg = true;

  00084	c6 46 7c 01	 mov	 BYTE PTR [esi+124], 1
$LN13@SendFailMe:
  00088	5e		 pop	 esi
$LN5@SendFailMe:
  00089	5f		 pop	 edi

; 1482 : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?SendFailMessage@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::SendFailMessage
_TEXT	ENDS
PUBLIC	?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z	; CChaosCastle::SendAllLoserFailMessage
; Function compile flags: /Ogtp
;	COMDAT ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv395 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iWinnerIndex$ = 12					; size = 4
?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z PROC	; CChaosCastle::SendAllLoserFailMessage, COMDAT
; _this$ = ecx

; 1485 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 1486 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 9c 00 00
	00		 js	 $LN4@SendAllLos
  00012	33 c0		 xor	 eax, eax
  00014	83 ff 06	 cmp	 edi, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 8c 00 00
	00		 je	 $LN4@SendAllLos

; 1487 : 	{
; 1488 : 		return;
; 1489 : 	}
; 1490 : 
; 1491 : 	if ( OBJMAX_RANGE(iWinnerIndex) == FALSE && iWinnerIndex != -1)	

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  00025	85 c9		 test	 ecx, ecx
  00027	78 0f		 js	 SHORT $LN17@SendAllLos
  00029	33 c0		 xor	 eax, eax
  0002b	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00031	0f 9e c0	 setle	 al
  00034	85 c0		 test	 eax, eax
  00036	75 05		 jne	 SHORT $LN18@SendAllLos
$LN17@SendAllLos:
  00038	83 f9 ff	 cmp	 ecx, -1
  0003b	75 71		 jne	 SHORT $LN4@SendAllLos
$LN18@SendAllLos:

; 1492 : 	{
; 1493 : 		return;
; 1494 : 	}
; 1495 : 
; 1496 : 
; 1497 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0003d	8b c7		 mov	 eax, edi
  0003f	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00045	56		 push	 esi
  00046	8d 74 18 6c	 lea	 esi, DWORD PTR [eax+ebx+108]
  0004a	c7 45 08 46 00
	00 00		 mov	 DWORD PTR tv395[ebp], 70 ; 00000046H
$LL19@SendAllLos:

; 1498 : 	{
; 1499 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	83 f8 ff	 cmp	 eax, -1
  00056	74 4d		 je	 SHORT $LN5@SendAllLos

; 1500 : 		{
; 1501 : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != iWinnerIndex )

  00058	3b c1		 cmp	 eax, ecx
  0005a	74 49		 je	 SHORT $LN5@SendAllLos

; 1502 : 			{
; 1503 : 				if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg == false )

  0005c	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  00060	75 43		 jne	 SHORT $LN5@SendAllLos

; 1504 : 				{
; 1505 : 					this->RewardUserEXP(iChaosCastleIndex, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex, false);

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0006e	0f be 94 08 a6
	0e 00 00	 movsx	 edx, BYTE PTR [eax+ecx+3750]
  00076	6a 00		 push	 0
  00078	52		 push	 edx
  00079	57		 push	 edi
  0007a	8b cb		 mov	 ecx, ebx
  0007c	e8 00 00 00 00	 call	 ?RewardUserEXP@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::RewardUserEXP

; 1506 : 					::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 211)), this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 1);

  00081	8b 06		 mov	 eax, DWORD PTR [esi]
  00083	6a 01		 push	 1
  00085	50		 push	 eax
  00086	68 d3 04 00 00	 push	 1235			; 000004d3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00090	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1507 : 					this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_bSendQuitMsg = true;

  0009b	8b 4d 0c	 mov	 ecx, DWORD PTR _iWinnerIndex$[ebp]
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
$LN5@SendAllLos:

; 1492 : 	{
; 1493 : 		return;
; 1494 : 	}
; 1495 : 
; 1496 : 
; 1497 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000a5	83 c6 14	 add	 esi, 20			; 00000014H
  000a8	ff 4d 08	 dec	 DWORD PTR tv395[ebp]
  000ab	75 a4		 jne	 SHORT $LL19@SendAllLos
  000ad	5e		 pop	 esi
$LN4@SendAllLos:
  000ae	5f		 pop	 edi
  000af	5b		 pop	 ebx

; 1508 : 				}
; 1509 : 			}
; 1510 : 		}
; 1511 : 	}
; 1512 : }

  000b0	5d		 pop	 ebp
  000b1	c2 08 00	 ret	 8
?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ENDP	; CChaosCastle::SendAllLoserFailMessage
_TEXT	ENDS
PUBLIC	?GetCurrentWinUser@CChaosCastle@@QAEHH@Z	; CChaosCastle::GetCurrentWinUser
; Function compile flags: /Ogtp
;	COMDAT ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iCC_SCORE$ = -12					; size = 4
_iCC_WINNER_INDEX$ = -8					; size = 4
_this$ = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetCurrentWinUser@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetCurrentWinUser, COMDAT
; _this$ = ecx

; 1957 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1958 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	85 f6		 test	 esi, esi
  0000f	78 0c		 js	 SHORT $LN18@GetCurrent@2
  00011	33 c0		 xor	 eax, eax
  00013	83 fe 06	 cmp	 esi, 6
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 0a		 jne	 SHORT $LN11@GetCurrent@2
$LN18@GetCurrent@2:

; 1959 : 	{
; 1960 : 		return -1;

  0001d	83 c8 ff	 or	 eax, -1
  00020	5e		 pop	 esi

; 2002 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN11@GetCurrent@2:
  00027	53		 push	 ebx

; 1961 : 	}
; 1962 : 
; 1963 : 	int iCC_SCORE = -1;

  00028	83 c8 ff	 or	 eax, -1
  0002b	57		 push	 edi

; 1964 : 	int iCC_WINNER_INDEX = -1;
; 1965 : 
; 1966 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0002c	33 ff		 xor	 edi, edi
  0002e	6b f6 6c	 imul	 esi, 108		; 0000006cH
  00031	89 45 f4	 mov	 DWORD PTR _iCC_SCORE$[ebp], eax
  00034	89 45 f8	 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], eax
  00037	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0003a	8d 5c 81 6c	 lea	 ebx, DWORD PTR [ecx+eax*4+108]
  0003e	8b ff		 npad	 2
$LL23@GetCurrent@2:

; 1967 : 	{
; 1968 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 03		 mov	 eax, DWORD PTR [ebx]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 63		 je	 SHORT $LN9@GetCurrent@2

; 1969 : 		{
; 1970 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE &&
; 1971 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) &&	
; 1972 : 				this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iUserState == 0 )

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004d	83 c4 04	 add	 esp, 4
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 55		 jne	 SHORT $LN9@GetCurrent@2
  00055	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00057	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00063	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00066	03 d1		 add	 edx, ecx
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00071	0f b6 8a 49 01
	00 00		 movzx	 ecx, BYTE PTR [edx+329]
  00078	3b c8		 cmp	 ecx, eax
  0007a	75 2e		 jne	 SHORT $LN9@GetCurrent@2
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8d 44 3e 06	 lea	 eax, DWORD PTR [esi+edi+6]
  00083	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00086	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0008a	75 1e		 jne	 SHORT $LN9@GetCurrent@2

; 1973 : 			{
; 1974 : 				LPOBJ lpObj = &gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex];
; 1975 : 
; 1976 : 				int iUSER_SCORE = lpObj->m_cKillUserCount + lpObj->m_cKillMonsterCount * 2;

  0008c	0f be 82 ad 0e
	00 00		 movsx	 eax, BYTE PTR [edx+3757]
  00093	0f be 8a ac 0e
	00 00		 movsx	 ecx, BYTE PTR [edx+3756]
  0009a	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1977 : 
; 1978 : 				if ( iCC_SCORE < iUSER_SCORE )

  0009d	39 45 f4	 cmp	 DWORD PTR _iCC_SCORE$[ebp], eax
  000a0	7d 08		 jge	 SHORT $LN9@GetCurrent@2

; 1979 : 				{
; 1980 : 					iCC_SCORE = iUSER_SCORE;
; 1981 : 					iCC_WINNER_INDEX = lpObj->m_Index;

  000a2	8b 12		 mov	 edx, DWORD PTR [edx]
  000a4	89 45 f4	 mov	 DWORD PTR _iCC_SCORE$[ebp], eax
  000a7	89 55 f8	 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], edx
$LN9@GetCurrent@2:

; 1964 : 	int iCC_WINNER_INDEX = -1;
; 1965 : 
; 1966 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000aa	47		 inc	 edi
  000ab	83 c3 14	 add	 ebx, 20			; 00000014H
  000ae	83 ff 46	 cmp	 edi, 70			; 00000046H
  000b1	7c 8d		 jl	 SHORT $LL23@GetCurrent@2

; 1982 : 				}
; 1983 : 			}
; 1984 : 		}
; 1985 : 	}
; 1986 : 
; 1987 : 	if ( iCC_WINNER_INDEX != -1 )

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
  000b6	5f		 pop	 edi
  000b7	5b		 pop	 ebx
  000b8	83 f8 ff	 cmp	 eax, -1
  000bb	74 4a		 je	 SHORT $LN22@GetCurrent@2

; 1988 : 	{
; 1989 : 		if ( gObj[iCC_WINNER_INDEX].m_cKillUserCount == 0 && gObj[iCC_WINNER_INDEX].m_cKillMonsterCount == 0 )

  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000c9	80 bc 08 ac 0e
	00 00 00	 cmp	 BYTE PTR [eax+ecx+3756], 0
  000d1	75 34		 jne	 SHORT $LN22@GetCurrent@2
  000d3	80 bc 08 ad 0e
	00 00 00	 cmp	 BYTE PTR [eax+ecx+3757], 0
  000db	75 2a		 jne	 SHORT $LN22@GetCurrent@2

; 1990 : 		{
; 1991 : 			int iUSER_COUNT = this->GetCurPlayUser(iChaosCastleIndex);

  000dd	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 1992 : 			int iMONSTER_COUNT = this->GetMonsterListCount(iChaosCastleIndex);

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b f0		 mov	 esi, eax
  000ee	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 1993 : 
; 1994 : 			if ( iUSER_COUNT != 1 || iMONSTER_COUNT != 0 )

  000f7	83 fe 01	 cmp	 esi, 1
  000fa	75 04		 jne	 SHORT $LN1@GetCurrent@2
  000fc	85 c0		 test	 eax, eax
  000fe	74 07		 je	 SHORT $LN22@GetCurrent@2
$LN1@GetCurrent@2:

; 1995 : 			{
; 1996 : 				iCC_WINNER_INDEX = -1;

  00100	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iCC_WINNER_INDEX$[ebp], -1
$LN22@GetCurrent@2:

; 1997 : 			}
; 1998 : 		}
; 1999 : 	}
; 2000 : 
; 2001 : 	return iCC_WINNER_INDEX;

  00107	8b 45 f8	 mov	 eax, DWORD PTR _iCC_WINNER_INDEX$[ebp]
  0010a	5e		 pop	 esi

; 2002 : }

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 04 00	 ret	 4
?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetCurrentWinUser
_TEXT	ENDS
PUBLIC	?CheckPlayEnded@CChaosCastle@@QAEHH@Z		; CChaosCastle::CheckPlayEnded
; Function compile flags: /Ogtp
;	COMDAT ?CheckPlayEnded@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckPlayEnded@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::CheckPlayEnded, COMDAT
; _this$ = ecx

; 2097 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2098 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00005	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 0c		 js	 SHORT $LN8@CheckPlayE
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 06	 cmp	 esi, 6
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 08		 jne	 SHORT $LN3@CheckPlayE
$LN8@CheckPlayE:
  0001a	5e		 pop	 esi

; 2099 : 	{
; 2100 : 		return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	5b		 pop	 ebx

; 2117 : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN3@CheckPlayE:
  00022	57		 push	 edi

; 2101 : 	}
; 2102 : 
; 2103 : 	int iCUR_USER_COUNT = this->GetCurPlayUser(iChaosCastleIndex);

  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 2104 : 	int iCUR_MONSTER_COUNT = this->GetMonsterListCount(iChaosCastleIndex);

  00029	56		 push	 esi
  0002a	8b cb		 mov	 ecx, ebx
  0002c	8b f8		 mov	 edi, eax
  0002e	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 2105 : 
; 2106 : 	if ( iCUR_USER_COUNT <= 0 )

  00033	85 ff		 test	 edi, edi
  00035	7f 0c		 jg	 SHORT $LN2@CheckPlayE

; 2107 : 	{
; 2108 : 		return 2;

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	b8 02 00 00 00	 mov	 eax, 2
  0003e	5b		 pop	 ebx

; 2117 : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN2@CheckPlayE:

; 2109 : 	}
; 2110 : 
; 2111 : 	if ( iCUR_USER_COUNT == 1 && iCUR_MONSTER_COUNT <= 0)

  00043	83 ff 01	 cmp	 edi, 1
  00046	75 0d		 jne	 SHORT $LN1@CheckPlayE
  00048	85 c0		 test	 eax, eax
  0004a	7f 09		 jg	 SHORT $LN1@CheckPlayE

; 2112 : 	{
; 2113 : 		return 1;

  0004c	8b c7		 mov	 eax, edi
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 2117 : }

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN1@CheckPlayE:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 2114 : 	}
; 2115 : 
; 2116 : 	return 0;

  00057	33 c0		 xor	 eax, eax
  00059	5b		 pop	 ebx

; 2117 : }

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?CheckPlayEnded@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::CheckPlayEnded
_TEXT	ENDS
PUBLIC	??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@ ; `string'
PUBLIC	?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z	; CChaosCastle::CheckCanStartPlay
;	COMDAT ??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@
CONST	SEGMENT
??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@ DB '['
	DB	'Chaos Castle] (%d) GetCurPlayUser() FAILED (UserCount:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z PROC		; CChaosCastle::CheckCanStartPlay, COMDAT
; _this$ = ecx

; 2140 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2141 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 2b		 js	 SHORT $LN7@CheckCanSt
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 06	 cmp	 esi, 6
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax

; 2142 : 	{
; 2143 : 		return false;

  00015	74 1f		 je	 SHORT $LN7@CheckCanSt

; 2144 : 	}
; 2145 : 
; 2146 : 	int iEnteredUser = this->GetCurPlayUser(iChaosCastleIndex);

  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 2147 : 
; 2148 : 	if ( iEnteredUser < ZtConfig.Event.Zt_CCMinPlayer )

  0001d	3b 05 64 08 00
	00		 cmp	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2148
  00023	7d 18		 jge	 SHORT $LN1@CheckCanSt

; 2149 : 	{
; 2150 : 		LogAddTD("[Chaos Castle] (%d) GetCurPlayUser() FAILED (UserCount:%d)", iChaosCastleIndex+1, iEnteredUser);

  00025	50		 push	 eax
  00026	46		 inc	 esi
  00027	56		 push	 esi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GPIGPHOF@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5GetCurPlayUs@
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CheckCanSt:

; 2151 : 
; 2152 : 		return false;

  00036	32 c0		 xor	 al, al
  00038	5e		 pop	 esi

; 2156 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN1@CheckCanSt:

; 2153 : 	}
; 2154 : 
; 2155 : 	return true;

  0003d	b0 01		 mov	 al, 1
  0003f	5e		 pop	 esi

; 2156 : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z ENDP		; CChaosCastle::CheckCanStartPlay
_TEXT	ENDS
PUBLIC	?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z	; CChaosCastle::BlowObjsFromPoint
; Function compile flags: /Ogtp
;	COMDAT ?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z
_TEXT	SEGMENT
_lpObj$ = -24						; size = 4
_this$ = -20						; size = 4
_iOBJ_DIST$ = -16					; size = 4
tv285 = -12						; size = 4
_iBLOWOUT_COUNT$220542 = -12				; size = 4
_iBLOW_MAX$220547 = -8					; size = 4
_iSIGN_Y$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iSIGN_X$ = 12						; size = 4
_iMapNumber$ = 12					; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z PROC	; CChaosCastle::BlowObjsFromPoint, COMDAT
; _this$ = ecx

; 2393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 2394 : 	if ( !gObjIsConnected(iIndex))

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  00011	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN29@BlowObjsFr
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 2517 : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 10 00	 ret	 16			; 00000010H
$LN29@BlowObjsFr:

; 2395 : 	{
; 2396 : 		return FALSE;
; 2397 : 	}
; 2398 : 
; 2399 : 	if ( !CHECK_LIMIT(iX, 256) || !CHECK_LIMIT(iY, 256))

  00025	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  00028	53		 push	 ebx
  00029	8b 18		 mov	 ebx, DWORD PTR [eax]
  0002b	85 db		 test	 ebx, ebx
  0002d	0f 88 6f 02 00
	00		 js	 $LN27@BlowObjsFr
  00033	33 c0		 xor	 eax, eax
  00035	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  0003b	0f 9e c0	 setle	 al
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 5c 02 00
	00		 je	 $LN27@BlowObjsFr
  00046	8b 4d 14	 mov	 ecx, DWORD PTR _iY$[ebp]
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	85 d2		 test	 edx, edx
  0004d	0f 88 4f 02 00
	00		 js	 $LN27@BlowObjsFr
  00053	33 c0		 xor	 eax, eax
  00055	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0005b	0f 9e c0	 setle	 al
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 3c 02 00
	00		 je	 $LN27@BlowObjsFr

; 2402 : 	}
; 2403 : 
; 2404 : 	LPOBJ lpObj = &gObj[iIndex];

  00066	8b c7		 mov	 eax, edi
  00068	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0006e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2405 : 
; 2406 : 	if ( lpObj->DieRegen )

  00074	80 b8 a2 03 00
	00 00		 cmp	 BYTE PTR [eax+930], 0
  0007b	89 45 e8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2407 : 	{
; 2408 : 		return FALSE;

  0007e	0f 85 1e 02 00
	00		 jne	 $LN27@BlowObjsFr

; 2409 : 	}
; 2410 : 
; 2411 : 	if ( lpObj->Teleport )

  00084	80 b8 a0 03 00
	00 00		 cmp	 BYTE PTR [eax+928], 0

; 2412 : 	{
; 2413 : 		return FALSE;

  0008b	0f 85 11 02 00
	00		 jne	 $LN27@BlowObjsFr

; 2414 : 	}
; 2415 : 
; 2416 : 	if ( lpObj->MapNumber != iMapNumber )

  00091	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00098	3b 4d 0c	 cmp	 ecx, DWORD PTR _iMapNumber$[ebp]

; 2417 : 	{
; 2418 : 		return FALSE;

  0009b	0f 85 01 02 00
	00		 jne	 $LN27@BlowObjsFr

; 2419 : 	}
; 2420 : 
; 2421 : 	int iOBJ_DIST = this->CalDistance(lpObj->X, lpObj->Y, iX, iY);

  000a1	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  000a8	0f bf b8 44 01
	00 00		 movsx	 edi, WORD PTR [eax+324]
  000af	52		 push	 edx
  000b0	53		 push	 ebx
  000b1	51		 push	 ecx
  000b2	89 4d f4	 mov	 DWORD PTR tv285[ebp], ecx
  000b5	57		 push	 edi
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?CalDistance@CChaosCastle@@QAEHHHHH@Z ; CChaosCastle::CalDistance
  000bd	8b f0		 mov	 esi, eax
  000bf	89 75 f0	 mov	 DWORD PTR _iOBJ_DIST$[ebp], esi

; 2422 : 
; 2423 : 	if ( !CHECK_LIMIT(iOBJ_DIST, 4))

  000c2	85 f6		 test	 esi, esi
  000c4	0f 88 d8 01 00
	00		 js	 $LN27@BlowObjsFr
  000ca	33 c0		 xor	 eax, eax
  000cc	83 fe 03	 cmp	 esi, 3
  000cf	0f 9e c0	 setle	 al
  000d2	85 c0		 test	 eax, eax

; 2424 : 	{
; 2425 : 		return FALSE;

  000d4	0f 84 c8 01 00
	00		 je	 $LN27@BlowObjsFr

; 2426 : 	}
; 2427 : 
; 2428 : 	int iSIGN_X = 1;
; 2429 : 	int iSIGN_Y = 1;
; 2430 : 	int iUX = lpObj->X;
; 2431 : 	int iUY = lpObj->Y;
; 2432 : 
; 2433 : 	if ( iUX > iX )

  000da	3b fb		 cmp	 edi, ebx
  000dc	7e 09		 jle	 SHORT $LN55@BlowObjsFr

; 2434 : 	{
; 2435 : 		iSIGN_X = 1;

  000de	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _iSIGN_X$[ebp], 1
  000e5	eb 27		 jmp	 SHORT $LN38@BlowObjsFr
$LN55@BlowObjsFr:

; 2436 : 	}
; 2437 : 	else if ( iUX < iX )

  000e7	7d 09		 jge	 SHORT $LN20@BlowObjsFr

; 2438 : 	{
; 2439 : 		iSIGN_X = -1;

  000e9	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_X$[ebp], -1

; 2440 : 	}
; 2441 : 	else

  000f0	eb 1c		 jmp	 SHORT $LN38@BlowObjsFr
$LN20@BlowObjsFr:

; 2442 : 	{
; 2443 : 		int iRND = rand() % 2;

  000f2	e8 00 00 00 00	 call	 _rand
  000f7	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000fc	79 05		 jns	 SHORT $LN49@BlowObjsFr
  000fe	48		 dec	 eax
  000ff	83 c8 fe	 or	 eax, -2			; fffffffeH
  00102	40		 inc	 eax
$LN49@BlowObjsFr:

; 2444 : 		(!iRND)?iSIGN_X = 1:iSIGN_X = -1;

  00103	f7 d8		 neg	 eax
  00105	1b c0		 sbb	 eax, eax
  00107	83 e0 fe	 and	 eax, -2			; fffffffeH
  0010a	40		 inc	 eax
  0010b	89 45 0c	 mov	 DWORD PTR _iSIGN_X$[ebp], eax
$LN38@BlowObjsFr:

; 2445 : 	}
; 2446 : 		
; 2447 : 	if ( iUY > iY )

  0010e	8b 55 14	 mov	 edx, DWORD PTR _iY$[ebp]
  00111	8b 02		 mov	 eax, DWORD PTR [edx]
  00113	8b 4d f4	 mov	 ecx, DWORD PTR tv285[ebp]
  00116	3b c8		 cmp	 ecx, eax
  00118	7e 10		 jle	 SHORT $LN56@BlowObjsFr

; 2448 : 	{
; 2449 : 		iSIGN_Y = 1;

  0011a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _iSIGN_Y$[ebp], 1

; 2459 : 	}
; 2460 : 
; 2461 : 	BOOL bSuccessBlowOut = FALSE;
; 2462 : 
; 2463 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  00121	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$220542[ebp], 0
  00128	eb 3a		 jmp	 SHORT $LN14@BlowObjsFr
$LN56@BlowObjsFr:

; 2450 : 	}
; 2451 : 	else if ( iUY < iY )

  0012a	7d 10		 jge	 SHORT $LN16@BlowObjsFr

; 2452 : 	{
; 2453 : 		iSIGN_Y = -1;

  0012c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iSIGN_Y$[ebp], -1

; 2459 : 	}
; 2460 : 
; 2461 : 	BOOL bSuccessBlowOut = FALSE;
; 2462 : 
; 2463 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  00133	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$220542[ebp], 0
  0013a	eb 28		 jmp	 SHORT $LN14@BlowObjsFr
$LN16@BlowObjsFr:

; 2454 : 	}
; 2455 : 	else
; 2456 : 	{
; 2457 : 		int iRND = rand() % 2;

  0013c	e8 00 00 00 00	 call	 _rand
  00141	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00146	79 05		 jns	 SHORT $LN50@BlowObjsFr
  00148	48		 dec	 eax
  00149	83 c8 fe	 or	 eax, -2			; fffffffeH
  0014c	40		 inc	 eax
$LN50@BlowObjsFr:

; 2458 : 		(!iRND)?iSIGN_Y = 1:iSIGN_Y = -1;

  0014d	f7 d8		 neg	 eax
  0014f	1b c0		 sbb	 eax, eax
  00151	83 e0 fe	 and	 eax, -2			; fffffffeH
  00154	40		 inc	 eax
  00155	89 45 fc	 mov	 DWORD PTR _iSIGN_Y$[ebp], eax

; 2459 : 	}
; 2460 : 
; 2461 : 	BOOL bSuccessBlowOut = FALSE;
; 2462 : 
; 2463 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  00158	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iBLOWOUT_COUNT$220542[ebp], 0
  0015f	eb 03		 jmp	 SHORT $LN14@BlowObjsFr
$LL46@BlowObjsFr:
  00161	8b 75 f0	 mov	 esi, DWORD PTR _iOBJ_DIST$[ebp]
$LN14@BlowObjsFr:

; 2464 : 	{
; 2465 : 		int iBLOW_MIN = g_iChaosCastle_BlowOutDistance[iOBJ_DIST][0];

  00164	8b 1c f5 00 00
	00 00		 mov	 ebx, DWORD PTR _g_iChaosCastle_BlowOutDistance[esi*8]

; 2466 : 		int iBLOW_MAX = g_iChaosCastle_BlowOutDistance[iOBJ_DIST][1];

  0016b	8b 34 f5 04 00
	00 00		 mov	 esi, DWORD PTR _g_iChaosCastle_BlowOutDistance[esi*8+4]
  00172	89 75 f8	 mov	 DWORD PTR _iBLOW_MAX$220547[ebp], esi

; 2467 : 		int iBLOW_X = rand() % (iBLOW_MAX - iBLOW_MIN + 1) + iBLOW_MIN;

  00175	2b f3		 sub	 esi, ebx
  00177	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
  0017a	e8 00 00 00 00	 call	 _rand
  0017f	99		 cdq
  00180	f7 ff		 idiv	 edi
  00182	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]

; 2468 : 		int iBLOW_Y = rand() % (iBLOW_MAX - iBLOW_MIN + 1) + iBLOW_MIN;

  00185	e8 00 00 00 00	 call	 _rand
  0018a	99		 cdq
  0018b	f7 ff		 idiv	 edi
  0018d	8d 3c 13	 lea	 edi, DWORD PTR [ebx+edx]

; 2469 : 		int iRND = rand() % 2;

  00190	e8 00 00 00 00	 call	 _rand
  00195	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0019a	79 05		 jns	 SHORT $LN51@BlowObjsFr
  0019c	48		 dec	 eax
  0019d	83 c8 fe	 or	 eax, -2			; fffffffeH
  001a0	40		 inc	 eax
$LN51@BlowObjsFr:

; 2472 : 		{
; 2473 : 			if ( iBLOW_X >= iBLOW_MAX )

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _iBLOW_MAX$220547[ebp]

; 2470 : 
; 2471 : 		if ( iRND )

  001a4	74 23		 je	 SHORT $LN11@BlowObjsFr

; 2472 : 		{
; 2473 : 			if ( iBLOW_X >= iBLOW_MAX )

  001a6	3b f0		 cmp	 esi, eax
  001a8	7c 40		 jl	 SHORT $LN47@BlowObjsFr

; 2474 : 			{
; 2475 : 				iBLOW_X = iBLOW_MAX;

  001aa	8b f0		 mov	 esi, eax

; 2476 : 				iBLOW_Y = iBLOW_MIN + (rand() % 2 -1);

  001ac	e8 00 00 00 00	 call	 _rand
  001b1	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001b6	79 05		 jns	 SHORT $LN52@BlowObjsFr
  001b8	48		 dec	 eax
  001b9	83 c8 fe	 or	 eax, -2			; fffffffeH
  001bc	40		 inc	 eax
$LN52@BlowObjsFr:
  001bd	8d 7c 18 ff	 lea	 edi, DWORD PTR [eax+ebx-1]

; 2477 : 
; 2478 : 				if ( iBLOW_Y < 0 )

  001c1	85 ff		 test	 edi, edi
  001c3	79 25		 jns	 SHORT $LN47@BlowObjsFr

; 2479 : 				{
; 2480 : 					iBLOW_Y = 0;

  001c5	33 ff		 xor	 edi, edi

; 2481 : 				}
; 2482 : 			}
; 2483 : 		}

  001c7	eb 21		 jmp	 SHORT $LN47@BlowObjsFr
$LN11@BlowObjsFr:

; 2484 : 		else if ( iBLOW_Y >= iBLOW_MAX )

  001c9	3b f8		 cmp	 edi, eax
  001cb	7c 1d		 jl	 SHORT $LN47@BlowObjsFr

; 2485 : 		{
; 2486 : 			iBLOW_Y = iBLOW_MAX;

  001cd	8b f8		 mov	 edi, eax

; 2487 : 			iBLOW_X = iBLOW_MIN + (rand() % 2 -1);

  001cf	e8 00 00 00 00	 call	 _rand
  001d4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001d9	79 05		 jns	 SHORT $LN53@BlowObjsFr
  001db	48		 dec	 eax
  001dc	83 c8 fe	 or	 eax, -2			; fffffffeH
  001df	40		 inc	 eax
$LN53@BlowObjsFr:
  001e0	8d 74 18 ff	 lea	 esi, DWORD PTR [eax+ebx-1]

; 2488 : 
; 2489 : 			if ( iBLOW_X < 0 )

  001e4	85 f6		 test	 esi, esi
  001e6	79 02		 jns	 SHORT $LN47@BlowObjsFr

; 2490 : 			{
; 2491 : 				iBLOW_X = 0;

  001e8	33 f6		 xor	 esi, esi
$LN47@BlowObjsFr:

; 2492 : 			}
; 2493 : 		}
; 2494 : 
; 2495 : 		int iTX = lpObj->X  + iBLOW_X * iSIGN_X;
; 2496 : 		int iTY = lpObj->Y  + iBLOW_Y * iSIGN_Y;

  001ea	0f af 7d fc	 imul	 edi, DWORD PTR _iSIGN_Y$[ebp]
  001ee	0f af 75 0c	 imul	 esi, DWORD PTR _iSIGN_X$[ebp]
  001f2	8b 5d e8	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  001f5	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  001fc	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  00203	03 f9		 add	 edi, ecx
  00205	03 f0		 add	 esi, eax

; 2497 : 
; 2498 : 		if ( iTX < 0 ) iTX = 0;

  00207	79 02		 jns	 SHORT $LN5@BlowObjsFr
  00209	33 f6		 xor	 esi, esi
$LN5@BlowObjsFr:

; 2499 : 		if ( iTY < 0 ) iTY = 0;

  0020b	85 ff		 test	 edi, edi
  0020d	79 02		 jns	 SHORT $LN4@BlowObjsFr
  0020f	33 ff		 xor	 edi, edi
$LN4@BlowObjsFr:

; 2500 : 		if ( iTX > 255 ) iTX = 255;

  00211	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00217	7e 05		 jle	 SHORT $LN3@BlowObjsFr
  00219	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
$LN3@BlowObjsFr:

; 2501 : 		if ( iTY > 255 ) iTY = 255;

  0021e	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00224	7e 05		 jle	 SHORT $LN2@BlowObjsFr
  00226	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
$LN2@BlowObjsFr:

; 2502 : 
; 2503 : 		bSuccessBlowOut = this->ObjSetPosition(iIndex, iTX, iTY);

  0022b	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0022e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	57		 push	 edi
  00232	56		 push	 esi
  00233	52		 push	 edx
  00234	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition

; 2504 : 		
; 2505 : 		if ( bSuccessBlowOut )

  00239	85 c0		 test	 eax, eax
  0023b	75 1e		 jne	 SHORT $LN43@BlowObjsFr

; 2459 : 	}
; 2460 : 
; 2461 : 	BOOL bSuccessBlowOut = FALSE;
; 2462 : 
; 2463 : 	for ( int iBLOWOUT_COUNT = 0;iBLOWOUT_COUNT < 5 ;iBLOWOUT_COUNT++)

  0023d	8b 45 f4	 mov	 eax, DWORD PTR _iBLOWOUT_COUNT$220542[ebp]
  00240	40		 inc	 eax
  00241	89 45 f4	 mov	 DWORD PTR _iBLOWOUT_COUNT$220542[ebp], eax
  00244	83 f8 05	 cmp	 eax, 5
  00247	0f 8c 14 ff ff
	ff		 jl	 $LL46@BlowObjsFr

; 2512 : 			break;
; 2513 : 		}
; 2514 : 	}
; 2515 : 
; 2516 : 	return TRUE;

  0024d	5b		 pop	 ebx
  0024e	5f		 pop	 edi
  0024f	b8 01 00 00 00	 mov	 eax, 1
  00254	5e		 pop	 esi

; 2517 : }

  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c2 10 00	 ret	 16			; 00000010H
$LN43@BlowObjsFr:

; 2506 : 		{
; 2507 : 			lpObj->m_iChaosCastleBlowTime = GetTickCount();

  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 2508 : 			iX = iTX;
; 2509 : 			iY = iTY;
; 2510 : 
; 2511 : 			this->GiveUserDamage(lpObj->m_Index, g_iChaosCastle_BlowOutDamage[iOBJ_DIST % 4]);

  00261	8b 55 f0	 mov	 edx, DWORD PTR _iOBJ_DIST$[ebp]
  00264	81 e2 03 00 00
	80		 and	 edx, -2147483645	; 80000003H
  0026a	8b 4d 14	 mov	 ecx, DWORD PTR _iY$[ebp]
  0026d	89 83 a8 0e 00
	00		 mov	 DWORD PTR [ebx+3752], eax
  00273	8b 45 10	 mov	 eax, DWORD PTR _iX$[ebp]
  00276	89 30		 mov	 DWORD PTR [eax], esi
  00278	89 39		 mov	 DWORD PTR [ecx], edi
  0027a	79 05		 jns	 SHORT $LN54@BlowObjsFr
  0027c	4a		 dec	 edx
  0027d	83 ca fc	 or	 edx, -4			; fffffffcH
  00280	42		 inc	 edx
$LN54@BlowObjsFr:
  00281	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_iChaosCastle_BlowOutDamage[edx*4]
  00288	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0028a	50		 push	 eax
  0028b	51		 push	 ecx
  0028c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0028f	e8 00 00 00 00	 call	 ?GiveUserDamage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveUserDamage
  00294	5b		 pop	 ebx
  00295	5f		 pop	 edi

; 2512 : 			break;
; 2513 : 		}
; 2514 : 	}
; 2515 : 
; 2516 : 	return TRUE;

  00296	b8 01 00 00 00	 mov	 eax, 1
  0029b	5e		 pop	 esi

; 2517 : }

  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c2 10 00	 ret	 16			; 00000010H
$LN27@BlowObjsFr:
  002a2	5b		 pop	 ebx
  002a3	5f		 pop	 edi

; 2400 : 	{
; 2401 : 		return FALSE;

  002a4	33 c0		 xor	 eax, eax
  002a6	5e		 pop	 esi

; 2517 : }

  002a7	8b e5		 mov	 esp, ebp
  002a9	5d		 pop	 ebp
  002aa	c2 10 00	 ret	 16			; 00000010H
?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z ENDP	; CChaosCastle::BlowObjsFromPoint
_TEXT	ENDS
PUBLIC	??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ ; `string'
PUBLIC	?CheckUserInDieTile@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckUserInDieTile
;	COMDAT ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
CONST	SEGMENT
??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall '
	DB	'from Castle (X:%d, Y:%d)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iSY$220724 = -8					; size = 4
_this$ = -4						; size = 4
tv312 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckUserInDieTile@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::CheckUserInDieTile, COMDAT
; _this$ = ecx

; 2739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 2740 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 5d fc	 mov	 DWORD PTR _this$[ebp], ebx
  00010	85 ff		 test	 edi, edi
  00012	0f 88 a1 01 00
	00		 js	 $LN5@CheckUserI
  00018	33 c0		 xor	 eax, eax
  0001a	83 ff 06	 cmp	 edi, 6
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 91 01 00
	00		 je	 $LN5@CheckUserI

; 2741 : 		return;
; 2742 : 
; 2743 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00028	8b c7		 mov	 eax, edi
  0002a	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00030	56		 push	 esi
  00031	8d 74 18 6c	 lea	 esi, DWORD PTR [eax+ebx+108]
  00035	c7 45 08 46 00
	00 00		 mov	 DWORD PTR tv312[ebp], 70 ; 00000046H
  0003c	eb 05		 jmp	 SHORT $LN7@CheckUserI
  0003e	8b ff		 npad	 2
$LL18@CheckUserI:
  00040	8b 5d fc	 mov	 ebx, DWORD PTR _this$[ebp]
$LN7@CheckUserI:

; 2744 : 	{
; 2745 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	83 f8 ff	 cmp	 eax, -1
  00048	0f 84 5e 01 00
	00		 je	 $LN6@CheckUserI

; 2746 : 		{
; 2747 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE &&
; 2748 : 				 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00054	83 c4 04	 add	 esp, 4
  00057	83 f8 01	 cmp	 eax, 1
  0005a	0f 85 4c 01 00
	00		 jne	 $LN6@CheckUserI
  00060	57		 push	 edi
  00061	8b cb		 mov	 ecx, ebx
  00063	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	8b c8		 mov	 ecx, eax
  00070	8b 06		 mov	 eax, DWORD PTR [esi]
  00072	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00078	0f b6 9c 10 49
	01 00 00	 movzx	 ebx, BYTE PTR [eax+edx+329]
  00080	3b d9		 cmp	 ebx, ecx
  00082	0f 85 24 01 00
	00		 jne	 $LN6@CheckUserI

; 2749 : 			{
; 2750 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Life > 0.0 )

  00088	d9 ee		 fldz
  0008a	d8 94 10 fc 00
	00 00		 fcom	 DWORD PTR [eax+edx+252]
  00091	df e0		 fnstsw	 ax
  00093	f6 c4 05	 test	 ah, 5
  00096	0f 8a 0e 01 00
	00		 jp	 $LN23@CheckUserI

; 2751 : 				{
; 2752 : 					int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  0009c	8b 06		 mov	 eax, DWORD PTR [esi]

; 2753 : 					int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;
; 2754 : 
; 2755 : 					int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);
; 2756 : 
; 2757 : 					BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  0009e	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000a4	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000aa	0f bf 9c 10 44
	01 00 00	 movsx	 ebx, WORD PTR [eax+edx+324]
  000b2	0f bf 84 10 46
	01 00 00	 movsx	 eax, WORD PTR [eax+edx+326]
  000ba	89 45 f8	 mov	 DWORD PTR _iSY$220724[ebp], eax
  000bd	c1 e0 08	 shl	 eax, 8
  000c0	03 81 10 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  000c6	f6 04 18 08	 test	 BYTE PTR [eax+ebx], 8

; 2758 : 
; 2759 : 					if ( btMapAttr == 8 )

  000ca	0f 84 da 00 00
	00		 je	 $LN23@CheckUserI

; 2760 : 					{
; 2761 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Life = 0;

  000d0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d2	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000d8	d9 9c 11 fc 00
	00 00		 fstp	 DWORD PTR [ecx+edx+252]

; 2762 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_State = 4;

  000df	8b 16		 mov	 edx, DWORD PTR [esi]
  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e6	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000ec	c7 84 02 20 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [edx+eax+544], 4

; 2763 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].KillerType = 1;

  000f7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00105	c6 84 11 a1 03
	00 00 01	 mov	 BYTE PTR [ecx+edx+929], 1

; 2764 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].RegenTime = GetTickCount();

  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00113	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00115	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011b	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00121	89 84 11 a8 03
	00 00		 mov	 DWORD PTR [ecx+edx+936], eax

; 2765 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].DieRegen = 1;

  00128	8b 06		 mov	 eax, DWORD PTR [esi]
  0012a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00130	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00136	c6 84 08 a2 03
	00 00 01	 mov	 BYTE PTR [eax+ecx+930], 1

; 2766 : 						gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].PathCount = 0;

  0013e	8b 16		 mov	 edx, DWORD PTR [esi]
  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00145	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0014b	c7 84 02 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+eax+388], 0

; 2767 : 
; 2768 : 						GCDiePlayerSend(&gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex],
; 2769 : 							this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, 0, 0);

  00156	8b 06		 mov	 eax, DWORD PTR [esi]
  00158	6a 00		 push	 0
  0015a	6a 00		 push	 0
  0015c	50		 push	 eax
  0015d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00163	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend

; 2770 : 
; 2771 : 						LogAddTD("[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall from Castle (X:%d, Y:%d)",
; 2772 : 							iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 2773 : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,
; 2774 : 							iSX, iSY);

  0016f	8b 06		 mov	 eax, DWORD PTR [esi]
  00171	8b 4d f8	 mov	 ecx, DWORD PTR _iSY$220724[ebp]
  00174	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0017a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00180	51		 push	 ecx
  00181	53		 push	 ebx
  00182	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  00185	52		 push	 edx
  00186	83 c0 6c	 add	 eax, 108		; 0000006cH
  00189	50		 push	 eax
  0018a	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0018d	50		 push	 eax
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2775 : 
; 2776 : 						this->SendFailMessage(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex);

  00199	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019b	83 c4 28	 add	 esp, 40			; 00000028H
  0019e	51		 push	 ecx
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	57		 push	 edi
  001a3	e8 00 00 00 00	 call	 ?SendFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendFailMessage
  001a8	eb 02		 jmp	 SHORT $LN6@CheckUserI
$LN23@CheckUserI:

; 2758 : 
; 2759 : 					if ( btMapAttr == 8 )

  001aa	dd d8		 fstp	 ST(0)
$LN6@CheckUserI:

; 2741 : 		return;
; 2742 : 
; 2743 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  001ac	83 c6 14	 add	 esi, 20			; 00000014H
  001af	ff 4d 08	 dec	 DWORD PTR tv312[ebp]
  001b2	0f 85 88 fe ff
	ff		 jne	 $LL18@CheckUserI
  001b8	5e		 pop	 esi
$LN5@CheckUserI:
  001b9	5f		 pop	 edi
  001ba	5b		 pop	 ebx

; 2777 : 
; 2778 : 					}
; 2779 : 				}
; 2780 : 			}
; 2781 : 		}
; 2782 : 	}
; 2783 : }

  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c2 04 00	 ret	 4
?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::CheckUserInDieTile
_TEXT	ENDS
PUBLIC	?ProcessTrapStatus@CChaosCastle@@QAEXH@Z	; CChaosCastle::ProcessTrapStatus
; Function compile flags: /Ogtp
;	COMDAT ?ProcessTrapStatus@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ProcessTrapStatus@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::ProcessTrapStatus, COMDAT
; _this$ = ecx

; 2883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2884 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 a4 00 00
	00		 js	 $LN1@ProcessTra
  00012	33 c0		 xor	 eax, eax
  00014	83 fe 06	 cmp	 esi, 6
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 94 00 00
	00		 je	 $LN1@ProcessTra

; 2885 : 		return;
; 2886 : 
; 2887 : 	int iCUR_LIVES = this->GetCurPlayUser(iChaosCastleIndex) + this->GetMonsterListCount(iChaosCastleIndex);

  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  00029	56		 push	 esi
  0002a	8b cf		 mov	 ecx, edi
  0002c	8b d8		 mov	 ebx, eax
  0002e	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00033	03 d8		 add	 ebx, eax

; 2888 : 
; 2889 : 	if ( iCUR_LIVES > 40 )

  00035	83 fb 28	 cmp	 ebx, 40			; 00000028H
  00038	7e 15		 jle	 SHORT $LN6@ProcessTra

; 2890 : 	{
; 2891 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 0;

  0003a	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  00040	5b		 pop	 ebx
  00041	c7 44 3e 64 00
	00 00 00	 mov	 DWORD PTR [esi+edi+100], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 2907 : 	}
; 2908 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN6@ProcessTra:

; 2892 : 	}
; 2893 : 	else if ( iCUR_LIVES > 30 )

  0004f	83 fb 1e	 cmp	 ebx, 30			; 0000001eH
  00052	7e 21		 jle	 SHORT $LN4@ProcessTra

; 2894 : 	{
; 2895 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 1;

  00054	8b c6		 mov	 eax, esi
  00056	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H

; 2896 : 		this->SendNoticeState(iChaosCastleIndex, 8);

  0005c	6a 08		 push	 8

; 2906 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  0005e	56		 push	 esi
  0005f	8b cf		 mov	 ecx, edi
  00061	c7 44 38 64 01
	00 00 00	 mov	 DWORD PTR [eax+edi+100], 1
  00069	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  0006e	5b		 pop	 ebx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 2907 : 	}
; 2908 : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN4@ProcessTra:

; 2897 : 	}
; 2898 : 	else if ( iCUR_LIVES > 20 )

  00075	83 fb 14	 cmp	 ebx, 20			; 00000014H
  00078	7e 21		 jle	 SHORT $LN2@ProcessTra

; 2899 : 	{
; 2900 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 2;

  0007a	8b ce		 mov	 ecx, esi
  0007c	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H

; 2901 : 		this->SendNoticeState(iChaosCastleIndex, 9);

  00082	6a 09		 push	 9
  00084	c7 44 39 64 02
	00 00 00	 mov	 DWORD PTR [ecx+edi+100], 2

; 2906 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  0008c	56		 push	 esi
  0008d	8b cf		 mov	 ecx, edi
  0008f	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  00094	5b		 pop	 ebx
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi

; 2907 : 	}
; 2908 : }

  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
$LN2@ProcessTra:

; 2902 : 	}
; 2903 : 	else
; 2904 : 	{
; 2905 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS = 3;

  0009b	8b d6		 mov	 edx, esi
  0009d	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H

; 2906 : 		this->SendNoticeState(iChaosCastleIndex, 10);

  000a3	6a 0a		 push	 10			; 0000000aH
  000a5	56		 push	 esi
  000a6	8b cf		 mov	 ecx, edi
  000a8	c7 44 3a 64 03
	00 00 00	 mov	 DWORD PTR [edx+edi+100], 3
  000b0	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
  000b5	5b		 pop	 ebx
$LN1@ProcessTra:
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi

; 2907 : 	}
; 2908 : }

  000b8	5d		 pop	 ebp
  000b9	c2 04 00	 ret	 4
?ProcessTrapStatus@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::ProcessTrapStatus
_TEXT	ENDS
PUBLIC	??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 339  : 		++*this;

  0000a	83 c2 08	 add	 edx, 8
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 340  : 		return (_Tmp);
; 341  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 372  : 	_Tree_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 373  : 		{	// construct with null node
; 374  : 		}

  00008	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@std@@QAE@PAUCHAOSCASTLE_START_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >::_Vector_iterator<std::_Vector_val<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAE@PAUtagPOINT@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
; Function compile flags: /Ogtp
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=, COMDAT
; _this$ = ecx

; 369  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 370  : 		return (*this += -_Off);

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	f7 d9		 neg	 ecx
  0000a	03 c9		 add	 ecx, ecx
  0000c	03 c9		 add	 ecx, ecx
  0000e	03 c9		 add	 ecx, ecx
  00010	01 08		 add	 DWORD PTR [eax], ecx

; 371  : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T226013 = -12						; size = 12
$T226005 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 4a		 je	 SHORT $LN1@allocate
  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN3@allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T226005[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T226013[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T226005[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T226013[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T226013[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z
_TEXT	SEGMENT
$T226036 = -12						; size = 12
$T226028 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z PROC ; std::allocator<CHAOSCASTLE_START_TIME>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T226028[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T226036[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T226028[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T226036[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T226036[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ENDP ; std::allocator<CHAOSCASTLE_START_TIME>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T226059 = -12						; size = 12
$T226051 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@3
  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@3
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@3
$LN3@allocate@3:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T226051[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T226059[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T226051[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T226059[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T226059[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@3:
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z
_TEXT	SEGMENT
$T226082 = -12						; size = 12
$T226074 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z PROC ; std::allocator<tagPOINT>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@4
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@4
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@4
$LN3@allocate@4:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T226074[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T226082[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T226074[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T226082[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T226082[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@4:
?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ENDP ; std::allocator<tagPOINT>::allocate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@4
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@4:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z PROC ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN5@Move@2
  00010	56		 push	 esi
$LL7@Move@2:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL7@Move@2
  00025	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUCHAOSCASTLE_START_TIME@@PAU1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00@Z ENDP ; std::_Move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val@5
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Cons_val@5:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@6
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@6:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z PROC ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@@Z ENDP ; std::_Dest_val<std::allocator<tagPOINT>,tagPOINT>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 1326 : 		}

  00027	5d		 pop	 ebp
  00028	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<tagPOINT> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T226329 = -16						; size = 12
$T226313 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 1c		 push	 28			; 0000001cH
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 18	 mov	 WORD PTR [eax+24], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T226313[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T226313[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T226329[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T226329[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T226329[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z PROC ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 13		 je	 SHORT $LN3@construct@9
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN3@construct@9:

; 209  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??$construct@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@QAEXPAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >::construct<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@7
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@7:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@8
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@8:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
_TEXT	ENDS
PUBLIC	??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	?SetState_PlayEnd@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_PlayEnd
;	COMDAT ??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
CONST	SEGMENT
??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Chaos Castle] (%d) SetState PLAYEND', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_PlayEnd@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?SetState_PlayEnd@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_PlayEnd, COMDAT
; _this$ = ecx

; 1022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1023 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 46		 js	 SHORT $LN2@SetState_P
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 06	 cmp	 esi, 6
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 3a		 je	 SHORT $LN2@SetState_P

; 1024 : 	{
; 1025 : 		return;
; 1026 : 	}
; 1027 : 
; 1028 : 	this->SendNoticeState(iChaosCastleIndex, 7);

  0001a	6a 07		 push	 7
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 1029 : 	this->ClearMonster(iChaosCastleIndex);

  00022	56		 push	 esi
  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?ClearMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::ClearMonster

; 1030 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = false;

  0002a	8b c6		 mov	 eax, esi
  0002c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00032	c6 44 38 4c 00	 mov	 BYTE PTR [eax+edi+76], 0

; 1031 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = this->m_iCC_TIME_MIN_REST * 60 * 1000;

  00037	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0003a	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H

; 1032 : 
; 1033 : 	LogAddTD("[Chaos Castle] (%d) SetState PLAYEND", iChaosCastleIndex+1);

  00040	46		 inc	 esi
  00041	56		 push	 esi
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HDBNCAHD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00047	89 4c 38 40	 mov	 DWORD PTR [eax+edi+64], ecx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00051	83 c4 08	 add	 esp, 8
$LN2@SetState_P:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 1034 : 
; 1035 : 
; 1036 : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?SetState_PlayEnd@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_PlayEnd
_TEXT	ENDS
PUBLIC	?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z	; CChaosCastle::SearchNBlowObjs
; Function compile flags: /Ogtp
;	COMDAT ?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$220503 = -36				; size = 4
tv282 = -32						; size = 4
_iMAX_Y$ = -28						; size = 4
_iMAX_X$ = -24						; size = 4
tv276 = -20						; size = 4
_i$220499 = -16						; size = 4
_this$ = -12						; size = 4
_iMIN_Y$ = -8						; size = 4
_iMIN_X$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z PROC		; CChaosCastle::SearchNBlowObjs, COMDAT
; _this$ = ecx

; 2346 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2347 : 	if ( !CC_MAP_RANGE(iMapNumber))

  00009	8b 7d 08	 mov	 edi, DWORD PTR _iMapNumber$[ebp]
  0000c	8b d9		 mov	 ebx, ecx
  0000e	33 f6		 xor	 esi, esi
  00010	89 5d f4	 mov	 DWORD PTR _this$[ebp], ebx
  00013	83 ff 35	 cmp	 edi, 53			; 00000035H
  00016	74 19		 je	 SHORT $LN27@SearchNBlo
  00018	83 ff 12	 cmp	 edi, 18			; 00000012H
  0001b	0f 8c 8d 01 00
	00		 jl	 $LN12@SearchNBlo
  00021	33 c0		 xor	 eax, eax
  00023	83 ff 17	 cmp	 edi, 23			; 00000017H
  00026	0f 9e c0	 setle	 al
  00029	3b c6		 cmp	 eax, esi
  0002b	0f 84 7d 01 00
	00		 je	 $LN12@SearchNBlo
$LN27@SearchNBlo:

; 2348 : 		return;
; 2349 : 
; 2350 : 	if ( !CHECK_LIMIT(iX, 256) || !CHECK_LIMIT(iY, 256))

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _iX$[ebp]
  00034	3b ce		 cmp	 ecx, esi
  00036	0f 8c 72 01 00
	00		 jl	 $LN12@SearchNBlo
  0003c	33 c0		 xor	 eax, eax
  0003e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00044	0f 9e c0	 setle	 al
  00047	3b c6		 cmp	 eax, esi
  00049	0f 84 5f 01 00
	00		 je	 $LN12@SearchNBlo
  0004f	8b 45 10	 mov	 eax, DWORD PTR _iY$[ebp]
  00052	3b c6		 cmp	 eax, esi
  00054	0f 8c 54 01 00
	00		 jl	 $LN12@SearchNBlo
  0005a	33 d2		 xor	 edx, edx
  0005c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00061	0f 9e c2	 setle	 dl
  00064	3b d6		 cmp	 edx, esi
  00066	0f 84 42 01 00
	00		 je	 $LN12@SearchNBlo

; 2351 : 		return;
; 2352 : 
; 2353 : 	int iMIN_X = iX-3;

  0006c	8d 51 fd	 lea	 edx, DWORD PTR [ecx-3]

; 2354 : 	int iMAX_X = iX+3;

  0006f	83 c1 03	 add	 ecx, 3
  00072	89 4d e8	 mov	 DWORD PTR _iMAX_X$[ebp], ecx

; 2355 : 	int iMIN_Y = iY-3;

  00075	8d 48 fd	 lea	 ecx, DWORD PTR [eax-3]

; 2356 : 	int iMAX_Y = iY+3;

  00078	83 c0 03	 add	 eax, 3
  0007b	89 55 fc	 mov	 DWORD PTR _iMIN_X$[ebp], edx
  0007e	89 4d f8	 mov	 DWORD PTR _iMIN_Y$[ebp], ecx
  00081	89 45 e4	 mov	 DWORD PTR _iMAX_Y$[ebp], eax

; 2357 : 
; 2358 : 	if ( iMIN_X < 0 ) iMIN_X = 0;

  00084	3b d6		 cmp	 edx, esi
  00086	7d 03		 jge	 SHORT $LN11@SearchNBlo
  00088	89 75 fc	 mov	 DWORD PTR _iMIN_X$[ebp], esi
$LN11@SearchNBlo:

; 2359 : 	if ( iMIN_Y < 0 ) iMIN_Y = 0;

  0008b	3b ce		 cmp	 ecx, esi
  0008d	7d 05		 jge	 SHORT $LN10@SearchNBlo
  0008f	89 75 f8	 mov	 DWORD PTR _iMIN_Y$[ebp], esi
  00092	8b ce		 mov	 ecx, esi
$LN10@SearchNBlo:

; 2360 : 	if ( iMIN_X > 255 ) iMIN_X = 255;

  00094	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00099	39 45 fc	 cmp	 DWORD PTR _iMIN_X$[ebp], eax
  0009c	7e 03		 jle	 SHORT $LN9@SearchNBlo
  0009e	89 45 fc	 mov	 DWORD PTR _iMIN_X$[ebp], eax
$LN9@SearchNBlo:

; 2361 : 	if ( iMIN_Y > 255 ) iMIN_Y = 255;

  000a1	3b c8		 cmp	 ecx, eax
  000a3	7e 03		 jle	 SHORT $LN8@SearchNBlo
  000a5	89 45 f8	 mov	 DWORD PTR _iMIN_Y$[ebp], eax
$LN8@SearchNBlo:

; 2364 : 	{
; 2365 : 		int iChaosCastleIndex = this->GetChaosCastleIndex(iMapNumber);

  000a8	57		 push	 edi
  000a9	8b cb		 mov	 ecx, ebx
  000ab	89 75 f0	 mov	 DWORD PTR _i$220499[ebp], esi
  000ae	e8 00 00 00 00	 call	 ?GetChaosCastleIndex@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleIndex
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b9	89 45 dc	 mov	 DWORD PTR _iChaosCastleIndex$220503[ebp], eax
  000bc	6b c0 6c	 imul	 eax, 108		; 0000006cH
  000bf	89 45 ec	 mov	 DWORD PTR tv276[ebp], eax
  000c2	eb 03		 jmp	 SHORT $LN7@SearchNBlo
$LL31@SearchNBlo:
  000c4	8b 45 ec	 mov	 eax, DWORD PTR tv276[ebp]
$LN7@SearchNBlo:

; 2366 : 
; 2367 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex == -1 )

  000c7	03 c6		 add	 eax, esi
  000c9	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000cc	8b 74 83 6c	 mov	 esi, DWORD PTR [ebx+eax*4+108]
  000d0	89 75 e0	 mov	 DWORD PTR tv282[ebp], esi
  000d3	83 fe ff	 cmp	 esi, -1
  000d6	0f 84 c2 00 00
	00		 je	 $LN6@SearchNBlo

; 2368 : 		{
; 2369 : 			continue;
; 2370 : 		}
; 2371 : 
; 2372 : 		int iIndex = this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex;
; 2373 : 
; 2374 : 		if ( gObj[iIndex].MapNumber == iMapNumber && gObj[iIndex].Connected > PLAYER_LOGGED )

  000dc	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000e2	0f b6 94 0e 49
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+329]
  000ea	3b d7		 cmp	 edx, edi
  000ec	0f 85 ac 00 00
	00		 jne	 $LN6@SearchNBlo
  000f2	83 7c 0e 04 02	 cmp	 DWORD PTR [esi+ecx+4], 2
  000f7	0f 8e a1 00 00
	00		 jle	 $LN6@SearchNBlo

; 2375 : 		{
; 2376 : 			if ( gObj[iIndex].X >= iMIN_X && gObj[iIndex].X <= iMAX_X && gObj[iIndex].Y >= iMIN_Y && gObj[iIndex].Y <= iMAX_Y )

  000fd	0f bf 84 0e 44
	01 00 00	 movsx	 eax, WORD PTR [esi+ecx+324]
  00105	3b 45 fc	 cmp	 eax, DWORD PTR _iMIN_X$[ebp]
  00108	0f 8c 90 00 00
	00		 jl	 $LN6@SearchNBlo
  0010e	3b 45 e8	 cmp	 eax, DWORD PTR _iMAX_X$[ebp]
  00111	0f 8f 87 00 00
	00		 jg	 $LN6@SearchNBlo
  00117	0f bf 84 0e 46
	01 00 00	 movsx	 eax, WORD PTR [esi+ecx+326]
  0011f	3b 45 f8	 cmp	 eax, DWORD PTR _iMIN_Y$[ebp]
  00122	7c 7a		 jl	 SHORT $LN6@SearchNBlo
  00124	3b 45 e4	 cmp	 eax, DWORD PTR _iMAX_Y$[ebp]
  00127	7f 75		 jg	 SHORT $LN6@SearchNBlo

; 2377 : 			{
; 2378 : 				this->BlowObjsFromPoint(gObj[iIndex].m_Index, iMapNumber, iX, iY);

  00129	8d 45 10	 lea	 eax, DWORD PTR _iY$[ebp]
  0012c	50		 push	 eax
  0012d	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  00130	8d 55 0c	 lea	 edx, DWORD PTR _iX$[ebp]
  00133	52		 push	 edx
  00134	57		 push	 edi
  00135	50		 push	 eax
  00136	8b cb		 mov	 ecx, ebx
  00138	e8 00 00 00 00	 call	 ?BlowObjsFromPoint@CChaosCastle@@QAEHHHAAH0@Z ; CChaosCastle::BlowObjsFromPoint

; 2379 : 
; 2380 : 				BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iY * 256 + iX]&0x08;

  0013d	8b 5d 0c	 mov	 ebx, DWORD PTR _iX$[ebp]
  00140	8b cf		 mov	 ecx, edi
  00142	8b 7d 10	 mov	 edi, DWORD PTR _iY$[ebp]
  00145	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0014b	8b d7		 mov	 edx, edi
  0014d	c1 e2 08	 shl	 edx, 8
  00150	03 91 10 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+16]
  00156	f6 04 1a 08	 test	 BYTE PTR [edx+ebx], 8

; 2381 : 
; 2382 : 				if ( btMapAttr == 8 )

  0015a	74 36		 je	 SHORT $LN28@SearchNBlo

; 2383 : 				{
; 2384 : 					this->AddFallUser(iChaosCastleIndex, iIndex);

  0015c	8b 45 e0	 mov	 eax, DWORD PTR tv282[ebp]
  0015f	8b 4d dc	 mov	 ecx, DWORD PTR _iChaosCastleIndex$220503[ebp]
  00162	50		 push	 eax
  00163	51		 push	 ecx
  00164	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	e8 00 00 00 00	 call	 ?AddFallUser@CChaosCastle@@QAEXHH@Z ; CChaosCastle::AddFallUser

; 2385 : 					LogAddTD("[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Fall from Castle (X:%d, Y:%d)", iMapNumber-17, gObj[iIndex].AccountID, gObj[iIndex].Name, iX, iY);

  0016c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00171	8b 4d 08	 mov	 ecx, DWORD PTR _iMapNumber$[ebp]
  00174	57		 push	 edi
  00175	53		 push	 ebx
  00176	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0017a	52		 push	 edx
  0017b	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0017f	50		 push	 eax
  00180	83 c1 ef	 add	 ecx, -17		; ffffffefH
  00183	51		 push	 ecx
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PPIJPFML@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use@
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0018f	83 c4 18	 add	 esp, 24			; 00000018H
$LN28@SearchNBlo:
  00192	8b 5d f4	 mov	 ebx, DWORD PTR _this$[ebp]
  00195	8b 7d 08	 mov	 edi, DWORD PTR _iMapNumber$[ebp]
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN6@SearchNBlo:

; 2362 : 	
; 2363 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  0019e	8b 75 f0	 mov	 esi, DWORD PTR _i$220499[ebp]
  001a1	46		 inc	 esi
  001a2	89 75 f0	 mov	 DWORD PTR _i$220499[ebp], esi
  001a5	83 fe 46	 cmp	 esi, 70			; 00000046H
  001a8	0f 8c 16 ff ff
	ff		 jl	 $LL31@SearchNBlo
$LN12@SearchNBlo:
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx

; 2386 : 				}
; 2387 : 			}
; 2388 : 		}
; 2389 : 	}
; 2390 : }

  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c2 0c 00	 ret	 12			; 0000000cH
?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z ENDP		; CChaosCastle::SearchNBlowObjs
_TEXT	ENDS
PUBLIC	?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::end
_TEXT	ENDS
PUBLIC	?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back
; Function compile flags: /Ogtp
;	COMDAT ?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back, COMDAT
; _this$ = ecx

; 1017 : 		if (!empty())

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	39 01		 cmp	 DWORD PTR [ecx], eax
  00005	74 06		 je	 SHORT $LN1@pop_back

; 1018 : 			{	// erase last element
; 1019 : 			_Dest_val(this->_Alval,
; 1020 : 				this->_Mylast - 1);
; 1021 : 			--this->_Mylast;

  00007	83 c0 f8	 add	 eax, -8			; fffffff8H
  0000a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN1@pop_back:

; 1022 : 			}
; 1023 : 		}

  0000d	c3		 ret	 0
?pop_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::pop_back
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@2@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::end
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> > >
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-, COMDAT
; _this$ = ecx

; 374  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 375  : 		_Myiter _Tmp = *this;
; 376  : 		return (_Tmp -= _Off);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00012	2b ca		 sub	 ecx, edx
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 377  : 		}

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<tagPOINT,std::allocator<tagPOINT> > >::operator-
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
$T226707 = -16						; size = 12
$T226691 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 18	 mov	 BYTE PTR [ecx+24], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 19	 mov	 BYTE PTR [edx+25], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T226691[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T226707[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T226691[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T226707[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T226707[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		if (max_size() < _Count)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00015	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  0001a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001d	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0001f	c1 f9 02	 sar	 ecx, 2
  00022	3b c8		 cmp	 ecx, eax
  00024	73 50		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00026	53		 push	 ebx
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0002c	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00031	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00034	8b d8		 mov	 ebx, eax
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	2b d0		 sub	 edx, eax
  0003a	c1 fa 02	 sar	 edx, 2
  0003d	03 d2		 add	 edx, edx
  0003f	03 d2		 add	 edx, edx
  00041	52		 push	 edx
  00042	50		 push	 eax
  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 _memmove

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0004e	2b f8		 sub	 edi, eax
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	c1 ff 02	 sar	 edi, 2

; 761  : 			if (this->_Myfirst != 0)

  00056	85 c0		 test	 eax, eax
  00058	74 09		 je	 SHORT $LN37@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN37@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00063	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00066	8d 14 bb	 lea	 edx, DWORD PTR [ebx+edi*4]
  00069	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  0006c	5f		 pop	 edi

; 771  : 			this->_Myfirst = _Ptr;

  0006d	89 1e		 mov	 DWORD PTR [esi], ebx
  0006f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00072	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00075	5b		 pop	 ebx
$LN3@reserve:
  00076	5e		 pop	 esi

; 772  : 			}
; 773  : 		}

  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
$LN42@reserve:
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv795 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 19 00	 cmp	 BYTE PTR [ebx+25], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN295@erase:
$LN40@erase:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00030	74 05		 je	 SHORT $LN39@erase

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase
$LN39@erase:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0003e	74 04		 je	 SHORT $LN37@erase

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase
$LN37@erase:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase
$LN291@erase:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  00080	74 04		 je	 SHORT $LN43@erase
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase
$LN43@erase:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv795[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  000a6	74 07		 je	 SHORT $LN45@erase
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase
$LN45@erase:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv795[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase
$LN35@erase:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 19 00	 cmp	 BYTE PTR [edi+25], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 18	 mov	 dl, BYTE PTR [ebx+24]
  00111	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  00114	88 50 18	 mov	 BYTE PTR [eax+24], dl
  00117	88 4b 18	 mov	 BYTE PTR [ebx+24], cl
$LN165@erase:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0011d	b3 01		 mov	 bl, 1
  0011f	38 58 18	 cmp	 BYTE PTR [eax+24], bl
  00122	0f 85 fa 00 00
	00		 jne	 $LN19@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 e8 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00137	38 5f 18	 cmp	 BYTE PTR [edi+24], bl
  0013a	0f 85 df 00 00
	00		 jne	 $LN16@erase

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 18 00	 cmp	 BYTE PTR [eax+24], 0
  0014d	75 13		 jne	 SHORT $LN14@erase

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 18	 mov	 BYTE PTR [eax+24], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN293@erase

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  0016d	75 08		 jne	 SHORT $LN11@erase
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  00175	74 61		 je	 SHORT $LN294@erase
$LN11@erase:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  0017d	75 15		 jne	 SHORT $LN9@erase

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 18	 mov	 dl, BYTE PTR [esi+24]
  00197	88 50 18	 mov	 BYTE PTR [eax+24], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 18	 mov	 BYTE PTR [esi+24], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 18	 mov	 BYTE PTR [eax+24], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN16@erase
$LN15@erase:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 18 00	 cmp	 BYTE PTR [eax+24], 0
  001af	75 12		 jne	 SHORT $LN7@erase

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 18	 mov	 BYTE PTR [eax+24], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN293@erase

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  001d6	75 17		 jne	 SHORT $LN4@erase
$LN294@erase:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
$LN293@erase:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 30		 jmp	 SHORT $LN16@erase
$LN4@erase:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  001f4	75 15		 jne	 SHORT $LN2@erase

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 18	 mov	 dl, BYTE PTR [esi+24]
  0020e	88 50 18	 mov	 BYTE PTR [eax+24], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 18	 mov	 BYTE PTR [esi+24], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 18	 mov	 BYTE PTR [eax+24], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Rrotate
$LN16@erase:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021f	88 5f 18	 mov	 BYTE PTR [edi+24], bl
$LN19@erase:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00222	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx
  00237	85 c0		 test	 eax, eax
  00239	74 04		 je	 SHORT $LN1@erase

; 1373 : 			--this->_Mysize;

  0023b	48		 dec	 eax
  0023c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0023f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00242	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00245	89 10		 mov	 DWORD PTR [eax], edx

; 1376 : 		}

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 08 00	 ret	 8
$LN292@erase:
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Destroy_range<std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<tagPOINT> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UtagPOINT@@@std@@@std@@YAXPAUtagPOINT@@0AAV?$allocator@UtagPOINT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	3d 54 55 55 15	 cmp	 eax, 357913940		; 15555554H
  0000b	72 16		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  0000d	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  00023	40		 inc	 eax
  00024	53		 push	 ebx
  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1642 : 		_Newnode->_Parent = _Wherenode;

  00028	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002b	57		 push	 edi
  0002c	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	32 db		 xor	 bl, bl
  00037	3b c2		 cmp	 eax, edx
  00039	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003b	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00049	eb 20		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  0004b	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0004e	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  00050	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00059	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  0005b	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005d	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00066	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00068	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0006b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006e	8b c7		 mov	 eax, edi
  00070	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  00073	0f 85 97 01 00
	00		 jne	 $LN9@Insert
  00079	56		 push	 esi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00080	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00083	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00086	3b 16		 cmp	 edx, DWORD PTR [esi]
  00088	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  0008e	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00091	38 5e 18	 cmp	 BYTE PTR [esi+24], bl
  00094	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00096	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  0009a	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  0009e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a4	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000ad	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000b5	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000b7	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000b9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bc	8b 32		 mov	 esi, DWORD PTR [edx]
  000be	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c1	8b 32		 mov	 esi, DWORD PTR [edx]
  000c3	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  000c6	75 03		 jne	 SHORT $LN110@Insert
  000c8	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert:
  000cb	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000ce	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d1	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d4	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000d7	75 05		 jne	 SHORT $LN109@Insert
  000d9	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000dc	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000de	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e1	3b 06		 cmp	 eax, DWORD PTR [esi]
  000e3	75 04		 jne	 SHORT $LN107@Insert
  000e5	89 16		 mov	 DWORD PTR [esi], edx
  000e7	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000e9	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000ec	89 02		 mov	 DWORD PTR [edx], eax
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f4	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000fe	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00107	8b 32		 mov	 esi, DWORD PTR [edx]
  00109	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0010c	89 3a		 mov	 DWORD PTR [edx], edi
  0010e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00111	38 5f 19	 cmp	 BYTE PTR [edi+25], bl
  00114	75 03		 jne	 SHORT $LN173@Insert
  00116	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00119	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0011c	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0011f	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00122	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  00125	75 0b		 jne	 SHORT $LN172@Insert
  00127	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0012a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0012d	e9 cb 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  00132	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00135	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00138	75 0b		 jne	 SHORT $LN170@Insert
  0013a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0013d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00140	e9 b8 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  00145	89 37		 mov	 DWORD PTR [edi], esi
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0014a	e9 ae 00 00 00	 jmp	 $LN376@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  0014f	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00151	38 5e 18	 cmp	 BYTE PTR [esi+24], bl
  00154	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00156	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0015a	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0015e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00161	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00164	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  0016d	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00172	3b 02		 cmp	 eax, DWORD PTR [edx]
  00174	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00176	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  00178	8b 10		 mov	 edx, DWORD PTR [eax]
  0017a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017d	89 30		 mov	 DWORD PTR [eax], esi
  0017f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00182	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  00185	75 03		 jne	 SHORT $LN252@Insert
  00187	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert:
  0018a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0018d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00190	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00193	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00196	75 05		 jne	 SHORT $LN251@Insert
  00198	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0019b	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  0019d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a0	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001a3	75 05		 jne	 SHORT $LN249@Insert
  001a5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a8	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001aa	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001ac	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001af	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b5	c6 42 18 01	 mov	 BYTE PTR [edx+24], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001bf	88 5a 18	 mov	 BYTE PTR [edx+24], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c5	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c8	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001cb	8b 3e		 mov	 edi, DWORD PTR [esi]
  001cd	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d0	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d2	38 5f 19	 cmp	 BYTE PTR [edi+25], bl
  001d5	75 03		 jne	 SHORT $LN315@Insert
  001d7	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001da	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001dd	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e0	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001e3	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001e6	75 05		 jne	 SHORT $LN314@Insert
  001e8	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001eb	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001ed	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f0	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f2	75 04		 jne	 SHORT $LN312@Insert
  001f4	89 37		 mov	 DWORD PTR [edi], esi
  001f6	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001f8	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  001fb	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert:
  001fd	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00200	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00203	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00206	38 5a 18	 cmp	 BYTE PTR [edx+24], bl
  00209	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
  0020f	5e		 pop	 esi
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00210	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00213	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  00216	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00219	89 38		 mov	 DWORD PTR [eax], edi
  0021b	5f		 pop	 edi
  0021c	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1
  00220	5b		 pop	 ebx

; 1721 : 		}

  00221	5d		 pop	 ebp
  00222	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 13		 je	 SHORT $LN7@Cons_val@9
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN7@Cons_val@9:

; 281  : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@U3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@$$QAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME>
  0001e	83 c6 08	 add	 esi, 8
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 08	 add	 edi, 8
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov@2
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov@2:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@U3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@$$QAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT>
  0001e	83 c6 08	 add	 esi, 8
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 08	 add	 edi, 8
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov@2

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov@2:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
_TEXT	ENDS
PUBLIC	?SetState_Playing@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_Playing
PUBLIC	?SetState_Closed@CChaosCastle@@IAEXH@Z		; CChaosCastle::SetState_Closed
PUBLIC	?SetState@CChaosCastle@@QAEXHH@Z		; CChaosCastle::SetState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
;	COMDAT ?SetState@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
_iCC_STATE$ = 12					; size = 4
?SetState@CChaosCastle@@QAEXHH@Z PROC			; CChaosCastle::SetState, COMDAT
; _this$ = ecx

; 931  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 932  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 48		 js	 SHORT $LN7@SetState
  0000a	33 d2		 xor	 edx, edx
  0000c	83 f8 06	 cmp	 eax, 6
  0000f	0f 9e c2	 setle	 dl
  00012	85 d2		 test	 edx, edx
  00014	74 3c		 je	 SHORT $LN7@SetState

; 933  : 	{
; 934  : 		return;
; 935  : 	}
; 936  : 
; 937  : 	if ( iCC_STATE < CC_STATE_NONE || iCC_STATE > CC_STATE_PLAYEND )

  00016	8b 55 0c	 mov	 edx, DWORD PTR _iCC_STATE$[ebp]
  00019	83 fa 03	 cmp	 edx, 3
  0001c	77 34		 ja	 SHORT $LN7@SetState

; 938  : 	{
; 939  : 		return;
; 940  : 	}
; 941  : 
; 942  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE = iCC_STATE;

  0001e	56		 push	 esi
  0001f	8b f0		 mov	 esi, eax
  00021	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  00027	89 54 0e 30	 mov	 DWORD PTR [esi+ecx+48], edx
  0002b	5e		 pop	 esi

; 943  : 
; 944  : 	switch ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_STATE )

  0002c	83 fa 03	 cmp	 edx, 3
  0002f	77 21		 ja	 SHORT $LN7@SetState
  00031	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN14@SetState[edx*4]
$LN3@SetState:

; 945  : 	{
; 946  : 		case CC_STATE_NONE:
; 947  : 			this->SetState_None(iChaosCastleIndex);
; 948  : 			break;
; 949  : 
; 950  : 		case CC_STATE_CLOSED:
; 951  : 			this->SetState_Closed(iChaosCastleIndex);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?SetState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Closed

; 960  : 	}
; 961  : 	
; 962  : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN2@SetState:

; 952  : 			break;
; 953  : 
; 954  : 		case CC_STATE_PLAYING:
; 955  : 			this->SetState_Playing(iChaosCastleIndex);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?SetState_Playing@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Playing

; 960  : 	}
; 961  : 	
; 962  : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN1@SetState:

; 956  : 			break;
; 957  : 
; 958  : 		case CC_STATE_PLAYEND:
; 959  : 			this->SetState_PlayEnd(iChaosCastleIndex);

  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_PlayEnd
$LN7@SetState:

; 960  : 	}
; 961  : 	
; 962  : }

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
  00056	8b ff		 npad	 2
$LN14@SetState:
  00058	00 00 00 00	 DD	 $LN7@SetState
  0005c	00 00 00 00	 DD	 $LN3@SetState
  00060	00 00 00 00	 DD	 $LN2@SetState
  00064	00 00 00 00	 DD	 $LN1@SetState
?SetState@CChaosCastle@@QAEXHH@Z ENDP			; CChaosCastle::SetState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetRemainTime@CChaosCastle@@QAEHH@Z		; CChaosCastle::GetRemainTime
EXTRN	__imp__GetLocalTime@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetRemainTime@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
tv462 = -36						; size = 4
tv477 = -32						; size = 4
tv465 = -28						; size = 4
_bTIME_CHANGED$220422 = -24				; size = 4
_sysTime$220419 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?GetRemainTime@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::GetRemainTime, COMDAT
; _this$ = ecx

; 2203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 2204 : 	int iREMAIN_MINUTE = 0;
; 2205 : 
; 2206 : 	if ( this->GetCurrentState(iChaosCastleIndex) == 1 )

  00012	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00015	57		 push	 edi
  00016	8b f1		 mov	 esi, ecx
  00018	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  0001d	83 f8 01	 cmp	 eax, 1
  00020	75 24		 jne	 SHORT $LN18@GetRemainT

; 2207 : 	{
; 2208 : 		iREMAIN_MINUTE = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000 - this->m_iCC_TIME_MIN_OPEN + 1;

  00022	69 ff 70 08 00
	00		 imul	 edi, 2160		; 00000870H
  00028	8b 7c 37 40	 mov	 edi, DWORD PTR [edi+esi+64]
  0002c	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00031	f7 ef		 imul	 edi
  00033	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00036	8b c2		 mov	 eax, edx
  00038	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003b	03 c2		 add	 eax, edx
  0003d	2b 46 08	 sub	 eax, DWORD PTR [esi+8]
  00040	40		 inc	 eax

; 2209 : 	}
; 2210 : 	else

  00041	e9 14 01 00 00	 jmp	 $LN5@GetRemainT
$LN18@GetRemainT:
  00046	53		 push	 ebx

; 2211 : 	{
; 2212 : 		SYSTEMTIME sysTime;
; 2213 : 		GetLocalTime(&sysTime);

  00047	8d 4d ec	 lea	 ecx, DWORD PTR _sysTime$220419[ebp]
  0004a	51		 push	 ecx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 2214 : 		int iMIN_HOUR = 24;
; 2215 : 		int iMIN_MINUTE = 60;
; 2216 : 		BOOL bTIME_CHANGED = FALSE;
; 2217 : 		std::vector<CHAOSCASTLE_START_TIME>::iterator it;
; 2218 : 
; 2219 : 		for( it = this->m_vtChaosCastleOpenTime.begin();  it != this->m_vtChaosCastleOpenTime.end(); it++)

  00051	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00054	8b 76 24	 mov	 esi, DWORD PTR [esi+36]
  00057	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0005c	8d 48 24	 lea	 ecx, DWORD PTR [eax+36]
  0005f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$220422[ebp], 0
  00066	89 55 dc	 mov	 DWORD PTR tv462[ebp], edx
  00069	89 75 e4	 mov	 DWORD PTR tv465[ebp], esi
  0006c	3b d6		 cmp	 edx, esi
  0006e	74 56		 je	 SHORT $LN99@GetRemainT

; 2230 : 				}
; 2231 : 			}
; 2232 : 		}
; 2233 : 					
; 2234 : 		if ( bTIME_CHANGED == 0 )

  00070	0f b7 75 f4	 movzx	 esi, WORD PTR _sysTime$220419[ebp+8]
  00074	8b fe		 mov	 edi, esi
  00076	c1 e7 04	 shl	 edi, 4
  00079	2b fe		 sub	 edi, esi
  0007b	0f b7 75 f6	 movzx	 esi, WORD PTR _sysTime$220419[ebp+10]
  0007f	8d 34 be	 lea	 esi, DWORD PTR [esi+edi*4]
  00082	89 75 e0	 mov	 DWORD PTR tv477[ebp], esi
$LL37@GetRemainT:

; 2220 : 		{
; 2221 : 			CHAOSCASTLE_START_TIME & pRET = *it;
; 2222 : 			
; 2223 : 			if ( (sysTime.wHour * 60 + sysTime.wMinute) < (pRET.m_iHour * 60 + pRET.m_iMinute))

  00085	8b 32		 mov	 esi, DWORD PTR [edx]
  00087	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0008a	8b de		 mov	 ebx, esi
  0008c	c1 e3 04	 shl	 ebx, 4
  0008f	2b de		 sub	 ebx, esi
  00091	8d 3c 9f	 lea	 edi, DWORD PTR [edi+ebx*4]
  00094	39 7d e0	 cmp	 DWORD PTR tv477[ebp], edi
  00097	7d 1a		 jge	 SHORT $LN15@GetRemainT

; 2224 : 			{
; 2225 : 				if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute))

  00099	8b d8		 mov	 ebx, eax
  0009b	c1 e3 04	 shl	 ebx, 4
  0009e	2b d8		 sub	 ebx, eax
  000a0	8d 1c 99	 lea	 ebx, DWORD PTR [ecx+ebx*4]
  000a3	3b df		 cmp	 ebx, edi
  000a5	7e 0c		 jle	 SHORT $LN15@GetRemainT

; 2226 : 				{
; 2227 : 					bTIME_CHANGED = 1;
; 2228 : 					iMIN_HOUR = pRET.m_iHour;
; 2229 : 					iMIN_MINUTE = pRET.m_iMinute;

  000a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000aa	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$220422[ebp], 1
  000b1	8b c6		 mov	 eax, esi
$LN15@GetRemainT:

; 2214 : 		int iMIN_HOUR = 24;
; 2215 : 		int iMIN_MINUTE = 60;
; 2216 : 		BOOL bTIME_CHANGED = FALSE;
; 2217 : 		std::vector<CHAOSCASTLE_START_TIME>::iterator it;
; 2218 : 
; 2219 : 		for( it = this->m_vtChaosCastleOpenTime.begin();  it != this->m_vtChaosCastleOpenTime.end(); it++)

  000b3	8b 75 e4	 mov	 esi, DWORD PTR tv465[ebp]
  000b6	83 c2 08	 add	 edx, 8
  000b9	3b d6		 cmp	 edx, esi
  000bb	75 c8		 jne	 SHORT $LL37@GetRemainT

; 2230 : 				}
; 2231 : 			}
; 2232 : 		}
; 2233 : 					
; 2234 : 		if ( bTIME_CHANGED == 0 )

  000bd	83 7d e8 00	 cmp	 DWORD PTR _bTIME_CHANGED$220422[ebp], 0
  000c1	75 42		 jne	 SHORT $LN104@GetRemainT
  000c3	8b 55 dc	 mov	 edx, DWORD PTR tv462[ebp]
$LN99@GetRemainT:

; 2235 : 		{
; 2236 : 			it = this->m_vtChaosCastleOpenTime.begin();

  000c6	8b fa		 mov	 edi, edx

; 2237 : 			iMIN_HOUR = 24;

  000c8	b8 18 00 00 00	 mov	 eax, 24			; 00000018H

; 2238 : 			iMIN_MINUTE = 60;

  000cd	8d 48 24	 lea	 ecx, DWORD PTR [eax+36]

; 2239 : 
; 2240 : 			for(; it != this->m_vtChaosCastleOpenTime.end(); it++)

  000d0	3b fe		 cmp	 edi, esi
  000d2	74 31		 je	 SHORT $LN104@GetRemainT
$LL72@GetRemainT:

; 2241 : 			{
; 2242 : 				CHAOSCASTLE_START_TIME & pRET = *it;
; 2243 : 			
; 2244 : 				if ( (iMIN_HOUR * 60 + iMIN_MINUTE) > (pRET.m_iHour * 60 + pRET.m_iMinute))

  000d4	8b 17		 mov	 edx, DWORD PTR [edi]
  000d6	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  000d9	8b da		 mov	 ebx, edx
  000db	c1 e3 04	 shl	 ebx, 4
  000de	2b da		 sub	 ebx, edx
  000e0	8d 34 9e	 lea	 esi, DWORD PTR [esi+ebx*4]
  000e3	8b d8		 mov	 ebx, eax
  000e5	c1 e3 04	 shl	 ebx, 4
  000e8	2b d8		 sub	 ebx, eax
  000ea	8d 1c 99	 lea	 ebx, DWORD PTR [ecx+ebx*4]
  000ed	3b de		 cmp	 ebx, esi
  000ef	7e 0c		 jle	 SHORT $LN9@GetRemainT

; 2245 : 				{
; 2246 : 					bTIME_CHANGED = 2;
; 2247 : 					iMIN_HOUR = pRET.m_iHour;
; 2248 : 					iMIN_MINUTE = pRET.m_iMinute;

  000f1	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f4	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$220422[ebp], 2
  000fb	8b c2		 mov	 eax, edx
$LN9@GetRemainT:

; 2239 : 
; 2240 : 			for(; it != this->m_vtChaosCastleOpenTime.end(); it++)

  000fd	83 c7 08	 add	 edi, 8
  00100	3b 7d e4	 cmp	 edi, DWORD PTR tv465[ebp]
  00103	75 cf		 jne	 SHORT $LL72@GetRemainT
$LN104@GetRemainT:

; 2249 : 				}
; 2250 : 			}
; 2251 : 		}
; 2252 : 
; 2253 : 		switch ( bTIME_CHANGED )

  00105	8b 55 e8	 mov	 edx, DWORD PTR _bTIME_CHANGED$220422[ebp]
  00108	4a		 dec	 edx
  00109	5b		 pop	 ebx
  0010a	74 0e		 je	 SHORT $LN4@GetRemainT
  0010c	4a		 dec	 edx
  0010d	75 4f		 jne	 SHORT $LN105@GetRemainT

; 2257 : 				break;
; 2258 : 			case 2:
; 2259 : 				iREMAIN_MINUTE = ((((iMIN_HOUR + 24) * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond)) ) / 60 + 1;

  0010f	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$220419[ebp+8]
  00113	2b c2		 sub	 eax, edx
  00115	83 c0 18	 add	 eax, 24			; 00000018H

; 2260 : 				break;

  00118	eb 06		 jmp	 SHORT $LN106@GetRemainT
$LN4@GetRemainT:

; 2254 : 		{
; 2255 : 			case 1:
; 2256 : 				iREMAIN_MINUTE = (((iMIN_HOUR * 60 * 60 + iMIN_MINUTE * 60) - (sysTime.wHour * 60 * 60 + sysTime.wMinute * 60 + sysTime.wSecond))) /60 + 1;

  0011a	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$220419[ebp+8]
  0011e	2b c2		 sub	 eax, edx
$LN106@GetRemainT:
  00120	8b d0		 mov	 edx, eax
  00122	c1 e2 04	 shl	 edx, 4
  00125	2b d0		 sub	 edx, eax
  00127	03 d2		 add	 edx, edx
  00129	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  0012c	0f b7 55 f6	 movzx	 edx, WORD PTR _sysTime$220419[ebp+10]
  00130	2b c2		 sub	 eax, edx
  00132	0f b7 55 f8	 movzx	 edx, WORD PTR _sysTime$220419[ebp+12]
  00136	03 c1		 add	 eax, ecx
  00138	8b c8		 mov	 ecx, eax
  0013a	c1 e1 04	 shl	 ecx, 4
  0013d	2b c8		 sub	 ecx, eax
  0013f	03 c9		 add	 ecx, ecx
  00141	03 c9		 add	 ecx, ecx
  00143	2b ca		 sub	 ecx, edx
  00145	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0014a	f7 e9		 imul	 ecx
  0014c	03 d1		 add	 edx, ecx
  0014e	c1 fa 05	 sar	 edx, 5
  00151	8b c2		 mov	 eax, edx
  00153	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00156	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
$LN5@GetRemainT:

; 2261 : 			default:
; 2262 : 				iREMAIN_MINUTE = -1;
; 2263 : 				break;
; 2264 : 		}
; 2265 : 	}
; 2266 : 
; 2267 : 	if ( iREMAIN_MINUTE < 0 )

  0015a	85 c0		 test	 eax, eax
  0015c	79 02		 jns	 SHORT $LN1@GetRemainT
$LN105@GetRemainT:

; 2268 : 	{
; 2269 : 		iREMAIN_MINUTE = 0;

  0015e	33 c0		 xor	 eax, eax
$LN1@GetRemainT:

; 2270 : 	}
; 2271 : 
; 2272 : 	return iREMAIN_MINUTE;
; 2273 : }

  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	5f		 pop	 edi
  00164	33 cd		 xor	 ecx, ebp
  00166	5e		 pop	 esi
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c2 04 00	 ret	 4
?GetRemainTime@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::GetRemainTime
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::end
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00005	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00008	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000b	80 7b 19 00	 cmp	 BYTE PTR [ebx+25], 0
  0000f	8b f3		 mov	 esi, ebx
  00011	75 1e		 jne	 SHORT $LN7@clear
$LL9@clear:
  00013	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00016	51		 push	 ecx
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 19 00	 cmp	 BYTE PTR [esi+25], 0
  0002d	8b de		 mov	 ebx, esi
  0002f	74 e2		 je	 SHORT $LL9@clear
$LN7@clear:

; 1416 : 		_Root() = this->_Myhead;

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00037	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0003c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00042	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1420 : 		}

  0004c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
; Function compile flags: /Ogtp
;	COMDAT ?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ
_TEXT	SEGMENT
?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back, COMDAT
; _this$ = ecx

; 967  : 		return (*(end() - 1));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 08	 sub	 eax, 8

; 968  : 		}

  00006	c3		 ret	 0
?back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEAAUtagPOINT@@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::back
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z
_TEXT	SEGMENT
$T228636 = -16						; size = 12
$T228578 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 1c		 push	 28			; 0000001cH
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 18	 mov	 BYTE PTR [ecx+24], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 19	 mov	 BYTE PTR [edx+25], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T228578[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T228636[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T228578[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T228636[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T228636[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	7d 05		 jge	 SHORT $LN4@lower_boun
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:
  00022	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun
$LN36@lower_boun:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  00014	c1 f8 02	 sar	 eax, 2
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 02	 sar	 edx, 2
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
$LN1@Reserve:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reserve
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T228822 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 1c		 jne	 SHORT $LN97@erase@2
  00014	3b d0		 cmp	 edx, eax
  00016	75 18		 jne	 SHORT $LN97@erase@2

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::clear

; 1383 : 			return (begin());

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx
  00029	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase@2:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  00030	3b ca		 cmp	 ecx, edx
  00032	74 5e		 je	 SHORT $LN1@erase@2
$LL2@erase@2:

; 1388 : 				erase(_First++);

  00034	80 79 19 00	 cmp	 BYTE PTR [ecx+25], 0
  00038	8b d1		 mov	 edx, ecx
  0003a	75 42		 jne	 SHORT $LN59@erase@2
  0003c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003f	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00043	75 1a		 jne	 SHORT $LN99@erase@2
  00045	8b c8		 mov	 ecx, eax
  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0004d	75 0b		 jne	 SHORT $LN73@erase@2
  0004f	90		 npad	 1
$LL74@erase@2:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00058	74 f6		 je	 SHORT $LL74@erase@2
$LN73@erase@2:
  0005a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@2
$LN99@erase@2:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00066	75 13		 jne	 SHORT $LN57@erase@2
$LL58@erase@2:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@2
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00079	74 ed		 je	 SHORT $LL58@erase@2
$LN57@erase@2:
  0007b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@2:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T228822[ebp]
  00082	52		 push	 edx
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0008d	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00090	75 a2		 jne	 SHORT $LL2@erase@2
$LN1@erase@2:

; 1389 : 			return (iterator(_First._Ptr, this));

  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXPAUtagPOINT@@0@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAXPAUCHAOSCASTLE_START_TIME@@0AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T229174 = 16						; size = 4
$T229172 = 16						; size = 4
__Where$222811 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00010	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	b1 01		 mov	 cl, 1
  00019	57		 push	 edi
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert
  0001f	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  0002d	0f 9d c1	 setge	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN146@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  00035	0f 9c c1	 setl	 cl
$LN146@Linsert:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b fe		 mov	 edi, esi
  0004e	89 7d 10	 mov	 DWORD PTR __Where$222811[ebp], edi

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T229172[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 7d 10	 mov	 edi, DWORD PTR __Where$222811[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  0008d	52		 push	 edx
  0008e	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00091	7d 24		 jge	 SHORT $LN2@Linsert
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __Addleft$[ebp]
  00096	56		 push	 esi
  00097	51		 push	 ecx
  00098	8d 55 10	 lea	 edx, DWORD PTR $T229174[ebp]
  0009b	52		 push	 edx
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Insert
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b0	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000b7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	83 c4 04	 add	 esp, 4
  000c2	89 38		 mov	 DWORD PTR [eax], edi
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000ca	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
$T229544 = -12						; size = 12
$T229497 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00008	6a 1c		 push	 28			; 0000001cH
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	33 c0		 xor	 eax, eax
  00015	83 c4 04	 add	 esp, 4
  00018	3b f0		 cmp	 esi, eax
  0001a	74 33		 je	 SHORT $LN12@Buynode@2
  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00027	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  0002a	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0002d	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  00031	52		 push	 edx
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	83 c7 0d	 add	 edi, 13			; 0000000dH
  00039	57		 push	 edi
  0003a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0003d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@std@@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@2@U?$pair@HU_MONSTER_ITEM_DROP@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@0@PAU?$pair@$$CBHU_MONSTER_ITEM_DROP@@@0@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,std::pair<int const ,_MONSTER_ITEM_DROP>,std::pair<int,_MONSTER_ITEM_DROP> >
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 599  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@2:
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR $T229497[ebp]
  00052	51		 push	 ecx
  00053	8d 4d f4	 lea	 ecx, DWORD PTR $T229544[ebp]
  00056	89 45 08	 mov	 DWORD PTR $T229497[ebp], eax
  00059	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00063	8d 55 f4	 lea	 edx, DWORD PTR $T229544[ebp]
  00066	52		 push	 edx
  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T229544[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Buynode@2:
$LN43@Buynode@2:
  00073	cc		 int	 3
??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z
_TEXT	SEGMENT
__Cat$229589 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z PROC ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$229589[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z
_TEXT	SEGMENT
__Cat$229599 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z PROC ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$229599[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@@Z ENDP ; std::_Uninitialized_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	?Clear@_CHAOSCASTLE_DATA@@QAEXXZ		; _CHAOSCASTLE_DATA::Clear
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.h
;	COMDAT ?Clear@_CHAOSCASTLE_DATA@@QAEXXZ
_TEXT	SEGMENT
$T229651 = -4						; size = 4
?Clear@_CHAOSCASTLE_DATA@@QAEXXZ PROC			; _CHAOSCASTLE_DATA::Clear, COMDAT
; _this$ = ecx

; 207  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b d1		 mov	 edx, ecx
  00006	53		 push	 ebx

; 208  : 		this->m_iMISSION_SUCCESS = -1;
; 209  : 		this->m_iCC_NOTIFY_COUNT = -1;
; 210  : 		this->m_bCC_MSG_BEFORE_ENTER = false;

  00007	33 db		 xor	 ebx, ebx
  00009	83 c8 ff	 or	 eax, -1
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00011	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00014	89 5a 1f	 mov	 DWORD PTR [edx+31], ebx

; 211  : 		this->m_bCC_MSG_BEFORE_PLAY = false;
; 212  : 		this->m_bCC_MSG_BEFORE_END = false;
; 213  : 		this->m_bCC_MSG_BEFORE_QUIT = false;
; 214  : 		this->m_bCC_CAN_ENTER = false;

  00017	66 89 5a 1c	 mov	 WORD PTR [edx+28], bx

; 215  : 		this->m_bCC_CAN_PARTY = false;
; 216  : 		this->m_bCC_PLAY_START = false;

  0001b	88 5a 1e	 mov	 BYTE PTR [edx+30], bl

; 217  : 		this->m_iCC_ENTERED_USER = 0;

  0001e	89 5a 24	 mov	 DWORD PTR [edx+36], ebx

; 218  : 		this->m_iCC_FIRST_USER_COUNT = 0;

  00021	89 5a 28	 mov	 DWORD PTR [edx+40], ebx

; 219  : 		this->m_iCC_FIRST_MONSTER_COUNT = 0;

  00024	89 5a 2c	 mov	 DWORD PTR [edx+44], ebx

; 220  : 		this->m_lCC_CURRENT_MONSTER_COUNT = 0;

  00027	89 5a 30	 mov	 DWORD PTR [edx+48], ebx

; 221  : 		this->m_iCC_TRAP_STATUS = 0;

  0002a	89 5a 34	 mov	 DWORD PTR [edx+52], ebx

; 222  : 		this->m_iCC_TRAP_OLD_STATUS = 0;

  0002d	89 5a 38	 mov	 DWORD PTR [edx+56], ebx
  00030	8d ba b4 05 00
	00		 lea	 edi, DWORD PTR [edx+1460]

; 223  : 
; 224  : 		for ( int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++)
; 225  : 		{
; 226  : 			this->m_lCC_MONSTER_COUNT[iMON] = -1;

  00036	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0003b	f3 ab		 rep stosd

; 227  : 		}
; 228  : 
; 229  : 		for ( int iFALL = 0; iFALL < MAX_CHAOSCASTLE_USER ; iFALL ++)

  0003d	8d ba 44 07 00
	00		 lea	 edi, DWORD PTR [edx+1860]

; 230  : 		{
; 231  : 			this->m_lFallUser[iFALL] = -1;

  00043	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00048	f3 ab		 rep stosd

; 232  : 		}
; 233  : 
; 234  : 		this->m_mapMonsterItemList.clear();

  0004a	8b 82 60 08 00
	00		 mov	 eax, DWORD PTR [edx+2144]
  00050	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00053	8d ba 5c 08 00
	00		 lea	 edi, DWORD PTR [edx+2140]
  00059	89 75 fc	 mov	 DWORD PTR $T229651[ebp], esi
  0005c	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  0005f	75 21		 jne	 SHORT $LN15@Clear
$LL17@Clear:
  00061	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00064	51		 push	 ecx
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Erase
  0006c	8b 55 fc	 mov	 edx, DWORD PTR $T229651[ebp]
  0006f	8b 36		 mov	 esi, DWORD PTR [esi]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00077	83 c4 04	 add	 esp, 4
  0007a	89 75 fc	 mov	 DWORD PTR $T229651[ebp], esi
  0007d	38 5e 19	 cmp	 BYTE PTR [esi+25], bl
  00080	74 df		 je	 SHORT $LL17@Clear
$LN15@Clear:
  00082	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00085	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00088	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008b	89 00		 mov	 DWORD PTR [eax], eax
  0008d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00090	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00093	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 235  : 	};	// line : 408

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?Clear@_CHAOSCASTLE_DATA@@QAEXXZ ENDP			; _CHAOSCASTLE_DATA::Clear
_TEXT	ENDS
PUBLIC	?Init@CChaosCastle@@QAEX_N@Z			; CChaosCastle::Init
_BSS	SEGMENT
_g_rtPOINT_TRAP DB 040H DUP (?)
_g_rtPOINT_FRAME DB 040H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
_BSS	ENDS
;	COMDAT ?Init@CChaosCastle@@QAEX_N@Z
_TEXT	SEGMENT
tv539 = -8						; size = 4
tv331 = -4						; size = 4
tv328 = 8						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CChaosCastle@@QAEX_N@Z PROC			; CChaosCastle::Init, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   : 	this->m_bCC_EVENT_ENABLE = bEVENT_ENABLE;

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _bEVENT_ENABLE$[ebp]
  00007	83 ec 08	 sub	 esp, 8
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 100  : 
; 101  : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00012	33 f6		 xor	 esi, esi
$LL6@Init:

; 102  : 	{
; 103  : 		this->SetState(i, CC_STATE_CLOSED);

  00014	6a 01		 push	 1
  00016	56		 push	 esi
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
  0001e	46		 inc	 esi
  0001f	83 fe 07	 cmp	 esi, 7
  00022	7c f0		 jl	 SHORT $LL6@Init

; 104  : 	}
; 105  : 
; 106  : 	for ( int iTRAP_STEP = 0; iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00024	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _g_iChaosCastle_GroundAxis+8

; 127  : 
; 128  : 		g_rtPOINT_TRAP[0].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  0002a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _g_iChaosCastle_GroundAxis
  00030	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  00033	99		 cdq
  00034	2b c2		 sub	 eax, edx
  00036	8b f0		 mov	 esi, eax
  00038	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+4
  0003d	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _g_iChaosCastle_GroundAxis+12
  00043	d1 fe		 sar	 esi, 1
  00045	99		 cdq
  00046	2b c2		 sub	 eax, edx
  00048	d1 f8		 sar	 eax, 1
  0004a	89 75 08	 mov	 DWORD PTR tv328[ebp], esi
  0004d	89 45 fc	 mov	 DWORD PTR tv331[ebp], eax
  00050	b9 00 00 00 00	 mov	 ecx, OFFSET _g_iChaosCastle_DamageAxis
  00055	eb 15		 jmp	 SHORT $LN3@Init
  00057	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL13@Init:

; 104  : 	}
; 105  : 
; 106  : 	for ( int iTRAP_STEP = 0; iTRAP_STEP<MAX_CC_TRAP_STEP;iTRAP_STEP++)

  00060	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _g_iChaosCastle_GroundAxis
  00066	8b 75 08	 mov	 esi, DWORD PTR tv328[ebp]
  00069	8b 45 fc	 mov	 eax, DWORD PTR tv331[ebp]
$LN3@Init:

; 107  : 	{
; 108  : 		g_rtPOINT_FRAME[0].left = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0]) / 2 + 1;
; 109  : 		g_rtPOINT_FRAME[0].top = g_iChaosCastle_GroundAxis[1];

  0006c	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR _g_iChaosCastle_GroundAxis+4
  00072	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00075	89 15 00 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME, edx
  0007b	89 1d 04 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+4, ebx

; 110  : 		g_rtPOINT_FRAME[0].right = ::g_iChaosCastle_GroundAxis[2];

  00081	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR _g_iChaosCastle_GroundAxis+8

; 111  : 		g_rtPOINT_FRAME[0].bottom = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 ;
; 112  : 
; 113  : 		g_rtPOINT_FRAME[1].left = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0]) / 2 + 1;

  00087	89 15 10 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+16, edx

; 114  : 		g_rtPOINT_FRAME[1].top = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 + 1;

  0008d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00090	a3 0c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+12, eax

; 115  : 		g_rtPOINT_FRAME[1].right = g_iChaosCastle_GroundAxis[2];
; 116  : 		g_rtPOINT_FRAME[1].bottom = ::g_iChaosCastle_GroundAxis[3];
; 117  : 		
; 118  : 		g_rtPOINT_FRAME[2].left = ::g_iChaosCastle_GroundAxis[0];
; 119  : 		g_rtPOINT_FRAME[2].top = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2 + 1;
; 120  : 		g_rtPOINT_FRAME[2].right = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0] ) / 2 ;
; 121  : 		g_rtPOINT_FRAME[2].bottom = ::g_iChaosCastle_GroundAxis[3];
; 122  : 
; 123  : 		g_rtPOINT_FRAME[3].left = ::g_iChaosCastle_GroundAxis[0];
; 124  : 		g_rtPOINT_FRAME[3].top = ::g_iChaosCastle_GroundAxis[1];
; 125  : 		g_rtPOINT_FRAME[3].right = (::g_iChaosCastle_GroundAxis[2] + ::g_iChaosCastle_GroundAxis[0] ) / 2;
; 126  : 		g_rtPOINT_FRAME[3].bottom = (::g_iChaosCastle_GroundAxis[3] + ::g_iChaosCastle_GroundAxis[1] ) / 2;

  00095	a3 3c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_FRAME+60, eax
  0009a	89 1d 08 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+8, ebx
  000a0	89 15 14 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+20, edx
  000a6	89 1d 18 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+24, ebx
  000ac	8b 1d 0c 00 00
	00		 mov	 ebx, DWORD PTR _g_iChaosCastle_GroundAxis+12
  000b2	89 15 24 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+36, edx
  000b8	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _g_iChaosCastle_GroundAxis+4
  000be	89 3d 20 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+32, edi
  000c4	89 3d 30 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+48, edi

; 127  : 
; 128  : 		g_rtPOINT_TRAP[0].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  000ca	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  000cd	89 1d 1c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+28, ebx
  000d3	89 1d 2c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+44, ebx
  000d9	8b 19		 mov	 ebx, DWORD PTR [ecx]
  000db	89 15 34 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+52, edx
  000e1	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  000e4	99		 cdq
  000e5	2b c2		 sub	 eax, edx
  000e7	89 35 28 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+40, esi
  000ed	89 35 38 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_FRAME+56, esi
  000f3	8b f0		 mov	 esi, eax
  000f5	d1 fe		 sar	 esi, 1
  000f7	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000fa	89 45 f8	 mov	 DWORD PTR tv539[ebp], eax
  000fd	a3 00 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP, eax

; 129  : 		g_rtPOINT_TRAP[0].top = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1];

  00102	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00105	a3 04 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+4, eax

; 130  : 		g_rtPOINT_TRAP[0].right = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][2];
; 131  : 		g_rtPOINT_TRAP[0].bottom = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1]) / 2;

  0010a	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  0010d	89 3d 08 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+8, edi
  00113	99		 cdq
  00114	2b c2		 sub	 eax, edx

; 132  : 
; 133  : 		g_rtPOINT_TRAP[1].left = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0]) / 2 + 1;

  00116	8b 55 f8	 mov	 edx, DWORD PTR tv539[ebp]
  00119	d1 f8		 sar	 eax, 1
  0011b	89 15 10 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+16, edx

; 134  : 		g_rtPOINT_TRAP[1].top = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2 + 1;

  00121	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00124	89 15 14 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+20, edx

; 135  : 		g_rtPOINT_TRAP[1].right = g_iChaosCastle_DamageAxis[iTRAP_STEP][2];

  0012a	89 3d 18 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+24, edi

; 136  : 		g_rtPOINT_TRAP[1].bottom = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3];

  00130	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]

; 137  : 
; 138  : 		g_rtPOINT_TRAP[2].left = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0];
; 139  : 		g_rtPOINT_TRAP[2].top = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2 + 1;

  00133	89 15 24 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+36, edx

; 140  : 		g_rtPOINT_TRAP[2].right = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ) / 2;
; 141  : 		g_rtPOINT_TRAP[2].bottom = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3];
; 142  : 
; 143  : 		g_rtPOINT_TRAP[3].left = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0];
; 144  : 		g_rtPOINT_TRAP[3].top = ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1];

  00139	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013c	83 c1 10	 add	 ecx, 16			; 00000010H
  0013f	a3 0c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+12, eax
  00144	89 3d 1c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+28, edi
  0014a	89 1d 20 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+32, ebx
  00150	89 35 28 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+40, esi
  00156	89 3d 2c 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+44, edi
  0015c	89 1d 30 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+48, ebx
  00162	89 15 34 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+52, edx

; 145  : 		g_rtPOINT_TRAP[3].right = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] ) / 2;

  00168	89 35 38 00 00
	00		 mov	 DWORD PTR _g_rtPOINT_TRAP+56, esi

; 146  : 		g_rtPOINT_TRAP[3].bottom = (::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] + ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] ) / 2;

  0016e	a3 3c 00 00 00	 mov	 DWORD PTR _g_rtPOINT_TRAP+60, eax
  00173	81 f9 40 00 00
	00		 cmp	 ecx, OFFSET _g_iChaosCastle_DamageAxis+64
  00179	0f 8c e1 fe ff
	ff		 jl	 $LL13@Init
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx

; 147  : 	}
; 148  : }

  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 04 00	 ret	 4
?Init@CChaosCastle@@QAEX_N@Z ENDP			; CChaosCastle::Init
_TEXT	ENDS
PUBLIC	??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@ ; `string'
PUBLIC	??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ ; `string'
PUBLIC	??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ ; `string'
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckSync@CChaosCastle@@IAEXH@Z		; CChaosCastle::CheckSync
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@ DB '['
	DB	'Chaos Castle] (%d) Sync Start Time. [%d] min remain (START HO'
	DB	'UR:%d, MIN:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
CONST	SEGMENT
??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ DB '['
	DB	'Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Termi'
	DB	'nated (bTIME_CHANGED=%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
CONST	SEGMENT
??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@ DB '['
	DB	'Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Termi'
	DB	'nated (m_vtChaosCastleOpenTime.empty())', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
CONST	ENDS
;	COMDAT ?CheckSync@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
tv507 = -40						; size = 4
tv495 = -36						; size = 4
_this$GSCopy$ = -32					; size = 4
_bTIME_CHANGED$ = -28					; size = 4
_iChaosCastleIndex$GSCopy$ = -24			; size = 4
_sysTime$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?CheckSync@CChaosCastle@@IAEXH@Z PROC			; CChaosCastle::CheckSync, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00015	8b d9		 mov	 ebx, ecx

; 345  : 
; 346  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  00017	89 5d e0	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 373  : 			return;
; 374  : 
; 375  : 	}
; 376  : 
; 377  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  0001a	89 75 e8	 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], esi
  0001d	85 f6		 test	 esi, esi
  0001f	0f 88 01 02 00
	00		 js	 $LN18@CheckSync

; 306  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00025	33 c0		 xor	 eax, eax
  00027	83 fe 06	 cmp	 esi, 6
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 f1 01 00
	00		 je	 $LN18@CheckSync

; 307  : 	{
; 308  : 		return;
; 309  : 	}
; 310  : 
; 311  : 	if ( this->m_vtChaosCastleOpenTime.empty() != false )

  00035	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00038	3b 43 24	 cmp	 eax, DWORD PTR [ebx+36]
  0003b	75 2e		 jne	 SHORT $LN16@CheckSync

; 312  : 	{
; 313  : 		LogAddC(2, "[Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Terminated (m_vtChaosCastleOpenTime.empty())", iChaosCastleIndex);

  0003d	56		 push	 esi
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@HCMJNMOO@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 		this->SetState(iChaosCastleIndex+1, CC_STATE_NONE);

  0004e	6a 00		 push	 0
  00050	46		 inc	 esi
  00051	56		 push	 esi
  00052	8b cb		 mov	 ecx, ebx
  00054	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 382  : }

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN16@CheckSync:
  0006b	57		 push	 edi

; 315  : 		
; 316  : 		return;
; 317  : 	}
; 318  : 
; 319  : 	SYSTEMTIME sysTime;
; 320  : 	GetLocalTime(&sysTime);

  0006c	8d 4d ec	 lea	 ecx, DWORD PTR _sysTime$[ebp]
  0006f	51		 push	 ecx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 321  : 	int iMIN_HOUR = 24;
; 322  : 	int iMIN_MINUTE = 60;
; 323  : 	BOOL bTIME_CHANGED = FALSE;
; 324  : 	std::vector<CHAOSCASTLE_START_TIME>::iterator it;
; 325  : 	for (it = this->m_vtChaosCastleOpenTime.begin() ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  00076	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  00079	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0007c	be 18 00 00 00	 mov	 esi, 24			; 00000018H
  00081	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  00084	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  0008b	89 55 dc	 mov	 DWORD PTR tv495[ebp], edx
  0008e	3b c2		 cmp	 eax, edx
  00090	74 56		 je	 SHORT $LN102@CheckSync

; 336  : 			}
; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	if ( bTIME_CHANGED == FALSE )

  00092	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+8]
  00096	8b d1		 mov	 edx, ecx
  00098	c1 e2 04	 shl	 edx, 4
  0009b	2b d1		 sub	 edx, ecx
  0009d	0f b7 4d f6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  000a1	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  000a4	89 55 d8	 mov	 DWORD PTR tv507[ebp], edx
$LL40@CheckSync:

; 326  : 	{
; 327  : 		CHAOSCASTLE_START_TIME * stCCTime = &(*it);
; 328  : 
; 329  : 		if ( (sysTime.wHour * 60 + sysTime.wMinute) < (stCCTime->m_iHour * 60 + stCCTime->m_iMinute) )

  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ac	8b d9		 mov	 ebx, ecx
  000ae	c1 e3 04	 shl	 ebx, 4
  000b1	2b d9		 sub	 ebx, ecx
  000b3	8d 14 9a	 lea	 edx, DWORD PTR [edx+ebx*4]
  000b6	39 55 d8	 cmp	 DWORD PTR tv507[ebp], edx
  000b9	7d 1a		 jge	 SHORT $LN14@CheckSync

; 330  : 		{
; 331  : 			if ( ( iMIN_HOUR * 60 + iMIN_MINUTE ) > ( stCCTime->m_iHour * 60 + stCCTime->m_iMinute ) )

  000bb	8b de		 mov	 ebx, esi
  000bd	c1 e3 04	 shl	 ebx, 4
  000c0	2b de		 sub	 ebx, esi
  000c2	8d 1c 9f	 lea	 ebx, DWORD PTR [edi+ebx*4]
  000c5	3b da		 cmp	 ebx, edx
  000c7	7e 0c		 jle	 SHORT $LN14@CheckSync

; 332  : 			{
; 333  : 				bTIME_CHANGED = TRUE;
; 334  : 				iMIN_HOUR = stCCTime->m_iHour;
; 335  : 				iMIN_MINUTE = stCCTime->m_iMinute;

  000c9	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000cc	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1
  000d3	8b f1		 mov	 esi, ecx
$LN14@CheckSync:

; 321  : 	int iMIN_HOUR = 24;
; 322  : 	int iMIN_MINUTE = 60;
; 323  : 	BOOL bTIME_CHANGED = FALSE;
; 324  : 	std::vector<CHAOSCASTLE_START_TIME>::iterator it;
; 325  : 	for (it = this->m_vtChaosCastleOpenTime.begin() ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  000d5	8b 55 dc	 mov	 edx, DWORD PTR tv495[ebp]
  000d8	83 c0 08	 add	 eax, 8
  000db	3b c2		 cmp	 eax, edx
  000dd	75 c8		 jne	 SHORT $LL40@CheckSync

; 336  : 			}
; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	if ( bTIME_CHANGED == FALSE )

  000df	83 7d e4 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  000e3	8b 5d e0	 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  000e6	75 43		 jne	 SHORT $LN106@CheckSync
$LN102@CheckSync:

; 341  : 	{
; 342  : 		it = this->m_vtChaosCastleOpenTime.begin();

  000e8	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]

; 343  : 		iMIN_HOUR = 24;

  000eb	be 18 00 00 00	 mov	 esi, 24			; 00000018H

; 344  : 		iMIN_MINUTE = 60;

  000f0	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]

; 345  : 
; 346  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  000f3	3b ca		 cmp	 ecx, edx
  000f5	74 34		 je	 SHORT $LN106@CheckSync
$LL75@CheckSync:

; 347  : 		{
; 348  : 			CHAOSCASTLE_START_TIME * stCCTime = &(*it);
; 349  : 
; 350  : 			if ( ( iMIN_HOUR * 60 + iMIN_MINUTE ) > ( stCCTime->m_iHour * 60 + stCCTime->m_iMinute ) )

  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fc	8b d8		 mov	 ebx, eax
  000fe	c1 e3 04	 shl	 ebx, 4
  00101	2b d8		 sub	 ebx, eax
  00103	8d 14 9a	 lea	 edx, DWORD PTR [edx+ebx*4]
  00106	8b de		 mov	 ebx, esi
  00108	c1 e3 04	 shl	 ebx, 4
  0010b	2b de		 sub	 ebx, esi
  0010d	8d 1c 9f	 lea	 ebx, DWORD PTR [edi+ebx*4]
  00110	3b da		 cmp	 ebx, edx
  00112	7e 0c		 jle	 SHORT $LN8@CheckSync

; 351  : 			{
; 352  : 				bTIME_CHANGED = 2;
; 353  : 				iMIN_HOUR = stCCTime->m_iHour;
; 354  : 				iMIN_MINUTE = stCCTime->m_iMinute;

  00114	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00117	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2
  0011e	8b f0		 mov	 esi, eax
$LN8@CheckSync:

; 345  : 
; 346  : 		for ( ; it != this->m_vtChaosCastleOpenTime.end() ; it++ )

  00120	83 c1 08	 add	 ecx, 8
  00123	3b 4d dc	 cmp	 ecx, DWORD PTR tv495[ebp]
  00126	75 cf		 jne	 SHORT $LL75@CheckSync
  00128	8b 5d e0	 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN106@CheckSync:

; 355  : 			}
; 356  : 		}
; 357  : 	}
; 358  : 
; 359  : 	switch ( bTIME_CHANGED )

  0012b	8b 4d e4	 mov	 ecx, DWORD PTR _bTIME_CHANGED$[ebp]
  0012e	8b c1		 mov	 eax, ecx
  00130	48		 dec	 eax
  00131	74 7e		 je	 SHORT $LN3@CheckSync
  00133	48		 dec	 eax
  00134	74 35		 je	 SHORT $LN2@CheckSync

; 368  : 
; 369  : 		default:
; 370  : 			LogAddC(2, "[Chaos Castle] (%d) No Schedule Time Data - Chaos Castle Terminated (bTIME_CHANGED=%d)",
; 371  : 				iChaosCastleIndex + 1, bTIME_CHANGED);

  00136	8b 75 e8	 mov	 esi, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00139	51		 push	 ecx
  0013a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0013d	50		 push	 eax
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CMJAMBAM@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5No?5Schedule?5@
  00143	6a 02		 push	 2
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0014b	83 c4 10	 add	 esp, 16			; 00000010H

; 372  : 			this->SetState(iChaosCastleIndex, CC_STATE_NONE);

  0014e	6a 00		 push	 0
  00150	56		 push	 esi
  00151	8b cb		 mov	 ecx, ebx
  00153	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx

; 382  : }

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	33 cd		 xor	 ecx, ebp
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 04 00	 ret	 4
$LN2@CheckSync:

; 363  : 			break;
; 364  : 
; 365  : 		case 2:
; 366  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = ((((iMIN_HOUR+24) * 60 * 60) + (iMIN_MINUTE * 60)) - ((sysTime.wHour * 60 * 60) + (sysTime.wMinute * 60) + (sysTime.wSecond))) * 1000;

  0016b	8b 4d e8	 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0016e	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$[ebp+8]
  00172	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  00178	03 d9		 add	 ebx, ecx
  0017a	8b c6		 mov	 eax, esi
  0017c	2b c2		 sub	 eax, edx
  0017e	0f b7 55 f6	 movzx	 edx, WORD PTR _sysTime$[ebp+10]
  00182	83 c0 18	 add	 eax, 24			; 00000018H
  00185	8b c8		 mov	 ecx, eax
  00187	c1 e1 04	 shl	 ecx, 4
  0018a	2b c8		 sub	 ecx, eax
  0018c	03 c9		 add	 ecx, ecx
  0018e	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00191	2b c2		 sub	 eax, edx
  00193	0f b7 55 f8	 movzx	 edx, WORD PTR _sysTime$[ebp+12]
  00197	03 c7		 add	 eax, edi
  00199	8b c8		 mov	 ecx, eax
  0019b	c1 e1 04	 shl	 ecx, 4
  0019e	2b c8		 sub	 ecx, eax
  001a0	03 c9		 add	 ecx, ecx
  001a2	03 c9		 add	 ecx, ecx
  001a4	2b ca		 sub	 ecx, edx
  001a6	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  001ac	89 4b 40	 mov	 DWORD PTR [ebx+64], ecx

; 367  : 			break;

  001af	eb 41		 jmp	 SHORT $LN4@CheckSync
$LN3@CheckSync:

; 360  : 	{
; 361  : 		case TRUE:
; 362  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = (((iMIN_HOUR * 60 * 60) + (iMIN_MINUTE * 60)) - ((sysTime.wHour * 60 * 60) + (sysTime.wMinute * 60) + (sysTime.wSecond))) * 1000;

  001b1	8b 45 e8	 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001b4	0f b7 4d f4	 movzx	 ecx, WORD PTR _sysTime$[ebp+8]
  001b8	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  001be	03 d8		 add	 ebx, eax
  001c0	8b c6		 mov	 eax, esi
  001c2	2b c1		 sub	 eax, ecx
  001c4	0f b7 4d f6	 movzx	 ecx, WORD PTR _sysTime$[ebp+10]
  001c8	8b d0		 mov	 edx, eax
  001ca	c1 e2 04	 shl	 edx, 4
  001cd	2b d0		 sub	 edx, eax
  001cf	03 d2		 add	 edx, edx
  001d1	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  001d4	2b c1		 sub	 eax, ecx
  001d6	03 c7		 add	 eax, edi
  001d8	8b d0		 mov	 edx, eax
  001da	c1 e2 04	 shl	 edx, 4
  001dd	2b d0		 sub	 edx, eax
  001df	0f b7 45 f8	 movzx	 eax, WORD PTR _sysTime$[ebp+12]
  001e3	03 d2		 add	 edx, edx
  001e5	03 d2		 add	 edx, edx
  001e7	2b d0		 sub	 edx, eax
  001e9	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  001ef	89 53 40	 mov	 DWORD PTR [ebx+64], edx
$LN4@CheckSync:

; 373  : 			return;
; 374  : 
; 375  : 	}
; 376  : 
; 377  : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001f8	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 378  : 
; 379  : 	LogAddTD("[Chaos Castle] (%d) Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)",
; 380  : 		iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000,
; 381  : 		iMIN_HOUR, iMIN_MINUTE);

  001fb	8b 5b 40	 mov	 ebx, DWORD PTR [ebx+64]
  001fe	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00203	f7 eb		 imul	 ebx
  00205	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00208	8b ca		 mov	 ecx, edx
  0020a	57		 push	 edi
  0020b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0020e	03 ca		 add	 ecx, edx
  00210	8b 55 e8	 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00213	56		 push	 esi
  00214	51		 push	 ecx
  00215	42		 inc	 edx
  00216	52		 push	 edx
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@IGEPIJHA@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Start?5T@
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00222	83 c4 14	 add	 esp, 20			; 00000014H
  00225	5f		 pop	 edi
$LN18@CheckSync:

; 382  : }

  00226	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00229	5e		 pop	 esi
  0022a	33 cd		 xor	 ecx, ebp
  0022c	5b		 pop	 ebx
  0022d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00232	8b e5		 mov	 esp, ebp
  00234	5d		 pop	 ebp
  00235	c2 04 00	 ret	 4
?CheckSync@CChaosCastle@@IAEXH@Z ENDP			; CChaosCastle::CheckSync
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Closed@CChaosCastle@@IAEXH@Z		; CChaosCastle::ProcState_Closed
EXTRN	?g_bChaosCastle@@3HA:DWORD			; g_bChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_Closed@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -288					; size = 4
_pMsg$218604 = -284					; size = 4
_iChaosCastleIndex$GSCopy$ = -280			; size = 4
_pNotice$218600 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_Closed@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_Closed, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]

; 429  : 
; 430  : 					for (int i= OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00016	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], eax
  0001c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0002a	8b d9		 mov	 ebx, ecx
  0002c	57		 push	 edi
  0002d	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  00033	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00036	ff d6		 call	 esi
  00038	2b 47 44	 sub	 eax, DWORD PTR [edi+68]
  0003b	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00040	0f 8c 6c 01 00
	00		 jl	 $LN35@ProcState_

; 391  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;
; 392  : 
; 393  : 	if ( iTICK_MSEC >= 1000 )
; 394  : 	{
; 395  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;
; 396  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  00046	29 47 40	 sub	 DWORD PTR [edi+64], eax
  00049	ff d6		 call	 esi
  0004b	89 47 44	 mov	 DWORD PTR [edi+68], eax

; 397  : 
; 398  : 		if ( g_bChaosCastle != FALSE )

  0004e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle
  00055	0f 84 57 01 00
	00		 je	 $LN35@ProcState_

; 399  : 		{
; 400  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ( this->m_iCC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER == false)

  0005b	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0005e	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00061	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00067	3b c8		 cmp	 ecx, eax
  00069	7f 0c		 jg	 SHORT $LN14@ProcState_
  0006b	80 7f 4c 00	 cmp	 BYTE PTR [edi+76], 0
  0006f	75 06		 jne	 SHORT $LN14@ProcState_

; 401  : 			{
; 402  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = true;

  00071	66 c7 47 4c 01
	01		 mov	 WORD PTR [edi+76], 257	; 00000101H
$LN14@ProcState_:

; 403  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_PARTY = true;
; 404  : 			}
; 405  : 
; 406  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ( this->m_iCC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && (this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC/60000) !=this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT)

  00077	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0007a	69 d2 60 ea 00
	00		 imul	 edx, 60000		; 0000ea60H
  00080	3b ca		 cmp	 ecx, edx
  00082	7f 62		 jg	 SHORT $LN31@ProcState_
  00084	85 c9		 test	 ecx, ecx
  00086	7e 5e		 jle	 SHORT $LN31@ProcState_
  00088	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0008d	f7 e9		 imul	 ecx
  0008f	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00092	8b c2		 mov	 eax, edx
  00094	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00097	03 c2		 add	 eax, edx
  00099	3b 47 48	 cmp	 eax, DWORD PTR [edi+72]
  0009c	74 48		 je	 SHORT $LN31@ProcState_

; 407  : 			{
; 408  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC / 60000;
; 409  : 
; 410  : 				if ( iChaosCastleIndex == 0 )

  0009e	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], 0
  000a5	89 47 48	 mov	 DWORD PTR [edi+72], eax
  000a8	75 3c		 jne	 SHORT $LN31@ProcState_

; 411  : 				{
; 412  : 					PMSG_NOTICE pNotice;
; 413  : 
; 414  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 208)), this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_NOTIFY_COUNT+1);

  000aa	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  000ad	40		 inc	 eax
  000ae	50		 push	 eax
  000af	68 d0 04 00 00	 push	 1232			; 000004d0H
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000be	50		 push	 eax
  000bf	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$218600[ebp]
  000c5	6a 00		 push	 0
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 415  : 					this->SendAllUserAnyMsg( (LPBYTE)&pNotice, pNotice.h.size);

  000cd	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$218600[ebp+1]
  000d4	83 c4 10	 add	 esp, 16			; 00000010H
  000d7	52		 push	 edx
  000d8	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$218600[ebp]
  000de	50		 push	 eax
  000df	8b cb		 mov	 ecx, ebx
  000e1	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CChaosCastle@@QAEXPAEH@Z ; CChaosCastle::SendAllUserAnyMsg
$LN31@ProcState_:

; 416  : 				}
; 417  : 			}
; 418  : 
; 419  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_ENTER == false )

  000e6	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  000e9	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  000ee	0f 8f be 00 00
	00		 jg	 $LN35@ProcState_
  000f4	85 c0		 test	 eax, eax
  000f6	0f 8e b6 00 00
	00		 jle	 $LN35@ProcState_
  000fc	80 7f 4f 00	 cmp	 BYTE PTR [edi+79], 0
  00100	0f 85 ac 00 00
	00		 jne	 $LN35@ProcState_

; 420  : 			{
; 421  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_ENTER = true;
; 422  : 
; 423  : 				if ( iChaosCastleIndex == 0 )

  00106	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], 0
  0010d	c6 47 4f 01	 mov	 BYTE PTR [edi+79], 1
  00111	0f 85 9b 00 00
	00		 jne	 $LN35@ProcState_

; 424  : 				{
; 425  : 					PMSG_SET_DEVILSQUARE pMsg;
; 426  : 
; 427  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00117	6a 04		 push	 4
  00119	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$218604[ebp]
  0011f	68 92 00 00 00	 push	 146			; 00000092H
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0012a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 					pMsg.Type = 10;

  00133	c6 85 e7 fe ff
	ff 0a		 mov	 BYTE PTR _pMsg$218604[ebp+3], 10 ; 0000000aH

; 429  : 
; 430  : 					for (int i= OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0013a	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  0013f	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL9@ProcState_:

; 431  : 					{
; 432  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00144	83 7c 16 04 03	 cmp	 DWORD PTR [esi+edx+4], 3
  00149	75 52		 jne	 SHORT $LN8@ProcState_
  0014b	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  00151	75 4a		 jne	 SHORT $LN8@ProcState_

; 433  : 						{
; 434  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00153	8a 84 16 49 01
	00 00		 mov	 al, BYTE PTR [esi+edx+329]
  0015a	3c 35		 cmp	 al, 53			; 00000035H
  0015c	74 3f		 je	 SHORT $LN8@ProcState_
  0015e	3c 12		 cmp	 al, 18			; 00000012H
  00160	72 0c		 jb	 SHORT $LN29@ProcState_
  00162	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00167	3a c8		 cmp	 cl, al
  00169	1b c9		 sbb	 ecx, ecx
  0016b	41		 inc	 ecx
  0016c	75 2f		 jne	 SHORT $LN8@ProcState_
$LN29@ProcState_:

; 435  : 							{
; 436  : 								if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  0016e	3c 34		 cmp	 al, 52			; 00000034H
  00170	74 2b		 je	 SHORT $LN8@ProcState_
  00172	3c 0b		 cmp	 al, 11			; 0000000bH
  00174	72 09		 jb	 SHORT $LN30@ProcState_
  00176	b1 11		 mov	 cl, 17			; 00000011H
  00178	3a c8		 cmp	 cl, al
  0017a	1b c0		 sbb	 eax, eax
  0017c	40		 inc	 eax
  0017d	75 1e		 jne	 SHORT $LN8@ProcState_
$LN30@ProcState_:

; 437  : 								{
; 438  : 									DataSend(i, (LPBYTE)&pMsg, pMsg.h.size);

  0017f	0f b6 95 e5 fe
	ff ff		 movzx	 edx, BYTE PTR _pMsg$218604[ebp+1]
  00186	52		 push	 edx
  00187	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$218604[ebp]
  0018d	50		 push	 eax
  0018e	53		 push	 ebx
  0018f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00194	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@ProcState_:

; 429  : 
; 430  : 					for (int i= OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0019d	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  001a3	43		 inc	 ebx
  001a4	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  001aa	7c 98		 jl	 SHORT $LL9@ProcState_
  001ac	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
$LN35@ProcState_:

; 439  : 								}
; 440  : 							}
; 441  : 						}
; 442  : 					}
; 443  : 				}
; 444  : 			}
; 445  : 		}
; 446  : 	}
; 447  : 
; 448  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  001b2	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  001b6	7f 24		 jg	 SHORT $LN1@ProcState_

; 449  : 	{
; 450  : 		if ( g_bChaosCastle != FALSE )

  001b8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bChaosCastle@@3HA, 0 ; g_bChaosCastle
  001bf	74 0b		 je	 SHORT $LN2@ProcState_

; 451  : 		{
; 452  : 			this->SetState(iChaosCastleIndex, CC_STATE_PLAYING);

  001c1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001c7	6a 02		 push	 2
  001c9	51		 push	 ecx

; 453  : 		}
; 454  : 		else

  001ca	eb 09		 jmp	 SHORT $LN37@ProcState_
$LN2@ProcState_:

; 455  : 		{
; 456  : 			this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  001cc	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  001d2	6a 01		 push	 1
  001d4	52		 push	 edx
$LN37@ProcState_:
  001d5	8b cb		 mov	 ecx, ebx
  001d7	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN1@ProcState_:

; 457  : 		}
; 458  : 	}
; 459  : }

  001dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	33 cd		 xor	 ecx, ebp
  001e3	5b		 pop	 ebx
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 04 00	 ret	 4
?ProcState_Closed@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_Closed
_TEXT	ENDS
PUBLIC	?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z	; CChaosCastle::ProcState_PlayEnd
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$219172 = 8					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_PlayEnd, COMDAT
; _this$ = ecx

; 898  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 899  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	03 f7		 add	 esi, edi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001b	2b 46 44	 sub	 eax, DWORD PTR [esi+68]

; 900  : 
; 901  : 	if ( iTICK_MSEC >= 1000 )

  0001e	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00023	7c 51		 jl	 SHORT $LN6@ProcState_@2

; 902  : 	{
; 903  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  00025	29 46 40	 sub	 DWORD PTR [esi+64], eax

; 904  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 905  : 		this->CheckUserInDieTile(iChaosCastleIndex);

  0002e	53		 push	 ebx
  0002f	8b cf		 mov	 ecx, edi
  00031	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00034	e8 00 00 00 00	 call	 ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckUserInDieTile

; 906  : 
; 907  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 && this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0 && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_QUIT == false)

  00039	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0003c	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00041	7f 33		 jg	 SHORT $LN6@ProcState_@2
  00043	85 c0		 test	 eax, eax
  00045	7e 2f		 jle	 SHORT $LN6@ProcState_@2
  00047	80 7e 52 00	 cmp	 BYTE PTR [esi+82], 0
  0004b	75 29		 jne	 SHORT $LN6@ProcState_@2

; 908  : 		{
; 909  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_QUIT = true;
; 910  : 
; 911  : 			PMSG_SET_DEVILSQUARE pMsg;
; 912  : 
; 913  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0004d	6a 04		 push	 4
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR _pMsg$219172[ebp]
  00052	68 92 00 00 00	 push	 146			; 00000092H
  00057	51		 push	 ecx
  00058	c6 46 52 01	 mov	 BYTE PTR [esi+82], 1
  0005c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 914  : 			pMsg.Type = 13;
; 915  : 
; 916  : 			this->SendChaosCastleAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  00064	53		 push	 ebx
  00065	6a 04		 push	 4
  00067	8d 55 08	 lea	 edx, DWORD PTR _pMsg$219172[ebp]
  0006a	52		 push	 edx
  0006b	8b cf		 mov	 ecx, edi
  0006d	c6 45 0b 0d	 mov	 BYTE PTR _pMsg$219172[ebp+3], 13 ; 0000000dH
  00071	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN6@ProcState_@2:

; 917  : 		}
; 918  : 	}
; 919  : 
; 920  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  00076	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0
  0007a	7f 0a		 jg	 SHORT $LN1@ProcState_@2

; 921  : 	{
; 922  : 		this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  0007c	6a 01		 push	 1
  0007e	53		 push	 ebx
  0007f	8b cf		 mov	 ecx, edi
  00081	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN1@ProcState_@2:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 923  : 	}
; 924  : }

  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_PlayEnd
_TEXT	ENDS
PUBLIC	?ClearChaosCastleData@CChaosCastle@@IAEXH@Z	; CChaosCastle::ClearChaosCastleData
; Function compile flags: /Ogtp
;	COMDAT ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?ClearChaosCastleData@CChaosCastle@@IAEXH@Z PROC	; CChaosCastle::ClearChaosCastleData, COMDAT
; _this$ = ecx

; 1039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1040 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b c3		 cmp	 eax, ebx
  0000e	0f 8c c0 02 00
	00		 jl	 $LN14@ClearChaos
  00014	33 c9		 xor	 ecx, ecx
  00016	83 f8 06	 cmp	 eax, 6
  00019	0f 9e c1	 setle	 cl
  0001c	3b cb		 cmp	 ecx, ebx
  0001e	0f 84 b0 02 00
	00		 je	 $LN14@ClearChaos

; 1041 : 	{
; 1042 : 		return;
; 1043 : 	}
; 1044 : 
; 1045 : 	this->m_stChaosCastleData[iChaosCastleIndex].Clear();

  00024	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  0002a	03 f0		 add	 esi, eax
  0002c	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  0002f	e8 00 00 00 00	 call	 ?Clear@_CHAOSCASTLE_DATA@@QAEXXZ ; _CHAOSCASTLE_DATA::Clear
  00034	8d 46 74	 lea	 eax, DWORD PTR [esi+116]
  00037	8d 53 0e	 lea	 edx, DWORD PTR [ebx+14]
  0003a	83 c9 ff	 or	 ecx, -1
  0003d	57		 push	 edi
  0003e	8b ff		 npad	 2
$LL4@ClearChaos:

; 1046 : 
; 1047 : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++ )
; 1048 : 	{
; 1049 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00040	39 48 f8	 cmp	 DWORD PTR [eax-8], ecx
  00043	74 6e		 je	 SHORT $LN1@ClearChaos

; 1050 : 		{
; 1051 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  00045	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00048	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00054	88 8c 3e a5 0e
	00 00		 mov	 BYTE PTR [esi+edi+3749], cl

; 1052 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  0005b	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  0005e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0006a	88 8c 3e a6 0e
	00 00		 mov	 BYTE PTR [esi+edi+3750], cl

; 1053 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  00071	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  00074	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00080	89 9c 3e a8 0e
	00 00		 mov	 DWORD PTR [esi+edi+3752], ebx

; 1054 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  00087	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  0008a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00096	88 9c 3e ac 0e
	00 00		 mov	 BYTE PTR [esi+edi+3756], bl

; 1055 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  0009d	8b 70 f8	 mov	 esi, DWORD PTR [eax-8]
  000a0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a6	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000ac	88 9c 3e ad 0e
	00 00		 mov	 BYTE PTR [esi+edi+3757], bl
$LN1@ClearChaos:

; 1056 : 		}
; 1057 : 
; 1058 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  000b3	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  000b6	89 58 fc	 mov	 DWORD PTR [eax-4], ebx
  000b9	89 18		 mov	 DWORD PTR [eax], ebx
  000bb	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  000be	88 58 08	 mov	 BYTE PTR [eax+8], bl
  000c1	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  000c4	74 6e		 je	 SHORT $LN15@ClearChaos

; 1050 : 		{
; 1051 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  000c6	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000c9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000d5	88 8c 3e a5 0e
	00 00		 mov	 BYTE PTR [esi+edi+3749], cl

; 1052 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  000dc	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000df	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e5	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000eb	88 8c 3e a6 0e
	00 00		 mov	 BYTE PTR [esi+edi+3750], cl

; 1053 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  000f2	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  000f5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fb	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00101	89 9c 3e a8 0e
	00 00		 mov	 DWORD PTR [esi+edi+3752], ebx

; 1054 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  00108	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0010b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00117	88 9c 3e ac 0e
	00 00		 mov	 BYTE PTR [esi+edi+3756], bl

; 1055 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  0011e	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00121	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00127	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0012d	88 9c 3e ad 0e
	00 00		 mov	 BYTE PTR [esi+edi+3757], bl
$LN15@ClearChaos:

; 1056 : 		}
; 1057 : 
; 1058 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  00134	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00137	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  0013a	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  0013d	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  00140	88 58 1c	 mov	 BYTE PTR [eax+28], bl
  00143	39 48 20	 cmp	 DWORD PTR [eax+32], ecx
  00146	74 6e		 je	 SHORT $LN16@ClearChaos

; 1050 : 		{
; 1051 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  00148	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  0014b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00151	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00157	88 8c 3e a5 0e
	00 00		 mov	 BYTE PTR [esi+edi+3749], cl

; 1052 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  0015e	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00161	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00167	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0016d	88 8c 3e a6 0e
	00 00		 mov	 BYTE PTR [esi+edi+3750], cl

; 1053 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  00174	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00177	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00183	89 9c 3e a8 0e
	00 00		 mov	 DWORD PTR [esi+edi+3752], ebx

; 1054 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  0018a	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  0018d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00193	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00199	88 9c 3e ac 0e
	00 00		 mov	 BYTE PTR [esi+edi+3756], bl

; 1055 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  001a0	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  001a3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a9	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001af	88 9c 3e ad 0e
	00 00		 mov	 BYTE PTR [esi+edi+3757], bl
$LN16@ClearChaos:

; 1056 : 		}
; 1057 : 
; 1058 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  001b6	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  001b9	89 58 24	 mov	 DWORD PTR [eax+36], ebx
  001bc	89 58 28	 mov	 DWORD PTR [eax+40], ebx
  001bf	89 58 2c	 mov	 DWORD PTR [eax+44], ebx
  001c2	88 58 30	 mov	 BYTE PTR [eax+48], bl
  001c5	39 48 34	 cmp	 DWORD PTR [eax+52], ecx
  001c8	74 6e		 je	 SHORT $LN17@ClearChaos

; 1050 : 		{
; 1051 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  001ca	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  001cd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d3	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001d9	88 8c 3e a5 0e
	00 00		 mov	 BYTE PTR [esi+edi+3749], cl

; 1052 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  001e0	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  001e3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e9	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001ef	88 8c 3e a6 0e
	00 00		 mov	 BYTE PTR [esi+edi+3750], cl

; 1053 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  001f6	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  001f9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ff	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00205	89 9c 3e a8 0e
	00 00		 mov	 DWORD PTR [esi+edi+3752], ebx

; 1054 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  0020c	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  0020f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00215	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0021b	88 9c 3e ac 0e
	00 00		 mov	 BYTE PTR [esi+edi+3756], bl

; 1055 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  00222	8b 70 34	 mov	 esi, DWORD PTR [eax+52]
  00225	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00231	88 9c 3e ad 0e
	00 00		 mov	 BYTE PTR [esi+edi+3757], bl
$LN17@ClearChaos:

; 1056 : 		}
; 1057 : 
; 1058 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  00238	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  0023b	89 58 38	 mov	 DWORD PTR [eax+56], ebx
  0023e	89 58 3c	 mov	 DWORD PTR [eax+60], ebx
  00241	89 58 40	 mov	 DWORD PTR [eax+64], ebx
  00244	88 58 44	 mov	 BYTE PTR [eax+68], bl
  00247	39 48 48	 cmp	 DWORD PTR [eax+72], ecx
  0024a	74 6e		 je	 SHORT $LN18@ClearChaos

; 1050 : 		{
; 1051 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex = -1;

  0024c	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  0024f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00255	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0025b	88 8c 3e a5 0e
	00 00		 mov	 BYTE PTR [esi+edi+3749], cl

; 1052 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex = -1;

  00262	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  00265	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00271	88 8c 3e a6 0e
	00 00		 mov	 BYTE PTR [esi+edi+3750], cl

; 1053 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = 0;

  00278	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  0027b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00281	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00287	89 9c 3e a8 0e
	00 00		 mov	 DWORD PTR [esi+edi+3752], ebx

; 1054 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillUserCount = 0;

  0028e	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  00291	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00297	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0029d	88 9c 3e ac 0e
	00 00		 mov	 BYTE PTR [esi+edi+3756], bl

; 1055 : 			gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cKillMonsterCount = 0;

  002a4	8b 70 48	 mov	 esi, DWORD PTR [eax+72]
  002a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ad	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  002b3	88 9c 3e ad 0e
	00 00		 mov	 BYTE PTR [esi+edi+3757], bl
$LN18@ClearChaos:

; 1056 : 		}
; 1057 : 
; 1058 : 		this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].Clear();

  002ba	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  002bd	89 58 4c	 mov	 DWORD PTR [eax+76], ebx
  002c0	89 58 50	 mov	 DWORD PTR [eax+80], ebx
  002c3	89 58 54	 mov	 DWORD PTR [eax+84], ebx
  002c6	88 58 58	 mov	 BYTE PTR [eax+88], bl
  002c9	83 c0 64	 add	 eax, 100		; 00000064H
  002cc	4a		 dec	 edx
  002cd	0f 85 6d fd ff
	ff		 jne	 $LL4@ClearChaos
  002d3	5f		 pop	 edi
$LN14@ClearChaos:
  002d4	5e		 pop	 esi
  002d5	5b		 pop	 ebx

; 1059 : 	}
; 1060 : }

  002d6	5d		 pop	 ebp
  002d7	c2 04 00	 ret	 4
?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ENDP	; CChaosCastle::ClearChaosCastleData
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
$T230001 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	7d 05		 jge	 SHORT $LN8@find
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:
  00025	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  00029	74 ec		 je	 SHORT $LL10@find
  0002b	5e		 pop	 esi
$LN9@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	7c 11		 jl	 SHORT $LN3@find
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T230001[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T230001[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HAAH@std@@YAXAAV?$allocator@H@0@PAHAAH@Z ; std::_Cons_val<std::allocator<int>,int,int &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T230248 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T230248[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXPAUCHAOSCASTLE_START_TIME@@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXXZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Tidy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
  00012	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
  0001e	8b c7		 mov	 eax, edi
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 757  : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??$insert@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::insert<std::pair<int,_MONSTER_ITEM_DROP> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$230379 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$230379[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCHAOSCASTLE_START_TIME@@@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEPAUCHAOSCASTLE_START_TIME@@PAU2@00@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Umove<CHAOSCASTLE_START_TIME *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$230399 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$230399[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUtagPOINT@@@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEPAUtagPOINT@@PAU2@00@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Umove<tagPOINT *>
_TEXT	ENDS
PUBLIC	??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
;	COMDAT ??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
CONST	SEGMENT
??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Chaos Castle] (%d) SetState CLOSED', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Closed@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
tv164 = 8						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetState_Closed@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_Closed, COMDAT
; _this$ = ecx

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 971  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	85 ff		 test	 edi, edi
  00010	0f 88 a9 00 00
	00		 js	 $LN7@SetState_C
  00016	33 c0		 xor	 eax, eax
  00018	83 ff 06	 cmp	 edi, 6
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 99 00 00
	00		 je	 $LN7@SetState_C

; 972  : 	{
; 973  : 		return;
; 974  : 	}
; 975  : 
; 976  : 	this->SendNoticeState(iChaosCastleIndex, 7);

  00026	53		 push	 ebx
  00027	6a 07		 push	 7
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 977  : 	this->ClearChaosCastleData(iChaosCastleIndex);

  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ; CChaosCastle::ClearChaosCastleData

; 978  : 	this->ClearMonster(iChaosCastleIndex);

  00037	57		 push	 edi
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?ClearMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::ClearMonster

; 981  : 	{
; 982  : 		if ( gObj[n].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  00047	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  0004c	89 45 08	 mov	 DWORD PTR tv164[ebp], eax
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00054	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL13@SetState_C:
  00060	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00068	3b 4d 08	 cmp	 ecx, DWORD PTR tv164[ebp]
  0006b	75 17		 jne	 SHORT $LN4@SetState_C

; 983  : 		{
; 984  : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  0006d	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  00072	7e 10		 jle	 SHORT $LN4@SetState_C

; 985  : 			{
; 986  : 				gObjMoveGate(n, 22);

  00074	6a 16		 push	 22			; 00000016H
  00076	53		 push	 ebx
  00077	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00081	83 c4 08	 add	 esp, 8
$LN4@SetState_C:

; 979  : 
; 980  : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00084	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0008a	43		 inc	 ebx
  0008b	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00091	7c cd		 jl	 SHORT $LL13@SetState_C

; 987  : 			}
; 988  : 		}
; 989  : 	}
; 990  : 
; 991  : 	this->SafetyCastleZone(iChaosCastleIndex);

  00093	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00096	57		 push	 edi
  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 ?SafetyCastleZone@CChaosCastle@@QAEXH@Z ; CChaosCastle::SafetyCastleZone

; 992  : 	this->SetMapAttrFill(iChaosCastleIndex);

  0009e	57		 push	 edi
  0009f	8b ce		 mov	 ecx, esi
  000a1	e8 00 00 00 00	 call	 ?SetMapAttrFill@CChaosCastle@@QAEXH@Z ; CChaosCastle::SetMapAttrFill

; 993  : 	this->CheckSync(iChaosCastleIndex);

  000a6	57		 push	 edi
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?CheckSync@CChaosCastle@@IAEXH@Z ; CChaosCastle::CheckSync

; 994  : 
; 995  : 	LogAddTD("[Chaos Castle] (%d) SetState CLOSED", iChaosCastleIndex+1);

  000ae	47		 inc	 edi
  000af	57		 push	 edi
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MMNDEFNC@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bb	83 c4 08	 add	 esp, 8
  000be	5b		 pop	 ebx
$LN7@SetState_C:
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi

; 996  : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?SetState_Closed@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_Closed
_TEXT	ENDS
PUBLIC	??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@ ; `string'
;	COMDAT ??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Chaos Castle] (%d) SetState PLAYING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@
CONST	SEGMENT
??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@ DB '['
	DB	'Chaos Castle] (%d) Failed to Start Chaos Castle : Lack of Use'
	DB	'r', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_Playing@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iChaosCastleIndex$ = 8					; size = 4
?SetState_Playing@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::SetState_Playing, COMDAT
; _this$ = ecx

; 999  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1000 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 74		 js	 SHORT $LN1@SetState_P@2
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 06	 cmp	 esi, 6
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 68		 je	 SHORT $LN1@SetState_P@2

; 1001 : 	{
; 1002 : 		return;
; 1003 : 	}
; 1004 : 
; 1005 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER = false;

  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 70 08 00
	00		 imul	 eax, 2160		; 00000870H
  00022	c6 44 38 4c 00	 mov	 BYTE PTR [eax+edi+76], 0

; 1006 : 	this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = this->m_iCC_TIME_MIN_PLAY * 60 * 1000;

  00027	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0002a	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H

; 1007 : 	this->SendCastleZoneSafetyInfo(iChaosCastleIndex, true);

  00030	6a 01		 push	 1
  00032	89 4c 38 40	 mov	 DWORD PTR [eax+edi+64], ecx
  00036	56		 push	 esi
  00037	8b cf		 mov	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo

; 1008 : 
; 1009 : 	if ( this->CheckCanStartPlay(iChaosCastleIndex) == false )

  0003e	56		 push	 esi
  0003f	8b cf		 mov	 ecx, edi
  00041	e8 00 00 00 00	 call	 ?CheckCanStartPlay@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanStartPlay
  00046	84 c0		 test	 al, al
  00048	75 28		 jne	 SHORT $LN2@SetState_P@2

; 1010 : 	{
; 1011 : 		this->PlayFailedRollBack(iChaosCastleIndex);

  0004a	56		 push	 esi
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?PlayFailedRollBack@CChaosCastle@@QAEXH@Z ; CChaosCastle::PlayFailedRollBack

; 1012 : 		LogAddTD("[Chaos Castle] (%d) Failed to Start Chaos Castle : Lack of User", iChaosCastleIndex +1 );

  00052	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00055	52		 push	 edx
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@EGGFCMCP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Failed?5to?5St@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00061	83 c4 08	 add	 esp, 8

; 1013 : 		this->SetState_Closed(iChaosCastleIndex);

  00064	56		 push	 esi
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?SetState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::SetState_Closed
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 1018 : 	}
; 1019 : }

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
$LN2@SetState_P@2:

; 1014 : 	}
; 1015 : 	else
; 1016 : 	{
; 1017 : 		LogAddTD("[Chaos Castle] (%d) SetState PLAYING", iChaosCastleIndex + 1 );

  00072	46		 inc	 esi
  00073	56		 push	 esi
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BCOGMMAI@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007f	83 c4 08	 add	 esp, 8
$LN1@SetState_P@2:
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi

; 1018 : 	}
; 1019 : }

  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
?SetState_Playing@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::SetState_Playing
_TEXT	ENDS
PUBLIC	?SetItemsToMonster@CChaosCastle@@QAEXH@Z	; CChaosCastle::SetItemsToMonster
EXTRN	?gNewServer@@3HA:DWORD				; gNewServer
; Function compile flags: /Ogtp
;	COMDAT ?SetItemsToMonster@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
$T230423 = -56						; size = 12
$T230419 = -56						; size = 12
$T230424 = -44						; size = 8
$T230420 = -44						; size = 8
_MID$ = -36						; size = 8
__Where$231117 = -32					; size = 4
$T230668 = -32						; size = 4
$T231046 = -28						; size = 4
__Where$230739 = -28					; size = 4
_iMAX_MONSTER$ = -24					; size = 4
tv574 = -20						; size = 4
_iB$219971 = -20					; size = 4
_iB$219468 = -16					; size = 4
_this$ = -16						; size = 4
tv741 = -12						; size = 4
_iC$219472 = -12					; size = 4
tv791 = -8						; size = 4
tv1094 = -4						; size = 4
tv1047 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?SetItemsToMonster@CChaosCastle@@QAEXH@Z PROC		; CChaosCastle::SetItemsToMonster, COMDAT
; _this$ = ecx

; 1227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1228 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  00010	85 f6		 test	 esi, esi
  00012	0f 88 66 02 00
	00		 js	 $LN8@SetItemsTo
  00018	33 c0		 xor	 eax, eax
  0001a	83 fe 06	 cmp	 esi, 6
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 56 02 00
	00		 je	 $LN8@SetItemsTo

; 1229 : 	{
; 1230 : 		return;
; 1231 : 	}
; 1232 : 
; 1233 : 	int iMAX_MONSTER = this->GetMonsterListCount(iChaosCastleIndex);

  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  0002e	89 45 e8	 mov	 DWORD PTR _iMAX_MONSTER$[ebp], eax

; 1234 : 
; 1235 : 	if ( iMAX_MONSTER <= 0 )

  00031	85 c0		 test	 eax, eax
  00033	0f 8e 45 02 00
	00		 jle	 $LN8@SetItemsTo

; 1236 : 	{
; 1237 : 		return;
; 1238 : 	}
; 1239 : 
; 1240 : 	std::map<int, _MONSTER_ITEM_DROP>::iterator it;
; 1241 : 	_MONSTER_ITEM_DROP MID;

  00039	83 c8 ff	 or	 eax, -1
  0003c	89 45 dc	 mov	 DWORD PTR _MID$[ebp], eax
  0003f	89 45 e0	 mov	 DWORD PTR _MID$[ebp+4], eax

; 1242 : 
; 1243 : 	if(gNewServer == TRUE) //season4.5 add-on
; 1244 : 	{
; 1245 : 		for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  00042	8b c6		 mov	 eax, esi
  00044	c1 e0 04	 shl	 eax, 4
  00047	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gNewServer@@3HA, 1 ; gNewServer
  0004e	57		 push	 edi
  0004f	0f 85 17 01 00
	00		 jne	 $LN22@SetItemsTo
  00055	89 45 fc	 mov	 DWORD PTR tv1047[ebp], eax
  00058	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR tv574[ebp], 2
  0005f	90		 npad	 1
$LL250@SetItemsTo:

; 1246 : 		{
; 1247 : 			for ( int iB=0; iB< ::g_iChaosCastle_MonsterItemsNewServer[iChaosCastleIndex][iA][1] ; iB++)

  00060	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _g_iChaosCastle_MonsterItemsNewServer[eax+4], 0
  00067	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iB$219468[ebp], 0
  0006e	0f 8e e0 00 00
	00		 jle	 $LN20@SetItemsTo
  00074	8b fe		 mov	 edi, esi
  00076	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  0007c	69 ff 1c 02 00
	00		 imul	 edi, 540		; 0000021cH
  00082	03 f3		 add	 esi, ebx
  00084	89 75 f8	 mov	 DWORD PTR tv791[ebp], esi
  00087	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL18@SetItemsTo:

; 1248 : 			{
; 1249 : 				for ( int iC=0;iC<200;iC++)

  00090	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iC$219472[ebp], 0
$LL15@SetItemsTo:

; 1250 : 				{
; 1251 : 					int iMONSTER_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[rand() % iMAX_MONSTER];

  00097	e8 00 00 00 00	 call	 _rand
  0009c	99		 cdq
  0009d	f7 7d e8	 idiv	 DWORD PTR _iMAX_MONSTER$[ebp]

; 1252 : 					it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMONSTER_INDEX);

  000a0	8b 8e 90 08 00
	00		 mov	 ecx, DWORD PTR [esi+2192]
  000a6	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a9	03 d7		 add	 edx, edi
  000ab	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  000af	8b 94 93 e4 05
	00 00		 mov	 edx, DWORD PTR [ebx+edx*4+1508]
  000b6	75 14		 jne	 SHORT $LN45@SetItemsTo
$LL46@SetItemsTo:
  000b8	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  000bb	7d 05		 jge	 SHORT $LN44@SetItemsTo
  000bd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c0	eb 04		 jmp	 SHORT $LN43@SetItemsTo
$LN44@SetItemsTo:
  000c2	8b c8		 mov	 ecx, eax
  000c4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN43@SetItemsTo:
  000c6	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  000ca	74 ec		 je	 SHORT $LL46@SetItemsTo
$LN45@SetItemsTo:
  000cc	8b 86 90 08 00
	00		 mov	 eax, DWORD PTR [esi+2192]
  000d2	89 4d e4	 mov	 DWORD PTR __Where$230739[ebp], ecx
  000d5	3b c8		 cmp	 ecx, eax
  000d7	74 0a		 je	 SHORT $LN39@SetItemsTo
  000d9	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  000dc	7c 05		 jl	 SHORT $LN39@SetItemsTo
  000de	8d 45 e4	 lea	 eax, DWORD PTR __Where$230739[ebp]
  000e1	eb 06		 jmp	 SHORT $LN40@SetItemsTo
$LN39@SetItemsTo:
  000e3	89 45 e0	 mov	 DWORD PTR $T230668[ebp], eax
  000e6	8d 45 e0	 lea	 eax, DWORD PTR $T230668[ebp]
$LN40@SetItemsTo:
  000e9	8b 00		 mov	 eax, DWORD PTR [eax]

; 1253 : 
; 1254 : 					if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  000eb	8b 4d f8	 mov	 ecx, DWORD PTR tv791[ebp]
  000ee	3b 81 90 08 00
	00		 cmp	 eax, DWORD PTR [ecx+2192]
  000f4	74 10		 je	 SHORT $LN241@SetItemsTo

; 1248 : 			{
; 1249 : 				for ( int iC=0;iC<200;iC++)

  000f6	8b 45 f4	 mov	 eax, DWORD PTR _iC$219472[ebp]
  000f9	40		 inc	 eax
  000fa	89 45 f4	 mov	 DWORD PTR _iC$219472[ebp], eax
  000fd	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  00102	7c 93		 jl	 SHORT $LL15@SetItemsTo

; 1275 : 
; 1276 : 					if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  00104	eb 33		 jmp	 SHORT $LN17@SetItemsTo
$LN241@SetItemsTo:

; 1255 : 					{
; 1256 : 						MID.m_iIndex = iMONSTER_INDEX;
; 1257 : 						MID.m_iItemKind = ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][0];

  00106	8b 45 fc	 mov	 eax, DWORD PTR tv1047[ebp]
  00109	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_MonsterItems[eax]

; 1258 : 						this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.insert( std::pair<int,_MONSTER_ITEM_DROP>(iMONSTER_INDEX, MID) );

  0010f	6a 00		 push	 0
  00111	8d 4d c8	 lea	 ecx, DWORD PTR $T230419[ebp]
  00114	51		 push	 ecx
  00115	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  0011b	89 55 c8	 mov	 DWORD PTR $T230419[ebp], edx
  0011e	89 55 cc	 mov	 DWORD PTR $T230419[ebp+4], edx
  00121	89 45 d0	 mov	 DWORD PTR $T230419[ebp+8], eax
  00124	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
  00129	50		 push	 eax
  0012a	8d 55 d4	 lea	 edx, DWORD PTR $T230420[ebp]
  0012d	52		 push	 edx
  0012e	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  00134	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
$LN17@SetItemsTo:

; 1246 : 		{
; 1247 : 			for ( int iB=0; iB< ::g_iChaosCastle_MonsterItemsNewServer[iChaosCastleIndex][iA][1] ; iB++)

  00139	8b 45 f0	 mov	 eax, DWORD PTR _iB$219468[ebp]
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR tv1047[ebp]
  0013f	40		 inc	 eax
  00140	89 45 f0	 mov	 DWORD PTR _iB$219468[ebp], eax
  00143	3b 81 04 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_MonsterItemsNewServer[ecx+4]
  00149	0f 8c 41 ff ff
	ff		 jl	 $LL18@SetItemsTo
  0014f	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  00152	8b c1		 mov	 eax, ecx
$LN20@SetItemsTo:

; 1242 : 
; 1243 : 	if(gNewServer == TRUE) //season4.5 add-on
; 1244 : 	{
; 1245 : 		for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  00154	83 c0 08	 add	 eax, 8
  00157	ff 4d ec	 dec	 DWORD PTR tv574[ebp]
  0015a	89 45 fc	 mov	 DWORD PTR tv1047[ebp], eax
  0015d	0f 85 fd fe ff
	ff		 jne	 $LL250@SetItemsTo
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx

; 1281 : 						break;
; 1282 : 					}
; 1283 : 				}
; 1284 : 			}
; 1285 : 		}
; 1286 : 	}
; 1287 : }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 04 00	 ret	 4
$LN22@SetItemsTo:

; 1259 : 						break;
; 1260 : 					}
; 1261 : 				}
; 1262 : 			}
; 1263 : 		}
; 1264 : 	}
; 1265 : 	else
; 1266 : 	{
; 1267 : 		for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  0016c	89 45 fc	 mov	 DWORD PTR tv1094[ebp], eax
  0016f	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR tv741[ebp], 2
  00176	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL251@SetItemsTo:

; 1268 : 		{
; 1269 : 			for ( int iB=0; iB< ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][1] ; iB++)

  00180	83 b8 04 00 00
	00 00		 cmp	 DWORD PTR _g_iChaosCastle_MonsterItems[eax+4], 0
  00187	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iB$219971[ebp], 0
  0018e	0f 8e da 00 00
	00		 jle	 $LN9@SetItemsTo
  00194	8b fe		 mov	 edi, esi
  00196	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  0019c	69 ff 1c 02 00
	00		 imul	 edi, 540		; 0000021cH
  001a2	03 f3		 add	 esi, ebx
  001a4	89 75 f8	 mov	 DWORD PTR tv791[ebp], esi
$LL249@SetItemsTo:

; 1270 : 			{
; 1271 : 				for ( int iC=0;iC<200;iC++)

  001a7	33 db		 xor	 ebx, ebx
  001a9	8d a4 24 00 00
	00 00		 npad	 7
$LL4@SetItemsTo:

; 1272 : 				{
; 1273 : 					int iMONSTER_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[rand() % iMAX_MONSTER];

  001b0	e8 00 00 00 00	 call	 _rand
  001b5	99		 cdq
  001b6	f7 7d e8	 idiv	 DWORD PTR _iMAX_MONSTER$[ebp]
  001b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 1274 : 					it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMONSTER_INDEX);

  001bc	8b 8e 90 08 00
	00		 mov	 ecx, DWORD PTR [esi+2192]
  001c2	03 d7		 add	 edx, edi
  001c4	8b 94 90 e4 05
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+1508]
  001cb	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001ce	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  001d2	75 14		 jne	 SHORT $LN143@SetItemsTo
$LL144@SetItemsTo:
  001d4	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  001d7	7d 05		 jge	 SHORT $LN142@SetItemsTo
  001d9	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001dc	eb 04		 jmp	 SHORT $LN141@SetItemsTo
$LN142@SetItemsTo:
  001de	8b c8		 mov	 ecx, eax
  001e0	8b 00		 mov	 eax, DWORD PTR [eax]
$LN141@SetItemsTo:
  001e2	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  001e6	74 ec		 je	 SHORT $LL144@SetItemsTo
$LN143@SetItemsTo:
  001e8	8b 86 90 08 00
	00		 mov	 eax, DWORD PTR [esi+2192]
  001ee	89 4d e0	 mov	 DWORD PTR __Where$231117[ebp], ecx
  001f1	3b c8		 cmp	 ecx, eax
  001f3	74 0a		 je	 SHORT $LN137@SetItemsTo
  001f5	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  001f8	7c 05		 jl	 SHORT $LN137@SetItemsTo
  001fa	8d 45 e0	 lea	 eax, DWORD PTR __Where$231117[ebp]
  001fd	eb 06		 jmp	 SHORT $LN138@SetItemsTo
$LN137@SetItemsTo:
  001ff	89 45 e4	 mov	 DWORD PTR $T231046[ebp], eax
  00202	8d 45 e4	 lea	 eax, DWORD PTR $T231046[ebp]
$LN138@SetItemsTo:
  00205	8b 00		 mov	 eax, DWORD PTR [eax]

; 1275 : 
; 1276 : 					if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  00207	8b 4d f8	 mov	 ecx, DWORD PTR tv791[ebp]
  0020a	3b 81 90 08 00
	00		 cmp	 eax, DWORD PTR [ecx+2192]
  00210	74 0b		 je	 SHORT $LN242@SetItemsTo

; 1270 : 			{
; 1271 : 				for ( int iC=0;iC<200;iC++)

  00212	43		 inc	 ebx
  00213	81 fb c8 00 00
	00		 cmp	 ebx, 200		; 000000c8H
  00219	7c 95		 jl	 SHORT $LL4@SetItemsTo

; 1275 : 
; 1276 : 					if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  0021b	eb 33		 jmp	 SHORT $LN6@SetItemsTo
$LN242@SetItemsTo:

; 1277 : 					{
; 1278 : 						MID.m_iIndex = iMONSTER_INDEX;
; 1279 : 						MID.m_iItemKind = ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][0];

  0021d	8b 45 fc	 mov	 eax, DWORD PTR tv1094[ebp]
  00220	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _g_iChaosCastle_MonsterItems[eax]

; 1280 : 						this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.insert( std::pair<int,_MONSTER_ITEM_DROP>(iMONSTER_INDEX, MID) );

  00226	6a 00		 push	 0
  00228	8d 4d c8	 lea	 ecx, DWORD PTR $T230423[ebp]
  0022b	51		 push	 ecx
  0022c	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  00232	89 55 c8	 mov	 DWORD PTR $T230423[ebp], edx
  00235	89 55 cc	 mov	 DWORD PTR $T230423[ebp+4], edx
  00238	89 45 d0	 mov	 DWORD PTR $T230423[ebp+8], eax
  0023b	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_MONSTER_ITEM_DROP@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_MONSTER_ITEM_DROP@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Buynode<std::pair<int,_MONSTER_ITEM_DROP> >
  00240	50		 push	 eax
  00241	8d 55 d4	 lea	 edx, DWORD PTR $T230424[ebp]
  00244	52		 push	 edx
  00245	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  0024b	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::_Linsert
$LN6@SetItemsTo:

; 1268 : 		{
; 1269 : 			for ( int iB=0; iB< ::g_iChaosCastle_MonsterItems[iChaosCastleIndex][iA][1] ; iB++)

  00250	8b 45 ec	 mov	 eax, DWORD PTR _iB$219971[ebp]
  00253	8b 4d fc	 mov	 ecx, DWORD PTR tv1094[ebp]
  00256	40		 inc	 eax
  00257	89 45 ec	 mov	 DWORD PTR _iB$219971[ebp], eax
  0025a	3b 81 04 00 00
	00		 cmp	 eax, DWORD PTR _g_iChaosCastle_MonsterItems[ecx+4]
  00260	0f 8c 41 ff ff
	ff		 jl	 $LL249@SetItemsTo
  00266	8b 5d f0	 mov	 ebx, DWORD PTR _this$[ebp]
  00269	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]
  0026c	8b c1		 mov	 eax, ecx
$LN9@SetItemsTo:

; 1259 : 						break;
; 1260 : 					}
; 1261 : 				}
; 1262 : 			}
; 1263 : 		}
; 1264 : 	}
; 1265 : 	else
; 1266 : 	{
; 1267 : 		for ( int iA = 0;iA < MAX_CC_MONSTER_DROP_ITEM ; iA++)

  0026e	83 c0 08	 add	 eax, 8
  00271	ff 4d f4	 dec	 DWORD PTR tv741[ebp]
  00274	89 45 fc	 mov	 DWORD PTR tv1094[ebp], eax
  00277	0f 85 03 ff ff
	ff		 jne	 $LL251@SetItemsTo
  0027d	5f		 pop	 edi
$LN8@SetItemsTo:
  0027e	5e		 pop	 esi
  0027f	5b		 pop	 ebx

; 1281 : 						break;
; 1282 : 					}
; 1283 : 				}
; 1284 : 			}
; 1285 : 		}
; 1286 : 	}
; 1287 : }

  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c2 04 00	 ret	 4
?SetItemsToMonster@CChaosCastle@@QAEXH@Z ENDP		; CChaosCastle::SetItemsToMonster
_TEXT	ENDS
PUBLIC	??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@ ; `string'
PUBLIC	?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z	; CChaosCastle::SearchNDropMonsterItem
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
;	COMDAT ??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@ DB '['
	DB	'Chaos Castle] (%d) Monster Dropped ChaosCastle Item To [%s][%'
	DB	's] (Item:%s)', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
CONST	ENDS
;	COMDAT ?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z
_TEXT	SEGMENT
_MID$ = -12						; size = 8
tv263 = -4						; size = 4
_iChaosCastleIndex$ = 8					; size = 4
_iMonsterIndex$ = 12					; size = 4
_it$ = 16						; size = 4
_iMaxHitUserIndex$ = 16					; size = 4
?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z PROC	; CChaosCastle::SearchNDropMonsterItem, COMDAT
; _this$ = ecx

; 1290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iChaosCastleIndex$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 18 01 00
	00		 js	 $LN1@SearchNDro
  00014	33 c0		 xor	 eax, eax
  00016	83 fa 06	 cmp	 edx, 6
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 08 01 00
	00		 je	 $LN1@SearchNDro

; 1292 : 	{
; 1293 : 		return;
; 1294 : 	}
; 1295 : 
; 1296 : 	if ( OBJMAX_RANGE(iMonsterIndex) == FALSE )

  00024	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	0f 88 fd 00 00
	00		 js	 $LN1@SearchNDro
  0002f	33 c9		 xor	 ecx, ecx
  00031	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00036	0f 9e c1	 setle	 cl
  00039	8b c1		 mov	 eax, ecx
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 e9 00 00
	00		 je	 $LN1@SearchNDro

; 1297 : 	{
; 1298 : 		return;
; 1299 : 	}
; 1300 : 
; 1301 : 	if ( OBJMAX_RANGE(iMaxHitUserIndex) == FALSE )

  00043	53		 push	 ebx
  00044	8b 5d 10	 mov	 ebx, DWORD PTR _iMaxHitUserIndex$[ebp]
  00047	85 db		 test	 ebx, ebx
  00049	0f 88 dc 00 00
	00		 js	 $LN37@SearchNDro
  0004f	33 c0		 xor	 eax, eax
  00051	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00057	0f 9e c0	 setle	 al
  0005a	89 45 fc	 mov	 DWORD PTR tv263[ebp], eax
  0005d	85 c0		 test	 eax, eax
  0005f	0f 84 c6 00 00
	00		 je	 $LN37@SearchNDro

; 1302 : 	{
; 1303 : 		return;
; 1304 : 	}
; 1305 : 
; 1306 : 	std::map<int, _MONSTER_ITEM_DROP>::iterator it = this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.find(iMonsterIndex);

  00065	69 d2 70 08 00
	00		 imul	 edx, 2160		; 00000870H
  0006b	03 f2		 add	 esi, edx
  0006d	8d 55 0c	 lea	 edx, DWORD PTR _iMonsterIndex$[ebp]
  00070	52		 push	 edx
  00071	8d 45 10	 lea	 eax, DWORD PTR _it$[ebp]
  00074	50		 push	 eax
  00075	8d 8e 8c 08 00
	00		 lea	 ecx, DWORD PTR [esi+2188]
  0007b	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::find

; 1307 : 
; 1308 : 	if ( it == this->m_stChaosCastleData[iChaosCastleIndex].m_mapMonsterItemList.end() )

  00080	8b 45 10	 mov	 eax, DWORD PTR _it$[ebp]
  00083	3b 86 90 08 00
	00		 cmp	 eax, DWORD PTR [esi+2192]
  00089	0f 84 9c 00 00
	00		 je	 $LN37@SearchNDro

; 1309 : 	{
; 1310 : 		return;
; 1311 : 	}
; 1312 : 
; 1313 : 	_MONSTER_ITEM_DROP MID = it->second;

  0008f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00092	57		 push	 edi
  00093	8b 78 14	 mov	 edi, DWORD PTR [eax+20]

; 1314 : 	int iType = MID.m_iItemKind;
; 1315 : 	int iLevel = 0;

  00096	33 c0		 xor	 eax, eax
  00098	89 4d f4	 mov	 DWORD PTR _MID$[ebp], ecx

; 1316 : 	
; 1317 : 	if ( iType == ITEMGET(13,15) )

  0009b	81 ff 0f 1a 00
	00		 cmp	 edi, 6671		; 00001a0fH
  000a1	75 11		 jne	 SHORT $LN39@SearchNDro

; 1318 : 	{
; 1319 : 		iLevel = rand()%4;

  000a3	e8 00 00 00 00	 call	 _rand
  000a8	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000ad	79 05		 jns	 SHORT $LN39@SearchNDro
  000af	48		 dec	 eax
  000b0	83 c8 fc	 or	 eax, -4			; fffffffcH
  000b3	40		 inc	 eax
$LN39@SearchNDro:

; 1320 : 	}
; 1321 : 
; 1322 : 	::ItemSerialCreateSend(gObj[iMaxHitUserIndex].m_Index, (BYTE)gObj[iMaxHitUserIndex].MapNumber, (BYTE)gObj[iMaxHitUserIndex].X,
; 1323 : 		(BYTE)gObj[iMaxHitUserIndex].Y, iType, (BYTE)iLevel, 0, 0, 0, 0, iMaxHitUserIndex, 0, 0);

  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	53		 push	 ebx
  000bf	6a 00		 push	 0
  000c1	8b f3		 mov	 esi, ebx
  000c3	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000c9	0f b6 94 0e 46
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+326]
  000d1	6a 00		 push	 0
  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	50		 push	 eax
  000d8	0f b6 84 0e 44
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+324]
  000e0	57		 push	 edi
  000e1	52		 push	 edx
  000e2	0f b6 94 0e 49
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+329]
  000ea	50		 push	 eax
  000eb	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  000ee	52		 push	 edx
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  000f5	83 c4 34	 add	 esp, 52			; 00000034H

; 1324 : 
; 1325 : 	if ( OBJMAX_RANGE(iMaxHitUserIndex) != FALSE )

  000f8	83 7d fc 00	 cmp	 DWORD PTR tv263[ebp], 0
  000fc	74 2c		 je	 SHORT $LN38@SearchNDro

; 1326 : 	{
; 1327 : 		LogAddTD("[Chaos Castle] (%d) Monster Dropped ChaosCastle Item To [%s][%s] (Item:%s)",
; 1328 : 			iChaosCastleIndex+1, gObj[iMaxHitUserIndex].AccountID, gObj[iMaxHitUserIndex].Name,
; 1329 : 			ItemAttribute[iType].Name);

  000fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00103	6b ff 70	 imul	 edi, 112		; 00000070H
  00106	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0010a	81 c7 00 00 00
	00		 add	 edi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00110	57		 push	 edi
  00111	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00115	8b 45 08	 mov	 eax, DWORD PTR _iChaosCastleIndex$[ebp]
  00118	51		 push	 ecx
  00119	52		 push	 edx
  0011a	40		 inc	 eax
  0011b	50		 push	 eax
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@HKCNHNKH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Drop@
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00127	83 c4 14	 add	 esp, 20			; 00000014H
$LN38@SearchNDro:
  0012a	5f		 pop	 edi
$LN37@SearchNDro:
  0012b	5b		 pop	 ebx
$LN1@SearchNDro:
  0012c	5e		 pop	 esi

; 1330 : 	}
; 1331 : }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 0c 00	 ret	 12			; 0000000cH
?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z ENDP	; CChaosCastle::SearchNDropMonsterItem
_TEXT	ENDS
PUBLIC	??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ ; `string'
PUBLIC	??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RewardZettoMoney@CChaosCastle@@QAEHH@Z		; CChaosCastle::RewardZettoMoney
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] Win Zen Lotto (RewardZen:%d, User'
	DB	'Zen:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Chaos Castle][Bug Tracer] (%d) [%s][%s] Reword ZettoMoney(Map'
	DB	':%d) Send Message', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@
CONST	SEGMENT
??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@ DB '['
	DB	'Chaos Castle] (%d) ERROR : REWARD ZEN <= 0 (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RewardZettoMoney@CChaosCastle@@QAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RewardZettoMoney@CChaosCastle@@QAEHH@Z$0
__ehfuncinfo$?RewardZettoMoney@CChaosCastle@@QAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ?RewardZettoMoney@CChaosCastle@@QAEHH@Z
_TEXT	SEGMENT
_vtZettoWinner$ = -332					; size = 16
tv804 = -316						; size = 4
_iZettoMoney$ = -312					; size = 4
_this$GSCopy$ = -308					; size = 4
_iZettoWinnerIndex$ = -308				; size = 4
tv514 = -304						; size = 4
tv361 = -304						; size = 4
_pNotice$ = -300					; size = 272
_szZettoWinnerName$ = -28				; size = 11
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
?RewardZettoMoney@CChaosCastle@@QAEHH@Z PROC		; CChaosCastle::RewardZettoMoney, COMDAT
; _this$ = ecx

; 3217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 7d 08	 mov	 edi, DWORD PTR _iChaosCastleIndex$[ebp]

; 3257 : 	}
; 3258 : 
; 3259 : 	int iZettoWinnerIndex = vtZettoWinner[rand()%iPlayUser];

  00031	89 8d cc fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00037	85 ff		 test	 edi, edi
  00039	78 56		 js	 SHORT $LN63@RewardZett

; 3218 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003b	33 c0		 xor	 eax, eax
  0003d	83 ff 06	 cmp	 edi, 6
  00040	0f 9e c0	 setle	 al
  00043	85 c0		 test	 eax, eax

; 3219 : 	{
; 3220 : 		return -1;

  00045	74 4a		 je	 SHORT $LN63@RewardZett

; 3221 : 	}
; 3222 : 
; 3223 : 	int iPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  00047	57		 push	 edi
  00048	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  0004d	8b f0		 mov	 esi, eax

; 3224 : 
; 3225 : 	if ( iPlayUser <= 0 )

  0004f	85 f6		 test	 esi, esi

; 3226 : 	{
; 3227 : 		return -1;

  00051	7e 3e		 jle	 SHORT $LN63@RewardZett

; 3228 : 	}
; 3229 : 
; 3230 : 	int iZettoMoney = iPlayUser * (g_iChaosCastle_EnterCost[iChaosCastleIndex] * 80 / 100);

  00053	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR _g_iChaosCastle_EnterCost[edi*4]
  0005a	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0005d	c1 e1 04	 shl	 ecx, 4
  00060	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00065	f7 e9		 imul	 ecx
  00067	c1 fa 05	 sar	 edx, 5
  0006a	8b da		 mov	 ebx, edx
  0006c	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0006f	03 da		 add	 ebx, edx
  00071	0f af de	 imul	 ebx, esi

; 3231 : 
; 3232 : 	if ( iZettoMoney <= 0 )

  00074	33 c0		 xor	 eax, eax
  00076	89 9d c8 fe ff
	ff		 mov	 DWORD PTR _iZettoMoney$[ebp], ebx
  0007c	3b d8		 cmp	 ebx, eax
  0007e	7f 19		 jg	 SHORT $LN15@RewardZett

; 3233 : 	{
; 3234 : 		LogAddTD("[Chaos Castle] (%d) ERROR : REWARD ZEN <= 0 (%d)", iChaosCastleIndex+1, iZettoMoney);

  00080	53		 push	 ebx
  00081	47		 inc	 edi
  00082	57		 push	 edi
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@POIMMHNL@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5ERROR?5?3?5REWA@
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN63@RewardZett:

; 3235 : 		return -1;

  00091	83 c8 ff	 or	 eax, -1
  00094	e9 64 02 00 00	 jmp	 $LN18@RewardZett
$LN15@RewardZett:

; 3236 : 	}
; 3237 : 
; 3238 : 	std::vector<int> vtZettoWinner;

  00099	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _vtZettoWinner$[ebp], eax
  0009f	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _vtZettoWinner$[ebp+4], eax
  000a5	89 85 bc fe ff
	ff		 mov	 DWORD PTR _vtZettoWinner$[ebp+8], eax
  000ab	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  000b1	8b cf		 mov	 ecx, edi
  000b3	69 c9 70 08 00
	00		 imul	 ecx, 2160		; 00000870H
  000b9	8d 74 11 6c	 lea	 esi, DWORD PTR [ecx+edx+108]
  000bd	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  000c0	89 b5 c4 fe ff
	ff		 mov	 DWORD PTR tv804[ebp], esi
  000c6	c7 85 d0 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv514[ebp], 70 ; 00000046H
$LL14@RewardZett:

; 3241 : 	{
; 3242 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  000d0	8b 06		 mov	 eax, DWORD PTR [esi]
  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	74 40		 je	 SHORT $LN13@RewardZett

; 3243 : 		{
; 3244 : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) == TRUE && 
; 3245 : 				gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == this->GetChaosCastleMapNumber(iChaosCastleIndex) )

  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000dd	83 c4 04	 add	 esp, 4
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	75 32		 jne	 SHORT $LN13@RewardZett
  000e5	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000eb	57		 push	 edi
  000ec	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  000f1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f9	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000ff	0f b6 8c 11 49
	01 00 00	 movzx	 ecx, BYTE PTR [ecx+edx+329]
  00107	3b c8		 cmp	 ecx, eax
  00109	75 0c		 jne	 SHORT $LN13@RewardZett

; 3246 : 			{
; 3247 : 				vtZettoWinner.push_back(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex);

  0010b	56		 push	 esi
  0010c	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  00112	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN13@RewardZett:

; 3239 : 
; 3240 : 	for(int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00117	83 c6 14	 add	 esi, 20			; 00000014H
  0011a	ff 8d d0 fe ff
	ff		 dec	 DWORD PTR tv514[ebp]
  00120	75 ae		 jne	 SHORT $LL14@RewardZett

; 3248 : 			}
; 3249 : 		}
; 3250 : 	}
; 3251 : 
; 3252 : 	iPlayUser = vtZettoWinner.size();

  00122	8b b5 b8 fe ff
	ff		 mov	 esi, DWORD PTR _vtZettoWinner$[ebp+4]
  00128	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _vtZettoWinner$[ebp]
  0012e	2b f0		 sub	 esi, eax
  00130	c1 fe 02	 sar	 esi, 2

; 3253 : 
; 3254 : 	if ( iPlayUser <= 0 )

  00133	85 f6		 test	 esi, esi
  00135	7f 15		 jg	 SHORT $LN9@RewardZett

; 3255 : 	{
; 3256 : 		return -1;

  00137	85 c0		 test	 eax, eax
  00139	74 09		 je	 SHORT $LN42@RewardZett
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00141	83 c4 04	 add	 esp, 4
$LN42@RewardZett:
  00144	83 c8 ff	 or	 eax, -1
  00147	e9 b1 01 00 00	 jmp	 $LN18@RewardZett
$LN9@RewardZett:

; 3257 : 	}
; 3258 : 
; 3259 : 	int iZettoWinnerIndex = vtZettoWinner[rand()%iPlayUser];

  0014c	e8 00 00 00 00	 call	 _rand
  00151	99		 cdq
  00152	f7 fe		 idiv	 esi
  00154	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _vtZettoWinner$[ebp]
  0015a	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]

; 3260 : 	char szZettoWinnerName[11] ={0};
; 3261 : 	memcpy(szZettoWinnerName, gObj[iZettoWinnerIndex].Name, 10);

  0015d	8b f2		 mov	 esi, edx
  0015f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00165	33 c0		 xor	 eax, eax
  00167	89 45 e5	 mov	 DWORD PTR _szZettoWinnerName$[ebp+1], eax
  0016a	89 45 e9	 mov	 DWORD PTR _szZettoWinnerName$[ebp+5], eax
  0016d	66 89 45 ed	 mov	 WORD PTR _szZettoWinnerName$[ebp+9], ax
  00171	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00176	c6 45 e4 00	 mov	 BYTE PTR _szZettoWinnerName$[ebp], 0
  0017a	8b 4c 06 77	 mov	 ecx, DWORD PTR [esi+eax+119]
  0017e	89 4d e4	 mov	 DWORD PTR _szZettoWinnerName$[ebp], ecx
  00181	8b 4c 06 7b	 mov	 ecx, DWORD PTR [esi+eax+123]
  00185	89 4d e8	 mov	 DWORD PTR _szZettoWinnerName$[ebp+4], ecx
  00188	66 8b 4c 06 7f	 mov	 cx, WORD PTR [esi+eax+127]
  0018d	66 89 4d ec	 mov	 WORD PTR _szZettoWinnerName$[ebp+8], cx

; 3262 : 	gObj[iZettoWinnerIndex].Money += iZettoMoney;

  00191	01 9c 06 f0 00
	00 00		 add	 DWORD PTR [esi+eax+240], ebx
  00198	8d 84 06 f0 00
	00 00		 lea	 eax, DWORD PTR [esi+eax+240]

; 3263 : 
; 3264 : 	if ( gObj[iZettoWinnerIndex].Money > MAX_ZEN )

  0019f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a4	b9 00 94 35 77	 mov	 ecx, 2000000000		; 77359400H
  001a9	89 95 cc fe ff
	ff		 mov	 DWORD PTR _iZettoWinnerIndex$[ebp], edx
  001af	39 8c 06 f0 00
	00 00		 cmp	 DWORD PTR [esi+eax+240], ecx
  001b6	7e 0c		 jle	 SHORT $LN8@RewardZett

; 3265 : 	{
; 3266 : 		gObj[iZettoWinnerIndex].Money = MAX_ZEN;

  001b8	89 8c 06 f0 00
	00 00		 mov	 DWORD PTR [esi+eax+240], ecx
  001bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN8@RewardZett:

; 3267 : 	}
; 3268 : 
; 3269 : 	GCMoneySend(iZettoWinnerIndex, gObj[iZettoWinnerIndex].Money);

  001c4	8b 84 06 f0 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+240]
  001cb	50		 push	 eax
  001cc	52		 push	 edx
  001cd	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 3270 : 
; 3271 : 	PMSG_NOTICE pNotice;
; 3272 : 	TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4,213)), iChaosCastleIndex+1, szZettoWinnerName, iZettoMoney);

  001d2	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _iZettoMoney$[ebp]
  001d8	83 c4 08	 add	 esp, 8
  001db	51		 push	 ecx
  001dc	8d 55 e4	 lea	 edx, DWORD PTR _szZettoWinnerName$[ebp]
  001df	52		 push	 edx
  001e0	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  001e3	53		 push	 ebx
  001e4	68 d5 04 00 00	 push	 1237			; 000004d5H
  001e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001ee	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001f3	50		 push	 eax
  001f4	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  001fa	6a 00		 push	 0
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00202	8b bd c4 fe ff
	ff		 mov	 edi, DWORD PTR tv804[ebp]
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020e	83 c4 18	 add	 esp, 24			; 00000018H
  00211	c7 85 d0 fe ff
	ff 46 00 00 00	 mov	 DWORD PTR tv361[ebp], 70 ; 00000046H
  0021b	eb 03 8d 49 00	 npad	 5
$LL7@RewardZett:

; 3275 : 	{
; 3276 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00220	8b 17		 mov	 edx, DWORD PTR [edi]
  00222	83 fa ff	 cmp	 edx, -1
  00225	74 71		 je	 SHORT $LN6@RewardZett

; 3277 : 		{
; 3278 : 			if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Connected == PLAYER_PLAYING )

  00227	8b c2		 mov	 eax, edx
  00229	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0022f	83 7c 08 04 03	 cmp	 DWORD PTR [eax+ecx+4], 3
  00234	75 62		 jne	 SHORT $LN6@RewardZett

; 3279 : 			{
; 3280 : 				if ( gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleIndex != -1 && 
; 3281 : 					 gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_cChaosCastleSubIndex!= -1)

  00236	80 bc 08 a5 0e
	00 00 ff	 cmp	 BYTE PTR [eax+ecx+3749], -1
  0023e	74 28		 je	 SHORT $LN2@RewardZett
  00240	80 bc 08 a6 0e
	00 00 ff	 cmp	 BYTE PTR [eax+ecx+3750], -1
  00248	74 1e		 je	 SHORT $LN2@RewardZett

; 3282 : 				{
; 3283 : 					DataSend(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  0024a	0f b6 8d d5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$[ebp+1]
  00251	51		 push	 ecx
  00252	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00258	50		 push	 eax
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0025f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00265	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@RewardZett:

; 3284 : 				}
; 3285 : 
; 3286 : 				LogAddTD("[Chaos Castle][Bug Tracer] (%d) [%s][%s] Reword ZettoMoney(Map:%d) Send Message",
; 3287 : 					iChaosCastleIndex+1, gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].AccountID,
; 3288 : 					gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Name,	gObj[iZettoWinnerIndex].MapNumber);

  00268	8b 07		 mov	 eax, DWORD PTR [edi]
  0026a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00270	03 c1		 add	 eax, ecx
  00272	0f b6 8c 0e 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+ecx+329]
  0027a	51		 push	 ecx
  0027b	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  0027e	52		 push	 edx
  0027f	83 c0 6c	 add	 eax, 108		; 0000006cH
  00282	50		 push	 eax
  00283	53		 push	 ebx
  00284	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BKKNHLPK@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0028f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00295	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@RewardZett:

; 3273 : 
; 3274 : 	for(int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00298	83 c7 14	 add	 edi, 20			; 00000014H
  0029b	ff 8d d0 fe ff
	ff		 dec	 DWORD PTR tv361[ebp]
  002a1	0f 85 79 ff ff
	ff		 jne	 $LL7@RewardZett

; 3289 : 			}
; 3290 : 		}
; 3291 : 	}
; 3292 : 
; 3293 : 	if ( OBJMAX_RANGE(iZettoWinnerIndex))

  002a7	8b bd cc fe ff
	ff		 mov	 edi, DWORD PTR _iZettoWinnerIndex$[ebp]
  002ad	85 ff		 test	 edi, edi
  002af	78 37		 js	 SHORT $LN1@RewardZett
  002b1	33 c0		 xor	 eax, eax
  002b3	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  002b9	0f 9e c0	 setle	 al
  002bc	85 c0		 test	 eax, eax
  002be	74 28		 je	 SHORT $LN1@RewardZett

; 3294 : 	{
; 3295 : 		LogAddTD("[Chaos Castle] (%d) [%s][%s] Win Zen Lotto (RewardZen:%d, UserZen:%d)", iChaosCastleIndex+1, gObj[iZettoWinnerIndex].AccountID, gObj[iZettoWinnerIndex].Name, iZettoMoney, gObj[iZettoWinnerIndex].Money);

  002c0	8b 84 0e f0 00
	00 00		 mov	 eax, DWORD PTR [esi+ecx+240]
  002c7	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _iZettoMoney$[ebp]
  002cd	50		 push	 eax
  002ce	52		 push	 edx
  002cf	8d 44 0e 77	 lea	 eax, DWORD PTR [esi+ecx+119]
  002d3	50		 push	 eax
  002d4	8d 4c 0e 6c	 lea	 ecx, DWORD PTR [esi+ecx+108]
  002d8	51		 push	 ecx
  002d9	53		 push	 ebx
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@DMBELMMH@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win@
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002e5	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@RewardZett:

; 3296 : 	}
; 3297 : 
; 3298 : 	return iZettoWinnerIndex;

  002e8	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _vtZettoWinner$[ebp]
  002ee	85 c0		 test	 eax, eax
  002f0	74 09		 je	 SHORT $LN55@RewardZett
  002f2	50		 push	 eax
  002f3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002f8	83 c4 04	 add	 esp, 4
$LN55@RewardZett:
  002fb	8b c7		 mov	 eax, edi
$LN18@RewardZett:

; 3299 : }

  002fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00300	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00307	59		 pop	 ecx
  00308	5f		 pop	 edi
  00309	5e		 pop	 esi
  0030a	5b		 pop	 ebx
  0030b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030e	33 cd		 xor	 ecx, ebp
  00310	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00315	8b e5		 mov	 esp, ebp
  00317	5d		 pop	 ebp
  00318	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RewardZettoMoney@CChaosCastle@@QAEHH@Z$0:
  00000	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _vtZettoWinner$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?RewardZettoMoney@CChaosCastle@@QAEHH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a b0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-336]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RewardZettoMoney@CChaosCastle@@QAEHH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RewardZettoMoney@CChaosCastle@@QAEHH@Z ENDP		; CChaosCastle::RewardZettoMoney
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T231512 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T231512[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
PUBLIC	??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@3
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@3:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 26		 je	 SHORT $LN1@erase@3

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 1a		 je	 SHORT $LN30@erase@3
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase@3:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00027	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002a	83 c2 08	 add	 edx, 8
  0002d	83 c6 08	 add	 esi, 8
  00030	3b d7		 cmp	 edx, edi
  00032	75 ec		 jne	 SHORT $LL32@erase@3
  00034	5b		 pop	 ebx
$LN30@erase@3:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00035	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00038	5f		 pop	 edi
$LN1@erase@3:
  00039	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::erase
_TEXT	ENDS
PUBLIC	??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@4
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@4:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$221510 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$231757 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@2:
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 03	 sar	 ecx, 3
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UCHAOSCASTLE_START_TIME@@@std@@QAEPAUCHAOSCASTLE_START_TIME@@I@Z ; std::allocator<CHAOSCASTLE_START_TIME>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$231757[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$221510[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCHAOSCASTLE_START_TIME@@PAU1@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@U1@@std@@YAPAUCHAOSCASTLE_START_TIME@@PAU1@00AAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CHAOSCASTLE_START_TIME *,CHAOSCASTLE_START_TIME *,std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 03	 sar	 edi, 3

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 fb	 lea	 edx, DWORD PTR [ebx+edi*8]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve@2:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$221510[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@2:
$LN41@reserve@2:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
PUBLIC	?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$221583 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$231842 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@3:
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 03	 sar	 ecx, 3
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UtagPOINT@@@std@@QAEPAUtagPOINT@@I@Z ; std::allocator<tagPOINT>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$231842[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$221583[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUtagPOINT@@PAU1@V?$allocator@UtagPOINT@@@std@@U1@@std@@YAPAUtagPOINT@@PAU1@00AAV?$allocator@UtagPOINT@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tagPOINT *,tagPOINT *,std::allocator<tagPOINT>,tagPOINT>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 03	 sar	 edi, 3

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 fb	 lea	 edx, DWORD PTR [ebx+edi*8]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve@3:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$221583[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@3:
$LN41@reserve@3:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
PUBLIC	??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T232017 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T232017[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::~map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
PUBLIC	??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T232207 = -16						; size = 12
$T232099 = -4						; size = 4
??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 1c		 push	 28			; 0000001cH
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 18	 mov	 BYTE PTR [ecx+24], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 19	 mov	 BYTE PTR [edx+25], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T232099[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T232207[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T232099[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T232207[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T232207[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  0006c	cc		 int	 3
??0?$map@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >::map<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> > >
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00014	c1 f8 03	 sar	 eax, 3
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@2:
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 03	 sar	 edx, 3
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve@2

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve@2
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve@2
$LN23@Reserve@2:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve@2:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve@2
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve@2:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
$LN1@Reserve@2:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve@2:
?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00014	c1 f8 03	 sar	 eax, 3
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@3:
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 03	 sar	 edx, 3
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve@3

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve@3
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve@3
$LN23@Reserve@3:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve@3:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve@3
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve@3:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
$LN1@Reserve@3:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve@3:
?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
_TEXT	ENDS
PUBLIC	??0_CHAOSCASTLE_DATA@@QAE@XZ			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA
; Function compile flags: /Ogtp
;	COMDAT ??0_CHAOSCASTLE_DATA@@QAE@XZ
_TEXT	SEGMENT
$T232547 = -16						; size = 12
$T232425 = -4						; size = 4
??0_CHAOSCASTLE_DATA@@QAE@XZ PROC			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0000d	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00012	33 db		 xor	 ebx, ebx
$LL5@CHAOSCASTL:
  00014	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0001a	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0001d	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00020	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  00023	88 58 10	 mov	 BYTE PTR [eax+16], bl
  00026	83 c0 14	 add	 eax, 20			; 00000014H
  00029	49		 dec	 ecx
  0002a	79 e8		 jns	 SHORT $LL5@CHAOSCASTL
  0002c	6a 1c		 push	 28			; 0000001cH
  0002e	89 9e 64 08 00
	00		 mov	 DWORD PTR [esi+2148], ebx
  00034	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00039	83 c4 04	 add	 esp, 4
  0003c	3b c3		 cmp	 eax, ebx
  0003e	74 36		 je	 SHORT $LN36@CHAOSCASTL
  00040	89 86 60 08 00
	00		 mov	 DWORD PTR [esi+2144], eax
  00046	89 00		 mov	 DWORD PTR [eax], eax
  00048	8b 86 60 08 00
	00		 mov	 eax, DWORD PTR [esi+2144]
  0004e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00051	8b 86 60 08 00
	00		 mov	 eax, DWORD PTR [esi+2144]
  00057	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0005a	8b 86 60 08 00
	00		 mov	 eax, DWORD PTR [esi+2144]
  00060	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1
  00064	8b 8e 60 08 00
	00		 mov	 ecx, DWORD PTR [esi+2144]
  0006a	8b c6		 mov	 eax, esi
  0006c	5e		 pop	 esi
  0006d	c6 41 19 01	 mov	 BYTE PTR [ecx+25], 1
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN36@CHAOSCASTL:
  00076	8d 55 fc	 lea	 edx, DWORD PTR $T232425[ebp]
  00079	52		 push	 edx
  0007a	8d 4d f0	 lea	 ecx, DWORD PTR $T232547[ebp]
  0007d	89 5d fc	 mov	 DWORD PTR $T232425[ebp], ebx
  00080	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00085	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0008a	8d 45 f0	 lea	 eax, DWORD PTR $T232547[ebp]
  0008d	50		 push	 eax
  0008e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T232547[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00095	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN63@CHAOSCASTL:
$LN62@CHAOSCASTL:
  0009a	cc		 int	 3
??0_CHAOSCASTLE_DATA@@QAE@XZ ENDP			; _CHAOSCASTLE_DATA::_CHAOSCASTLE_DATA
_TEXT	ENDS
PUBLIC	??1_CHAOSCASTLE_DATA@@QAE@XZ			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_CHAOSCASTLE_DATA@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_CHAOSCASTLE_DATA@@QAE@XZ$2
__ehfuncinfo$??1_CHAOSCASTLE_DATA@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_CHAOSCASTLE_DATA@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1_CHAOSCASTLE_DATA@@QAE@XZ
_TEXT	SEGMENT
$T232784 = -20						; size = 4
$T232814 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_CHAOSCASTLE_DATA@@QAE@XZ PROC			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_CHAOSCASTLE_DATA@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8d b1 5c 08 00
	00		 lea	 esi, DWORD PTR [ecx+2140]
  0002c	89 75 f0	 mov	 DWORD PTR $T232814[ebp], esi
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	50		 push	 eax
  00035	51		 push	 ecx
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T232784[ebp]
  00039	50		 push	 eax
  0003a	8b ce		 mov	 ecx, esi
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::erase
  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	83 c4 04	 add	 esp, 4
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5e		 pop	 esi
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_CHAOSCASTLE_DATA@@QAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T232814[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_MONSTER_ITEM_DROP@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_MONSTER_ITEM_DROP@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >::~_Tree_val<std::_Tmap_traits<int,_MONSTER_ITEM_DROP,std::less<int>,std::allocator<std::pair<int const ,_MONSTER_ITEM_DROP> >,0> >
__ehhandler$??1_CHAOSCASTLE_DATA@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_CHAOSCASTLE_DATA@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_CHAOSCASTLE_DATA@@QAE@XZ ENDP			; _CHAOSCASTLE_DATA::~_CHAOSCASTLE_DATA
PUBLIC	??_7CChaosCastle@@6B@				; CChaosCastle::`vftable'
PUBLIC	??1CChaosCastle@@UAE@XZ				; CChaosCastle::~CChaosCastle
PUBLIC	??_R4CChaosCastle@@6B@				; CChaosCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCChaosCastle@@@8			; CChaosCastle `RTTI Type Descriptor'
PUBLIC	??_R3CChaosCastle@@8				; CChaosCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CChaosCastle@@8				; CChaosCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CChaosCastle@@8			; CChaosCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??_ECChaosCastle@@UAEPAXI@Z:PROC		; CChaosCastle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CChaosCastle@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CChaosCastle@@8 DD FLAT:??_R0?AVCChaosCastle@@@8 ; CChaosCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CChaosCastle@@8
rdata$r	SEGMENT
??_R2CChaosCastle@@8 DD FLAT:??_R1A@?0A@EA@CChaosCastle@@8 ; CChaosCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CChaosCastle@@8
rdata$r	SEGMENT
??_R3CChaosCastle@@8 DD 00H				; CChaosCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCChaosCastle@@@8
_DATA	SEGMENT
??_R0?AVCChaosCastle@@@8 DD FLAT:??_7type_info@@6B@	; CChaosCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCChaosCastle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CChaosCastle@@6B@
rdata$r	SEGMENT
??_R4CChaosCastle@@6B@ DD 00H				; CChaosCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCChaosCastle@@@8
	DD	FLAT:??_R3CChaosCastle@@8
rdata$r	ENDS
;	COMDAT ??_7CChaosCastle@@6B@
CONST	SEGMENT
??_7CChaosCastle@@6B@ DD FLAT:??_R4CChaosCastle@@6B@	; CChaosCastle::`vftable'
	DD	FLAT:??_ECChaosCastle@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CChaosCastle@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CChaosCastle@@UAE@XZ$0
__ehfuncinfo$??1CChaosCastle@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CChaosCastle@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ??1CChaosCastle@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CChaosCastle@@UAE@XZ PROC				; CChaosCastle::~CChaosCastle, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CChaosCastle@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CChaosCastle@@6B@

; 58   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)
; 59   : 	{
; 60   : 	}
; 61   : }

  00030	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00035	6a 07		 push	 7
  00037	68 70 08 00 00	 push	 2160			; 00000870H
  0003c	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  0003f	33 ff		 xor	 edi, edi
  00041	50		 push	 eax
  00042	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0004d	3b c7		 cmp	 eax, edi
  0004f	74 09		 je	 SHORT $LN15@CChaosCast
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00057	83 c4 04	 add	 esp, 4
$LN15@CChaosCast:
  0005a	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  0005d	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00060	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CChaosCastle@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__ehhandler$??1CChaosCastle@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CChaosCastle@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CChaosCastle@@UAE@XZ ENDP				; CChaosCastle::~CChaosCastle
PUBLIC	?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z PROC ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back@2
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back@2:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@IAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXABUCHAOSCASTLE_START_TIME@@@Z ENDP ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z PROC ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back@3
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back@3:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@IAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ENDP ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	??0CChaosCastle@@QAE@XZ				; CChaosCastle::CChaosCastle
EXTRN	_srand:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
;	COMDAT __real@3f800000
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CChaosCastle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CChaosCastle@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CChaosCastle@@QAE@XZ$1
__ehfuncinfo$??0CChaosCastle@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CChaosCastle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ??0CChaosCastle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_i$218292 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CChaosCastle@@QAE@XZ PROC				; CChaosCastle::CChaosCastle, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CChaosCastle@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d ec	 mov	 DWORD PTR _this$[ebp], ebx
  0002d	33 f6		 xor	 esi, esi
  0002f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CChaosCastle@@6B@
  00035	89 73 20	 mov	 DWORD PTR [ebx+32], esi
  00038	89 73 24	 mov	 DWORD PTR [ebx+36], esi
  0003b	89 73 28	 mov	 DWORD PTR [ebx+40], esi
  0003e	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00043	68 00 00 00 00	 push	 OFFSET ??0_CHAOSCASTLE_DATA@@QAE@XZ
  00048	6a 07		 push	 7
  0004a	68 70 08 00 00	 push	 2160			; 00000870H
  0004f	8d 43 30	 lea	 eax, DWORD PTR [ebx+48]
  00052	50		 push	 eax
  00053	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00056	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z

; 32   : 	this->m_bCC_EVENT_ENABLE = FALSE;
; 33   : 	this->m_iCC_TIME_MIN_OPEN = 10;
; 34   : 	this->m_iCC_NORMAL_ITEM_DROP = 100;
; 35   : 	this->m_iCC_EXCEL_ITEM_DROP = 1200;
; 36   : 	this->m_iCC_MONSTER_REGEN = 0;
; 37   : 
; 38   : 	for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  0005b	33 d2		 xor	 edx, edx
  0005d	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00060	89 73 1c	 mov	 DWORD PTR [ebx+28], esi
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	c7 43 08 0a 00
	00 00		 mov	 DWORD PTR [ebx+8], 10	; 0000000aH
  0006e	c7 43 14 64 00
	00 00		 mov	 DWORD PTR [ebx+20], 100	; 00000064H
  00075	c7 43 18 b0 04
	00 00		 mov	 DWORD PTR [ebx+24], 1200 ; 000004b0H
  0007c	89 55 f0	 mov	 DWORD PTR _i$218292[ebp], edx
  0007f	8d 7b 34	 lea	 edi, DWORD PTR [ebx+52]
  00082	8d b3 45 3b 00
	00		 lea	 esi, DWORD PTR [ebx+15173]
  00088	eb 09		 jmp	 SHORT $LN3@CChaosCast@2
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL22@CChaosCast@2:

; 31   : {

  00090	8b 55 f0	 mov	 edx, DWORD PTR _i$218292[ebp]
$LN3@CChaosCast@2:

; 39   : 	{
; 40   : 		this->m_stChaosCastleData[i].m_iCC_STATE = CC_STATE_NONE;
; 41   : 		this->m_stChaosCastleData[i].m_iMapNumber = this->GetChaosCastleMapNumber(i);

  00093	52		 push	 edx
  00094	8b cb		 mov	 ecx, ebx
  00096	c7 47 fc 00 00
	00 00		 mov	 DWORD PTR [edi-4], 0
  0009d	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber

; 42   : 		this->m_stChaosCastleData[i].m_iChaosCastleIndex = i;
; 43   : 		this->m_stChaosCastleData[i].m_iCC_REMAIN_MSEC = -1;
; 44   : 		this->m_stChaosCastleData[i].m_iCC_TICK_COUNT = -1;
; 45   : 		this->m_stChaosCastleData[i].m_iCC_REWARD_EXP = 1.0f; //season 4.5 add-on

  000a2	d9 e8		 fld1
  000a4	89 07		 mov	 DWORD PTR [edi], eax
  000a6	d9 9f 68 08 00
	00		 fstp	 DWORD PTR [edi+2152]
  000ac	83 c8 ff	 or	 eax, -1

; 46   : 		this->ClearChaosCastleData(i);

  000af	52		 push	 edx
  000b0	8b cb		 mov	 ecx, ebx
  000b2	89 57 04	 mov	 DWORD PTR [edi+4], edx
  000b5	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  000b8	89 47 10	 mov	 DWORD PTR [edi+16], eax
  000bb	e8 00 00 00 00	 call	 ?ClearChaosCastleData@CChaosCastle@@IAEXH@Z ; CChaosCastle::ClearChaosCastleData
  000c0	8b 45 f0	 mov	 eax, DWORD PTR _i$218292[ebp]
  000c3	40		 inc	 eax

; 47   : 
; 48   : #ifdef _CONFLICT_
; 49   : 		this->m_RewardData[i].Clear();

  000c4	c7 46 fb 00 00
	00 00		 mov	 DWORD PTR [esi-5], 0
  000cb	c7 46 ff 00 00
	ff ff		 mov	 DWORD PTR [esi-1], -65536 ; ffff0000H
  000d2	c7 46 03 ff ff
	00 00		 mov	 DWORD PTR [esi+3], 65535 ; 0000ffffH
  000d9	83 c6 0c	 add	 esi, 12			; 0000000cH
  000dc	81 c7 70 08 00
	00		 add	 edi, 2160		; 00000870H
  000e2	89 45 f0	 mov	 DWORD PTR _i$218292[ebp], eax
  000e5	83 f8 07	 cmp	 eax, 7
  000e8	7c a6		 jl	 SHORT $LL22@CChaosCast@2

; 50   : #endif
; 51   : 	}
; 52   : 
; 53   : 	srand(time(NULL));

  000ea	6a 00		 push	 0
  000ec	e8 00 00 00 00	 call	 __time64
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _srand
  000f7	83 c4 08	 add	 esp, 8

; 54   : }

  000fa	8b c3		 mov	 eax, ebx
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00106	59		 pop	 ecx
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CChaosCastle@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAE@XZ ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::~vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >
__unwindfunclet$??0CChaosCastle@@QAE@XZ$1:
  0000b	68 00 00 00 00	 push	 OFFSET ??1_CHAOSCASTLE_DATA@@QAE@XZ
  00010	6a 07		 push	 7
  00012	68 70 08 00 00	 push	 2160			; 00000870H
  00017	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 c0 30	 add	 eax, 48			; 00000030H
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00023	c3		 ret	 0
__ehhandler$??0CChaosCastle@@QAE@XZ:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CChaosCastle@@QAE@XZ
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CChaosCastle@@QAE@XZ ENDP				; CChaosCastle::CChaosCastle
; Function compile flags: /Ogtp
;	COMDAT ??_GCChaosCastle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCChaosCastle@@UAEPAXI@Z PROC			; CChaosCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CChaosCastle@@UAE@XZ	; CChaosCastle::~CChaosCastle
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCChaosCastle@@UAEPAXI@Z ENDP			; CChaosCastle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CChaosCastle@@QAEXPAD@Z			; CChaosCastle::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@ DB '[Chao'
	DB	's Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
CONST	ENDS
;	COMDAT ?Load@CChaosCastle@@QAEXPAD@Z
_TEXT	SEGMENT
_Schedule$218508 = -24					; size = 8
tv814 = -16						; size = 4
tv812 = -16						; size = 4
tv805 = -16						; size = 4
tv803 = -16						; size = 4
tv797 = -16						; size = 4
tv795 = -16						; size = 4
tv789 = -16						; size = 4
tv787 = -16						; size = 4
tv780 = -16						; size = 4
tv778 = -16						; size = 4
_this$ = -12						; size = 4
_type$ = -8						; size = 4
tv817 = -2						; size = 2
tv809 = -2						; size = 2
tv800 = -2						; size = 2
tv792 = -2						; size = 2
tv784 = -2						; size = 2
_filename$ = 8						; size = 4
?Load@CChaosCastle@@QAEXPAD@Z PROC			; CChaosCastle::Load, COMDAT
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 152  : 	SMDFile = fopen(filename, "r");

  00008	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00012	56		 push	 esi
  00013	89 5d f4	 mov	 DWORD PTR _this$[ebp], ebx
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 153  : 
; 154  : 	if ( SMDFile == NULL )

  00023	85 c0		 test	 eax, eax
  00025	75 16		 jne	 SHORT $LN25@Load

; 155  : 	{
; 156  : 		MsgBox("[Chaos Castle] Info file Load Fail [%s]", filename);

  00027	56		 push	 esi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HJPKEJEN@?$FLChaos?5Castle?$FN?5Info?5file?5Load?5Fa@
  0002d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00032	83 c4 08	 add	 esp, 8
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 302  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN25@Load:

; 157  : 		return;
; 158  : 	}
; 159  : 
; 160  : 	int Token;
; 161  : 	int type = -1;
; 162  : 	int iChaosCastleCount = -1;
; 163  : 
; 164  : 	this->m_vtChaosCastleOpenTime.erase( this->m_vtChaosCastleOpenTime.begin(), this->m_vtChaosCastleOpenTime.end());

  0003d	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  00040	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00043	57		 push	 edi
  00044	8d 7b 20	 lea	 edi, DWORD PTR [ebx+32]
  00047	3b c8		 cmp	 ecx, eax
  00049	74 1e		 je	 SHORT $LN168@Load
  0004b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004e	3b c2		 cmp	 eax, edx
  00050	74 14		 je	 SHORT $LN75@Load
$LL77@Load:
  00052	8b 30		 mov	 esi, DWORD PTR [eax]
  00054	89 31		 mov	 DWORD PTR [ecx], esi
  00056	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00059	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0005c	83 c0 08	 add	 eax, 8
  0005f	83 c1 08	 add	 ecx, 8
  00062	3b c2		 cmp	 eax, edx
  00064	75 ec		 jne	 SHORT $LL77@Load
$LN75@Load:
  00066	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN168@Load:

; 165  : 
; 166  : 	while ( true )
; 167  : 	{
; 168  : 		Token = GetToken();

  00069	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 169  : 
; 170  : 		if ( Token == 2 )

  0006e	83 f8 02	 cmp	 eax, 2
  00071	0f 84 cb 04 00
	00		 je	 $LN179@Load
  00077	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL24@Load:

; 171  : 		{
; 172  : 			break;
; 173  : 		}
; 174  : 
; 175  : 		type = (int)TokenNumber;

  00080	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00086	e8 00 00 00 00	 call	 __ftol2_sse
  0008b	8b f0		 mov	 esi, eax
  0008d	89 75 f8	 mov	 DWORD PTR _type$[ebp], esi
$LL21@Load:

; 176  : 
; 177  : 		while ( true )
; 178  : 		{
; 179  : 			if ( type == 0 )	// Time Setting

  00090	85 f6		 test	 esi, esi
  00092	75 72		 jne	 SHORT $LN19@Load

; 180  : 			{
; 181  : 				Token = GetToken();

  00094	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 182  : 
; 183  : 				if ( strcmp("end", TokenString) == 0 )

  00099	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0009e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL182@Load:
  000a3	8a 10		 mov	 dl, BYTE PTR [eax]
  000a5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000a7	75 1a		 jne	 SHORT $LN183@Load
  000a9	84 d2		 test	 dl, dl
  000ab	74 12		 je	 SHORT $LN184@Load
  000ad	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b3	75 0e		 jne	 SHORT $LN183@Load
  000b5	83 c0 02	 add	 eax, 2
  000b8	83 c1 02	 add	 ecx, 2
  000bb	84 d2		 test	 dl, dl
  000bd	75 e4		 jne	 SHORT $LL182@Load
$LN184@Load:
  000bf	33 c0		 xor	 eax, eax
  000c1	eb 05		 jmp	 SHORT $LN185@Load
$LN183@Load:
  000c3	1b c0		 sbb	 eax, eax
  000c5	83 d8 ff	 sbb	 eax, -1
$LN185@Load:
  000c8	85 c0		 test	 eax, eax
  000ca	0f 84 64 04 00
	00		 je	 $LN206@Load

; 184  : 				{
; 185  : 					break;
; 186  : 				}
; 187  : 
; 188  : 				this->m_iCC_TIME_MIN_OPEN = (int)TokenNumber;

  000d0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000d6	e8 00 00 00 00	 call	 __ftol2_sse
  000db	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 189  : 
; 190  : 				Token = GetToken();

  000de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 191  : 				this->m_iCC_TIME_MIN_PLAY = (int)TokenNumber;

  000e3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e9	e8 00 00 00 00	 call	 __ftol2_sse
  000ee	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 192  : 
; 193  : 				Token = GetToken();

  000f1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 194  : 				this->m_iCC_TIME_MIN_REST = (int)TokenNumber;

  000f6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000fc	e8 00 00 00 00	 call	 __ftol2_sse
  00101	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00104	eb 8a		 jmp	 SHORT $LL21@Load
$LN19@Load:

; 195  : 			}
; 196  : 			else if ( type == 1 ) // Drops

  00106	83 fe 01	 cmp	 esi, 1
  00109	75 7b		 jne	 SHORT $LN16@Load

; 197  : 			{
; 198  : 				Token = GetToken();

  0010b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 199  : 
; 200  : 				if ( strcmp("end", TokenString) == 0 )

  00110	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00115	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0011a	8d 9b 00 00 00
	00		 npad	 6
$LL186@Load:
  00120	8a 10		 mov	 dl, BYTE PTR [eax]
  00122	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00124	75 1a		 jne	 SHORT $LN187@Load
  00126	84 d2		 test	 dl, dl
  00128	74 12		 je	 SHORT $LN188@Load
  0012a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0012d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00130	75 0e		 jne	 SHORT $LN187@Load
  00132	83 c0 02	 add	 eax, 2
  00135	83 c1 02	 add	 ecx, 2
  00138	84 d2		 test	 dl, dl
  0013a	75 e4		 jne	 SHORT $LL186@Load
$LN188@Load:
  0013c	33 c0		 xor	 eax, eax
  0013e	eb 05		 jmp	 SHORT $LN189@Load
$LN187@Load:
  00140	1b c0		 sbb	 eax, eax
  00142	83 d8 ff	 sbb	 eax, -1
$LN189@Load:
  00145	85 c0		 test	 eax, eax
  00147	0f 84 e7 03 00
	00		 je	 $LN206@Load

; 201  : 				{
; 202  : 					break;
; 203  : 				}
; 204  : 
; 205  : 				this->m_iCC_NORMAL_ITEM_DROP = (int)TokenNumber;

  0014d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00153	e8 00 00 00 00	 call	 __ftol2_sse
  00158	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 206  : 
; 207  : 				Token = GetToken();

  0015b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 208  : 				this->m_iCC_EXCEL_ITEM_DROP = (int)TokenNumber;

  00160	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00166	e8 00 00 00 00	 call	 __ftol2_sse
  0016b	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 209  : 
; 210  : 				Token = GetToken();

  0016e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 211  : 				this->m_iCC_MONSTER_REGEN = (int)TokenNumber;

  00173	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00179	e8 00 00 00 00	 call	 __ftol2_sse
  0017e	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00181	e9 0a ff ff ff	 jmp	 $LL21@Load
$LN16@Load:

; 212  : 			}
; 213  : 			else if ( type == 2 ) // Schedule

  00186	83 fe 02	 cmp	 esi, 2
  00189	0f 85 45 01 00
	00		 jne	 $LN13@Load

; 214  : 			{
; 215  : 				Token = GetToken();

  0018f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 216  : 
; 217  : 				if ( strcmp("end", TokenString) == 0 )

  00194	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00199	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0019e	8b ff		 npad	 2
$LL190@Load:
  001a0	8a 10		 mov	 dl, BYTE PTR [eax]
  001a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001a4	75 1a		 jne	 SHORT $LN191@Load
  001a6	84 d2		 test	 dl, dl
  001a8	74 12		 je	 SHORT $LN192@Load
  001aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001b0	75 0e		 jne	 SHORT $LN191@Load
  001b2	83 c0 02	 add	 eax, 2
  001b5	83 c1 02	 add	 ecx, 2
  001b8	84 d2		 test	 dl, dl
  001ba	75 e4		 jne	 SHORT $LL190@Load
$LN192@Load:
  001bc	33 c0		 xor	 eax, eax
  001be	eb 05		 jmp	 SHORT $LN193@Load
$LN191@Load:
  001c0	1b c0		 sbb	 eax, eax
  001c2	83 d8 ff	 sbb	 eax, -1
$LN193@Load:
  001c5	85 c0		 test	 eax, eax
  001c7	0f 84 67 03 00
	00		 je	 $LN206@Load

; 218  : 				{
; 219  : 					break;
; 220  : 				}
; 221  : 				
; 222  : 				CHAOSCASTLE_START_TIME Schedule;
; 223  : 
; 224  : 				Schedule.m_iHour = (int)TokenNumber;

  001cd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d3	e8 00 00 00 00	 call	 __ftol2_sse
  001d8	89 45 e8	 mov	 DWORD PTR _Schedule$218508[ebp], eax

; 225  : 
; 226  : 				Token = GetToken();

  001db	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 227  : 				Schedule.m_iMinute = (int)TokenNumber;

  001e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e6	e8 00 00 00 00	 call	 __ftol2_sse
  001eb	89 45 ec	 mov	 DWORD PTR _Schedule$218508[ebp+4], eax

; 228  : 
; 229  : 				this->m_vtChaosCastleOpenTime.push_back(Schedule);

  001ee	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001f1	8d 4d e8	 lea	 ecx, DWORD PTR _Schedule$218508[ebp]
  001f4	3b c8		 cmp	 ecx, eax
  001f6	73 76		 jae	 SHORT $LN85@Load
  001f8	8b 17		 mov	 edx, DWORD PTR [edi]
  001fa	3b d1		 cmp	 edx, ecx
  001fc	77 70		 ja	 SHORT $LN85@Load
  001fe	8b f1		 mov	 esi, ecx
  00200	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00203	2b f2		 sub	 esi, edx
  00205	c1 fe 03	 sar	 esi, 3
  00208	3b c1		 cmp	 eax, ecx
  0020a	75 40		 jne	 SHORT $LN96@Load
  0020c	2b c2		 sub	 eax, edx
  0020e	c1 f8 03	 sar	 eax, 3
  00211	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00216	0f 87 4d 03 00
	00		 ja	 $LN174@Load
  0021c	2b ca		 sub	 ecx, edx
  0021e	40		 inc	 eax
  0021f	c1 f9 03	 sar	 ecx, 3
  00222	3b c1		 cmp	 eax, ecx
  00224	76 26		 jbe	 SHORT $LN96@Load
  00226	8b d1		 mov	 edx, ecx
  00228	d1 ea		 shr	 edx, 1
  0022a	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  0022f	2b da		 sub	 ebx, edx
  00231	3b d9		 cmp	 ebx, ecx
  00233	73 04		 jae	 SHORT $LN118@Load
  00235	33 c9		 xor	 ecx, ecx
  00237	eb 02		 jmp	 SHORT $LN119@Load
$LN118@Load:
  00239	03 ca		 add	 ecx, edx
$LN119@Load:
  0023b	3b c8		 cmp	 ecx, eax
  0023d	73 02		 jae	 SHORT $LN115@Load
  0023f	8b c8		 mov	 ecx, eax
$LN115@Load:
  00241	51		 push	 ecx
  00242	8b cf		 mov	 ecx, edi
  00244	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
  00249	8b 5d f4	 mov	 ebx, DWORD PTR _this$[ebp]
$LN96@Load:
  0024c	8b 17		 mov	 edx, DWORD PTR [edi]
  0024e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00251	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  00254	50		 push	 eax
  00255	51		 push	 ecx
  00256	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@AAU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@AAU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME &>
  0025f	8b 75 f8	 mov	 esi, DWORD PTR _type$[ebp]
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH
  00265	83 47 04 08	 add	 DWORD PTR [edi+4], 8
  00269	e9 22 fe ff ff	 jmp	 $LL21@Load
$LN85@Load:
  0026e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00271	3b c1		 cmp	 eax, ecx
  00273	75 42		 jne	 SHORT $LN131@Load
  00275	8b 17		 mov	 edx, DWORD PTR [edi]
  00277	2b c2		 sub	 eax, edx
  00279	c1 f8 03	 sar	 eax, 3
  0027c	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00281	0f 87 e2 02 00
	00		 ja	 $LN174@Load
  00287	2b ca		 sub	 ecx, edx
  00289	40		 inc	 eax
  0028a	c1 f9 03	 sar	 ecx, 3
  0028d	3b c1		 cmp	 eax, ecx
  0028f	76 26		 jbe	 SHORT $LN131@Load
  00291	8b d1		 mov	 edx, ecx
  00293	d1 ea		 shr	 edx, 1
  00295	be ff ff ff 1f	 mov	 esi, 536870911		; 1fffffffH
  0029a	2b f2		 sub	 esi, edx
  0029c	3b f1		 cmp	 esi, ecx
  0029e	73 04		 jae	 SHORT $LN153@Load
  002a0	33 c9		 xor	 ecx, ecx
  002a2	eb 02		 jmp	 SHORT $LN154@Load
$LN153@Load:
  002a4	03 ca		 add	 ecx, edx
$LN154@Load:
  002a6	3b c8		 cmp	 ecx, eax
  002a8	73 02		 jae	 SHORT $LN150@Load
  002aa	8b c8		 mov	 ecx, eax
$LN150@Load:
  002ac	51		 push	 ecx
  002ad	8b cf		 mov	 ecx, edi
  002af	e8 00 00 00 00	 call	 ?reserve@?$vector@UCHAOSCASTLE_START_TIME@@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::vector<CHAOSCASTLE_START_TIME,std::allocator<CHAOSCASTLE_START_TIME> >::reserve
  002b4	8b 75 f8	 mov	 esi, DWORD PTR _type$[ebp]
$LN131@Load:
  002b7	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  002ba	8d 45 e8	 lea	 eax, DWORD PTR _Schedule$218508[ebp]
  002bd	50		 push	 eax
  002be	51		 push	 ecx
  002bf	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  002c2	52		 push	 edx
  002c3	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UCHAOSCASTLE_START_TIME@@@std@@UCHAOSCASTLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UCHAOSCASTLE_START_TIME@@@0@PAUCHAOSCASTLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<CHAOSCASTLE_START_TIME>,CHAOSCASTLE_START_TIME,CHAOSCASTLE_START_TIME const &>
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002cb	83 47 04 08	 add	 DWORD PTR [edi+4], 8
  002cf	e9 bc fd ff ff	 jmp	 $LL21@Load
$LN13@Load:

; 230  : 			}
; 231  : 			else if ( type == 3 ) // ItemDropProb

  002d4	83 fe 03	 cmp	 esi, 3
  002d7	75 6d		 jne	 SHORT $LN10@Load

; 232  : 			{
; 233  : 				Token = GetToken();

  002d9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 234  : 
; 235  : 				if ( strcmp("end", TokenString) == 0 )

  002de	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  002e3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL194@Load:
  002e8	8a 10		 mov	 dl, BYTE PTR [eax]
  002ea	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002ec	75 1a		 jne	 SHORT $LN195@Load
  002ee	84 d2		 test	 dl, dl
  002f0	74 12		 je	 SHORT $LN196@Load
  002f2	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002f5	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002f8	75 0e		 jne	 SHORT $LN195@Load
  002fa	83 c0 02	 add	 eax, 2
  002fd	83 c1 02	 add	 ecx, 2
  00300	84 d2		 test	 dl, dl
  00302	75 e4		 jne	 SHORT $LL194@Load
$LN196@Load:
  00304	33 c0		 xor	 eax, eax
  00306	eb 05		 jmp	 SHORT $LN197@Load
$LN195@Load:
  00308	1b c0		 sbb	 eax, eax
  0030a	83 d8 ff	 sbb	 eax, -1
$LN197@Load:
  0030d	85 c0		 test	 eax, eax
  0030f	0f 84 1f 02 00
	00		 je	 $LN206@Load

; 236  : 				{
; 237  : 					break;
; 238  : 				}
; 239  : 		
; 240  : 				g_iChaosCastle_OffLineGiftRate = (int)TokenNumber;

  00315	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0031b	e8 00 00 00 00	 call	 __ftol2_sse
  00320	8b c8		 mov	 ecx, eax

; 241  : 				g_iChaosCastle_OffLineGiftRate %= 10000;

  00322	b8 53 74 24 97	 mov	 eax, -1759218605	; 97247453H
  00327	f7 e9		 imul	 ecx
  00329	c1 fa 0c	 sar	 edx, 12			; 0000000cH
  0032c	8b c2		 mov	 eax, edx
  0032e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00331	03 c2		 add	 eax, edx
  00333	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  00339	03 c8		 add	 ecx, eax
  0033b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_iChaosCastle_OffLineGiftRate@@3HA, ecx ; g_iChaosCastle_OffLineGiftRate
  00341	e9 4a fd ff ff	 jmp	 $LL21@Load
$LN10@Load:

; 242  : 			}
; 243  : 			//Season 4.5 add-on
; 244  : 			else if ( type == 4 )

  00346	83 fe 04	 cmp	 esi, 4
  00349	0f 85 88 00 00
	00		 jne	 $LN7@Load

; 245  : 			{
; 246  : 				Token = GetToken();

  0034f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 247  : 
; 248  : 				if (strcmp("end", TokenString) == 0)

  00354	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00359	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0035e	8b ff		 npad	 2
$LL198@Load:
  00360	8a 10		 mov	 dl, BYTE PTR [eax]
  00362	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00364	75 1a		 jne	 SHORT $LN199@Load
  00366	84 d2		 test	 dl, dl
  00368	74 12		 je	 SHORT $LN200@Load
  0036a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0036d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00370	75 0e		 jne	 SHORT $LN199@Load
  00372	83 c0 02	 add	 eax, 2
  00375	83 c1 02	 add	 ecx, 2
  00378	84 d2		 test	 dl, dl
  0037a	75 e4		 jne	 SHORT $LL198@Load
$LN200@Load:
  0037c	33 c0		 xor	 eax, eax
  0037e	eb 05		 jmp	 SHORT $LN201@Load
$LN199@Load:
  00380	1b c0		 sbb	 eax, eax
  00382	83 d8 ff	 sbb	 eax, -1
$LN201@Load:
  00385	85 c0		 test	 eax, eax
  00387	0f 84 a7 01 00
	00		 je	 $LN206@Load

; 249  : 				{
; 250  : 					break;
; 251  : 				}
; 252  : 			
; 253  : 				int iChaosCastleIndex = (int)TokenNumber;

  0038d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00393	e8 00 00 00 00	 call	 __ftol2_sse
  00398	8b f0		 mov	 esi, eax

; 254  : 
; 255  : 				if ( CC_FLOOR_RANGE(iChaosCastleIndex) != FALSE )

  0039a	85 f6		 test	 esi, esi
  0039c	78 2c		 js	 SHORT $LN5@Load
  0039e	33 c0		 xor	 eax, eax
  003a0	83 fe 06	 cmp	 esi, 6
  003a3	0f 9e c0	 setle	 al
  003a6	85 c0		 test	 eax, eax
  003a8	74 20		 je	 SHORT $LN5@Load

; 256  : 				{
; 257  : 					Token = GetToken();

  003aa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 258  : 					this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REWARD_EXP = TokenNumber;

  003af	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003b5	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  003bb	d9 9c 1e 9c 08
	00 00		 fstp	 DWORD PTR [esi+ebx+2204]

; 259  : 				}
; 260  : 				else

  003c2	8b 75 f8	 mov	 esi, DWORD PTR _type$[ebp]
  003c5	e9 c6 fc ff ff	 jmp	 $LL21@Load
$LN5@Load:

; 261  : 				{
; 262  : 					Token = GetToken();

  003ca	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 263  : 				}

  003cf	8b 75 f8	 mov	 esi, DWORD PTR _type$[ebp]
  003d2	e9 b9 fc ff ff	 jmp	 $LL21@Load
$LN7@Load:

; 264  : 			}
; 265  : #ifdef _CONFLICT_
; 266  : 			else if( type == 5 )

  003d7	83 fe 05	 cmp	 esi, 5
  003da	0f 85 b0 fc ff
	ff		 jne	 $LL21@Load

; 267  : 			{
; 268  : 				Token = GetToken();

  003e0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 269  : 				// ----
; 270  : 				if (strcmp("end", TokenString) == 0)

  003e5	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  003ea	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  003ef	90		 npad	 1
$LL202@Load:
  003f0	8a 10		 mov	 dl, BYTE PTR [eax]
  003f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  003f4	75 1a		 jne	 SHORT $LN203@Load
  003f6	84 d2		 test	 dl, dl
  003f8	74 12		 je	 SHORT $LN204@Load
  003fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  003fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00400	75 0e		 jne	 SHORT $LN203@Load
  00402	83 c0 02	 add	 eax, 2
  00405	83 c1 02	 add	 ecx, 2
  00408	84 d2		 test	 dl, dl
  0040a	75 e4		 jne	 SHORT $LL202@Load
$LN204@Load:
  0040c	33 c0		 xor	 eax, eax
  0040e	eb 05		 jmp	 SHORT $LN205@Load
$LN203@Load:
  00410	1b c0		 sbb	 eax, eax
  00412	83 d8 ff	 sbb	 eax, -1
$LN205@Load:
  00415	85 c0		 test	 eax, eax
  00417	0f 84 17 01 00
	00		 je	 $LN206@Load

; 271  : 				{
; 272  : 					break;
; 273  : 				}
; 274  : 				// ----
; 275  : 				int CastleLevel = TokenNumber;

  0041d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00423	e8 00 00 00 00	 call	 __ftol2_sse
  00428	8b f0		 mov	 esi, eax

; 276  : 				// ----
; 277  : 				Token = GetToken();

  0042a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 278  : 				this->m_RewardData[CastleLevel].AncientRate		= TokenNumber;

  0042f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00435	e8 00 00 00 00	 call	 __ftol2_sse
  0043a	8d 8c 76 d0 0e
	00 00		 lea	 ecx, DWORD PTR [esi+esi*2+3792]
  00441	89 04 8b	 mov	 DWORD PTR [ebx+ecx*4], eax

; 279  : 				// ----
; 280  : 				Token = GetToken();

  00444	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 281  : 				this->m_RewardData[CastleLevel].AncientCount	= TokenNumber;

  00449	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0044f	d9 7d fe	 fnstcw	 WORD PTR tv817[ebp]
  00452	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00455	0f b7 45 fe	 movzx	 eax, WORD PTR tv817[ebp]
  00459	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0045e	89 45 f0	 mov	 DWORD PTR tv814[ebp], eax
  00461	8d 34 93	 lea	 esi, DWORD PTR [ebx+edx*4]
  00464	d9 6d f0	 fldcw	 WORD PTR tv814[ebp]
  00467	db 5d f0	 fistp	 DWORD PTR tv812[ebp]
  0046a	8a 45 f0	 mov	 al, BYTE PTR tv812[ebp]
  0046d	88 86 44 3b 00
	00		 mov	 BYTE PTR [esi+15172], al
  00473	d9 6d fe	 fldcw	 WORD PTR tv817[ebp]

; 282  : 				// ----
; 283  : 				Token = GetToken();

  00476	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 284  : 				this->m_RewardData[CastleLevel].ItemCount		= TokenNumber;

  0047b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00481	d9 7d fe	 fnstcw	 WORD PTR tv809[ebp]
  00484	0f b7 45 fe	 movzx	 eax, WORD PTR tv809[ebp]
  00488	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0048d	89 45 f0	 mov	 DWORD PTR tv805[ebp], eax
  00490	d9 6d f0	 fldcw	 WORD PTR tv805[ebp]
  00493	db 5d f0	 fistp	 DWORD PTR tv803[ebp]
  00496	8a 4d f0	 mov	 cl, BYTE PTR tv803[ebp]
  00499	88 8e 45 3b 00
	00		 mov	 BYTE PTR [esi+15173], cl
  0049f	d9 6d fe	 fldcw	 WORD PTR tv809[ebp]

; 285  : 				// ----
; 286  : 				Token = GetToken();

  004a2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 287  : 				this->m_RewardData[CastleLevel].ItemID			= TokenNumber;

  004a7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004ad	d9 7d fe	 fnstcw	 WORD PTR tv800[ebp]
  004b0	0f b7 45 fe	 movzx	 eax, WORD PTR tv800[ebp]
  004b4	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004b9	89 45 f0	 mov	 DWORD PTR tv797[ebp], eax
  004bc	d9 6d f0	 fldcw	 WORD PTR tv797[ebp]
  004bf	db 5d f0	 fistp	 DWORD PTR tv795[ebp]
  004c2	66 8b 55 f0	 mov	 dx, WORD PTR tv795[ebp]
  004c6	66 89 96 46 3b
	00 00		 mov	 WORD PTR [esi+15174], dx
  004cd	d9 6d fe	 fldcw	 WORD PTR tv800[ebp]

; 288  : 				// ----
; 289  : 				Token = GetToken();

  004d0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 290  : 				this->m_RewardData[CastleLevel].ItemIndex		= TokenNumber;

  004d5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004db	d9 7d fe	 fnstcw	 WORD PTR tv792[ebp]
  004de	0f b7 45 fe	 movzx	 eax, WORD PTR tv792[ebp]
  004e2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004e7	89 45 f0	 mov	 DWORD PTR tv789[ebp], eax
  004ea	d9 6d f0	 fldcw	 WORD PTR tv789[ebp]
  004ed	db 5d f0	 fistp	 DWORD PTR tv787[ebp]
  004f0	66 8b 45 f0	 mov	 ax, WORD PTR tv787[ebp]
  004f4	66 89 86 48 3b
	00 00		 mov	 WORD PTR [esi+15176], ax
  004fb	d9 6d fe	 fldcw	 WORD PTR tv792[ebp]

; 291  : 				// ----
; 292  : 				Token = GetToken();

  004fe	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 293  : 				this->m_RewardData[CastleLevel].ItemLevel		= TokenNumber;

  00503	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00509	d9 7d fe	 fnstcw	 WORD PTR tv784[ebp]
  0050c	0f b7 45 fe	 movzx	 eax, WORD PTR tv784[ebp]
  00510	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00515	89 45 f0	 mov	 DWORD PTR tv780[ebp], eax
  00518	d9 6d f0	 fldcw	 WORD PTR tv780[ebp]
  0051b	db 5d f0	 fistp	 DWORD PTR tv778[ebp]
  0051e	66 8b 4d f0	 mov	 cx, WORD PTR tv778[ebp]
  00522	66 89 8e 4a 3b
	00 00		 mov	 WORD PTR [esi+15178], cx

; 294  : 			}
; 295  : #endif
; 296  : 		}

  00529	8b 75 f8	 mov	 esi, DWORD PTR _type$[ebp]
  0052c	d9 6d fe	 fldcw	 WORD PTR tv784[ebp]
  0052f	e9 5c fb ff ff	 jmp	 $LL21@Load
$LN206@Load:

; 165  : 
; 166  : 	while ( true )
; 167  : 	{
; 168  : 		Token = GetToken();

  00534	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 169  : 
; 170  : 		if ( Token == 2 )

  00539	83 f8 02	 cmp	 eax, 2
  0053c	0f 85 3e fb ff
	ff		 jne	 $LL24@Load
$LN179@Load:

; 297  : 	}
; 298  : 
; 299  : 	fclose(SMDFile);

  00542	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  00548	52		 push	 edx
  00549	e8 00 00 00 00	 call	 _fclose

; 300  : 
; 301  : 	LogAdd("%s file load!", filename);

  0054e	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00551	50		 push	 eax
  00552	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00557	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0055d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00560	5f		 pop	 edi
  00561	5e		 pop	 esi
  00562	5b		 pop	 ebx

; 302  : }

  00563	8b e5		 mov	 esp, ebp
  00565	5d		 pop	 ebp
  00566	c2 04 00	 ret	 4
$LN174@Load:

; 228  : 
; 229  : 				this->m_vtChaosCastleOpenTime.push_back(Schedule);

  00569	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0056e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN208@Load:
$LN207@Load:
  00573	cc		 int	 3
?Load@CChaosCastle@@QAEXPAD@Z ENDP			; CChaosCastle::Load
_TEXT	ENDS
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z	; CChaosCastle::PullObjInnerPlace
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z$0
__ehfuncinfo$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iPT$219069 = -112					; size = 8
tv1681 = -108						; size = 4
_iUSER_AXIS$ = -104					; size = 4
tv1678 = -100						; size = 4
tv696 = -100						; size = 4
_iChaosCastleIndex$GSCopy$ = -96			; size = 4
tv1563 = -92						; size = 4
tv793 = -92						; size = 4
tv162 = -92						; size = 4
_this$GSCopy$ = -88					; size = 4
_vtMAP_UNTRAP$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
_iTRAP_STEP$ = 12					; size = 4
?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z PROC		; CChaosCastle::PullObjInnerPlace, COMDAT
; _this$ = ecx

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]

; 697  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0002e	33 ff		 xor	 edi, edi
  00030	89 4d a8	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 710  : 	{
; 711  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  00033	89 75 a0	 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], esi
  00036	3b f7		 cmp	 esi, edi
  00038	0f 8c ea 03 00
	00		 jl	 $LN47@PullObjInn

; 697  : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003e	33 c0		 xor	 eax, eax
  00040	83 fe 06	 cmp	 esi, 6
  00043	0f 9e c0	 setle	 al
  00046	3b c7		 cmp	 eax, edi
  00048	0f 84 da 03 00
	00		 je	 $LN47@PullObjInn

; 698  : 		return;
; 699  : 
; 700  : 	if ( CC_TRAP_STEP_RANGE(iTRAP_STEP) == FALSE )

  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _iTRAP_STEP$[ebp]
  00051	3b cf		 cmp	 ecx, edi
  00053	0f 8c cf 03 00
	00		 jl	 $LN47@PullObjInn
  00059	33 c0		 xor	 eax, eax
  0005b	83 f9 03	 cmp	 ecx, 3
  0005e	0f 9e c0	 setle	 al
  00061	3b c7		 cmp	 eax, edi
  00063	0f 84 bf 03 00
	00		 je	 $LN47@PullObjInn

; 701  : 		return;
; 702  : 
; 703  : 	if ( iTRAP_STEP == 0 )

  00069	3b cf		 cmp	 ecx, edi
  0006b	0f 84 b7 03 00
	00		 je	 $LN47@PullObjInn

; 704  : 		return;
; 705  : 
; 706  : 	int iUSER_AXIS = 0;
; 707  : 	std::vector<POINT> vtMAP_UNTRAP[MAX_CC_TRAP_STEP];

  00071	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00076	68 00 00 00 00	 push	 OFFSET ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
  0007b	6a 04		 push	 4
  0007d	6a 10		 push	 16			; 00000010H
  0007f	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  00082	50		 push	 eax
  00083	89 7d 98	 mov	 DWORD PTR _iUSER_AXIS$[ebp], edi
  00086	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0008b	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0008e	8b ff		 npad	 2
$LL43@PullObjInn:

; 710  : 	{
; 711  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  00090	8b 9f 00 00 00
	00		 mov	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi]
  00096	3b 9f 08 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  0009c	7f 61		 jg	 SHORT $LN42@PullObjInn
  0009e	8b ff		 npad	 2
$LL40@PullObjInn:

; 712  : 		{
; 713  : 			for ( int iMAPY = g_rtPOINT_TRAP[iAXIS].top ; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++ )

  000a0	8b b7 04 00 00
	00		 mov	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+4]
  000a6	3b b7 0c 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  000ac	7f 45		 jg	 SHORT $LN39@PullObjInn

; 714  : 			{
; 715  : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  000ae	8b 4d a0	 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  000b1	51		 push	 ecx
  000b2	8b 4d a8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000b5	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  000ba	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H

; 723  : 				}
; 724  : 			}
; 725  : 		}
; 726  : 	}
; 727  : 
; 728  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  000c0	8d 90 00 00 00
	00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  000c6	89 55 a4	 mov	 DWORD PTR tv793[ebp], edx
$LN37@PullObjInn:

; 716  : 
; 717  : 				BYTE btMapAttr = MapC[iMapNumber].GetAttr(iMAPX, iMAPY);

  000c9	8b 4d a4	 mov	 ecx, DWORD PTR tv793[ebp]
  000cc	56		 push	 esi
  000cd	53		 push	 ebx
  000ce	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 718  : 
; 719  : 				if ( (btMapAttr&2) != 2 && (btMapAttr&4) != 4 && (btMapAttr&8) != 8 ) 

  000d3	a8 0e		 test	 al, 14			; 0000000eH
  000d5	75 13		 jne	 SHORT $LN36@PullObjInn

; 720  : 				{
; 721  : 					POINT iPT = {iMAPX, iMAPY};
; 722  : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  000d7	8d 45 90	 lea	 eax, DWORD PTR _iPT$219069[ebp]
  000da	50		 push	 eax
  000db	8d 4c 3d b0	 lea	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+edi]
  000df	89 5d 90	 mov	 DWORD PTR _iPT$219069[ebp], ebx
  000e2	89 75 94	 mov	 DWORD PTR _iPT$219069[ebp+4], esi
  000e5	e8 00 00 00 00	 call	 ?push_back@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXABUtagPOINT@@@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::push_back
$LN36@PullObjInn:

; 712  : 		{
; 713  : 			for ( int iMAPY = g_rtPOINT_TRAP[iAXIS].top ; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++ )

  000ea	46		 inc	 esi
  000eb	3b b7 0c 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  000f1	7e d6		 jle	 SHORT $LN37@PullObjInn
$LN39@PullObjInn:

; 710  : 	{
; 711  : 		for ( int iMAPX = g_rtPOINT_TRAP[iAXIS].left ; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX ++ )

  000f3	43		 inc	 ebx
  000f4	3b 9f 08 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  000fa	7e a4		 jle	 SHORT $LL40@PullObjInn
  000fc	8b 75 a0	 mov	 esi, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
$LN42@PullObjInn:

; 708  : 
; 709  : 	for ( int iAXIS = 0; iAXIS < MAX_CC_TRAP_STEP ; iAXIS++)

  000ff	83 c7 10	 add	 edi, 16			; 00000010H
  00102	83 ff 40	 cmp	 edi, 64			; 00000040H
  00105	7c 89		 jl	 SHORT $LL43@PullObjInn

; 723  : 				}
; 724  : 			}
; 725  : 		}
; 726  : 	}
; 727  : 
; 728  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00107	69 f6 70 08 00
	00		 imul	 esi, 2160		; 00000870H
  0010d	03 75 a8	 add	 esi, DWORD PTR _this$GSCopy$[ebp]
  00110	c7 45 9c 46 00
	00 00		 mov	 DWORD PTR tv696[ebp], 70 ; 00000046H
  00117	89 75 a4	 mov	 DWORD PTR tv1563[ebp], esi
  0011a	83 c6 6c	 add	 esi, 108		; 0000006cH
  0011d	8d 49 00	 npad	 3
$LL33@PullObjInn:

; 729  : 	{
; 730  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex != -1 )

  00120	8b 06		 mov	 eax, DWORD PTR [esi]
  00122	83 f8 ff	 cmp	 eax, -1
  00125	0f 84 f6 00 00
	00		 je	 $LN32@PullObjInn

; 731  : 		{
; 732  : 			if ( gObjIsConnected(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex) ==TRUE && gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].MapNumber == (this->GetChaosCastleMapNumber(iChaosCastleIndex)) )

  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00131	83 c4 04	 add	 esp, 4
  00134	83 f8 01	 cmp	 eax, 1
  00137	0f 85 e4 00 00
	00		 jne	 $LN32@PullObjInn
  0013d	8b 55 a0	 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  00140	8b 4d a8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00149	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00151	8b d3		 mov	 edx, ebx
  00153	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00159	0f b6 94 0a 49
	01 00 00	 movzx	 edx, BYTE PTR [edx+ecx+329]
  00161	3b d0		 cmp	 edx, eax
  00163	0f 85 b8 00 00
	00		 jne	 $LN32@PullObjInn

; 733  : 			{
; 734  : 				int iSX = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].X;

  00169	8b d3		 mov	 edx, ebx

; 735  : 				int iSY = gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].Y;
; 736  : 
; 737  : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);
; 738  : 
; 739  : 				BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  0016b	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00171	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00177	03 ca		 add	 ecx, edx
  00179	0f bf 91 44 01
	00 00		 movsx	 edx, WORD PTR [ecx+324]
  00180	0f bf 89 46 01
	00 00		 movsx	 ecx, WORD PTR [ecx+326]
  00187	8b f9		 mov	 edi, ecx
  00189	c1 e7 08	 shl	 edi, 8
  0018c	03 b8 10 00 00
	00		 add	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00192	8a 04 17	 mov	 al, BYTE PTR [edi+edx]
  00195	24 08		 and	 al, 8

; 740  : 
; 741  : 				if ( btMapAttr == 8 )

  00197	0f 84 84 00 00
	00		 je	 $LN32@PullObjInn

; 742  : 				{
; 743  : 					int n=0;
; 744  : 					for ( n=0;n<MAX_CC_TRAP_STEP;n++)

  0019d	33 ff		 xor	 edi, edi
  0019f	b8 08 00 00 00	 mov	 eax, OFFSET _g_rtPOINT_FRAME+8
$LL27@PullObjInn:

; 745  : 					{
; 746  : 						if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 747  : 							 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  001a4	3b 50 f8	 cmp	 edx, DWORD PTR [eax-8]
  001a7	7c 0e		 jl	 SHORT $LN26@PullObjInn
  001a9	3b 10		 cmp	 edx, DWORD PTR [eax]
  001ab	7f 0a		 jg	 SHORT $LN26@PullObjInn
  001ad	3b 48 fc	 cmp	 ecx, DWORD PTR [eax-4]
  001b0	7c 05		 jl	 SHORT $LN26@PullObjInn
  001b2	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001b5	7e 0d		 jle	 SHORT $LN132@PullObjInn
$LN26@PullObjInn:

; 742  : 				{
; 743  : 					int n=0;
; 744  : 					for ( n=0;n<MAX_CC_TRAP_STEP;n++)

  001b7	83 c0 10	 add	 eax, 16			; 00000010H
  001ba	47		 inc	 edi
  001bb	3d 48 00 00 00	 cmp	 eax, OFFSET _g_rtPOINT_FRAME+72
  001c0	7c e2		 jl	 SHORT $LL27@PullObjInn

; 797  : 				{
; 798  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 799  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  001c2	eb 03		 jmp	 SHORT $LN25@PullObjInn
$LN132@PullObjInn:

; 748  : 						{
; 749  : 							iUSER_AXIS = n;

  001c4	89 7d 98	 mov	 DWORD PTR _iUSER_AXIS$[ebp], edi
$LN25@PullObjInn:

; 750  : 							break;
; 751  : 						}
; 752  : 					}
; 753  : 
; 754  : 					if ( n == MAX_CC_TRAP_STEP )

  001c7	83 ff 04	 cmp	 edi, 4
  001ca	74 55		 je	 SHORT $LN32@PullObjInn

; 755  : 						continue;
; 756  : 
; 757  : 					if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  001cc	8b 4d 98	 mov	 ecx, DWORD PTR _iUSER_AXIS$[ebp]
  001cf	03 c9		 add	 ecx, ecx
  001d1	8b 54 cd b0	 mov	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  001d5	3b 54 cd b4	 cmp	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]
  001d9	8d 44 cd b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  001dd	74 42		 je	 SHORT $LN32@PullObjInn

; 758  : 					{
; 759  : 						POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  001df	8b 4c cd b4	 mov	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]

; 760  : 						vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  001e3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e6	8b 79 f8	 mov	 edi, DWORD PTR [ecx-8]
  001e9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001ec	39 10		 cmp	 DWORD PTR [eax], edx
  001ee	74 06		 je	 SHORT $LN87@PullObjInn
  001f0	83 c2 f8	 add	 edx, -8			; fffffff8H
  001f3	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN87@PullObjInn:

; 761  : 
; 762  : 						if ( this->ObjSetPosition(this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex, ptEMPTY.x, ptEMPTY.y) == TRUE )

  001f6	51		 push	 ecx
  001f7	8b 4d a8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001fa	57		 push	 edi
  001fb	53		 push	 ebx
  001fc	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  00201	83 f8 01	 cmp	 eax, 1
  00204	75 1b		 jne	 SHORT $LN32@PullObjInn

; 763  : 						{
; 764  : 							gObj[this->m_stChaosCastleData[iChaosCastleIndex].m_UserData[i].m_iIndex].m_iChaosCastleBlowTime = GetTickCount();

  00206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0020c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00214	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0021a	89 84 11 a8 0e
	00 00		 mov	 DWORD PTR [ecx+edx+3752], eax
$LN32@PullObjInn:

; 723  : 				}
; 724  : 			}
; 725  : 		}
; 726  : 	}
; 727  : 
; 728  : 	for ( int i=0;i<MAX_CHAOSCASTLE_USER;i++)

  00221	83 c6 14	 add	 esi, 20			; 00000014H
  00224	ff 4d 9c	 dec	 DWORD PTR tv696[ebp]
  00227	0f 85 f3 fe ff
	ff		 jne	 $LL33@PullObjInn

; 765  : 						}
; 766  : 					}
; 767  : 				}
; 768  : 			}
; 769  : 		}
; 770  : 	}
; 771  : 
; 772  : 	for ( int iMON = 0; iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++ )

  0022d	8b 4d a4	 mov	 ecx, DWORD PTR tv1563[ebp]
  00230	81 c1 e4 05 00
	00		 add	 ecx, 1508		; 000005e4H
  00236	89 4d 9c	 mov	 DWORD PTR tv1678[ebp], ecx
  00239	c7 45 a4 64 00
	00 00		 mov	 DWORD PTR tv162[ebp], 100 ; 00000064H
$LL20@PullObjInn:

; 773  : 	{
; 774  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  00240	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00242	89 5d 94	 mov	 DWORD PTR tv1681[ebp], ebx
  00245	83 fb ff	 cmp	 ebx, -1
  00248	0f 84 29 01 00
	00		 je	 $LN19@PullObjInn

; 775  : 			continue;
; 776  : 
; 777  : 		int iMON_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON];
; 778  : 
; 779  : 		if ( !CHECK_LIMIT(iMON_INDEX, OBJ_MAXMONSTER))

  0024e	85 db		 test	 ebx, ebx
  00250	78 0f		 js	 SHORT $LN142@PullObjInn
  00252	33 c0		 xor	 eax, eax
  00254	81 fb c7 32 00
	00		 cmp	 ebx, 12999		; 000032c7H
  0025a	0f 9e c0	 setle	 al
  0025d	85 c0		 test	 eax, eax
  0025f	75 0b		 jne	 SHORT $LN16@PullObjInn
$LN142@PullObjInn:

; 780  : 		{
; 781  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] = -1;

  00261	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 782  : 			continue;

  00267	e9 0b 01 00 00	 jmp	 $LN19@PullObjInn
$LN16@PullObjInn:

; 783  : 		}
; 784  : 
; 785  : 		if ( gObj[iMON_INDEX].Life > 0.0f && CC_MAP_RANGE(gObj[iMON_INDEX].MapNumber) != FALSE && gObj[iMON_INDEX].Connected > PLAYER_EMPTY )

  0026c	d9 ee		 fldz
  0026e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00274	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  0027a	d8 9c 3b fc 00
	00 00		 fcomp	 DWORD PTR [ebx+edi+252]
  00281	df e0		 fnstsw	 ax
  00283	f6 c4 05	 test	 ah, 5
  00286	0f 8a eb 00 00
	00		 jp	 $LN19@PullObjInn
  0028c	0f b6 84 3b 49
	01 00 00	 movzx	 eax, BYTE PTR [ebx+edi+329]
  00294	3c 35		 cmp	 al, 53			; 00000035H
  00296	74 15		 je	 SHORT $LN143@PullObjInn
  00298	3c 12		 cmp	 al, 18			; 00000012H
  0029a	0f 82 d7 00 00
	00		 jb	 $LN19@PullObjInn
  002a0	b1 17		 mov	 cl, 23			; 00000017H
  002a2	3a c8		 cmp	 cl, al
  002a4	1b c0		 sbb	 eax, eax
  002a6	40		 inc	 eax
  002a7	0f 84 ca 00 00
	00		 je	 $LN19@PullObjInn
$LN143@PullObjInn:
  002ad	83 7c 3b 04 00	 cmp	 DWORD PTR [ebx+edi+4], 0
  002b2	0f 8e bf 00 00
	00		 jle	 $LN19@PullObjInn

; 786  : 		{
; 787  : 			int iSX = gObj[iMON_INDEX].X;
; 788  : 			int iSY = gObj[iMON_INDEX].Y;
; 789  : 			int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  002b8	8b 45 a0	 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  002bb	8b 75 a8	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  002be	0f bf 94 3b 44
	01 00 00	 movsx	 edx, WORD PTR [ebx+edi+324]
  002c6	0f bf bc 3b 46
	01 00 00	 movsx	 edi, WORD PTR [ebx+edi+326]
  002ce	50		 push	 eax
  002cf	8b ce		 mov	 ecx, esi
  002d1	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber

; 790  : 
; 791  : 			BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  002d6	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  002dc	8b cf		 mov	 ecx, edi
  002de	c1 e1 08	 shl	 ecx, 8
  002e1	03 88 10 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  002e7	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  002ea	24 08		 and	 al, 8

; 792  : 
; 793  : 			if ( btMapAttr == 8 )

  002ec	0f 84 85 00 00
	00		 je	 $LN19@PullObjInn

; 794  : 			{
; 795  : 				int n=0;
; 796  : 				for (n=0;n<MAX_CC_TRAP_STEP;n++)

  002f2	33 c9		 xor	 ecx, ecx
  002f4	b8 08 00 00 00	 mov	 eax, OFFSET _g_rtPOINT_FRAME+8
  002f9	8d a4 24 00 00
	00 00		 npad	 7
$LL13@PullObjInn:

; 797  : 				{
; 798  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 799  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  00300	3b 50 f8	 cmp	 edx, DWORD PTR [eax-8]
  00303	7c 0e		 jl	 SHORT $LN12@PullObjInn
  00305	3b 10		 cmp	 edx, DWORD PTR [eax]
  00307	7f 0a		 jg	 SHORT $LN12@PullObjInn
  00309	3b 78 fc	 cmp	 edi, DWORD PTR [eax-4]
  0030c	7c 05		 jl	 SHORT $LN12@PullObjInn
  0030e	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00311	7e 0d		 jle	 SHORT $LN133@PullObjInn
$LN12@PullObjInn:

; 794  : 			{
; 795  : 				int n=0;
; 796  : 				for (n=0;n<MAX_CC_TRAP_STEP;n++)

  00313	83 c0 10	 add	 eax, 16			; 00000010H
  00316	41		 inc	 ecx
  00317	3d 48 00 00 00	 cmp	 eax, OFFSET _g_rtPOINT_FRAME+72
  0031c	7c e2		 jl	 SHORT $LL13@PullObjInn

; 797  : 				{
; 798  : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right &&
; 799  : 						 iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  0031e	eb 03		 jmp	 SHORT $LN11@PullObjInn
$LN133@PullObjInn:

; 800  : 					{
; 801  : 						iUSER_AXIS = n;

  00320	89 4d 98	 mov	 DWORD PTR _iUSER_AXIS$[ebp], ecx
$LN11@PullObjInn:

; 802  : 						break;
; 803  : 					}
; 804  : 				}
; 805  : 
; 806  : 				if ( n == MAX_CC_TRAP_STEP )

  00323	83 f9 04	 cmp	 ecx, 4
  00326	74 4f		 je	 SHORT $LN19@PullObjInn

; 807  : 					continue;
; 808  : 
; 809  : 				if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  00328	8b 4d 98	 mov	 ecx, DWORD PTR _iUSER_AXIS$[ebp]
  0032b	03 c9		 add	 ecx, ecx
  0032d	8b 54 cd b0	 mov	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  00331	3b 54 cd b4	 cmp	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]
  00335	8d 44 cd b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  00339	74 3c		 je	 SHORT $LN19@PullObjInn

; 810  : 				{
; 811  : 					POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  0033b	8b 4c cd b4	 mov	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]

; 812  : 					vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  0033f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00342	8b 79 f8	 mov	 edi, DWORD PTR [ecx-8]
  00345	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00348	39 10		 cmp	 DWORD PTR [eax], edx
  0034a	74 06		 je	 SHORT $LN119@PullObjInn
  0034c	83 c2 f8	 add	 edx, -8			; fffffff8H
  0034f	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN119@PullObjInn:

; 813  : 
; 814  : 					if ( this->ObjSetPosition(iMON_INDEX, ptEMPTY.x, ptEMPTY.y) == TRUE )

  00352	8b 45 94	 mov	 eax, DWORD PTR tv1681[ebp]
  00355	51		 push	 ecx
  00356	57		 push	 edi
  00357	50		 push	 eax
  00358	8b ce		 mov	 ecx, esi
  0035a	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  0035f	83 f8 01	 cmp	 eax, 1
  00362	75 13		 jne	 SHORT $LN19@PullObjInn

; 815  : 					{
; 816  : 						gObj[iMON_INDEX].m_iChaosCastleBlowTime = GetTickCount();

  00364	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0036a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00370	89 84 0b a8 0e
	00 00		 mov	 DWORD PTR [ebx+ecx+3752], eax
$LN19@PullObjInn:

; 765  : 						}
; 766  : 					}
; 767  : 				}
; 768  : 			}
; 769  : 		}
; 770  : 	}
; 771  : 
; 772  : 	for ( int iMON = 0; iMON < MAX_CHAOSCASTLE_MONSTER ; iMON++ )

  00377	8b 4d 9c	 mov	 ecx, DWORD PTR tv1678[ebp]
  0037a	83 c1 04	 add	 ecx, 4
  0037d	ff 4d a4	 dec	 DWORD PTR tv162[ebp]
  00380	89 4d 9c	 mov	 DWORD PTR tv1678[ebp], ecx
  00383	0f 85 b7 fe ff
	ff		 jne	 $LL20@PullObjInn

; 824  : 	{
; 825  : 		int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  00389	8b 55 a0	 mov	 edx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0038c	8b 4d a8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0038f	52		 push	 edx
  00390	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  00395	8b d8		 mov	 ebx, eax
  00397	69 db 48 3d 05
	00		 imul	 ebx, 343368		; 00053d48H
  0039d	33 ff		 xor	 edi, edi
  0039f	90		 npad	 1
$LL6@PullObjInn:

; 826  : 
; 827  : 		if ( MapC[iMapNumber].m_cItem[iMAP_ITEM].IsItem() )

  003a0	8d 8c 3b 24 00
	00 00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ebx+edi+36]
  003a7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003ac	85 c0		 test	 eax, eax
  003ae	74 51		 je	 SHORT $LN5@PullObjInn

; 828  : 		{
; 829  : 			int x = MapC[iMapNumber].m_cItem[iMAP_ITEM].px;

  003b0	0f b6 8c 3b f8
	00 00 00	 movzx	 ecx, BYTE PTR ?MapC@@3PAVMapClass@@A[ebx+edi+248]

; 830  : 			int y = MapC[iMapNumber].m_cItem[iMAP_ITEM].py;
; 831  : 
; 832  : 			if ( x < ::g_iChaosCastle_DamageAxis[iTRAP_STEP][0] || x > ::g_iChaosCastle_DamageAxis[iTRAP_STEP][2] ||
; 833  : 				 y < ::g_iChaosCastle_DamageAxis[iTRAP_STEP][1] || y > ::g_iChaosCastle_DamageAxis[iTRAP_STEP][3] )

  003b8	8b 45 0c	 mov	 eax, DWORD PTR _iTRAP_STEP$[ebp]
  003bb	0f b6 94 3b f9
	00 00 00	 movzx	 edx, BYTE PTR ?MapC@@3PAVMapClass@@A[ebx+edi+249]
  003c3	c1 e0 04	 shl	 eax, 4
  003c6	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax]
  003cc	7c 18		 jl	 SHORT $LN1@PullObjInn
  003ce	3b 88 08 00 00
	00		 cmp	 ecx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+8]
  003d4	7f 10		 jg	 SHORT $LN1@PullObjInn
  003d6	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+4]
  003dc	7c 08		 jl	 SHORT $LN1@PullObjInn
  003de	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR _g_iChaosCastle_DamageAxis[eax+12]
  003e4	7e 1b		 jle	 SHORT $LN5@PullObjInn
$LN1@PullObjInn:

; 834  : 			{
; 835  : 				MapC[iMapNumber].m_cItem[iMAP_ITEM].m_State = 8;

  003e6	c7 84 3b fc 00
	00 00 08 00 00
	00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[ebx+edi+252], 8

; 836  : 				MapC[iMapNumber].m_cItem[iMAP_ITEM].Give = true;

  003f1	c6 84 3b fb 00
	00 00 01	 mov	 BYTE PTR ?MapC@@3PAVMapClass@@A[ebx+edi+251], 1

; 837  : 				MapC[iMapNumber].m_cItem[iMAP_ITEM].live = false;

  003f9	c6 84 3b fa 00
	00 00 00	 mov	 BYTE PTR ?MapC@@3PAVMapClass@@A[ebx+edi+250], 0
$LN5@PullObjInn:

; 817  : 					}
; 818  : 				}
; 819  : 			}
; 820  : 		}
; 821  : 	}
; 822  : 
; 823  : 	for ( int iMAP_ITEM =0;iMAP_ITEM<MAX_MAPITEM;iMAP_ITEM++)

  00401	81 c7 74 04 00
	00		 add	 edi, 1140		; 00000474H
  00407	81 ff f0 37 05
	00		 cmp	 edi, 342000		; 000537f0H
  0040d	7c 91		 jl	 SHORT $LL6@PullObjInn

; 838  : 			}
; 839  : 		}
; 840  : 	}
; 841  : }

  0040f	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00414	6a 04		 push	 4
  00416	6a 10		 push	 16			; 00000010H
  00418	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0041b	50		 push	 eax
  0041c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00423	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN47@PullObjInn:
  00428	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0042b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00432	59		 pop	 ecx
  00433	5f		 pop	 edi
  00434	5e		 pop	 esi
  00435	5b		 pop	 ebx
  00436	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00439	33 cd		 xor	 ecx, ebp
  0043b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00440	8b e5		 mov	 esp, ebp
  00442	5d		 pop	 ebp
  00443	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00005	6a 04		 push	 4
  00007	6a 10		 push	 16			; 00000010H
  00009	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00012	c3		 ret	 0
__ehhandler$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z ENDP		; CChaosCastle::PullObjInnerPlace
PUBLIC	_iChaosCastleIndex$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z	; CChaosCastle::CheckMonsterInDieTile
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z$0
__ehfuncinfo$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaoscastle.cpp
xdata$x	ENDS
;	COMDAT ?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
_TEXT	SEGMENT
tv757 = -120						; size = 4
_iPT$220688 = -116					; size = 8
_iUSER_AXIS$ = -108					; size = 4
_iMAPX$220677 = -100					; size = 4
_iChaosCastleIndex$GSCopy$ = -96			; size = 4
_this$GSCopy$ = -92					; size = 4
tv333 = -88						; size = 4
_iMAPY$220681 = -88					; size = 4
tv1279 = -84						; size = 4
tv1096 = -84						; size = 4
_vtMAP_UNTRAP$ = -80					; size = 64
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iChaosCastleIndex$ = 8					; size = 4
?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z PROC	; CChaosCastle::CheckMonsterInDieTile, COMDAT
; _this$ = ecx

; 2654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 5d 08	 mov	 ebx, DWORD PTR _iChaosCastleIndex$[ebp]

; 2655 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0002e	33 ff		 xor	 edi, edi
  00030	89 4d a4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 2674 : 				{
; 2675 : 					POINT iPT = {iMAPX, iMAPY};
; 2676 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  00033	89 5d a0	 mov	 DWORD PTR _iChaosCastleIndex$GSCopy$[ebp], ebx
  00036	3b df		 cmp	 ebx, edi
  00038	0f 8c 35 03 00
	00		 jl	 $LN26@CheckMonst

; 2655 : 	if ( CC_FLOOR_RANGE(iChaosCastleIndex) == FALSE )

  0003e	33 c0		 xor	 eax, eax
  00040	83 fb 06	 cmp	 ebx, 6
  00043	0f 9e c0	 setle	 al
  00046	3b c7		 cmp	 eax, edi
  00048	0f 84 25 03 00
	00		 je	 $LN26@CheckMonst

; 2656 : 	{
; 2657 : 		return;
; 2658 : 	}
; 2659 : 
; 2660 : 	int iUSER_AXIS = 0;
; 2661 : 	std::vector<POINT> vtMAP_UNTRAP[4];

  0004e	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00053	68 00 00 00 00	 push	 OFFSET ??0?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::vector<tagPOINT,std::allocator<tagPOINT> >
  00058	6a 04		 push	 4
  0005a	6a 10		 push	 16			; 00000010H
  0005c	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0005f	50		 push	 eax
  00060	89 7d 94	 mov	 DWORD PTR _iUSER_AXIS$[ebp], edi
  00063	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  00068	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0006b	89 7d ac	 mov	 DWORD PTR tv1096[ebp], edi
  0006e	8b ff		 npad	 2
$LL24@CheckMonst:

; 2664 : 	{
; 2665 : 		for(int iMAPX = g_rtPOINT_TRAP[iAXIS].left; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX++)

  00070	8b b7 00 00 00
	00		 mov	 esi, DWORD PTR _g_rtPOINT_TRAP[edi]
  00076	89 75 9c	 mov	 DWORD PTR _iMAPX$220677[ebp], esi
  00079	3b b7 08 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  0007f	0f 8f 55 01 00
	00		 jg	 $LN23@CheckMonst
  00085	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL21@CheckMonst:

; 2666 : 		{
; 2667 : 			for(int iMAPY = g_rtPOINT_TRAP[iAXIS].top; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++)

  00090	8b 9f 04 00 00
	00		 mov	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+4]
  00096	89 5d a8	 mov	 DWORD PTR _iMAPY$220681[ebp], ebx
  00099	3b 9f 0c 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  0009f	0f 8f 22 01 00
	00		 jg	 $LN20@CheckMonst

; 2668 : 			{
; 2669 : 				int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  000a5	8b 4d a0	 mov	 ecx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d a4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000ac	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber
  000b1	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H

; 2677 : 				}
; 2678 : 			}
; 2679 : 		}
; 2680 : 	}
; 2681 : 
; 2682 : 	for(int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON ++ )

  000b7	8d 90 00 00 00
	00		 lea	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  000bd	89 55 88	 mov	 DWORD PTR tv757[ebp], edx
$LN18@CheckMonst:

; 2670 : 
; 2671 : 				BYTE btMapAttr = MapC[iMapNumber].GetAttr(iMAPX, iMAPY);

  000c0	8b 4d 88	 mov	 ecx, DWORD PTR tv757[ebp]
  000c3	53		 push	 ebx
  000c4	56		 push	 esi
  000c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 2672 : 
; 2673 : 				if ( (btMapAttr&2)!= 2 && (btMapAttr&4)!= 4 && (btMapAttr&8)!= 8 )

  000ca	a8 0e		 test	 al, 14			; 0000000eH
  000cc	0f 85 e5 00 00
	00		 jne	 $LN17@CheckMonst

; 2674 : 				{
; 2675 : 					POINT iPT = {iMAPX, iMAPY};
; 2676 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  000d2	8b 44 3d b4	 mov	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+edi+4]
  000d6	89 75 8c	 mov	 DWORD PTR _iPT$220688[ebp], esi
  000d9	8d 74 3d b0	 lea	 esi, DWORD PTR _vtMAP_UNTRAP$[ebp+edi]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR _iPT$220688[ebp]
  000e0	89 5d 90	 mov	 DWORD PTR _iPT$220688[ebp+4], ebx
  000e3	3b c8		 cmp	 ecx, eax
  000e5	73 6c		 jae	 SHORT $LN40@CheckMonst
  000e7	8b 16		 mov	 edx, DWORD PTR [esi]
  000e9	3b d1		 cmp	 edx, ecx
  000eb	77 66		 ja	 SHORT $LN40@CheckMonst
  000ed	8b f9		 mov	 edi, ecx
  000ef	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000f2	2b fa		 sub	 edi, edx
  000f4	c1 ff 03	 sar	 edi, 3
  000f7	3b c1		 cmp	 eax, ecx
  000f9	75 40		 jne	 SHORT $LN51@CheckMonst
  000fb	2b c2		 sub	 eax, edx
  000fd	c1 f8 03	 sar	 eax, 3
  00100	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00105	0f 87 2e 01 00
	00		 ja	 $LN158@CheckMonst
  0010b	2b ca		 sub	 ecx, edx
  0010d	40		 inc	 eax
  0010e	c1 f9 03	 sar	 ecx, 3
  00111	3b c1		 cmp	 eax, ecx
  00113	76 26		 jbe	 SHORT $LN51@CheckMonst
  00115	8b d1		 mov	 edx, ecx
  00117	d1 ea		 shr	 edx, 1
  00119	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  0011e	2b da		 sub	 ebx, edx
  00120	3b d9		 cmp	 ebx, ecx
  00122	73 04		 jae	 SHORT $LN73@CheckMonst
  00124	33 c9		 xor	 ecx, ecx
  00126	eb 02		 jmp	 SHORT $LN74@CheckMonst
$LN73@CheckMonst:
  00128	03 ca		 add	 ecx, edx
$LN74@CheckMonst:
  0012a	3b c8		 cmp	 ecx, eax
  0012c	73 02		 jae	 SHORT $LN70@CheckMonst
  0012e	8b c8		 mov	 ecx, eax
$LN70@CheckMonst:
  00130	51		 push	 ecx
  00131	8b ce		 mov	 ecx, esi
  00133	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
  00138	8b 5d a8	 mov	 ebx, DWORD PTR _iMAPY$220681[ebp]
$LN51@CheckMonst:
  0013b	8b 16		 mov	 edx, DWORD PTR [esi]
  0013d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00140	8d 04 fa	 lea	 eax, DWORD PTR [edx+edi*8]
  00143	50		 push	 eax
  00144	51		 push	 ecx
  00145	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00148	52		 push	 edx
  00149	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@AAU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@AAU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT &>
  0014e	8b 7d ac	 mov	 edi, DWORD PTR tv1096[ebp]
  00151	eb 5a		 jmp	 SHORT $LN178@CheckMonst
$LN40@CheckMonst:
  00153	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00156	3b c1		 cmp	 eax, ecx
  00158	75 42		 jne	 SHORT $LN86@CheckMonst
  0015a	8b 16		 mov	 edx, DWORD PTR [esi]
  0015c	2b c2		 sub	 eax, edx
  0015e	c1 f8 03	 sar	 eax, 3
  00161	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00166	0f 87 cd 00 00
	00		 ja	 $LN158@CheckMonst
  0016c	2b ca		 sub	 ecx, edx
  0016e	40		 inc	 eax
  0016f	c1 f9 03	 sar	 ecx, 3
  00172	3b c1		 cmp	 eax, ecx
  00174	76 26		 jbe	 SHORT $LN86@CheckMonst
  00176	8b d1		 mov	 edx, ecx
  00178	d1 ea		 shr	 edx, 1
  0017a	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0017f	2b fa		 sub	 edi, edx
  00181	3b f9		 cmp	 edi, ecx
  00183	73 04		 jae	 SHORT $LN108@CheckMonst
  00185	33 c9		 xor	 ecx, ecx
  00187	eb 02		 jmp	 SHORT $LN109@CheckMonst
$LN108@CheckMonst:
  00189	03 ca		 add	 ecx, edx
$LN109@CheckMonst:
  0018b	3b c8		 cmp	 ecx, eax
  0018d	73 02		 jae	 SHORT $LN105@CheckMonst
  0018f	8b c8		 mov	 ecx, eax
$LN105@CheckMonst:
  00191	51		 push	 ecx
  00192	8b ce		 mov	 ecx, esi
  00194	e8 00 00 00 00	 call	 ?reserve@?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAEXI@Z ; std::vector<tagPOINT,std::allocator<tagPOINT> >::reserve
  00199	8b 7d ac	 mov	 edi, DWORD PTR tv1096[ebp]
$LN86@CheckMonst:
  0019c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0019f	8d 45 8c	 lea	 eax, DWORD PTR _iPT$220688[ebp]
  001a2	50		 push	 eax
  001a3	51		 push	 ecx
  001a4	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  001a7	52		 push	 edx
  001a8	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UtagPOINT@@@std@@UtagPOINT@@ABU3@@std@@YAXAAV?$allocator@UtagPOINT@@@0@PAUtagPOINT@@ABU2@@Z ; std::_Cons_val<std::allocator<tagPOINT>,tagPOINT,tagPOINT const &>
$LN178@CheckMonst:
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b0	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  001b4	8b 75 9c	 mov	 esi, DWORD PTR _iMAPX$220677[ebp]
$LN17@CheckMonst:

; 2666 : 		{
; 2667 : 			for(int iMAPY = g_rtPOINT_TRAP[iAXIS].top; iMAPY <= g_rtPOINT_TRAP[iAXIS].bottom ; iMAPY++)

  001b7	43		 inc	 ebx
  001b8	89 5d a8	 mov	 DWORD PTR _iMAPY$220681[ebp], ebx
  001bb	3b 9f 0c 00 00
	00		 cmp	 ebx, DWORD PTR _g_rtPOINT_TRAP[edi+12]
  001c1	0f 8e f9 fe ff
	ff		 jle	 $LN18@CheckMonst
$LN20@CheckMonst:

; 2664 : 	{
; 2665 : 		for(int iMAPX = g_rtPOINT_TRAP[iAXIS].left; iMAPX <= g_rtPOINT_TRAP[iAXIS].right ; iMAPX++)

  001c7	46		 inc	 esi
  001c8	89 75 9c	 mov	 DWORD PTR _iMAPX$220677[ebp], esi
  001cb	3b b7 08 00 00
	00		 cmp	 esi, DWORD PTR _g_rtPOINT_TRAP[edi+8]
  001d1	0f 8e b9 fe ff
	ff		 jle	 $LL21@CheckMonst
  001d7	8b 5d a0	 mov	 ebx, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
$LN23@CheckMonst:

; 2662 : 
; 2663 : 	for ( int iAXIS =0;iAXIS < 4 ; iAXIS++)

  001da	83 c7 10	 add	 edi, 16			; 00000010H
  001dd	89 7d ac	 mov	 DWORD PTR tv1096[ebp], edi
  001e0	83 ff 40	 cmp	 edi, 64			; 00000040H
  001e3	0f 8c 87 fe ff
	ff		 jl	 $LL24@CheckMonst

; 2677 : 				}
; 2678 : 			}
; 2679 : 		}
; 2680 : 	}
; 2681 : 
; 2682 : 	for(int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON ++ )

  001e9	8b 45 a4	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  001ec	69 db 70 08 00
	00		 imul	 ebx, 2160		; 00000870H
  001f2	8d 8c 03 e4 05
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+1508]
  001f9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ff	89 4d ac	 mov	 DWORD PTR tv1279[ebp], ecx
  00202	c7 45 a8 64 00
	00 00		 mov	 DWORD PTR tv333[ebp], 100 ; 00000064H
  00209	8d a4 24 00 00
	00 00		 npad	 7
$LL14@CheckMonst:

; 2683 : 	{
; 2684 : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] == -1 )

  00210	8b 39		 mov	 edi, DWORD PTR [ecx]
  00212	83 ff ff	 cmp	 edi, -1
  00215	0f 84 2d 01 00
	00		 je	 $LN13@CheckMonst

; 2685 : 		{
; 2686 : 			continue;
; 2687 : 		}
; 2688 : 
; 2689 : 		int iMON_INDEX = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON];
; 2690 : 
; 2691 : 		if ( !CHECK_LIMIT(iMON_INDEX, OBJ_MAXMONSTER))

  0021b	85 ff		 test	 edi, edi
  0021d	78 0f		 js	 SHORT $LN167@CheckMonst
  0021f	33 c0		 xor	 eax, eax
  00221	81 ff c7 32 00
	00		 cmp	 edi, 12999		; 000032c7H
  00227	0f 9e c0	 setle	 al
  0022a	85 c0		 test	 eax, eax
  0022c	75 15		 jne	 SHORT $LN10@CheckMonst
$LN167@CheckMonst:

; 2692 : 		{
; 2693 : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[iMON] = -1;

  0022e	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 2694 : 			continue;

  00234	e9 09 01 00 00	 jmp	 $LN169@CheckMonst
$LN158@CheckMonst:

; 2674 : 				{
; 2675 : 					POINT iPT = {iMAPX, iMAPY};
; 2676 : 					vtMAP_UNTRAP[iAXIS].push_back(iPT);

  00239	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0023e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN179@CheckMonst:
$LN10@CheckMonst:

; 2695 : 		}
; 2696 : 
; 2697 : 		if ( gObj[iMON_INDEX].Life > 0.0f && CC_MAP_RANGE(gObj[iMON_INDEX].MapNumber) != FALSE && gObj[iMON_INDEX].Connected > PLAYER_EMPTY )

  00243	d9 ee		 fldz
  00245	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0024b	d8 9c 1f fc 00
	00 00		 fcomp	 DWORD PTR [edi+ebx+252]
  00252	df e0		 fnstsw	 ax
  00254	f6 c4 05	 test	 ah, 5
  00257	0f 8a eb 00 00
	00		 jp	 $LN13@CheckMonst
  0025d	0f b6 84 1f 49
	01 00 00	 movzx	 eax, BYTE PTR [edi+ebx+329]
  00265	3c 35		 cmp	 al, 53			; 00000035H
  00267	74 15		 je	 SHORT $LN168@CheckMonst
  00269	3c 12		 cmp	 al, 18			; 00000012H
  0026b	0f 82 d7 00 00
	00		 jb	 $LN13@CheckMonst
  00271	b1 17		 mov	 cl, 23			; 00000017H
  00273	3a c8		 cmp	 cl, al
  00275	1b c0		 sbb	 eax, eax
  00277	40		 inc	 eax
  00278	0f 84 ca 00 00
	00		 je	 $LN13@CheckMonst
$LN168@CheckMonst:
  0027e	83 7c 1f 04 00	 cmp	 DWORD PTR [edi+ebx+4], 0
  00283	0f 8e bf 00 00
	00		 jle	 $LN13@CheckMonst

; 2698 : 		{
; 2699 : 			int iSX = gObj[iMON_INDEX].X;
; 2700 : 			int iSY = gObj[iMON_INDEX].Y;
; 2701 : 
; 2702 : 			int iMapNumber = this->GetChaosCastleMapNumber(iChaosCastleIndex);

  00289	8b 45 a0	 mov	 eax, DWORD PTR _iChaosCastleIndex$GSCopy$[ebp]
  0028c	8b 4d a4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0028f	0f bf 94 1f 44
	01 00 00	 movsx	 edx, WORD PTR [edi+ebx+324]
  00297	0f bf b4 1f 46
	01 00 00	 movsx	 esi, WORD PTR [edi+ebx+326]
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 ?GetChaosCastleMapNumber@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetChaosCastleMapNumber

; 2703 : 
; 2704 : 			BYTE btMapAttr = MapC[iMapNumber].m_attrbuf[iSY * 256 + iSX] & 0x08;

  002a5	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  002ab	8b ce		 mov	 ecx, esi
  002ad	c1 e1 08	 shl	 ecx, 8
  002b0	03 88 10 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  002b6	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]
  002b9	24 08		 and	 al, 8

; 2705 : 
; 2706 : 			if ( btMapAttr == 8 )

  002bb	0f 84 87 00 00
	00		 je	 $LN13@CheckMonst

; 2707 : 			{
; 2708 : 				 int n=0;
; 2709 : 				for ( n=0;n<MAX_CC_TRAP_STEP;n++)

  002c1	33 c9		 xor	 ecx, ecx
  002c3	b8 08 00 00 00	 mov	 eax, OFFSET _g_rtPOINT_FRAME+8
$LL7@CheckMonst:

; 2710 : 				{
; 2711 : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right && iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  002c8	3b 50 f8	 cmp	 edx, DWORD PTR [eax-8]
  002cb	7c 0e		 jl	 SHORT $LN6@CheckMonst
  002cd	3b 10		 cmp	 edx, DWORD PTR [eax]
  002cf	7f 0a		 jg	 SHORT $LN6@CheckMonst
  002d1	3b 70 fc	 cmp	 esi, DWORD PTR [eax-4]
  002d4	7c 05		 jl	 SHORT $LN6@CheckMonst
  002d6	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  002d9	7e 0d		 jle	 SHORT $LN160@CheckMonst
$LN6@CheckMonst:

; 2707 : 			{
; 2708 : 				 int n=0;
; 2709 : 				for ( n=0;n<MAX_CC_TRAP_STEP;n++)

  002db	83 c0 10	 add	 eax, 16			; 00000010H
  002de	41		 inc	 ecx
  002df	3d 48 00 00 00	 cmp	 eax, OFFSET _g_rtPOINT_FRAME+72
  002e4	7c e2		 jl	 SHORT $LL7@CheckMonst

; 2710 : 				{
; 2711 : 					if ( iSX >= g_rtPOINT_FRAME[n].left && iSX <= g_rtPOINT_FRAME[n].right && iSY >= g_rtPOINT_FRAME[n].top && iSY <= g_rtPOINT_FRAME[n].bottom )

  002e6	eb 03		 jmp	 SHORT $LN5@CheckMonst
$LN160@CheckMonst:

; 2712 : 					{
; 2713 : 						iUSER_AXIS = n;

  002e8	89 4d 94	 mov	 DWORD PTR _iUSER_AXIS$[ebp], ecx
$LN5@CheckMonst:

; 2714 : 						break;
; 2715 : 					}
; 2716 : 				}
; 2717 : 
; 2718 : 				if (n == MAX_CC_TRAP_STEP )

  002eb	83 f9 04	 cmp	 ecx, 4
  002ee	74 58		 je	 SHORT $LN13@CheckMonst

; 2719 : 				{
; 2720 : 					continue;
; 2721 : 				}
; 2722 : 
; 2723 : 				if ( vtMAP_UNTRAP[iUSER_AXIS].empty() == false )

  002f0	8b 4d 94	 mov	 ecx, DWORD PTR _iUSER_AXIS$[ebp]
  002f3	03 c9		 add	 ecx, ecx
  002f5	8b 54 cd b0	 mov	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  002f9	3b 54 cd b4	 cmp	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]
  002fd	8d 44 cd b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8]
  00301	74 45		 je	 SHORT $LN13@CheckMonst

; 2724 : 				{
; 2725 : 					POINT ptEMPTY = vtMAP_UNTRAP[iUSER_AXIS].back();

  00303	8b 4c cd b4	 mov	 ecx, DWORD PTR _vtMAP_UNTRAP$[ebp+ecx*8+4]

; 2726 : 					vtMAP_UNTRAP[iUSER_AXIS].pop_back();

  00307	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0030a	8b 71 f8	 mov	 esi, DWORD PTR [ecx-8]
  0030d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00310	39 10		 cmp	 DWORD PTR [eax], edx
  00312	74 06		 je	 SHORT $LN148@CheckMonst
  00314	83 c2 f8	 add	 edx, -8			; fffffff8H
  00317	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN148@CheckMonst:

; 2727 : 
; 2728 : 					if ( this->ObjSetPosition(iMON_INDEX, ptEMPTY.x, ptEMPTY.y) == TRUE )

  0031a	8b 45 ac	 mov	 eax, DWORD PTR tv1279[ebp]
  0031d	8b 00		 mov	 eax, DWORD PTR [eax]
  0031f	51		 push	 ecx
  00320	8b 4d a4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00323	56		 push	 esi
  00324	50		 push	 eax
  00325	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  0032a	83 f8 01	 cmp	 eax, 1
  0032d	75 13		 jne	 SHORT $LN169@CheckMonst

; 2729 : 					{
; 2730 : 						gObj[iMON_INDEX].m_iChaosCastleBlowTime = GetTickCount();

  0032f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00335	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033b	89 84 0f a8 0e
	00 00		 mov	 DWORD PTR [edi+ecx+3752], eax
$LN169@CheckMonst:

; 2694 : 			continue;

  00342	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN13@CheckMonst:

; 2677 : 				}
; 2678 : 			}
; 2679 : 		}
; 2680 : 	}
; 2681 : 
; 2682 : 	for(int iMON = 0;iMON < MAX_CHAOSCASTLE_MONSTER ; iMON ++ )

  00348	8b 4d ac	 mov	 ecx, DWORD PTR tv1279[ebp]
  0034b	83 c1 04	 add	 ecx, 4
  0034e	ff 4d a8	 dec	 DWORD PTR tv333[ebp]
  00351	89 4d ac	 mov	 DWORD PTR tv1279[ebp], ecx
  00354	0f 85 b6 fe ff
	ff		 jne	 $LL14@CheckMonst

; 2731 : 					}
; 2732 : 				}
; 2733 : 			}
; 2734 : 		}
; 2735 : 	}
; 2736 : }

  0035a	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  0035f	6a 04		 push	 4
  00361	6a 10		 push	 16			; 00000010H
  00363	8d 55 b0	 lea	 edx, DWORD PTR _vtMAP_UNTRAP$[ebp]
  00366	52		 push	 edx
  00367	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0036e	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN26@CheckMonst:
  00373	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00376	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0037d	59		 pop	 ecx
  0037e	5f		 pop	 edi
  0037f	5e		 pop	 esi
  00380	5b		 pop	 ebx
  00381	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00384	33 cd		 xor	 ecx, ebp
  00386	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038b	8b e5		 mov	 esp, ebp
  0038d	5d		 pop	 ebp
  0038e	c2 04 00	 ret	 4
$LN177@CheckMonst:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$vector@UtagPOINT@@V?$allocator@UtagPOINT@@@std@@@std@@QAE@XZ ; std::vector<tagPOINT,std::allocator<tagPOINT> >::~vector<tagPOINT,std::allocator<tagPOINT> >
  00005	6a 04		 push	 4
  00007	6a 10		 push	 16			; 00000010H
  00009	8d 45 b0	 lea	 eax, DWORD PTR _vtMAP_UNTRAP$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00012	c3		 ret	 0
__ehhandler$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z ENDP	; CChaosCastle::CheckMonsterInDieTile
PUBLIC	??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ ; `string'
PUBLIC	??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ ; `string'
PUBLIC	??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@ ; `string'
PUBLIC	??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@ ; `string'
PUBLIC	??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ ; `string'
PUBLIC	??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?ProcState_Playing@CChaosCastle@@IAEXH@Z	; CChaosCastle::ProcState_Playing
;	COMDAT ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
CONST	SEGMENT
??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ DB '['
	DB	'Chaos Castle] (%d) Has No Winner : Monster Left (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Chaos Castle][Bug Tracer] (%d) Left Monster AttrInfo %d/%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
CONST	SEGMENT
??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@ DB '['
	DB	'Chaos Castle] (%d) Has No Winner.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
CONST	SEGMENT
??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class='
	DB	'%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Ene'
	DB	'rgy=%d, LeaderShip=%d, Map=%d, Pk=%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@
CONST	SEGMENT
??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@ DB '['
	DB	'Chaos Castle] (%d) is Over : TIME-OUT (Left User:%d, Monster:'
	DB	'%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
CONST	SEGMENT
??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ DB '['
	DB	'Chaos Castle] (%d) Chaos Castle Quest Closed - No User', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
CONST	SEGMENT
??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@ DB '['
	DB	'Chaos Castle] (%d) Chaos Castle Quest Start (UserCount:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProcState_Playing@CChaosCastle@@IAEXH@Z
_TEXT	SEGMENT
_iWinnerIndex$218679 = -284				; size = 4
_iWinnerIndex$218660 = -284				; size = 4
tv603 = -280						; size = 4
_pMsg$218644 = -280					; size = 4
_pMsg$218640 = -280					; size = 4
_pNotice$218648 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iChaosCastleIndex$ = 8					; size = 4
?ProcState_Playing@CChaosCastle@@IAEXH@Z PROC		; CChaosCastle::ProcState_Playing, COMDAT
; _this$ = ecx

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iChaosCastleIndex$[ebp]

; 463  : 	int iTICK_MSEC = GetTickCount() - this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT;

  00018	8b de		 mov	 ebx, esi
  0001a	69 db 70 08 00
	00		 imul	 ebx, 2160		; 00000870H
  00020	57		 push	 edi
  00021	8b f9		 mov	 edi, ecx
  00023	03 df		 add	 ebx, edi
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002b	2b 43 44	 sub	 eax, DWORD PTR [ebx+68]

; 464  : 
; 465  : 	if ( iTICK_MSEC >= 1000 )

  0002e	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00033	0f 8c c3 02 00
	00		 jl	 $LN49@ProcState_@3

; 466  : 	{
; 467  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC -= iTICK_MSEC;

  00039	29 43 40	 sub	 DWORD PTR [ebx+64], eax

; 468  : 		this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TICK_COUNT = GetTickCount();

  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00042	89 43 44	 mov	 DWORD PTR [ebx+68], eax

; 469  : 
; 470  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ((this->m_iCC_TIME_MIN_PLAY*60-30)*1000) &&
; 471  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_PLAY == false )

  00045	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00048	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  0004e	81 e9 30 75 00
	00		 sub	 ecx, 30000		; 00007530H
  00054	39 4b 40	 cmp	 DWORD PTR [ebx+64], ecx
  00057	7f 38		 jg	 SHORT $LN33@ProcState_@3
  00059	80 7b 50 00	 cmp	 BYTE PTR [ebx+80], 0
  0005d	75 32		 jne	 SHORT $LN33@ProcState_@3

; 472  : 		{
; 473  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_PLAY = true;
; 474  : 			
; 475  : 			PMSG_SET_DEVILSQUARE pMsg;
; 476  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0005f	6a 04		 push	 4
  00061	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$218640[ebp]
  00067	68 92 00 00 00	 push	 146			; 00000092H
  0006c	52		 push	 edx
  0006d	c6 43 50 01	 mov	 BYTE PTR [ebx+80], 1
  00071	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 477  : 			pMsg.Type = 11;
; 478  : 			this->SendChaosCastleAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  00079	56		 push	 esi
  0007a	6a 04		 push	 4
  0007c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$218640[ebp]
  00082	50		 push	 eax
  00083	8b cf		 mov	 ecx, edi
  00085	c6 85 eb fe ff
	ff 0b		 mov	 BYTE PTR _pMsg$218640[ebp+3], 11 ; 0000000bH
  0008c	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN33@ProcState_@3:

; 479  : 		}
; 480  : 
; 481  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 30000 &&
; 482  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC > 0  &&
; 483  : 			 this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_END == false )

  00091	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00094	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00099	7f 3c		 jg	 SHORT $LN47@ProcState_@3
  0009b	85 c0		 test	 eax, eax
  0009d	7e 38		 jle	 SHORT $LN47@ProcState_@3
  0009f	80 7b 51 00	 cmp	 BYTE PTR [ebx+81], 0
  000a3	75 32		 jne	 SHORT $LN47@ProcState_@3

; 484  : 		{
; 485  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_MSG_BEFORE_END = true;
; 486  : 			PMSG_SET_DEVILSQUARE pMsg;
; 487  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  000a5	6a 04		 push	 4
  000a7	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$218644[ebp]
  000ad	68 92 00 00 00	 push	 146			; 00000092H
  000b2	51		 push	 ecx
  000b3	c6 43 51 01	 mov	 BYTE PTR [ebx+81], 1
  000b7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 488  : 			pMsg.Type = 12;
; 489  : 			this->SendChaosCastleAnyMsg((LPBYTE)&pMsg, sizeof(pMsg), iChaosCastleIndex);

  000bf	56		 push	 esi
  000c0	6a 04		 push	 4
  000c2	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$218644[ebp]
  000c8	52		 push	 edx
  000c9	8b cf		 mov	 ecx, edi
  000cb	c6 85 eb fe ff
	ff 0c		 mov	 BYTE PTR _pMsg$218644[ebp+3], 12 ; 0000000cH
  000d2	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg
$LN47@ProcState_@3:

; 490  : 		}
; 491  : 
; 492  : 		// Set Play Quest
; 493  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= ((this->m_iCC_TIME_MIN_PLAY*60-60)*1000) &&
; 494  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == false )

  000d7	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000da	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  000e0	8d 88 a0 15 ff
	ff		 lea	 ecx, DWORD PTR [eax-60000]
  000e6	39 4b 40	 cmp	 DWORD PTR [ebx+64], ecx
  000e9	0f 8f a9 00 00
	00		 jg	 $LN31@ProcState_@3
  000ef	80 7b 4e 00	 cmp	 BYTE PTR [ebx+78], 0
  000f3	0f 85 e4 00 00
	00		 jne	 $LN48@ProcState_@3

; 495  : 		{
; 496  : 			PMSG_NOTICE pNotice;
; 497  : 
; 498  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC = (this->m_iCC_TIME_MIN_PLAY*60)*1000;

  000f9	89 43 40	 mov	 DWORD PTR [ebx+64], eax

; 499  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_PARTY = false;
; 500  : 
; 501  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4,209)), iChaosCastleIndex+1);

  000fc	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000ff	50		 push	 eax
  00100	68 d1 04 00 00	 push	 1233			; 000004d1H
  00105	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0010a	c6 43 4d 00	 mov	 BYTE PTR [ebx+77], 0
  0010e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00113	50		 push	 eax
  00114	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$218648[ebp]
  0011a	6a 00		 push	 0
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 502  : 			this->SendChaosCastleAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iChaosCastleIndex);

  00122	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$218648[ebp+1]
  00129	83 c4 10	 add	 esp, 16			; 00000010H
  0012c	56		 push	 esi
  0012d	50		 push	 eax
  0012e	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$218648[ebp]
  00134	51		 push	 ecx
  00135	8b cf		 mov	 ecx, edi
  00137	e8 00 00 00 00	 call	 ?SendChaosCastleAnyMsg@CChaosCastle@@QAEXPAEHH@Z ; CChaosCastle::SendChaosCastleAnyMsg

; 503  : 
; 504  : 			this->UnSafetyCastleZone(iChaosCastleIndex);

  0013c	56		 push	 esi
  0013d	8b cf		 mov	 ecx, edi
  0013f	e8 00 00 00 00	 call	 ?UnSafetyCastleZone@CChaosCastle@@QAEXH@Z ; CChaosCastle::UnSafetyCastleZone

; 505  : 			this->SendCastleZoneSafetyInfo(iChaosCastleIndex, 0);

  00144	6a 00		 push	 0
  00146	56		 push	 esi
  00147	8b cf		 mov	 ecx, edi
  00149	e8 00 00 00 00	 call	 ?SendCastleZoneSafetyInfo@CChaosCastle@@QAEXH_N@Z ; CChaosCastle::SendCastleZoneSafetyInfo

; 506  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START = true;
; 507  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_USER_COUNT = this->ReCalcUserCount(iChaosCastleIndex);

  0014e	56		 push	 esi
  0014f	8b cf		 mov	 ecx, edi
  00151	c6 43 4e 01	 mov	 BYTE PTR [ebx+78], 1
  00155	e8 00 00 00 00	 call	 ?ReCalcUserCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::ReCalcUserCount

; 508  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT = this->SetMonster(iChaosCastleIndex);

  0015a	56		 push	 esi
  0015b	8b cf		 mov	 ecx, edi
  0015d	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  00160	e8 00 00 00 00	 call	 ?SetMonster@CChaosCastle@@QAEHH@Z ; CChaosCastle::SetMonster

; 509  : 			this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_FIRST_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT; 
; 510  : 			this->SetItemsToMonster(iChaosCastleIndex);

  00165	56		 push	 esi
  00166	8b cf		 mov	 ecx, edi
  00168	89 43 60	 mov	 DWORD PTR [ebx+96], eax
  0016b	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  0016e	e8 00 00 00 00	 call	 ?SetItemsToMonster@CChaosCastle@@QAEXH@Z ; CChaosCastle::SetItemsToMonster

; 511  : 			this->SendNoticeState(iChaosCastleIndex, 5);

  00173	6a 05		 push	 5
  00175	56		 push	 esi
  00176	8b cf		 mov	 ecx, edi
  00178	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState

; 512  : 			
; 513  : 			LogAddTD("[Chaos Castle] (%d) Chaos Castle Quest Start (UserCount:%d)",	iChaosCastleIndex+1, this->GetCurPlayUser(iChaosCastleIndex));

  0017d	56		 push	 esi
  0017e	8b cf		 mov	 ecx, edi
  00180	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00185	50		 push	 eax
  00186	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00189	50		 push	 eax
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@PFNIGNGP@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@ProcState_@3:

; 514  : 		}
; 515  : 
; 516  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == false && this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_CAN_ENTER == false )

  00198	80 7b 4e 00	 cmp	 BYTE PTR [ebx+78], 0
  0019c	75 3f		 jne	 SHORT $LN48@ProcState_@3
  0019e	80 7b 4c 00	 cmp	 BYTE PTR [ebx+76], 0
  001a2	75 39		 jne	 SHORT $LN48@ProcState_@3

; 517  : 		{
; 518  : 			int iCurPlayUser = this->GetCurPlayUser(iChaosCastleIndex);

  001a4	56		 push	 esi
  001a5	8b cf		 mov	 ecx, edi
  001a7	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser

; 519  : 
; 520  : 			if (iCurPlayUser == 0 )

  001ac	85 c0		 test	 eax, eax
  001ae	75 2d		 jne	 SHORT $LN48@ProcState_@3

; 521  : 			{
; 522  : 				this->SetState(iChaosCastleIndex, CC_STATE_CLOSED);

  001b0	6a 01		 push	 1
  001b2	56		 push	 esi
  001b3	8b cf		 mov	 ecx, edi
  001b5	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState

; 523  : 				LogAddTD("[Chaos Castle] (%d) Chaos Castle Quest Closed - No User",	iChaosCastleIndex+1);

  001ba	46		 inc	 esi
  001bb	56		 push	 esi
  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@NBGGDBDE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Chaos?5Castle@
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c7	83 c4 08	 add	 esp, 8
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx

; 692  : 	}
; 693  : }

  001cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d0	33 cd		 xor	 ecx, ebp
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 04 00	 ret	 4
$LN48@ProcState_@3:

; 524  : 				return;
; 525  : 			}
; 526  : 		}
; 527  : 
; 528  : 		if ( this->m_stChaosCastleData[iChaosCastleIndex].m_bCC_PLAY_START == true )

  001dd	80 7b 4e 01	 cmp	 BYTE PTR [ebx+78], 1
  001e1	0f 85 15 01 00
	00		 jne	 $LN49@ProcState_@3

; 529  : 		{
; 530  : 			this->ProcessFallUser(iChaosCastleIndex);

  001e7	56		 push	 esi
  001e8	8b cf		 mov	 ecx, edi
  001ea	e8 00 00 00 00	 call	 ?ProcessFallUser@CChaosCastle@@QAEXH@Z ; CChaosCastle::ProcessFallUser

; 531  : 			this->CheckUserInDieTile(iChaosCastleIndex);

  001ef	56		 push	 esi
  001f0	8b cf		 mov	 ecx, edi
  001f2	e8 00 00 00 00	 call	 ?CheckUserInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckUserInDieTile

; 532  : 			this->CheckMonsterInDieTile(iChaosCastleIndex);

  001f7	56		 push	 esi
  001f8	8b cf		 mov	 ecx, edi
  001fa	e8 00 00 00 00	 call	 ?CheckMonsterInDieTile@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckMonsterInDieTile

; 533  : 			this->ProcessTrapStatus(iChaosCastleIndex);

  001ff	56		 push	 esi
  00200	8b cf		 mov	 ecx, edi
  00202	e8 00 00 00 00	 call	 ?ProcessTrapStatus@CChaosCastle@@QAEXH@Z ; CChaosCastle::ProcessTrapStatus

; 534  : 
; 535  : 			if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS != this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_OLD_STATUS )

  00207	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  0020a	3b 43 68	 cmp	 eax, DWORD PTR [ebx+104]
  0020d	74 18		 je	 SHORT $LN27@ProcState_@3

; 536  : 			{
; 537  : 				this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_OLD_STATUS = this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS;
; 538  : 				this->SetMapAttrHollow(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS);

  0020f	50		 push	 eax
  00210	56		 push	 esi
  00211	8b cf		 mov	 ecx, edi
  00213	89 43 68	 mov	 DWORD PTR [ebx+104], eax
  00216	e8 00 00 00 00	 call	 ?SetMapAttrHollow@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetMapAttrHollow

; 539  : 				this->PullObjInnerPlace(iChaosCastleIndex, this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_TRAP_STATUS);

  0021b	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  0021e	52		 push	 edx
  0021f	56		 push	 esi
  00220	8b cf		 mov	 ecx, edi
  00222	e8 00 00 00 00	 call	 ?PullObjInnerPlace@CChaosCastle@@QAEXHH@Z ; CChaosCastle::PullObjInnerPlace
$LN27@ProcState_@3:

; 540  : 			}
; 541  : 
; 542  : 			BOOL bPlayEnded = this->CheckPlayEnded(iChaosCastleIndex);

  00227	56		 push	 esi
  00228	8b cf		 mov	 ecx, edi
  0022a	e8 00 00 00 00	 call	 ?CheckPlayEnded@CChaosCastle@@QAEHH@Z ; CChaosCastle::CheckPlayEnded

; 543  : 
; 544  : 			if ( bPlayEnded == TRUE )

  0022f	83 f8 01	 cmp	 eax, 1
  00232	0f 85 ad 00 00
	00		 jne	 $LN26@ProcState_@3
$LN55@ProcState_@3:

; 545  : 			{
; 546  : 				int iWinnerIndex = -1;
; 547  : 				int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  00238	56		 push	 esi
  00239	8b cf		 mov	 ecx, edi
  0023b	c7 85 e4 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$218660[ebp], -1
  00245	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 548  : 
; 549  : 				if ( iMonsterCount <= 0 )

  0024a	85 c0		 test	 eax, eax
  0024c	0f 8f 86 00 00
	00		 jg	 $LN25@ProcState_@3

; 550  : 				{
; 551  : 					iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  00252	56		 push	 esi
  00253	8b cf		 mov	 ecx, edi
  00255	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  0025a	8b d8		 mov	 ebx, eax

; 552  : 
; 553  : 					if ( iWinnerIndex != -1 )

  0025c	83 fb ff	 cmp	 ebx, -1
  0025f	0f 84 85 01 00
	00		 je	 $LN13@ProcState_@3

; 554  : 					{
; 555  : 						LogAddTD("[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 556  : 							iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 557  : 							gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 558  : 							gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 559  : 							gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 560  : 							gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  00265	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0026b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00271	0f be 90 3d 01
	00 00		 movsx	 edx, BYTE PTR [eax+317]
  00278	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0027f	52		 push	 edx
  00280	0f b7 90 18 01
	00 00		 movzx	 edx, WORD PTR [eax+280]
  00287	51		 push	 ecx
  00288	0f b7 88 fa 00
	00 00		 movzx	 ecx, WORD PTR [eax+250]
  0028f	52		 push	 edx
  00290	0f b7 90 f8 00
	00 00		 movzx	 edx, WORD PTR [eax+248]
  00297	51		 push	 ecx
  00298	0f b7 88 f6 00
	00 00		 movzx	 ecx, WORD PTR [eax+246]
  0029f	52		 push	 edx
  002a0	0f b7 90 f4 00
	00 00		 movzx	 edx, WORD PTR [eax+244]
  002a7	51		 push	 ecx
  002a8	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  002ae	52		 push	 edx
  002af	8b 90 c0 00 00
	00		 mov	 edx, DWORD PTR [eax+192]
  002b5	51		 push	 ecx
  002b6	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  002bd	52		 push	 edx
  002be	0f b7 90 b8 00
	00 00		 movzx	 edx, WORD PTR [eax+184]
  002c5	51		 push	 ecx
  002c6	52		 push	 edx
  002c7	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  002ca	51		 push	 ecx
  002cb	83 c0 6c	 add	 eax, 108		; 0000006cH
  002ce	50		 push	 eax
  002cf	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  002d2	52		 push	 edx

; 561  : 
; 562  : 						this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);
; 563  : 						this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);
; 564  : 					}
; 565  : 					else

  002d3	e9 ed 00 00 00	 jmp	 $LN54@ProcState_@3
$LN25@ProcState_@3:

; 566  : 					{
; 567  : 						LogAddTD("[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);
; 568  : 					}
; 569  : 				}
; 570  : 				else
; 571  : 				{
; 572  : 					LogAddTD("[Chaos Castle] (%d) Has No Winner : Monster Left (%d)", iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  002d8	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]
  002db	51		 push	 ecx
  002dc	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  002df	52		 push	 edx

; 573  : 				}
; 574  : 
; 575  : 				this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);
; 576  : 				this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);
; 577  : 				return;

  002e0	e9 d4 01 00 00	 jmp	 $LN52@ProcState_@3
$LN26@ProcState_@3:

; 578  : 			}
; 579  : 		
; 580  : 			if ( bPlayEnded == 2 )

  002e5	83 f8 02	 cmp	 eax, 2

; 581  : 			{
; 582  : 				int iWinnerIndex = -1;
; 583  : 				int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);
; 584  : 
; 585  : 				if ( iMonsterCount <= 0 )
; 586  : 				{
; 587  : 					iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);
; 588  : 
; 589  : 					if ( iWinnerIndex != -1 )
; 590  : 					{
; 591  : 						LogAddTD("[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 592  : 							iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 593  : 							gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 594  : 							gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 595  : 							gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 596  : 							gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);
; 597  : 
; 598  : 						this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);
; 599  : 						this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);
; 600  : 					}
; 601  : 					else

  002e8	0f 84 4a ff ff
	ff		 je	 $LN55@ProcState_@3

; 602  : 					{
; 603  : 						LogAddTD("[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);
; 604  : 					}
; 605  : 				}
; 606  : 				else
; 607  : 				{
; 608  : 					LogAddTD("[Chaos Castle] (%d) Has No Winner : Monster Left (%d)",
; 609  : 						iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);
; 610  : 				}
; 611  : 
; 612  : 				this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);
; 613  : 				this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);
; 614  : 
; 615  : 				return;
; 616  : 			}
; 617  : 		
; 618  : 			if ( bPlayEnded == FALSE )

  002ee	85 c0		 test	 eax, eax
  002f0	75 0a		 jne	 SHORT $LN49@ProcState_@3

; 619  : 			{
; 620  : 				this->SendNoticeState(iChaosCastleIndex, 6);

  002f2	6a 06		 push	 6
  002f4	56		 push	 esi
  002f5	8b cf		 mov	 ecx, edi
  002f7	e8 00 00 00 00	 call	 ?SendNoticeState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendNoticeState
$LN49@ProcState_@3:

; 621  : 			}
; 622  : 		}
; 623  : 	}
; 624  : 
; 625  : 	if ( this->m_stChaosCastleData[iChaosCastleIndex].m_iCC_REMAIN_MSEC <= 0 )

  002fc	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  00300	0f 8f da 01 00
	00		 jg	 $LN15@ProcState_@3

; 626  : 	{
; 627  : 		LogAddTD("[Chaos Castle] (%d) is Over : TIME-OUT (Left User:%d, Monster:%d)", iChaosCastleIndex+1, this->GetCurPlayUser(iChaosCastleIndex), this->GetMonsterListCount(iChaosCastleIndex));

  00306	56		 push	 esi
  00307	8b cf		 mov	 ecx, edi
  00309	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount
  0030e	50		 push	 eax
  0030f	56		 push	 esi
  00310	8b cf		 mov	 ecx, edi
  00312	e8 00 00 00 00	 call	 ?GetCurPlayUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurPlayUser
  00317	50		 push	 eax
  00318	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0031b	50		 push	 eax
  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CDMJLAJE@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5is?5Over?5?3?5TI@
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00327	83 c4 10	 add	 esp, 16			; 00000010H

; 628  : 
; 629  : 		int iWinnerIndex = -1;
; 630  : 		int iMonsterCount = this->GetMonsterListCount(iChaosCastleIndex);

  0032a	56		 push	 esi
  0032b	8b cf		 mov	 ecx, edi
  0032d	c7 85 e4 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _iWinnerIndex$218679[ebp], -1
  00337	e8 00 00 00 00	 call	 ?GetMonsterListCount@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetMonsterListCount

; 631  : 
; 632  : 		if ( iMonsterCount <= 0 )
; 633  : 		{
; 634  : 			iWinnerIndex = this->GetCurrentWinUser(iChaosCastleIndex);

  0033c	56		 push	 esi
  0033d	8b cf		 mov	 ecx, edi
  0033f	85 c0		 test	 eax, eax
  00341	0f 8f ba 00 00
	00		 jg	 $LN14@ProcState_@3
  00347	e8 00 00 00 00	 call	 ?GetCurrentWinUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentWinUser
  0034c	8b d8		 mov	 ebx, eax

; 635  : 
; 636  : 			if ( iWinnerIndex != -1 )

  0034e	83 fb ff	 cmp	 ebx, -1
  00351	0f 84 93 00 00
	00		 je	 $LN13@ProcState_@3

; 637  : 			{
; 638  : 				LogAddTD("[Chaos Castle] (%d) [%s][%s] is Winner. [CharInfoSave : Class=%d, Level=%d, LvPoint=%d, Exp=%d, Str=%d, Dex=%d, Vit=%d, Energy=%d, LeaderShip=%d, Map=%d, Pk=%d]",
; 639  : 					iChaosCastleIndex+1, gObj[iWinnerIndex].AccountID, gObj[iWinnerIndex].Name,
; 640  : 					gObj[iWinnerIndex].Class, gObj[iWinnerIndex].Level, gObj[iWinnerIndex].LevelUpPoint,
; 641  : 					gObj[iWinnerIndex].Experience, gObj[iWinnerIndex].Strength,
; 642  : 					gObj[iWinnerIndex].Dexterity, gObj[iWinnerIndex].Vitality, gObj[iWinnerIndex].Energy,
; 643  : 					gObj[iWinnerIndex].Leadership, gObj[iWinnerIndex].MapNumber, gObj[iWinnerIndex].m_PK_Level);

  00357	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0035d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00363	0f be 90 3d 01
	00 00		 movsx	 edx, BYTE PTR [eax+317]
  0036a	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00371	52		 push	 edx
  00372	0f b7 90 18 01
	00 00		 movzx	 edx, WORD PTR [eax+280]
  00379	51		 push	 ecx
  0037a	0f b7 88 fa 00
	00 00		 movzx	 ecx, WORD PTR [eax+250]
  00381	52		 push	 edx
  00382	0f b7 90 f8 00
	00 00		 movzx	 edx, WORD PTR [eax+248]
  00389	51		 push	 ecx
  0038a	0f b7 88 f6 00
	00 00		 movzx	 ecx, WORD PTR [eax+246]
  00391	52		 push	 edx
  00392	0f b7 90 f4 00
	00 00		 movzx	 edx, WORD PTR [eax+244]
  00399	51		 push	 ecx
  0039a	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  003a0	52		 push	 edx
  003a1	8b 90 c0 00 00
	00		 mov	 edx, DWORD PTR [eax+192]
  003a7	51		 push	 ecx
  003a8	0f bf 88 be 00
	00 00		 movsx	 ecx, WORD PTR [eax+190]
  003af	52		 push	 edx
  003b0	0f b7 90 b8 00
	00 00		 movzx	 edx, WORD PTR [eax+184]
  003b7	51		 push	 ecx
  003b8	52		 push	 edx
  003b9	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  003bc	51		 push	 ecx
  003bd	83 c0 6c	 add	 eax, 108		; 0000006cH
  003c0	50		 push	 eax
  003c1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  003c4	50		 push	 eax
$LN54@ProcState_@3:
  003c5	68 00 00 00 00	 push	 OFFSET ??_C@_0KB@EOIGCIIB@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5@
  003ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003d0	83 c4 3c	 add	 esp, 60			; 0000003cH

; 644  : 
; 645  : 				this->SendWinMessage(iChaosCastleIndex, iWinnerIndex);

  003d3	53		 push	 ebx
  003d4	56		 push	 esi
  003d5	8b cf		 mov	 ecx, edi
  003d7	e8 00 00 00 00	 call	 ?SendWinMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendWinMessage

; 646  : 				this->GiveWinnerItem(iChaosCastleIndex, iWinnerIndex);

  003dc	53		 push	 ebx
  003dd	56		 push	 esi
  003de	8b cf		 mov	 ecx, edi
  003e0	e8 00 00 00 00	 call	 ?GiveWinnerItem@CChaosCastle@@QAEXHH@Z ; CChaosCastle::GiveWinnerItem

; 647  : 			}
; 648  : 			else

  003e5	e9 e3 00 00 00	 jmp	 $LN1@ProcState_@3
$LN13@ProcState_@3:

; 649  : 			{
; 650  : 				LogAddTD("[Chaos Castle] (%d) Has No Winner.", iChaosCastleIndex+1);

  003ea	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  003ed	50		 push	 eax
  003ee	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JOONMNFN@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  003f3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003f9	83 c4 08	 add	 esp, 8

; 651  : 			}
; 652  : 		}
; 653  : 		else

  003fc	e9 cc 00 00 00	 jmp	 $LN1@ProcState_@3
$LN14@ProcState_@3:

; 654  : 		{
; 655  : 			if( this->GetCurrentState(iChaosCastleIndex) == 1) //season 2.5 add-on

  00401	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  00406	83 f8 01	 cmp	 eax, 1
  00409	0f 85 a2 00 00
	00		 jne	 $LN10@ProcState_@3

; 656  : 			{
; 657  : 				for ( int i=0;i<MAX_CHAOSCASTLE_MONSTER;i++)

  0040f	81 c3 e4 05 00
	00		 add	 ebx, 1508		; 000005e4H
  00415	c7 85 e8 fe ff
	ff 64 00 00 00	 mov	 DWORD PTR tv603[ebp], 100 ; 00000064H
  0041f	90		 npad	 1
$LL9@ProcState_@3:

; 658  : 				{
; 659  : 					if(this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] == -1)

  00420	8b 03		 mov	 eax, DWORD PTR [ebx]
  00422	83 f8 ff	 cmp	 eax, -1
  00425	74 79		 je	 SHORT $LN8@ProcState_@3

; 660  : 					{
; 661  : 						continue;
; 662  : 					}
; 663  : 
; 664  : 					int CC_MONSTER_COUNT = this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i];
; 665  : 					
; 666  : 					if ( ((CC_MONSTER_COUNT<0)?FALSE:(CC_MONSTER_COUNT>OBJ_MAXMONSTER-1)?FALSE:TRUE) == FALSE ) 

  00427	85 c0		 test	 eax, eax
  00429	78 0e		 js	 SHORT $LN45@ProcState_@3
  0042b	33 c9		 xor	 ecx, ecx
  0042d	3d c7 32 00 00	 cmp	 eax, 12999		; 000032c7H
  00432	0f 9e c1	 setle	 cl
  00435	85 c9		 test	 ecx, ecx
  00437	75 08		 jne	 SHORT $LN5@ProcState_@3
$LN45@ProcState_@3:

; 667  : 					{
; 668  : 						this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_MONSTER_COUNT[i] = -1;

  00439	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 669  : 						continue;

  0043f	eb 5f		 jmp	 SHORT $LN8@ProcState_@3
$LN5@ProcState_@3:

; 670  : 					}
; 671  : 
; 672  : 					if(gObj[CC_MONSTER_COUNT].Life > 0.0f)

  00441	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00447	d9 ee		 fldz
  00449	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0044f	d8 9c 10 fc 00
	00 00		 fcomp	 DWORD PTR [eax+edx+252]
  00456	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00459	df e0		 fnstsw	 ax
  0045b	f6 c4 05	 test	 ah, 5
  0045e	7a 40		 jp	 SHORT $LN8@ProcState_@3

; 673  : 					{
; 674  : 						if(CC_MAP_RANGE(gObj[CC_MONSTER_COUNT].MapNumber) != FALSE)

  00460	0f b6 81 49 01
	00 00		 movzx	 eax, BYTE PTR [ecx+329]
  00467	3c 35		 cmp	 al, 53			; 00000035H
  00469	74 0d		 je	 SHORT $LN46@ProcState_@3
  0046b	3c 12		 cmp	 al, 18			; 00000012H
  0046d	72 31		 jb	 SHORT $LN8@ProcState_@3
  0046f	b2 17		 mov	 dl, 23			; 00000017H
  00471	3a d0		 cmp	 dl, al
  00473	1b c0		 sbb	 eax, eax
  00475	40		 inc	 eax
  00476	74 28		 je	 SHORT $LN8@ProcState_@3
$LN46@ProcState_@3:

; 675  : 						{
; 676  : 							if(gObj[CC_MONSTER_COUNT].Connected > 0)

  00478	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0047c	7e 22		 jle	 SHORT $LN8@ProcState_@3

; 677  : 							{
; 678  : 								LogAddTD("[Chaos Castle][Bug Tracer] (%d) Left Monster AttrInfo %d/%d", iChaosCastleIndex+1, gObj[CC_MONSTER_COUNT].X, gObj[CC_MONSTER_COUNT].Y);

  0047e	0f bf 81 46 01
	00 00		 movsx	 eax, WORD PTR [ecx+326]
  00485	0f bf 89 44 01
	00 00		 movsx	 ecx, WORD PTR [ecx+324]
  0048c	50		 push	 eax
  0048d	51		 push	 ecx
  0048e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ENGGGAC@?$FLChaos?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0049d	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@ProcState_@3:

; 656  : 			{
; 657  : 				for ( int i=0;i<MAX_CHAOSCASTLE_MONSTER;i++)

  004a0	83 c3 04	 add	 ebx, 4
  004a3	ff 8d e8 fe ff
	ff		 dec	 DWORD PTR tv603[ebp]
  004a9	0f 85 71 ff ff
	ff		 jne	 $LL9@ProcState_@3

; 679  : 							}
; 680  : 						}
; 681  : 					}
; 682  : 				}
; 683  : 			}
; 684  : 			else

  004af	eb 16		 jmp	 SHORT $LN53@ProcState_@3
$LN10@ProcState_@3:

; 685  : 			{
; 686  : 				LogAddTD("[Chaos Castle] (%d) Has No Winner : Monster Left (%d)", iChaosCastleIndex+1, this->m_stChaosCastleData[iChaosCastleIndex].m_lCC_CURRENT_MONSTER_COUNT);

  004b1	8b 53 60	 mov	 edx, DWORD PTR [ebx+96]
  004b4	52		 push	 edx
  004b5	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  004b8	50		 push	 eax
$LN52@ProcState_@3:
  004b9	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DNCOEMLJ@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5Has?5No?5Winne@
  004be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@ProcState_@3:
  004c7	8b 9d e4 fe ff
	ff		 mov	 ebx, DWORD PTR _iWinnerIndex$218679[ebp]
$LN1@ProcState_@3:

; 687  : 			}
; 688  : 		}
; 689  : 
; 690  : 		this->SendAllLoserFailMessage(iChaosCastleIndex, iWinnerIndex);

  004cd	53		 push	 ebx
  004ce	56		 push	 esi
  004cf	8b cf		 mov	 ecx, edi
  004d1	e8 00 00 00 00	 call	 ?SendAllLoserFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendAllLoserFailMessage

; 691  : 		this->SetState(iChaosCastleIndex, CC_STATE_PLAYEND);

  004d6	6a 03		 push	 3
  004d8	56		 push	 esi
  004d9	8b cf		 mov	 ecx, edi
  004db	e8 00 00 00 00	 call	 ?SetState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetState
$LN15@ProcState_@3:

; 692  : 	}
; 693  : }

  004e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e3	5f		 pop	 edi
  004e4	5e		 pop	 esi
  004e5	33 cd		 xor	 ecx, ebp
  004e7	5b		 pop	 ebx
  004e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ed	8b e5		 mov	 esp, ebp
  004ef	5d		 pop	 ebp
  004f0	c2 04 00	 ret	 4
?ProcState_Playing@CChaosCastle@@IAEXH@Z ENDP		; CChaosCastle::ProcState_Playing
_TEXT	ENDS
PUBLIC	?Run@CChaosCastle@@QAEXXZ			; CChaosCastle::Run
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
; Function compile flags: /Ogtp
;	COMDAT ?Run@CChaosCastle@@QAEXXZ
_TEXT	SEGMENT
?Run@CChaosCastle@@QAEXXZ PROC				; CChaosCastle::Run, COMDAT
; _this$ = ecx

; 64   : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 65   : 	if ( this->m_bCC_EVENT_ENABLE != FALSE )

  00003	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00007	74 4e		 je	 SHORT $LN1@Run

; 66   : 	{
; 67   : 		for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 7b 30	 lea	 edi, DWORD PTR [ebx+48]
$LL10@Run:

; 68   : 		{
; 69   : 			switch ( this->m_stChaosCastleData[i].m_iCC_STATE )

  00010	8b 07		 mov	 eax, DWORD PTR [edi]
  00012	83 f8 03	 cmp	 eax, 3
  00015	77 23		 ja	 SHORT $LN9@Run
  00017	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@Run[eax*4]
$LN4@Run:

; 70   : 			{
; 71   : 				case CC_STATE_NONE:
; 72   : 					this->ProcState_None(i);
; 73   : 					break;
; 74   : 
; 75   : 				case CC_STATE_CLOSED:
; 76   : 					this->ProcState_Closed(i);

  0001e	56		 push	 esi
  0001f	8b cb		 mov	 ecx, ebx
  00021	e8 00 00 00 00	 call	 ?ProcState_Closed@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_Closed

; 77   : 					break;

  00026	eb 12		 jmp	 SHORT $LN9@Run
$LN3@Run:

; 78   : 
; 79   : 				case CC_STATE_PLAYING:
; 80   : 					this->ProcState_Playing(i);

  00028	56		 push	 esi
  00029	8b cb		 mov	 ecx, ebx
  0002b	e8 00 00 00 00	 call	 ?ProcState_Playing@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_Playing

; 81   : 					break;

  00030	eb 08		 jmp	 SHORT $LN9@Run
$LN2@Run:

; 82   : 
; 83   : 				case CC_STATE_PLAYEND:
; 84   : 					this->ProcState_PlayEnd(i);

  00032	56		 push	 esi
  00033	8b cb		 mov	 ecx, ebx
  00035	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CChaosCastle@@IAEXH@Z ; CChaosCastle::ProcState_PlayEnd
$LN9@Run:

; 66   : 	{
; 67   : 		for ( int i=0;i<MAX_CHAOSCASTLE_LEVEL;i++)

  0003a	46		 inc	 esi
  0003b	81 c7 70 08 00
	00		 add	 edi, 2160		; 00000870H
  00041	83 fe 07	 cmp	 esi, 7
  00044	7c ca		 jl	 SHORT $LL10@Run

; 85   : 					break;
; 86   : 			}
; 87   : 		}
; 88   : 
; 89   : 		if ( szAuthKey[13] != AUTHKEY13 )

  00046	80 3d 0d 00 00
	00 bb		 cmp	 BYTE PTR ?szAuthKey@@3PADA+13, -69 ; ffffffbbH
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	74 06		 je	 SHORT $LN1@Run
  00051	5b		 pop	 ebx

; 90   : 		{
; 91   : 			DestroyGIocp();

  00052	e9 00 00 00 00	 jmp	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN1@Run:
  00057	5b		 pop	 ebx

; 92   : 		}
; 93   : 
; 94   : 	}
; 95   : }

  00058	c3		 ret	 0
  00059	8d 49 00	 npad	 3
$LN18@Run:
  0005c	00 00 00 00	 DD	 $LN9@Run
  00060	00 00 00 00	 DD	 $LN4@Run
  00064	00 00 00 00	 DD	 $LN3@Run
  00068	00 00 00 00	 DD	 $LN2@Run
?Run@CChaosCastle@@QAEXXZ ENDP				; CChaosCastle::Run
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_ChaosCastle@@YAXXZ
text$yc	SEGMENT
??__Eg_ChaosCastle@@YAXXZ PROC				; `dynamic initializer for 'g_ChaosCastle'', COMDAT

; 28   : CChaosCastle g_ChaosCastle;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00005	e8 00 00 00 00	 call	 ??0CChaosCastle@@QAE@XZ	; CChaosCastle::CChaosCastle
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_ChaosCastle@@YAXXZ ; `dynamic atexit destructor for 'g_ChaosCastle''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_ChaosCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_ChaosCastle''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_ChaosCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_ChaosCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ChaosCastle'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00005	e9 00 00 00 00	 jmp	 ??1CChaosCastle@@UAE@XZ	; CChaosCastle::~CChaosCastle
??__Fg_ChaosCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ChaosCastle''
text$yd	ENDS
PUBLIC	?g_ChaosCastle@@3VCChaosCastle@@A		; g_ChaosCastle
_BSS	SEGMENT
?g_ChaosCastle@@3VCChaosCastle@@A DB 03b94H DUP (?)	; g_ChaosCastle
_BSS	ENDS
CRT$XCU	SEGMENT
_g_ChaosCastle$initializer$ DD FLAT:??__Eg_ChaosCastle@@YAXXZ
CRT$XCU	ENDS
END
