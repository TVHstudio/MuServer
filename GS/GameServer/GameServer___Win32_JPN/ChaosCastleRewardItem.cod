; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\ChaosCastleRewardItem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gChaosCastleRewardItem@@3VCChaosCastleRewardItem@@A ; gChaosCastleRewardItem
_BSS	SEGMENT
?gChaosCastleRewardItem@@3VCChaosCastleRewardItem@@A DB 0af20H DUP (?) ; gChaosCastleRewardItem
_BSS	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0CJ@ICOICLOC@?4?4?2Data?2ZtData?2ChaosCastleReward@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@CChaosCastleRewardItem@@QAEXXZ		; CChaosCastleRewardItem::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\chaoscastlerewarditem.cpp
CONST	SEGMENT
??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB ' '
	DB	'%d %d %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ICOICLOC@?4?4?2Data?2ZtData?2ChaosCastleReward@
CONST	SEGMENT
??_C@_0CJ@ICOICLOC@?4?4?2Data?2ZtData?2ChaosCastleReward@ DB '..\Data\ZtD'
	DB	'ata\ChaosCastleRewardItem.ini', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@CChaosCastleRewardItem@@QAEXXZ
_TEXT	SEGMENT
tv542 = -304						; size = 4
_file$ = -300						; size = 4
_Flag$ = -296						; size = 4
_n$206127 = -292					; size = 32
_Buff$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?Load@CChaosCastleRewardItem@@QAEXXZ PROC		; CChaosCastleRewardItem::Load, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	57		 push	 edi
  00015	8b d9		 mov	 ebx, ecx

; 12   : 	if(!g_ZtLicense.CheckUser(Local) && 
; 13   : 	   !g_ZtLicense.CheckUser(MedoniAndrei))

  00017	33 ff		 xor	 edi, edi
  00019	57		 push	 edi
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0001f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00024	84 c0		 test	 al, al
  00026	75 22		 jne	 SHORT $LN19@Load
  00028	6a 32		 push	 50			; 00000032H
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0002f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00034	84 c0		 test	 al, al
  00036	75 12		 jne	 SHORT $LN19@Load

; 14   : 	{
; 15   : 		this->Enable = 0;

  00038	89 3b		 mov	 DWORD PTR [ebx], edi
  0003a	5f		 pop	 edi
  0003b	5b		 pop	 ebx

; 87   : }

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN19@Load:
  0004a	56		 push	 esi

; 16   : 		return;
; 17   : 	}
; 18   : 
; 19   : 	this->Enable = GetPrivateProfileInt("ZtTeam","Enable",0,CC_REWARD_ITEM_DIR);

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@ICOICLOC@?4?4?2Data?2ZtData?2ChaosCastleReward@
  00050	57		 push	 edi
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00061	89 03		 mov	 DWORD PTR [ebx], eax
  00063	8d 53 08	 lea	 edx, DWORD PTR [ebx+8]
  00066	be 07 00 00 00	 mov	 esi, 7
  0006b	eb 03 8d 49 00	 npad	 5
$LL18@Load:

; 22   : 	{
; 23   : 		for(int i=0;i<MAX_CC_REWARD_ITEM;i++)

  00070	8b c2		 mov	 eax, edx
  00072	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
$LL15@Load:

; 24   : 		{
; 25   : 			this->Reward[i][j].Type		= 0;

  00077	89 78 fc	 mov	 DWORD PTR [eax-4], edi

; 26   : 			this->Reward[i][j].Index	= 0;

  0007a	89 38		 mov	 DWORD PTR [eax], edi

; 27   : 			this->Reward[i][j].Level	= 0;

  0007c	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 28   : 			this->Reward[i][j].Skill	= 0;

  0007f	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 29   : 			this->Reward[i][j].Luck		= 0;

  00082	89 78 0c	 mov	 DWORD PTR [eax+12], edi

; 30   : 			this->Reward[i][j].Opt		= 0;

  00085	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 31   : 			this->Reward[i][j].Exl		= 0;

  00088	89 78 14	 mov	 DWORD PTR [eax+20], edi

; 32   : 			this->Reward[i][j].Anc		= 0;

  0008b	89 78 18	 mov	 DWORD PTR [eax+24], edi
  0008e	05 e0 00 00 00	 add	 eax, 224		; 000000e0H
  00093	49		 dec	 ecx
  00094	75 e1		 jne	 SHORT $LL15@Load

; 20   : 
; 21   : 	for (int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)

  00096	83 c2 20	 add	 edx, 32			; 00000020H
  00099	4e		 dec	 esi
  0009a	75 d4		 jne	 SHORT $LL18@Load

; 33   : 		}
; 34   : 	}
; 35   : 
; 36   : 	FILE *file = fopen(CC_REWARD_ITEM_DIR,"r");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@ICOICLOC@?4?4?2Data?2ZtData?2ChaosCastleReward@
  000a6	e8 00 00 00 00	 call	 _fopen
  000ab	8b f0		 mov	 esi, eax
  000ad	83 c4 08	 add	 esp, 8
  000b0	89 b5 d4 fe ff
	ff		 mov	 DWORD PTR _file$[ebp], esi

; 37   : 
; 38   : 	if(file == NULL)

  000b6	3b f7		 cmp	 esi, edi
  000b8	75 13		 jne	 SHORT $LN12@Load

; 39   : 	{
; 40   : 		this->Enable = 0;

  000ba	5e		 pop	 esi
  000bb	89 3b		 mov	 DWORD PTR [ebx], edi
  000bd	5f		 pop	 edi
  000be	5b		 pop	 ebx

; 87   : }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	33 cd		 xor	 ecx, ebp
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN12@Load:

; 41   : 		return;
; 42   : 	}
; 43   : 
; 44   : 	char Buff[256];
; 45   : 	int Flag = 0;
; 46   : 
; 47   : 	for (int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)
; 48   : 	{
; 49   : 		this->Count[j] = 0;
; 50   : 	}
; 51   : 	
; 52   : 	while(!feof(file))

  000cd	56		 push	 esi
  000ce	89 bd d8 fe ff
	ff		 mov	 DWORD PTR _Flag$[ebp], edi
  000d4	89 bb 04 af 00
	00		 mov	 DWORD PTR [ebx+44804], edi
  000da	89 bb 08 af 00
	00		 mov	 DWORD PTR [ebx+44808], edi
  000e0	89 bb 0c af 00
	00		 mov	 DWORD PTR [ebx+44812], edi
  000e6	89 bb 10 af 00
	00		 mov	 DWORD PTR [ebx+44816], edi
  000ec	89 bb 14 af 00
	00		 mov	 DWORD PTR [ebx+44820], edi
  000f2	89 bb 18 af 00
	00		 mov	 DWORD PTR [ebx+44824], edi
  000f8	89 bb 1c af 00
	00		 mov	 DWORD PTR [ebx+44828], edi
  000fe	e8 00 00 00 00	 call	 _feof
  00103	83 c4 04	 add	 esp, 4
  00106	85 c0		 test	 eax, eax
  00108	0f 85 ab 01 00
	00		 jne	 $LN7@Load
  0010e	8b ff		 npad	 2
$LL8@Load:

; 53   : 	{
; 54   : 		fgets(Buff,256,file);	

  00110	56		 push	 esi
  00111	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00117	68 00 01 00 00	 push	 256			; 00000100H
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _fgets

; 55   : 
; 56   : 		if(Zt_IsBadFileLine(Buff, Flag))	

  00122	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _Flag$[ebp]
  00128	51		 push	 ecx
  00129	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  00135	83 c4 14	 add	 esp, 20			; 00000014H
  00138	84 c0		 test	 al, al
  0013a	0f 85 68 01 00
	00		 jne	 $LN28@Load

; 57   : 			continue;
; 58   : 
; 59   : 		for(int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)

  00140	8d b3 04 af 00
	00		 lea	 esi, DWORD PTR [ebx+44804]
  00146	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL5@Load:

; 60   : 		{
; 61   : 			if(Flag == (j+1))

  00150	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00153	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv542[ebp], eax
  00159	39 85 d8 fe ff
	ff		 cmp	 DWORD PTR _Flag$[ebp], eax
  0015f	0f 85 2d 01 00
	00		 jne	 $LN4@Load

; 62   : 			{
; 63   : 				int n[8];
; 64   : 
; 65   : 				sscanf(Buff," %d %d %d %d %d %d %d %d %d",&n[0],&n[1],&n[2],&n[3],&n[4],&n[5],&n[6],&n[7]);

  00165	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _n$206127[ebp+28]
  0016b	50		 push	 eax
  0016c	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$206127[ebp+24]
  00172	51		 push	 ecx
  00173	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _n$206127[ebp+20]
  00179	52		 push	 edx
  0017a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _n$206127[ebp+16]
  00180	50		 push	 eax
  00181	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$206127[ebp+12]
  00187	51		 push	 ecx
  00188	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _n$206127[ebp+8]
  0018e	52		 push	 edx
  0018f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _n$206127[ebp+4]
  00195	50		 push	 eax
  00196	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _n$206127[ebp]
  0019c	51		 push	 ecx
  0019d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EFDCNEL@?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 _sscanf

; 66   : 
; 67   : 				this->Reward[this->Count[j]][j].Type	= n[0];

  001ae	8b 06		 mov	 eax, DWORD PTR [esi]
  001b0	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp]
  001b6	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001bd	2b c8		 sub	 ecx, eax
  001bf	03 cf		 add	 ecx, edi
  001c1	c1 e1 05	 shl	 ecx, 5
  001c4	89 54 19 04	 mov	 DWORD PTR [ecx+ebx+4], edx

; 68   : 				this->Reward[this->Count[j]][j].Index	= n[1];

  001c8	8b 06		 mov	 eax, DWORD PTR [esi]
  001ca	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp+4]
  001d0	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001d7	2b c8		 sub	 ecx, eax
  001d9	03 cf		 add	 ecx, edi
  001db	c1 e1 05	 shl	 ecx, 5
  001de	89 54 19 08	 mov	 DWORD PTR [ecx+ebx+8], edx

; 69   : 				this->Reward[this->Count[j]][j].Level	= n[2];

  001e2	8b 06		 mov	 eax, DWORD PTR [esi]
  001e4	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp+8]
  001ea	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001f1	2b c8		 sub	 ecx, eax
  001f3	03 cf		 add	 ecx, edi
  001f5	c1 e1 05	 shl	 ecx, 5
  001f8	89 54 19 0c	 mov	 DWORD PTR [ecx+ebx+12], edx

; 70   : 				this->Reward[this->Count[j]][j].Skill	= n[3];

  001fc	8b 06		 mov	 eax, DWORD PTR [esi]
  001fe	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp+12]
  00204	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0020b	2b c8		 sub	 ecx, eax
  0020d	03 cf		 add	 ecx, edi
  0020f	c1 e1 05	 shl	 ecx, 5
  00212	89 54 19 10	 mov	 DWORD PTR [ecx+ebx+16], edx

; 71   : 				this->Reward[this->Count[j]][j].Luck	= n[4];

  00216	8b 06		 mov	 eax, DWORD PTR [esi]
  00218	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp+16]
  0021e	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00225	2b c8		 sub	 ecx, eax
  00227	03 cf		 add	 ecx, edi
  00229	c1 e1 05	 shl	 ecx, 5
  0022c	89 54 19 14	 mov	 DWORD PTR [ecx+ebx+20], edx

; 72   : 				this->Reward[this->Count[j]][j].Opt		= n[5];

  00230	8b 06		 mov	 eax, DWORD PTR [esi]
  00232	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp+20]
  00238	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0023f	2b c8		 sub	 ecx, eax
  00241	03 cf		 add	 ecx, edi
  00243	c1 e1 05	 shl	 ecx, 5
  00246	89 54 19 18	 mov	 DWORD PTR [ecx+ebx+24], edx

; 73   : 				this->Reward[this->Count[j]][j].Exl		= n[6];

  0024a	8b 06		 mov	 eax, DWORD PTR [esi]
  0024c	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _n$206127[ebp+24]
  00252	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00259	2b c8		 sub	 ecx, eax
  0025b	03 cf		 add	 ecx, edi
  0025d	c1 e1 05	 shl	 ecx, 5
  00260	89 54 19 1c	 mov	 DWORD PTR [ecx+ebx+28], edx

; 74   : 				this->Reward[this->Count[j]][j].Anc		= n[7];

  00264	8b 06		 mov	 eax, DWORD PTR [esi]
  00266	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0026d	2b c8		 sub	 ecx, eax
  0026f	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _n$206127[ebp+28]
  00275	8d 54 39 01	 lea	 edx, DWORD PTR [ecx+edi+1]
  00279	c1 e2 05	 shl	 edx, 5
  0027c	89 04 1a	 mov	 DWORD PTR [edx+ebx], eax

; 75   : 
; 76   : 				this->Count[j]++;

  0027f	ff 06		 inc	 DWORD PTR [esi]
  00281	83 c4 28	 add	 esp, 40			; 00000028H

; 77   : 
; 78   : 				if(this->Count[j]>=MAX_CC_REWARD_ITEM)

  00284	81 3e c8 00 00
	00		 cmp	 DWORD PTR [esi], 200	; 000000c8H
  0028a	7d 14		 jge	 SHORT $LN41@Load
  0028c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv542[ebp]
$LN4@Load:

; 57   : 			continue;
; 58   : 
; 59   : 		for(int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)

  00292	8b f8		 mov	 edi, eax
  00294	83 c6 04	 add	 esi, 4
  00297	83 ff 07	 cmp	 edi, 7
  0029a	0f 8c b0 fe ff
	ff		 jl	 $LL5@Load
$LN41@Load:
  002a0	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _file$[ebp]
  002a6	33 ff		 xor	 edi, edi
$LN28@Load:

; 41   : 		return;
; 42   : 	}
; 43   : 
; 44   : 	char Buff[256];
; 45   : 	int Flag = 0;
; 46   : 
; 47   : 	for (int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)
; 48   : 	{
; 49   : 		this->Count[j] = 0;
; 50   : 	}
; 51   : 	
; 52   : 	while(!feof(file))

  002a8	56		 push	 esi
  002a9	e8 00 00 00 00	 call	 _feof
  002ae	83 c4 04	 add	 esp, 4
  002b1	85 c0		 test	 eax, eax
  002b3	0f 84 57 fe ff
	ff		 je	 $LL8@Load
$LN7@Load:

; 79   : 				{
; 80   : 					break;
; 81   : 				}
; 82   : 			}
; 83   : 		}
; 84   : 	}
; 85   : 
; 86   : 	fclose(file);

  002b9	56		 push	 esi
  002ba	e8 00 00 00 00	 call	 _fclose

; 87   : }

  002bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c2	83 c4 04	 add	 esp, 4
  002c5	5e		 pop	 esi
  002c6	5f		 pop	 edi
  002c7	33 cd		 xor	 ecx, ebp
  002c9	5b		 pop	 ebx
  002ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cf	8b e5		 mov	 esp, ebp
  002d1	5d		 pop	 ebp
  002d2	c3		 ret	 0
?Load@CChaosCastleRewardItem@@QAEXXZ ENDP		; CChaosCastleRewardItem::Load
_TEXT	ENDS
PUBLIC	?Main@CChaosCastleRewardItem@@QAE_NHH@Z		; CChaosCastleRewardItem::Main
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?Main@CChaosCastleRewardItem@@QAE_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_ChaosCastleIndex$ = 12					; size = 4
?Main@CChaosCastleRewardItem@@QAE_NHH@Z PROC		; CChaosCastleRewardItem::Main, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 91   : 	
; 92   : 	if(!this->Enable)

  00006	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00009	75 07		 jne	 SHORT $LN6@Main

; 93   : 	{
; 94   : 		return false;

  0000b	32 c0		 xor	 al, al
  0000d	5b		 pop	 ebx

; 117  : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN6@Main:

; 95   : 	}
; 96   : 
; 97   : 	LPOBJ lpObj = &gObj[aIndex];
; 98   : 	
; 99   : 	for(int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)

  00012	8b 45 0c	 mov	 eax, DWORD PTR _ChaosCastleIndex$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00020	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	33 f6		 xor	 esi, esi
$LL5@Main:

; 100  : 	{
; 101  : 		if(ChaosCastleIndex == j)

  00028	3b c6		 cmp	 eax, esi
  0002a	74 0f		 je	 SHORT $LN10@Main

; 95   : 	}
; 96   : 
; 97   : 	LPOBJ lpObj = &gObj[aIndex];
; 98   : 	
; 99   : 	for(int j = 0; j < MAX_CHAOSCASTLE_LEVEL; j++)

  0002c	46		 inc	 esi
  0002d	83 fe 07	 cmp	 esi, 7
  00030	7c f6		 jl	 SHORT $LL5@Main
$LN3@Main:
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	return false;

  00034	32 c0		 xor	 al, al
  00036	5b		 pop	 ebx

; 117  : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
$LN10@Main:

; 102  : 		{
; 103  : 			if(this->Count[j] == 0)

  0003b	83 bc b3 04 af
	00 00 00	 cmp	 DWORD PTR [ebx+esi*4+44804], 0

; 104  : 			{
; 105  : 				return false;

  00043	74 ed		 je	 SHORT $LN3@Main

; 106  : 			}
; 107  : 
; 108  : 			int itemId = rand()%this->Count[j];

  00045	e8 00 00 00 00	 call	 _rand
  0004a	99		 cdq
  0004b	f7 bc b3 04 af
	00 00		 idiv	 DWORD PTR [ebx+esi*4+44804]

; 109  : 
; 110  : 			ItemSerialCreateSend(aIndex,lpObj->MapNumber,lpObj->X,lpObj->Y,ITEMGET(this->Reward[itemId][j].Type,this->Reward[itemId][j].Index),this->Reward[itemId][j].Level,0,this->Reward[itemId][j].Skill,this->Reward[itemId][j].Luck,this->Reward[itemId][j].Opt,aIndex,this->Reward[itemId][j].Exl,this->Reward[itemId][j].Anc);

  00052	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00059	2b c2		 sub	 eax, edx
  0005b	03 c6		 add	 eax, esi
  0005d	c1 e0 05	 shl	 eax, 5
  00060	0f b6 4c 18 20	 movzx	 ecx, BYTE PTR [eax+ebx+32]
  00065	0f b6 54 18 1c	 movzx	 edx, BYTE PTR [eax+ebx+28]
  0006a	03 c3		 add	 eax, ebx
  0006c	51		 push	 ecx
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00070	52		 push	 edx
  00071	0f b6 50 18	 movzx	 edx, BYTE PTR [eax+24]
  00075	51		 push	 ecx
  00076	52		 push	 edx
  00077	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  0007b	52		 push	 edx
  0007c	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  00080	52		 push	 edx
  00081	0f b6 50 0c	 movzx	 edx, BYTE PTR [eax+12]
  00085	6a 00		 push	 0
  00087	52		 push	 edx
  00088	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008b	c1 e2 09	 shl	 edx, 9
  0008e	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00091	0f b6 87 46 01
	00 00		 movzx	 eax, BYTE PTR [edi+326]
  00098	52		 push	 edx
  00099	0f b6 97 44 01
	00 00		 movzx	 edx, BYTE PTR [edi+324]
  000a0	50		 push	 eax
  000a1	0f b6 87 49 01
	00 00		 movzx	 eax, BYTE PTR [edi+329]
  000a8	52		 push	 edx
  000a9	50		 push	 eax
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi

; 111  : 
; 112  : 			return true;	

  000b5	b0 01		 mov	 al, 1
  000b7	5b		 pop	 ebx

; 117  : }

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8
?Main@CChaosCastleRewardItem@@QAE_NHH@Z ENDP		; CChaosCastleRewardItem::Main
_TEXT	ENDS
END
