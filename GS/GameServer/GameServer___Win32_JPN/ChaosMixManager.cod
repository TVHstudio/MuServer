; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\ChaosMixManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ChaosMixManager@@3VcChaosMixManager@@A		; ChaosMixManager
_BSS	SEGMENT
?ChaosMixManager@@3VcChaosMixManager@@A DB 0a7e0904H DUP (?) ; ChaosMixManager
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_0CD@OGIGDJMB@?4?4?2Data?2ZtData?2ChaosMixManager?4i@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Init@cChaosMixManager@@QAEXXZ			; cChaosMixManager::Init
EXTRN	_fclose:PROC
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
; File e:\work\tranet_version\gs\gameserver\chaosmixmanager.cpp
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGIGDJMB@?4?4?2Data?2ZtData?2ChaosMixManager?4i@
CONST	SEGMENT
??_C@_0CD@OGIGDJMB@?4?4?2Data?2ZtData?2ChaosMixManager?4i@ DB '..\Data\Zt'
	DB	'Data\ChaosMixManager.ini', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Init@cChaosMixManager@@QAEXXZ
_TEXT	SEGMENT
?Init@cChaosMixManager@@QAEXXZ PROC			; cChaosMixManager::Init, COMDAT
; _this$ = ecx

; 13   : {

  00000	56		 push	 esi

; 14   : 	SMDFile = fopen(MIX_DIR, "r");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@OGIGDJMB@?4?4?2Data?2ZtData?2ChaosMixManager?4i@
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 _fopen
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 15   : 	if ( SMDFile == NULL )

  0001a	85 c0		 test	 eax, eax
  0001c	75 1a		 jne	 SHORT $LN9@Init

; 16   : 	{
; 17   : 		MessageBoxA(0,MIX_DIR,"LOAD FILE ERROR",0);

  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@OGIGDJMB@?4?4?2Data?2ZtData?2ChaosMixManager?4i@
  00029	50		 push	 eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 18   : 		ExitProcess(0);

  00030	6a 00		 push	 0
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN29@Init:
$LN9@Init:

; 19   : 	}
; 20   : 	int Token;
; 21   : 	int type = -1;
; 22   : 	this->MixCount = 0;

  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 23   : 	while ( true )
; 24   : 	{
; 25   : 	    Token = GetToken();

  0003e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 26   :         if( Token == END) break;

  00043	83 f8 02	 cmp	 eax, 2
  00046	0f 84 02 03 00
	00		 je	 $LN17@Init
  0004c	57		 push	 edi
  0004d	8d 49 00	 npad	 3
$LL8@Init:

; 27   : 		this->MixID[this->MixCount] = (int)TokenNumber;			//MixID

  00050	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00056	e8 00 00 00 00	 call	 __ftol2_sse
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	89 44 8e 04	 mov	 DWORD PTR [esi+ecx*4+4], eax

; 28   : 
; 29   : 		Token = GetToken();

  00061	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 30   : 		this->MixPercent[this->MixCount] = (int)TokenNumber;	//MixPercent

  00066	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0006c	e8 00 00 00 00	 call	 __ftol2_sse
  00071	8b 16		 mov	 edx, DWORD PTR [esi]
  00073	89 84 96 44 1f
	00 00		 mov	 DWORD PTR [esi+edx*4+8004], eax

; 31   : 
; 32   : 		Token = GetToken();

  0007a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 33   : 		this->MixZen[this->MixCount] = (int)TokenNumber;		//MixZen

  0007f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00085	e8 00 00 00 00	 call	 __ftol2_sse
  0008a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008c	89 84 8e c4 5d
	00 00		 mov	 DWORD PTR [esi+ecx*4+24004], eax

; 34   : 
; 35   : 		this->ItemCount[this->MixCount] = 0;

  00093	8b 16		 mov	 edx, DWORD PTR [esi]
  00095	c7 84 96 84 3e
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx*4+16004], 0

; 36   : 
; 37   : 		while ( true )
; 38   : 		{
; 39   : 		    Token = GetToken();

  000a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 40   : 			if (!strcmp("end",TokenString))	break;

  000a5	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  000aa	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  000af	90		 npad	 1
$LL19@Init:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN20@Init
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN21@Init
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN20@Init
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL19@Init
$LN21@Init:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN22@Init
$LN20@Init:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN22@Init:
  000d5	85 c0		 test	 eax, eax
  000d7	0f 84 60 02 00
	00		 je	 $LN27@Init
  000dd	8d 49 00	 npad	 3
$LL5@Init:

; 41   : 
; 42   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].MixType = TokenNumber;

  000e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e6	8b 3e		 mov	 edi, DWORD PTR [esi]
  000e8	e8 00 00 00 00	 call	 __ftol2_sse
  000ed	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  000f4	8b cf		 mov	 ecx, edi
  000f6	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  000fc	03 d1		 add	 edx, ecx
  000fe	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00101	89 84 32 04 7d
	00 00		 mov	 DWORD PTR [edx+esi+32004], eax

; 43   : 
; 44   : 			Token = GetToken();	

  00108	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 45   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Type = TokenNumber;

  0010d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0010f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00115	e8 00 00 00 00	 call	 __ftol2_sse
  0011a	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  00121	8b cf		 mov	 ecx, edi
  00123	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  00129	03 d1		 add	 edx, ecx
  0012b	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0012e	89 84 32 08 7d
	00 00		 mov	 DWORD PTR [edx+esi+32008], eax

; 46   : 
; 47   : 			Token = GetToken();

  00135	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 48   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Index = TokenNumber;

  0013a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0013c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00142	e8 00 00 00 00	 call	 __ftol2_sse
  00147	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  0014e	8b cf		 mov	 ecx, edi
  00150	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  00156	03 d1		 add	 edx, ecx
  00158	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0015b	89 84 32 0c 7d
	00 00		 mov	 DWORD PTR [edx+esi+32012], eax

; 49   : 
; 50   : 			Token = GetToken();

  00162	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 51   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Lvl = TokenNumber;

  00167	8b 3e		 mov	 edi, DWORD PTR [esi]
  00169	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0016f	e8 00 00 00 00	 call	 __ftol2_sse
  00174	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  0017b	8b cf		 mov	 ecx, edi
  0017d	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  00183	03 d1		 add	 edx, ecx
  00185	6b d2 2c	 imul	 edx, 44			; 0000002cH
  00188	89 84 32 10 7d
	00 00		 mov	 DWORD PTR [edx+esi+32016], eax

; 52   : 
; 53   : 			Token = GetToken();

  0018f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 54   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Skill = TokenNumber;

  00194	8b 3e		 mov	 edi, DWORD PTR [esi]
  00196	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0019c	e8 00 00 00 00	 call	 __ftol2_sse
  001a1	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  001a8	8b cf		 mov	 ecx, edi
  001aa	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  001b0	03 d1		 add	 edx, ecx
  001b2	6b d2 2c	 imul	 edx, 44			; 0000002cH
  001b5	89 84 32 14 7d
	00 00		 mov	 DWORD PTR [edx+esi+32020], eax

; 55   : 
; 56   : 			Token = GetToken();

  001bc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 57   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Luck = TokenNumber;

  001c1	8b 3e		 mov	 edi, DWORD PTR [esi]
  001c3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001c9	e8 00 00 00 00	 call	 __ftol2_sse
  001ce	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  001d5	8b cf		 mov	 ecx, edi
  001d7	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  001dd	03 d1		 add	 edx, ecx
  001df	6b d2 2c	 imul	 edx, 44			; 0000002cH
  001e2	89 84 32 18 7d
	00 00		 mov	 DWORD PTR [edx+esi+32024], eax

; 58   : 
; 59   : 			Token = GetToken();

  001e9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 60   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Opt = TokenNumber;

  001ee	8b 3e		 mov	 edi, DWORD PTR [esi]
  001f0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f6	e8 00 00 00 00	 call	 __ftol2_sse
  001fb	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  00202	8b cf		 mov	 ecx, edi
  00204	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  0020a	03 d1		 add	 edx, ecx
  0020c	6b d2 2c	 imul	 edx, 44			; 0000002cH
  0020f	89 84 32 1c 7d
	00 00		 mov	 DWORD PTR [edx+esi+32028], eax

; 61   : 
; 62   : 			Token = GetToken();

  00216	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 63   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Exl = TokenNumber;

  0021b	8b 3e		 mov	 edi, DWORD PTR [esi]
  0021d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00223	e8 00 00 00 00	 call	 __ftol2_sse
  00228	8b 94 be 84 3e
	00 00		 mov	 edx, DWORD PTR [esi+edi*4+16004]
  0022f	8b cf		 mov	 ecx, edi
  00231	69 c9 d0 07 00
	00		 imul	 ecx, 2000		; 000007d0H
  00237	8d 8c 0a d8 02
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+728]
  0023e	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00241	89 04 31	 mov	 DWORD PTR [ecx+esi], eax

; 64   : 
; 65   : 			Token = GetToken();

  00244	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 66   : 			this->Mix[this->MixCount][this->ItemCount[this->MixCount]].Anc = TokenNumber;

  00249	8b 3e		 mov	 edi, DWORD PTR [esi]
  0024b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00251	e8 00 00 00 00	 call	 __ftol2_sse
  00256	8b 8c be 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+edi*4+16004]
  0025d	8b d7		 mov	 edx, edi
  0025f	69 d2 d0 07 00
	00		 imul	 edx, 2000		; 000007d0H
  00265	03 ca		 add	 ecx, edx
  00267	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  0026a	89 84 31 24 7d
	00 00		 mov	 DWORD PTR [ecx+esi+32036], eax

; 67   : 
; 68   : #ifdef PRIVATE_MODULE
; 69   : 			if(g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::MedoniAndrei))

  00271	6a 01		 push	 1
  00273	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00278	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0027d	84 c0		 test	 al, al
  0027f	75 10		 jne	 SHORT $LN1@Init
  00281	6a 32		 push	 50			; 00000032H
  00283	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00288	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0028d	84 c0		 test	 al, al
  0028f	74 5a		 je	 SHORT $LN2@Init
$LN1@Init:

; 70   : 			{
; 71   : 				Token = GetToken();

  00291	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 72   : 				this->Mix[this->MixCount][this->ItemCount[this->MixCount]].MinSocket = TokenNumber;

  00296	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0029c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0029e	e8 00 00 00 00	 call	 __ftol2_sse
  002a3	8b 8c be 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+edi*4+16004]
  002aa	8b d7		 mov	 edx, edi
  002ac	69 d2 d0 07 00
	00		 imul	 edx, 2000		; 000007d0H
  002b2	03 ca		 add	 ecx, edx
  002b4	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  002b7	89 84 31 28 7d
	00 00		 mov	 DWORD PTR [ecx+esi+32040], eax

; 73   : 
; 74   : 				Token = GetToken();

  002be	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 75   : 				this->Mix[this->MixCount][this->ItemCount[this->MixCount]].MaxSocket = TokenNumber;

  002c3	8b 3e		 mov	 edi, DWORD PTR [esi]
  002c5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002cb	e8 00 00 00 00	 call	 __ftol2_sse
  002d0	8b 8c be 84 3e
	00 00		 mov	 ecx, DWORD PTR [esi+edi*4+16004]
  002d7	8b d7		 mov	 edx, edi
  002d9	69 d2 d0 07 00
	00		 imul	 edx, 2000		; 000007d0H
  002df	03 ca		 add	 ecx, edx
  002e1	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  002e4	89 84 31 2c 7d
	00 00		 mov	 DWORD PTR [ecx+esi+32044], eax
$LN2@Init:

; 76   : 			}
; 77   : #endif
; 78   : 
; 79   : 			this->ItemCount[this->MixCount]++;

  002eb	8b 16		 mov	 edx, DWORD PTR [esi]
  002ed	ff 84 96 84 3e
	00 00		 inc	 DWORD PTR [esi+edx*4+16004]
  002f4	8d 84 96 84 3e
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+16004]
  002fb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00300	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00305	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0030a	8d 9b 00 00 00
	00		 npad	 6
$LL23@Init:

; 40   : 			if (!strcmp("end",TokenString))	break;

  00310	8a 10		 mov	 dl, BYTE PTR [eax]
  00312	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00314	75 1a		 jne	 SHORT $LN24@Init
  00316	84 d2		 test	 dl, dl
  00318	74 12		 je	 SHORT $LN25@Init
  0031a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0031d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00320	75 0e		 jne	 SHORT $LN24@Init
  00322	83 c0 02	 add	 eax, 2
  00325	83 c1 02	 add	 ecx, 2
  00328	84 d2		 test	 dl, dl
  0032a	75 e4		 jne	 SHORT $LL23@Init
$LN25@Init:
  0032c	33 c0		 xor	 eax, eax
  0032e	eb 05		 jmp	 SHORT $LN26@Init
$LN24@Init:
  00330	1b c0		 sbb	 eax, eax
  00332	83 d8 ff	 sbb	 eax, -1
$LN26@Init:
  00335	85 c0		 test	 eax, eax
  00337	0f 85 a3 fd ff
	ff		 jne	 $LL5@Init
$LN27@Init:

; 80   : 		}
; 81   : 		this->MixCount++;

  0033d	ff 06		 inc	 DWORD PTR [esi]
  0033f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00344	83 f8 02	 cmp	 eax, 2
  00347	0f 85 03 fd ff
	ff		 jne	 $LL8@Init
  0034d	5f		 pop	 edi
$LN17@Init:

; 82   :     }
; 83   : 	fclose(SMDFile);

  0034e	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00353	50		 push	 eax
  00354	e8 00 00 00 00	 call	 _fclose
  00359	83 c4 04	 add	 esp, 4
  0035c	5e		 pop	 esi

; 84   : }

  0035d	c3		 ret	 0
$LN28@Init:
?Init@cChaosMixManager@@QAEXXZ ENDP			; cChaosMixManager::Init
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z	; cChaosMixManager::nIBox
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\chaosmixmanager.cpp
;	COMDAT ?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z
_TEXT	SEGMENT
_i$203553 = 8						; size = 4
_aIndex$ = 8						; size = 4
_iType$ = 12						; size = 4
_iLevel$ = 16						; size = 4
_iSkill$ = 20						; size = 4
_iLuck$ = 24						; size = 4
_iOpt$ = 28						; size = 4
_iExl$ = 32						; size = 4
_iAnc$ = 36						; size = 4
?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z PROC		; cChaosMixManager::nIBox, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 250  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	8b 80 78 0e 00
	00		 mov	 eax, DWORD PTR [eax+3704]
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 251  : 
; 252  : 	int count = 0;
; 253  : 	for(int i = 0; i < 32; i++)

  0001b	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _i$203553[ebp], 0
  00022	05 97 00 00 00	 add	 eax, 151		; 00000097H
$LL22@nIBox:

; 254  : 	{
; 255  : 		int nOpt = 0;

  00027	8b 7d 0c	 mov	 edi, DWORD PTR _iType$[ebp]
  0002a	33 c9		 xor	 ecx, ecx

; 256  : 		int nExl = 0;

  0002c	33 d2		 xor	 edx, edx

; 257  : 		int nAnc = 0;

  0002e	33 f6		 xor	 esi, esi

; 258  : 		if(lpObj->pChaosBox[i].m_Option3 > 0)		nOpt = 1;

  00030	38 48 ff	 cmp	 BYTE PTR [eax-1], cl
  00033	76 03		 jbe	 SHORT $LN7@nIBox
  00035	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LN7@nIBox:

; 259  : 		if(lpObj->pChaosBox[i].m_NewOption > 0)		nExl = 1;

  00038	38 10		 cmp	 BYTE PTR [eax], dl
  0003a	76 05		 jbe	 SHORT $LN6@nIBox
  0003c	ba 01 00 00 00	 mov	 edx, 1
$LN6@nIBox:

; 260  : 		if(lpObj->pChaosBox[i].m_SetOption > 0)		nAnc = 1;

  00041	80 78 17 00	 cmp	 BYTE PTR [eax+23], 0
  00045	76 05		 jbe	 SHORT $LN5@nIBox
  00047	be 01 00 00 00	 mov	 esi, 1
$LN5@nIBox:

; 261  : 		//----
; 262  : 		if( iType == 0 )

  0004c	85 ff		 test	 edi, edi

; 268  : 		}
; 269  : 		else

  0004e	74 17		 je	 SHORT $LN26@nIBox

; 270  : 		{
; 271  : 			if( lpObj->pChaosBox[i].m_Type == iType 
; 272  : 				&& lpObj->pChaosBox[i].m_Level == iLevel
; 273  : 				&& nOpt == iOpt
; 274  : 				&& nExl == iExl
; 275  : 				&& nAnc == iAnc )

  00050	0f bf 98 6f ff
	ff ff		 movsx	 ebx, WORD PTR [eax-145]
  00057	3b df		 cmp	 ebx, edi
  00059	75 1b		 jne	 SHORT $LN9@nIBox
  0005b	0f bf b8 71 ff
	ff ff		 movsx	 edi, WORD PTR [eax-143]
  00062	3b 7d 10	 cmp	 edi, DWORD PTR _iLevel$[ebp]
  00065	75 0f		 jne	 SHORT $LN9@nIBox
$LN26@nIBox:
  00067	3b 4d 1c	 cmp	 ecx, DWORD PTR _iOpt$[ebp]
  0006a	75 0a		 jne	 SHORT $LN9@nIBox
  0006c	3b 55 20	 cmp	 edx, DWORD PTR _iExl$[ebp]
  0006f	75 05		 jne	 SHORT $LN9@nIBox
  00071	3b 75 24	 cmp	 esi, DWORD PTR _iAnc$[ebp]
  00074	74 1a		 je	 SHORT $LN14@nIBox
$LN9@nIBox:

; 251  : 
; 252  : 	int count = 0;
; 253  : 	for(int i = 0; i < 32; i++)

  00076	8b 4d 08	 mov	 ecx, DWORD PTR _i$203553[ebp]
  00079	41		 inc	 ecx
  0007a	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0007f	89 4d 08	 mov	 DWORD PTR _i$203553[ebp], ecx
  00082	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00085	7c a0		 jl	 SHORT $LL22@nIBox

; 276  : 				return true;
; 277  : 		}
; 278  : 		//----
; 279  : 	}
; 280  : 	return false;

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	32 c0		 xor	 al, al
  0008b	5b		 pop	 ebx

; 281  : }

  0008c	5d		 pop	 ebp
  0008d	c2 20 00	 ret	 32			; 00000020H
$LN14@nIBox:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 263  : 		{
; 264  : 			if( nOpt == iOpt
; 265  : 				&& nExl == iExl
; 266  : 				&& nAnc == iAnc )
; 267  : 				return true;

  00092	b0 01		 mov	 al, 1
  00094	5b		 pop	 ebx

; 281  : }

  00095	5d		 pop	 ebp
  00096	c2 20 00	 ret	 32			; 00000020H
?nIBox@cChaosMixManager@@AAE_NHHHHHHHH@Z ENDP		; cChaosMixManager::nIBox
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Box@cChaosMixManager@@AAEXHHH@Z		; cChaosMixManager::Box
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?GenExcOpt@@YAHH@Z:PROC				; GenExcOpt
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	_rand:PROC
EXTRN	_srand:PROC
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Box@cChaosMixManager@@AAEXHHH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -8068					; size = 4
_Percent$ = -8064					; size = 4
tv597 = -8060						; size = 4
_rNum$ = -8060						; size = 4
_randomSkillDrynea$203515 = -8056			; size = 4
_Zen$ = -8056						; size = 4
tv754 = -8052						; size = 4
_cExl$203500 = -8052					; size = 4
_cAnc$203501 = -8048					; size = 4
_rNumCount$ = -8048					; size = 4
_pMsg$ = -8044						; size = 16
_arrNum$ = -8028					; size = 8000
_ExcellentOpt$203505 = -28				; size = 24
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_IMix$ = 12						; size = 4
_Num$ = 16						; size = 4
?Box@cChaosMixManager@@AAEXHHH@Z PROC			; cChaosMixManager::Box, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 84 1f 00 00	 mov	 eax, 8068		; 00001f84H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 88   : 	LPOBJ lpObj = &gObj[aIndex];
; 89   : 
; 90   : 	PMSG_CHAOSMIXRESULT pMsg;
; 91   : 
; 92   : 	pMsg.Result = CB_ERROR;
; 93   : 
; 94   : 	int Percent = this->MixPercent[Num];

  0001c	89 b5 7c e0 ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00022	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00028	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	57		 push	 edi
  0002f	8b 7d 10	 mov	 edi, DWORD PTR _Num$[ebp]
  00032	8b d9		 mov	 ebx, ecx
  00034	8b 84 bb 44 1f
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+8004]

; 95   : 	int Zen = this->MixZen[Num];

  0003b	8b 8c bb c4 5d
	00 00		 mov	 ecx, DWORD PTR [ebx+edi*4+24004]

; 96   : 	bool Error = false;
; 97   : 	int rNum = 0;
; 98   : 	int arrNum[CHAOS_ITEM] = { 0 };

  00042	68 3c 1f 00 00	 push	 7996			; 00001f3cH
  00047	8d 95 a8 e0 ff
	ff		 lea	 edx, DWORD PTR _arrNum$[ebp+4]
  0004d	6a 00		 push	 0
  0004f	52		 push	 edx
  00050	c6 85 97 e0 ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00057	89 85 80 e0 ff
	ff		 mov	 DWORD PTR _Percent$[ebp], eax
  0005d	89 8d 88 e0 ff
	ff		 mov	 DWORD PTR _Zen$[ebp], ecx
  00063	c7 85 a4 e0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _arrNum$[ebp], 0
  0006d	e8 00 00 00 00	 call	 _memset
  00072	8b 8c bb 84 3e
	00 00		 mov	 ecx, DWORD PTR [ebx+edi*4+16004]

; 99   : 
; 100  : 	int rNumCount = 0;

  00079	33 c0		 xor	 eax, eax
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	89 85 90 e0 ff
	ff		 mov	 DWORD PTR _rNumCount$[ebp], eax

; 101  : 
; 102  : 	for(int i=0;i<this->ItemCount[Num];i++)

  00084	3b c8		 cmp	 ecx, eax
  00086	7e 4a		 jle	 SHORT $LN17@Box

; 103  : 	{
; 104  : 		if(this->Mix[Num][i].MixType == 1)

  00088	8b d7		 mov	 edx, edi
  0008a	69 d2 c0 57 01
	00		 imul	 edx, 88000		; 000157c0H
  00090	8d 94 1a 04 7d
	00 00		 lea	 edx, DWORD PTR [edx+ebx+32004]
  00097	89 95 8c e0 ff
	ff		 mov	 DWORD PTR tv754[ebp], edx
  0009d	8d 49 00	 npad	 3
$LL24@Box:
  000a0	8b 95 8c e0 ff
	ff		 mov	 edx, DWORD PTR tv754[ebp]
  000a6	8b 12		 mov	 edx, DWORD PTR [edx]
  000a8	83 fa 01	 cmp	 edx, 1
  000ab	74 19		 je	 SHORT $LN23@Box

; 105  : 		{
; 106  : 			if(!this->nIBox(aIndex,ITEMGET(this->Mix[Num][i].Type,this->Mix[Num][i].Index),this->Mix[Num][i].Lvl,this->Mix[Num][i].Skill,
; 107  : 			this->Mix[Num][i].Luck,this->Mix[Num][i].Opt,this->Mix[Num][i].Exl,this->Mix[Num][i].Anc))
; 108  : 			{
; 109  : 				Error == true;
; 110  : 			}
; 111  : 		}
; 112  : 		else if(this->Mix[Num][i].MixType == 2)

  000ad	83 fa 02	 cmp	 edx, 2
  000b0	75 14		 jne	 SHORT $LN23@Box

; 113  : 		{
; 114  : 			arrNum[rNumCount] = i;

  000b2	8b 95 90 e0 ff
	ff		 mov	 edx, DWORD PTR _rNumCount$[ebp]
  000b8	89 84 95 a4 e0
	ff ff		 mov	 DWORD PTR _arrNum$[ebp+edx*4], eax

; 115  : 			rNumCount++;

  000bf	42		 inc	 edx
  000c0	89 95 90 e0 ff
	ff		 mov	 DWORD PTR _rNumCount$[ebp], edx
$LN23@Box:

; 101  : 
; 102  : 	for(int i=0;i<this->ItemCount[Num];i++)

  000c6	83 85 8c e0 ff
	ff 2c		 add	 DWORD PTR tv754[ebp], 44 ; 0000002cH
  000cd	40		 inc	 eax
  000ce	3b c1		 cmp	 eax, ecx
  000d0	7c ce		 jl	 SHORT $LL24@Box
$LN17@Box:

; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 
; 120  : 	if(Error == true)
; 121  : 	{
; 122  : 		pMsg.Result = CB_INCORRECT_MIX_ITEMS;
; 123  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);
; 124  : 		return;
; 125  : 	}
; 126  : 
; 127  : 	if(lpObj->Money < Zen)

  000d2	8b 85 88 e0 ff
	ff		 mov	 eax, DWORD PTR _Zen$[ebp]
  000d8	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  000de	7d 34		 jge	 SHORT $LN16@Box

; 128  : 	{
; 129  : 		pMsg.Result = CB_NOT_ENOUGH_ZEN;
; 130  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000e0	0f b6 8d 95 e0
	ff ff		 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000e7	51		 push	 ecx
  000e8	8d 95 94 e0 ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  000ee	c6 85 97 e0 ff
	ff 02		 mov	 BYTE PTR _pMsg$[ebp+3], 2
  000f5	8b 06		 mov	 eax, DWORD PTR [esi]
  000f7	52		 push	 edx
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx

; 231  : 	}
; 232  : 
; 233  : }

  00104	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00107	33 cd		 xor	 ecx, ebp
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 0c 00	 ret	 12			; 0000000cH
$LN16@Box:

; 131  : 		return;
; 132  : 	}
; 133  : 
; 134  : 	srand(time(NULL));

  00114	6a 00		 push	 0
  00116	e8 00 00 00 00	 call	 __time64
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 _srand

; 135  : 	rNum = arrNum[rand()%rNumCount];

  00121	e8 00 00 00 00	 call	 _rand
  00126	99		 cdq
  00127	f7 bd 90 e0 ff
	ff		 idiv	 DWORD PTR _rNumCount$[ebp]
  0012d	8b 8c 95 a4 e0
	ff ff		 mov	 ecx, DWORD PTR _arrNum$[ebp+edx*4]

; 136  : 
; 137  : 	lpObj->Money-=(Zen);

  00134	8b 95 88 e0 ff
	ff		 mov	 edx, DWORD PTR _Zen$[ebp]
  0013a	29 96 f0 00 00
	00		 sub	 DWORD PTR [esi+240], edx
  00140	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]

; 138  : 
; 139  : 	GCMoneySend(aIndex, lpObj->Money);

  00146	50		 push	 eax
  00147	8b 85 7c e0 ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0014d	50		 push	 eax
  0014e	89 8d 84 e0 ff
	ff		 mov	 DWORD PTR _rNum$[ebp], ecx
  00154	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00159	83 c4 10	 add	 esp, 16			; 00000010H

; 140  : 
; 141  : 
; 142  : 	if(Percent > (rand()%100))

  0015c	e8 00 00 00 00	 call	 _rand
  00161	99		 cdq
  00162	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00167	f7 f9		 idiv	 ecx
  00169	39 95 80 e0 ff
	ff		 cmp	 DWORD PTR _Percent$[ebp], edx
  0016f	0f 8e 49 02 00
	00		 jle	 $LN15@Box

; 143  : 	{
; 144  : 		int cExl = 0;
; 145  : 		int cAnc = 0;
; 146  : 
; 147  : 		if(this->Mix[Num][rNum].Exl > 0)

  00175	69 ff d0 07 00
	00		 imul	 edi, 2000		; 000007d0H
  0017b	03 bd 84 e0 ff
	ff		 add	 edi, DWORD PTR _rNum$[ebp]
  00181	33 c9		 xor	 ecx, ecx
  00183	8d 87 d8 02 00
	00		 lea	 eax, DWORD PTR [edi+728]
  00189	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0018c	03 c3		 add	 eax, ebx
  0018e	89 8d 8c e0 ff
	ff		 mov	 DWORD PTR _cExl$203500[ebp], ecx
  00194	89 8d 90 e0 ff
	ff		 mov	 DWORD PTR _cAnc$203501[ebp], ecx
  0019a	89 85 84 e0 ff
	ff		 mov	 DWORD PTR tv597[ebp], eax
  001a0	39 08		 cmp	 DWORD PTR [eax], ecx
  001a2	7e 7a		 jle	 SHORT $LN12@Box

; 148  : 		{
; 149  : 
; 150  : #ifdef PRIVATE_MODULE
; 151  : 			if(g_ZtLicense.CheckUser(eZtUB::drynea))

  001a4	6a 01		 push	 1
  001a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001ab	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001b0	84 c0		 test	 al, al
  001b2	74 19		 je	 SHORT $LN13@Box

; 152  : 			{
; 153  : 				cExl = GenExcOpt(this->Mix[Num][rNum].Exl);

  001b4	8b 8d 84 e0 ff
	ff		 mov	 ecx, DWORD PTR tv597[ebp]
  001ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bc	52		 push	 edx
  001bd	e8 00 00 00 00	 call	 ?GenExcOpt@@YAHH@Z	; GenExcOpt
  001c2	83 c4 04	 add	 esp, 4
  001c5	89 85 8c e0 ff
	ff		 mov	 DWORD PTR _cExl$203500[ebp], eax

; 154  : 			}
; 155  : 			else

  001cb	eb 51		 jmp	 SHORT $LN12@Box
$LN13@Box:

; 156  : 			{
; 157  : 				int ExcellentOpt[6] = { 1, 2, 4, 8, 16, 32 };
; 158  : 				srand(time(NULL));

  001cd	6a 00		 push	 0
  001cf	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$203505[ebp], 1
  001d6	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$203505[ebp+4], 2
  001dd	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$203505[ebp+8], 4
  001e4	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$203505[ebp+12], 8
  001eb	c7 45 f4 10 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$203505[ebp+16], 16 ; 00000010H
  001f2	c7 45 f8 20 00
	00 00		 mov	 DWORD PTR _ExcellentOpt$203505[ebp+20], 32 ; 00000020H
  001f9	e8 00 00 00 00	 call	 __time64
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _srand
  00204	83 c4 08	 add	 esp, 8

; 159  : 				cExl = ExcellentOpt[rand()%6];

  00207	e8 00 00 00 00	 call	 _rand
  0020c	99		 cdq
  0020d	b9 06 00 00 00	 mov	 ecx, 6
  00212	f7 f9		 idiv	 ecx
  00214	8b 54 95 e4	 mov	 edx, DWORD PTR _ExcellentOpt$203505[ebp+edx*4]
  00218	89 95 8c e0 ff
	ff		 mov	 DWORD PTR _cExl$203500[ebp], edx
$LN12@Box:

; 160  : 			}	
; 161  : #else
; 162  : 			int ExcellentOpt[6] = { 1, 2, 4, 8, 16, 32 };
; 163  : 			srand(time(NULL));
; 164  : 			cExl = ExcellentOpt[rand()%6];
; 165  : #endif
; 166  : 		}
; 167  : 
; 168  : 		if(this->Mix[Num][rNum].Anc == 5 || this->Mix[Num][rNum].Anc == 10)

  0021e	6b ff 2c	 imul	 edi, 44			; 0000002cH
  00221	8b 84 1f 24 7d
	00 00		 mov	 eax, DWORD PTR [edi+ebx+32036]
  00228	03 fb		 add	 edi, ebx
  0022a	83 f8 05	 cmp	 eax, 5
  0022d	74 05		 je	 SHORT $LN10@Box
  0022f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00232	75 06		 jne	 SHORT $LN11@Box
$LN10@Box:

; 169  : 		{
; 170  : 			cAnc = this->Mix[Num][rNum].Anc;

  00234	89 85 90 e0 ff
	ff		 mov	 DWORD PTR _cAnc$203501[ebp], eax
$LN11@Box:

; 171  : 		}
; 172  : 
; 173  : #ifdef PRIVATE_MODULE
; 174  : 			if(g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::MedoniAndrei))

  0023a	6a 01		 push	 1
  0023c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00241	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00246	84 c0		 test	 al, al
  00248	75 10		 jne	 SHORT $LN8@Box
  0024a	6a 32		 push	 50			; 00000032H
  0024c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00251	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00256	84 c0		 test	 al, al
  00258	74 29		 je	 SHORT $LN9@Box
$LN8@Box:

; 175  : 			{
; 176  : #ifdef DRYNEA_LIST_CUSTOM
; 177  : 				int RandomSocketSlotInMixManager;
; 178  : 				//srand(time(0));
; 179  : 				//RandomSocketSlotInMixManager = (rand() % 5) + 1;
; 180  : 				if( this->Mix[Num][rNum].MaxSocket == this->Mix[Num][rNum].MinSocket )

  0025a	8b 97 28 7d 00
	00		 mov	 edx, DWORD PTR [edi+32040]
  00260	39 97 2c 7d 00
	00		 cmp	 DWORD PTR [edi+32044], edx

; 181  : 				{
; 182  : 					RandomSocketSlotInMixManager = this->Mix[Num][rNum].MinSocket;
; 183  : 				}
; 184  : 				else

  00266	74 15		 je	 SHORT $LN6@Box

; 185  : 				{
; 186  : 					RandomSocketSlotInMixManager = this->Mix[Num][rNum].MinSocket + (rand() % (this->Mix[Num][rNum].MaxSocket - this->Mix[Num][rNum].MinSocket + 1));

  00268	8b da		 mov	 ebx, edx
  0026a	e8 00 00 00 00	 call	 _rand
  0026f	8b 8f 2c 7d 00
	00		 mov	 ecx, DWORD PTR [edi+32044]
  00275	2b cb		 sub	 ecx, ebx
  00277	41		 inc	 ecx
  00278	99		 cdq
  00279	f7 f9		 idiv	 ecx
  0027b	03 d3		 add	 edx, ebx
$LN6@Box:

; 187  : 				}
; 188  : 
; 189  : 				lpObj->MixManagerSocket = RandomSocketSlotInMixManager;

  0027d	88 96 1c 28 00
	00		 mov	 BYTE PTR [esi+10268], dl
$LN9@Box:

; 190  : #endif
; 191  : 			}
; 192  : #endif
; 193  : #ifdef DRYNEA_31_10
; 194  : 			if(g_ZtLicense.CheckUser(eZtUB::drynea))

  00283	6a 01		 push	 1
  00285	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0028a	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0028f	84 c0		 test	 al, al
  00291	0f 84 bc 00 00
	00		 je	 $LN5@Box

; 195  : 			{
; 196  : 				srand(time(0));

  00297	6a 00		 push	 0
  00299	e8 00 00 00 00	 call	 __time64
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 _srand
  002a4	83 c4 08	 add	 esp, 8

; 197  : 				int randomLuckDrynea = rand()%2;

  002a7	e8 00 00 00 00	 call	 _rand
  002ac	8b d8		 mov	 ebx, eax
  002ae	81 e3 01 00 00
	80		 and	 ebx, -2147483647	; 80000001H
  002b4	79 05		 jns	 SHORT $LN35@Box
  002b6	4b		 dec	 ebx
  002b7	83 cb fe	 or	 ebx, -2			; fffffffeH
  002ba	43		 inc	 ebx
$LN35@Box:

; 198  : 				int randomSkillDrynea = rand()%2;

  002bb	e8 00 00 00 00	 call	 _rand
  002c0	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002c5	79 05		 jns	 SHORT $LN36@Box
  002c7	48		 dec	 eax
  002c8	83 c8 fe	 or	 eax, -2			; fffffffeH
  002cb	40		 inc	 eax
$LN36@Box:
  002cc	89 85 88 e0 ff
	ff		 mov	 DWORD PTR _randomSkillDrynea$203515[ebp], eax

; 199  : 				int randomExcelentDrynea = rand()%2;

  002d2	e8 00 00 00 00	 call	 _rand
  002d7	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002dc	79 05		 jns	 SHORT $LN37@Box
  002de	48		 dec	 eax
  002df	83 c8 fe	 or	 eax, -2			; fffffffeH
  002e2	40		 inc	 eax
$LN37@Box:

; 201  : 				{
; 202  : 					ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 203  : 					randomSkillDrynea, (BYTE)randomLuckDrynea, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);

  002e3	0f b6 8f 1c 7d
	00 00		 movzx	 ecx, BYTE PTR [edi+32028]

; 200  : 				if (randomExcelentDrynea)

  002ea	74 10		 je	 SHORT $LN4@Box

; 201  : 				{
; 202  : 					ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 203  : 					randomSkillDrynea, (BYTE)randomLuckDrynea, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);

  002ec	8b 95 90 e0 ff
	ff		 mov	 edx, DWORD PTR _cAnc$203501[ebp]
  002f2	8b 85 8c e0 ff
	ff		 mov	 eax, DWORD PTR _cExl$203500[ebp]
  002f8	52		 push	 edx
  002f9	50		 push	 eax

; 204  : 					::gObjInventoryCommit(lpObj->m_Index);
; 205  : 				}
; 206  : 				else

  002fa	eb 09		 jmp	 SHORT $LN38@Box
$LN4@Box:

; 207  : 				{
; 208  : 					ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 209  : 					randomSkillDrynea, (BYTE)randomLuckDrynea, (BYTE)this->Mix[Num][rNum].Opt, -1, 0, cAnc);

  002fc	8b 85 90 e0 ff
	ff		 mov	 eax, DWORD PTR _cAnc$203501[ebp]
  00302	50		 push	 eax
  00303	6a 00		 push	 0
$LN38@Box:
  00305	8b 95 88 e0 ff
	ff		 mov	 edx, DWORD PTR _randomSkillDrynea$203515[ebp]
  0030b	8b 87 08 7d 00
	00		 mov	 eax, DWORD PTR [edi+32008]
  00311	6a ff		 push	 -1
  00313	51		 push	 ecx
  00314	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00316	53		 push	 ebx
  00317	52		 push	 edx
  00318	6a 00		 push	 0
  0031a	6a 00		 push	 0
  0031c	c1 e0 09	 shl	 eax, 9
  0031f	03 87 0c 7d 00
	00		 add	 eax, DWORD PTR [edi+32012]
  00325	50		 push	 eax
  00326	6a 00		 push	 0
  00328	6a 00		 push	 0
  0032a	68 ff 00 00 00	 push	 255			; 000000ffH
  0032f	51		 push	 ecx
  00330	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 210  : 					::gObjInventoryCommit(lpObj->m_Index);

  00335	8b 16		 mov	 edx, DWORD PTR [esi]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0033d	83 c4 38	 add	 esp, 56			; 00000038H
  00340	5f		 pop	 edi
  00341	5e		 pop	 esi
  00342	5b		 pop	 ebx

; 231  : 	}
; 232  : 
; 233  : }

  00343	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00346	33 cd		 xor	 ecx, ebp
  00348	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034d	8b e5		 mov	 esp, ebp
  0034f	5d		 pop	 ebp
  00350	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Box:

; 211  : 				}
; 212  : 			}
; 213  : 			else
; 214  : 			{
; 215  : 				ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 216  : 				this->Mix[Num][rNum].Skill, (BYTE)this->Mix[Num][rNum].Luck, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);

  00353	8b 85 90 e0 ff
	ff		 mov	 eax, DWORD PTR _cAnc$203501[ebp]
  00359	8b 8d 8c e0 ff
	ff		 mov	 ecx, DWORD PTR _cExl$203500[ebp]
  0035f	0f b6 97 1c 7d
	00 00		 movzx	 edx, BYTE PTR [edi+32028]
  00366	50		 push	 eax
  00367	0f b6 87 18 7d
	00 00		 movzx	 eax, BYTE PTR [edi+32024]
  0036e	51		 push	 ecx
  0036f	0f b6 8f 14 7d
	00 00		 movzx	 ecx, BYTE PTR [edi+32020]
  00376	6a ff		 push	 -1
  00378	52		 push	 edx
  00379	8b 97 08 7d 00
	00		 mov	 edx, DWORD PTR [edi+32008]
  0037f	50		 push	 eax
  00380	8b 06		 mov	 eax, DWORD PTR [esi]
  00382	51		 push	 ecx
  00383	6a 00		 push	 0
  00385	6a 00		 push	 0
  00387	c1 e2 09	 shl	 edx, 9
  0038a	03 97 0c 7d 00
	00		 add	 edx, DWORD PTR [edi+32012]
  00390	52		 push	 edx
  00391	6a 00		 push	 0
  00393	6a 00		 push	 0
  00395	68 ff 00 00 00	 push	 255			; 000000ffH
  0039a	50		 push	 eax
  0039b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 217  : 				::gObjInventoryCommit(lpObj->m_Index);

  003a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003a2	51		 push	 ecx
  003a3	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  003a8	83 c4 38	 add	 esp, 56			; 00000038H
  003ab	5f		 pop	 edi
  003ac	5e		 pop	 esi
  003ad	5b		 pop	 ebx

; 231  : 	}
; 232  : 
; 233  : }

  003ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b1	33 cd		 xor	 ecx, ebp
  003b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b8	8b e5		 mov	 esp, ebp
  003ba	5d		 pop	 ebp
  003bb	c2 0c 00	 ret	 12			; 0000000cH
$LN15@Box:

; 218  : 			}
; 219  : #else
; 220  : 		ItemSerialCreateSend(lpObj->m_Index, -1, 0, 0, ITEMGET(this->Mix[Num][rNum].Type,this->Mix[Num][rNum].Index), 0, 0, 
; 221  : 			this->Mix[Num][rNum].Skill, (BYTE)this->Mix[Num][rNum].Luck, (BYTE)this->Mix[Num][rNum].Opt, -1, (BYTE)cExl, cAnc);
; 222  : 		::gObjInventoryCommit(lpObj->m_Index);
; 223  : #endif
; 224  : 
; 225  : 	}
; 226  : 	else
; 227  : 	{
; 228  : 		g_MixSystem.ChaosBoxInit(lpObj);

  003be	56		 push	 esi
  003bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  003c4	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 229  : 		::GCUserChaosBoxSend(lpObj, 0);

  003c9	6a 00		 push	 0
  003cb	56		 push	 esi
  003cc	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 230  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  003d1	0f b6 95 95 e0
	ff ff		 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  003d8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003da	52		 push	 edx
  003db	8d 85 94 e0 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  003e1	50		 push	 eax
  003e2	51		 push	 ecx
  003e3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 231  : 	}
; 232  : 
; 233  : }

  003e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003eb	83 c4 14	 add	 esp, 20			; 00000014H
  003ee	5f		 pop	 edi
  003ef	5e		 pop	 esi
  003f0	33 cd		 xor	 ecx, ebp
  003f2	5b		 pop	 ebx
  003f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f8	8b e5		 mov	 esp, ebp
  003fa	5d		 pop	 ebp
  003fb	c2 0c 00	 ret	 12			; 0000000cH
?Box@cChaosMixManager@@AAEXHHH@Z ENDP			; cChaosMixManager::Box
_TEXT	ENDS
PUBLIC	?Main@cChaosMixManager@@QAE_NHH@Z		; cChaosMixManager::Main
; Function compile flags: /Ogtp
;	COMDAT ?Main@cChaosMixManager@@QAE_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MixIndex$ = 12						; size = 4
?Main@cChaosMixManager@@QAE_NHH@Z PROC			; cChaosMixManager::Main, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 31		 mov	 esi, DWORD PTR [ecx]

; 237  : 	for(int i=0;i<this->MixCount;i++)

  00006	33 c0		 xor	 eax, eax
  00008	57		 push	 edi
  00009	85 f6		 test	 esi, esi
  0000b	7e 12		 jle	 SHORT $LN2@Main
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _MixIndex$[ebp]
  00010	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
$LL4@Main:

; 238  : 	{
; 239  : 		if(this->MixID[i] == MixIndex)

  00013	39 3a		 cmp	 DWORD PTR [edx], edi
  00015	74 10		 je	 SHORT $LN8@Main

; 237  : 	for(int i=0;i<this->MixCount;i++)

  00017	40		 inc	 eax
  00018	83 c2 04	 add	 edx, 4
  0001b	3b c6		 cmp	 eax, esi
  0001d	7c f4		 jl	 SHORT $LL4@Main
$LN2@Main:
  0001f	5f		 pop	 edi

; 243  : 		}
; 244  : 	}
; 245  : 	return false;

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 246  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN8@Main:

; 240  : 		{
; 241  : 			this->Box(aIndex,MixIndex,i);

  00027	50		 push	 eax
  00028	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?Box@cChaosMixManager@@AAEXHHH@Z ; cChaosMixManager::Box
  00032	5f		 pop	 edi

; 242  : 			return true;

  00033	b0 01		 mov	 al, 1
  00035	5e		 pop	 esi

; 246  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?Main@cChaosMixManager@@QAE_NHH@Z ENDP			; cChaosMixManager::Main
_TEXT	ENDS
END
