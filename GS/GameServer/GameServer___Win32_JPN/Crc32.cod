; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\Crc32.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??1CCrc32@@QAE@XZ				; CCrc32::~CCrc32
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\crc32.cpp
;	COMDAT ??1CCrc32@@QAE@XZ
_TEXT	SEGMENT
??1CCrc32@@QAE@XZ PROC					; CCrc32::~CCrc32, COMDAT
; _this$ = ecx

; 25   : }

  00000	c3		 ret	 0
??1CCrc32@@QAE@XZ ENDP					; CCrc32::~CCrc32
_TEXT	ENDS
PUBLIC	?Set@CCrc32@@QAEKKD@Z				; CCrc32::Set
; Function compile flags: /Ogtp
;	COMDAT ?Set@CCrc32@@QAEKKD@Z
_TEXT	SEGMENT
_Replace$ = 8						; size = 4
_szMsg$ = 12						; size = 1
?Set@CCrc32@@QAEKKD@Z PROC				; CCrc32::Set, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 
; 31   : 	for(int i = 1; i < (szMsg + 1); i++)

  00003	0f be 4d 0c	 movsx	 ecx, BYTE PTR _szMsg$[ebp]
  00007	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 01	 cmp	 edx, 1
  0000f	7e 25		 jle	 SHORT $LN2@Set

; 29   : 	unsigned long Res	= 0;

  00011	56		 push	 esi
  00012	8d 72 ff	 lea	 esi, DWORD PTR [edx-1]
  00015	8b 55 08	 mov	 edx, DWORD PTR _Replace$[ebp]
  00018	57		 push	 edi
  00019	49		 dec	 ecx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@Set:

; 32   : 	{
; 33   : 		if(Replace & 1) Res |= 1 << (szMsg - i); Replace >>= 1;

  00020	f6 c2 01	 test	 dl, 1
  00023	74 09		 je	 SHORT $LN1@Set
  00025	bf 01 00 00 00	 mov	 edi, 1
  0002a	d3 e7		 shl	 edi, cl
  0002c	0b c7		 or	 eax, edi
$LN1@Set:
  0002e	d1 ea		 shr	 edx, 1
  00030	49		 dec	 ecx
  00031	4e		 dec	 esi
  00032	75 ec		 jne	 SHORT $LL4@Set
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
$LN2@Set:

; 34   : 	}
; 35   : 
; 36   : 	return Res;
; 37   : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?Set@CCrc32@@QAEKKD@Z ENDP				; CCrc32::Set
_TEXT	ENDS
PUBLIC	?Repl@CCrc32@@QAEXPAKPAEK@Z			; CCrc32::Repl
; Function compile flags: /Ogtp
;	COMDAT ?Repl@CCrc32@@QAEXPAKPAEK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szBytes$ = 8						; size = 4
_szBuff$ = 12						; size = 4
_Length$ = 16						; size = 4
?Repl@CCrc32@@QAEXPAKPAEK@Z PROC			; CCrc32::Repl, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 41   : 	while(Length--)

  00004	8b 55 10	 mov	 edx, DWORD PTR _Length$[ebp]
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	85 d2		 test	 edx, edx
  0000c	74 2a		 je	 SHORT $LN6@Repl
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _szBuff$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _szBytes$[ebp]
$LL2@Repl:

; 42   : 	{
; 43   : 		*szBytes = (*szBytes >> 8) ^ this->Addr[(*szBytes & 0xFF) ^ *szBuff++];

  00017	8b 07		 mov	 eax, DWORD PTR [edi]
  00019	0f b6 1e	 movzx	 ebx, BYTE PTR [esi]
  0001c	8b c8		 mov	 ecx, eax
  0001e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00024	33 cb		 xor	 ecx, ebx
  00026	8b 5d fc	 mov	 ebx, DWORD PTR _this$[ebp]
  00029	c1 e8 08	 shr	 eax, 8
  0002c	33 04 8b	 xor	 eax, DWORD PTR [ebx+ecx*4]
  0002f	46		 inc	 esi
  00030	4a		 dec	 edx
  00031	89 07		 mov	 DWORD PTR [edi], eax
  00033	75 e2		 jne	 SHORT $LL2@Repl
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
$LN6@Repl:

; 44   : 	}
; 45   : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?Repl@CCrc32@@QAEXPAKPAEK@Z ENDP			; CCrc32::Repl
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Get@CCrc32@@QAEKPBD@Z				; CCrc32::Get
EXTRN	_fclose:PROC
EXTRN	_fread:PROC
EXTRN	_fopen:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Get@CCrc32@@QAEKPBD@Z
_TEXT	SEGMENT
_Buff$ = -1032						; size = 4
_szBuff$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_szFile$ = 8						; size = 4
?Get@CCrc32@@QAEKPBD@Z PROC				; CCrc32::Get, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _szFile$[ebp]
  00018	57		 push	 edi

; 49   : 	unsigned long Buff			= 0xFFFFFFFF;
; 50   : 	FILE * FilePath				= NULL;
; 51   : 	int ReadBytes				= NULL;
; 52   : 
; 53   : 	unsigned char szBuff[1024]	= {0};	

  00019	68 ff 03 00 00	 push	 1023			; 000003ffH
  0001e	8d 85 fd fb ff
	ff		 lea	 eax, DWORD PTR _szBuff$[ebp+1]
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	8b d9		 mov	 ebx, ecx
  00029	c7 85 f8 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _Buff$[ebp], -1
  00033	c6 85 fc fb ff
	ff 00		 mov	 BYTE PTR _szBuff$[ebp], 0
  0003a	e8 00 00 00 00	 call	 _memset

; 54   : 
; 55   : 	if((FilePath = fopen(szFile, "rb")) == NULL)

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 _fopen
  0004a	8b f8		 mov	 edi, eax
  0004c	83 c4 14	 add	 esp, 20			; 00000014H
  0004f	85 ff		 test	 edi, edi
  00051	75 1d		 jne	 SHORT $LL3@Get

; 56   : 	{
; 57   : 		return 0xFFFFFFFF;

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	83 c8 ff	 or	 eax, -1
  00058	5b		 pop	 ebx

; 69   : 	
; 70   : 	return(Buff ^ 0xFFFFFFFF);
; 71   : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL3@Get:

; 58   : 	}
; 59   : 
; 60   : 	do
; 61   : 	{
; 62   : 		ReadBytes = fread(szBuff, sizeof(char), 1024, FilePath);

  00070	57		 push	 edi
  00071	68 00 04 00 00	 push	 1024			; 00000400H
  00076	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _szBuff$[ebp]
  0007c	6a 01		 push	 1
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _fread
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	8b f0		 mov	 esi, eax

; 63   : 		
; 64   : 		this->Repl(&Buff, szBuff, ReadBytes);

  00089	56		 push	 esi
  0008a	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szBuff$[ebp]
  00090	52		 push	 edx
  00091	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00097	50		 push	 eax
  00098	8b cb		 mov	 ecx, ebx
  0009a	e8 00 00 00 00	 call	 ?Repl@CCrc32@@QAEXPAKPAEK@Z ; CCrc32::Repl

; 65   : 	}
; 66   : 	while(ReadBytes == 1024);

  0009f	81 fe 00 04 00
	00		 cmp	 esi, 1024		; 00000400H
  000a5	74 c9		 je	 SHORT $LL3@Get

; 67   : 	
; 68   : 	fclose(FilePath);

  000a7	57		 push	 edi
  000a8	e8 00 00 00 00	 call	 _fclose

; 69   : 	
; 70   : 	return(Buff ^ 0xFFFFFFFF);
; 71   : }

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _Buff$[ebp]
  000b6	83 c4 04	 add	 esp, 4
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	33 cd		 xor	 ecx, ebp
  000bd	f7 d0		 not	 eax
  000bf	5b		 pop	 ebx
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 04 00	 ret	 4
?Get@CCrc32@@QAEKPBD@Z ENDP				; CCrc32::Get
_TEXT	ENDS
PUBLIC	??0CCrc32@@QAE@XZ				; CCrc32::CCrc32
; Function compile flags: /Ogtp
;	COMDAT ??0CCrc32@@QAE@XZ
_TEXT	SEGMENT
??0CCrc32@@QAE@XZ PROC					; CCrc32::CCrc32, COMDAT
; _this$ = ecx

; 7    : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 8    : 	::memset(&this->Addr, NULL, sizeof(this->Addr));

  00002	68 00 04 00 00	 push	 1024			; 00000400H
  00007	8b f9		 mov	 edi, ecx
  00009	6a 00		 push	 0
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _memset
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9    : 	
; 10   : 	for(int i = 0; i <= 255; i++)

  00014	33 f6		 xor	 esi, esi
$LL6@CCrc32:

; 11   : 	{
; 12   : 		this->Addr[i]	= this->Set(i, 8) << 24;

  00016	6a 08		 push	 8
  00018	56		 push	 esi
  00019	8b cf		 mov	 ecx, edi
  0001b	e8 00 00 00 00	 call	 ?Set@CCrc32@@QAEKKD@Z	; CCrc32::Set
  00020	c1 e0 18	 shl	 eax, 24			; 00000018H

; 13   : 		
; 14   : 		for(int y = 0; y < 8; y++)
; 15   : 		{
; 16   : 			Addr[i]		= (Addr[i] << 1) ^ (Addr[i] & (1 << 31) ? 0x04C11DB7 : 0);

  00023	8b c8		 mov	 ecx, eax
  00025	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0002a	f7 d8		 neg	 eax
  0002c	1b c0		 sbb	 eax, eax
  0002e	03 c9		 add	 ecx, ecx
  00030	25 b7 1d c1 04	 and	 eax, 79764919		; 04c11db7H
  00035	33 c1		 xor	 eax, ecx
  00037	8b c8		 mov	 ecx, eax
  00039	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  0003f	f7 d9		 neg	 ecx
  00041	1b c9		 sbb	 ecx, ecx
  00043	81 e1 b7 1d c1
	04		 and	 ecx, 79764919		; 04c11db7H
  00049	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  0004c	33 ca		 xor	 ecx, edx
  0004e	8b c1		 mov	 eax, ecx
  00050	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00055	f7 d8		 neg	 eax
  00057	1b c0		 sbb	 eax, eax
  00059	03 c9		 add	 ecx, ecx
  0005b	25 b7 1d c1 04	 and	 eax, 79764919		; 04c11db7H
  00060	33 c1		 xor	 eax, ecx
  00062	8b c8		 mov	 ecx, eax
  00064	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  0006a	f7 d9		 neg	 ecx
  0006c	1b c9		 sbb	 ecx, ecx
  0006e	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  00071	81 e1 b7 1d c1
	04		 and	 ecx, 79764919		; 04c11db7H
  00077	33 ca		 xor	 ecx, edx
  00079	8b c1		 mov	 eax, ecx
  0007b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00080	f7 d8		 neg	 eax
  00082	1b c0		 sbb	 eax, eax
  00084	03 c9		 add	 ecx, ecx
  00086	25 b7 1d c1 04	 and	 eax, 79764919		; 04c11db7H
  0008b	33 c1		 xor	 eax, ecx
  0008d	8b c8		 mov	 ecx, eax
  0008f	81 e1 00 00 00
	80		 and	 ecx, -2147483648	; 80000000H
  00095	f7 d9		 neg	 ecx
  00097	1b c9		 sbb	 ecx, ecx
  00099	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  0009c	81 e1 b7 1d c1
	04		 and	 ecx, 79764919		; 04c11db7H
  000a2	33 ca		 xor	 ecx, edx
  000a4	8b c1		 mov	 eax, ecx
  000a6	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000ab	f7 d8		 neg	 eax
  000ad	1b c0		 sbb	 eax, eax
  000af	25 b7 1d c1 04	 and	 eax, 79764919		; 04c11db7H
  000b4	03 c9		 add	 ecx, ecx
  000b6	33 c1		 xor	 eax, ecx
  000b8	8b d0		 mov	 edx, eax
  000ba	81 e2 00 00 00
	80		 and	 edx, -2147483648	; 80000000H
  000c0	f7 da		 neg	 edx
  000c2	1b d2		 sbb	 edx, edx
  000c4	81 e2 b7 1d c1
	04		 and	 edx, 79764919		; 04c11db7H
  000ca	03 c0		 add	 eax, eax
  000cc	33 d0		 xor	 edx, eax

; 17   : 		}
; 18   : 
; 19   : 		Addr[i]			= this->Set(Addr[i], 32);

  000ce	6a 20		 push	 32			; 00000020H
  000d0	52		 push	 edx
  000d1	8b cf		 mov	 ecx, edi
  000d3	e8 00 00 00 00	 call	 ?Set@CCrc32@@QAEKKD@Z	; CCrc32::Set
  000d8	89 04 b7	 mov	 DWORD PTR [edi+esi*4], eax
  000db	46		 inc	 esi
  000dc	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  000e2	0f 8e 2e ff ff
	ff		 jle	 $LL6@CCrc32

; 20   : 	}
; 21   : }

  000e8	8b c7		 mov	 eax, edi
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	c3		 ret	 0
??0CCrc32@@QAE@XZ ENDP					; CCrc32::CCrc32
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_Crc32@@YAXXZ
text$yc	SEGMENT
??__Eg_Crc32@@YAXXZ PROC				; `dynamic initializer for 'g_Crc32'', COMDAT

; 4    : CCrc32 g_Crc32;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crc32@@3VCCrc32@@A ; g_Crc32
  00005	e8 00 00 00 00	 call	 ??0CCrc32@@QAE@XZ	; CCrc32::CCrc32
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_Crc32@@YAXXZ ; `dynamic atexit destructor for 'g_Crc32''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_Crc32@@YAXXZ ENDP				; `dynamic initializer for 'g_Crc32''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_Crc32@@YAXXZ
text$yd	SEGMENT
??__Fg_Crc32@@YAXXZ PROC				; `dynamic atexit destructor for 'g_Crc32'', COMDAT
  00000	c3		 ret	 0
??__Fg_Crc32@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_Crc32''
text$yd	ENDS
PUBLIC	?g_Crc32@@3VCCrc32@@A				; g_Crc32
_BSS	SEGMENT
?g_Crc32@@3VCCrc32@@A DB 0400H DUP (?)			; g_Crc32
_BSS	ENDS
CRT$XCU	SEGMENT
_g_Crc32$initializer$ DD FLAT:??__Eg_Crc32@@YAXXZ
CRT$XCU	ENDS
END
