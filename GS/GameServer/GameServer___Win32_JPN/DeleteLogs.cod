; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\DeleteLogs.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	__imp__FindClose@4:PROC
EXTRN	_free:PROC
EXTRN	__errno:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\dirent.h
;	COMDAT _closedir
_TEXT	SEGMENT
_closedir PROC						; COMDAT
; _dirp$ = esi

; 511  : {   

  00000	57		 push	 edi

; 512  :   int retcode = 0;

  00001	33 ff		 xor	 edi, edi

; 513  : 
; 514  :   /* make sure that dirp points to legal structure */
; 515  :   assert (dirp != NULL);
; 516  :   if (dirp == NULL) {

  00003	85 f6		 test	 esi, esi
  00005	75 10		 jne	 SHORT $LN4@closedir

; 517  :     errno = EBADF;

  00007	e8 00 00 00 00	 call	 __errno
  0000c	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 518  :     return -1;

  00012	83 c8 ff	 or	 eax, -1
  00015	5f		 pop	 edi

; 542  : }

  00016	c3		 ret	 0
$LN4@closedir:

; 519  :   }
; 520  :  
; 521  :   /* free directory name and search handles */
; 522  :   if (dirp->dirname != NULL) free (dirp->dirname);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	85 c0		 test	 eax, eax
  0001b	74 09		 je	 SHORT $LN3@closedir
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _free
  00023	83 c4 04	 add	 esp, 4
$LN3@closedir:

; 523  : 
; 524  : #if defined(DIRENT_WIN32_INTERFACE)
; 525  :   if (dirp->search_handle != INVALID_HANDLE_VALUE) {

  00026	8b 86 50 02 00
	00		 mov	 eax, DWORD PTR [esi+592]
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	74 19		 je	 SHORT $LN1@closedir

; 526  :     if (FindClose (dirp->search_handle) == FALSE) {

  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  00038	85 c0		 test	 eax, eax
  0003a	75 0e		 jne	 SHORT $LN1@closedir

; 527  :       /* Unknown error */
; 528  :       retcode = -1;

  0003c	83 cf ff	 or	 edi, -1

; 529  :       errno = EBADF;

  0003f	e8 00 00 00 00	 call	 __errno
  00044	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9
$LN1@closedir:

; 530  :     }
; 531  :   }
; 532  : #endif                     
; 533  : 
; 534  :   /* clear dirp structure to make sure that it cannot be used anymore*/
; 535  :   memset (dirp, 0, sizeof (*dirp));

  0004a	68 54 02 00 00	 push	 596			; 00000254H
  0004f	6a 00		 push	 0
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 _memset

; 536  : # if defined(DIRENT_WIN32_INTERFACE)
; 537  :   dirp->search_handle = INVALID_HANDLE_VALUE;
; 538  : # endif
; 539  : 
; 540  :   free (dirp);

  00057	56		 push	 esi
  00058	c7 86 50 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+592], -1
  00062	e8 00 00 00 00	 call	 _free
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 541  :   return retcode;

  0006a	8b c7		 mov	 eax, edi
  0006c	5f		 pop	 edi

; 542  : }

  0006d	c3		 ret	 0
_closedir ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT __getdirname
_TEXT	SEGMENT
__getdirname PROC					; COMDAT
; _dp$ = eax

; 642  : #if defined(DIRENT_WIN32_INTERFACE)
; 643  :   return dp->data.cFileName;

  00000	05 34 01 00 00	 add	 eax, 308		; 00000134H

; 644  :   
; 645  : #elif defined(DIRENT_USE_FFBLK)
; 646  :   return dp->data.ff_name;
; 647  :   
; 648  : #else
; 649  :   return dp->data.name;
; 650  : #endif  
; 651  : }

  00005	c3		 ret	 0
__getdirname ENDP
_TEXT	ENDS
EXTRN	_strncpy:PROC
; Function compile flags: /Ogtp
;	COMDAT __setdirname
_TEXT	SEGMENT
__setdirname PROC					; COMDAT
; _dirp$ = esi

; 659  :   /* make sure that d_name is long enough */
; 660  :   assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
; 661  :   
; 662  :   strncpy (dirp->current.d_name,
; 663  :       _getdirname (&dirp->current),
; 664  :       NAME_MAX);

  00000	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00003	68 04 01 00 00	 push	 260			; 00000104H
  00008	8b c1		 mov	 eax, ecx
  0000a	e8 00 00 00 00	 call	 __getdirname
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _strncpy
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 665  :   dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/

  00019	c6 86 08 01 00
	00 00		 mov	 BYTE PTR [esi+264], 0

; 666  : }

  00020	c3		 ret	 0
__setdirname ENDP
_TEXT	ENDS
PUBLIC	??_C@_06EEHCNIJK@Kundun?$AA@			; `string'
PUBLIC	??_C@_07KEJLPAHK@Kanturu?$AA@			; `string'
PUBLIC	??_C@_07FJPHLACI@Connect?$AA@			; `string'
PUBLIC	??_C@_04NKFKOIHC@Chat?$AA@			; `string'
PUBLIC	??_C@_0M@PLKEEFIP@CastleSiege?$AA@		; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	?FilterName@@YA_NPAD@Z				; FilterName
;	COMDAT ??_C@_06EEHCNIJK@Kundun?$AA@
; File e:\work\tranet_version\gs\gameserver\deletelogs.cpp
CONST	SEGMENT
??_C@_06EEHCNIJK@Kundun?$AA@ DB 'Kundun', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEJLPAHK@Kanturu?$AA@
CONST	SEGMENT
??_C@_07KEJLPAHK@Kanturu?$AA@ DB 'Kanturu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJPHLACI@Connect?$AA@
CONST	SEGMENT
??_C@_07FJPHLACI@Connect?$AA@ DB 'Connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKFKOIHC@Chat?$AA@
CONST	SEGMENT
??_C@_04NKFKOIHC@Chat?$AA@ DB 'Chat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLKEEFIP@CastleSiege?$AA@
CONST	SEGMENT
??_C@_0M@PLKEEFIP@CastleSiege?$AA@ DB 'CastleSiege', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FilterName@@YA_NPAD@Z
_TEXT	SEGMENT
_Names$ = 8						; size = 4
?FilterName@@YA_NPAD@Z PROC				; FilterName, COMDAT

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 8    : 	if(!strcmp(Names,"."))	return false;

  00004	8b 75 08	 mov	 esi, DWORD PTR _Names$[ebp]
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01LFCBOECM@?4?$AA@
  0000c	8b c6		 mov	 eax, esi
  0000e	8b ff		 npad	 2
$LL10@FilterName:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00014	75 1a		 jne	 SHORT $LN11@FilterName
  00016	84 d2		 test	 dl, dl
  00018	74 12		 je	 SHORT $LN12@FilterName
  0001a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0001d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00020	75 0e		 jne	 SHORT $LN11@FilterName
  00022	83 c0 02	 add	 eax, 2
  00025	83 c1 02	 add	 ecx, 2
  00028	84 d2		 test	 dl, dl
  0002a	75 e4		 jne	 SHORT $LL10@FilterName
$LN12@FilterName:
  0002c	33 c0		 xor	 eax, eax
  0002e	eb 05		 jmp	 SHORT $LN13@FilterName
$LN11@FilterName:
  00030	1b c0		 sbb	 eax, eax
  00032	83 d8 ff	 sbb	 eax, -1
$LN13@FilterName:
  00035	85 c0		 test	 eax, eax
  00037	75 05		 jne	 SHORT $LN7@FilterName
$LN38@FilterName:
  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 15   : 
; 16   : 	return true;
; 17   : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN7@FilterName:

; 9    : 	if(!strcmp(Names,".."))	return false;

  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02DJGKEECL@?4?4?$AA@
  00043	8b c6		 mov	 eax, esi
$LL14@FilterName:
  00045	8a 10		 mov	 dl, BYTE PTR [eax]
  00047	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00049	75 1a		 jne	 SHORT $LN15@FilterName
  0004b	84 d2		 test	 dl, dl
  0004d	74 12		 je	 SHORT $LN16@FilterName
  0004f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00052	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00055	75 0e		 jne	 SHORT $LN15@FilterName
  00057	83 c0 02	 add	 eax, 2
  0005a	83 c1 02	 add	 ecx, 2
  0005d	84 d2		 test	 dl, dl
  0005f	75 e4		 jne	 SHORT $LL14@FilterName
$LN16@FilterName:
  00061	33 c0		 xor	 eax, eax
  00063	eb 05		 jmp	 SHORT $LN17@FilterName
$LN15@FilterName:
  00065	1b c0		 sbb	 eax, eax
  00067	83 d8 ff	 sbb	 eax, -1
$LN17@FilterName:
  0006a	85 c0		 test	 eax, eax
  0006c	74 cb		 je	 SHORT $LN38@FilterName

; 10   : 	if(!strcmp(Names,"CastleSiege"))	return false;

  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@PLKEEFIP@CastleSiege?$AA@
  00073	8b c6		 mov	 eax, esi
$LL18@FilterName:
  00075	8a 10		 mov	 dl, BYTE PTR [eax]
  00077	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00079	75 1a		 jne	 SHORT $LN19@FilterName
  0007b	84 d2		 test	 dl, dl
  0007d	74 12		 je	 SHORT $LN20@FilterName
  0007f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00082	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00085	75 0e		 jne	 SHORT $LN19@FilterName
  00087	83 c0 02	 add	 eax, 2
  0008a	83 c1 02	 add	 ecx, 2
  0008d	84 d2		 test	 dl, dl
  0008f	75 e4		 jne	 SHORT $LL18@FilterName
$LN20@FilterName:
  00091	33 c0		 xor	 eax, eax
  00093	eb 05		 jmp	 SHORT $LN21@FilterName
$LN19@FilterName:
  00095	1b c0		 sbb	 eax, eax
  00097	83 d8 ff	 sbb	 eax, -1
$LN21@FilterName:
  0009a	85 c0		 test	 eax, eax
  0009c	74 9b		 je	 SHORT $LN38@FilterName

; 11   : 	if(!strcmp(Names,"Chat"))	return false;

  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04NKFKOIHC@Chat?$AA@
  000a3	8b c6		 mov	 eax, esi
$LL22@FilterName:
  000a5	8a 10		 mov	 dl, BYTE PTR [eax]
  000a7	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000a9	75 1a		 jne	 SHORT $LN23@FilterName
  000ab	84 d2		 test	 dl, dl
  000ad	74 12		 je	 SHORT $LN24@FilterName
  000af	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b2	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b5	75 0e		 jne	 SHORT $LN23@FilterName
  000b7	83 c0 02	 add	 eax, 2
  000ba	83 c1 02	 add	 ecx, 2
  000bd	84 d2		 test	 dl, dl
  000bf	75 e4		 jne	 SHORT $LL22@FilterName
$LN24@FilterName:
  000c1	33 c0		 xor	 eax, eax
  000c3	eb 05		 jmp	 SHORT $LN25@FilterName
$LN23@FilterName:
  000c5	1b c0		 sbb	 eax, eax
  000c7	83 d8 ff	 sbb	 eax, -1
$LN25@FilterName:
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 67 ff ff
	ff		 je	 $LN38@FilterName

; 12   : 	if(!strcmp(Names,"Connect"))	return false;

  000d2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07FJPHLACI@Connect?$AA@
  000d7	8b c6		 mov	 eax, esi
  000d9	8d a4 24 00 00
	00 00		 npad	 7
$LL26@FilterName:
  000e0	8a 10		 mov	 dl, BYTE PTR [eax]
  000e2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000e4	75 1a		 jne	 SHORT $LN27@FilterName
  000e6	84 d2		 test	 dl, dl
  000e8	74 12		 je	 SHORT $LN28@FilterName
  000ea	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000ed	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000f0	75 0e		 jne	 SHORT $LN27@FilterName
  000f2	83 c0 02	 add	 eax, 2
  000f5	83 c1 02	 add	 ecx, 2
  000f8	84 d2		 test	 dl, dl
  000fa	75 e4		 jne	 SHORT $LL26@FilterName
$LN28@FilterName:
  000fc	33 c0		 xor	 eax, eax
  000fe	eb 05		 jmp	 SHORT $LN29@FilterName
$LN27@FilterName:
  00100	1b c0		 sbb	 eax, eax
  00102	83 d8 ff	 sbb	 eax, -1
$LN29@FilterName:
  00105	85 c0		 test	 eax, eax
  00107	0f 84 2c ff ff
	ff		 je	 $LN38@FilterName

; 13   : 	if(!strcmp(Names,"Kanturu"))	return false;

  0010d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07KEJLPAHK@Kanturu?$AA@
  00112	8b c6		 mov	 eax, esi
$LL30@FilterName:
  00114	8a 10		 mov	 dl, BYTE PTR [eax]
  00116	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00118	75 1a		 jne	 SHORT $LN31@FilterName
  0011a	84 d2		 test	 dl, dl
  0011c	74 12		 je	 SHORT $LN32@FilterName
  0011e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00121	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00124	75 0e		 jne	 SHORT $LN31@FilterName
  00126	83 c0 02	 add	 eax, 2
  00129	83 c1 02	 add	 ecx, 2
  0012c	84 d2		 test	 dl, dl
  0012e	75 e4		 jne	 SHORT $LL30@FilterName
$LN32@FilterName:
  00130	33 c0		 xor	 eax, eax
  00132	eb 05		 jmp	 SHORT $LN33@FilterName
$LN31@FilterName:
  00134	1b c0		 sbb	 eax, eax
  00136	83 d8 ff	 sbb	 eax, -1
$LN33@FilterName:
  00139	85 c0		 test	 eax, eax
  0013b	0f 84 f8 fe ff
	ff		 je	 $LN38@FilterName

; 14   : 	if(!strcmp(Names,"Kundun"))	return false;

  00141	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06EEHCNIJK@Kundun?$AA@
  00146	8b c6		 mov	 eax, esi
$LL34@FilterName:
  00148	8a 10		 mov	 dl, BYTE PTR [eax]
  0014a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0014c	75 20		 jne	 SHORT $LN35@FilterName
  0014e	84 d2		 test	 dl, dl
  00150	74 12		 je	 SHORT $LN36@FilterName
  00152	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00155	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00158	75 14		 jne	 SHORT $LN35@FilterName
  0015a	83 c0 02	 add	 eax, 2
  0015d	83 c1 02	 add	 ecx, 2
  00160	84 d2		 test	 dl, dl
  00162	75 e4		 jne	 SHORT $LL34@FilterName
$LN36@FilterName:
  00164	33 c0		 xor	 eax, eax
  00166	85 c0		 test	 eax, eax
  00168	0f 95 c0	 setne	 al
  0016b	5e		 pop	 esi

; 15   : 
; 16   : 	return true;
; 17   : }

  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
$LN35@FilterName:

; 14   : 	if(!strcmp(Names,"Kundun"))	return false;

  0016e	1b c0		 sbb	 eax, eax
  00170	83 d8 ff	 sbb	 eax, -1
  00173	85 c0		 test	 eax, eax
  00175	0f 95 c0	 setne	 al
  00178	5e		 pop	 esi

; 15   : 
; 16   : 	return true;
; 17   : }

  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
?FilterName@@YA_NPAD@Z ENDP				; FilterName
_TEXT	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
EXTRN	_strchr:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 215  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 _strchr
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
EXTRN	__imp__FindNextFileA@8:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\dirent.h
;	COMDAT _readdir
_TEXT	SEGMENT
_readdir PROC						; COMDAT
; _dirp$ = eax

; 437  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 438  :   assert (dirp != NULL);
; 439  :   if (dirp == NULL) {

  00003	85 f6		 test	 esi, esi
  00005	75 0f		 jne	 SHORT $LN5@readdir
$LN8@readdir:

; 440  :     errno = EBADF;

  00007	e8 00 00 00 00	 call	 __errno
  0000c	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 441  :     return NULL;

  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 487  : }

  00015	c3		 ret	 0
$LN5@readdir:

; 442  :   }
; 443  : 
; 444  : #if defined(DIRENT_WIN32_INTERFACE)
; 445  :   if (dirp->search_handle == INVALID_HANDLE_VALUE) {

  00016	8b 86 50 02 00
	00		 mov	 eax, DWORD PTR [esi+592]
  0001c	83 f8 ff	 cmp	 eax, -1

; 446  :     /* directory stream was opened/rewound incorrectly or it ended normally */
; 447  :     errno = EBADF;
; 448  :     return NULL;

  0001f	74 e6		 je	 SHORT $LN8@readdir

; 449  :   }
; 450  : #endif
; 451  : 
; 452  :   if (dirp->dirent_filled != 0) {

  00021	83 be 4c 02 00
	00 00		 cmp	 DWORD PTR [esi+588], 0
  00028	74 0f		 je	 SHORT $LN3@readdir

; 453  :     /*
; 454  :      * Directory entry has already been retrieved and there is no need to
; 455  :      * retrieve a new one.  Directory entry will be retrieved in advance
; 456  :      * when the user calls readdir function for the first time.  This is so
; 457  :      * because real dirent has separate functions for opening and reading
; 458  :      * the stream whereas Win32 and DOS dirents open the stream
; 459  :      * automatically when we retrieve the first file.  Therefore, we have to
; 460  :      * save the first file when opening the stream and later we have to
; 461  :      * return the saved entry when the user tries to read the first entry.
; 462  :      */
; 463  :     dirp->dirent_filled = 0;

  0002a	c7 86 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+588], 0

; 484  :     assert (dirp->dirent_filled == 0);
; 485  :   }
; 486  :   return &dirp->current;

  00034	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00037	5e		 pop	 esi

; 487  : }

  00038	c3		 ret	 0
$LN3@readdir:

; 464  :   } else {
; 465  :     /* fill in entry and return that */
; 466  : #if defined(DIRENT_WIN32_INTERFACE)
; 467  :     if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {

  00039	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  0003f	51		 push	 ecx
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  00047	85 c0		 test	 eax, eax
  00049	75 26		 jne	 SHORT $LN1@readdir

; 468  :       /* Last file has been processed or an error occured */
; 469  :       FindClose (dirp->search_handle);

  0004b	8b 96 50 02 00
	00		 mov	 edx, DWORD PTR [esi+592]
  00051	52		 push	 edx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4

; 470  :       dirp->search_handle = INVALID_HANDLE_VALUE;

  00058	c7 86 50 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+592], -1

; 471  :       errno = ENOENT;

  00062	e8 00 00 00 00	 call	 __errno
  00067	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 472  :       return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	5e		 pop	 esi

; 487  : }

  00070	c3		 ret	 0
$LN1@readdir:

; 473  :     }
; 474  : 
; 475  : # elif defined(DIRENT_MSDOS_INTERFACE)
; 476  :     if (_dos_findnext (&dirp->current.data) != 0) {
; 477  :       /* _dos_findnext and findnext will set errno to ENOENT when no
; 478  :        * more entries could be retrieved. */
; 479  :       return NULL;
; 480  :     }
; 481  : # endif
; 482  : 
; 483  :     _setdirname (dirp);

  00071	e8 00 00 00 00	 call	 __setdirname

; 484  :     assert (dirp->dirent_filled == 0);
; 485  :   }
; 486  :   return &dirp->current;

  00076	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00079	5e		 pop	 esi

; 487  : }

  0007a	c3		 ret	 0
_readdir ENDP
_TEXT	ENDS
EXTRN	__imp__FindFirstFileA@8:PROC
; Function compile flags: /Ogtp
;	COMDAT __initdir
_TEXT	SEGMENT
__initdir PROC						; COMDAT
; _dirp$ = eax

; 602  : { 

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 603  :   assert (dirp != NULL);
; 604  :   assert (dirp->dirname != NULL);
; 605  :   dirp->dirent_filled = 0;
; 606  : 
; 607  : # if defined(DIRENT_WIN32_INTERFACE)
; 608  :   /* Open stream and retrieve first file */
; 609  :   dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	c7 86 4c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+588], 0
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  0001d	89 86 50 02 00
	00		 mov	 DWORD PTR [esi+592], eax

; 610  :   if (dirp->search_handle == INVALID_HANDLE_VALUE) {

  00023	83 f8 ff	 cmp	 eax, -1
  00026	75 0f		 jne	 SHORT $LN1@initdir

; 611  :     /* something went wrong but we don't know what.  GetLastError() could
; 612  :      * give us more information about the error, but then we should map
; 613  :      * the error code into errno. */
; 614  :     errno = ENOENT;

  00028	e8 00 00 00 00	 call	 __errno
  0002d	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 615  :     return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 632  :   return 1;
; 633  : }

  00036	c3		 ret	 0
$LN1@initdir:

; 616  :   }
; 617  : 
; 618  : # elif defined(DIRENT_MSDOS_INTERFACE)
; 619  :   if (_dos_findfirst (dirp->dirname,
; 620  :           _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
; 621  :           &dirp->current.data) != 0)
; 622  :   {
; 623  :     /* _dos_findfirst and findfirst will set errno to ENOENT when no 
; 624  :      * more entries could be retrieved. */
; 625  :     return 0;
; 626  :   }
; 627  : # endif
; 628  : 
; 629  :   /* initialize DIR and it's first entry */
; 630  :   _setdirname (dirp);

  00037	e8 00 00 00 00	 call	 __setdirname

; 631  :   dirp->dirent_filled = 1;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	89 86 4c 02 00
	00		 mov	 DWORD PTR [esi+588], eax
  00047	5e		 pop	 esi

; 632  :   return 1;
; 633  : }

  00048	c3		 ret	 0
__initdir ENDP
_TEXT	ENDS
EXTRN	_malloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _opendir
_TEXT	SEGMENT
_opendir PROC						; COMDAT
; _dirname$ = edi

; 345  : {

  00000	56		 push	 esi

; 346  :   DIR *dirp;
; 347  :   assert (dirname != NULL);
; 348  :   
; 349  :   dirp = (DIR*)malloc (sizeof (struct DIR));

  00001	68 54 02 00 00	 push	 596			; 00000254H
  00006	e8 00 00 00 00	 call	 _malloc
  0000b	8b f0		 mov	 esi, eax
  0000d	83 c4 04	 add	 esp, 4

; 350  :   if (dirp != NULL) {

  00010	85 f6		 test	 esi, esi
  00012	0f 84 98 00 00
	00		 je	 $LN1@opendir

; 351  :     char *p;
; 352  :     
; 353  :     /* allocate room for directory name */
; 354  :     dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));

  00018	8b c7		 mov	 eax, edi
  0001a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001d	8d 49 00	 npad	 3
$LL11@opendir:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL11@opendir
  00027	2b c2		 sub	 eax, edx
  00029	83 c0 05	 add	 eax, 5
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _malloc
  00032	83 c4 04	 add	 esp, 4
  00035	89 06		 mov	 DWORD PTR [esi], eax

; 355  :     if (dirp->dirname == NULL) {

  00037	85 c0		 test	 eax, eax
  00039	75 0d		 jne	 SHORT $LN3@opendir

; 356  :       /* failed to duplicate directory name.  errno set by malloc() */
; 357  :       free (dirp);

  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _free
  00041	83 c4 04	 add	 esp, 4

; 358  :       return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	5e		 pop	 esi

; 386  : }

  00047	c3		 ret	 0
$LN3@opendir:

; 359  :     }
; 360  :     /* Copy directory name while appending directory separator and "*.*".
; 361  :      * Directory separator is not appended if the name already ends with
; 362  :      * drive or directory separator.  Directory separator is assumed to be
; 363  :      * '/' or '\' and drive separator is assumed to be ':'. */
; 364  :     strcpy (dirp->dirname, dirname);

  00048	8b cf		 mov	 ecx, edi
  0004a	8b d0		 mov	 edx, eax
  0004c	8d 64 24 00	 npad	 4
$LL7@opendir:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	88 02		 mov	 BYTE PTR [edx], al
  00054	41		 inc	 ecx
  00055	42		 inc	 edx
  00056	84 c0		 test	 al, al
  00058	75 f6		 jne	 SHORT $LL7@opendir

; 365  :     p = strchr (dirp->dirname, '\0');

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _strchr
  00064	83 c4 08	 add	 esp, 8

; 366  :     if (dirp->dirname < p  &&
; 367  :         *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')

  00067	39 06		 cmp	 DWORD PTR [esi], eax
  00069	73 1d		 jae	 SHORT $LN2@opendir
  0006b	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  0006e	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00071	74 15		 je	 SHORT $LN2@opendir
  00073	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00076	74 10		 je	 SHORT $LN2@opendir
  00078	80 f9 3a	 cmp	 cl, 58			; 0000003aH
  0007b	74 0b		 je	 SHORT $LN2@opendir

; 368  :     {
; 369  :       strcpy (p++, "\\");

  0007d	8b c8		 mov	 ecx, eax
  0007f	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00084	40		 inc	 eax
  00085	66 89 11	 mov	 WORD PTR [ecx], dx
$LN2@opendir:

; 370  :     }
; 371  : # ifdef DIRENT_WIN32_INTERFACE
; 372  :     strcpy (p, "*"); /*scan files with and without extension in win32*/

  00088	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0008d	66 89 08	 mov	 WORD PTR [eax], cx

; 373  : # else
; 374  :     strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
; 375  : # endif
; 376  : 
; 377  :     /* open stream */
; 378  :     if (_initdir (dirp) == 0) {

  00090	8b c6		 mov	 eax, esi
  00092	e8 00 00 00 00	 call	 __initdir
  00097	85 c0		 test	 eax, eax
  00099	75 15		 jne	 SHORT $LN1@opendir

; 379  :       /* initialization failed */
; 380  :       free (dirp->dirname);

  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _free

; 381  :       free (dirp);

  000a3	56		 push	 esi
  000a4	e8 00 00 00 00	 call	 _free
  000a9	83 c4 08	 add	 esp, 8

; 382  :       return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	5e		 pop	 esi

; 386  : }

  000af	c3		 ret	 0
$LN1@opendir:

; 383  :     }
; 384  :   }
; 385  :   return dirp;

  000b0	8b c6		 mov	 eax, esi
  000b2	5e		 pop	 esi

; 386  : }

  000b3	c3		 ret	 0
_opendir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@		; `string'
PUBLIC	??_C@_06LLPCNOPC@?4?2LOG?2?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DeleteLogs@@YAXXZ				; DeleteLogs
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_remove:PROC
EXTRN	_sprintf:PROC
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@
; File e:\work\tranet_version\gs\gameserver\deletelogs.cpp
CONST	SEGMENT
??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@ DB 'Done Logs: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@
CONST	SEGMENT
??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@ DB '.\LOG\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLPCNOPC@?4?2LOG?2?$AA@
CONST	SEGMENT
??_C@_06LLPCNOPC@?4?2LOG?2?$AA@ DB '.\LOG\', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DeleteLogs@@YAXXZ
_TEXT	SEGMENT
_InfoDate$188423 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?DeleteLogs@@YAXXZ PROC					; DeleteLogs, COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21   : 	if(!ZtConfig.CommonServer.DeleteLogs) return;

  00010	83 3d 30 00 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+48, 0
  00017	74 6e		 je	 SHORT $LN7@DeleteLogs

; 22   : 
; 23   : 	struct dirent *entry;
; 24   : 
; 25   : 	DIR * dir = opendir(".\\LOG\\");

  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_06LLPCNOPC@?4?2LOG?2?$AA@
  00020	e8 00 00 00 00	 call	 _opendir
  00025	8b f0		 mov	 esi, eax

; 26   : 
; 27   : 	if (!dir) 

  00027	85 f6		 test	 esi, esi
  00029	74 5a		 je	 SHORT $LN11@DeleteLogs

; 28   : 	{
; 29   : 		return;
; 30   : 	}
; 31   : 
; 32   : 	while ( (entry = readdir(dir)) != NULL)

  0002b	e8 00 00 00 00	 call	 _readdir
  00030	8b f8		 mov	 edi, eax
  00032	85 ff		 test	 edi, edi
  00034	74 4a		 je	 SHORT $LN3@DeleteLogs
$LL4@DeleteLogs:

; 33   : 	{
; 34   : 		if(!FilterName(entry->d_name))	continue;

  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 ?FilterName@@YA_NPAD@Z	; FilterName
  0003c	83 c4 04	 add	 esp, 4
  0003f	84 c0		 test	 al, al
  00041	74 30		 je	 SHORT $LN1@DeleteLogs

; 35   : 
; 36   : 		char InfoDate[100];
; 37   : 
; 38   : 		sprintf(InfoDate, ".\\LOG\\%s",entry->d_name);

  00043	57		 push	 edi
  00044	8d 45 98	 lea	 eax, DWORD PTR _InfoDate$188423[ebp]
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_08HNHFGJCA@?4?2LOG?2?$CFs?$AA@
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _sprintf

; 39   : 
; 40   : 		if (remove(InfoDate)==NULL)

  00052	8d 4d 98	 lea	 ecx, DWORD PTR _InfoDate$188423[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _remove
  0005b	83 c4 10	 add	 esp, 16			; 00000010H
  0005e	85 c0		 test	 eax, eax
  00060	75 11		 jne	 SHORT $LN1@DeleteLogs

; 41   : 		{
; 42   : 			LogAddC(2,"Done Logs: %s",entry->d_name);

  00062	57		 push	 edi
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HDJCJJCC@Done?5Logs?3?5?$CFs?$AA@
  00068	6a 02		 push	 2
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DeleteLogs:

; 28   : 	{
; 29   : 		return;
; 30   : 	}
; 31   : 
; 32   : 	while ( (entry = readdir(dir)) != NULL)

  00073	8b c6		 mov	 eax, esi
  00075	e8 00 00 00 00	 call	 _readdir
  0007a	8b f8		 mov	 edi, eax
  0007c	85 ff		 test	 edi, edi
  0007e	75 b6		 jne	 SHORT $LL4@DeleteLogs
$LN3@DeleteLogs:

; 43   : 		}
; 44   : 	}
; 45   : 	closedir(dir);

  00080	e8 00 00 00 00	 call	 _closedir
$LN11@DeleteLogs:
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
$LN7@DeleteLogs:

; 46   : }

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?DeleteLogs@@YAXXZ ENDP					; DeleteLogs
_TEXT	ENDS
END
