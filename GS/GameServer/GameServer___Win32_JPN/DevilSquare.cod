; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\DevilSquare.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	070H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
	DD	010eH
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	ORG $+4
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$ = eax

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __localtime64
  00006	83 c4 04	 add	 esp, 4

; 117  : #pragma warning( pop )
; 118  : }

  00009	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?DevilSquareProtocolCore@@YAXEPAEH@Z		; DevilSquareProtocolCore
EXTRN	?EGAnsIllusionTempleEnter@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT@@@Z:PROC ; CIllusionTempleEvent::EGAnsIllusionTempleEnter
EXTRN	?EGAnsIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT@@@Z:PROC ; CIllusionTempleEvent::EGAnsIllusionTempleEnterCount
EXTRN	?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTempleEvent
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.cpp
;	COMDAT ?DevilSquareProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?DevilSquareProtocolCore@@YAXEPAEH@Z PROC		; DevilSquareProtocolCore, COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 	switch ( protoNum )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00007	83 e8 12	 sub	 eax, 18			; 00000012H
  0000a	74 15		 je	 SHORT $LN2@DevilSquar
  0000c	83 e8 02	 sub	 eax, 2
  0000f	75 1e		 jne	 SHORT $LN3@DevilSquar

; 45   : 			break;
; 46   : 		case 20: //Receive the EnterCount for IllusionTemple on T Key
; 47   : 			g_IllusionTempleEvent.EGAnsIllusionTempleEnterCount((PMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT *)aRecv);

  00011	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00014	50		 push	 eax
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  0001a	e8 00 00 00 00	 call	 ?EGAnsIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT@@@Z ; CIllusionTempleEvent::EGAnsIllusionTempleEnterCount

; 48   : 			break;
; 49   : 
; 50   : 	}
; 51   : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN2@DevilSquar:

; 37   : 	{
; 38   : #if(DEBUG_EVENT_COUNTER == 1)
; 39   : 		case 11: //Receive the EnterCount for BloodCastle on T Key
; 40   : 			EGAnsBloodCastleEnterCount((PMSG_ANS_BLOODCASTLE_ENTERCOUNT *)aRecv);
; 41   : 			break;
; 42   : #endif
; 43   : 		case 18: //To enter Illusion Temple Increasing the EnterCount thru Ranking Server
; 44   : 			g_IllusionTempleEvent.EGAnsIllusionTempleEnter((PMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT *)aRecv);

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00024	51		 push	 ecx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  0002a	e8 00 00 00 00	 call	 ?EGAnsIllusionTempleEnter@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT@@@Z ; CIllusionTempleEvent::EGAnsIllusionTempleEnter
$LN3@DevilSquar:

; 48   : 			break;
; 49   : 
; 50   : 	}
; 51   : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?DevilSquareProtocolCore@@YAXEPAEH@Z ENDP		; DevilSquareProtocolCore
_TEXT	ENDS
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ ; `string'
PUBLIC	?DataSendRank@@YAXPADH@Z			; DataSendRank
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@ DB 'Can not co'
	DB	'nnect Ranking Server', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataSendRank@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_size$ = 12						; size = 4
?DataSendRank@@YAXPADH@Z PROC				; DataSendRank, COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	if ( IsDevilSquareEventConnected == FALSE && DevilSquareEventConnect == FALSE )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?IsDevilSquareEventConnected@@3HA ; IsDevilSquareEventConnected
  00008	85 c0		 test	 eax, eax
  0000a	75 57		 jne	 SHORT $LN3@DataSendRa
  0000c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, eax ; DevilSquareEventConnect
  00012	75 6e		 jne	 SHORT $LN1@DataSendRa

; 56   : 	{
; 57   : 		wsRServerCli.Close();

  00014	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  00019	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 58   : 		wsRServerCli.CreateSocket(ghWnd);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00023	50		 push	 eax
  00024	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  00029	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 59   : 
; 60   : 		if ( GMRankingServerConnect(gDevilSquareEventServerIp, WM_GM_RANKING_CLIENT_MSG_PROC) == FALSE )

  0002e	68 0c 04 00 00	 push	 1036			; 0000040cH
  00033	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  00038	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  0003d	83 c4 08	 add	 esp, 8
  00040	85 c0		 test	 eax, eax
  00042	75 15		 jne	 SHORT $LN2@DataSendRa

; 61   : 		{
; 62   : 			IsDevilSquareEventConnected = FALSE;
; 63   : 			LogAddTD("Can not connect Ranking Server");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server?$AA@
  00049	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00054	83 c4 04	 add	 esp, 4

; 74   : 	}
; 75   : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN2@DataSendRa:

; 64   : 
; 65   : 			return;
; 66   : 		}
; 67   : 
; 68   : 		IsDevilSquareEventConnected = TRUE;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
$LN3@DataSendRa:

; 69   : 	}
; 70   : 
; 71   : 	if ( DevilSquareEventConnect == FALSE && IsDevilSquareEventConnected != FALSE )

  00063	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  0006a	75 16		 jne	 SHORT $LN1@DataSendRa
  0006c	85 c0		 test	 eax, eax
  0006e	74 12		 je	 SHORT $LN1@DataSendRa

; 72   : 	{
; 73   : 		wsRServerCli.DataSend(pMsg, size);

  00070	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00073	8b 55 08	 mov	 edx, DWORD PTR _pMsg$[ebp]
  00076	51		 push	 ecx
  00077	52		 push	 edx
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  0007d	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@DataSendRa:

; 74   : 	}
; 75   : }

  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?DataSendRank@@YAXPADH@Z ENDP				; DataSendRank
_TEXT	ENDS
PUBLIC	?SetOpen@CDevilSquare@@AAEXXZ			; CDevilSquare::SetOpen
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SetOpen@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
?SetOpen@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::SetOpen, COMDAT
; _this$ = ecx

; 400  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 401  : 	this->m_iRemainTime = this->m_iOpenTime;

  00003	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00006	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 402  : 
; 403  : 	if ( this->m_iOpenTime <= 1 )

  00009	83 f8 01	 cmp	 eax, 1
  0000c	7f 19		 jg	 SHORT $LN2@SetOpen

; 404  : 	{
; 405  : 		this->m_iTime = GetTickCount();

  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 406  : 		this->m_iremainTimeSec = 60;

  00014	c7 46 10 3c 00
	00 00		 mov	 DWORD PTR [esi+16], 60	; 0000003cH

; 412  : 	}
; 413  : 
; 414  : 	this->m_bSendTimeCount = FALSE;

  0001b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00022	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00025	5e		 pop	 esi

; 415  : }

  00026	c3		 ret	 0
$LN2@SetOpen:

; 407  : 	}
; 408  : 	else
; 409  : 	{
; 410  : 		this->m_iTime = GetTickCount() + 60000;

  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002d	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H

; 411  : 		this->m_iremainTimeSec = -1;

  00032	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1

; 412  : 	}
; 413  : 
; 414  : 	this->m_bSendTimeCount = FALSE;

  00039	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00040	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00043	5e		 pop	 esi

; 415  : }

  00044	c3		 ret	 0
?SetOpen@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::SetOpen
_TEXT	ENDS
PUBLIC	?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z	; CDevilSquare::GetDevilSquareIndex
; Function compile flags: /Ogtp
;	COMDAT ?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z
_TEXT	SEGMENT
_iGateNumber$ = 8					; size = 4
?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z PROC		; CDevilSquare::GetDevilSquareIndex, COMDAT
; _this$ = ecx

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 440  : 	switch ( iGateNumber )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iGateNumber$[ebp]
  00006	8d 41 c6	 lea	 eax, DWORD PTR [ecx-58]
  00009	3d d4 00 00 00	 cmp	 eax, 212		; 000000d4H
  0000e	77 1e		 ja	 SHORT $LN1@GetDevilSq
  00010	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN9@GetDevilSq[eax]
  00017	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@GetDevilSq[edx*4]
$LN3@GetDevilSq:

; 441  : 	{
; 442  : 		case 58:
; 443  : 		case 59:
; 444  : 		case 60:
; 445  : 		case 61:
; 446  : 			return iGateNumber - 58;	// Devil 1 - 4
; 447  : 			break;
; 448  : 
; 449  : 		case 111:
; 450  : 		case 112:
; 451  : 			return iGateNumber - 107;	// Devil 5 - 6

  0001e	8d 41 95	 lea	 eax, DWORD PTR [ecx-107]

; 460  : 			break;
; 461  : 	}
; 462  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN2@GetDevilSq:

; 452  : 			break;
; 453  : 
; 454  : 		case 270:
; 455  : 			return ( MAX_DEVILSQUARE_GROUND - 1 ); // Devil 7

  00025	b8 06 00 00 00	 mov	 eax, 6

; 460  : 			break;
; 461  : 	}
; 462  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN1@GetDevilSq:

; 456  : 			break;
; 457  : 
; 458  : 		default:
; 459  : 			return -1;

  0002e	83 c8 ff	 or	 eax, -1
$LN5@GetDevilSq:

; 460  : 			break;
; 461  : 	}
; 462  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
  00035	8d 49 00	 npad	 3
$LN10@GetDevilSq:
  00038	00 00 00 00	 DD	 $LN5@GetDevilSq
  0003c	00 00 00 00	 DD	 $LN3@GetDevilSq
  00040	00 00 00 00	 DD	 $LN2@GetDevilSq
  00044	00 00 00 00	 DD	 $LN1@GetDevilSq
$LN9@GetDevilSq:
  00048	00		 DB	 0
  00049	00		 DB	 0
  0004a	00		 DB	 0
  0004b	00		 DB	 0
  0004c	03		 DB	 3
  0004d	03		 DB	 3
  0004e	03		 DB	 3
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	03		 DB	 3
  00059	03		 DB	 3
  0005a	03		 DB	 3
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	03		 DB	 3
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	01		 DB	 1
  0007e	01		 DB	 1
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	03		 DB	 3
  00089	03		 DB	 3
  0008a	03		 DB	 3
  0008b	03		 DB	 3
  0008c	03		 DB	 3
  0008d	03		 DB	 3
  0008e	03		 DB	 3
  0008f	03		 DB	 3
  00090	03		 DB	 3
  00091	03		 DB	 3
  00092	03		 DB	 3
  00093	03		 DB	 3
  00094	03		 DB	 3
  00095	03		 DB	 3
  00096	03		 DB	 3
  00097	03		 DB	 3
  00098	03		 DB	 3
  00099	03		 DB	 3
  0009a	03		 DB	 3
  0009b	03		 DB	 3
  0009c	03		 DB	 3
  0009d	03		 DB	 3
  0009e	03		 DB	 3
  0009f	03		 DB	 3
  000a0	03		 DB	 3
  000a1	03		 DB	 3
  000a2	03		 DB	 3
  000a3	03		 DB	 3
  000a4	03		 DB	 3
  000a5	03		 DB	 3
  000a6	03		 DB	 3
  000a7	03		 DB	 3
  000a8	03		 DB	 3
  000a9	03		 DB	 3
  000aa	03		 DB	 3
  000ab	03		 DB	 3
  000ac	03		 DB	 3
  000ad	03		 DB	 3
  000ae	03		 DB	 3
  000af	03		 DB	 3
  000b0	03		 DB	 3
  000b1	03		 DB	 3
  000b2	03		 DB	 3
  000b3	03		 DB	 3
  000b4	03		 DB	 3
  000b5	03		 DB	 3
  000b6	03		 DB	 3
  000b7	03		 DB	 3
  000b8	03		 DB	 3
  000b9	03		 DB	 3
  000ba	03		 DB	 3
  000bb	03		 DB	 3
  000bc	03		 DB	 3
  000bd	03		 DB	 3
  000be	03		 DB	 3
  000bf	03		 DB	 3
  000c0	03		 DB	 3
  000c1	03		 DB	 3
  000c2	03		 DB	 3
  000c3	03		 DB	 3
  000c4	03		 DB	 3
  000c5	03		 DB	 3
  000c6	03		 DB	 3
  000c7	03		 DB	 3
  000c8	03		 DB	 3
  000c9	03		 DB	 3
  000ca	03		 DB	 3
  000cb	03		 DB	 3
  000cc	03		 DB	 3
  000cd	03		 DB	 3
  000ce	03		 DB	 3
  000cf	03		 DB	 3
  000d0	03		 DB	 3
  000d1	03		 DB	 3
  000d2	03		 DB	 3
  000d3	03		 DB	 3
  000d4	03		 DB	 3
  000d5	03		 DB	 3
  000d6	03		 DB	 3
  000d7	03		 DB	 3
  000d8	03		 DB	 3
  000d9	03		 DB	 3
  000da	03		 DB	 3
  000db	03		 DB	 3
  000dc	03		 DB	 3
  000dd	03		 DB	 3
  000de	03		 DB	 3
  000df	03		 DB	 3
  000e0	03		 DB	 3
  000e1	03		 DB	 3
  000e2	03		 DB	 3
  000e3	03		 DB	 3
  000e4	03		 DB	 3
  000e5	03		 DB	 3
  000e6	03		 DB	 3
  000e7	03		 DB	 3
  000e8	03		 DB	 3
  000e9	03		 DB	 3
  000ea	03		 DB	 3
  000eb	03		 DB	 3
  000ec	03		 DB	 3
  000ed	03		 DB	 3
  000ee	03		 DB	 3
  000ef	03		 DB	 3
  000f0	03		 DB	 3
  000f1	03		 DB	 3
  000f2	03		 DB	 3
  000f3	03		 DB	 3
  000f4	03		 DB	 3
  000f5	03		 DB	 3
  000f6	03		 DB	 3
  000f7	03		 DB	 3
  000f8	03		 DB	 3
  000f9	03		 DB	 3
  000fa	03		 DB	 3
  000fb	03		 DB	 3
  000fc	03		 DB	 3
  000fd	03		 DB	 3
  000fe	03		 DB	 3
  000ff	03		 DB	 3
  00100	03		 DB	 3
  00101	03		 DB	 3
  00102	03		 DB	 3
  00103	03		 DB	 3
  00104	03		 DB	 3
  00105	03		 DB	 3
  00106	03		 DB	 3
  00107	03		 DB	 3
  00108	03		 DB	 3
  00109	03		 DB	 3
  0010a	03		 DB	 3
  0010b	03		 DB	 3
  0010c	03		 DB	 3
  0010d	03		 DB	 3
  0010e	03		 DB	 3
  0010f	03		 DB	 3
  00110	03		 DB	 3
  00111	03		 DB	 3
  00112	03		 DB	 3
  00113	03		 DB	 3
  00114	03		 DB	 3
  00115	03		 DB	 3
  00116	03		 DB	 3
  00117	03		 DB	 3
  00118	03		 DB	 3
  00119	03		 DB	 3
  0011a	03		 DB	 3
  0011b	03		 DB	 3
  0011c	02		 DB	 2
?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z ENDP		; CDevilSquare::GetDevilSquareIndex
_TEXT	ENDS
PUBLIC	?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z	; CDevilSquare::GetUserLevelToEnter
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
_iMoveGate$ = 12					; size = 4
?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z PROC	; CDevilSquare::GetUserLevelToEnter, COMDAT
; _this$ = ecx

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 466  : 	iMoveGate = (BYTE)-1;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMoveGate$[ebp]
  00006	56		 push	 esi

; 467  : 
; 468  : 	if ( gObjIsConnected(iUserIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  0000a	56		 push	 esi
  0000b	c7 00 ff 00 00
	00		 mov	 DWORD PTR [eax], 255	; 000000ffH
  00011	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN11@GetUserLev

; 469  : 	{
; 470  : 		return -1;

  0001d	83 c8 ff	 or	 eax, -1
  00020	5e		 pop	 esi

; 511  : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN11@GetUserLev:

; 471  : 	}
; 472  : 
; 473  : 	int iENTER_LEVEL = -1;
; 474  : 
; 475  : 	//if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iUserIndex]) != FALSE)
; 476  : 	if(gObj[iUserIndex].ChangeUP3rd == 1)

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00031	53		 push	 ebx
  00032	57		 push	 edi
  00033	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00036	83 cb ff	 or	 ebx, -1
  00039	80 bf bc 00 00
	00 01		 cmp	 BYTE PTR [edi+188], 1
  00040	75 19		 jne	 SHORT $LN10@GetUserLev

; 492  : 				{
; 493  : 					iENTER_LEVEL = i;
; 494  : 					iMoveGate = g_sttDEVILSQUARE_LEVEL[i].MoveGate;

  00042	8b 45 0c	 mov	 eax, DWORD PTR _iMoveGate$[ebp]
  00045	8b 15 88 00 00
	00		 mov	 edx, DWORD PTR _g_sttDEVILSQUARE_LEVEL+136
  0004b	bb 06 00 00 00	 mov	 ebx, 6
  00050	5f		 pop	 edi
  00051	89 10		 mov	 DWORD PTR [eax], edx

; 501  : 				{
; 502  : 					iENTER_LEVEL = i;
; 503  : 					iMoveGate = g_sttDEVILSQUARE_LEVEL[i].MoveGate;
; 504  : 					break;
; 505  : 				}
; 506  : 			}
; 507  : 		}
; 508  : 	}
; 509  : 
; 510  : 	return iENTER_LEVEL;

  00053	8b c3		 mov	 eax, ebx
  00055	5b		 pop	 ebx
  00056	5e		 pop	 esi

; 511  : }

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
$LN10@GetUserLev:
  0005b	0f b7 87 b8 00
	00 00		 movzx	 eax, WORD PTR [edi+184]

; 477  : 	{
; 478  : 		iENTER_LEVEL = MAX_DEVILSQUARE_GROUND - 1;
; 479  : 		iMoveGate = g_sttDEVILSQUARE_LEVEL[iENTER_LEVEL].MoveGate;
; 480  : 	}
; 481  : 	else
; 482  : 	{
; 483  : 		for ( int i=0;i<MAX_DEVILSQUARE_GROUND-1;i++)

  00062	33 f6		 xor	 esi, esi
  00064	b9 04 00 00 00	 mov	 ecx, OFFSET _g_sttDEVILSQUARE_LEVEL+4
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL8@GetUserLev:

; 484  : 		{
; 485  : 			if ( gObj[iUserIndex].Class == CLASS_DARKLORD
; 486  : #ifdef MONK
; 487  : 				|| gObj[iUserIndex].Class == CLASS_MONK
; 488  : #endif
; 489  : 				|| gObj[iUserIndex].Class == CLASS_MAGUMSA )

  00070	83 f8 04	 cmp	 eax, 4
  00073	74 1a		 je	 SHORT $LN4@GetUserLev
  00075	83 f8 06	 cmp	 eax, 6
  00078	74 15		 je	 SHORT $LN4@GetUserLev
  0007a	83 f8 03	 cmp	 eax, 3
  0007d	74 10		 je	 SHORT $LN4@GetUserLev

; 495  : 					break;
; 496  : 				}
; 497  : 			}
; 498  : 			else
; 499  : 			{
; 500  : 				if ( gObj[iUserIndex].Level >= g_sttDEVILSQUARE_LEVEL[i].NormalCharacterMinLevel  && gObj[iUserIndex].Level <= g_sttDEVILSQUARE_LEVEL[i].NormalCharacterMaxLevel )

  0007f	0f bf 97 be 00
	00 00		 movsx	 edx, WORD PTR [edi+190]
  00086	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  00089	7c 15		 jl	 SHORT $LN7@GetUserLev
  0008b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0008d	eb 0f		 jmp	 SHORT $LN19@GetUserLev
$LN4@GetUserLev:

; 490  : 			{
; 491  : 				if ( gObj[iUserIndex].Level >= g_sttDEVILSQUARE_LEVEL[i].SpecialCharacterMinLevel  && gObj[iUserIndex].Level <= g_sttDEVILSQUARE_LEVEL[i].SpecialCharacterMaxLevel )

  0008f	0f bf 97 be 00
	00 00		 movsx	 edx, WORD PTR [edi+190]
  00096	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00099	7c 05		 jl	 SHORT $LN7@GetUserLev
  0009b	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
$LN19@GetUserLev:
  0009e	7e 15		 jle	 SHORT $LN16@GetUserLev
$LN7@GetUserLev:

; 477  : 	{
; 478  : 		iENTER_LEVEL = MAX_DEVILSQUARE_GROUND - 1;
; 479  : 		iMoveGate = g_sttDEVILSQUARE_LEVEL[iENTER_LEVEL].MoveGate;
; 480  : 	}
; 481  : 	else
; 482  : 	{
; 483  : 		for ( int i=0;i<MAX_DEVILSQUARE_GROUND-1;i++)

  000a0	83 c1 14	 add	 ecx, 20			; 00000014H
  000a3	46		 inc	 esi
  000a4	81 f9 7c 00 00
	00		 cmp	 ecx, OFFSET _g_sttDEVILSQUARE_LEVEL+124
  000aa	7c c4		 jl	 SHORT $LL8@GetUserLev

; 501  : 				{
; 502  : 					iENTER_LEVEL = i;
; 503  : 					iMoveGate = g_sttDEVILSQUARE_LEVEL[i].MoveGate;
; 504  : 					break;
; 505  : 				}
; 506  : 			}
; 507  : 		}
; 508  : 	}
; 509  : 
; 510  : 	return iENTER_LEVEL;

  000ac	5f		 pop	 edi
  000ad	8b c3		 mov	 eax, ebx
  000af	5b		 pop	 ebx
  000b0	5e		 pop	 esi

; 511  : }

  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8
$LN16@GetUserLev:

; 492  : 				{
; 493  : 					iENTER_LEVEL = i;
; 494  : 					iMoveGate = g_sttDEVILSQUARE_LEVEL[i].MoveGate;

  000b5	8b 45 0c	 mov	 eax, DWORD PTR _iMoveGate$[ebp]
  000b8	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  000bb	8b 14 8d 10 00
	00 00		 mov	 edx, DWORD PTR _g_sttDEVILSQUARE_LEVEL[ecx*4+16]
  000c2	8b de		 mov	 ebx, esi
  000c4	5f		 pop	 edi
  000c5	89 10		 mov	 DWORD PTR [eax], edx

; 501  : 				{
; 502  : 					iENTER_LEVEL = i;
; 503  : 					iMoveGate = g_sttDEVILSQUARE_LEVEL[i].MoveGate;
; 504  : 					break;
; 505  : 				}
; 506  : 			}
; 507  : 		}
; 508  : 	}
; 509  : 
; 510  : 	return iENTER_LEVEL;

  000c7	8b c3		 mov	 eax, ebx
  000c9	5b		 pop	 ebx
  000ca	5e		 pop	 esi

; 511  : }

  000cb	5d		 pop	 ebp
  000cc	c2 08 00	 ret	 8
?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z ENDP	; CDevilSquare::GetUserLevelToEnter
_TEXT	ENDS
PUBLIC	??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Monte@ ; `string'
PUBLIC	?SetMonster@CDevilSquare@@QAEXXZ		; CDevilSquare::SetMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
;	COMDAT ??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Monte@
CONST	SEGMENT
??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Monte@ DB '['
	DB	'DevilSquare] [%d] Invalid MonterType', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetMonster@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
tv300 = -8						; size = 4
_n$222632 = -4						; size = 4
?SetMonster@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::SetMonster, COMDAT
; _this$ = ecx

; 1016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1017 : 	int result;
; 1018 : 
; 1019 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  00006	83 3d 84 2c 03
	00 00		 cmp	 DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004, 0
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$222632[ebp], 0
  00014	0f 8e 97 00 00
	00		 jle	 $LN17@SetMonster
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	be 0a 00 00 00	 mov	 esi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+10
  00021	57		 push	 edi
  00022	89 75 f8	 mov	 DWORD PTR tv300[ebp], esi
$LL29@SetMonster:

; 1020 : 	{
; 1021 : 		if ( DS_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE )

  00025	8a 4e fe	 mov	 cl, BYTE PTR [esi-2]
  00028	80 f9 09	 cmp	 cl, 9
  0002b	74 0c		 je	 SHORT $LN26@SetMonster
  0002d	33 c0		 xor	 eax, eax
  0002f	80 f9 20	 cmp	 cl, 32			; 00000020H
  00032	0f 94 c0	 sete	 al
  00035	85 c0		 test	 eax, eax
  00037	74 5c		 je	 SHORT $LN18@SetMonster
$LN26@SetMonster:

; 1022 : 		{
; 1023 : 			WORD wMonIndex = gMSetBase.m_Mp[n].m_Type;
; 1024 : 			BYTE btDSIndex = -1;
; 1025 : 
; 1026 : 			if ( gMSetBase.m_Mp[n].m_X == 119 )

  00039	8a 06		 mov	 al, BYTE PTR [esi]
  0003b	0f b7 7e fc	 movzx	 edi, WORD PTR [esi-4]
  0003f	3c 77		 cmp	 al, 119			; 00000077H
  00041	75 72		 jne	 SHORT $LN15@SetMonster

; 1027 : 			{
; 1028 : 				btDSIndex = DEVIL_SQUARE_GROUND_1;

  00043	32 db		 xor	 bl, bl
$LN2@SetMonster:

; 1059 : 			}
; 1060 : 
; 1061 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  00045	0f b6 c9	 movzx	 ecx, cl
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0004e	0f bf f0	 movsx	 esi, ax
  00051	83 c4 04	 add	 esp, 4

; 1062 : 
; 1063 : 			if ( result >= 0 )

  00054	85 f6		 test	 esi, esi
  00056	78 3a		 js	 SHORT $LN28@SetMonster

; 1064 : 			{
; 1065 : 				gObjSetPosMonster(result, n);

  00058	8b 55 fc	 mov	 edx, DWORD PTR _n$222632[ebp]
  0005b	52		 push	 edx
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1066 : 				gObjSetMonster(result, wMonIndex); 

  00062	57		 push	 edi
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1067 : 				gObj[result].MaxRegenTime = 1000;	// Rgeneration in 1 second

  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	8b c6		 mov	 eax, esi
  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0007a	c7 84 08 ac 03
	00 00 e8 03 00
	00		 mov	 DWORD PTR [eax+ecx+940], 1000 ; 000003e8H

; 1068 : 				gObj[result].m_bDevilSquareIndex = btDSIndex;

  00085	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008b	88 9c 10 9c 0e
	00 00		 mov	 BYTE PTR [eax+edx+3740], bl
$LN28@SetMonster:

; 1058 : 				continue;

  00092	8b 75 f8	 mov	 esi, DWORD PTR tv300[ebp]
$LN18@SetMonster:

; 1017 : 	int result;
; 1018 : 
; 1019 : 	for ( int n=0;n<gMSetBase.m_Count;n++)

  00095	8b 45 fc	 mov	 eax, DWORD PTR _n$222632[ebp]
  00098	40		 inc	 eax
  00099	83 c6 10	 add	 esi, 16			; 00000010H
  0009c	89 45 fc	 mov	 DWORD PTR _n$222632[ebp], eax
  0009f	89 75 f8	 mov	 DWORD PTR tv300[ebp], esi
  000a2	3b 05 84 2c 03
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+208004
  000a8	0f 8c 77 ff ff
	ff		 jl	 $LL29@SetMonster
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
$LN17@SetMonster:

; 1069 : 			}
; 1070 : 		}
; 1071 : 	}
; 1072 : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
$LN15@SetMonster:

; 1029 : 			}
; 1030 : 			else if ( gMSetBase.m_Mp[n].m_X == 121 )

  000b5	3c 79		 cmp	 al, 121			; 00000079H
  000b7	75 04		 jne	 SHORT $LN13@SetMonster

; 1031 : 			{
; 1032 : 				btDSIndex = DEVIL_SQUARE_GROUND_2;

  000b9	b3 01		 mov	 bl, 1
  000bb	eb 88		 jmp	 SHORT $LN2@SetMonster
$LN13@SetMonster:

; 1033 : 			}
; 1034 : 			else if ( gMSetBase.m_Mp[n].m_X == 49 )

  000bd	3c 31		 cmp	 al, 49			; 00000031H
  000bf	75 04		 jne	 SHORT $LN11@SetMonster

; 1035 : 			{
; 1036 : 				btDSIndex = DEVIL_SQUARE_GROUND_3;

  000c1	b3 02		 mov	 bl, 2
  000c3	eb 80		 jmp	 SHORT $LN2@SetMonster
$LN11@SetMonster:

; 1037 : 			}
; 1038 : 			else if ( gMSetBase.m_Mp[n].m_X == 53 )

  000c5	3c 35		 cmp	 al, 53			; 00000035H
  000c7	75 07		 jne	 SHORT $LN9@SetMonster

; 1039 : 			{
; 1040 : 				btDSIndex = DEVIL_SQUARE_GROUND_4;

  000c9	b3 03		 mov	 bl, 3
  000cb	e9 75 ff ff ff	 jmp	 $LN2@SetMonster
$LN9@SetMonster:

; 1041 : 			}
; 1042 : 			else if ( gMSetBase.m_Mp[n].m_X == 120 )

  000d0	3c 78		 cmp	 al, 120			; 00000078H
  000d2	75 07		 jne	 SHORT $LN7@SetMonster

; 1043 : 			{
; 1044 : 				btDSIndex = DEVIL_SQUARE_GROUND_5;

  000d4	b3 04		 mov	 bl, 4
  000d6	e9 6a ff ff ff	 jmp	 $LN2@SetMonster
$LN7@SetMonster:

; 1045 : 			}
; 1046 : 			else if ( gMSetBase.m_Mp[n].m_X == 122 )

  000db	3c 7a		 cmp	 al, 122			; 0000007aH
  000dd	75 07		 jne	 SHORT $LN5@SetMonster

; 1047 : 			{
; 1048 : 				btDSIndex = DEVIL_SQUARE_GROUND_6;

  000df	b3 05		 mov	 bl, 5
  000e1	e9 5f ff ff ff	 jmp	 $LN2@SetMonster
$LN5@SetMonster:

; 1049 : 			}
; 1050 : 			else if ( gMSetBase.m_Mp[n].m_X == 50 )

  000e6	3c 32		 cmp	 al, 50			; 00000032H
  000e8	75 07		 jne	 SHORT $LN27@SetMonster

; 1051 : 			{
; 1052 : 				btDSIndex = DEVIL_SQUARE_GROUND_7;

  000ea	b3 06		 mov	 bl, 6

; 1053 : 			}
; 1054 : 
; 1055 : 			if ( btDSIndex == 0xFF )

  000ec	e9 54 ff ff ff	 jmp	 $LN2@SetMonster
$LN27@SetMonster:

; 1056 : 			{
; 1057 : 				LogAddTD("[DevilSquare] [%d] Invalid MonterType", wMonIndex);

  000f1	57		 push	 edi
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Monte@
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fd	83 c4 08	 add	 esp, 8

; 1058 : 				continue;

  00100	eb 93		 jmp	 SHORT $LN18@SetMonster
?SetMonster@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::SetMonster
_TEXT	ENDS
PUBLIC	?ClearMonstr@CDevilSquare@@QAEXXZ		; CDevilSquare::ClearMonstr
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Ogtp
;	COMDAT ?ClearMonstr@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
?ClearMonstr@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::ClearMonstr, COMDAT
; _this$ = ecx

; 1075 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1076 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  00002	33 ff		 xor	 edi, edi
  00004	33 f6		 xor	 esi, esi
  00006	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL4@ClearMonst:

; 1077 : 	{
; 1078 : 		if ( DS_MAP_RANGE(gObj[n].MapNumber) != FALSE )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	8a 84 06 49 01
	00 00		 mov	 al, BYTE PTR [esi+eax+329]
  0001c	3c 09		 cmp	 al, 9
  0001e	74 0d		 je	 SHORT $LN11@ClearMonst
  00020	33 c9		 xor	 ecx, ecx
  00022	3c 20		 cmp	 al, 32			; 00000020H
  00024	0f 94 c1	 sete	 cl
  00027	8b c1		 mov	 eax, ecx
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $LN3@ClearMonst
$LN11@ClearMonst:

; 1079 : 		{
; 1080 : 			gObjDel(n);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00033	83 c4 04	 add	 esp, 4
$LN3@ClearMonst:

; 1076 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  00036	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0003c	47		 inc	 edi
  0003d	81 fe 80 76 97
	08		 cmp	 esi, 144144000		; 08977680H
  00043	7c cb		 jl	 SHORT $LL4@ClearMonst

; 1081 : 		}
; 1082 : 	}
; 1083 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	c3		 ret	 0
?ClearMonstr@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::ClearMonstr
_TEXT	ENDS
PUBLIC	??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSquar@ ; `string'
PUBLIC	??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquare::gDevilSquareMonsterRegen
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?Clear@CMagicInf@@QAEXXZ:PROC			; CMagicInf::Clear
EXTRN	?GetMonsterType@CDevilSquareGround@@QAEGH@Z:PROC ; CDevilSquareGround::GetMonsterType
;	COMDAT ??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSquar@
CONST	SEGMENT
??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSquar@ DB '[DevilSq'
	DB	'uare] Invalid DevilSquareIndex [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN?$FL@ DB '['
	DB	'DevilSquare] Monter Regen [%d][%d][%d,%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv210 = -4						; size = 4
_monstertype$ = 8					; size = 2
_lpObj$ = 8						; size = 4
?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDevilSquare::gDevilSquareMonsterRegen, COMDAT
; _this$ = ecx

; 1086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1087 : 	BYTE devilsquareindex = lpObj->m_bDevilSquareIndex;

  00006	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00009	8a 9e 9c 0e 00
	00		 mov	 bl, BYTE PTR [esi+3740]

; 1088 : 
; 1089 : 	if ( devilsquareindex < 0 || devilsquareindex >= MAX_DEVILSQUARE_GROUND )

  0000f	80 fb 07	 cmp	 bl, 7
  00012	0f 83 ee 00 00
	00		 jae	 $LN6@gDevilSqua

; 1092 : 		return;
; 1093 : 	}
; 1094 : 
; 1095 : 	if ( lpObj->m_PosNum == -1 )

  00018	66 83 be b0 03
	00 00 ff	 cmp	 WORD PTR [esi+944], -1
  00020	75 13		 jne	 SHORT $LN5@gDevilSqua

; 1096 : 	{
; 1097 : 		gObjDel(lpObj->m_Index);

  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0002a	83 c4 04	 add	 esp, 4
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 1122 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN5@gDevilSqua:

; 1098 : 		return;
; 1099 : 	}
; 1100 : 
; 1101 : 	WORD monstertype = this->m_DevilSquareGround[devilsquareindex].GetMonsterType(this->m_iPlaytime - this->m_iRemainTime );

  00035	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00038	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  0003b	0f b6 c3	 movzx	 eax, bl
  0003e	89 45 fc	 mov	 DWORD PTR tv210[ebp], eax
  00041	69 c0 a8 04 00
	00		 imul	 eax, 1192		; 000004a8H
  00047	52		 push	 edx
  00048	8d 4c 08 3c	 lea	 ecx, DWORD PTR [eax+ecx+60]
  0004c	e8 00 00 00 00	 call	 ?GetMonsterType@CDevilSquareGround@@QAEGH@Z ; CDevilSquareGround::GetMonsterType
  00051	0f b7 c0	 movzx	 eax, ax

; 1102 : 
; 1103 : 	if ( monstertype == (BYTE)-1 )

  00054	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00059	89 45 08	 mov	 DWORD PTR _monstertype$[ebp], eax
  0005c	66 3b c1	 cmp	 ax, cx
  0005f	75 17		 jne	 SHORT $LN4@gDevilSqua

; 1104 : 	{
; 1105 : 		LogAddTD("[DevilSquare] [%d] Invalid MonterType", monstertype);

  00061	51		 push	 ecx
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Monte@
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0006d	83 c4 08	 add	 esp, 8
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1122 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
$LN4@gDevilSqua:
  00078	57		 push	 edi

; 1106 : 		return;
; 1107 : 	}
; 1108 : 
; 1109 : 	for ( int n=0;n<MAX_MAGIC;n++)

  00079	33 ff		 xor	 edi, edi
  0007b	eb 03 8d 49 00	 npad	 5
$LL3@gDevilSqua:

; 1110 : 	{
; 1111 : 		lpObj->Magic[n].Clear();

  00080	8b 8e c8 04 00
	00		 mov	 ecx, DWORD PTR [esi+1224]
  00086	03 cf		 add	 ecx, edi
  00088	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear
  0008d	83 c7 18	 add	 edi, 24			; 00000018H
  00090	81 ff 10 0e 00
	00		 cmp	 edi, 3600		; 00000e10H
  00096	7c e8		 jl	 SHORT $LL3@gDevilSqua

; 1112 : 	}
; 1113 : 
; 1114 : 	gObjSetMonster(lpObj->m_Index, monstertype);

  00098	0f b7 7d 08	 movzx	 edi, WORD PTR _monstertype$[ebp]
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	57		 push	 edi
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1115 : 	lpObj->DieRegen = FALSE;
; 1116 : 	gObjMonsterRegen(lpObj);

  000a5	56		 push	 esi
  000a6	c6 86 a2 03 00
	00 00		 mov	 BYTE PTR [esi+930], 0
  000ad	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterRegen

; 1117 : 	CreateFrustrum(lpObj->X, lpObj->Y, lpObj->m_Index);

  000b2	8b 06		 mov	 eax, DWORD PTR [esi]
  000b4	0f bf 8e 46 01
	00 00		 movsx	 ecx, WORD PTR [esi+326]
  000bb	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  000c2	50		 push	 eax
  000c3	51		 push	 ecx
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 1118 : 	lpObj->m_bDevilSquareIndex = devilsquareindex;
; 1119 : 	lpObj->MaxRegenTime = 1000;
; 1120 : 
; 1121 : 	LogAddTD("[DevilSquare] Monter Regen [%d][%d][%d,%d]", monstertype, devilsquareindex, lpObj->X, lpObj->Y);

  000ca	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  000d1	0f bf 8e 44 01
	00 00		 movsx	 ecx, WORD PTR [esi+324]
  000d8	8b 55 fc	 mov	 edx, DWORD PTR tv210[ebp]
  000db	50		 push	 eax
  000dc	51		 push	 ecx
  000dd	52		 push	 edx
  000de	57		 push	 edi
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN?$FL@
  000e4	88 9e 9c 0e 00
	00		 mov	 BYTE PTR [esi+3740], bl
  000ea	c7 86 ac 03 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+940], 1000 ; 000003e8H
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fa	83 c4 2c	 add	 esp, 44			; 0000002cH
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx

; 1122 : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 04 00	 ret	 4
$LN6@gDevilSqua:

; 1090 : 	{
; 1091 : 		LogAddTD("[DevilSquare] Invalid DevilSquareIndex [%d]", devilsquareindex);

  00106	0f b6 c3	 movzx	 eax, bl
  00109	50		 push	 eax
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSquar@
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00115	83 c4 08	 add	 esp, 8
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx

; 1122 : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 04 00	 ret	 4
?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDevilSquare::gDevilSquareMonsterRegen
_TEXT	ENDS
PUBLIC	??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?SendEventStartMsg@CDevilSquare@@AAEXXZ		; CDevilSquare::SendEventStartMsg
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event?$AA@
CONST	SEGMENT
??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event?$AA@ DB '[DevilSquar'
	DB	'e] Start Event', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SendEventStartMsg@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_pWithOutEvneter$ = -548				; size = 272
_pToEventer$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
?SendEventStartMsg@CDevilSquare@@AAEXXZ PROC		; CDevilSquare::SendEventStartMsg, COMDAT
; _this$ = ecx

; 1125 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 02 00
	00		 sub	 esp, 548		; 00000224H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 1126 : 	PMSG_NOTICE pToEventer;
; 1127 : 	PMSG_NOTICE pWithOutEvneter;
; 1128 : 
; 1129 : 	TNotice::MakeNoticeMsg(&pToEventer, 0, lMsg.Get(MSGGET(2, 195)));

  00015	68 c3 02 00 00	 push	 707			; 000002c3H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0001f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00024	50		 push	 eax
  00025	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pToEventer$[ebp]
  0002b	6a 00		 push	 0
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1130 : 	TNotice::MakeNoticeMsg(&pWithOutEvneter, 0, lMsg.Get(MSGGET(2, 196)));

  00036	68 c4 02 00 00	 push	 708			; 000002c4H
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00040	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00045	50		 push	 eax
  00046	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _pWithOutEvneter$[ebp]
  0004c	6a 00		 push	 0
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1131 : 
; 1132 : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00057	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  0005c	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL6@SendEventS:

; 1133 : 	{
; 1134 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0006b	75 41		 jne	 SHORT $LN5@SendEventS

; 1135 : 		{
; 1136 : 			if ( DS_MAP_RANGE(gObj[n].MapNumber) != FALSE )

  0006d	8a 84 06 49 01
	00 00		 mov	 al, BYTE PTR [esi+eax+329]
  00074	3c 09		 cmp	 al, 9
  00076	74 0d		 je	 SHORT $LN13@SendEventS
  00078	33 d2		 xor	 edx, edx
  0007a	3c 20		 cmp	 al, 32			; 00000020H
  0007c	0f 94 c2	 sete	 dl
  0007f	8b c2		 mov	 eax, edx
  00081	85 c0		 test	 eax, eax
  00083	74 11		 je	 SHORT $LN2@SendEventS
$LN13@SendEventS:

; 1137 : 			{
; 1138 : 				DataSend(n, (LPBYTE)&pToEventer, pToEventer.h.size);

  00085	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pToEventer$[ebp+1]
  0008c	50		 push	 eax
  0008d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pToEventer$[ebp]
  00093	51		 push	 ecx

; 1139 : 			}
; 1140 : 			else

  00094	eb 0f		 jmp	 SHORT $LN14@SendEventS
$LN2@SendEventS:

; 1141 : 			{
; 1142 : 				DataSend(n, (LPBYTE)&pWithOutEvneter, pWithOutEvneter.h.size);

  00096	0f b6 95 dd fd
	ff ff		 movzx	 edx, BYTE PTR _pWithOutEvneter$[ebp+1]
  0009d	52		 push	 edx
  0009e	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _pWithOutEvneter$[ebp]
  000a4	50		 push	 eax
$LN14@SendEventS:
  000a5	57		 push	 edi
  000a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendEventS:

; 1131 : 
; 1132 : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  000ae	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  000b4	47		 inc	 edi
  000b5	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  000bb	7c a4		 jl	 SHORT $LL6@SendEventS

; 1143 : 			}
; 1144 : 		}
; 1145 : 	}
; 1146 : 
; 1147 : 	LogAddTD("[DevilSquare] Start Event");

  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event?$AA@
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1148 : }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	83 c4 04	 add	 esp, 4
  000ce	5f		 pop	 edi
  000cf	33 cd		 xor	 ecx, ebp
  000d1	5e		 pop	 esi
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
?SendEventStartMsg@CDevilSquare@@AAEXXZ ENDP		; CDevilSquare::SendEventStartMsg
_TEXT	ENDS
PUBLIC	??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DieProcDevilSquare@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquare::DieProcDevilSquare
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL@ DB '['
	DB	'DevilSquare] Dead [%s][%s][%d][%d]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DieProcDevilSquare@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$ = -304						; size = 4
_pMsg$ = -300						; size = 40
_msg$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DieProcDevilSquare@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDevilSquare::DieProcDevilSquare, COMDAT
; _this$ = ecx

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 1152 : 	char msg[255];
; 1153 : 
; 1154 : 	wsprintf(msg, lMsg.Get(MSGGET(2, 197)), lpObj->m_nEventScore);

  00018	8b 86 90 0e 00
	00		 mov	 eax, DWORD PTR [esi+3728]
  0001e	50		 push	 eax
  0001f	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00025	68 c5 02 00 00	 push	 709			; 000002c5H
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00034	50		 push	 eax
  00035	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  0003b	51		 push	 ecx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1155 : 	GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  00042	8b 16		 mov	 edx, DWORD PTR [esi]
  00044	6a 01		 push	 1
  00046	52		 push	 edx
  00047	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1156 : 
; 1157 : 	if ( lpObj->m_nEventScore <= 0 )

  00053	8b 9e 90 0e 00
	00		 mov	 ebx, DWORD PTR [esi+3728]
  00059	83 c4 18	 add	 esp, 24			; 00000018H
  0005c	85 db		 test	 ebx, ebx
  0005e	0f 8e 12 01 00
	00		 jle	 $LN6@DieProcDev

; 1158 : 	{
; 1159 : 		return;
; 1160 : 	}
; 1161 : 
; 1162 : 	PMSG_ANS_EVENTUSERSCORE pMsg;
; 1163 : 
; 1164 : 	pMsg.h.c = 0xC1;
; 1165 : 	pMsg.h.headcode = 0x01;
; 1166 : 	pMsg.h.size = sizeof(pMsg);
; 1167 : 	pMsg.SquareNum = lpObj->m_bDevilSquareIndex;
; 1168 : 	pMsg.Class = lpObj->Class;

  00064	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  0006b	8a 96 9c 0e 00
	00		 mov	 dl, BYTE PTR [esi+3740]
  00071	57		 push	 edi
  00072	0f b6 fa	 movzx	 edi, dl
  00075	8b c1		 mov	 eax, ecx
  00077	c6 85 d4 fe ff
	ff c1		 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  0007e	66 c7 85 d5 fe
	ff ff 28 01	 mov	 WORD PTR _pMsg$[ebp+1], 296 ; 00000128H
  00087	89 bd f8 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+36], edi
  0008d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+32], eax

; 1169 : 
; 1170 : 	if ( lpObj->Class == 1 )

  00093	83 f9 01	 cmp	 ecx, 1
  00096	75 4b		 jne	 SHORT $LN4@DieProcDev

; 1171 : 	{
; 1172 : 		if ( lpObj->Class >= 0 && lpObj->Class < MAX_TYPE_PLAYER )
; 1173 : 		{
; 1174 : 			if ( DS_LEVEL_RANGE(lpObj->m_bDevilSquareIndex) != FALSE )

  00098	b9 06 00 00 00	 mov	 ecx, 6
  0009d	3a ca		 cmp	 cl, dl
  0009f	1b c9		 sbb	 ecx, ecx
  000a1	41		 inc	 ecx
  000a2	74 31		 je	 SHORT $LN2@DieProcDev

; 1175 : 			{
; 1176 : 				lpObj->m_nEventScore+= this->m_BonusScoreTable[lpObj->Class][lpObj->m_bDevilSquareIndex]/100;

  000a4	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  000ab	2b d0		 sub	 edx, eax
  000ad	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b3	03 d7		 add	 edx, edi
  000b5	8b 8c 90 d4 20
	00 00		 mov	 ecx, DWORD PTR [eax+edx*4+8404]
  000bc	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000c1	f7 e9		 imul	 ecx
  000c3	c1 fa 05	 sar	 edx, 5
  000c6	8b ca		 mov	 ecx, edx
  000c8	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000cb	03 ca		 add	 ecx, edx
  000cd	03 cb		 add	 ecx, ebx
  000cf	89 8e 90 0e 00
	00		 mov	 DWORD PTR [esi+3728], ecx
$LN2@DieProcDev:

; 1177 : 
; 1178 : 
; 1179 : 				
; 1180 : 			}
; 1181 : 		}
; 1182 : 
; 1183 : 		pMsg.Score = lpObj->m_nEventScore;

  000d5	8b 96 90 0e 00
	00		 mov	 edx, DWORD PTR [esi+3728]
  000db	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+28], edx

; 1184 : 	}
; 1185 : 	else

  000e1	eb 06		 jmp	 SHORT $LN1@DieProcDev
$LN4@DieProcDev:

; 1186 : 	{
; 1187 : 		pMsg.Score = lpObj->m_nEventScore;

  000e3	89 9d f0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+28], ebx
$LN1@DieProcDev:

; 1188 : 	}
; 1189 : 
; 1190 : 	pMsg.ServerCode = gGameServerCode;

  000e9	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode

; 1191 : 	memcpy(pMsg.AccountID, lpObj->AccountID, sizeof(pMsg.AccountID));

  000f0	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  000f3	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  000f6	8d 7e 6c	 lea	 edi, DWORD PTR [esi+108]
  000f9	89 85 ec fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+24], eax
  000ff	0f b7 47 08	 movzx	 eax, WORD PTR [edi+8]

; 1192 : 	memcpy(pMsg.GameID, lpObj->Name, sizeof(pMsg.GameID));

  00103	8d 5e 77	 lea	 ebx, DWORD PTR [esi+119]
  00106	89 8d d7 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  0010c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0010e	66 89 85 df fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+11], ax
  00115	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  00119	89 8d e1 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+13], ecx
  0011f	89 95 db fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00125	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 1193 : 
; 1194 : 	DataSendRank((char*)&pMsg, pMsg.h.size);

  00128	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0012e	6a 28		 push	 40			; 00000028H
  00130	51		 push	 ecx
  00131	89 95 e5 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+17], edx
  00137	66 89 85 e9 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+21], ax
  0013e	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank

; 1195 : 
; 1196 : 	LogAddTD("[DevilSquare] Dead [%s][%s][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->m_nEventExp, lpObj->m_nEventScore);

  00143	8b 96 90 0e 00
	00		 mov	 edx, DWORD PTR [esi+3728]
  00149	8b 86 94 0e 00
	00		 mov	 eax, DWORD PTR [esi+3732]
  0014f	52		 push	 edx
  00150	50		 push	 eax
  00151	53		 push	 ebx
  00152	57		 push	 edi
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL@
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0015e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1197 : 
; 1198 : 	lpObj->m_nEventScore = 0;

  00161	33 c0		 xor	 eax, eax
  00163	89 86 90 0e 00
	00		 mov	 DWORD PTR [esi+3728], eax

; 1199 : 	lpObj->m_nEventMoney = 0;

  00169	89 86 98 0e 00
	00		 mov	 DWORD PTR [esi+3736], eax

; 1200 : 	lpObj->m_nEventExp = 0;

  0016f	89 86 94 0e 00
	00		 mov	 DWORD PTR [esi+3732], eax
  00175	5f		 pop	 edi
$LN6@DieProcDev:

; 1201 : 
; 1202 : }

  00176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	5e		 pop	 esi
  0017a	33 cd		 xor	 ecx, ebp
  0017c	5b		 pop	 ebx
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 04 00	 ret	 4
?DieProcDevilSquare@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDevilSquare::DieProcDevilSquare
_TEXT	ENDS
PUBLIC	?gObjMonsterExpSingle@CDevilSquare@@QAEHPAUOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterExpSingle
EXTRN	?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z:PROC ; gObjLevelUp
EXTRN	?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z:PROC ; gObjUserSetExp
EXTRN	?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; gObjSealUserSetExp
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?DinamicExp@cGrandReset@@QAEHHH@Z:PROC		; cGrandReset::DinamicExp
EXTRN	?gGrandReset@@3VcGrandReset@@A:BYTE		; gGrandReset
EXTRN	?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; cResetSystem::Main
EXTRN	?gResetSystem@@3VcResetSystem@@A:BYTE		; gResetSystem
EXTRN	?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterLevelSystem::CheckIsMasterLevelCharacter
EXTRN	?g_MasterLevelSystem@@3VCMasterLevelSystem@@A:BYTE ; g_MasterLevelSystem
EXTRN	?gLevelExperience@@3PAKA:BYTE			; gLevelExperience
EXTRN	_rand:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allrem:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterExpSingle@CDevilSquare@@QAEHPAUOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
_maxexp$ = -16						; size = 8
_exp$ = -8						; size = 8
tv365 = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_dmg$ = 16						; size = 4
_tot_dmg$ = 20						; size = 4
?gObjMonsterExpSingle@CDevilSquare@@QAEHPAUOBJECTSTRUCT@@0HH@Z PROC ; CDevilSquare::gObjMonsterExpSingle, COMDAT
; _this$ = ecx

; 1205 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1206 : 	__int64 exp;
; 1207 : 	__int64 maxexp = 0;
; 1208 : 
; 1209 : 	int level = ((lpTargetObj->Level + 25) * lpTargetObj->Level) / 3;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00009	0f b7 80 be 00
	00 00		 movzx	 eax, WORD PTR [eax+190]
  00010	0f bf c8	 movsx	 ecx, ax
  00013	8d 51 19	 lea	 edx, DWORD PTR [ecx+25]
  00016	0f af d1	 imul	 edx, ecx
  00019	89 45 fc	 mov	 DWORD PTR tv365[ebp], eax
  0001c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00021	f7 ea		 imul	 edx
  00023	53		 push	 ebx
  00024	56		 push	 esi
  00025	57		 push	 edi

; 1210 : 
; 1211 : 	if ( (lpTargetObj->Level + 10) < lpObj->Level )

  00026	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00029	0f bf 9f be 00
	00 00		 movsx	 ebx, WORD PTR [edi+190]
  00030	8b f2		 mov	 esi, edx
  00032	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00035	8d 41 0a	 lea	 eax, DWORD PTR [ecx+10]
  00038	03 f2		 add	 esi, edx
  0003a	3b c3		 cmp	 eax, ebx
  0003c	7d 08		 jge	 SHORT $LN15@gObjMonste

; 1212 : 	{
; 1213 : 		level = (level*(lpTargetObj->Level + 10))/lpObj->Level;

  0003e	0f af c6	 imul	 eax, esi
  00041	99		 cdq
  00042	f7 fb		 idiv	 ebx
  00044	8b f0		 mov	 esi, eax
$LN15@gObjMonste:

; 1214 : 	}
; 1215 : 
; 1216 : 	if ( lpTargetObj->Level >= 65 )

  00046	66 83 7d fc 41	 cmp	 WORD PTR tv365[ebp], 65	; 00000041H
  0004b	7c 13		 jl	 SHORT $LN14@gObjMonste

; 1217 : 	{
; 1218 : 		level += (lpTargetObj->Level-64)*(lpTargetObj->Level / 4);

  0004d	8b c1		 mov	 eax, ecx
  0004f	99		 cdq
  00050	83 e2 03	 and	 edx, 3
  00053	03 c2		 add	 eax, edx
  00055	c1 f8 02	 sar	 eax, 2
  00058	8d 59 c0	 lea	 ebx, DWORD PTR [ecx-64]
  0005b	0f af d8	 imul	 ebx, eax
  0005e	03 f3		 add	 esi, ebx
$LN14@gObjMonste:

; 1219 : 	}
; 1220 : 
; 1221 : 	if ( level > 0 )

  00060	85 f6		 test	 esi, esi
  00062	7e 21		 jle	 SHORT $LN13@gObjMonste

; 1222 : 	{
; 1223 : 		maxexp = level / 2;

  00064	8b c6		 mov	 eax, esi
  00066	99		 cdq
  00067	2b c2		 sub	 eax, edx
  00069	d1 f8		 sar	 eax, 1
  0006b	99		 cdq
  0006c	8b d8		 mov	 ebx, eax
  0006e	89 55 f4	 mov	 DWORD PTR _maxexp$[ebp+4], edx

; 1228 : 	}
; 1229 : 
; 1230 : 	if ( maxexp < 1 )

  00071	85 d2		 test	 edx, edx
  00073	7f 1b		 jg	 SHORT $LN11@gObjMonste
  00075	7c 05		 jl	 SHORT $LN19@gObjMonste
  00077	83 fb 01	 cmp	 ebx, 1
  0007a	73 14		 jae	 SHORT $LN11@gObjMonste
$LN19@gObjMonste:

; 1231 : 	{
; 1232 : 		exp = level;

  0007c	8b c6		 mov	 eax, esi
  0007e	99		 cdq
  0007f	8b c8		 mov	 ecx, eax
  00081	8b da		 mov	 ebx, edx

; 1233 : 	}
; 1234 : 	else

  00083	eb 28		 jmp	 SHORT $LN10@gObjMonste
$LN13@gObjMonste:

; 1224 : 	}
; 1225 : 	else
; 1226 : 	{
; 1227 : 		level = 0;

  00085	33 f6		 xor	 esi, esi

; 1231 : 	{
; 1232 : 		exp = level;

  00087	8b c6		 mov	 eax, esi
  00089	99		 cdq
  0008a	8b c8		 mov	 ecx, eax
  0008c	8b da		 mov	 ebx, edx

; 1233 : 	}
; 1234 : 	else

  0008e	eb 1d		 jmp	 SHORT $LN10@gObjMonste
$LN11@gObjMonste:

; 1235 : 	{
; 1236 : 		exp = level + rand()%maxexp;

  00090	e8 00 00 00 00	 call	 _rand
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _maxexp$[ebp+4]
  00098	51		 push	 ecx
  00099	99		 cdq
  0009a	53		 push	 ebx
  0009b	52		 push	 edx
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 __allrem
  000a2	8b c8		 mov	 ecx, eax
  000a4	8b da		 mov	 ebx, edx
  000a6	8b c6		 mov	 eax, esi
  000a8	99		 cdq
  000a9	03 c8		 add	 ecx, eax
  000ab	13 da		 adc	 ebx, edx
$LN10@gObjMonste:

; 1237 : 	}
; 1238 : 
; 1239 : 	exp = (dmg * exp)/tot_dmg;

  000ad	8b 45 10	 mov	 eax, DWORD PTR _dmg$[ebp]
  000b0	53		 push	 ebx
  000b1	99		 cdq
  000b2	51		 push	 ecx
  000b3	52		 push	 edx
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 __allmul
  000ba	8b c8		 mov	 ecx, eax
  000bc	8b 45 14	 mov	 eax, DWORD PTR _tot_dmg$[ebp]
  000bf	8b f2		 mov	 esi, edx
  000c1	99		 cdq
  000c2	52		 push	 edx
  000c3	50		 push	 eax
  000c4	56		 push	 esi
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 __alldiv

; 1240 : 	DWORD mymaxexp = gLevelExperience[lpObj->Level];

  000cb	0f bf 8f be 00
	00 00		 movsx	 ecx, WORD PTR [edi+190]
  000d2	8b 34 8d 00 00
	00 00		 mov	 esi, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]

; 1241 : 
; 1242 : 	if ( exp > mymaxexp )

  000d9	33 c9		 xor	 ecx, ecx
  000db	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax
  000de	89 55 fc	 mov	 DWORD PTR _exp$[ebp+4], edx
  000e1	3b d1		 cmp	 edx, ecx
  000e3	7c 0c		 jl	 SHORT $LN9@gObjMonste
  000e5	7f 04		 jg	 SHORT $LN20@gObjMonste
  000e7	3b c6		 cmp	 eax, esi
  000e9	76 06		 jbe	 SHORT $LN9@gObjMonste
$LN20@gObjMonste:

; 1243 : 	{
; 1244 : 		exp = mymaxexp;

  000eb	89 75 f8	 mov	 DWORD PTR _exp$[ebp], esi
  000ee	89 4d fc	 mov	 DWORD PTR _exp$[ebp+4], ecx
$LN9@gObjMonste:

; 1245 : 	}
; 1246 : 
; 1247 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpObj) == FALSE)

  000f1	57		 push	 edi
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  000f7	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  000fc	85 c0		 test	 eax, eax
  000fe	75 2f		 jne	 SHORT $LN8@gObjMonste

; 1248 : 	{
; 1249 : 		int NewExp = exp;
; 1250 : 		NewExp = gResetSystem.Main(lpObj);

  00100	57		 push	 edi
  00101	b9 00 00 00 00	 mov	 ecx, OFFSET ?gResetSystem@@3VcResetSystem@@A ; gResetSystem
  00106	e8 00 00 00 00	 call	 ?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; cResetSystem::Main

; 1251 : 		NewExp = gGrandReset.DinamicExp(lpObj->m_Index, NewExp);

  0010b	8b 17		 mov	 edx, DWORD PTR [edi]
  0010d	50		 push	 eax
  0010e	52		 push	 edx
  0010f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGrandReset@@3VcGrandReset@@A ; gGrandReset
  00114	e8 00 00 00 00	 call	 ?DinamicExp@cGrandReset@@QAEHHH@Z ; cGrandReset::DinamicExp

; 1252 : 		exp *= NewExp;

  00119	8b 4d fc	 mov	 ecx, DWORD PTR _exp$[ebp+4]
  0011c	51		 push	 ecx
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _exp$[ebp]
  00120	99		 cdq
  00121	51		 push	 ecx
  00122	52		 push	 edx
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 __allmul
  00129	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax
  0012c	89 55 fc	 mov	 DWORD PTR _exp$[ebp+4], edx
$LN8@gObjMonste:

; 1253 : 		//exp = int(exp * gResetSystem.Main(lpObj));
; 1254 : 		//exp = int(exp * gAddExperience);
; 1255 : 	}
; 1256 : #if(PC_BANG_POINT_SYSTEM==1)
; 1257 : 	if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpObj) == FALSE)//Season 4.5 addon
; 1258 : 	{
; 1259 : 		g_PCBangPointSystem.AddExperience(lpObj,exp);
; 1260 : 	}
; 1261 : #endif
; 1262 : 
; 1263 : 	if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty != FALSE)

  0012f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00134	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  00139	83 f8 01	 cmp	 eax, 1
  0013c	75 34		 jne	 SHORT $LN23@gObjMonste
  0013e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  00145	74 2b		 je	 SHORT $LN23@gObjMonste

; 1264 : 	{
; 1265 : 		exp =  (exp * g_CrywolfSync.GetGettingExpPenaltyRate()) / 100;

  00147	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0014c	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _exp$[ebp+4]
  00154	51		 push	 ecx
  00155	8b 4d f8	 mov	 ecx, DWORD PTR _exp$[ebp]
  00158	99		 cdq
  00159	51		 push	 ecx
  0015a	52		 push	 edx
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 __allmul
  00161	6a 00		 push	 0
  00163	6a 64		 push	 100			; 00000064H
  00165	52		 push	 edx
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 __alldiv
  0016c	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax
  0016f	89 55 fc	 mov	 DWORD PTR _exp$[ebp+4], edx
$LN23@gObjMonste:

; 1266 : 	}
; 1267 : 
; 1268 : 	if ( exp > 0 )

  00172	83 7d fc 00	 cmp	 DWORD PTR _exp$[ebp+4], 0
  00176	0f 8c 8c 00 00
	00		 jl	 $LN24@gObjMonste
  0017c	7f 0a		 jg	 SHORT $LN21@gObjMonste
  0017e	83 7d f8 00	 cmp	 DWORD PTR _exp$[ebp], 0
  00182	0f 86 80 00 00
	00		 jbe	 $LN24@gObjMonste
$LN21@gObjMonste:

; 1269 : 	{
; 1270 : 		if ( lpObj->Type == OBJ_USER )

  00188	66 83 7f 68 01	 cmp	 WORD PTR [edi+104], 1
  0018d	75 79		 jne	 SHORT $LN24@gObjMonste

; 1271 : 		{
; 1272 : 			gObjSealUserSetExp(lpObj, exp, FALSE); //Seal Exp (Season3 add-on)

  0018f	6a 00		 push	 0
  00191	8d 55 f8	 lea	 edx, DWORD PTR _exp$[ebp]
  00194	52		 push	 edx
  00195	57		 push	 edi
  00196	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp

; 1273 : 			gObjUserSetExp(lpObj,exp);	//Panda Use

  0019b	8d 45 f8	 lea	 eax, DWORD PTR _exp$[ebp]
  0019e	50		 push	 eax
  0019f	57		 push	 edi
  001a0	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp

; 1274 : 
; 1275 : 			lpObj->Experience += exp;

  001a5	8b 45 f8	 mov	 eax, DWORD PTR _exp$[ebp]

; 1276 : 			lpObj->m_nEventExp += exp;
; 1277 : 
; 1278 : #if(PARTY_ZEN_DROP==TRUE)
; 1279 : 			if(lpTargetObj->Type == OBJ_MONSTER)

  001a8	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001ab	01 87 c8 00 00
	00		 add	 DWORD PTR [edi+200], eax
  001b1	01 87 94 0e 00
	00		 add	 DWORD PTR [edi+3732], eax
  001b7	83 c4 14	 add	 esp, 20			; 00000014H
  001ba	66 83 79 68 02	 cmp	 WORD PTR [ecx+104], 2
  001bf	75 21		 jne	 SHORT $LN2@gObjMonste

; 1280 : 			{
; 1281 : 				if (exp > MAX_ZEN)

  001c1	83 7d fc 00	 cmp	 DWORD PTR _exp$[ebp+4], 0
  001c5	7c 15		 jl	 SHORT $LN3@gObjMonste
  001c7	7f 07		 jg	 SHORT $LN22@gObjMonste
  001c9	3d 00 94 35 77	 cmp	 eax, 2000000000		; 77359400H
  001ce	76 0c		 jbe	 SHORT $LN3@gObjMonste
$LN22@gObjMonste:

; 1282 : 				{
; 1283 : 					lpTargetObj->Money = MAX_ZEN;

  001d0	c7 81 f0 00 00
	00 00 94 35 77	 mov	 DWORD PTR [ecx+240], 2000000000 ; 77359400H

; 1284 : 				}
; 1285 : 				else

  001da	eb 06		 jmp	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:

; 1286 : 				{
; 1287 : 					lpTargetObj->Money = exp;

  001dc	89 81 f0 00 00
	00		 mov	 DWORD PTR [ecx+240], eax
$LN2@gObjMonste:

; 1288 : 				}
; 1289 : 			}
; 1290 : #endif
; 1291 : 
; 1292 : 			if ( gObjLevelUp(lpObj, exp, lpTargetObj->Class, 0) == false )

  001e2	0f b7 89 b8 00
	00 00		 movzx	 ecx, WORD PTR [ecx+184]
  001e9	6a 00		 push	 0
  001eb	51		 push	 ecx
  001ec	8d 55 f8	 lea	 edx, DWORD PTR _exp$[ebp]
  001ef	52		 push	 edx
  001f0	57		 push	 edi
  001f1	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z ; gObjLevelUp
  001f6	83 c4 10	 add	 esp, 16			; 00000010H
  001f9	84 c0		 test	 al, al
  001fb	75 0b		 jne	 SHORT $LN24@gObjMonste

; 1293 : 			{
; 1294 : 				return 0;

  001fd	5f		 pop	 edi
  001fe	5e		 pop	 esi
  001ff	33 c0		 xor	 eax, eax
  00201	5b		 pop	 ebx

; 1300 : }

  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c2 10 00	 ret	 16			; 00000010H
$LN24@gObjMonste:

; 1295 : 			}
; 1296 : 		}
; 1297 : 	}
; 1298 : 
; 1299 : 	return exp;

  00208	8b 45 f8	 mov	 eax, DWORD PTR _exp$[ebp]
  0020b	5f		 pop	 edi
  0020c	5e		 pop	 esi
  0020d	5b		 pop	 ebx

; 1300 : }

  0020e	8b e5		 mov	 esp, ebp
  00210	5d		 pop	 ebp
  00211	c2 10 00	 ret	 16			; 00000010H
?gObjMonsterExpSingle@CDevilSquare@@QAEHPAUOBJECTSTRUCT@@0HH@Z ENDP ; CDevilSquare::gObjMonsterExpSingle
_TEXT	ENDS
PUBLIC	__real@4069000000000000
PUBLIC	__real@3fc999999999999a
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BA@HPOBAIIK@DevilSquare?4cpp?$AA@	; `string'
PUBLIC	_lpObj$GSCopy$
PUBLIC	_lpTargetObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?gObjExpParty@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjExpParty
EXTRN	?GCKillPlayerExpSend@@YAXHHHHH@Z:PROC		; GCKillPlayerExpSend
EXTRN	?CheckExp@CDonateManager@@QAEXHAA_J@Z:PROC	; CDonateManager::CheckExp
EXTRN	?g_DonateManager@@3VCDonateManager@@A:BYTE	; g_DonateManager
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	?CheckMinMonsterLevel@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@0@Z:PROC ; CMasterLevelSystem::CheckMinMonsterLevel
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPOBAIIK@DevilSquare?4cpp?$AA@
CONST	SEGMENT
??_C@_0BA@HPOBAIIK@DevilSquare?4cpp?$AA@ DB 'DevilSquare.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjExpParty@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -108					; size = 4
_myexp$222814 = -104					; size = 8
tv908 = -100						; size = 4
_expMoney$ = -96					; size = 4
_viewplayer$ = -92					; size = 4
_totalexp$ = -88					; size = 8
tv931 = -84						; size = 4
_bApplaySetParty$ = -84					; size = 4
tv989 = -80						; size = 4
_toplevel$ = -80					; size = 4
_totallevel$ = -76					; size = 4
tv945 = -72						; size = 4
tv899 = -72						; size = 4
_viewpercent$ = -68					; size = 4
_lpTargetObj$GSCopy$ = -64				; size = 4
_exp$ = -60						; size = 8
_dis$ = -52						; size = 40
tv258 = -12						; size = 4
_bCheckSetParty$ = -12					; size = 7
_n$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjExpParty@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z PROC ; CDevilSquare::gObjExpParty, COMDAT
; _this$ = ecx

; 1303 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]

; 1304 : 	int n;
; 1305 : 
; 1306 : 	__int64 exp;
; 1307 : 	__int64 maxexp = 0;
; 1308 : 	__int64 totalexp;
; 1309 : #if(PARTY_ZEN_DROP==TRUE)
; 1310 : 	unsigned int expMoney = 0;

  00013	89 45 c0	 mov	 DWORD PTR _lpTargetObj$GSCopy$[ebp], eax

; 1311 : #endif
; 1312 : 
; 1313 : 	int level = ((lpTargetObj->Level + 25) * lpTargetObj->Level) / 3;

  00016	0f bf 80 be 00
	00 00		 movsx	 eax, WORD PTR [eax+190]
  0001d	8d 48 19	 lea	 ecx, DWORD PTR [eax+25]
  00020	0f af c8	 imul	 ecx, eax
  00023	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00028	f7 e9		 imul	 ecx
  0002a	53		 push	 ebx
  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00030	33 f6		 xor	 esi, esi
  00032	89 7d 94	 mov	 DWORD PTR _lpObj$GSCopy$[ebp], edi

; 1314 : 	int number;
; 1315 : 	int partynum = 0;
; 1316 : 	int totallevel = 0;
; 1317 : 	int partylevel;
; 1318 : 	int partycount;
; 1319 : 	int dis[MAX_USER_IN_PARTY];
; 1320 : 	int viewplayer = 0;
; 1321 : 	int viewpercent = 100;
; 1322 : 	BOOL bApplaySetParty = FALSE;
; 1323 : 	bool bCheckSetParty[MAX_TYPE_PLAYER];
; 1324 : 	partynum = lpObj->PartyNumber;

  00035	8b bf 2c 04 00
	00		 mov	 edi, DWORD PTR [edi+1068]
  0003b	8b da		 mov	 ebx, edx
  0003d	c1 eb 1f	 shr	 ebx, 31			; 0000001fH

; 1330 : 	{
; 1331 : 		number = gParty.m_PartyS[partynum].Number[n];

  00040	8b c7		 mov	 eax, edi
  00042	03 da		 add	 ebx, edx
  00044	6b c0 68	 imul	 eax, 104		; 00000068H
  00047	8d 80 0c 00 00
	00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[eax+12]
  0004d	89 75 a0	 mov	 DWORD PTR _expMoney$[ebp], esi
  00050	89 75 b4	 mov	 DWORD PTR _totallevel$[ebp], esi
  00053	89 75 a4	 mov	 DWORD PTR _viewplayer$[ebp], esi
  00056	c7 45 bc 64 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 100 ; 00000064H
  0005d	89 75 ac	 mov	 DWORD PTR _bApplaySetParty$[ebp], esi
  00060	89 75 b0	 mov	 DWORD PTR _toplevel$[ebp], esi
  00063	89 45 9c	 mov	 DWORD PTR tv908[ebp], eax
  00066	89 45 b8	 mov	 DWORD PTR tv899[ebp], eax
  00069	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR tv258[ebp], 10 ; 0000000aH
$LL70@gObjExpPar:
  00070	8b 4d b8	 mov	 ecx, DWORD PTR tv899[ebp]
  00073	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1332 : 
; 1333 : 		if ( number >= 0 )

  00075	85 c0		 test	 eax, eax
  00077	78 38		 js	 SHORT $LN69@gObjExpPar

; 1334 : 		{
; 1335 : 			lpPartyObj = &gObj[number];
; 1336 : 
; 1337 : 			int dis = gObjCalDistance(lpTargetObj,lpPartyObj); //Season 2.5 add-on

  00079	8b 55 c0	 mov	 edx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  0007c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00082	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00088	8b f0		 mov	 esi, eax
  0008a	56		 push	 esi
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00091	83 c4 08	 add	 esp, 8

; 1338 : 
; 1339 : 			if(dis < 10) //Season 2.5 add-on

  00094	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00097	7d 18		 jge	 SHORT $LN69@gObjExpPar

; 1340 : 			{
; 1341 : 				if ( lpPartyObj->Level+lpPartyObj->MLevel > toplevel )//Season 4.5 fix

  00099	0f bf 86 d0 00
	00 00		 movsx	 eax, WORD PTR [esi+208]
  000a0	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  000a7	03 c1		 add	 eax, ecx
  000a9	3b 45 b0	 cmp	 eax, DWORD PTR _toplevel$[ebp]
  000ac	7e 03		 jle	 SHORT $LN69@gObjExpPar

; 1342 : 				{
; 1343 : 					toplevel = lpPartyObj->Level+lpPartyObj->MLevel;//Season 4.5 fix

  000ae	89 45 b0	 mov	 DWORD PTR _toplevel$[ebp], eax
$LN69@gObjExpPar:

; 1325 : 	LPOBJ lpPartyObj;
; 1326 : 	
; 1327 : 	int toplevel = 0;
; 1328 : 
; 1329 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  000b1	83 45 b8 04	 add	 DWORD PTR tv899[ebp], 4
  000b5	ff 4d f4	 dec	 DWORD PTR tv258[ebp]
  000b8	75 b6		 jne	 SHORT $LL70@gObjExpPar

; 1344 : 				}
; 1345 : 			}
; 1346 : 		}
; 1347 : 	}
; 1348 : 
; 1349 : 	if ( OBJMAX_RANGE(partynum) == FALSE )

  000ba	85 ff		 test	 edi, edi
  000bc	78 0f		 js	 SHORT $LN81@gObjExpPar
  000be	33 c0		 xor	 eax, eax
  000c0	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  000c6	0f 9e c0	 setle	 al
  000c9	85 c0		 test	 eax, eax
  000cb	75 2b		 jne	 SHORT $LN64@gObjExpPar
$LN81@gObjExpPar:

; 1350 : 	{
; 1351 : 		LogAdd("error : %s %d", __FILE__, __LINE__);

  000cd	68 47 05 00 00	 push	 1351			; 00000547H
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HPOBAIIK@DevilSquare?4cpp?$AA@
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx

; 1614 : 		}
; 1615 : 	}	
; 1616 : #endif
; 1617 : }

  000e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000eb	33 cd		 xor	 ecx, ebp
  000ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c2 10 00	 ret	 16			; 00000010H
$LN64@gObjExpPar:

; 1352 : 		return;
; 1353 : 	}
; 1354 : 
; 1355 : 	partycount = gParty.m_PartyS[partynum].Count;
; 1356 : 
; 1357 : 	for ( n =0;n<MAX_USER_IN_PARTY;n++)

  000f8	8b 55 9c	 mov	 edx, DWORD PTR tv908[ebp]
  000fb	33 ff		 xor	 edi, edi
  000fd	89 55 b8	 mov	 DWORD PTR tv945[ebp], edx
$LL63@gObjExpPar:

; 1358 : 	{
; 1359 : 		number = gParty.m_PartyS[partynum].Number[n];

  00100	8b 45 b8	 mov	 eax, DWORD PTR tv945[ebp]
  00103	8b 30		 mov	 esi, DWORD PTR [eax]

; 1360 : 
; 1361 : 		if ( number >= 0 )

  00105	85 f6		 test	 esi, esi
  00107	78 78		 js	 SHORT $LN62@gObjExpPar

; 1362 : 		{
; 1363 : 			lpPartyObj = &gObj[number];
; 1364 : 
; 1365 : 			if ( lpTargetObj->MapNumber ==lpPartyObj->MapNumber )

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00115	8b 55 c0	 mov	 edx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  00118	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0011b	8a 8a 49 01 00
	00		 mov	 cl, BYTE PTR [edx+329]
  00121	3a 88 49 01 00
	00		 cmp	 cl, BYTE PTR [eax+329]
  00127	75 58		 jne	 SHORT $LN62@gObjExpPar

; 1366 : 			{
; 1367 : 				dis[n] = gObjCalDistance(lpTargetObj, &gObj[number]);

  00129	50		 push	 eax
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00130	83 c4 08	 add	 esp, 8
  00133	89 44 bd cc	 mov	 DWORD PTR _dis$[ebp+edi*4], eax

; 1368 : 
; 1369 : 				if ( dis[n] < 10 )

  00137	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0013a	7d 45		 jge	 SHORT $LN62@gObjExpPar

; 1370 : 				{
; 1371 : 					lpPartyObj = &gObj[number];
; 1372 : 
; 1373 : 					if ( toplevel >= (lpPartyObj->Level + lpPartyObj->MLevel + 200 ) ) // Season 4.5 fix

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00142	0f bf 94 0e be
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+190]
  0014a	0f bf 84 0e d0
	00 00 00	 movsx	 eax, WORD PTR [esi+ecx+208]
  00152	03 c2		 add	 eax, edx
  00154	8d 90 c8 00 00
	00		 lea	 edx, DWORD PTR [eax+200]
  0015a	39 55 b0	 cmp	 DWORD PTR _toplevel$[ebp], edx
  0015d	7c 0f		 jl	 SHORT $LN57@gObjExpPar

; 1374 : 					{
; 1375 : 						totallevel += lpPartyObj->Level + lpPartyObj->MLevel + 200;//Season 4.5 fix

  0015f	8b 55 b4	 mov	 edx, DWORD PTR _totallevel$[ebp]
  00162	8d 84 02 c8 00
	00 00		 lea	 eax, DWORD PTR [edx+eax+200]
  00169	89 45 b4	 mov	 DWORD PTR _totallevel$[ebp], eax

; 1376 : 					}
; 1377 : 					else

  0016c	eb 03		 jmp	 SHORT $LN56@gObjExpPar
$LN57@gObjExpPar:

; 1378 : 					{
; 1379 : 						totallevel += lpPartyObj->Level + lpPartyObj->MLevel; // Season 4.5 fix

  0016e	01 45 b4	 add	 DWORD PTR _totallevel$[ebp], eax
$LN56@gObjExpPar:

; 1380 : 					}
; 1381 : 
; 1382 : 					viewplayer++;
; 1383 : 					bCheckSetParty[lpPartyObj->Class] = true;

  00171	0f b7 8c 0e b8
	00 00 00	 movzx	 ecx, WORD PTR [esi+ecx+184]
  00179	ff 45 a4	 inc	 DWORD PTR _viewplayer$[ebp]
  0017c	c6 44 0d f4 01	 mov	 BYTE PTR _bCheckSetParty$[ebp+ecx], 1
$LN62@gObjExpPar:

; 1352 : 		return;
; 1353 : 	}
; 1354 : 
; 1355 : 	partycount = gParty.m_PartyS[partynum].Count;
; 1356 : 
; 1357 : 	for ( n =0;n<MAX_USER_IN_PARTY;n++)

  00181	83 45 b8 04	 add	 DWORD PTR tv945[ebp], 4
  00185	47		 inc	 edi
  00186	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00189	0f 8c 71 ff ff
	ff		 jl	 $LL63@gObjExpPar

; 1384 : 				}
; 1385 : 			}
; 1386 : 		}
; 1387 : 	}
; 1388 : 
; 1389 : 	if ( bCheckSetParty[0] != false && bCheckSetParty[1] != false && bCheckSetParty[2] != false 
; 1390 : 		|| bCheckSetParty[3] != false && bCheckSetParty[4] != false && bCheckSetParty[5] != false )//Season 4.5 addon

  0018f	80 7d f4 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp], 0
  00193	74 0c		 je	 SHORT $LN53@gObjExpPar
  00195	80 7d f5 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+1], 0
  00199	74 06		 je	 SHORT $LN53@gObjExpPar
  0019b	80 7d f6 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+2], 0
  0019f	75 12		 jne	 SHORT $LN54@gObjExpPar
$LN53@gObjExpPar:
  001a1	80 7d f7 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+3], 0
  001a5	74 13		 je	 SHORT $LN93@gObjExpPar
  001a7	80 7d f8 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+4], 0
  001ab	74 0d		 je	 SHORT $LN93@gObjExpPar
  001ad	80 7d f9 00	 cmp	 BYTE PTR _bCheckSetParty$[ebp+5], 0
  001b1	74 07		 je	 SHORT $LN93@gObjExpPar
$LN54@gObjExpPar:

; 1391 : 	{
; 1392 : 		bApplaySetParty = TRUE;

  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	eb 03		 jmp	 SHORT $LN55@gObjExpPar
$LN93@gObjExpPar:
  001ba	8b 45 ac	 mov	 eax, DWORD PTR _bApplaySetParty$[ebp]
$LN55@gObjExpPar:

; 1393 : 	}
; 1394 : 
; 1395 : 	if ( viewplayer > 1 )

  001bd	8b 4d a4	 mov	 ecx, DWORD PTR _viewplayer$[ebp]
  001c0	83 f9 01	 cmp	 ecx, 1
  001c3	0f 8e d7 00 00
	00		 jle	 $LN52@gObjExpPar

; 1396 : 	{
; 1397 : 		if ( bApplaySetParty != FALSE )

  001c9	85 c0		 test	 eax, eax
  001cb	74 62		 je	 SHORT $LN51@gObjExpPar

; 1398 : 		{
; 1399 : 			if ( viewplayer == 3 )

  001cd	83 f9 03	 cmp	 ecx, 3
  001d0	75 16		 jne	 SHORT $LN50@gObjExpPar

; 1400 : 			{
; 1401 : 				viewpercent = ZtConfig.Event.DSParty3ExpPercent;//230;

  001d2	8b 15 68 08 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2152

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  001d8	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  001db	89 55 bc	 mov	 DWORD PTR _viewpercent$[ebp], edx
  001de	99		 cdq
  001df	f7 f9		 idiv	 ecx
  001e1	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  001e3	e9 bb 00 00 00	 jmp	 $LN35@gObjExpPar
$LN50@gObjExpPar:

; 1402 : 			}
; 1403 : 			else if ( viewplayer == 4 )

  001e8	83 f9 04	 cmp	 ecx, 4
  001eb	75 15		 jne	 SHORT $LN48@gObjExpPar

; 1404 : 			{
; 1405 : 				viewpercent = ZtConfig.Event.DSParty4ExpPercent;//270;

  001ed	a1 6c 08 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2156
  001f2	89 45 bc	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  001f5	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  001f8	99		 cdq
  001f9	f7 f9		 idiv	 ecx
  001fb	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  001fd	e9 a1 00 00 00	 jmp	 $LN35@gObjExpPar
$LN48@gObjExpPar:

; 1406 : 			}
; 1407 : 			else if ( viewplayer >= 5 )

  00202	83 f9 05	 cmp	 ecx, 5
  00205	7c 16		 jl	 SHORT $LN46@gObjExpPar

; 1408 : 			{
; 1409 : 				viewpercent = ZtConfig.Event.DSParty5ExpPercent;//300;

  00207	8b 15 70 08 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2160

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  0020d	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00210	89 55 bc	 mov	 DWORD PTR _viewpercent$[ebp], edx
  00213	99		 cdq
  00214	f7 f9		 idiv	 ecx
  00216	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  00218	e9 86 00 00 00	 jmp	 $LN35@gObjExpPar
$LN46@gObjExpPar:

; 1410 : 			}
; 1411 : 			else
; 1412 : 			{
; 1413 : 				viewpercent = ZtConfig.Event.DSPartyExpPercentOther;//120;

  0021d	a1 74 08 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2164
  00222	89 45 bc	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  00225	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00228	99		 cdq
  00229	f7 f9		 idiv	 ecx
  0022b	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  0022d	eb 74		 jmp	 SHORT $LN35@gObjExpPar
$LN51@gObjExpPar:

; 1414 : 			}
; 1415 : 		}
; 1416 : 		else
; 1417 : 		{
; 1418 : 			if ( viewplayer == 2 )

  0022f	83 f9 02	 cmp	 ecx, 2
  00232	75 13		 jne	 SHORT $LN43@gObjExpPar

; 1419 : 			{
; 1420 : 				viewpercent = ZtConfig.Event.DSParty2ExpSetPercent;//160;

  00234	8b 15 78 08 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2168

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  0023a	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  0023d	89 55 bc	 mov	 DWORD PTR _viewpercent$[ebp], edx
  00240	99		 cdq
  00241	f7 f9		 idiv	 ecx
  00243	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  00245	eb 5c		 jmp	 SHORT $LN35@gObjExpPar
$LN43@gObjExpPar:

; 1421 : 			}
; 1422 : 			else if ( viewplayer == 3 )

  00247	83 f9 03	 cmp	 ecx, 3
  0024a	75 12		 jne	 SHORT $LN41@gObjExpPar

; 1423 : 			{
; 1424 : 				viewpercent = ZtConfig.Event.DSParty3ExpSetPercent;//180;

  0024c	a1 7c 08 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2172
  00251	89 45 bc	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  00254	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00257	99		 cdq
  00258	f7 f9		 idiv	 ecx
  0025a	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  0025c	eb 45		 jmp	 SHORT $LN35@gObjExpPar
$LN41@gObjExpPar:

; 1425 : 			}
; 1426 : 			else if ( viewplayer == 4 )

  0025e	83 f9 04	 cmp	 ecx, 4
  00261	75 13		 jne	 SHORT $LN39@gObjExpPar

; 1427 : 			{
; 1428 : 				viewpercent = ZtConfig.Event.DSParty4ExpSetPercent;//200;

  00263	8b 15 80 08 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2176

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  00269	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  0026c	89 55 bc	 mov	 DWORD PTR _viewpercent$[ebp], edx
  0026f	99		 cdq
  00270	f7 f9		 idiv	 ecx
  00272	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  00274	eb 2d		 jmp	 SHORT $LN35@gObjExpPar
$LN39@gObjExpPar:

; 1429 : 			}
; 1430 : 			else if ( viewplayer >= 5 )

  00276	83 f9 05	 cmp	 ecx, 5
  00279	7c 12		 jl	 SHORT $LN37@gObjExpPar

; 1431 : 			{
; 1432 : 				viewpercent = ZtConfig.Event.DSParty5ExpSetPercent;//220;

  0027b	a1 84 08 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2180
  00280	89 45 bc	 mov	 DWORD PTR _viewpercent$[ebp], eax

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  00283	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00286	99		 cdq
  00287	f7 f9		 idiv	 ecx
  00289	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  0028b	eb 16		 jmp	 SHORT $LN35@gObjExpPar
$LN37@gObjExpPar:

; 1433 : 			}
; 1434 : 			else
; 1435 : 			{
; 1436 : 				viewpercent = ZtConfig.Event.DSParty1ExpSetPercent;//120;

  0028d	8b 15 88 08 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2184

; 1437 : 			}
; 1438 : 		}
; 1439 : 
; 1440 : 		partylevel = totallevel / viewplayer;

  00293	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00296	89 55 bc	 mov	 DWORD PTR _viewpercent$[ebp], edx
  00299	99		 cdq
  0029a	f7 f9		 idiv	 ecx
  0029c	8b f0		 mov	 esi, eax

; 1441 : 	}
; 1442 : 	else

  0029e	eb 03		 jmp	 SHORT $LN35@gObjExpPar
$LN52@gObjExpPar:

; 1443 : 	{
; 1444 : 		partylevel = totallevel;

  002a0	8b 75 b4	 mov	 esi, DWORD PTR _totallevel$[ebp]
$LN35@gObjExpPar:

; 1445 : 	}
; 1446 : 
; 1447 : 	if ( (lpTargetObj->Level +10) < partylevel )

  002a3	8b 45 c0	 mov	 eax, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  002a6	0f b7 b8 be 00
	00 00		 movzx	 edi, WORD PTR [eax+190]
  002ad	0f bf cf	 movsx	 ecx, di
  002b0	8d 41 0a	 lea	 eax, DWORD PTR [ecx+10]
  002b3	3b c6		 cmp	 eax, esi
  002b5	7d 08		 jge	 SHORT $LN34@gObjExpPar

; 1448 : 	{
; 1449 : 		level = (level * (lpTargetObj->Level+10) ) / partylevel;

  002b7	0f af c3	 imul	 eax, ebx
  002ba	99		 cdq
  002bb	f7 fe		 idiv	 esi
  002bd	8b d8		 mov	 ebx, eax
$LN34@gObjExpPar:

; 1450 : 	}
; 1451 : 
; 1452 : 	if ( lpTargetObj->Level >= 65 )

  002bf	66 83 ff 41	 cmp	 di, 65			; 00000041H
  002c3	7c 52		 jl	 SHORT $LN31@gObjExpPar

; 1453 : 	{
; 1454 : 		if ( viewplayer == 1 )

  002c5	83 7d a4 01	 cmp	 DWORD PTR _viewplayer$[ebp], 1
  002c9	75 20		 jne	 SHORT $LN32@gObjExpPar

; 1455 : 		{
; 1456 : 			level += ((lpTargetObj->Level+lpTargetObj->MLevel) - 64) * (lpTargetObj->Level/ 4);

  002cb	8b 55 c0	 mov	 edx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  002ce	0f bf 82 d0 00
	00 00		 movsx	 eax, WORD PTR [edx+208]
  002d5	8d 74 08 c0	 lea	 esi, DWORD PTR [eax+ecx-64]
  002d9	8b c1		 mov	 eax, ecx
  002db	99		 cdq
  002dc	83 e2 03	 and	 edx, 3
  002df	03 c2		 add	 eax, edx
  002e1	c1 f8 02	 sar	 eax, 2
  002e4	0f af f0	 imul	 esi, eax
  002e7	03 de		 add	 ebx, esi

; 1457 : 		}
; 1458 : 		else

  002e9	eb 2c		 jmp	 SHORT $LN31@gObjExpPar
$LN32@gObjExpPar:

; 1459 : 		{
; 1460 : 			level += (int)(200.0 - ((lpObj->Level + lpObj->MLevel) * 0.2));

  002eb	8b 45 94	 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
  002ee	0f bf 88 d0 00
	00 00		 movsx	 ecx, WORD PTR [eax+208]
  002f5	0f bf 90 be 00
	00 00		 movsx	 edx, WORD PTR [eax+190]
  002fc	03 ca		 add	 ecx, edx
  002fe	89 4d ac	 mov	 DWORD PTR tv931[ebp], ecx
  00301	db 45 ac	 fild	 DWORD PTR tv931[ebp]
  00304	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fc999999999999a
  0030a	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4069000000000000
  00310	e8 00 00 00 00	 call	 __ftol2_sse
  00315	2b d8		 sub	 ebx, eax
$LN31@gObjExpPar:

; 1461 : 		}
; 1462 : 	}
; 1463 : 
; 1464 : 	if ( level > 0 )

  00317	85 db		 test	 ebx, ebx
  00319	7e 22		 jle	 SHORT $LN30@gObjExpPar

; 1465 : 	{
; 1466 : 		maxexp = level / 2;

  0031b	8b c3		 mov	 eax, ebx
  0031d	99		 cdq
  0031e	2b c2		 sub	 eax, edx
  00320	d1 f8		 sar	 eax, 1
  00322	99		 cdq
  00323	8b fa		 mov	 edi, edx
  00325	8b f0		 mov	 esi, eax

; 1471 : 	}
; 1472 : 
; 1473 : 	if ( maxexp < 1 )

  00327	85 ff		 test	 edi, edi
  00329	7f 1f		 jg	 SHORT $LN28@gObjExpPar
  0032b	7c 05		 jl	 SHORT $LN83@gObjExpPar
  0032d	83 fe 01	 cmp	 esi, 1
  00330	73 18		 jae	 SHORT $LN28@gObjExpPar
$LN83@gObjExpPar:

; 1474 : 	{
; 1475 : 		totalexp = level;

  00332	8b c3		 mov	 eax, ebx
  00334	99		 cdq
  00335	89 45 a8	 mov	 DWORD PTR _totalexp$[ebp], eax
  00338	89 55 ac	 mov	 DWORD PTR _totalexp$[ebp+4], edx

; 1476 : 	}
; 1477 : 	else

  0033b	eb 2d		 jmp	 SHORT $LN27@gObjExpPar
$LN30@gObjExpPar:

; 1467 : 	}
; 1468 : 	else
; 1469 : 	{
; 1470 : 		level = 0;

  0033d	33 db		 xor	 ebx, ebx

; 1474 : 	{
; 1475 : 		totalexp = level;

  0033f	8b c3		 mov	 eax, ebx
  00341	99		 cdq
  00342	89 45 a8	 mov	 DWORD PTR _totalexp$[ebp], eax
  00345	89 55 ac	 mov	 DWORD PTR _totalexp$[ebp+4], edx

; 1476 : 	}
; 1477 : 	else

  00348	eb 20		 jmp	 SHORT $LN27@gObjExpPar
$LN28@gObjExpPar:

; 1478 : 	{
; 1479 : 		totalexp = level + rand()%maxexp;

  0034a	e8 00 00 00 00	 call	 _rand
  0034f	57		 push	 edi
  00350	99		 cdq
  00351	56		 push	 esi
  00352	52		 push	 edx
  00353	50		 push	 eax
  00354	e8 00 00 00 00	 call	 __allrem
  00359	8b c8		 mov	 ecx, eax
  0035b	8b f2		 mov	 esi, edx
  0035d	8b c3		 mov	 eax, ebx
  0035f	99		 cdq
  00360	03 c8		 add	 ecx, eax
  00362	13 f2		 adc	 esi, edx
  00364	89 4d a8	 mov	 DWORD PTR _totalexp$[ebp], ecx
  00367	89 75 ac	 mov	 DWORD PTR _totalexp$[ebp+4], esi
$LN27@gObjExpPar:

; 1480 : 	}
; 1481 : #if(PARTY_ZEN_DROP==FALSE)
; 1482 : 	if ( lpTargetObj->Type == OBJ_MONSTER )
; 1483 : 	{
; 1484 : 		lpTargetObj->Money = totalexp;
; 1485 : 	}
; 1486 : #endif
; 1487 : 	for ( n=0;n<MAX_USER_IN_PARTY;n++)

  0036a	8b 4d 9c	 mov	 ecx, DWORD PTR tv908[ebp]
  0036d	33 c0		 xor	 eax, eax
  0036f	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  00372	89 4d b0	 mov	 DWORD PTR tv989[ebp], ecx
$LL98@gObjExpPar:

; 1488 : 	{
; 1489 : 		number = gParty.m_PartyS[partynum].Number[n];

  00375	8b 55 b0	 mov	 edx, DWORD PTR tv989[ebp]
  00378	8b 32		 mov	 esi, DWORD PTR [edx]

; 1490 : 
; 1491 : 		if ( number >= 0 )

  0037a	85 f6		 test	 esi, esi
  0037c	0f 88 57 02 00
	00		 js	 $LN25@gObjExpPar

; 1492 : 		{
; 1493 : 			lpPartyObj = &gObj[number];
; 1494 : 
; 1495 : 			if ( lpTargetObj->MapNumber == lpPartyObj->MapNumber )

  00382	8b 4d c0	 mov	 ecx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  00385	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0038b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00391	8a 91 49 01 00
	00		 mov	 dl, BYTE PTR [ecx+329]
  00397	3a 96 49 01 00
	00		 cmp	 dl, BYTE PTR [esi+329]
  0039d	0f 85 36 02 00
	00		 jne	 $LN25@gObjExpPar

; 1496 : 			{
; 1497 : 				if ( dis[n] < 10 )

  003a3	83 7c 85 cc 0a	 cmp	 DWORD PTR _dis$[ebp+eax*4], 10 ; 0000000aH
  003a8	0f 8d 2b 02 00
	00		 jge	 $LN25@gObjExpPar

; 1498 : 				{
; 1499 : 					__int64 myexp = 0;//Season 4.5 changed
; 1500 : 					
; 1501 : 					//Season 4.5 addon start
; 1502 : 					if(g_MasterLevelSystem.CheckMinMonsterLevel(lpPartyObj,lpTargetObj) == 0)

  003ae	8b c1		 mov	 eax, ecx
  003b0	50		 push	 eax
  003b1	56		 push	 esi
  003b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  003b7	e8 00 00 00 00	 call	 ?CheckMinMonsterLevel@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@0@Z ; CMasterLevelSystem::CheckMinMonsterLevel
  003bc	85 c0		 test	 eax, eax
  003be	75 0b		 jne	 SHORT $LN20@gObjExpPar

; 1503 : 					{
; 1504 : 						exp = 0;

  003c0	89 45 c4	 mov	 DWORD PTR _exp$[ebp], eax
  003c3	89 45 c8	 mov	 DWORD PTR _exp$[ebp+4], eax

; 1505 : 					}
; 1506 : 					else 

  003c6	e9 8b 00 00 00	 jmp	 $LN92@gObjExpPar
$LN20@gObjExpPar:

; 1507 : 					{
; 1508 : 						if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpPartyObj) != 0)

  003cb	56		 push	 esi
  003cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  003d1	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  003d6	85 c0		 test	 eax, eax
  003d8	74 11		 je	 SHORT $LN18@gObjExpPar

; 1509 : 						{
; 1510 : 							myexp = lpPartyObj->MLNextExp;

  003da	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  003e0	8b be e4 00 00
	00		 mov	 edi, DWORD PTR [esi+228]
  003e6	89 4d 98	 mov	 DWORD PTR _myexp$222814[ebp], ecx

; 1511 : 						}
; 1512 : 						else

  003e9	eb 13		 jmp	 SHORT $LN17@gObjExpPar
$LN18@gObjExpPar:

; 1513 : 						{
; 1514 : 							myexp = gLevelExperience[lpPartyObj->Level];

  003eb	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  003f2	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?gLevelExperience@@3PAKA[edx*4]
  003f9	89 45 98	 mov	 DWORD PTR _myexp$222814[ebp], eax
  003fc	33 ff		 xor	 edi, edi
$LN17@gObjExpPar:

; 1515 : 						}
; 1516 : 
; 1517 : 						exp = ((totalexp * viewpercent* (lpPartyObj->Level + lpPartyObj->MLevel) ) / totallevel ) / 100;

  003fe	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  00405	0f bf 86 d0 00
	00 00		 movsx	 eax, WORD PTR [esi+208]
  0040c	03 c1		 add	 eax, ecx
  0040e	f7 6d bc	 imul	 DWORD PTR _viewpercent$[ebp]
  00411	8b 4d ac	 mov	 ecx, DWORD PTR _totalexp$[ebp+4]
  00414	51		 push	 ecx
  00415	8b 4d a8	 mov	 ecx, DWORD PTR _totalexp$[ebp]
  00418	51		 push	 ecx
  00419	52		 push	 edx
  0041a	50		 push	 eax
  0041b	e8 00 00 00 00	 call	 __allmul
  00420	8b c8		 mov	 ecx, eax
  00422	8b 45 b4	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00425	8b da		 mov	 ebx, edx
  00427	99		 cdq
  00428	52		 push	 edx
  00429	50		 push	 eax
  0042a	53		 push	 ebx
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 __alldiv
  00431	6a 00		 push	 0
  00433	6a 64		 push	 100			; 00000064H
  00435	52		 push	 edx
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 __alldiv
  0043c	89 45 c4	 mov	 DWORD PTR _exp$[ebp], eax
  0043f	89 55 c8	 mov	 DWORD PTR _exp$[ebp+4], edx

; 1518 : 					}
; 1519 : 					//Season 4.5 addon end
; 1520 : 
; 1521 : 					if ( exp > myexp  )

  00442	3b d7		 cmp	 edx, edi
  00444	7c 10		 jl	 SHORT $LN92@gObjExpPar
  00446	7f 05		 jg	 SHORT $LN91@gObjExpPar
  00448	3b 45 98	 cmp	 eax, DWORD PTR _myexp$222814[ebp]
  0044b	76 09		 jbe	 SHORT $LN92@gObjExpPar
$LN91@gObjExpPar:

; 1522 : 					{
; 1523 : 						exp = myexp;

  0044d	8b 55 98	 mov	 edx, DWORD PTR _myexp$222814[ebp]
  00450	89 55 c4	 mov	 DWORD PTR _exp$[ebp], edx
  00453	89 7d c8	 mov	 DWORD PTR _exp$[ebp+4], edi
$LN92@gObjExpPar:
  00456	8b 7d c0	 mov	 edi, DWORD PTR _lpTargetObj$GSCopy$[ebp]

; 1524 : 					}
; 1525 : 
; 1526 : 					if( lpPartyObj->Type == OBJ_USER )

  00459	bb 01 00 00 00	 mov	 ebx, 1
  0045e	66 39 5e 68	 cmp	 WORD PTR [esi+104], bx
  00462	75 0e		 jne	 SHORT $LN94@gObjExpPar

; 1527 : 					{
; 1528 : 						if ( lpTargetObj->Type == OBJ_USER )

  00464	66 39 5f 68	 cmp	 WORD PTR [edi+104], bx
  00468	75 08		 jne	 SHORT $LN94@gObjExpPar

; 1529 : 						{
; 1530 : 							exp = 0;

  0046a	33 c0		 xor	 eax, eax
  0046c	89 45 c4	 mov	 DWORD PTR _exp$[ebp], eax
  0046f	89 45 c8	 mov	 DWORD PTR _exp$[ebp+4], eax
$LN94@gObjExpPar:

; 1531 : 						}
; 1532 : 					}
; 1533 : 
; 1534 : 					if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpPartyObj) == FALSE)

  00472	56		 push	 esi
  00473	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterLevelSystem@@3VCMasterLevelSystem@@A ; g_MasterLevelSystem
  00478	e8 00 00 00 00	 call	 ?CheckIsMasterLevelCharacter@CMasterLevelSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterLevelSystem::CheckIsMasterLevelCharacter
  0047d	85 c0		 test	 eax, eax
  0047f	75 2f		 jne	 SHORT $LN13@gObjExpPar

; 1535 : 					{
; 1536 : 						int NewExp = exp;
; 1537 : 						NewExp = gResetSystem.Main(lpPartyObj);

  00481	56		 push	 esi
  00482	b9 00 00 00 00	 mov	 ecx, OFFSET ?gResetSystem@@3VcResetSystem@@A ; gResetSystem
  00487	e8 00 00 00 00	 call	 ?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; cResetSystem::Main

; 1538 : 						NewExp = gGrandReset.DinamicExp(lpPartyObj->m_Index, NewExp);

  0048c	50		 push	 eax
  0048d	8b 06		 mov	 eax, DWORD PTR [esi]
  0048f	50		 push	 eax
  00490	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGrandReset@@3VcGrandReset@@A ; gGrandReset
  00495	e8 00 00 00 00	 call	 ?DinamicExp@cGrandReset@@QAEHHH@Z ; cGrandReset::DinamicExp

; 1539 : 						exp *= NewExp;

  0049a	8b 4d c8	 mov	 ecx, DWORD PTR _exp$[ebp+4]
  0049d	51		 push	 ecx
  0049e	8b 4d c4	 mov	 ecx, DWORD PTR _exp$[ebp]
  004a1	99		 cdq
  004a2	51		 push	 ecx
  004a3	52		 push	 edx
  004a4	50		 push	 eax
  004a5	e8 00 00 00 00	 call	 __allmul
  004aa	89 45 c4	 mov	 DWORD PTR _exp$[ebp], eax
  004ad	89 55 c8	 mov	 DWORD PTR _exp$[ebp+4], edx
$LN13@gObjExpPar:

; 1540 : 						//exp = int(exp * gResetSystem.Main(lpPartyObj));
; 1541 : 						//exp = int(exp * gAddExperience);
; 1542 : 					}
; 1543 : #if(PC_BANG_POINT_SYSTEM==1)
; 1544 : 					if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(lpPartyObj) == FALSE)//Season 4.5 addon
; 1545 : 					{
; 1546 : 						g_PCBangPointSystem.AddExperience(lpPartyObj,exp);
; 1547 : 					}
; 1548 : #endif
; 1549 : 					if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty != FALSE)

  004b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  004b5	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  004ba	3b c3		 cmp	 eax, ebx
  004bc	75 34		 jne	 SHORT $LN97@gObjExpPar
  004be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  004c5	74 2b		 je	 SHORT $LN97@gObjExpPar

; 1550 : 					{
; 1551 : 						exp =  (exp * g_CrywolfSync.GetGettingExpPenaltyRate()) / 100;

  004c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  004cc	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  004d1	8b 4d c8	 mov	 ecx, DWORD PTR _exp$[ebp+4]
  004d4	51		 push	 ecx
  004d5	8b 4d c4	 mov	 ecx, DWORD PTR _exp$[ebp]
  004d8	99		 cdq
  004d9	51		 push	 ecx
  004da	52		 push	 edx
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 __allmul
  004e1	6a 00		 push	 0
  004e3	6a 64		 push	 100			; 00000064H
  004e5	52		 push	 edx
  004e6	50		 push	 eax
  004e7	e8 00 00 00 00	 call	 __alldiv
  004ec	89 45 c4	 mov	 DWORD PTR _exp$[ebp], eax
  004ef	89 55 c8	 mov	 DWORD PTR _exp$[ebp+4], edx
$LN97@gObjExpPar:

; 1552 : 					}
; 1553 : 
; 1554 : #if(CUSTOM_NPC_BUFFER==TRUE)
; 1555 : 					if(g_ZtLicense.user.NpcBuffer)

  004f2	80 3d dd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+221, 0
  004f9	74 2f		 je	 SHORT $LN10@gObjExpPar

; 1556 : 					{
; 1557 : 						if(lpPartyObj->ExpBuffTime > 0)

  004fb	83 be 90 28 00
	00 00		 cmp	 DWORD PTR [esi+10384], 0
  00502	76 26		 jbe	 SHORT $LN10@gObjExpPar

; 1558 : 						{
; 1559 : 							exp += ( exp * 15 ) / 100;

  00504	8b 45 c4	 mov	 eax, DWORD PTR _exp$[ebp]
  00507	8b 4d c8	 mov	 ecx, DWORD PTR _exp$[ebp+4]
  0050a	8b d0		 mov	 edx, eax
  0050c	8b d9		 mov	 ebx, ecx
  0050e	0f a4 d3 04	 shld	 ebx, edx, 4
  00512	c1 e2 04	 shl	 edx, 4
  00515	6a 00		 push	 0
  00517	2b d0		 sub	 edx, eax
  00519	6a 64		 push	 100			; 00000064H
  0051b	1b d9		 sbb	 ebx, ecx
  0051d	53		 push	 ebx
  0051e	52		 push	 edx
  0051f	e8 00 00 00 00	 call	 __alldiv
  00524	01 45 c4	 add	 DWORD PTR _exp$[ebp], eax
  00527	11 55 c8	 adc	 DWORD PTR _exp$[ebp+4], edx
$LN10@gObjExpPar:

; 1560 : 						}
; 1561 : 					}
; 1562 : #endif
; 1563 : 
; 1564 : #if(CUSTOM_DONATEMANAGER)
; 1565 : 				g_DonateManager.CheckExp(lpObj->m_Index, exp);

  0052a	8b 4d 94	 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  0052d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0052f	8d 45 c4	 lea	 eax, DWORD PTR _exp$[ebp]
  00532	50		 push	 eax
  00533	52		 push	 edx
  00534	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DonateManager@@3VCDonateManager@@A ; g_DonateManager
  00539	e8 00 00 00 00	 call	 ?CheckExp@CDonateManager@@QAEXHAA_J@Z ; CDonateManager::CheckExp

; 1566 : #endif
; 1567 : 
; 1568 : 					if ( exp > 0 )

  0053e	83 7d c8 00	 cmp	 DWORD PTR _exp$[ebp+4], 0
  00542	7c 74		 jl	 SHORT $LN95@gObjExpPar
  00544	7f 06		 jg	 SHORT $LN85@gObjExpPar
  00546	83 7d c4 00	 cmp	 DWORD PTR _exp$[ebp], 0
  0054a	76 6c		 jbe	 SHORT $LN95@gObjExpPar
$LN85@gObjExpPar:

; 1569 : 					{
; 1570 : 						if ( lpPartyObj->Type == OBJ_USER )

  0054c	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00551	0f 85 82 00 00
	00		 jne	 $LN25@gObjExpPar

; 1571 : 						{
; 1572 : 							gObjSealUserSetExp(lpPartyObj, exp, FALSE); //Seal Exp (Season3 add-on)

  00557	6a 00		 push	 0
  00559	8d 45 c4	 lea	 eax, DWORD PTR _exp$[ebp]
  0055c	50		 push	 eax
  0055d	56		 push	 esi
  0055e	e8 00 00 00 00	 call	 ?gObjSealUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; gObjSealUserSetExp

; 1573 : 							gObjUserSetExp(lpPartyObj,exp);	//Panda Use

  00563	8d 4d c4	 lea	 ecx, DWORD PTR _exp$[ebp]
  00566	51		 push	 ecx
  00567	56		 push	 esi
  00568	e8 00 00 00 00	 call	 ?gObjUserSetExp@@YAXPAUOBJECTSTRUCT@@AA_J@Z ; gObjUserSetExp

; 1574 : 
; 1575 : 							lpPartyObj->Experience += exp;

  0056d	8b 55 c4	 mov	 edx, DWORD PTR _exp$[ebp]
  00570	01 96 c8 00 00
	00		 add	 DWORD PTR [esi+200], edx

; 1576 : 							lpPartyObj->m_nEventExp += exp;

  00576	8b 45 c4	 mov	 eax, DWORD PTR _exp$[ebp]
  00579	01 86 94 0e 00
	00		 add	 DWORD PTR [esi+3732], eax
  0057f	83 c4 14	 add	 esp, 20			; 00000014H

; 1577 : 
; 1578 : #if(PARTY_ZEN_DROP==TRUE)
; 1579 : 							if(lpTargetObj->Type == OBJ_MONSTER)

  00582	66 83 7f 68 02	 cmp	 WORD PTR [edi+104], 2
  00587	75 14		 jne	 SHORT $LN6@gObjExpPar

; 1580 : 							{
; 1581 : 								if (expMoney < exp)

  00589	33 c0		 xor	 eax, eax
  0058b	3b 45 c8	 cmp	 eax, DWORD PTR _exp$[ebp+4]
  0058e	7f 0d		 jg	 SHORT $LN6@gObjExpPar
  00590	8b 45 c4	 mov	 eax, DWORD PTR _exp$[ebp]
  00593	7c 05		 jl	 SHORT $LN86@gObjExpPar
  00595	39 45 a0	 cmp	 DWORD PTR _expMoney$[ebp], eax
  00598	73 03		 jae	 SHORT $LN6@gObjExpPar
$LN86@gObjExpPar:

; 1582 : 								{
; 1583 : 									expMoney = exp;

  0059a	89 45 a0	 mov	 DWORD PTR _expMoney$[ebp], eax
$LN6@gObjExpPar:

; 1584 : 								}
; 1585 : 							}
; 1586 : #endif
; 1587 : 
; 1588 : 							if ( gObjLevelUp(lpPartyObj, exp, lpTargetObj->Class, EVENT_TYPE_PARTY) == false )

  0059d	0f b7 8f b8 00
	00 00		 movzx	 ecx, WORD PTR [edi+184]
  005a4	6a 01		 push	 1
  005a6	51		 push	 ecx
  005a7	8d 55 c4	 lea	 edx, DWORD PTR _exp$[ebp]
  005aa	52		 push	 edx
  005ab	56		 push	 esi
  005ac	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAUOBJECTSTRUCT@@AA_JHH@Z ; gObjLevelUp
  005b1	83 c4 10	 add	 esp, 16			; 00000010H
  005b4	84 c0		 test	 al, al
  005b6	74 21		 je	 SHORT $LN25@gObjExpPar
$LN95@gObjExpPar:

; 1589 : 							{
; 1590 : 								continue;
; 1591 : 							}
; 1592 : 						}
; 1593 : 					}
; 1594 : 
; 1595 : 					if ( lpPartyObj->Type == OBJ_USER )

  005b8	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  005bd	75 1a		 jne	 SHORT $LN25@gObjExpPar

; 1596 : 					{
; 1597 : 						GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);

  005bf	8b 45 14	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  005c2	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  005c5	8b 55 c4	 mov	 edx, DWORD PTR _exp$[ebp]
  005c8	50		 push	 eax
  005c9	8b 07		 mov	 eax, DWORD PTR [edi]
  005cb	51		 push	 ecx
  005cc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005ce	52		 push	 edx
  005cf	50		 push	 eax
  005d0	51		 push	 ecx
  005d1	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  005d6	83 c4 14	 add	 esp, 20			; 00000014H
$LN25@gObjExpPar:

; 1480 : 	}
; 1481 : #if(PARTY_ZEN_DROP==FALSE)
; 1482 : 	if ( lpTargetObj->Type == OBJ_MONSTER )
; 1483 : 	{
; 1484 : 		lpTargetObj->Money = totalexp;
; 1485 : 	}
; 1486 : #endif
; 1487 : 	for ( n=0;n<MAX_USER_IN_PARTY;n++)

  005d9	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  005dc	83 45 b0 04	 add	 DWORD PTR tv989[ebp], 4
  005e0	40		 inc	 eax
  005e1	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
  005e4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  005e7	0f 8c 88 fd ff
	ff		 jl	 $LL98@gObjExpPar

; 1598 : 					}
; 1599 : 				}
; 1600 : 			}
; 1601 : 		}
; 1602 : 	}
; 1603 : 
; 1604 : #if(PARTY_ZEN_DROP==TRUE)
; 1605 : 	if(lpTargetObj->Type == OBJ_MONSTER && expMoney > 0)

  005ed	8b 4d c0	 mov	 ecx, DWORD PTR _lpTargetObj$GSCopy$[ebp]
  005f0	66 83 79 68 02	 cmp	 WORD PTR [ecx+104], 2
  005f5	75 31		 jne	 SHORT $LN1@gObjExpPar
  005f7	8b 45 a0	 mov	 eax, DWORD PTR _expMoney$[ebp]
  005fa	85 c0		 test	 eax, eax
  005fc	74 2a		 je	 SHORT $LN1@gObjExpPar

; 1606 : 	{
; 1607 : 		if (expMoney > MAX_ZEN)

  005fe	3d 00 94 35 77	 cmp	 eax, 2000000000		; 77359400H
  00603	76 1d		 jbe	 SHORT $LN2@gObjExpPar

; 1608 : 		{
; 1609 : 			lpTargetObj->Money = MAX_ZEN;

  00605	5f		 pop	 edi
  00606	5e		 pop	 esi
  00607	c7 81 f0 00 00
	00 00 94 35 77	 mov	 DWORD PTR [ecx+240], 2000000000 ; 77359400H
  00611	5b		 pop	 ebx

; 1614 : 		}
; 1615 : 	}	
; 1616 : #endif
; 1617 : }

  00612	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00615	33 cd		 xor	 ecx, ebp
  00617	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061c	8b e5		 mov	 esp, ebp
  0061e	5d		 pop	 ebp
  0061f	c2 10 00	 ret	 16			; 00000010H
$LN2@gObjExpPar:

; 1610 : 		}
; 1611 : 		else
; 1612 : 		{
; 1613 : 			lpTargetObj->Money = expMoney;

  00622	89 81 f0 00 00
	00		 mov	 DWORD PTR [ecx+240], eax
$LN1@gObjExpPar:

; 1614 : 		}
; 1615 : 	}	
; 1616 : #endif
; 1617 : }

  00628	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062b	5f		 pop	 edi
  0062c	5e		 pop	 esi
  0062d	33 cd		 xor	 ecx, ebp
  0062f	5b		 pop	 ebx
  00630	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00635	8b e5		 mov	 esp, ebp
  00637	5d		 pop	 ebp
  00638	c2 10 00	 ret	 16			; 00000010H
?gObjExpParty@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z ENDP ; CDevilSquare::gObjExpParty
_TEXT	ENDS
PUBLIC	?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterScoreDivision
EXTRN	?gObjMonsterLastHitDamageUser@@YAHPAUOBJECTSTRUCT@@AAH@Z:PROC ; gObjMonsterLastHitDamageUser
EXTRN	?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageUserDel
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
tv176 = -4						; size = 4
_HitIndex$ = 8						; size = 4
_lpMonObj$ = 8						; size = 4
_lpObj$ = 12						; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z PROC ; CDevilSquare::gObjMonsterScoreDivision, COMDAT
; _this$ = ecx

; 1620 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1621 : 	::gObjMonsterHitDamageUserDel(lpMonObj);

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpMonObj$[ebp]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel

; 1622 : 	lpMonObj->Money = 0;
; 1623 : 
; 1624 : 	LPOBJ lpTargetObj;
; 1625 : 	int HitIndex;
; 1626 : 	int LastHitObjNum = ::gObjMonsterLastHitDamageUser(lpMonObj, HitIndex);

  0000e	8d 45 08	 lea	 eax, DWORD PTR _HitIndex$[ebp]
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	c7 86 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+240], 0
  0001d	e8 00 00 00 00	 call	 ?gObjMonsterLastHitDamageUser@@YAHPAUOBJECTSTRUCT@@AAH@Z ; gObjMonsterLastHitDamageUser
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 : 
; 1628 : 	if ( LastHitObjNum != -1 )

  00025	83 f8 ff	 cmp	 eax, -1
  00028	74 48		 je	 SHORT $LN1@gObjMonste@2

; 1629 : 	{
; 1630 : 		lpTargetObj = &gObj[LastHitObjNum];
; 1631 : 		int lc5 = (int)(lpMonObj->sHD[HitIndex].HitDamage / lpMonObj->MaxLife * lpMonObj->Level);
; 1632 : 		lc5 *= lpTargetObj->m_bDevilSquareIndex + 1;
; 1633 : 		lpTargetObj->m_nEventScore += lc5;

  0002a	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00031	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00037	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	57		 push	 edi
  0003e	8b f8		 mov	 edi, eax
  00040	8b 45 08	 mov	 eax, DWORD PTR _HitIndex$[ebp]
  00043	8d 8c 40 0f 03
	00 00		 lea	 ecx, DWORD PTR [eax+eax*2+783]
  0004a	89 55 fc	 mov	 DWORD PTR tv176[ebp], edx
  0004d	db 04 8e	 fild	 DWORD PTR [esi+ecx*4]
  00050	d8 b6 00 01 00
	00		 fdiv	 DWORD PTR [esi+256]
  00056	db 45 fc	 fild	 DWORD PTR tv176[ebp]
  00059	de c9		 fmulp	 ST(1), ST(0)
  0005b	e8 00 00 00 00	 call	 __ftol2_sse
  00060	0f b6 8f 9c 0e
	00 00		 movzx	 ecx, BYTE PTR [edi+3740]
  00067	41		 inc	 ecx
  00068	0f af c1	 imul	 eax, ecx
  0006b	01 87 90 0e 00
	00		 add	 DWORD PTR [edi+3728], eax
  00071	5f		 pop	 edi
$LN1@gObjMonste@2:
  00072	5e		 pop	 esi

; 1634 : 	}
; 1635 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 10 00	 ret	 16			; 00000010H
?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAUOBJECTSTRUCT@@0HH@Z ENDP ; CDevilSquare::gObjMonsterScoreDivision
_TEXT	ENDS
PUBLIC	?ItemClear@CDevilSquare@@AAEXXZ			; CDevilSquare::ItemClear
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?ItemClear@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
?ItemClear@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ItemClear, COMDAT
; _this$ = ecx

; 1639 : 	int CurTime = GetTickCount();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00006	b8 84 28 2f 00	 mov	 eax, OFFSET ?MapC@@3PAVMapClass@@A+3090564
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@ItemClear:

; 1640 : 
; 1641 : 	for ( int i=0;i<MAX_MAPITEM;i++)
; 1642 : 	{
; 1643 : 		MapC[MAP_INDEX_DEVILSQUARE].m_cItem[i].m_State = 8;

  00010	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
  00016	05 74 04 00 00	 add	 eax, 1140		; 00000474H
  0001b	3d 74 60 34 00	 cmp	 eax, OFFSET ?MapC@@3PAVMapClass@@A+3432564
  00020	7c ee		 jl	 SHORT $LL3@ItemClear

; 1644 : 	}
; 1645 : }

  00022	c3		 ret	 0
?ItemClear@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ItemClear
_TEXT	ENDS
PUBLIC	?CalcScore@CDevilSquare@@QAEXXZ			; CDevilSquare::CalcScore
EXTRN	?SendScore@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::SendScore
EXTRN	?SortScore@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::SortScore
EXTRN	?InsertObj@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CDevilSquareGround::InsertObj
EXTRN	?ClearScore@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::ClearScore
; Function compile flags: /Ogtp
;	COMDAT ?CalcScore@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
tv263 = -4						; size = 4
?CalcScore@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::CalcScore, COMDAT
; _this$ = ecx

; 1648 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 1649 : 	for ( int n=0;n<MAX_DEVILSQUARE_GROUND;n++)

  00009	8d 7e 3c	 lea	 edi, DWORD PTR [esi+60]
  0000c	89 7d fc	 mov	 DWORD PTR tv263[ebp], edi
  0000f	bb 07 00 00 00	 mov	 ebx, 7
$LL12@CalcScore:

; 1650 : 	{
; 1651 : 		this->m_DevilSquareGround[n].ClearScore();

  00014	8b cf		 mov	 ecx, edi
  00016	e8 00 00 00 00	 call	 ?ClearScore@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::ClearScore
  0001b	81 c7 a8 04 00
	00		 add	 edi, 1192		; 000004a8H
  00021	4b		 dec	 ebx
  00022	75 f0		 jne	 SHORT $LL12@CalcScore

; 1652 : 	}
; 1653 : 
; 1654 : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00024	bf 00 a7 40 09	 mov	 edi, 155232000		; 0940a700H
  00029	bb 03 00 00 00	 mov	 ebx, 3
  0002e	8b ff		 npad	 2
$LL9@CalcScore:

; 1655 : 	{
; 1656 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	39 5c 07 04	 cmp	 DWORD PTR [edi+eax+4], ebx
  00039	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0003c	75 3c		 jne	 SHORT $LN8@CalcScore

; 1657 : 		{
; 1658 : 			if ( DS_MAP_RANGE(gObj[n].MapNumber) != FALSE )

  0003e	8a 81 49 01 00
	00		 mov	 al, BYTE PTR [ecx+329]
  00044	3c 09		 cmp	 al, 9
  00046	74 0d		 je	 SHORT $LN25@CalcScore
  00048	33 d2		 xor	 edx, edx
  0004a	3c 20		 cmp	 al, 32			; 00000020H
  0004c	0f 94 c2	 sete	 dl
  0004f	8b c2		 mov	 eax, edx
  00051	85 c0		 test	 eax, eax
  00053	74 25		 je	 SHORT $LN8@CalcScore
$LN25@CalcScore:

; 1659 : 			{
; 1660 : 				if ( DS_LEVEL_RANGE(gObj[n].m_bDevilSquareIndex) != FALSE )

  00055	8a 91 9c 0e 00
	00		 mov	 dl, BYTE PTR [ecx+3740]
  0005b	b8 06 00 00 00	 mov	 eax, 6
  00060	3a c2		 cmp	 al, dl
  00062	1b c0		 sbb	 eax, eax
  00064	40		 inc	 eax
  00065	74 13		 je	 SHORT $LN8@CalcScore

; 1661 : 				{
; 1662 : 					this->m_DevilSquareGround[gObj[n].m_bDevilSquareIndex].InsertObj(&gObj[n]);

  00067	51		 push	 ecx
  00068	0f b6 ca	 movzx	 ecx, dl
  0006b	69 c9 a8 04 00
	00		 imul	 ecx, 1192		; 000004a8H
  00071	8d 4c 31 3c	 lea	 ecx, DWORD PTR [ecx+esi+60]
  00075	e8 00 00 00 00	 call	 ?InsertObj@CDevilSquareGround@@QAEXPAUOBJECTSTRUCT@@@Z ; CDevilSquareGround::InsertObj
$LN8@CalcScore:

; 1652 : 	}
; 1653 : 
; 1654 : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  0007a	81 c7 50 2b 00
	00		 add	 edi, 11088		; 00002b50H
  00080	81 ff 80 d7 e9
	09		 cmp	 edi, 166320000		; 09e9d780H
  00086	7c a8		 jl	 SHORT $LL9@CalcScore

; 1663 : 				}
; 1664 : 			}
; 1665 : 		}
; 1666 : 	}
; 1667 : 
; 1668 : 	for (int  n=0;n<MAX_DEVILSQUARE_GROUND;n++)

  00088	8b 75 fc	 mov	 esi, DWORD PTR tv263[ebp]
  0008b	bf 07 00 00 00	 mov	 edi, 7
$LL3@CalcScore:

; 1669 : 	{
; 1670 : 		this->m_DevilSquareGround[n].SortScore();

  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?SortScore@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::SortScore

; 1671 : 		this->m_DevilSquareGround[n].SendScore();

  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 ?SendScore@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::SendScore
  0009e	81 c6 a8 04 00
	00		 add	 esi, 1192		; 000004a8H
  000a4	4f		 dec	 edi
  000a5	75 e9		 jne	 SHORT $LL3@CalcScore
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 1672 : 	}
; 1673 : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?CalcScore@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::CalcScore
_TEXT	ENDS
PUBLIC	?SendLiveCall@CDevilSquare@@AAEXXZ		; CDevilSquare::SendLiveCall
; Function compile flags: /Ogtp
;	COMDAT ?SendLiveCall@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
?SendLiveCall@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::SendLiveCall, COMDAT
; _this$ = ecx

; 1681 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1682 : 	PMSG_ANS_EVENTLIVE pMsg;
; 1683 : 	
; 1684 : 	pMsg.h.c = 0xC1;
; 1685 : 	pMsg.h.headcode = 0x03;

  00004	b8 03 00 00 00	 mov	 eax, 3

; 1686 : 	pMsg.h.size = sizeof(pMsg);
; 1687 : 
; 1688 : 	DataSendRank((char *)&pMsg, pMsg.h.size);

  00009	50		 push	 eax
  0000a	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	50		 push	 eax
  0000e	c6 45 fc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00012	66 c7 45 fd 03
	03		 mov	 WORD PTR _pMsg$[ebp+1], 771 ; 00000303H
  00018	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank
  0001d	83 c4 08	 add	 esp, 8

; 1689 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?SendLiveCall@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::SendLiveCall
_TEXT	ENDS
PUBLIC	?gObjScoreClear@CDevilSquare@@AAEXXZ		; CDevilSquare::gObjScoreClear
; Function compile flags: /Ogtp
;	COMDAT ?gObjScoreClear@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
?gObjScoreClear@CDevilSquare@@AAEXXZ PROC		; CDevilSquare::gObjScoreClear, COMDAT
; _this$ = ecx

; 1692 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1693 : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	57		 push	 edi
  00009	b8 00 a7 40 09	 mov	 eax, 155232000		; 0940a700H
  0000e	ba 03 00 00 00	 mov	 edx, 3
  00013	33 ff		 xor	 edi, edi
$LL5@gObjScoreC:

; 1694 : 	{
; 1695 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00015	39 54 30 04	 cmp	 DWORD PTR [eax+esi+4], edx
  00019	75 41		 jne	 SHORT $LN4@gObjScoreC

; 1696 : 		{
; 1697 : 			if ( DS_MAP_RANGE(gObj[n].MapNumber) != FALSE )

  0001b	8a 8c 30 49 01
	00 00		 mov	 cl, BYTE PTR [eax+esi+329]
  00022	80 f9 09	 cmp	 cl, 9
  00025	74 0e		 je	 SHORT $LN12@gObjScoreC
  00027	33 db		 xor	 ebx, ebx
  00029	80 f9 20	 cmp	 cl, 32			; 00000020H
  0002c	0f 94 c3	 sete	 bl
  0002f	8b cb		 mov	 ecx, ebx
  00031	3b cf		 cmp	 ecx, edi
  00033	74 27		 je	 SHORT $LN4@gObjScoreC
$LN12@gObjScoreC:

; 1698 : 			{
; 1699 : 				gObj[n].m_nEventScore = 0;

  00035	89 bc 30 90 0e
	00 00		 mov	 DWORD PTR [eax+esi+3728], edi

; 1700 : 				gObj[n].m_nEventMoney = 0;

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	89 bc 08 98 0e
	00 00		 mov	 DWORD PTR [eax+ecx+3736], edi

; 1701 : 				gObj[n].m_nEventExp = 0;

  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004f	89 bc 08 94 0e
	00 00		 mov	 DWORD PTR [eax+ecx+3732], edi
  00056	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN4@gObjScoreC:

; 1693 : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  0005c	05 50 2b 00 00	 add	 eax, 11088		; 00002b50H
  00061	3d 80 d7 e9 09	 cmp	 eax, 166320000		; 09e9d780H
  00066	7c ad		 jl	 SHORT $LL5@gObjScoreC

; 1702 : 			}
; 1703 : 		}
; 1704 : 	}
; 1705 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	c3		 ret	 0
?gObjScoreClear@CDevilSquare@@AAEXXZ ENDP		; CDevilSquare::gObjScoreClear
_TEXT	ENDS
PUBLIC	??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5use@ ; `string'
PUBLIC	?CheckInvalidUser@CDevilSquare@@AAEXXZ		; CDevilSquare::CheckInvalidUser
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5use@
CONST	SEGMENT
??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5use@ DB '['
	DB	'DevilSquare] [%s][%s] Found user in DevilSquare [State:Close]'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckInvalidUser@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
?CheckInvalidUser@CDevilSquare@@AAEXXZ PROC		; CDevilSquare::CheckInvalidUser, COMDAT
; _this$ = ecx

; 1708 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b d9		 mov	 ebx, ecx

; 1709 : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000a	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  0000f	90		 npad	 1
$LL6@CheckInval:

; 1710 : 	{
; 1711 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00010	83 7c 0e 04 03	 cmp	 DWORD PTR [esi+ecx+4], 3
  00015	75 4d		 jne	 SHORT $LN5@CheckInval

; 1712 : 		{
; 1713 : 			if ( DS_MAP_RANGE(gObj[n].MapNumber) != FALSE )

  00017	8a 84 0e 49 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+329]
  0001e	3c 09		 cmp	 al, 9
  00020	74 0d		 je	 SHORT $LN14@CheckInval
  00022	33 d2		 xor	 edx, edx
  00024	3c 20		 cmp	 al, 32			; 00000020H
  00026	0f 94 c2	 sete	 dl
  00029	8b c2		 mov	 eax, edx
  0002b	85 c0		 test	 eax, eax
  0002d	74 35		 je	 SHORT $LN5@CheckInval
$LN14@CheckInval:

; 1714 : 			{
; 1715 : 				if ( this->m_eState == DevilSquare_CLOSE )

  0002f	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00033	75 2f		 jne	 SHORT $LN5@CheckInval

; 1716 : 				{
; 1717 : 					LogAddC(2, "[DevilSquare] [%s][%s] Found user in DevilSquare [State:Close]", gObj[n].AccountID, gObj[n].Name);

  00035	8d 44 0e 77	 lea	 eax, DWORD PTR [esi+ecx+119]
  00039	50		 push	 eax
  0003a	8d 4c 0e 6c	 lea	 ecx, DWORD PTR [esi+ecx+108]
  0003e	51		 push	 ecx
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5use@
  00044	6a 02		 push	 2
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1718 : 					gObjUserKill(gObj[n].m_Index);

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	8b 04 16	 mov	 eax, DWORD PTR [esi+edx]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00061	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@CheckInval:

; 1709 : 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00064	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0006a	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00070	7c 9e		 jl	 SHORT $LL6@CheckInval

; 1719 : 				}
; 1720 : 			}
; 1721 : 		}
; 1722 : 	}
; 1723 : }

  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	c3		 ret	 0
?CheckInvalidUser@CDevilSquare@@AAEXXZ ENDP		; CDevilSquare::CheckInvalidUser
_TEXT	ENDS
PUBLIC	?size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::size, COMDAT
; _this$ = ecx

; 877  : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 878  : 		}

  00003	c3		 ret	 0
?size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::size
_TEXT	ENDS
PUBLIC	??8?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 281  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 296  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??9?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 299  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 301  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Nextnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Nextnode
; Function compile flags: /Ogtp
;	COMDAT ?_Nextnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Nextnode, COMDAT

; 560  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 562  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Nextnode
_TEXT	ENDS
PUBLIC	??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@XZ ; std::allocator<DEVILSQUARE_START_TIME>::allocator<DEVILSQUARE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@XZ PROC ; std::allocator<DEVILSQUARE_START_TIME>::allocator<DEVILSQUARE_START_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@XZ ENDP ; std::allocator<DEVILSQUARE_START_TIME>::allocator<DEVILSQUARE_START_TIME>
_TEXT	ENDS
PUBLIC	??E?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 221  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 238  : 		return (*this);
; 239  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	?_Prevnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Prevnode
; Function compile flags: /Ogtp
;	COMDAT ?_Prevnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Prevnode, COMDAT

; 565  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 567  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Prevnode
_TEXT	ENDS
PUBLIC	?_Myval@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAUDEVILSQUARE_START_TIME@@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAUDEVILSQUARE_START_TIME@@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAUDEVILSQUARE_START_TIME@@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z PROC ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Myval, COMDAT

; 570  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 572  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@SAAAUDEVILSQUARE_START_TIME@@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z ENDP ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<DEVILSQUARE_START_TIME>::allocator<DEVILSQUARE_START_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<DEVILSQUARE_START_TIME>::allocator<DEVILSQUARE_START_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<DEVILSQUARE_START_TIME>::allocator<DEVILSQUARE_START_TIME>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 36   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 37   : 		}

  00008	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 93   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 94   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QBEIXZ ; std::allocator<DEVILSQUARE_START_TIME>::max_size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<DEVILSQUARE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<DEVILSQUARE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	??$addressof@UDEVILSQUARE_START_TIME@@@std@@YAPAUDEVILSQUARE_START_TIME@@AAU1@@Z ; std::addressof<DEVILSQUARE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@UDEVILSQUARE_START_TIME@@@std@@YAPAUDEVILSQUARE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UDEVILSQUARE_START_TIME@@@std@@YAPAUDEVILSQUARE_START_TIME@@AAU1@@Z PROC ; std::addressof<DEVILSQUARE_START_TIME>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UDEVILSQUARE_START_TIME@@@std@@YAPAUDEVILSQUARE_START_TIME@@AAU1@@Z ENDP ; std::addressof<DEVILSQUARE_START_TIME>
_TEXT	ENDS
PUBLIC	??$?0UDEVILSQUARE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node><DEVILSQUARE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$?0UDEVILSQUARE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0UDEVILSQUARE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z PROC ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node><DEVILSQUARE_START_TIME>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0UDEVILSQUARE_START_TIME@@@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@ABV?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z ENDP ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node><DEVILSQUARE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@ABUDEVILSQUARE_START_TIME@@@std@@YAABUDEVILSQUARE_START_TIME@@ABU1@@Z ; std::forward<DEVILSQUARE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUDEVILSQUARE_START_TIME@@@std@@YAABUDEVILSQUARE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUDEVILSQUARE_START_TIME@@@std@@YAABUDEVILSQUARE_START_TIME@@ABU1@@Z PROC ; std::forward<DEVILSQUARE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUDEVILSQUARE_START_TIME@@@std@@YAABUDEVILSQUARE_START_TIME@@ABU1@@Z ENDP ; std::forward<DEVILSQUARE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UDEVILSQUARE_START_TIME@@ABU1@@std@@YAXPAUDEVILSQUARE_START_TIME@@ABU1@@Z ; std::_Construct<DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@UDEVILSQUARE_START_TIME@@ABU1@@std@@YAXPAUDEVILSQUARE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UDEVILSQUARE_START_TIME@@ABU1@@std@@YAXPAUDEVILSQUARE_START_TIME@@ABU1@@Z PROC ; std::_Construct<DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UDEVILSQUARE_START_TIME@@ABU1@@std@@YAXPAUDEVILSQUARE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?SetPlaying@CDevilSquare@@AAEXXZ		; CDevilSquare::SetPlaying
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.cpp
;	COMDAT ?SetPlaying@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
?SetPlaying@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::SetPlaying, COMDAT
; _this$ = ecx

; 418  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 	this->gObjScoreClear();

  00003	e8 00 00 00 00	 call	 ?gObjScoreClear@CDevilSquare@@AAEXXZ ; CDevilSquare::gObjScoreClear

; 420  : 	this->SetMonster();

  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ?SetMonster@CDevilSquare@@QAEXXZ ; CDevilSquare::SetMonster

; 421  : 
; 422  : 	this->m_iRemainTime = this->m_iPlaytime;

  0000f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00012	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 423  : 
; 424  : 	if ( this->m_iPlaytime <= 1 )

  00015	83 f8 01	 cmp	 eax, 1
  00018	7f 19		 jg	 SHORT $LN2@SetPlaying

; 425  : 	{
; 426  : 		this->m_iTime = GetTickCount();

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 427  : 		this->m_iremainTimeSec = 60;

  00020	c7 46 10 3c 00
	00 00		 mov	 DWORD PTR [esi+16], 60	; 0000003cH

; 433  : 	}
; 434  : 	
; 435  : 	this->m_bSendTimeCount = FALSE;

  00027	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0002e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00031	5e		 pop	 esi

; 436  : }

  00032	c3		 ret	 0
$LN2@SetPlaying:

; 428  : 	}
; 429  : 	else
; 430  : 	{
; 431  : 		this->m_iTime = GetTickCount() + 60000;

  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00039	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H

; 432  : 		this->m_iremainTimeSec = -1;

  0003e	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1

; 433  : 	}
; 434  : 	
; 435  : 	this->m_bSendTimeCount = FALSE;

  00045	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 436  : }

  00050	c3		 ret	 0
?SetPlaying@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::SetPlaying
_TEXT	ENDS
PUBLIC	??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 369  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 370  : 		++(*(_Mybase *)this);

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx

; 371  : 		return (*this);
; 372  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 375  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 376  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 377  : 		++*this;

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
  0000c	89 11		 mov	 DWORD PTR [ecx], edx

; 378  : 		return (_Tmp);
; 379  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
??E?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator++
_TEXT	ENDS
PUBLIC	??1?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >, COMDAT
; _this$ = ecx

; 502  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	50		 push	 eax
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 503  : 		}

  00009	c3		 ret	 0
??1?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >, COMDAT
; _this$ = ecx

; 179  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 180  : 		}

  00008	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEABUDEVILSQUARE_START_TIME@@XZ ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEABUDEVILSQUARE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEABUDEVILSQUARE_START_TIME@@XZ PROC ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 218  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEABUDEVILSQUARE_START_TIME@@XZ ENDP ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z ; std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z PROC ; std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >, COMDAT
; _this$ = ecx

; 438  : 		{	// construct allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 439  : 		}

  00002	c2 04 00	 ret	 4
??0?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z ENDP ; std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
_TEXT	ENDS
PUBLIC	?max_size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 882  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 883  : 		}

  00005	c3		 ret	 0
?max_size@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T223912 = -12						; size = 12
$T223917 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 40		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	8d 45 08	 lea	 eax, DWORD PTR $T223917[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T223912[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T223917[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T223912[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T223912[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAEXPAUDEVILSQUARE_START_TIME@@ABU3@@Z ; std::allocator<DEVILSQUARE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAEXPAUDEVILSQUARE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAEXPAUDEVILSQUARE_START_TIME@@ABU3@@Z PROC ; std::allocator<DEVILSQUARE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UDEVILSQUARE_START_TIME@@@std@@QAEXPAUDEVILSQUARE_START_TIME@@ABU3@@Z ENDP ; std::allocator<DEVILSQUARE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >, COMDAT
; _this$ = ecx

; 336  : 	_List_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 337  : 		{	// construct with null node
; 338  : 		}

  00008	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??D?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEAAUDEVILSQUARE_START_TIME@@XZ ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEAAUDEVILSQUARE_START_TIME@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEAAUDEVILSQUARE_START_TIME@@XZ PROC ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 360  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 361  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QBEAAUDEVILSQUARE_START_TIME@@XZ ENDP ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::operator*
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXI@Z ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Incsize
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
CONST	ENDS
;	COMDAT ?_Incsize@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Incsize, COMDAT
; _this$ = ecx

; 1519 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	be fe ff ff 1f	 mov	 esi, 536870910		; 1ffffffeH
  0000f	2b f0		 sub	 esi, eax
  00011	3b f2		 cmp	 esi, edx
  00013	5e		 pop	 esi
  00014	73 0a		 jae	 SHORT $LN1@Incsize

; 1521 : 			_Xlength_error("list<T> too long");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0001b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN11@Incsize:
$LN1@Incsize:

; 1522 : 		this->_Mysize += _Count;

  00020	03 c2		 add	 eax, edx
  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1523 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN10@Incsize:
?_Incsize@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Incsize
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
$T224010 = -12						; size = 12
$T224002 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 40		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 10		 ja	 SHORT $LN3@allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00027	8d 45 08	 lea	 eax, DWORD PTR $T224002[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T224010[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T224002[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T224010[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T224010[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >, COMDAT
; _this$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_const_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>,std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>,std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@0@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>,std::_List_nod<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@UDEVILSQUARE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UDEVILSQUARE_START_TIME@@@0@PAUDEVILSQUARE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<DEVILSQUARE_START_TIME>,DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@UDEVILSQUARE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UDEVILSQUARE_START_TIME@@@0@PAUDEVILSQUARE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@UDEVILSQUARE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UDEVILSQUARE_START_TIME@@@0@PAUDEVILSQUARE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<DEVILSQUARE_START_TIME>,DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@UDEVILSQUARE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UDEVILSQUARE_START_TIME@@@0@PAUDEVILSQUARE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<DEVILSQUARE_START_TIME>,DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??0?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z
_TEXT	SEGMENT
$T224122 = -16						; size = 12
$T224099 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z PROC ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >, COMDAT
; _this$ = ecx

; 493  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 10		 push	 16			; 00000010H
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 12		 je	 SHORT $LN13@List_val
  0001e	89 06		 mov	 DWORD PTR [esi], eax

; 496  : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00020	89 00		 mov	 DWORD PTR [eax], eax

; 497  : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 498  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN13@List_val:
  00030	8d 45 fc	 lea	 eax, DWORD PTR $T224099[ebp]
  00033	50		 push	 eax
  00034	8d 4d f0	 lea	 ecx, DWORD PTR $T224122[ebp]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T224099[ebp], 0
  0003e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00043	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T224122[ebp]
  0004b	51		 push	 ecx
  0004c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T224122[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@List_val:
$LN28@List_val:
  00058	cc		 int	 3
??0?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@V?$allocator@UDEVILSQUARE_START_TIME@@@1@@Z ENDP ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
_TEXT	ENDS
PUBLIC	??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >, COMDAT
; _this$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@PBV?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >::_List_iterator<std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?clear@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::clear, COMDAT
; _this$ = ecx

; 1096 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1097 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1098 : 		this->_Orphan_ptr(*this, 0);
; 1099 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1100 : 
; 1101 : 		_Nodeptr _Pnext;
; 1102 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1103 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00007	89 09		 mov	 DWORD PTR [ecx], ecx

; 1104 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 1105 : 		this->_Mysize = 0;

  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1106 : 
; 1107 : 		for (; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	74 19		 je	 SHORT $LN1@clear
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL3@clear:

; 1108 : 			{	// delete an element
; 1109 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 38		 mov	 edi, DWORD PTR [eax]

; 1110 : 
; 1111 : 			_Dest_val(this->_Alnod, _Pnode);
; 1112 : 			this->_Alnod.deallocate(_Pnode, 1);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c7		 mov	 eax, edi
  0002d	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0002f	75 ef		 jne	 SHORT $LL3@clear
  00031	5f		 pop	 edi
$LN1@clear:
  00032	5e		 pop	 esi

; 1113 : 			}
; 1114 : 		}

  00033	c3		 ret	 0
?clear@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Buynode
; Function compile flags: /Ogtp
;	COMDAT ?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z
_TEXT	SEGMENT
$T224211 = -12						; size = 12
$T224188 = 8						; size = 4
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z PROC ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Buynode, COMDAT
; _this$ = ecx

; 507  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00008	6a 10		 push	 16			; 00000010H
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	83 c4 04	 add	 esp, 4
  00016	85 f6		 test	 esi, esi
  00018	74 29		 je	 SHORT $LN10@Buynode

; 509  : 
; 510  : 		_TRY_BEGIN
; 511  : 		this->_Nextnode(_Pnode) = _Next;

  0001a	8b 45 08	 mov	 eax, DWORD PTR __Next$[ebp]

; 512  : 		this->_Prevnode(_Pnode) = _Prev;
; 513  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Pnode)), _Val);

  0001d	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR __Prev$[ebp]
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	52		 push	 edx
  00026	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00029	50		 push	 eax
  0002a	83 c7 09	 add	 edi, 9
  0002d	57		 push	 edi
  0002e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00031	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@UDEVILSQUARE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UDEVILSQUARE_START_TIME@@@0@PAUDEVILSQUARE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<DEVILSQUARE_START_TIME>,DEVILSQUARE_START_TIME,DEVILSQUARE_START_TIME const &>
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	5f		 pop	 edi

; 514  : 		_CATCH_ALL
; 515  : 		this->_Alnod.deallocate(_Pnode, 1);
; 516  : 		_RERAISE;
; 517  : 		_CATCH_END
; 518  : 
; 519  : 		return (_Pnode);

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 520  : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

$LN10@Buynode:
  00043	8d 4d 08	 lea	 ecx, DWORD PTR $T224188[ebp]
  00046	51		 push	 ecx
  00047	8d 4d f4	 lea	 ecx, DWORD PTR $T224211[ebp]
  0004a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T224188[ebp], 0
  00051	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00056	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005b	8d 55 f4	 lea	 edx, DWORD PTR $T224211[ebp]
  0005e	52		 push	 edx
  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T224211[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00066	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@Buynode:
$LN32@Buynode:
  0006b	cc		 int	 3
?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z ENDP ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T224316 = -16						; size = 12
$T224272 = -4						; size = 4
??0?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >, COMDAT
; _this$ = ecx

; 607  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 10		 push	 16			; 00000010H
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 10		 je	 SHORT $LN18@list
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	89 00		 mov	 DWORD PTR [eax], eax
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 608  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0

; 607  : 		{	// construct empty list

$LN18@list:
  0002e	8d 45 fc	 lea	 eax, DWORD PTR $T224272[ebp]
  00031	50		 push	 eax
  00032	8d 4d f0	 lea	 ecx, DWORD PTR $T224316[ebp]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T224272[ebp], 0
  0003c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00041	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00046	8d 4d f0	 lea	 ecx, DWORD PTR $T224316[ebp]
  00049	51		 push	 ecx
  0004a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T224316[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN35@list:
$LN34@list:
  00056	cc		 int	 3
??0?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
_TEXT	ENDS
PUBLIC	?begin@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::begin
; Function compile flags: /Ogtp
;	COMDAT ?begin@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Myhead, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::end
_TEXT	ENDS
PUBLIC	?_Insert@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@ABUDEVILSQUARE_START_TIME@@@Z ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@ABUDEVILSQUARE_START_TIME@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@ABUDEVILSQUARE_START_TIME@@@Z PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Insert, COMDAT
; _this$ = ecx

; 967  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 968  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 969  : 		if (_Where._Getcont() != this)
; 970  : 			_DEBUG_ERROR("list insert iterator outside range");
; 971  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 972  : 
; 973  : 		_Nodeptr _Pnode = _Where._Mynode();
; 974  : 		_Nodeptr _Newnode =
; 975  : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode), _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00013	51		 push	 ecx
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Buynode

; 976  : 		_Incsize(1);

  0001d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00020	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00025	2b d1		 sub	 edx, ecx
  00027	83 fa 01	 cmp	 edx, 1
  0002a	73 0a		 jae	 SHORT $LN7@Insert
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN24@Insert:
$LN7@Insert:
  00036	41		 inc	 ecx
  00037	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 977  : 		this->_Prevnode(_Pnode) = _Newnode;

  0003a	89 07		 mov	 DWORD PTR [edi], eax

; 978  : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	5f		 pop	 edi
  00040	89 01		 mov	 DWORD PTR [ecx], eax
  00042	5e		 pop	 esi

; 979  : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN23@Insert:
?_Insert@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@@2@ABUDEVILSQUARE_START_TIME@@@Z ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Insert
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1496 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1497 : 		clear();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]
  00007	89 09		 mov	 DWORD PTR [ecx], ecx
  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	74 19		 je	 SHORT $LN3@Tidy
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@Tidy:
  00020	8b 38		 mov	 edi, DWORD PTR [eax]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c7		 mov	 eax, edi
  0002d	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0002f	75 ef		 jne	 SHORT $LL5@Tidy
  00031	5f		 pop	 edi
$LN3@Tidy:
  00032	5e		 pop	 esi

; 1498 : 		}

  00033	c3		 ret	 0
?_Tidy@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Tidy
_TEXT	ENDS
PUBLIC	??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL?$CF@ ; `string'
PUBLIC	?CheckSync@CDevilSquare@@AAEXXZ			; CDevilSquare::CheckSync
;	COMDAT ??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL?$CF@ DB '['
	DB	'DevilSquare] Sync Open Time. [%d]min remain', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.cpp
CONST	ENDS
;	COMDAT ?CheckSync@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_WebzenVar2$ = -32					; size = 8
_ltime$ = -32						; size = 8
_WebzenVar1$ = -24					; size = 8
_loc12$ = -20						; size = 4
_today$ = -16						; size = 4
tv652 = -12						; size = 4
tv622 = -12						; size = 4
_CurrentTime$ = -8					; size = 4
_this$ = -4						; size = 4
?CheckSync@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::CheckSync, COMDAT
; _this$ = ecx

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 549  : 	std::list<DEVILSQUARE_START_TIME>::iterator it; //loc2 -> ebp 4
; 550  : 	DEVILSQUARE_START_TIME WebzenVar1; //loc 3-4 -> ebp C
; 551  : 	DEVILSQUARE_START_TIME WebzenVar2; //loc 5-6 -> epb 14
; 552  : 	int BaseTime = 0; // loc7 -> ebp 18
; 553  : 	int CheckTime = 0; // loc8 -> ebp 1C
; 554  : 	DWORD CurrentTime = 0;	// loc9 -> ebp 20
; 555  : 
; 556  : 	if(this->m_listDevilSquareOpenTime.size() == 0)

  00009	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0000d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00010	0f 84 19 01 00
	00		 je	 $LN17@CheckSync

; 557  : 	{
; 558  : 		return;
; 559  : 	}
; 560  : 
; 561  : 	tm * today; //loc10 -> ebp 24
; 562  : 	time_t ltime; //loc11 -> ebp 28
; 563  : 
; 564  : 	time(&ltime); //

  00016	53		 push	 ebx
  00017	8d 45 e0	 lea	 eax, DWORD PTR _ltime$[ebp]
  0001a	57		 push	 edi
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 __time64

; 565  : 	today = localtime(&ltime); //

  00021	8d 4d e0	 lea	 ecx, DWORD PTR _ltime$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 __localtime64

; 566  : 
; 567  : 	int loc12; //loc12 -> ebp 30
; 568  : 	CurrentTime = (today->tm_hour * 60) + today->tm_min;

  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 569  : 	WebzenVar1 = *m_listDevilSquareOpenTime.begin();

  0002d	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  00030	8b d1		 mov	 edx, ecx
  00032	c1 e2 04	 shl	 edx, 4
  00035	2b d1		 sub	 edx, ecx
  00037	89 45 f0	 mov	 DWORD PTR _today$[ebp], eax
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00040	89 4d f8	 mov	 DWORD PTR _CurrentTime$[ebp], ecx
  00043	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00045	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00048	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 7d f4	 mov	 DWORD PTR tv622[ebp], edi
  00051	89 45 ec	 mov	 DWORD PTR _WebzenVar1$[ebp+4], eax

; 570  : 
; 571  : 	for( it = m_listDevilSquareOpenTime.begin(); it != m_listDevilSquareOpenTime.end(); ++it ) //for identical

  00054	3b cf		 cmp	 ecx, edi
  00056	0f 84 b1 00 00
	00		 je	 $LN163@CheckSync
  0005c	8d 64 24 00	 npad	 4
$LL166@CheckSync:

; 572  : 	{
; 573  : 		WebzenVar2 = *it; // loc5-6
; 574  : 		BaseTime = (WebzenVar1.m_iHour * 60) + WebzenVar1.m_iMinute;

  00060	8b 7d ec	 mov	 edi, DWORD PTR _WebzenVar1$[ebp+4]
  00063	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00066	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
  00069	8b c2		 mov	 eax, edx
  0006b	c1 e0 04	 shl	 eax, 4
  0006e	2b c2		 sub	 eax, edx
  00070	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]

; 575  : 		CheckTime =	(WebzenVar2.m_iHour * 60) + WebzenVar2.m_iMinute;

  00073	8b fe		 mov	 edi, esi
  00075	c1 e7 04	 shl	 edi, 4
  00078	2b fe		 sub	 edi, esi
  0007a	8d 3c bb	 lea	 edi, DWORD PTR [ebx+edi*4]

; 576  : 
; 577  : 		if( BaseTime == CheckTime )

  0007d	3b c7		 cmp	 eax, edi
  0007f	75 67		 jne	 SHORT $LN12@CheckSync

; 578  : 		{
; 579  : 			if( CurrentTime < CheckTime )

  00081	39 7d f8	 cmp	 DWORD PTR _CurrentTime$[ebp], edi
  00084	73 74		 jae	 SHORT $LN14@CheckSync
$LN164@CheckSync:

; 580  : 			{
; 581  : 				WebzenVar2 = *it;

  00086	8b 7d f4	 mov	 edi, DWORD PTR tv622[ebp]
$LN160@CheckSync:

; 594  : 		}
; 595  : 	}
; 596  : 
; 597  : 	for(loc12 = 2;loc12--;) //good ->func identical so far

  00089	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8b 52 34	 mov	 edx, DWORD PTR [edx+52]
  0008f	b8 02 00 00 00	 mov	 eax, 2
  00094	89 55 f4	 mov	 DWORD PTR tv652[ebp], edx
$LL8@CheckSync:
  00097	48		 dec	 eax
  00098	89 45 ec	 mov	 DWORD PTR _loc12$[ebp], eax

; 598  : 	{
; 599  : 		if(it == m_listDevilSquareOpenTime.end())

  0009b	3b cf		 cmp	 ecx, edi
  0009d	75 08		 jne	 SHORT $LN6@CheckSync

; 600  : 		{
; 601  : 			it = m_listDevilSquareOpenTime.begin();

  0009f	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 602  : 
; 603  : 			WebzenVar2 = (*it);

  000a1	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  000a4	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
$LN6@CheckSync:

; 604  : 		}
; 605  : 
; 606  : 		CheckTime = WebzenVar2.m_iHour*60+WebzenVar2.m_iMinute;

  000a7	8b c6		 mov	 eax, esi
  000a9	c1 e0 04	 shl	 eax, 4
  000ac	2b c6		 sub	 eax, esi
  000ae	8d 14 83	 lea	 edx, DWORD PTR [ebx+eax*4]

; 607  : 
; 608  : 		if(today->tm_hour <= WebzenVar2.m_iHour)

  000b1	8b 45 f0	 mov	 eax, DWORD PTR _today$[ebp]

; 609  : 		{
; 610  : 			this->m_iRemainTime = CheckTime - CurrentTime;

  000b4	2b 55 f8	 sub	 edx, DWORD PTR _CurrentTime$[ebp]
  000b7	39 70 08	 cmp	 DWORD PTR [eax+8], esi
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 611  : 		}
; 612  : 		else

  000bd	7e 06		 jle	 SHORT $LN167@CheckSync

; 613  : 		{
; 614  : 			this->m_iRemainTime = 1440-CurrentTime+CheckTime;

  000bf	81 c2 a0 05 00
	00		 add	 edx, 1440		; 000005a0H
$LN167@CheckSync:
  000c5	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 615  : 		}
; 616  : 
; 617  : 		if(this->m_iRemainTime <= this->m_iOpenTime)

  000c8	8b 55 f4	 mov	 edx, DWORD PTR tv652[ebp]
  000cb	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  000ce	7f 48		 jg	 SHORT $LN3@CheckSync

; 618  : 		{
; 619  : 			it++;

  000d0	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 620  : 
; 621  : 			if(it != this->m_listDevilSquareOpenTime.end())

  000d2	3b cf		 cmp	 ecx, edi
  000d4	74 06		 je	 SHORT $LN2@CheckSync

; 622  : 			{
; 623  : 				WebzenVar2 = (*it);

  000d6	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  000d9	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
$LN2@CheckSync:

; 594  : 		}
; 595  : 	}
; 596  : 
; 597  : 	for(loc12 = 2;loc12--;) //good ->func identical so far

  000dc	8b 45 ec	 mov	 eax, DWORD PTR _loc12$[ebp]
  000df	85 c0		 test	 eax, eax
  000e1	75 b4		 jne	 SHORT $LL8@CheckSync

; 582  : 				break;
; 583  : 			}
; 584  : 			continue;
; 585  : 		}
; 586  : 		
; 587  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  000e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	eb 33		 jmp	 SHORT $LN162@CheckSync
$LN12@CheckSync:
  000e8	8b 55 f8	 mov	 edx, DWORD PTR _CurrentTime$[ebp]
  000eb	3b d0		 cmp	 edx, eax
  000ed	72 04		 jb	 SHORT $LN10@CheckSync
  000ef	3b d7		 cmp	 edx, edi
  000f1	72 93		 jb	 SHORT $LN164@CheckSync
$LN10@CheckSync:

; 588  : 		{
; 589  : 			break;
; 590  : 		}
; 591  : 		else
; 592  : 		{
; 593  : 			WebzenVar1 = *it;

  000f3	8b c3		 mov	 eax, ebx
  000f5	8b d6		 mov	 edx, esi
  000f7	89 45 ec	 mov	 DWORD PTR _WebzenVar1$[ebp+4], eax
$LN14@CheckSync:

; 570  : 
; 571  : 	for( it = m_listDevilSquareOpenTime.begin(); it != m_listDevilSquareOpenTime.end(); ++it ) //for identical

  000fa	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ff	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00102	0f 85 58 ff ff
	ff		 jne	 $LL166@CheckSync

; 582  : 				break;
; 583  : 			}
; 584  : 			continue;
; 585  : 		}
; 586  : 		
; 587  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  00108	e9 79 ff ff ff	 jmp	 $LN164@CheckSync
$LN163@CheckSync:

; 580  : 			{
; 581  : 				WebzenVar2 = *it;

  0010d	8b 5d e4	 mov	 ebx, DWORD PTR _WebzenVar2$[ebp+4]
  00110	8b 75 e0	 mov	 esi, DWORD PTR _WebzenVar2$[ebp]
  00113	e9 71 ff ff ff	 jmp	 $LN160@CheckSync
$LN3@CheckSync:

; 624  : 			}
; 625  : 		}
; 626  : 		else
; 627  : 		{
; 628  : 			this->m_iRemainTime -= this->m_iOpenTime;

  00118	29 50 0c	 sub	 DWORD PTR [eax+12], edx
$LN162@CheckSync:

; 629  : 			break;
; 630  : 		}
; 631  : 	}
; 632  : 
; 633  : 	LogAdd("[DevilSquare] Sync Open Time. [%d]min remain", m_iRemainTime);

  0011b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0011e	51		 push	 ecx
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL?$CF@
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0012a	83 c4 08	 add	 esp, 8
  0012d	5f		 pop	 edi
  0012e	5b		 pop	 ebx
$LN17@CheckSync:
  0012f	5e		 pop	 esi

; 634  : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
?CheckSync@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::CheckSync
_TEXT	ENDS
PUBLIC	?CheckCloseTime@CDevilSquare@@QAEHXZ		; CDevilSquare::CheckCloseTime
; Function compile flags: /Ogtp
;	COMDAT ?CheckCloseTime@CDevilSquare@@QAEHXZ
_TEXT	SEGMENT
_WebzenVar2$ = -36					; size = 8
_ltime$ = -36						; size = 8
_WebzenVar1$ = -28					; size = 8
tv616 = -24						; size = 4
tv582 = -20						; size = 4
_loc12$ = -16						; size = 4
_this$ = -16						; size = 4
tv592 = -12						; size = 4
_loc13$ = -12						; size = 4
tv590 = -8						; size = 4
_CurrentTime$ = -4					; size = 4
?CheckCloseTime@CDevilSquare@@QAEHXZ PROC		; CDevilSquare::CheckCloseTime, COMDAT
; _this$ = ecx

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 638  : 	std::list<DEVILSQUARE_START_TIME>::iterator it; //loc2 -> ebp 4
; 639  : 	DEVILSQUARE_START_TIME WebzenVar1; //loc 3-4 -> ebp C
; 640  : 	DEVILSQUARE_START_TIME WebzenVar2; //loc 5-6 -> epb 14
; 641  : 	int BaseTime = 0; // loc7 -> ebp 18
; 642  : 	int CheckTime = 0; // loc8 -> ebp 1C
; 643  : 	DWORD CurrentTime = 0;	// loc9 -> ebp 20
; 644  : 	
; 645  : 	tm * today; //loc10 -> ebp 24
; 646  : 	time_t ltime; //loc11 -> ebp 28
; 647  : 
; 648  : 	int loc12 = 0; //loc12 -> ebp 30
; 649  : 	int loc13;
; 650  : 
; 651  : 	if(this->m_listDevilSquareOpenTime.size() == 0)

  00009	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0000d	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00010	75 07		 jne	 SHORT $LN16@CheckClose

; 652  : 	{
; 653  : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	5e		 pop	 esi

; 721  : 			break;
; 722  : 		}
; 723  : 	}
; 724  : 
; 725  : 	return loc12;
; 726  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN16@CheckClose:
  00019	53		 push	 ebx

; 654  : 	}
; 655  : 
; 656  : 	time(&ltime); //

  0001a	8d 45 dc	 lea	 eax, DWORD PTR _ltime$[ebp]
  0001d	57		 push	 edi
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 __time64

; 657  : 	today = localtime(&ltime); //

  00024	8d 4d dc	 lea	 ecx, DWORD PTR _ltime$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 __localtime64

; 658  : 
; 659  : 	
; 660  : 	CurrentTime = (today->tm_hour * 60) + today->tm_min;

  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 661  : 	WebzenVar1 = *m_listDevilSquareOpenTime.begin();

  00033	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  00036	8b 37		 mov	 esi, DWORD PTR [edi]
  00038	8b d1		 mov	 edx, ecx
  0003a	c1 e2 04	 shl	 edx, 4
  0003d	2b d1		 sub	 edx, ecx
  0003f	89 4d ec	 mov	 DWORD PTR tv582[ebp], ecx
  00042	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00045	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00048	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004b	89 4d fc	 mov	 DWORD PTR _CurrentTime$[ebp], ecx

; 662  : 
; 663  : 	for( it = m_listDevilSquareOpenTime.begin(); it != m_listDevilSquareOpenTime.end(); ++it ) //for identical

  0004e	8b ce		 mov	 ecx, esi
  00050	83 c4 08	 add	 esp, 8
  00053	89 7d f8	 mov	 DWORD PTR tv590[ebp], edi
  00056	89 75 f4	 mov	 DWORD PTR tv592[ebp], esi
  00059	89 55 e8	 mov	 DWORD PTR _WebzenVar1$[ebp+4], edx
  0005c	3b cf		 cmp	 ecx, edi
  0005e	0f 84 af 00 00
	00		 je	 $LN163@CheckClose
$LL63@CheckClose:

; 664  : 	{
; 665  : 		WebzenVar2 = *it; // loc5-6

  00064	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 666  : 		BaseTime = (WebzenVar1.m_iHour * 60) + WebzenVar1.m_iMinute;

  00067	8b 7d e8	 mov	 edi, DWORD PTR _WebzenVar1$[ebp+4]
  0006a	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
  0006d	8b f0		 mov	 esi, eax
  0006f	c1 e6 04	 shl	 esi, 4
  00072	2b f0		 sub	 esi, eax
  00074	8d 3c b7	 lea	 edi, DWORD PTR [edi+esi*4]

; 667  : 		CheckTime =	(WebzenVar2.m_iHour * 60) + WebzenVar2.m_iMinute;

  00077	8b f2		 mov	 esi, edx
  00079	c1 e6 04	 shl	 esi, 4
  0007c	2b f2		 sub	 esi, edx
  0007e	8d 34 b3	 lea	 esi, DWORD PTR [ebx+esi*4]

; 668  : 
; 669  : 		if( BaseTime == CheckTime )

  00081	3b fe		 cmp	 edi, esi
  00083	75 6a		 jne	 SHORT $LN12@CheckClose

; 670  : 		{
; 671  : 			if( CurrentTime < CheckTime )

  00085	39 75 fc	 cmp	 DWORD PTR _CurrentTime$[ebp], esi
  00088	73 77		 jae	 SHORT $LN14@CheckClose
$LN164@CheckClose:

; 672  : 			{
; 673  : 				WebzenVar2 = *it;

  0008a	8b 7d f8	 mov	 edi, DWORD PTR tv590[ebp]
$LN166@CheckClose:
  0008d	8b 75 f4	 mov	 esi, DWORD PTR tv592[ebp]
$LN160@CheckClose:

; 686  : 		}
; 687  : 	}
; 688  : 
; 689  : 	for(loc13 = 2;loc13--;) //good ->func identical so far

  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00096	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _loc13$[ebp], 2
  0009d	89 45 e8	 mov	 DWORD PTR tv616[ebp], eax
$LL8@CheckClose:
  000a0	ff 4d f4	 dec	 DWORD PTR _loc13$[ebp]

; 690  : 	{
; 691  : 		if(it == m_listDevilSquareOpenTime.end())

  000a3	3b cf		 cmp	 ecx, edi
  000a5	75 08		 jne	 SHORT $LN6@CheckClose

; 692  : 		{
; 693  : 			it = m_listDevilSquareOpenTime.begin();

  000a7	8b ce		 mov	 ecx, esi

; 694  : 
; 695  : 			WebzenVar2 = (*it);

  000a9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ac	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
$LN6@CheckClose:

; 696  : 		}
; 697  : 
; 698  : 		CheckTime = WebzenVar2.m_iHour*60+WebzenVar2.m_iMinute;

  000af	8b c2		 mov	 eax, edx
  000b1	c1 e0 04	 shl	 eax, 4
  000b4	2b c2		 sub	 eax, edx
  000b6	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]

; 699  : 
; 700  : 		if(today->tm_hour <= WebzenVar2.m_iHour)
; 701  : 		{
; 702  : 			loc12 = CheckTime - CurrentTime;

  000b9	2b 45 fc	 sub	 eax, DWORD PTR _CurrentTime$[ebp]
  000bc	39 55 ec	 cmp	 DWORD PTR tv582[ebp], edx

; 703  : 		}
; 704  : 		else

  000bf	7e 05		 jle	 SHORT $LN167@CheckClose

; 705  : 		{
; 706  : 			loc12 = 1440-CurrentTime+CheckTime;

  000c1	05 a0 05 00 00	 add	 eax, 1440		; 000005a0H
$LN167@CheckClose:

; 707  : 		}
; 708  : 
; 709  : 		if(loc12 <= this->m_iOpenTime)

  000c6	8b 7d e8	 mov	 edi, DWORD PTR tv616[ebp]
  000c9	89 45 f0	 mov	 DWORD PTR _loc12$[ebp], eax
  000cc	3b c7		 cmp	 eax, edi
  000ce	7f 4e		 jg	 SHORT $LN3@CheckClose

; 710  : 		{
; 711  : 			it++;

  000d0	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 712  : 
; 713  : 			if(it != this->m_listDevilSquareOpenTime.end())

  000d2	8b 7d f8	 mov	 edi, DWORD PTR tv590[ebp]
  000d5	3b cf		 cmp	 ecx, edi
  000d7	74 06		 je	 SHORT $LN2@CheckClose

; 714  : 			{
; 715  : 				WebzenVar2 = (*it);

  000d9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000dc	8b 59 0c	 mov	 ebx, DWORD PTR [ecx+12]
$LN2@CheckClose:

; 686  : 		}
; 687  : 	}
; 688  : 
; 689  : 	for(loc13 = 2;loc13--;) //good ->func identical so far

  000df	83 7d f4 00	 cmp	 DWORD PTR _loc13$[ebp], 0
  000e3	75 bb		 jne	 SHORT $LL8@CheckClose

; 674  : 				break;
; 675  : 			}
; 676  : 			continue;
; 677  : 		}
; 678  : 		
; 679  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  000e5	8b 45 f0	 mov	 eax, DWORD PTR _loc12$[ebp]
  000e8	5f		 pop	 edi
  000e9	5b		 pop	 ebx
  000ea	5e		 pop	 esi

; 721  : 			break;
; 722  : 		}
; 723  : 	}
; 724  : 
; 725  : 	return loc12;
; 726  : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN12@CheckClose:

; 674  : 				break;
; 675  : 			}
; 676  : 			continue;
; 677  : 		}
; 678  : 		
; 679  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  000ef	8b 45 fc	 mov	 eax, DWORD PTR _CurrentTime$[ebp]
  000f2	3b c7		 cmp	 eax, edi
  000f4	72 04		 jb	 SHORT $LN10@CheckClose
  000f6	3b c6		 cmp	 eax, esi
  000f8	72 90		 jb	 SHORT $LN164@CheckClose
$LN10@CheckClose:

; 680  : 		{
; 681  : 			break;
; 682  : 		}
; 683  : 		else
; 684  : 		{
; 685  : 			WebzenVar1 = *it;

  000fa	8b f3		 mov	 esi, ebx
  000fc	8b c2		 mov	 eax, edx
  000fe	89 75 e8	 mov	 DWORD PTR _WebzenVar1$[ebp+4], esi
$LN14@CheckClose:

; 662  : 
; 663  : 	for( it = m_listDevilSquareOpenTime.begin(); it != m_listDevilSquareOpenTime.end(); ++it ) //for identical

  00101	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00103	8b 7d f8	 mov	 edi, DWORD PTR tv590[ebp]
  00106	3b cf		 cmp	 ecx, edi
  00108	0f 85 56 ff ff
	ff		 jne	 $LL63@CheckClose

; 674  : 				break;
; 675  : 			}
; 676  : 			continue;
; 677  : 		}
; 678  : 		
; 679  : 		if( CurrentTime >= BaseTime && CurrentTime < CheckTime )

  0010e	e9 7a ff ff ff	 jmp	 $LN166@CheckClose
$LN163@CheckClose:

; 672  : 			{
; 673  : 				WebzenVar2 = *it;

  00113	8b 5d e0	 mov	 ebx, DWORD PTR _WebzenVar2$[ebp+4]
  00116	8b 55 dc	 mov	 edx, DWORD PTR _WebzenVar2$[ebp]
  00119	e9 72 ff ff ff	 jmp	 $LN160@CheckClose
$LN3@CheckClose:

; 716  : 			}
; 717  : 		}
; 718  : 		else
; 719  : 		{
; 720  : 			loc12 -= this->m_iOpenTime;

  0011e	2b c7		 sub	 eax, edi
  00120	5f		 pop	 edi
  00121	5b		 pop	 ebx
  00122	5e		 pop	 esi

; 721  : 			break;
; 722  : 		}
; 723  : 	}
; 724  : 
; 725  : 	return loc12;
; 726  : }

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?CheckCloseTime@CDevilSquare@@QAEHXZ ENDP		; CDevilSquare::CheckCloseTime
_TEXT	ENDS
PUBLIC	??1?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??1?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >, COMDAT
; _this$ = ecx

; 769  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 770  : 		_Tidy();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]
  00007	89 09		 mov	 DWORD PTR [ecx], ecx
  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00015	3b 06		 cmp	 eax, DWORD PTR [esi]
  00017	74 19		 je	 SHORT $LN6@list@2
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL8@list@2:
  00020	8b 38		 mov	 edi, DWORD PTR [eax]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c7		 mov	 eax, edi
  0002d	3b 3e		 cmp	 edi, DWORD PTR [esi]
  0002f	75 ef		 jne	 SHORT $LL8@list@2
  00031	5f		 pop	 edi
$LN6@list@2:

; 771  : 		}

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4
  0003d	5e		 pop	 esi
  0003e	c3		 ret	 0
??1?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
_TEXT	ENDS
PUBLIC	?push_back@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXABUDEVILSQUARE_START_TIME@@@Z ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXABUDEVILSQUARE_START_TIME@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXABUDEVILSQUARE_START_TIME@@@Z PROC ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 926  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 927  : 		_Insert(end(), _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Buynode
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00021	2b d1		 sub	 edx, ecx
  00023	83 fa 01	 cmp	 edx, 1
  00026	73 0a		 jae	 SHORT $LN19@push_back
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@push_back:
$LN19@push_back:
  00032	41		 inc	 ecx
  00033	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00036	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	5f		 pop	 edi
  0003d	89 01		 mov	 DWORD PTR [ecx], eax
  0003f	5e		 pop	 esi

; 928  : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN36@push_back:
?push_back@?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEXABUDEVILSQUARE_START_TIME@@@Z ENDP ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	??_7CDevilSquare@@6B@				; CDevilSquare::`vftable'
PUBLIC	??0CDevilSquare@@QAE@XZ				; CDevilSquare::CDevilSquare
PUBLIC	??_R4CDevilSquare@@6B@				; CDevilSquare::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDevilSquare@@@8			; CDevilSquare `RTTI Type Descriptor'
PUBLIC	??_R3CDevilSquare@@8				; CDevilSquare::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDevilSquare@@8				; CDevilSquare::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDevilSquare@@8			; CDevilSquare::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??0CDevilSquareGround@@QAE@XZ:PROC		; CDevilSquareGround::CDevilSquareGround
EXTRN	??1CDevilSquareGround@@UAE@XZ:PROC		; CDevilSquareGround::~CDevilSquareGround
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_ECDevilSquare@@UAEPAXI@Z:PROC		; CDevilSquare::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CDevilSquare@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDevilSquare@@8 DD FLAT:??_R0?AVCDevilSquare@@@8 ; CDevilSquare::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDevilSquare@@8
rdata$r	ENDS
;	COMDAT ??_R2CDevilSquare@@8
rdata$r	SEGMENT
??_R2CDevilSquare@@8 DD FLAT:??_R1A@?0A@EA@CDevilSquare@@8 ; CDevilSquare::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDevilSquare@@8
rdata$r	SEGMENT
??_R3CDevilSquare@@8 DD 00H				; CDevilSquare::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDevilSquare@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDevilSquare@@@8
_DATA	SEGMENT
??_R0?AVCDevilSquare@@@8 DD FLAT:??_7type_info@@6B@	; CDevilSquare `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDevilSquare@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDevilSquare@@6B@
rdata$r	SEGMENT
??_R4CDevilSquare@@6B@ DD 00H				; CDevilSquare::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDevilSquare@@@8
	DD	FLAT:??_R3CDevilSquare@@8
rdata$r	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_7CDevilSquare@@6B@
CONST	SEGMENT
??_7CDevilSquare@@6B@ DD FLAT:??_R4CDevilSquare@@6B@	; CDevilSquare::`vftable'
	DD	FLAT:??_ECDevilSquare@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CDevilSquare@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDevilSquare@@QAE@XZ$0
__ehfuncinfo$??0CDevilSquare@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CDevilSquare@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.cpp
xdata$x	ENDS
;	COMDAT ??0CDevilSquare@@QAE@XZ
_TEXT	SEGMENT
$T225649 = -32						; size = 12
_this$ = -20						; size = 4
$T225562 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDevilSquare@@QAE@XZ PROC				; CDevilSquare::CDevilSquare, COMDAT
; _this$ = ecx

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDevilSquare@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx
  00029	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDevilSquare@@6B@
  00032	33 ff		 xor	 edi, edi
  00034	6a 10		 push	 16			; 00000010H
  00036	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	3b c7		 cmp	 eax, edi
  00043	0f 84 6a 01 00
	00		 je	 $LN25@CDevilSqua
  00049	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0004c	89 00		 mov	 DWORD PTR [eax], eax
  0004e	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00051	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00054	68 00 00 00 00	 push	 OFFSET ??1CDevilSquareGround@@UAE@XZ ; CDevilSquareGround::~CDevilSquareGround
  00059	68 00 00 00 00	 push	 OFFSET ??0CDevilSquareGround@@QAE@XZ ; CDevilSquareGround::CDevilSquareGround
  0005e	6a 07		 push	 7
  00060	68 a8 04 00 00	 push	 1192			; 000004a8H
  00065	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00068	50		 push	 eax
  00069	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0006c	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z

; 79   : 	this->m_bQuit = FALSE;
; 80   : 	this->m_iCloseTime = 2; //30
; 81   : 	this->m_iOpenTime = 2; //34
; 82   : 	this->m_iPlaytime = 10;
; 83   : 
; 84   : 	//Dark Wizard until 4th Floor
; 85   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_1] = 0;
; 86   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_2] = 0;
; 87   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_3] = 0;
; 88   : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_4] = 170;
; 89   : 	
; 90   : 	//Dark Knight until 4th Floor
; 91   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_1] = 20;
; 92   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_2] = 90;
; 93   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_3] = 120;
; 94   : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_4] = 400;
; 95   : 
; 96   : 	//Elf until 4th Floor
; 97   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_1] = 10;
; 98   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_2] = 10;
; 99   : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_3] = 10;
; 100  : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_4] = 200;
; 101  : 
; 102  : 	//Magumsa until 4th Floor
; 103  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_1] = 0;
; 104  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_2] = 0;
; 105  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_3] = 0;
; 106  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_4] = 0;
; 107  : 
; 108  : 	//Dark Wizard 5th & 6th Floor
; 109  : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_5] = 170;
; 110  : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_6] = 170;
; 111  : 
; 112  : 	//Dark Knight 5th & 6th Floor
; 113  : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_5] = 400;
; 114  : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_6] = 400;
; 115  : 
; 116  : 	//Elf 5th & 6th Floor
; 117  : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_5] = 200;
; 118  : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_6] = 200;
; 119  : 
; 120  : 	//Magumsa 5th & 6th Floor
; 121  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_5] = 0;
; 122  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_6] = 0;
; 123  : 
; 124  : 	//Dark Lord All Floors
; 125  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_1] = 0;
; 126  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_2] = 0;
; 127  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_3] = 0;
; 128  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_4] = 0;
; 129  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_5] = 0;
; 130  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_6] = 0;
; 131  : 
; 132  : 	//Season3 add-on (All Classes 7th Floor)
; 133  : 	this->m_BonusScoreTable[CLASS_WIZARD][DEVIL_SQUARE_GROUND_7] = 170;
; 134  : 	this->m_BonusScoreTable[CLASS_KNIGHT][DEVIL_SQUARE_GROUND_7] = 400;
; 135  : 	this->m_BonusScoreTable[CLASS_ELF][DEVIL_SQUARE_GROUND_7] = 200;
; 136  : 	this->m_BonusScoreTable[CLASS_MAGUMSA][DEVIL_SQUARE_GROUND_7] = 0;
; 137  : 	this->m_BonusScoreTable[CLASS_DARKLORD][DEVIL_SQUARE_GROUND_7] = 0;
; 138  : 
; 139  : 	//Season4.5 add-on
; 140  : 	for( int i = 0; i < MAX_DEVILSQUARE_GROUND; i++)
; 141  : 	{
; 142  : 		(float&)this->m_BonusScoreTable[CLASS_SUMMONER][i] = 1.0f;

  00071	d9 e8		 fld1
  00073	b8 02 00 00 00	 mov	 eax, 2
  00078	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0007b	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0007e	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00083	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00086	89 86 0c 21 00
	00		 mov	 DWORD PTR [esi+8460], eax
  0008c	89 86 10 21 00
	00		 mov	 DWORD PTR [esi+8464], eax
  00092	89 86 14 21 00
	00		 mov	 DWORD PTR [esi+8468], eax
  00098	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0009b	89 be d4 20 00
	00		 mov	 DWORD PTR [esi+8404], edi
  000a1	89 be d8 20 00
	00		 mov	 DWORD PTR [esi+8408], edi
  000a7	89 be dc 20 00
	00		 mov	 DWORD PTR [esi+8412], edi
  000ad	c7 86 f0 20 00
	00 14 00 00 00	 mov	 DWORD PTR [esi+8432], 20 ; 00000014H
  000b7	c7 86 f4 20 00
	00 5a 00 00 00	 mov	 DWORD PTR [esi+8436], 90 ; 0000005aH
  000c1	c7 86 f8 20 00
	00 78 00 00 00	 mov	 DWORD PTR [esi+8440], 120 ; 00000078H
  000cb	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  000d0	89 86 18 21 00
	00		 mov	 DWORD PTR [esi+8472], eax
  000d6	89 86 1c 21 00
	00		 mov	 DWORD PTR [esi+8476], eax
  000dc	89 86 20 21 00
	00		 mov	 DWORD PTR [esi+8480], eax
  000e2	89 86 24 21 00
	00		 mov	 DWORD PTR [esi+8484], eax
  000e8	89 be 28 21 00
	00		 mov	 DWORD PTR [esi+8488], edi
  000ee	89 be 2c 21 00
	00		 mov	 DWORD PTR [esi+8492], edi
  000f4	89 be 30 21 00
	00		 mov	 DWORD PTR [esi+8496], edi
  000fa	89 be 34 21 00
	00		 mov	 DWORD PTR [esi+8500], edi
  00100	89 be 38 21 00
	00		 mov	 DWORD PTR [esi+8504], edi
  00106	89 be 3c 21 00
	00		 mov	 DWORD PTR [esi+8508], edi
  0010c	89 be 44 21 00
	00		 mov	 DWORD PTR [esi+8516], edi
  00112	89 be 48 21 00
	00		 mov	 DWORD PTR [esi+8520], edi
  00118	89 be 4c 21 00
	00		 mov	 DWORD PTR [esi+8524], edi
  0011e	89 be 50 21 00
	00		 mov	 DWORD PTR [esi+8528], edi
  00124	89 be 54 21 00
	00		 mov	 DWORD PTR [esi+8532], edi
  0012a	89 be 58 21 00
	00		 mov	 DWORD PTR [esi+8536], edi
  00130	89 be 40 21 00
	00		 mov	 DWORD PTR [esi+8512], edi
  00136	89 be 5c 21 00
	00		 mov	 DWORD PTR [esi+8540], edi
  0013c	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH
  00141	89 96 e0 20 00
	00		 mov	 DWORD PTR [esi+8416], edx
  00147	89 96 e4 20 00
	00		 mov	 DWORD PTR [esi+8420], edx
  0014d	89 96 e8 20 00
	00		 mov	 DWORD PTR [esi+8424], edx
  00153	89 96 ec 20 00
	00		 mov	 DWORD PTR [esi+8428], edx
  00159	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0015e	89 8e fc 20 00
	00		 mov	 DWORD PTR [esi+8444], ecx
  00164	89 8e 00 21 00
	00		 mov	 DWORD PTR [esi+8448], ecx
  0016a	89 8e 04 21 00
	00		 mov	 DWORD PTR [esi+8452], ecx
  00170	89 8e 08 21 00
	00		 mov	 DWORD PTR [esi+8456], ecx
  00176	d9 96 60 21 00
	00		 fst	 DWORD PTR [esi+8544]
  0017c	d9 96 64 21 00
	00		 fst	 DWORD PTR [esi+8548]

; 143  : 	}
; 144  : }

  00182	8b c6		 mov	 eax, esi
  00184	d9 96 68 21 00
	00		 fst	 DWORD PTR [esi+8552]
  0018a	d9 96 6c 21 00
	00		 fst	 DWORD PTR [esi+8556]
  00190	d9 96 70 21 00
	00		 fst	 DWORD PTR [esi+8560]
  00196	d9 96 74 21 00
	00		 fst	 DWORD PTR [esi+8564]
  0019c	d9 9e 78 21 00
	00		 fstp	 DWORD PTR [esi+8568]
  001a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ac	59		 pop	 ecx
  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0

; 78   : {

$LN25@CDevilSqua:
  001b3	8d 4d f0	 lea	 ecx, DWORD PTR $T225562[ebp]
  001b6	51		 push	 ecx
  001b7	8d 4d e0	 lea	 ecx, DWORD PTR $T225649[ebp]
  001ba	89 7d f0	 mov	 DWORD PTR $T225562[ebp], edi
  001bd	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  001c2	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  001c7	8d 55 e0	 lea	 edx, DWORD PTR $T225649[ebp]
  001ca	52		 push	 edx
  001cb	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T225649[ebp], OFFSET ??_7bad_alloc@std@@6B@
  001d2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN54@CDevilSqua:
$LN53@CDevilSqua:
  001d7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDevilSquare@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	e9 00 00 00 00	 jmp	 ??1?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
__ehhandler$??0CDevilSquare@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDevilSquare@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDevilSquare@@QAE@XZ ENDP				; CDevilSquare::CDevilSquare
PUBLIC	??1CDevilSquare@@UAE@XZ				; CDevilSquare::~CDevilSquare
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CDevilSquare@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDevilSquare@@UAE@XZ$0
__ehfuncinfo$??1CDevilSquare@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CDevilSquare@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.cpp
xdata$x	ENDS
;	COMDAT ??1CDevilSquare@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDevilSquare@@UAE@XZ PROC				; CDevilSquare::~CDevilSquare, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDevilSquare@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDevilSquare@@6B@

; 148  : 	this->m_bQuit = TRUE;
; 149  : }

  00030	68 00 00 00 00	 push	 OFFSET ??1CDevilSquareGround@@UAE@XZ ; CDevilSquareGround::~CDevilSquareGround
  00035	6a 07		 push	 7
  00037	68 a8 04 00 00	 push	 1192			; 000004a8H
  0003c	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0003f	33 ff		 xor	 edi, edi
  00041	50		 push	 eax
  00042	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00045	c7 46 18 01 00
	00 00		 mov	 DWORD PTR [esi+24], 1
  0004c	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00051	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00054	8b 01		 mov	 eax, DWORD PTR [ecx]
  00056	89 09		 mov	 DWORD PTR [ecx], ecx
  00058	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0005b	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0005e	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00061	3b 46 24	 cmp	 eax, DWORD PTR [esi+36]
  00064	74 12		 je	 SHORT $LN9@CDevilSqua@2
$LL11@CDevilSqua@2:
  00066	8b 38		 mov	 edi, DWORD PTR [eax]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006e	83 c4 04	 add	 esp, 4
  00071	8b c7		 mov	 eax, edi
  00073	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  00076	75 ee		 jne	 SHORT $LL11@CDevilSqua@2
$LN9@CDevilSqua@2:
  00078	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00081	83 c4 04	 add	 esp, 4
  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDevilSquare@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	e9 00 00 00 00	 jmp	 ??1?$list@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAE@XZ ; std::list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::~list<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >
__ehhandler$??1CDevilSquare@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDevilSquare@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDevilSquare@@UAE@XZ ENDP				; CDevilSquare::~CDevilSquare
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fai@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CDevilSquare@@QAEXPAD@Z			; CDevilSquare::Load
EXTRN	_fclose:PROC
EXTRN	?IncExp@CDevilSquareGround@@QAEXM@Z:PROC	; CDevilSquareGround::IncExp
EXTRN	?SetBonus@CDevilSquareGround@@QAEXHHH@Z:PROC	; CDevilSquareGround::SetBonus
EXTRN	?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z:PROC	; CDevilSquareGround::SetBoss
EXTRN	?Set@CDevilSquareGround@@QAEXGHH@Z:PROC		; CDevilSquareGround::Set
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	?Init@CDevilSquareGround@@QAEXH@Z:PROC		; CDevilSquareGround::Init
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fai@
CONST	SEGMENT
??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fai@ DB '[Devil'
	DB	'Square] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.cpp
CONST	ENDS
;	COMDAT ?Load@CDevilSquare@@QAEXPAD@Z
_TEXT	SEGMENT
_Schedule$222148 = -28					; size = 8
_x$ = -20						; size = 4
_y$ = -16						; size = 4
_tx$ = -12						; size = 4
_type$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CDevilSquare@@QAEXPAD@Z PROC			; CDevilSquare::Load, COMDAT
; _this$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  : 	for ( int i=0;i<MAX_DEVILSQUARE_GROUND;i++)

  0000b	33 f6		 xor	 esi, esi
  0000d	8d 79 3c	 lea	 edi, DWORD PTR [ecx+60]
$LL31@Load:

; 167  : 	{
; 168  : 		this->m_DevilSquareGround[i].Init(i);

  00010	56		 push	 esi
  00011	8b cf		 mov	 ecx, edi
  00013	e8 00 00 00 00	 call	 ?Init@CDevilSquareGround@@QAEXH@Z ; CDevilSquareGround::Init
  00018	46		 inc	 esi
  00019	81 c7 a8 04 00
	00		 add	 edi, 1192		; 000004a8H
  0001f	83 fe 07	 cmp	 esi, 7
  00022	7c ec		 jl	 SHORT $LL31@Load

; 169  : 	}
; 170  : 
; 171  : 	int Token;
; 172  : 	int number;
; 173  : 	int type;
; 174  : 	int monstertype;
; 175  : 	int starttime;
; 176  : 	int endtime;
; 177  : 	int x;
; 178  : 	int y;
; 179  : 	int tx;
; 180  : 	int ty;
; 181  : 
; 182  : 	SMDFile = fopen(filename, "r");

  00024	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 _fopen
  00032	83 c4 08	 add	 esp, 8
  00035	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 183  : 
; 184  : 	if ( SMDFile == NULL )

  0003a	85 c0		 test	 eax, eax
  0003c	75 16		 jne	 SHORT $LN74@Load

; 185  : 	{
; 186  : 		MsgBox("[DevilSquare] Info file Load Fail [%s]", filename);

  0003e	56		 push	 esi
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fai@
  00044	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00049	83 c4 08	 add	 esp, 8
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 352  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
$LN74@Load:

; 187  : 		return;
; 188  : 	}
; 189  : 
; 190  : 	while ( true )
; 191  : 	{
; 192  : 		Token = GetToken();

  00054	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 193  : 
; 194  : 		if ( Token == 2 )

  00059	83 f8 02	 cmp	 eax, 2
  0005c	0f 84 19 04 00
	00		 je	 $LN85@Load
  00062	53		 push	 ebx
$LL27@Load:

; 195  : 		{
; 196  : 			break;
; 197  : 		}
; 198  : 
; 199  : 		type = (int)TokenNumber;

  00063	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00069	e8 00 00 00 00	 call	 __ftol2_sse
  0006e	8b d8		 mov	 ebx, eax
  00070	89 5d f8	 mov	 DWORD PTR _type$[ebp], ebx
$LL24@Load:

; 200  : 
; 201  : 		while ( true )
; 202  : 		{
; 203  : 			if ( type == 0 )	// Time Sync

  00073	85 db		 test	 ebx, ebx
  00075	75 75		 jne	 SHORT $LN22@Load

; 204  : 			{
; 205  : 				Token = GetToken();

  00077	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 206  : 
; 207  : 				if ( strcmp("end", TokenString) == 0 )

  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00081	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL88@Load:
  00086	8a 10		 mov	 dl, BYTE PTR [eax]
  00088	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0008a	75 1a		 jne	 SHORT $LN89@Load
  0008c	84 d2		 test	 dl, dl
  0008e	74 12		 je	 SHORT $LN90@Load
  00090	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00093	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00096	75 0e		 jne	 SHORT $LN89@Load
  00098	83 c0 02	 add	 eax, 2
  0009b	83 c1 02	 add	 ecx, 2
  0009e	84 d2		 test	 dl, dl
  000a0	75 e4		 jne	 SHORT $LL88@Load
$LN90@Load:
  000a2	33 c0		 xor	 eax, eax
  000a4	eb 05		 jmp	 SHORT $LN91@Load
$LN89@Load:
  000a6	1b c0		 sbb	 eax, eax
  000a8	83 d8 ff	 sbb	 eax, -1
$LN91@Load:
  000ab	85 c0		 test	 eax, eax
  000ad	0f 84 b6 03 00
	00		 je	 $LN3@Load

; 208  : 				{
; 209  : 					break;
; 210  : 				}
; 211  : 
; 212  : 				this->m_iCloseTime = (int)TokenNumber;

  000b3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000b9	e8 00 00 00 00	 call	 __ftol2_sse
  000be	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  000c1	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 213  : 
; 214  : 				Token = GetToken();

  000c4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 215  : 				this->m_iOpenTime = (int)TokenNumber;

  000c9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000cf	e8 00 00 00 00	 call	 __ftol2_sse
  000d4	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 216  : 
; 217  : 				Token = GetToken();

  000d7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 218  : 				this->m_iPlaytime = (int)TokenNumber;

  000dc	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e2	e8 00 00 00 00	 call	 __ftol2_sse
  000e7	89 46 38	 mov	 DWORD PTR [esi+56], eax
  000ea	eb 87		 jmp	 SHORT $LL24@Load
$LN22@Load:

; 219  : 			}
; 220  : 			else if ( type == 1 )	// Normal Monster Settings

  000ec	83 fb 01	 cmp	 ebx, 1
  000ef	0f 85 9a 00 00
	00		 jne	 $LN19@Load

; 221  : 			{
; 222  : 				Token = GetToken();

  000f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 223  : 
; 224  : 				if ( strcmp("end", TokenString) == 0 )

  000fa	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  000ff	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL92@Load:
  00104	8a 10		 mov	 dl, BYTE PTR [eax]
  00106	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00108	75 1a		 jne	 SHORT $LN93@Load
  0010a	84 d2		 test	 dl, dl
  0010c	74 12		 je	 SHORT $LN94@Load
  0010e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00111	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00114	75 0e		 jne	 SHORT $LN93@Load
  00116	83 c0 02	 add	 eax, 2
  00119	83 c1 02	 add	 ecx, 2
  0011c	84 d2		 test	 dl, dl
  0011e	75 e4		 jne	 SHORT $LL92@Load
$LN94@Load:
  00120	33 c0		 xor	 eax, eax
  00122	eb 05		 jmp	 SHORT $LN95@Load
$LN93@Load:
  00124	1b c0		 sbb	 eax, eax
  00126	83 d8 ff	 sbb	 eax, -1
$LN95@Load:
  00129	85 c0		 test	 eax, eax
  0012b	0f 84 38 03 00
	00		 je	 $LN3@Load

; 225  : 				{
; 226  : 					break;
; 227  : 				}
; 228  : 
; 229  : 				number = (int)TokenNumber;	// Devils Square Index;

  00131	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00137	e8 00 00 00 00	 call	 __ftol2_sse
  0013c	8b f0		 mov	 esi, eax

; 230  : 
; 231  : 				Token = GetToken();

  0013e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 232  : 				monstertype = (int)TokenNumber;

  00143	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00149	e8 00 00 00 00	 call	 __ftol2_sse
  0014e	8b f8		 mov	 edi, eax

; 233  : 
; 234  : 				Token = GetToken();

  00150	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 235  : 				starttime = (int)TokenNumber;

  00155	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0015b	e8 00 00 00 00	 call	 __ftol2_sse
  00160	8b d8		 mov	 ebx, eax

; 236  : 
; 237  : 				Token = GetToken();

  00162	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 238  : 				endtime = (int)TokenNumber;
; 239  : 
; 240  : 				this->m_DevilSquareGround[number].Set(monstertype, starttime, endtime);

  00167	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0016d	e8 00 00 00 00	 call	 __ftol2_sse
  00172	69 f6 a8 04 00
	00		 imul	 esi, 1192		; 000004a8H
  00178	50		 push	 eax
  00179	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	53		 push	 ebx
  0017d	57		 push	 edi
  0017e	8d 4c 06 3c	 lea	 ecx, DWORD PTR [esi+eax+60]
  00182	e8 00 00 00 00	 call	 ?Set@CDevilSquareGround@@QAEXGHH@Z ; CDevilSquareGround::Set
  00187	8b 5d f8	 mov	 ebx, DWORD PTR _type$[ebp]
  0018a	e9 e4 fe ff ff	 jmp	 $LL24@Load
$LN19@Load:

; 241  : 			}
; 242  : 			else if ( type == 2 )	// Boss Monster Set

  0018f	83 fb 02	 cmp	 ebx, 2
  00192	0f 85 df 00 00
	00		 jne	 $LN16@Load

; 243  : 			{
; 244  : 				Token = GetToken();

  00198	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 245  : 
; 246  : 				if ( strcmp("end", TokenString) == 0 )

  0019d	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  001a2	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL96@Load:
  001a7	8a 10		 mov	 dl, BYTE PTR [eax]
  001a9	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001ab	75 1a		 jne	 SHORT $LN97@Load
  001ad	84 d2		 test	 dl, dl
  001af	74 12		 je	 SHORT $LN98@Load
  001b1	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001b4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001b7	75 0e		 jne	 SHORT $LN97@Load
  001b9	83 c0 02	 add	 eax, 2
  001bc	83 c1 02	 add	 ecx, 2
  001bf	84 d2		 test	 dl, dl
  001c1	75 e4		 jne	 SHORT $LL96@Load
$LN98@Load:
  001c3	33 c0		 xor	 eax, eax
  001c5	eb 05		 jmp	 SHORT $LN99@Load
$LN97@Load:
  001c7	1b c0		 sbb	 eax, eax
  001c9	83 d8 ff	 sbb	 eax, -1
$LN99@Load:
  001cc	85 c0		 test	 eax, eax
  001ce	0f 84 95 02 00
	00		 je	 $LN3@Load

; 247  : 				{
; 248  : 					break;
; 249  : 				}
; 250  : 
; 251  : 				number = (int)TokenNumber;	// Devils Square Index;

  001d4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001da	e8 00 00 00 00	 call	 __ftol2_sse
  001df	8b f0		 mov	 esi, eax

; 252  : 
; 253  : 				Token = GetToken();

  001e1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 254  : 				monstertype = (int)TokenNumber;

  001e6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ec	e8 00 00 00 00	 call	 __ftol2_sse
  001f1	8b f8		 mov	 edi, eax

; 255  : 
; 256  : 				Token = GetToken();

  001f3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 257  : 				starttime = (int)TokenNumber;

  001f8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001fe	e8 00 00 00 00	 call	 __ftol2_sse
  00203	8b d8		 mov	 ebx, eax

; 258  : 
; 259  : 				Token = GetToken();

  00205	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 260  : 				x = (int)TokenNumber;

  0020a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00210	e8 00 00 00 00	 call	 __ftol2_sse
  00215	89 45 ec	 mov	 DWORD PTR _x$[ebp], eax

; 261  : 
; 262  : 				Token = GetToken();

  00218	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 263  : 				y = (int)TokenNumber;

  0021d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00223	e8 00 00 00 00	 call	 __ftol2_sse
  00228	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax

; 264  : 
; 265  : 				Token = GetToken();

  0022b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 266  : 				tx = (int)TokenNumber;

  00230	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00236	e8 00 00 00 00	 call	 __ftol2_sse
  0023b	89 45 f4	 mov	 DWORD PTR _tx$[ebp], eax

; 267  : 
; 268  : 				Token = GetToken();

  0023e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 269  : 				ty = (int)TokenNumber;
; 270  : 
; 271  : 				this->m_DevilSquareGround[number].SetBoss(monstertype, starttime, x, y, tx, ty);

  00243	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00249	e8 00 00 00 00	 call	 __ftol2_sse
  0024e	69 f6 a8 04 00
	00		 imul	 esi, 1192		; 000004a8H
  00254	8b 4d f4	 mov	 ecx, DWORD PTR _tx$[ebp]
  00257	8b 55 f0	 mov	 edx, DWORD PTR _y$[ebp]
  0025a	50		 push	 eax
  0025b	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  0025e	51		 push	 ecx
  0025f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00262	52		 push	 edx
  00263	50		 push	 eax
  00264	53		 push	 ebx
  00265	57		 push	 edi
  00266	8d 4c 0e 3c	 lea	 ecx, DWORD PTR [esi+ecx+60]
  0026a	e8 00 00 00 00	 call	 ?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z ; CDevilSquareGround::SetBoss
  0026f	8b 5d f8	 mov	 ebx, DWORD PTR _type$[ebp]
  00272	e9 fc fd ff ff	 jmp	 $LL24@Load
$LN16@Load:

; 272  : 			}
; 273  : 			else if ( type == 3 ) // Bonus Sttings

  00277	83 fb 03	 cmp	 ebx, 3
  0027a	0f 85 9b 00 00
	00		 jne	 $LN13@Load

; 274  : 			{
; 275  : 				Token = GetToken();

  00280	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 276  : 
; 277  : 				if ( strcmp("end", TokenString) == 0 )

  00285	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0028a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0028f	90		 npad	 1
$LL100@Load:
  00290	8a 10		 mov	 dl, BYTE PTR [eax]
  00292	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00294	75 1a		 jne	 SHORT $LN101@Load
  00296	84 d2		 test	 dl, dl
  00298	74 12		 je	 SHORT $LN102@Load
  0029a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0029d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002a0	75 0e		 jne	 SHORT $LN101@Load
  002a2	83 c0 02	 add	 eax, 2
  002a5	83 c1 02	 add	 ecx, 2
  002a8	84 d2		 test	 dl, dl
  002aa	75 e4		 jne	 SHORT $LL100@Load
$LN102@Load:
  002ac	33 c0		 xor	 eax, eax
  002ae	eb 05		 jmp	 SHORT $LN103@Load
$LN101@Load:
  002b0	1b c0		 sbb	 eax, eax
  002b2	83 d8 ff	 sbb	 eax, -1
$LN103@Load:
  002b5	85 c0		 test	 eax, eax
  002b7	0f 84 ac 01 00
	00		 je	 $LN3@Load

; 278  : 				{
; 279  : 					break;
; 280  : 				}
; 281  : 
; 282  : 				int index; //loc13
; 283  : 				int rank; //loc14
; 284  : 				int zen; //loc15
; 285  : 				int exp; //1oc16
; 286  : 
; 287  : 				index = (int)TokenNumber;

  002bd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002c3	e8 00 00 00 00	 call	 __ftol2_sse
  002c8	8b f0		 mov	 esi, eax

; 288  : 
; 289  : 				Token = GetToken();

  002ca	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 290  : 				rank = (int)TokenNumber;

  002cf	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002d5	e8 00 00 00 00	 call	 __ftol2_sse
  002da	8b f8		 mov	 edi, eax

; 291  : 
; 292  : 				Token = GetToken();

  002dc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 293  : 				exp = (int)TokenNumber;

  002e1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002e7	e8 00 00 00 00	 call	 __ftol2_sse
  002ec	8b d8		 mov	 ebx, eax

; 294  : 
; 295  : 				Token = GetToken();

  002ee	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 296  : 				zen = (int)TokenNumber;
; 297  : 
; 298  : 				this->m_DevilSquareGround[index].SetBonus(rank, exp, zen);

  002f3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002f9	e8 00 00 00 00	 call	 __ftol2_sse
  002fe	69 f6 a8 04 00
	00		 imul	 esi, 1192		; 000004a8H
  00304	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00307	50		 push	 eax
  00308	53		 push	 ebx
  00309	57		 push	 edi
  0030a	8d 4c 16 3c	 lea	 ecx, DWORD PTR [esi+edx+60]
  0030e	e8 00 00 00 00	 call	 ?SetBonus@CDevilSquareGround@@QAEXHHH@Z ; CDevilSquareGround::SetBonus
  00313	8b 5d f8	 mov	 ebx, DWORD PTR _type$[ebp]
  00316	e9 58 fd ff ff	 jmp	 $LL24@Load
$LN13@Load:

; 299  : 			}
; 300  : 			//season 2.5 add-on
; 301  : 			else if ( type == 4 ) // Timer Settings (webzen stupid??) -> Identical

  0031b	83 fb 04	 cmp	 ebx, 4
  0031e	0f 85 98 00 00
	00		 jne	 $LN10@Load

; 302  : 			{
; 303  : 				Token = GetToken();

  00324	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 304  : 
; 305  : 				if ( strcmp("end", TokenString) == 0 )

  00329	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0032e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL104@Load:
  00333	8a 10		 mov	 dl, BYTE PTR [eax]
  00335	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00337	75 1a		 jne	 SHORT $LN105@Load
  00339	84 d2		 test	 dl, dl
  0033b	74 12		 je	 SHORT $LN106@Load
  0033d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00340	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00343	75 0e		 jne	 SHORT $LN105@Load
  00345	83 c0 02	 add	 eax, 2
  00348	83 c1 02	 add	 ecx, 2
  0034b	84 d2		 test	 dl, dl
  0034d	75 e4		 jne	 SHORT $LL104@Load
$LN106@Load:
  0034f	33 c0		 xor	 eax, eax
  00351	eb 05		 jmp	 SHORT $LN107@Load
$LN105@Load:
  00353	1b c0		 sbb	 eax, eax
  00355	83 d8 ff	 sbb	 eax, -1
$LN107@Load:
  00358	85 c0		 test	 eax, eax
  0035a	0f 84 09 01 00
	00		 je	 $LN3@Load

; 306  : 				{
; 307  : 					break;
; 308  : 				}
; 309  : 
; 310  : 				DEVILSQUARE_START_TIME Schedule;
; 311  : 
; 312  : 				Schedule.m_iHour = (int)TokenNumber;

  00360	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00366	e8 00 00 00 00	 call	 __ftol2_sse
  0036b	89 45 e4	 mov	 DWORD PTR _Schedule$222148[ebp], eax

; 313  : 
; 314  : 				Token = GetToken();

  0036e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 315  : 				Schedule.m_iMinute = (int)TokenNumber;

  00373	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00379	e8 00 00 00 00	 call	 __ftol2_sse

; 316  : 
; 317  : 				this->m_listDevilSquareOpenTime.push_back(Schedule);

  0037e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00381	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  00384	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00387	89 45 e8	 mov	 DWORD PTR _Schedule$222148[ebp+4], eax
  0038a	8d 45 e4	 lea	 eax, DWORD PTR _Schedule$222148[ebp]
  0038d	50		 push	 eax
  0038e	51		 push	 ecx
  0038f	57		 push	 edi
  00390	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00393	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UDEVILSQUARE_START_TIME@@V?$allocator@UDEVILSQUARE_START_TIME@@@std@@@2@PAU342@0ABUDEVILSQUARE_START_TIME@@@Z ; std::_List_val<DEVILSQUARE_START_TIME,std::allocator<DEVILSQUARE_START_TIME> >::_Buynode
  00398	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0039b	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  003a0	2b d1		 sub	 edx, ecx
  003a2	83 fa 01	 cmp	 edx, 1
  003a5	0f 82 f3 00 00
	00		 jb	 $LN83@Load
  003ab	41		 inc	 ecx
  003ac	89 4e 28	 mov	 DWORD PTR [esi+40], ecx
  003af	89 47 04	 mov	 DWORD PTR [edi+4], eax
  003b2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003b5	89 01		 mov	 DWORD PTR [ecx], eax
  003b7	e9 b7 fc ff ff	 jmp	 $LL24@Load
$LN10@Load:

; 318  : 			}
; 319  : 			//season4.5 add-on
; 320  : 			else if ( type == 5 )

  003bc	83 fb 05	 cmp	 ebx, 5
  003bf	0f 85 ae fc ff
	ff		 jne	 $LL24@Load

; 321  : 			{
; 322  : 				Token = GetToken();

  003c5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 323  : 
; 324  : 				if (strcmp("end", TokenString) == 0)

  003ca	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  003cf	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL108@Load:
  003d4	8a 10		 mov	 dl, BYTE PTR [eax]
  003d6	3a 11		 cmp	 dl, BYTE PTR [ecx]
  003d8	75 1a		 jne	 SHORT $LN109@Load
  003da	84 d2		 test	 dl, dl
  003dc	74 12		 je	 SHORT $LN110@Load
  003de	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  003e1	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  003e4	75 0e		 jne	 SHORT $LN109@Load
  003e6	83 c0 02	 add	 eax, 2
  003e9	83 c1 02	 add	 ecx, 2
  003ec	84 d2		 test	 dl, dl
  003ee	75 e4		 jne	 SHORT $LL108@Load
$LN110@Load:
  003f0	33 c0		 xor	 eax, eax
  003f2	eb 05		 jmp	 SHORT $LN111@Load
$LN109@Load:
  003f4	1b c0		 sbb	 eax, eax
  003f6	83 d8 ff	 sbb	 eax, -1
$LN111@Load:
  003f9	85 c0		 test	 eax, eax
  003fb	74 41		 je	 SHORT $LN84@Load

; 329  : 					}
; 330  : 
; 331  : 					break;
; 332  : 				}
; 333  : 
; 334  : 				int iLevel = (int)TokenNumber;

  003fd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00403	e8 00 00 00 00	 call	 __ftol2_sse
  00408	8b f0		 mov	 esi, eax

; 335  : 
; 336  : 				if ( DS_LEVEL_RANGE(iLevel) != FALSE )

  0040a	85 f6		 test	 esi, esi
  0040c	78 26		 js	 SHORT $LN2@Load
  0040e	33 c0		 xor	 eax, eax
  00410	83 fe 06	 cmp	 esi, 6
  00413	0f 9e c0	 setle	 al
  00416	85 c0		 test	 eax, eax
  00418	74 1a		 je	 SHORT $LN2@Load

; 337  : 				{
; 338  : 					Token = GetToken();

  0041a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 339  : 					this->m_BonusScoreTable[CLASS_SUMMONER][iLevel] = (int&)TokenNumber;

  0041f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _TokenNumber
  00425	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00428	89 94 b0 60 21
	00 00		 mov	 DWORD PTR [eax+esi*4+8544], edx

; 340  : 				}
; 341  : 				else

  0042f	e9 3f fc ff ff	 jmp	 $LL24@Load
$LN2@Load:

; 342  : 				{
; 343  : 					Token = GetToken();

  00434	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 344  : 				}
; 345  : 			}
; 346  : 		}

  00439	e9 35 fc ff ff	 jmp	 $LL24@Load
$LN84@Load:

; 325  : 				{
; 326  : 					for( int i = 0; i < MAX_DEVILSQUARE_GROUND; i++) //clear

  0043e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00441	8d 7e 3c	 lea	 edi, DWORD PTR [esi+60]
  00444	81 c6 60 21 00
	00		 add	 esi, 8544		; 00002160H
  0044a	bb 07 00 00 00	 mov	 ebx, 7
  0044f	90		 npad	 1
$LL5@Load:

; 327  : 					{
; 328  : 						this->m_DevilSquareGround[i].IncExp((float&)this->m_BonusScoreTable[CLASS_SUMMONER][i]);

  00450	d9 06		 fld	 DWORD PTR [esi]
  00452	51		 push	 ecx
  00453	8b cf		 mov	 ecx, edi
  00455	d9 1c 24	 fstp	 DWORD PTR [esp]
  00458	e8 00 00 00 00	 call	 ?IncExp@CDevilSquareGround@@QAEXM@Z ; CDevilSquareGround::IncExp
  0045d	83 c6 04	 add	 esi, 4
  00460	81 c7 a8 04 00
	00		 add	 edi, 1192		; 000004a8H
  00466	4b		 dec	 ebx
  00467	75 e7		 jne	 SHORT $LL5@Load
$LN3@Load:

; 187  : 		return;
; 188  : 	}
; 189  : 
; 190  : 	while ( true )
; 191  : 	{
; 192  : 		Token = GetToken();

  00469	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 193  : 
; 194  : 		if ( Token == 2 )

  0046e	83 f8 02	 cmp	 eax, 2
  00471	0f 85 ec fb ff
	ff		 jne	 $LL27@Load
  00477	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0047a	5b		 pop	 ebx
$LN85@Load:

; 347  : 	}
; 348  : 
; 349  : 	fclose (SMDFile );

  0047b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00481	51		 push	 ecx
  00482	e8 00 00 00 00	 call	 _fclose

; 350  : 
; 351  : 	LogAdd("%s file load!", filename);

  00487	56		 push	 esi
  00488	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  0048d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00493	83 c4 0c	 add	 esp, 12			; 0000000cH
  00496	5f		 pop	 edi
  00497	5e		 pop	 esi

; 352  : }

  00498	8b e5		 mov	 esp, ebp
  0049a	5d		 pop	 ebp
  0049b	c2 04 00	 ret	 4
$LN83@Load:

; 316  : 
; 317  : 				this->m_listDevilSquareOpenTime.push_back(Schedule);

  0049e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  004a3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN113@Load:
$LN112@Load:
  004a8	cc		 int	 3
?Load@CDevilSquare@@QAEXPAD@Z ENDP			; CDevilSquare::Load
_TEXT	ENDS
PUBLIC	??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close?$AA@ ; `string'
PUBLIC	?SetClose@CDevilSquare@@QAEXXZ			; CDevilSquare::SetClose
EXTRN	?Clear@CDevilSquareGround@@QAEXXZ:PROC		; CDevilSquareGround::Clear
;	COMDAT ??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close?$AA@
CONST	SEGMENT
??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close?$AA@ DB '[DevilSquare] Clos'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetClose@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
?SetClose@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::SetClose, COMDAT
; _this$ = ecx

; 368  : 	if ( LogAdd != NULL )

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?LogAdd@@3P6AXPADZZA, 0 ; LogAdd
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 0e		 je	 SHORT $LN6@SetClose

; 369  : 	{
; 370  : 		LogAddTD("[DevilSquare] Close");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close?$AA@
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00018	83 c4 04	 add	 esp, 4
$LN6@SetClose:

; 371  : 	}
; 372  : 
; 373  : 	this->ClearMonstr();

  0001b	53		 push	 ebx
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?ClearMonstr@CDevilSquare@@QAEXXZ ; CDevilSquare::ClearMonstr

; 374  : 	this->CalcScore();

  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?CalcScore@CDevilSquare@@QAEXXZ ; CDevilSquare::CalcScore
  0002a	8d 7e 3c	 lea	 edi, DWORD PTR [esi+60]
  0002d	bb 07 00 00 00	 mov	 ebx, 7
$LL5@SetClose:

; 375  : 
; 376  : 	for ( int i=0;i<MAX_DEVILSQUARE_GROUND;i++)
; 377  : 	{
; 378  : 		this->m_DevilSquareGround[i].Clear();

  00032	8b cf		 mov	 ecx, edi
  00034	e8 00 00 00 00	 call	 ?Clear@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::Clear
  00039	81 c7 a8 04 00
	00		 add	 edi, 1192		; 000004a8H
  0003f	4b		 dec	 ebx
  00040	75 f0		 jne	 SHORT $LL5@SetClose

; 379  : 	}
; 380  : 
; 381  : 	this->m_iRemainTime = this->m_iCloseTime;

  00042	8b 46 30	 mov	 eax, DWORD PTR [esi+48]

; 382  : 	this->CheckSync();

  00045	8b ce		 mov	 ecx, esi
  00047	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0004a	e8 00 00 00 00	 call	 ?CheckSync@CDevilSquare@@AAEXXZ ; CDevilSquare::CheckSync

; 383  : 	this->m_bFlag = 0;

  0004f	33 ff		 xor	 edi, edi

; 384  : 
; 385  : 	if ( this->m_iRemainTime <= 1 )

  00051	83 7e 0c 01	 cmp	 DWORD PTR [esi+12], 1
  00055	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00058	5b		 pop	 ebx
  00059	7f 16		 jg	 SHORT $LN2@SetClose

; 386  : 	{
; 387  : 		this->m_iTime = GetTickCount();

  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 393  : 		this->m_iremainTimeSec = -1;
; 394  : 	}
; 395  : 	
; 396  : 	this->m_bSendTimeCount = FALSE;

  00061	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00064	5f		 pop	 edi
  00065	c7 46 10 3c 00
	00 00		 mov	 DWORD PTR [esi+16], 60	; 0000003cH
  0006c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006f	5e		 pop	 esi

; 397  : }

  00070	c3		 ret	 0
$LN2@SetClose:

; 388  : 		this->m_iremainTimeSec = 60;
; 389  : 	}
; 390  : 	else
; 391  : 	{
; 392  : 		this->m_iTime = GetTickCount() + 60000;

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 393  : 		this->m_iremainTimeSec = -1;
; 394  : 	}
; 395  : 	
; 396  : 	this->m_bSendTimeCount = FALSE;

  00077	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  0007a	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  0007f	5f		 pop	 edi
  00080	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
  00087	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0008a	5e		 pop	 esi

; 397  : }

  0008b	c3		 ret	 0
?SetClose@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::SetClose
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCDevilSquare@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDevilSquare@@UAEPAXI@Z PROC			; CDevilSquare::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDevilSquare@@UAE@XZ	; CDevilSquare::~CDevilSquare
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCDevilSquare@@UAEPAXI@Z ENDP			; CDevilSquare::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
; Function compile flags: /Ogtp
;	COMDAT ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z
_TEXT	SEGMENT
_eState$ = 8						; size = 4
?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z PROC ; CDevilSquare::SetState, COMDAT
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 	this->m_eState = eState;

  00003	8b 45 08	 mov	 eax, DWORD PTR _eState$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 357  : 
; 358  : 	switch ( this->m_eState )

  00009	83 e8 00	 sub	 eax, 0
  0000c	74 18		 je	 SHORT $LN3@SetState
  0000e	48		 dec	 eax
  0000f	74 0c		 je	 SHORT $LN2@SetState
  00011	48		 dec	 eax
  00012	75 17		 jne	 SHORT $LN4@SetState

; 362  : 		case DevilSquare_PLAYING:	this->SetPlaying();	break;

  00014	e8 00 00 00 00	 call	 ?SetPlaying@CDevilSquare@@AAEXXZ ; CDevilSquare::SetPlaying

; 363  : 	}
; 364  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN2@SetState:

; 361  : 		case DevilSquare_OPEN:		this->SetOpen();	break;

  0001d	e8 00 00 00 00	 call	 ?SetOpen@CDevilSquare@@AAEXXZ ; CDevilSquare::SetOpen

; 363  : 	}
; 364  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@SetState:

; 359  : 	{
; 360  : 		case DevilSquare_CLOSE:	this->SetClose();	break;

  00026	e8 00 00 00 00	 call	 ?SetClose@CDevilSquare@@QAEXXZ ; CDevilSquare::SetClose
$LN4@SetState:

; 363  : 	}
; 364  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ENDP ; CDevilSquare::SetState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ProcClose@CDevilSquare@@AAEXXZ			; CDevilSquare::ProcClose
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?ProcClose@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_pMsg$222502 = -284					; size = 4
_i$222553 = -280					; size = 4
_i$222531 = -280					; size = 4
_i$222504 = -280					; size = 4
_pNotice$222551 = -276					; size = 272
_pNotice$222529 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
?ProcClose@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ProcClose, COMDAT
; _this$ = ecx

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b d9		 mov	 ebx, ecx

; 730  : 	if ( this->m_iremainTimeSec != -1 )

  00017	83 ce ff	 or	 esi, -1
  0001a	57		 push	 edi
  0001b	39 73 10	 cmp	 DWORD PTR [ebx+16], esi
  0001e	0f 84 d9 01 00
	00		 je	 $LN35@ProcClose

; 731  : 	{
; 732  : 		int lc2 = (GetTickCount() - this->m_iTime)/1000;

  00024	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002d	8b c8		 mov	 ecx, eax
  0002f	2b ce		 sub	 ecx, esi
  00031	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00036	f7 e1		 mul	 ecx
  00038	c1 ea 06	 shr	 edx, 6

; 733  : 
; 734  : 		if ( lc2 != 0 )

  0003b	85 d2		 test	 edx, edx
  0003d	0f 84 4f 03 00
	00		 je	 $LN1@ProcClose

; 735  : 		{
; 736  : 			this->m_iremainTimeSec -= lc2;

  00043	29 53 10	 sub	 DWORD PTR [ebx+16], edx

; 737  : 			this->m_iTime += lc2 * 1000;

  00046	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0004c	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0004f	03 d6		 add	 edx, esi
  00051	89 53 08	 mov	 DWORD PTR [ebx+8], edx

; 738  : 
; 739  : 			if ( this->m_iremainTimeSec <= 30 && this->m_bSendTimeCount == FALSE )

  00054	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00057	0f 8f bd 00 00
	00		 jg	 $LN80@ProcClose
  0005d	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  00061	0f 85 b3 00 00
	00		 jne	 $LN80@ProcClose

; 740  : 			{
; 741  : 				PMSG_SET_DEVILSQUARE pMsg;
; 742  : 
; 743  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00067	6a 04		 push	 4
  00069	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$222502[ebp]
  0006f	68 92 00 00 00	 push	 146			; 00000092H
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0007a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 744  : 				pMsg.Type = DevilSquare_CLOSE;

  00083	c6 85 e7 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$222502[ebp+3], 0

; 745  : 
; 746  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0008a	c7 85 e8 fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$222504[ebp], 14000 ; 000036b0H
  00094	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL32@ProcClose:

; 747  : 				{
; 748  : 					if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  000a0	83 7c 3e 04 03	 cmp	 DWORD PTR [esi+edi+4], 3
  000a5	75 58		 jne	 SHORT $LN31@ProcClose
  000a7	66 83 7c 3e 68
	01		 cmp	 WORD PTR [esi+edi+104], 1
  000ad	75 50		 jne	 SHORT $LN31@ProcClose

; 749  : 					{
; 750  : 						if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  000af	8a 84 3e 49 01
	00 00		 mov	 al, BYTE PTR [esi+edi+329]
  000b6	3c 34		 cmp	 al, 52			; 00000034H
  000b8	74 45		 je	 SHORT $LN31@ProcClose
  000ba	3c 0b		 cmp	 al, 11			; 0000000bH
  000bc	72 0c		 jb	 SHORT $LN85@ProcClose
  000be	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  000c3	3a c8		 cmp	 cl, al
  000c5	1b c9		 sbb	 ecx, ecx
  000c7	41		 inc	 ecx
  000c8	75 35		 jne	 SHORT $LN31@ProcClose
$LN85@ProcClose:

; 751  : 						{
; 752  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  000ca	3c 35		 cmp	 al, 53			; 00000035H
  000cc	74 31		 je	 SHORT $LN31@ProcClose
  000ce	3c 12		 cmp	 al, 18			; 00000012H
  000d0	72 09		 jb	 SHORT $LN73@ProcClose
  000d2	b2 17		 mov	 dl, 23			; 00000017H
  000d4	3a d0		 cmp	 dl, al
  000d6	1b c0		 sbb	 eax, eax
  000d8	40		 inc	 eax
  000d9	75 24		 jne	 SHORT $LN31@ProcClose
$LN73@ProcClose:

; 753  : 							{
; 754  : 								DataSend(i, (LPBYTE)&pMsg, pMsg.h.size);

  000db	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$222502[ebp+1]
  000e2	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _i$222504[ebp]
  000e8	50		 push	 eax
  000e9	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$222502[ebp]
  000ef	51		 push	 ecx
  000f0	52		 push	 edx
  000f1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@ProcClose:

; 745  : 
; 746  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  000ff	ff 85 e8 fe ff
	ff		 inc	 DWORD PTR _i$222504[ebp]
  00105	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0010b	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00111	7c 8d		 jl	 SHORT $LL32@ProcClose

; 755  : 							}
; 756  : 						}
; 757  : 					}
; 758  : 				}
; 759  : 
; 760  : 				this->m_bSendTimeCount = TRUE;

  00113	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [ebx+20], 1
$LN80@ProcClose:

; 761  : 			}		
; 762  : 
; 763  : 			if (this->m_iremainTimeSec < 1 )

  0011a	83 7b 10 01	 cmp	 DWORD PTR [ebx+16], 1
  0011e	0f 8d 6e 02 00
	00		 jge	 $LN1@ProcClose

; 764  : 			{
; 765  : 				PMSG_NOTICE pNotice;
; 766  : 
; 767  : 				TNotice::MakeNoticeMsg((TNotice *)&pNotice, 0, lMsg.Get(MSGGET(2, 191)));

  00124	68 bf 02 00 00	 push	 703			; 000002bfH
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0012e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00133	50		 push	 eax
  00134	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$222529[ebp]
  0013a	6a 00		 push	 0
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00142	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 768  : 
; 769  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0014b	c7 85 e8 fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$222531[ebp], 14000 ; 000036b0H
  00155	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  0015a	8d 9b 00 00 00
	00		 npad	 6
$LL25@ProcClose:

; 770  : 				{
; 771  : 					if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00160	83 7c 3e 04 03	 cmp	 DWORD PTR [esi+edi+4], 3
  00165	75 58		 jne	 SHORT $LN24@ProcClose
  00167	66 83 7c 3e 68
	01		 cmp	 WORD PTR [esi+edi+104], 1
  0016d	75 50		 jne	 SHORT $LN24@ProcClose

; 772  : 					{
; 773  : 						if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  0016f	8a 84 3e 49 01
	00 00		 mov	 al, BYTE PTR [esi+edi+329]
  00176	3c 34		 cmp	 al, 52			; 00000034H
  00178	74 45		 je	 SHORT $LN24@ProcClose
  0017a	3c 0b		 cmp	 al, 11			; 0000000bH
  0017c	72 0c		 jb	 SHORT $LN83@ProcClose
  0017e	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00183	3a c8		 cmp	 cl, al
  00185	1b c9		 sbb	 ecx, ecx
  00187	41		 inc	 ecx
  00188	75 35		 jne	 SHORT $LN24@ProcClose
$LN83@ProcClose:

; 774  : 						{
; 775  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  0018a	3c 35		 cmp	 al, 53			; 00000035H
  0018c	74 31		 je	 SHORT $LN24@ProcClose
  0018e	3c 12		 cmp	 al, 18			; 00000012H
  00190	72 09		 jb	 SHORT $LN75@ProcClose
  00192	b2 17		 mov	 dl, 23			; 00000017H
  00194	3a d0		 cmp	 dl, al
  00196	1b c0		 sbb	 eax, eax
  00198	40		 inc	 eax
  00199	75 24		 jne	 SHORT $LN24@ProcClose
$LN75@ProcClose:

; 776  : 							{
; 777  : 								DataSend(i, (LPBYTE)&pNotice, pNotice.h.size);

  0019b	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$222529[ebp+1]
  001a2	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _i$222531[ebp]
  001a8	50		 push	 eax
  001a9	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$222529[ebp]
  001af	51		 push	 ecx
  001b0	52		 push	 edx
  001b1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001b6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@ProcClose:

; 768  : 
; 769  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  001bf	ff 85 e8 fe ff
	ff		 inc	 DWORD PTR _i$222531[ebp]
  001c5	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  001cb	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  001d1	7c 8d		 jl	 SHORT $LL25@ProcClose

; 778  : 							}
; 779  : 						}
; 780  : 					}
; 781  : 				}
; 782  : 
; 783  : 				LogAddTD(pNotice.Notice);

  001d3	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$222529[ebp+13]
  001d9	50		 push	 eax
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e0	83 c4 04	 add	 esp, 4

; 784  : 				this->SetState(DevilSquare_OPEN);

  001e3	6a 01		 push	 1
  001e5	8b cb		 mov	 ecx, ebx
  001e7	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx

; 848  : 		}
; 849  : 	}
; 850  : }

  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
$LN35@ProcClose:

; 785  : 			}
; 786  : 		
; 787  : 		}
; 788  : 	}
; 789  : 	else if ( this->m_iTime < GetTickCount() )

  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00203	39 43 08	 cmp	 DWORD PTR [ebx+8], eax
  00206	0f 83 86 01 00
	00		 jae	 $LN1@ProcClose

; 790  : 	{
; 791  : 		this->ClearMonstr();

  0020c	8b cb		 mov	 ecx, ebx
  0020e	e8 00 00 00 00	 call	 ?ClearMonstr@CDevilSquare@@QAEXXZ ; CDevilSquare::ClearMonstr

; 792  : 		this->m_iRemainTime--;

  00213	01 73 0c	 add	 DWORD PTR [ebx+12], esi

; 793  : 
; 794  : 		if ( this->m_bFlag == 0 )

  00216	83 7b 1c 00	 cmp	 DWORD PTR [ebx+28], 0
  0021a	75 5c		 jne	 SHORT $LN17@ProcClose

; 795  : 		{
; 796  : 			for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00222	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00227	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  0022c	8d 64 24 00	 npad	 4
$LL16@ProcClose:

; 797  : 			{
; 798  : 				if ( gObj[i].Connected == PLAYER_PLAYING )

  00230	83 7c 0e 04 03	 cmp	 DWORD PTR [esi+ecx+4], 3
  00235	75 29		 jne	 SHORT $LN15@ProcClose

; 799  : 				{
; 800  : 					if ( DS_MAP_RANGE(gObj[i].MapNumber) != FALSE )

  00237	8a 84 0e 49 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+329]
  0023e	3c 09		 cmp	 al, 9
  00240	74 0d		 je	 SHORT $LN76@ProcClose
  00242	33 d2		 xor	 edx, edx
  00244	3c 20		 cmp	 al, 32			; 00000020H
  00246	0f 94 c2	 sete	 dl
  00249	8b c2		 mov	 eax, edx
  0024b	85 c0		 test	 eax, eax
  0024d	74 11		 je	 SHORT $LN15@ProcClose
$LN76@ProcClose:

; 801  : 					{
; 802  : 						gObjMoveGate(i, 27);

  0024f	6a 1b		 push	 27			; 0000001bH
  00251	57		 push	 edi
  00252	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00257	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025d	83 c4 08	 add	 esp, 8
$LN15@ProcClose:

; 795  : 		{
; 796  : 			for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00260	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00266	47		 inc	 edi
  00267	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  0026d	7c c1		 jl	 SHORT $LL16@ProcClose

; 803  : 					}
; 804  : 				}
; 805  : 			}
; 806  : 
; 807  : 			this->ItemClear();

  0026f	8b cb		 mov	 ecx, ebx
  00271	e8 00 00 00 00	 call	 ?ItemClear@CDevilSquare@@AAEXXZ ; CDevilSquare::ItemClear

; 808  : 		}
; 809  : 		else

  00276	eb 07		 jmp	 SHORT $LN11@ProcClose
$LN17@ProcClose:

; 810  : 		{
; 811  : 			this->CheckInvalidUser();

  00278	8b cb		 mov	 ecx, ebx
  0027a	e8 00 00 00 00	 call	 ?CheckInvalidUser@CDevilSquare@@AAEXXZ ; CDevilSquare::CheckInvalidUser
$LN11@ProcClose:

; 812  : 		}
; 813  : 
; 814  : 		if ( this->m_iRemainTime <= 15 )

  0027f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00282	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00285	0f 8f cc 00 00
	00		 jg	 $LN9@ProcClose

; 815  : 		{
; 816  : 			if ( (this->m_iRemainTime%5)== 0 )

  0028b	8b c1		 mov	 eax, ecx
  0028d	99		 cdq
  0028e	be 05 00 00 00	 mov	 esi, 5
  00293	f7 fe		 idiv	 esi
  00295	85 d2		 test	 edx, edx
  00297	0f 85 ba 00 00
	00		 jne	 $LN9@ProcClose

; 817  : 			{
; 818  : 				PMSG_NOTICE pNotice;
; 819  : 
; 820  : 				TNotice::MakeNoticeMsgEx((TNotice *)&pNotice, 0, lMsg.Get(MSGGET(2, 192)), this->m_iRemainTime);

  0029d	51		 push	 ecx
  0029e	68 c0 02 00 00	 push	 704			; 000002c0H
  002a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002a8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002ad	50		 push	 eax
  002ae	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$222551[ebp]
  002b4	6a 00		 push	 0
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  002bc	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c2	83 c4 10	 add	 esp, 16			; 00000010H

; 821  : 
; 822  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  002c5	c7 85 e8 fe ff
	ff b0 36 00 00	 mov	 DWORD PTR _i$222553[ebp], 14000 ; 000036b0H
  002cf	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL8@ProcClose:

; 823  : 				{
; 824  : 					if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  002d4	83 7c 3e 04 03	 cmp	 DWORD PTR [esi+edi+4], 3
  002d9	75 58		 jne	 SHORT $LN7@ProcClose
  002db	66 83 7c 3e 68
	01		 cmp	 WORD PTR [esi+edi+104], 1
  002e1	75 50		 jne	 SHORT $LN7@ProcClose

; 825  : 					{
; 826  : 						if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  002e3	8a 84 3e 49 01
	00 00		 mov	 al, BYTE PTR [esi+edi+329]
  002ea	3c 34		 cmp	 al, 52			; 00000034H
  002ec	74 45		 je	 SHORT $LN7@ProcClose
  002ee	3c 0b		 cmp	 al, 11			; 0000000bH
  002f0	72 0c		 jb	 SHORT $LN82@ProcClose
  002f2	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  002f7	3a c8		 cmp	 cl, al
  002f9	1b c9		 sbb	 ecx, ecx
  002fb	41		 inc	 ecx
  002fc	75 35		 jne	 SHORT $LN7@ProcClose
$LN82@ProcClose:

; 827  : 						{
; 828  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  002fe	3c 35		 cmp	 al, 53			; 00000035H
  00300	74 31		 je	 SHORT $LN7@ProcClose
  00302	3c 12		 cmp	 al, 18			; 00000012H
  00304	72 09		 jb	 SHORT $LN78@ProcClose
  00306	b2 17		 mov	 dl, 23			; 00000017H
  00308	3a d0		 cmp	 dl, al
  0030a	1b c0		 sbb	 eax, eax
  0030c	40		 inc	 eax
  0030d	75 24		 jne	 SHORT $LN7@ProcClose
$LN78@ProcClose:

; 829  : 							{
; 830  : 								DataSend(i, (LPBYTE)&pNotice, pNotice.h.size);

  0030f	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$222551[ebp+1]
  00316	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _i$222553[ebp]
  0031c	50		 push	 eax
  0031d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$222551[ebp]
  00323	51		 push	 ecx
  00324	52		 push	 edx
  00325	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0032a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00330	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@ProcClose:

; 821  : 
; 822  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  00333	ff 85 e8 fe ff
	ff		 inc	 DWORD PTR _i$222553[ebp]
  00339	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0033f	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00345	7c 8d		 jl	 SHORT $LL8@ProcClose

; 831  : 							}
; 832  : 						}
; 833  : 					}
; 834  : 				}
; 835  : 
; 836  : 				LogAddTD((char*)pNotice.Notice);

  00347	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$222551[ebp+13]
  0034d	50		 push	 eax
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00354	83 c4 04	 add	 esp, 4
$LN9@ProcClose:

; 837  : 			}
; 838  : 		}
; 839  : 
; 840  : 		if ( this->m_iRemainTime == 1 && this->m_iremainTimeSec == -1 )

  00357	83 7b 0c 01	 cmp	 DWORD PTR [ebx+12], 1
  0035b	75 27		 jne	 SHORT $LN2@ProcClose
  0035d	83 7b 10 ff	 cmp	 DWORD PTR [ebx+16], -1
  00361	75 21		 jne	 SHORT $LN2@ProcClose

; 841  : 		{
; 842  : 			this->m_iremainTimeSec = 60;

  00363	c7 43 10 3c 00
	00 00		 mov	 DWORD PTR [ebx+16], 60	; 0000003cH

; 843  : 			this->m_iTime = GetTickCount();

  0036a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00370	5f		 pop	 edi
  00371	5e		 pop	 esi

; 844  : 		}
; 845  : 		else
; 846  : 		{
; 847  : 			this->m_iTime = GetTickCount() + 60000;

  00372	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00375	5b		 pop	 ebx

; 848  : 		}
; 849  : 	}
; 850  : }

  00376	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00379	33 cd		 xor	 ecx, ebp
  0037b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00380	8b e5		 mov	 esp, ebp
  00382	5d		 pop	 ebp
  00383	c3		 ret	 0
$LN2@ProcClose:

; 844  : 		}
; 845  : 		else
; 846  : 		{
; 847  : 			this->m_iTime = GetTickCount() + 60000;

  00384	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0038a	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  0038f	89 43 08	 mov	 DWORD PTR [ebx+8], eax
$LN1@ProcClose:

; 848  : 		}
; 849  : 	}
; 850  : }

  00392	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00395	5f		 pop	 edi
  00396	5e		 pop	 esi
  00397	33 cd		 xor	 ecx, ebp
  00399	5b		 pop	 ebx
  0039a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039f	8b e5		 mov	 esp, ebp
  003a1	5d		 pop	 ebp
  003a2	c3		 ret	 0
?ProcClose@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ProcClose
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ProcOpen@CDevilSquare@@AAEXXZ			; CDevilSquare::ProcOpen
; Function compile flags: /Ogtp
;	COMDAT ?ProcOpen@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_pMsg$222571 = -280					; size = 4
_pNotice$222585 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
?ProcOpen@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ProcOpen, COMDAT
; _this$ = ecx

; 853  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b f9		 mov	 edi, ecx

; 854  : 	if ( this->m_iremainTimeSec != -1 )

  00018	83 ce ff	 or	 esi, -1
  0001b	39 77 10	 cmp	 DWORD PTR [edi+16], esi
  0001e	0f 84 0a 01 00
	00		 je	 $LN21@ProcOpen@2

; 855  : 	{
; 856  : 
; 857  : 		int lc2 = (GetTickCount() - this->m_iTime)/1000;

  00024	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002d	8b c8		 mov	 ecx, eax
  0002f	2b ce		 sub	 ecx, esi
  00031	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00036	f7 e1		 mul	 ecx
  00038	c1 ea 06	 shr	 edx, 6

; 858  : 
; 859  : 		if ( lc2 != 0 )

  0003b	85 d2		 test	 edx, edx
  0003d	0f 84 ff 01 00
	00		 je	 $LN1@ProcOpen@2

; 860  : 		{
; 861  : 			this->m_iremainTimeSec -= lc2;

  00043	29 57 10	 sub	 DWORD PTR [edi+16], edx

; 862  : 			this->m_iTime += lc2 * 1000;

  00046	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0004c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0004f	03 d6		 add	 edx, esi
  00051	89 57 08	 mov	 DWORD PTR [edi+8], edx

; 863  : 
; 864  : 			if ( this->m_iremainTimeSec <= 30 && this->m_bSendTimeCount == FALSE )

  00054	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00057	0f 8f a6 00 00
	00		 jg	 $LN49@ProcOpen@2
  0005d	83 7f 14 00	 cmp	 DWORD PTR [edi+20], 0
  00061	0f 85 9c 00 00
	00		 jne	 $LN49@ProcOpen@2

; 865  : 			{
; 866  : 				PMSG_SET_DEVILSQUARE pMsg;
; 867  : 
; 868  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00067	6a 04		 push	 4
  00069	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$222571[ebp]
  0006f	68 92 00 00 00	 push	 146			; 00000092H
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0007a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 869  : 				pMsg.Type = DevilSquare_OPEN;

  00083	c6 85 eb fe ff
	ff 01		 mov	 BYTE PTR _pMsg$222571[ebp+3], 1

; 870  : 
; 871  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0008a	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  0008f	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL18@ProcOpen@2:

; 872  : 				{
; 873  : 					if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00094	83 7c 16 04 03	 cmp	 DWORD PTR [esi+edx+4], 3
  00099	75 52		 jne	 SHORT $LN17@ProcOpen@2
  0009b	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  000a1	75 4a		 jne	 SHORT $LN17@ProcOpen@2

; 874  : 					{
; 875  : 						if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  000a3	8a 84 16 49 01
	00 00		 mov	 al, BYTE PTR [esi+edx+329]
  000aa	3c 34		 cmp	 al, 52			; 00000034H
  000ac	74 3f		 je	 SHORT $LN17@ProcOpen@2
  000ae	3c 0b		 cmp	 al, 11			; 0000000bH
  000b0	72 0c		 jb	 SHORT $LN44@ProcOpen@2
  000b2	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  000b7	3a c8		 cmp	 cl, al
  000b9	1b c9		 sbb	 ecx, ecx
  000bb	41		 inc	 ecx
  000bc	75 2f		 jne	 SHORT $LN17@ProcOpen@2
$LN44@ProcOpen@2:

; 876  : 						{
; 877  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  000be	3c 35		 cmp	 al, 53			; 00000035H
  000c0	74 2b		 je	 SHORT $LN17@ProcOpen@2
  000c2	3c 12		 cmp	 al, 18			; 00000012H
  000c4	72 09		 jb	 SHORT $LN45@ProcOpen@2
  000c6	b1 17		 mov	 cl, 23			; 00000017H
  000c8	3a c8		 cmp	 cl, al
  000ca	1b c0		 sbb	 eax, eax
  000cc	40		 inc	 eax
  000cd	75 1e		 jne	 SHORT $LN17@ProcOpen@2
$LN45@ProcOpen@2:

; 878  : 							{
; 879  : 								DataSend(i, (LPBYTE)&pMsg, pMsg.h.size);

  000cf	0f b6 95 e9 fe
	ff ff		 movzx	 edx, BYTE PTR _pMsg$222571[ebp+1]
  000d6	52		 push	 edx
  000d7	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$222571[ebp]
  000dd	50		 push	 eax
  000de	53		 push	 ebx
  000df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@ProcOpen@2:

; 870  : 
; 871  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  000ed	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  000f3	43		 inc	 ebx
  000f4	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  000fa	7c 98		 jl	 SHORT $LL18@ProcOpen@2

; 880  : 							}
; 881  : 						}
; 882  : 					}
; 883  : 				}
; 884  : 
; 885  : 				this->m_bSendTimeCount = TRUE;

  000fc	c7 47 14 01 00
	00 00		 mov	 DWORD PTR [edi+20], 1
$LN49@ProcOpen@2:

; 886  : 			}
; 887  : 
; 888  : 			if (this->m_iremainTimeSec < 1 )

  00103	83 7f 10 01	 cmp	 DWORD PTR [edi+16], 1
  00107	0f 8d 35 01 00
	00		 jge	 $LN1@ProcOpen@2

; 889  : 			{
; 890  : 				this->SendEventStartMsg();

  0010d	8b cf		 mov	 ecx, edi
  0010f	e8 00 00 00 00	 call	 ?SendEventStartMsg@CDevilSquare@@AAEXXZ ; CDevilSquare::SendEventStartMsg

; 891  : 				this->SetState(DevilSquare_PLAYING);

  00114	6a 02		 push	 2
  00116	8b cf		 mov	 ecx, edi
  00118	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx

; 936  : 			}
; 937  : 		}
; 938  : 	}
; 939  : }

  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
$LN21@ProcOpen@2:

; 892  : 			}
; 893  : 		
; 894  : 		}
; 895  : 	}
; 896  : 	else
; 897  : 	{
; 898  : 		if ( this->m_iTime < GetTickCount() )

  0012e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00134	ff d3		 call	 ebx
  00136	39 47 08	 cmp	 DWORD PTR [edi+8], eax
  00139	0f 83 03 01 00
	00		 jae	 $LN1@ProcOpen@2

; 899  : 		{
; 900  : 			this->ClearMonstr();

  0013f	8b cf		 mov	 ecx, edi
  00141	e8 00 00 00 00	 call	 ?ClearMonstr@CDevilSquare@@QAEXXZ ; CDevilSquare::ClearMonstr

; 901  : 			this->m_iRemainTime--;

  00146	01 77 0c	 add	 DWORD PTR [edi+12], esi
  00149	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 902  : 
; 903  : 			if ( this->m_iRemainTime > 0 )

  0014c	85 c0		 test	 eax, eax
  0014e	0f 8e bc 00 00
	00		 jle	 $LN9@ProcOpen@2

; 904  : 			{
; 905  : 				PMSG_NOTICE pNotice;
; 906  : 
; 907  : 				TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(2, 193)), this->m_iRemainTime);

  00154	50		 push	 eax
  00155	68 c1 02 00 00	 push	 705			; 000002c1H
  0015a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0015f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00164	50		 push	 eax
  00165	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$222585[ebp]
  0016b	6a 00		 push	 0
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00173	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00179	83 c4 10	 add	 esp, 16			; 00000010H

; 908  : 
; 909  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  0017c	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  00181	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL8@ProcOpen@2:

; 910  : 				{
; 911  : 					if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00186	83 7c 16 04 03	 cmp	 DWORD PTR [esi+edx+4], 3
  0018b	75 52		 jne	 SHORT $LN7@ProcOpen@2
  0018d	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  00193	75 4a		 jne	 SHORT $LN7@ProcOpen@2

; 912  : 					{
; 913  : 						if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00195	8a 84 16 49 01
	00 00		 mov	 al, BYTE PTR [esi+edx+329]
  0019c	3c 34		 cmp	 al, 52			; 00000034H
  0019e	74 3f		 je	 SHORT $LN7@ProcOpen@2
  001a0	3c 0b		 cmp	 al, 11			; 0000000bH
  001a2	72 0c		 jb	 SHORT $LN46@ProcOpen@2
  001a4	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  001a9	3a c8		 cmp	 cl, al
  001ab	1b c9		 sbb	 ecx, ecx
  001ad	41		 inc	 ecx
  001ae	75 2f		 jne	 SHORT $LN7@ProcOpen@2
$LN46@ProcOpen@2:

; 914  : 						{
; 915  : 							if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  001b0	3c 35		 cmp	 al, 53			; 00000035H
  001b2	74 2b		 je	 SHORT $LN7@ProcOpen@2
  001b4	3c 12		 cmp	 al, 18			; 00000012H
  001b6	72 09		 jb	 SHORT $LN47@ProcOpen@2
  001b8	b1 17		 mov	 cl, 23			; 00000017H
  001ba	3a c8		 cmp	 cl, al
  001bc	1b c0		 sbb	 eax, eax
  001be	40		 inc	 eax
  001bf	75 1e		 jne	 SHORT $LN7@ProcOpen@2
$LN47@ProcOpen@2:

; 916  : 							{
; 917  : 								DataSend(i, (LPBYTE)&pNotice, pNotice.h.size);

  001c1	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$222585[ebp+1]
  001c8	52		 push	 edx
  001c9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$222585[ebp]
  001cf	50		 push	 eax
  001d0	53		 push	 ebx
  001d1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@ProcOpen@2:

; 908  : 
; 909  : 				for ( int i=OBJ_STARTUSERINDZT;i<OBJMAX;i++)

  001df	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  001e5	43		 inc	 ebx
  001e6	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  001ec	7c 98		 jl	 SHORT $LL8@ProcOpen@2

; 918  : 							}
; 919  : 						}
; 920  : 					}
; 921  : 				}
; 922  : 
; 923  : 				LogAddTD((char*)pNotice.Notice);

  001ee	8d 8d f9 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$222585[ebp+13]
  001f4	51		 push	 ecx
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001fb	83 c4 04	 add	 esp, 4

; 924  : 
; 925  : 				this->m_iTime = GetTickCount();

  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00204	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0020a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0020d	83 ce ff	 or	 esi, -1
$LN9@ProcOpen@2:

; 926  : 			}
; 927  : 
; 928  : 			if (this->m_iRemainTime == 1 && this->m_iremainTimeSec == -1)

  00210	83 7f 0c 01	 cmp	 DWORD PTR [edi+12], 1
  00214	75 22		 jne	 SHORT $LN2@ProcOpen@2
  00216	39 77 10	 cmp	 DWORD PTR [edi+16], esi
  00219	75 1d		 jne	 SHORT $LN2@ProcOpen@2

; 929  : 			{
; 930  : 				this->m_iremainTimeSec = 60;

  0021b	c7 47 10 3c 00
	00 00		 mov	 DWORD PTR [edi+16], 60	; 0000003cH

; 931  : 				this->m_iTime = GetTickCount();

  00222	ff d3		 call	 ebx

; 932  : 			}
; 933  : 			else
; 934  : 			{
; 935  : 				this->m_iTime = GetTickCount() + 60000;

  00224	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00227	5f		 pop	 edi
  00228	5e		 pop	 esi
  00229	5b		 pop	 ebx

; 936  : 			}
; 937  : 		}
; 938  : 	}
; 939  : }

  0022a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022d	33 cd		 xor	 ecx, ebp
  0022f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
$LN2@ProcOpen@2:

; 932  : 			}
; 933  : 			else
; 934  : 			{
; 935  : 				this->m_iTime = GetTickCount() + 60000;

  00238	ff d3		 call	 ebx
  0023a	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  0023f	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN1@ProcOpen@2:

; 936  : 			}
; 937  : 		}
; 938  : 	}
; 939  : }

  00242	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00245	5f		 pop	 edi
  00246	5e		 pop	 esi
  00247	33 cd		 xor	 ecx, ebp
  00249	5b		 pop	 ebx
  0024a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c3		 ret	 0
?ProcOpen@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ProcOpen
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ProcPlaying@CDevilSquare@@AAEXXZ		; CDevilSquare::ProcPlaying
EXTRN	?RegenBossMonster@CDevilSquareGround@@QAEXH@Z:PROC ; CDevilSquareGround::RegenBossMonster
EXTRN	?AllSendSameMapMsg@@YAXPAEHE@Z:PROC		; AllSendSameMapMsg
; Function compile flags: /Ogtp
;	COMDAT ?ProcPlaying@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_pMsg$222604 = -280					; size = 4
_pNotice$222618 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
?ProcPlaying@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ProcPlaying, COMDAT
; _this$ = ecx

; 942  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b f1		 mov	 esi, ecx

; 943  : 	if ( this->m_iremainTimeSec != -1 )

  00018	83 cf ff	 or	 edi, -1
  0001b	39 7e 10	 cmp	 DWORD PTR [esi+16], edi
  0001e	0f 84 e5 00 00
	00		 je	 $LN18@ProcPlayin

; 944  : 	{
; 945  : 		int lc2 = (GetTickCount() - this->m_iTime)/1000;

  00024	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002d	8b c8		 mov	 ecx, eax
  0002f	2b cf		 sub	 ecx, edi
  00031	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00036	f7 e1		 mul	 ecx
  00038	c1 ea 06	 shr	 edx, 6

; 946  : 
; 947  : 		if ( lc2 != 0 )

  0003b	85 d2		 test	 edx, edx
  0003d	0f 84 90 01 00
	00		 je	 $LN1@ProcPlayin

; 948  : 		{
; 949  : 			this->m_iremainTimeSec -= lc2;

  00043	29 56 10	 sub	 DWORD PTR [esi+16], edx

; 950  : 			this->m_iTime += lc2 * 1000;

  00046	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0004c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0004f	03 d7		 add	 edx, edi
  00051	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 951  : 
; 952  : 			if ( this->m_iremainTimeSec <= 30 && this->m_bSendTimeCount == FALSE )

  00054	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00057	0f 8f 88 00 00
	00		 jg	 $LN29@ProcPlayin
  0005d	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  00061	0f 85 7e 00 00
	00		 jne	 $LN29@ProcPlayin

; 953  : 			{
; 954  : 				PMSG_SET_DEVILSQUARE pMsg;
; 955  : 
; 956  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00067	6a 04		 push	 4
  00069	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$222604[ebp]
  0006f	68 92 00 00 00	 push	 146			; 00000092H
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 957  : 				pMsg.Type = DevilSquare_PLAYING;
; 958  : 
; 959  : 				for(int i = 0; i < OBJMAX; i++)

  00083	33 db		 xor	 ebx, ebx
  00085	c6 85 eb fe ff
	ff 02		 mov	 BYTE PTR _pMsg$222604[ebp+3], 2
  0008c	33 ff		 xor	 edi, edi
  0008e	8b ff		 npad	 2
$LL15@ProcPlayin:

; 960  : 				{
; 961  : 					if(gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00090	83 7c 0f 04 03	 cmp	 DWORD PTR [edi+ecx+4], 3
  00095	75 38		 jne	 SHORT $LN14@ProcPlayin
  00097	66 83 7c 0f 68
	01		 cmp	 WORD PTR [edi+ecx+104], 1
  0009d	75 30		 jne	 SHORT $LN14@ProcPlayin

; 962  : 					{
; 963  : 						if(DS_MAP_RANGE(gObj[i].MapNumber) != FALSE)

  0009f	8a 84 0f 49 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+329]
  000a6	3c 09		 cmp	 al, 9
  000a8	74 0d		 je	 SHORT $LN27@ProcPlayin
  000aa	33 d2		 xor	 edx, edx
  000ac	3c 20		 cmp	 al, 32			; 00000020H
  000ae	0f 94 c2	 sete	 dl
  000b1	8b c2		 mov	 eax, edx
  000b3	85 c0		 test	 eax, eax
  000b5	74 18		 je	 SHORT $LN14@ProcPlayin
$LN27@ProcPlayin:

; 964  : 						{
; 965  : 							DataSend(i, (LPBYTE)&pMsg, sizeof(pMsg));

  000b7	6a 04		 push	 4
  000b9	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$222604[ebp]
  000bf	50		 push	 eax
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@ProcPlayin:

; 957  : 				pMsg.Type = DevilSquare_PLAYING;
; 958  : 
; 959  : 				for(int i = 0; i < OBJMAX; i++)

  000cf	81 c7 50 2b 00
	00		 add	 edi, 11088		; 00002b50H
  000d5	43		 inc	 ebx
  000d6	81 ff 80 d7 e9
	09		 cmp	 edi, 166320000		; 09e9d780H
  000dc	7c b2		 jl	 SHORT $LL15@ProcPlayin

; 966  : 						}
; 967  : 					}
; 968  : 				}
; 969  : 				
; 970  : 				this->m_bSendTimeCount = TRUE;

  000de	c7 46 14 01 00
	00 00		 mov	 DWORD PTR [esi+20], 1
$LN29@ProcPlayin:

; 971  : 			}
; 972  : 
; 973  : 			if ( this->m_iremainTimeSec < 1 )

  000e5	83 7e 10 01	 cmp	 DWORD PTR [esi+16], 1
  000e9	0f 8d e4 00 00
	00		 jge	 $LN1@ProcPlayin

; 974  : 			{
; 975  : 				this->SetState(DevilSquare_CLOSE);

  000ef	6a 00		 push	 0
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx

; 1009 : 				}
; 1010 : 			}
; 1011 : 		}
; 1012 : 	}
; 1013 : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 cd		 xor	 ecx, ebp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
$LN18@ProcPlayin:

; 976  : 			}
; 977  : 		}
; 978  : 	}
; 979  : 	else
; 980  : 	{
; 981  : 		if ( this->m_iTime < GetTickCount() )

  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0010f	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  00112	0f 83 bb 00 00
	00		 jae	 $LN1@ProcPlayin

; 982  : 		{
; 983  : 			this->m_iRemainTime--;

  00118	01 7e 0c	 add	 DWORD PTR [esi+12], edi
  0011b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]

; 984  : 
; 985  : 			if ( this->m_iRemainTime > 0 )

  0011e	85 c9		 test	 ecx, ecx
  00120	0f 8e ad 00 00
	00		 jle	 $LN1@ProcPlayin

; 986  : 			{
; 987  : 				if ( (this->m_iRemainTime%5) == 0 )

  00126	8b c1		 mov	 eax, ecx
  00128	99		 cdq
  00129	bf 05 00 00 00	 mov	 edi, 5
  0012e	f7 ff		 idiv	 edi
  00130	85 d2		 test	 edx, edx
  00132	75 45		 jne	 SHORT $LN6@ProcPlayin

; 988  : 				{
; 989  : 					PMSG_NOTICE pNotice;
; 990  : 
; 991  : 					TNotice::MakeNoticeMsgEx((TNotice *)&pNotice, 0, lMsg.Get(MSGGET(2, 194)), this->m_iRemainTime);

  00134	51		 push	 ecx
  00135	68 c2 02 00 00	 push	 706			; 000002c2H
  0013a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0013f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00144	50		 push	 eax
  00145	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$222618[ebp]
  0014b	6a 00		 push	 0
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 992  : 					LogAddTD((char*)pNotice.Notice);

  00153	8d 95 f9 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$222618[ebp+13]
  00159	52		 push	 edx
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 993  : 					AllSendSameMapMsg((LPBYTE)&pNotice, pNotice.h.size, MAP_INDEX_DEVILSQUARE);

  00160	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$222618[ebp+1]
  00167	6a 09		 push	 9
  00169	50		 push	 eax
  0016a	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$222618[ebp]
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 ?AllSendSameMapMsg@@YAXPAEHE@Z ; AllSendSameMapMsg
  00176	83 c4 20	 add	 esp, 32			; 00000020H
$LN6@ProcPlayin:

; 994  : 				}
; 995  : 
; 996  : 				for ( int i=0;i<MAX_DEVILSQUARE_GROUND;i++)

  00179	8d 7e 3c	 lea	 edi, DWORD PTR [esi+60]
  0017c	bb 07 00 00 00	 mov	 ebx, 7
$LL5@ProcPlayin:

; 997  : 				{
; 998  : 					this->m_DevilSquareGround[i].RegenBossMonster(this->m_iPlaytime - this->m_iRemainTime);

  00181	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00184	2b 56 0c	 sub	 edx, DWORD PTR [esi+12]
  00187	8b cf		 mov	 ecx, edi
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 ?RegenBossMonster@CDevilSquareGround@@QAEXH@Z ; CDevilSquareGround::RegenBossMonster
  0018f	81 c7 a8 04 00
	00		 add	 edi, 1192		; 000004a8H
  00195	4b		 dec	 ebx
  00196	75 e9		 jne	 SHORT $LL5@ProcPlayin

; 999  : 				}
; 1000 : 
; 1001 : 				if ( this->m_iRemainTime == 1 && this->m_iremainTimeSec == -1 )

  00198	83 7e 0c 01	 cmp	 DWORD PTR [esi+12], 1
  0019c	75 27		 jne	 SHORT $LN2@ProcPlayin
  0019e	83 7e 10 ff	 cmp	 DWORD PTR [esi+16], -1
  001a2	75 21		 jne	 SHORT $LN2@ProcPlayin

; 1002 : 				{
; 1003 : 					this->m_iremainTimeSec = 60;

  001a4	c7 46 10 3c 00
	00 00		 mov	 DWORD PTR [esi+16], 60	; 0000003cH

; 1004 : 					this->m_iTime = GetTickCount();

  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001b1	5f		 pop	 edi

; 1005 : 				}
; 1006 : 				else
; 1007 : 				{
; 1008 : 					this->m_iTime = GetTickCount() + 60000;

  001b2	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001b5	5e		 pop	 esi
  001b6	5b		 pop	 ebx

; 1009 : 				}
; 1010 : 			}
; 1011 : 		}
; 1012 : 	}
; 1013 : }

  001b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ba	33 cd		 xor	 ecx, ebp
  001bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c3		 ret	 0
$LN2@ProcPlayin:

; 1005 : 				}
; 1006 : 				else
; 1007 : 				{
; 1008 : 					this->m_iTime = GetTickCount() + 60000;

  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001cb	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  001d0	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN1@ProcPlayin:

; 1009 : 				}
; 1010 : 			}
; 1011 : 		}
; 1012 : 	}
; 1013 : }

  001d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	33 cd		 xor	 ecx, ebp
  001da	5b		 pop	 ebx
  001db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c3		 ret	 0
?ProcPlaying@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ProcPlaying
_TEXT	ENDS
PUBLIC	?Run@CDevilSquare@@QAEHXZ			; CDevilSquare::Run
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
EXTRN	?gDevilSquareEvent@@3HA:DWORD			; gDevilSquareEvent
EXTRN	__imp__Sleep@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Run@CDevilSquare@@QAEHXZ
_TEXT	SEGMENT
?Run@CDevilSquare@@QAEHXZ PROC				; CDevilSquare::Run, COMDAT
; _this$ = ecx

; 514  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 515  : 	int count = 0;

  00004	33 ff		 xor	 edi, edi

; 516  : 
; 517  : 	while ( this->m_bQuit == FALSE )

  00006	39 7e 18	 cmp	 DWORD PTR [esi+24], edi
  00009	75 62		 jne	 SHORT $LN14@Run
  0000b	53		 push	 ebx
  0000c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Sleep@4
$LL10@Run:

; 518  : 	{
; 519  : 		if ( gDevilSquareEvent != FALSE )

  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDevilSquareEvent@@3HA, 0 ; gDevilSquareEvent
  00019	74 27		 je	 SHORT $LN6@Run

; 520  : 		{
; 521  : 			switch ( this->m_eState )

  0001b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001e	83 e8 00	 sub	 eax, 0
  00021	74 18		 je	 SHORT $LN5@Run
  00023	48		 dec	 eax
  00024	74 0c		 je	 SHORT $LN4@Run
  00026	48		 dec	 eax
  00027	75 19		 jne	 SHORT $LN6@Run

; 525  : 				case DevilSquare_PLAYING:	this->ProcPlaying();	break;

  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?ProcPlaying@CDevilSquare@@AAEXXZ ; CDevilSquare::ProcPlaying
  00030	eb 10		 jmp	 SHORT $LN6@Run
$LN4@Run:

; 524  : 				case DevilSquare_OPEN:		this->ProcOpen();		break;

  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?ProcOpen@CDevilSquare@@AAEXXZ ; CDevilSquare::ProcOpen
  00039	eb 07		 jmp	 SHORT $LN6@Run
$LN5@Run:

; 522  : 			{
; 523  : 				case DevilSquare_CLOSE:	this->ProcClose();		break;

  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?ProcClose@CDevilSquare@@AAEXXZ ; CDevilSquare::ProcClose
$LN6@Run:

; 526  : 			}
; 527  : 		}
; 528  : 
; 529  : 		Sleep(100);

  00042	6a 64		 push	 100			; 00000064H
  00044	ff d3		 call	 ebx

; 530  : 		count++;

  00046	47		 inc	 edi

; 531  : 
; 532  : 		if ( count > 600 )

  00047	81 ff 58 02 00
	00		 cmp	 edi, 600		; 00000258H
  0004d	7e 17		 jle	 SHORT $LN16@Run

; 533  : 		{
; 534  : 			this->SendLiveCall();

  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?SendLiveCall@CDevilSquare@@AAEXXZ ; CDevilSquare::SendLiveCall

; 535  : 			count = 0;

  00056	33 ff		 xor	 edi, edi

; 536  : 
; 537  : 			if ( szAuthKey[12] != AUTHKEY12 )

  00058	80 3d 0c 00 00
	00 f1		 cmp	 BYTE PTR ?szAuthKey@@3PADA+12, -15 ; fffffff1H
  0005f	74 05		 je	 SHORT $LN16@Run

; 538  : 			{
; 539  : 				DestroyGIocp();

  00061	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN16@Run:

; 516  : 
; 517  : 	while ( this->m_bQuit == FALSE )

  00066	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  0006a	74 a6		 je	 SHORT $LL10@Run
  0006c	5b		 pop	 ebx
$LN14@Run:
  0006d	5f		 pop	 edi

; 540  : 			}
; 541  : 		}
; 542  : 	}
; 543  : 
; 544  : 	return TRUE;

  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	5e		 pop	 esi

; 545  : }

  00074	c3		 ret	 0
?Run@CDevilSquare@@QAEHXZ ENDP				; CDevilSquare::Run
_TEXT	ENDS
PUBLIC	?DevilSquareThreadFunc@@YGIPAX@Z		; DevilSquareThreadFunc
; Function compile flags: /Ogtp
;	COMDAT ?DevilSquareThreadFunc@@YGIPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?DevilSquareThreadFunc@@YGIPAX@Z PROC			; DevilSquareThreadFunc, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	CDevilSquare * pDevilSquare = (CDevilSquare *)p;
; 31   : 	return pDevilSquare->Run();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00006	e8 00 00 00 00	 call	 ?Run@CDevilSquare@@QAEHXZ ; CDevilSquare::Run

; 32   : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?DevilSquareThreadFunc@@YGIPAX@Z ENDP			; DevilSquareThreadFunc
_TEXT	ENDS
PUBLIC	?Init@CDevilSquare@@QAEXXZ			; CDevilSquare::Init
EXTRN	__beginthreadex:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Init@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
_dwThreadId$ = -4					; size = 4
?Init@CDevilSquare@@QAEXXZ PROC				; CDevilSquare::Init, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 153  : 	this->m_bQuit = TRUE;
; 154  : 	Sleep(500);

  00007	68 f4 01 00 00	 push	 500			; 000001f4H
  0000c	c7 46 18 01 00
	00 00		 mov	 DWORD PTR [esi+24], 1
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 155  : 
; 156  : 	this->SetState(DevilSquare_CLOSE);

  00019	6a 00		 push	 0
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState

; 157  : 	this->m_bQuit = FALSE;
; 158  : 
; 159  : 	DWORD dwThreadId;
; 160  : 
; 161  : 	this->m_hThread = (UINT)_beginthreadex( 0, 0, DevilSquareThreadFunc, this, 0, (LPUINT)&dwThreadId);

  00022	8d 45 fc	 lea	 eax, DWORD PTR _dwThreadId$[ebp]
  00025	50		 push	 eax
  00026	6a 00		 push	 0
  00028	56		 push	 esi
  00029	68 00 00 00 00	 push	 OFFSET ?DevilSquareThreadFunc@@YGIPAX@Z ; DevilSquareThreadFunc
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00039	e8 00 00 00 00	 call	 __beginthreadex
  0003e	83 c4 18	 add	 esp, 24			; 00000018H
  00041	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00044	5e		 pop	 esi

; 162  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?Init@CDevilSquare@@QAEXXZ ENDP				; CDevilSquare::Init
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_DevilSquare@@YAXXZ
text$yc	SEGMENT
??__Eg_DevilSquare@@YAXXZ PROC				; `dynamic initializer for 'g_DevilSquare'', COMDAT

; 26   : CDevilSquare g_DevilSquare;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00005	e8 00 00 00 00	 call	 ??0CDevilSquare@@QAE@XZ	; CDevilSquare::CDevilSquare
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_DevilSquare@@YAXXZ ; `dynamic atexit destructor for 'g_DevilSquare''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_DevilSquare@@YAXXZ ENDP				; `dynamic initializer for 'g_DevilSquare''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_DevilSquare@@YAXXZ
text$yd	SEGMENT
??__Fg_DevilSquare@@YAXXZ PROC				; `dynamic atexit destructor for 'g_DevilSquare'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00005	e9 00 00 00 00	 jmp	 ??1CDevilSquare@@UAE@XZ	; CDevilSquare::~CDevilSquare
??__Fg_DevilSquare@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_DevilSquare''
text$yd	ENDS
PUBLIC	?g_DevilSquare@@3VCDevilSquare@@A		; g_DevilSquare
_BSS	SEGMENT
?g_DevilSquare@@3VCDevilSquare@@A DB 02198H DUP (?)	; g_DevilSquare
_BSS	ENDS
CRT$XCU	SEGMENT
_g_DevilSquare$initializer$ DD FLAT:??__Eg_DevilSquare@@YAXXZ
CRT$XCU	ENDS
END
