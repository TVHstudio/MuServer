; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\DuelManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_g_DuelGates DD	0127H
	DD	0128H
	DD	012fH
	DD	0129H
	DD	012aH
	DD	0130H
	DD	012bH
	DD	012cH
	DD	0131H
	DD	012dH
	DD	012eH
	DD	0132H
CONST	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	070H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
	DD	010eH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CDuelManager@@QAE@XZ				; CDuelManager::CDuelManager
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\duelmanager.cpp
;	COMDAT ??0CDuelManager@@QAE@XZ
_TEXT	SEGMENT
??0CDuelManager@@QAE@XZ PROC				; CDuelManager::CDuelManager, COMDAT
; _this$ = ecx

; 38   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx

; 39   : 
; 40   :   ZeroMemory(&this->m_Rooms, sizeof(this->m_Rooms));

  00005	68 30 01 00 00	 push	 304			; 00000130H
  0000a	33 ff		 xor	 edi, edi
  0000c	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
  0000f	57		 push	 edi
  00010	53		 push	 ebx
  00011	e8 00 00 00 00	 call	 _memset

; 41   : 
; 42   :   for(int i = 0; i < MAX_DUEL_ROOMS; i++) 
; 43   :   {
; 44   :     this->m_Rooms[i].bFree = true;

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 45   :     this->m_Rooms[i].bWaiting = false;

  0001e	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 46   :     this->m_Rooms[i].bHasWinner = false;

  00021	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  00024	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  00027	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  0002d	89 be ac 00 00
	00		 mov	 DWORD PTR [esi+172], edi
  00033	89 be f0 00 00
	00		 mov	 DWORD PTR [esi+240], edi
  00039	89 be f8 00 00
	00		 mov	 DWORD PTR [esi+248], edi
  0003f	89 be 3c 01 00
	00		 mov	 DWORD PTR [esi+316], edi
  00045	89 03		 mov	 DWORD PTR [ebx], eax
  00047	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0004a	89 86 a8 00 00
	00		 mov	 DWORD PTR [esi+168], eax
  00050	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax
  00056	5f		 pop	 edi

; 47   :   }
; 48   : 
; 49   : }

  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	c3		 ret	 0
??0CDuelManager@@QAE@XZ ENDP				; CDuelManager::CDuelManager
_TEXT	ENDS
PUBLIC	??1CDuelManager@@QAE@XZ				; CDuelManager::~CDuelManager
; Function compile flags: /Ogtp
;	COMDAT ??1CDuelManager@@QAE@XZ
_TEXT	SEGMENT
??1CDuelManager@@QAE@XZ PROC				; CDuelManager::~CDuelManager, COMDAT
; _this$ = ecx

; 53   : }

  00000	c3		 ret	 0
??1CDuelManager@@QAE@XZ ENDP				; CDuelManager::~CDuelManager
_TEXT	ENDS
PUBLIC	?GetUserDuelRoom@CDuelManager@@QAEHPAUOBJECTSTRUCT@@@Z ; CDuelManager::GetUserDuelRoom
; Function compile flags: /Ogtp
;	COMDAT ?GetUserDuelRoom@CDuelManager@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?GetUserDuelRoom@CDuelManager@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CDuelManager::GetUserDuelRoom, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	83 c1 20	 add	 ecx, 32			; 00000020H
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@GetUserDue:

; 58   :   {
; 59   :     if(this->m_Rooms[i].lpObj01 == lpObj ||
; 60   :       this->m_Rooms[i].lpObj02 == lpObj) 

  00010	39 51 f8	 cmp	 DWORD PTR [ecx-8], edx
  00013	74 10		 je	 SHORT $LN6@GetUserDue
  00015	39 11		 cmp	 DWORD PTR [ecx], edx
  00017	74 0c		 je	 SHORT $LN6@GetUserDue

; 57   :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00019	40		 inc	 eax
  0001a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001d	83 f8 04	 cmp	 eax, 4
  00020	7c ee		 jl	 SHORT $LL5@GetUserDue

; 61   :     {
; 62   :       return i;
; 63   :     }
; 64   :   }
; 65   :   return -1;

  00022	83 c8 ff	 or	 eax, -1
$LN6@GetUserDue:

; 66   : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetUserDuelRoom@CDuelManager@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CDuelManager::GetUserDuelRoom
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?UpdateDuelScore@CDuelManager@@QAEXH@Z		; CDuelManager::UpdateDuelScore
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?UpdateDuelScore@CDuelManager@@QAEXH@Z
_TEXT	SEGMENT
_aIndex2$ = -20						; size = 4
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_iRoom$ = 8						; size = 4
?UpdateDuelScore@CDuelManager@@QAEXH@Z PROC		; CDuelManager::UpdateDuelScore, COMDAT
; _this$ = ecx

; 163  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _iRoom$[ebp]

; 164  : 
; 165  :   if(iRoom < 0 || iRoom > MAX_DUEL_ROOMS - 1)

  00013	83 f8 03	 cmp	 eax, 3
  00016	0f 87 37 01 00
	00		 ja	 $LN5@UpdateDuel

; 166  :     return;
; 167  : 
; 168  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || this->m_Rooms[iRoom].lpObj02 == NULL) return;

  0001c	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0001f	56		 push	 esi
  00020	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00023	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00026	85 c0		 test	 eax, eax
  00028	0f 84 24 01 00
	00		 je	 $LN25@UpdateDuel
  0002e	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00031	85 c9		 test	 ecx, ecx
  00033	0f 84 19 01 00
	00		 je	 $LN25@UpdateDuel

; 169  : 
; 170  :   int aIndex1 = this->m_Rooms[iRoom].lpObj01->m_Index;
; 171  :   int aIndex2 = this->m_Rooms[iRoom].lpObj02->m_Index;

  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	53		 push	 ebx
  0003c	8b 18		 mov	 ebx, DWORD PTR [eax]
  0003e	89 4d ec	 mov	 DWORD PTR _aIndex2$[ebp], ecx

; 172  : 
; 173  :   if ( !OBJMAX_RANGE(aIndex1) || !OBJMAX_RANGE(aIndex2))

  00041	85 db		 test	 ebx, ebx
  00043	0f 88 08 01 00
	00		 js	 $LN26@UpdateDuel
  00049	33 c0		 xor	 eax, eax
  0004b	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00051	0f 9e c0	 setle	 al
  00054	85 c0		 test	 eax, eax
  00056	0f 84 f5 00 00
	00		 je	 $LN26@UpdateDuel
  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 88 ed 00 00
	00		 js	 $LN26@UpdateDuel
  00064	33 c0		 xor	 eax, eax
  00066	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0006c	0f 9e c0	 setle	 al
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 da 00 00
	00		 je	 $LN26@UpdateDuel

; 174  :     return;
; 175  : 
; 176  :   if ( !gObjIsConnected(aIndex1) || !gObjIsConnected(aIndex2) )

  00077	53		 push	 ebx
  00078	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007d	83 c4 04	 add	 esp, 4
  00080	85 c0		 test	 eax, eax
  00082	0f 84 c9 00 00
	00		 je	 $LN26@UpdateDuel
  00088	8b 45 ec	 mov	 eax, DWORD PTR _aIndex2$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00091	83 c4 04	 add	 esp, 4
  00094	85 c0		 test	 eax, eax
  00096	0f 84 b5 00 00
	00		 je	 $LN26@UpdateDuel

; 177  :     return;
; 178  : 
; 179  :   if ( gObj[aIndex1].Type == OBJ_MONSTER || gObj[aIndex2].Type == OBJ_MONSTER )

  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a2	8b d3		 mov	 edx, ebx
  000a4	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000aa	66 83 7c 0a 68
	02		 cmp	 WORD PTR [edx+ecx+104], 2
  000b0	0f 84 9b 00 00
	00		 je	 $LN26@UpdateDuel
  000b6	8b 45 ec	 mov	 eax, DWORD PTR _aIndex2$[ebp]
  000b9	57		 push	 edi
  000ba	8b f8		 mov	 edi, eax
  000bc	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  000c2	66 83 7c 39 68
	02		 cmp	 WORD PTR [ecx+edi+104], 2
  000c8	0f 84 82 00 00
	00		 je	 $LN27@UpdateDuel

; 180  :     return;
; 181  :   
; 182  :   if ( gObj[aIndex1].CloseCount >= 0 || gObj[aIndex2].CloseCount >= 0 )

  000ce	80 7c 0a 0a 00	 cmp	 BYTE PTR [edx+ecx+10], 0
  000d3	7d 7b		 jge	 SHORT $LN27@UpdateDuel
  000d5	80 7c 39 0a 00	 cmp	 BYTE PTR [ecx+edi+10], 0
  000da	7d 74		 jge	 SHORT $LN27@UpdateDuel

; 183  :     return;
; 184  : 
; 185  :   PMSG_DUEL_SCORE pMsg;
; 186  : 
; 187  :   pMsg.h.c = 0xC1;
; 188  :   pMsg.h.size = sizeof(pMsg);
; 189  :   pMsg.h.headcode = 0xAA;
; 190  :   pMsg.h.subcode = 0x04;
; 191  :   pMsg.NumberH1 = SET_NUMBERH(aIndex1);
; 192  :   pMsg.NumberL1 = SET_NUMBERL(aIndex1);
; 193  :   pMsg.NumberH2 = SET_NUMBERH(aIndex2);

  000dc	8b d0		 mov	 edx, eax
  000de	c1 ea 08	 shr	 edx, 8
  000e1	8b cb		 mov	 ecx, ebx
  000e3	c1 e9 08	 shr	 ecx, 8
  000e6	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 194  :   pMsg.NumberL2 = SET_NUMBERL(aIndex2);
; 195  :   pMsg.btDuelScore1 = this->m_Rooms[iRoom].btPoints01;
; 196  :   pMsg.btDuelScore2 = this->m_Rooms[iRoom].btPoints02;
; 197  : 
; 198  :   DataSend(aIndex1, (LPBYTE)&pMsg, pMsg.h.size);

  000e9	6a 0a		 push	 10			; 0000000aH
  000eb	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000ee	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  000f1	8a 4e 24	 mov	 cl, BYTE PTR [esi+36]
  000f4	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+7], al
  000f7	8a 46 1c	 mov	 al, BYTE PTR [esi+28]
  000fa	52		 push	 edx
  000fb	53		 push	 ebx
  000fc	c7 45 f0 c1 0a
	aa 04		 mov	 DWORD PTR _pMsg$[ebp], 78252737 ; 04aa0ac1H
  00103	88 5d f5	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00106	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+8], al
  00109	88 4d f9	 mov	 BYTE PTR _pMsg$[ebp+9], cl
  0010c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 199  :   DataSend(aIndex2, (LPBYTE)&pMsg, pMsg.h.size);

  00111	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00115	8b 55 ec	 mov	 edx, DWORD PTR _aIndex2$[ebp]
  00118	50		 push	 eax
  00119	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0011c	51		 push	 ecx
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00123	83 c4 18	 add	 esp, 24			; 00000018H
  00126	83 c6 28	 add	 esi, 40			; 00000028H
  00129	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0012e	8b ff		 npad	 2
$LL4@UpdateDuel:

; 202  :   {
; 203  :     if(this->m_Rooms[iRoom].lpLearners[i] == NULL) 

  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	85 c0		 test	 eax, eax
  00134	74 14		 je	 SHORT $LN3@UpdateDuel

; 204  :     {
; 205  :       continue;
; 206  :     }
; 207  :     DataSend(this->m_Rooms[iRoom].lpLearners[i]->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00136	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0013a	8b 00		 mov	 eax, DWORD PTR [eax]
  0013c	51		 push	 ecx
  0013d	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00140	52		 push	 edx
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@UpdateDuel:

; 200  : 
; 201  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  0014a	83 c6 04	 add	 esi, 4
  0014d	4f		 dec	 edi
  0014e	75 e0		 jne	 SHORT $LL4@UpdateDuel
$LN27@UpdateDuel:
  00150	5f		 pop	 edi
$LN26@UpdateDuel:
  00151	5b		 pop	 ebx
$LN25@UpdateDuel:
  00152	5e		 pop	 esi
$LN5@UpdateDuel:

; 208  :   }
; 209  : 
; 210  : }

  00153	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c2 04 00	 ret	 4
?UpdateDuelScore@CDuelManager@@QAEXH@Z ENDP		; CDuelManager::UpdateDuelScore
_TEXT	ENDS
PUBLIC	?PlayerScore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::PlayerScore
; Function compile flags: /Ogtp
;	COMDAT ?PlayerScore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?PlayerScore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CDuelManager::PlayerScore, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 214  :   int iRoom = this->GetUserDuelRoom(lpObj);

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?GetUserDuelRoom@CDuelManager@@QAEHPAUOBJECTSTRUCT@@@Z ; CDuelManager::GetUserDuelRoom

; 215  :   if(iRoom >= 0 && iRoom < MAX_DUEL_ROOMS)

  00010	83 f8 03	 cmp	 eax, 3
  00013	77 2d		 ja	 SHORT $LN1@PlayerScor

; 216  :   {
; 217  :     if(this->m_Rooms[iRoom].lpObj01 == lpObj)

  00015	8b c8		 mov	 ecx, eax
  00017	6b c9 4c	 imul	 ecx, 76			; 0000004cH
  0001a	03 ce		 add	 ecx, esi
  0001c	39 79 18	 cmp	 DWORD PTR [ecx+24], edi
  0001f	75 11		 jne	 SHORT $LN3@PlayerScor

; 218  :     {
; 219  :       this->m_Rooms[iRoom].btPoints01++;

  00021	fe 41 1c	 inc	 BYTE PTR [ecx+28]

; 225  :       this->UpdateDuelScore(iRoom);

  00024	50		 push	 eax
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?UpdateDuelScore@CDuelManager@@QAEXH@Z ; CDuelManager::UpdateDuelScore
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 226  :     }
; 227  :   }
; 228  : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN3@PlayerScor:

; 220  :       this->UpdateDuelScore(iRoom);
; 221  :     }
; 222  :     else if(this->m_Rooms[iRoom].lpObj02 == lpObj)

  00032	39 79 20	 cmp	 DWORD PTR [ecx+32], edi
  00035	75 0b		 jne	 SHORT $LN1@PlayerScor

; 223  :     {
; 224  :       this->m_Rooms[iRoom].btPoints02++;

  00037	fe 41 24	 inc	 BYTE PTR [ecx+36]

; 225  :       this->UpdateDuelScore(iRoom);

  0003a	50		 push	 eax
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?UpdateDuelScore@CDuelManager@@QAEXH@Z ; CDuelManager::UpdateDuelScore
$LN1@PlayerScor:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 226  :     }
; 227  :   }
; 228  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?PlayerScore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CDuelManager::PlayerScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel
; Function compile flags: /Ogtp
;	COMDAT ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpMsgClose$ = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CDuelManager::SendEndDuel, COMDAT
; _this$ = ecx

; 231  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 232  : 
; 233  :   if(lpObj == NULL) return;

  00014	85 f6		 test	 esi, esi
  00016	74 2b		 je	 SHORT $LN3@SendEndDue

; 234  :   if(gObjIsConnected(lpObj->m_Index) == FALSE) return;

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	74 1c		 je	 SHORT $LN3@SendEndDue

; 235  : 
; 236  :   BYTE lpMsgClose[5] = { 0xC1, 0x05, 0xAA, 0x03, 0x00 } ;
; 237  : 
; 238  :   DataSend(lpObj->m_Index, &lpMsgClose[0], lpMsgClose[1]);

  00027	8b 16		 mov	 edx, DWORD PTR [esi]
  00029	6a 05		 push	 5
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR _lpMsgClose$[ebp]
  0002e	51		 push	 ecx
  0002f	52		 push	 edx
  00030	c7 45 f4 c1 05
	aa 03		 mov	 DWORD PTR _lpMsgClose$[ebp], 61474241 ; 03aa05c1H
  00037	c6 45 f8 00	 mov	 BYTE PTR _lpMsgClose$[ebp+4], 0
  0003b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendEndDue:

; 239  : 
; 240  : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	5e		 pop	 esi
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CDuelManager::SendEndDuel
_TEXT	ENDS
PUBLIC	?GetSpectatorCount@CDuelManager@@QAEHH@Z	; CDuelManager::GetSpectatorCount
; Function compile flags: /Ogtp
;	COMDAT ?GetSpectatorCount@CDuelManager@@QAEHH@Z
_TEXT	SEGMENT
_iRoom$ = 8						; size = 4
?GetSpectatorCount@CDuelManager@@QAEHH@Z PROC		; CDuelManager::GetSpectatorCount, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  : 
; 245  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS) 

  00003	8b 55 08	 mov	 edx, DWORD PTR _iRoom$[ebp]
  00006	83 fa 03	 cmp	 edx, 3
  00009	77 5c		 ja	 SHORT $LN5@GetSpectat

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  0000b	6b d2 13	 imul	 edx, 19			; 00000013H
  0000e	33 c0		 xor	 eax, eax
  00010	39 44 91 28	 cmp	 DWORD PTR [ecx+edx*4+40], eax
  00014	74 05		 je	 SHORT $LN3@GetSpectat

; 254  :     {
; 255  :       iCount++;

  00016	b8 01 00 00 00	 mov	 eax, 1
$LN3@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  0001b	83 7c 91 2c 00	 cmp	 DWORD PTR [ecx+edx*4+44], 0
  00020	74 01		 je	 SHORT $LN15@GetSpectat

; 254  :     {
; 255  :       iCount++;

  00022	40		 inc	 eax
$LN15@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  00023	83 7c 91 30 00	 cmp	 DWORD PTR [ecx+edx*4+48], 0
  00028	74 01		 je	 SHORT $LN17@GetSpectat

; 254  :     {
; 255  :       iCount++;

  0002a	40		 inc	 eax
$LN17@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  0002b	83 7c 91 34 00	 cmp	 DWORD PTR [ecx+edx*4+52], 0
  00030	74 01		 je	 SHORT $LN19@GetSpectat

; 254  :     {
; 255  :       iCount++;

  00032	40		 inc	 eax
$LN19@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  00033	83 7c 91 38 00	 cmp	 DWORD PTR [ecx+edx*4+56], 0
  00038	74 01		 je	 SHORT $LN21@GetSpectat

; 254  :     {
; 255  :       iCount++;

  0003a	40		 inc	 eax
$LN21@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  0003b	83 7c 91 3c 00	 cmp	 DWORD PTR [ecx+edx*4+60], 0
  00040	74 01		 je	 SHORT $LN23@GetSpectat

; 254  :     {
; 255  :       iCount++;

  00042	40		 inc	 eax
$LN23@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  00043	83 7c 91 40 00	 cmp	 DWORD PTR [ecx+edx*4+64], 0
  00048	74 01		 je	 SHORT $LN25@GetSpectat

; 254  :     {
; 255  :       iCount++;

  0004a	40		 inc	 eax
$LN25@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  0004b	83 7c 91 44 00	 cmp	 DWORD PTR [ecx+edx*4+68], 0
  00050	74 01		 je	 SHORT $LN27@GetSpectat

; 254  :     {
; 255  :       iCount++;

  00052	40		 inc	 eax
$LN27@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  00053	83 7c 91 48 00	 cmp	 DWORD PTR [ecx+edx*4+72], 0
  00058	74 01		 je	 SHORT $LN29@GetSpectat

; 254  :     {
; 255  :       iCount++;

  0005a	40		 inc	 eax
$LN29@GetSpectat:

; 248  :   }
; 249  : 
; 250  :   int iCount = 0;
; 251  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)
; 252  :   {
; 253  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL) 

  0005b	83 7c 91 4c 00	 cmp	 DWORD PTR [ecx+edx*4+76], 0
  00060	74 08		 je	 SHORT $LN7@GetSpectat

; 254  :     {
; 255  :       iCount++;

  00062	40		 inc	 eax

; 256  :     }
; 257  :   }
; 258  : 
; 259  :   return iCount;
; 260  : 
; 261  : }

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
$LN5@GetSpectat:

; 246  :   {
; 247  :     return -1;

  00067	83 c8 ff	 or	 eax, -1
$LN7@GetSpectat:

; 256  :     }
; 257  :   }
; 258  : 
; 259  :   return iCount;
; 260  : 
; 261  : }

  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?GetSpectatorCount@CDuelManager@@QAEHH@Z ENDP		; CDuelManager::GetSpectatorCount
_TEXT	ENDS
PUBLIC	?RemoveUser@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::RemoveUser
; Function compile flags: /Ogtp
;	COMDAT ?RemoveUser@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?RemoveUser@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CDuelManager::RemoveUser, COMDAT
; _this$ = ecx

; 265  : 
; 266  :   //verificar se faz parte do duel
; 267  :   //verificar se eh da batalha...
; 268  :   // -> se for, finalizar a sala
; 269  :   //resetar informações do duel
; 270  :   //se for um watcher remover interface
; 271  :   //mover para gate 294
; 272  : 
; 273  : }

  00000	c2 04 00	 ret	 4
?RemoveUser@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CDuelManager::RemoveUser
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SendDuelStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendDuelStatus
; Function compile flags: /Ogtp
;	COMDAT ?SendDuelStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -108					; size = 4
_this$ = -104						; size = 4
tv344 = -100						; size = 4
_pMsg$ = -96						; size = 92
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?SendDuelStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDuelManager::SendDuelStatus, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 312  : 
; 313  :     }
; 314  : 
; 315  :   }
; 316  : 
; 317  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b d9		 mov	 ebx, ecx
  00018	6a 58		 push	 88			; 00000058H
  0001a	8d 4d a4	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0001d	6a 00		 push	 0
  0001f	51		 push	 ecx
  00020	89 5d 98	 mov	 DWORD PTR _this$[ebp], ebx
  00023	89 45 94	 mov	 DWORD PTR _lpObj$GSCopy$[ebp], eax
  00026	c7 45 a0 c1 5c
	aa 06		 mov	 DWORD PTR _pMsg$[ebp], 111828161 ; 06aa5cc1H
  0002d	e8 00 00 00 00	 call	 _memset
  00032	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	33 ff		 xor	 edi, edi
  0003a	8d 75 b9	 lea	 esi, DWORD PTR _pMsg$[ebp+25]
  0003d	89 45 9c	 mov	 DWORD PTR tv344[ebp], eax
$LL9@SendDuelSt:

; 288  :   {
; 289  : 
; 290  :     if(this->m_Rooms[i].bFree == FALSE)

  00040	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  00044	75 51		 jne	 SHORT $LN8@SendDuelSt

; 291  :     {
; 292  : 
; 293  :       if(this->m_Rooms[i].lpObj01 == NULL || this->m_Rooms[i].lpObj02 == NULL)

  00046	83 38 00	 cmp	 DWORD PTR [eax], 0
  00049	74 4c		 je	 SHORT $LN8@SendDuelSt
  0004b	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  0004e	85 db		 test	 ebx, ebx
  00050	74 45		 je	 SHORT $LN8@SendDuelSt

; 294  :       {
; 295  :         continue;
; 296  :       }
; 297  : 
; 298  :       pMsg.pRoomStatus[i].btDuelRunning = TRUE;
; 299  : 
; 300  :       int iSpecCount = this->GetSpectatorCount(i);

  00052	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	57		 push	 edi
  00056	c6 46 ff 01	 mov	 BYTE PTR [esi-1], 1
  0005a	e8 00 00 00 00	 call	 ?GetSpectatorCount@CDuelManager@@QAEHH@Z ; CDuelManager::GetSpectatorCount

; 301  :       if(iSpecCount < 0 || iSpecCount >= 10)

  0005f	83 f8 09	 cmp	 eax, 9

; 302  :       {
; 303  :         pMsg.pRoomStatus[i].btDuelOpen = FALSE;
; 304  :       }
; 305  :       else
; 306  :       {
; 307  :         pMsg.pRoomStatus[i].btDuelOpen = TRUE;
; 308  :       }
; 309  : 
; 310  :       memcpy(&pMsg.pRoomStatus[i].szName1[0], &this->m_Rooms[i].lpObj01->Name[0], 10);

  00062	8b 45 9c	 mov	 eax, DWORD PTR tv344[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	0f 96 c2	 setbe	 dl
  0006a	88 16		 mov	 BYTE PTR [esi], dl
  0006c	8b 48 77	 mov	 ecx, DWORD PTR [eax+119]
  0006f	89 4e eb	 mov	 DWORD PTR [esi-21], ecx
  00072	8b 50 7b	 mov	 edx, DWORD PTR [eax+123]
  00075	89 56 ef	 mov	 DWORD PTR [esi-17], edx
  00078	0f b7 40 7f	 movzx	 eax, WORD PTR [eax+127]
  0007c	66 89 46 f3	 mov	 WORD PTR [esi-13], ax

; 311  :       memcpy(&pMsg.pRoomStatus[i].szName2[0], &this->m_Rooms[i].lpObj02->Name[0], 10);

  00080	8b 4b 77	 mov	 ecx, DWORD PTR [ebx+119]
  00083	89 4e f5	 mov	 DWORD PTR [esi-11], ecx
  00086	8b 53 7b	 mov	 edx, DWORD PTR [ebx+123]
  00089	89 56 f9	 mov	 DWORD PTR [esi-7], edx
  0008c	0f b7 43 7f	 movzx	 eax, WORD PTR [ebx+127]
  00090	66 89 46 fd	 mov	 WORD PTR [esi-3], ax
  00094	8b 45 9c	 mov	 eax, DWORD PTR tv344[ebp]
$LN8@SendDuelSt:

; 277  : 
; 278  :   PMSG_DUEL_STATUS pMsg;
; 279  : 
; 280  :   pMsg.h.c = 0xC1;
; 281  :   pMsg.h.size = sizeof(pMsg);
; 282  :   pMsg.h.headcode = 0xAA;
; 283  :   pMsg.h.subcode = 0x06;
; 284  : 
; 285  :   ZeroMemory(&pMsg.pRoomStatus, sizeof(pMsg.pRoomStatus));
; 286  :   
; 287  :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00097	47		 inc	 edi
  00098	83 c0 4c	 add	 eax, 76			; 0000004cH
  0009b	83 c6 16	 add	 esi, 22			; 00000016H
  0009e	89 45 9c	 mov	 DWORD PTR tv344[ebp], eax
  000a1	83 ff 04	 cmp	 edi, 4
  000a4	7c 9a		 jl	 SHORT $LL9@SendDuelSt

; 312  : 
; 313  :     }
; 314  : 
; 315  :   }
; 316  : 
; 317  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  000a6	0f b6 4d a1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000aa	8b 45 94	 mov	 eax, DWORD PTR _lpObj$GSCopy$[ebp]
  000ad	51		 push	 ecx
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	8d 55 a0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000b3	52		 push	 edx
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 318  : 
; 319  : }

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	33 cd		 xor	 ecx, ebp
  000c4	5b		 pop	 ebx
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c2 04 00	 ret	 4
?SendDuelStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDuelManager::SendDuelStatus
_TEXT	ENDS
PUBLIC	?GetFreeRoomIndex@CDuelManager@@QAEHXZ		; CDuelManager::GetFreeRoomIndex
; Function compile flags: /Ogtp
;	COMDAT ?GetFreeRoomIndex@CDuelManager@@QAEHXZ
_TEXT	SEGMENT
?GetFreeRoomIndex@CDuelManager@@QAEHXZ PROC		; CDuelManager::GetFreeRoomIndex, COMDAT
; _this$ = ecx

; 323  :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00000	33 c0		 xor	 eax, eax
  00002	83 c1 14	 add	 ecx, 20			; 00000014H
  00005	ba 01 00 00 00	 mov	 edx, 1
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL5@GetFreeRoo:

; 324  :   {
; 325  :     if(this->m_Rooms[i].bFree == TRUE)

  00010	39 51 fc	 cmp	 DWORD PTR [ecx-4], edx
  00013	75 05		 jne	 SHORT $LN4@GetFreeRoo

; 326  :     {
; 327  :       if(this->m_Rooms[i].bWaiting == FALSE)

  00015	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00018	74 0d		 je	 SHORT $LN6@GetFreeRoo
$LN4@GetFreeRoo:

; 323  :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  0001a	03 c2		 add	 eax, edx
  0001c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001f	83 f8 04	 cmp	 eax, 4
  00022	7c ec		 jl	 SHORT $LL5@GetFreeRoo

; 328  :       {
; 329  :         return i;  
; 330  :       }
; 331  :     }
; 332  :   }
; 333  :   return -1;

  00024	83 c8 ff	 or	 eax, -1
$LN6@GetFreeRoo:

; 334  : }

  00027	c3		 ret	 0
?GetFreeRoomIndex@CDuelManager@@QAEHXZ ENDP		; CDuelManager::GetFreeRoomIndex
_TEXT	ENDS
PUBLIC	?UserDuelInfoReset@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::UserDuelInfoReset
EXTRN	?ReSetTarget@CDarkSpirit@@QAEXH@Z:PROC		; CDarkSpirit::ReSetTarget
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
; Function compile flags: /Ogtp
;	COMDAT ?UserDuelInfoReset@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?UserDuelInfoReset@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDuelManager::UserDuelInfoReset, COMDAT
; _this$ = ecx

; 337  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  :   if(lpObj == NULL) 

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 34		 je	 SHORT $LN2@UserDuelIn

; 339  :   {  
; 340  :     return;
; 341  :   }
; 342  :   lpObj->m_iDuelRoom = -1;

  0000a	83 c9 ff	 or	 ecx, -1
  0000d	89 88 b4 21 00
	00		 mov	 DWORD PTR [eax+8628], ecx

; 343  :   lpObj->m_iDuelUser = -1;

  00013	89 88 b8 0e 00
	00		 mov	 DWORD PTR [eax+3768], ecx

; 344  :   lpObj->m_iDuelUserRequested = -1;

  00019	89 88 b4 0e 00
	00		 mov	 DWORD PTR [eax+3764], ecx

; 345  :   lpObj->m_iDuelUserReserved = -1;

  0001f	89 88 b0 0e 00
	00		 mov	 DWORD PTR [eax+3760], ecx

; 346  :   lpObj->m_btDuelScore = 0;

  00025	c6 80 bc 0e 00
	00 00		 mov	 BYTE PTR [eax+3772], 0

; 347  :   gDarkSpirit[lpObj->m_Index].ReSetTarget(lpObj->m_Index);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00031	50		 push	 eax
  00032	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  00039	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget
$LN2@UserDuelIn:

; 348  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?UserDuelInfoReset@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDuelManager::UserDuelInfoReset
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendEndDuelNotification@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAD1@Z ; CDuelManager::SendEndDuelNotification
; Function compile flags: /Ogtp
;	COMDAT ?SendEndDuelNotification@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAD1@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Winner$ = 12						; size = 4
_Looser$ = 16						; size = 4
?SendEndDuelNotification@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAD1@Z PROC ; CDuelManager::SendEndDuelNotification, COMDAT
; _this$ = ecx

; 415  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _Winner$[ebp]
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _Looser$[ebp]
  00016	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00019	56		 push	 esi

; 416  : 
; 417  :   PMSG_DUEL_FINISH pMsg;
; 418  :   pMsg.h.c = 0xC1;
; 419  :   pMsg.h.size = sizeof(pMsg);
; 420  :   pMsg.h.headcode = 0xAA;
; 421  :   pMsg.h.subcode = 0x0C;
; 422  :   memcpy(pMsg.szWinner, Winner, 10);

  0001a	8b 30		 mov	 esi, DWORD PTR [eax]
  0001c	89 75 e8	 mov	 DWORD PTR _pMsg$[ebp+4], esi
  0001f	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00022	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  00026	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+12], ax

; 423  :   memcpy(pMsg.szLooser, Looser, 10);

  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	89 45 f2	 mov	 DWORD PTR _pMsg$[ebp+14], eax
  0002f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00032	66 8b 49 08	 mov	 cx, WORD PTR [ecx+8]
  00036	89 45 f6	 mov	 DWORD PTR _pMsg$[ebp+18], eax

; 424  : 
; 425  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  00039	6a 18		 push	 24			; 00000018H
  0003b	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003e	66 89 4d fa	 mov	 WORD PTR _pMsg$[ebp+22], cx
  00042	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00044	50		 push	 eax
  00045	51		 push	 ecx
  00046	c7 45 e4 c1 18
	aa 0c		 mov	 DWORD PTR _pMsg$[ebp], 212474049 ; 0caa18c1H
  0004d	89 75 ec	 mov	 DWORD PTR _pMsg$[ebp+8], esi
  00050	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 426  : 
; 427  : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	33 cd		 xor	 ecx, ebp
  0005d	5e		 pop	 esi
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
?SendEndDuelNotification@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAD1@Z ENDP ; CDuelManager::SendEndDuelNotification
_TEXT	ENDS
PUBLIC	_iSpecIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SendSpectatorAdd@CDuelManager@@QAEXHH@Z	; CDuelManager::SendSpectatorAdd
; Function compile flags: /Ogtp
;	COMDAT ?SendSpectatorAdd@CDuelManager@@QAEXHH@Z
_TEXT	SEGMENT
_iSpecIndex$GSCopy$ = -24				; size = 4
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iSpecIndex$ = 8					; size = 4
_iRoom$ = 12						; size = 4
?SendSpectatorAdd@CDuelManager@@QAEXHH@Z PROC		; CDuelManager::SendSpectatorAdd, COMDAT
; _this$ = ecx

; 430  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _iRoom$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _iSpecIndex$[ebp]
  00016	53		 push	 ebx
  00017	8b d9		 mov	 ebx, ecx

; 456  : 
; 457  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  00019	89 55 e8	 mov	 DWORD PTR _iSpecIndex$GSCopy$[ebp], edx
  0001c	83 f8 03	 cmp	 eax, 3
  0001f	77 73		 ja	 SHORT $LN6@SendSpecta

; 431  : 
; 432  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)
; 433  :   {
; 434  :     return;
; 435  :   }
; 436  : 
; 437  :   if(iSpecIndex < 0 || iSpecIndex >= MAX_DUEL_LEARNERS)

  00021	83 fa 09	 cmp	 edx, 9
  00024	77 6e		 ja	 SHORT $LN6@SendSpecta

; 438  :   {
; 439  :     return;
; 440  :   }
; 441  : 
; 442  :   if(this->m_Rooms[iRoom].lpLearners[iSpecIndex] == NULL) return;

  00026	57		 push	 edi
  00027	8b f8		 mov	 edi, eax
  00029	6b ff 13	 imul	 edi, 19			; 00000013H
  0002c	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  0002f	8b 4c 8b 28	 mov	 ecx, DWORD PTR [ebx+ecx*4+40]
  00033	85 c9		 test	 ecx, ecx
  00035	74 5c		 je	 SHORT $LN18@SendSpecta

; 443  : 
; 444  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || 
; 445  :     this->m_Rooms[iRoom].lpObj02 == NULL)

  00037	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0003a	83 7c 18 18 00	 cmp	 DWORD PTR [eax+ebx+24], 0
  0003f	74 52		 je	 SHORT $LN18@SendSpecta
  00041	83 7c 18 20 00	 cmp	 DWORD PTR [eax+ebx+32], 0
  00046	74 4b		 je	 SHORT $LN18@SendSpecta

; 446  :   {
; 447  :     return;
; 448  :   }
; 449  : 
; 450  :   PMSG_DUEL_SPEC_ADD pMsg;
; 451  :   pMsg.h.c = 0xC1;

  00048	c7 45 ec c1 0e
	aa 08		 mov	 DWORD PTR _pMsg$[ebp], 145362625 ; 08aa0ec1H

; 452  :   pMsg.h.size = sizeof(pMsg);
; 453  :   pMsg.h.headcode = 0xAA;
; 454  :   pMsg.h.subcode = 0x08;
; 455  :   memcpy(pMsg.szName, this->m_Rooms[iRoom].lpLearners[iSpecIndex]->Name, 10);

  0004f	8b 41 77	 mov	 eax, DWORD PTR [ecx+119]
  00052	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  00055	8b 41 7b	 mov	 eax, DWORD PTR [ecx+123]
  00058	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0005b	66 8b 49 7f	 mov	 cx, WORD PTR [ecx+127]
  0005f	56		 push	 esi
  00060	66 89 4d f8	 mov	 WORD PTR _pMsg$[ebp+12], cx

; 456  : 
; 457  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  00064	33 f6		 xor	 esi, esi
$LL17@SendSpecta:

; 458  :   {
; 459  :     if(i == iSpecIndex) continue;

  00066	3b f2		 cmp	 esi, edx
  00068	74 22		 je	 SHORT $LN4@SendSpecta

; 460  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL)

  0006a	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0006d	8b 44 83 28	 mov	 eax, DWORD PTR [ebx+eax*4+40]
  00071	85 c0		 test	 eax, eax
  00073	74 17		 je	 SHORT $LN4@SendSpecta

; 461  :     {
; 462  :       DataSend(this->m_Rooms[iRoom].lpLearners[i]->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  00075	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	51		 push	 ecx
  0007c	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00086	8b 55 e8	 mov	 edx, DWORD PTR _iSpecIndex$GSCopy$[ebp]
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendSpecta:

; 456  : 
; 457  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  0008c	46		 inc	 esi
  0008d	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00090	7c d4		 jl	 SHORT $LL17@SendSpecta
  00092	5e		 pop	 esi
$LN18@SendSpecta:
  00093	5f		 pop	 edi
$LN6@SendSpecta:

; 463  :     }
; 464  :   }
; 465  : 
; 466  : }

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	33 cd		 xor	 ecx, ebp
  00099	5b		 pop	 ebx
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 08 00	 ret	 8
?SendSpectatorAdd@CDuelManager@@QAEXHH@Z ENDP		; CDuelManager::SendSpectatorAdd
_TEXT	ENDS
PUBLIC	_iSpecIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?SendSpectatorRemove@CDuelManager@@QAEXHH@Z	; CDuelManager::SendSpectatorRemove
; Function compile flags: /Ogtp
;	COMDAT ?SendSpectatorRemove@CDuelManager@@QAEXHH@Z
_TEXT	SEGMENT
_iSpecIndex$GSCopy$ = -24				; size = 4
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iSpecIndex$ = 8					; size = 4
_iRoom$ = 12						; size = 4
?SendSpectatorRemove@CDuelManager@@QAEXHH@Z PROC	; CDuelManager::SendSpectatorRemove, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _iRoom$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _iSpecIndex$[ebp]
  00016	53		 push	 ebx
  00017	8b d9		 mov	 ebx, ecx

; 495  : 
; 496  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  00019	89 55 e8	 mov	 DWORD PTR _iSpecIndex$GSCopy$[ebp], edx
  0001c	83 f8 03	 cmp	 eax, 3
  0001f	77 73		 ja	 SHORT $LN6@SendSpecta@2

; 470  : 
; 471  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)
; 472  :   {
; 473  :     return;
; 474  :   }
; 475  : 
; 476  :   if(iSpecIndex < 0 || iSpecIndex >= MAX_DUEL_LEARNERS)

  00021	83 fa 09	 cmp	 edx, 9
  00024	77 6e		 ja	 SHORT $LN6@SendSpecta@2

; 477  :   {
; 478  :     return;
; 479  :   }
; 480  : 
; 481  :   if(this->m_Rooms[iRoom].lpLearners[iSpecIndex] == NULL) return;

  00026	57		 push	 edi
  00027	8b f8		 mov	 edi, eax
  00029	6b ff 13	 imul	 edi, 19			; 00000013H
  0002c	8d 0c 17	 lea	 ecx, DWORD PTR [edi+edx]
  0002f	8b 4c 8b 28	 mov	 ecx, DWORD PTR [ebx+ecx*4+40]
  00033	85 c9		 test	 ecx, ecx
  00035	74 5c		 je	 SHORT $LN18@SendSpecta@2

; 482  : 
; 483  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || 
; 484  :     this->m_Rooms[iRoom].lpObj02 == NULL)

  00037	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0003a	83 7c 18 18 00	 cmp	 DWORD PTR [eax+ebx+24], 0
  0003f	74 52		 je	 SHORT $LN18@SendSpecta@2
  00041	83 7c 18 20 00	 cmp	 DWORD PTR [eax+ebx+32], 0
  00046	74 4b		 je	 SHORT $LN18@SendSpecta@2

; 485  :   {
; 486  :     return;
; 487  :   }
; 488  : 
; 489  :   PMSG_DUEL_SPEC_ADD pMsg;
; 490  :   pMsg.h.c = 0xC1;

  00048	c7 45 ec c1 0e
	aa 0a		 mov	 DWORD PTR _pMsg$[ebp], 178917057 ; 0aaa0ec1H

; 491  :   pMsg.h.size = sizeof(pMsg);
; 492  :   pMsg.h.headcode = 0xAA;
; 493  :   pMsg.h.subcode = 0x0A;
; 494  :   memcpy(pMsg.szName, this->m_Rooms[iRoom].lpLearners[iSpecIndex]->Name, 10);

  0004f	8b 41 77	 mov	 eax, DWORD PTR [ecx+119]
  00052	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  00055	8b 41 7b	 mov	 eax, DWORD PTR [ecx+123]
  00058	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0005b	66 8b 49 7f	 mov	 cx, WORD PTR [ecx+127]
  0005f	56		 push	 esi
  00060	66 89 4d f8	 mov	 WORD PTR _pMsg$[ebp+12], cx

; 495  : 
; 496  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  00064	33 f6		 xor	 esi, esi
$LL17@SendSpecta@2:

; 497  :   {
; 498  :     if(i == iSpecIndex) continue;

  00066	3b f2		 cmp	 esi, edx
  00068	74 22		 je	 SHORT $LN4@SendSpecta@2

; 499  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL)

  0006a	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0006d	8b 44 83 28	 mov	 eax, DWORD PTR [ebx+eax*4+40]
  00071	85 c0		 test	 eax, eax
  00073	74 17		 je	 SHORT $LN4@SendSpecta@2

; 500  :     {
; 501  :       DataSend(this->m_Rooms[iRoom].lpLearners[i]->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  00075	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	51		 push	 ecx
  0007c	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00086	8b 55 e8	 mov	 edx, DWORD PTR _iSpecIndex$GSCopy$[ebp]
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendSpecta@2:

; 495  : 
; 496  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  0008c	46		 inc	 esi
  0008d	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00090	7c d4		 jl	 SHORT $LL17@SendSpecta@2
  00092	5e		 pop	 esi
$LN18@SendSpecta@2:
  00093	5f		 pop	 edi
$LN6@SendSpecta@2:

; 502  :     }
; 503  :   }
; 504  : 
; 505  : }

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	33 cd		 xor	 ecx, ebp
  00099	5b		 pop	 ebx
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 08 00	 ret	 8
?SendSpectatorRemove@CDuelManager@@QAEXHH@Z ENDP	; CDuelManager::SendSpectatorRemove
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendSpectatorList@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendSpectatorList
; Function compile flags: /Ogtp
;	COMDAT ?SendSpectatorList@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -112						; size = 105
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iRoom$ = 12						; size = 4
?SendSpectatorList@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z PROC ; CDuelManager::SendSpectatorList, COMDAT
; _this$ = ecx

; 529  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 530  : 
; 531  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)

  00010	8b 55 0c	 mov	 edx, DWORD PTR _iRoom$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00017	83 fa 03	 cmp	 edx, 3
  0001a	0f 87 15 02 00
	00		 ja	 $LN6@SendSpecta@3

; 532  :   {
; 533  :     return;
; 534  :   }
; 535  : 
; 536  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || 
; 537  :     this->m_Rooms[iRoom].lpObj02 == NULL)

  00020	8b c2		 mov	 eax, edx
  00022	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00025	83 7c 08 18 00	 cmp	 DWORD PTR [eax+ecx+24], 0
  0002a	56		 push	 esi
  0002b	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0002e	0f 84 00 02 00
	00		 je	 $LN35@SendSpecta@3
  00034	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00038	0f 84 f6 01 00
	00		 je	 $LN35@SendSpecta@3

; 538  :   {
; 539  :     return;
; 540  :   }
; 541  : 
; 542  :   PMSG_DUEL_SPEC_LIST pMsg;
; 543  :   pMsg.h.c = 0xC1;
; 544  :   pMsg.h.headcode = 0xAA;
; 545  :   pMsg.h.subcode = 0x0B;
; 546  :   pMsg.btCount = 0;

  0003e	32 c0		 xor	 al, al

; 547  : 
; 548  :   if(this->m_Rooms[iRoom].bFree == FALSE)

  00040	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00044	c6 45 90 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00048	66 c7 45 92 aa
	0b		 mov	 WORD PTR _pMsg$[ebp+2], 2986 ; 00000baaH
  0004e	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00051	0f 85 bb 01 00
	00		 jne	 $LN34@SendSpecta@3

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  00057	6b d2 13	 imul	 edx, 19			; 00000013H
  0005a	8b 74 91 28	 mov	 esi, DWORD PTR [ecx+edx*4+40]
  0005e	57		 push	 edi
  0005f	85 f6		 test	 esi, esi
  00061	74 19		 je	 SHORT $LN3@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  00063	b0 01		 mov	 al, 1
  00065	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00068	8b 7e 77	 mov	 edi, DWORD PTR [esi+119]
  0006b	89 7d 95	 mov	 DWORD PTR _pMsg$[ebp+5], edi
  0006e	8b 7e 7b	 mov	 edi, DWORD PTR [esi+123]
  00071	89 7d 99	 mov	 DWORD PTR _pMsg$[ebp+9], edi
  00074	66 8b 76 7f	 mov	 si, WORD PTR [esi+127]
  00078	66 89 75 9d	 mov	 WORD PTR _pMsg$[ebp+13], si
$LN3@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  0007c	8b 74 91 2c	 mov	 esi, DWORD PTR [ecx+edx*4+44]
  00080	85 f6		 test	 esi, esi
  00082	74 25		 je	 SHORT $LN18@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  00084	0f b6 f8	 movzx	 edi, al
  00087	fe c0		 inc	 al
  00089	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0008c	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  0008f	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  00092	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  00096	89 07		 mov	 DWORD PTR [edi], eax
  00098	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  0009b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0009e	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  000a2	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  000a6	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN18@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  000a9	8b 74 91 30	 mov	 esi, DWORD PTR [ecx+edx*4+48]
  000ad	85 f6		 test	 esi, esi
  000af	74 25		 je	 SHORT $LN20@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  000b1	0f b6 f8	 movzx	 edi, al
  000b4	fe c0		 inc	 al
  000b6	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  000b9	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  000bc	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  000bf	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  000c3	89 07		 mov	 DWORD PTR [edi], eax
  000c5	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  000c8	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000cb	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  000cf	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  000d3	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN20@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  000d6	8b 74 91 34	 mov	 esi, DWORD PTR [ecx+edx*4+52]
  000da	85 f6		 test	 esi, esi
  000dc	74 25		 je	 SHORT $LN22@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  000de	0f b6 f8	 movzx	 edi, al
  000e1	fe c0		 inc	 al
  000e3	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  000e6	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  000e9	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  000ec	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  000f0	89 07		 mov	 DWORD PTR [edi], eax
  000f2	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  000f5	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000f8	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  000fc	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  00100	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN22@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  00103	8b 74 91 38	 mov	 esi, DWORD PTR [ecx+edx*4+56]
  00107	85 f6		 test	 esi, esi
  00109	74 25		 je	 SHORT $LN24@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  0010b	0f b6 f8	 movzx	 edi, al
  0010e	fe c0		 inc	 al
  00110	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00113	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  00116	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  00119	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  0011d	89 07		 mov	 DWORD PTR [edi], eax
  0011f	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  00122	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00125	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  00129	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  0012d	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN24@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  00130	8b 74 91 3c	 mov	 esi, DWORD PTR [ecx+edx*4+60]
  00134	85 f6		 test	 esi, esi
  00136	74 25		 je	 SHORT $LN26@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  00138	0f b6 f8	 movzx	 edi, al
  0013b	fe c0		 inc	 al
  0013d	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00140	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  00143	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  00146	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  0014a	89 07		 mov	 DWORD PTR [edi], eax
  0014c	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  0014f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00152	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  00156	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  0015a	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN26@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  0015d	8b 74 91 40	 mov	 esi, DWORD PTR [ecx+edx*4+64]
  00161	85 f6		 test	 esi, esi
  00163	74 25		 je	 SHORT $LN28@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  00165	0f b6 f8	 movzx	 edi, al
  00168	fe c0		 inc	 al
  0016a	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0016d	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  00170	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  00173	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  00177	89 07		 mov	 DWORD PTR [edi], eax
  00179	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  0017c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0017f	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  00183	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  00187	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN28@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  0018a	8b 74 91 44	 mov	 esi, DWORD PTR [ecx+edx*4+68]
  0018e	85 f6		 test	 esi, esi
  00190	74 25		 je	 SHORT $LN30@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  00192	0f b6 f8	 movzx	 edi, al
  00195	fe c0		 inc	 al
  00197	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0019a	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  0019d	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  001a0	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  001a4	89 07		 mov	 DWORD PTR [edi], eax
  001a6	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  001a9	89 47 04	 mov	 DWORD PTR [edi+4], eax
  001ac	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  001b0	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  001b4	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN30@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  001b7	8b 74 91 48	 mov	 esi, DWORD PTR [ecx+edx*4+72]
  001bb	85 f6		 test	 esi, esi
  001bd	74 25		 je	 SHORT $LN32@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  001bf	0f b6 f8	 movzx	 edi, al
  001c2	fe c0		 inc	 al
  001c4	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  001c7	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  001ca	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  001cd	8d 7c 7d 95	 lea	 edi, DWORD PTR _pMsg$[ebp+edi*2+5]
  001d1	89 07		 mov	 DWORD PTR [edi], eax
  001d3	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  001d6	89 47 04	 mov	 DWORD PTR [edi+4], eax
  001d9	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  001dd	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  001e1	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN32@SendSpecta@3:

; 549  :   {
; 550  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)
; 551  :     {
; 552  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  001e4	8b 4c 91 4c	 mov	 ecx, DWORD PTR [ecx+edx*4+76]
  001e8	5f		 pop	 edi
  001e9	85 c9		 test	 ecx, ecx
  001eb	74 25		 je	 SHORT $LN34@SendSpecta@3

; 553  :       {
; 554  :         memcpy(&pMsg.szName[pMsg.btCount++][0], this->m_Rooms[iRoom].lpLearners[u]->Name, 10);

  001ed	0f b6 d0	 movzx	 edx, al
  001f0	fe c0		 inc	 al
  001f2	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al
  001f5	8b 41 77	 mov	 eax, DWORD PTR [ecx+119]
  001f8	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  001fb	8d 54 55 95	 lea	 edx, DWORD PTR _pMsg$[ebp+edx*2+5]
  001ff	89 02		 mov	 DWORD PTR [edx], eax
  00201	8b 41 7b	 mov	 eax, DWORD PTR [ecx+123]
  00204	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00207	66 8b 49 7f	 mov	 cx, WORD PTR [ecx+127]
  0020b	66 89 4a 08	 mov	 WORD PTR [edx+8], cx
  0020f	8a 45 94	 mov	 al, BYTE PTR _pMsg$[ebp+4]
$LN34@SendSpecta@3:

; 555  :       }
; 556  :     }
; 557  :   }
; 558  : 
; 559  :   pMsg.h.size = 5 + (pMsg.btCount * 10);

  00212	8a d0		 mov	 dl, al
  00214	02 d2		 add	 dl, dl
  00216	02 d2		 add	 dl, dl
  00218	02 c2		 add	 al, dl

; 560  : 
; 561  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  0021a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0021c	02 c0		 add	 al, al
  0021e	04 05		 add	 al, 5
  00220	88 45 91	 mov	 BYTE PTR _pMsg$[ebp+1], al
  00223	0f b6 c0	 movzx	 eax, al
  00226	50		 push	 eax
  00227	8d 4d 90	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0022a	51		 push	 ecx
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00231	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@SendSpecta@3:
  00234	5e		 pop	 esi
$LN6@SendSpecta@3:

; 562  : 
; 563  : }

  00235	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00238	33 cd		 xor	 ecx, ebp
  0023a	5b		 pop	 ebx
  0023b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c2 08 00	 ret	 8
?SendSpectatorList@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ENDP ; CDuelManager::SendSpectatorList
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__$ArrayPad$
PUBLIC	?SendLifebarStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendLifebarStatus
EXTRN	__fltused:DWORD
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SendLifebarStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv377 = -24						; size = 4
tv375 = -24						; size = 4
tv367 = -24						; size = 4
tv200 = -24						; size = 4
tv379 = -18						; size = 2
tv370 = -18						; size = 2
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iRoom$ = 12						; size = 4
?SendLifebarStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z PROC ; CDuelManager::SendLifebarStatus, COMDAT
; _this$ = ecx

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _iRoom$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 594  : 
; 595  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)

  00017	83 f8 03	 cmp	 eax, 3
  0001a	0f 87 15 01 00
	00		 ja	 $LN1@SendLifeba

; 596  :   {
; 597  :     return;
; 598  :   }
; 599  : 
; 600  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || 
; 601  :     this->m_Rooms[iRoom].lpObj02 == NULL)

  00020	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00023	03 c1		 add	 eax, ecx
  00025	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00029	0f 84 06 01 00
	00		 je	 $LN1@SendLifeba
  0002f	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00033	0f 84 fc 00 00
	00		 je	 $LN1@SendLifeba

; 602  :   {
; 603  :     return;
; 604  :   }
; 605  : 
; 606  :   PMSG_DUEL_LIFEBAR_REFILL pMsg;
; 607  :   pMsg.h.c = 0xC1;
; 608  :   pMsg.h.size = sizeof(pMsg);
; 609  :   pMsg.h.headcode = 0xAA;
; 610  :   pMsg.h.subcode = 0x05;
; 611  : 
; 612  :   pMsg.btObjId01H = HIBYTE(this->m_Rooms[iRoom].lpObj01->m_Index);

  00039	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 613  :   pMsg.btObjId01L = LOBYTE(this->m_Rooms[iRoom].lpObj01->m_Index);
; 614  : 
; 615  :   pMsg.btObjId02H = HIBYTE(this->m_Rooms[iRoom].lpObj02->m_Index);
; 616  :   pMsg.btObjId02L = LOBYTE(this->m_Rooms[iRoom].lpObj02->m_Index);
; 617  : 
; 618  :   pMsg.btLife01 = (BYTE)(this->m_Rooms[iRoom].lpObj01->Life / ((this->m_Rooms[iRoom].lpObj01->MaxLife + this->m_Rooms[iRoom].lpObj01->AddLife) / 100));

  0003c	d9 7d ee	 fnstcw	 WORD PTR tv379[ebp]
  0003f	c7 45 f0 c1 0c
	aa 05		 mov	 DWORD PTR _pMsg$[ebp], 95030465 ; 05aa0cc1H
  00046	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0004a	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  0004d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00050	88 55 f5	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00053	53		 push	 ebx
  00054	56		 push	 esi
  00055	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  00058	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0005c	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+6], al
  0005f	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00062	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+7], dl
  00065	0f b7 45 ee	 movzx	 eax, WORD PTR tv379[ebp]
  00069	db 81 4c 01 00
	00		 fild	 DWORD PTR [ecx+332]
  0006f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00074	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  0007a	89 45 e8	 mov	 DWORD PTR tv377[ebp], eax
  0007d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4059000000000000

; 619  :   pMsg.btLife02 = (BYTE)(this->m_Rooms[iRoom].lpObj02->Life / ((this->m_Rooms[iRoom].lpObj02->MaxLife + this->m_Rooms[iRoom].lpObj02->AddLife) / 100));
; 620  : 
; 621  :   pMsg.btShield01 = this->m_Rooms[iRoom].lpObj01->iShield / ((this->m_Rooms[iRoom].lpObj01->iMaxShield + this->m_Rooms[iRoom].lpObj01->iAddShield) / 100);
; 622  :   pMsg.btShield02 = this->m_Rooms[iRoom].lpObj02->iShield / ((this->m_Rooms[iRoom].lpObj02->iMaxShield + this->m_Rooms[iRoom].lpObj02->iAddShield) / 100);
; 623  : 
; 624  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  00083	6a 0c		 push	 12			; 0000000cH
  00085	dc f9		 fdiv	 ST(1), ST(0)
  00087	d9 c9		 fxch	 ST(1)
  00089	d8 b9 fc 00 00
	00		 fdivr	 DWORD PTR [ecx+252]
  0008f	d9 6d e8	 fldcw	 WORD PTR tv377[ebp]
  00092	db 5d e8	 fistp	 DWORD PTR tv375[ebp]
  00095	0f b6 45 e8	 movzx	 eax, BYTE PTR tv375[ebp]
  00099	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+8], al
  0009c	d9 6d ee	 fldcw	 WORD PTR tv379[ebp]
  0009f	db 86 4c 01 00
	00		 fild	 DWORD PTR [esi+332]
  000a5	d9 7d ee	 fnstcw	 WORD PTR tv370[ebp]
  000a8	d8 86 00 01 00
	00		 fadd	 DWORD PTR [esi+256]
  000ae	0f b7 45 ee	 movzx	 eax, WORD PTR tv370[ebp]
  000b2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000b7	89 45 e8	 mov	 DWORD PTR tv367[ebp], eax
  000ba	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000bf	de f1		 fdivrp	 ST(1), ST(0)
  000c1	d8 be fc 00 00
	00		 fdivr	 DWORD PTR [esi+252]
  000c7	d9 6d e8	 fldcw	 WORD PTR tv367[ebp]
  000ca	db 5d e8	 fistp	 DWORD PTR tv200[ebp]
  000cd	0f b6 55 e8	 movzx	 edx, BYTE PTR tv200[ebp]
  000d1	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+9], dl
  000d4	8b 91 5c 01 00
	00		 mov	 edx, DWORD PTR [ecx+348]
  000da	03 91 58 01 00
	00		 add	 edx, DWORD PTR [ecx+344]
  000e0	d9 6d ee	 fldcw	 WORD PTR tv370[ebp]
  000e3	f7 ea		 imul	 edx
  000e5	8b 81 54 01 00
	00		 mov	 eax, DWORD PTR [ecx+340]
  000eb	c1 fa 05	 sar	 edx, 5
  000ee	8b da		 mov	 ebx, edx
  000f0	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  000f3	03 da		 add	 ebx, edx
  000f5	99		 cdq
  000f6	f7 fb		 idiv	 ebx
  000f8	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+10], al
  000fb	8b 8e 5c 01 00
	00		 mov	 ecx, DWORD PTR [esi+348]
  00101	03 8e 58 01 00
	00		 add	 ecx, DWORD PTR [esi+344]
  00107	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0010c	f7 e9		 imul	 ecx
  0010e	8b 86 54 01 00
	00		 mov	 eax, DWORD PTR [esi+340]
  00114	c1 fa 05	 sar	 edx, 5
  00117	8b ca		 mov	 ecx, edx
  00119	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0011c	03 ca		 add	 ecx, edx
  0011e	99		 cdq
  0011f	f7 f9		 idiv	 ecx
  00121	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00124	52		 push	 edx
  00125	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+11], al
  00128	8b 07		 mov	 eax, DWORD PTR [edi]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	5e		 pop	 esi
  00134	5b		 pop	 ebx
$LN1@SendLifeba:

; 625  : 
; 626  : }

  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	33 cd		 xor	 ecx, ebp
  0013a	5f		 pop	 edi
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 08 00	 ret	 8
?SendLifebarStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ENDP ; CDuelManager::SendLifebarStatus
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendLifebarInit@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendLifebarInit
; Function compile flags: /Ogtp
;	COMDAT ?SendLifebarInit@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 5
_pMsg2$ = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iRoom$ = 12						; size = 4
?SendLifebarInit@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z PROC ; CDuelManager::SendLifebarInit, COMDAT
; _this$ = ecx

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _iRoom$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 630  : 
; 631  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)

  00017	83 f8 03	 cmp	 eax, 3
  0001a	0f 87 93 00 00
	00		 ja	 $LN1@SendLifeba@2

; 632  :   {
; 633  :     return;
; 634  :   }
; 635  : 
; 636  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || 
; 637  :     this->m_Rooms[iRoom].lpObj02 == NULL)

  00020	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00023	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  00026	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 82 00 00
	00		 je	 $LN1@SendLifeba@2
  00031	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00034	85 c9		 test	 ecx, ecx
  00036	74 7b		 je	 SHORT $LN1@SendLifeba@2

; 638  :   {
; 639  :     return;
; 640  :   }
; 641  : 
; 642  :   PMSG_DUEL_LIFEBAR_NAME pMsg2;
; 643  :   pMsg2.h.c = 0xC1;

  00038	c7 45 dc c1 1e
	aa 07		 mov	 DWORD PTR _pMsg2$[ebp], 128589505 ; 07aa1ec1H
  0003f	57		 push	 edi

; 644  :   pMsg2.h.size = sizeof(pMsg2);
; 645  :   pMsg2.h.headcode = 0xAA;
; 646  :   pMsg2.h.subcode = 0x07;
; 647  :   pMsg2.Type = 0x00;

  00040	33 ff		 xor	 edi, edi
  00042	66 89 7d e0	 mov	 WORD PTR _pMsg2$[ebp+4], di

; 648  :   
; 649  :   memcpy(pMsg2.szName1, this->m_Rooms[iRoom].lpObj01->Name, 10);

  00046	8b 78 77	 mov	 edi, DWORD PTR [eax+119]
  00049	89 7d e2	 mov	 DWORD PTR _pMsg2$[ebp+6], edi
  0004c	8b 78 7b	 mov	 edi, DWORD PTR [eax+123]
  0004f	89 7d e6	 mov	 DWORD PTR _pMsg2$[ebp+10], edi
  00052	66 8b 40 7f	 mov	 ax, WORD PTR [eax+127]
  00056	66 89 45 ea	 mov	 WORD PTR _pMsg2$[ebp+14], ax

; 650  :   memcpy(pMsg2.szName2, this->m_Rooms[iRoom].lpObj02->Name, 10);

  0005a	8b 41 77	 mov	 eax, DWORD PTR [ecx+119]
  0005d	89 45 ec	 mov	 DWORD PTR _pMsg2$[ebp+16], eax
  00060	8b 41 7b	 mov	 eax, DWORD PTR [ecx+123]
  00063	89 45 f0	 mov	 DWORD PTR _pMsg2$[ebp+20], eax
  00066	66 8b 49 7f	 mov	 cx, WORD PTR [ecx+127]

; 651  : 
; 652  :   pMsg2.btObjId1H = HIBYTE(this->m_Rooms[iRoom].lpObj01->m_Index);

  0006a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]

; 653  :   pMsg2.btObjId1L = LOBYTE(this->m_Rooms[iRoom].lpObj01->m_Index);
; 654  : 
; 655  :   pMsg2.btObjId2H = HIBYTE(this->m_Rooms[iRoom].lpObj02->m_Index);

  0006d	8b 52 20	 mov	 edx, DWORD PTR [edx+32]
  00070	66 89 4d f4	 mov	 WORD PTR _pMsg2$[ebp+24], cx
  00074	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00078	88 4d f6	 mov	 BYTE PTR _pMsg2$[ebp+26], cl
  0007b	8a 00		 mov	 al, BYTE PTR [eax]
  0007d	88 45 f7	 mov	 BYTE PTR _pMsg2$[ebp+27], al
  00080	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  00084	88 4d f8	 mov	 BYTE PTR _pMsg2$[ebp+28], cl

; 656  :   pMsg2.btObjId2L = LOBYTE(this->m_Rooms[iRoom].lpObj02->m_Index);
; 657  : 
; 658  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg2, pMsg2.h.size);

  00087	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00089	8a 12		 mov	 dl, BYTE PTR [edx]
  0008b	6a 1e		 push	 30			; 0000001eH
  0008d	8d 45 dc	 lea	 eax, DWORD PTR _pMsg2$[ebp]
  00090	50		 push	 eax
  00091	51		 push	 ecx
  00092	88 55 f9	 mov	 BYTE PTR _pMsg2$[ebp+29], dl
  00095	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 659  : 
; 660  :   PMSG_DUEL_LIFEBAR_INIT pMsg;
; 661  :   pMsg.h.c = 0xC1;
; 662  :   pMsg.h.size = sizeof(pMsg);
; 663  :   pMsg.h.headcode = 0xAA;
; 664  :   pMsg.h.subcode = 0x0D;
; 665  : 
; 666  :   DataSend(lpObj->m_Index, (BYTE*)&pMsg, pMsg.h.size);

  0009a	8b 06		 mov	 eax, DWORD PTR [esi]
  0009c	6a 05		 push	 5
  0009e	8d 55 d4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000a1	52		 push	 edx
  000a2	50		 push	 eax
  000a3	c7 45 d4 c1 05
	aa 0d		 mov	 DWORD PTR _pMsg$[ebp], 229246401 ; 0daa05c1H
  000aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000af	83 c4 18	 add	 esp, 24			; 00000018H
  000b2	5f		 pop	 edi
$LN1@SendLifeba@2:

; 667  : 
; 668  : }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5e		 pop	 esi
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 08 00	 ret	 8
?SendLifebarInit@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ENDP ; CDuelManager::SendLifebarInit
_TEXT	ENDS
PUBLIC	?IsDuelEnable@CDuelManager@@QAE_NH@Z		; CDuelManager::IsDuelEnable
; Function compile flags: /Ogtp
;	COMDAT ?IsDuelEnable@CDuelManager@@QAE_NH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?IsDuelEnable@CDuelManager@@QAE_NH@Z PROC		; CDuelManager::IsDuelEnable, COMDAT
; _this$ = ecx

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1259 : 
; 1260 :   if ( OBJMAX_RANGE(aIndex ) == FALSE)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 39		 js	 SHORT $LN1@IsDuelEnab
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax

; 1261 :   {
; 1262 :     return false;

  00018	74 2a		 je	 SHORT $LN1@IsDuelEnab

; 1263 :   }
; 1264 : 
; 1265 :   if ( gObjIsConnected(aIndex) == TRUE )

  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00020	83 c4 04	 add	 esp, 4
  00023	83 f8 01	 cmp	 eax, 1
  00026	75 1c		 jne	 SHORT $LN1@IsDuelEnab

; 1266 :   {
; 1267 :     if ( ( gObj[aIndex].m_Option & 2 ) == 2 )

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00033	f6 84 06 8c 0e
	00 00 02	 test	 BYTE PTR [esi+eax+3724], 2
  0003b	74 07		 je	 SHORT $LN1@IsDuelEnab

; 1268 :     {
; 1269 :       return true;

  0003d	b0 01		 mov	 al, 1
  0003f	5e		 pop	 esi

; 1274 : 
; 1275 : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN1@IsDuelEnab:

; 1270 :     }
; 1271 :   }
; 1272 : 
; 1273 :   return false;

  00044	32 c0		 xor	 al, al
  00046	5e		 pop	 esi

; 1274 : 
; 1275 : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?IsDuelEnable@CDuelManager@@QAE_NH@Z ENDP		; CDuelManager::IsDuelEnable
_TEXT	ENDS
PUBLIC	?SetDuelOption@CDuelManager@@QAEXHH@Z		; CDuelManager::SetDuelOption
; Function compile flags: /Ogtp
;	COMDAT ?SetDuelOption@CDuelManager@@QAEXHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_bState$ = 12						; size = 4
?SetDuelOption@CDuelManager@@QAEXHH@Z PROC		; CDuelManager::SetDuelOption, COMDAT
; _this$ = ecx

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1279 :   if ( gObjIsConnected(lpObj) == TRUE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	83 f8 01	 cmp	 eax, 1
  00013	75 36		 jne	 SHORT $LN1@SetDuelOpt

; 1280 :   {
; 1281 :     if ( bState == 0 )
; 1282 :     {
; 1283 :       gObj[lpObj].m_Option = 0;

  00015	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001b	83 7d 0c 00	 cmp	 DWORD PTR _bState$[ebp], 0
  0001f	75 15		 jne	 SHORT $LN2@SetDuelOpt
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	c7 84 06 8c 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+3724], 0
  00031	5e		 pop	 esi

; 1288 :     }
; 1289 :   }
; 1290 : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
$LN2@SetDuelOpt:

; 1284 :     }
; 1285 :     else
; 1286 :     {
; 1287 :       gObj[lpObj].m_Option |= 2;

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	83 8c 0e 8c 0e
	00 00 02	 or	 DWORD PTR [esi+ecx+3724], 2
  00044	8d 84 0e 8c 0e
	00 00		 lea	 eax, DWORD PTR [esi+ecx+3724]
$LN1@SetDuelOpt:
  0004b	5e		 pop	 esi

; 1288 :     }
; 1289 :   }
; 1290 : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?SetDuelOption@CDuelManager@@QAEXHH@Z ENDP		; CDuelManager::SetDuelOption
_TEXT	ENDS
PUBLIC	?IsOnDuel@CDuelManager@@QAE_NH@Z		; CDuelManager::IsOnDuel
; Function compile flags: /Ogtp
;	COMDAT ?IsOnDuel@CDuelManager@@QAE_NH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?IsOnDuel@CDuelManager@@QAE_NH@Z PROC			; CDuelManager::IsOnDuel, COMDAT
; _this$ = ecx

; 1293 : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1294 : 
; 1295 :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000c	56		 push	 esi
  0000d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00013	33 d2		 xor	 edx, edx
  00015	03 f0		 add	 esi, eax
  00017	8d 41 20	 lea	 eax, DWORD PTR [ecx+32]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@IsOnDuel:

; 1296 :   {
; 1297 :     if(this->m_Rooms[i].lpObj01 == &gObj[lpObj])

  00020	39 70 f8	 cmp	 DWORD PTR [eax-8], esi
  00023	74 14		 je	 SHORT $LN9@IsOnDuel

; 1300 :     }
; 1301 :     if(this->m_Rooms[i].lpObj02 == &gObj[lpObj]) 

  00025	39 30		 cmp	 DWORD PTR [eax], esi
  00027	74 10		 je	 SHORT $LN9@IsOnDuel

; 1294 : 
; 1295 :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00029	42		 inc	 edx
  0002a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0002d	83 fa 04	 cmp	 edx, 4
  00030	7c ee		 jl	 SHORT $LL5@IsOnDuel

; 1302 :     {
; 1303 :       return true;
; 1304 :     }
; 1305 :   }
; 1306 : 
; 1307 :   return false;

  00032	32 c0		 xor	 al, al
  00034	5e		 pop	 esi

; 1308 : 
; 1309 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN9@IsOnDuel:

; 1298 :     {
; 1299 :       return true;

  00039	b0 01		 mov	 al, 1
  0003b	5e		 pop	 esi

; 1308 : 
; 1309 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?IsOnDuel@CDuelManager@@QAE_NH@Z ENDP			; CDuelManager::IsOnDuel
_TEXT	ENDS
PUBLIC	?IsOnDuel@CDuelManager@@QAE_NHH@Z		; CDuelManager::IsOnDuel
; Function compile flags: /Ogtp
;	COMDAT ?IsOnDuel@CDuelManager@@QAE_NHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpObj2$ = 12						; size = 4
?IsOnDuel@CDuelManager@@QAE_NHH@Z PROC			; CDuelManager::IsOnDuel, COMDAT
; _this$ = ecx

; 1312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1313 : 
; 1314 :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
$LL14@IsOnDuel@2:

; 1315 :   {
; 1316 : 
; 1317 :     if(this->m_Rooms[i].bFree == FALSE)

  00011	83 78 f8 00	 cmp	 DWORD PTR [eax-8], 0
  00015	75 35		 jne	 SHORT $LN5@IsOnDuel@2

; 1318 :     {
; 1319 : 
; 1320 :       if(this->m_Rooms[i].lpObj01 == &gObj[lpObj] && 
; 1321 :         this->m_Rooms[i].lpObj02 == &gObj[lpObj2]) 

  00017	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00022	03 d6		 add	 edx, esi
  00024	3b ca		 cmp	 ecx, edx
  00026	75 10		 jne	 SHORT $LN2@IsOnDuel@2
  00028	8b 5d 0c	 mov	 ebx, DWORD PTR _lpObj2$[ebp]
  0002b	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00031	03 de		 add	 ebx, esi
  00033	39 58 08	 cmp	 DWORD PTR [eax+8], ebx
  00036	74 26		 je	 SHORT $LN10@IsOnDuel@2
$LN2@IsOnDuel@2:

; 1324 :       }
; 1325 : 
; 1326 :       if(this->m_Rooms[i].lpObj01 == &gObj[lpObj2] && 
; 1327 :         this->m_Rooms[i].lpObj02 == &gObj[lpObj]) 

  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _lpObj2$[ebp]
  0003b	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00041	03 de		 add	 ebx, esi
  00043	3b cb		 cmp	 ecx, ebx
  00045	75 05		 jne	 SHORT $LN5@IsOnDuel@2
  00047	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  0004a	74 12		 je	 SHORT $LN10@IsOnDuel@2
$LN5@IsOnDuel@2:

; 1313 : 
; 1314 :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  0004c	47		 inc	 edi
  0004d	83 c0 4c	 add	 eax, 76			; 0000004cH
  00050	83 ff 04	 cmp	 edi, 4
  00053	7c bc		 jl	 SHORT $LL14@IsOnDuel@2

; 1328 :       {
; 1329 :         return true;
; 1330 :       }
; 1331 : 
; 1332 :     }
; 1333 : 
; 1334 :   }
; 1335 : 
; 1336 :   return false;

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	32 c0		 xor	 al, al
  00059	5b		 pop	 ebx

; 1337 : 
; 1338 : }

  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
$LN10@IsOnDuel@2:
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 1322 :       {
; 1323 :         return true;

  00060	b0 01		 mov	 al, 1
  00062	5b		 pop	 ebx

; 1337 : 
; 1338 : }

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
?IsOnDuel@CDuelManager@@QAE_NHH@Z ENDP			; CDuelManager::IsOnDuel
_TEXT	ENDS
PUBLIC	?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z	; CDuelManager::SetBuff
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjApplyBuffEffectDuration
; Function compile flags: /Ogtp
;	COMDAT ?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpUser$ = 8						; size = 4
_bUse$ = 12						; size = 4
?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z PROC	; CDuelManager::SetBuff, COMDAT
; _this$ = ecx

; 1341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1342 : 	if( bUse )

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bUse$[ebp], 0
  00007	56		 push	 esi

; 1343 : 	{
; 1344 : 		gObjApplyBuffEffectDuration(lpUser, 18, 0, 0, 0, 0, -10);

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpUser$[ebp]
  0000b	74 32		 je	 SHORT $LN1@SetBuff
  0000d	6a f6		 push	 -10			; fffffff6H
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	6a 12		 push	 18			; 00000012H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjApplyBuffEffectDuration

; 1345 : 		gObjApplyBuffEffectDuration(lpUser, 98, 0, 0, 0, 0, -10);

  0001f	6a f6		 push	 -10			; fffffff6H
  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	6a 62		 push	 98			; 00000062H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjApplyBuffEffectDuration

; 1346 : 		gObjViewportListProtocolDestroy(lpUser);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  00037	83 c4 3c	 add	 esp, 60			; 0000003cH
  0003a	5e		 pop	 esi

; 1353 : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN1@SetBuff:

; 1347 : 		return;
; 1348 : 	}
; 1349 : 
; 1350 : 	gObjRemoveBuffEffect(lpUser, 18);

  0003f	6a 12		 push	 18			; 00000012H
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 1351 : 	gObjRemoveBuffEffect(lpUser, 98);

  00047	6a 62		 push	 98			; 00000062H
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 1352 : 	gObjViewportListProtocolCreate(lpUser);

  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	5e		 pop	 esi

; 1353 : }

  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ENDP	; CDuelManager::SetBuff
_TEXT	ENDS
PUBLIC	?DuelCheck@CDuelManager@@QAE_NPAUOBJECTSTRUCT@@0@Z ; CDuelManager::DuelCheck
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\duelmanager.h
;	COMDAT ?DuelCheck@CDuelManager@@QAE_NPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpObj2$ = 12						; size = 4
?DuelCheck@CDuelManager@@QAE_NPAUOBJECTSTRUCT@@0@Z PROC	; CDuelManager::DuelCheck, COMDAT
; _this$ = ecx

; 232  :   bool DuelCheck(LPOBJ lpObj, LPOBJ lpObj2) { return this->IsOnDuel(lpObj->m_Index, lpObj2->m_Index); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpObj2$[ebp]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000b	52		 push	 edx
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ?IsOnDuel@CDuelManager@@QAE_NHH@Z ; CDuelManager::IsOnDuel
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
?DuelCheck@CDuelManager@@QAE_NPAUOBJECTSTRUCT@@0@Z ENDP	; CDuelManager::DuelCheck
_TEXT	ENDS
PUBLIC	??_C@_0CH@OPDCOOJL@?$FLDuel?5Manager?$FN?5Room?5Reset?5?9?5Numb@ ; `string'
PUBLIC	?RoomReset@CDuelManager@@QAEXH_N0@Z		; CDuelManager::RoomReset
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
;	COMDAT ??_C@_0CH@OPDCOOJL@?$FLDuel?5Manager?$FN?5Room?5Reset?5?9?5Numb@
; File e:\work\tranet_version\gs\gameserver\duelmanager.cpp
CONST	SEGMENT
??_C@_0CH@OPDCOOJL@?$FLDuel?5Manager?$FN?5Room?5Reset?5?9?5Numb@ DB '[Due'
	DB	'l Manager] Room Reset - Number: %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RoomReset@CDuelManager@@QAEXH_N0@Z
_TEXT	SEGMENT
_iRoom$ = 8						; size = 4
_dontMove$ = 12						; size = 1
tv276 = 16						; size = 4
_dontSendEnd$ = 16					; size = 1
?RoomReset@CDuelManager@@QAEXH_N0@Z PROC		; CDuelManager::RoomReset, COMDAT
; _this$ = ecx

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 352  : 
; 353  :   if(this->m_Rooms[iRoom].lpObj01 != NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _iRoom$[ebp]
  00008	6b f6 4c	 imul	 esi, 76			; 0000004cH
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b 44 1e 18	 mov	 eax, DWORD PTR [esi+ebx+24]
  00011	03 f3		 add	 esi, ebx
  00013	57		 push	 edi
  00014	85 c0		 test	 eax, eax
  00016	74 4f		 je	 SHORT $LN14@RoomReset

; 354  :   {
; 355  :     if(gObjIsConnected(this->m_Rooms[iRoom].lpObj01->m_Index))

  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	74 35		 je	 SHORT $LN10@RoomReset

; 356  :     {
; 357  :       if(dontSendEnd == false)

  00027	80 7d 10 00	 cmp	 BYTE PTR _dontSendEnd$[ebp], 0
  0002b	75 0b		 jne	 SHORT $LN12@RoomReset

; 358  :         this->SendEndDuel(this->m_Rooms[iRoom].lpObj01);

  0002d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00030	52		 push	 edx
  00031	8b cb		 mov	 ecx, ebx
  00033	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel
$LN12@RoomReset:

; 359  :       if(this->m_Rooms[iRoom].lpObj01->MapNumber == MAP_INDEX_VULCANROOM)

  00038	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0003b	80 b8 49 01 00
	00 40		 cmp	 BYTE PTR [eax+329], 64	; 00000040H
  00042	75 18		 jne	 SHORT $LN10@RoomReset

; 360  :       {
; 361  :         if(dontMove == false)

  00044	80 7d 0c 00	 cmp	 BYTE PTR _dontMove$[ebp], 0
  00048	75 12		 jne	 SHORT $LN10@RoomReset

; 362  :           gObjMoveGate(this->m_Rooms[iRoom].lpObj01->m_Index, ZtConfig.PvP.DuelGate);

  0004a	8b 0d 40 09 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2368
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00059	83 c4 08	 add	 esp, 8
$LN10@RoomReset:

; 363  :       }
; 364  :     }
; 365  :     this->UserDuelInfoReset(this->m_Rooms[iRoom].lpObj01);

  0005c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0005f	50		 push	 eax
  00060	8b cb		 mov	 ecx, ebx
  00062	e8 00 00 00 00	 call	 ?UserDuelInfoReset@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::UserDuelInfoReset
$LN14@RoomReset:

; 366  :   }
; 367  : 
; 368  :   if(this->m_Rooms[iRoom].lpObj02 != NULL)

  00067	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0006a	85 c0		 test	 eax, eax
  0006c	74 4f		 je	 SHORT $LN9@RoomReset

; 369  :   {
; 370  :     if(gObjIsConnected(this->m_Rooms[iRoom].lpObj02->m_Index))

  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00076	83 c4 04	 add	 esp, 4
  00079	85 c0		 test	 eax, eax
  0007b	74 35		 je	 SHORT $LN5@RoomReset

; 371  :     {
; 372  :       if(dontSendEnd == false)

  0007d	80 7d 10 00	 cmp	 BYTE PTR _dontSendEnd$[ebp], 0
  00081	75 0b		 jne	 SHORT $LN7@RoomReset

; 373  :         this->SendEndDuel(this->m_Rooms[iRoom].lpObj02);

  00083	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00086	52		 push	 edx
  00087	8b cb		 mov	 ecx, ebx
  00089	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel
$LN7@RoomReset:

; 374  :       if(this->m_Rooms[iRoom].lpObj02->MapNumber == MAP_INDEX_VULCANROOM)

  0008e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00091	80 b8 49 01 00
	00 40		 cmp	 BYTE PTR [eax+329], 64	; 00000040H
  00098	75 18		 jne	 SHORT $LN5@RoomReset

; 375  :       {
; 376  :         if(dontMove == false)

  0009a	80 7d 0c 00	 cmp	 BYTE PTR _dontMove$[ebp], 0
  0009e	75 12		 jne	 SHORT $LN5@RoomReset

; 377  :           gObjMoveGate(this->m_Rooms[iRoom].lpObj02->m_Index, ZtConfig.PvP.DuelGate);

  000a0	8b 0d 40 09 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2368
  000a6	8b 10		 mov	 edx, DWORD PTR [eax]
  000a8	51		 push	 ecx
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000af	83 c4 08	 add	 esp, 8
$LN5@RoomReset:

; 378  :       }
; 379  :     }
; 380  :     this->UserDuelInfoReset(this->m_Rooms[iRoom].lpObj02);

  000b2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000b5	50		 push	 eax
  000b6	8b cb		 mov	 ecx, ebx
  000b8	e8 00 00 00 00	 call	 ?UserDuelInfoReset@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::UserDuelInfoReset
$LN9@RoomReset:

; 381  :   }
; 382  : 
; 383  :   for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  000bd	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
  000c0	c7 45 10 0a 00
	00 00		 mov	 DWORD PTR tv276[ebp], 10 ; 0000000aH
$LL4@RoomReset:

; 384  :   {
; 385  :     if(this->m_Rooms[iRoom].lpLearners[i] != NULL)

  000c7	8b 07		 mov	 eax, DWORD PTR [edi]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	3b c1		 cmp	 eax, ecx
  000cd	74 2a		 je	 SHORT $LN1@RoomReset

; 386  :     {
; 387  :       this->SendEndDuel(this->m_Rooms[iRoom].lpLearners[i]);

  000cf	50		 push	 eax
  000d0	8b cb		 mov	 ecx, ebx
  000d2	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel

; 388  :      // GCStateInfoSend(this->m_Rooms[iRoom].lpLearners[i], 0, eVS_INVISIBLE);
; 389  :      // GCStateInfoSend(this->m_Rooms[iRoom].lpLearners[i], 0, eVS_TRANSPARENCY);
; 390  :      // GCStateInfoSend(this->m_Rooms[iRoom].lpLearners[i], 0, eVS_DUEL_INTERFACE);
; 391  : 	  this->SetBuff(this->m_Rooms[iRoom].lpLearners[i], FALSE);

  000d7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d9	6a 00		 push	 0
  000db	51		 push	 ecx
  000dc	8b cb		 mov	 ecx, ebx
  000de	e8 00 00 00 00	 call	 ?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SetBuff

; 392  :       gObjMoveGate(this->m_Rooms[iRoom].lpLearners[i]->m_Index, ZtConfig.PvP.DuelGate);

  000e3	8b 15 40 09 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2368
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	52		 push	 edx
  000ee	51		 push	 ecx
  000ef	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000f4	83 c4 08	 add	 esp, 8
  000f7	33 c9		 xor	 ecx, ecx
$LN1@RoomReset:

; 393  :     }
; 394  :     this->m_Rooms[iRoom].lpLearners[i] = NULL;

  000f9	89 0f		 mov	 DWORD PTR [edi], ecx
  000fb	83 c7 04	 add	 edi, 4
  000fe	ff 4d 10	 dec	 DWORD PTR tv276[ebp]
  00101	75 c4		 jne	 SHORT $LL4@RoomReset

; 395  :   }
; 396  : 
; 397  :   this->m_Rooms[iRoom].lpObj01 = NULL;
; 398  :   this->m_Rooms[iRoom].btPoints01 = 0;
; 399  : 
; 400  :   this->m_Rooms[iRoom].lpObj02 = NULL;
; 401  :   this->m_Rooms[iRoom].btPoints02 = 0;
; 402  : 
; 403  :   this->m_Rooms[iRoom].bFree = TRUE;
; 404  :   this->m_Rooms[iRoom].bWaiting = FALSE;
; 405  :   this->m_Rooms[iRoom].bHasWinner = FALSE;
; 406  : 
; 407  :   this->m_Rooms[iRoom].dwTickCount = 0;
; 408  :   this->m_Rooms[iRoom].dwStartTime = 0;
; 409  : 
; 410  :   LogAddTD("[Duel Manager] Room Reset - Number: %d", iRoom + 1);

  00103	8b 55 08	 mov	 edx, DWORD PTR _iRoom$[ebp]
  00106	42		 inc	 edx
  00107	52		 push	 edx
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OPDCOOJL@?$FLDuel?5Manager?$FN?5Room?5Reset?5?9?5Numb@
  0010d	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00110	c6 46 1c 00	 mov	 BYTE PTR [esi+28], 0
  00114	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00117	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  0011b	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1
  00122	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  00125	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00128	89 4e 50	 mov	 DWORD PTR [esi+80], ecx
  0012b	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00134	83 c4 08	 add	 esp, 8
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx

; 411  : 
; 412  : }

  0013a	5d		 pop	 ebp
  0013b	c2 0c 00	 ret	 12			; 0000000cH
?RoomReset@CDuelManager@@QAEXH_N0@Z ENDP		; CDuelManager::RoomReset
_TEXT	ENDS
PUBLIC	?SendSpectatorList@CDuelManager@@QAEXH@Z	; CDuelManager::SendSpectatorList
; Function compile flags: /Ogtp
;	COMDAT ?SendSpectatorList@CDuelManager@@QAEXH@Z
_TEXT	SEGMENT
_iRoom$ = 8						; size = 4
?SendSpectatorList@CDuelManager@@QAEXH@Z PROC		; CDuelManager::SendSpectatorList, COMDAT
; _this$ = ecx

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 509  : 
; 510  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _iRoom$[ebp]
  00009	83 f9 03	 cmp	 ecx, 3
  0000c	77 31		 ja	 SHORT $LN6@SendSpecta@4

; 511  :   {
; 512  :     return;
; 513  :   }
; 514  : 
; 515  :   if(this->m_Rooms[iRoom].bFree == FALSE)

  0000e	8b c1		 mov	 eax, ecx
  00010	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00013	83 7c 18 10 00	 cmp	 DWORD PTR [eax+ebx+16], 0
  00018	75 25		 jne	 SHORT $LN6@SendSpecta@4

; 516  :   {
; 517  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)

  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8d 74 18 28	 lea	 esi, DWORD PTR [eax+ebx+40]
  00020	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL12@SendSpecta@4:

; 518  :     {
; 519  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 0c		 je	 SHORT $LN3@SendSpecta@4

; 520  :       {
; 521  :         this->SendSpectatorList(this->m_Rooms[iRoom].lpLearners[u], iRoom);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	8b cb		 mov	 ecx, ebx
  0002f	e8 00 00 00 00	 call	 ?SendSpectatorList@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendSpectatorList
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _iRoom$[ebp]
$LN3@SendSpecta@4:

; 516  :   {
; 517  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)

  00037	83 c6 04	 add	 esi, 4
  0003a	4f		 dec	 edi
  0003b	75 e8		 jne	 SHORT $LL12@SendSpecta@4
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
$LN6@SendSpecta@4:
  0003f	5b		 pop	 ebx

; 522  :       }
; 523  :     }
; 524  :   }
; 525  : 
; 526  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?SendSpectatorList@CDuelManager@@QAEXH@Z ENDP		; CDuelManager::SendSpectatorList
_TEXT	ENDS
PUBLIC	?SendLifebarStatus@CDuelManager@@QAEXH@Z	; CDuelManager::SendLifebarStatus
; Function compile flags: /Ogtp
;	COMDAT ?SendLifebarStatus@CDuelManager@@QAEXH@Z
_TEXT	SEGMENT
_iRoom$ = 8						; size = 4
?SendLifebarStatus@CDuelManager@@QAEXH@Z PROC		; CDuelManager::SendLifebarStatus, COMDAT
; _this$ = ecx

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 567  : 
; 568  :   if(iRoom < 0 || iRoom >= MAX_DUEL_ROOMS)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _iRoom$[ebp]
  00009	83 f9 03	 cmp	 ecx, 3
  0000c	77 3d		 ja	 SHORT $LN6@SendLifeba@3

; 569  :   {
; 570  :     return;
; 571  :   }
; 572  : 
; 573  :   if(this->m_Rooms[iRoom].lpObj01 == NULL || 
; 574  :     this->m_Rooms[iRoom].lpObj02 == NULL)

  0000e	8b c1		 mov	 eax, ecx
  00010	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00013	03 c3		 add	 eax, ebx
  00015	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00019	74 30		 je	 SHORT $LN6@SendLifeba@3
  0001b	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0001f	74 2a		 je	 SHORT $LN6@SendLifeba@3

; 575  :   {
; 576  :     return;
; 577  :   }
; 578  : 
; 579  :   if(this->m_Rooms[iRoom].bFree == FALSE)

  00021	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00025	75 24		 jne	 SHORT $LN6@SendLifeba@3

; 580  :   {
; 581  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)

  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	8d 70 28	 lea	 esi, DWORD PTR [eax+40]
  0002c	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL14@SendLifeba@3:

; 582  :     {
; 583  :       if(this->m_Rooms[iRoom].lpLearners[u] != NULL)

  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	85 c0		 test	 eax, eax
  00035	74 0c		 je	 SHORT $LN3@SendLifeba@3

; 584  :       {
; 585  :         this->SendLifebarStatus(this->m_Rooms[iRoom].lpLearners[u], iRoom);

  00037	51		 push	 ecx
  00038	50		 push	 eax
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?SendLifebarStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendLifebarStatus
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _iRoom$[ebp]
$LN3@SendLifeba@3:

; 580  :   {
; 581  :     for(int u = 0; u < MAX_DUEL_LEARNERS; u++)

  00043	83 c6 04	 add	 esi, 4
  00046	4f		 dec	 edi
  00047	75 e8		 jne	 SHORT $LL14@SendLifeba@3
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
$LN6@SendLifeba@3:
  0004b	5b		 pop	 ebx

; 586  :       }
; 587  :     }
; 588  :   }
; 589  : 
; 590  : }

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?SendLifebarStatus@CDuelManager@@QAEXH@Z ENDP		; CDuelManager::SendLifebarStatus
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?KillUserProc@CDuelManager@@QAEXPAUOBJECTSTRUCT@@0@Z ; CDuelManager::KillUserProc
EXTRN	?DuelWin@CAchievements@@QAEXH@Z:PROC		; CAchievements::DuelWin
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	__imp__wsprintfA:PROC
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@
; File e:\work\tranet_version\gs\gameserver\duelmanager.h
CONST	SEGMENT
??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@ DB '['
	DB	'Duel] [%s][%s] Win Duel, Loser [%s][%s]', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\duelmanager.cpp
CONST	ENDS
;	COMDAT ?KillUserProc@CDuelManager@@QAEXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv233 = -272						; size = 4
_ServerCmd$216619 = -268				; size = 7
_szMsg$216618 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTarget$ = 12						; size = 4
?KillUserProc@CDuelManager@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; CDuelManager::KillUserProc, COMDAT
; _this$ = ecx

; 671  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _lpTarget$[ebp]

; 672  :     
; 673  :   if(!this->DuelCheck(lpObj, lpTarget)) return;

  0001c	8b 07		 mov	 eax, DWORD PTR [edi]
  0001e	8b d9		 mov	 ebx, ecx
  00020	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	8b cb		 mov	 ecx, ebx
  00026	e8 00 00 00 00	 call	 ?IsOnDuel@CDuelManager@@QAE_NHH@Z ; CDuelManager::IsOnDuel
  0002b	84 c0		 test	 al, al
  0002d	0f 84 92 01 00
	00		 je	 $LN1@KillUserPr

; 674  :   
; 675  :   int iDuelRoom = this->GetUserDuelRoom(lpObj);

  00033	56		 push	 esi
  00034	8b cb		 mov	 ecx, ebx
  00036	e8 00 00 00 00	 call	 ?GetUserDuelRoom@CDuelManager@@QAEHPAUOBJECTSTRUCT@@@Z ; CDuelManager::GetUserDuelRoom

; 676  :   if(iDuelRoom == -1)

  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	0f 84 81 01 00
	00		 je	 $LN1@KillUserPr

; 677  :   {
; 678  :     return;
; 679  :   }
; 680  : 
; 681  :   lpTarget->KillerType = 3;
; 682  : 
; 683  :   int Points = ((lpObj == this->m_Rooms[iDuelRoom].lpObj01) ? this->m_Rooms[iDuelRoom].btPoints01 : this->m_Rooms[iDuelRoom].btPoints02);

  00044	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00047	03 c3		 add	 eax, ebx
  00049	c6 87 a1 03 00
	00 03		 mov	 BYTE PTR [edi+929], 3
  00050	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv233[ebp], eax
  00056	3b 70 18	 cmp	 esi, DWORD PTR [eax+24]
  00059	75 05		 jne	 SHORT $LN6@KillUserPr
  0005b	8a 48 1c	 mov	 cl, BYTE PTR [eax+28]
  0005e	eb 03		 jmp	 SHORT $LN7@KillUserPr
$LN6@KillUserPr:
  00060	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
$LN7@KillUserPr:

; 684  :   if(Points >= DUEL_WIN_POINT_COUNT)

  00063	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00066	0f 82 59 01 00
	00		 jb	 $LN1@KillUserPr

; 685  :   {
; 686  : 
; 687  :     this->m_Rooms[iDuelRoom].bHasWinner = TRUE;
; 688  : 
; 689  :     this->SendEndDuel(lpTarget);

  0006c	57		 push	 edi
  0006d	8b cb		 mov	 ecx, ebx
  0006f	c7 40 58 01 00
	00 00		 mov	 DWORD PTR [eax+88], 1
  00076	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel

; 690  :     this->SendEndDuel(lpObj);

  0007b	56		 push	 esi
  0007c	8b cb		 mov	 ecx, ebx
  0007e	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel

; 691  : 
; 692  :     this->SendEndDuelNotification(lpTarget, lpObj->Name, lpTarget->Name);

  00083	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  00086	50		 push	 eax
  00087	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0008a	51		 push	 ecx
  0008b	57		 push	 edi
  0008c	8b cb		 mov	 ecx, ebx
  0008e	e8 00 00 00 00	 call	 ?SendEndDuelNotification@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAD1@Z ; CDuelManager::SendEndDuelNotification

; 693  :     this->SendEndDuelNotification(lpObj, lpObj->Name, lpTarget->Name);

  00093	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  00096	50		 push	 eax
  00097	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0009a	50		 push	 eax
  0009b	56		 push	 esi
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?SendEndDuelNotification@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAD1@Z ; CDuelManager::SendEndDuelNotification

; 694  : 
; 695  :     gDarkSpirit[lpObj->m_Index].ReSetTarget(lpTarget->m_Index);

  000a3	8b 06		 mov	 eax, DWORD PTR [esi]
  000a5	8b 17		 mov	 edx, DWORD PTR [edi]
  000a7	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000aa	52		 push	 edx
  000ab	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  000b2	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 696  :     gDarkSpirit[lpTarget->m_Index].ReSetTarget(lpObj->m_Index);

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	50		 push	 eax
  000ba	8b 07		 mov	 eax, DWORD PTR [edi]
  000bc	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000bf	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  000c6	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 697  : 
; 698  :     char szMsg[256];
; 699  : 
; 700  :     wsprintf(szMsg,lMsg.Get(1216),lpTarget->Name);

  000cb	8d 5f 77	 lea	 ebx, DWORD PTR [edi+119]
  000ce	53		 push	 ebx
  000cf	68 c0 04 00 00	 push	 1216			; 000004c0H
  000d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000de	50		 push	 eax
  000df	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$216618[ebp]
  000e5	51		 push	 ecx
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 701  :     GCServerMsgStringSend(szMsg,lpObj->m_Index,1);

  000ec	8b 16		 mov	 edx, DWORD PTR [esi]
  000ee	6a 01		 push	 1
  000f0	52		 push	 edx
  000f1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$216618[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000fd	83 c4 18	 add	 esp, 24			; 00000018H

; 702  : 
; 703  :     wsprintf(szMsg,lMsg.Get(1217),lpObj->Name);

  00100	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00103	50		 push	 eax
  00104	68 c1 04 00 00	 push	 1217			; 000004c1H
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0010e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00113	50		 push	 eax
  00114	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$216618[ebp]
  0011a	51		 push	 ecx
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 704  :     GCServerMsgStringSend(szMsg,lpTarget->m_Index,1);

  00121	8b 17		 mov	 edx, DWORD PTR [edi]
  00123	6a 01		 push	 1
  00125	52		 push	 edx
  00126	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$216618[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 705  : 
; 706  :     PMSG_SERVERCMD ServerCmd;
; 707  : 
; 708  :     PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00132	6a 07		 push	 7
  00134	6a 40		 push	 64			; 00000040H
  00136	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$216619[ebp]
  0013c	68 f3 00 00 00	 push	 243			; 000000f3H
  00141	51		 push	 ecx
  00142	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 709  :     ServerCmd.CmdType = 0;
; 710  :     ServerCmd.X = lpObj->X;

  00147	8a 96 44 01 00
	00		 mov	 dl, BYTE PTR [esi+324]

; 711  :     ServerCmd.Y = lpObj->Y;

  0014d	8a 86 46 01 00
	00		 mov	 al, BYTE PTR [esi+326]

; 712  : 
; 713  :     MsgSendV2(lpObj,(unsigned char *)&ServerCmd,sizeof(ServerCmd));

  00153	6a 07		 push	 7
  00155	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$216619[ebp]
  0015b	51		 push	 ecx
  0015c	56		 push	 esi
  0015d	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$216619[ebp+4], 0
  00164	88 95 f9 fe ff
	ff		 mov	 BYTE PTR _ServerCmd$216619[ebp+5], dl
  0016a	88 85 fa fe ff
	ff		 mov	 BYTE PTR _ServerCmd$216619[ebp+6], al
  00170	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 714  : 	
; 715  :     DataSend(lpObj->m_Index,(unsigned char *)&ServerCmd,sizeof(ServerCmd));

  00175	6a 07		 push	 7
  00177	8b 06		 mov	 eax, DWORD PTR [esi]
  00179	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _ServerCmd$216619[ebp]
  0017f	52		 push	 edx
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00186	83 c4 40	 add	 esp, 64			; 00000040H

; 716  : 
; 717  :    // gObjUseSkill.AddOrRemoveBuff(eVS_DUEL_MEDAL, lpObj->m_Index, TRUE);
; 718  : 
; 719  :     this->m_Rooms[iDuelRoom].dwTickCount = GetTickCount() + 10000;

  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0018f	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv233[ebp]
  00195	05 10 27 00 00	 add	 eax, 10000		; 00002710H

; 720  : 
; 721  :     LogAdd("[Duel] [%s][%s] Win Duel, Loser [%s][%s]",lpObj->AccountID,lpObj->Name,lpTarget->AccountID,lpTarget->Name);

  0019a	53		 push	 ebx
  0019b	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  0019e	83 c7 6c	 add	 edi, 108		; 0000006cH
  001a1	57		 push	 edi
  001a2	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  001a5	50		 push	 eax
  001a6	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  001a9	52		 push	 edx
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser?5@
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 722  : 
; 723  : #if(SYSTEM_ACHIEVEMENTS)
; 724  : 	g_Achievements.DuelWin(lpObj->m_Index);

  001b5	8b 06		 mov	 eax, DWORD PTR [esi]
  001b7	83 c4 14	 add	 esp, 20			; 00000014H
  001ba	50		 push	 eax
  001bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  001c0	e8 00 00 00 00	 call	 ?DuelWin@CAchievements@@QAEXH@Z ; CAchievements::DuelWin
$LN1@KillUserPr:

; 725  : #endif
; 726  : 
; 727  :   }
; 728  : 
; 729  : }

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c8	5f		 pop	 edi
  001c9	5e		 pop	 esi
  001ca	33 cd		 xor	 ecx, ebp
  001cc	5b		 pop	 ebx
  001cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d2	8b e5		 mov	 esp, ebp
  001d4	5d		 pop	 ebp
  001d5	c2 08 00	 ret	 8
?KillUserProc@CDuelManager@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CDuelManager::KillUserProc
_TEXT	ENDS
PUBLIC	??_C@_0CP@JDCEHNOG@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Wrong?5ro@ ; `string'
PUBLIC	??_C@_0BE@HOCMEGF@Unable?5to?5move?5you?4?$AA@	; `string'
PUBLIC	??_C@_0BK@NJJAOGJG@You?5are?5now?5in?5room?5duel?4?$AA@ ; `string'
PUBLIC	??_C@_0EA@FFLNNFDL@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@ ; `string'
PUBLIC	??_C@_0DH@ELLBEPOK@The?5duel?5that?5you?5are?5trying?5to?5@ ; `string'
PUBLIC	??_C@_0EE@FAHDMNGE@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@ ; `string'
PUBLIC	??_C@_0DK@EPBGNKJN@There?5is?5no?5one?5in?5the?5duel?5that@ ; `string'
PUBLIC	?RecvWatchRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_WATCH@@@Z ; CDuelManager::RecvWatchRequest
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0CP@JDCEHNOG@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Wrong?5ro@
CONST	SEGMENT
??_C@_0CP@JDCEHNOG@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Wrong?5ro@ DB '['
	DB	'Duel Manager] (%s)(%s) Wrong room index! (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HOCMEGF@Unable?5to?5move?5you?4?$AA@
CONST	SEGMENT
??_C@_0BE@HOCMEGF@Unable?5to?5move?5you?4?$AA@ DB 'Unable to move you.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NJJAOGJG@You?5are?5now?5in?5room?5duel?4?$AA@
CONST	SEGMENT
??_C@_0BK@NJJAOGJG@You?5are?5now?5in?5room?5duel?4?$AA@ DB 'You are now i'
	DB	'n room duel.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FFLNNFDL@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@
CONST	SEGMENT
??_C@_0EA@FFLNNFDL@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@ DB '['
	DB	'Duel Manager] (%s)(%s) Watch request error: room is full! (%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ELLBEPOK@The?5duel?5that?5you?5are?5trying?5to?5@
CONST	SEGMENT
??_C@_0DH@ELLBEPOK@The?5duel?5that?5you?5are?5trying?5to?5@ DB 'The duel '
	DB	'that you are trying to watch is already full.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FAHDMNGE@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@
CONST	SEGMENT
??_C@_0EE@FAHDMNGE@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@ DB '['
	DB	'Duel Manager] (%s)(%s) Watch request error: wrong duel state!'
	DB	' (%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EPBGNKJN@There?5is?5no?5one?5in?5the?5duel?5that@
CONST	SEGMENT
??_C@_0DK@EPBGNKJN@There?5is?5no?5one?5in?5the?5duel?5that@ DB 'There is '
	DB	'no one in the duel that you are trying to watch.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RecvWatchRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_WATCH@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?RecvWatchRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_WATCH@@@Z PROC ; CDuelManager::RecvWatchRequest, COMDAT
; _this$ = ecx

; 755  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 756  : 
; 757  :   if(lpObj->m_IfState.use == 0 || lpObj->m_IfState.type != 20) 

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00008	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0000e	8b d9		 mov	 ebx, ecx
  00010	a8 03		 test	 al, 3
  00012	0f 84 85 01 00
	00		 je	 $LN8@RecvWatchR
  00018	8b c8		 mov	 ecx, eax
  0001a	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00020	81 f9 00 05 00
	00		 cmp	 ecx, 1280		; 00000500H
  00026	0f 85 71 01 00
	00		 jne	 $LN8@RecvWatchR

; 758  :   {
; 759  :     return;
; 760  :   }
; 761  : 
; 762  :   lpObj->m_IfState.use = 0;
; 763  :   lpObj->m_IfState.type = 0;

  0002c	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  00031	57		 push	 edi

; 764  : 
; 765  :   if(lpMsg->btRoomIndex >= 0 && lpMsg->btRoomIndex < MAX_DUEL_ROOMS)

  00032	8b 7d 0c	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00035	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax
  0003b	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  0003e	3c 04		 cmp	 al, 4
  00040	0f 83 3a 01 00
	00		 jae	 $LN7@RecvWatchR

; 766  :   {
; 767  : 
; 768  :     if(this->m_Rooms[lpMsg->btRoomIndex].bFree == TRUE) 

  00046	0f b6 c8	 movzx	 ecx, al
  00049	8b c1		 mov	 eax, ecx
  0004b	6b c0 4c	 imul	 eax, 76			; 0000004cH
  0004e	03 c3		 add	 eax, ebx
  00050	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00054	75 33		 jne	 SHORT $LN6@RecvWatchR

; 769  :     {
; 770  :       GCServerMsgStringSend("There is no one in the duel that you are trying to watch.", lpObj->m_Index, 1);

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	6a 01		 push	 1
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EPBGNKJN@There?5is?5no?5one?5in?5the?5duel?5that@
  00060	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 771  :       LogAddC(2, "[Duel Manager] (%s)(%s) Watch request error: wrong duel state! (%d)", lpObj->AccountID, lpObj->Name, lpMsg->btRoomIndex);

  00065	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00069	51		 push	 ecx
  0006a	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  0006d	52		 push	 edx
  0006e	83 c6 6c	 add	 esi, 108		; 0000006cH
  00071	56		 push	 esi
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@FAHDMNGE@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@
  00077	6a 02		 push	 2
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0007f	83 c4 20	 add	 esp, 32			; 00000020H
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 812  : 
; 813  : }

  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
$LN6@RecvWatchR:

; 772  :       return;
; 773  :     }
; 774  : 
; 775  :     for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  00089	33 ff		 xor	 edi, edi
  0008b	83 c0 28	 add	 eax, 40			; 00000028H
  0008e	8b ff		 npad	 2
$LL5@RecvWatchR:

; 776  :     {
; 777  :       if(this->m_Rooms[lpMsg->btRoomIndex].lpLearners[i] == NULL)

  00090	83 38 00	 cmp	 DWORD PTR [eax], 0
  00093	74 3f		 je	 SHORT $LN13@RecvWatchR

; 772  :       return;
; 773  :     }
; 774  : 
; 775  :     for(int i = 0; i < MAX_DUEL_LEARNERS; i++)

  00095	47		 inc	 edi
  00096	83 c0 04	 add	 eax, 4
  00099	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  0009c	7c f2		 jl	 SHORT $LL5@RecvWatchR

; 800  :         return;
; 801  :       }
; 802  :     }
; 803  : 
; 804  :     GCServerMsgStringSend("The duel that you are trying to watch is already full.", lpObj->m_Index, 1);

  0009e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a0	6a 01		 push	 1
  000a2	51		 push	 ecx
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ELLBEPOK@The?5duel?5that?5you?5are?5trying?5to?5@
  000a8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 805  :     LogAddC(2, "[Duel Manager] (%s)(%s) Watch request error: room is full! (%d)", lpObj->AccountID, lpObj->Name, lpMsg->btRoomIndex);

  000ad	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000b0	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000b4	50		 push	 eax
  000b5	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  000b8	51		 push	 ecx
  000b9	83 c6 6c	 add	 esi, 108		; 0000006cH
  000bc	56		 push	 esi
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@FFLNNFDL@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Watch?5re@
  000c2	6a 02		 push	 2
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000ca	83 c4 20	 add	 esp, 32			; 00000020H
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx

; 812  : 
; 813  : }

  000d0	5d		 pop	 ebp
  000d1	c2 08 00	 ret	 8
$LN13@RecvWatchR:

; 778  :       {
; 779  : #if(DEBUG_FIX_DUEL)
; 780  : 		  gObjTeleport(lpObj->m_Index, MAP_INDEX_VULCANROOM, g_DuelRespawns[i].
; 781  : #else
; 782  :         if(gObjMoveGate(lpObj->m_Index, g_DuelGates[lpMsg->btRoomIndex].LearnerGate))

  000d4	8b 16		 mov	 edx, DWORD PTR [esi]
  000d6	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  000d9	8b 0c 85 08 00
	00 00		 mov	 ecx, DWORD PTR _g_DuelGates[eax*4+8]
  000e0	51		 push	 ecx
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000e7	83 c4 08	 add	 esp, 8
  000ea	85 c0		 test	 eax, eax
  000ec	74 79		 je	 SHORT $LN1@RecvWatchR

; 783  : #endif
; 784  :         {
; 785  :           this->m_Rooms[lpMsg->btRoomIndex].lpLearners[i] = lpObj;

  000ee	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000f1	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000f5	6b c9 13	 imul	 ecx, 19			; 00000013H
  000f8	03 cf		 add	 ecx, edi
  000fa	89 74 8b 28	 mov	 DWORD PTR [ebx+ecx*4+40], esi

; 786  :           this->SendSpectatorList(lpObj, lpMsg->btRoomIndex);

  000fe	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00102	52		 push	 edx
  00103	56		 push	 esi
  00104	8b cb		 mov	 ecx, ebx
  00106	e8 00 00 00 00	 call	 ?SendSpectatorList@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendSpectatorList

; 787  :           this->SendSpectatorAdd(i, lpMsg->btRoomIndex);

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0010e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00112	51		 push	 ecx
  00113	57		 push	 edi
  00114	8b cb		 mov	 ecx, ebx
  00116	e8 00 00 00 00	 call	 ?SendSpectatorAdd@CDuelManager@@QAEXHH@Z ; CDuelManager::SendSpectatorAdd

; 788  :           GCServerMsgStringSend("You are now in room duel.", lpObj->m_Index, 1);

  0011b	8b 16		 mov	 edx, DWORD PTR [esi]
  0011d	6a 01		 push	 1
  0011f	52		 push	 edx
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NJJAOGJG@You?5are?5now?5in?5room?5duel?4?$AA@
  00125	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 789  :          // GCStateInfoSend(lpObj, 1, eVS_DUEL_INTERFACE);
; 790  :          // GCStateInfoSend(lpObj, 1, eVS_TRANSPARENCY);
; 791  :           //GCStateInfoSend(lpObj, 1, eVS_INVISIBLE, TRUE, TRUE);
; 792  : 		  this->SetBuff(lpObj, TRUE);

  0012d	6a 01		 push	 1
  0012f	56		 push	 esi
  00130	8b cb		 mov	 ecx, ebx
  00132	e8 00 00 00 00	 call	 ?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SetBuff

; 793  : 
; 794  :           this->SendLifebarInit(lpObj, lpMsg->btRoomIndex);

  00137	8b 7d 0c	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0013a	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0013e	50		 push	 eax
  0013f	56		 push	 esi
  00140	8b cb		 mov	 ecx, ebx
  00142	e8 00 00 00 00	 call	 ?SendLifebarInit@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendLifebarInit

; 795  :           this->SendLifebarStatus(lpObj, lpMsg->btRoomIndex);

  00147	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0014b	51		 push	 ecx
  0014c	56		 push	 esi
  0014d	8b cb		 mov	 ecx, ebx
  0014f	e8 00 00 00 00	 call	 ?SendLifebarStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SendLifebarStatus

; 796  :           this->UpdateDuelScore(lpMsg->btRoomIndex);

  00154	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00158	52		 push	 edx
  00159	8b cb		 mov	 ecx, ebx
  0015b	e8 00 00 00 00	 call	 ?UpdateDuelScore@CDuelManager@@QAEXH@Z ; CDuelManager::UpdateDuelScore
  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx

; 812  : 
; 813  : }

  00163	5d		 pop	 ebp
  00164	c2 08 00	 ret	 8
$LN1@RecvWatchR:

; 797  :           return;
; 798  :         }      
; 799  :         GCServerMsgStringSend("Unable to move you.", lpObj->m_Index, 1);

  00167	8b 06		 mov	 eax, DWORD PTR [esi]
  00169	6a 01		 push	 1
  0016b	50		 push	 eax
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HOCMEGF@Unable?5to?5move?5you?4?$AA@
  00171	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	5b		 pop	 ebx

; 812  : 
; 813  : }

  0017c	5d		 pop	 ebp
  0017d	c2 08 00	 ret	 8
$LN7@RecvWatchR:

; 806  : 
; 807  :     return;
; 808  : 
; 809  :   }
; 810  : 
; 811  :   LogAddC(2, "[Duel Manager] (%s)(%s) Wrong room index! (%d)", lpObj->AccountID, lpObj->Name, lpMsg->btRoomIndex);

  00180	0f b6 d0	 movzx	 edx, al
  00183	52		 push	 edx
  00184	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00187	50		 push	 eax
  00188	83 c6 6c	 add	 esi, 108		; 0000006cH
  0018b	56		 push	 esi
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JDCEHNOG@?$FLDuel?5Manager?$FN?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Wrong?5ro@
  00191	6a 02		 push	 2
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00199	83 c4 14	 add	 esp, 20			; 00000014H
  0019c	5f		 pop	 edi
$LN8@RecvWatchR:
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx

; 812  : 
; 813  : }

  0019f	5d		 pop	 ebp
  001a0	c2 08 00	 ret	 8
?RecvWatchRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_WATCH@@@Z ENDP ; CDuelManager::RecvWatchRequest
_TEXT	ENDS
PUBLIC	??_C@_0DD@GLFLBGPF@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0BB@JJKLKLEC@Duel?5User?5Switch?$AA@	; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RecvDuelAnswer@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_ANSWER_START@@@Z ; CDuelManager::RecvDuelAnswer
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
;	COMDAT ??_C@_0DD@GLFLBGPF@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DD@GLFLBGPF@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CFs@ DB '['
	DB	'Duel] [%s][%s] Duel Started [%s][%s] on Room [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JJKLKLEC@Duel?5User?5Switch?$AA@
CONST	SEGMENT
??_C@_0BB@JJKLKLEC@Duel?5User?5Switch?$AA@ DB 'Duel User Switch', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RecvDuelAnswer@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_ANSWER_START@@@Z
_TEXT	SEGMENT
_szDuelName2$216695 = -72				; size = 11
_iDuelRoom$ = -60					; size = 4
_lpMsg$GSCopy$ = -56					; size = 4
_szDuelName$216694 = -52				; size = 11
tv706 = -40						; size = 4
tv637 = -40						; size = 4
tv652 = -33						; size = 1
_iDuelIndex$ = -32					; size = 4
_this$GSCopy$ = -28					; size = 4
_pMsgSend$ = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?RecvDuelAnswer@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_ANSWER_START@@@Z PROC ; CDuelManager::RecvDuelAnswer, COMDAT
; _this$ = ecx

; 816  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 817  : 
; 818  :   int iDuelIndex = -1;
; 819  :   int iDuelRoom = lpObj->m_iDuelRoom;

  00018	8b 9e b4 21 00
	00		 mov	 ebx, DWORD PTR [esi+8628]
  0001e	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx

; 997  :         }
; 998  :       }
; 999  :       else
; 1000 :       {
; 1001 :         this->RoomReset(iDuelRoom);
; 1002 :         DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 1003 :         return;
; 1004 :       }
; 1005 :     }
; 1006 :     else
; 1007 :     {
; 1008 :       this->RoomReset(iDuelRoom);

  00021	89 45 c8	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  00024	89 5d c4	 mov	 DWORD PTR _iDuelRoom$[ebp], ebx
  00027	c6 45 ec 00	 mov	 BYTE PTR _pMsgSend$[ebp+4], 0
  0002b	c7 45 e8 c1 11
	aa 01		 mov	 DWORD PTR _pMsgSend$[ebp], 27922881 ; 01aa11c1H
  00032	83 fb 03	 cmp	 ebx, 3
  00035	0f 87 0d 05 00
	00		 ja	 $LN23@RecvDuelAn

; 820  :   
; 821  :   PMSG_DUEL_START pMsgSend;
; 822  :   
; 823  :   pMsgSend.h.c = 0xC1;
; 824  :   pMsgSend.h.headcode = 0xAA;
; 825  :   pMsgSend.h.subcode = 0x01;
; 826  :   pMsgSend.bDuelStart = 0;
; 827  :   pMsgSend.h.size = sizeof(pMsgSend);
; 828  : 
; 829  :   if(iDuelRoom < 0 || iDuelRoom > MAX_DUEL_ROOMS - 1) 
; 830  :   {
; 831  :     return;
; 832  :   }
; 833  : 
; 834  :   if ( gObj[lpObj->m_Index].CloseType != -1 ) 

  0003b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00049	80 7c 11 0b ff	 cmp	 BYTE PTR [ecx+edx+11], -1
  0004e	0f 85 f4 04 00
	00		 jne	 $LN23@RecvDuelAn

; 835  :     return;
; 836  :   
; 837  :   iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00054	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00058	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  0005c	66 c1 e1 08	 shl	 cx, 8
  00060	57		 push	 edi
  00061	0f b7 f9	 movzx	 edi, cx
  00064	0b fa		 or	 edi, edx
  00066	89 7d e0	 mov	 DWORD PTR _iDuelIndex$[ebp], edi

; 838  : 
; 839  :   if ( OBJMAX_RANGE(iDuelIndex) )

  00069	0f 8c d8 04 00
	00		 jl	 $LN58@RecvDuelAn
  0006f	33 c0		 xor	 eax, eax
  00071	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00077	0f 9e c0	 setle	 al
  0007a	85 c0		 test	 eax, eax
  0007c	0f 84 c5 04 00
	00		 je	 $LN58@RecvDuelAn

; 840  :   {
; 841  :     if ( !gObjIsConnected(iDuelIndex) )

  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00088	83 c4 04	 add	 esp, 4
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 b4 04 00
	00		 je	 $LN58@RecvDuelAn

; 842  : 	{
; 843  : 		return;
; 844  : 	}
; 845  : 
; 846  :     if ( gObj[iDuelIndex].Type == OBJ_MONSTER )

  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00098	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0009e	66 83 7c 07 68
	02		 cmp	 WORD PTR [edi+eax+104], 2
  000a4	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000a7	89 4d d8	 mov	 DWORD PTR tv637[ebp], ecx
  000aa	0f 84 97 04 00
	00		 je	 $LN58@RecvDuelAn

; 847  :       return;
; 848  : 
; 849  :     if ( gObj[iDuelIndex].CloseCount >= 0 )

  000b0	80 79 0a 00	 cmp	 BYTE PTR [ecx+10], 0
  000b4	0f 8d 8d 04 00
	00		 jge	 $LN58@RecvDuelAn

; 850  :       return;
; 851  : 
; 852  : 	if(gObj[iDuelIndex].m_DuelChar == false)

  000ba	80 b9 b8 21 00
	00 00		 cmp	 BYTE PTR [ecx+8632], 0
  000c1	75 14		 jne	 SHORT $LN17@RecvDuelAn

; 853  : 	{
; 854  : 		GCServerMsgStringSend("Duel User Switch", lpObj->m_Index, 1);

  000c3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000c5	6a 01		 push	 1
  000c7	51		 push	 ecx
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JJKLKLEC@Duel?5User?5Switch?$AA@
  000cd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 855  : 		return;

  000d2	e9 6d 04 00 00	 jmp	 $LN59@RecvDuelAn
$LN17@RecvDuelAn:

; 856  : 	}
; 857  : 
; 858  :     if ( lpMsg->bDuelOK )

  000d7	8b 55 c8	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  000da	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  000dd	88 45 df	 mov	 BYTE PTR tv652[ebp], al
  000e0	84 c0		 test	 al, al
  000e2	0f 84 8d 00 00
	00		 je	 $LN52@RecvDuelAn

; 859  :     {
; 860  :       if ( BC_MAP_RANGE(gObj[iDuelIndex].MapNumber) ||
; 861  :          CC_MAP_RANGE(gObj[iDuelIndex].MapNumber) ||
; 862  :          DS_MAP_RANGE(gObj[iDuelIndex].MapNumber) || 
; 863  : 		 IT_MAP_RANGE(gObj[iDuelIndex].MapNumber) )

  000e8	8a 81 49 01 00
	00		 mov	 al, BYTE PTR [ecx+329]
  000ee	3c 34		 cmp	 al, 52			; 00000034H
  000f0	74 40		 je	 SHORT $LN14@RecvDuelAn
  000f2	3c 0b		 cmp	 al, 11			; 0000000bH
  000f4	72 0c		 jb	 SHORT $LN51@RecvDuelAn
  000f6	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  000fb	3a d0		 cmp	 dl, al
  000fd	1b d2		 sbb	 edx, edx
  000ff	42		 inc	 edx
  00100	75 30		 jne	 SHORT $LN14@RecvDuelAn
$LN51@RecvDuelAn:
  00102	3c 35		 cmp	 al, 53			; 00000035H
  00104	74 2c		 je	 SHORT $LN14@RecvDuelAn
  00106	3c 12		 cmp	 al, 18			; 00000012H
  00108	72 0c		 jb	 SHORT $LN46@RecvDuelAn
  0010a	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  0010f	3a d0		 cmp	 dl, al
  00111	1b d2		 sbb	 edx, edx
  00113	42		 inc	 edx
  00114	75 1c		 jne	 SHORT $LN14@RecvDuelAn
$LN46@RecvDuelAn:
  00116	3c 09		 cmp	 al, 9
  00118	74 18		 je	 SHORT $LN14@RecvDuelAn
  0011a	33 d2		 xor	 edx, edx
  0011c	3c 20		 cmp	 al, 32			; 00000020H
  0011e	0f 94 c2	 sete	 dl
  00121	85 d2		 test	 edx, edx
  00123	75 0d		 jne	 SHORT $LN14@RecvDuelAn
  00125	3c 2d		 cmp	 al, 45			; 0000002dH
  00127	72 4c		 jb	 SHORT $LN52@RecvDuelAn
  00129	b2 32		 mov	 dl, 50			; 00000032H
  0012b	3a d0		 cmp	 dl, al
  0012d	1b c0		 sbb	 eax, eax
  0012f	40		 inc	 eax
  00130	74 43		 je	 SHORT $LN52@RecvDuelAn
$LN14@RecvDuelAn:

; 864  :       {
; 865  : 
; 866  :         GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), lpObj->m_Index, 1);

  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	6a 01		 push	 1
  00136	50		 push	 eax
  00137	68 cf 04 00 00	 push	 1231			; 000004cfH
$LN63@RecvDuelAn:
  0013c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00141	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 867  : 
; 868  :         this->RoomReset(iDuelRoom, true, true);

  0014c	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00152	6a 01		 push	 1
  00154	6a 01		 push	 1
  00156	53		 push	 ebx
  00157	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset

; 869  : 
; 870  :         memcpy(pMsgSend.szName, lpObj->Name, sizeof(pMsgSend.szName));

  0015c	8b 4e 77	 mov	 ecx, DWORD PTR [esi+119]
  0015f	8b 56 7b	 mov	 edx, DWORD PTR [esi+123]
  00162	66 8b 46 7f	 mov	 ax, WORD PTR [esi+127]
  00166	89 4d ef	 mov	 DWORD PTR _pMsgSend$[ebp+7], ecx
  00169	89 55 f3	 mov	 DWORD PTR _pMsgSend$[ebp+11], edx
  0016c	66 89 45 f7	 mov	 WORD PTR _pMsgSend$[ebp+15], ax

; 871  :         DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 872  :         return;

  00170	e9 bd 03 00 00	 jmp	 $LN60@RecvDuelAn
$LN52@RecvDuelAn:

; 873  :       }
; 874  :     }
; 875  : 
; 876  :     if ( OBJMAX_RANGE(lpObj->m_iDuelUser ) )

  00175	8b 86 b8 0e 00
	00		 mov	 eax, DWORD PTR [esi+3768]
  0017b	85 c0		 test	 eax, eax
  0017d	78 7d		 js	 SHORT $LN53@RecvDuelAn
  0017f	33 d2		 xor	 edx, edx
  00181	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00186	0f 9e c2	 setle	 dl
  00189	8b c2		 mov	 eax, edx
  0018b	85 c0		 test	 eax, eax
  0018d	74 6d		 je	 SHORT $LN53@RecvDuelAn

; 877  :     {
; 878  :       GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), lpObj->m_Index, 1);

  0018f	8b 06		 mov	 eax, DWORD PTR [esi]
  00191	6a 01		 push	 1
  00193	50		 push	 eax
  00194	68 a0 04 00 00	 push	 1184			; 000004a0H
  00199	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0019e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 879  :       GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), lpObj->m_Index, 1);

  001a9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ae	6a 01		 push	 1
  001b0	51		 push	 ecx
  001b1	68 a1 04 00 00	 push	 1185			; 000004a1H
  001b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001bb	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 880  :       
; 881  :       this->RoomReset(iDuelRoom, true, true);

  001c6	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	6a 01		 push	 1
  001ce	6a 01		 push	 1
  001d0	53		 push	 ebx
  001d1	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset

; 882  : 
; 883  :       memcpy(pMsgSend.szName, lpObj->Name, sizeof(pMsgSend.szName));

  001d6	8b 56 77	 mov	 edx, DWORD PTR [esi+119]
  001d9	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  001dc	66 8b 4e 7f	 mov	 cx, WORD PTR [esi+127]
  001e0	89 55 ef	 mov	 DWORD PTR _pMsgSend$[ebp+7], edx

; 884  :       DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  001e3	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsgSend$[ebp+1]
  001e7	89 45 f3	 mov	 DWORD PTR _pMsgSend$[ebp+11], eax
  001ea	52		 push	 edx
  001eb	8d 45 e8	 lea	 eax, DWORD PTR _pMsgSend$[ebp]
  001ee	66 89 4d f7	 mov	 WORD PTR _pMsgSend$[ebp+15], cx
  001f2	8b 4d e0	 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  001f5	50		 push	 eax
  001f6	51		 push	 ecx

; 885  :       return;

  001f7	e9 43 03 00 00	 jmp	 $LN61@RecvDuelAn
$LN53@RecvDuelAn:

; 886  :     }
; 887  : 
; 888  :     if ( OBJMAX_RANGE(lpObj->m_iDuelUserReserved) )

  001fc	8b 86 b0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3760]
  00202	85 c0		 test	 eax, eax
  00204	78 1f		 js	 SHORT $LN57@RecvDuelAn
  00206	33 d2		 xor	 edx, edx
  00208	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  0020d	0f 9e c2	 setle	 dl
  00210	8b c2		 mov	 eax, edx
  00212	85 c0		 test	 eax, eax
  00214	74 0f		 je	 SHORT $LN57@RecvDuelAn

; 889  :     {
; 890  :       GCServerMsgStringSend(lMsg.Get(MSGGET(4, 173)), lpObj->m_Index, 1);

  00216	8b 06		 mov	 eax, DWORD PTR [esi]
  00218	6a 01		 push	 1
  0021a	50		 push	 eax
  0021b	68 ad 04 00 00	 push	 1197			; 000004adH

; 891  : 
; 892  :       this->RoomReset(iDuelRoom, true, true);
; 893  : 
; 894  :       memcpy(pMsgSend.szName, lpObj->Name, sizeof(pMsgSend.szName));
; 895  :       DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 896  :       return;

  00220	e9 17 ff ff ff	 jmp	 $LN63@RecvDuelAn
$LN57@RecvDuelAn:

; 897  :     }
; 898  : 
; 899  :     if ( gObj[iDuelIndex].m_iDuelUserReserved == lpObj->m_Index )

  00225	8b 06		 mov	 eax, DWORD PTR [esi]
  00227	39 81 b0 0e 00
	00		 cmp	 DWORD PTR [ecx+3760], eax
  0022d	0f 85 f2 02 00
	00		 jne	 $LN11@RecvDuelAn

; 900  :     {
; 901  : 
; 902  :       char szDuelName[MAX_ACCOUNT_LEN+1]={0};
; 903  :       char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 904  : 
; 905  :       memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);

  00233	8b 51 77	 mov	 edx, DWORD PTR [ecx+119]
  00236	33 c0		 xor	 eax, eax
  00238	89 45 cd	 mov	 DWORD PTR _szDuelName$216694[ebp+1], eax
  0023b	89 45 d1	 mov	 DWORD PTR _szDuelName$216694[ebp+5], eax
  0023e	66 89 45 d5	 mov	 WORD PTR _szDuelName$216694[ebp+9], ax
  00242	89 45 b9	 mov	 DWORD PTR _szDuelName2$216695[ebp+1], eax
  00245	89 45 bd	 mov	 DWORD PTR _szDuelName2$216695[ebp+5], eax
  00248	66 89 45 c1	 mov	 WORD PTR _szDuelName2$216695[ebp+9], ax
  0024c	8b 41 7b	 mov	 eax, DWORD PTR [ecx+123]
  0024f	66 8b 49 7f	 mov	 cx, WORD PTR [ecx+127]
  00253	89 45 d0	 mov	 DWORD PTR _szDuelName$216694[ebp+4], eax

; 906  :       szDuelName[MAX_ACCOUNT_LEN] = 0;
; 907  : 
; 908  :       memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);

  00256	8b 45 c8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  00259	89 55 cc	 mov	 DWORD PTR _szDuelName$216694[ebp], edx
  0025c	8b 50 07	 mov	 edx, DWORD PTR [eax+7]
  0025f	66 89 4d d4	 mov	 WORD PTR _szDuelName$216694[ebp+8], cx
  00263	8b 48 0b	 mov	 ecx, DWORD PTR [eax+11]
  00266	89 55 b8	 mov	 DWORD PTR _szDuelName2$216695[ebp], edx
  00269	66 8b 50 0f	 mov	 dx, WORD PTR [eax+15]
  0026d	89 4d bc	 mov	 DWORD PTR _szDuelName2$216695[ebp+4], ecx
  00270	c6 45 d6 00	 mov	 BYTE PTR _szDuelName$216694[ebp+10], 0
  00274	66 89 55 c0	 mov	 WORD PTR _szDuelName2$216695[ebp+8], dx

; 909  :       szDuelName2[MAX_ACCOUNT_LEN] = 0;

  00278	c6 45 c2 00	 mov	 BYTE PTR _szDuelName2$216695[ebp+10], 0

; 910  : 
; 911  :       if ( !strcmp(szDuelName, szDuelName2))

  0027c	8d 4d b8	 lea	 ecx, DWORD PTR _szDuelName2$216695[ebp]
  0027f	8d 45 cc	 lea	 eax, DWORD PTR _szDuelName$216694[ebp]
$LL47@RecvDuelAn:
  00282	8a 10		 mov	 dl, BYTE PTR [eax]
  00284	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00286	75 1a		 jne	 SHORT $LN48@RecvDuelAn
  00288	84 d2		 test	 dl, dl
  0028a	74 12		 je	 SHORT $LN49@RecvDuelAn
  0028c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0028f	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00292	75 0e		 jne	 SHORT $LN48@RecvDuelAn
  00294	83 c0 02	 add	 eax, 2
  00297	83 c1 02	 add	 ecx, 2
  0029a	84 d2		 test	 dl, dl
  0029c	75 e4		 jne	 SHORT $LL47@RecvDuelAn
$LN49@RecvDuelAn:
  0029e	33 c0		 xor	 eax, eax
  002a0	eb 05		 jmp	 SHORT $LN50@RecvDuelAn
$LN48@RecvDuelAn:
  002a2	1b c0		 sbb	 eax, eax
  002a4	83 d8 ff	 sbb	 eax, -1
$LN50@RecvDuelAn:
  002a7	85 c0		 test	 eax, eax
  002a9	0f 85 76 02 00
	00		 jne	 $LN11@RecvDuelAn

; 912  :       {
; 913  :         if ( lpMsg->bDuelOK == false)

  002af	8a 45 df	 mov	 al, BYTE PTR tv652[ebp]
  002b2	84 c0		 test	 al, al
  002b4	75 37		 jne	 SHORT $LN9@RecvDuelAn

; 914  :         {
; 915  :           this->RoomReset(iDuelRoom, true, true);

  002b6	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002b9	6a 01		 push	 1
  002bb	6a 01		 push	 1
  002bd	53		 push	 ebx
  002be	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset

; 916  :           pMsgSend.bDuelStart = 0x0F;
; 917  :           memcpy(pMsgSend.szName, lpObj->Name, sizeof(pMsgSend.szName));

  002c3	8b 46 77	 mov	 eax, DWORD PTR [esi+119]
  002c6	8b 4e 7b	 mov	 ecx, DWORD PTR [esi+123]
  002c9	66 8b 56 7f	 mov	 dx, WORD PTR [esi+127]
  002cd	89 45 ef	 mov	 DWORD PTR _pMsgSend$[ebp+7], eax

; 918  :           DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  002d0	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  002d4	89 4d f3	 mov	 DWORD PTR _pMsgSend$[ebp+11], ecx
  002d7	50		 push	 eax
  002d8	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  002db	66 89 55 f7	 mov	 WORD PTR _pMsgSend$[ebp+15], dx
  002df	8b 55 e0	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  002e2	51		 push	 ecx
  002e3	c6 45 ec 0f	 mov	 BYTE PTR _pMsgSend$[ebp+4], 15 ; 0000000fH
  002e7	52		 push	 edx
  002e8	e9 52 02 00 00	 jmp	 $LN61@RecvDuelAn
$LN9@RecvDuelAn:

; 919  :         }
; 920  :         else if ( lpMsg->bDuelOK == true )

  002ed	3c 01		 cmp	 al, 1
  002ef	0f 85 52 02 00
	00		 jne	 $LN58@RecvDuelAn

; 921  :         {
; 922  : 
; 923  :           if ( lpObj->Money < 30000 )

  002f5	b8 30 75 00 00	 mov	 eax, 30000		; 00007530H
  002fa	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  00300	7d 30		 jge	 SHORT $LN6@RecvDuelAn

; 924  :           {
; 925  :             this->SendEndDuel(&gObj[iDuelIndex]);

  00302	8b 45 d8	 mov	 eax, DWORD PTR tv637[ebp]
  00305	8b 7d e4	 mov	 edi, DWORD PTR _this$GSCopy$[ebp]
  00308	50		 push	 eax
  00309	8b cf		 mov	 ecx, edi
  0030b	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel

; 926  :             this->RoomReset(iDuelRoom, true);

  00310	6a 00		 push	 0
  00312	6a 01		 push	 1
  00314	53		 push	 ebx
  00315	8b cf		 mov	 ecx, edi
  00317	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset

; 927  :             pMsgSend.bDuelStart = 0x0e;
; 928  :             pMsgSend.h.size = sizeof(pMsgSend);
; 929  :             DataSend(lpObj->m_Index, (BYTE*)&pMsgSend, pMsgSend.h.size);

  0031c	8b 16		 mov	 edx, DWORD PTR [esi]
  0031e	6a 11		 push	 17			; 00000011H
  00320	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  00323	51		 push	 ecx
  00324	c6 45 ec 0e	 mov	 BYTE PTR _pMsgSend$[ebp+4], 14 ; 0000000eH
  00328	c6 45 e9 11	 mov	 BYTE PTR _pMsgSend$[ebp+1], 17 ; 00000011H
  0032c	52		 push	 edx

; 930  :             return;

  0032d	e9 0d 02 00 00	 jmp	 $LN61@RecvDuelAn
$LN6@RecvDuelAn:

; 931  :           }
; 932  :           if(gObj[iDuelIndex].Money < 30000)

  00332	8b 4d d8	 mov	 ecx, DWORD PTR tv637[ebp]
  00335	39 81 f0 00 00
	00		 cmp	 DWORD PTR [ecx+240], eax
  0033b	7d 26		 jge	 SHORT $LN5@RecvDuelAn

; 933  :           {
; 934  :             this->SendEndDuel(lpObj);

  0033d	56		 push	 esi
  0033e	8b 75 e4	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00341	8b ce		 mov	 ecx, esi
  00343	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel

; 935  :             this->RoomReset(iDuelRoom, true);

  00348	6a 00		 push	 0
  0034a	6a 01		 push	 1
  0034c	53		 push	 ebx
  0034d	8b ce		 mov	 ecx, esi
  0034f	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset

; 936  :             pMsgSend.bDuelStart = 0x0e;

  00354	c6 45 ec 0e	 mov	 BYTE PTR _pMsgSend$[ebp+4], 14 ; 0000000eH

; 937  :             pMsgSend.h.size = sizeof(pMsgSend);

  00358	c6 45 e9 11	 mov	 BYTE PTR _pMsgSend$[ebp+1], 17 ; 00000011H

; 938  :             DataSend(iDuelIndex, (BYTE*)&pMsgSend, pMsgSend.h.size);

  0035c	6a 11		 push	 17			; 00000011H

; 939  :             return;

  0035e	e9 d4 01 00 00	 jmp	 $LN62@RecvDuelAn
$LN5@RecvDuelAn:

; 940  :           }
; 941  : 
; 942  :           if(gObjMoveGate(lpObj->m_Index, g_DuelGates[iDuelRoom].UserGate01) == false)

  00363	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00366	03 c0		 add	 eax, eax
  00368	8b 8c 00 00 00
	00 00		 mov	 ecx, DWORD PTR _g_DuelGates[eax+eax]
  0036f	03 c0		 add	 eax, eax
  00371	89 45 d8	 mov	 DWORD PTR tv706[ebp], eax
  00374	8b 06		 mov	 eax, DWORD PTR [esi]
  00376	51		 push	 ecx
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0037d	83 c4 08	 add	 esp, 8
  00380	85 c0		 test	 eax, eax

; 943  :           {
; 944  :             this->RoomReset(iDuelRoom, true, true);
; 945  :             return;

  00382	74 1a		 je	 SHORT $LN64@RecvDuelAn

; 946  :           }
; 947  :           if(gObjMoveGate(iDuelIndex, g_DuelGates[iDuelRoom].UserGate02) == false)

  00384	8b 55 d8	 mov	 edx, DWORD PTR tv706[ebp]
  00387	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _g_DuelGates[edx+4]
  0038d	8b 4d e0	 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  00390	50		 push	 eax
  00391	51		 push	 ecx
  00392	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00397	83 c4 08	 add	 esp, 8
  0039a	85 c0		 test	 eax, eax
  0039c	75 20		 jne	 SHORT $LN3@RecvDuelAn
$LN64@RecvDuelAn:

; 948  :           {
; 949  :             this->RoomReset(iDuelRoom, true, true);

  0039e	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  003a1	6a 01		 push	 1
  003a3	6a 01		 push	 1
  003a5	53		 push	 ebx
  003a6	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset
  003ab	5f		 pop	 edi
  003ac	5e		 pop	 esi
  003ad	5b		 pop	 ebx

; 1010 :       return;
; 1011 :     }
; 1012 :   }
; 1013 : }

  003ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b1	33 cd		 xor	 ecx, ebp
  003b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b8	8b e5		 mov	 esp, ebp
  003ba	5d		 pop	 ebp
  003bb	c2 08 00	 ret	 8
$LN3@RecvDuelAn:

; 950  :             return;
; 951  :           }
; 952  : 
; 953  :           lpObj->Money -= 30000;

  003be	81 86 f0 00 00
	00 d0 8a ff ff	 add	 DWORD PTR [esi+240], -30000 ; ffff8ad0H
  003c8	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]

; 954  :           GCMoneySend(lpObj->m_Index, lpObj->Money);

  003ce	8b 16		 mov	 edx, DWORD PTR [esi]
  003d0	50		 push	 eax
  003d1	52		 push	 edx
  003d2	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 955  : 
; 956  :           gObj[iDuelIndex].Money -= 30000;

  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003dc	81 84 07 f0 00
	00 00 d0 8a ff
	ff		 add	 DWORD PTR [edi+eax+240], -30000 ; ffff8ad0H

; 957  :           GCMoneySend(iDuelIndex, gObj[iDuelIndex].Money);

  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ec	8b 8c 07 f0 00
	00 00		 mov	 ecx, DWORD PTR [edi+eax+240]
  003f3	8b 55 e0	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  003f6	51		 push	 ecx
  003f7	52		 push	 edx
  003f8	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 958  : 
; 959  : 
; 960  : 		  gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 961  :           gObj[iDuelIndex].m_btDuelScore = 0;
; 962  :           gObj[iDuelIndex].m_iDuelUser = lpObj->m_Index;
; 963  : 
; 964  :           this->m_Rooms[iDuelRoom].dwStartTime = GetTickCount();

  003fd	6b db 4c	 imul	 ebx, 76			; 0000004cH
  00400	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00405	03 5d e4	 add	 ebx, DWORD PTR _this$GSCopy$[ebp]
  00408	c7 84 07 b0 0e
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edi+eax+3760], -1
  00413	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00419	c6 84 0f bc 0e
	00 00 00	 mov	 BYTE PTR [edi+ecx+3772], 0
  00421	8b 16		 mov	 edx, DWORD PTR [esi]
  00423	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00428	83 c4 10	 add	 esp, 16			; 00000010H
  0042b	89 94 07 b8 0e
	00 00		 mov	 DWORD PTR [edi+eax+3768], edx
  00432	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00438	89 43 54	 mov	 DWORD PTR [ebx+84], eax

; 965  :           this->m_Rooms[iDuelRoom].dwTickCount = GetTickCount() + (DUEL_TIME * 60000);

  0043b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00441	05 40 77 1b 00	 add	 eax, 1800000		; 001b7740H
  00446	89 43 50	 mov	 DWORD PTR [ebx+80], eax

; 966  : 
; 967  :           lpObj->m_iDuelUserRequested = -1;

  00449	83 c8 ff	 or	 eax, -1
  0044c	89 86 b4 0e 00
	00		 mov	 DWORD PTR [esi+3764], eax

; 968  :           lpObj->m_iDuelUserReserved = -1;

  00452	89 86 b0 0e 00
	00		 mov	 DWORD PTR [esi+3760], eax

; 969  : 
; 970  :           lpObj->m_btDuelScore = 0;
; 971  :           lpObj->m_iDuelUser = iDuelIndex;

  00458	8b 45 e0	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  0045b	89 86 b8 0e 00
	00		 mov	 DWORD PTR [esi+3768], eax

; 972  : 
; 973  :           this->m_Rooms[iDuelRoom].bFree = FALSE;

  00461	33 c9		 xor	 ecx, ecx

; 974  :           this->m_Rooms[iDuelRoom].bWaiting = FALSE;
; 975  :           this->m_Rooms[iDuelRoom].bHasWinner = FALSE;
; 976  : 
; 977  :           pMsgSend.bDuelStart = 0;
; 978  : 
; 979  :           pMsgSend.NumberH = SET_NUMBERH(iDuelIndex);

  00463	8b d0		 mov	 edx, eax

; 980  :           pMsgSend.NumberL = SET_NUMBERL(iDuelIndex);

  00465	88 45 ee	 mov	 BYTE PTR _pMsgSend$[ebp+6], al

; 981  : 
; 982  :           memcpy(pMsgSend.szName, szDuelName, sizeof(pMsgSend.szName));

  00468	8b 45 cc	 mov	 eax, DWORD PTR _szDuelName$216694[ebp]
  0046b	c6 86 bc 0e 00
	00 00		 mov	 BYTE PTR [esi+3772], 0
  00472	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  00475	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx
  00478	89 4b 58	 mov	 DWORD PTR [ebx+88], ecx
  0047b	c1 ea 08	 shr	 edx, 8
  0047e	88 4d ec	 mov	 BYTE PTR _pMsgSend$[ebp+4], cl
  00481	8b 4d d0	 mov	 ecx, DWORD PTR _szDuelName$216694[ebp+4]
  00484	89 45 ef	 mov	 DWORD PTR _pMsgSend$[ebp+7], eax

; 983  : 
; 984  :           DataSend(lpObj->m_Index, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  00487	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  0048b	88 55 ed	 mov	 BYTE PTR _pMsgSend$[ebp+5], dl
  0048e	66 8b 55 d4	 mov	 dx, WORD PTR _szDuelName$216694[ebp+8]
  00492	89 4d f3	 mov	 DWORD PTR _pMsgSend$[ebp+11], ecx
  00495	50		 push	 eax
  00496	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  00499	66 89 55 f7	 mov	 WORD PTR _pMsgSend$[ebp+15], dx
  0049d	8b 16		 mov	 edx, DWORD PTR [esi]
  0049f	51		 push	 ecx
  004a0	52		 push	 edx
  004a1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 985  : 
; 986  :           pMsgSend.NumberH = SET_NUMBERH(lpObj->m_Index);

  004a6	8b 06		 mov	 eax, DWORD PTR [esi]

; 987  :           pMsgSend.NumberL = SET_NUMBERL(lpObj->m_Index);
; 988  : 
; 989  :           memcpy(pMsgSend.szName, lpObj->Name, sizeof(pMsgSend.szName));

  004a8	8b 56 77	 mov	 edx, DWORD PTR [esi+119]
  004ab	8a 0e		 mov	 cl, BYTE PTR [esi]
  004ad	8d 5e 77	 lea	 ebx, DWORD PTR [esi+119]
  004b0	c1 e8 08	 shr	 eax, 8
  004b3	88 45 ed	 mov	 BYTE PTR _pMsgSend$[ebp+5], al
  004b6	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  004b9	89 55 ef	 mov	 DWORD PTR _pMsgSend$[ebp+7], edx

; 990  : 
; 991  :           DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  004bc	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsgSend$[ebp+1]
  004c0	88 4d ee	 mov	 BYTE PTR _pMsgSend$[ebp+6], cl
  004c3	66 8b 4b 08	 mov	 cx, WORD PTR [ebx+8]
  004c7	89 45 f3	 mov	 DWORD PTR _pMsgSend$[ebp+11], eax
  004ca	52		 push	 edx
  004cb	8d 45 e8	 lea	 eax, DWORD PTR _pMsgSend$[ebp]
  004ce	66 89 4d f7	 mov	 WORD PTR _pMsgSend$[ebp+15], cx
  004d2	8b 4d e0	 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  004d5	50		 push	 eax
  004d6	51		 push	 ecx
  004d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 992  : 
; 993  :           this->UpdateDuelScore(iDuelRoom);

  004dc	8b 55 c4	 mov	 edx, DWORD PTR _iDuelRoom$[ebp]
  004df	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  004e2	83 c4 18	 add	 esp, 24			; 00000018H
  004e5	52		 push	 edx
  004e6	e8 00 00 00 00	 call	 ?UpdateDuelScore@CDuelManager@@QAEXH@Z ; CDuelManager::UpdateDuelScore

; 994  : 
; 995  :           LogAddTD("[Duel] [%s][%s] Duel Started [%s][%s] on Room [%d]", lpObj->AccountID, lpObj->Name,
; 996  :             gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name, iDuelRoom + 1);

  004eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004f0	8b 4d c4	 mov	 ecx, DWORD PTR _iDuelRoom$[ebp]
  004f3	41		 inc	 ecx
  004f4	51		 push	 ecx
  004f5	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  004f9	52		 push	 edx
  004fa	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  004fe	50		 push	 eax
  004ff	53		 push	 ebx
  00500	83 c6 6c	 add	 esi, 108		; 0000006cH
  00503	56		 push	 esi
  00504	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GLFLBGPF@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CFs@
  00509	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0050f	83 c4 18	 add	 esp, 24			; 00000018H
  00512	5f		 pop	 edi
  00513	5e		 pop	 esi
  00514	5b		 pop	 ebx

; 1010 :       return;
; 1011 :     }
; 1012 :   }
; 1013 : }

  00515	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00518	33 cd		 xor	 ecx, ebp
  0051a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051f	8b e5		 mov	 esp, ebp
  00521	5d		 pop	 ebp
  00522	c2 08 00	 ret	 8
$LN11@RecvDuelAn:

; 997  :         }
; 998  :       }
; 999  :       else
; 1000 :       {
; 1001 :         this->RoomReset(iDuelRoom);
; 1002 :         DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 1003 :         return;
; 1004 :       }
; 1005 :     }
; 1006 :     else
; 1007 :     {
; 1008 :       this->RoomReset(iDuelRoom);

  00525	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00528	6a 00		 push	 0
  0052a	6a 00		 push	 0
  0052c	53		 push	 ebx
  0052d	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset
$LN60@RecvDuelAn:

; 1009 :       DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  00532	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsgSend$[ebp+1]
  00536	51		 push	 ecx
$LN62@RecvDuelAn:
  00537	8b 45 e0	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  0053a	8d 55 e8	 lea	 edx, DWORD PTR _pMsgSend$[ebp]
  0053d	52		 push	 edx
  0053e	50		 push	 eax
$LN61@RecvDuelAn:
  0053f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
$LN59@RecvDuelAn:
  00544	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN58@RecvDuelAn:
  00547	5f		 pop	 edi
$LN23@RecvDuelAn:

; 1010 :       return;
; 1011 :     }
; 1012 :   }
; 1013 : }

  00548	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054b	5e		 pop	 esi
  0054c	33 cd		 xor	 ecx, ebp
  0054e	5b		 pop	 ebx
  0054f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00554	8b e5		 mov	 esp, ebp
  00556	5d		 pop	 ebp
  00557	c2 08 00	 ret	 8
?RecvDuelAnswer@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_ANSWER_START@@@Z ENDP ; CDuelManager::RecvDuelAnswer
_TEXT	ENDS
PUBLIC	??_C@_0EJ@MOPGDAOH@?$FLDuel?5Manager?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requeste@ ; `string'
PUBLIC	??_C@_0CK@MLMIACIE@Duels?5are?5not?5allowed?5in?5Illusio@ ; `string'
PUBLIC	??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BA@JCKBAINH@DuelManager?4cpp?$AA@	; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RecvDuelRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_START@@@Z ; CDuelManager::RecvDuelRequest
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
;	COMDAT ??_C@_0EJ@MOPGDAOH@?$FLDuel?5Manager?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requeste@
CONST	SEGMENT
??_C@_0EJ@MOPGDAOH@?$FLDuel?5Manager?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requeste@ DB '['
	DB	'Duel Manager] [%s][%s] Requested to Start Duel to [%s][%s] on'
	DB	' Room [%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MLMIACIE@Duels?5are?5not?5allowed?5in?5Illusio@
CONST	SEGMENT
??_C@_0CK@MLMIACIE@Duels?5are?5not?5allowed?5in?5Illusio@ DB 'Duels are n'
	DB	'ot allowed in Illusion Temple.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ DB 'error '
	DB	': %s %d (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCKBAINH@DuelManager?4cpp?$AA@
CONST	SEGMENT
??_C@_0BA@JCKBAINH@DuelManager?4cpp?$AA@ DB 'DuelManager.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RecvDuelRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_START@@@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -324					; size = 4
_szDuelName2$ = -320					; size = 11
_iDuelRoom$ = -308					; size = 4
_this$GSCopy$ = -304					; size = 4
_iDuelIndex$ = -300					; size = 4
_pMsg$ = -296						; size = 16
_pMsgSend$216760 = -280					; size = 17
_pMsgSend$216756 = -280					; size = 17
_pMsgSend$216752 = -280					; size = 17
_szDuelName$ = -276					; size = 11
_szTempText$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?RecvDuelRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_START@@@Z PROC ; CDuelManager::RecvDuelRequest, COMDAT
; _this$ = ecx

; 1016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 1017 : 	/*
; 1018 :   if(g_DuelSystemState != TRUE)
; 1019 :   {
; 1020 :     GCServerMsgStringSend("O duel foi desativado neste servidor!", lpObj->m_Index, 1);
; 1021 :     return;
; 1022 :   }
; 1023 :   */
; 1024 :   int iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00016	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0001a	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00020	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00028	66 c1 e1 08	 shl	 cx, 8
  0002c	57		 push	 edi
  0002d	0f b7 f9	 movzx	 edi, cx
  00030	0b fa		 or	 edi, edx

; 1136 :   {
; 1137 :     return;
; 1138 :   }
; 1139 :   lpObj->m_PacketCheckTime = GetTickCount();

  00032	89 85 bc fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  00038	89 bd d4 fe ff
	ff		 mov	 DWORD PTR _iDuelIndex$[ebp], edi
  0003e	7c 0f		 jl	 SHORT $LN66@RecvDuelRe

; 1025 : 
; 1026 :   if ( !OBJMAX_RANGE(iDuelIndex) )

  00040	33 c0		 xor	 eax, eax
  00042	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00048	0f 9e c0	 setle	 al
  0004b	85 c0		 test	 eax, eax
  0004d	75 2b		 jne	 SHORT $LN36@RecvDuelRe
$LN66@RecvDuelRe:

; 1027 :   {
; 1028 :     LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);

  0004f	57		 push	 edi
  00050	68 04 04 00 00	 push	 1028			; 00000404H
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JCKBAINH@DuelManager?4cpp?$AA@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 1254 : 
; 1255 : }

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN36@RecvDuelRe:
  0007a	53		 push	 ebx

; 1029 :     return;
; 1030 :   }
; 1031 : 
; 1032 :   if ( iDuelIndex == lpObj->m_Index )

  0007b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0007d	3b fb		 cmp	 edi, ebx
  0007f	0f 84 0f 06 00
	00		 je	 $LN79@RecvDuelRe

; 1033 :     return;
; 1034 : 
; 1035 :   char szTempText[256];
; 1036 : 
; 1037 :   if ( lpObj->CloseType != -1 )

  00085	80 7e 0b ff	 cmp	 BYTE PTR [esi+11], -1
  00089	0f 85 05 06 00
	00		 jne	 $LN79@RecvDuelRe

; 1038 :     return;
; 1039 :   
; 1040 :   if ( gNonPK ) 

  0008f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00096	74 1d		 je	 SHORT $LN33@RecvDuelRe

; 1041 :   {
; 1042 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 174)), lpObj->m_Index, 1);

  00098	6a 01		 push	 1
  0009a	53		 push	 ebx
  0009b	68 ae 04 00 00	 push	 1198			; 000004aeH
$LN83@RecvDuelRe:
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1043 :     return;

  000b0	e9 dc 05 00 00	 jmp	 $LN80@RecvDuelRe
$LN33@RecvDuelRe:

; 1044 :   }
; 1045 : 
; 1046 :   if ( !gPkLimitFree ) 

  000b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  000bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c2	75 2f		 jne	 SHORT $LN76@RecvDuelRe

; 1047 :   {
; 1048 :     if ( lpObj->m_PK_Level >= 6 )

  000c4	b0 06		 mov	 al, 6
  000c6	38 86 3d 01 00
	00		 cmp	 BYTE PTR [esi+317], al
  000cc	7c 0a		 jl	 SHORT $LN31@RecvDuelRe

; 1049 :     {
; 1050 :       GCServerMsgStringSend(lMsg.Get(MSGGET(4, 175)), lpObj->m_Index, 1);

  000ce	6a 01		 push	 1
  000d0	53		 push	 ebx
  000d1	68 af 04 00 00	 push	 1199			; 000004afH

; 1051 :       return;

  000d6	eb c8		 jmp	 SHORT $LN83@RecvDuelRe
$LN31@RecvDuelRe:

; 1052 :     }
; 1053 :     if ( gObj[iDuelIndex].m_PK_Level >= 6 )

  000d8	8b cf		 mov	 ecx, edi
  000da	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  000e0	38 84 11 3d 01
	00 00		 cmp	 BYTE PTR [ecx+edx+317], al
  000e7	7c 0a		 jl	 SHORT $LN76@RecvDuelRe

; 1054 :     {
; 1055 :       GCServerMsgStringSend(lMsg.Get(MSGGET(4, 176)), lpObj->m_Index, 1);

  000e9	6a 01		 push	 1
  000eb	53		 push	 ebx
  000ec	68 b0 04 00 00	 push	 1200			; 000004b0H

; 1056 :       return;

  000f1	eb ad		 jmp	 SHORT $LN83@RecvDuelRe
$LN76@RecvDuelRe:

; 1057 :     }
; 1058 :   }
; 1059 : 
; 1060 :   if ( OBJMAX_RANGE(lpObj->m_iDuelUserReserved) )

  000f3	8b 86 b0 0e 00
	00		 mov	 eax, DWORD PTR [esi+3760]
  000f9	85 c0		 test	 eax, eax
  000fb	78 3a		 js	 SHORT $LN77@RecvDuelRe
  000fd	33 c9		 xor	 ecx, ecx
  000ff	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00104	0f 9e c1	 setle	 cl
  00107	8b c1		 mov	 eax, ecx
  00109	85 c0		 test	 eax, eax
  0010b	74 2a		 je	 SHORT $LN77@RecvDuelRe

; 1061 :   {
; 1062 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 159)), lpObj->m_Index, 1);

  0010d	6a 01		 push	 1
  0010f	53		 push	 ebx
  00110	68 9f 04 00 00	 push	 1183			; 0000049fH
$LN87@RecvDuelRe:
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1063 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), lpObj->m_Index, 1);

  00125	8b 16		 mov	 edx, DWORD PTR [esi]
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012a	6a 01		 push	 1
  0012c	52		 push	 edx
  0012d	68 a1 04 00 00	 push	 1185			; 000004a1H

; 1064 :     return;

  00132	e9 69 ff ff ff	 jmp	 $LN83@RecvDuelRe
$LN77@RecvDuelRe:

; 1065 :   }
; 1066 : 
; 1067 :   if ( OBJMAX_RANGE( lpObj->m_iDuelUser ) )

  00137	8b 86 b8 0e 00
	00		 mov	 eax, DWORD PTR [esi+3768]
  0013d	85 c0		 test	 eax, eax
  0013f	78 1a		 js	 SHORT $LN28@RecvDuelRe
  00141	33 c9		 xor	 ecx, ecx
  00143	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00148	0f 9e c1	 setle	 cl
  0014b	8b c1		 mov	 eax, ecx
  0014d	85 c0		 test	 eax, eax
  0014f	74 0a		 je	 SHORT $LN28@RecvDuelRe

; 1068 :   {
; 1069 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), lpObj->m_Index, 1);

  00151	6a 01		 push	 1
  00153	53		 push	 ebx
  00154	68 a0 04 00 00	 push	 1184			; 000004a0H

; 1070 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), lpObj->m_Index, 1);
; 1071 :     return;

  00159	eb ba		 jmp	 SHORT $LN87@RecvDuelRe
$LN28@RecvDuelRe:

; 1072 :   }
; 1073 : 
; 1074 :   if ( DS_MAP_RANGE(gObj[iDuelIndex].MapNumber ) )

  0015b	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00161	8a 84 17 49 01
	00 00		 mov	 al, BYTE PTR [edi+edx+329]
  00168	3c 09		 cmp	 al, 9
  0016a	74 0d		 je	 SHORT $LN67@RecvDuelRe
  0016c	33 c9		 xor	 ecx, ecx
  0016e	3c 20		 cmp	 al, 32			; 00000020H
  00170	0f 94 c1	 sete	 cl
  00173	8b c1		 mov	 eax, ecx
  00175	85 c0		 test	 eax, eax
  00177	74 0d		 je	 SHORT $LN27@RecvDuelRe
$LN67@RecvDuelRe:

; 1075 :   {
; 1076 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 180)), lpObj->m_Index, 1);

  00179	6a 01		 push	 1
  0017b	53		 push	 ebx
  0017c	68 b4 04 00 00	 push	 1204			; 000004b4H

; 1077 :     return;

  00181	e9 1a ff ff ff	 jmp	 $LN83@RecvDuelRe
$LN27@RecvDuelRe:

; 1078 :   }
; 1079 : 
; 1080 :   if ( BC_MAP_RANGE(lpObj->MapNumber) )

  00186	8a 86 49 01 00
	00		 mov	 al, BYTE PTR [esi+329]
  0018c	3c 34		 cmp	 al, 52			; 00000034H
  0018e	74 10		 je	 SHORT $LN68@RecvDuelRe
  00190	3c 0b		 cmp	 al, 11			; 0000000bH
  00192	72 19		 jb	 SHORT $LN26@RecvDuelRe
  00194	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00199	3a c8		 cmp	 cl, al
  0019b	1b c9		 sbb	 ecx, ecx
  0019d	41		 inc	 ecx
  0019e	74 0d		 je	 SHORT $LN26@RecvDuelRe
$LN68@RecvDuelRe:

; 1081 :   {
; 1082 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 166)), lpObj->m_Index, 1);

  001a0	6a 01		 push	 1
  001a2	53		 push	 ebx
  001a3	68 a6 04 00 00	 push	 1190			; 000004a6H

; 1083 :     return;

  001a8	e9 f3 fe ff ff	 jmp	 $LN83@RecvDuelRe
$LN26@RecvDuelRe:

; 1084 :   }
; 1085 : 
; 1086 :   if ( CC_MAP_RANGE(lpObj->MapNumber) )

  001ad	3c 35		 cmp	 al, 53			; 00000035H
  001af	74 10		 je	 SHORT $LN69@RecvDuelRe
  001b1	3c 12		 cmp	 al, 18			; 00000012H
  001b3	72 19		 jb	 SHORT $LN25@RecvDuelRe
  001b5	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  001ba	3a c8		 cmp	 cl, al
  001bc	1b c9		 sbb	 ecx, ecx
  001be	41		 inc	 ecx
  001bf	74 0d		 je	 SHORT $LN25@RecvDuelRe
$LN69@RecvDuelRe:

; 1087 :   {
; 1088 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), lpObj->m_Index, 1);

  001c1	6a 01		 push	 1
  001c3	53		 push	 ebx
  001c4	68 cf 04 00 00	 push	 1231			; 000004cfH

; 1089 :     return;

  001c9	e9 d2 fe ff ff	 jmp	 $LN83@RecvDuelRe
$LN25@RecvDuelRe:

; 1090 :   }
; 1091 : 
; 1092 :   if ( IT_MAP_RANGE(lpObj->MapNumber) != FALSE )

  001ce	3c 2d		 cmp	 al, 45			; 0000002dH
  001d0	72 1b		 jb	 SHORT $LN24@RecvDuelRe
  001d2	b1 32		 mov	 cl, 50			; 00000032H
  001d4	3a c8		 cmp	 cl, al
  001d6	1b c0		 sbb	 eax, eax
  001d8	40		 inc	 eax
  001d9	74 12		 je	 SHORT $LN24@RecvDuelRe

; 1093 :   {
; 1094 :     ::GCServerMsgStringSend("Duels are not allowed in Illusion Temple.", lpObj->m_Index, 1);

  001db	6a 01		 push	 1
  001dd	53		 push	 ebx
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MLMIACIE@Duels?5are?5not?5allowed?5in?5Illusio@
  001e3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001e8	e9 a4 04 00 00	 jmp	 $LN80@RecvDuelRe
$LN24@RecvDuelRe:

; 1095 :     return;
; 1096 :   }
; 1097 : 
; 1098 :   if ( lpObj->Level < 30 || gObj[iDuelIndex].Level < 30)

  001ed	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  001f2	66 39 8e be 00
	00 00		 cmp	 WORD PTR [esi+190], cx
  001f9	0f 8c 72 04 00
	00		 jl	 $LN22@RecvDuelRe
  001ff	66 39 8c 17 be
	00 00 00	 cmp	 WORD PTR [edi+edx+190], cx
  00207	0f 8c 64 04 00
	00		 jl	 $LN22@RecvDuelRe

; 1107 :     return;
; 1108 :   }
; 1109 : 
; 1110 :   if ( lpObj->Money < 30000 || gObj[iDuelIndex].Money < 30000 )

  0020d	b8 30 75 00 00	 mov	 eax, 30000		; 00007530H
  00212	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  00218	0f 8c 42 04 00
	00		 jl	 $LN20@RecvDuelRe
  0021e	39 84 17 f0 00
	00 00		 cmp	 DWORD PTR [edi+edx+240], eax
  00225	0f 8c 35 04 00
	00		 jl	 $LN20@RecvDuelRe

; 1120 :   }
; 1121 : 
; 1122 :   int iDuelRoom = this->GetFreeRoomIndex();

  0022b	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00231	e8 00 00 00 00	 call	 ?GetFreeRoomIndex@CDuelManager@@QAEHXZ ; CDuelManager::GetFreeRoomIndex
  00236	89 85 cc fe ff
	ff		 mov	 DWORD PTR _iDuelRoom$[ebp], eax

; 1123 :   if ( iDuelRoom == -1 )

  0023c	83 f8 ff	 cmp	 eax, -1
  0023f	75 0c		 jne	 SHORT $LN19@RecvDuelRe

; 1124 :   {
; 1125 :     PMSG_DUEL_START pMsgSend;
; 1126 :     pMsgSend.h.c = 0xC1;
; 1127 :     pMsgSend.h.headcode = 0xAA;
; 1128 :     pMsgSend.h.subcode = 0x01;
; 1129 :     pMsgSend.bDuelStart = 0x10;

  00241	c6 85 ec fe ff
	ff 10		 mov	 BYTE PTR _pMsgSend$216760[ebp+4], 16 ; 00000010H

; 1130 :     pMsgSend.h.size = sizeof(pMsgSend);
; 1131 :     DataSend(lpObj->m_Index, (BYTE*)&pMsgSend, pMsgSend.h.size);
; 1132 :     return;

  00248	e9 2b 04 00 00	 jmp	 $LN81@RecvDuelRe
$LN19@RecvDuelRe:

; 1133 :   }
; 1134 : 
; 1135 :   if ( ( GetTickCount() - lpObj->m_PacketCheckTime ) < 300 )

  0024d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00253	ff d3		 call	 ebx
  00255	2b 86 8c 03 00
	00		 sub	 eax, DWORD PTR [esi+908]
  0025b	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00260	0f 82 2e 04 00
	00		 jb	 $LN79@RecvDuelRe

; 1136 :   {
; 1137 :     return;
; 1138 :   }
; 1139 :   lpObj->m_PacketCheckTime = GetTickCount();

  00266	ff d3		 call	 ebx
  00268	89 86 8c 03 00
	00		 mov	 DWORD PTR [esi+908], eax

; 1140 : 
; 1141 :   char szDuelName[MAX_ACCOUNT_LEN+1] = {0};

  0026e	33 c0		 xor	 eax, eax
  00270	89 85 ed fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+1], eax
  00276	89 85 f1 fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+5], eax
  0027c	66 89 85 f5 fe
	ff ff		 mov	 WORD PTR _szDuelName$[ebp+9], ax

; 1142 :   char szDuelName2[MAX_ACCOUNT_LEN+1] = {0};

  00283	89 85 c1 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+1], eax
  00289	89 85 c5 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+5], eax
  0028f	66 89 85 c9 fe
	ff ff		 mov	 WORD PTR _szDuelName2$[ebp+9], ax

; 1143 : 
; 1144 :   memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);

  00296	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029b	8b 4c 07 77	 mov	 ecx, DWORD PTR [edi+eax+119]
  0029f	8b 54 07 7b	 mov	 edx, DWORD PTR [edi+eax+123]
  002a3	0f b7 44 07 7f	 movzx	 eax, WORD PTR [edi+eax+127]
  002a8	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _szDuelName$[ebp+8], ax

; 1145 :   szDuelName[MAX_ACCOUNT_LEN] = 0;
; 1146 : 
; 1147 :   memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);

  002af	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  002b5	89 8d ec fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp], ecx
  002bb	8b 48 06	 mov	 ecx, DWORD PTR [eax+6]
  002be	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+4], edx
  002c4	8b 50 0a	 mov	 edx, DWORD PTR [eax+10]
  002c7	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  002cb	89 8d c0 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp], ecx
  002d1	66 89 85 c8 fe
	ff ff		 mov	 WORD PTR _szDuelName2$[ebp+8], ax
  002d8	c6 85 f6 fe ff
	ff 00		 mov	 BYTE PTR _szDuelName$[ebp+10], 0
  002df	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+4], edx

; 1148 :   szDuelName2[MAX_ACCOUNT_LEN] = 0;

  002e5	c6 85 ca fe ff
	ff 00		 mov	 BYTE PTR _szDuelName2$[ebp+10], 0

; 1149 : 
; 1150 :   if ( strcmp(szDuelName, szDuelName2) )

  002ec	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _szDuelName2$[ebp]
  002f2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szDuelName$[ebp]
$LL70@RecvDuelRe:
  002f8	8a 10		 mov	 dl, BYTE PTR [eax]
  002fa	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002fc	75 1a		 jne	 SHORT $LN71@RecvDuelRe
  002fe	84 d2		 test	 dl, dl
  00300	74 12		 je	 SHORT $LN72@RecvDuelRe
  00302	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00305	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00308	75 0e		 jne	 SHORT $LN71@RecvDuelRe
  0030a	83 c0 02	 add	 eax, 2
  0030d	83 c1 02	 add	 ecx, 2
  00310	84 d2		 test	 dl, dl
  00312	75 e4		 jne	 SHORT $LL70@RecvDuelRe
$LN72@RecvDuelRe:
  00314	33 c0		 xor	 eax, eax
  00316	eb 05		 jmp	 SHORT $LN73@RecvDuelRe
$LN71@RecvDuelRe:
  00318	1b c0		 sbb	 eax, eax
  0031a	83 d8 ff	 sbb	 eax, -1
$LN73@RecvDuelRe:
  0031d	85 c0		 test	 eax, eax
  0031f	74 0f		 je	 SHORT $LN17@RecvDuelRe

; 1151 :   {
; 1152 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 162)), lpObj->m_Index, 1);

  00321	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00323	6a 01		 push	 1
  00325	51		 push	 ecx
  00326	68 a2 04 00 00	 push	 1186			; 000004a2H

; 1153 :     return;

  0032b	e9 70 fd ff ff	 jmp	 $LN83@RecvDuelRe
$LN17@RecvDuelRe:

; 1154 :   }
; 1155 : 
; 1156 :   if ( this->IsDuelEnable(iDuelIndex) == FALSE )

  00330	8b 9d d4 fe ff
	ff		 mov	 ebx, DWORD PTR _iDuelIndex$[ebp]
  00336	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0033c	53		 push	 ebx
  0033d	e8 00 00 00 00	 call	 ?IsDuelEnable@CDuelManager@@QAE_NH@Z ; CDuelManager::IsDuelEnable
  00342	84 c0		 test	 al, al
  00344	75 0f		 jne	 SHORT $LN16@RecvDuelRe

; 1157 :   {
; 1158 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 163)), lpObj->m_Index, 1);

  00346	8b 16		 mov	 edx, DWORD PTR [esi]
  00348	6a 01		 push	 1
  0034a	52		 push	 edx
  0034b	68 a3 04 00 00	 push	 1187			; 000004a3H

; 1159 :     return;

  00350	e9 4b fd ff ff	 jmp	 $LN83@RecvDuelRe
$LN16@RecvDuelRe:

; 1160 :   }
; 1161 : 
; 1162 :   if ( lpObj->lpGuild && lpObj->lpGuild->WarState == 1 )

  00355	8b 86 38 04 00
	00		 mov	 eax, DWORD PTR [esi+1080]
  0035b	85 c0		 test	 eax, eax
  0035d	74 18		 je	 SHORT $LN15@RecvDuelRe
  0035f	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00366	75 0f		 jne	 SHORT $LN15@RecvDuelRe

; 1163 :   {
; 1164 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 164)), lpObj->m_Index, 1);

  00368	8b 06		 mov	 eax, DWORD PTR [esi]
  0036a	6a 01		 push	 1
  0036c	50		 push	 eax
  0036d	68 a4 04 00 00	 push	 1188			; 000004a4H

; 1165 :     return;

  00372	e9 29 fd ff ff	 jmp	 $LN83@RecvDuelRe
$LN15@RecvDuelRe:

; 1166 :   }
; 1167 : 
; 1168 :   if ( gObj[iDuelIndex].lpGuild && gObj[iDuelIndex].lpGuild->WarState == 1 )

  00377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0037d	8b 84 0f 38 04
	00 00		 mov	 eax, DWORD PTR [edi+ecx+1080]
  00384	85 c0		 test	 eax, eax
  00386	74 18		 je	 SHORT $LN14@RecvDuelRe
  00388	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  0038f	75 0f		 jne	 SHORT $LN14@RecvDuelRe

; 1169 :   {
; 1170 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 165)), lpObj->m_Index, 1);

  00391	8b 16		 mov	 edx, DWORD PTR [esi]
  00393	6a 01		 push	 1
  00395	52		 push	 edx
  00396	68 a5 04 00 00	 push	 1189			; 000004a5H

; 1171 :     return;

  0039b	e9 00 fd ff ff	 jmp	 $LN83@RecvDuelRe
$LN14@RecvDuelRe:

; 1172 :   }
; 1173 : 
; 1174 :   if ( gObjIsConnected(iDuelIndex) == FALSE )

  003a0	53		 push	 ebx
  003a1	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  003a6	83 c4 04	 add	 esp, 4
  003a9	85 c0		 test	 eax, eax
  003ab	0f 84 e3 02 00
	00		 je	 $LN79@RecvDuelRe

; 1175 :     return;
; 1176 : 
; 1177 :   if ( gObj[iDuelIndex].Type == OBJ_MONSTER )

  003b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b7	66 83 7c 0f 68
	02		 cmp	 WORD PTR [edi+ecx+104], 2
  003bd	0f 84 d1 02 00
	00		 je	 $LN79@RecvDuelRe

; 1178 :     return;
; 1179 : 
; 1180 :   if ( gObj[iDuelIndex].CloseCount >= 0 )

  003c3	80 7c 0f 0a 00	 cmp	 BYTE PTR [edi+ecx+10], 0
  003c8	0f 8d c6 02 00
	00		 jge	 $LN79@RecvDuelRe

; 1181 :     return;
; 1182 : 
; 1183 :   for (int n=0;n<MAX_SELF_DEFENSE;n++)

  003ce	33 c0		 xor	 eax, eax
  003d0	8d 96 e4 03 00
	00		 lea	 edx, DWORD PTR [esi+996]
  003d6	eb 0e		 jmp	 SHORT $LN10@RecvDuelRe
  003d8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL74@RecvDuelRe:
  003e0	8b 9d d4 fe ff
	ff		 mov	 ebx, DWORD PTR _iDuelIndex$[ebp]
$LN10@RecvDuelRe:

; 1184 :   {
; 1185 :     if ( lpObj->SelfDefense[n] >= 0 || gObj[iDuelIndex].SelfDefense[n] >= 0 )

  003e6	83 3a 00	 cmp	 DWORD PTR [edx], 0
  003e9	7d 34		 jge	 SHORT $LN64@RecvDuelRe
  003eb	69 db d4 0a 00
	00		 imul	 ebx, 2772		; 00000ad4H
  003f1	03 d8		 add	 ebx, eax
  003f3	83 bc 99 e4 03
	00 00 00	 cmp	 DWORD PTR [ecx+ebx*4+996], 0
  003fb	7d 22		 jge	 SHORT $LN64@RecvDuelRe

; 1181 :     return;
; 1182 : 
; 1183 :   for (int n=0;n<MAX_SELF_DEFENSE;n++)

  003fd	40		 inc	 eax
  003fe	83 c2 04	 add	 edx, 4
  00401	83 f8 07	 cmp	 eax, 7
  00404	7c da		 jl	 SHORT $LL74@RecvDuelRe

; 1189 :     }
; 1190 :   }
; 1191 : 
; 1192 :   if ( lpObj->m_IfState.use > 0 )

  00406	b0 03		 mov	 al, 3
  00408	84 86 1c 0e 00
	00		 test	 BYTE PTR [esi+3612], al
  0040e	76 1e		 jbe	 SHORT $LN5@RecvDuelRe

; 1193 :   {
; 1194 :     GCServerMsgStringSend(lMsg.Get(MSGGET(4, 167)), lpObj->m_Index, 1);

  00410	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00412	6a 01		 push	 1
  00414	51		 push	 ecx
  00415	68 a7 04 00 00	 push	 1191			; 000004a7H

; 1195 :     return;

  0041a	e9 81 fc ff ff	 jmp	 $LN83@RecvDuelRe
$LN64@RecvDuelRe:

; 1186 :     {
; 1187 :       GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), lpObj->m_Index, 1);

  0041f	8b 06		 mov	 eax, DWORD PTR [esi]
  00421	6a 01		 push	 1
  00423	50		 push	 eax
  00424	68 bd 04 00 00	 push	 1213			; 000004bdH

; 1188 :       return;

  00429	e9 72 fc ff ff	 jmp	 $LN83@RecvDuelRe
$LN5@RecvDuelRe:

; 1196 :   }
; 1197 : 
; 1198 :   if ( gObj[iDuelIndex].m_IfState.use > 0 )

  0042e	84 84 0f 1c 0e
	00 00		 test	 BYTE PTR [edi+ecx+3612], al
  00435	76 49		 jbe	 SHORT $LN4@RecvDuelRe

; 1199 :   {
; 1200 :     wsprintf(szTempText, lMsg.Get(MSGGET(4, 168)), gObj[iDuelIndex].Name);

  00437	8d 54 0f 77	 lea	 edx, DWORD PTR [edi+ecx+119]
  0043b	52		 push	 edx
  0043c	68 a8 04 00 00	 push	 1192			; 000004a8H
  00441	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00446	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0044b	50		 push	 eax
  0044c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  00452	50		 push	 eax
  00453	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1201 :     GCServerMsgStringSend(szTempText, lpObj->m_Index, 1);

  00459	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0045b	6a 01		 push	 1
  0045d	51		 push	 ecx
  0045e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTempText$[ebp]
  00464	52		 push	 edx

; 1222 :     GCServerMsgStringSend(szTempText, lpObj->m_Index, 1);

  00465	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0046a	83 c4 18	 add	 esp, 24			; 00000018H
  0046d	5b		 pop	 ebx
  0046e	5f		 pop	 edi
  0046f	5e		 pop	 esi

; 1254 : 
; 1255 : }

  00470	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00473	33 cd		 xor	 ecx, ebp
  00475	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047a	8b e5		 mov	 esp, ebp
  0047c	5d		 pop	 ebp
  0047d	c2 08 00	 ret	 8
$LN4@RecvDuelRe:

; 1202 :     return;
; 1203 :   }
; 1204 : 
; 1205 :   if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserRequested) )

  00480	8b 84 0f b4 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3764]
  00487	85 c0		 test	 eax, eax
  00489	78 1c		 js	 SHORT $LN75@RecvDuelRe
  0048b	33 d2		 xor	 edx, edx
  0048d	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00492	0f 9e c2	 setle	 dl
  00495	8b c2		 mov	 eax, edx
  00497	85 c0		 test	 eax, eax
  00499	74 0c		 je	 SHORT $LN75@RecvDuelRe

; 1206 :   {
; 1207 :     wsprintf(szTempText, lMsg.Get(MSGGET(4, 169)), gObj[iDuelIndex].Name);

  0049b	8d 44 0f 77	 lea	 eax, DWORD PTR [edi+ecx+119]
  0049f	50		 push	 eax
  004a0	68 a9 04 00 00	 push	 1193			; 000004a9H

; 1208 :     GCServerMsgStringSend(szTempText, lpObj->m_Index, 1);
; 1209 :     return;

  004a5	eb 4c		 jmp	 SHORT $LN85@RecvDuelRe
$LN75@RecvDuelRe:

; 1210 :   }
; 1211 : 
; 1212 :   if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserReserved) )

  004a7	8b 84 0f b0 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3760]
  004ae	85 c0		 test	 eax, eax
  004b0	78 1c		 js	 SHORT $LN78@RecvDuelRe
  004b2	33 d2		 xor	 edx, edx
  004b4	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  004b9	0f 9e c2	 setle	 dl
  004bc	8b c2		 mov	 eax, edx
  004be	85 c0		 test	 eax, eax
  004c0	74 0c		 je	 SHORT $LN78@RecvDuelRe

; 1213 :   {
; 1214 :     wsprintf(szTempText, lMsg.Get(MSGGET(4, 170)), gObj[iDuelIndex].Name);

  004c2	8d 44 0f 77	 lea	 eax, DWORD PTR [edi+ecx+119]
  004c6	50		 push	 eax
  004c7	68 aa 04 00 00	 push	 1194			; 000004aaH

; 1215 :     GCServerMsgStringSend(szTempText, lpObj->m_Index, 1);
; 1216 :     return;

  004cc	eb 25		 jmp	 SHORT $LN85@RecvDuelRe
$LN78@RecvDuelRe:

; 1217 :   }
; 1218 : 
; 1219 :   if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )

  004ce	8b 84 0f b8 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3768]
  004d5	85 c0		 test	 eax, eax
  004d7	78 59		 js	 SHORT $LN1@RecvDuelRe
  004d9	33 d2		 xor	 edx, edx
  004db	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  004e0	0f 9e c2	 setle	 dl
  004e3	8b c2		 mov	 eax, edx
  004e5	85 c0		 test	 eax, eax
  004e7	74 49		 je	 SHORT $LN1@RecvDuelRe

; 1220 :   {
; 1221 :     wsprintf(szTempText, lMsg.Get(MSGGET(4, 171)), gObj[iDuelIndex].Name);

  004e9	8d 44 0f 77	 lea	 eax, DWORD PTR [edi+ecx+119]
  004ed	50		 push	 eax
  004ee	68 ab 04 00 00	 push	 1195			; 000004abH
$LN85@RecvDuelRe:
  004f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004f8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004fd	50		 push	 eax
  004fe	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  00504	51		 push	 ecx
  00505	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1222 :     GCServerMsgStringSend(szTempText, lpObj->m_Index, 1);

  0050b	8b 16		 mov	 edx, DWORD PTR [esi]
  0050d	6a 01		 push	 1
  0050f	52		 push	 edx
  00510	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  00516	50		 push	 eax
  00517	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0051c	83 c4 18	 add	 esp, 24			; 00000018H
  0051f	5b		 pop	 ebx
  00520	5f		 pop	 edi
  00521	5e		 pop	 esi

; 1254 : 
; 1255 : }

  00522	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00525	33 cd		 xor	 ecx, ebp
  00527	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052c	8b e5		 mov	 esp, ebp
  0052e	5d		 pop	 ebp
  0052f	c2 08 00	 ret	 8
$LN1@RecvDuelRe:

; 1223 :     return;
; 1224 :   }
; 1225 : 
; 1226 :   lpObj->m_iDuelUser = -1;
; 1227 :   lpObj->m_iDuelUserReserved = iDuelIndex;
; 1228 :   gObj[iDuelIndex].m_iDuelUserRequested = lpObj->m_Index;

  00532	8b 16		 mov	 edx, DWORD PTR [esi]
  00534	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  0053a	89 8e b0 0e 00
	00		 mov	 DWORD PTR [esi+3760], ecx
  00540	c7 86 b8 0e 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+3768], -1
  0054a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0054f	89 94 07 b4 0e
	00 00		 mov	 DWORD PTR [edi+eax+3764], edx

; 1229 :   lpObj->m_iDuelRoom = iDuelRoom;

  00556	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _iDuelRoom$[ebp]
  0055c	89 86 b4 21 00
	00		 mov	 DWORD PTR [esi+8628], eax

; 1230 :   gObj[iDuelIndex].m_iDuelRoom = iDuelRoom;

  00562	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00568	89 84 0f b4 21
	00 00		 mov	 DWORD PTR [edi+ecx+8628], eax

; 1231 : 
; 1232 :   lpObj->m_DuelChar = true;
; 1233 : 
; 1234 :   this->m_Rooms[iDuelRoom].lpObj01 = lpObj;

  0056f	6b c0 4c	 imul	 eax, 76			; 0000004cH
  00572	03 85 d0 fe ff
	ff		 add	 eax, DWORD PTR _this$GSCopy$[ebp]
  00578	c6 86 b8 21 00
	00 01		 mov	 BYTE PTR [esi+8632], 1
  0057f	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 1235 :   this->m_Rooms[iDuelRoom].lpObj02 = &gObj[iDuelIndex];

  00582	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1236 :   this->m_Rooms[iDuelRoom].bWaiting = TRUE;

  00588	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1
  0058f	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  00592	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 1237 : 
; 1238 :   PMSG_DUEL_QUESTION_START pMsg;
; 1239 : 
; 1240 :   pMsg.h.c = 0xC1;
; 1241 :   pMsg.h.headcode = 0xAA;
; 1242 :   pMsg.h.subcode = 0x02;
; 1243 :   pMsg.h.size = sizeof(pMsg);
; 1244 :   pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00595	8b 06		 mov	 eax, DWORD PTR [esi]

; 1245 :   pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 1246 :   memcpy(pMsg.szName, lpObj->Name, sizeof(pMsg.szName));

  00597	8b 56 77	 mov	 edx, DWORD PTR [esi+119]
  0059a	8a 0e		 mov	 cl, BYTE PTR [esi]
  0059c	c1 e8 08	 shr	 eax, 8
  0059f	8d 5e 77	 lea	 ebx, DWORD PTR [esi+119]
  005a2	88 85 dc fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al
  005a8	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  005ab	89 95 de fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+6], edx

; 1247 : 
; 1248 :   DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  005b1	6a 10		 push	 16			; 00000010H
  005b3	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  005b9	89 85 e2 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+10], eax
  005bf	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  005c5	88 8d dd fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+5], cl
  005cb	66 8b 4b 08	 mov	 cx, WORD PTR [ebx+8]
  005cf	52		 push	 edx
  005d0	50		 push	 eax
  005d1	c7 85 d8 fe ff
	ff c1 10 aa 02	 mov	 DWORD PTR _pMsg$[ebp], 44699841 ; 02aa10c1H
  005db	66 89 8d e6 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+14], cx
  005e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1249 : 
; 1250 :   wsprintf(szTempText, lMsg.Get(MSGGET(4, 172)), gObj[iDuelIndex].Name);

  005e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  005f0	8d 54 0f 77	 lea	 edx, DWORD PTR [edi+ecx+119]
  005f4	52		 push	 edx
  005f5	68 ac 04 00 00	 push	 1196			; 000004acH
  005fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005ff	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00604	50		 push	 eax
  00605	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  0060b	50		 push	 eax
  0060c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1251 :   GCServerMsgStringSend(szTempText, lpObj->m_Index, 1);

  00612	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00614	6a 01		 push	 1
  00616	51		 push	 ecx
  00617	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTempText$[ebp]
  0061d	52		 push	 edx
  0061e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1252 : 
; 1253 :   LogAddTD("[Duel Manager] [%s][%s] Requested to Start Duel to [%s][%s] on Room [%d]", lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name, iDuelRoom+1);

  00623	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00628	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _iDuelRoom$[ebp]
  0062e	41		 inc	 ecx
  0062f	51		 push	 ecx
  00630	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00634	52		 push	 edx
  00635	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  00639	50		 push	 eax
  0063a	53		 push	 ebx
  0063b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0063e	56		 push	 esi
  0063f	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@MOPGDAOH@?$FLDuel?5Manager?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requeste@
  00644	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0064a	83 c4 30	 add	 esp, 48			; 00000030H
  0064d	5b		 pop	 ebx
  0064e	5f		 pop	 edi
  0064f	5e		 pop	 esi

; 1254 : 
; 1255 : }

  00650	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00653	33 cd		 xor	 ecx, ebp
  00655	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0065a	8b e5		 mov	 esp, ebp
  0065c	5d		 pop	 ebp
  0065d	c2 08 00	 ret	 8
$LN20@RecvDuelRe:

; 1111 :   {
; 1112 :     PMSG_DUEL_START pMsgSend;
; 1113 :     pMsgSend.h.c = 0xC1;
; 1114 :     pMsgSend.h.headcode = 0xAA;
; 1115 :     pMsgSend.h.subcode = 0x01;
; 1116 :     pMsgSend.bDuelStart = 0x1e;

  00660	88 8d ec fe ff
	ff		 mov	 BYTE PTR _pMsgSend$216756[ebp+4], cl

; 1117 :     pMsgSend.h.size = sizeof(pMsgSend);
; 1118 :     DataSend(lpObj->m_Index, (BYTE*)&pMsgSend, pMsgSend.h.size);

  00666	6a 11		 push	 17			; 00000011H
  00668	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsgSend$216756[ebp]
  0066e	51		 push	 ecx

; 1119 :     return;

  0066f	eb 10		 jmp	 SHORT $LN82@RecvDuelRe
$LN22@RecvDuelRe:

; 1099 :   {
; 1100 :     PMSG_DUEL_START pMsgSend;
; 1101 :     pMsgSend.h.c = 0xC1;
; 1102 :     pMsgSend.h.headcode = 0xAA;
; 1103 :     pMsgSend.h.subcode = 0x01;
; 1104 :     pMsgSend.bDuelStart = 0x0C;

  00671	c6 85 ec fe ff
	ff 0c		 mov	 BYTE PTR _pMsgSend$216752[ebp+4], 12 ; 0000000cH
$LN81@RecvDuelRe:

; 1105 :     pMsgSend.h.size = sizeof(pMsgSend);
; 1106 :     DataSend(lpObj->m_Index, (BYTE*)&pMsgSend, pMsgSend.h.size);

  00678	6a 11		 push	 17			; 00000011H
  0067a	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsgSend$216752[ebp]
  00680	52		 push	 edx
$LN82@RecvDuelRe:
  00681	53		 push	 ebx
  00682	c7 85 e8 fe ff
	ff c1 11 aa 01	 mov	 DWORD PTR _pMsgSend$216752[ebp], 27922881 ; 01aa11c1H
  0068c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
$LN80@RecvDuelRe:
  00691	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN79@RecvDuelRe:

; 1254 : 
; 1255 : }

  00694	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00697	5b		 pop	 ebx
  00698	5f		 pop	 edi
  00699	33 cd		 xor	 ecx, ebp
  0069b	5e		 pop	 esi
  0069c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a1	8b e5		 mov	 esp, ebp
  006a3	5d		 pop	 ebp
  006a4	c2 08 00	 ret	 8
?RecvDuelRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_START@@@Z ENDP ; CDuelManager::RecvDuelRequest
_TEXT	ENDS
PUBLIC	??_C@_0CA@IOIFMHLG@?$FLDuel?5Manager?$FN?5Room?5?$CFd?5cleaned?4?$AA@ ; `string'
PUBLIC	??_C@_0CN@FHAOCOHB@?$FLDuel?5Manager?$FN?5Some?5spectator?5le@ ; `string'
PUBLIC	??_C@_0CN@KOMGNNFM@?$FLDuel?5Manager?$FN?5Spectator?5?$CI?$CFs?$CJ?5le@ ; `string'
PUBLIC	?Run@CDuelManager@@QAEXXZ			; CDuelManager::Run
;	COMDAT ??_C@_0CA@IOIFMHLG@?$FLDuel?5Manager?$FN?5Room?5?$CFd?5cleaned?4?$AA@
CONST	SEGMENT
??_C@_0CA@IOIFMHLG@?$FLDuel?5Manager?$FN?5Room?5?$CFd?5cleaned?4?$AA@ DB '['
	DB	'Duel Manager] Room %d cleaned.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FHAOCOHB@?$FLDuel?5Manager?$FN?5Some?5spectator?5le@
CONST	SEGMENT
??_C@_0CN@FHAOCOHB@?$FLDuel?5Manager?$FN?5Some?5spectator?5le@ DB '[Duel '
	DB	'Manager] Some spectator leaves room %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KOMGNNFM@?$FLDuel?5Manager?$FN?5Spectator?5?$CI?$CFs?$CJ?5le@
CONST	SEGMENT
??_C@_0CN@KOMGNNFM@?$FLDuel?5Manager?$FN?5Spectator?5?$CI?$CFs?$CJ?5le@ DB '['
	DB	'Duel Manager] Spectator (%s) leaves room %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Run@CDuelManager@@QAEXXZ
_TEXT	SEGMENT
tv386 = -8						; size = 4
_u$216307 = -4						; size = 4
?Run@CDuelManager@@QAEXXZ PROC				; CDuelManager::Run, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b d9		 mov	 ebx, ecx

; 70   :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  0000b	33 ff		 xor	 edi, edi
  0000d	8d 49 00	 npad	 3
$LL43@Run:

; 71   :   {
; 72   :     if(this->m_Rooms[i].bFree == FALSE)

  00010	8b f7		 mov	 esi, edi
  00012	6b f6 4c	 imul	 esi, 76			; 0000004cH
  00015	03 f3		 add	 esi, ebx
  00017	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0001b	89 75 f8	 mov	 DWORD PTR tv386[ebp], esi
  0001e	0f 85 8a 01 00
	00		 jne	 $LN29@Run

; 73   :     {
; 74   : 
; 75   :       if(GetTickCount() - this->m_Rooms[i].dwStartTime < 5000) continue;

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002a	2b 46 54	 sub	 eax, DWORD PTR [esi+84]
  0002d	3d 88 13 00 00	 cmp	 eax, 5000		; 00001388H
  00032	0f 82 76 01 00
	00		 jb	 $LN29@Run

; 76   : 
; 77   :       for(int u = 0; u < MAX_DUEL_LEARNERS; u++)

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _u$216307[ebp], 0
  0003f	83 c6 28	 add	 esi, 40			; 00000028H
$LL25@Run:

; 78   :       {
; 79   :         if(this->m_Rooms[i].lpLearners[u] == NULL) continue;

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	85 c0		 test	 eax, eax
  00046	0f 84 80 00 00
	00		 je	 $LN24@Run

; 80   :         if(gObjIsConnected(this->m_Rooms[i].lpLearners[u]->m_Index))

  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00054	83 c4 04	 add	 esp, 4
  00057	85 c0		 test	 eax, eax
  00059	74 4b		 je	 SHORT $LN21@Run

; 81   :         {
; 82   :           if(this->m_Rooms[i].lpLearners[u]->MapNumber != MAP_INDEX_VULCANROOM)

  0005b	8b 06		 mov	 eax, DWORD PTR [esi]
  0005d	80 b8 49 01 00
	00 40		 cmp	 BYTE PTR [eax+329], 64	; 00000040H
  00064	74 66		 je	 SHORT $LN24@Run

; 83   :           {
; 84   :             this->SendEndDuel(this->m_Rooms[i].lpLearners[u]);

  00066	50		 push	 eax
  00067	8b cb		 mov	 ecx, ebx
  00069	e8 00 00 00 00	 call	 ?SendEndDuel@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendEndDuel

; 85   :            // GCStateInfoSend(this->m_Rooms[i].lpLearners[u], 0, eVS_INVISIBLE);
; 86   :            // GCStateInfoSend(this->m_Rooms[i].lpLearners[u], 0, eVS_TRANSPARENCY);
; 87   :            // GCStateInfoSend(this->m_Rooms[i].lpLearners[u], 0, eVS_DUEL_INTERFACE);
; 88   : 			this->SetBuff(this->m_Rooms[i].lpLearners[u], FALSE);

  0006e	8b 16		 mov	 edx, DWORD PTR [esi]
  00070	6a 00		 push	 0
  00072	52		 push	 edx
  00073	8b cb		 mov	 ecx, ebx
  00075	e8 00 00 00 00	 call	 ?SetBuff@CDuelManager@@QAEXPAUOBJECTSTRUCT@@H@Z ; CDuelManager::SetBuff

; 89   :             LogAddTD("[Duel Manager] Spectator (%s) leaves room %d", this->m_Rooms[i].lpLearners[u]->Name, i + 1);

  0007a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0007c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0007f	50		 push	 eax
  00080	83 c1 77	 add	 ecx, 119		; 00000077H
  00083	51		 push	 ecx
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@KOMGNNFM@?$FLDuel?5Manager?$FN?5Spectator?5?$CI?$CFs?$CJ?5le@
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 90   :             this->SendSpectatorRemove(u, i);

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _u$216307[ebp]
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	57		 push	 edi
  00096	52		 push	 edx
  00097	8b cb		 mov	 ecx, ebx
  00099	e8 00 00 00 00	 call	 ?SendSpectatorRemove@CDuelManager@@QAEXHH@Z ; CDuelManager::SendSpectatorRemove

; 91   :             this->m_Rooms[i].lpLearners[u] = NULL;

  0009e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 92   :           }
; 93   :         }
; 94   :         else

  000a4	eb 26		 jmp	 SHORT $LN24@Run
$LN21@Run:

; 95   :         {
; 96   :           LogAddTD("[Duel Manager] Some spectator leaves room %d", this->m_Rooms[i].lpLearners[u]->Name, i + 1);

  000a6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a8	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000ab	50		 push	 eax
  000ac	83 c1 77	 add	 ecx, 119		; 00000077H
  000af	51		 push	 ecx
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FHAOCOHB@?$FLDuel?5Manager?$FN?5Some?5spectator?5le@
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   :           this->m_Rooms[i].lpLearners[u] = NULL;
; 98   :           this->SendSpectatorList(i);

  000be	57		 push	 edi
  000bf	8b cb		 mov	 ecx, ebx
  000c1	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  000c7	e8 00 00 00 00	 call	 ?SendSpectatorList@CDuelManager@@QAEXH@Z ; CDuelManager::SendSpectatorList
$LN24@Run:

; 76   : 
; 77   :       for(int u = 0; u < MAX_DUEL_LEARNERS; u++)

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _u$216307[ebp]
  000cf	40		 inc	 eax
  000d0	83 c6 04	 add	 esi, 4
  000d3	89 45 fc	 mov	 DWORD PTR _u$216307[ebp], eax
  000d6	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000d9	0f 8c 63 ff ff
	ff		 jl	 $LL25@Run

; 99   :         }
; 100  :       }
; 101  : 
; 102  :       if(this->m_Rooms[i].lpObj01 != NULL && this->m_Rooms[i].lpObj02 != NULL)

  000df	8b 75 f8	 mov	 esi, DWORD PTR tv386[ebp]
  000e2	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000e5	85 c0		 test	 eax, eax
  000e7	0f 84 b5 00 00
	00		 je	 $LN18@Run
  000ed	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  000f1	0f 84 ab 00 00
	00		 je	 $LN18@Run

; 103  :       {
; 104  :         if(gObjIsConnected(this->m_Rooms[i].lpObj01->m_Index) == FALSE ||
; 105  :           gObjIsConnected(this->m_Rooms[i].lpObj02->m_Index) == FALSE)

  000f7	8b 10		 mov	 edx, DWORD PTR [eax]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000ff	83 c4 04	 add	 esp, 4
  00102	85 c0		 test	 eax, eax
  00104	0f 84 98 00 00
	00		 je	 $LN18@Run
  0010a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0010d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00115	83 c4 04	 add	 esp, 4
  00118	85 c0		 test	 eax, eax
  0011a	0f 84 82 00 00
	00		 je	 $LN18@Run

; 106  :         {
; 107  :           this->RoomReset(i);
; 108  :           continue;
; 109  :         }
; 110  :         else if ((this->m_Rooms[i].lpObj01->MapNumber != MAP_INDEX_VULCANROOM ||
; 111  :           this->m_Rooms[i].lpObj02->MapNumber != MAP_INDEX_VULCANROOM) && 
; 112  :           this->m_Rooms[i].bHasWinner == FALSE)

  00120	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00123	80 b8 49 01 00
	00 40		 cmp	 BYTE PTR [eax+329], 64	; 00000040H
  0012a	75 0c		 jne	 SHORT $LN13@Run
  0012c	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0012f	80 ba 49 01 00
	00 40		 cmp	 BYTE PTR [edx+329], 64	; 00000040H
  00136	74 06		 je	 SHORT $LN40@Run
$LN13@Run:
  00138	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0

; 113  :         {
; 114  :           this->RoomReset(i);
; 115  :           continue;

  0013c	74 64		 je	 SHORT $LN18@Run
$LN40@Run:

; 116  :         }
; 117  :         else if (this->m_Rooms[i].lpObj01->Connected < PLAYER_PLAYING ||
; 118  :           this->m_Rooms[i].lpObj02->Connected < PLAYER_PLAYING)

  0013e	b9 03 00 00 00	 mov	 ecx, 3
  00143	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00146	7c 5a		 jl	 SHORT $LN18@Run
  00148	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0014b	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  0014e	7c 52		 jl	 SHORT $LN18@Run

; 127  :         continue;
; 128  :       }
; 129  : 
; 130  :       if(this->m_UpdateLifebarTime < GetTickCount())

  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00156	39 43 04	 cmp	 DWORD PTR [ebx+4], eax
  00159	73 16		 jae	 SHORT $LN8@Run

; 131  :       {
; 132  :         this->SendLifebarStatus(i);

  0015b	57		 push	 edi
  0015c	8b cb		 mov	 ecx, ebx
  0015e	e8 00 00 00 00	 call	 ?SendLifebarStatus@CDuelManager@@QAEXH@Z ; CDuelManager::SendLifebarStatus

; 133  :         this->m_UpdateLifebarTime = GetTickCount() + 2000;

  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00169	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0016e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN8@Run:

; 134  :       }
; 135  : 
; 136  :       if(this->m_Rooms[i].dwTickCount != 0)

  00171	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00175	74 37		 je	 SHORT $LN29@Run

; 137  :       {
; 138  :         if(this->m_Rooms[i].dwTickCount < GetTickCount())

  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0017d	39 46 50	 cmp	 DWORD PTR [esi+80], eax
  00180	73 2c		 jae	 SHORT $LN29@Run

; 139  :         {
; 140  :           this->RoomReset(i);

  00182	6a 00		 push	 0
  00184	6a 00		 push	 0
  00186	57		 push	 edi
  00187	8b cb		 mov	 ecx, ebx
  00189	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset

; 141  :           LogAddTD("[Duel Manager] Room %d cleaned.", i+1);

  0018e	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00191	51		 push	 ecx
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IOIFMHLG@?$FLDuel?5Manager?$FN?5Room?5?$CFd?5cleaned?4?$AA@
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0019d	83 c4 08	 add	 esp, 8
  001a0	eb 0c		 jmp	 SHORT $LN29@Run
$LN18@Run:

; 119  :         {
; 120  :           this->RoomReset(i);
; 121  :           continue;
; 122  :         }
; 123  :       }
; 124  :       else
; 125  :       {
; 126  :         this->RoomReset(i);

  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	57		 push	 edi
  001a7	8b cb		 mov	 ecx, ebx
  001a9	e8 00 00 00 00	 call	 ?RoomReset@CDuelManager@@QAEXH_N0@Z ; CDuelManager::RoomReset
$LN29@Run:

; 70   :   for(int i = 0; i < MAX_DUEL_ROOMS; i++)

  001ae	47		 inc	 edi
  001af	83 ff 04	 cmp	 edi, 4
  001b2	0f 8c 58 fe ff
	ff		 jl	 $LL43@Run

; 142  :         }
; 143  :       }
; 144  :     }
; 145  :   }
; 146  : 
; 147  :   if(this->m_UpdateTickCount < GetTickCount())

  001b8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  001be	ff d7		 call	 edi
  001c0	39 03		 cmp	 DWORD PTR [ebx], eax
  001c2	73 4b		 jae	 SHORT $LN5@Run

; 148  :   {
; 149  :     for(int i = OBJ_STARTUSERINDZT; i < OBJMAX; i++)

  001c4	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  001c9	8d a4 24 00 00
	00 00		 npad	 7
$LL4@Run:

; 150  :     {
; 151  :       if((gObj[i].m_IfState.use) && gObj[i].m_IfState.type == 20)

  001d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d6	8b 84 16 1c 0e
	00 00		 mov	 eax, DWORD PTR [esi+edx+3612]
  001dd	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  001e0	a8 03		 test	 al, 3
  001e2	74 14		 je	 SHORT $LN3@Run
  001e4	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  001e9	3d 00 05 00 00	 cmp	 eax, 1280		; 00000500H
  001ee	75 08		 jne	 SHORT $LN3@Run

; 152  :       {
; 153  :         this->SendDuelStatus(&gObj[i]);

  001f0	51		 push	 ecx
  001f1	8b cb		 mov	 ecx, ebx
  001f3	e8 00 00 00 00	 call	 ?SendDuelStatus@CDuelManager@@QAEXPAUOBJECTSTRUCT@@@Z ; CDuelManager::SendDuelStatus
$LN3@Run:

; 148  :   {
; 149  :     for(int i = OBJ_STARTUSERINDZT; i < OBJMAX; i++)

  001f8	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  001fe	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00204	7c ca		 jl	 SHORT $LL4@Run

; 154  :       }
; 155  :     }
; 156  :     this->m_UpdateTickCount = GetTickCount() + 6000;

  00206	ff d7		 call	 edi
  00208	05 70 17 00 00	 add	 eax, 6000		; 00001770H
  0020d	89 03		 mov	 DWORD PTR [ebx], eax
$LN5@Run:
  0020f	5f		 pop	 edi
  00210	5e		 pop	 esi
  00211	5b		 pop	 ebx

; 157  :   }
; 158  : 
; 159  :   return;
; 160  : }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
?Run@CDuelManager@@QAEXXZ ENDP				; CDuelManager::Run
_TEXT	ENDS
PUBLIC	?ProtocolCore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAE@Z ; CDuelManager::ProtocolCore
; Function compile flags: /Ogtp
;	COMDAT ?ProtocolCore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpPacket$ = 12						; size = 4
?ProtocolCore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAE@Z PROC ; CDuelManager::ProtocolCore, COMDAT
; _this$ = ecx

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 733  :   PMSG_DEFAULT2* pMsg = (PMSG_DEFAULT2*)lpPacket;
; 734  :   switch(pMsg->subcode)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpPacket$[ebp]
  00006	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0000a	4a		 dec	 edx
  0000b	83 fa 08	 cmp	 edx, 8
  0000e	77 4f		 ja	 SHORT $LN1@ProtocolCo
  00010	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@ProtocolCo[edx*4]
$LN5@ProtocolCo:

; 735  :   {
; 736  :   case 0x01:
; 737  :     this->RecvDuelRequest(lpObj, (PMSG_DUEL_REQUEST_START*)lpPacket);

  00017	50		 push	 eax
  00018	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?RecvDuelRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_START@@@Z ; CDuelManager::RecvDuelRequest

; 749  :     }
; 750  :     break;
; 751  :   }
; 752  : }

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
$LN4@ProtocolCo:

; 738  :     break;
; 739  :   case 0x02:
; 740  :     this->RecvDuelAnswer(lpObj, (PMSG_DUEL_ANSWER_START*)lpPacket);

  00025	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00028	50		 push	 eax
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?RecvDuelAnswer@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_ANSWER_START@@@Z ; CDuelManager::RecvDuelAnswer

; 749  :     }
; 750  :     break;
; 751  :   }
; 752  : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN3@ProtocolCo:

; 741  :     break;
; 742  :   case 0x07:
; 743  :     this->RecvWatchRequest(lpObj, (PMSG_DUEL_REQUEST_WATCH*)lpPacket);

  00033	50		 push	 eax
  00034	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?RecvWatchRequest@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_DUEL_REQUEST_WATCH@@@Z ; CDuelManager::RecvWatchRequest

; 749  :     }
; 750  :     break;
; 751  :   }
; 752  : }

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN2@ProtocolCo:

; 744  :     break;
; 745  :   case 0x09:
; 746  :     if(lpObj->MapNumber == MAP_INDEX_VULCANROOM)

  00041	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00044	80 b8 49 01 00
	00 40		 cmp	 BYTE PTR [eax+329], 64	; 00000040H
  0004b	75 12		 jne	 SHORT $LN1@ProtocolCo

; 747  :     {
; 748  :       gObjMoveGate(lpObj->m_Index, ZtConfig.PvP.DuelGate); // vai pro vulcan map

  0004d	8b 0d 40 09 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2368
  00053	8b 10		 mov	 edx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0005c	83 c4 08	 add	 esp, 8
$LN1@ProtocolCo:

; 749  :     }
; 750  :     break;
; 751  :   }
; 752  : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
  00063	90		 npad	 1
$LN10@ProtocolCo:
  00064	00 00 00 00	 DD	 $LN5@ProtocolCo
  00068	00 00 00 00	 DD	 $LN4@ProtocolCo
  0006c	00 00 00 00	 DD	 $LN1@ProtocolCo
  00070	00 00 00 00	 DD	 $LN1@ProtocolCo
  00074	00 00 00 00	 DD	 $LN1@ProtocolCo
  00078	00 00 00 00	 DD	 $LN1@ProtocolCo
  0007c	00 00 00 00	 DD	 $LN3@ProtocolCo
  00080	00 00 00 00	 DD	 $LN1@ProtocolCo
  00084	00 00 00 00	 DD	 $LN2@ProtocolCo
?ProtocolCore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAE@Z ENDP ; CDuelManager::ProtocolCore
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_DuelManager@@YAXXZ
text$yc	SEGMENT
??__Eg_DuelManager@@YAXXZ PROC				; `dynamic initializer for 'g_DuelManager'', COMDAT

; 35   : CDuelManager  g_DuelManager;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DuelManager@@3VCDuelManager@@A ; g_DuelManager
  00005	e8 00 00 00 00	 call	 ??0CDuelManager@@QAE@XZ	; CDuelManager::CDuelManager
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_DuelManager@@YAXXZ ; `dynamic atexit destructor for 'g_DuelManager''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_DuelManager@@YAXXZ ENDP				; `dynamic initializer for 'g_DuelManager''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_DuelManager@@YAXXZ
text$yd	SEGMENT
??__Fg_DuelManager@@YAXXZ PROC				; `dynamic atexit destructor for 'g_DuelManager'', COMDAT
  00000	c3		 ret	 0
??__Fg_DuelManager@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_DuelManager''
text$yd	ENDS
PUBLIC	?g_DuelManager@@3VCDuelManager@@A		; g_DuelManager
_BSS	SEGMENT
?g_DuelManager@@3VCDuelManager@@A DB 0140H DUP (?)	; g_DuelManager
_BSS	ENDS
CRT$XCU	SEGMENT
_g_DuelManager$initializer$ DD FLAT:??__Eg_DuelManager@@YAXXZ
CRT$XCU	ENDS
END
