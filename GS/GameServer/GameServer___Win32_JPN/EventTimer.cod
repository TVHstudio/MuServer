; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\EventTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??0cEventTimer@@QAE@XZ				; cEventTimer::cEventTimer
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\eventtimer.cpp
;	COMDAT ??0cEventTimer@@QAE@XZ
_TEXT	SEGMENT
??0cEventTimer@@QAE@XZ PROC				; cEventTimer::cEventTimer, COMDAT
; _this$ = ecx

; 26   : {

  00000	8b c1		 mov	 eax, ecx

; 27   : 
; 28   : }

  00002	c3		 ret	 0
??0cEventTimer@@QAE@XZ ENDP				; cEventTimer::cEventTimer
_TEXT	ENDS
PUBLIC	??1cEventTimer@@QAE@XZ				; cEventTimer::~cEventTimer
; Function compile flags: /Ogtp
;	COMDAT ??1cEventTimer@@QAE@XZ
_TEXT	SEGMENT
??1cEventTimer@@QAE@XZ PROC				; cEventTimer::~cEventTimer, COMDAT
; _this$ = ecx

; 32   : 
; 33   : }

  00000	c3		 ret	 0
??1cEventTimer@@QAE@XZ ENDP				; cEventTimer::~cEventTimer
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BN@PJNAMCJO@?4?2Events?2EventManagement?4dat?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BMBCGMBM@?4?2Events?2ChaosCastle?4dat?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DJALDJOM@?4?2Events?2DevilSquare?4dat?$AA@ ; `string'
PUBLIC	??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_0BJ@ILBNMJBN@?4?2Events?2BloodCastle?4dat?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_0L@JKOGOOIH@EventTimer?$AA@		; `string'
PUBLIC	??_C@_0BM@FGLABAKE@?4?4?2Data?2ZtData?2ZtCustom?4ini?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadTimer@cEventTimer@@QAEXXZ			; cEventTimer::LoadTimer
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PJNAMCJO@?4?2Events?2EventManagement?4dat?$AA@
CONST	SEGMENT
??_C@_0BN@PJNAMCJO@?4?2Events?2EventManagement?4dat?$AA@ DB '.\Events\Eve'
	DB	'ntManagement.dat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BMBCGMBM@?4?2Events?2ChaosCastle?4dat?$AA@
CONST	SEGMENT
??_C@_0BJ@BMBCGMBM@?4?2Events?2ChaosCastle?4dat?$AA@ DB '.\Events\ChaosCa'
	DB	'stle.dat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DJALDJOM@?4?2Events?2DevilSquare?4dat?$AA@
CONST	SEGMENT
??_C@_0BJ@DJALDJOM@?4?2Events?2DevilSquare?4dat?$AA@ DB '.\Events\DevilSq'
	DB	'uare.dat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@ DB '%d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ILBNMJBN@?4?2Events?2BloodCastle?4dat?$AA@
CONST	SEGMENT
??_C@_0BJ@ILBNMJBN@?4?2Events?2BloodCastle?4dat?$AA@ DB '.\Events\BloodCa'
	DB	'stle.dat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKOGOOIH@EventTimer?$AA@
CONST	SEGMENT
??_C@_0L@JKOGOOIH@EventTimer?$AA@ DB 'EventTimer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FGLABAKE@?4?4?2Data?2ZtData?2ZtCustom?4ini?$AA@
CONST	SEGMENT
??_C@_0BM@FGLABAKE@?4?4?2Data?2ZtData?2ZtCustom?4ini?$AA@ DB '..\Data\ZtD'
	DB	'ata\ZtCustom.ini', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadTimer@cEventTimer@@QAEXXZ
_TEXT	SEGMENT
_Flag$ = -792						; size = 4
_Flag2$ = -788						; size = 4
_Flag3$ = -784						; size = 4
_n$210784 = -780					; size = 8
_n$210773 = -780					; size = 8
_n$210761 = -780					; size = 8
_type$ = -776						; size = 4
_Buff2$ = -772						; size = 256
_Buff3$ = -516						; size = 256
_Buff$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?LoadTimer@cEventTimer@@QAEXXZ PROC			; cEventTimer::LoadTimer, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 03 00
	00		 sub	 esp, 792		; 00000318H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 37   : 	this->Enable = GetPrivateProfileInt("ZtTeam","EventTimer",0,ZtCustom_DIR);

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@FGLABAKE@?4?4?2Data?2ZtData?2ZtCustom?4ini?$AA@
  0001a	33 db		 xor	 ebx, ebx
  0001c	53		 push	 ebx
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JKOGOOIH@EventTimer?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00027	8b f1		 mov	 esi, ecx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0002f	89 06		 mov	 DWORD PTR [esi], eax

; 38   : 
; 39   : 	if(!this->Enable) return;

  00031	3b c3		 cmp	 eax, ebx
  00033	0f 84 61 04 00
	00		 je	 $LN28@LoadTimer

; 40   : 
; 41   : 	FILE * file = fopen(gDirPath.GetNewPath(".\\Events\\BloodCastle.dat"),"r");

  00039	57		 push	 edi
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@ILBNMJBN@?4?2Events?2BloodCastle?4dat?$AA@
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00049	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _fopen
  00054	8b f8		 mov	 edi, eax
  00056	83 c4 08	 add	 esp, 8

; 42   : 	if(file == NULL)

  00059	3b fb		 cmp	 edi, ebx
  0005b	75 24		 jne	 SHORT $LN26@LoadTimer

; 43   : 	{
; 44   : 		MessageBoxA(0,gDirPath.GetNewPath(".\\Events\\BloodCastle.dat"),"LOAD FILE ERROR",0);

  0005d	53		 push	 ebx
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@ILBNMJBN@?4?2Events?2BloodCastle?4dat?$AA@
$LN49@LoadTimer:
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0006d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00072	50		 push	 eax
  00073	53		 push	 ebx
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 45   : 		ExitProcess(0);

  0007a	53		 push	 ebx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN50@LoadTimer:
$LN26@LoadTimer:

; 46   : 	}
; 47   : 	char Buff[256];
; 48   : 	int Flag = 0;
; 49   : 	this->CountBC = 0;
; 50   : 	while(!feof(file))

  00081	57		 push	 edi
  00082	89 9d e8 fc ff
	ff		 mov	 DWORD PTR _Flag$[ebp], ebx
  00088	89 9e 24 03 00
	00		 mov	 DWORD PTR [esi+804], ebx
  0008e	e8 00 00 00 00	 call	 _feof
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	0f 85 90 00 00
	00		 jne	 $LN24@LoadTimer
  0009e	8b ff		 npad	 2
$LL25@LoadTimer:

; 51   : 	{
; 52   : 		fgets(Buff,256,file);

  000a0	57		 push	 edi
  000a1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  000a7	68 00 01 00 00	 push	 256			; 00000100H
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _fgets

; 53   : 		if(Zt_IsBadFileLine(Buff, Flag))

  000b2	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR _Flag$[ebp]
  000b8	51		 push	 ecx
  000b9	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  000c5	83 c4 14	 add	 esp, 20			; 00000014H
  000c8	84 c0		 test	 al, al
  000ca	75 51		 jne	 SHORT $LN22@LoadTimer

; 54   : 			continue;
; 55   : 		if(Flag == 4)

  000cc	83 bd e8 fc ff
	ff 04		 cmp	 DWORD PTR _Flag$[ebp], 4
  000d3	75 48		 jne	 SHORT $LN22@LoadTimer

; 56   : 		{
; 57   : 			int n[2];
; 58   : 			sscanf(Buff, "%d %d", &n[0], &n[1]);

  000d5	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _n$210761[ebp+4]
  000db	50		 push	 eax
  000dc	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _n$210761[ebp]
  000e2	51		 push	 ecx
  000e3	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _sscanf

; 59   : 			this->BC[this->CountBC].Hour = n[0];

  000f4	8b 86 24 03 00
	00		 mov	 eax, DWORD PTR [esi+804]
  000fa	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _n$210761[ebp]
  00100	89 4c c6 04	 mov	 DWORD PTR [esi+eax*8+4], ecx

; 60   : 			this->BC[this->CountBC].Min = n[1];

  00104	8b 96 24 03 00
	00		 mov	 edx, DWORD PTR [esi+804]
  0010a	8b 85 f8 fc ff
	ff		 mov	 eax, DWORD PTR _n$210761[ebp+4]
  00110	83 c4 10	 add	 esp, 16			; 00000010H
  00113	89 44 d6 08	 mov	 DWORD PTR [esi+edx*8+8], eax

; 61   : 			this->CountBC++;

  00117	ff 86 24 03 00
	00		 inc	 DWORD PTR [esi+804]
$LN22@LoadTimer:

; 46   : 	}
; 47   : 	char Buff[256];
; 48   : 	int Flag = 0;
; 49   : 	this->CountBC = 0;
; 50   : 	while(!feof(file))

  0011d	57		 push	 edi
  0011e	e8 00 00 00 00	 call	 _feof
  00123	83 c4 04	 add	 esp, 4
  00126	85 c0		 test	 eax, eax
  00128	0f 84 72 ff ff
	ff		 je	 $LL25@LoadTimer
$LN24@LoadTimer:

; 62   : 		}
; 63   : 	}
; 64   : 	fclose(file);

  0012e	57		 push	 edi
  0012f	e8 00 00 00 00	 call	 _fclose
  00134	83 c4 04	 add	 esp, 4

; 65   : 
; 66   : 	// ----
; 67   : 
; 68   : 	FILE * file2 = fopen(gDirPath.GetNewPath(".\\Events\\DevilSquare.dat"),"r");

  00137	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DJALDJOM@?4?2Events?2DevilSquare?4dat?$AA@
  00141	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00146	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _fopen
  00151	8b d8		 mov	 ebx, eax

; 69   : 	if(file2 == NULL)

  00153	33 c0		 xor	 eax, eax
  00155	83 c4 08	 add	 esp, 8
  00158	3b d8		 cmp	 ebx, eax
  0015a	75 26		 jne	 SHORT $LN21@LoadTimer

; 70   : 	{
; 71   : 		MessageBoxA(0,gDirPath.GetNewPath(".\\Events\\DevilSquare.dat"),"LOAD FILE ERROR",0);

  0015c	50		 push	 eax
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DJALDJOM@?4?2Events?2DevilSquare?4dat?$AA@
  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0016c	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00171	50		 push	 eax
  00172	6a 00		 push	 0
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 72   : 		ExitProcess(0);

  0017a	6a 00		 push	 0
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN51@LoadTimer:
$LN21@LoadTimer:

; 73   : 	}
; 74   : 	char Buff2[256];
; 75   : 	int Flag2 = 0;
; 76   : 	this->CountDS = 0;
; 77   : 	while(!feof(file2))

  00182	53		 push	 ebx
  00183	89 85 ec fc ff
	ff		 mov	 DWORD PTR _Flag2$[ebp], eax
  00189	89 86 48 06 00
	00		 mov	 DWORD PTR [esi+1608], eax
  0018f	e8 00 00 00 00	 call	 _feof
  00194	83 c4 04	 add	 esp, 4
  00197	85 c0		 test	 eax, eax
  00199	0f 85 95 00 00
	00		 jne	 $LN19@LoadTimer
  0019f	90		 npad	 1
$LL20@LoadTimer:

; 78   : 	{
; 79   : 		fgets(Buff2,256,file);

  001a0	57		 push	 edi
  001a1	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR _Buff2$[ebp]
  001a7	68 00 01 00 00	 push	 256			; 00000100H
  001ac	51		 push	 ecx
  001ad	e8 00 00 00 00	 call	 _fgets

; 80   : 		if(Zt_IsBadFileLine(Buff2, Flag2))

  001b2	8d 95 ec fc ff
	ff		 lea	 edx, DWORD PTR _Flag2$[ebp]
  001b8	52		 push	 edx
  001b9	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _Buff2$[ebp]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  001c5	83 c4 14	 add	 esp, 20			; 00000014H
  001c8	84 c0		 test	 al, al
  001ca	75 57		 jne	 SHORT $LN17@LoadTimer

; 81   : 			continue;
; 82   : 		if(Flag2 == 4)

  001cc	83 bd ec fc ff
	ff 04		 cmp	 DWORD PTR _Flag2$[ebp], 4
  001d3	75 4e		 jne	 SHORT $LN17@LoadTimer

; 83   : 		{
; 84   : 			int n[2];
; 85   : 			sscanf(Buff2, "%d %d", &n[0], &n[1]);

  001d5	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _n$210773[ebp+4]
  001db	51		 push	 ecx
  001dc	8d 95 f4 fc ff
	ff		 lea	 edx, DWORD PTR _n$210773[ebp]
  001e2	52		 push	 edx
  001e3	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _Buff2$[ebp]
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _sscanf

; 86   : 			this->DS[this->CountDS].Hour = n[0];

  001f4	8b 8e 48 06 00
	00		 mov	 ecx, DWORD PTR [esi+1608]
  001fa	8b 95 f4 fc ff
	ff		 mov	 edx, DWORD PTR _n$210773[ebp]
  00200	89 94 ce 28 03
	00 00		 mov	 DWORD PTR [esi+ecx*8+808], edx

; 87   : 			this->DS[this->CountDS].Min = n[1];

  00207	8b 86 48 06 00
	00		 mov	 eax, DWORD PTR [esi+1608]
  0020d	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR _n$210773[ebp+4]
  00213	83 c4 10	 add	 esp, 16			; 00000010H
  00216	89 8c c6 2c 03
	00 00		 mov	 DWORD PTR [esi+eax*8+812], ecx

; 88   : 			this->CountDS++;

  0021d	ff 86 48 06 00
	00		 inc	 DWORD PTR [esi+1608]
$LN17@LoadTimer:

; 73   : 	}
; 74   : 	char Buff2[256];
; 75   : 	int Flag2 = 0;
; 76   : 	this->CountDS = 0;
; 77   : 	while(!feof(file2))

  00223	53		 push	 ebx
  00224	e8 00 00 00 00	 call	 _feof
  00229	83 c4 04	 add	 esp, 4
  0022c	85 c0		 test	 eax, eax
  0022e	0f 84 6c ff ff
	ff		 je	 $LL20@LoadTimer
$LN19@LoadTimer:

; 89   : 		}
; 90   : 	}
; 91   : 	fclose(file2);

  00234	53		 push	 ebx
  00235	e8 00 00 00 00	 call	 _fclose
  0023a	83 c4 04	 add	 esp, 4

; 92   : 
; 93   : 	// ----
; 94   : 
; 95   : 	FILE * file3 = fopen(gDirPath.GetNewPath(".\\Events\\ChaosCastle.dat"),"r");

  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BMBCGMBM@?4?2Events?2ChaosCastle?4dat?$AA@
  00247	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0024c	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _fopen
  00257	8b f8		 mov	 edi, eax

; 96   : 	if(file3 == NULL)

  00259	33 db		 xor	 ebx, ebx
  0025b	83 c4 08	 add	 esp, 8
  0025e	3b fb		 cmp	 edi, ebx
  00260	75 10		 jne	 SHORT $LN16@LoadTimer

; 97   : 	{
; 98   : 		MessageBoxA(0,gDirPath.GetNewPath(".\\Events\\ChaosCastle.dat"),"LOAD FILE ERROR",0);

  00262	53		 push	 ebx
  00263	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BMBCGMBM@?4?2Events?2ChaosCastle?4dat?$AA@

; 99   : 		ExitProcess(0);

  0026d	e9 f6 fd ff ff	 jmp	 $LN49@LoadTimer
$LN16@LoadTimer:

; 100  : 	}
; 101  : 	char Buff3[256];
; 102  : 	int Flag3 = 0;
; 103  : 	this->CountCC = 0;
; 104  : 	while(!feof(file3))

  00272	57		 push	 edi
  00273	89 9d f0 fc ff
	ff		 mov	 DWORD PTR _Flag3$[ebp], ebx
  00279	89 9e 6c 09 00
	00		 mov	 DWORD PTR [esi+2412], ebx
  0027f	e8 00 00 00 00	 call	 _feof
  00284	83 c4 04	 add	 esp, 4
  00287	85 c0		 test	 eax, eax
  00289	0f 85 95 00 00
	00		 jne	 $LN14@LoadTimer
  0028f	90		 npad	 1
$LL15@LoadTimer:

; 105  : 	{
; 106  : 		fgets(Buff3,256,file3);

  00290	57		 push	 edi
  00291	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR _Buff3$[ebp]
  00297	68 00 01 00 00	 push	 256			; 00000100H
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 _fgets

; 107  : 		if(Zt_IsBadFileLine(Buff3, Flag3))

  002a2	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _Flag3$[ebp]
  002a8	50		 push	 eax
  002a9	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _Buff3$[ebp]
  002af	51		 push	 ecx
  002b0	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  002b5	83 c4 14	 add	 esp, 20			; 00000014H
  002b8	84 c0		 test	 al, al
  002ba	75 57		 jne	 SHORT $LN12@LoadTimer

; 108  : 			continue;
; 109  : 		if(Flag3 == 2)

  002bc	83 bd f0 fc ff
	ff 02		 cmp	 DWORD PTR _Flag3$[ebp], 2
  002c3	75 4e		 jne	 SHORT $LN12@LoadTimer

; 110  : 		{
; 111  : 			int n[2];
; 112  : 			sscanf(Buff3, "%d %d", &n[0], &n[1]);

  002c5	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR _n$210784[ebp+4]
  002cb	52		 push	 edx
  002cc	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _n$210784[ebp]
  002d2	50		 push	 eax
  002d3	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _Buff3$[ebp]
  002d9	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  002de	51		 push	 ecx
  002df	e8 00 00 00 00	 call	 _sscanf

; 113  : 			this->CC[this->CountCC].Hour = n[0];

  002e4	8b 96 6c 09 00
	00		 mov	 edx, DWORD PTR [esi+2412]
  002ea	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _n$210784[ebp]
  002f0	89 84 d6 4c 06
	00 00		 mov	 DWORD PTR [esi+edx*8+1612], eax

; 114  : 			this->CC[this->CountCC].Min = n[1];

  002f7	8b 8e 6c 09 00
	00		 mov	 ecx, DWORD PTR [esi+2412]
  002fd	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _n$210784[ebp+4]
  00303	83 c4 10	 add	 esp, 16			; 00000010H
  00306	89 94 ce 50 06
	00 00		 mov	 DWORD PTR [esi+ecx*8+1616], edx

; 115  : 			this->CountCC++;

  0030d	ff 86 6c 09 00
	00		 inc	 DWORD PTR [esi+2412]
$LN12@LoadTimer:

; 100  : 	}
; 101  : 	char Buff3[256];
; 102  : 	int Flag3 = 0;
; 103  : 	this->CountCC = 0;
; 104  : 	while(!feof(file3))

  00313	57		 push	 edi
  00314	e8 00 00 00 00	 call	 _feof
  00319	83 c4 04	 add	 esp, 4
  0031c	85 c0		 test	 eax, eax
  0031e	0f 84 6c ff ff
	ff		 je	 $LL15@LoadTimer
$LN14@LoadTimer:

; 116  : 		}
; 117  : 	}
; 118  : 	fclose(file3);

  00324	57		 push	 edi
  00325	e8 00 00 00 00	 call	 _fclose
  0032a	83 c4 04	 add	 esp, 4

; 119  : 
; 120  : 	// ----
; 121  : 
; 122  : 	SMDFile = fopen(gDirPath.GetNewPath(".\\Events\\EventManagement.dat"), "r");

  0032d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00332	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJNAMCJO@?4?2Events?2EventManagement?4dat?$AA@
  00337	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0033c	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 _fopen
  00347	83 c4 08	 add	 esp, 8
  0034a	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 123  : 
; 124  : 	if ( SMDFile == NULL )

  0034f	3b c3		 cmp	 eax, ebx
  00351	75 10		 jne	 SHORT $LN11@LoadTimer

; 125  : 	{
; 126  : 		MessageBoxA(0,gDirPath.GetNewPath(".\\Events\\EventManagement.dat"),"LOAD FILE ERROR",0);

  00353	53		 push	 ebx
  00354	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  00359	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJNAMCJO@?4?2Events?2EventManagement?4dat?$AA@

; 127  : 		ExitProcess(0);

  0035e	e9 05 fd ff ff	 jmp	 $LN49@LoadTimer
$LN11@LoadTimer:

; 128  : 	}
; 129  : 
; 130  : 	int Token;
; 131  : 	int type = -1;
; 132  : 
; 133  : 	while ( true )
; 134  : 	{
; 135  : 		Token = GetToken();

  00363	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 136  : 
; 137  : 		if ( Token == 2 )

  00368	83 f8 02	 cmp	 eax, 2
  0036b	0f 84 1a 01 00
	00		 je	 $LN41@LoadTimer
$LL10@LoadTimer:

; 138  : 		{
; 139  : 			break;
; 140  : 		}
; 141  : 
; 142  : 		type = (int)TokenNumber;

  00371	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00377	e8 00 00 00 00	 call	 __ftol2_sse
  0037c	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _type$[ebp], eax
$LL7@LoadTimer:

; 143  : 
; 144  : 		while ( true )
; 145  : 		{
; 146  : 			if ( type == 0 )

  00382	83 bd f8 fc ff
	ff 00		 cmp	 DWORD PTR _type$[ebp], 0
  00389	75 f7		 jne	 SHORT $LL7@LoadTimer

; 147  : 			{
; 148  : 				Token = GetToken();

  0038b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 149  : 
; 150  : 				if ( strcmp("end", TokenString) == 0 )

  00390	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00395	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0039a	8d 9b 00 00 00
	00		 npad	 6
$LL42@LoadTimer:
  003a0	8a 10		 mov	 dl, BYTE PTR [eax]
  003a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  003a4	75 1a		 jne	 SHORT $LN43@LoadTimer
  003a6	84 d2		 test	 dl, dl
  003a8	74 12		 je	 SHORT $LN47@LoadTimer
  003aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  003ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  003b0	75 0e		 jne	 SHORT $LN43@LoadTimer
  003b2	83 c0 02	 add	 eax, 2
  003b5	83 c1 02	 add	 ecx, 2
  003b8	84 d2		 test	 dl, dl
  003ba	75 e4		 jne	 SHORT $LL42@LoadTimer
$LN47@LoadTimer:
  003bc	33 c0		 xor	 eax, eax
  003be	eb 05		 jmp	 SHORT $LN45@LoadTimer
$LN43@LoadTimer:
  003c0	1b c0		 sbb	 eax, eax
  003c2	83 d8 ff	 sbb	 eax, -1
$LN45@LoadTimer:
  003c5	85 c0		 test	 eax, eax
  003c7	0f 84 b0 00 00
	00		 je	 $LN40@LoadTimer

; 151  : 				{
; 152  : 					break;
; 153  : 				}
; 154  : 
; 155  : 				int EventType  = (int)TokenNumber;

  003cd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003d3	e8 00 00 00 00	 call	 __ftol2_sse
  003d8	8b d8		 mov	 ebx, eax

; 156  : 
; 157  : 				Token = GetToken();

  003da	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 158  : 				int EventHour = (int)TokenNumber;

  003df	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003e5	e8 00 00 00 00	 call	 __ftol2_sse
  003ea	8b f8		 mov	 edi, eax

; 159  : 
; 160  : 				Token = GetToken();

  003ec	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 161  : 				int EventMin = (int)TokenNumber;

  003f1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003f7	e8 00 00 00 00	 call	 __ftol2_sse

; 162  : 
; 163  : 				if(EventType == 2)

  003fc	83 fb 02	 cmp	 ebx, 2
  003ff	75 25		 jne	 SHORT $LN3@LoadTimer

; 164  : 				{
; 165  : 					this->GD[this->CountGD].Hour = EventHour;

  00401	8b 8e 90 0c 00
	00		 mov	 ecx, DWORD PTR [esi+3216]
  00407	89 bc ce 70 09
	00 00		 mov	 DWORD PTR [esi+ecx*8+2416], edi

; 166  : 					this->GD[this->CountGD].Min = EventMin;

  0040e	8b 96 90 0c 00
	00		 mov	 edx, DWORD PTR [esi+3216]
  00414	89 84 d6 74 09
	00 00		 mov	 DWORD PTR [esi+edx*8+2420], eax

; 167  : 					this->CountGD++;

  0041b	ff 86 90 0c 00
	00		 inc	 DWORD PTR [esi+3216]

; 168  : 				}
; 169  : 				if(EventType == 3)

  00421	e9 5c ff ff ff	 jmp	 $LL7@LoadTimer
$LN3@LoadTimer:
  00426	83 fb 03	 cmp	 ebx, 3
  00429	75 25		 jne	 SHORT $LN2@LoadTimer

; 170  : 				{
; 171  : 					this->WW[this->CountWW].Hour = EventHour;

  0042b	8b 8e b4 0f 00
	00		 mov	 ecx, DWORD PTR [esi+4020]
  00431	89 bc ce 94 0c
	00 00		 mov	 DWORD PTR [esi+ecx*8+3220], edi

; 172  : 					this->WW[this->CountWW].Min = EventMin;

  00438	8b 96 b4 0f 00
	00		 mov	 edx, DWORD PTR [esi+4020]
  0043e	89 84 d6 98 0c
	00 00		 mov	 DWORD PTR [esi+edx*8+3224], eax

; 173  : 					this->CountWW++;

  00445	ff 86 b4 0f 00
	00		 inc	 DWORD PTR [esi+4020]

; 174  : 				}
; 175  : 				if(EventType == 0)

  0044b	e9 32 ff ff ff	 jmp	 $LL7@LoadTimer
$LN2@LoadTimer:
  00450	85 db		 test	 ebx, ebx
  00452	0f 85 2a ff ff
	ff		 jne	 $LL7@LoadTimer

; 176  : 				{
; 177  : 					this->RD[this->CountRD].Hour = EventHour;

  00458	8b 8e d8 12 00
	00		 mov	 ecx, DWORD PTR [esi+4824]
  0045e	89 bc ce b8 0f
	00 00		 mov	 DWORD PTR [esi+ecx*8+4024], edi

; 178  : 					this->RD[this->CountRD].Min = EventMin;

  00465	8b 96 d8 12 00
	00		 mov	 edx, DWORD PTR [esi+4824]
  0046b	89 84 d6 bc 0f
	00 00		 mov	 DWORD PTR [esi+edx*8+4028], eax

; 179  : 					this->CountRD++;

  00472	ff 86 d8 12 00
	00		 inc	 DWORD PTR [esi+4824]

; 180  : 				}
; 181  : 			}
; 182  : 		}

  00478	e9 05 ff ff ff	 jmp	 $LL7@LoadTimer
$LN40@LoadTimer:

; 128  : 	}
; 129  : 
; 130  : 	int Token;
; 131  : 	int type = -1;
; 132  : 
; 133  : 	while ( true )
; 134  : 	{
; 135  : 		Token = GetToken();

  0047d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 136  : 
; 137  : 		if ( Token == 2 )

  00482	83 f8 02	 cmp	 eax, 2
  00485	0f 85 e6 fe ff
	ff		 jne	 $LL10@LoadTimer
$LN41@LoadTimer:

; 183  : 	}
; 184  : 
; 185  : 	fclose(SMDFile);

  0048b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00490	50		 push	 eax
  00491	e8 00 00 00 00	 call	 _fclose
  00496	83 c4 04	 add	 esp, 4
  00499	5f		 pop	 edi
$LN28@LoadTimer:

; 186  : 
; 187  : }

  0049a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049d	5e		 pop	 esi
  0049e	33 cd		 xor	 ecx, ebp
  004a0	5b		 pop	 ebx
  004a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a6	8b e5		 mov	 esp, ebp
  004a8	5d		 pop	 ebp
  004a9	c3		 ret	 0
$LN48@LoadTimer:
?LoadTimer@cEventTimer@@QAEXXZ ENDP			; cEventTimer::LoadTimer
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Client@cEventTimer@@QAEXXZ			; cEventTimer::Client
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_DungeonSiege@@3VCDungeonSiege@@A:BYTE	; g_DungeonSiege
EXTRN	?GetStateDate@CCastleSiege@@QAEXHPAU_SYSTEMTIME@@@Z:PROC ; CCastleSiege::GetStateDate
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
EXTRN	?DropEvent@@3VcDropEvent@@A:BYTE		; DropEvent
EXTRN	?HappyHour@@3VcHappyHour@@A:BYTE		; HappyHour
EXTRN	?g_TeleportShop@@3VTeleportShop@@A:BYTE		; g_TeleportShop
EXTRN	?SearchEvent@@3VcSearchEvent@@A:BYTE		; SearchEvent
EXTRN	?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A:BYTE	; gPandoraBoxEvent
EXTRN	?TvT@@3VcTvTEvent@@A:BYTE			; TvT
EXTRN	?g_DeviasBattle@@3VCDeviasBattle@@A:BYTE	; g_DeviasBattle
EXTRN	?LoraBattle@@3VcLoraBattle@@A:BYTE		; LoraBattle
EXTRN	?GetCustom@CZtLicense@@QAEHXZ:PROC		; CZtLicense::GetCustom
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Client@cEventTimer@@QAEXXZ
_TEXT	SEGMENT
_TimeCastleSiege$ = -180				; size = 4
_TimeCryWolf$ = -176					; size = 4
_TimeDungeonSiege$ = -172				; size = 4
_CCStart$ = -168					; size = 4
_WWStart$ = -164					; size = 4
_DSStart$ = -160					; size = 4
_GDStart$ = -156					; size = 4
_BCStart$ = -152					; size = 4
_TimeShop$ = -148					; size = 4
_TimePandora$ = -144					; size = 4
_TimeDevias$ = -140					; size = 4
_TimeTvT$ = -136					; size = 4
_RDStart$ = -132					; size = 4
_TimeLora$ = -128					; size = 4
_TimeDropEvent$ = -124					; size = 4
_TimeHappy$ = -120					; size = 4
_TimeEvengelion$ = -116					; size = 4
tv2698 = -112						; size = 4
_this$GSCopy$ = -112					; size = 4
_tm$210968 = -108					; size = 16
_tSend$210992 = -92					; size = 72
_t$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?Client@cEventTimer@@QAEXXZ PROC			; cEventTimer::Client, COMDAT
; _this$ = ecx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 191  : 	if(!this->Enable) return;

  00017	33 db		 xor	 ebx, ebx

; 204  : 
; 205  : 	for(int i=0;i<this->CountBC;i++)

  00019	89 75 90	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0001c	39 1e		 cmp	 DWORD PTR [esi], ebx
  0001e	0f 84 c5 09 00
	00		 je	 $LN2@Client

; 192  : 
; 193  : 	DWORD BCStart = 0;
; 194  : 	DWORD DSStart = 0;
; 195  : 	DWORD CCStart = 0;
; 196  : 	DWORD GDStart = 0;
; 197  : 	DWORD WWStart = 0;
; 198  : 	DWORD RDStart = 0;
; 199  : 
; 200  : 	SYSTEMTIME t;
; 201  : 	GetLocalTime(&t);

  00024	57		 push	 edi
  00025	8d 45 ec	 lea	 eax, DWORD PTR _t$[ebp]
  00028	50		 push	 eax
  00029	89 9d 68 ff ff
	ff		 mov	 DWORD PTR _BCStart$[ebp], ebx
  0002f	89 9d 60 ff ff
	ff		 mov	 DWORD PTR _DSStart$[ebp], ebx
  00035	89 9d 58 ff ff
	ff		 mov	 DWORD PTR _CCStart$[ebp], ebx
  0003b	89 9d 64 ff ff
	ff		 mov	 DWORD PTR _GDStart$[ebp], ebx
  00041	89 9d 5c ff ff
	ff		 mov	 DWORD PTR _WWStart$[ebp], ebx
  00047	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _RDStart$[ebp], ebx
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 202  : 
; 203  : 	DWORD Tim = time(NULL);

  00053	53		 push	 ebx
  00054	e8 00 00 00 00	 call	 __time64
  00059	8b b6 24 03 00
	00		 mov	 esi, DWORD PTR [esi+804]
  0005f	83 c4 04	 add	 esp, 4

; 204  : 
; 205  : 	for(int i=0;i<this->CountBC;i++)

  00062	3b f3		 cmp	 esi, ebx
  00064	7e 5c		 jle	 SHORT $LN150@Client
  00066	0f b7 45 f4	 movzx	 eax, WORD PTR _t$[ebp+8]
  0006a	0f b7 55 f6	 movzx	 edx, WORD PTR _t$[ebp+10]
  0006e	8b c8		 mov	 ecx, eax
  00070	c1 e1 04	 shl	 ecx, 4
  00073	2b c8		 sub	 ecx, eax
  00075	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00078	0f b7 55 f8	 movzx	 edx, WORD PTR _t$[ebp+12]
  0007c	8b c8		 mov	 ecx, eax
  0007e	c1 e1 04	 shl	 ecx, 4
  00081	2b c8		 sub	 ecx, eax
  00083	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00086	8b 55 90	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  00089	83 c2 08	 add	 edx, 8
  0008c	8d 64 24 00	 npad	 4
$LL98@Client:

; 206  : 	{
; 207  : /*
; 208  : 	ATLENSURE( nYear >= 1900 );
; 209  : 	ATLENSURE( nMonth >= 1 && nMonth <= 12 );
; 210  : 	ATLENSURE( nDay >= 1 && nDay <= 31 );
; 211  : 	ATLENSURE( nHour >= 0 && nHour <= 23 );
; 212  : 	ATLENSURE( nMin >= 0 && nMin <= 59 );
; 213  : 	ATLENSURE( nSec >= 0 && nSec <= 59 );
; 214  : */
; 215  : 
; 216  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 217  : 		int fTime = this->BC[i].Hour * 3600 + this->BC[i].Min * 60 ;

  00090	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00093	8b f9		 mov	 edi, ecx
  00095	c1 e7 04	 shl	 edi, 4
  00098	2b f9		 sub	 edi, ecx
  0009a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009c	8d 3c b9	 lea	 edi, DWORD PTR [ecx+edi*4]
  0009f	8b cf		 mov	 ecx, edi
  000a1	c1 e1 04	 shl	 ecx, 4
  000a4	2b cf		 sub	 ecx, edi
  000a6	03 c9		 add	 ecx, ecx
  000a8	03 c9		 add	 ecx, ecx

; 218  : 
; 219  : 		if(fTime > lTime )

  000aa	3b c8		 cmp	 ecx, eax
  000ac	7f 0a		 jg	 SHORT $LN121@Client

; 204  : 
; 205  : 	for(int i=0;i<this->CountBC;i++)

  000ae	43		 inc	 ebx
  000af	83 c2 08	 add	 edx, 8
  000b2	3b de		 cmp	 ebx, esi
  000b4	7c da		 jl	 SHORT $LL98@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  000b6	eb 0a		 jmp	 SHORT $LN150@Client
$LN121@Client:

; 220  : 		{
; 221  : 			BCStart = fTime - lTime;

  000b8	2b c8		 sub	 ecx, eax
  000ba	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _BCStart$[ebp], ecx

; 222  : 			break;
; 223  : 		}
; 224  : 	}
; 225  : 
; 226  : 	if(BCStart == 0)

  000c0	75 4d		 jne	 SHORT $LN168@Client
$LN150@Client:

; 227  : 	{
; 228  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  000c2	0f b7 45 f4	 movzx	 eax, WORD PTR _t$[ebp+8]
  000c6	8b d0		 mov	 edx, eax
  000c8	c1 e2 04	 shl	 edx, 4
  000cb	2b d0		 sub	 edx, eax
  000cd	0f b7 45 f6	 movzx	 eax, WORD PTR _t$[ebp+10]
  000d1	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  000d4	0f b7 55 f8	 movzx	 edx, WORD PTR _t$[ebp+12]
  000d8	8b c8		 mov	 ecx, eax
  000da	c1 e1 04	 shl	 ecx, 4
  000dd	2b c8		 sub	 ecx, eax
  000df	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 229  : 		int fTime =  86400 + this->BC[0].Hour * 3600 + this->BC[0].Min * 60 ;

  000e2	8b 55 90	 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  000e5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e8	83 c1 18	 add	 ecx, 24			; 00000018H
  000eb	8b f1		 mov	 esi, ecx
  000ed	c1 e6 04	 shl	 esi, 4
  000f0	2b f1		 sub	 esi, ecx
  000f2	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000f5	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  000f8	8b ca		 mov	 ecx, edx
  000fa	c1 e1 04	 shl	 ecx, 4
  000fd	2b ca		 sub	 ecx, edx
  000ff	03 c9		 add	 ecx, ecx
  00101	03 c9		 add	 ecx, ecx

; 230  : 
; 231  : 		if(fTime > lTime )

  00103	3b c8		 cmp	 ecx, eax
  00105	7e 08		 jle	 SHORT $LN168@Client

; 232  : 		{
; 233  : 			BCStart = fTime - lTime;

  00107	2b c8		 sub	 ecx, eax
  00109	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _BCStart$[ebp], ecx
$LN168@Client:

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	// ----
; 238  : 
; 239  : 	for(int i=0;i<this->CountDS;i++)

  0010f	8b 7d 90	 mov	 edi, DWORD PTR _this$GSCopy$[ebp]
  00112	33 db		 xor	 ebx, ebx
  00114	39 9f 48 06 00
	00		 cmp	 DWORD PTR [edi+1608], ebx
  0011a	7e 3c		 jle	 SHORT $LN169@Client
  0011c	8d 97 2c 03 00
	00		 lea	 edx, DWORD PTR [edi+812]
$LL92@Client:

; 240  : 	{
; 241  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 242  : 		int fTime = this->DS[i].Hour * 3600 + this->DS[i].Min * 60 ;

  00122	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00125	8b f1		 mov	 esi, ecx
  00127	c1 e6 04	 shl	 esi, 4
  0012a	2b f1		 sub	 esi, ecx
  0012c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0012e	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  00131	8b ce		 mov	 ecx, esi
  00133	c1 e1 04	 shl	 ecx, 4
  00136	2b ce		 sub	 ecx, esi
  00138	03 c9		 add	 ecx, ecx
  0013a	03 c9		 add	 ecx, ecx

; 243  : 
; 244  : 		if(fTime > lTime )

  0013c	3b c8		 cmp	 ecx, eax
  0013e	7f 0e		 jg	 SHORT $LN122@Client

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	// ----
; 238  : 
; 239  : 	for(int i=0;i<this->CountDS;i++)

  00140	43		 inc	 ebx
  00141	83 c2 08	 add	 edx, 8
  00144	3b 9f 48 06 00
	00		 cmp	 ebx, DWORD PTR [edi+1608]
  0014a	7c d6		 jl	 SHORT $LL92@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  0014c	eb 0a		 jmp	 SHORT $LN169@Client
$LN122@Client:

; 245  : 		{
; 246  : 			DSStart = fTime - lTime;

  0014e	2b c8		 sub	 ecx, eax
  00150	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _DSStart$[ebp], ecx

; 247  : 			break;
; 248  : 		}
; 249  : 	}
; 250  : 
; 251  : 	if(DSStart == 0)

  00156	75 30		 jne	 SHORT $LN170@Client
$LN169@Client:

; 252  : 	{
; 253  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 254  : 		int fTime =  86400 + this->DS[0].Hour * 3600 + this->DS[0].Min * 60 ;

  00158	8b 8f 28 03 00
	00		 mov	 ecx, DWORD PTR [edi+808]
  0015e	83 c1 18	 add	 ecx, 24			; 00000018H
  00161	8b d1		 mov	 edx, ecx
  00163	c1 e2 04	 shl	 edx, 4
  00166	2b d1		 sub	 edx, ecx
  00168	8b 8f 2c 03 00
	00		 mov	 ecx, DWORD PTR [edi+812]
  0016e	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00171	8b ca		 mov	 ecx, edx
  00173	c1 e1 04	 shl	 ecx, 4
  00176	2b ca		 sub	 ecx, edx
  00178	03 c9		 add	 ecx, ecx
  0017a	03 c9		 add	 ecx, ecx

; 255  : 
; 256  : 		if(fTime > lTime )

  0017c	3b c8		 cmp	 ecx, eax
  0017e	7e 08		 jle	 SHORT $LN170@Client

; 257  : 		{
; 258  : 			DSStart = fTime - lTime;

  00180	2b c8		 sub	 ecx, eax
  00182	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _DSStart$[ebp], ecx
$LN170@Client:

; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	// ----
; 263  : 
; 264  : 	for(int i=0;i<this->CountCC;i++)

  00188	8b 8f 6c 09 00
	00		 mov	 ecx, DWORD PTR [edi+2412]
  0018e	33 db		 xor	 ebx, ebx
  00190	85 c9		 test	 ecx, ecx
  00192	7e 42		 jle	 SHORT $LN152@Client
  00194	8d 97 50 06 00
	00		 lea	 edx, DWORD PTR [edi+1616]
  0019a	8d 9b 00 00 00
	00		 npad	 6
$LL86@Client:

; 265  : 	{
; 266  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 267  : 		int fTime = this->CC[i].Hour * 3600 + this->CC[i].Min * 60 ;

  001a0	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  001a3	8b f1		 mov	 esi, ecx
  001a5	c1 e6 04	 shl	 esi, 4
  001a8	2b f1		 sub	 esi, ecx
  001aa	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001ac	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  001af	8b ce		 mov	 ecx, esi
  001b1	c1 e1 04	 shl	 ecx, 4
  001b4	2b ce		 sub	 ecx, esi
  001b6	03 c9		 add	 ecx, ecx
  001b8	03 c9		 add	 ecx, ecx

; 268  : 
; 269  : 		if(fTime > lTime )

  001ba	3b c8		 cmp	 ecx, eax
  001bc	7f 0e		 jg	 SHORT $LN123@Client

; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	// ----
; 263  : 
; 264  : 	for(int i=0;i<this->CountCC;i++)

  001be	43		 inc	 ebx
  001bf	83 c2 08	 add	 edx, 8
  001c2	3b 9f 6c 09 00
	00		 cmp	 ebx, DWORD PTR [edi+2412]
  001c8	7c d6		 jl	 SHORT $LL86@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  001ca	eb 0a		 jmp	 SHORT $LN152@Client
$LN123@Client:

; 270  : 		{
; 271  : 			CCStart = fTime - lTime;

  001cc	2b c8		 sub	 ecx, eax
  001ce	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _CCStart$[ebp], ecx

; 272  : 			break;
; 273  : 		}
; 274  : 	}
; 275  : 
; 276  : 	if(CCStart == 0)

  001d4	75 30		 jne	 SHORT $LN175@Client
$LN152@Client:

; 277  : 	{
; 278  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 279  : 		int fTime =  86400 + this->CC[0].Hour * 3600 + this->CC[0].Min * 60 ;

  001d6	8b 8f 4c 06 00
	00		 mov	 ecx, DWORD PTR [edi+1612]
  001dc	83 c1 18	 add	 ecx, 24			; 00000018H
  001df	8b d1		 mov	 edx, ecx
  001e1	c1 e2 04	 shl	 edx, 4
  001e4	2b d1		 sub	 edx, ecx
  001e6	8b 8f 50 06 00
	00		 mov	 ecx, DWORD PTR [edi+1616]
  001ec	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  001ef	8b ca		 mov	 ecx, edx
  001f1	c1 e1 04	 shl	 ecx, 4
  001f4	2b ca		 sub	 ecx, edx
  001f6	03 c9		 add	 ecx, ecx
  001f8	03 c9		 add	 ecx, ecx

; 280  : 
; 281  : 		if(fTime > lTime )

  001fa	3b c8		 cmp	 ecx, eax
  001fc	7e 08		 jle	 SHORT $LN175@Client

; 282  : 		{
; 283  : 			CCStart = fTime - lTime;

  001fe	2b c8		 sub	 ecx, eax
  00200	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _CCStart$[ebp], ecx
$LN175@Client:

; 284  : 		}
; 285  : 	}
; 286  : 
; 287  : 	// ----
; 288  : 
; 289  : 	for(int i=0;i<this->CountGD;i++)

  00206	33 db		 xor	 ebx, ebx
  00208	39 9f 90 0c 00
	00		 cmp	 DWORD PTR [edi+3216], ebx
  0020e	7e 3c		 jle	 SHORT $LN153@Client
  00210	8d 97 74 09 00
	00		 lea	 edx, DWORD PTR [edi+2420]
$LL80@Client:

; 290  : 	{
; 291  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 292  : 		int fTime = this->GD[i].Hour * 3600 + this->GD[i].Min * 60 ;

  00216	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00219	8b f1		 mov	 esi, ecx
  0021b	c1 e6 04	 shl	 esi, 4
  0021e	2b f1		 sub	 esi, ecx
  00220	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00222	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  00225	8b ce		 mov	 ecx, esi
  00227	c1 e1 04	 shl	 ecx, 4
  0022a	2b ce		 sub	 ecx, esi
  0022c	03 c9		 add	 ecx, ecx
  0022e	03 c9		 add	 ecx, ecx

; 293  : 
; 294  : 		if(fTime > lTime )

  00230	3b c8		 cmp	 ecx, eax
  00232	7f 0e		 jg	 SHORT $LN124@Client

; 284  : 		}
; 285  : 	}
; 286  : 
; 287  : 	// ----
; 288  : 
; 289  : 	for(int i=0;i<this->CountGD;i++)

  00234	43		 inc	 ebx
  00235	83 c2 08	 add	 edx, 8
  00238	3b 9f 90 0c 00
	00		 cmp	 ebx, DWORD PTR [edi+3216]
  0023e	7c d6		 jl	 SHORT $LL80@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  00240	eb 0a		 jmp	 SHORT $LN153@Client
$LN124@Client:

; 295  : 		{
; 296  : 			GDStart = fTime - lTime;

  00242	2b c8		 sub	 ecx, eax
  00244	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _GDStart$[ebp], ecx

; 297  : 			break;
; 298  : 		}
; 299  : 	}
; 300  : 
; 301  : 	if(GDStart == 0)

  0024a	75 30		 jne	 SHORT $LN75@Client
$LN153@Client:

; 302  : 	{
; 303  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 304  : 		int fTime =  86400 + this->GD[0].Hour * 3600 + this->GD[0].Min * 60 ;

  0024c	8b 8f 70 09 00
	00		 mov	 ecx, DWORD PTR [edi+2416]
  00252	83 c1 18	 add	 ecx, 24			; 00000018H
  00255	8b d1		 mov	 edx, ecx
  00257	c1 e2 04	 shl	 edx, 4
  0025a	2b d1		 sub	 edx, ecx
  0025c	8b 8f 74 09 00
	00		 mov	 ecx, DWORD PTR [edi+2420]
  00262	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00265	8b ca		 mov	 ecx, edx
  00267	c1 e1 04	 shl	 ecx, 4
  0026a	2b ca		 sub	 ecx, edx
  0026c	03 c9		 add	 ecx, ecx
  0026e	03 c9		 add	 ecx, ecx

; 305  : 
; 306  : 		if(fTime > lTime )

  00270	3b c8		 cmp	 ecx, eax
  00272	7e 08		 jle	 SHORT $LN75@Client

; 307  : 		{
; 308  : 			GDStart = fTime - lTime;

  00274	2b c8		 sub	 ecx, eax
  00276	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _GDStart$[ebp], ecx
$LN75@Client:

; 309  : 		}
; 310  : 	}
; 311  : 
; 312  : 	// ----
; 313  : 
; 314  : 	for(int i=0;i<this->CountWW;i++)

  0027c	33 db		 xor	 ebx, ebx
  0027e	39 9f b4 0f 00
	00		 cmp	 DWORD PTR [edi+4020], ebx
  00284	7e 42		 jle	 SHORT $LN154@Client
  00286	8d 97 94 0c 00
	00		 lea	 edx, DWORD PTR [edi+3220]
  0028c	8d 64 24 00	 npad	 4
$LL74@Client:

; 315  : 	{
; 316  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 317  : 		int fTime = this->WW[i].Hour * 3600 + this->WW[i].Min * 60 ;

  00290	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00292	8b f1		 mov	 esi, ecx
  00294	c1 e6 04	 shl	 esi, 4
  00297	2b f1		 sub	 esi, ecx
  00299	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0029c	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  0029f	8b ce		 mov	 ecx, esi
  002a1	c1 e1 04	 shl	 ecx, 4
  002a4	2b ce		 sub	 ecx, esi
  002a6	03 c9		 add	 ecx, ecx
  002a8	03 c9		 add	 ecx, ecx

; 318  : 
; 319  : 		if(fTime > lTime )

  002aa	3b c8		 cmp	 ecx, eax
  002ac	7f 0e		 jg	 SHORT $LN125@Client

; 309  : 		}
; 310  : 	}
; 311  : 
; 312  : 	// ----
; 313  : 
; 314  : 	for(int i=0;i<this->CountWW;i++)

  002ae	43		 inc	 ebx
  002af	83 c2 08	 add	 edx, 8
  002b2	3b 9f b4 0f 00
	00		 cmp	 ebx, DWORD PTR [edi+4020]
  002b8	7c d6		 jl	 SHORT $LL74@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  002ba	eb 0a		 jmp	 SHORT $LN182@Client
$LN125@Client:

; 320  : 		{
; 321  : 			WWStart = fTime - lTime;

  002bc	2b c8		 sub	 ecx, eax
  002be	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _WWStart$[ebp], ecx

; 322  : 			break;
; 323  : 		}
; 324  : 	}
; 325  : 
; 326  : 	if(WWStart == 0)

  002c4	75 34		 jne	 SHORT $LN174@Client
$LN182@Client:
  002c6	33 db		 xor	 ebx, ebx
$LN154@Client:

; 327  : 	{
; 328  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 329  : 		int fTime =  86400 + this->WW[0].Hour * 3600 + this->WW[0].Min * 60 ;

  002c8	8b 8f 94 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3220]
  002ce	83 c1 18	 add	 ecx, 24			; 00000018H
  002d1	8b d1		 mov	 edx, ecx
  002d3	c1 e2 04	 shl	 edx, 4
  002d6	2b d1		 sub	 edx, ecx
  002d8	8b 8f 98 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3224]
  002de	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  002e1	8b ca		 mov	 ecx, edx
  002e3	c1 e1 04	 shl	 ecx, 4
  002e6	2b ca		 sub	 ecx, edx
  002e8	03 c9		 add	 ecx, ecx
  002ea	03 c9		 add	 ecx, ecx

; 330  : 
; 331  : 		if(fTime > lTime )

  002ec	3b c8		 cmp	 ecx, eax
  002ee	7e 0c		 jle	 SHORT $LN69@Client

; 332  : 		{
; 333  : 			WWStart = fTime - lTime;

  002f0	2b c8		 sub	 ecx, eax
  002f2	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _WWStart$[ebp], ecx
  002f8	eb 02		 jmp	 SHORT $LN69@Client
$LN174@Client:
  002fa	33 db		 xor	 ebx, ebx
$LN69@Client:

; 334  : 		}
; 335  : 	}
; 336  : 
; 337  : #if(EVENT_TIMER_EX)
; 338  : 
; 339  : 	DWORD TimeLora = 0;
; 340  : 	DWORD TimeDevias = 0;
; 341  : 	DWORD TimeTvT = 0;
; 342  : 	DWORD TimePandora = 0;
; 343  : 	DWORD TimeEvengelion = 0;
; 344  : 	DWORD TimeShop = 0;
; 345  : 	DWORD TimeHappy = 0;
; 346  : 	DWORD TimeDropEvent = 0;
; 347  : 	DWORD TimeCryWolf = 0;
; 348  : 	DWORD TimeCastleSiege = 0;
; 349  : 	DWORD TimeDungeonSiege = 0;
; 350  : 
; 351  : 	if( g_ZtLicense.CheckUser(eZtUB::Local)  || 
; 352  : 		g_ZtLicense.CheckUser(eZtUB::Gredy)  || g_ZtLicense.CheckUser(eZtUB::GredyLocal) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || 
; 353  : 		g_ZtLicense.CheckUser(eZtUB::Artem)  || g_ZtLicense.CheckUser(eZtUB::Artem2)		||
; 354  : 		g_ZtLicense.CheckUser(eZtUB::NSGames) || g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::ulasevich2) ||
; 355  : 		g_ZtLicense.GetCustom())

  002fc	53		 push	 ebx
  002fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00302	89 5d 80	 mov	 DWORD PTR _TimeLora$[ebp], ebx
  00305	89 9d 74 ff ff
	ff		 mov	 DWORD PTR _TimeDevias$[ebp], ebx
  0030b	89 9d 78 ff ff
	ff		 mov	 DWORD PTR _TimeTvT$[ebp], ebx
  00311	89 9d 70 ff ff
	ff		 mov	 DWORD PTR _TimePandora$[ebp], ebx
  00317	89 5d 8c	 mov	 DWORD PTR _TimeEvengelion$[ebp], ebx
  0031a	89 9d 6c ff ff
	ff		 mov	 DWORD PTR _TimeShop$[ebp], ebx
  00320	89 5d 88	 mov	 DWORD PTR _TimeHappy$[ebp], ebx
  00323	89 5d 84	 mov	 DWORD PTR _TimeDropEvent$[ebp], ebx
  00326	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _TimeCryWolf$[ebp], ebx
  0032c	89 9d 4c ff ff
	ff		 mov	 DWORD PTR _TimeCastleSiege$[ebp], ebx
  00332	89 9d 54 ff ff
	ff		 mov	 DWORD PTR _TimeDungeonSiege$[ebp], ebx
  00338	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0033d	84 c0		 test	 al, al
  0033f	0f 85 96 00 00
	00		 jne	 $LN67@Client
  00345	6a 20		 push	 32			; 00000020H
  00347	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0034c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00351	84 c0		 test	 al, al
  00353	0f 85 82 00 00
	00		 jne	 $LN67@Client
  00359	6a 21		 push	 33			; 00000021H
  0035b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00360	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00365	84 c0		 test	 al, al
  00367	75 72		 jne	 SHORT $LN67@Client
  00369	6a 22		 push	 34			; 00000022H
  0036b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00370	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00375	84 c0		 test	 al, al
  00377	75 62		 jne	 SHORT $LN67@Client
  00379	6a 30		 push	 48			; 00000030H
  0037b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00380	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00385	84 c0		 test	 al, al
  00387	75 52		 jne	 SHORT $LN67@Client
  00389	6a 31		 push	 49			; 00000031H
  0038b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00390	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00395	84 c0		 test	 al, al
  00397	75 42		 jne	 SHORT $LN67@Client
  00399	6a 51		 push	 81			; 00000051H
  0039b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003a0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003a5	84 c0		 test	 al, al
  003a7	75 32		 jne	 SHORT $LN67@Client
  003a9	6a 17		 push	 23			; 00000017H
  003ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003b0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003b5	84 c0		 test	 al, al
  003b7	75 22		 jne	 SHORT $LN67@Client
  003b9	6a 24		 push	 36			; 00000024H
  003bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003c0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003c5	84 c0		 test	 al, al
  003c7	75 12		 jne	 SHORT $LN67@Client
  003c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003ce	e8 00 00 00 00	 call	 ?GetCustom@CZtLicense@@QAEHXZ ; CZtLicense::GetCustom
  003d3	85 c0		 test	 eax, eax
  003d5	0f 84 47 04 00
	00		 je	 $LN167@Client
$LN67@Client:

; 356  : 	{
; 357  : 		// --
; 358  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  003db	0f b7 4d f4	 movzx	 ecx, WORD PTR _t$[ebp+8]
  003df	0f b7 45 f6	 movzx	 eax, WORD PTR _t$[ebp+10]
  003e3	0f b7 55 f8	 movzx	 edx, WORD PTR _t$[ebp+12]

; 359  : 		// --> Lorencia Battle
; 360  : 		int iCount = LoraBattle.Count;

  003e7	8b 3d c0 1c 02
	00		 mov	 edi, DWORD PTR ?LoraBattle@@3VcLoraBattle@@A+138432
  003ed	8b f1		 mov	 esi, ecx
  003ef	c1 e6 04	 shl	 esi, 4
  003f2	2b f1		 sub	 esi, ecx
  003f4	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  003f7	8b c8		 mov	 ecx, eax
  003f9	c1 e1 04	 shl	 ecx, 4
  003fc	2b c8		 sub	 ecx, eax

; 361  : 		for(int i = 0; i < iCount; i++)

  003fe	33 db		 xor	 ebx, ebx
  00400	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00403	85 ff		 test	 edi, edi
  00405	7e 38		 jle	 SHORT $LN155@Client

; 356  : 	{
; 357  : 		// --
; 358  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  00407	ba cc 10 02 00	 mov	 edx, OFFSET ?LoraBattle@@3VcLoraBattle@@A+135372
  0040c	8d 64 24 00	 npad	 4
$LL66@Client:

; 362  : 		{
; 363  : 			int fTime = LoraBattle.Time[i].Hour * 3600 + LoraBattle.Time[i].Min * 60;

  00410	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00413	8b f1		 mov	 esi, ecx
  00415	c1 e6 04	 shl	 esi, 4
  00418	2b f1		 sub	 esi, ecx
  0041a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0041c	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  0041f	8b ce		 mov	 ecx, esi
  00421	c1 e1 04	 shl	 ecx, 4
  00424	2b ce		 sub	 ecx, esi
  00426	03 c9		 add	 ecx, ecx
  00428	03 c9		 add	 ecx, ecx

; 364  : 			if(fTime > lTime )

  0042a	3b c8		 cmp	 ecx, eax
  0042c	7f 0a		 jg	 SHORT $LN126@Client

; 361  : 		for(int i = 0; i < iCount; i++)

  0042e	43		 inc	 ebx
  0042f	83 c2 18	 add	 edx, 24			; 00000018H
  00432	3b df		 cmp	 ebx, edi
  00434	7c da		 jl	 SHORT $LL66@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  00436	eb 07		 jmp	 SHORT $LN155@Client
$LN126@Client:

; 365  : 			{
; 366  : 				TimeLora = fTime - lTime;

  00438	2b c8		 sub	 ecx, eax
  0043a	89 4d 80	 mov	 DWORD PTR _TimeLora$[ebp], ecx

; 367  : 				break;
; 368  : 			}
; 369  : 		}
; 370  : 		if(TimeLora == 0)

  0043d	75 1e		 jne	 SHORT $LN171@Client
$LN155@Client:

; 371  : 		{
; 372  : 			int fTime =  86400 + LoraBattle.Time[0].Hour * 3600 + LoraBattle.Time[0].Min;

  0043f	8b 0d c8 10 02
	00		 mov	 ecx, DWORD PTR ?LoraBattle@@3VcLoraBattle@@A+135368
  00445	83 c1 18	 add	 ecx, 24			; 00000018H
  00448	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  0044e	03 0d cc 10 02
	00		 add	 ecx, DWORD PTR ?LoraBattle@@3VcLoraBattle@@A+135372

; 373  : 			if(fTime > lTime)

  00454	3b c8		 cmp	 ecx, eax
  00456	7e 05		 jle	 SHORT $LN171@Client

; 374  : 			{
; 375  : 				TimeLora = fTime - lTime;

  00458	2b c8		 sub	 ecx, eax
  0045a	89 4d 80	 mov	 DWORD PTR _TimeLora$[ebp], ecx
$LN171@Client:

; 376  : 			}
; 377  : 		}	
; 378  : 		// --> Devias Battle
; 379  : 		iCount = g_DeviasBattle.Count;

  0045d	8b 3d c0 1c 02
	00		 mov	 edi, DWORD PTR ?g_DeviasBattle@@3VCDeviasBattle@@A+138432

; 380  : 		for(int i = 0; i < iCount; i++)

  00463	33 db		 xor	 ebx, ebx
  00465	85 ff		 test	 edi, edi
  00467	7e 39		 jle	 SHORT $LN156@Client

; 376  : 			}
; 377  : 		}	
; 378  : 		// --> Devias Battle
; 379  : 		iCount = g_DeviasBattle.Count;

  00469	ba cc 10 02 00	 mov	 edx, OFFSET ?g_DeviasBattle@@3VCDeviasBattle@@A+135372
  0046e	8b ff		 npad	 2
$LL60@Client:

; 381  : 		{
; 382  : 			int fTime = g_DeviasBattle.Time[i].Hour * 3600 + g_DeviasBattle.Time[i].Min * 60;

  00470	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00473	8b f1		 mov	 esi, ecx
  00475	c1 e6 04	 shl	 esi, 4
  00478	2b f1		 sub	 esi, ecx
  0047a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0047c	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  0047f	8b ce		 mov	 ecx, esi
  00481	c1 e1 04	 shl	 ecx, 4
  00484	2b ce		 sub	 ecx, esi
  00486	03 c9		 add	 ecx, ecx
  00488	03 c9		 add	 ecx, ecx

; 383  : 			if(fTime > lTime )

  0048a	3b c8		 cmp	 ecx, eax
  0048c	7f 0a		 jg	 SHORT $LN127@Client

; 380  : 		for(int i = 0; i < iCount; i++)

  0048e	43		 inc	 ebx
  0048f	83 c2 18	 add	 edx, 24			; 00000018H
  00492	3b df		 cmp	 ebx, edi
  00494	7c da		 jl	 SHORT $LL60@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  00496	eb 0a		 jmp	 SHORT $LN156@Client
$LN127@Client:

; 384  : 			{
; 385  : 				TimeDevias = fTime - lTime;

  00498	2b c8		 sub	 ecx, eax
  0049a	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _TimeDevias$[ebp], ecx

; 386  : 				break;
; 387  : 			}
; 388  : 		}
; 389  : 		if(TimeDevias == 0)

  004a0	75 21		 jne	 SHORT $LN177@Client
$LN156@Client:

; 390  : 		{
; 391  : 			int fTime = 86400 + g_DeviasBattle.Time[0].Hour * 3600 + g_DeviasBattle.Time[0].Min;

  004a2	8b 0d c8 10 02
	00		 mov	 ecx, DWORD PTR ?g_DeviasBattle@@3VCDeviasBattle@@A+135368
  004a8	83 c1 18	 add	 ecx, 24			; 00000018H
  004ab	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  004b1	03 0d cc 10 02
	00		 add	 ecx, DWORD PTR ?g_DeviasBattle@@3VCDeviasBattle@@A+135372

; 392  : 			if(fTime > lTime)

  004b7	3b c8		 cmp	 ecx, eax
  004b9	7e 08		 jle	 SHORT $LN177@Client

; 393  : 			{
; 394  : 				TimeDevias = fTime - lTime;

  004bb	2b c8		 sub	 ecx, eax
  004bd	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _TimeDevias$[ebp], ecx
$LN177@Client:

; 395  : 			}
; 396  : 		}	
; 397  : 		// --> TvT
; 398  : 		iCount = TvT.Count;

  004c3	8b 3d a8 00 00
	00		 mov	 edi, DWORD PTR ?TvT@@3VcTvTEvent@@A+168

; 399  : 		for(int i = 0; i < iCount; i++)

  004c9	33 f6		 xor	 esi, esi
  004cb	85 ff		 test	 edi, edi
  004cd	7e 3b		 jle	 SHORT $LN172@Client

; 395  : 			}
; 396  : 		}	
; 397  : 		// --> TvT
; 398  : 		iCount = TvT.Count;

  004cf	bb cc 10 02 00	 mov	 ebx, OFFSET ?g_DeviasBattle@@3VCDeviasBattle@@A+135372
$LL54@Client:

; 400  : 		{
; 401  : 			int fTime = TvT.T[i].H * 3600 + g_DeviasBattle.Time[i].Min * 60;

  004d4	8b 0c f5 58 00
	00 00		 mov	 ecx, DWORD PTR ?TvT@@3VcTvTEvent@@A[esi*8+88]
  004db	8b d1		 mov	 edx, ecx
  004dd	c1 e2 04	 shl	 edx, 4
  004e0	2b d1		 sub	 edx, ecx
  004e2	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004e4	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  004e7	8b ca		 mov	 ecx, edx
  004e9	c1 e1 04	 shl	 ecx, 4
  004ec	2b ca		 sub	 ecx, edx
  004ee	03 c9		 add	 ecx, ecx
  004f0	03 c9		 add	 ecx, ecx

; 402  : 			if(fTime > lTime )

  004f2	3b c8		 cmp	 ecx, eax
  004f4	7f 0a		 jg	 SHORT $LN128@Client

; 399  : 		for(int i = 0; i < iCount; i++)

  004f6	46		 inc	 esi
  004f7	83 c3 18	 add	 ebx, 24			; 00000018H
  004fa	3b f7		 cmp	 esi, edi
  004fc	7c d6		 jl	 SHORT $LL54@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  004fe	eb 0a		 jmp	 SHORT $LN172@Client
$LN128@Client:

; 403  : 			{
; 404  : 				TimeTvT = fTime - lTime;

  00500	2b c8		 sub	 ecx, eax
  00502	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _TimeTvT$[ebp], ecx

; 405  : 				break;
; 406  : 			}
; 407  : 		}
; 408  : 		if(TimeTvT == 0)

  00508	75 21		 jne	 SHORT $LN181@Client
$LN172@Client:

; 409  : 		{
; 410  : 			int fTime = 86400 + TvT.T[0].H * 3600 + g_DeviasBattle.Time[0].Min;

  0050a	8b 0d 58 00 00
	00		 mov	 ecx, DWORD PTR ?TvT@@3VcTvTEvent@@A+88
  00510	83 c1 18	 add	 ecx, 24			; 00000018H
  00513	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  00519	03 0d cc 10 02
	00		 add	 ecx, DWORD PTR ?g_DeviasBattle@@3VCDeviasBattle@@A+135372

; 411  : 			if(fTime > lTime)

  0051f	3b c8		 cmp	 ecx, eax
  00521	7e 08		 jle	 SHORT $LN181@Client

; 412  : 			{
; 413  : 				TimeTvT = fTime - lTime;

  00523	2b c8		 sub	 ecx, eax
  00525	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _TimeTvT$[ebp], ecx
$LN181@Client:

; 414  : 			}
; 415  : 		}	
; 416  : 		// --> Pandora
; 417  : 		iCount = gPandoraBoxEvent.CountTimes;

  0052b	8b 3d bc 0e 00
	00		 mov	 edi, DWORD PTR ?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A+3772

; 418  : 		for(int i = 0; i < iCount; i++)

  00531	33 d2		 xor	 edx, edx
  00533	85 ff		 test	 edi, edi
  00535	7e 41		 jle	 SHORT $LN158@Client
  00537	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL48@Client:

; 419  : 		{
; 420  : 			int fTime = gPandoraBoxEvent.Times[i].Hour * 3600 + gPandoraBoxEvent.Times[i].Min * 60;

  00540	8b 0c d5 1c 0e
	00 00		 mov	 ecx, DWORD PTR ?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A[edx*8+3612]
  00547	8b f1		 mov	 esi, ecx
  00549	c1 e6 04	 shl	 esi, 4
  0054c	2b f1		 sub	 esi, ecx
  0054e	8b 0c d5 20 0e
	00 00		 mov	 ecx, DWORD PTR ?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A[edx*8+3616]
  00555	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  00558	8b ce		 mov	 ecx, esi
  0055a	c1 e1 04	 shl	 ecx, 4
  0055d	2b ce		 sub	 ecx, esi
  0055f	03 c9		 add	 ecx, ecx
  00561	03 c9		 add	 ecx, ecx

; 421  : 			if(fTime > lTime )

  00563	3b c8		 cmp	 ecx, eax
  00565	7f 07		 jg	 SHORT $LN129@Client

; 418  : 		for(int i = 0; i < iCount; i++)

  00567	42		 inc	 edx
  00568	3b d7		 cmp	 edx, edi
  0056a	7c d4		 jl	 SHORT $LL48@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  0056c	eb 0a		 jmp	 SHORT $LN158@Client
$LN129@Client:

; 422  : 			{
; 423  : 				TimePandora = fTime - lTime;

  0056e	2b c8		 sub	 ecx, eax
  00570	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _TimePandora$[ebp], ecx

; 424  : 				break;
; 425  : 			}
; 426  : 		}
; 427  : 		if(TimePandora == 0)

  00576	75 21		 jne	 SHORT $LN43@Client
$LN158@Client:

; 428  : 		{
; 429  : 			int fTime = 86400 + gPandoraBoxEvent.Times[0].Hour * 3600 + gPandoraBoxEvent.Times[0].Min;

  00578	8b 0d 1c 0e 00
	00		 mov	 ecx, DWORD PTR ?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A+3612
  0057e	83 c1 18	 add	 ecx, 24			; 00000018H
  00581	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  00587	03 0d 20 0e 00
	00		 add	 ecx, DWORD PTR ?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A+3616

; 430  : 			if(fTime > lTime)

  0058d	3b c8		 cmp	 ecx, eax
  0058f	7e 08		 jle	 SHORT $LN43@Client

; 431  : 			{
; 432  : 				TimePandora = fTime - lTime;

  00591	2b c8		 sub	 ecx, eax
  00593	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _TimePandora$[ebp], ecx
$LN43@Client:

; 433  : 			}
; 434  : 		}	
; 435  : 		// --> Evangelion
; 436  : 		/*iCount = gPandoraBoxEvent.CountTimes;
; 437  : 		for(int i = 0; i < iCount; i++)
; 438  : 		{
; 439  : 			int fTime = gPandoraBoxEvent.Times[i].Hour * 3600 + gPandoraBoxEvent.Times[i].Min * 60;
; 440  : 			if(fTime > lTime )
; 441  : 			{
; 442  : 				TimePandora = fTime - lTime;
; 443  : 				break;
; 444  : 			}
; 445  : 		}
; 446  : 		if(TimePandora == 0)
; 447  : 		{
; 448  : 			int fTime = 86400 + gPandoraBoxEvent.Times[0].Hour * 3600 + gPandoraBoxEvent.Times[0].Min;
; 449  : 			if(fTime > lTime)
; 450  : 			{
; 451  : 				TimePandora = fTime - lTime;
; 452  : 			}
; 453  : 		}	*/
; 454  : 		// --> SearchEvent
; 455  : 		iCount = SearchEvent.Count;

  00599	8b 3d 1c 2d 00
	00		 mov	 edi, DWORD PTR ?SearchEvent@@3VcSearchEvent@@A+11548

; 456  : 		for(int i = 0; i < iCount; i++)

  0059f	33 d2		 xor	 edx, edx
  005a1	85 ff		 test	 edi, edi
  005a3	7e 40		 jle	 SHORT $LN159@Client
  005a5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL42@Client:

; 457  : 		{
; 458  : 			int fTime = SearchEvent.TickTime[i].Hour * 3600 + SearchEvent.TickTime[i].Min * 60;

  005b0	8b 0c d5 6c 00
	00 00		 mov	 ecx, DWORD PTR ?SearchEvent@@3VcSearchEvent@@A[edx*8+108]
  005b7	8b f1		 mov	 esi, ecx
  005b9	c1 e6 04	 shl	 esi, 4
  005bc	2b f1		 sub	 esi, ecx
  005be	8b 0c d5 70 00
	00 00		 mov	 ecx, DWORD PTR ?SearchEvent@@3VcSearchEvent@@A[edx*8+112]
  005c5	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  005c8	8b ce		 mov	 ecx, esi
  005ca	c1 e1 04	 shl	 ecx, 4
  005cd	2b ce		 sub	 ecx, esi
  005cf	03 c9		 add	 ecx, ecx
  005d1	03 c9		 add	 ecx, ecx

; 459  : 			if(fTime > lTime )

  005d3	3b c8		 cmp	 ecx, eax
  005d5	7f 07		 jg	 SHORT $LN130@Client

; 456  : 		for(int i = 0; i < iCount; i++)

  005d7	42		 inc	 edx
  005d8	3b d7		 cmp	 edx, edi
  005da	7c d4		 jl	 SHORT $LL42@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  005dc	eb 07		 jmp	 SHORT $LN159@Client
$LN130@Client:

; 460  : 			{
; 461  : 				TimeEvengelion = fTime - lTime;

  005de	2b c8		 sub	 ecx, eax
  005e0	89 4d 8c	 mov	 DWORD PTR _TimeEvengelion$[ebp], ecx

; 462  : 				break;
; 463  : 			}
; 464  : 		}
; 465  : 		if(TimeEvengelion == 0)

  005e3	75 1e		 jne	 SHORT $LN37@Client
$LN159@Client:

; 466  : 		{
; 467  : 			int fTime = 86400 + SearchEvent.TickTime[0].Hour * 3600 + SearchEvent.TickTime[0].Min;

  005e5	8b 0d 6c 00 00
	00		 mov	 ecx, DWORD PTR ?SearchEvent@@3VcSearchEvent@@A+108
  005eb	83 c1 18	 add	 ecx, 24			; 00000018H
  005ee	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  005f4	03 0d 70 00 00
	00		 add	 ecx, DWORD PTR ?SearchEvent@@3VcSearchEvent@@A+112

; 468  : 			if(fTime > lTime)

  005fa	3b c8		 cmp	 ecx, eax
  005fc	7e 05		 jle	 SHORT $LN37@Client

; 469  : 			{
; 470  : 				TimeEvengelion = fTime - lTime;

  005fe	2b c8		 sub	 ecx, eax
  00600	89 4d 8c	 mov	 DWORD PTR _TimeEvengelion$[ebp], ecx
$LN37@Client:

; 471  : 			}
; 472  : 		}	
; 473  : 		// --> Shop Event
; 474  : 		iCount = g_TeleportShop.TimeLoaded;

  00603	8b 3d 3c 01 00
	00		 mov	 edi, DWORD PTR ?g_TeleportShop@@3VTeleportShop@@A+316

; 475  : 		for(int i = 0; i < iCount; i++)

  00609	33 d2		 xor	 edx, edx
  0060b	85 ff		 test	 edi, edi
  0060d	7e 39		 jle	 SHORT $LN160@Client
  0060f	90		 npad	 1
$LL36@Client:

; 476  : 		{
; 477  : 			int fTime = g_TeleportShop.DataTime[i].Hour * 3600 + g_TeleportShop.DataTime[i].Min * 60;

  00610	8b 0c d5 ec 00
	00 00		 mov	 ecx, DWORD PTR ?g_TeleportShop@@3VTeleportShop@@A[edx*8+236]
  00617	8b f1		 mov	 esi, ecx
  00619	c1 e6 04	 shl	 esi, 4
  0061c	2b f1		 sub	 esi, ecx
  0061e	8b 0c d5 f0 00
	00 00		 mov	 ecx, DWORD PTR ?g_TeleportShop@@3VTeleportShop@@A[edx*8+240]
  00625	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  00628	8b ce		 mov	 ecx, esi
  0062a	c1 e1 04	 shl	 ecx, 4
  0062d	2b ce		 sub	 ecx, esi
  0062f	03 c9		 add	 ecx, ecx
  00631	03 c9		 add	 ecx, ecx

; 478  : 			if(fTime > lTime )

  00633	3b c8		 cmp	 ecx, eax
  00635	7f 07		 jg	 SHORT $LN131@Client

; 475  : 		for(int i = 0; i < iCount; i++)

  00637	42		 inc	 edx
  00638	3b d7		 cmp	 edx, edi
  0063a	7c d4		 jl	 SHORT $LL36@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  0063c	eb 0a		 jmp	 SHORT $LN160@Client
$LN131@Client:

; 479  : 			{
; 480  : 				TimeShop = fTime - lTime;

  0063e	2b c8		 sub	 ecx, eax
  00640	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _TimeShop$[ebp], ecx

; 481  : 				break;
; 482  : 			}
; 483  : 		}
; 484  : 		if(TimeShop == 0)

  00646	75 21		 jne	 SHORT $LN31@Client
$LN160@Client:

; 485  : 		{
; 486  : 			int fTime = 86400 + g_TeleportShop.DataTime[0].Hour * 3600 + g_TeleportShop.DataTime[0].Min;

  00648	8b 0d ec 00 00
	00		 mov	 ecx, DWORD PTR ?g_TeleportShop@@3VTeleportShop@@A+236
  0064e	83 c1 18	 add	 ecx, 24			; 00000018H
  00651	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  00657	03 0d f0 00 00
	00		 add	 ecx, DWORD PTR ?g_TeleportShop@@3VTeleportShop@@A+240

; 487  : 			if(fTime > lTime)

  0065d	3b c8		 cmp	 ecx, eax
  0065f	7e 08		 jle	 SHORT $LN31@Client

; 488  : 			{
; 489  : 				TimeShop = fTime - lTime;

  00661	2b c8		 sub	 ecx, eax
  00663	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _TimeShop$[ebp], ecx
$LN31@Client:

; 490  : 			}
; 491  : 		}	
; 492  : 		// --> Happy hour
; 493  : 		iCount = HappyHour.Count;

  00669	8b 1d 10 08 00
	00		 mov	 ebx, DWORD PTR ?HappyHour@@3VcHappyHour@@A+2064

; 494  : 		for(int i = 0; i < iCount; i++)

  0066f	33 ff		 xor	 edi, edi
  00671	85 db		 test	 ebx, ebx
  00673	7e 3a		 jle	 SHORT $LN161@Client

; 490  : 			}
; 491  : 		}	
; 492  : 		// --> Happy hour
; 493  : 		iCount = HappyHour.Count;

  00675	ba 14 00 00 00	 mov	 edx, OFFSET ?HappyHour@@3VcHappyHour@@A+20
  0067a	8d 9b 00 00 00
	00		 npad	 6
$LL30@Client:

; 495  : 		{
; 496  : 			int fTime = HappyHour.HappyStruct[i].Hour * 3600 + HappyHour.HappyStruct[i].Min * 60;

  00680	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00683	8b f1		 mov	 esi, ecx
  00685	c1 e6 04	 shl	 esi, 4
  00688	2b f1		 sub	 esi, ecx
  0068a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0068c	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  0068f	8b ce		 mov	 ecx, esi
  00691	c1 e1 04	 shl	 ecx, 4
  00694	2b ce		 sub	 ecx, esi
  00696	03 c9		 add	 ecx, ecx
  00698	03 c9		 add	 ecx, ecx

; 497  : 			if(fTime > lTime )

  0069a	3b c8		 cmp	 ecx, eax
  0069c	7f 0a		 jg	 SHORT $LN132@Client

; 494  : 		for(int i = 0; i < iCount; i++)

  0069e	47		 inc	 edi
  0069f	83 c2 10	 add	 edx, 16			; 00000010H
  006a2	3b fb		 cmp	 edi, ebx
  006a4	7c da		 jl	 SHORT $LL30@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  006a6	eb 07		 jmp	 SHORT $LN161@Client
$LN132@Client:

; 498  : 			{
; 499  : 				TimeHappy = fTime - lTime;

  006a8	2b c8		 sub	 ecx, eax
  006aa	89 4d 88	 mov	 DWORD PTR _TimeHappy$[ebp], ecx

; 500  : 				break;
; 501  : 			}
; 502  : 		}
; 503  : 		if(TimeHappy == 0)

  006ad	75 1e		 jne	 SHORT $LN178@Client
$LN161@Client:

; 504  : 		{
; 505  : 			int fTime = 86400 + HappyHour.HappyStruct[0].Hour * 3600 + HappyHour.HappyStruct[0].Min;

  006af	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?HappyHour@@3VcHappyHour@@A+16
  006b5	83 c1 18	 add	 ecx, 24			; 00000018H
  006b8	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  006be	03 0d 14 00 00
	00		 add	 ecx, DWORD PTR ?HappyHour@@3VcHappyHour@@A+20

; 506  : 			if(fTime > lTime)

  006c4	3b c8		 cmp	 ecx, eax
  006c6	7e 05		 jle	 SHORT $LN178@Client

; 507  : 			{
; 508  : 				TimeHappy = fTime - lTime;

  006c8	2b c8		 sub	 ecx, eax
  006ca	89 4d 88	 mov	 DWORD PTR _TimeHappy$[ebp], ecx
$LN178@Client:

; 509  : 			}
; 510  : 		}
; 511  : 		// --> Drop
; 512  : 		iCount = DropEvent.Count[2];

  006cd	8b 3d bc 2c 00
	00		 mov	 edi, DWORD PTR ?DropEvent@@3VcDropEvent@@A+11452

; 513  : 		for(int i = 0; i < iCount; i++)

  006d3	33 d2		 xor	 edx, edx
  006d5	85 ff		 test	 edi, edi
  006d7	7e 3c		 jle	 SHORT $LN162@Client
  006d9	8d a4 24 00 00
	00 00		 npad	 7
$LL24@Client:

; 514  : 		{
; 515  : 			int fTime = DropEvent.Time[i].Hour * 3600 + DropEvent.Time[i].Min * 60;

  006e0	8b 0c d5 04 20
	00 00		 mov	 ecx, DWORD PTR ?DropEvent@@3VcDropEvent@@A[edx*8+8196]
  006e7	8b f1		 mov	 esi, ecx
  006e9	c1 e6 04	 shl	 esi, 4
  006ec	2b f1		 sub	 esi, ecx
  006ee	8b 0c d5 08 20
	00 00		 mov	 ecx, DWORD PTR ?DropEvent@@3VcDropEvent@@A[edx*8+8200]
  006f5	8d 34 b1	 lea	 esi, DWORD PTR [ecx+esi*4]
  006f8	8b ce		 mov	 ecx, esi
  006fa	c1 e1 04	 shl	 ecx, 4
  006fd	2b ce		 sub	 ecx, esi
  006ff	03 c9		 add	 ecx, ecx
  00701	03 c9		 add	 ecx, ecx

; 516  : 			if(fTime > lTime )

  00703	3b c8		 cmp	 ecx, eax
  00705	7f 07		 jg	 SHORT $LN133@Client

; 513  : 		for(int i = 0; i < iCount; i++)

  00707	42		 inc	 edx
  00708	3b d7		 cmp	 edx, edi
  0070a	7c d4		 jl	 SHORT $LL24@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  0070c	eb 07		 jmp	 SHORT $LN162@Client
$LN133@Client:

; 517  : 			{
; 518  : 				TimeDropEvent = fTime - lTime;

  0070e	2b c8		 sub	 ecx, eax
  00710	89 4d 84	 mov	 DWORD PTR _TimeDropEvent$[ebp], ecx

; 519  : 				break;
; 520  : 			}
; 521  : 		}
; 522  : 		if(TimeDropEvent == 0)

  00713	75 1e		 jne	 SHORT $LN179@Client
$LN162@Client:

; 523  : 		{
; 524  : 			int fTime = 86400 + DropEvent.Time[0].Hour * 3600 + DropEvent.Time[0].Min;

  00715	8b 0d 04 20 00
	00		 mov	 ecx, DWORD PTR ?DropEvent@@3VcDropEvent@@A+8196
  0071b	83 c1 18	 add	 ecx, 24			; 00000018H
  0071e	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  00724	03 0d 08 20 00
	00		 add	 ecx, DWORD PTR ?DropEvent@@3VcDropEvent@@A+8200

; 525  : 			if(fTime > lTime)

  0072a	3b c8		 cmp	 ecx, eax
  0072c	7e 05		 jle	 SHORT $LN179@Client

; 526  : 			{
; 527  : 				TimeDropEvent = fTime - lTime;

  0072e	2b c8		 sub	 ecx, eax
  00730	89 4d 84	 mov	 DWORD PTR _TimeDropEvent$[ebp], ecx
$LN179@Client:

; 528  : 			}
; 529  : 		}
; 530  : 
; 531  : 		// --> CryWolf
; 532  : 		if(TimeCryWolf == 0)
; 533  : 		{
; 534  : 			int fTime = 86400 + g_Crywolf.m_StartTimeInfo[0].m_iHour * 3600 + g_Crywolf.m_StartTimeInfo[0].m_iMinute;

  00733	8b 0d dc ca 0f
	00		 mov	 ecx, DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1034972

; 535  : 
; 536  : 			if(g_Crywolf.m_StartTimeInfo[0].m_iDayOfWeek > 0)

  00739	8b 15 d8 ca 0f
	00		 mov	 edx, DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1034968
  0073f	83 c1 18	 add	 ecx, 24			; 00000018H
  00742	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  00748	03 0d e0 ca 0f
	00		 add	 ecx, DWORD PTR ?g_Crywolf@@3VCCrywolf@@A+1034976
  0074e	85 d2		 test	 edx, edx
  00750	7e 32		 jle	 SHORT $LN17@Client

; 537  : 			{
; 538  : 				lTime = t.wDayOfWeek * 86400 + t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  00752	0f b7 45 f0	 movzx	 eax, WORD PTR _t$[ebp+4]

; 539  : 				fTime += 86400 * g_Crywolf.m_StartTimeInfo[0].m_iDayOfWeek;

  00756	69 d2 80 51 01
	00		 imul	 edx, 86400		; 00015180H
  0075c	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0075f	0f b7 45 f4	 movzx	 eax, WORD PTR _t$[ebp+8]
  00763	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  00766	8b f0		 mov	 esi, eax
  00768	c1 e6 04	 shl	 esi, 4
  0076b	2b f0		 sub	 esi, eax
  0076d	0f b7 45 f6	 movzx	 eax, WORD PTR _t$[ebp+10]
  00771	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00774	8b f0		 mov	 esi, eax
  00776	c1 e6 04	 shl	 esi, 4
  00779	2b f0		 sub	 esi, eax
  0077b	0f b7 45 f8	 movzx	 eax, WORD PTR _t$[ebp+12]
  0077f	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00782	03 ca		 add	 ecx, edx
$LN17@Client:

; 540  : 			}
; 541  : 
; 542  : 			if(fTime > lTime)

  00784	3b c8		 cmp	 ecx, eax
  00786	7e 08		 jle	 SHORT $LN164@Client

; 543  : 			{
; 544  : 				TimeCryWolf = fTime - lTime;

  00788	2b c8		 sub	 ecx, eax
  0078a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _TimeCryWolf$[ebp], ecx
$LN164@Client:

; 545  : 			}
; 546  : 		}
; 547  : 		// --> CastleSiege
; 548  : 		if(TimeCastleSiege == 0)
; 549  : 		{
; 550  : 			SYSTEMTIME tm;
; 551  : 			g_CastleSiege.GetStateDate(CASTLESIEGE_STATE_STARTSIEGE, &tm);

  00790	8d 55 94	 lea	 edx, DWORD PTR _tm$210968[ebp]
  00793	52		 push	 edx
  00794	6a 07		 push	 7
  00796	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0079b	e8 00 00 00 00	 call	 ?GetStateDate@CCastleSiege@@QAEXHPAU_SYSTEMTIME@@@Z ; CCastleSiege::GetStateDate

; 552  : 
; 553  : 			lTime = t.wDayOfWeek * 86400 + t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  007a0	0f b7 45 f0	 movzx	 eax, WORD PTR _t$[ebp+4]
  007a4	0f b7 4d f4	 movzx	 ecx, WORD PTR _t$[ebp+8]
  007a8	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  007ab	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  007ae	8b d0		 mov	 edx, eax
  007b0	c1 e2 04	 shl	 edx, 4
  007b3	2b d0		 sub	 edx, eax
  007b5	0f b7 45 f6	 movzx	 eax, WORD PTR _t$[ebp+10]
  007b9	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  007bc	0f b7 55 f8	 movzx	 edx, WORD PTR _t$[ebp+12]
  007c0	8b c8		 mov	 ecx, eax
  007c2	c1 e1 04	 shl	 ecx, 4
  007c5	2b c8		 sub	 ecx, eax

; 554  : 
; 555  : 			int fTime = 86400 * tm.wDay + tm.wHour * 3600 + tm.wMinute;

  007c7	0f b7 45 9a	 movzx	 eax, WORD PTR _tm$210968[ebp+6]
  007cb	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  007ce	0f b7 55 9c	 movzx	 edx, WORD PTR _tm$210968[ebp+8]
  007d2	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  007d5	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  007d8	0f b7 55 9e	 movzx	 edx, WORD PTR _tm$210968[ebp+10]
  007dc	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  007e2	03 c2		 add	 eax, edx

; 556  : 
; 557  : 			if(fTime > lTime)

  007e4	3b c1		 cmp	 eax, ecx
  007e6	7e 08		 jle	 SHORT $LN165@Client

; 558  : 			{
; 559  : 				TimeCastleSiege = fTime - lTime;

  007e8	2b c1		 sub	 eax, ecx
  007ea	89 85 4c ff ff
	ff		 mov	 DWORD PTR _TimeCastleSiege$[ebp], eax
$LN165@Client:

; 560  : 			}
; 561  : 		}
; 562  : 		// --> DungeonSiege
; 563  : 		if(TimeDungeonSiege == 0)
; 564  : 		{
; 565  : 			int fTime = 86400 + g_DungeonSiege.iEventStartHour * 3600 + g_DungeonSiege.iEventeStartMinut;

  007f0	a1 60 00 00 00	 mov	 eax, DWORD PTR ?g_DungeonSiege@@3VCDungeonSiege@@A+96

; 566  : 
; 567  : 			if(g_DungeonSiege.iEventStartDay > 0)

  007f5	8b 15 5c 00 00
	00		 mov	 edx, DWORD PTR ?g_DungeonSiege@@3VCDungeonSiege@@A+92
  007fb	83 c0 18	 add	 eax, 24			; 00000018H
  007fe	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  00804	03 05 64 00 00
	00		 add	 eax, DWORD PTR ?g_DungeonSiege@@3VCDungeonSiege@@A+100
  0080a	85 d2		 test	 edx, edx
  0080c	7e 08		 jle	 SHORT $LN12@Client

; 568  : 			{
; 569  : 				lTime = t.wDayOfWeek * 86400 + t.wHour * 3600 + t.wMinute * 60 + t.wSecond;
; 570  : 				fTime += 86400 * g_DungeonSiege.iEventStartDay;

  0080e	69 d2 80 51 01
	00		 imul	 edx, 86400		; 00015180H
  00814	03 c2		 add	 eax, edx
$LN12@Client:

; 571  : 			}
; 572  : 
; 573  : 			if(fTime > lTime)

  00816	3b c1		 cmp	 eax, ecx
  00818	7e 08		 jle	 SHORT $LN167@Client

; 574  : 			{
; 575  : 				TimeDungeonSiege = fTime - lTime;

  0081a	2b c1		 sub	 eax, ecx
  0081c	89 85 54 ff ff
	ff		 mov	 DWORD PTR _TimeDungeonSiege$[ebp], eax
$LN167@Client:

; 576  : 			}
; 577  : 		}
; 578  : 	}
; 579  : 
; 580  : 
; 581  : 	// ----
; 582  : 
; 583  : 	for(int i=0;i<this->CountRD;i++)

  00822	8b 75 90	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00825	33 db		 xor	 ebx, ebx
  00827	39 9e d8 12 00
	00		 cmp	 DWORD PTR [esi+4824], ebx
  0082d	7e 5c		 jle	 SHORT $LN173@Client

; 584  : 	{
; 585  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  0082f	0f b7 45 f4	 movzx	 eax, WORD PTR _t$[ebp+8]
  00833	0f b7 55 f6	 movzx	 edx, WORD PTR _t$[ebp+10]
  00837	8b c8		 mov	 ecx, eax
  00839	c1 e1 04	 shl	 ecx, 4
  0083c	2b c8		 sub	 ecx, eax
  0083e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00841	0f b7 55 f8	 movzx	 edx, WORD PTR _t$[ebp+12]
  00845	8b c8		 mov	 ecx, eax
  00847	c1 e1 04	 shl	 ecx, 4
  0084a	2b c8		 sub	 ecx, eax
  0084c	8d 3c 8a	 lea	 edi, DWORD PTR [edx+ecx*4]
  0084f	8d 8e bc 0f 00
	00		 lea	 ecx, DWORD PTR [esi+4028]
$LL10@Client:

; 586  : 		int fTime = this->RD[i].Hour * 3600 + this->RD[i].Min * 60 ;

  00855	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00858	8b d0		 mov	 edx, eax
  0085a	c1 e2 04	 shl	 edx, 4
  0085d	2b d0		 sub	 edx, eax
  0085f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00861	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]
  00864	8b c2		 mov	 eax, edx
  00866	c1 e0 04	 shl	 eax, 4
  00869	2b c2		 sub	 eax, edx
  0086b	03 c0		 add	 eax, eax
  0086d	03 c0		 add	 eax, eax

; 587  : 
; 588  : 		if(fTime > lTime )

  0086f	3b c7		 cmp	 eax, edi
  00871	7f 0e		 jg	 SHORT $LN134@Client

; 576  : 			}
; 577  : 		}
; 578  : 	}
; 579  : 
; 580  : 
; 581  : 	// ----
; 582  : 
; 583  : 	for(int i=0;i<this->CountRD;i++)

  00873	43		 inc	 ebx
  00874	83 c1 08	 add	 ecx, 8
  00877	3b 9e d8 12 00
	00		 cmp	 ebx, DWORD PTR [esi+4824]
  0087d	7c d6		 jl	 SHORT $LL10@Client

; 587  : 
; 588  : 		if(fTime > lTime )

  0087f	eb 0a		 jmp	 SHORT $LN173@Client
$LN134@Client:

; 589  : 		{
; 590  : 			RDStart = fTime - lTime;

  00881	2b c7		 sub	 eax, edi
  00883	89 85 7c ff ff
	ff		 mov	 DWORD PTR _RDStart$[ebp], eax

; 591  : 			break;
; 592  : 		}
; 593  : 	}
; 594  : 
; 595  : 	if(RDStart == 0)

  00889	75 50		 jne	 SHORT $LN5@Client
$LN173@Client:

; 596  : 	{
; 597  : 		int lTime = t.wHour * 3600 + t.wMinute * 60 + t.wSecond;

  0088b	0f b7 45 f4	 movzx	 eax, WORD PTR _t$[ebp+8]
  0088f	0f b7 55 f6	 movzx	 edx, WORD PTR _t$[ebp+10]
  00893	8b c8		 mov	 ecx, eax
  00895	c1 e1 04	 shl	 ecx, 4
  00898	2b c8		 sub	 ecx, eax
  0089a	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0089d	0f b7 55 f8	 movzx	 edx, WORD PTR _t$[ebp+12]
  008a1	8b c8		 mov	 ecx, eax
  008a3	c1 e1 04	 shl	 ecx, 4
  008a6	2b c8		 sub	 ecx, eax

; 598  : 		int fTime =  86400 + this->RD[0].Hour * 3600 + this->RD[0].Min * 60 ;

  008a8	8b 86 b8 0f 00
	00		 mov	 eax, DWORD PTR [esi+4024]
  008ae	83 c0 18	 add	 eax, 24			; 00000018H
  008b1	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  008b4	8b c8		 mov	 ecx, eax
  008b6	c1 e1 04	 shl	 ecx, 4
  008b9	2b c8		 sub	 ecx, eax
  008bb	8b 86 bc 0f 00
	00		 mov	 eax, DWORD PTR [esi+4028]
  008c1	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  008c4	8b c1		 mov	 eax, ecx
  008c6	c1 e0 04	 shl	 eax, 4
  008c9	2b c1		 sub	 eax, ecx
  008cb	03 c0		 add	 eax, eax
  008cd	03 c0		 add	 eax, eax

; 599  : 
; 600  : 		if(fTime > lTime )

  008cf	3b c2		 cmp	 eax, edx
  008d1	7e 08		 jle	 SHORT $LN5@Client

; 601  : 		{
; 602  : 			RDStart = fTime - lTime;

  008d3	2b c2		 sub	 eax, edx
  008d5	89 85 7c ff ff
	ff		 mov	 DWORD PTR _RDStart$[ebp], eax
$LN5@Client:

; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 	// ----
; 607  : 
; 608  : #endif
; 609  : 
; 610  : 	// ----
; 611  : 
; 612  : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX; n++)

  008db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008e1	8b bd 54 ff ff
	ff		 mov	 edi, DWORD PTR _TimeDungeonSiege$[ebp]
  008e7	8b 9d 4c ff ff
	ff		 mov	 ebx, DWORD PTR _TimeCastleSiege$[ebp]
  008ed	c7 45 90 00 a7
	40 09		 mov	 DWORD PTR tv2698[ebp], 155232000 ; 0940a700H
  008f4	8b 45 90	 mov	 eax, DWORD PTR tv2698[ebp]
  008f7	be b0 36 00 00	 mov	 esi, 14000		; 000036b0H
  008fc	8d 64 24 00	 npad	 4
$LL4@Client:

; 613  : 	{
; 614  : 		LPOBJ lpObj = &gObj[n];
; 615  : 		if ( lpObj->Connected >= PLAYER_PLAYING && lpObj->OffExp == 0 && lpObj->OffTrade == 0)

  00900	83 7c 08 04 03	 cmp	 DWORD PTR [eax+ecx+4], 3
  00905	0f 8c c9 00 00
	00		 jl	 $LN3@Client
  0090b	83 bc 08 98 22
	00 00 00	 cmp	 DWORD PTR [eax+ecx+8856], 0
  00913	0f 85 bb 00 00
	00		 jne	 $LN3@Client
  00919	83 bc 08 ac 22
	00 00 00	 cmp	 DWORD PTR [eax+ecx+8876], 0
  00921	0f 85 ad 00 00
	00		 jne	 $LN3@Client

; 616  : 		{
; 617  : 			GCTEventTime tSend;
; 618  : 			ZeroMemory(&tSend,sizeof(tSend));

  00927	6a 48		 push	 72			; 00000048H
  00929	8d 4d a4	 lea	 ecx, DWORD PTR _tSend$210992[ebp]
  0092c	6a 00		 push	 0
  0092e	51		 push	 ecx
  0092f	e8 00 00 00 00	 call	 _memset

; 619  : 			tSend.h.set((LPBYTE)&tSend, 0xFB, 16, sizeof(tSend));
; 620  : 			tSend.TimeBC = BCStart;

  00934	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _BCStart$[ebp]

; 621  : 			tSend.TimeDS = DSStart;

  0093a	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _DSStart$[ebp]

; 622  : 			tSend.TimeCC = CCStart;

  00940	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _CCStart$[ebp]
  00946	89 55 a8	 mov	 DWORD PTR _tSend$210992[ebp+4], edx

; 623  : 			tSend.TimeGD = GDStart;

  00949	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _GDStart$[ebp]
  0094f	89 55 b4	 mov	 DWORD PTR _tSend$210992[ebp+16], edx

; 624  : 			tSend.TimeWW = WWStart;
; 625  : #if(EVENT_TIMER_EX)
; 626  : 			tSend.TimeLora = TimeLora;
; 627  : 			tSend.TimeDevias = TimeDevias;

  00952	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _TimeDevias$[ebp]
  00958	89 45 ac	 mov	 DWORD PTR _tSend$210992[ebp+8], eax
  0095b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _WWStart$[ebp]
  00961	89 4d b0	 mov	 DWORD PTR _tSend$210992[ebp+12], ecx
  00964	8b 4d 80	 mov	 ecx, DWORD PTR _TimeLora$[ebp]
  00967	89 55 c0	 mov	 DWORD PTR _tSend$210992[ebp+28], edx

; 628  : 			tSend.TimeTvT = TimeTvT;
; 629  : 			tSend.TimePandora = TimePandora;
; 630  : 			tSend.TimeEvengelion = TimeEvengelion;

  0096a	8b 55 8c	 mov	 edx, DWORD PTR _TimeEvengelion$[ebp]
  0096d	89 45 b8	 mov	 DWORD PTR _tSend$210992[ebp+20], eax
  00970	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _TimeTvT$[ebp]
  00976	89 4d bc	 mov	 DWORD PTR _tSend$210992[ebp+24], ecx
  00979	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _TimePandora$[ebp]
  0097f	89 55 cc	 mov	 DWORD PTR _tSend$210992[ebp+40], edx

; 631  : 			tSend.TimeShop = TimeShop;
; 632  : 			tSend.TimeHappy = TimeHappy;
; 633  : 			tSend.TimeDropEvent = TimeDropEvent;

  00982	8b 55 84	 mov	 edx, DWORD PTR _TimeDropEvent$[ebp]
  00985	89 45 c4	 mov	 DWORD PTR _tSend$210992[ebp+32], eax
  00988	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _TimeShop$[ebp]
  0098e	89 4d c8	 mov	 DWORD PTR _tSend$210992[ebp+36], ecx
  00991	8b 4d 88	 mov	 ecx, DWORD PTR _TimeHappy$[ebp]
  00994	89 55 d8	 mov	 DWORD PTR _tSend$210992[ebp+52], edx

; 634  : 
; 635  : 			tSend.TimeCryWolf = TimeCryWolf;
; 636  : 			tSend.TimeCastleSiege = TimeCastleSiege;
; 637  : 			tSend.TimeDungeonSiege = TimeDungeonSiege;
; 638  : 			tSend.TimeRedDragon = RDStart;
; 639  : #endif
; 640  : 			DataSend(n,(LPBYTE)&tSend,sizeof(tSend));

  00997	6a 48		 push	 72			; 00000048H
  00999	8d 55 a4	 lea	 edx, DWORD PTR _tSend$210992[ebp]
  0099c	89 45 d0	 mov	 DWORD PTR _tSend$210992[ebp+44], eax
  0099f	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _TimeCryWolf$[ebp]
  009a5	89 4d d4	 mov	 DWORD PTR _tSend$210992[ebp+48], ecx
  009a8	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _RDStart$[ebp]
  009ae	52		 push	 edx
  009af	56		 push	 esi
  009b0	c7 45 a4 c1 48
	fb 10		 mov	 DWORD PTR _tSend$210992[ebp], 284903617 ; 10fb48c1H
  009b7	89 45 dc	 mov	 DWORD PTR _tSend$210992[ebp+56], eax
  009ba	89 5d e0	 mov	 DWORD PTR _tSend$210992[ebp+60], ebx
  009bd	89 7d e4	 mov	 DWORD PTR _tSend$210992[ebp+64], edi
  009c0	89 4d e8	 mov	 DWORD PTR _tSend$210992[ebp+68], ecx
  009c3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  009c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009ce	8b 45 90	 mov	 eax, DWORD PTR tv2698[ebp]
  009d1	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@Client:

; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 	// ----
; 607  : 
; 608  : #endif
; 609  : 
; 610  : 	// ----
; 611  : 
; 612  : 	for (int n=OBJ_STARTUSERINDZT;n<OBJMAX; n++)

  009d4	05 50 2b 00 00	 add	 eax, 11088		; 00002b50H
  009d9	46		 inc	 esi
  009da	89 45 90	 mov	 DWORD PTR tv2698[ebp], eax
  009dd	3d 80 d7 e9 09	 cmp	 eax, 166320000		; 09e9d780H
  009e2	0f 8c 18 ff ff
	ff		 jl	 $LL4@Client
  009e8	5f		 pop	 edi
$LN2@Client:

; 641  : 		}
; 642  : 	}
; 643  : }

  009e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009ec	5e		 pop	 esi
  009ed	33 cd		 xor	 ecx, ebp
  009ef	5b		 pop	 ebx
  009f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009f5	8b e5		 mov	 esp, ebp
  009f7	5d		 pop	 ebp
  009f8	c3		 ret	 0
?Client@cEventTimer@@QAEXXZ ENDP			; cEventTimer::Client
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgEventTimer@@YAXXZ
text$yc	SEGMENT
??__EgEventTimer@@YAXXZ PROC				; `dynamic initializer for 'gEventTimer'', COMDAT

; 23   : cEventTimer gEventTimer;

  00000	68 00 00 00 00	 push	 OFFSET ??__FgEventTimer@@YAXXZ ; `dynamic atexit destructor for 'gEventTimer''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EgEventTimer@@YAXXZ ENDP				; `dynamic initializer for 'gEventTimer''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgEventTimer@@YAXXZ
text$yd	SEGMENT
??__FgEventTimer@@YAXXZ PROC				; `dynamic atexit destructor for 'gEventTimer'', COMDAT
  00000	c3		 ret	 0
??__FgEventTimer@@YAXXZ ENDP				; `dynamic atexit destructor for 'gEventTimer''
text$yd	ENDS
PUBLIC	?gEventTimer@@3VcEventTimer@@A			; gEventTimer
_BSS	SEGMENT
?gEventTimer@@3VcEventTimer@@A DB 012dcH DUP (?)	; gEventTimer
_BSS	ENDS
CRT$XCU	SEGMENT
_gEventTimer$initializer$ DD FLAT:??__EgEventTimer@@YAXXZ
CRT$XCU	ENDS
END
