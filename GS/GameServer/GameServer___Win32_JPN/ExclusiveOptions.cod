; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\ExclusiveOptions.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gExclusiveOptions@@3VcExclusiveOptions@@A	; gExclusiveOptions
_BSS	SEGMENT
?gExclusiveOptions@@3VcExclusiveOptions@@A DB 01348H DUP (?) ; gExclusiveOptions
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0L@DBBEOKP@LOAD?5ERROR?$AA@		; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0CE@KHNMJFNL@?4?4?2Data?2ZtData?2ZtclusiveOptions?4@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cExclusiveOptions@@QAEXXZ			; cExclusiveOptions::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\exclusiveoptions.cpp
CONST	SEGMENT
??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%d %d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DBBEOKP@LOAD?5ERROR?$AA@
CONST	SEGMENT
??_C@_0L@DBBEOKP@LOAD?5ERROR?$AA@ DB 'LOAD ERROR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KHNMJFNL@?4?4?2Data?2ZtData?2ZtclusiveOptions?4@
CONST	SEGMENT
??_C@_0CE@KHNMJFNL@?4?4?2Data?2ZtData?2ZtclusiveOptions?4@ DB '..\Data\Zt'
	DB	'Data\ZtclusiveOptions.ini', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@cExclusiveOptions@@QAEXXZ
_TEXT	SEGMENT
_Flag$ = -312						; size = 4
_n$202441 = -308					; size = 16
_n$202448 = -292					; size = 12
_n$202444 = -276					; size = 12
_Buff$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?Load@cExclusiveOptions@@QAEXXZ PROC			; cExclusiveOptions::Load, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 15   : 	this->Enable = GetPrivateProfileInt("ZtTeam","Enable",0,ExclusiveOptions_DIR);

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KHNMJFNL@?4?4?2Data?2ZtData?2ZtclusiveOptions?4@
  0001b	33 ff		 xor	 edi, edi
  0001d	57		 push	 edi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00028	8b f1		 mov	 esi, ecx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 16   : 
; 17   : 	ZeroMemory(this->Exclusive,sizeof(Exclusive));

  00030	68 60 09 00 00	 push	 2400			; 00000960H
  00035	85 c0		 test	 eax, eax
  00037	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0003a	0f 95 c0	 setne	 al
  0003d	57		 push	 edi
  0003e	51		 push	 ecx
  0003f	88 06		 mov	 BYTE PTR [esi], al
  00041	e8 00 00 00 00	 call	 _memset

; 18   : 	ZeroMemory(this->ExclusiveInv,sizeof(ExclusiveInv));

  00046	68 60 09 00 00	 push	 2400			; 00000960H
  0004b	8d 96 64 09 00
	00		 lea	 edx, DWORD PTR [esi+2404]
  00051	57		 push	 edi
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 _memset

; 19   : 
; 20   : 	FILE * file = fopen(ExclusiveOptions_DIR,"r");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KHNMJFNL@?4?4?2Data?2ZtData?2ZtclusiveOptions?4@
  00062	e8 00 00 00 00	 call	 _fopen
  00067	8b d8		 mov	 ebx, eax
  00069	83 c4 20	 add	 esp, 32			; 00000020H

; 21   : 
; 22   : 	if(file == NULL)

  0006c	3b df		 cmp	 ebx, edi
  0006e	75 26		 jne	 SHORT $LN12@Load

; 23   : 	{
; 24   : 		MessageBoxA(0,ExclusiveOptions_DIR,"LOAD ERROR",0);

  00070	57		 push	 edi
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DBBEOKP@LOAD?5ERROR?$AA@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KHNMJFNL@?4?4?2Data?2ZtData?2ZtclusiveOptions?4@
  0007b	57		 push	 edi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00082	5f		 pop	 edi

; 25   : 		this->Enable = false;

  00083	c6 06 00	 mov	 BYTE PTR [esi], 0
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 86   : }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN12@Load:

; 26   : 	}
; 27   : 
; 28   : 	if(!this->Enable) return;

  00096	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00099	0f 84 d6 02 00
	00		 je	 $LN13@Load

; 29   : 
; 30   : 	char Buff[256];
; 31   : 	int Flag = 0;
; 32   : 
; 33   : 	this->Count = 0;
; 34   : 	this->CountInv = 0;
; 35   : #ifdef ZTCLUSIVE_AMYLET
; 36   : 	if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  0009f	6a 17		 push	 23			; 00000017H
  000a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000a6	89 bd c8 fe ff
	ff		 mov	 DWORD PTR _Flag$[ebp], edi
  000ac	89 be 40 13 00
	00		 mov	 DWORD PTR [esi+4928], edi
  000b2	89 be 44 13 00
	00		 mov	 DWORD PTR [esi+4932], edi
  000b8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000bd	84 c0		 test	 al, al
  000bf	75 2f		 jne	 SHORT $LN9@Load
  000c1	6a 1c		 push	 28			; 0000001cH
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000c8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000cd	84 c0		 test	 al, al
  000cf	75 1f		 jne	 SHORT $LN9@Load
  000d1	57		 push	 edi
  000d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000d7	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000dc	84 c0		 test	 al, al
  000de	75 10		 jne	 SHORT $LN9@Load
  000e0	6a 24		 push	 36			; 00000024H
  000e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000e7	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000ec	84 c0		 test	 al, al
  000ee	74 06		 je	 SHORT $LN16@Load
$LN9@Load:

; 37   : 	{
; 38   : 		this->CountInvTime = 0;

  000f0	89 be 3c 13 00
	00		 mov	 DWORD PTR [esi+4924], edi
$LN16@Load:

; 39   : 	}
; 40   : #endif
; 41   : 
; 42   : 	while(!feof(file))

  000f6	53		 push	 ebx
  000f7	e8 00 00 00 00	 call	 _feof
  000fc	83 c4 04	 add	 esp, 4
  000ff	85 c0		 test	 eax, eax
  00101	0f 85 65 02 00
	00		 jne	 $LN7@Load
  00107	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL8@Load:

; 43   : 	{
; 44   : 		fgets(Buff,256,file);

  00110	53		 push	 ebx
  00111	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00117	68 00 01 00 00	 push	 256			; 00000100H
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _fgets

; 45   : 		if(Zt_IsBadFileLine(Buff, Flag))

  00122	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _Flag$[ebp]
  00128	51		 push	 ecx
  00129	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  00135	83 c4 14	 add	 esp, 20			; 00000014H
  00138	84 c0		 test	 al, al
  0013a	0f 85 1b 02 00
	00		 jne	 $LN1@Load

; 46   : 			continue;
; 47   : 		if(Flag == 1)

  00140	39 bd c8 fe ff
	ff		 cmp	 DWORD PTR _Flag$[ebp], edi
  00146	0f 85 89 00 00
	00		 jne	 $LN5@Load

; 48   : 		{
; 49   : 			int n[4];
; 50   : 			sscanf(Buff, "%d %d %d %d" , &n[0], &n[1], &n[2], &n[3]);

  0014c	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _n$202441[ebp+12]
  00152	50		 push	 eax
  00153	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$202441[ebp+8]
  00159	51		 push	 ecx
  0015a	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _n$202441[ebp+4]
  00160	52		 push	 edx
  00161	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _n$202441[ebp]
  00167	50		 push	 eax
  00168	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00173	51		 push	 ecx
  00174	e8 00 00 00 00	 call	 _sscanf

; 51   : 			this->Exclusive[this->Count].Type = n[0];

  00179	8b 86 40 13 00
	00		 mov	 eax, DWORD PTR [esi+4928]
  0017f	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00182	66 8b 85 cc fe
	ff ff		 mov	 ax, WORD PTR _n$202441[ebp]
  00189	66 89 44 96 04	 mov	 WORD PTR [esi+edx*4+4], ax

; 52   : 			this->Exclusive[this->Count].Index = n[1];

  0018e	8b 86 40 13 00
	00		 mov	 eax, DWORD PTR [esi+4928]
  00194	66 8b 95 d0 fe
	ff ff		 mov	 dx, WORD PTR _n$202441[ebp+4]
  0019b	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0019e	66 89 54 8e 06	 mov	 WORD PTR [esi+ecx*4+6], dx

; 53   : 			this->Exclusive[this->Count].Options = n[2];

  001a3	8b 86 40 13 00
	00		 mov	 eax, DWORD PTR [esi+4928]
  001a9	66 8b 8d d4 fe
	ff ff		 mov	 cx, WORD PTR _n$202441[ebp+8]
  001b0	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  001b3	66 89 4c 86 08	 mov	 WORD PTR [esi+eax*4+8], cx

; 54   : 			this->Exclusive[this->Count].Value = n[3];

  001b8	8b 86 40 13 00
	00		 mov	 eax, DWORD PTR [esi+4928]
  001be	03 c7		 add	 eax, edi
  001c0	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001c3	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _n$202441[ebp+12]
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
  001cc	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 55   : 			this->Count++;

  001cf	01 be 40 13 00
	00		 add	 DWORD PTR [esi+4928], edi
$LN5@Load:

; 56   : 		}
; 57   : 		if(Flag == 2)

  001d5	83 bd c8 fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  001dc	0f 85 94 00 00
	00		 jne	 $LN4@Load

; 58   : 		{
; 59   : 			int n[3];
; 60   : 			sscanf(Buff, "%d %d %d %d" , &n[0], &n[1], &n[2], &n[3]);

  001e2	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$202444[ebp+12]
  001e8	51		 push	 ecx
  001e9	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _n$202444[ebp+8]
  001ef	52		 push	 edx
  001f0	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _n$202444[ebp+4]
  001f6	50		 push	 eax
  001f7	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _n$202444[ebp]
  001fd	51		 push	 ecx
  001fe	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00204	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00209	52		 push	 edx
  0020a	e8 00 00 00 00	 call	 _sscanf

; 61   : 			this->ExclusiveInv[this->CountInv].Type = n[0];

  0020f	8b 86 44 13 00
	00		 mov	 eax, DWORD PTR [esi+4932]
  00215	66 8b 8d ec fe
	ff ff		 mov	 cx, WORD PTR _n$202444[ebp]
  0021c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0021f	66 89 8c 86 64
	09 00 00	 mov	 WORD PTR [esi+eax*4+2404], cx

; 62   : 			this->ExclusiveInv[this->CountInv].Index = n[1];

  00227	8b 86 44 13 00
	00		 mov	 eax, DWORD PTR [esi+4932]
  0022d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00230	66 8b 85 f0 fe
	ff ff		 mov	 ax, WORD PTR _n$202444[ebp+4]
  00237	66 89 84 96 66
	09 00 00	 mov	 WORD PTR [esi+edx*4+2406], ax

; 63   : 			this->ExclusiveInv[this->CountInv].Options = n[2];

  0023f	8b 86 44 13 00
	00		 mov	 eax, DWORD PTR [esi+4932]
  00245	66 8b 95 f4 fe
	ff ff		 mov	 dx, WORD PTR _n$202444[ebp+8]
  0024c	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0024f	66 89 94 8e 68
	09 00 00	 mov	 WORD PTR [esi+ecx*4+2408], dx

; 64   : 			this->ExclusiveInv[this->CountInv].Value = n[3];

  00257	8b 86 44 13 00
	00		 mov	 eax, DWORD PTR [esi+4932]
  0025d	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _n$202444[ebp+12]
  00263	8d 84 40 5b 02
	00 00		 lea	 eax, DWORD PTR [eax+eax*2+603]
  0026a	83 c4 18	 add	 esp, 24			; 00000018H
  0026d	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 65   : 			this->CountInv++;

  00270	01 be 44 13 00
	00		 add	 DWORD PTR [esi+4932], edi
$LN4@Load:

; 66   : 		}
; 67   : 		
; 68   : #ifdef ZTCLUSIVE_AMYLET
; 69   : 		if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  00276	6a 17		 push	 23			; 00000017H
  00278	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0027d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00282	84 c0		 test	 al, al
  00284	75 34		 jne	 SHORT $LN2@Load
  00286	6a 1c		 push	 28			; 0000001cH
  00288	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0028d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00292	84 c0		 test	 al, al
  00294	75 24		 jne	 SHORT $LN2@Load
  00296	6a 00		 push	 0
  00298	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0029d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002a2	84 c0		 test	 al, al
  002a4	75 14		 jne	 SHORT $LN2@Load
  002a6	6a 24		 push	 36			; 00000024H
  002a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002ad	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002b2	84 c0		 test	 al, al
  002b4	0f 84 a1 00 00
	00		 je	 $LN1@Load
$LN2@Load:

; 70   : 		{
; 71   : 			if(Flag == 3)

  002ba	83 bd c8 fe ff
	ff 03		 cmp	 DWORD PTR _Flag$[ebp], 3
  002c1	0f 85 94 00 00
	00		 jne	 $LN1@Load

; 72   : 			{
; 73   : 				int n[3];
; 74   : 				sscanf(Buff, "%d %d %d %d" , &n[0], &n[1], &n[2], &n[3]);		

  002c7	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _n$202448[ebp+12]
  002cd	52		 push	 edx
  002ce	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _n$202448[ebp+8]
  002d4	50		 push	 eax
  002d5	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _n$202448[ebp+4]
  002db	51		 push	 ecx
  002dc	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _n$202448[ebp]
  002e2	52		 push	 edx
  002e3	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 _sscanf

; 75   : 				this->ExclusiveInvTime[this->CountInvTime].Type = n[0];

  002f4	8b 86 3c 13 00
	00		 mov	 eax, DWORD PTR [esi+4924]
  002fa	66 8b 95 dc fe
	ff ff		 mov	 dx, WORD PTR _n$202448[ebp]
  00301	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00304	66 89 94 8e c4
	12 00 00	 mov	 WORD PTR [esi+ecx*4+4804], dx

; 76   : 				this->ExclusiveInvTime[this->CountInvTime].Index = n[1];

  0030c	8b 86 3c 13 00
	00		 mov	 eax, DWORD PTR [esi+4924]
  00312	66 8b 8d e0 fe
	ff ff		 mov	 cx, WORD PTR _n$202448[ebp+4]
  00319	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0031c	66 89 8c 86 c6
	12 00 00	 mov	 WORD PTR [esi+eax*4+4806], cx

; 77   : 				this->ExclusiveInvTime[this->CountInvTime].Options = n[2];

  00324	8b 86 3c 13 00
	00		 mov	 eax, DWORD PTR [esi+4924]
  0032a	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0032d	66 8b 85 e4 fe
	ff ff		 mov	 ax, WORD PTR _n$202448[ebp+8]
  00334	66 89 84 96 c8
	12 00 00	 mov	 WORD PTR [esi+edx*4+4808], ax

; 78   : 				this->ExclusiveInvTime[this->CountInvTime].Value = n[3];

  0033c	8b 86 3c 13 00
	00		 mov	 eax, DWORD PTR [esi+4924]
  00342	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _n$202448[ebp+12]
  00348	8d 8c 40 b3 04
	00 00		 lea	 ecx, DWORD PTR [eax+eax*2+1203]
  0034f	83 c4 18	 add	 esp, 24			; 00000018H
  00352	89 14 8e	 mov	 DWORD PTR [esi+ecx*4], edx

; 79   : 				this->CountInvTime++;

  00355	01 be 3c 13 00
	00		 add	 DWORD PTR [esi+4924], edi
$LN1@Load:

; 39   : 	}
; 40   : #endif
; 41   : 
; 42   : 	while(!feof(file))

  0035b	53		 push	 ebx
  0035c	e8 00 00 00 00	 call	 _feof
  00361	83 c4 04	 add	 esp, 4
  00364	85 c0		 test	 eax, eax
  00366	0f 84 a4 fd ff
	ff		 je	 $LL8@Load
$LN7@Load:

; 80   : 			}
; 81   : 		}
; 82   : 		
; 83   : #endif
; 84   : 	}
; 85   : 	fclose(file);

  0036c	53		 push	 ebx
  0036d	e8 00 00 00 00	 call	 _fclose
  00372	83 c4 04	 add	 esp, 4
$LN13@Load:

; 86   : }

  00375	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00378	5f		 pop	 edi
  00379	5e		 pop	 esi
  0037a	33 cd		 xor	 ecx, ebp
  0037c	5b		 pop	 ebx
  0037d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00382	8b e5		 mov	 esp, ebp
  00384	5d		 pop	 ebp
  00385	c3		 ret	 0
?Load@cExclusiveOptions@@QAEXXZ ENDP			; cExclusiveOptions::Load
_TEXT	ENDS
PUBLIC	?Options@cExclusiveOptions@@QAEXH@Z		; cExclusiveOptions::Options
EXTRN	?CheckInventoryItem@@YA_NHH@Z:PROC		; CheckInventoryItem
EXTRN	?Max90Procent@@YAXAAH@Z:PROC			; Max90Procent
EXTRN	?CheckInCharacterItem@@YA_NHH@Z:PROC		; CheckInCharacterItem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?Options@cExclusiveOptions@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?Options@cExclusiveOptions@@QAEXH@Z PROC		; cExclusiveOptions::Options, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 106  : 	if(!this->Enable) return;

  00007	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0000a	89 7d fc	 mov	 DWORD PTR _this$[ebp], edi
  0000d	0f 84 ca 02 00
	00		 je	 $LN15@Options

; 107  : 
; 108  : 	LPOBJ lpObj = &gObj[aIndex];

  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 109  : 
; 110  : 	for(int a = 0; a < this->Count; a++)

  00024	33 db		 xor	 ebx, ebx
  00026	39 9f 40 13 00
	00		 cmp	 DWORD PTR [edi+4928], ebx
  0002c	0f 8e 40 01 00
	00		 jle	 $LN32@Options

; 107  : 
; 108  : 	LPOBJ lpObj = &gObj[aIndex];

  00032	83 c7 0c	 add	 edi, 12			; 0000000cH
$LL42@Options:

; 111  : 	{
; 112  : 		if(CheckInCharacterItem(aIndex,ITEMGET(this->Exclusive[a].Type,this->Exclusive[a].Index)))

  00035	0f bf 47 f8	 movsx	 eax, WORD PTR [edi-8]
  00039	0f bf 4f fa	 movsx	 ecx, WORD PTR [edi-6]
  0003d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00040	c1 e0 09	 shl	 eax, 9
  00043	03 c1		 add	 eax, ecx
  00045	50		 push	 eax
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?CheckInCharacterItem@@YA_NHH@Z ; CheckInCharacterItem
  0004c	83 c4 08	 add	 esp, 8
  0004f	84 c0		 test	 al, al
  00051	0f 84 06 01 00
	00		 je	 $LN33@Options

; 113  : 		{
; 114  : 			switch(this->Exclusive[a].Options)

  00057	0f bf 47 fc	 movsx	 eax, WORD PTR [edi-4]
  0005b	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0005e	0f 87 f9 00 00
	00		 ja	 $LN33@Options
  00064	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN46@Options[eax*4]
$LN28@Options:

; 115  : 			{
; 116  : 			case eExclusiveOpt::Damage:
; 117  : 				lpObj->m_AttackDamageMinRight += this->Exclusive[a].Value;

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	01 86 84 04 00
	00		 add	 DWORD PTR [esi+1156], eax

; 118  : 				lpObj->m_AttackDamageMaxRight += this->Exclusive[a].Value;

  00073	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00075	01 8e 80 04 00
	00		 add	 DWORD PTR [esi+1152], ecx

; 119  : 				lpObj->m_AttackDamageMinLeft += this->Exclusive[a].Value;

  0007b	8b 17		 mov	 edx, DWORD PTR [edi]
  0007d	01 96 7c 04 00
	00		 add	 DWORD PTR [esi+1148], edx

; 120  : 				lpObj->m_AttackDamageMaxLeft += this->Exclusive[a].Value;

  00083	8b 07		 mov	 eax, DWORD PTR [edi]
  00085	01 86 78 04 00
	00		 add	 DWORD PTR [esi+1144], eax

; 121  : /*				lpObj->m_MagicDamageMin += this->Exclusive[a].Value;
; 122  : 				lpObj->m_MagicDamageMax += this->Exclusive[a].Value;	*/	
; 123  : 				break;

  0008b	e9 cd 00 00 00	 jmp	 $LN33@Options
$LN27@Options:

; 124  : 			case eExclusiveOpt::MinDefence:
; 125  : 				lpObj->m_Defense += this->Exclusive[a].Value;

  00090	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00092	01 8e 94 04 00
	00		 add	 DWORD PTR [esi+1172], ecx

; 126  : 				break;

  00098	e9 c0 00 00 00	 jmp	 $LN33@Options
$LN26@Options:

; 127  : 			case eExclusiveOpt::IgnoreDefence:
; 128  : 				lpObj->SetOpIgnoreDefense += this->Exclusive[a].Value;

  0009d	8a 17		 mov	 dl, BYTE PTR [edi]
  0009f	00 96 3e 11 00
	00		 add	 BYTE PTR [esi+4414], dl
  000a5	8d 86 3e 11 00
	00		 lea	 eax, DWORD PTR [esi+4414]

; 129  : 				Max90Procent((int&)lpObj->SetOpIgnoreDefense);

  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  000b1	83 c4 04	 add	 esp, 4

; 130  : 				break;

  000b4	e9 a4 00 00 00	 jmp	 $LN33@Options
$LN25@Options:

; 131  : 			case eExclusiveOpt::CriticalDamageRate:
; 132  : 				lpObj->m_CriticalDamage += this->Exclusive[a].Value;

  000b9	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000bb	01 8e bc 04 00
	00		 add	 DWORD PTR [esi+1212], ecx
  000c1	8d 86 bc 04 00
	00		 lea	 eax, DWORD PTR [esi+1212]

; 133  : 				Max90Procent((int&)lpObj->m_CriticalDamage);

  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  000cd	83 c4 04	 add	 esp, 4

; 134  : 				break;

  000d0	e9 88 00 00 00	 jmp	 $LN33@Options
$LN24@Options:

; 135  : 			case eExclusiveOpt::ExellentDamageRate:
; 136  : 				lpObj->m_ExcelentDamage += this->Exclusive[a].Value;

  000d5	8b 17		 mov	 edx, DWORD PTR [edi]
  000d7	01 96 c0 04 00
	00		 add	 DWORD PTR [esi+1216], edx
  000dd	8d 86 c0 04 00
	00		 lea	 eax, DWORD PTR [esi+1216]

; 137  : 				Max90Procent((int&)lpObj->m_ExcelentDamage);

  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  000e9	83 c4 04	 add	 esp, 4

; 138  : 				break;

  000ec	eb 6f		 jmp	 SHORT $LN33@Options
$LN23@Options:

; 139  : 			case eExclusiveOpt::DoubleDamage:
; 140  : 				lpObj->SetOpDoubleDamage += this->Exclusive[a].Value;

  000ee	8a 0f		 mov	 cl, BYTE PTR [edi]
  000f0	00 8e 3f 11 00
	00		 add	 BYTE PTR [esi+4415], cl
  000f6	8d 86 3f 11 00
	00		 lea	 eax, DWORD PTR [esi+4415]

; 141  : 				Max90Procent((int&)lpObj->SetOpDoubleDamage);

  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  00102	83 c4 04	 add	 esp, 4

; 142  : 				break;

  00105	eb 56		 jmp	 SHORT $LN33@Options
$LN22@Options:

; 143  : 			case eExclusiveOpt::AbsordDamage:
; 144  : 				lpObj->DamageMinus += this->Exclusive[a].Value;

  00107	8a 17		 mov	 dl, BYTE PTR [edi]
  00109	00 96 70 01 00
	00		 add	 BYTE PTR [esi+368], dl
  0010f	8d 86 70 01 00
	00		 lea	 eax, DWORD PTR [esi+368]

; 145  : 				Max90Procent((int&)lpObj->DamageMinus);

  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  0011b	83 c4 04	 add	 esp, 4

; 146  : 				break;

  0011e	eb 3d		 jmp	 SHORT $LN33@Options
$LN21@Options:

; 147  : 			case eExclusiveOpt::ReflectDamage:
; 148  : 				lpObj->DamageReflect += this->Exclusive[a].Value;

  00120	8a 0f		 mov	 cl, BYTE PTR [edi]
  00122	00 8e 71 01 00
	00		 add	 BYTE PTR [esi+369], cl
  00128	8d 86 71 01 00
	00		 lea	 eax, DWORD PTR [esi+369]

; 149  : 				Max90Procent((int&)lpObj->DamageReflect);

  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  00134	83 c4 04	 add	 esp, 4

; 150  : 				break;

  00137	eb 24		 jmp	 SHORT $LN33@Options
$LN20@Options:

; 151  : 			case eExclusiveOpt::SD:
; 152  : 				lpObj->iAddShield += this->Exclusive[a].Value;

  00139	8b 17		 mov	 edx, DWORD PTR [edi]
  0013b	01 96 5c 01 00
	00		 add	 DWORD PTR [esi+348], edx

; 153  : 				break;

  00141	eb 1a		 jmp	 SHORT $LN33@Options
$LN19@Options:

; 154  : 			case eExclusiveOpt::Life:
; 155  : 				lpObj->AddLife += this->Exclusive[a].Value;

  00143	8b 07		 mov	 eax, DWORD PTR [edi]
  00145	01 86 4c 01 00
	00		 add	 DWORD PTR [esi+332], eax

; 156  : 				break;

  0014b	eb 10		 jmp	 SHORT $LN33@Options
$LN18@Options:

; 157  : 			case eExclusiveOpt::WizardDamage:
; 158  : 				lpObj->m_MagicDamageMin += this->Exclusive[a].Value;

  0014d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0014f	01 8e 68 04 00
	00		 add	 DWORD PTR [esi+1128], ecx

; 159  : 				lpObj->m_MagicDamageMax += this->Exclusive[a].Value;

  00155	8b 17		 mov	 edx, DWORD PTR [edi]
  00157	01 96 6c 04 00
	00		 add	 DWORD PTR [esi+1132], edx
$LN33@Options:

; 109  : 
; 110  : 	for(int a = 0; a < this->Count; a++)

  0015d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00160	43		 inc	 ebx
  00161	83 c7 0c	 add	 edi, 12			; 0000000cH
  00164	3b 98 40 13 00
	00		 cmp	 ebx, DWORD PTR [eax+4928]
  0016a	0f 8c c5 fe ff
	ff		 jl	 $LL42@Options
  00170	8b f8		 mov	 edi, eax
$LN32@Options:

; 160  : 				break;
; 161  : 			}
; 162  : 		}
; 163  : 	}
; 164  : 
; 165  : 	for(int a = 0; a < this->CountInv; a++)

  00172	33 db		 xor	 ebx, ebx
  00174	39 9f 44 13 00
	00		 cmp	 DWORD PTR [edi+4932], ebx
  0017a	0f 8e 5b 01 00
	00		 jle	 $LN44@Options
  00180	81 c7 6c 09 00
	00		 add	 edi, 2412		; 0000096cH
  00186	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL43@Options:

; 166  : 	{
; 167  : 		if(CheckInventoryItem(aIndex,ITEMGET(this->ExclusiveInv[a].Type,this->ExclusiveInv[a].Index)))

  00190	0f bf 4f f8	 movsx	 ecx, WORD PTR [edi-8]
  00194	0f bf 57 fa	 movsx	 edx, WORD PTR [edi-6]
  00198	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0019b	c1 e1 09	 shl	 ecx, 9
  0019e	03 ca		 add	 ecx, edx
  001a0	51		 push	 ecx
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 ?CheckInventoryItem@@YA_NHH@Z ; CheckInventoryItem
  001a7	83 c4 08	 add	 esp, 8
  001aa	84 c0		 test	 al, al
  001ac	0f 84 16 01 00
	00		 je	 $LN16@Options

; 168  : 		{
; 169  : 			switch(this->ExclusiveInv[a].Options)

  001b2	0f bf 47 fc	 movsx	 eax, WORD PTR [edi-4]
  001b6	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001b9	0f 87 09 01 00
	00		 ja	 $LN16@Options
  001bf	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN47@Options[eax*4]
$LN11@Options:

; 170  : 			{
; 171  : 			case eExclusiveOpt::Damage:
; 172  : 				lpObj->m_AttackDamageMinRight += this->ExclusiveInv[a].Value;

  001c6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001c8	01 8e 84 04 00
	00		 add	 DWORD PTR [esi+1156], ecx

; 173  : 				lpObj->m_AttackDamageMaxRight += this->ExclusiveInv[a].Value;

  001ce	8b 17		 mov	 edx, DWORD PTR [edi]
  001d0	01 96 80 04 00
	00		 add	 DWORD PTR [esi+1152], edx

; 174  : 				lpObj->m_AttackDamageMinLeft += this->ExclusiveInv[a].Value;

  001d6	8b 07		 mov	 eax, DWORD PTR [edi]
  001d8	01 86 7c 04 00
	00		 add	 DWORD PTR [esi+1148], eax

; 175  : 				lpObj->m_AttackDamageMaxLeft += this->ExclusiveInv[a].Value;

  001de	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001e0	01 8e 78 04 00
	00		 add	 DWORD PTR [esi+1144], ecx

; 176  : 				lpObj->m_MagicDamageMin += this->ExclusiveInv[a].Value;

  001e6	8b 17		 mov	 edx, DWORD PTR [edi]
  001e8	01 96 68 04 00
	00		 add	 DWORD PTR [esi+1128], edx

; 177  : 				lpObj->m_MagicDamageMax += this->ExclusiveInv[a].Value;		

  001ee	8b 07		 mov	 eax, DWORD PTR [edi]
  001f0	01 86 6c 04 00
	00		 add	 DWORD PTR [esi+1132], eax

; 178  : 				break;

  001f6	e9 cd 00 00 00	 jmp	 $LN16@Options
$LN10@Options:

; 179  : 			case eExclusiveOpt::MinDefence:
; 180  : 				lpObj->m_Defense += this->ExclusiveInv[a].Value;

  001fb	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001fd	01 8e 94 04 00
	00		 add	 DWORD PTR [esi+1172], ecx

; 181  : 				break;

  00203	e9 c0 00 00 00	 jmp	 $LN16@Options
$LN9@Options:

; 182  : 			case eExclusiveOpt::IgnoreDefence:
; 183  : 				lpObj->SetOpIgnoreDefense += this->ExclusiveInv[a].Value;

  00208	8a 17		 mov	 dl, BYTE PTR [edi]
  0020a	00 96 3e 11 00
	00		 add	 BYTE PTR [esi+4414], dl
  00210	8d 86 3e 11 00
	00		 lea	 eax, DWORD PTR [esi+4414]

; 184  : 				Max90Procent((int&)lpObj->SetOpIgnoreDefense);

  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  0021c	83 c4 04	 add	 esp, 4

; 185  : 				break;

  0021f	e9 a4 00 00 00	 jmp	 $LN16@Options
$LN8@Options:

; 186  : 			case eExclusiveOpt::CriticalDamageRate:
; 187  : 				lpObj->m_CriticalDamage += this->ExclusiveInv[a].Value;

  00224	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00226	01 8e bc 04 00
	00		 add	 DWORD PTR [esi+1212], ecx
  0022c	8d 86 bc 04 00
	00		 lea	 eax, DWORD PTR [esi+1212]

; 188  : 				Max90Procent((int&)lpObj->m_CriticalDamage);

  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  00238	83 c4 04	 add	 esp, 4

; 189  : 				break;

  0023b	e9 88 00 00 00	 jmp	 $LN16@Options
$LN7@Options:

; 190  : 			case eExclusiveOpt::ExellentDamageRate:
; 191  : 				lpObj->m_ExcelentDamage += this->ExclusiveInv[a].Value;

  00240	8b 17		 mov	 edx, DWORD PTR [edi]
  00242	01 96 c0 04 00
	00		 add	 DWORD PTR [esi+1216], edx
  00248	8d 86 c0 04 00
	00		 lea	 eax, DWORD PTR [esi+1216]

; 192  : 				Max90Procent((int&)lpObj->m_ExcelentDamage);

  0024e	50		 push	 eax
  0024f	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  00254	83 c4 04	 add	 esp, 4

; 193  : 				break;

  00257	eb 6f		 jmp	 SHORT $LN16@Options
$LN6@Options:

; 194  : 			case eExclusiveOpt::DoubleDamage:
; 195  : 				lpObj->SetOpDoubleDamage += this->ExclusiveInv[a].Value;

  00259	8a 0f		 mov	 cl, BYTE PTR [edi]
  0025b	00 8e 3f 11 00
	00		 add	 BYTE PTR [esi+4415], cl
  00261	8d 86 3f 11 00
	00		 lea	 eax, DWORD PTR [esi+4415]

; 196  : 				Max90Procent((int&)lpObj->SetOpDoubleDamage);

  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  0026d	83 c4 04	 add	 esp, 4

; 197  : 				break;

  00270	eb 56		 jmp	 SHORT $LN16@Options
$LN5@Options:

; 198  : 			case eExclusiveOpt::AbsordDamage:
; 199  : 				lpObj->DamageMinus += this->ExclusiveInv[a].Value;

  00272	8a 17		 mov	 dl, BYTE PTR [edi]
  00274	00 96 70 01 00
	00		 add	 BYTE PTR [esi+368], dl
  0027a	8d 86 70 01 00
	00		 lea	 eax, DWORD PTR [esi+368]

; 200  : 				Max90Procent((int&)lpObj->DamageMinus);

  00280	50		 push	 eax
  00281	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  00286	83 c4 04	 add	 esp, 4

; 201  : 				break;

  00289	eb 3d		 jmp	 SHORT $LN16@Options
$LN4@Options:

; 202  : 			case eExclusiveOpt::ReflectDamage:
; 203  : 				lpObj->DamageReflect += this->ExclusiveInv[a].Value;

  0028b	8a 0f		 mov	 cl, BYTE PTR [edi]
  0028d	00 8e 71 01 00
	00		 add	 BYTE PTR [esi+369], cl
  00293	8d 86 71 01 00
	00		 lea	 eax, DWORD PTR [esi+369]

; 204  : 				Max90Procent((int&)lpObj->DamageReflect);

  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 ?Max90Procent@@YAXAAH@Z	; Max90Procent
  0029f	83 c4 04	 add	 esp, 4

; 205  : 				break;

  002a2	eb 24		 jmp	 SHORT $LN16@Options
$LN3@Options:

; 206  : 			case eExclusiveOpt::SD:
; 207  : 				lpObj->iAddShield += this->ExclusiveInv[a].Value;

  002a4	8b 17		 mov	 edx, DWORD PTR [edi]
  002a6	01 96 5c 01 00
	00		 add	 DWORD PTR [esi+348], edx

; 208  : 				break;

  002ac	eb 1a		 jmp	 SHORT $LN16@Options
$LN2@Options:

; 209  : 			case eExclusiveOpt::Life:
; 210  : 				lpObj->AddLife += this->ExclusiveInv[a].Value;

  002ae	8b 07		 mov	 eax, DWORD PTR [edi]
  002b0	01 86 4c 01 00
	00		 add	 DWORD PTR [esi+332], eax

; 211  : 				break;

  002b6	eb 10		 jmp	 SHORT $LN16@Options
$LN1@Options:

; 212  : 			case eExclusiveOpt::WizardDamage:
; 213  : 				lpObj->m_MagicDamageMin += this->ExclusiveInv[a].Value;

  002b8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002ba	01 8e 68 04 00
	00		 add	 DWORD PTR [esi+1128], ecx

; 214  : 				lpObj->m_MagicDamageMax += this->ExclusiveInv[a].Value;

  002c0	8b 17		 mov	 edx, DWORD PTR [edi]
  002c2	01 96 6c 04 00
	00		 add	 DWORD PTR [esi+1132], edx
$LN16@Options:

; 160  : 				break;
; 161  : 			}
; 162  : 		}
; 163  : 	}
; 164  : 
; 165  : 	for(int a = 0; a < this->CountInv; a++)

  002c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002cb	43		 inc	 ebx
  002cc	83 c7 0c	 add	 edi, 12			; 0000000cH
  002cf	3b 98 44 13 00
	00		 cmp	 ebx, DWORD PTR [eax+4932]
  002d5	0f 8c b5 fe ff
	ff		 jl	 $LL43@Options
$LN44@Options:
  002db	5e		 pop	 esi
  002dc	5b		 pop	 ebx
$LN15@Options:
  002dd	5f		 pop	 edi

; 215  : 				break;
; 216  : 			}
; 217  : 		}
; 218  : 	}
; 219  : 
; 220  : }

  002de	8b e5		 mov	 esp, ebp
  002e0	5d		 pop	 ebp
  002e1	c2 04 00	 ret	 4
$LN46@Options:
  002e4	00 00 00 00	 DD	 $LN28@Options
  002e8	00 00 00 00	 DD	 $LN27@Options
  002ec	00 00 00 00	 DD	 $LN26@Options
  002f0	00 00 00 00	 DD	 $LN25@Options
  002f4	00 00 00 00	 DD	 $LN24@Options
  002f8	00 00 00 00	 DD	 $LN23@Options
  002fc	00 00 00 00	 DD	 $LN22@Options
  00300	00 00 00 00	 DD	 $LN21@Options
  00304	00 00 00 00	 DD	 $LN20@Options
  00308	00 00 00 00	 DD	 $LN19@Options
  0030c	00 00 00 00	 DD	 $LN18@Options
$LN47@Options:
  00310	00 00 00 00	 DD	 $LN11@Options
  00314	00 00 00 00	 DD	 $LN10@Options
  00318	00 00 00 00	 DD	 $LN9@Options
  0031c	00 00 00 00	 DD	 $LN8@Options
  00320	00 00 00 00	 DD	 $LN7@Options
  00324	00 00 00 00	 DD	 $LN6@Options
  00328	00 00 00 00	 DD	 $LN5@Options
  0032c	00 00 00 00	 DD	 $LN4@Options
  00330	00 00 00 00	 DD	 $LN3@Options
  00334	00 00 00 00	 DD	 $LN2@Options
  00338	00 00 00 00	 DD	 $LN1@Options
?Options@cExclusiveOptions@@QAEXH@Z ENDP		; cExclusiveOptions::Options
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	?DropZen@cExclusiveOptions@@QAEXHAAM@Z		; cExclusiveOptions::DropZen
EXTRN	__fltused:DWORD
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DropZen@cExclusiveOptions@@QAEXHAAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?DropZen@cExclusiveOptions@@QAEXHAAM@Z PROC		; cExclusiveOptions::DropZen, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 224  : 	if(!this->Enable) return;

  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000d	0f 84 fc 00 00
	00		 je	 $LN5@DropZen

; 225  : 
; 226  : 	for(int a = 0; a < this->Count; a++)

  00013	53		 push	 ebx
  00014	33 db		 xor	 ebx, ebx
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _money$[ebp]
  0001a	39 9e 40 13 00
	00		 cmp	 DWORD PTR [esi+4928], ebx
  00020	7e 6c		 jle	 SHORT $LN12@DropZen
  00022	83 c6 08	 add	 esi, 8
$LL14@DropZen:

; 227  : 	{
; 228  : 		if(CheckInCharacterItem(aIndex,ITEMGET(this->Exclusive[a].Type,this->Exclusive[a].Index)) && this->Exclusive[a].Options == eExclusiveOpt::Zen)

  00025	0f bf 46 fc	 movsx	 eax, WORD PTR [esi-4]
  00029	0f bf 4e fe	 movsx	 ecx, WORD PTR [esi-2]
  0002d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00030	c1 e0 09	 shl	 eax, 9
  00033	03 c1		 add	 eax, ecx
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?CheckInCharacterItem@@YA_NHH@Z ; CheckInCharacterItem
  0003c	83 c4 08	 add	 esp, 8
  0003f	84 c0		 test	 al, al
  00041	74 3a		 je	 SHORT $LN13@DropZen
  00043	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00046	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH
  0004a	75 31		 jne	 SHORT $LN13@DropZen

; 229  : 		{
; 230  : 			if(this->Exclusive[a].Options)

  0004c	66 85 c0	 test	 ax, ax
  0004f	74 2c		 je	 SHORT $LN13@DropZen

; 231  : 			{
; 232  : 				if (g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  00051	6a 12		 push	 18			; 00000012H
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00058	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0005d	84 c0		 test	 al, al
  0005f	74 0d		 je	 SHORT $LN9@DropZen

; 233  : 				{
; 234  : 					money += ( money * this->Exclusive[a].Value)/100;

  00061	db 46 04	 fild	 DWORD PTR [esi+4]
  00064	d8 0f		 fmul	 DWORD PTR [edi]
  00066	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000

; 235  : 				}
; 236  : 				else

  0006c	eb 0b		 jmp	 SHORT $LN26@DropZen
$LN9@DropZen:

; 237  : 				{
; 238  : 					money += ( money * 100 ) / this->Exclusive[a].Value;

  0006e	d9 07		 fld	 DWORD PTR [edi]
  00070	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4059000000000000
  00076	da 76 04	 fidiv	 DWORD PTR [esi+4]
$LN26@DropZen:
  00079	d8 07		 fadd	 DWORD PTR [edi]
  0007b	d9 1f		 fstp	 DWORD PTR [edi]
$LN13@DropZen:

; 225  : 
; 226  : 	for(int a = 0; a < this->Count; a++)

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	43		 inc	 ebx
  00081	83 c6 0c	 add	 esi, 12			; 0000000cH
  00084	3b 98 40 13 00
	00		 cmp	 ebx, DWORD PTR [eax+4928]
  0008a	7c 99		 jl	 SHORT $LL14@DropZen
  0008c	8b f0		 mov	 esi, eax
$LN12@DropZen:

; 239  : 				}
; 240  : 				
; 241  : 			}
; 242  : 		}
; 243  : 	}
; 244  : 
; 245  : 	for(int a = 0; a < this->CountInv; a++)

  0008e	33 db		 xor	 ebx, ebx
  00090	39 9e 44 13 00
	00		 cmp	 DWORD PTR [esi+4932], ebx
  00096	7e 75		 jle	 SHORT $LN24@DropZen
  00098	81 c6 68 09 00
	00		 add	 esi, 2408		; 00000968H
  0009e	8b ff		 npad	 2
$LL7@DropZen:

; 246  : 	{
; 247  : 		if(CheckInventoryItem(aIndex,ITEMGET(this->ExclusiveInv[a].Type,this->ExclusiveInv[a].Index)) && this->ExclusiveInv[a].Options == eExclusiveOpt::Zen)

  000a0	0f bf 4e fc	 movsx	 ecx, WORD PTR [esi-4]
  000a4	0f bf 56 fe	 movsx	 edx, WORD PTR [esi-2]
  000a8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000ab	c1 e1 09	 shl	 ecx, 9
  000ae	03 ca		 add	 ecx, edx
  000b0	51		 push	 ecx
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?CheckInventoryItem@@YA_NHH@Z ; CheckInventoryItem
  000b7	83 c4 08	 add	 esp, 8
  000ba	84 c0		 test	 al, al
  000bc	74 40		 je	 SHORT $LN6@DropZen
  000be	0f b7 06	 movzx	 eax, WORD PTR [esi]
  000c1	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH
  000c5	75 37		 jne	 SHORT $LN6@DropZen

; 248  : 		{
; 249  : 			if(this->ExclusiveInv[a].Options)

  000c7	66 85 c0	 test	 ax, ax
  000ca	74 32		 je	 SHORT $LN6@DropZen

; 250  : 			{
; 251  : 				if (g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  000cc	6a 12		 push	 18			; 00000012H
  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000d3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000d8	84 c0		 test	 al, al
  000da	74 10		 je	 SHORT $LN2@DropZen

; 252  : 				{
; 253  : 					money += ( money * this->Exclusive[a].Value)/100;

  000dc	db 86 a4 f6 ff
	ff		 fild	 DWORD PTR [esi-2396]
  000e2	d8 0f		 fmul	 DWORD PTR [edi]
  000e4	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000

; 254  : 				}
; 255  : 				else

  000ea	eb 0e		 jmp	 SHORT $LN27@DropZen
$LN2@DropZen:

; 256  : 				{
; 257  : 					money += ( money * 100 ) / this->Exclusive[a].Value;

  000ec	d9 07		 fld	 DWORD PTR [edi]
  000ee	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4059000000000000
  000f4	da b6 a4 f6 ff
	ff		 fidiv	 DWORD PTR [esi-2396]
$LN27@DropZen:
  000fa	d8 07		 fadd	 DWORD PTR [edi]
  000fc	d9 1f		 fstp	 DWORD PTR [edi]
$LN6@DropZen:

; 239  : 				}
; 240  : 				
; 241  : 			}
; 242  : 		}
; 243  : 	}
; 244  : 
; 245  : 	for(int a = 0; a < this->CountInv; a++)

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	43		 inc	 ebx
  00102	83 c6 0c	 add	 esi, 12			; 0000000cH
  00105	3b 99 44 13 00
	00		 cmp	 ebx, DWORD PTR [ecx+4932]
  0010b	7c 93		 jl	 SHORT $LL7@DropZen
$LN24@DropZen:
  0010d	5f		 pop	 edi
  0010e	5b		 pop	 ebx
$LN5@DropZen:
  0010f	5e		 pop	 esi

; 258  : 				}
; 259  : 			}
; 260  : 		}
; 261  : 	}
; 262  : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 08 00	 ret	 8
?DropZen@cExclusiveOptions@@QAEXHAAM@Z ENDP		; cExclusiveOptions::DropZen
_TEXT	ENDS
PUBLIC	?ExpFunction@cExclusiveOptions@@QAEXHAA_J@Z	; cExclusiveOptions::ExpFunction
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Ogtp
;	COMDAT ?ExpFunction@cExclusiveOptions@@QAEXHAA_J@Z
_TEXT	SEGMENT
tv818 = -12						; size = 4
tv816 = -12						; size = 4
tv814 = -12						; size = 4
tv929 = -8						; size = 4
tv748 = -8						; size = 4
_a$202535 = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
tv561 = 12						; size = 4
_a$202553 = 12						; size = 4
_a$202543 = 12						; size = 4
_exp$ = 12						; size = 4
?ExpFunction@cExclusiveOptions@@QAEXHAA_J@Z PROC	; cExclusiveOptions::ExpFunction, COMDAT
; _this$ = ecx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 266  : 	if(!this->Enable) return;

  00009	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0000c	89 5d fc	 mov	 DWORD PTR _this$[ebp], ebx
  0000f	0f 84 72 02 00
	00		 je	 $LN3@ExpFunctio

; 267  : 
; 268  : 	for(int a = 0; a < this->Count; a++)

  00015	83 bb 40 13 00
	00 00		 cmp	 DWORD PTR [ebx+4928], 0
  0001c	56		 push	 esi
  0001d	8b 75 0c	 mov	 esi, DWORD PTR _exp$[ebp]
  00020	57		 push	 edi
  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _a$202535[ebp], 0
  00028	0f 8e af 00 00
	00		 jle	 $LN31@ExpFunctio
  0002e	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]
  00031	89 7d 0c	 mov	 DWORD PTR tv561[ebp], edi
$LL21@ExpFunctio:

; 269  : 	{
; 270  : 		if(CheckInCharacterItem(aIndex,ITEMGET(this->Exclusive[a].Type,this->Exclusive[a].Index)) && this->Exclusive[a].Options == eExclusiveOpt::Exp)

  00034	0f bf 47 fc	 movsx	 eax, WORD PTR [edi-4]
  00038	0f bf 4f fe	 movsx	 ecx, WORD PTR [edi-2]
  0003c	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0003f	c1 e0 09	 shl	 eax, 9
  00042	03 c1		 add	 eax, ecx
  00044	50		 push	 eax
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ?CheckInCharacterItem@@YA_NHH@Z ; CheckInCharacterItem
  0004b	83 c4 08	 add	 esp, 8
  0004e	84 c0		 test	 al, al
  00050	74 72		 je	 SHORT $LN20@ExpFunctio
  00052	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00055	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH
  00059	75 69		 jne	 SHORT $LN20@ExpFunctio

; 271  : 		{
; 272  : 			if(this->Exclusive[a].Options)

  0005b	66 85 c0	 test	 ax, ax
  0005e	74 64		 je	 SHORT $LN20@ExpFunctio

; 273  : 			{
; 274  : 				if (g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  00060	6a 12		 push	 18			; 00000012H
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00067	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0006c	84 c0		 test	 al, al

; 275  : 				{
; 276  : 					exp += ( exp * this->Exclusive[a].Value)/100;

  0006e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00071	99		 cdq
  00072	74 20		 je	 SHORT $LN16@ExpFunctio
  00074	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00077	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00079	51		 push	 ecx
  0007a	53		 push	 ebx
  0007b	52		 push	 edx
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 __allmul
  00082	6a 00		 push	 0
  00084	6a 64		 push	 100			; 00000064H
  00086	52		 push	 edx
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 __alldiv
  0008d	03 c3		 add	 eax, ebx
  0008f	13 56 04	 adc	 edx, DWORD PTR [esi+4]

; 277  : 				}
; 278  : 				else

  00092	eb 28		 jmp	 SHORT $LN35@ExpFunctio
$LN16@ExpFunctio:

; 279  : 				{
; 280  : 					exp += ( exp * 100 ) / this->Exclusive[a].Value;

  00094	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00097	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00099	6a 00		 push	 0
  0009b	6a 64		 push	 100			; 00000064H
  0009d	53		 push	 ebx
  0009e	51		 push	 ecx
  0009f	8b f8		 mov	 edi, eax
  000a1	89 55 f4	 mov	 DWORD PTR tv818[ebp], edx
  000a4	e8 00 00 00 00	 call	 __allmul
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR tv818[ebp]
  000ac	51		 push	 ecx
  000ad	57		 push	 edi
  000ae	52		 push	 edx
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 __alldiv
  000b5	03 06		 add	 eax, DWORD PTR [esi]
  000b7	8b 7d 0c	 mov	 edi, DWORD PTR tv561[ebp]
  000ba	13 d3		 adc	 edx, ebx
$LN35@ExpFunctio:
  000bc	8b 5d fc	 mov	 ebx, DWORD PTR _this$[ebp]
  000bf	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000c2	89 06		 mov	 DWORD PTR [esi], eax
$LN20@ExpFunctio:

; 267  : 
; 268  : 	for(int a = 0; a < this->Count; a++)

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _a$202535[ebp]
  000c7	40		 inc	 eax
  000c8	83 c7 0c	 add	 edi, 12			; 0000000cH
  000cb	89 45 f8	 mov	 DWORD PTR _a$202535[ebp], eax
  000ce	89 7d 0c	 mov	 DWORD PTR tv561[ebp], edi
  000d1	3b 83 40 13 00
	00		 cmp	 eax, DWORD PTR [ebx+4928]
  000d7	0f 8c 57 ff ff
	ff		 jl	 $LL21@ExpFunctio
$LN31@ExpFunctio:

; 281  : 				}
; 282  : 				
; 283  : 			}
; 284  : 		}
; 285  : 	}
; 286  : 
; 287  : 	for(int a = 0; a < this->CountInv; a++)

  000dd	83 bb 44 13 00
	00 00		 cmp	 DWORD PTR [ebx+4932], 0
  000e4	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _a$202543[ebp], 0
  000eb	0f 8e bb 00 00
	00		 jle	 $LN12@ExpFunctio
  000f1	8d bb 68 09 00
	00		 lea	 edi, DWORD PTR [ebx+2408]
  000f7	89 7d f8	 mov	 DWORD PTR tv748[ebp], edi
  000fa	8d 9b 00 00 00
	00		 npad	 6
$LL14@ExpFunctio:

; 288  : 	{
; 289  : 		if(CheckInventoryItem(aIndex,ITEMGET(this->ExclusiveInv[a].Type,this->ExclusiveInv[a].Index)) && this->ExclusiveInv[a].Options == eExclusiveOpt::Exp)

  00100	0f bf 47 fc	 movsx	 eax, WORD PTR [edi-4]
  00104	0f bf 4f fe	 movsx	 ecx, WORD PTR [edi-2]
  00108	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0010b	c1 e0 09	 shl	 eax, 9
  0010e	03 c1		 add	 eax, ecx
  00110	50		 push	 eax
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 ?CheckInventoryItem@@YA_NHH@Z ; CheckInventoryItem
  00117	83 c4 08	 add	 esp, 8
  0011a	84 c0		 test	 al, al
  0011c	74 75		 je	 SHORT $LN13@ExpFunctio
  0011e	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00121	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH
  00125	75 6c		 jne	 SHORT $LN13@ExpFunctio

; 290  : 		{
; 291  : 			if(this->ExclusiveInv[a].Options)

  00127	66 85 c0	 test	 ax, ax
  0012a	74 67		 je	 SHORT $LN13@ExpFunctio

; 292  : 			{
; 293  : 				if (g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  0012c	6a 12		 push	 18			; 00000012H
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00133	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00138	84 c0		 test	 al, al

; 294  : 				{
; 295  : 					exp += ( exp * this->Exclusive[a].Value)/100;

  0013a	8b 87 a4 f6 ff
	ff		 mov	 eax, DWORD PTR [edi-2396]
  00140	99		 cdq
  00141	74 20		 je	 SHORT $LN9@ExpFunctio
  00143	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00146	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00148	51		 push	 ecx
  00149	53		 push	 ebx
  0014a	52		 push	 edx
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 __allmul
  00151	6a 00		 push	 0
  00153	6a 64		 push	 100			; 00000064H
  00155	52		 push	 edx
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 __alldiv
  0015c	03 c3		 add	 eax, ebx
  0015e	13 56 04	 adc	 edx, DWORD PTR [esi+4]

; 296  : 				}
; 297  : 				else

  00161	eb 28		 jmp	 SHORT $LN36@ExpFunctio
$LN9@ExpFunctio:

; 298  : 				{
; 299  : 					exp += ( exp * 100 ) / this->Exclusive[a].Value;

  00163	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00166	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00168	6a 00		 push	 0
  0016a	6a 64		 push	 100			; 00000064H
  0016c	53		 push	 ebx
  0016d	51		 push	 ecx
  0016e	8b f8		 mov	 edi, eax
  00170	89 55 f4	 mov	 DWORD PTR tv816[ebp], edx
  00173	e8 00 00 00 00	 call	 __allmul
  00178	8b 4d f4	 mov	 ecx, DWORD PTR tv816[ebp]
  0017b	51		 push	 ecx
  0017c	57		 push	 edi
  0017d	52		 push	 edx
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 __alldiv
  00184	03 06		 add	 eax, DWORD PTR [esi]
  00186	8b 7d f8	 mov	 edi, DWORD PTR tv748[ebp]
  00189	13 d3		 adc	 edx, ebx
$LN36@ExpFunctio:
  0018b	8b 5d fc	 mov	 ebx, DWORD PTR _this$[ebp]
  0018e	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00191	89 06		 mov	 DWORD PTR [esi], eax
$LN13@ExpFunctio:

; 281  : 				}
; 282  : 				
; 283  : 			}
; 284  : 		}
; 285  : 	}
; 286  : 
; 287  : 	for(int a = 0; a < this->CountInv; a++)

  00193	8b 45 0c	 mov	 eax, DWORD PTR _a$202543[ebp]
  00196	40		 inc	 eax
  00197	83 c7 0c	 add	 edi, 12			; 0000000cH
  0019a	89 45 0c	 mov	 DWORD PTR _a$202543[ebp], eax
  0019d	89 7d f8	 mov	 DWORD PTR tv748[ebp], edi
  001a0	3b 83 44 13 00
	00		 cmp	 eax, DWORD PTR [ebx+4932]
  001a6	0f 8c 54 ff ff
	ff		 jl	 $LL14@ExpFunctio
$LN12@ExpFunctio:

; 300  : 				}
; 301  : 			}
; 302  : 		}
; 303  : 	}
; 304  : #ifdef ZTCLUSIVE_AMYLET
; 305  : 	if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  001ac	6a 17		 push	 23			; 00000017H
  001ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001b3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001b8	84 c0		 test	 al, al
  001ba	75 34		 jne	 SHORT $LN32@ExpFunctio
  001bc	6a 1c		 push	 28			; 0000001cH
  001be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001c3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001c8	84 c0		 test	 al, al
  001ca	75 24		 jne	 SHORT $LN32@ExpFunctio
  001cc	6a 00		 push	 0
  001ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001d3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001d8	84 c0		 test	 al, al
  001da	75 14		 jne	 SHORT $LN32@ExpFunctio
  001dc	6a 24		 push	 36			; 00000024H
  001de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001e3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001e8	84 c0		 test	 al, al
  001ea	0f 84 95 00 00
	00		 je	 $LN33@ExpFunctio
$LN32@ExpFunctio:

; 306  : 	{
; 307  : 	for(int a = 0; a < this->CountInvTime; a++)

  001f0	83 bb 3c 13 00
	00 00		 cmp	 DWORD PTR [ebx+4924], 0
  001f7	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _a$202553[ebp], 0
  001fe	0f 8e 81 00 00
	00		 jle	 $LN33@ExpFunctio
  00204	81 c3 c8 12 00
	00		 add	 ebx, 4808		; 000012c8H
  0020a	89 5d f8	 mov	 DWORD PTR tv929[ebp], ebx
  0020d	8d 49 00	 npad	 3
$LL5@ExpFunctio:

; 308  : 	{
; 309  : 		if(CheckInventoryItem(aIndex,ITEMGET(this->ExclusiveInvTime[a].Type,this->ExclusiveInvTime[a].Index)) && this->ExclusiveInvTime[a].Options == eExclusiveOpt::Exp)

  00210	0f bf 43 fc	 movsx	 eax, WORD PTR [ebx-4]
  00214	0f bf 4b fe	 movsx	 ecx, WORD PTR [ebx-2]
  00218	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0021b	c1 e0 09	 shl	 eax, 9
  0021e	03 c1		 add	 eax, ecx
  00220	50		 push	 eax
  00221	52		 push	 edx
  00222	e8 00 00 00 00	 call	 ?CheckInventoryItem@@YA_NHH@Z ; CheckInventoryItem
  00227	83 c4 08	 add	 esp, 8
  0022a	84 c0		 test	 al, al
  0022c	74 3f		 je	 SHORT $LN4@ExpFunctio
  0022e	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00231	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH
  00235	75 36		 jne	 SHORT $LN4@ExpFunctio

; 310  : 		{
; 311  : 			if(this->ExclusiveInvTime[a].Options)

  00237	66 85 c0	 test	 ax, ax
  0023a	74 31		 je	 SHORT $LN4@ExpFunctio

; 312  : 			{
; 313  : 				exp += ( exp * 100 ) / this->ExclusiveInvTime[a].Value;

  0023c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0023f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00242	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00244	6a 00		 push	 0
  00246	6a 64		 push	 100			; 00000064H
  00248	99		 cdq
  00249	57		 push	 edi
  0024a	51		 push	 ecx
  0024b	8b d8		 mov	 ebx, eax
  0024d	89 55 f4	 mov	 DWORD PTR tv814[ebp], edx
  00250	e8 00 00 00 00	 call	 __allmul
  00255	8b 4d f4	 mov	 ecx, DWORD PTR tv814[ebp]
  00258	51		 push	 ecx
  00259	53		 push	 ebx
  0025a	52		 push	 edx
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 __alldiv
  00261	03 06		 add	 eax, DWORD PTR [esi]
  00263	8b 5d f8	 mov	 ebx, DWORD PTR tv929[ebp]
  00266	13 d7		 adc	 edx, edi
  00268	89 06		 mov	 DWORD PTR [esi], eax
  0026a	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN4@ExpFunctio:

; 306  : 	{
; 307  : 	for(int a = 0; a < this->CountInvTime; a++)

  0026d	8b 45 0c	 mov	 eax, DWORD PTR _a$202553[ebp]
  00270	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00273	40		 inc	 eax
  00274	83 c3 0c	 add	 ebx, 12			; 0000000cH
  00277	89 45 0c	 mov	 DWORD PTR _a$202553[ebp], eax
  0027a	89 5d f8	 mov	 DWORD PTR tv929[ebp], ebx
  0027d	3b 81 3c 13 00
	00		 cmp	 eax, DWORD PTR [ecx+4924]
  00283	7c 8b		 jl	 SHORT $LL5@ExpFunctio
$LN33@ExpFunctio:
  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
$LN3@ExpFunctio:
  00287	5b		 pop	 ebx

; 314  : 			}
; 315  : 		}
; 316  : 	}
; 317  : 	}
; 318  : #endif
; 319  : }

  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c2 08 00	 ret	 8
?ExpFunction@cExclusiveOptions@@QAEXHAA_J@Z ENDP	; cExclusiveOptions::ExpFunction
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3f800000
PUBLIC	?TickTime@cExclusiveOptions@@QAEXH@Z		; cExclusiveOptions::TickTime
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TickTime@cExclusiveOptions@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_a$202567 = -4						; size = 4
_aIndex$ = 8						; size = 4
?TickTime@cExclusiveOptions@@QAEXH@Z PROC		; cExclusiveOptions::TickTime, COMDAT
; _this$ = ecx

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 325  : 	if(!this->Enable) return;

  00009	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0000c	89 7d f8	 mov	 DWORD PTR _this$[ebp], edi
  0000f	0f 84 24 01 00
	00		 je	 $LN6@TickTime

; 326  : 	LPOBJ lpObj = &gObj[aIndex];

  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  0001f	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 327  : 	if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  00025	6a 17		 push	 23			; 00000017H
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0002c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00031	84 c0		 test	 al, al
  00033	75 34		 jne	 SHORT $LN17@TickTime
  00035	6a 1c		 push	 28			; 0000001cH
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0003c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00041	84 c0		 test	 al, al
  00043	75 24		 jne	 SHORT $LN17@TickTime
  00045	6a 00		 push	 0
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0004c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00051	84 c0		 test	 al, al
  00053	75 14		 jne	 SHORT $LN17@TickTime
  00055	6a 24		 push	 36			; 00000024H
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0005c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00061	84 c0		 test	 al, al
  00063	0f 84 cf 00 00
	00		 je	 $LN18@TickTime
$LN17@TickTime:

; 328  : 	{
; 329  : 		for(int a = 0; a < this->CountInvTime; a++)

  00069	83 bf 3c 13 00
	00 00		 cmp	 DWORD PTR [edi+4924], 0
  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _a$202567[ebp], 0
  00077	0f 8e bb 00 00
	00		 jle	 $LN18@TickTime
  0007d	56		 push	 esi
  0007e	8d b3 44 28 00
	00		 lea	 esi, DWORD PTR [ebx+10308]
  00084	81 c7 c6 12 00
	00		 add	 edi, 4806		; 000012c6H
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL8@TickTime:

; 330  : 		{
; 331  : 			if(CheckInCharacterItem(aIndex,ITEMGET(this->ExclusiveInvTime[a].Type,this->ExclusiveInvTime[a].Index)))

  00090	0f bf 47 fe	 movsx	 eax, WORD PTR [edi-2]
  00094	0f bf 0f	 movsx	 ecx, WORD PTR [edi]
  00097	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0009a	c1 e0 09	 shl	 eax, 9
  0009d	03 c1		 add	 eax, ecx
  0009f	50		 push	 eax
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ?CheckInCharacterItem@@YA_NHH@Z ; CheckInCharacterItem
  000a6	83 c4 08	 add	 esp, 8
  000a9	84 c0		 test	 al, al
  000ab	74 58		 je	 SHORT $LN7@TickTime

; 332  : 			{
; 333  : 			//	switch(this->ExclusiveInv[a].Options)
; 334  : 				if(lpObj->pInventory[9].m_Type == ITEMGET(this->ExclusiveInvTime[a].Type,this->ExclusiveInvTime[a].Index))

  000ad	0f bf 4f fe	 movsx	 ecx, WORD PTR [edi-2]
  000b1	0f bf 17	 movsx	 edx, WORD PTR [edi]
  000b4	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  000ba	c1 e1 09	 shl	 ecx, 9
  000bd	03 ca		 add	 ecx, edx
  000bf	0f bf 90 7a 07
	00 00		 movsx	 edx, WORD PTR [eax+1914]
  000c6	3b d1		 cmp	 edx, ecx
  000c8	75 3b		 jne	 SHORT $LN7@TickTime

; 335  : 				{
; 336  : 					if(lpObj->pInventory[9].m_Durability < 1.0f)

  000ca	d9 e8		 fld1
  000cc	d8 98 98 07 00
	00		 fcomp	 DWORD PTR [eax+1944]
  000d2	df e0		 fnstsw	 ax
  000d4	f6 c4 41	 test	 ah, 65			; 00000041H
  000d7	74 51		 je	 SHORT $LN15@TickTime

; 339  : 
; 340  : 						return;
; 341  : 					}	
; 342  : 					if(lpObj->ExclusiveItemTime[a] > 960)//16 minutes

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]
  000db	3d c0 03 00 00	 cmp	 eax, 960		; 000003c0H
  000e0	7e 20		 jle	 SHORT $LN2@TickTime

; 343  : 					{
; 344  : 						lpObj->pInventory[9].m_Durability--;

  000e2	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  000e8	d9 80 98 07 00
	00		 fld	 DWORD PTR [eax+1944]
  000ee	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  000f4	d9 98 98 07 00
	00		 fstp	 DWORD PTR [eax+1944]

; 345  : 						lpObj->ExclusiveItemTime[a] = 0;

  000fa	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 346  : 					}
; 347  : 					else

  00100	eb 03		 jmp	 SHORT $LN7@TickTime
$LN2@TickTime:

; 348  : 					{
; 349  : 						lpObj->ExclusiveItemTime[a]++;

  00102	40		 inc	 eax
  00103	89 06		 mov	 DWORD PTR [esi], eax
$LN7@TickTime:

; 328  : 	{
; 329  : 		for(int a = 0; a < this->CountInvTime; a++)

  00105	8b 45 fc	 mov	 eax, DWORD PTR _a$202567[ebp]
  00108	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	40		 inc	 eax
  0010c	83 c6 04	 add	 esi, 4
  0010f	83 c7 0c	 add	 edi, 12			; 0000000cH
  00112	89 45 fc	 mov	 DWORD PTR _a$202567[ebp], eax
  00115	3b 81 3c 13 00
	00		 cmp	 eax, DWORD PTR [ecx+4924]
  0011b	0f 8c 6f ff ff
	ff		 jl	 $LL8@TickTime
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	5f		 pop	 edi

; 350  : 					}
; 351  : 				}
; 352  : 			}
; 353  : 		}
; 354  : 	}
; 355  : }

  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 04 00	 ret	 4
$LN15@TickTime:

; 337  : 					{
; 338  : 						gObjInventoryDeleteItem(lpObj->m_Index,9);

  0012a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0012c	6a 09		 push	 9
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00134	83 c4 08	 add	 esp, 8
  00137	5e		 pop	 esi
$LN18@TickTime:
  00138	5b		 pop	 ebx
$LN6@TickTime:
  00139	5f		 pop	 edi

; 350  : 					}
; 351  : 				}
; 352  : 			}
; 353  : 		}
; 354  : 	}
; 355  : }

  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 04 00	 ret	 4
?TickTime@cExclusiveOptions@@QAEXH@Z ENDP		; cExclusiveOptions::TickTime
_TEXT	ENDS
END
