; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\Functions.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetRandomExeOption@@YAEE@Z			; GetRandomExeOption
EXTRN	_rand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\functions.cpp
;	COMDAT ?GetRandomExeOption@@YAEE@Z
_TEXT	SEGMENT
_ExeOptions$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_MaxOption$ = 8						; size = 1
?GetRandomExeOption@@YAEE@Z PROC			; GetRandomExeOption, COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 11   : 	unsigned char ExeOptions[6] = {1,2,4,8,16,32};

  00011	c7 45 f4 01 02
	04 08		 mov	 DWORD PTR _ExeOptions$[ebp], 134480385 ; 08040201H
  00018	66 c7 45 f8 10
	20		 mov	 WORD PTR _ExeOptions$[ebp+4], 8208 ; 00002010H

; 12   : 	// ----
; 13   : 	unsigned char Random = 0;
; 14   : 	unsigned char RandomEx = 0;
; 15   : 	unsigned char ReturnValue = 0;

  0001e	32 db		 xor	 bl, bl

; 16   : 
; 17   : 	Random = rand()%(MaxOption+1);

  00020	e8 00 00 00 00	 call	 _rand
  00025	0f b6 4d 08	 movzx	 ecx, BYTE PTR _MaxOption$[ebp]
  00029	99		 cdq
  0002a	41		 inc	 ecx
  0002b	f7 f9		 idiv	 ecx

; 18   : 
; 19   : 	for (int i=0;i<Random;i++)

  0002d	0f b6 c2	 movzx	 eax, dl
  00030	85 c0		 test	 eax, eax
  00032	7e 1e		 jle	 SHORT $LN13@GetRandomE

; 11   : 	unsigned char ExeOptions[6] = {1,2,4,8,16,32};

  00034	56		 push	 esi
  00035	8b f0		 mov	 esi, eax
$LL3@GetRandomE:

; 20   : 	{
; 21   : 		while ( true )
; 22   : 		{
; 23   : 			RandomEx = ExeOptions[rand()%6];

  00037	e8 00 00 00 00	 call	 _rand
  0003c	99		 cdq
  0003d	b9 06 00 00 00	 mov	 ecx, 6
  00042	f7 f9		 idiv	 ecx
  00044	8a 54 15 f4	 mov	 dl, BYTE PTR _ExeOptions$[ebp+edx]

; 24   : 
; 25   : 			if ( (ReturnValue&RandomEx) == 0 )

  00048	84 da		 test	 bl, dl
  0004a	75 eb		 jne	 SHORT $LL3@GetRandomE

; 26   : 			{
; 27   : 				ReturnValue+=RandomEx;

  0004c	02 da		 add	 bl, dl
  0004e	4e		 dec	 esi
  0004f	75 e6		 jne	 SHORT $LL3@GetRandomE
  00051	5e		 pop	 esi
$LN13@GetRandomE:

; 28   : 				break;
; 29   : 			}
; 30   : 		}
; 31   : 	}
; 32   : 	return ReturnValue;
; 33   : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	8a c3		 mov	 al, bl
  00057	33 cd		 xor	 ecx, ebp
  00059	5b		 pop	 ebx
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?GetRandomExeOption@@YAEE@Z ENDP			; GetRandomExeOption
_TEXT	ENDS
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	?Zt_IsBadFileLine@@YA_NPADAAH@Z			; Zt_IsBadFileLine
EXTRN	_isalnum:PROC
EXTRN	_strncmp:PROC
EXTRN	_isdigit:PROC
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Zt_IsBadFileLine@@YA_NPADAAH@Z
_TEXT	SEGMENT
_FileLine$ = 8						; size = 4
tv85 = 12						; size = 4
_Flag$ = 12						; size = 4
?Zt_IsBadFileLine@@YA_NPADAAH@Z PROC			; Zt_IsBadFileLine, COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 36   : 	if(Flag == 0)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _Flag$[ebp]
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _FileLine$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	75 1e		 jne	 SHORT $LN20@Zt_IsBadFi

; 37   : 	{
; 38   : 		if(isdigit(FileLine[0]))

  00011	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _isdigit
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN9@Zt_IsBadFi

; 39   : 		{
; 40   : 			Flag = FileLine[0] - 48;

  00021	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  00024	83 e9 30	 sub	 ecx, 48			; 00000030H
  00027	89 0e		 mov	 DWORD PTR [esi], ecx
$LN5@Zt_IsBadFi:

; 56   : 		return true;

  00029	5f		 pop	 edi
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 63   : 	}
; 64   : 	return true;
; 65   : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN20@Zt_IsBadFi:

; 41   : 			return true;
; 42   : 		}
; 43   : 	}
; 44   : 	else if(Flag < 0 || Flag > 9)	//Old 9

  0002f	78 05		 js	 SHORT $LN8@Zt_IsBadFi
  00031	83 f8 09	 cmp	 eax, 9
  00034	7e 06		 jle	 SHORT $LN9@Zt_IsBadFi
$LN8@Zt_IsBadFi:

; 45   : 	{
; 46   : 		Flag = 0;

  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN9@Zt_IsBadFi:

; 47   : 	}
; 48   : 
; 49   : 	if(!strncmp(FileLine, "end", 3))

  0003c	6a 03		 push	 3
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 _strncmp
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	85 c0		 test	 eax, eax
  0004e	75 08		 jne	 SHORT $LN7@Zt_IsBadFi

; 50   : 	{
; 51   : 		Flag = 0;

  00050	89 06		 mov	 DWORD PTR [esi], eax
  00052	5f		 pop	 edi

; 56   : 		return true;

  00053	b0 01		 mov	 al, 1
  00055	5e		 pop	 esi

; 63   : 	}
; 64   : 	return true;
; 65   : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN7@Zt_IsBadFi:

; 52   : 		return true;
; 53   : 	}
; 54   : 
; 55   : 	if(FileLine[0] == '/' || FileLine[0] == '\n')

  00058	8a 07		 mov	 al, BYTE PTR [edi]
  0005a	3c 2f		 cmp	 al, 47			; 0000002fH
  0005c	74 cb		 je	 SHORT $LN5@Zt_IsBadFi
  0005e	3c 0a		 cmp	 al, 10			; 0000000aH
  00060	74 c7		 je	 SHORT $LN5@Zt_IsBadFi

; 57   : 
; 58   : 
; 59   : 	for(UINT i = 0; i < strlen(FileLine); i++)

  00062	8b c7		 mov	 eax, edi
  00064	33 f6		 xor	 esi, esi
  00066	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL18@Zt_IsBadFi:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL18@Zt_IsBadFi
  00077	2b c2		 sub	 eax, edx
  00079	74 ae		 je	 SHORT $LN5@Zt_IsBadFi
  0007b	eb 03 8d 49 00	 npad	 5
$LL4@Zt_IsBadFi:

; 60   : 	{
; 61   : 		if(isalnum(FileLine[i]))

  00080	0f be 14 3e	 movsx	 edx, BYTE PTR [esi+edi]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _isalnum
  0008a	83 c4 04	 add	 esp, 4
  0008d	85 c0		 test	 eax, eax
  0008f	75 19		 jne	 SHORT $LN16@Zt_IsBadFi

; 57   : 
; 58   : 
; 59   : 	for(UINT i = 0; i < strlen(FileLine); i++)

  00091	8b c7		 mov	 eax, edi
  00093	46		 inc	 esi
  00094	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL19@Zt_IsBadFi:
  00097	8a 08		 mov	 cl, BYTE PTR [eax]
  00099	40		 inc	 eax
  0009a	84 c9		 test	 cl, cl
  0009c	75 f9		 jne	 SHORT $LL19@Zt_IsBadFi
  0009e	2b c2		 sub	 eax, edx
  000a0	3b f0		 cmp	 esi, eax
  000a2	72 dc		 jb	 SHORT $LL4@Zt_IsBadFi

; 56   : 		return true;

  000a4	5f		 pop	 edi
  000a5	b0 01		 mov	 al, 1
  000a7	5e		 pop	 esi

; 63   : 	}
; 64   : 	return true;
; 65   : }

  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN16@Zt_IsBadFi:
  000aa	5f		 pop	 edi

; 62   : 			return false;

  000ab	32 c0		 xor	 al, al
  000ad	5e		 pop	 esi

; 63   : 	}
; 64   : 	return true;
; 65   : }

  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?Zt_IsBadFileLine@@YA_NPADAAH@Z ENDP			; Zt_IsBadFileLine
_TEXT	ENDS
PUBLIC	?GetNumberByPercent@@YAHHHH@Z			; GetNumberByPercent
; Function compile flags: /Ogtp
;	COMDAT ?GetNumberByPercent@@YAHHHH@Z
_TEXT	SEGMENT
_Proc$ = 8						; size = 4
_Min$ = 12						; size = 4
_Max$ = 16						; size = 4
?GetNumberByPercent@@YAHHHH@Z PROC			; GetNumberByPercent, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 68   : 	int Random = rand()%100;

  00006	e8 00 00 00 00	 call	 _rand

; 69   : 
; 70   : 	if(Proc == 0 || Max == Min)

  0000b	8b 75 08	 mov	 esi, DWORD PTR _Proc$[ebp]
  0000e	8b 5d 0c	 mov	 ebx, DWORD PTR _Min$[ebp]
  00011	99		 cdq
  00012	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00017	f7 f9		 idiv	 ecx
  00019	85 f6		 test	 esi, esi
  0001b	74 35		 je	 SHORT $LN6@GetNumberB
  0001d	8b 7d 10	 mov	 edi, DWORD PTR _Max$[ebp]
$LL10@GetNumberB:
  00020	3b fb		 cmp	 edi, ebx
  00022	74 2e		 je	 SHORT $LN6@GetNumberB

; 72   : 	
; 73   : 	if(Random <= Proc)

  00024	3b d6		 cmp	 edx, esi
  00026	7e 31		 jle	 SHORT $LN13@GetNumberB

; 75   : 
; 76   : 	if(Proc > 50)
; 77   : 		return GetNumberByPercent(Proc/2, Min, Max-1);

  00028	4f		 dec	 edi
  00029	83 fe 32	 cmp	 esi, 50			; 00000032H
  0002c	7e 04		 jle	 SHORT $LN4@GetNumberB
  0002e	8b c6		 mov	 eax, esi
  00030	eb 08		 jmp	 SHORT $LN15@GetNumberB
$LN4@GetNumberB:

; 78   : 	else if(Proc < 30)

  00032	83 fe 1e	 cmp	 esi, 30			; 0000001eH
  00035	7d 0a		 jge	 SHORT $LN14@GetNumberB

; 79   : 		return GetNumberByPercent(Proc*3/2, Min, Max-1);

  00037	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
$LN15@GetNumberB:
  0003a	99		 cdq
  0003b	2b c2		 sub	 eax, edx
  0003d	d1 f8		 sar	 eax, 1
  0003f	8b f0		 mov	 esi, eax
$LN14@GetNumberB:

; 68   : 	int Random = rand()%100;

  00041	e8 00 00 00 00	 call	 _rand
  00046	99		 cdq
  00047	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0004c	f7 f9		 idiv	 ecx

; 69   : 
; 70   : 	if(Proc == 0 || Max == Min)

  0004e	85 f6		 test	 esi, esi
  00050	75 ce		 jne	 SHORT $LL10@GetNumberB
$LN6@GetNumberB:
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 71   : 		return Min;

  00054	8b c3		 mov	 eax, ebx
  00056	5b		 pop	 ebx

; 80   : 	else
; 81   : 		return GetNumberByPercent(Proc, Min, Max-1);
; 82   : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN13@GetNumberB:

; 74   : 		return Max;

  00059	8b c7		 mov	 eax, edi
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 80   : 	else
; 81   : 		return GetNumberByPercent(Proc, Min, Max-1);
; 82   : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GetNumberByPercent@@YAHHHH@Z ENDP			; GetNumberByPercent
_TEXT	ENDS
PUBLIC	?gObjGetItemCountInInventory@@YAHHHH@Z		; gObjGetItemCountInInventory
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetItemCountInInventory@@YAHHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_ItemID$ = 12						; size = 4
_ItemLevel$ = 16					; size = 4
?gObjGetItemCountInInventory@@YAHHHH@Z PROC		; gObjGetItemCountInInventory, COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 120  : 	if(aIndex >= OBJMAX)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  0000b	7c 04		 jl	 SHORT $LN5@gObjGetIte

; 121  : 		return 0;

  0000d	33 c0		 xor	 eax, eax

; 132  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN5@gObjGetIte:

; 122  : 
; 123  : 	LPOBJ lpObj = &gObj[aIndex];

  00011	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00017	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	53		 push	 ebx
  0001e	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00024	8b 45 10	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00027	56		 push	 esi
  00028	8b 75 0c	 mov	 esi, DWORD PTR _ItemID$[ebp]

; 124  : 
; 125  : 	int Count = 0;

  0002b	33 d2		 xor	 edx, edx
  0002d	57		 push	 edi
  0002e	81 c1 f8 09 00
	00		 add	 ecx, 2552		; 000009f8H
  00034	8d 7a 38	 lea	 edi, DWORD PTR [edx+56]
$LL4@gObjGetIte:

; 127  : 	{
; 128  : 		if (lpObj->pInventory[i].m_Type == ItemID && lpObj->pInventory[i].m_Level == ItemLevel)

  00037	0f bf 59 fe	 movsx	 ebx, WORD PTR [ecx-2]
  0003b	3b de		 cmp	 ebx, esi
  0003d	75 08		 jne	 SHORT $LN3@gObjGetIte
  0003f	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  00042	3b d8		 cmp	 ebx, eax
  00044	75 01		 jne	 SHORT $LN3@gObjGetIte

; 129  : 			Count++;

  00046	42		 inc	 edx
$LN3@gObjGetIte:

; 127  : 	{
; 128  : 		if (lpObj->pInventory[i].m_Type == ItemID && lpObj->pInventory[i].m_Level == ItemLevel)

  00047	0f bf 99 d2 00
	00 00		 movsx	 ebx, WORD PTR [ecx+210]
  0004e	3b de		 cmp	 ebx, esi
  00050	75 0c		 jne	 SHORT $LN11@gObjGetIte
  00052	0f bf 99 d4 00
	00 00		 movsx	 ebx, WORD PTR [ecx+212]
  00059	3b d8		 cmp	 ebx, eax
  0005b	75 01		 jne	 SHORT $LN11@gObjGetIte

; 129  : 			Count++;

  0005d	42		 inc	 edx
$LN11@gObjGetIte:

; 127  : 	{
; 128  : 		if (lpObj->pInventory[i].m_Type == ItemID && lpObj->pInventory[i].m_Level == ItemLevel)

  0005e	0f bf 99 a6 01
	00 00		 movsx	 ebx, WORD PTR [ecx+422]
  00065	3b de		 cmp	 ebx, esi
  00067	75 0c		 jne	 SHORT $LN12@gObjGetIte
  00069	0f bf 99 a8 01
	00 00		 movsx	 ebx, WORD PTR [ecx+424]
  00070	3b d8		 cmp	 ebx, eax
  00072	75 01		 jne	 SHORT $LN12@gObjGetIte

; 129  : 			Count++;

  00074	42		 inc	 edx
$LN12@gObjGetIte:

; 127  : 	{
; 128  : 		if (lpObj->pInventory[i].m_Type == ItemID && lpObj->pInventory[i].m_Level == ItemLevel)

  00075	0f bf 99 7a 02
	00 00		 movsx	 ebx, WORD PTR [ecx+634]
  0007c	3b de		 cmp	 ebx, esi
  0007e	75 0c		 jne	 SHORT $LN14@gObjGetIte
  00080	0f bf 99 7c 02
	00 00		 movsx	 ebx, WORD PTR [ecx+636]
  00087	3b d8		 cmp	 ebx, eax
  00089	75 01		 jne	 SHORT $LN14@gObjGetIte

; 129  : 			Count++;

  0008b	42		 inc	 edx
$LN14@gObjGetIte:

; 122  : 
; 123  : 	LPOBJ lpObj = &gObj[aIndex];

  0008c	81 c1 50 03 00
	00		 add	 ecx, 848		; 00000350H

; 126  : 	for (int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  00092	4f		 dec	 edi
  00093	75 a2		 jne	 SHORT $LL4@gObjGetIte

; 130  : 	}
; 131  : 	return Count;

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	8b c2		 mov	 eax, edx
  00099	5b		 pop	 ebx

; 132  : }

  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?gObjGetItemCountInInventory@@YAHHHH@Z ENDP		; gObjGetItemCountInInventory
_TEXT	ENDS
PUBLIC	?gObjDeleteItemsCount@@YAHHFFH@Z		; gObjDeleteItemsCount
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
; Function compile flags: /Ogtp
;	COMDAT ?gObjDeleteItemsCount@@YAHHFFH@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 2
_Level$ = 16						; size = 2
_dCount$ = 20						; size = 4
?gObjDeleteItemsCount@@YAHHFFH@Z PROC			; gObjDeleteItemsCount, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 136  : 	if(aIndex >= OBJMAX)

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00007	81 f9 98 3a 00
	00		 cmp	 ecx, 15000		; 00003a98H
  0000d	7c 06		 jl	 SHORT $LN6@gObjDelete

; 137  : 		return 0;

  0000f	33 c0		 xor	 eax, eax

; 155  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
$LN6@gObjDelete:
  00015	53		 push	 ebx

; 138  : 
; 139  : 	LPOBJ lpObj = &gObj[aIndex];

  00016	8b d9		 mov	 ebx, ecx
  00018	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  0001e	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00024	56		 push	 esi
  00025	57		 push	 edi

; 140  : 
; 141  : 	int count = 0;

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 142  : 	for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  0002d	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  00032	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  00037	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL5@gObjDelete:

; 143  : 	{
; 144  : 		if(lpObj->pInventory[i].m_Type == Type && lpObj->pInventory[i].m_Level == Level)

  00040	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  00046	66 8b 55 0c	 mov	 dx, WORD PTR _Type$[ebp]
  0004a	66 39 54 38 06	 cmp	 WORD PTR [eax+edi+6], dx
  0004f	75 30		 jne	 SHORT $LN4@gObjDelete
  00051	66 8b 55 10	 mov	 dx, WORD PTR _Level$[ebp]
  00055	66 39 54 38 08	 cmp	 WORD PTR [eax+edi+8], dx
  0005a	75 25		 jne	 SHORT $LN4@gObjDelete

; 145  : 		{
; 146  : 			gObjInventoryDeleteItem(aIndex, i);

  0005c	56		 push	 esi
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 147  : 			GCInventoryItemDeleteSend(aIndex, i, 1);

  00063	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00066	6a 01		 push	 1
  00068	56		 push	 esi
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 148  : 			count++;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00072	40		 inc	 eax
  00073	83 c4 14	 add	 esp, 20			; 00000014H
  00076	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 149  : 
; 150  : 			if(dCount == count)

  00079	39 45 14	 cmp	 DWORD PTR _dCount$[ebp], eax
  0007c	74 12		 je	 SHORT $LN14@gObjDelete
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
$LN4@gObjDelete:

; 142  : 	for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  00081	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00087	46		 inc	 esi
  00088	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  0008e	7c b0		 jl	 SHORT $LL5@gObjDelete
$LN14@gObjDelete:

; 151  : 				break;
; 152  : 		}
; 153  : 	}
; 154  : 	return count;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 155  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?gObjDeleteItemsCount@@YAHHFFH@Z ENDP			; gObjDeleteItemsCount
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ZtFireCracker@@YAXHEE@Z			; ZtFireCracker
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?ZtFireCracker@@YAXHEE@Z
_TEXT	SEGMENT
_Packet5$ = -44						; size = 7
_Packet2$ = -36						; size = 7
_Packet4$ = -28						; size = 7
_Packet$ = -20						; size = 7
_Packet3$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_X$ = 12						; size = 1
_Y$ = 16						; size = 1
?ZtFireCracker@@YAXHEE@Z PROC				; ZtFireCracker, COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 161  : 	LPOBJ lpObj = &gObj[aIndex];
; 162  : 	BYTE Packet[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X, Y};

  00010	8a 45 10	 mov	 al, BYTE PTR _Y$[ebp]
  00013	53		 push	 ebx
  00014	8a 5d 0c	 mov	 bl, BYTE PTR _X$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 163  : 	DataSend(aIndex,Packet,Packet[1]);

  0001b	6a 07		 push	 7
  0001d	8d 4d ec	 lea	 ecx, DWORD PTR _Packet$[ebp]
  00020	51		 push	 ecx
  00021	56		 push	 esi
  00022	c7 45 ec c1 07
	f3 40		 mov	 DWORD PTR _Packet$[ebp], 1089669057 ; 40f307c1H
  00029	c6 45 f0 00	 mov	 BYTE PTR _Packet$[ebp+4], 0
  0002d	88 5d f1	 mov	 BYTE PTR _Packet$[ebp+5], bl
  00030	88 45 f2	 mov	 BYTE PTR _Packet$[ebp+6], al
  00033	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 164  : 	BYTE Packet2[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X+1, Y};

  00038	8a 45 10	 mov	 al, BYTE PTR _Y$[ebp]

; 165  : 	DataSend(aIndex,Packet2,Packet2[1]);

  0003b	6a 07		 push	 7
  0003d	8d 4d dc	 lea	 ecx, DWORD PTR _Packet2$[ebp]
  00040	51		 push	 ecx
  00041	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00044	56		 push	 esi
  00045	c7 45 dc c1 07
	f3 40		 mov	 DWORD PTR _Packet2$[ebp], 1089669057 ; 40f307c1H
  0004c	c6 45 e0 00	 mov	 BYTE PTR _Packet2$[ebp+4], 0
  00050	88 55 e1	 mov	 BYTE PTR _Packet2$[ebp+5], dl
  00053	88 45 e2	 mov	 BYTE PTR _Packet2$[ebp+6], al
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 166  : 	BYTE Packet3[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X, Y+1};

  0005b	8a 55 10	 mov	 dl, BYTE PTR _Y$[ebp]

; 167  : 	DataSend(aIndex,Packet3,Packet3[1]);

  0005e	6a 07		 push	 7
  00060	8d 45 f4	 lea	 eax, DWORD PTR _Packet3$[ebp]
  00063	50		 push	 eax
  00064	fe c2		 inc	 dl
  00066	56		 push	 esi
  00067	c7 45 f4 c1 07
	f3 40		 mov	 DWORD PTR _Packet3$[ebp], 1089669057 ; 40f307c1H
  0006e	c6 45 f8 00	 mov	 BYTE PTR _Packet3$[ebp+4], 0
  00072	88 5d f9	 mov	 BYTE PTR _Packet3$[ebp+5], bl
  00075	88 55 fa	 mov	 BYTE PTR _Packet3$[ebp+6], dl
  00078	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 168  : 	BYTE Packet4[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X, Y-1};

  0007d	8a 4d 10	 mov	 cl, BYTE PTR _Y$[ebp]

; 169  : 	DataSend(aIndex,Packet4,Packet4[1]);

  00080	6a 07		 push	 7
  00082	8d 55 e4	 lea	 edx, DWORD PTR _Packet4$[ebp]
  00085	52		 push	 edx
  00086	fe c9		 dec	 cl
  00088	56		 push	 esi
  00089	c7 45 e4 c1 07
	f3 40		 mov	 DWORD PTR _Packet4$[ebp], 1089669057 ; 40f307c1H
  00090	c6 45 e8 00	 mov	 BYTE PTR _Packet4$[ebp+4], 0
  00094	88 5d e9	 mov	 BYTE PTR _Packet4$[ebp+5], bl
  00097	88 4d ea	 mov	 BYTE PTR _Packet4$[ebp+6], cl
  0009a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 170  : 	BYTE Packet5[7] = {0xC1, 0x07, 0xF3, 0x40, 0x00, X-1, Y};

  0009f	8a 45 10	 mov	 al, BYTE PTR _Y$[ebp]

; 171  : 	DataSend(aIndex,Packet5,Packet5[1]);

  000a2	6a 07		 push	 7
  000a4	8d 4d d4	 lea	 ecx, DWORD PTR _Packet5$[ebp]
  000a7	51		 push	 ecx
  000a8	fe cb		 dec	 bl
  000aa	56		 push	 esi
  000ab	c7 45 d4 c1 07
	f3 40		 mov	 DWORD PTR _Packet5$[ebp], 1089669057 ; 40f307c1H
  000b2	c6 45 d8 00	 mov	 BYTE PTR _Packet5$[ebp+4], 0
  000b6	88 5d d9	 mov	 BYTE PTR _Packet5$[ebp+5], bl
  000b9	88 45 da	 mov	 BYTE PTR _Packet5$[ebp+6], al
  000bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 172  : }

  000c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c4	83 c4 3c	 add	 esp, 60			; 0000003cH
  000c7	5e		 pop	 esi
  000c8	33 cd		 xor	 ecx, ebp
  000ca	5b		 pop	 ebx
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?ZtFireCracker@@YAXHEE@Z ENDP				; ZtFireCracker
_TEXT	ENDS
PUBLIC	?GetExcOptionCount@@YAEE@Z			; GetExcOptionCount
; Function compile flags: /Ogtp
;	COMDAT ?GetExcOptionCount@@YAEE@Z
_TEXT	SEGMENT
_ExcellentCount$ = -4					; size = 4
_ExcellentOption$ = 8					; size = 1
?GetExcOptionCount@@YAEE@Z PROC				; GetExcOptionCount, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 177  : 	int ExcellentCount = 0;

  00004	33 d2		 xor	 edx, edx
  00006	53		 push	 ebx

; 178  : 	// ----
; 179  : 	for( int i = 0; i < 6; i++ )

  00007	8a 5d 08	 mov	 bl, BYTE PTR _ExcellentOption$[ebp]
  0000a	89 55 fc	 mov	 DWORD PTR _ExcellentCount$[ebp], edx
  0000d	8d 49 00	 npad	 3
$LL4@GetExcOpti:

; 180  : 	{
; 181  : 		if( (ExcellentOption >> i) & 1 )

  00010	8a c3		 mov	 al, bl
  00012	8a ca		 mov	 cl, dl
  00014	d2 e8		 shr	 al, cl
  00016	a8 01		 test	 al, 1
  00018	74 03		 je	 SHORT $LN3@GetExcOpti

; 182  : 		{
; 183  : 			ExcellentCount++;

  0001a	ff 45 fc	 inc	 DWORD PTR _ExcellentCount$[ebp]
$LN3@GetExcOpti:

; 178  : 	// ----
; 179  : 	for( int i = 0; i < 6; i++ )

  0001d	42		 inc	 edx
  0001e	83 fa 06	 cmp	 edx, 6
  00021	7c ed		 jl	 SHORT $LL4@GetExcOpti

; 184  : 		}
; 185  : 	}
; 186  : 	// ----
; 187  : 	return ExcellentCount;

  00023	8a 45 fc	 mov	 al, BYTE PTR _ExcellentCount$[ebp]
  00026	5b		 pop	 ebx

; 188  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?GetExcOptionCount@@YAEE@Z ENDP				; GetExcOptionCount
_TEXT	ENDS
PUBLIC	?EmptyPointInventory@@YAHH@Z			; EmptyPointInventory
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?EmptyPointInventory@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?EmptyPointInventory@@YAHH@Z PROC			; EmptyPointInventory, COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 192  : 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00009	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0000f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 193  : 	int Empty = 0;

  00015	33 db		 xor	 ebx, ebx
  00017	be f0 09 00 00	 mov	 esi, 2544		; 000009f0H
  0001c	8d 64 24 00	 npad	 4
$LL14@EmptyPoint:

; 197  :     {
; 198  :         if( !lpObj->pInventory[i].IsItem() )

  00020	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	85 c0		 test	 eax, eax
  0002f	75 01		 jne	 SHORT $LN13@EmptyPoint

; 199  : 		{
; 200  : 			Empty++;

  00031	43		 inc	 ebx
$LN13@EmptyPoint:

; 194  : 	// ----
; 195  : 
; 196  : 	for( int i = INVETORY_WEAR_SIZE; i < 76; i++ )

  00032	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00038	81 fe f0 3e 00
	00		 cmp	 esi, 16112		; 00003ef0H
  0003e	7c e0		 jl	 SHORT $LL14@EmptyPoint

; 201  : 		}
; 202  : 	}
; 203  : 
; 204  : 	if(lpObj->ExpandedInventory == 0)

  00040	80 bf 24 26 00
	00 00		 cmp	 BYTE PTR [edi+9764], 0

; 205  : 	{
; 206  : 		return Empty;

  00047	74 57		 je	 SHORT $LN23@EmptyPoint

; 207  : 	}
; 208  : 
; 209  : 	for( int i = 76; i < 108; i++ )

  00049	be f0 3e 00 00	 mov	 esi, 16112		; 00003ef0H
  0004e	8b ff		 npad	 2
$LL9@EmptyPoint:

; 210  :     {
; 211  :         if( !lpObj->pInventory[i].IsItem() )

  00050	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00056	03 ce		 add	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	85 c0		 test	 eax, eax
  0005f	75 01		 jne	 SHORT $LN8@EmptyPoint

; 212  : 		{
; 213  : 			Empty++;

  00061	43		 inc	 ebx
$LN8@EmptyPoint:

; 207  : 	}
; 208  : 
; 209  : 	for( int i = 76; i < 108; i++ )

  00062	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00068	81 fe 70 59 00
	00		 cmp	 esi, 22896		; 00005970H
  0006e	7c e0		 jl	 SHORT $LL9@EmptyPoint

; 214  : 		}
; 215  : 	}	
; 216  : 
; 217  : 	if(lpObj->ExpandedInventory == 1)

  00070	80 bf 24 26 00
	00 01		 cmp	 BYTE PTR [edi+9764], 1

; 218  : 	{
; 219  : 		return Empty;

  00077	74 27		 je	 SHORT $LN23@EmptyPoint

; 220  : 	}
; 221  : 
; 222  : 	for( int i = 108; i < 140; i++ )

  00079	be 70 59 00 00	 mov	 esi, 22896		; 00005970H
  0007e	8b ff		 npad	 2
$LL4@EmptyPoint:

; 223  :     {
; 224  :         if( !lpObj->pInventory[i].IsItem() )

  00080	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00086	03 ce		 add	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0008d	85 c0		 test	 eax, eax
  0008f	75 01		 jne	 SHORT $LN3@EmptyPoint

; 225  : 		{
; 226  : 			Empty++;

  00091	43		 inc	 ebx
$LN3@EmptyPoint:

; 220  : 	}
; 221  : 
; 222  : 	for( int i = 108; i < 140; i++ )

  00092	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00098	81 fe f0 73 00
	00		 cmp	 esi, 29680		; 000073f0H
  0009e	7c e0		 jl	 SHORT $LL4@EmptyPoint
$LN23@EmptyPoint:
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi

; 227  : 		}
; 228  : 	}	
; 229  : 
; 230  : 	return Empty;

  000a2	8b c3		 mov	 eax, ebx
  000a4	5b		 pop	 ebx

; 231  : }

  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?EmptyPointInventory@@YAHH@Z ENDP			; EmptyPointInventory
_TEXT	ENDS
PUBLIC	?ExCheckInventoryEmptySpace@@YAHH@Z		; ExCheckInventoryEmptySpace
; Function compile flags: /Ogtp
;	COMDAT ?ExCheckInventoryEmptySpace@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?ExCheckInventoryEmptySpace@@YAHH@Z PROC		; ExCheckInventoryEmptySpace, COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00006	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0000c	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b ba 28 0e 00
	00		 mov	 edi, DWORD PTR [edx+3624]

; 236  : 	int iEmptyCount = 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  00020	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  00023	b3 ff		 mov	 bl, 255			; 000000ffH
$LL14@ExCheckInv:

; 238  : 	{
; 239  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00025	38 59 fe	 cmp	 BYTE PTR [ecx-2], bl
  00028	75 01		 jne	 SHORT $LN13@ExCheckInv

; 240  : 		{
; 241  : 			iEmptyCount++;

  0002a	40		 inc	 eax
$LN13@ExCheckInv:

; 238  : 	{
; 239  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0002b	38 59 ff	 cmp	 BYTE PTR [ecx-1], bl
  0002e	75 01		 jne	 SHORT $LN24@ExCheckInv

; 240  : 		{
; 241  : 			iEmptyCount++;

  00030	40		 inc	 eax
$LN24@ExCheckInv:

; 238  : 	{
; 239  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00031	38 19		 cmp	 BYTE PTR [ecx], bl
  00033	75 01		 jne	 SHORT $LN25@ExCheckInv

; 240  : 		{
; 241  : 			iEmptyCount++;

  00035	40		 inc	 eax
$LN25@ExCheckInv:

; 238  : 	{
; 239  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00036	38 59 01	 cmp	 BYTE PTR [ecx+1], bl
  00039	75 01		 jne	 SHORT $LN26@ExCheckInv

; 240  : 		{
; 241  : 			iEmptyCount++;

  0003b	40		 inc	 eax
$LN26@ExCheckInv:

; 235  : 	LPOBJ lpObj = &gObj[aIndex];

  0003c	83 c1 04	 add	 ecx, 4

; 237  : 	for ( int x=0;x<64;x++)

  0003f	4e		 dec	 esi
  00040	75 e3		 jne	 SHORT $LL14@ExCheckInv

; 242  : 		}
; 243  : 	}
; 244  : 
; 245  : 	if(lpObj->ExpandedInventory == 0)

  00042	8a 92 24 26 00
	00		 mov	 dl, BYTE PTR [edx+9764]
  00048	84 d2		 test	 dl, dl

; 246  : 	{
; 247  : 		return iEmptyCount;

  0004a	74 51		 je	 SHORT $LN15@ExCheckInv

; 248  : 	}
; 249  : 
; 250  : 	for ( int x=64;x<96;x++)

  0004c	8d 4f 42	 lea	 ecx, DWORD PTR [edi+66]
  0004f	be 08 00 00 00	 mov	 esi, 8
$LL9@ExCheckInv:

; 251  : 	{
; 252  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00054	38 59 fe	 cmp	 BYTE PTR [ecx-2], bl
  00057	75 01		 jne	 SHORT $LN8@ExCheckInv

; 253  : 		{
; 254  : 			iEmptyCount++;

  00059	40		 inc	 eax
$LN8@ExCheckInv:

; 251  : 	{
; 252  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0005a	38 59 ff	 cmp	 BYTE PTR [ecx-1], bl
  0005d	75 01		 jne	 SHORT $LN28@ExCheckInv

; 253  : 		{
; 254  : 			iEmptyCount++;

  0005f	40		 inc	 eax
$LN28@ExCheckInv:

; 251  : 	{
; 252  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00060	38 19		 cmp	 BYTE PTR [ecx], bl
  00062	75 01		 jne	 SHORT $LN29@ExCheckInv

; 253  : 		{
; 254  : 			iEmptyCount++;

  00064	40		 inc	 eax
$LN29@ExCheckInv:

; 251  : 	{
; 252  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00065	38 59 01	 cmp	 BYTE PTR [ecx+1], bl
  00068	75 01		 jne	 SHORT $LN30@ExCheckInv

; 253  : 		{
; 254  : 			iEmptyCount++;

  0006a	40		 inc	 eax
$LN30@ExCheckInv:

; 248  : 	}
; 249  : 
; 250  : 	for ( int x=64;x<96;x++)

  0006b	83 c1 04	 add	 ecx, 4
  0006e	4e		 dec	 esi
  0006f	75 e3		 jne	 SHORT $LL9@ExCheckInv

; 255  : 		}
; 256  : 	}
; 257  : 
; 258  : 	if(lpObj->ExpandedInventory == 1)

  00071	80 fa 01	 cmp	 dl, 1

; 259  : 	{
; 260  : 		return iEmptyCount;

  00074	74 27		 je	 SHORT $LN15@ExCheckInv

; 261  : 	}
; 262  : 
; 263  : 	for ( int x=96;x<128;x++)

  00076	8d 4f 62	 lea	 ecx, DWORD PTR [edi+98]
  00079	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  0007c	8d 64 24 00	 npad	 4
$LL4@ExCheckInv:

; 264  : 	{
; 265  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00080	38 59 fe	 cmp	 BYTE PTR [ecx-2], bl
  00083	75 01		 jne	 SHORT $LN3@ExCheckInv

; 266  : 		{
; 267  : 			iEmptyCount++;

  00085	40		 inc	 eax
$LN3@ExCheckInv:

; 264  : 	{
; 265  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00086	38 59 ff	 cmp	 BYTE PTR [ecx-1], bl
  00089	75 01		 jne	 SHORT $LN36@ExCheckInv

; 266  : 		{
; 267  : 			iEmptyCount++;

  0008b	40		 inc	 eax
$LN36@ExCheckInv:

; 264  : 	{
; 265  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0008c	38 19		 cmp	 BYTE PTR [ecx], bl
  0008e	75 01		 jne	 SHORT $LN37@ExCheckInv

; 266  : 		{
; 267  : 			iEmptyCount++;

  00090	40		 inc	 eax
$LN37@ExCheckInv:

; 264  : 	{
; 265  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00091	38 59 01	 cmp	 BYTE PTR [ecx+1], bl
  00094	75 01		 jne	 SHORT $LN38@ExCheckInv

; 266  : 		{
; 267  : 			iEmptyCount++;

  00096	40		 inc	 eax
$LN38@ExCheckInv:

; 261  : 	}
; 262  : 
; 263  : 	for ( int x=96;x<128;x++)

  00097	83 c1 04	 add	 ecx, 4
  0009a	4a		 dec	 edx
  0009b	75 e3		 jne	 SHORT $LL4@ExCheckInv
$LN15@ExCheckInv:
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 	return iEmptyCount;
; 272  : 
; 273  : 	//LPOBJ lpObj = &gObj[aIndex];
; 274  : 	//int h=0;
; 275  : 	//int w=0;
; 276  : 	//int iItemWidth = 1, iItemHeight = 1;
; 277  : 	//BYTE blank = 0;
; 278  : 
; 279  : 	//int Point = 0;
; 280  : 	//
; 281  : 	//for(h=0;h<8;h++)
; 282  : 	//{
; 283  : 	//	for(w=0;w<8;w++)
; 284  : 	//	{
; 285  : 	//		if(*(BYTE*)(lpObj->pInventoryMap+(h)*8+(w)) == 255)
; 286  : 	//		{
; 287  : 	//			blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, 1, 1);
; 288  : 
; 289  : 	//			//if ( blank == 0xFE )
; 290  : 	//			//{
; 291  : 	//			//	continue;
; 292  : 	//			//	//result = FALSE;
; 293  : 	//			//	//break;
; 294  : 	//			//}
; 295  : 
; 296  : 	//			//if ( blank == 0xFF )
; 297  : 	//			//{
; 298  : 	//			//	Point++;
; 299  : 	//			//	//return TRUE;
; 300  : 	//			//}
; 301  : 
; 302  : 	//			if ( blank == 0xFF )
; 303  : 	//			{
; 304  : 	//				Point++;
; 305  : 	//			}
; 306  : 	//				
; 307  : 	//		}
; 308  : 	//	}
; 309  : 	//}
; 310  : 	//
; 311  : 	//if(lpObj->ExpandedInventory == 0)
; 312  : 	//{
; 313  : 	//	return Point;
; 314  : 	//}
; 315  : 	//
; 316  : 	//for(h=0;h<4;h++)
; 317  : 	//{
; 318  : 	//	for(w=0;w<8;w++)
; 319  : 	//	{
; 320  : 	//		if(*(BYTE*)((lpObj->pInventoryMap+64)+(h)*8+(w)) == 255)
; 321  : 	//		{
; 322  : 	//			blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, 1, 1);
; 323  : 
; 324  : 	//			//if ( blank == 0xFE )
; 325  : 	//			//{
; 326  : 	//			//	continue;
; 327  : 	//			//	//result = FALSE;
; 328  : 	//			//	//break;
; 329  : 	//			//}
; 330  : 
; 331  : 	//			//if ( blank == 0xFF )
; 332  : 	//			//{
; 333  : 	//			//	Point++;
; 334  : 	//			//	//return TRUE;
; 335  : 	//			//}
; 336  : 	//			
; 337  : 	//			if ( blank == 0xFF )
; 338  : 	//			{
; 339  : 	//				Point++;
; 340  : 	//			}
; 341  : 	//		}
; 342  : 	//	}
; 343  : 	//}
; 344  : 	//
; 345  : 	//if(lpObj->ExpandedInventory == 1)
; 346  : 	//{
; 347  : 	//	return Point;
; 348  : 	//}
; 349  : 	//
; 350  : 	//for(h=0;h<4;h++)
; 351  : 	//{
; 352  : 	//	for(w=0;w<8;w++)
; 353  : 	//	{
; 354  : 	//		if(*(BYTE*)((lpObj->pInventoryMap+96)+(h)*8+(w)) == 255)
; 355  : 	//		{
; 356  : 	//			blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, 1, 1);
; 357  : 
; 358  : 	//			LogAdd("0x%X",blank);
; 359  : 
; 360  : 	//			//if ( blank == 0xFE )
; 361  : 	//			//{
; 362  : 	//			//	continue;
; 363  : 	//			//	//result = FALSE;
; 364  : 	//			//	//break;
; 365  : 	//			//}
; 366  : 
; 367  : 	//			//if ( blank == 0xFF )
; 368  : 	//			//{
; 369  : 	//			//	Point++;
; 370  : 	//			//	//return TRUE;
; 371  : 	//			//}
; 372  : 	//			if ( blank == 0xFF )
; 373  : 	//			{
; 374  : 	//				Point++;
; 375  : 	//			}
; 376  : 	//		}
; 377  : 	//	}
; 378  : 	//}
; 379  : 
; 380  : 	//LogAdd("Point: %d",Point);
; 381  : 
; 382  : 	//return Point;
; 383  : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?ExCheckInventoryEmptySpace@@YAHH@Z ENDP		; ExCheckInventoryEmptySpace
_TEXT	ENDS
PUBLIC	?ExIsBadFileLineV2@@YA_NPADAAH@Z		; ExIsBadFileLineV2
; Function compile flags: /Ogtp
;	COMDAT ?ExIsBadFileLineV2@@YA_NPADAAH@Z
_TEXT	SEGMENT
_FileLine$ = 8						; size = 4
tv85 = 12						; size = 4
_Flag$ = 12						; size = 4
?ExIsBadFileLineV2@@YA_NPADAAH@Z PROC			; ExIsBadFileLineV2, COMDAT

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 387  : 	if(Flag == 0)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _Flag$[ebp]
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _FileLine$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	75 1e		 jne	 SHORT $LN20@ExIsBadFil

; 388  : 	{
; 389  : 		if(isdigit(FileLine[0]))

  00011	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _isdigit
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 1d		 je	 SHORT $LN9@ExIsBadFil

; 390  : 		{
; 391  : 			Flag = FileLine[0] - 48;

  00021	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  00024	83 e9 30	 sub	 ecx, 48			; 00000030H
  00027	89 0e		 mov	 DWORD PTR [esi], ecx
$LN5@ExIsBadFil:

; 407  : 		return true;

  00029	5f		 pop	 edi
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 413  : 	}
; 414  : 	return true;
; 415  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN20@ExIsBadFil:

; 392  : 			return true;
; 393  : 		}
; 394  : 	}
; 395  : 	else if(Flag < 0 || Flag > 999)	//Old 9

  0002f	78 07		 js	 SHORT $LN8@ExIsBadFil
  00031	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  00036	7e 06		 jle	 SHORT $LN9@ExIsBadFil
$LN8@ExIsBadFil:

; 396  : 	{
; 397  : 		Flag = -1;

  00038	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN9@ExIsBadFil:

; 398  : 	}
; 399  : 
; 400  : 	if(!strncmp(FileLine, "end", 3))

  0003e	6a 03		 push	 3
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00045	57		 push	 edi
  00046	e8 00 00 00 00	 call	 _strncmp
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	85 c0		 test	 eax, eax
  00050	75 0c		 jne	 SHORT $LN7@ExIsBadFil

; 401  : 	{
; 402  : 		Flag = -1;

  00052	5f		 pop	 edi
  00053	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 407  : 		return true;

  00059	b0 01		 mov	 al, 1
  0005b	5e		 pop	 esi

; 413  : 	}
; 414  : 	return true;
; 415  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN7@ExIsBadFil:

; 403  : 		return true;
; 404  : 	}
; 405  : 
; 406  : 	if(FileLine[0] == '/' || FileLine[0] == '\n')

  0005e	8a 07		 mov	 al, BYTE PTR [edi]
  00060	3c 2f		 cmp	 al, 47			; 0000002fH
  00062	74 c5		 je	 SHORT $LN5@ExIsBadFil
  00064	3c 0a		 cmp	 al, 10			; 0000000aH
  00066	74 c1		 je	 SHORT $LN5@ExIsBadFil

; 408  : 
; 409  : 	for(UINT i = 0; i < strlen(FileLine); i++)

  00068	8b c7		 mov	 eax, edi
  0006a	33 f6		 xor	 esi, esi
  0006c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0006f	90		 npad	 1
$LL18@ExIsBadFil:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL18@ExIsBadFil
  00077	2b c2		 sub	 eax, edx
  00079	74 ae		 je	 SHORT $LN5@ExIsBadFil
  0007b	eb 03 8d 49 00	 npad	 5
$LL4@ExIsBadFil:

; 410  : 	{
; 411  : 		if(isalnum(FileLine[i]))

  00080	0f be 14 3e	 movsx	 edx, BYTE PTR [esi+edi]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _isalnum
  0008a	83 c4 04	 add	 esp, 4
  0008d	85 c0		 test	 eax, eax
  0008f	75 19		 jne	 SHORT $LN16@ExIsBadFil

; 408  : 
; 409  : 	for(UINT i = 0; i < strlen(FileLine); i++)

  00091	8b c7		 mov	 eax, edi
  00093	46		 inc	 esi
  00094	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL19@ExIsBadFil:
  00097	8a 08		 mov	 cl, BYTE PTR [eax]
  00099	40		 inc	 eax
  0009a	84 c9		 test	 cl, cl
  0009c	75 f9		 jne	 SHORT $LL19@ExIsBadFil
  0009e	2b c2		 sub	 eax, edx
  000a0	3b f0		 cmp	 esi, eax
  000a2	72 dc		 jb	 SHORT $LL4@ExIsBadFil

; 407  : 		return true;

  000a4	5f		 pop	 edi
  000a5	b0 01		 mov	 al, 1
  000a7	5e		 pop	 esi

; 413  : 	}
; 414  : 	return true;
; 415  : }

  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN16@ExIsBadFil:
  000aa	5f		 pop	 edi

; 412  : 			return false;

  000ab	32 c0		 xor	 al, al
  000ad	5e		 pop	 esi

; 413  : 	}
; 414  : 	return true;
; 415  : }

  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?ExIsBadFileLineV2@@YA_NPADAAH@Z ENDP			; ExIsBadFileLineV2
_TEXT	ENDS
PUBLIC	?CheckOptions@@YA_N_NHH@Z			; CheckOptions
; Function compile flags: /Ogtp
;	COMDAT ?CheckOptions@@YA_N_NHH@Z
_TEXT	SEGMENT
_bItem$ = 8						; size = 1
_Item1$ = 12						; size = 4
_Item2$ = 16						; size = 4
?CheckOptions@@YA_N_NHH@Z PROC				; CheckOptions, COMDAT

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 419  : 	if(bItem)

  00003	80 7d 08 00	 cmp	 BYTE PTR _bItem$[ebp], 0
  00007	74 0b		 je	 SHORT $LN8@CheckOptio

; 420  : 	{
; 421  : 		if(Item1 == Item2)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _Item1$[ebp]
  0000c	3b 45 10	 cmp	 eax, DWORD PTR _Item2$[ebp]
  0000f	0f 94 c0	 sete	 al

; 433  : 		{
; 434  : 			return true;
; 435  : 		}
; 436  : 		else if(!Item2 && !Item2)
; 437  : 		{
; 438  : 			return true;
; 439  : 		}
; 440  : 		else
; 441  : 		{
; 442  : 			return false;
; 443  : 		}
; 444  : 	}
; 445  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN8@CheckOptio:

; 422  : 		{
; 423  : 			return true;
; 424  : 		}
; 425  : 		else
; 426  : 		{
; 427  : 			return false;
; 428  : 		}
; 429  : 	}
; 430  : 	else
; 431  : 	{
; 432  : 		if(Item2 && Item2)

  00014	b0 01		 mov	 al, 1

; 433  : 		{
; 434  : 			return true;
; 435  : 		}
; 436  : 		else if(!Item2 && !Item2)
; 437  : 		{
; 438  : 			return true;
; 439  : 		}
; 440  : 		else
; 441  : 		{
; 442  : 			return false;
; 443  : 		}
; 444  : 	}
; 445  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?CheckOptions@@YA_N_NHH@Z ENDP				; CheckOptions
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?CheckInCharacterItem@@YA_NHH@Z			; CheckInCharacterItem
EXTRN	__fltused:DWORD
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckInCharacterItem@@YA_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_ItemType$ = 12						; size = 4
?CheckInCharacterItem@@YA_NHH@Z PROC			; CheckInCharacterItem, COMDAT

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 449  : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _ItemType$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000c	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00012	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	33 f6		 xor	 esi, esi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL6@CheckInCha:

; 452  : 	{
; 453  : 		if(!lpObj->pInventory[i].IsItem())

  00020	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00026	03 ce		 add	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002d	85 c0		 test	 eax, eax
  0002f	74 1e		 je	 SHORT $LN5@CheckInCha

; 454  : 		{
; 455  : 			continue;
; 456  : 		}
; 457  : 
; 458  : 		if(lpObj->pInventory[i].m_Durability <= 0.0f)

  00031	8b 87 24 0e 00
	00		 mov	 eax, DWORD PTR [edi+3620]
  00037	d9 ee		 fldz
  00039	d8 5c 30 24	 fcomp	 DWORD PTR [eax+esi+36]
  0003d	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00040	df e0		 fnstsw	 ax
  00042	f6 c4 01	 test	 ah, 1
  00045	74 08		 je	 SHORT $LN5@CheckInCha

; 459  : 		{
; 460  : 			continue;
; 461  : 		}
; 462  : 
; 463  : 		if(lpObj->pInventory[i].m_Type != ItemType)

  00047	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  0004b	3b cb		 cmp	 ecx, ebx
  0004d	74 15		 je	 SHORT $LN1@CheckInCha
$LN5@CheckInCha:

; 450  : 
; 451  : 	for (int i=0;i<INVETORY_WEAR_SIZE;i++)

  0004f	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00055	81 fe f0 09 00
	00		 cmp	 esi, 2544		; 000009f0H
  0005b	7c c3		 jl	 SHORT $LL6@CheckInCha

; 469  : 		
; 470  : 	}
; 471  : 	return false;

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	32 c0		 xor	 al, al
  00061	5b		 pop	 ebx

; 472  : }

  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
$LN1@CheckInCha:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 464  : 		{
; 465  : 			continue;
; 466  : 		}
; 467  : 
; 468  : 		return true;

  00066	b0 01		 mov	 al, 1
  00068	5b		 pop	 ebx

; 472  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?CheckInCharacterItem@@YA_NHH@Z ENDP			; CheckInCharacterItem
_TEXT	ENDS
PUBLIC	?CheckInventoryItem@@YA_NHH@Z			; CheckInventoryItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckInventoryItem@@YA_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_ItemType$ = 12						; size = 4
?CheckInventoryItem@@YA_NHH@Z PROC			; CheckInventoryItem, COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 476  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _ItemType$[ebp]
  00009	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 477  : 
; 478  : 	for ( int i=INVETORY_WEAR_SIZE;i<INVENTORY_SIZE;i++)

  00015	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001a	8b 80 24 0e 00
	00		 mov	 eax, DWORD PTR [eax+3620]
  00020	05 f6 09 00 00	 add	 eax, 2550		; 000009f6H
  00025	56		 push	 esi
$LL4@CheckInven:

; 479  : 	{
; 480  : 		
; 481  : 			if(lpObj->pInventory[i].m_Type == ItemType)

  00026	0f bf 30	 movsx	 esi, WORD PTR [eax]
  00029	3b f2		 cmp	 esi, edx
  0002b	74 13		 je	 SHORT $LN8@CheckInven

; 477  : 
; 478  : 	for ( int i=INVETORY_WEAR_SIZE;i<INVENTORY_SIZE;i++)

  0002d	41		 inc	 ecx
  0002e	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  00033	81 f9 ec 00 00
	00		 cmp	 ecx, 236		; 000000ecH
  00039	7c eb		 jl	 SHORT $LL4@CheckInven

; 484  : 			}
; 485  : 	}
; 486  : 	return false;

  0003b	32 c0		 xor	 al, al
  0003d	5e		 pop	 esi

; 487  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN8@CheckInven:

; 482  : 			{
; 483  : 				return true;

  00040	b0 01		 mov	 al, 1
  00042	5e		 pop	 esi

; 487  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?CheckInventoryItem@@YA_NHH@Z ENDP			; CheckInventoryItem
_TEXT	ENDS
PUBLIC	?Max90Procent@@YAXAAH@Z				; Max90Procent
; Function compile flags: /Ogtp
;	COMDAT ?Max90Procent@@YAXAAH@Z
_TEXT	SEGMENT
_Value$ = 8						; size = 4
?Max90Procent@@YAXAAH@Z PROC				; Max90Procent, COMDAT

; 491  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 492  : 	if(Value > 90)

  00003	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00006	83 38 5a	 cmp	 DWORD PTR [eax], 90	; 0000005aH
  00009	7e 06		 jle	 SHORT $LN1@Max90Proce

; 493  : 	{
; 494  : 		Value = 90;

  0000b	c7 00 5a 00 00
	00		 mov	 DWORD PTR [eax], 90	; 0000005aH
$LN1@Max90Proce:

; 495  : 	}
; 496  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?Max90Procent@@YAXAAH@Z ENDP				; Max90Procent
_TEXT	ENDS
PUBLIC	?GetInventoryEmptyPoint@@YAHH@Z			; GetInventoryEmptyPoint
; Function compile flags: /Ogtp
;	COMDAT ?GetInventoryEmptyPoint@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GetInventoryEmptyPoint@@YAHH@Z PROC			; GetInventoryEmptyPoint, COMDAT

; 500  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 501  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00006	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0000c	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b ba 28 0e 00
	00		 mov	 edi, DWORD PTR [edx+3624]

; 502  : 	int iEmptyCount = 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  00020	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  00023	b3 ff		 mov	 bl, 255			; 000000ffH
$LL14@GetInvento:

; 505  : 	{
; 506  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00025	38 59 fe	 cmp	 BYTE PTR [ecx-2], bl
  00028	75 01		 jne	 SHORT $LN13@GetInvento

; 507  : 		{
; 508  : 			iEmptyCount++;

  0002a	40		 inc	 eax
$LN13@GetInvento:

; 505  : 	{
; 506  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0002b	38 59 ff	 cmp	 BYTE PTR [ecx-1], bl
  0002e	75 01		 jne	 SHORT $LN24@GetInvento

; 507  : 		{
; 508  : 			iEmptyCount++;

  00030	40		 inc	 eax
$LN24@GetInvento:

; 505  : 	{
; 506  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00031	38 19		 cmp	 BYTE PTR [ecx], bl
  00033	75 01		 jne	 SHORT $LN25@GetInvento

; 507  : 		{
; 508  : 			iEmptyCount++;

  00035	40		 inc	 eax
$LN25@GetInvento:

; 505  : 	{
; 506  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00036	38 59 01	 cmp	 BYTE PTR [ecx+1], bl
  00039	75 01		 jne	 SHORT $LN26@GetInvento

; 507  : 		{
; 508  : 			iEmptyCount++;

  0003b	40		 inc	 eax
$LN26@GetInvento:

; 501  : 	LPOBJ lpObj = &gObj[aIndex];

  0003c	83 c1 04	 add	 ecx, 4

; 503  : 
; 504  : 	for ( int x=0;x<64;x++)

  0003f	4e		 dec	 esi
  00040	75 e3		 jne	 SHORT $LL14@GetInvento

; 509  : 		}
; 510  : 	}
; 511  : 
; 512  : 	if(lpObj->ExpandedInventory == 0)

  00042	8a 92 24 26 00
	00		 mov	 dl, BYTE PTR [edx+9764]
  00048	84 d2		 test	 dl, dl

; 513  : 	{
; 514  : 		return iEmptyCount;

  0004a	74 51		 je	 SHORT $LN15@GetInvento

; 515  : 	}
; 516  : 
; 517  : 	for ( int x=64;x<96;x++)

  0004c	8d 4f 42	 lea	 ecx, DWORD PTR [edi+66]
  0004f	be 08 00 00 00	 mov	 esi, 8
$LL9@GetInvento:

; 518  : 	{
; 519  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00054	38 59 fe	 cmp	 BYTE PTR [ecx-2], bl
  00057	75 01		 jne	 SHORT $LN8@GetInvento

; 520  : 		{
; 521  : 			iEmptyCount++;

  00059	40		 inc	 eax
$LN8@GetInvento:

; 518  : 	{
; 519  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0005a	38 59 ff	 cmp	 BYTE PTR [ecx-1], bl
  0005d	75 01		 jne	 SHORT $LN28@GetInvento

; 520  : 		{
; 521  : 			iEmptyCount++;

  0005f	40		 inc	 eax
$LN28@GetInvento:

; 518  : 	{
; 519  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00060	38 19		 cmp	 BYTE PTR [ecx], bl
  00062	75 01		 jne	 SHORT $LN29@GetInvento

; 520  : 		{
; 521  : 			iEmptyCount++;

  00064	40		 inc	 eax
$LN29@GetInvento:

; 518  : 	{
; 519  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00065	38 59 01	 cmp	 BYTE PTR [ecx+1], bl
  00068	75 01		 jne	 SHORT $LN30@GetInvento

; 520  : 		{
; 521  : 			iEmptyCount++;

  0006a	40		 inc	 eax
$LN30@GetInvento:

; 515  : 	}
; 516  : 
; 517  : 	for ( int x=64;x<96;x++)

  0006b	83 c1 04	 add	 ecx, 4
  0006e	4e		 dec	 esi
  0006f	75 e3		 jne	 SHORT $LL9@GetInvento

; 522  : 		}
; 523  : 	}
; 524  : 
; 525  : 	if(lpObj->ExpandedInventory == 1)

  00071	80 fa 01	 cmp	 dl, 1

; 526  : 	{
; 527  : 		return iEmptyCount;

  00074	74 27		 je	 SHORT $LN15@GetInvento

; 528  : 	}
; 529  : 
; 530  : 	for ( int x=96;x<128;x++)

  00076	8d 4f 62	 lea	 ecx, DWORD PTR [edi+98]
  00079	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  0007c	8d 64 24 00	 npad	 4
$LL4@GetInvento:

; 531  : 	{
; 532  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00080	38 59 fe	 cmp	 BYTE PTR [ecx-2], bl
  00083	75 01		 jne	 SHORT $LN3@GetInvento

; 533  : 		{
; 534  : 			iEmptyCount++;

  00085	40		 inc	 eax
$LN3@GetInvento:

; 531  : 	{
; 532  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00086	38 59 ff	 cmp	 BYTE PTR [ecx-1], bl
  00089	75 01		 jne	 SHORT $LN36@GetInvento

; 533  : 		{
; 534  : 			iEmptyCount++;

  0008b	40		 inc	 eax
$LN36@GetInvento:

; 531  : 	{
; 532  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  0008c	38 19		 cmp	 BYTE PTR [ecx], bl
  0008e	75 01		 jne	 SHORT $LN37@GetInvento

; 533  : 		{
; 534  : 			iEmptyCount++;

  00090	40		 inc	 eax
$LN37@GetInvento:

; 531  : 	{
; 532  : 		if ( lpObj->pInventoryMap[x] == 0xFF )

  00091	38 59 01	 cmp	 BYTE PTR [ecx+1], bl
  00094	75 01		 jne	 SHORT $LN38@GetInvento

; 533  : 		{
; 534  : 			iEmptyCount++;

  00096	40		 inc	 eax
$LN38@GetInvento:

; 528  : 	}
; 529  : 
; 530  : 	for ( int x=96;x<128;x++)

  00097	83 c1 04	 add	 ecx, 4
  0009a	4a		 dec	 edx
  0009b	75 e3		 jne	 SHORT $LL4@GetInvento
$LN15@GetInvento:
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx

; 535  : 		}
; 536  : 	}
; 537  : 
; 538  : 	return iEmptyCount;
; 539  : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?GetInventoryEmptyPoint@@YAHH@Z ENDP			; GetInventoryEmptyPoint
_TEXT	ENDS
PUBLIC	??$_Unchecked@PAH@std@@YAPAHPAH@Z		; std::_Unchecked<int *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAH@std@@YAPAHPAH@Z PROC			; std::_Unchecked<int *>, COMDAT

; 266  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 267  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 268  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAH@std@@YAPAHPAH@Z ENDP			; std::_Unchecked<int *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAH@std@@YAPAHPAH@Z		; std::_Dist_type<int *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dist_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Dist_type<int *>, COMDAT

; 850  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 851  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Dist_type<int *>
_TEXT	ENDS
PUBLIC	??$_Move@AAH@std@@YA$$QAHAAH@Z			; std::_Move<int &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAH@std@@YA$$QAHAAH@Z PROC			; std::_Move<int &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::_Move<int &>
_TEXT	ENDS
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
; Function compile flags: /Ogtp
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);
; 103  : 	_Left = _Move(_Right);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	56		 push	 esi
  0000c	8b 32		 mov	 esi, DWORD PTR [edx]
  0000e	89 30		 mov	 DWORD PTR [eax], esi

; 104  : 	_Right = _Move(_Tmp);

  00010	89 0a		 mov	 DWORD PTR [edx], ecx
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAHPAH@std@@YAXPAH0@Z		; std::iter_swap<int *,int *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$iter_swap@PAHPAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAHPAH@std@@YAXPAH0@Z PROC			; std::iter_swap<int *,int *>, COMDAT

; 2133 : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2134 : 	swap(*_Left, *_Right);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	56		 push	 esi
  0000c	8b 32		 mov	 esi, DWORD PTR [edx]
  0000e	89 30		 mov	 DWORD PTR [eax], esi
  00010	89 0a		 mov	 DWORD PTR [edx], ecx
  00012	5e		 pop	 esi

; 2135 : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$iter_swap@PAHPAH@std@@YAXPAH0@Z ENDP			; std::iter_swap<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Random_shuffle@PAHH@std@@YAXPAH00@Z		; std::_Random_shuffle<int *,int>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\algorithm
;	COMDAT ??$_Random_shuffle@PAHH@std@@YAXPAH00@Z
_TEXT	SEGMENT
__Index$203870 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Random_shuffle@PAHH@std@@YAXPAH00@Z PROC		; std::_Random_shuffle<int *,int>, COMDAT

; 2214 : 	{	// shuffle [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2215 : 	const int _RANDOM_BITS = 15;	// minimum random bits from rand()
; 2216 : 	const int _RANDOM_MAX = (1U << _RANDOM_BITS) - 1;
; 2217 : 
; 2218 : 	_RanIt _Next = _First;
; 2219 : 	for (unsigned long _Index = 2; ++_Next != _Last; ++_Index)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00008	83 c3 04	 add	 ebx, 4
  0000b	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __Index$203870[ebp], 2
  00012	3b 5d 0c	 cmp	 ebx, DWORD PTR __Last$[ebp]
  00015	74 61		 je	 SHORT $LN4@Random_shu
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL6@Random_shu:

; 2220 : 		{	// assume unsigned long big enough for _Diff count
; 2221 : 		unsigned long _Rm = _RANDOM_MAX;

  00020	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH

; 2222 : 		unsigned long _Rn = _CSTD rand() & _RANDOM_MAX;

  00025	e8 00 00 00 00	 call	 _rand
  0002a	8b f0		 mov	 esi, eax
  0002c	23 f7		 and	 esi, edi

; 2223 : 		for (; _Rm < _Index && _Rm != ~0UL;
; 2224 : 			_Rm = _Rm << _RANDOM_BITS | _RANDOM_MAX)

  0002e	39 7d fc	 cmp	 DWORD PTR __Index$203870[ebp], edi
  00031	76 22		 jbe	 SHORT $LN1@Random_shu
$LL23@Random_shu:
  00033	83 ff ff	 cmp	 edi, -1
  00036	74 1d		 je	 SHORT $LN1@Random_shu

; 2225 : 			_Rn = _Rn << _RANDOM_BITS
; 2226 : 				| (_CSTD rand() & _RANDOM_MAX);	// build random value

  00038	e8 00 00 00 00	 call	 _rand
  0003d	c1 e7 0f	 shl	 edi, 15			; 0000000fH
  00040	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00045	c1 e6 0f	 shl	 esi, 15			; 0000000fH
  00048	81 cf ff 7f 00
	00		 or	 edi, 32767		; 00007fffH
  0004e	0b f0		 or	 esi, eax
  00050	3b 7d fc	 cmp	 edi, DWORD PTR __Index$203870[ebp]
  00053	72 de		 jb	 SHORT $LL23@Random_shu
$LN1@Random_shu:

; 2227 : 
; 2228 : 		_STD iter_swap(_Next, _First + _Diff(_Rn % _Index));	// swap a pair

  00055	33 d2		 xor	 edx, edx
  00057	8b c6		 mov	 eax, esi
  00059	f7 75 fc	 div	 DWORD PTR __Index$203870[ebp]
  0005c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0005f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00061	ff 45 fc	 inc	 DWORD PTR __Index$203870[ebp]
  00064	83 c3 04	 add	 ebx, 4
  00067	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0006a	8b 10		 mov	 edx, DWORD PTR [eax]
  0006c	89 53 fc	 mov	 DWORD PTR [ebx-4], edx
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
  00071	3b 5d 0c	 cmp	 ebx, DWORD PTR __Last$[ebp]
  00074	75 aa		 jne	 SHORT $LL6@Random_shu
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
$LN4@Random_shu:
  00078	5b		 pop	 ebx

; 2229 : 		}
; 2230 : 	}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??$_Random_shuffle@PAHH@std@@YAXPAH00@Z ENDP		; std::_Random_shuffle<int *,int>
_TEXT	ENDS
PUBLIC	??$random_shuffle@PAH@std@@YAXPAH0@Z		; std::random_shuffle<int *>
; Function compile flags: /Ogtp
;	COMDAT ??$random_shuffle@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$random_shuffle@PAH@std@@YAXPAH0@Z PROC		; std::random_shuffle<int *>, COMDAT

; 2234 : 	{	// shuffle [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 	_DEBUG_RANGE(_First, _Last);
; 2236 : 	if (_First != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	3b c1		 cmp	 eax, ecx
  0000b	74 0c		 je	 SHORT $LN1@random_shu

; 2237 : 		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last),
; 2238 : 			_Dist_type(_First));

  0000d	6a 00		 push	 0
  0000f	51		 push	 ecx
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$_Random_shuffle@PAHH@std@@YAXPAH00@Z ; std::_Random_shuffle<int *,int>
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@random_shu:

; 2239 : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$random_shuffle@PAH@std@@YAXPAH0@Z ENDP		; std::random_shuffle<int *>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GenExcOpt@@YAHH@Z				; GenExcOpt
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\functions.cpp
;	COMDAT ?GenExcOpt@@YAHH@Z
_TEXT	SEGMENT
_opt_db$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_amount$ = 8						; size = 4
?GenExcOpt@@YAHH@Z PROC					; GenExcOpt, COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 85   : 	// User input errors
; 86   : 	if (amount > 6) amount = 6;

  00011	8b 75 08	 mov	 esi, DWORD PTR _amount$[ebp]
  00014	83 fe 06	 cmp	 esi, 6
  00017	0f 8e 80 00 00
	00		 jle	 $LN5@GenExcOpt
  0001d	be 06 00 00 00	 mov	 esi, 6
$LN4@GenExcOpt:
  00022	53		 push	 ebx

; 88   : 
; 89   : 	int opt_db[6]  = {1, 2, 4, 8, 16, 32};
; 90   : 	int exc = 0;

  00023	33 db		 xor	 ebx, ebx

; 91   : 
; 92   : 	std::random_shuffle(opt_db, opt_db + 6);

  00025	53		 push	 ebx
  00026	8d 45 fc	 lea	 eax, DWORD PTR _opt_db$[ebp+24]
  00029	50		 push	 eax
  0002a	8d 4d e4	 lea	 ecx, DWORD PTR _opt_db$[ebp]
  0002d	51		 push	 ecx
  0002e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp], 1
  00035	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+4], 2
  0003c	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+8], 4
  00043	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+12], 8
  0004a	c7 45 f4 10 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+16], 16 ; 00000010H
  00051	c7 45 f8 20 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+20], 32 ; 00000020H
  00058	e8 00 00 00 00	 call	 ??$_Random_shuffle@PAHH@std@@YAXPAH00@Z ; std::_Random_shuffle<int *,int>
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	33 c9		 xor	 ecx, ecx
  00062	33 d2		 xor	 edx, edx

; 93   : 
; 94   : 	for(int n=0; n < amount; n++)

  00064	33 c0		 xor	 eax, eax
  00066	83 fe 02	 cmp	 esi, 2
  00069	7c 15		 jl	 SHORT $LC20@GenExcOpt
  0006b	57		 push	 edi
  0006c	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  0006f	90		 npad	 1
$LL21@GenExcOpt:

; 95   : 		exc += opt_db[n];

  00070	03 4c 85 e4	 add	 ecx, DWORD PTR _opt_db$[ebp+eax*4]
  00074	03 54 85 e8	 add	 edx, DWORD PTR _opt_db$[ebp+eax*4+4]
  00078	83 c0 02	 add	 eax, 2
  0007b	3b c7		 cmp	 eax, edi
  0007d	7c f1		 jl	 SHORT $LL21@GenExcOpt
  0007f	5f		 pop	 edi
$LC20@GenExcOpt:

; 93   : 
; 94   : 	for(int n=0; n < amount; n++)

  00080	3b c6		 cmp	 eax, esi
  00082	7d 04		 jge	 SHORT $LN19@GenExcOpt

; 95   : 		exc += opt_db[n];

  00084	8b 5c 85 e4	 mov	 ebx, DWORD PTR _opt_db$[ebp+eax*4]
$LN19@GenExcOpt:
  00088	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008b	03 c3		 add	 eax, ebx
  0008d	5b		 pop	 ebx
  0008e	5e		 pop	 esi

; 96   : 
; 97   : 	return exc;
; 98   : }

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	33 cd		 xor	 ecx, ebp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
$LN5@GenExcOpt:

; 87   : 	if (amount < 1) return 0;

  0009d	83 fe 01	 cmp	 esi, 1
  000a0	7d 80		 jge	 SHORT $LN4@GenExcOpt

; 96   : 
; 97   : 	return exc;
; 98   : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	33 c0		 xor	 eax, eax
  000a9	5e		 pop	 esi
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GenExcOpt@@YAHH@Z ENDP					; GenExcOpt
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ExGenExcOpt@@YAHH@Z				; ExGenExcOpt
; Function compile flags: /Ogtp
;	COMDAT ?ExGenExcOpt@@YAHH@Z
_TEXT	SEGMENT
_opt_db$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_amount$ = 8						; size = 4
?ExGenExcOpt@@YAHH@Z PROC				; ExGenExcOpt, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 102  : 	// User input errors
; 103  : 	if (amount > 6) amount = 6;

  00011	8b 75 08	 mov	 esi, DWORD PTR _amount$[ebp]
  00014	83 fe 06	 cmp	 esi, 6
  00017	0f 8e 80 00 00
	00		 jle	 $LN5@ExGenExcOp
  0001d	be 06 00 00 00	 mov	 esi, 6
$LN4@ExGenExcOp:
  00022	53		 push	 ebx

; 105  : 
; 106  : 	int opt_db[6]  = {1, 2, 4, 8, 16, 32};
; 107  : 	int exc = 0;

  00023	33 db		 xor	 ebx, ebx

; 108  : 
; 109  : 	std::random_shuffle(opt_db, opt_db + 6);

  00025	53		 push	 ebx
  00026	8d 45 fc	 lea	 eax, DWORD PTR _opt_db$[ebp+24]
  00029	50		 push	 eax
  0002a	8d 4d e4	 lea	 ecx, DWORD PTR _opt_db$[ebp]
  0002d	51		 push	 ecx
  0002e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp], 1
  00035	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+4], 2
  0003c	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+8], 4
  00043	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+12], 8
  0004a	c7 45 f4 10 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+16], 16 ; 00000010H
  00051	c7 45 f8 20 00
	00 00		 mov	 DWORD PTR _opt_db$[ebp+20], 32 ; 00000020H
  00058	e8 00 00 00 00	 call	 ??$_Random_shuffle@PAHH@std@@YAXPAH00@Z ; std::_Random_shuffle<int *,int>
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	33 c9		 xor	 ecx, ecx
  00062	33 d2		 xor	 edx, edx

; 110  : 
; 111  : 	for(int n=0; n < amount; n++)

  00064	33 c0		 xor	 eax, eax
  00066	83 fe 02	 cmp	 esi, 2
  00069	7c 15		 jl	 SHORT $LC20@ExGenExcOp
  0006b	57		 push	 edi
  0006c	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  0006f	90		 npad	 1
$LL21@ExGenExcOp:

; 112  : 		exc += opt_db[n];

  00070	03 4c 85 e4	 add	 ecx, DWORD PTR _opt_db$[ebp+eax*4]
  00074	03 54 85 e8	 add	 edx, DWORD PTR _opt_db$[ebp+eax*4+4]
  00078	83 c0 02	 add	 eax, 2
  0007b	3b c7		 cmp	 eax, edi
  0007d	7c f1		 jl	 SHORT $LL21@ExGenExcOp
  0007f	5f		 pop	 edi
$LC20@ExGenExcOp:

; 110  : 
; 111  : 	for(int n=0; n < amount; n++)

  00080	3b c6		 cmp	 eax, esi
  00082	7d 04		 jge	 SHORT $LN19@ExGenExcOp

; 112  : 		exc += opt_db[n];

  00084	8b 5c 85 e4	 mov	 ebx, DWORD PTR _opt_db$[ebp+eax*4]
$LN19@ExGenExcOp:
  00088	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008b	03 c3		 add	 eax, ebx
  0008d	5b		 pop	 ebx
  0008e	5e		 pop	 esi

; 113  : 
; 114  : 	return exc;
; 115  : }

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	33 cd		 xor	 ecx, ebp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
$LN5@ExGenExcOp:

; 104  : 	if (amount < 1) return 0;

  0009d	83 fe 01	 cmp	 esi, 1
  000a0	7d 80		 jge	 SHORT $LN4@ExGenExcOp

; 113  : 
; 114  : 	return exc;
; 115  : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	33 c0		 xor	 eax, eax
  000a9	5e		 pop	 esi
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?ExGenExcOpt@@YAHH@Z ENDP				; ExGenExcOpt
_TEXT	ENDS
END
