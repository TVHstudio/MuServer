; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\GrandReset.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0GrandResetEXP@@QAE@XZ			; GrandResetEXP::GrandResetEXP
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\grandreset.h
;	COMDAT ??0GrandResetEXP@@QAE@XZ
_TEXT	SEGMENT
??0GrandResetEXP@@QAE@XZ PROC				; GrandResetEXP::GrandResetEXP, COMDAT
; _this$ = ecx

; 11   : 	GrandResetEXP()

  00000	8b c1		 mov	 eax, ecx

; 12   : 	{
; 13   : 		this->GrandReset = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	66 89 08	 mov	 WORD PTR [eax], cx

; 14   : 		this->TypeExp = false;

  00007	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 15   : 		this->MinusExp = 0;

  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 16   : 	}

  0000d	c3		 ret	 0
??0GrandResetEXP@@QAE@XZ ENDP				; GrandResetEXP::GrandResetEXP
_TEXT	ENDS
PUBLIC	??_C@_0DL@JEEEMDGP@?$FLGrandResetSystem?$FN?5Accaunt?3?5?$CFs?5?0@ ; `string'
PUBLIC	?ExGrandResetSystemFunciton@cGrandReset@@QAEXH@Z ; cGrandReset::ExGrandResetSystemFunciton
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?GrandResetUp@CAchievements@@QAEXH@Z:PROC	; CAchievements::GrandResetUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; ResetSystemGC_CharUpdate
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?GCManaSend@@YAXHHEEH@Z:PROC			; GCManaSend
EXTRN	?GCReFillSend@@YAXHHEEH@Z:PROC			; GCReFillSend
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?ZtFireCracker@@YAXHEE@Z:PROC			; ZtFireCracker
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?ZtUserDataSend@@YAXH@Z:PROC			; ZtUserDataSend
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
EXTRN	?GetText@CZtText@@QAEPADH@Z:PROC		; CZtText::GetText
EXTRN	?g_ZtText@@3VCZtText@@A:BYTE			; g_ZtText
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DL@JEEEMDGP@?$FLGrandResetSystem?$FN?5Accaunt?3?5?$CFs?5?0@
; File e:\work\tranet_version\gs\gameserver\grandreset.cpp
CONST	SEGMENT
??_C@_0DL@JEEEMDGP@?$FLGrandResetSystem?$FN?5Accaunt?3?5?$CFs?5?0@ DB '[G'
	DB	'randResetSystem] Accaunt: %s , Name: %s , GrandReset: %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ExGrandResetSystemFunciton@cGrandReset@@QAEXH@Z
_TEXT	SEGMENT
tv1066 = -8						; size = 4
tv1061 = -8						; size = 4
tv1056 = -8						; size = 4
tv972 = -8						; size = 4
tv1076 = -4						; size = 4
tv1071 = -4						; size = 4
tv951 = -4						; size = 4
tv942 = -4						; size = 4
tv933 = -4						; size = 4
_aIndex$ = 8						; size = 4
?ExGrandResetSystemFunciton@cGrandReset@@QAEXH@Z PROC	; cGrandReset::ExGrandResetSystemFunciton, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 116  : 	if(!this->EnableGrandResetSystem)

  00009	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0000c	0f 84 fe 05 00
	00		 je	 $LN44@ExGrandRes

; 117  : 		return;
; 118  : 
; 119  : 	LPOBJ lpObj = &gObj[aIndex];

  00012	53		 push	 ebx
  00013	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00016	56		 push	 esi
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 120  : 
; 121  : 	if ( (GetTickCount() - lpObj->MySelfDefenseTime ) < 60000)

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002b	2b 86 1c 04 00
	00		 sub	 eax, DWORD PTR [esi+1052]
  00031	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00036	73 31		 jae	 SHORT $LN42@ExGrandRes

; 122  : 	{
; 123  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), lpObj->m_Index, 1);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	6a 01		 push	 1
  0003c	50		 push	 eax
  0003d	68 6d 04 00 00	 push	 1133			; 0000046dH
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00047	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 124  : 		GCCloseMsgSend(aIndex,-1); //Season 2.5 add-on

  00052	68 ff 00 00 00	 push	 255			; 000000ffH
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	5f		 pop	 edi

; 306  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
$LN42@ExGrandRes:

; 125  : 		return;
; 126  : 	}
; 127  : 
; 128  : 	if(lpObj->SkillRecallParty_Time != 0)

  00069	66 83 be 74 12
	00 00 00	 cmp	 WORD PTR [esi+4724], 0
  00071	0f 85 97 05 00
	00		 jne	 $LN48@ExGrandRes

; 129  : 	{
; 130  : 		return;
; 131  : 	}
; 132  : 
; 133  : 	if(lpObj->MapNumber != this->m_iMapForGrand)

  00077	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  0007e	3b 8f d8 00 00
	00		 cmp	 ecx, DWORD PTR [edi+216]
  00084	74 1f		 je	 SHORT $LN40@ExGrandRes

; 134  : 	{
; 135  : 		MsgNormal(aIndex,g_ZtText.GetText(12));

  00086	6a 0c		 push	 12			; 0000000cH
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0008d	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00092	50		 push	 eax
  00093	53		 push	 ebx
  00094	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00099	83 c4 08	 add	 esp, 8
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	5f		 pop	 edi

; 306  : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
$LN40@ExGrandRes:

; 136  : 		return;
; 137  : 	}
; 138  : 
; 139  : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  000a5	56		 push	 esi
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000ab	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000b0	85 c0		 test	 eax, eax
  000b2	75 23		 jne	 SHORT $LN39@ExGrandRes

; 140  : 	{
; 141  : 		GCServerMsgStringSend(g_ZtText.GetText(13),lpObj->m_Index,1);

  000b4	8b 16		 mov	 edx, DWORD PTR [esi]
  000b6	6a 01		 push	 1
  000b8	52		 push	 edx
  000b9	6a 0d		 push	 13			; 0000000dH
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  000c0	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	5f		 pop	 edi

; 306  : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
$LN39@ExGrandRes:

; 142  : 		return;
; 143  : 	}
; 144  : 
; 145  : 	//Проверка на максимальное количество ресето?
; 146  : 	if(lpObj->GReset >= this->MaxGrandRes)

  000d7	8b 9e 94 22 00
	00		 mov	 ebx, DWORD PTR [esi+8852]
  000dd	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000e0	3b d8		 cmp	 ebx, eax
  000e2	7c 23		 jl	 SHORT $LN38@ExGrandRes

; 147  : 	{
; 148  : 		MsgNormal(aIndex,g_ZtText.GetText(14),this->MaxGrandRes);

  000e4	50		 push	 eax
  000e5	6a 0e		 push	 14			; 0000000eH
  000e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  000ec	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  000f1	50		 push	 eax
  000f2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	5f		 pop	 edi

; 306  : }

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
$LN38@ExGrandRes:

; 149  : 		return;
; 150  : 	}
; 151  : 	
; 152  : 	//Проверка на Ресе?
; 153  : 	if(this->NeedRes > lpObj->Reset)

  00107	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0010a	3b 86 90 22 00
	00		 cmp	 eax, DWORD PTR [esi+8848]
  00110	7e 23		 jle	 SHORT $LN37@ExGrandRes

; 154  : 	{
; 155  : 		MsgNormal(aIndex,g_ZtText.GetText(15),this->NeedRes);

  00112	50		 push	 eax
  00113	6a 0f		 push	 15			; 0000000fH
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0011a	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00122	50		 push	 eax
  00123	51		 push	 ecx
  00124	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	5f		 pop	 edi

; 306  : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 04 00	 ret	 4
$LN37@ExGrandRes:

; 156  : 		return;
; 157  : 	}
; 158  : 	//Проверка на уровен?
; 159  : 	if(this->NeedLevel > lpObj->Level)

  00135	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  0013c	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0013f	3b c2		 cmp	 eax, edx
  00141	7e 23		 jle	 SHORT $LN36@ExGrandRes

; 160  : 	{
; 161  : 		MsgNormal(aIndex,g_ZtText.GetText(16),this->NeedLevel);

  00143	50		 push	 eax
  00144	6a 10		 push	 16			; 00000010H
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0014b	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00150	50		 push	 eax
  00151	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	5f		 pop	 edi

; 306  : }

  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 04 00	 ret	 4
$LN36@ExGrandRes:

; 162  : 		return;
; 163  : 	}
; 164  : 	int ZenMoney = 0;
; 165  : 	//Проверка на зе?
; 166  : 	switch(this->ZenForm)

  00166	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00169	8b c2		 mov	 eax, edx
  0016b	33 c9		 xor	 ecx, ecx
  0016d	48		 dec	 eax
  0016e	74 08		 je	 SHORT $LN33@ExGrandRes
  00170	48		 dec	 eax
  00171	75 0c		 jne	 SHORT $LN34@ExGrandRes

; 169  : 		case 2: ZenMoney = this->NeedZen; break;

  00173	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00176	eb 07		 jmp	 SHORT $LN34@ExGrandRes
$LN33@ExGrandRes:

; 167  : 	{
; 168  : 		case 1: ZenMoney = this->NeedZen * ( lpObj->GReset + 1 ); break;

  00178	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0017b	0f af 4f 0c	 imul	 ecx, DWORD PTR [edi+12]
$LN34@ExGrandRes:

; 170  : 	}
; 171  : 	
; 172  : 	if(this->ZenForm != 0)

  0017f	85 d2		 test	 edx, edx
  00181	74 2b		 je	 SHORT $LN30@ExGrandRes

; 173  : 	{
; 174  : 		if(lpObj->Money < ZenMoney)

  00183	39 8e f0 00 00
	00		 cmp	 DWORD PTR [esi+240], ecx
  00189	7d 23		 jge	 SHORT $LN30@ExGrandRes

; 175  : 		{
; 176  : 			MsgNormal(aIndex,g_ZtText.GetText(17),ZenMoney);

  0018b	51		 push	 ecx
  0018c	6a 11		 push	 17			; 00000011H
  0018e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  00193	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00198	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0019b	50		 push	 eax
  0019c	51		 push	 ecx
  0019d	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	5f		 pop	 edi

; 306  : }

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c2 04 00	 ret	 4
$LN30@ExGrandRes:

; 177  : 			return;
; 178  : 		}
; 179  : 	}
; 180  : 	//Проверка на пустой инвентар?
; 181  : 	if(this->NeedEmptyInv)

  001ae	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  001b2	0f 84 94 00 00
	00		 je	 $LN46@ExGrandRes

; 182  : 	{
; 183  : 		if(lpObj->pInventory[0].m_Type != -1 || lpObj->pInventory[1].m_Type != -1 || lpObj->pInventory[2].m_Type != -1 ||
; 184  : 		   lpObj->pInventory[3].m_Type != -1 || lpObj->pInventory[4].m_Type != -1 || lpObj->pInventory[5].m_Type != -1 ||
; 185  : 		   lpObj->pInventory[6].m_Type != -1 || lpObj->pInventory[7].m_Type != -1 || lpObj->pInventory[8].m_Type != -1 ||
; 186  : 		   lpObj->pInventory[9].m_Type != -1 || lpObj->pInventory[10].m_Type != -1|| lpObj->pInventory[11].m_Type != -1)

  001b8	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  001be	83 ca ff	 or	 edx, -1
  001c1	66 39 50 06	 cmp	 WORD PTR [eax+6], dx
  001c5	75 63		 jne	 SHORT $LN27@ExGrandRes
  001c7	66 39 90 da 00
	00 00		 cmp	 WORD PTR [eax+218], dx
  001ce	75 5a		 jne	 SHORT $LN27@ExGrandRes
  001d0	66 39 90 ae 01
	00 00		 cmp	 WORD PTR [eax+430], dx
  001d7	75 51		 jne	 SHORT $LN27@ExGrandRes
  001d9	66 39 90 82 02
	00 00		 cmp	 WORD PTR [eax+642], dx
  001e0	75 48		 jne	 SHORT $LN27@ExGrandRes
  001e2	66 39 90 56 03
	00 00		 cmp	 WORD PTR [eax+854], dx
  001e9	75 3f		 jne	 SHORT $LN27@ExGrandRes
  001eb	66 39 90 2a 04
	00 00		 cmp	 WORD PTR [eax+1066], dx
  001f2	75 36		 jne	 SHORT $LN27@ExGrandRes
  001f4	66 39 90 fe 04
	00 00		 cmp	 WORD PTR [eax+1278], dx
  001fb	75 2d		 jne	 SHORT $LN27@ExGrandRes
  001fd	66 39 90 d2 05
	00 00		 cmp	 WORD PTR [eax+1490], dx
  00204	75 24		 jne	 SHORT $LN27@ExGrandRes
  00206	66 39 90 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], dx
  0020d	75 1b		 jne	 SHORT $LN27@ExGrandRes
  0020f	66 39 90 7a 07
	00 00		 cmp	 WORD PTR [eax+1914], dx
  00216	75 12		 jne	 SHORT $LN27@ExGrandRes
  00218	66 39 90 4e 08
	00 00		 cmp	 WORD PTR [eax+2126], dx
  0021f	75 09		 jne	 SHORT $LN27@ExGrandRes
  00221	66 39 90 22 09
	00 00		 cmp	 WORD PTR [eax+2338], dx
  00228	74 22		 je	 SHORT $LN46@ExGrandRes
$LN27@ExGrandRes:

; 187  : 		{
; 188  : 			MsgNormal(aIndex,g_ZtText.GetText(18));

  0022a	6a 12		 push	 18			; 00000012H
  0022c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  00231	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00236	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00239	50		 push	 eax
  0023a	52		 push	 edx
  0023b	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00240	83 c4 08	 add	 esp, 8
  00243	5e		 pop	 esi
  00244	5b		 pop	 ebx
  00245	5f		 pop	 edi

; 306  : }

  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c2 04 00	 ret	 4
$LN46@ExGrandRes:

; 189  : 			return;
; 190  : 		}
; 191  : 	}
; 192  : 	/////////////////////
; 193  : 	//Выполнение Гран?ресета//
; 194  : 	/////////////////////
; 195  : 	lpObj->Money -= ZenMoney;

  0024c	29 8e f0 00 00
	00		 sub	 DWORD PTR [esi+240], ecx

; 196  : 	lpObj->Level = 1;

  00252	b8 01 00 00 00	 mov	 eax, 1
  00257	66 89 86 be 00
	00 00		 mov	 WORD PTR [esi+190], ax

; 197  : 	lpObj->Experience = 0;

  0025e	c7 86 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+200], 0

; 198  : 	lpObj->NextExp = 100;

  00268	c7 86 cc 00 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+204], 100 ; 00000064H

; 199  : 	if(this->AddForm == 2 || this->AddForm == 3)

  00272	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00275	83 f8 02	 cmp	 eax, 2
  00278	74 05		 je	 SHORT $LN25@ExGrandRes
  0027a	83 f8 03	 cmp	 eax, 3
  0027d	75 2a		 jne	 SHORT $LN24@ExGrandRes
$LN25@ExGrandRes:

; 200  : 	{
; 201  : 		lpObj->Strength = 25;
; 202  : 		lpObj->Dexterity = 25;
; 203  : 		lpObj->Vitality = 25;
; 204  : 		lpObj->Energy = 25;
; 205  : 		if(lpObj->Class == 4)

  0027f	66 83 be b8 00
	00 00 04	 cmp	 WORD PTR [esi+184], 4
  00287	c7 86 f4 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+244], 1638425 ; 00190019H
  00291	c7 86 f8 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+248], 1638425 ; 00190019H
  0029b	75 0c		 jne	 SHORT $LN24@ExGrandRes

; 206  : 		{
; 207  : 			lpObj->Leadership = 25;

  0029d	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
  002a2	66 89 96 18 01
	00 00		 mov	 WORD PTR [esi+280], dx
$LN24@ExGrandRes:

; 208  : 		}
; 209  : 	}
; 210  : 	//Поинта за гран?ресе?
; 211  : 	if(this->AddForm == 1 || this->AddForm == 2)

  002a9	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  002ac	83 f8 01	 cmp	 eax, 1
  002af	74 05		 je	 SHORT $LN22@ExGrandRes
  002b1	83 f8 02	 cmp	 eax, 2
  002b4	75 6e		 jne	 SHORT $LN20@ExGrandRes
$LN22@ExGrandRes:

; 212  : 	{
; 213  : 		switch (lpObj->Class)

  002b6	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  002bd	83 f8 06	 cmp	 eax, 6
  002c0	77 62		 ja	 SHORT $LN20@ExGrandRes
  002c2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN51@ExGrandRes[eax*4]
$LN19@ExGrandRes:

; 214  : 		{
; 215  : 			case 0: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsDW ;  break;

  002c9	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  002cc	0f af 47 1c	 imul	 eax, DWORD PTR [edi+28]
  002d0	eb 4c		 jmp	 SHORT $LN50@ExGrandRes
$LN18@ExGrandRes:

; 216  : 			case 1: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsDK ;  break;

  002d2	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  002d5	0f af 4f 20	 imul	 ecx, DWORD PTR [edi+32]
  002d9	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx
  002df	eb 43		 jmp	 SHORT $LN20@ExGrandRes
$LN17@ExGrandRes:

; 217  : 			case 2: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsELF ; break;

  002e1	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  002e4	0f af 57 24	 imul	 edx, DWORD PTR [edi+36]
  002e8	89 96 c0 00 00
	00		 mov	 DWORD PTR [esi+192], edx
  002ee	eb 34		 jmp	 SHORT $LN20@ExGrandRes
$LN16@ExGrandRes:

; 218  : 			case 3: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsMG ;  break;

  002f0	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  002f3	0f af 47 2c	 imul	 eax, DWORD PTR [edi+44]
  002f7	eb 25		 jmp	 SHORT $LN50@ExGrandRes
$LN15@ExGrandRes:

; 219  : 			case 4: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsDL ;  break;

  002f9	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  002fc	0f af 4f 30	 imul	 ecx, DWORD PTR [edi+48]
  00300	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx
  00306	eb 1c		 jmp	 SHORT $LN20@ExGrandRes
$LN14@ExGrandRes:

; 220  : 			case 5: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsSUM ; break;

  00308	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  0030b	0f af 57 28	 imul	 edx, DWORD PTR [edi+40]
  0030f	89 96 c0 00 00
	00		 mov	 DWORD PTR [esi+192], edx
  00315	eb 0d		 jmp	 SHORT $LN20@ExGrandRes
$LN13@ExGrandRes:

; 221  : 			case 6: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsRF ; break;

  00317	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0031a	0f af 47 34	 imul	 eax, DWORD PTR [edi+52]
$LN50@ExGrandRes:
  0031e	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
$LN20@ExGrandRes:

; 222  : 		}
; 223  : 	}
; 224  : 	if(this->AddForm == 3)

  00324	83 7f 18 03	 cmp	 DWORD PTR [edi+24], 3
  00328	75 0c		 jne	 SHORT $LN12@ExGrandRes

; 225  : 	{
; 226  : 		lpObj->LevelUpPoint = 0;

  0032a	c7 86 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+192], 0

; 227  : 	}
; 228  : 	else

  00334	eb 0c		 jmp	 SHORT $LN11@ExGrandRes
$LN12@ExGrandRes:

; 229  : 	{
; 230  : 		lpObj->LevelUpPoint += lpObj->ZtFreePoints;

  00336	8b 8e 8c 22 00
	00		 mov	 ecx, DWORD PTR [esi+8844]
  0033c	01 8e c0 00 00
	00		 add	 DWORD PTR [esi+192], ecx
$LN11@ExGrandRes:

; 231  : 	}
; 232  : 	
; 233  : 	lpObj->Reset = 0;
; 234  : 	lpObj->GReset += 1;

  00342	43		 inc	 ebx
  00343	c7 86 90 22 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+8848], 0
  0034d	89 9e 94 22 00
	00		 mov	 DWORD PTR [esi+8852], ebx

; 235  : 
; 236  : 	if(this->AddCredits > 0)

  00353	83 7f 3c 00	 cmp	 DWORD PTR [edi+60], 0
  00357	7e 44		 jle	 SHORT $LN47@ExGrandRes

; 237  : 	{
; 238  : 		if(g_ZtLicense.CheckUser(eZtUB::NSGames))

  00359	6a 51		 push	 81			; 00000051H
  0035b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00360	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00365	84 c0		 test	 al, al
  00367	74 17		 je	 SHORT $LN9@ExGrandRes

; 239  : 		{
; 240  : 			lpObj->PCPoint += this->AddCredits;	

  00369	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]

; 245  : 		}
; 246  : 		ZtUserDataSend(aIndex);

  0036c	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0036f	01 96 88 22 00
	00		 add	 DWORD PTR [esi+8840], edx
  00375	53		 push	 ebx
  00376	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  0037b	83 c4 04	 add	 esp, 4
  0037e	eb 20		 jmp	 SHORT $LN10@ExGrandRes
$LN9@ExGrandRes:

; 241  : 		}
; 242  : 		else
; 243  : 		{
; 244  : 			lpObj->ZtCred += this->AddCredits;		

  00380	db 47 3c	 fild	 DWORD PTR [edi+60]

; 245  : 		}
; 246  : 		ZtUserDataSend(aIndex);

  00383	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00386	53		 push	 ebx
  00387	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  0038d	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
  00393	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  00398	83 c4 04	 add	 esp, 4
  0039b	eb 03		 jmp	 SHORT $LN10@ExGrandRes
$LN47@ExGrandRes:
  0039d	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
$LN10@ExGrandRes:

; 247  : 	}
; 248  : 	if(this->AddWcoinC > 0)

  003a0	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  003a3	89 45 fc	 mov	 DWORD PTR tv933[ebp], eax
  003a6	85 c0		 test	 eax, eax
  003a8	7e 0f		 jle	 SHORT $LN7@ExGrandRes

; 249  : 	{
; 250  : 		lpObj->GameShop.WCoinC += this->AddWcoinC;

  003aa	db 45 fc	 fild	 DWORD PTR tv933[ebp]
  003ad	dc 86 00 23 00
	00		 fadd	 QWORD PTR [esi+8960]
  003b3	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
$LN7@ExGrandRes:

; 251  : 	}
; 252  : 	if(this->AddWcoinP > 0)

  003b9	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  003bc	89 45 fc	 mov	 DWORD PTR tv942[ebp], eax
  003bf	85 c0		 test	 eax, eax
  003c1	7e 0f		 jle	 SHORT $LN6@ExGrandRes

; 253  : 	{
; 254  : 		lpObj->GameShop.WCoinP += this->AddWcoinP;

  003c3	db 45 fc	 fild	 DWORD PTR tv942[ebp]
  003c6	dc 86 f8 22 00
	00		 fadd	 QWORD PTR [esi+8952]
  003cc	dd 9e f8 22 00
	00		 fstp	 QWORD PTR [esi+8952]
$LN6@ExGrandRes:

; 255  : 	}
; 256  : 	if(this->AddGoblinPoint > 0)

  003d2	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  003d5	89 45 fc	 mov	 DWORD PTR tv951[ebp], eax
  003d8	85 c0		 test	 eax, eax
  003da	7e 0f		 jle	 SHORT $LN5@ExGrandRes

; 257  : 	{
; 258  : 		lpObj->GameShop.GoblinPoint += this->AddGoblinPoint;

  003dc	db 45 fc	 fild	 DWORD PTR tv951[ebp]
  003df	dc 86 08 23 00
	00		 fadd	 QWORD PTR [esi+8968]
  003e5	dd 9e 08 23 00
	00		 fstp	 QWORD PTR [esi+8968]
$LN5@ExGrandRes:

; 259  : 	}
; 260  : 
; 261  : 	if(this->AddWcoinC > 0 || this->AddWcoinP > 0 || this->AddGoblinPoint > 0)

  003eb	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  003ef	7f 0c		 jg	 SHORT $LN3@ExGrandRes
  003f1	83 7f 44 00	 cmp	 DWORD PTR [edi+68], 0
  003f5	7f 06		 jg	 SHORT $LN3@ExGrandRes
  003f7	83 7f 48 00	 cmp	 DWORD PTR [edi+72], 0
  003fb	7e 0b		 jle	 SHORT $LN4@ExGrandRes
$LN3@ExGrandRes:

; 262  : 	{
; 263  : 		gGameShop.GDSaveUserInfo(aIndex);

  003fd	53		 push	 ebx
  003fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00403	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN4@ExGrandRes:

; 264  : 	}	
; 265  : 
; 266  : 	ZtFireCracker(aIndex, lpObj->X, lpObj->Y);

  00408	0f b6 86 46 01
	00 00		 movzx	 eax, BYTE PTR [esi+326]
  0040f	0f b6 8e 44 01
	00 00		 movzx	 ecx, BYTE PTR [esi+324]
  00416	50		 push	 eax
  00417	51		 push	 ecx
  00418	53		 push	 ebx
  00419	e8 00 00 00 00	 call	 ?ZtFireCracker@@YAXHEE@Z ; ZtFireCracker

; 267  : 	//gObjCloseSet(aIndex, 1);
; 268  : 
; 269  : 	lpObj->Life = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  0041e	0f bf 96 d0 00
	00 00		 movsx	 edx, WORD PTR [esi+208]
  00425	0f bf 86 be 00
	00 00		 movsx	 eax, WORD PTR [esi+190]
  0042c	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00430	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00437	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  0043d	0f b7 90 0c 00
	00 00		 movzx	 edx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  00444	89 4d fc	 mov	 DWORD PTR tv1076[ebp], ecx
  00447	0f b7 8e f8 00
	00 00		 movzx	 ecx, WORD PTR [esi+248]
  0044e	db 45 fc	 fild	 DWORD PTR tv1076[ebp]
  00451	8b f9		 mov	 edi, ecx
  00453	2b fa		 sub	 edi, edx
  00455	d9 5d f8	 fstp	 DWORD PTR tv972[ebp]

; 270  : 	lpObj->Mana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  00458	0f b7 96 fa 00
	00 00		 movzx	 edx, WORD PTR [esi+250]
  0045f	89 7d fc	 mov	 DWORD PTR tv1071[ebp], edi
  00462	8b da		 mov	 ebx, edx
  00464	db 45 fc	 fild	 DWORD PTR tv1071[ebp]
  00467	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  0046d	d9 45 f8	 fld	 DWORD PTR tv972[ebp]
  00470	d9 c0		 fld	 ST(0)
  00472	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00478	d8 80 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  0047e	de c2		 faddp	 ST(2), ST(0)
  00480	d9 c9		 fxch	 ST(1)
  00482	d9 9e fc 00 00
	00		 fstp	 DWORD PTR [esi+252]
  00488	0f b7 b8 0e 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  0048f	2b df		 sub	 ebx, edi
  00491	89 5d f8	 mov	 DWORD PTR tv1066[ebp], ebx
  00494	db 45 f8	 fild	 DWORD PTR tv1066[ebp]
  00497	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  0049d	d9 c1		 fld	 ST(1)
  0049f	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  004a5	d8 80 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  004ab	de c1		 faddp	 ST(1), ST(0)
  004ad	d9 9e 10 01 00
	00		 fstp	 DWORD PTR [esi+272]

; 271  : 
; 272  : 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  004b3	0f b7 b8 0c 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  004ba	2b cf		 sub	 ecx, edi
  004bc	89 4d f8	 mov	 DWORD PTR tv1061[ebp], ecx

; 273  : 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);
; 274  : 
; 275  : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;
; 276  : 	lpObj->EnergyToMana = DCInfo.DefClass[lpObj->Class].EnergyToMana;
; 277  : 
; 278  : 	::gObjSetBP(aIndex);

  004bf	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  004c2	57		 push	 edi
  004c3	db 45 f8	 fild	 DWORD PTR tv1061[ebp]
  004c6	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  004cc	d9 c1		 fld	 ST(1)
  004ce	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  004d4	d8 80 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  004da	de c1		 faddp	 ST(1), ST(0)
  004dc	d9 9e 00 01 00
	00		 fstp	 DWORD PTR [esi+256]
  004e2	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  004e9	2b d1		 sub	 edx, ecx
  004eb	89 55 f8	 mov	 DWORD PTR tv1056[ebp], edx
  004ee	db 45 f8	 fild	 DWORD PTR tv1056[ebp]
  004f1	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  004f7	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  004fd	de ca		 fmulp	 ST(2), ST(0)
  004ff	d9 80 20 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  00505	de c2		 faddp	 ST(2), ST(0)
  00507	de c1		 faddp	 ST(1), ST(0)
  00509	d9 9e 14 01 00
	00		 fstp	 DWORD PTR [esi+276]
  0050f	d9 80 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  00515	d9 9e 34 01 00
	00		 fstp	 DWORD PTR [esi+308]
  0051b	d9 80 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00521	d9 9e 38 01 00
	00		 fstp	 DWORD PTR [esi+312]
  00527	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 279  : 	lpObj->BP = lpObj->MaxBP / 2;

  0052c	8b 86 2c 01 00
	00		 mov	 eax, DWORD PTR [esi+300]
  00532	99		 cdq
  00533	2b c2		 sub	 eax, edx
  00535	d1 f8		 sar	 eax, 1

; 280  : 	::gObjCalcMaxLifePower(aIndex);

  00537	57		 push	 edi
  00538	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax
  0053e	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 281  : 
; 282  : 	GCReFillSend(aIndex, (int)lpObj->MaxLife + lpObj->AddLife, 0xFE, 0, lpObj->iMaxShield + lpObj->iAddShield);

  00543	8b 96 5c 01 00
	00		 mov	 edx, DWORD PTR [esi+348]
  00549	83 c4 14	 add	 esp, 20			; 00000014H
  0054c	03 96 58 01 00
	00		 add	 edx, DWORD PTR [esi+344]
  00552	52		 push	 edx
  00553	6a 00		 push	 0
  00555	68 fe 00 00 00	 push	 254			; 000000feH
  0055a	d9 86 00 01 00
	00		 fld	 DWORD PTR [esi+256]
  00560	e8 00 00 00 00	 call	 __ftol2_sse
  00565	03 86 4c 01 00
	00		 add	 eax, DWORD PTR [esi+332]
  0056b	50		 push	 eax
  0056c	57		 push	 edi
  0056d	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 283  : 	//gObjSetBP(aIndex);
; 284  : 	GCManaSend(aIndex,(int)lpObj->MaxMana + lpObj->AddMana, 0xFE, 0, lpObj->MaxBP + lpObj->AddBP);

  00572	d9 86 14 01 00
	00		 fld	 DWORD PTR [esi+276]
  00578	8b 86 30 01 00
	00		 mov	 eax, DWORD PTR [esi+304]
  0057e	03 86 2c 01 00
	00		 add	 eax, DWORD PTR [esi+300]
  00584	83 c4 14	 add	 esp, 20			; 00000014H
  00587	50		 push	 eax
  00588	6a 00		 push	 0
  0058a	68 fe 00 00 00	 push	 254			; 000000feH
  0058f	e8 00 00 00 00	 call	 __ftol2_sse
  00594	03 86 50 01 00
	00		 add	 eax, DWORD PTR [esi+336]
  0059a	50		 push	 eax
  0059b	57		 push	 edi
  0059c	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 285  : 	gObjCalCharacter(aIndex);

  005a1	57		 push	 edi
  005a2	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 286  : 
; 287  : 	ResetSystemGC_CharUpdate(lpObj);

  005a7	56		 push	 esi
  005a8	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate

; 288  : 
; 289  : 	GCMoneySend(aIndex, lpObj->Money);

  005ad	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  005b3	51		 push	 ecx
  005b4	57		 push	 edi
  005b5	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  005ba	83 c4 24	 add	 esp, 36			; 00000024H

; 290  : 
; 291  : #if(CUSTOM_NOOBBUFF)
; 292  : 	if(ZtConfig.CommonServer.bNoobBuffEnable)

  005bd	80 3d 20 01 00
	00 00		 cmp	 BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+288, 0
  005c4	74 20		 je	 SHORT $LN1@ExGrandRes

; 293  : 	{
; 294  : 		if(gObjSearchActiveEffect(lpObj,AT_NOOB_BUFF) == TRUE)

  005c6	68 b6 00 00 00	 push	 182			; 000000b6H
  005cb	56		 push	 esi
  005cc	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  005d1	83 c4 08	 add	 esp, 8
  005d4	3c 01		 cmp	 al, 1
  005d6	75 0e		 jne	 SHORT $LN1@ExGrandRes

; 295  : 		{
; 296  : 			gObjRemoveBuffEffect(lpObj,AT_NOOB_BUFF);

  005d8	68 b6 00 00 00	 push	 182			; 000000b6H
  005dd	56		 push	 esi
  005de	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  005e3	83 c4 08	 add	 esp, 8
$LN1@ExGrandRes:

; 297  : 		}
; 298  : 	}
; 299  : #endif
; 300  : 
; 301  : #if(SYSTEM_ACHIEVEMENTS)
; 302  : 	g_Achievements.GrandResetUp(aIndex);

  005e6	57		 push	 edi
  005e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  005ec	e8 00 00 00 00	 call	 ?GrandResetUp@CAchievements@@QAEXH@Z ; CAchievements::GrandResetUp

; 303  : #endif
; 304  : 
; 305  : 	LogAddTD("[GrandResetSystem] Accaunt: %s , Name: %s , GrandReset: %d",lpObj->AccountID, lpObj->Name,lpObj->GReset);

  005f1	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  005f7	52		 push	 edx
  005f8	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  005fb	50		 push	 eax
  005fc	83 c6 6c	 add	 esi, 108		; 0000006cH
  005ff	56		 push	 esi
  00600	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@JEEEMDGP@?$FLGrandResetSystem?$FN?5Accaunt?3?5?$CFs?5?0@
  00605	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0060b	83 c4 10	 add	 esp, 16			; 00000010H
$LN48@ExGrandRes:
  0060e	5e		 pop	 esi
  0060f	5b		 pop	 ebx
$LN44@ExGrandRes:
  00610	5f		 pop	 edi

; 306  : }

  00611	8b e5		 mov	 esp, ebp
  00613	5d		 pop	 ebp
  00614	c2 04 00	 ret	 4
  00617	90		 npad	 1
$LN51@ExGrandRes:
  00618	00 00 00 00	 DD	 $LN19@ExGrandRes
  0061c	00 00 00 00	 DD	 $LN18@ExGrandRes
  00620	00 00 00 00	 DD	 $LN17@ExGrandRes
  00624	00 00 00 00	 DD	 $LN16@ExGrandRes
  00628	00 00 00 00	 DD	 $LN15@ExGrandRes
  0062c	00 00 00 00	 DD	 $LN14@ExGrandRes
  00630	00 00 00 00	 DD	 $LN13@ExGrandRes
?ExGrandResetSystemFunciton@cGrandReset@@QAEXH@Z ENDP	; cGrandReset::ExGrandResetSystemFunciton
_TEXT	ENDS
PUBLIC	?SearchItem@cGrandReset@@QAE_NHHHH_N0000H0@Z	; cGrandReset::SearchItem
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?CheckOptionItem@@YA_NHHH@Z:PROC		; CheckOptionItem
; Function compile flags: /Ogtp
;	COMDAT ?SearchItem@cGrandReset@@QAE_NHHHH_N0000H0@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_iType$ = 12						; size = 2
_Type$ = 12						; size = 4
_Index$ = 16						; size = 4
_Level$ = 20						; size = 4
_Skill$ = 24						; size = 1
_Luck$ = 28						; size = 1
_Opt$ = 32						; size = 1
_Exl$ = 36						; size = 1
_Anc$ = 40						; size = 1
_count$ = 44						; size = 4
_iDelCount$213993 = 48					; size = 4
_del$ = 48						; size = 1
?SearchItem@cGrandReset@@QAE_NHHHH_N0000H0@Z PROC	; cGrandReset::SearchItem, COMDAT
; _this$ = ecx

; 869  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 870  : 	LPOBJ lpUser = &gObj[aIndex];
; 871  : 	int iCount = 0;
; 872  : 	short iType = ITEMGET(Type, Index);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00012	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	c1 e0 09	 shl	 eax, 9
  0001b	03 45 10	 add	 eax, DWORD PTR _Index$[ebp]
  0001e	57		 push	 edi
  0001f	0f b7 d8	 movzx	 ebx, ax
  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
  00029	89 5d 0c	 mov	 DWORD PTR _iType$[ebp], ebx
  0002c	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
$LL22@SearchItem:

; 875  : 	{
; 876  : 		if( lpUser->pInventory[i].m_Type == iType && 
; 877  : 			lpUser->pInventory[i].m_Level >= Level &&
; 878  : 			CheckOptionItem(lpUser->pInventory[i].m_Option1, Skill, FALSE) &&
; 879  : 			CheckOptionItem(lpUser->pInventory[i].m_Option2, Luck, FALSE) &&
; 880  : 			CheckOptionItem(lpUser->pInventory[i].m_Option3, Opt, FALSE) &&
; 881  : 			CheckOptionItem(lpUser->pInventory[i].m_NewOption, Exl, FALSE) &&
; 882  : 			CheckOptionItem(lpUser->pInventory[i].m_SetOption, Anc, FALSE) )

  00031	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  00037	66 39 5c 0f 06	 cmp	 WORD PTR [edi+ecx+6], bx
  0003c	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0003f	0f 85 b7 00 00
	00		 jne	 $LN11@SearchItem
  00045	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]
  00049	3b 55 14	 cmp	 edx, DWORD PTR _Level$[ebp]
  0004c	0f 8c aa 00 00
	00		 jl	 $LN11@SearchItem
  00052	0f b6 4d 18	 movzx	 ecx, BYTE PTR _Skill$[ebp]
  00056	0f b6 90 94 00
	00 00		 movzx	 edx, BYTE PTR [eax+148]
  0005d	6a 00		 push	 0
  0005f	51		 push	 ecx
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	84 c0		 test	 al, al
  0006b	0f 84 8b 00 00
	00		 je	 $LN11@SearchItem
  00071	0f b6 45 1c	 movzx	 eax, BYTE PTR _Luck$[ebp]
  00075	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0007b	0f b6 94 0f 95
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+149]
  00083	6a 00		 push	 0
  00085	50		 push	 eax
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	84 c0		 test	 al, al
  00091	74 69		 je	 SHORT $LN11@SearchItem
  00093	0f b6 45 20	 movzx	 eax, BYTE PTR _Opt$[ebp]
  00097	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0009d	0f b6 94 0f 96
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+150]
  000a5	6a 00		 push	 0
  000a7	50		 push	 eax
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	84 c0		 test	 al, al
  000b3	74 47		 je	 SHORT $LN11@SearchItem
  000b5	0f b6 45 24	 movzx	 eax, BYTE PTR _Exl$[ebp]
  000b9	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  000bf	0f b6 94 0f 97
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+151]
  000c7	6a 00		 push	 0
  000c9	50		 push	 eax
  000ca	52		 push	 edx
  000cb	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	84 c0		 test	 al, al
  000d5	74 25		 je	 SHORT $LN11@SearchItem
  000d7	0f b6 45 28	 movzx	 eax, BYTE PTR _Anc$[ebp]
  000db	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  000e1	0f b6 94 0f ae
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+174]
  000e9	6a 00		 push	 0
  000eb	50		 push	 eax
  000ec	52		 push	 edx
  000ed	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	84 c0		 test	 al, al
  000f7	74 03		 je	 SHORT $LN11@SearchItem

; 883  : 		{
; 884  : 			iCount++;

  000f9	ff 45 fc	 inc	 DWORD PTR _iCount$[ebp]
$LN11@SearchItem:

; 873  : 
; 874  : 	for (int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  000fc	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00102	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  00108	0f 8c 23 ff ff
	ff		 jl	 $LL22@SearchItem

; 885  : 		}
; 886  : 	}
; 887  : 
; 888  : 	if(iCount >= count)

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _iCount$[ebp]
  00111	3b 45 2c	 cmp	 eax, DWORD PTR _count$[ebp]
  00114	0f 8c 39 01 00
	00		 jl	 $LN8@SearchItem

; 889  : 	{
; 890  : 		if(del)

  0011a	80 7d 30 00	 cmp	 BYTE PTR _del$[ebp], 0
  0011e	0f 84 24 01 00
	00		 je	 $LN17@SearchItem

; 891  : 		{
; 892  : 			int iDelCount = 0;

  00124	c7 45 30 00 00
	00 00		 mov	 DWORD PTR _iDelCount$213993[ebp], 0

; 893  : 			for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  0012b	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  00130	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  00135	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@SearchItem:

; 894  : 			{
; 895  : 				if( lpUser->pInventory[i].m_Type == iType && 
; 896  : 					lpUser->pInventory[i].m_Level >= Level &&
; 897  : 					CheckOptionItem(lpUser->pInventory[i].m_Option1, Skill, FALSE) &&
; 898  : 					CheckOptionItem(lpUser->pInventory[i].m_Option2, Luck, FALSE) &&
; 899  : 					CheckOptionItem(lpUser->pInventory[i].m_Option3, Opt, FALSE) &&
; 900  : 					CheckOptionItem(lpUser->pInventory[i].m_NewOption, Exl, FALSE) &&
; 901  : 					CheckOptionItem(lpUser->pInventory[i].m_SetOption, Anc, FALSE) )

  00140	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  00146	66 8b 55 0c	 mov	 dx, WORD PTR _iType$[ebp]
  0014a	66 39 54 0f 06	 cmp	 WORD PTR [edi+ecx+6], dx
  0014f	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  00152	0f 85 dd 00 00
	00		 jne	 $LN5@SearchItem
  00158	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0015c	3b 4d 14	 cmp	 ecx, DWORD PTR _Level$[ebp]
  0015f	0f 8c d0 00 00
	00		 jl	 $LN5@SearchItem
  00165	0f b6 55 18	 movzx	 edx, BYTE PTR _Skill$[ebp]
  00169	0f b6 80 94 00
	00 00		 movzx	 eax, BYTE PTR [eax+148]
  00170	6a 00		 push	 0
  00172	52		 push	 edx
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	84 c0		 test	 al, al
  0017e	0f 84 b1 00 00
	00		 je	 $LN5@SearchItem
  00184	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _Luck$[ebp]
  00188	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  0018e	0f b6 84 17 95
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+149]
  00196	6a 00		 push	 0
  00198	51		 push	 ecx
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a2	84 c0		 test	 al, al
  001a4	0f 84 8b 00 00
	00		 je	 $LN5@SearchItem
  001aa	0f b6 4d 20	 movzx	 ecx, BYTE PTR _Opt$[ebp]
  001ae	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  001b4	0f b6 84 17 96
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+150]
  001bc	6a 00		 push	 0
  001be	51		 push	 ecx
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c8	84 c0		 test	 al, al
  001ca	74 69		 je	 SHORT $LN5@SearchItem
  001cc	0f b6 4d 24	 movzx	 ecx, BYTE PTR _Exl$[ebp]
  001d0	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  001d6	0f b6 84 17 97
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+151]
  001de	6a 00		 push	 0
  001e0	51		 push	 ecx
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ea	84 c0		 test	 al, al
  001ec	74 47		 je	 SHORT $LN5@SearchItem
  001ee	0f b6 4d 28	 movzx	 ecx, BYTE PTR _Anc$[ebp]
  001f2	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  001f8	0f b6 84 17 ae
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+174]
  00200	6a 00		 push	 0
  00202	51		 push	 ecx
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020c	84 c0		 test	 al, al
  0020e	74 25		 je	 SHORT $LN5@SearchItem

; 902  : 				{
; 903  : 					gObjInventoryDeleteItem(aIndex, i);

  00210	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00213	53		 push	 ebx
  00214	51		 push	 ecx
  00215	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 904  : 					GCInventoryItemDeleteSend(aIndex, i, 1);

  0021a	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0021d	6a 01		 push	 1
  0021f	53		 push	 ebx
  00220	52		 push	 edx
  00221	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 905  : 					iDelCount++;

  00226	8b 45 30	 mov	 eax, DWORD PTR _iDelCount$213993[ebp]
  00229	40		 inc	 eax
  0022a	83 c4 14	 add	 esp, 20			; 00000014H
  0022d	89 45 30	 mov	 DWORD PTR _iDelCount$213993[ebp], eax

; 906  : 					if(iDelCount == count)

  00230	3b 45 2c	 cmp	 eax, DWORD PTR _count$[ebp]
  00233	74 13		 je	 SHORT $LN17@SearchItem
$LN5@SearchItem:

; 893  : 			for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  00235	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0023b	43		 inc	 ebx
  0023c	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  00242	0f 8c f8 fe ff
	ff		 jl	 $LL6@SearchItem
$LN17@SearchItem:
  00248	5f		 pop	 edi
  00249	5e		 pop	 esi

; 907  : 					{
; 908  : 						return true;

  0024a	b0 01		 mov	 al, 1
  0024c	5b		 pop	 ebx

; 918  : 	}
; 919  : }

  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c2 2c 00	 ret	 44			; 0000002cH
$LN8@SearchItem:
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi

; 909  : 					}
; 910  : 				}
; 911  : 			}
; 912  : 		}
; 913  : 		return true;
; 914  : 	}
; 915  : 	else
; 916  : 	{
; 917  : 		return false;

  00255	32 c0		 xor	 al, al
  00257	5b		 pop	 ebx

; 918  : 	}
; 919  : }

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 2c 00	 ret	 44			; 0000002cH
?SearchItem@cGrandReset@@QAE_NHHHH_N0000H0@Z ENDP	; cGrandReset::SearchItem
_TEXT	ENDS
PUBLIC	?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	56		 push	 esi

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	2b 31		 sub	 esi, DWORD PTR [ecx]
  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 880  : 		}

  0001a	c3		 ret	 0
?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000d	2b d0		 sub	 edx, eax
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 941  : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEAAUGrandResetEXP@@I@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEAAUGrandResetEXP@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEAAUGrandResetEXP@@I@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEAAUGrandResetEXP@@I@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 880  : 		}

  00016	c3		 ret	 0
?size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEAAUGRANDSYSTEM_REWARD_DATA@@I@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEAAUGRANDSYSTEM_REWARD_DATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEAAUGRANDSYSTEM_REWARD_DATA@@I@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 941  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEAAUGRANDSYSTEM_REWARD_DATA@@I@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ PROC	; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBE_NPBUGrandResetEXP@@@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Inside
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBE_NPBUGrandResetEXP@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBE_NPBUGrandResetEXP@@@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@2
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@2
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@2:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBE_NPBUGrandResetEXP@@@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXPAUGrandResetEXP@@0@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXPAUGrandResetEXP@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXPAUGrandResetEXP@@0@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXPAUGrandResetEXP@@0@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ ; std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >::~_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >::~_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >::~_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UGrandResetEXP@@@std@@QAE@XZ	; std::allocator<GrandResetEXP>::allocator<GrandResetEXP>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UGrandResetEXP@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UGrandResetEXP@@@std@@QAE@XZ PROC	; std::allocator<GrandResetEXP>::allocator<GrandResetEXP>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UGrandResetEXP@@@std@@QAE@XZ ENDP	; std::allocator<GrandResetEXP>::allocator<GrandResetEXP>
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBE_NPBUGRANDSYSTEM_REWARD_DATA@@@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Inside
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBE_NPBUGRANDSYSTEM_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBE_NPBUGRANDSYSTEM_REWARD_DATA@@@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@3
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@3
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@3:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBE_NPBUGRANDSYSTEM_REWARD_DATA@@@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::~_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::~_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::~_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@XZ ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocator<GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@XZ PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocator<GRANDSYSTEM_REWARD_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@XZ ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocator<GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	56		 push	 esi

; 777  : 		return (this->_Myend - this->_Myfirst);

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	2b 31		 sub	 esi, DWORD PTR [ecx]
  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 778  : 		}

  0001a	c3		 ret	 0
?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXXZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXXZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000a	cc		 int	 3
?_Xlen@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEXXZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UGrandResetEXP@@@std@@QAE@ABV01@@Z ; std::allocator<GrandResetEXP>::allocator<GrandResetEXP>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UGrandResetEXP@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UGrandResetEXP@@@std@@QAE@ABV01@@Z PROC	; std::allocator<GrandResetEXP>::allocator<GrandResetEXP>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UGrandResetEXP@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<GrandResetEXP>::allocator<GrandResetEXP>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@I@Z ; std::allocator<GrandResetEXP>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@I@Z PROC ; std::allocator<GrandResetEXP>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@I@Z ENDP ; std::allocator<GrandResetEXP>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 778  : 		}

  00016	c3		 ret	 0
?capacity@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXXZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@3:
$LN3@Xlen@3:
  0000a	cc		 int	 3
?_Xlen@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocator<GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocator<GRANDSYSTEM_REWARD_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocator<GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@I@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@I@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@I@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ; std::allocator<RESET_NEEDITEM_DATA>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ PROC ; std::allocator<RESET_NEEDITEM_DATA>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ENDP ; std::allocator<RESET_NEEDITEM_DATA>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UGrandResetEXP@@@std@@QBEIXZ ; std::allocator<GrandResetEXP>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UGrandResetEXP@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UGrandResetEXP@@@std@@QBEIXZ PROC	; std::allocator<GrandResetEXP>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UGrandResetEXP@@@std@@QBEIXZ ENDP	; std::allocator<GrandResetEXP>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QBEIXZ ; std::allocator<GRANDSYSTEM_REWARD_DATA>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QBEIXZ PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QBEIXZ ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Compat
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ; std::addressof<RESET_NEEDITEM_DATA const >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::addressof<RESET_NEEDITEM_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::addressof<RESET_NEEDITEM_DATA const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUGrandResetEXP@@@std@@YAPBUGrandResetEXP@@ABU1@@Z ; std::addressof<GrandResetEXP const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBUGrandResetEXP@@@std@@YAPBUGrandResetEXP@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUGrandResetEXP@@@std@@YAPBUGrandResetEXP@@ABU1@@Z PROC ; std::addressof<GrandResetEXP const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUGrandResetEXP@@@std@@YAPBUGrandResetEXP@@ABU1@@Z ENDP ; std::addressof<GrandResetEXP const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUGRANDSYSTEM_REWARD_DATA@@@std@@YAPBUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z ; std::addressof<GRANDSYSTEM_REWARD_DATA const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBUGRANDSYSTEM_REWARD_DATA@@@std@@YAPBUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUGRANDSYSTEM_REWARD_DATA@@@std@@YAPBUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z PROC ; std::addressof<GRANDSYSTEM_REWARD_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUGRANDSYSTEM_REWARD_DATA@@@std@@YAPBUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z ENDP ; std::addressof<GRANDSYSTEM_REWARD_DATA const >
_TEXT	ENDS
PUBLIC	??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct:
  00017	5f		 pop	 edi

; 209  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ; std::forward<RESET_NEEDITEM_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA const &>
_TEXT	ENDS
PUBLIC	??$forward@AAUGrandResetEXP@@@std@@YAAAUGrandResetEXP@@AAU1@@Z ; std::forward<GrandResetEXP &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAUGrandResetEXP@@@std@@YAAAUGrandResetEXP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUGrandResetEXP@@@std@@YAAAUGrandResetEXP@@AAU1@@Z PROC ; std::forward<GrandResetEXP &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUGrandResetEXP@@@std@@YAAAUGrandResetEXP@@AAU1@@Z ENDP ; std::forward<GrandResetEXP &>
_TEXT	ENDS
PUBLIC	??$construct@AAUGrandResetEXP@@@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@AAU2@@Z ; std::allocator<GrandResetEXP>::construct<GrandResetEXP &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUGrandResetEXP@@@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUGrandResetEXP@@@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@AAU2@@Z PROC ; std::allocator<GrandResetEXP>::construct<GrandResetEXP &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@2:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@AAUGrandResetEXP@@@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@AAU2@@Z ENDP ; std::allocator<GrandResetEXP>::construct<GrandResetEXP &>
_TEXT	ENDS
PUBLIC	??$forward@ABUGrandResetEXP@@@std@@YAABUGrandResetEXP@@ABU1@@Z ; std::forward<GrandResetEXP const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUGrandResetEXP@@@std@@YAABUGrandResetEXP@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUGrandResetEXP@@@std@@YAABUGrandResetEXP@@ABU1@@Z PROC ; std::forward<GrandResetEXP const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUGrandResetEXP@@@std@@YAABUGrandResetEXP@@ABU1@@Z ENDP ; std::forward<GrandResetEXP const &>
_TEXT	ENDS
PUBLIC	??$forward@AAUGRANDSYSTEM_REWARD_DATA@@@std@@YAAAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z ; std::forward<GRANDSYSTEM_REWARD_DATA &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAUGRANDSYSTEM_REWARD_DATA@@@std@@YAAAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUGRANDSYSTEM_REWARD_DATA@@@std@@YAAAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z PROC ; std::forward<GRANDSYSTEM_REWARD_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUGRANDSYSTEM_REWARD_DATA@@@std@@YAAAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z ENDP ; std::forward<GRANDSYSTEM_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	??$construct@AAUGRANDSYSTEM_REWARD_DATA@@@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct<GRANDSYSTEM_REWARD_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUGRANDSYSTEM_REWARD_DATA@@@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUGRANDSYSTEM_REWARD_DATA@@@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct<GRANDSYSTEM_REWARD_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@3
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@3:
  00017	5f		 pop	 edi

; 209  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@AAUGRANDSYSTEM_REWARD_DATA@@@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct<GRANDSYSTEM_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	??$forward@ABUGRANDSYSTEM_REWARD_DATA@@@std@@YAABUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z ; std::forward<GRANDSYSTEM_REWARD_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUGRANDSYSTEM_REWARD_DATA@@@std@@YAABUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUGRANDSYSTEM_REWARD_DATA@@@std@@YAABUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z PROC ; std::forward<GRANDSYSTEM_REWARD_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUGRANDSYSTEM_REWARD_DATA@@@std@@YAABUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z ENDP ; std::forward<GRANDSYSTEM_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UGrandResetEXP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGrandResetEXP@@0@Z ; std::_Ptr_cat<GrandResetEXP,GrandResetEXP>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UGrandResetEXP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGrandResetEXP@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UGrandResetEXP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGrandResetEXP@@0@Z PROC ; std::_Ptr_cat<GrandResetEXP,GrandResetEXP>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UGrandResetEXP@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGrandResetEXP@@0@Z ENDP ; std::_Ptr_cat<GrandResetEXP,GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z PROC ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UGRANDSYSTEM_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDSYSTEM_REWARD_DATA@@0@Z ; std::_Ptr_cat<GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@UGRANDSYSTEM_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDSYSTEM_REWARD_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UGRANDSYSTEM_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDSYSTEM_REWARD_DATA@@0@Z PROC ; std::_Ptr_cat<GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UGRANDSYSTEM_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUGRANDSYSTEM_REWARD_DATA@@0@Z ENDP ; std::_Ptr_cat<GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@Construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@Construct:
  00017	5f		 pop	 edi

; 49   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UGrandResetEXP@@ABU1@@std@@YAXPAUGrandResetEXP@@ABU1@@Z ; std::_Construct<GrandResetEXP,GrandResetEXP const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@UGrandResetEXP@@ABU1@@std@@YAXPAUGrandResetEXP@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UGrandResetEXP@@ABU1@@std@@YAXPAUGrandResetEXP@@ABU1@@Z PROC ; std::_Construct<GrandResetEXP,GrandResetEXP const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UGrandResetEXP@@ABU1@@std@@YAXPAUGrandResetEXP@@ABU1@@Z ENDP ; std::_Construct<GrandResetEXP,GrandResetEXP const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UGRANDSYSTEM_REWARD_DATA@@ABU1@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z ; std::_Construct<GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@UGRANDSYSTEM_REWARD_DATA@@ABU1@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UGRANDSYSTEM_REWARD_DATA@@ABU1@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z PROC ; std::_Construct<GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@Construct@3
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@Construct@3:
  00017	5f		 pop	 edi

; 49   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Construct@UGRANDSYSTEM_REWARD_DATA@@ABU1@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@ABU1@@Z ENDP ; std::_Construct<GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$move@AAUGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z ; std::move<GrandResetEXP &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z PROC ; std::move<GrandResetEXP &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z ENDP ; std::move<GrandResetEXP &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ; std::_Val_type<RESET_NEEDITEM_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z PROC ; std::_Val_type<RESET_NEEDITEM_DATA *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ENDP ; std::_Val_type<RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUGrandResetEXP@@@std@@YAPAUGrandResetEXP@@PAU1@@Z ; std::_Val_type<GrandResetEXP *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAUGrandResetEXP@@@std@@YAPAUGrandResetEXP@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUGrandResetEXP@@@std@@YAPAUGrandResetEXP@@PAU1@@Z PROC ; std::_Val_type<GrandResetEXP *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUGrandResetEXP@@@std@@YAPAUGrandResetEXP@@PAU1@@Z ENDP ; std::_Val_type<GrandResetEXP *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@@Z ; std::_Val_type<GRANDSYSTEM_REWARD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAUGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@@Z PROC ; std::_Val_type<GRANDSYSTEM_REWARD_DATA *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@@Z ENDP ; std::_Val_type<GRANDSYSTEM_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ; std::_Destroy<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z PROC ; std::_Destroy<RESET_NEEDITEM_DATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ENDP ; std::_Destroy<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@UGrandResetEXP@@@std@@YAXPAUGrandResetEXP@@@Z ; std::_Destroy<GrandResetEXP>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@UGrandResetEXP@@@std@@YAXPAUGrandResetEXP@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UGrandResetEXP@@@std@@YAXPAUGrandResetEXP@@@Z PROC ; std::_Destroy<GrandResetEXP>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UGrandResetEXP@@@std@@YAXPAUGrandResetEXP@@@Z ENDP ; std::_Destroy<GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$_Destroy@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@@Z ; std::_Destroy<GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@@Z PROC ; std::_Destroy<GRANDSYSTEM_REWARD_DATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@@Z ENDP ; std::_Destroy<GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$forward@UGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z ; std::forward<GrandResetEXP>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@UGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z PROC ; std::forward<GrandResetEXP>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UGrandResetEXP@@@std@@YA$$QAUGrandResetEXP@@AAU1@@Z ENDP ; std::forward<GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$forward@UGRANDSYSTEM_REWARD_DATA@@@std@@YA$$QAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z ; std::forward<GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@UGRANDSYSTEM_REWARD_DATA@@@std@@YA$$QAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UGRANDSYSTEM_REWARD_DATA@@@std@@YA$$QAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z PROC ; std::forward<GRANDSYSTEM_REWARD_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UGRANDSYSTEM_REWARD_DATA@@@std@@YA$$QAUGRANDSYSTEM_REWARD_DATA@@AAU1@@Z ENDP ; std::forward<GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?DinamicExp@cGrandReset@@QAEHHH@Z		; cGrandReset::DinamicExp
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\grandreset.cpp
;	COMDAT ?DinamicExp@cGrandReset@@QAEHHH@Z
_TEXT	SEGMENT
_list$213810 = -12					; size = 8
_Result$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Experience$ = 12					; size = 4
?DinamicExp@cGrandReset@@QAEHHH@Z PROC			; cGrandReset::DinamicExp, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 311  : 	int Result = Experience;
; 312  : 
; 313  : 	if(!this->EnableGrandResetSystem)

  00006	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _Experience$[ebp]
  0000d	8b c7		 mov	 eax, edi
  0000f	89 45 fc	 mov	 DWORD PTR _Result$[ebp], eax

; 314  : 	{
; 315  : 		return Result;

  00012	0f 84 b2 00 00
	00		 je	 $LN12@DinamicExp

; 316  : 	}
; 317  : 
; 318  : 	if(!this->EnableGrandDinamic)

  00018	80 b9 b4 00 00
	00 00		 cmp	 BYTE PTR [ecx+180], 0

; 319  : 	{
; 320  : 		return Result;

  0001f	0f 84 a5 00 00
	00		 je	 $LN12@DinamicExp

; 321  : 	}
; 322  : 
; 323  : 	if(OBJMAX_RANGE(aIndex) == 0)

  00025	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	85 d2		 test	 edx, edx
  0002c	0f 88 96 00 00
	00		 js	 $LN24@DinamicExp
  00032	33 db		 xor	 ebx, ebx
  00034	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  0003a	0f 9e c3	 setle	 bl
  0003d	8b f3		 mov	 esi, ebx
  0003f	85 f6		 test	 esi, esi

; 324  : 	{
; 325  : 		return Result;

  00041	0f 84 81 00 00
	00		 je	 $LN24@DinamicExp

; 326  : 	}
; 327  : 
; 328  : 	LPOBJ lpUser = &gObj[aIndex];

  00047	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0004d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	8b da		 mov	 ebx, edx

; 329  : 
; 330  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00055	83 7b 04 03	 cmp	 DWORD PTR [ebx+4], 3

; 331  : 	{
; 332  : 		return Result;

  00059	7c 6d		 jl	 SHORT $LN24@DinamicExp

; 333  : 	}
; 334  : 
; 335  : 	for(int i = 0; i < this->DataExp.size(); i++)

  0005b	8b b9 b8 00 00
	00		 mov	 edi, DWORD PTR [ecx+184]
  00061	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  00067	2b d7		 sub	 edx, edi
  00069	c1 fa 03	 sar	 edx, 3
  0006c	33 f6		 xor	 esi, esi
  0006e	85 d2		 test	 edx, edx
  00070	74 56		 je	 SHORT $LN24@DinamicExp
  00072	8b 83 94 22 00
	00		 mov	 eax, DWORD PTR [ebx+8852]
  00078	8b cf		 mov	 ecx, edi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL7@DinamicExp:

; 336  : 	{
; 337  : 		GrandResetEXP list = this->DataExp[i];

  00080	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  00083	8b 39		 mov	 edi, DWORD PTR [ecx]
  00085	89 5d f8	 mov	 DWORD PTR _list$213810[ebp+4], ebx

; 338  : 
; 339  : 		if(lpUser->GReset == list.GrandReset)

  00088	0f bf df	 movsx	 ebx, di
  0008b	3b c3		 cmp	 eax, ebx
  0008d	74 14		 je	 SHORT $LN21@DinamicExp

; 333  : 	}
; 334  : 
; 335  : 	for(int i = 0; i < this->DataExp.size(); i++)

  0008f	46		 inc	 esi
  00090	83 c1 08	 add	 ecx, 8
  00093	3b f2		 cmp	 esi, edx
  00095	72 e9		 jb	 SHORT $LL7@DinamicExp

; 338  : 
; 339  : 		if(lpUser->GReset == list.GrandReset)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _Result$[ebp]
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	5f		 pop	 edi

; 353  : 			}
; 354  : 
; 355  : 			break;
; 356  : 		}
; 357  : 	}
; 358  : 
; 359  : 	return Result;
; 360  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
$LN21@DinamicExp:

; 340  : 		{
; 341  : 			if(list.TypeExp == false)

  000a3	8b c7		 mov	 eax, edi
  000a5	c1 e8 10	 shr	 eax, 16			; 00000010H
  000a8	84 c0		 test	 al, al
  000aa	75 19		 jne	 SHORT $LN3@DinamicExp

; 342  : 			{
; 343  : 				Result = Experience - list.MinusExp;

  000ac	8b 45 0c	 mov	 eax, DWORD PTR _Experience$[ebp]
  000af	2b 45 f8	 sub	 eax, DWORD PTR _list$213810[ebp+4]

; 344  : 
; 345  : 				if(Result < 1)

  000b2	83 f8 01	 cmp	 eax, 1
  000b5	7d 11		 jge	 SHORT $LN24@DinamicExp

; 346  : 				{
; 347  : 					Result = 1;

  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	5f		 pop	 edi

; 353  : 			}
; 354  : 
; 355  : 			break;
; 356  : 		}
; 357  : 	}
; 358  : 
; 359  : 	return Result;
; 360  : }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
$LN3@DinamicExp:

; 348  : 				}
; 349  : 			}
; 350  : 			else
; 351  : 			{
; 352  : 				Result = list.MinusExp;

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _list$213810[ebp+4]
$LN24@DinamicExp:
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
$LN12@DinamicExp:
  000ca	5f		 pop	 edi

; 353  : 			}
; 354  : 
; 355  : 			break;
; 356  : 		}
; 357  : 	}
; 358  : 
; 359  : 	return Result;
; 360  : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 08 00	 ret	 8
?DinamicExp@cGrandReset@@QAEHHH@Z ENDP			; cGrandReset::DinamicExp
_TEXT	ENDS
PUBLIC	??_C@_0CN@NMLOMMO@?$FLGReset?$FN?3?5You?5need?5Empty?5Invento@ ; `string'
PUBLIC	??_C@_0BM@CCOFCGNI@?$FLGReset?$FN?3?5Interface?5Disable?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCDialogInfo@cGrandReset@@QAEXH@Z		; cGrandReset::GCDialogInfo
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CN@NMLOMMO@?$FLGReset?$FN?3?5You?5need?5Empty?5Invento@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CN@NMLOMMO@?$FLGReset?$FN?3?5You?5need?5Empty?5Invento@ DB '[GRese'
	DB	't]: You need Empty Inventory to GReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CCOFCGNI@?$FLGReset?$FN?3?5Interface?5Disable?$AA@
CONST	SEGMENT
??_C@_0BM@CCOFCGNI@?$FLGReset?$FN?3?5Interface?5Disable?$AA@ DB '[GReset]'
	DB	': Interface Disable', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\grandreset.cpp
CONST	ENDS
;	COMDAT ?GCDialogInfo@cGrandReset@@QAEXH@Z
_TEXT	SEGMENT
_lpObj$ = -60						; size = 4
_aIndex$GSCopy$ = -56					; size = 4
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCDialogInfo@cGrandReset@@QAEXH@Z PROC			; cGrandReset::GCDialogInfo, COMDAT
; _this$ = ecx

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 386  : 	PMSG_GRAND_DIALOG pMsg;
; 387  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xA1, sizeof(pMsg));
; 388  : 	pMsg.Result = 1;
; 389  : 
; 390  : 	if(!this->EnableGrandResetSystem)

  00017	83 3e 00	 cmp	 DWORD PTR [esi], 0

; 523  : 	}
; 524  : 	#endif
; 525  : 
; 526  : 	#if(ENABLE_GRAND_NEEDITEM)
; 527  : 	// Need Item
; 528  : 	pMsg.AddEnableItem = false;

  0001a	89 5d c8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001d	c7 45 cc c1 30
	fb a1		 mov	 DWORD PTR _pMsg$[ebp], -1577373503 ; a1fb30c1H
  00024	c6 45 d0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  00028	0f 84 b5 03 00
	00		 je	 $LN42@GCDialogIn

; 391  : 		return;
; 392  : 
; 393  : 	LPOBJ lpObj = &gObj[aIndex];

  0002e	57		 push	 edi
  0002f	8b fb		 mov	 edi, ebx
  00031	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00037	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	89 7d c4	 mov	 DWORD PTR _lpObj$[ebp], edi

; 394  : 
; 395  : 	if ( (GetTickCount() - lpObj->MySelfDefenseTime ) < 60000)

  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00046	2b 87 1c 04 00
	00		 sub	 eax, DWORD PTR [edi+1052]
  0004c	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00051	73 3b		 jae	 SHORT $LN40@GCDialogIn

; 396  : 	{
; 397  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), lpObj->m_Index, 1);

  00053	8b 07		 mov	 eax, DWORD PTR [edi]
  00055	6a 01		 push	 1
  00057	50		 push	 eax
  00058	68 6d 04 00 00	 push	 1133			; 0000046dH
  0005d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00062	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 398  : 		GCCloseMsgSend(aIndex,-1); //Season 2.5 add-on

  0006d	68 ff 00 00 00	 push	 255			; 000000ffH
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00078	83 c4 14	 add	 esp, 20			; 00000014H
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx

; 584  : }

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
$LN40@GCDialogIn:

; 399  : 		return;
; 400  : 	}
; 401  : 
; 402  : 	if(lpObj->SkillRecallParty_Time != 0)

  0008e	66 83 bf 74 12
	00 00 00	 cmp	 WORD PTR [edi+4724], 0
  00096	0f 85 46 03 00
	00		 jne	 $LN60@GCDialogIn

; 403  : 	{
; 404  : 		return;
; 405  : 	}
; 406  : 
; 407  : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  0009c	57		 push	 edi
  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000a2	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000a7	85 c0		 test	 eax, eax
  000a9	75 14		 jne	 SHORT $LN38@GCDialogIn

; 408  : 	{
; 409  : 		GCServerMsgStringSend("[GReset]: Interface Disable",lpObj->m_Index,1);

  000ab	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000ad	6a 01		 push	 1
  000af	51		 push	 ecx
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CCOFCGNI@?$FLGReset?$FN?3?5Interface?5Disable?$AA@
  000b5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 410  : 		return;

  000ba	e9 20 03 00 00	 jmp	 $LN61@GCDialogIn
$LN38@GCDialogIn:

; 411  : 	}
; 412  : 
; 413  : 	//Проверка на максимальное количество ресето?
; 414  : 	pMsg.GrandNum = lpObj->GReset;

  000bf	66 8b 97 94 22
	00 00		 mov	 dx, WORD PTR [edi+8852]

; 415  : 	pMsg.GrandMax = this->MaxGrandRes;

  000c6	66 8b 46 04	 mov	 ax, WORD PTR [esi+4]
  000ca	66 89 55 d2	 mov	 WORD PTR _pMsg$[ebp+6], dx
  000ce	66 89 45 d4	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 416  : 
; 417  : 	if(lpObj->GReset >= this->MaxGrandRes)

  000d2	8b 8f 94 22 00
	00		 mov	 ecx, DWORD PTR [edi+8852]
  000d8	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  000db	7c 04		 jl	 SHORT $LN37@GCDialogIn

; 418  : 	{
; 419  : 		//MsgNormal(aIndex,"[GReset]: Max Grand Reset %d",this->MaxGrandRes);
; 420  : 		pMsg.Result = 0;

  000dd	c6 45 d0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN37@GCDialogIn:

; 421  : 	}
; 422  : 	
; 423  : 	//Проверка на Ресе?
; 424  : 	pMsg.NeedReset = this->NeedRes;

  000e1	66 8b 56 10	 mov	 dx, WORD PTR [esi+16]

; 425  : 
; 426  : 	if(this->NeedRes > lpObj->Reset)

  000e5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e8	66 89 55 d6	 mov	 WORD PTR _pMsg$[ebp+10], dx
  000ec	3b 87 90 22 00
	00		 cmp	 eax, DWORD PTR [edi+8848]
  000f2	7e 04		 jle	 SHORT $LN36@GCDialogIn

; 427  : 	{
; 428  : 		//MsgNormal(aIndex,"[GReset]: You need above %d Reset to GReset",this->NeedLevel);
; 429  : 		pMsg.Result = 0;

  000f4	c6 45 d0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN36@GCDialogIn:

; 430  : 	}
; 431  : 
; 432  : 	//Проверка на уровен?
; 433  : 	pMsg.NeedLevel = this->NeedLevel;

  000f8	66 8b 4e 14	 mov	 cx, WORD PTR [esi+20]
  000fc	66 89 4d d8	 mov	 WORD PTR _pMsg$[ebp+12], cx

; 434  : 
; 435  : 	if(this->NeedLevel > lpObj->Level)

  00100	0f bf 97 be 00
	00 00		 movsx	 edx, WORD PTR [edi+190]
  00107	39 56 14	 cmp	 DWORD PTR [esi+20], edx
  0010a	7e 04		 jle	 SHORT $LN35@GCDialogIn

; 436  : 	{
; 437  : 		//MsgNormal(aIndex,"[GReset]: You need above %d Level to GReset",this->NeedLevel);
; 438  : 		pMsg.Result = 0;

  0010c	c6 45 d0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN35@GCDialogIn:

; 439  : 	}
; 440  : 	int ZenMoney = 0;
; 441  : 
; 442  : 	//Проверка на зе?
; 443  : 	switch(this->ZenForm)

  00110	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00113	8b ca		 mov	 ecx, edx
  00115	33 c0		 xor	 eax, eax
  00117	49		 dec	 ecx
  00118	74 08		 je	 SHORT $LN32@GCDialogIn
  0011a	49		 dec	 ecx
  0011b	75 10		 jne	 SHORT $LN33@GCDialogIn

; 446  : 		case 2: ZenMoney = this->NeedZen; break;

  0011d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00120	eb 0b		 jmp	 SHORT $LN33@GCDialogIn
$LN32@GCDialogIn:

; 444  : 	{
; 445  : 		case 1: ZenMoney = this->NeedZen * ( lpObj->GReset + 1 ); break;

  00122	8b 87 94 22 00
	00		 mov	 eax, DWORD PTR [edi+8852]
  00128	40		 inc	 eax
  00129	0f af 46 0c	 imul	 eax, DWORD PTR [esi+12]
$LN33@GCDialogIn:

; 447  : 	}
; 448  : 	
; 449  : 	pMsg.NeedMoney = ZenMoney;

  0012d	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 450  : 
; 451  : 	if(this->ZenForm != 0)

  00130	85 d2		 test	 edx, edx
  00132	74 0c		 je	 SHORT $LN29@GCDialogIn

; 452  : 	{
; 453  : 		if(lpObj->Money < ZenMoney)

  00134	39 87 f0 00 00
	00		 cmp	 DWORD PTR [edi+240], eax
  0013a	7d 04		 jge	 SHORT $LN29@GCDialogIn

; 454  : 		{
; 455  : 			//MsgNormal(aIndex,"[GReset]: You need above %d Zen to GReset",ZenMoney);
; 456  : 			pMsg.Result = 0;

  0013c	c6 45 d0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN29@GCDialogIn:

; 457  : 		}
; 458  : 	}
; 459  : 
; 460  : 	//Проверка на пустой инвентар?
; 461  : 	if(this->NeedEmptyInv)

  00140	83 c9 ff	 or	 ecx, -1
  00143	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00147	0f 84 90 00 00
	00		 je	 $LN27@GCDialogIn

; 462  : 	{
; 463  : 		if(lpObj->pInventory[0].m_Type != -1 || lpObj->pInventory[1].m_Type != -1 || lpObj->pInventory[2].m_Type != -1 ||
; 464  : 		   lpObj->pInventory[3].m_Type != -1 || lpObj->pInventory[4].m_Type != -1 || lpObj->pInventory[5].m_Type != -1 ||
; 465  : 		   lpObj->pInventory[6].m_Type != -1 || lpObj->pInventory[7].m_Type != -1 || lpObj->pInventory[8].m_Type != -1 ||
; 466  : 		   lpObj->pInventory[9].m_Type != -1 || lpObj->pInventory[10].m_Type != -1|| lpObj->pInventory[11].m_Type != -1)

  0014d	8b 87 24 0e 00
	00		 mov	 eax, DWORD PTR [edi+3620]
  00153	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  00157	75 63		 jne	 SHORT $LN26@GCDialogIn
  00159	66 39 88 da 00
	00 00		 cmp	 WORD PTR [eax+218], cx
  00160	75 5a		 jne	 SHORT $LN26@GCDialogIn
  00162	66 39 88 ae 01
	00 00		 cmp	 WORD PTR [eax+430], cx
  00169	75 51		 jne	 SHORT $LN26@GCDialogIn
  0016b	66 39 88 82 02
	00 00		 cmp	 WORD PTR [eax+642], cx
  00172	75 48		 jne	 SHORT $LN26@GCDialogIn
  00174	66 39 88 56 03
	00 00		 cmp	 WORD PTR [eax+854], cx
  0017b	75 3f		 jne	 SHORT $LN26@GCDialogIn
  0017d	66 39 88 2a 04
	00 00		 cmp	 WORD PTR [eax+1066], cx
  00184	75 36		 jne	 SHORT $LN26@GCDialogIn
  00186	66 39 88 fe 04
	00 00		 cmp	 WORD PTR [eax+1278], cx
  0018d	75 2d		 jne	 SHORT $LN26@GCDialogIn
  0018f	66 39 88 d2 05
	00 00		 cmp	 WORD PTR [eax+1490], cx
  00196	75 24		 jne	 SHORT $LN26@GCDialogIn
  00198	66 39 88 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], cx
  0019f	75 1b		 jne	 SHORT $LN26@GCDialogIn
  001a1	66 39 88 7a 07
	00 00		 cmp	 WORD PTR [eax+1914], cx
  001a8	75 12		 jne	 SHORT $LN26@GCDialogIn
  001aa	66 39 88 4e 08
	00 00		 cmp	 WORD PTR [eax+2126], cx
  001b1	75 09		 jne	 SHORT $LN26@GCDialogIn
  001b3	66 39 88 22 09
	00 00		 cmp	 WORD PTR [eax+2338], cx
  001ba	74 21		 je	 SHORT $LN27@GCDialogIn
$LN26@GCDialogIn:

; 467  : 		{
; 468  : 			MsgNormal(aIndex,"[GReset]: You need Empty Inventory to GReset");

  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@NMLOMMO@?$FLGReset?$FN?3?5You?5need?5Empty?5Invento@
  001c1	53		 push	 ebx
  001c2	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  001c7	83 c4 08	 add	 esp, 8
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx

; 584  : }

  001cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d0	33 cd		 xor	 ecx, ebp
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 04 00	 ret	 4
$LN27@GCDialogIn:

; 469  : 			pMsg.Result = 0;
; 470  : 			return;
; 471  : 		}
; 472  : 	}
; 473  : 
; 474  : 	//Поинта за гран?ресе?
; 475  : 	pMsg.RewardPoint = 0;
; 476  : 
; 477  : 	if(this->AddForm == 1 || this->AddForm == 2)

  001dd	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001e0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+20], 0
  001e7	83 f8 01	 cmp	 eax, 1
  001ea	74 05		 je	 SHORT $LN24@GCDialogIn
  001ec	83 f8 02	 cmp	 eax, 2
  001ef	75 78		 jne	 SHORT $LN22@GCDialogIn
$LN24@GCDialogIn:

; 478  : 	{
; 479  : 		switch (lpObj->Class)

  001f1	0f b7 87 b8 00
	00 00		 movzx	 eax, WORD PTR [edi+184]
  001f8	83 f8 06	 cmp	 eax, 6
  001fb	77 6c		 ja	 SHORT $LN22@GCDialogIn
  001fd	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN63@GCDialogIn[eax*4]
$LN21@GCDialogIn:

; 480  : 		{
; 481  : 		case 0: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsDW;  break;

  00204	8b 87 94 22 00
	00		 mov	 eax, DWORD PTR [edi+8852]
  0020a	40		 inc	 eax
  0020b	0f af 46 1c	 imul	 eax, DWORD PTR [esi+28]
  0020f	eb 55		 jmp	 SHORT $LN62@GCDialogIn
$LN20@GCDialogIn:

; 482  : 		case 1: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsDK;  break;

  00211	8b 97 94 22 00
	00		 mov	 edx, DWORD PTR [edi+8852]
  00217	42		 inc	 edx
  00218	0f af 56 20	 imul	 edx, DWORD PTR [esi+32]
  0021c	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+20], edx
  0021f	eb 48		 jmp	 SHORT $LN22@GCDialogIn
$LN19@GCDialogIn:

; 483  : 		case 2: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsELF; break;

  00221	8b 87 94 22 00
	00		 mov	 eax, DWORD PTR [edi+8852]
  00227	40		 inc	 eax
  00228	0f af 46 24	 imul	 eax, DWORD PTR [esi+36]
  0022c	eb 38		 jmp	 SHORT $LN62@GCDialogIn
$LN18@GCDialogIn:

; 484  : 		case 3: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsMG;  break;

  0022e	8b 97 94 22 00
	00		 mov	 edx, DWORD PTR [edi+8852]
  00234	42		 inc	 edx
  00235	0f af 56 2c	 imul	 edx, DWORD PTR [esi+44]
  00239	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+20], edx
  0023c	eb 2b		 jmp	 SHORT $LN22@GCDialogIn
$LN17@GCDialogIn:

; 485  : 		case 4: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsDL;  break;

  0023e	8b 87 94 22 00
	00		 mov	 eax, DWORD PTR [edi+8852]
  00244	40		 inc	 eax
  00245	0f af 46 30	 imul	 eax, DWORD PTR [esi+48]
  00249	eb 1b		 jmp	 SHORT $LN62@GCDialogIn
$LN16@GCDialogIn:

; 486  : 		case 5: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsSUM; break;

  0024b	8b 97 94 22 00
	00		 mov	 edx, DWORD PTR [edi+8852]
  00251	42		 inc	 edx
  00252	0f af 56 28	 imul	 edx, DWORD PTR [esi+40]
  00256	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+20], edx
  00259	eb 0e		 jmp	 SHORT $LN22@GCDialogIn
$LN15@GCDialogIn:

; 487  : 		case 6: pMsg.RewardPoint = ( lpObj->GReset + 1 ) * this->AddPointsRF;  break;

  0025b	8b 87 94 22 00
	00		 mov	 eax, DWORD PTR [edi+8852]
  00261	40		 inc	 eax
  00262	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
$LN62@GCDialogIn:
  00266	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+20], eax
$LN22@GCDialogIn:

; 488  : 		}
; 489  : 	}
; 490  : 
; 491  : 	//if(this->AddForm == 3)
; 492  : 	//{
; 493  : 	//	lpObj->LevelUpPoint = 0;
; 494  : 	//}
; 495  : 	//else
; 496  : 	//{
; 497  : 	//	lpObj->LevelUpPoint += lpObj->ZtFreePoints;
; 498  : 	//}
; 499  : 
; 500  : 	//if(this->AddCredits>0)
; 501  : 	//{
; 502  : 	//	lpObj->ZtCred += AddCredits;
; 503  : 	//}
; 504  : 
; 505  : 	pMsg.RewardWCoin = this->AddWcoinC;
; 506  : 
; 507  : 	//if(this->AddWcoinC > 0)
; 508  : 	//{
; 509  : 	//	lpObj->GameShop.WCoinC += this->AddWcoinC;
; 510  : 	//}
; 511  : 	//if(this->AddWcoinP > 0)
; 512  : 	//{
; 513  : 	//	lpObj->GameShop.WCoinP += this->AddWcoinP;
; 514  : 	//}
; 515  : 	//if(this->AddGoblinPoint > 0)
; 516  : 	//{
; 517  : 	//	lpObj->GameShop.GoblinPoint += this->AddGoblinPoint;
; 518  : 	//}
; 519  : 	#if(ENABLE_GRAND_CREDIT)
; 520  : 	if(this->AddCredits>0)

  00269	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0026c	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  0026f	89 55 e4	 mov	 DWORD PTR _pMsg$[ebp+24], edx
  00272	85 c0		 test	 eax, eax
  00274	7e 03		 jle	 SHORT $LN14@GCDialogIn

; 521  : 	{
; 522  : 		pMsg.RewardCredit = this->AddCredits;

  00276	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+28], eax
$LN14@GCDialogIn:

; 529  : 	pMsg.AddItem = -1;
; 530  : 	pMsg.AddItemLevel = 0;
; 531  : 	pMsg.AddItemSkill = 0;
; 532  : 	pMsg.AddItemLuck = 0;
; 533  : 	pMsg.AddItemOpt = 0;
; 534  : 	pMsg.AddItemExl = 0;
; 535  : 	pMsg.AddItemAnc = 0;
; 536  : 	pMsg.AddItemCount = 0;
; 537  : 
; 538  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  00279	8b 9e ec 00 00
	00		 mov	 ebx, DWORD PTR [esi+236]
  0027f	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+36], ecx
  00282	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  00288	2b cb		 sub	 ecx, ebx
  0028a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0028f	f7 e9		 imul	 ecx
  00291	03 d1		 add	 edx, ecx
  00293	c1 fa 04	 sar	 edx, 4
  00296	8b ca		 mov	 ecx, edx
  00298	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0029b	33 ff		 xor	 edi, edi
  0029d	03 ca		 add	 ecx, edx
  0029f	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp+32], 0
  002a3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+40], 0
  002aa	66 c7 45 f8 00
	00		 mov	 WORD PTR _pMsg$[ebp+44], 0
  002b0	c6 45 fa 00	 mov	 BYTE PTR _pMsg$[ebp+46], 0
  002b4	0f 84 98 00 00
	00		 je	 $LN59@GCDialogIn

; 523  : 	}
; 524  : 	#endif
; 525  : 
; 526  : 	#if(ENABLE_GRAND_NEEDITEM)
; 527  : 	// Need Item
; 528  : 	pMsg.AddEnableItem = false;

  002ba	8b 45 c4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002bd	8b 90 94 22 00
	00		 mov	 edx, DWORD PTR [eax+8852]
  002c3	42		 inc	 edx
  002c4	8b c3		 mov	 eax, ebx
$LL13@GCDialogIn:

; 539  : 	{
; 540  : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];
; 541  : 		if(nitem.ResetNum == (lpObj->GReset + 1))

  002c6	39 10		 cmp	 DWORD PTR [eax], edx
  002c8	74 0a		 je	 SHORT $LN56@GCDialogIn

; 529  : 	pMsg.AddItem = -1;
; 530  : 	pMsg.AddItemLevel = 0;
; 531  : 	pMsg.AddItemSkill = 0;
; 532  : 	pMsg.AddItemLuck = 0;
; 533  : 	pMsg.AddItemOpt = 0;
; 534  : 	pMsg.AddItemExl = 0;
; 535  : 	pMsg.AddItemAnc = 0;
; 536  : 	pMsg.AddItemCount = 0;
; 537  : 
; 538  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  002ca	47		 inc	 edi
  002cb	83 c0 1c	 add	 eax, 28			; 0000001cH
  002ce	3b f9		 cmp	 edi, ecx
  002d0	72 f4		 jb	 SHORT $LL13@GCDialogIn

; 539  : 	{
; 540  : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];
; 541  : 		if(nitem.ResetNum == (lpObj->GReset + 1))

  002d2	eb 7e		 jmp	 SHORT $LN59@GCDialogIn
$LN56@GCDialogIn:

; 542  : 		{
; 543  : 			pMsg.AddEnableItem = true;

  002d4	c6 45 ec 01	 mov	 BYTE PTR _pMsg$[ebp+32], 1

; 544  : 			pMsg.AddItem = ITEMGET(nitem.Type, nitem.Index);

  002d8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002db	c1 e1 09	 shl	 ecx, 9
  002de	03 48 08	 add	 ecx, DWORD PTR [eax+8]

; 545  : 			pMsg.AddItemLevel = nitem.Level;
; 546  : 			pMsg.AddItemSkill = nitem.Skill;
; 547  : 			pMsg.AddItemLuck = nitem.Luck;
; 548  : 			pMsg.AddItemOpt = nitem.Opt;
; 549  : 			pMsg.AddItemExl = nitem.Exl;
; 550  : 			pMsg.AddItemAnc = nitem.Anc;
; 551  : 			pMsg.AddItemCount = nitem.Count;
; 552  : 
; 553  : 			if(!this->SearchItem(aIndex, nitem.Type, nitem.Index, nitem.Level, nitem.Skill, nitem.Luck, nitem.Opt, nitem.Exl, nitem.Anc, nitem.Count, false))

  002e1	6a 00		 push	 0
  002e3	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+36], ecx
  002e6	0f b6 50 0c	 movzx	 edx, BYTE PTR [eax+12]
  002ea	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+40], dl
  002ed	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  002f1	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+41], cl
  002f4	0f b6 50 11	 movzx	 edx, BYTE PTR [eax+17]
  002f8	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+42], dl
  002fb	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  002ff	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+43], cl
  00302	0f b6 50 13	 movzx	 edx, BYTE PTR [eax+19]
  00306	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+44], dl
  00309	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  0030d	88 4d f9	 mov	 BYTE PTR _pMsg$[ebp+45], cl
  00310	0f b6 50 18	 movzx	 edx, BYTE PTR [eax+24]
  00314	88 55 fa	 mov	 BYTE PTR _pMsg$[ebp+46], dl
  00317	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0031a	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  0031e	51		 push	 ecx
  0031f	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00323	52		 push	 edx
  00324	0f b6 50 12	 movzx	 edx, BYTE PTR [eax+18]
  00328	51		 push	 ecx
  00329	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  0032d	52		 push	 edx
  0032e	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  00332	51		 push	 ecx
  00333	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00336	52		 push	 edx
  00337	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0033a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0033d	51		 push	 ecx
  0033e	8b 4d c8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00341	52		 push	 edx
  00342	50		 push	 eax
  00343	51		 push	 ecx
  00344	8b ce		 mov	 ecx, esi
  00346	e8 00 00 00 00	 call	 ?SearchItem@cGrandReset@@QAE_NHHHH_N0000H0@Z ; cGrandReset::SearchItem
  0034b	84 c0		 test	 al, al
  0034d	75 03		 jne	 SHORT $LN59@GCDialogIn

; 554  : 			{
; 555  : 				pMsg.Result = false;

  0034f	88 45 d0	 mov	 BYTE PTR _pMsg$[ebp+4], al
$LN59@GCDialogIn:

; 556  : 			}
; 557  : 
; 558  : 			break;
; 559  : 		}
; 560  : 	}
; 561  : 	#endif
; 562  : 
; 563  : 	if(g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2))

  00352	6a 00		 push	 0
  00354	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00359	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0035e	84 c0		 test	 al, al
  00360	75 20		 jne	 SHORT $LN7@GCDialogIn
  00362	6a 30		 push	 48			; 00000030H
  00364	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00369	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0036e	84 c0		 test	 al, al
  00370	75 10		 jne	 SHORT $LN7@GCDialogIn
  00372	6a 31		 push	 49			; 00000031H
  00374	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00379	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0037e	84 c0		 test	 al, al
  00380	74 4b		 je	 SHORT $LN4@GCDialogIn
$LN7@GCDialogIn:

; 564  : 	{
; 565  : 		//reward Item
; 566  : 		for(int i = 0; i < this->m_reward.size(); i++)

  00382	8b be dc 00 00
	00		 mov	 edi, DWORD PTR [esi+220]
  00388	8b b6 e0 00 00
	00		 mov	 esi, DWORD PTR [esi+224]
  0038e	2b f7		 sub	 esi, edi
  00390	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00395	f7 ee		 imul	 esi
  00397	c1 fa 03	 sar	 edx, 3
  0039a	8b ca		 mov	 ecx, edx
  0039c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0039f	03 ca		 add	 ecx, edx
  003a1	74 2a		 je	 SHORT $LN4@GCDialogIn
  003a3	8b c7		 mov	 eax, edi
$LL6@GCDialogIn:

; 567  : 		{
; 568  : 			GRANDSYSTEM_REWARD_DATA & ritem = this->m_reward[i];
; 569  : 			if(ritem.ResetNum == (lpObj->GReset + 1))

  003a5	8b 55 c4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003a8	8b 92 94 22 00
	00		 mov	 edx, DWORD PTR [edx+8852]
  003ae	42		 inc	 edx
  003af	39 10		 cmp	 DWORD PTR [eax], edx
  003b1	75 14		 jne	 SHORT $LN5@GCDialogIn

; 570  : 			{
; 571  : 				if(ritem.WcoinC > 0)

  003b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003b6	85 d2		 test	 edx, edx
  003b8	7e 03		 jle	 SHORT $LN2@GCDialogIn

; 572  : 				{
; 573  : 					pMsg.RewardWCoin = ritem.WcoinC;

  003ba	89 55 e4	 mov	 DWORD PTR _pMsg$[ebp+24], edx
$LN2@GCDialogIn:

; 574  : 				}
; 575  : 				if(ritem.Credit > 0)

  003bd	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  003c0	85 d2		 test	 edx, edx
  003c2	7e 03		 jle	 SHORT $LN5@GCDialogIn

; 576  : 				{
; 577  : 					pMsg.RewardCredit = ritem.Credit;

  003c4	89 55 e8	 mov	 DWORD PTR _pMsg$[ebp+28], edx
$LN5@GCDialogIn:

; 564  : 	{
; 565  : 		//reward Item
; 566  : 		for(int i = 0; i < this->m_reward.size(); i++)

  003c7	83 c0 24	 add	 eax, 36			; 00000024H
  003ca	49		 dec	 ecx
  003cb	75 d8		 jne	 SHORT $LL6@GCDialogIn
$LN4@GCDialogIn:

; 578  : 				}
; 579  : 			}
; 580  : 		}
; 581  : 	}
; 582  : 
; 583  : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003cd	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  003d1	8b 55 c8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  003d4	50		 push	 eax
  003d5	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  003d8	51		 push	 ecx
  003d9	52		 push	 edx
  003da	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
$LN61@GCDialogIn:
  003df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@GCDialogIn:
  003e2	5f		 pop	 edi
$LN42@GCDialogIn:

; 584  : }

  003e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e6	5e		 pop	 esi
  003e7	33 cd		 xor	 ecx, ebp
  003e9	5b		 pop	 ebx
  003ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ef	8b e5		 mov	 esp, ebp
  003f1	5d		 pop	 ebp
  003f2	c2 04 00	 ret	 4
  003f5	8d 49 00	 npad	 3
$LN63@GCDialogIn:
  003f8	00 00 00 00	 DD	 $LN21@GCDialogIn
  003fc	00 00 00 00	 DD	 $LN20@GCDialogIn
  00400	00 00 00 00	 DD	 $LN19@GCDialogIn
  00404	00 00 00 00	 DD	 $LN18@GCDialogIn
  00408	00 00 00 00	 DD	 $LN17@GCDialogIn
  0040c	00 00 00 00	 DD	 $LN16@GCDialogIn
  00410	00 00 00 00	 DD	 $LN15@GCDialogIn
?GCDialogInfo@cGrandReset@@QAEXH@Z ENDP			; cGrandReset::GCDialogInfo
_TEXT	ENDS
PUBLIC	??_C@_0CB@NBPJMHIN@?$FLGReset?$FN?3?5Need?5Grand?5Reset?5Items@ ; `string'
PUBLIC	??_C@_0CK@FCBCNAMG@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5@ ; `string'
PUBLIC	??_C@_0CM@HPMBDCHP@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Leve@ ; `string'
PUBLIC	??_C@_0CM@DHNDAPCF@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Rese@ ; `string'
PUBLIC	??_C@_0BN@NFJAONJC@?$FLGReset?$FN?3?5Max?5Grand?5Reset?5?$CFd?$AA@ ; `string'
PUBLIC	?CGGrandStart@cGrandReset@@QAEXH@Z		; cGrandReset::CGGrandStart
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
;	COMDAT ??_C@_0CB@NBPJMHIN@?$FLGReset?$FN?3?5Need?5Grand?5Reset?5Items@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CB@NBPJMHIN@?$FLGReset?$FN?3?5Need?5Grand?5Reset?5Items@ DB '[GRes'
	DB	'et]: Need Grand Reset Items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FCBCNAMG@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5@
CONST	SEGMENT
??_C@_0CK@FCBCNAMG@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5@ DB '['
	DB	'GReset]: You need above %d Zen to GReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HPMBDCHP@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Leve@
CONST	SEGMENT
??_C@_0CM@HPMBDCHP@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Leve@ DB '['
	DB	'GReset]: You need above %d Level to GReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DHNDAPCF@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Rese@
CONST	SEGMENT
??_C@_0CM@DHNDAPCF@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Rese@ DB '['
	DB	'GReset]: You need above %d Reset to GReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NFJAONJC@?$FLGReset?$FN?3?5Max?5Grand?5Reset?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@NFJAONJC@?$FLGReset?$FN?3?5Max?5Grand?5Reset?5?$CFd?$AA@ DB '[G'
	DB	'Reset]: Max Grand Reset %d', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\grandreset.cpp
CONST	ENDS
;	COMDAT ?CGGrandStart@cGrandReset@@QAEXH@Z
_TEXT	SEGMENT
tv1390 = -8						; size = 4
tv1385 = -8						; size = 4
tv1380 = -8						; size = 4
tv1206 = -8						; size = 4
tv1559 = -4						; size = 4
tv1400 = -4						; size = 4
tv1395 = -4						; size = 4
tv1155 = -4						; size = 4
tv1117 = -4						; size = 4
tv1108 = -4						; size = 4
tv1099 = -4						; size = 4
_ZenMoney$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CGGrandStart@cGrandReset@@QAEXH@Z PROC			; cGrandReset::CGGrandStart, COMDAT
; _this$ = ecx

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 588  : 	if(!this->EnableGrandResetSystem)

  00009	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0000c	0f 84 50 07 00
	00		 je	 $LN57@CGGrandSta

; 589  : 		return;
; 590  : 
; 591  : 	LPOBJ lpObj = &gObj[aIndex];

  00012	53		 push	 ebx
  00013	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00016	56		 push	 esi
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 592  : 
; 593  : 	if ( (GetTickCount() - lpObj->MySelfDefenseTime ) < 60000)

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002b	2b 86 1c 04 00
	00		 sub	 eax, DWORD PTR [esi+1052]
  00031	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00036	73 31		 jae	 SHORT $LN55@CGGrandSta

; 594  : 	{
; 595  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), lpObj->m_Index, 1);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	6a 01		 push	 1
  0003c	50		 push	 eax
  0003d	68 6d 04 00 00	 push	 1133			; 0000046dH
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00047	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 596  : 		GCCloseMsgSend(aIndex,-1); //Season 2.5 add-on

  00052	68 ff 00 00 00	 push	 255			; 000000ffH
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	5f		 pop	 edi

; 818  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
$LN55@CGGrandSta:

; 597  : 		return;
; 598  : 	}
; 599  : 
; 600  : 	if(lpObj->SkillRecallParty_Time != 0)

  00069	66 83 be 74 12
	00 00 00	 cmp	 WORD PTR [esi+4724], 0
  00071	0f 85 e9 06 00
	00		 jne	 $LN75@CGGrandSta

; 601  : 	{
; 602  : 		return;
; 603  : 	}
; 604  : 
; 605  : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  00077	56		 push	 esi
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0007d	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  00082	85 c0		 test	 eax, eax
  00084	75 1b		 jne	 SHORT $LN53@CGGrandSta

; 606  : 	{
; 607  : 		GCServerMsgStringSend("[GReset]: Interface Disable",lpObj->m_Index,1);

  00086	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00088	6a 01		 push	 1
  0008a	51		 push	 ecx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CCOFCGNI@?$FLGReset?$FN?3?5Interface?5Disable?$AA@
  00090	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	5f		 pop	 edi

; 818  : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN53@CGGrandSta:

; 608  : 		return;
; 609  : 	}
; 610  : 
; 611  : 	//Проверка на максимальное количество ресето?
; 612  : 	if(lpObj->GReset >= this->MaxGrandRes)

  000a1	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  000a7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000aa	3b d0		 cmp	 edx, eax
  000ac	7c 18		 jl	 SHORT $LN52@CGGrandSta

; 613  : 	{
; 614  : 		MsgNormal(aIndex,"[GReset]: Max Grand Reset %d",this->MaxGrandRes);

  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NFJAONJC@?$FLGReset?$FN?3?5Max?5Grand?5Reset?5?$CFd?$AA@
  000b4	53		 push	 ebx
  000b5	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	5f		 pop	 edi

; 818  : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 04 00	 ret	 4
$LN52@CGGrandSta:

; 615  : 		return;
; 616  : 	}
; 617  : 	
; 618  : 	//Проверка на Ресе?
; 619  : 	if(this->NeedRes > lpObj->Reset)

  000c6	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000c9	3b 86 90 22 00
	00		 cmp	 eax, DWORD PTR [esi+8848]
  000cf	7e 18		 jle	 SHORT $LN51@CGGrandSta

; 620  : 	{
; 621  : 		MsgNormal(aIndex,"[GReset]: You need above %d Reset to GReset",this->NeedRes);

  000d1	50		 push	 eax
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DHNDAPCF@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Rese@
  000d7	53		 push	 ebx
  000d8	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	5f		 pop	 edi

; 818  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
$LN51@CGGrandSta:

; 622  : 		return;
; 623  : 	}
; 624  : 	//Проверка на уровен?
; 625  : 	if(this->NeedLevel > lpObj->Level)

  000e9	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  000f0	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  000f3	3b c1		 cmp	 eax, ecx
  000f5	7e 18		 jle	 SHORT $LN50@CGGrandSta

; 626  : 	{
; 627  : 		MsgNormal(aIndex,"[GReset]: You need above %d Level to GReset",this->NeedLevel);

  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HPMBDCHP@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Leve@
  000fd	53		 push	 ebx
  000fe	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	5f		 pop	 edi

; 818  : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
$LN50@CGGrandSta:

; 628  : 		return;
; 629  : 	}
; 630  : 	int ZenMoney = 0;
; 631  : 	//Проверка на зе?
; 632  : 	switch(this->ZenForm)

  0010f	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00112	8b c1		 mov	 eax, ecx
  00114	48		 dec	 eax
  00115	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ZenMoney$[ebp], 0
  0011c	74 0b		 je	 SHORT $LN47@CGGrandSta
  0011e	48		 dec	 eax
  0011f	75 12		 jne	 SHORT $LN48@CGGrandSta

; 635  : 		case 2: ZenMoney = this->NeedZen; break;

  00121	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00124	89 55 fc	 mov	 DWORD PTR _ZenMoney$[ebp], edx
  00127	eb 0a		 jmp	 SHORT $LN48@CGGrandSta
$LN47@CGGrandSta:

; 633  : 	{
; 634  : 		case 1: ZenMoney = this->NeedZen * ( lpObj->GReset + 1 ); break;

  00129	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0012c	0f af 47 0c	 imul	 eax, DWORD PTR [edi+12]
  00130	89 45 fc	 mov	 DWORD PTR _ZenMoney$[ebp], eax
$LN48@CGGrandSta:

; 636  : 	}
; 637  : 	
; 638  : 	if(this->ZenForm != 0)

  00133	85 c9		 test	 ecx, ecx
  00135	74 23		 je	 SHORT $LN44@CGGrandSta

; 639  : 	{
; 640  : 		if(lpObj->Money < ZenMoney)

  00137	8b 45 fc	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  0013a	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  00140	7d 18		 jge	 SHORT $LN44@CGGrandSta

; 641  : 		{
; 642  : 			MsgNormal(aIndex,"[GReset]: You need above %d Zen to GReset",ZenMoney);

  00142	50		 push	 eax
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FCBCNAMG@?$FLGReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5@
  00148	53		 push	 ebx
  00149	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	5f		 pop	 edi

; 818  : }

  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 04 00	 ret	 4
$LN44@CGGrandSta:

; 643  : 			return;
; 644  : 		}
; 645  : 	}
; 646  : 	//Проверка на пустой инвентар?
; 647  : 	if(this->NeedEmptyInv)

  0015a	83 7f 38 00	 cmp	 DWORD PTR [edi+56], 0
  0015e	0f 84 89 00 00
	00		 je	 $LN42@CGGrandSta

; 648  : 	{
; 649  : 		if(lpObj->pInventory[0].m_Type != -1 || lpObj->pInventory[1].m_Type != -1 || lpObj->pInventory[2].m_Type != -1 ||
; 650  : 		   lpObj->pInventory[3].m_Type != -1 || lpObj->pInventory[4].m_Type != -1 || lpObj->pInventory[5].m_Type != -1 ||
; 651  : 		   lpObj->pInventory[6].m_Type != -1 || lpObj->pInventory[7].m_Type != -1 || lpObj->pInventory[8].m_Type != -1 ||
; 652  : 		   lpObj->pInventory[9].m_Type != -1 || lpObj->pInventory[10].m_Type != -1|| lpObj->pInventory[11].m_Type != -1)

  00164	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  0016a	83 c9 ff	 or	 ecx, -1
  0016d	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  00171	75 63		 jne	 SHORT $LN41@CGGrandSta
  00173	66 39 88 da 00
	00 00		 cmp	 WORD PTR [eax+218], cx
  0017a	75 5a		 jne	 SHORT $LN41@CGGrandSta
  0017c	66 39 88 ae 01
	00 00		 cmp	 WORD PTR [eax+430], cx
  00183	75 51		 jne	 SHORT $LN41@CGGrandSta
  00185	66 39 88 82 02
	00 00		 cmp	 WORD PTR [eax+642], cx
  0018c	75 48		 jne	 SHORT $LN41@CGGrandSta
  0018e	66 39 88 56 03
	00 00		 cmp	 WORD PTR [eax+854], cx
  00195	75 3f		 jne	 SHORT $LN41@CGGrandSta
  00197	66 39 88 2a 04
	00 00		 cmp	 WORD PTR [eax+1066], cx
  0019e	75 36		 jne	 SHORT $LN41@CGGrandSta
  001a0	66 39 88 fe 04
	00 00		 cmp	 WORD PTR [eax+1278], cx
  001a7	75 2d		 jne	 SHORT $LN41@CGGrandSta
  001a9	66 39 88 d2 05
	00 00		 cmp	 WORD PTR [eax+1490], cx
  001b0	75 24		 jne	 SHORT $LN41@CGGrandSta
  001b2	66 39 88 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], cx
  001b9	75 1b		 jne	 SHORT $LN41@CGGrandSta
  001bb	66 39 88 7a 07
	00 00		 cmp	 WORD PTR [eax+1914], cx
  001c2	75 12		 jne	 SHORT $LN41@CGGrandSta
  001c4	66 39 88 4e 08
	00 00		 cmp	 WORD PTR [eax+2126], cx
  001cb	75 09		 jne	 SHORT $LN41@CGGrandSta
  001cd	66 39 88 22 09
	00 00		 cmp	 WORD PTR [eax+2338], cx
  001d4	74 17		 je	 SHORT $LN42@CGGrandSta
$LN41@CGGrandSta:

; 653  : 		{
; 654  : 			MsgNormal(aIndex,"[GReset]: You need Empty Inventory to GReset");

  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@NMLOMMO@?$FLGReset?$FN?3?5You?5need?5Empty?5Invento@
  001db	53		 push	 ebx
  001dc	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  001e1	83 c4 08	 add	 esp, 8
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
  001e6	5f		 pop	 edi

; 818  : }

  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c2 04 00	 ret	 4
$LN42@CGGrandSta:

; 655  : 			return;
; 656  : 		}
; 657  : 	}
; 658  : 
; 659  : 	#if(ENABLE_GRAND_NEEDITEM)
; 660  : 	// Need Item
; 661  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  001ed	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
  001f3	2b 8f ec 00 00
	00		 sub	 ecx, DWORD PTR [edi+236]
  001f9	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001fe	f7 e9		 imul	 ecx
  00200	03 d1		 add	 edx, ecx
  00202	c1 fa 04	 sar	 edx, 4
  00205	8b ca		 mov	 ecx, edx
  00207	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0020a	33 db		 xor	 ebx, ebx
  0020c	03 ca		 add	 ecx, edx
  0020e	74 20		 je	 SHORT $LN73@CGGrandSta
  00210	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  00216	8b 87 ec 00 00
	00		 mov	 eax, DWORD PTR [edi+236]
  0021c	42		 inc	 edx
  0021d	8d 49 00	 npad	 3
$LL40@CGGrandSta:

; 662  : 	{
; 663  : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];
; 664  : 		if(nitem.ResetNum == (lpObj->GReset + 1))

  00220	39 10		 cmp	 DWORD PTR [eax], edx
  00222	0f 84 8e 00 00
	00		 je	 $LN69@CGGrandSta

; 655  : 			return;
; 656  : 		}
; 657  : 	}
; 658  : 
; 659  : 	#if(ENABLE_GRAND_NEEDITEM)
; 660  : 	// Need Item
; 661  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  00228	43		 inc	 ebx
  00229	83 c0 1c	 add	 eax, 28			; 0000001cH
  0022c	3b d9		 cmp	 ebx, ecx
  0022e	72 f0		 jb	 SHORT $LL40@CGGrandSta
$LN73@CGGrandSta:

; 669  : 				return;
; 670  : 			}
; 671  : 			break;
; 672  : 		}
; 673  : 	}
; 674  : 	#endif
; 675  : 
; 676  : 	/////////////////////
; 677  : 	//Выполнение Гран?ресета//
; 678  : 	/////////////////////
; 679  : 	lpObj->Money -= ZenMoney;

  00230	8b 4d fc	 mov	 ecx, DWORD PTR _ZenMoney$[ebp]
  00233	29 8e f0 00 00
	00		 sub	 DWORD PTR [esi+240], ecx

; 680  : 	lpObj->Level = 1;
; 681  : 	lpObj->Experience = 0;

  00239	33 db		 xor	 ebx, ebx
  0023b	ba 01 00 00 00	 mov	 edx, 1
  00240	66 89 96 be 00
	00 00		 mov	 WORD PTR [esi+190], dx
  00247	89 9e c8 00 00
	00		 mov	 DWORD PTR [esi+200], ebx

; 682  : 	lpObj->NextExp = 100;

  0024d	c7 86 cc 00 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+204], 100 ; 00000064H

; 683  : 	if(this->AddForm == 2 || this->AddForm == 3)

  00257	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0025a	83 f8 02	 cmp	 eax, 2
  0025d	74 05		 je	 SHORT $LN34@CGGrandSta
  0025f	83 f8 03	 cmp	 eax, 3
  00262	75 2a		 jne	 SHORT $LN33@CGGrandSta
$LN34@CGGrandSta:

; 684  : 	{
; 685  : 		lpObj->Strength = 25;
; 686  : 		lpObj->Dexterity = 25;
; 687  : 		lpObj->Vitality = 25;
; 688  : 		lpObj->Energy = 25;
; 689  : 		if(lpObj->Class == 4)

  00264	66 83 be b8 00
	00 00 04	 cmp	 WORD PTR [esi+184], 4
  0026c	c7 86 f4 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+244], 1638425 ; 00190019H
  00276	c7 86 f8 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+248], 1638425 ; 00190019H
  00280	75 0c		 jne	 SHORT $LN33@CGGrandSta

; 690  : 		{
; 691  : 			lpObj->Leadership = 25;

  00282	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00287	66 89 8e 18 01
	00 00		 mov	 WORD PTR [esi+280], cx
$LN33@CGGrandSta:

; 692  : 		}
; 693  : 	}
; 694  : 	//Поинта за гран?ресе?
; 695  : 	if(this->AddForm == 1 || this->AddForm == 2)

  0028e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00291	83 f8 01	 cmp	 eax, 1
  00294	74 09		 je	 SHORT $LN31@CGGrandSta
  00296	83 f8 02	 cmp	 eax, 2
  00299	0f 85 e3 00 00
	00		 jne	 $LN29@CGGrandSta
$LN31@CGGrandSta:

; 696  : 	{
; 697  : 		switch (lpObj->Class)

  0029f	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  002a6	83 f8 06	 cmp	 eax, 6
  002a9	0f 87 d3 00 00
	00		 ja	 $LN29@CGGrandSta
  002af	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN78@CGGrandSta[eax*4]
$LN69@CGGrandSta:

; 665  : 		{
; 666  : 			if(!this->SearchItem(aIndex, nitem.Type, nitem.Index, nitem.Level, nitem.Skill, nitem.Luck, nitem.Opt, nitem.Exl, nitem.Anc, nitem.Count, true))

  002b6	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002b9	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  002bd	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  002c0	6a 01		 push	 1
  002c2	51		 push	 ecx
  002c3	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  002c7	52		 push	 edx
  002c8	0f b6 50 12	 movzx	 edx, BYTE PTR [eax+18]
  002cc	51		 push	 ecx
  002cd	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  002d1	52		 push	 edx
  002d2	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  002d6	51		 push	 ecx
  002d7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002da	52		 push	 edx
  002db	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002de	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e1	51		 push	 ecx
  002e2	52		 push	 edx
  002e3	50		 push	 eax
  002e4	53		 push	 ebx
  002e5	8b cf		 mov	 ecx, edi
  002e7	e8 00 00 00 00	 call	 ?SearchItem@cGrandReset@@QAE_NHHHH_N0000H0@Z ; cGrandReset::SearchItem
  002ec	84 c0		 test	 al, al
  002ee	0f 85 3c ff ff
	ff		 jne	 $LN73@CGGrandSta

; 667  : 			{
; 668  : 				MsgNormal(aIndex,"[GReset]: Need Grand Reset Items");

  002f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NBPJMHIN@?$FLGReset?$FN?3?5Need?5Grand?5Reset?5Items@
  002f9	53		 push	 ebx
  002fa	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  002ff	83 c4 08	 add	 esp, 8
  00302	5e		 pop	 esi
  00303	5b		 pop	 ebx
  00304	5f		 pop	 edi

; 818  : }

  00305	8b e5		 mov	 esp, ebp
  00307	5d		 pop	 ebp
  00308	c2 04 00	 ret	 4
$LN28@CGGrandSta:

; 698  : 		{
; 699  : 			case 0: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsDW ;  break;

  0030b	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  00311	42		 inc	 edx
  00312	0f af 57 1c	 imul	 edx, DWORD PTR [edi+28]
  00316	eb 64		 jmp	 SHORT $LN77@CGGrandSta
$LN27@CGGrandSta:

; 700  : 			case 1: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsDK ;  break;

  00318	8b 86 94 22 00
	00		 mov	 eax, DWORD PTR [esi+8852]
  0031e	40		 inc	 eax
  0031f	0f af 47 20	 imul	 eax, DWORD PTR [edi+32]
  00323	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
  00329	eb 57		 jmp	 SHORT $LN29@CGGrandSta
$LN26@CGGrandSta:

; 701  : 			case 2: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsELF ; break;

  0032b	8b 8e 94 22 00
	00		 mov	 ecx, DWORD PTR [esi+8852]
  00331	41		 inc	 ecx
  00332	0f af 4f 24	 imul	 ecx, DWORD PTR [edi+36]
  00336	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx
  0033c	eb 44		 jmp	 SHORT $LN29@CGGrandSta
$LN25@CGGrandSta:

; 702  : 			case 3: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsMG ;  break;

  0033e	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  00344	42		 inc	 edx
  00345	0f af 57 2c	 imul	 edx, DWORD PTR [edi+44]
  00349	eb 31		 jmp	 SHORT $LN77@CGGrandSta
$LN24@CGGrandSta:

; 703  : 			case 4: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsDL ;  break;

  0034b	8b 86 94 22 00
	00		 mov	 eax, DWORD PTR [esi+8852]
  00351	40		 inc	 eax
  00352	0f af 47 30	 imul	 eax, DWORD PTR [edi+48]
  00356	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
  0035c	eb 24		 jmp	 SHORT $LN29@CGGrandSta
$LN23@CGGrandSta:

; 704  : 			case 5: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsSUM ; break;

  0035e	8b 8e 94 22 00
	00		 mov	 ecx, DWORD PTR [esi+8852]
  00364	41		 inc	 ecx
  00365	0f af 4f 28	 imul	 ecx, DWORD PTR [edi+40]
  00369	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx
  0036f	eb 11		 jmp	 SHORT $LN29@CGGrandSta
$LN22@CGGrandSta:

; 705  : 			case 6: lpObj->LevelUpPoint = ( lpObj->GReset + 1 ) * this->AddPointsRF ; break;

  00371	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  00377	42		 inc	 edx
  00378	0f af 57 34	 imul	 edx, DWORD PTR [edi+52]
$LN77@CGGrandSta:
  0037c	89 96 c0 00 00
	00		 mov	 DWORD PTR [esi+192], edx
$LN29@CGGrandSta:

; 706  : 		}
; 707  : 	}
; 708  : 	if(this->AddForm == 3)

  00382	83 7f 18 03	 cmp	 DWORD PTR [edi+24], 3
  00386	75 08		 jne	 SHORT $LN21@CGGrandSta

; 709  : 	{
; 710  : 		lpObj->LevelUpPoint = 0;

  00388	89 9e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ebx

; 711  : 	}
; 712  : 	else

  0038e	eb 0c		 jmp	 SHORT $LN20@CGGrandSta
$LN21@CGGrandSta:

; 713  : 	{
; 714  : 		lpObj->LevelUpPoint += lpObj->ZtFreePoints;

  00390	8b 86 8c 22 00
	00		 mov	 eax, DWORD PTR [esi+8844]
  00396	01 86 c0 00 00
	00		 add	 DWORD PTR [esi+192], eax
$LN20@CGGrandSta:

; 715  : 	}
; 716  : 	
; 717  : 	lpObj->Reset = 0;
; 718  : 	lpObj->GReset += 1;

  0039c	ff 86 94 22 00
	00		 inc	 DWORD PTR [esi+8852]
  003a2	89 9e 90 22 00
	00		 mov	 DWORD PTR [esi+8848], ebx

; 719  : 
; 720  : 	if(this->AddCredits > 0)

  003a8	39 5f 3c	 cmp	 DWORD PTR [edi+60], ebx
  003ab	7e 2a		 jle	 SHORT $LN17@CGGrandSta

; 721  : 	{
; 722  : 		if(g_ZtLicense.CheckUser(eZtUB::NSGames))

  003ad	6a 51		 push	 81			; 00000051H
  003af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003b4	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003b9	84 c0		 test	 al, al
  003bb	74 0b		 je	 SHORT $LN18@CGGrandSta

; 723  : 		{
; 724  : 			lpObj->PCPoint += this->AddCredits;	

  003bd	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  003c0	01 8e 88 22 00
	00		 add	 DWORD PTR [esi+8840], ecx

; 725  : 		}
; 726  : 		else

  003c6	eb 0f		 jmp	 SHORT $LN17@CGGrandSta
$LN18@CGGrandSta:

; 727  : 		{
; 728  : 			lpObj->ZtCred += this->AddCredits;		

  003c8	db 47 3c	 fild	 DWORD PTR [edi+60]
  003cb	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  003d1	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
$LN17@CGGrandSta:

; 729  : 		}
; 730  : 	}
; 731  : 
; 732  : 	if(this->AddWcoinC > 0)

  003d7	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  003da	89 45 fc	 mov	 DWORD PTR tv1099[ebp], eax
  003dd	3b c3		 cmp	 eax, ebx
  003df	7e 0f		 jle	 SHORT $LN16@CGGrandSta

; 733  : 	{
; 734  : 		lpObj->GameShop.WCoinC += this->AddWcoinC;

  003e1	db 45 fc	 fild	 DWORD PTR tv1099[ebp]
  003e4	dc 86 00 23 00
	00		 fadd	 QWORD PTR [esi+8960]
  003ea	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
$LN16@CGGrandSta:

; 735  : 	}
; 736  : 	if(this->AddWcoinP > 0)

  003f0	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  003f3	89 45 fc	 mov	 DWORD PTR tv1108[ebp], eax
  003f6	3b c3		 cmp	 eax, ebx
  003f8	7e 0f		 jle	 SHORT $LN15@CGGrandSta

; 737  : 	{
; 738  : 		lpObj->GameShop.WCoinP += this->AddWcoinP;

  003fa	db 45 fc	 fild	 DWORD PTR tv1108[ebp]
  003fd	dc 86 f8 22 00
	00		 fadd	 QWORD PTR [esi+8952]
  00403	dd 9e f8 22 00
	00		 fstp	 QWORD PTR [esi+8952]
$LN15@CGGrandSta:

; 739  : 	}
; 740  : 	if(this->AddGoblinPoint > 0)

  00409	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0040c	89 45 fc	 mov	 DWORD PTR tv1117[ebp], eax
  0040f	3b c3		 cmp	 eax, ebx
  00411	7e 0f		 jle	 SHORT $LN14@CGGrandSta

; 741  : 	{
; 742  : 		lpObj->GameShop.GoblinPoint += this->AddGoblinPoint;

  00413	db 45 fc	 fild	 DWORD PTR tv1117[ebp]
  00416	dc 86 08 23 00
	00		 fadd	 QWORD PTR [esi+8968]
  0041c	dd 9e 08 23 00
	00		 fstp	 QWORD PTR [esi+8968]
$LN14@CGGrandSta:

; 743  : 	}
; 744  : 
; 745  : 	if(this->AddWcoinC > 0 || this->AddWcoinP > 0 || this->AddGoblinPoint > 0)

  00422	39 5f 40	 cmp	 DWORD PTR [edi+64], ebx
  00425	7f 0a		 jg	 SHORT $LN12@CGGrandSta
  00427	39 5f 44	 cmp	 DWORD PTR [edi+68], ebx
  0042a	7f 05		 jg	 SHORT $LN12@CGGrandSta
  0042c	39 5f 48	 cmp	 DWORD PTR [edi+72], ebx
  0042f	7e 0e		 jle	 SHORT $LN13@CGGrandSta
$LN12@CGGrandSta:

; 746  : 	{
; 747  : 		gGameShop.GDSaveUserInfo(aIndex);

  00431	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00434	52		 push	 edx
  00435	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0043a	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN13@CGGrandSta:

; 748  : 	}	
; 749  : 
; 750  : 	if(g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2))

  0043f	53		 push	 ebx
  00440	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00445	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0044a	84 c0		 test	 al, al
  0044c	75 24		 jne	 SHORT $LN10@CGGrandSta
  0044e	6a 30		 push	 48			; 00000030H
  00450	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00455	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0045a	84 c0		 test	 al, al
  0045c	75 14		 jne	 SHORT $LN10@CGGrandSta
  0045e	6a 31		 push	 49			; 00000031H
  00460	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00465	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0046a	84 c0		 test	 al, al
  0046c	0f 84 e1 00 00
	00		 je	 $LN74@CGGrandSta
$LN10@CGGrandSta:

; 751  : 	{
; 752  : 		//reward Item
; 753  : 		for(int i = 0; i < this->m_reward.size(); i++)

  00472	8b 9f dc 00 00
	00		 mov	 ebx, DWORD PTR [edi+220]
  00478	8b bf e0 00 00
	00		 mov	 edi, DWORD PTR [edi+224]
  0047e	2b fb		 sub	 edi, ebx
  00480	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00485	f7 ef		 imul	 edi
  00487	c1 fa 03	 sar	 edx, 3
  0048a	8b c2		 mov	 eax, edx
  0048c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0048f	33 c9		 xor	 ecx, ecx
  00491	03 c2		 add	 eax, edx
  00493	0f 84 ba 00 00
	00		 je	 $LN74@CGGrandSta
  00499	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  0049f	42		 inc	 edx
  004a0	8b fb		 mov	 edi, ebx
$LL9@CGGrandSta:

; 754  : 		{
; 755  : 			GRANDSYSTEM_REWARD_DATA & ritem = this->m_reward[i];
; 756  : 			if(ritem.ResetNum == (lpObj->GReset + 1))

  004a2	39 17		 cmp	 DWORD PTR [edi], edx
  004a4	74 0d		 je	 SHORT $LN70@CGGrandSta

; 751  : 	{
; 752  : 		//reward Item
; 753  : 		for(int i = 0; i < this->m_reward.size(); i++)

  004a6	41		 inc	 ecx
  004a7	83 c7 24	 add	 edi, 36			; 00000024H
  004aa	3b c8		 cmp	 ecx, eax
  004ac	72 f4		 jb	 SHORT $LL9@CGGrandSta

; 754  : 		{
; 755  : 			GRANDSYSTEM_REWARD_DATA & ritem = this->m_reward[i];
; 756  : 			if(ritem.ResetNum == (lpObj->GReset + 1))

  004ae	e9 a0 00 00 00	 jmp	 $LN74@CGGrandSta
$LN70@CGGrandSta:

; 757  : 			{
; 758  : 				if(ritem.WcoinC > 0)

  004b3	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  004b6	89 45 fc	 mov	 DWORD PTR tv1559[ebp], eax
  004b9	85 c0		 test	 eax, eax
  004bb	7e 1c		 jle	 SHORT $LN5@CGGrandSta

; 759  : 				{
; 760  : 					lpObj->GameShop.WCoinC += ritem.WcoinC;

  004bd	db 45 fc	 fild	 DWORD PTR tv1559[ebp]

; 761  : 					gGameShop.GDSaveUserInfo(lpObj->m_Index);

  004c0	8b 06		 mov	 eax, DWORD PTR [esi]
  004c2	50		 push	 eax
  004c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  004c8	dc 86 00 23 00
	00		 fadd	 QWORD PTR [esi+8960]
  004ce	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
  004d4	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN5@CGGrandSta:

; 762  : 				}
; 763  : 				if(ritem.Credit > 0)

  004d9	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  004dc	89 45 fc	 mov	 DWORD PTR tv1155[ebp], eax
  004df	85 c0		 test	 eax, eax
  004e1	7e 1b		 jle	 SHORT $LN4@CGGrandSta

; 764  : 				{
; 765  : 					lpObj->ZtCred += ritem.Credit;

  004e3	db 45 fc	 fild	 DWORD PTR tv1155[ebp]

; 766  : 					ZtUserDataSend(aIndex);

  004e6	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  004e9	51		 push	 ecx
  004ea	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  004f0	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
  004f6	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  004fb	83 c4 04	 add	 esp, 4
$LN4@CGGrandSta:

; 767  : 				}
; 768  : 				if(ritem.EnableItem)

  004fe	80 7f 0c 00	 cmp	 BYTE PTR [edi+12], 0
  00502	74 4f		 je	 SHORT $LN74@CGGrandSta

; 769  : 				{
; 770  : 					ItemSerialCreateSend(aIndex,lpObj->MapNumber,lpObj->X,lpObj->Y,ITEMGET(ritem.Type, ritem.Index),ritem.Level,0,ritem.Skill,ritem.Luck,ritem.Opt,aIndex,ritem.Exl,ritem.Anc);

  00504	0f b6 57 20	 movzx	 edx, BYTE PTR [edi+32]
  00508	0f b6 47 1f	 movzx	 eax, BYTE PTR [edi+31]
  0050c	0f b6 4f 1e	 movzx	 ecx, BYTE PTR [edi+30]
  00510	52		 push	 edx
  00511	0f b6 57 1d	 movzx	 edx, BYTE PTR [edi+29]
  00515	50		 push	 eax
  00516	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00519	50		 push	 eax
  0051a	51		 push	 ecx
  0051b	0f b6 4f 1c	 movzx	 ecx, BYTE PTR [edi+28]
  0051f	52		 push	 edx
  00520	0f b6 57 18	 movzx	 edx, BYTE PTR [edi+24]
  00524	51		 push	 ecx
  00525	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00528	6a 00		 push	 0
  0052a	52		 push	 edx
  0052b	0f b6 96 46 01
	00 00		 movzx	 edx, BYTE PTR [esi+326]
  00532	c1 e1 09	 shl	 ecx, 9
  00535	03 4f 14	 add	 ecx, DWORD PTR [edi+20]
  00538	51		 push	 ecx
  00539	0f b6 8e 44 01
	00 00		 movzx	 ecx, BYTE PTR [esi+324]
  00540	52		 push	 edx
  00541	0f b6 96 49 01
	00 00		 movzx	 edx, BYTE PTR [esi+329]
  00548	51		 push	 ecx
  00549	52		 push	 edx
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00550	83 c4 34	 add	 esp, 52			; 00000034H
$LN74@CGGrandSta:

; 771  : 				}
; 772  : 				break;
; 773  : 			}
; 774  : 		}
; 775  : 	}
; 776  : 
; 777  : 
; 778  : 	ZtFireCracker(aIndex, lpObj->X, lpObj->Y);

  00553	0f b6 86 46 01
	00 00		 movzx	 eax, BYTE PTR [esi+326]
  0055a	0f b6 8e 44 01
	00 00		 movzx	 ecx, BYTE PTR [esi+324]
  00561	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00564	50		 push	 eax
  00565	51		 push	 ecx
  00566	52		 push	 edx
  00567	e8 00 00 00 00	 call	 ?ZtFireCracker@@YAXHEE@Z ; ZtFireCracker

; 779  : 	//gObjCloseSet(aIndex, 1);
; 780  : 
; 781  : 	lpObj->Life = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  0056c	0f bf 86 d0 00
	00 00		 movsx	 eax, WORD PTR [esi+208]
  00573	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  0057a	8d 54 08 ff	 lea	 edx, DWORD PTR [eax+ecx-1]
  0057e	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00585	0f b7 8e f8 00
	00 00		 movzx	 ecx, WORD PTR [esi+248]
  0058c	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  00592	89 55 fc	 mov	 DWORD PTR tv1400[ebp], edx
  00595	0f b7 90 0c 00
	00 00		 movzx	 edx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  0059c	db 45 fc	 fild	 DWORD PTR tv1400[ebp]
  0059f	8b f9		 mov	 edi, ecx
  005a1	2b fa		 sub	 edi, edx
  005a3	d9 5d f8	 fstp	 DWORD PTR tv1206[ebp]

; 782  : 	lpObj->Mana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  005a6	0f b7 96 fa 00
	00 00		 movzx	 edx, WORD PTR [esi+250]
  005ad	89 7d fc	 mov	 DWORD PTR tv1395[ebp], edi
  005b0	8b da		 mov	 ebx, edx
  005b2	db 45 fc	 fild	 DWORD PTR tv1395[ebp]
  005b5	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  005bb	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  005c1	d9 45 f8	 fld	 DWORD PTR tv1206[ebp]
  005c4	d9 c0		 fld	 ST(0)
  005c6	de ca		 fmulp	 ST(2), ST(0)
  005c8	d9 80 14 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  005ce	de c2		 faddp	 ST(2), ST(0)
  005d0	d9 ca		 fxch	 ST(2)
  005d2	de c1		 faddp	 ST(1), ST(0)
  005d4	d9 9e fc 00 00
	00		 fstp	 DWORD PTR [esi+252]
  005da	0f b7 b8 0e 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  005e1	2b df		 sub	 ebx, edi
  005e3	89 5d f8	 mov	 DWORD PTR tv1390[ebp], ebx
  005e6	db 45 f8	 fild	 DWORD PTR tv1390[ebp]
  005e9	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  005ef	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  005f5	d8 ca		 fmul	 ST(0), ST(2)
  005f7	d8 80 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  005fd	de c1		 faddp	 ST(1), ST(0)
  005ff	d9 9e 10 01 00
	00		 fstp	 DWORD PTR [esi+272]

; 783  : 
; 784  : 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  00605	0f b7 b8 0c 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  0060c	2b cf		 sub	 ecx, edi
  0060e	89 4d f8	 mov	 DWORD PTR tv1385[ebp], ecx

; 785  : 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);
; 786  : 
; 787  : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;
; 788  : 	lpObj->EnergyToMana = DCInfo.DefClass[lpObj->Class].EnergyToMana;
; 789  : 
; 790  : 	::gObjSetBP(aIndex);

  00611	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00614	57		 push	 edi
  00615	db 45 f8	 fild	 DWORD PTR tv1385[ebp]
  00618	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  0061e	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00624	d8 ca		 fmul	 ST(0), ST(2)
  00626	d8 80 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  0062c	de c1		 faddp	 ST(1), ST(0)
  0062e	d9 9e 00 01 00
	00		 fstp	 DWORD PTR [esi+256]
  00634	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  0063b	2b d1		 sub	 edx, ecx
  0063d	89 55 f8	 mov	 DWORD PTR tv1380[ebp], edx
  00640	db 45 f8	 fild	 DWORD PTR tv1380[ebp]
  00643	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00649	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  0064f	de ca		 fmulp	 ST(2), ST(0)
  00651	d9 80 20 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  00657	de c2		 faddp	 ST(2), ST(0)
  00659	de c1		 faddp	 ST(1), ST(0)
  0065b	d9 9e 14 01 00
	00		 fstp	 DWORD PTR [esi+276]
  00661	d9 80 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  00667	d9 9e 34 01 00
	00		 fstp	 DWORD PTR [esi+308]
  0066d	d9 80 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00673	d9 9e 38 01 00
	00		 fstp	 DWORD PTR [esi+312]
  00679	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 791  : 	lpObj->BP = lpObj->MaxBP / 2;

  0067e	8b 86 2c 01 00
	00		 mov	 eax, DWORD PTR [esi+300]
  00684	99		 cdq
  00685	2b c2		 sub	 eax, edx
  00687	d1 f8		 sar	 eax, 1

; 792  : 	::gObjCalcMaxLifePower(aIndex);

  00689	57		 push	 edi
  0068a	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax
  00690	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 793  : 
; 794  : 	GCReFillSend(aIndex, (int)lpObj->MaxLife + lpObj->AddLife, 0xFE, 0, lpObj->iMaxShield + lpObj->iAddShield);

  00695	8b 96 5c 01 00
	00		 mov	 edx, DWORD PTR [esi+348]
  0069b	83 c4 14	 add	 esp, 20			; 00000014H
  0069e	03 96 58 01 00
	00		 add	 edx, DWORD PTR [esi+344]
  006a4	d9 86 00 01 00
	00		 fld	 DWORD PTR [esi+256]
  006aa	52		 push	 edx
  006ab	6a 00		 push	 0
  006ad	68 fe 00 00 00	 push	 254			; 000000feH
  006b2	e8 00 00 00 00	 call	 __ftol2_sse
  006b7	03 86 4c 01 00
	00		 add	 eax, DWORD PTR [esi+332]
  006bd	50		 push	 eax
  006be	57		 push	 edi
  006bf	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 795  : 	//gObjSetBP(aIndex);
; 796  : 	GCManaSend(aIndex,(int)lpObj->MaxMana + lpObj->AddMana, 0xFE, 0, lpObj->MaxBP + lpObj->AddBP);

  006c4	d9 86 14 01 00
	00		 fld	 DWORD PTR [esi+276]
  006ca	8b 86 30 01 00
	00		 mov	 eax, DWORD PTR [esi+304]
  006d0	03 86 2c 01 00
	00		 add	 eax, DWORD PTR [esi+300]
  006d6	83 c4 14	 add	 esp, 20			; 00000014H
  006d9	50		 push	 eax
  006da	6a 00		 push	 0
  006dc	68 fe 00 00 00	 push	 254			; 000000feH
  006e1	e8 00 00 00 00	 call	 __ftol2_sse
  006e6	03 86 50 01 00
	00		 add	 eax, DWORD PTR [esi+336]
  006ec	50		 push	 eax
  006ed	57		 push	 edi
  006ee	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 797  : 	gObjCalCharacter(aIndex);

  006f3	57		 push	 edi
  006f4	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 798  : 
; 799  : 	ResetSystemGC_CharUpdate(lpObj);

  006f9	56		 push	 esi
  006fa	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate

; 800  : 
; 801  : 	GCMoneySend(aIndex, lpObj->Money);

  006ff	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  00705	51		 push	 ecx
  00706	57		 push	 edi
  00707	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0070c	83 c4 24	 add	 esp, 36			; 00000024H

; 802  : 
; 803  : #if(CUSTOM_NOOBBUFF)
; 804  : 	if(ZtConfig.CommonServer.bNoobBuffEnable)

  0070f	80 3d 20 01 00
	00 00		 cmp	 BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+288, 0
  00716	74 20		 je	 SHORT $LN1@CGGrandSta

; 805  : 	{
; 806  : 		if(gObjSearchActiveEffect(lpObj,AT_NOOB_BUFF) == TRUE)

  00718	68 b6 00 00 00	 push	 182			; 000000b6H
  0071d	56		 push	 esi
  0071e	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00723	83 c4 08	 add	 esp, 8
  00726	3c 01		 cmp	 al, 1
  00728	75 0e		 jne	 SHORT $LN1@CGGrandSta

; 807  : 		{
; 808  : 			gObjRemoveBuffEffect(lpObj,AT_NOOB_BUFF);

  0072a	68 b6 00 00 00	 push	 182			; 000000b6H
  0072f	56		 push	 esi
  00730	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00735	83 c4 08	 add	 esp, 8
$LN1@CGGrandSta:

; 809  : 		}
; 810  : 	}
; 811  : #endif
; 812  : 
; 813  : #if(SYSTEM_ACHIEVEMENTS)
; 814  : 	g_Achievements.GrandResetUp(aIndex);

  00738	57		 push	 edi
  00739	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  0073e	e8 00 00 00 00	 call	 ?GrandResetUp@CAchievements@@QAEXH@Z ; CAchievements::GrandResetUp

; 815  : #endif
; 816  : 
; 817  : 	LogAddTD("[GrandResetSystem] Accaunt: %s , Name: %s , GrandReset: %d",lpObj->AccountID, lpObj->Name,lpObj->GReset);

  00743	8b 96 94 22 00
	00		 mov	 edx, DWORD PTR [esi+8852]
  00749	52		 push	 edx
  0074a	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0074d	50		 push	 eax
  0074e	83 c6 6c	 add	 esi, 108		; 0000006cH
  00751	56		 push	 esi
  00752	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@JEEEMDGP@?$FLGrandResetSystem?$FN?5Accaunt?3?5?$CFs?5?0@
  00757	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0075d	83 c4 10	 add	 esp, 16			; 00000010H
$LN75@CGGrandSta:
  00760	5e		 pop	 esi
  00761	5b		 pop	 ebx
$LN57@CGGrandSta:
  00762	5f		 pop	 edi

; 818  : }

  00763	8b e5		 mov	 esp, ebp
  00765	5d		 pop	 ebp
  00766	c2 04 00	 ret	 4
  00769	8d 49 00	 npad	 3
$LN78@CGGrandSta:
  0076c	00 00 00 00	 DD	 $LN28@CGGrandSta
  00770	00 00 00 00	 DD	 $LN27@CGGrandSta
  00774	00 00 00 00	 DD	 $LN26@CGGrandSta
  00778	00 00 00 00	 DD	 $LN25@CGGrandSta
  0077c	00 00 00 00	 DD	 $LN24@CGGrandSta
  00780	00 00 00 00	 DD	 $LN23@CGGrandSta
  00784	00 00 00 00	 DD	 $LN22@CGGrandSta
?CGGrandStart@cGrandReset@@QAEXH@Z ENDP			; cGrandReset::CGGrandStart
_TEXT	ENDS
PUBLIC	?NpcDialog@cGrandReset@@QAE_NHH@Z		; cGrandReset::NpcDialog
EXTRN	?GetCustom@CZtLicense@@QAEHXZ:PROC		; CZtLicense::GetCustom
; Function compile flags: /Ogtp
;	COMDAT ?NpcDialog@cGrandReset@@QAE_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aNpcIndex$ = 12					; size = 4
?NpcDialog@cGrandReset@@QAE_NHH@Z PROC			; cGrandReset::NpcDialog, COMDAT
; _this$ = ecx

; 821  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 822  : 	if( !g_ZtLicense.CheckUser(eZtUB::Local) && 
; 823  : 		!g_ZtLicense.CheckUser(eZtUB::EpicMU) && 
; 824  : 		!g_ZtLicense.CheckUser(eZtUB::RevoMU) &&
; 825  : 		!g_ZtLicense.CheckUser(eZtUB::GloryMU) &&
; 826  : 		!g_ZtLicense.CheckUser(eZtUB::MedoniAndrei) &&
; 827  : 		!g_ZtLicense.CheckUser(eZtUB::Artem) && 
; 828  : 		!g_ZtLicense.CheckUser(eZtUB::Artem2) &&
; 829  : 		!g_ZtLicense.CheckUser(eZtUB::mu4you) &&
; 830  : 		!g_ZtLicense.CheckUser(eZtUB::Escalate) &&
; 831  : 		!g_ZtLicense.CheckUser(eZtUB::eternalmu) &&
; 832  : 		!g_ZtLicense.CheckUser(eZtUB::NSGames) &&
; 833  : 		!g_ZtLicense.CheckUser(eZtUB::MUCustom) &&
; 834  : 		!g_ZtLicense.CheckUser(eZtUB::AsteraMU))

  00006	6a 00		 push	 0
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00012	84 c0		 test	 al, al
  00014	0f 85 e6 00 00
	00		 jne	 $LN4@NpcDialog
  0001a	6a 3b		 push	 59			; 0000003bH
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00021	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00026	84 c0		 test	 al, al
  00028	0f 85 d2 00 00
	00		 jne	 $LN4@NpcDialog
  0002e	6a 43		 push	 67			; 00000043H
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00035	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0003a	84 c0		 test	 al, al
  0003c	0f 85 be 00 00
	00		 jne	 $LN4@NpcDialog
  00042	6a 46		 push	 70			; 00000046H
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00049	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0004e	84 c0		 test	 al, al
  00050	0f 85 aa 00 00
	00		 jne	 $LN4@NpcDialog
  00056	6a 32		 push	 50			; 00000032H
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0005d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00062	84 c0		 test	 al, al
  00064	0f 85 96 00 00
	00		 jne	 $LN4@NpcDialog
  0006a	6a 30		 push	 48			; 00000030H
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00071	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00076	84 c0		 test	 al, al
  00078	0f 85 82 00 00
	00		 jne	 $LN4@NpcDialog
  0007e	6a 31		 push	 49			; 00000031H
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00085	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0008a	84 c0		 test	 al, al
  0008c	75 72		 jne	 SHORT $LN4@NpcDialog
  0008e	6a 4e		 push	 78			; 0000004eH
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00095	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0009a	84 c0		 test	 al, al
  0009c	75 62		 jne	 SHORT $LN4@NpcDialog
  0009e	6a 40		 push	 64			; 00000040H
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000a5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000aa	84 c0		 test	 al, al
  000ac	75 52		 jne	 SHORT $LN4@NpcDialog
  000ae	6a 4f		 push	 79			; 0000004fH
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000b5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000ba	84 c0		 test	 al, al
  000bc	75 42		 jne	 SHORT $LN4@NpcDialog
  000be	6a 51		 push	 81			; 00000051H
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000c5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000ca	84 c0		 test	 al, al
  000cc	75 32		 jne	 SHORT $LN4@NpcDialog
  000ce	6a 55		 push	 85			; 00000055H
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000d5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000da	84 c0		 test	 al, al
  000dc	75 22		 jne	 SHORT $LN4@NpcDialog
  000de	6a 62		 push	 98			; 00000062H
  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000e5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000ea	84 c0		 test	 al, al
  000ec	75 12		 jne	 SHORT $LN4@NpcDialog

; 835  : 	{
; 836  : 		if(!g_ZtLicense.GetCustom())

  000ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000f3	e8 00 00 00 00	 call	 ?GetCustom@CZtLicense@@QAEHXZ ; CZtLicense::GetCustom
  000f8	85 c0		 test	 eax, eax

; 837  : 		{
; 838  : 			return false;

  000fa	0f 84 95 00 00
	00		 je	 $LN1@NpcDialog
$LN4@NpcDialog:

; 839  : 		}
; 840  : 	}
; 841  : 
; 842  : 	if(!OBJMAX_RANGE(aIndex) && !OBJMAX_RANGE(aNpcIndex))

  00100	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00103	8b 45 0c	 mov	 eax, DWORD PTR _aNpcIndex$[ebp]
  00106	85 d2		 test	 edx, edx
  00108	78 0f		 js	 SHORT $LN12@NpcDialog
  0010a	33 c9		 xor	 ecx, ecx
  0010c	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00112	0f 9e c1	 setle	 cl
  00115	85 c9		 test	 ecx, ecx
  00117	75 12		 jne	 SHORT $LN3@NpcDialog
$LN12@NpcDialog:
  00119	85 c0		 test	 eax, eax
  0011b	78 78		 js	 SHORT $LN1@NpcDialog
  0011d	33 c9		 xor	 ecx, ecx
  0011f	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00124	0f 9e c1	 setle	 cl
  00127	85 c9		 test	 ecx, ecx

; 843  : 	{
; 844  : 		return false;

  00129	74 6a		 je	 SHORT $LN1@NpcDialog
$LN3@NpcDialog:

; 845  : 	}
; 846  : 
; 847  : 	LPOBJ lpUser = &gObj[aIndex];
; 848  : 	LPOBJ lpNpc = &gObj[aNpcIndex];

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00137	57		 push	 edi
  00138	8b fa		 mov	 edi, edx
  0013a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00140	03 c1		 add	 eax, ecx

; 849  : 
; 850  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00142	83 7c 0f 04 03	 cmp	 DWORD PTR [edi+ecx+4], 3
  00147	5f		 pop	 edi

; 851  : 	{
; 852  : 		return false;

  00148	7c 4b		 jl	 SHORT $LN1@NpcDialog

; 853  : 	}
; 854  : 
; 855  : 	if( lpNpc->Class		== this->m_NpcClass  &&
; 856  : 		lpNpc->MapNumber	== this->m_NpcMap &&
; 857  : 		lpNpc->X			== this->m_NpcX   &&
; 858  : 	    lpNpc->Y			== this->m_NpcY )

  0014a	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00151	3b 8e c8 00 00
	00		 cmp	 ecx, DWORD PTR [esi+200]
  00157	75 3c		 jne	 SHORT $LN1@NpcDialog
  00159	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  00160	3b 8e cc 00 00
	00		 cmp	 ecx, DWORD PTR [esi+204]
  00166	75 2d		 jne	 SHORT $LN1@NpcDialog
  00168	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  0016f	3b 8e d0 00 00
	00		 cmp	 ecx, DWORD PTR [esi+208]
  00175	75 1e		 jne	 SHORT $LN1@NpcDialog
  00177	0f bf 80 46 01
	00 00		 movsx	 eax, WORD PTR [eax+326]
  0017e	3b 86 d4 00 00
	00		 cmp	 eax, DWORD PTR [esi+212]
  00184	75 0f		 jne	 SHORT $LN1@NpcDialog

; 859  : 	{
; 860  : 		this->GCDialogInfo(aIndex);

  00186	52		 push	 edx
  00187	8b ce		 mov	 ecx, esi
  00189	e8 00 00 00 00	 call	 ?GCDialogInfo@cGrandReset@@QAEXH@Z ; cGrandReset::GCDialogInfo

; 861  : 		return true;

  0018e	b0 01		 mov	 al, 1
  00190	5e		 pop	 esi

; 865  : }

  00191	5d		 pop	 ebp
  00192	c2 08 00	 ret	 8
$LN1@NpcDialog:

; 862  : 	}
; 863  : 
; 864  : 	return false;

  00195	32 c0		 xor	 al, al
  00197	5e		 pop	 esi

; 865  : }

  00198	5d		 pop	 ebp
  00199	c2 08 00	 ret	 8
?NpcDialog@cGrandReset@@QAE_NHH@Z ENDP			; cGrandReset::NpcDialog
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z PROC ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ENDP ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@V?$allocator@UGrandResetEXP@@@1@@Z ; std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@V?$allocator@UGrandResetEXP@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@V?$allocator@UGrandResetEXP@@@1@@Z PROC ; std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@V?$allocator@UGrandResetEXP@@@1@@Z ENDP ; std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@1@@Z ; std::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@1@@Z PROC ; std::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@1@@Z ENDP ; std::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Vector_val<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1275 : 		size_type _Capacity = capacity();

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	2b 31		 sub	 esi, DWORD PTR [ecx]
  00009	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000e	f7 ee		 imul	 esi
  00010	03 d6		 add	 edx, esi
  00012	c1 fa 04	 sar	 edx, 4
  00015	8b c2		 mov	 eax, edx
  00017	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001a	03 c2		 add	 eax, edx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0001c	8b c8		 mov	 ecx, eax
  0001e	d1 e9		 shr	 ecx, 1
  00020	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  00025	2b d1		 sub	 edx, ecx
  00027	5e		 pop	 esi
  00028	3b d0		 cmp	 edx, eax
  0002a	73 04		 jae	 SHORT $LN4@Grow_to
  0002c	33 c0		 xor	 eax, eax
  0002e	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00030	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00035	3b c1		 cmp	 eax, ecx
  00037	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00039	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBEIXZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEII@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEII@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to@2
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to@2:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IBEII@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEII@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	2b 11		 sub	 edx, DWORD PTR [ecx]
  00008	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000d	f7 ea		 imul	 edx
  0000f	c1 fa 03	 sar	 edx, 3
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00019	8b c8		 mov	 ecx, eax
  0001b	d1 e9		 shr	 ecx, 1
  0001d	ba c7 71 1c 07	 mov	 edx, 119304647		; 071c71c7H
  00022	2b d1		 sub	 edx, ecx
  00024	3b d0		 cmp	 edx, eax
  00026	73 04		 jae	 SHORT $LN4@Grow_to@3
  00028	33 c0		 xor	 eax, eax
  0002a	eb 02		 jmp	 SHORT $LN5@Grow_to@3
$LN4@Grow_to@3:
  0002c	03 c1		 add	 eax, ecx
$LN5@Grow_to@3:

; 1279 : 		if (_Capacity < _Count)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	3b c1		 cmp	 eax, ecx
  00033	73 02		 jae	 SHORT $LN1@Grow_to@3

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00035	8b c1		 mov	 eax, ecx
$LN1@Grow_to@3:

; 1282 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Grow_to@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@AAU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@AAU2@@Z ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@AAU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@AAU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@2:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@AAU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@3
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@3:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ; std::_Allocate<RESET_NEEDITEM_DATA>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T216772 = -12						; size = 12
$T216777 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z PROC ; std::_Allocate<RESET_NEEDITEM_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 4a		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN1@Allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002f	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T216777[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T216772[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216777[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T216772[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216772[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ENDP ; std::_Allocate<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Allocate@UGrandResetEXP@@@std@@YAPAUGrandResetEXP@@IPAU1@@Z ; std::_Allocate<GrandResetEXP>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@UGrandResetEXP@@@std@@YAPAUGrandResetEXP@@IPAU1@@Z
_TEXT	SEGMENT
$T216785 = -12						; size = 12
$T216789 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UGrandResetEXP@@@std@@YAPAUGrandResetEXP@@IPAU1@@Z PROC ; std::_Allocate<GrandResetEXP>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T216789[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T216785[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216789[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T216785[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216785[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@UGrandResetEXP@@@std@@YAPAUGrandResetEXP@@IPAU1@@Z ENDP ; std::_Allocate<GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$_Allocate@UGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@IPAU1@@Z ; std::_Allocate<GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@UGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T216794 = -12						; size = 12
$T216798 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@IPAU1@@Z PROC ; std::_Allocate<GRANDSYSTEM_REWARD_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 14		 ja	 SHORT $LN1@Allocate@3
  00017	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T216798[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T216794[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216798[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T216794[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216794[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@UGRANDSYSTEM_REWARD_DATA@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@IPAU1@@Z ENDP ; std::_Allocate<GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 197  : 		_Construct(_Ptr, _Val);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN5@construct@4
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN5@construct@4:
  00017	5f		 pop	 edi

; 198  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@ABU3@@Z ; std::allocator<GrandResetEXP>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@ABU3@@Z PROC ; std::allocator<GrandResetEXP>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@5
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@5:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@ABU3@@Z ENDP ; std::allocator<GrandResetEXP>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@ABU3@@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@ABU3@@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 197  : 		_Construct(_Ptr, _Val);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN5@construct@6
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN5@construct@6:
  00017	5f		 pop	 edi

; 198  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@ABU3@@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct
_TEXT	ENDS
PUBLIC	??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<GrandResetEXP *,GrandResetEXP *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<GrandResetEXP *,GrandResetEXP *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL3@Move
  00025	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<GrandResetEXP *,GrandResetEXP *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ; std::allocator<RESET_NEEDITEM_DATA>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@@Z ; std::allocator<GrandResetEXP>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@@Z PROC ; std::allocator<GrandResetEXP>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@@Z ENDP ; std::allocator<GrandResetEXP>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@7
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@7:
  00017	5f		 pop	 edi

; 203  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@$$QAU3@@Z ; std::allocator<GrandResetEXP>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@$$QAU3@@Z PROC ; std::allocator<GrandResetEXP>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@8
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@8:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UGrandResetEXP@@@std@@QAEXPAUGrandResetEXP@@$$QAU3@@Z ENDP ; std::allocator<GrandResetEXP>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@$$QAU3@@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@$$QAU3@@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@9
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@9:
  00017	5f		 pop	 edi

; 203  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEXPAUGRANDSYSTEM_REWARD_DATA@@$$QAU3@@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::construct
_TEXT	ENDS
PUBLIC	?CGGrandMenu@cGrandReset@@QAEXH@Z		; cGrandReset::CGGrandMenu
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\grandreset.cpp
;	COMDAT ?CGGrandMenu@cGrandReset@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGGrandMenu@cGrandReset@@QAEXH@Z PROC			; cGrandReset::CGGrandMenu, COMDAT
; _this$ = ecx

; 364  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 365  : 	if( !g_ZtLicense.CheckUser(eZtUB::Local) && 
; 366  : 		!g_ZtLicense.CheckUser(eZtUB::Gredy) &&
; 367  : 		!g_ZtLicense.CheckUser(eZtUB::Gredy2) && 
; 368  : 		!g_ZtLicense.CheckUser(eZtUB::GredyLocal)&&
; 369  : 		!g_ZtLicense.CheckUser(eZtUB::GloryMU) &&
; 370  : 		!g_ZtLicense.CheckUser(eZtUB::MedoniAndrei) &&
; 371  : 		!g_ZtLicense.CheckUser(eZtUB::mu4you) && 
; 372  : 		!g_ZtLicense.CheckUser(eZtUB::Escalate) &&
; 373  : 		!g_ZtLicense.CheckUser(eZtUB::eternalmu) &&
; 374  : 		!g_ZtLicense.CheckUser(eZtUB::NSGames) &&
; 375  : 		!g_ZtLicense.CheckUser(eZtUB::MUCustom) &&
; 376  : 		!g_ZtLicense.CheckUser(eZtUB::AsteraMU))

  00006	6a 00		 push	 0
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00012	84 c0		 test	 al, al
  00014	0f 85 bc 00 00
	00		 jne	 $LN1@CGGrandMen
  0001a	6a 20		 push	 32			; 00000020H
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00021	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00026	84 c0		 test	 al, al
  00028	0f 85 a8 00 00
	00		 jne	 $LN1@CGGrandMen
  0002e	6a 22		 push	 34			; 00000022H
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00035	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0003a	84 c0		 test	 al, al
  0003c	0f 85 94 00 00
	00		 jne	 $LN1@CGGrandMen
  00042	6a 21		 push	 33			; 00000021H
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00049	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0004e	84 c0		 test	 al, al
  00050	0f 85 80 00 00
	00		 jne	 $LN1@CGGrandMen
  00056	6a 46		 push	 70			; 00000046H
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0005d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00062	84 c0		 test	 al, al
  00064	75 70		 jne	 SHORT $LN1@CGGrandMen
  00066	6a 32		 push	 50			; 00000032H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0006d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00072	84 c0		 test	 al, al
  00074	75 60		 jne	 SHORT $LN1@CGGrandMen
  00076	6a 4e		 push	 78			; 0000004eH
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0007d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00082	84 c0		 test	 al, al
  00084	75 50		 jne	 SHORT $LN1@CGGrandMen
  00086	6a 40		 push	 64			; 00000040H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0008d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00092	84 c0		 test	 al, al
  00094	75 40		 jne	 SHORT $LN1@CGGrandMen
  00096	6a 4f		 push	 79			; 0000004fH
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0009d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000a2	84 c0		 test	 al, al
  000a4	75 30		 jne	 SHORT $LN1@CGGrandMen
  000a6	6a 51		 push	 81			; 00000051H
  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000ad	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000b2	84 c0		 test	 al, al
  000b4	75 20		 jne	 SHORT $LN1@CGGrandMen
  000b6	6a 55		 push	 85			; 00000055H
  000b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000bd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000c2	84 c0		 test	 al, al
  000c4	75 10		 jne	 SHORT $LN1@CGGrandMen
  000c6	6a 62		 push	 98			; 00000062H
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000cd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000d2	84 c0		 test	 al, al
  000d4	74 0b		 je	 SHORT $LN2@CGGrandMen
$LN1@CGGrandMen:

; 377  : 	{
; 378  : 		return;
; 379  : 	}
; 380  : 
; 381  : 	this->GCDialogInfo(aIndex);

  000d6	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000d9	50		 push	 eax
  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?GCDialogInfo@cGrandReset@@QAEXH@Z ; cGrandReset::GCDialogInfo
$LN2@CGGrandMen:
  000e1	5e		 pop	 esi

; 382  : }

  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
?CGGrandMenu@cGrandReset@@QAEXH@Z ENDP			; cGrandReset::CGGrandMenu
_TEXT	ENDS
PUBLIC	??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??0?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::vector<GrandResetEXP,std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::vector<GrandResetEXP,std::allocator<GrandResetEXP> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::vector<GrandResetEXP,std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	??0?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Vector_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Vector_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QAE@PAUGrandResetEXP@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::_Vector_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<GrandResetEXP,std::allocator<GrandResetEXP> > >::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
$T217026 = -12						; size = 12
$T217018 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 4a		 je	 SHORT $LN1@allocate
  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN3@allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T217018[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T217026[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T217018[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T217026[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T217026[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UGrandResetEXP@@@std@@QAEPAUGrandResetEXP@@I@Z ; std::allocator<GrandResetEXP>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@UGrandResetEXP@@@std@@QAEPAUGrandResetEXP@@I@Z
_TEXT	SEGMENT
$T217049 = -12						; size = 12
$T217041 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UGrandResetEXP@@@std@@QAEPAUGrandResetEXP@@I@Z PROC ; std::allocator<GrandResetEXP>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T217041[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T217049[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T217041[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T217049[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T217049[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@UGrandResetEXP@@@std@@QAEPAUGrandResetEXP@@I@Z ENDP ; std::allocator<GrandResetEXP>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEPAUGRANDSYSTEM_REWARD_DATA@@I@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEPAUGRANDSYSTEM_REWARD_DATA@@I@Z
_TEXT	SEGMENT
$T217072 = -12						; size = 12
$T217064 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEPAUGRANDSYSTEM_REWARD_DATA@@I@Z PROC ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@3
  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 14		 ja	 SHORT $LN3@allocate@3
  00017	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@3
$LN3@allocate@3:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T217064[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T217072[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T217064[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T217072[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T217072[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@3:
?allocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEPAUGRANDSYSTEM_REWARD_DATA@@I@Z ENDP ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN9@Cons_val@4
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN9@Cons_val@4:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@ABU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@ABU2@@Z ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@ABU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@ABU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@5
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@5:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@ABU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN9@Cons_val@6
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN9@Cons_val@6:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00@Z ; std::_Move<GrandResetEXP *,GrandResetEXP *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00@Z PROC ; std::_Move<GrandResetEXP *,GrandResetEXP *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN5@Move@2
  00010	56		 push	 esi
$LL7@Move@2:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL7@Move@2
  00025	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUGrandResetEXP@@PAU1@@std@@YAPAUGrandResetEXP@@PAU1@00@Z ENDP ; std::_Move<GrandResetEXP *,GrandResetEXP *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z PROC ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@@Z ; std::_Dest_val<std::allocator<GrandResetEXP>,GrandResetEXP>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@@Z PROC ; std::_Dest_val<std::allocator<GrandResetEXP>,GrandResetEXP>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@@Z ENDP ; std::_Dest_val<std::allocator<GrandResetEXP>,GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@@Z ; std::_Dest_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@@Z PROC ; std::_Dest_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@7
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@7:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@U3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@$$QAU2@@Z ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@U3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@U3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@8
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@8:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@U3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@9
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@9:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@XZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<GrandResetEXP> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
  0001e	83 c6 1c	 add	 esi, 28			; 0000001cH
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 1c	 add	 edi, 28			; 0000001cH
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP>,GrandResetEXP>
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP>,GrandResetEXP>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov@2
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov@2:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@U3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@$$QAU2@@Z ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP>
  0001e	83 c6 08	 add	 esi, 8
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 08	 add	 edi, 8
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov@2

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov@2:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP>,GrandResetEXP>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov@3
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov@3:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA>
  0001e	83 c6 24	 add	 esi, 36			; 00000024H
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 24	 add	 edi, 36			; 00000024H
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov@3

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov@3:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@@Z ; std::_Destroy_range<std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@@Z PROC ; std::_Destroy_range<std::allocator<GrandResetEXP> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UGrandResetEXP@@@std@@@std@@YAXPAUGrandResetEXP@@0AAV?$allocator@UGrandResetEXP@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAXPAUGRANDSYSTEM_REWARD_DATA@@0AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z
_TEXT	SEGMENT
__Cat$217449 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$217449[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@@Z ; std::_Uninitialized_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninitialized_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@@Z
_TEXT	SEGMENT
__Cat$217459 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@@Z PROC ; std::_Uninitialized_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$217459[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP>,GrandResetEXP>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@@Z ENDP ; std::_Uninitialized_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z ; std::_Uninitialized_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninitialized_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z
_TEXT	SEGMENT
__Cat$217469 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z PROC ; std::_Uninitialized_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$217469[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXPAUGrandResetEXP@@0@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXPAUGrandResetEXP@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXPAUGrandResetEXP@@0@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXPAUGrandResetEXP@@0@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXPAUGRANDSYSTEM_REWARD_DATA@@0@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$217497 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$217497[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUGrandResetEXP@@@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEPAUGrandResetEXP@@PAU2@00@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Umove<GrandResetEXP *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUGrandResetEXP@@@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEPAUGrandResetEXP@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$217516 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUGrandResetEXP@@@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEPAUGrandResetEXP@@PAU2@00@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Umove<GrandResetEXP *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$217516[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP>,GrandResetEXP>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUGrandResetEXP@@@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEPAUGrandResetEXP@@PAU2@00@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Umove<GrandResetEXP *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUGRANDSYSTEM_REWARD_DATA@@@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEPAUGRANDSYSTEM_REWARD_DATA@@PAU2@00@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Umove<GRANDSYSTEM_REWARD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUGRANDSYSTEM_REWARD_DATA@@@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEPAUGRANDSYSTEM_REWARD_DATA@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$217535 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUGRANDSYSTEM_REWARD_DATA@@@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEPAUGRANDSYSTEM_REWARD_DATA@@PAU2@00@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Umove<GRANDSYSTEM_REWARD_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$217535[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUGRANDSYSTEM_REWARD_DATA@@@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEPAUGRANDSYSTEM_REWARD_DATA@@PAU2@00@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Umove<GRANDSYSTEM_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@0@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@0@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 26		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 1a		 je	 SHORT $LN30@erase
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00027	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002a	83 c2 08	 add	 edx, 8
  0002d	83 c6 08	 add	 esi, 8
  00030	3b d7		 cmp	 edx, edi
  00032	75 ec		 jne	 SHORT $LL32@erase
  00034	5b		 pop	 ebx
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00035	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00038	5f		 pop	 edi
$LN1@erase:
  00039	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@@2@0@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXXZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXXZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXXZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXXZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$214368 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$217727 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	81 fb 49 92 24
	09		 cmp	 ebx, 153391689		; 09249249H
  00036	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00047	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0004c	f7 e9		 imul	 ecx
  0004e	03 d1		 add	 edx, ecx
  00050	c1 fa 04	 sar	 edx, 4
  00053	8b c2		 mov	 eax, edx
  00055	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00058	03 c2		 add	 eax, edx
  0005a	3b c3		 cmp	 eax, ebx
  0005c	73 79		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005e	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00061	53		 push	 ebx
  00062	8b cf		 mov	 ecx, edi
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00069	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$217727[ebp]
  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	53		 push	 ebx
  00072	6a 00		 push	 0
  00074	57		 push	 edi
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	52		 push	 edx
  00078	89 45 ec	 mov	 DWORD PTR __Ptr$214368[ebp], eax
  0007b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00082	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00087	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00089	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008c	2b cb		 sub	 ecx, ebx
  0008e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00093	f7 e9		 imul	 ecx
  00095	03 d1		 add	 edx, ecx
  00097	c1 fa 04	 sar	 edx, 4
  0009a	8b fa		 mov	 edi, edx
  0009c	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	03 fa		 add	 edi, edx

; 761  : 			if (this->_Myfirst != 0)

  000a4	85 db		 test	 ebx, ebx
  000a6	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000a8	53		 push	 ebx
  000a9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ae	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000b4	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000bb	2b c8		 sub	 ecx, eax
  000bd	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214368[ebp]
  000c0	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]

; 770  : 			this->_Mylast = _Ptr + _Size;

  000c3	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  000ca	2b cf		 sub	 ecx, edi
  000cc	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000cf	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  000d2	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000d5	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
__catch$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000eb	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214368[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f4	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  00100	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
PUBLIC	?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::reserve
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$214405 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$217814 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@2:
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 03	 sar	 ecx, 3
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@UGrandResetEXP@@@std@@QAEPAUGrandResetEXP@@I@Z ; std::allocator<GrandResetEXP>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$217814[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$214405[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGrandResetEXP@@PAU1@V?$allocator@UGrandResetEXP@@@std@@U1@@std@@YAPAUGrandResetEXP@@PAU1@00AAV?$allocator@UGrandResetEXP@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GrandResetEXP *,GrandResetEXP *,std::allocator<GrandResetEXP>,GrandResetEXP>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 03	 sar	 edi, 3

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 fb	 lea	 edx, DWORD PTR [ebx+edi*8]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve@2:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214405[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@2:
$LN41@reserve@2:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::reserve
PUBLIC	?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::reserve
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$214445 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$217899 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	81 fb c7 71 1c
	07		 cmp	 ebx, 119304647		; 071c71c7H
  00036	76 0a		 jbe	 SHORT $LN5@reserve@3

; 748  : 			_Xlen();	// result too long

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@3:
$LN5@reserve@3:

; 749  : 		else if (capacity() < _Count)

  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00047	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0004c	f7 e9		 imul	 ecx
  0004e	c1 fa 03	 sar	 edx, 3
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00056	03 c2		 add	 eax, edx
  00058	3b c3		 cmp	 eax, ebx
  0005a	73 6b		 jae	 SHORT $LN3@reserve@3

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005c	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  0005f	53		 push	 ebx
  00060	8b cf		 mov	 ecx, edi
  00062	e8 00 00 00 00	 call	 ?allocate@?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@QAEPAUGRANDSYSTEM_REWARD_DATA@@I@Z ; std::allocator<GRANDSYSTEM_REWARD_DATA>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00067	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$217899[ebp]
  0006a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006d	8b 16		 mov	 edx, DWORD PTR [esi]
  0006f	53		 push	 ebx
  00070	6a 00		 push	 0
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	52		 push	 edx
  00076	89 45 ec	 mov	 DWORD PTR __Ptr$214445[ebp], eax
  00079	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00080	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUGRANDSYSTEM_REWARD_DATA@@PAU1@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@U1@@std@@YAPAUGRANDSYSTEM_REWARD_DATA@@PAU1@00AAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<GRANDSYSTEM_REWARD_DATA *,GRANDSYSTEM_REWARD_DATA *,std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00085	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00087	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008a	2b cb		 sub	 ecx, ebx
  0008c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00091	f7 e9		 imul	 ecx
  00093	c1 fa 03	 sar	 edx, 3
  00096	8b fa		 mov	 edi, edx
  00098	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0009b	83 c4 18	 add	 esp, 24			; 00000018H
  0009e	03 fa		 add	 edi, edx

; 761  : 			if (this->_Myfirst != 0)

  000a0	85 db		 test	 ebx, ebx
  000a2	74 09		 je	 SHORT $LN35@reserve@3

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$LN35@reserve@3:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  000ad	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000b0	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  000b3	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214445[ebp]
  000b6	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]

; 770  : 			this->_Mylast = _Ptr + _Size;

  000b9	8d 0c ff	 lea	 ecx, DWORD PTR [edi+edi*8]
  000bc	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000bf	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  000c2	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000c5	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve@3:

; 772  : 			}
; 773  : 		}

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d1	59		 pop	 ecx
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000db	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214445[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e4	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@3:
$LN41@reserve@3:
  000f0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::reserve
PUBLIC	??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??1?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::~vector<GrandResetEXP,std::allocator<GrandResetEXP> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::~vector<GrandResetEXP,std::allocator<GrandResetEXP> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@3
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@3:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAE@XZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::~vector<GrandResetEXP,std::allocator<GrandResetEXP> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXXZ ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXXZ PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::clear, COMDAT
; _this$ = ecx

; 1218 : 		erase(begin(), end());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	3b d6		 cmp	 edx, esi
  00008	74 1f		 je	 SHORT $LN19@clear
  0000a	8b c6		 mov	 eax, esi
  0000c	3b f6		 cmp	 esi, esi
  0000e	74 16		 je	 SHORT $LN48@clear
  00010	57		 push	 edi
$LL50@clear:
  00011	8b 38		 mov	 edi, DWORD PTR [eax]
  00013	89 3a		 mov	 DWORD PTR [edx], edi
  00015	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00018	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  0001b	83 c0 08	 add	 eax, 8
  0001e	83 c2 08	 add	 edx, 8
  00021	3b c6		 cmp	 eax, esi
  00023	75 ec		 jne	 SHORT $LL50@clear
  00025	5f		 pop	 edi
$LN48@clear:
  00026	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN19@clear:
  00029	5e		 pop	 esi

; 1219 : 		}

  0002a	c3		 ret	 0
?clear@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXXZ ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::~vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::~vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@4
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@4:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::~vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1291 : 		size_type _Size = size();

  00004	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00006	56		 push	 esi
  00007	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000a	2b f3		 sub	 esi, ebx
  0000c	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00011	f7 ee		 imul	 esi

; 1292 : 		if (max_size() - _Count < _Size)

  00013	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00016	03 d6		 add	 edx, esi
  00018	c1 fa 04	 sar	 edx, 4
  0001b	8b f2		 mov	 esi, edx
  0001d	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00020	03 f2		 add	 esi, edx
  00022	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  00027	2b d0		 sub	 edx, eax
  00029	57		 push	 edi
  0002a	3b d6		 cmp	 edx, esi
  0002c	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00033	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00038	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  0003b	03 f0		 add	 esi, eax
  0003d	2b fb		 sub	 edi, ebx
  0003f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00044	f7 ef		 imul	 edi
  00046	03 d7		 add	 edx, edi
  00048	c1 fa 04	 sar	 edx, 4
  0004b	8b c2		 mov	 eax, edx
  0004d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00050	03 c2		 add	 eax, edx
  00052	3b f0		 cmp	 esi, eax
  00054	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00056	8b d0		 mov	 edx, eax
  00058	d1 ea		 shr	 edx, 1
  0005a	bf 49 92 24 09	 mov	 edi, 153391689		; 09249249H
  0005f	2b fa		 sub	 edi, edx
  00061	3b f8		 cmp	 edi, eax
  00063	73 04		 jae	 SHORT $LN23@Reserve
  00065	33 c0		 xor	 eax, eax
  00067	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00069	03 c2		 add	 eax, edx
$LN24@Reserve:
  0006b	3b c6		 cmp	 eax, esi
  0006d	73 02		 jae	 SHORT $LN20@Reserve
  0006f	8b c6		 mov	 eax, esi
$LN20@Reserve:
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
$LN1@Reserve:
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 1298 : 		}

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXI@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXI@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00014	c1 f8 03	 sar	 eax, 3
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@2:
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 03	 sar	 edx, 3
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve@2

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve@2
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve@2
$LN23@Reserve@2:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve@2:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve@2
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve@2:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXI@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::reserve
$LN1@Reserve@2:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve@2:
?_Reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000a	2b d7		 sub	 edx, edi
  0000c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00011	f7 ea		 imul	 edx

; 1292 : 		if (max_size() - _Count < _Size)

  00013	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00016	c1 fa 03	 sar	 edx, 3
  00019	8b f2		 mov	 esi, edx
  0001b	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001e	03 f2		 add	 esi, edx
  00020	ba c7 71 1c 07	 mov	 edx, 119304647		; 071c71c7H
  00025	2b d0		 sub	 edx, eax
  00027	3b d6		 cmp	 edx, esi
  00029	73 0a		 jae	 SHORT $LN4@Reserve@3

; 1293 : 			_Xlen();

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00030	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@3:
$LN4@Reserve@3:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	03 f0		 add	 esi, eax
  0003a	2b d7		 sub	 edx, edi
  0003c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00041	f7 ea		 imul	 edx
  00043	c1 fa 03	 sar	 edx, 3
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	3b f0		 cmp	 esi, eax
  0004f	76 21		 jbe	 SHORT $LN1@Reserve@3

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00051	8b d0		 mov	 edx, eax
  00053	d1 ea		 shr	 edx, 1
  00055	bf c7 71 1c 07	 mov	 edi, 119304647		; 071c71c7H
  0005a	2b fa		 sub	 edi, edx
  0005c	3b f8		 cmp	 edi, eax
  0005e	73 04		 jae	 SHORT $LN23@Reserve@3
  00060	33 c0		 xor	 eax, eax
  00062	eb 02		 jmp	 SHORT $LN24@Reserve@3
$LN23@Reserve@3:
  00064	03 c2		 add	 eax, edx
$LN24@Reserve@3:
  00066	3b c6		 cmp	 eax, esi
  00068	73 02		 jae	 SHORT $LN20@Reserve@3
  0006a	8b c6		 mov	 eax, esi
$LN20@Reserve@3:
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::reserve
$LN1@Reserve@3:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 1298 : 		}

  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
$LN33@Reserve@3:
?_Reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	??0cGrandReset@@QAE@XZ				; cGrandReset::cGrandReset
; Function compile flags: /Ogtp
;	COMDAT ??0cGrandReset@@QAE@XZ
_TEXT	SEGMENT
??0cGrandReset@@QAE@XZ PROC				; cGrandReset::cGrandReset, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx
  0000a	89 88 bc 00 00
	00		 mov	 DWORD PTR [eax+188], ecx
  00010	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx
  00016	89 88 dc 00 00
	00		 mov	 DWORD PTR [eax+220], ecx
  0001c	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx
  00022	89 88 e4 00 00
	00		 mov	 DWORD PTR [eax+228], ecx
  00028	89 88 ec 00 00
	00		 mov	 DWORD PTR [eax+236], ecx
  0002e	89 88 f0 00 00
	00		 mov	 DWORD PTR [eax+240], ecx
  00034	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx
  0003a	c3		 ret	 0
??0cGrandReset@@QAE@XZ ENDP				; cGrandReset::cGrandReset
_TEXT	ENDS
PUBLIC	??1cGrandReset@@QAE@XZ				; cGrandReset::~cGrandReset
; Function compile flags: /Ogtp
;	COMDAT ??1cGrandReset@@QAE@XZ
_TEXT	SEGMENT
??1cGrandReset@@QAE@XZ PROC				; cGrandReset::~cGrandReset, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	3b c7		 cmp	 eax, edi
  0000e	74 09		 je	 SHORT $LN13@cGrandRese
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN13@cGrandRese:
  00019	89 be ec 00 00
	00		 mov	 DWORD PTR [esi+236], edi
  0001f	89 be f0 00 00
	00		 mov	 DWORD PTR [esi+240], edi
  00025	89 be f4 00 00
	00		 mov	 DWORD PTR [esi+244], edi
  0002b	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  00031	3b c7		 cmp	 eax, edi
  00033	74 09		 je	 SHORT $LN24@cGrandRese
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
$LN24@cGrandRese:
  0003e	89 be dc 00 00
	00		 mov	 DWORD PTR [esi+220], edi
  00044	89 be e0 00 00
	00		 mov	 DWORD PTR [esi+224], edi
  0004a	89 be e4 00 00
	00		 mov	 DWORD PTR [esi+228], edi
  00050	8b 86 b8 00 00
	00		 mov	 eax, DWORD PTR [esi+184]
  00056	3b c7		 cmp	 eax, edi
  00058	74 09		 je	 SHORT $LN35@cGrandRese
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
$LN35@cGrandRese:
  00063	89 be b8 00 00
	00		 mov	 DWORD PTR [esi+184], edi
  00069	89 be bc 00 00
	00		 mov	 DWORD PTR [esi+188], edi
  0006f	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	c3		 ret	 0
??1cGrandReset@@QAE@XZ ENDP				; cGrandReset::~cGrandReset
_TEXT	ENDS
PUBLIC	?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 52		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 4c		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001e	f7 ef		 imul	 edi
  00020	03 d7		 add	 edx, edi
  00022	c1 fa 04	 sar	 edx, 4
  00025	8b fa		 mov	 edi, edx
  00027	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0002a	03 fa		 add	 edi, edx

; 980  : 			if (this->_Mylast == this->_Myend)

  0002c	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00031	6a 01		 push	 1
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0003a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003c	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  00043	2b c7		 sub	 eax, edi
  00045	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00059	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00063	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00066	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  00068	6a 01		 push	 1
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00071	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00074	57		 push	 edi
  00075	52		 push	 edx
  00076	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00082	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXABUGrandResetEXP@@@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXABUGrandResetEXP@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXABUGrandResetEXP@@@Z PROC ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back@2
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXI@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@AAU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@AAU2@@Z ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back@2:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@IAEXI@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGrandResetEXP@@@std@@UGrandResetEXP@@ABU3@@std@@YAXAAV?$allocator@UGrandResetEXP@@@0@PAUGrandResetEXP@@ABU2@@Z ; std::_Cons_val<std::allocator<GrandResetEXP>,GrandResetEXP,GrandResetEXP const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXABUGrandResetEXP@@@Z ENDP ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXABUGRANDSYSTEM_REWARD_DATA@@@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXABUGRANDSYSTEM_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXABUGRANDSYSTEM_REWARD_DATA@@@Z PROC ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4a		 jae	 SHORT $LN4@push_back@3
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 44		 ja	 SHORT $LN4@push_back@3

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0001e	f7 ef		 imul	 edi
  00020	c1 fa 03	 sar	 edx, 3
  00023	8b fa		 mov	 edi, edx
  00025	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00028	03 fa		 add	 edi, edx

; 980  : 			if (this->_Mylast == this->_Myend)

  0002a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002d	75 09		 jne	 SHORT $LN3@push_back@3

; 981  : 				_Reserve(1);

  0002f	6a 01		 push	 1
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Reserve
$LN3@push_back@3:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	8d 04 ff	 lea	 eax, DWORD PTR [edi+edi*8]
  0003d	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00051	83 46 04 24	 add	 DWORD PTR [esi+4], 36	; 00000024H
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN4@push_back@3:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0005b	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0005e	75 09		 jne	 SHORT $LN1@push_back@3

; 991  : 				_Reserve(1);

  00060	6a 01		 push	 1
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::_Reserve
$LN1@push_back@3:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00069	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0006c	57		 push	 edi
  0006d	52		 push	 edx
  0006e	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@UGRANDSYSTEM_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@UGRANDSYSTEM_REWARD_DATA@@@0@PAUGRANDSYSTEM_REWARD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<GRANDSYSTEM_REWARD_DATA>,GRANDSYSTEM_REWARD_DATA,GRANDSYSTEM_REWARD_DATA const &>
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  0007a	83 46 04 24	 add	 DWORD PTR [esi+4], 36	; 00000024H
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
?push_back@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXABUGRANDSYSTEM_REWARD_DATA@@@Z ENDP ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0M@MDEMBLOC@MapForGrand?$AA@		; `string'
PUBLIC	??_C@_04JEMJNNDC@NpcY?$AA@			; `string'
PUBLIC	??_C@_04INNCOMHD@NpcX?$AA@			; `string'
PUBLIC	??_C@_06KMEDHGPI@NpcMap?$AA@			; `string'
PUBLIC	??_C@_08BNJJHKPI@NpcClass?$AA@			; `string'
PUBLIC	??_C@_03LGLGIONO@cmd?$AA@			; `string'
PUBLIC	??_C@_0M@PPKBAKCD@?1grandreset?$AA@		; `string'
PUBLIC	??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@		; `string'
PUBLIC	??_C@_09PFIPMMFI@AddWcoinP?$AA@			; `string'
PUBLIC	??_C@_09JEGAINMK@AddWcoinC?$AA@			; `string'
PUBLIC	??_C@_0L@KDJHOFMG@AddCredits?$AA@		; `string'
PUBLIC	??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@		; `string'
PUBLIC	??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@		; `string'
PUBLIC	??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@		; `string'
PUBLIC	??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@		; `string'
PUBLIC	??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@		; `string'
PUBLIC	??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@		; `string'
PUBLIC	??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@		; `string'
PUBLIC	??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@		; `string'
PUBLIC	??_C@_08PFDBLNIM@Add?4Form?$AA@			; `string'
PUBLIC	??_C@_0L@BKBHHLKP@Need?4Level?$AA@		; `string'
PUBLIC	??_C@_08IILNMGKH@Need?4Res?$AA@			; `string'
PUBLIC	??_C@_08LCGFICFE@Need?4Zen?$AA@			; `string'
PUBLIC	??_C@_07IGJLCBJI@ZenForm?$AA@			; `string'
PUBLIC	??_C@_0N@KAKJAMBI@Max?4GrandRes?$AA@		; `string'
PUBLIC	??_C@_0L@EGGLDMI@GrandReset?$AA@		; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cGrandReset@@QAEXXZ			; cGrandReset::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
;	COMDAT ??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\grandreset.h
CONST	SEGMENT
??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@ DB '%d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDEMBLOC@MapForGrand?$AA@
CONST	SEGMENT
??_C@_0M@MDEMBLOC@MapForGrand?$AA@ DB 'MapForGrand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JEMJNNDC@NpcY?$AA@
CONST	SEGMENT
??_C@_04JEMJNNDC@NpcY?$AA@ DB 'NpcY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04INNCOMHD@NpcX?$AA@
CONST	SEGMENT
??_C@_04INNCOMHD@NpcX?$AA@ DB 'NpcX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMEDHGPI@NpcMap?$AA@
CONST	SEGMENT
??_C@_06KMEDHGPI@NpcMap?$AA@ DB 'NpcMap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNJJHKPI@NpcClass?$AA@
CONST	SEGMENT
??_C@_08BNJJHKPI@NpcClass?$AA@ DB 'NpcClass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGLGIONO@cmd?$AA@
CONST	SEGMENT
??_C@_03LGLGIONO@cmd?$AA@ DB 'cmd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PPKBAKCD@?1grandreset?$AA@
CONST	SEGMENT
??_C@_0M@PPKBAKCD@?1grandreset?$AA@ DB '/grandreset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@
CONST	SEGMENT
??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@ DB 'AddGoblinPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFIPMMFI@AddWcoinP?$AA@
CONST	SEGMENT
??_C@_09PFIPMMFI@AddWcoinP?$AA@ DB 'AddWcoinP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEGAINMK@AddWcoinC?$AA@
CONST	SEGMENT
??_C@_09JEGAINMK@AddWcoinC?$AA@ DB 'AddWcoinC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDJHOFMG@AddCredits?$AA@
CONST	SEGMENT
??_C@_0L@KDJHOFMG@AddCredits?$AA@ DB 'AddCredits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@
CONST	SEGMENT
??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@ DB 'Need.EmptyInv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@
CONST	SEGMENT
??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@ DB 'Add.PointsRF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@
CONST	SEGMENT
??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@ DB 'Add.PointsDL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@
CONST	SEGMENT
??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@ DB 'Add.PointsMG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@
CONST	SEGMENT
??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@ DB 'Add.PointsSUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@
CONST	SEGMENT
??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@ DB 'Add.PointsELF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@
CONST	SEGMENT
??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@ DB 'Add.PointsDK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@
CONST	SEGMENT
??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@ DB 'Add.PointsDW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFDBLNIM@Add?4Form?$AA@
CONST	SEGMENT
??_C@_08PFDBLNIM@Add?4Form?$AA@ DB 'Add.Form', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKBHHLKP@Need?4Level?$AA@
CONST	SEGMENT
??_C@_0L@BKBHHLKP@Need?4Level?$AA@ DB 'Need.Level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IILNMGKH@Need?4Res?$AA@
CONST	SEGMENT
??_C@_08IILNMGKH@Need?4Res?$AA@ DB 'Need.Res', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LCGFICFE@Need?4Zen?$AA@
CONST	SEGMENT
??_C@_08LCGFICFE@Need?4Zen?$AA@ DB 'Need.Zen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGJLCBJI@ZenForm?$AA@
CONST	SEGMENT
??_C@_07IGJLCBJI@ZenForm?$AA@ DB 'ZenForm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KAKJAMBI@Max?4GrandRes?$AA@
CONST	SEGMENT
??_C@_0N@KAKJAMBI@Max?4GrandRes?$AA@ DB 'Max.GrandRes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGGLDMI@GrandReset?$AA@
CONST	SEGMENT
??_C@_0L@EGGLDMI@GrandReset?$AA@ DB 'GrandReset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
CONST	SEGMENT
??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@ DB '..\Data\Z'
	DB	'tData\GrandReset.ini', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\grandreset.cpp
CONST	ENDS
;	COMDAT ?Load@cGrandReset@@QAEXXZ
_TEXT	SEGMENT
_list$213732 = -320					; size = 8
_Flag$ = -312						; size = 4
_list$213734 = -308					; size = 36
_list$213737 = -300					; size = 28
_n$213730 = -272					; size = 12
_Buff$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?Load@cGrandReset@@QAEXXZ PROC				; cGrandReset::Load, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 24   : 	//CheckFile(GrandReset_DIR);
; 25   : 	this->EnableGrandResetSystem = GetPrivateProfileInt("GrandReset","Enable",0,GrandReset_DIR);	

  00016	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetPrivateProfileIntA@16
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00021	6a 00		 push	 0
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0002d	8b f1		 mov	 esi, ecx
  0002f	ff d7		 call	 edi

; 26   : 	this->MaxGrandRes = GetPrivateProfileInt("GrandReset","Max.GrandRes",100,GrandReset_DIR);

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00036	6a 64		 push	 100			; 00000064H
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KAKJAMBI@Max?4GrandRes?$AA@
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00042	89 06		 mov	 DWORD PTR [esi], eax
  00044	ff d7		 call	 edi

; 27   : 	this->ZenForm = GetPrivateProfileInt("GrandReset","ZenForm",0,GrandReset_DIR);

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  0004b	6a 00		 push	 0
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_07IGJLCBJI@ZenForm?$AA@
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00057	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005a	ff d7		 call	 edi

; 28   : 	this->NeedZen = GetPrivateProfileInt("GrandReset","Need.Zen",0,GrandReset_DIR);

  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00061	6a 00		 push	 0
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_08LCGFICFE@Need?4Zen?$AA@
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	ff d7		 call	 edi

; 29   : 	this->NeedRes = GetPrivateProfileInt("GrandReset","Need.Res",0,GrandReset_DIR);

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00077	6a 00		 push	 0
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_08IILNMGKH@Need?4Res?$AA@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00083	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00086	ff d7		 call	 edi

; 30   : 	this->NeedLevel = GetPrivateProfileInt("GrandReset","Need.Level",0,GrandReset_DIR);

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  0008d	6a 00		 push	 0
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BKBHHLKP@Need?4Level?$AA@
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00099	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0009c	ff d7		 call	 edi

; 31   : 	this->AddForm = GetPrivateProfileInt("GrandReset","Add.Form",0,GrandReset_DIR);

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  000a3	6a 00		 push	 0
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_08PFDBLNIM@Add?4Form?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  000af	89 46 14	 mov	 DWORD PTR [esi+20], eax
  000b2	ff d7		 call	 edi

; 32   : 	this->AddPointsDW = GetPrivateProfileInt("GrandReset","Add.PointsDW",0,GrandReset_DIR);

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  000b9	6a 00		 push	 0
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  000c5	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000c8	ff d7		 call	 edi

; 33   : 	this->AddPointsDK = GetPrivateProfileInt("GrandReset","Add.PointsDK",0,GrandReset_DIR);

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  000cf	6a 00		 push	 0
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  000db	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000de	ff d7		 call	 edi

; 34   : 	this->AddPointsELF = GetPrivateProfileInt("GrandReset","Add.PointsELF",0,GrandReset_DIR);

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  000e5	6a 00		 push	 0
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  000f1	89 46 20	 mov	 DWORD PTR [esi+32], eax
  000f4	ff d7		 call	 edi

; 35   : 	this->AddPointsSUM = GetPrivateProfileInt("GrandReset","Add.PointsSUM",0,GrandReset_DIR);

  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  000fb	6a 00		 push	 0
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00107	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0010a	ff d7		 call	 edi

; 36   : 	this->AddPointsMG = GetPrivateProfileInt("GrandReset","Add.PointsMG",0,GrandReset_DIR);

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00111	6a 00		 push	 0
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0011d	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00120	ff d7		 call	 edi

; 37   : 	this->AddPointsDL = GetPrivateProfileInt("GrandReset","Add.PointsDL",0,GrandReset_DIR);

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00127	6a 00		 push	 0
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@
  0012e	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00136	ff d7		 call	 edi

; 38   : 	this->AddPointsRF = GetPrivateProfileInt("GrandReset","Add.PointsRF",0,GrandReset_DIR);

  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  0013d	6a 00		 push	 0
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00149	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0014c	ff d7		 call	 edi

; 39   : 	this->NeedEmptyInv = GetPrivateProfileInt("GrandReset","Need.EmptyInv",1,GrandReset_DIR);

  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00153	6a 01		 push	 1
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0015f	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00162	ff d7		 call	 edi

; 40   : 
; 41   : 	this->AddCredits = GetPrivateProfileInt("GrandReset","AddCredits",0,GrandReset_DIR);

  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00169	6a 00		 push	 0
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KDJHOFMG@AddCredits?$AA@
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00175	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00178	ff d7		 call	 edi

; 42   : 	this->AddWcoinC = GetPrivateProfileInt("GrandReset","AddWcoinC",0,GrandReset_DIR);

  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  0017f	6a 00		 push	 0
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_09JEGAINMK@AddWcoinC?$AA@
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0018b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0018e	ff d7		 call	 edi

; 43   : 	this->AddWcoinP = GetPrivateProfileInt("GrandReset","AddWcoinP",0,GrandReset_DIR);

  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00195	6a 00		 push	 0
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_09PFIPMMFI@AddWcoinP?$AA@
  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  001a1	89 46 40	 mov	 DWORD PTR [esi+64], eax
  001a4	ff d7		 call	 edi

; 44   : 	this->AddGoblinPoint = GetPrivateProfileInt("GrandReset","AddGoblinPoint",0,GrandReset_DIR);

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  001ab	6a 00		 push	 0
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  001b7	89 46 44	 mov	 DWORD PTR [esi+68], eax
  001ba	ff d7		 call	 edi

; 45   : 
; 46   : 	 GetPrivateProfileString("GrandReset", "cmd","/grandreset",this->CommandGrandReset,100,GrandReset_DIR);

  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  001c1	6a 64		 push	 100			; 00000064H
  001c3	89 46 48	 mov	 DWORD PTR [esi+72], eax
  001c6	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  001c9	50		 push	 eax
  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PPKBAKCD@?1grandreset?$AA@
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_03LGLGIONO@cmd?$AA@
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 47   : 
; 48   : 	 this->m_NpcClass = GetPrivateProfileInt("GrandReset", "NpcClass", 0, GrandReset_DIR);

  001df	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  001e4	6a 00		 push	 0
  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_08BNJJHKPI@NpcClass?$AA@
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  001f0	ff d7		 call	 edi

; 49   : 	 this->m_NpcMap = GetPrivateProfileInt("GrandReset", "NpcMap", 0, GrandReset_DIR);

  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  001f7	6a 00		 push	 0
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_06KMEDHGPI@NpcMap?$AA@
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00203	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00209	ff d7		 call	 edi

; 50   : 	 this->m_NpcX = GetPrivateProfileInt("GrandReset", "NpcX", 0, GrandReset_DIR);

  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00210	6a 00		 push	 0
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_04INNCOMHD@NpcX?$AA@
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0021c	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00222	ff d7		 call	 edi

; 51   : 	 this->m_NpcY = GetPrivateProfileInt("GrandReset", "NpcY", 0, GrandReset_DIR);

  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00229	6a 00		 push	 0
  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_04JEMJNNDC@NpcY?$AA@
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  00235	89 86 d0 00 00
	00		 mov	 DWORD PTR [esi+208], eax
  0023b	ff d7		 call	 edi

; 52   : 
; 53   : 	 this->m_iMapForGrand = GetPrivateProfileInt("GrandReset", "MapForGrand", 0, GrandReset_DIR);

  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  00242	6a 00		 push	 0
  00244	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MDEMBLOC@MapForGrand?$AA@
  00249	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EGGLDMI@GrandReset?$AA@
  0024e	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  00254	ff d7		 call	 edi
  00256	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax

; 54   : 
; 55   : //#ifdef PRIVATE_MODULE
; 56   : //	if(g_ZtLicense.CheckUser(eZtUB::drynea))
; 57   : //	{
; 58   : //		this->AddWcoin = GetPrivateProfileInt("GrandReset","AddWcoin",0,GrandReset_DIR);
; 59   : //	}
; 60   : //#endif
; 61   : 
; 62   : 	
; 63   : 
; 64   : #if(ADD_GRAND_EXP)
; 65   : 	 this->EnableGrandDinamic = g_ZtLicense.user.GrandDinamicExp;

  0025c	8a 0d e3 00 00
	00		 mov	 cl, BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+227
  00262	88 8e b4 00 00
	00		 mov	 BYTE PTR [esi+180], cl

; 66   : 
; 67   : 	this->DataExp.clear();

  00268	8b 96 b8 00 00
	00		 mov	 edx, DWORD PTR [esi+184]
  0026e	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [esi+188]
  00274	3b d0		 cmp	 edx, eax
  00276	74 22		 je	 SHORT $LN28@Load
  00278	8b c8		 mov	 ecx, eax
  0027a	3b c0		 cmp	 eax, eax
  0027c	74 16		 je	 SHORT $LN57@Load
  0027e	8b ff		 npad	 2
$LL59@Load:
  00280	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00282	89 1a		 mov	 DWORD PTR [edx], ebx
  00284	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  00287	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
  0028a	83 c1 08	 add	 ecx, 8
  0028d	83 c2 08	 add	 edx, 8
  00290	3b c8		 cmp	 ecx, eax
  00292	75 ec		 jne	 SHORT $LL59@Load
$LN57@Load:
  00294	89 96 bc 00 00
	00		 mov	 DWORD PTR [esi+188], edx
$LN28@Load:

; 68   : 
; 69   : 	FILE * file = fopen(GrandReset_DIR,"r");

  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  002a4	e8 00 00 00 00	 call	 _fopen
  002a9	8b d8		 mov	 ebx, eax
  002ab	83 c4 08	 add	 esp, 8

; 70   : 	if(file == NULL)

  002ae	85 db		 test	 ebx, ebx
  002b0	75 19		 jne	 SHORT $LN7@Load

; 71   : 	{
; 72   : 		MessageBoxA(0,GrandReset_DIR,"LOAD FILE ERROR",0);

  002b2	50		 push	 eax
  002b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHIKHLJD@?4?4?2Data?2ZtData?2GrandReset?4ini?$AA@
  002bd	50		 push	 eax
  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 73   : 		ExitProcess(0);

  002c4	53		 push	 ebx
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN71@Load:
$LN7@Load:

; 74   : 	}
; 75   : 	char Buff[256];
; 76   : 	int Flag = 0;
; 77   : 	while(!feof(file))

  002cb	53		 push	 ebx
  002cc	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _Flag$[ebp], 0
  002d6	e8 00 00 00 00	 call	 _feof
  002db	83 c4 04	 add	 esp, 4
  002de	85 c0		 test	 eax, eax
  002e0	0f 85 b1 01 00
	00		 jne	 $LN5@Load
  002e6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL6@Load:

; 78   : 	{
; 79   : 		fgets(Buff,256,file);

  002f0	53		 push	 ebx
  002f1	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  002f7	68 00 01 00 00	 push	 256			; 00000100H
  002fc	52		 push	 edx
  002fd	e8 00 00 00 00	 call	 _fgets

; 80   : 		if(Zt_IsBadFileLine(Buff, Flag)) continue;

  00302	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _Flag$[ebp]
  00308	50		 push	 eax
  00309	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  0030f	51		 push	 ecx
  00310	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  00315	83 c4 14	 add	 esp, 20			; 00000014H
  00318	84 c0		 test	 al, al
  0031a	0f 85 66 01 00
	00		 jne	 $LN1@Load

; 81   : 		if(Flag == 1)

  00320	83 bd c8 fe ff
	ff 01		 cmp	 DWORD PTR _Flag$[ebp], 1
  00327	75 65		 jne	 SHORT $LN3@Load

; 82   : 		{
; 83   : 			int n[3];
; 84   : 			sscanf(Buff, "%d %d %d", &n[0], &n[1], &n[2]);

  00329	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _n$213730[ebp+8]
  0032f	52		 push	 edx
  00330	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _n$213730[ebp+4]
  00336	50		 push	 eax
  00337	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _n$213730[ebp]
  0033d	51		 push	 ecx
  0033e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00344	68 00 00 00 00	 push	 OFFSET ??_C@_08OOHKHLPO@?$CFd?5?$CFd?5?$CFd?$AA@
  00349	52		 push	 edx
  0034a	e8 00 00 00 00	 call	 _sscanf

; 85   : 			GrandResetEXP list;
; 86   : 			list.GrandReset = n[0];

  0034f	66 8b 85 f0 fe
	ff ff		 mov	 ax, WORD PTR _n$213730[ebp]

; 87   : 			list.TypeExp	= n[1];
; 88   : 			list.MinusExp	= n[2];

  00356	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _n$213730[ebp+8]
  0035c	83 c4 14	 add	 esp, 20			; 00000014H
  0035f	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _n$213730[ebp+4], 0
  00366	66 89 85 c0 fe
	ff ff		 mov	 WORD PTR _list$213732[ebp], ax
  0036d	0f 95 c1	 setne	 cl

; 89   : 			this->DataExp.push_back(list);

  00370	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _list$213732[ebp]
  00376	88 8d c2 fe ff
	ff		 mov	 BYTE PTR _list$213732[ebp+2], cl
  0037c	50		 push	 eax
  0037d	8d 8e b8 00 00
	00		 lea	 ecx, DWORD PTR [esi+184]
  00383	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _list$213732[ebp+4], edx
  00389	e8 00 00 00 00	 call	 ?push_back@?$vector@UGrandResetEXP@@V?$allocator@UGrandResetEXP@@@std@@@std@@QAEXABUGrandResetEXP@@@Z ; std::vector<GrandResetEXP,std::allocator<GrandResetEXP> >::push_back
$LN3@Load:

; 90   : 		}
; 91   : 
; 92   : 		//if(g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2))
; 93   : 		{
; 94   : 			if(Flag == 2)

  0038e	83 bd c8 fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  00395	75 7a		 jne	 SHORT $LN2@Load

; 95   : 			{
; 96   : 				GRANDSYSTEM_REWARD_DATA list;
; 97   : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d %d %d",&list.ResetNum,&list.WcoinC,&list.Credit,&list.EnableItem,&list.Type,&list.Index,&list.Level,&list.Skill,&list.Luck,&list.Opt,&list.Exl,&list.Anc);

  00397	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _list$213734[ebp+32]
  0039d	51		 push	 ecx
  0039e	8d 95 eb fe ff
	ff		 lea	 edx, DWORD PTR _list$213734[ebp+31]
  003a4	52		 push	 edx
  003a5	8d 85 ea fe ff
	ff		 lea	 eax, DWORD PTR _list$213734[ebp+30]
  003ab	50		 push	 eax
  003ac	8d 8d e9 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213734[ebp+29]
  003b2	51		 push	 ecx
  003b3	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _list$213734[ebp+28]
  003b9	52		 push	 edx
  003ba	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _list$213734[ebp+24]
  003c0	50		 push	 eax
  003c1	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213734[ebp+20]
  003c7	51		 push	 ecx
  003c8	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _list$213734[ebp+16]
  003ce	52		 push	 edx
  003cf	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _list$213734[ebp+12]
  003d5	50		 push	 eax
  003d6	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213734[ebp+8]
  003dc	51		 push	 ecx
  003dd	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _list$213734[ebp+4]
  003e3	52		 push	 edx
  003e4	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _list$213734[ebp]
  003ea	50		 push	 eax
  003eb	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  003f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  003f6	51		 push	 ecx
  003f7	e8 00 00 00 00	 call	 _sscanf
  003fc	83 c4 38	 add	 esp, 56			; 00000038H

; 98   : 				this->m_reward.push_back(list);

  003ff	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _list$213734[ebp]
  00405	52		 push	 edx
  00406	8d 8e dc 00 00
	00		 lea	 ecx, DWORD PTR [esi+220]
  0040c	e8 00 00 00 00	 call	 ?push_back@?$vector@UGRANDSYSTEM_REWARD_DATA@@V?$allocator@UGRANDSYSTEM_REWARD_DATA@@@std@@@std@@QAEXABUGRANDSYSTEM_REWARD_DATA@@@Z ; std::vector<GRANDSYSTEM_REWARD_DATA,std::allocator<GRANDSYSTEM_REWARD_DATA> >::push_back
$LN2@Load:

; 99   : 			}
; 100  : 			#if(ENABLE_GRAND_NEEDITEM)
; 101  : 			if(Flag == 3)

  00411	83 bd c8 fe ff
	ff 03		 cmp	 DWORD PTR _Flag$[ebp], 3
  00418	75 6c		 jne	 SHORT $LN1@Load

; 102  : 			{
; 103  : 				RESET_NEEDITEM_DATA list;
; 104  : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d", &list.ResetNum,&list.Type,&list.Index,&list.Level,&list.Skill,&list.Luck,&list.Opt,&list.Exl,&list.Anc,&list.Count);

  0041a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _list$213737[ebp+24]
  00420	50		 push	 eax
  00421	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213737[ebp+20]
  00427	51		 push	 ecx
  00428	8d 95 e7 fe ff
	ff		 lea	 edx, DWORD PTR _list$213737[ebp+19]
  0042e	52		 push	 edx
  0042f	8d 85 e6 fe ff
	ff		 lea	 eax, DWORD PTR _list$213737[ebp+18]
  00435	50		 push	 eax
  00436	8d 8d e5 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213737[ebp+17]
  0043c	51		 push	 ecx
  0043d	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _list$213737[ebp+16]
  00443	52		 push	 edx
  00444	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _list$213737[ebp+12]
  0044a	50		 push	 eax
  0044b	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _list$213737[ebp+8]
  00451	51		 push	 ecx
  00452	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _list$213737[ebp+4]
  00458	52		 push	 edx
  00459	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _list$213737[ebp]
  0045f	50		 push	 eax
  00460	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00466	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0046b	51		 push	 ecx
  0046c	e8 00 00 00 00	 call	 _sscanf
  00471	83 c4 30	 add	 esp, 48			; 00000030H

; 105  : 				this->m_needitem.push_back(list);

  00474	8d 95 d4 fe ff
	ff		 lea	 edx, DWORD PTR _list$213737[ebp]
  0047a	52		 push	 edx
  0047b	8d 8e ec 00 00
	00		 lea	 ecx, DWORD PTR [esi+236]
  00481	e8 00 00 00 00	 call	 ?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
$LN1@Load:

; 74   : 	}
; 75   : 	char Buff[256];
; 76   : 	int Flag = 0;
; 77   : 	while(!feof(file))

  00486	53		 push	 ebx
  00487	e8 00 00 00 00	 call	 _feof
  0048c	83 c4 04	 add	 esp, 4
  0048f	85 c0		 test	 eax, eax
  00491	0f 84 59 fe ff
	ff		 je	 $LL6@Load
$LN5@Load:

; 106  : 			}
; 107  : 			#endif
; 108  : 		}
; 109  : 	}
; 110  : 	fclose(file);

  00497	53		 push	 ebx
  00498	e8 00 00 00 00	 call	 _fclose

; 111  : #endif
; 112  : }

  0049d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a0	83 c4 04	 add	 esp, 4
  004a3	5f		 pop	 edi
  004a4	5e		 pop	 esi
  004a5	33 cd		 xor	 ecx, ebp
  004a7	5b		 pop	 ebx
  004a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ad	8b e5		 mov	 esp, ebp
  004af	5d		 pop	 ebp
  004b0	c3		 ret	 0
$LN70@Load:
?Load@cGrandReset@@QAEXXZ ENDP				; cGrandReset::Load
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgGrandReset@@YAXXZ
text$yc	SEGMENT
??__EgGrandReset@@YAXXZ PROC				; `dynamic initializer for 'gGrandReset'', COMDAT

; 20   : cGrandReset gGrandReset;

  00000	68 00 00 00 00	 push	 OFFSET ??__FgGrandReset@@YAXXZ ; `dynamic atexit destructor for 'gGrandReset''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EgGrandReset@@YAXXZ ENDP				; `dynamic initializer for 'gGrandReset''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgGrandReset@@YAXXZ
text$yd	SEGMENT
??__FgGrandReset@@YAXXZ PROC				; `dynamic atexit destructor for 'gGrandReset'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGrandReset@@3VcGrandReset@@A ; gGrandReset
  00005	e9 00 00 00 00	 jmp	 ??1cGrandReset@@QAE@XZ
??__FgGrandReset@@YAXXZ ENDP				; `dynamic atexit destructor for 'gGrandReset''
text$yd	ENDS
PUBLIC	?gGrandReset@@3VcGrandReset@@A			; gGrandReset
_BSS	SEGMENT
?gGrandReset@@3VcGrandReset@@A DB 0fcH DUP (?)		; gGrandReset
_BSS	ENDS
CRT$XCU	SEGMENT
_gGrandReset$initializer$ DD FLAT:??__EgGrandReset@@YAXXZ
CRT$XCU	ENDS
END
