; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\IllusionTempleEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?m_i_IT_PlayTime@@3HA				; m_i_IT_PlayTime
PUBLIC	?m_i_IT_OpenTime@@3HA				; m_i_IT_OpenTime
PUBLIC	?m_i_IT_CloseTime@@3HA				; m_i_IT_CloseTime
PUBLIC	?m_i_IT_RestTime@@3HA				; m_i_IT_RestTime
PUBLIC	?m_i_IT_WaitTime@@3HA				; m_i_IT_WaitTime
PUBLIC	?g_iIllusionTempleEvent@@3HA			; g_iIllusionTempleEvent
PUBLIC	?g_iOldScrollDropRate@@3HA			; g_iOldScrollDropRate
PUBLIC	?g_iCovenantOfIllusionDropRate@@3HA		; g_iCovenantOfIllusionDropRate
PUBLIC	?g_iUseMaxLevelIllusionTemple@@3HA		; g_iUseMaxLevelIllusionTemple
PUBLIC	?g_iSaveIllusionTempleRankingPoint@@3HA		; g_iSaveIllusionTempleRankingPoint
PUBLIC	?g_iIllusionTempleRewardPercent@@3HA		; g_iIllusionTempleRewardPercent
PUBLIC	?g_iIllusionTempleMinUseSkillCnt@@3HA		; g_iIllusionTempleMinUseSkillCnt
PUBLIC	?g_iIllusionTempleRewardPercentMaster@@3HA	; g_iIllusionTempleRewardPercentMaster
_BSS	SEGMENT
?m_i_IT_PlayTime@@3HA DD 01H DUP (?)			; m_i_IT_PlayTime
?m_i_IT_OpenTime@@3HA DD 01H DUP (?)			; m_i_IT_OpenTime
?m_i_IT_CloseTime@@3HA DD 01H DUP (?)			; m_i_IT_CloseTime
?m_i_IT_RestTime@@3HA DD 01H DUP (?)			; m_i_IT_RestTime
?m_i_IT_WaitTime@@3HA DD 01H DUP (?)			; m_i_IT_WaitTime
?g_iOldScrollDropRate@@3HA DD 01H DUP (?)		; g_iOldScrollDropRate
?g_iCovenantOfIllusionDropRate@@3HA DD 01H DUP (?)	; g_iCovenantOfIllusionDropRate
?g_iUseMaxLevelIllusionTemple@@3HA DD 01H DUP (?)	; g_iUseMaxLevelIllusionTemple
?g_iSaveIllusionTempleRankingPoint@@3HA DD 01H DUP (?)	; g_iSaveIllusionTempleRankingPoint
_BSS	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	070H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
	DD	010eH
?g_iIllusionTempleEvent@@3HA DD 01H			; g_iIllusionTempleEvent
?g_iIllusionTempleRewardPercent@@3HA DD 064H		; g_iIllusionTempleRewardPercent
?g_iIllusionTempleMinUseSkillCnt@@3HA DD 03H		; g_iIllusionTempleMinUseSkillCnt
?g_iIllusionTempleRewardPercentMaster@@3HA DD 064H	; g_iIllusionTempleRewardPercentMaster
_DATA	ENDS
CONST	SEGMENT
_g_iIT_ChoasMixSuccessRate DD 046H
	DD	046H
	DD	046H
	DD	046H
	DD	046H
	DD	046H
_g_iIT_ChoasMixMoney DD 02dc6c0H
	DD	04c4b40H
	DD	06acfc0H
	DD	0895440H
	DD	0a7d8c0H
	DD	0c65d40H
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?LockTimeCheckSync@CIllusionTempleProcess@@QAEXXZ ; CIllusionTempleProcess::LockTimeCheckSync
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\illusiontempleprocess.h
;	COMDAT ?LockTimeCheckSync@CIllusionTempleProcess@@QAEXXZ
_TEXT	SEGMENT
?LockTimeCheckSync@CIllusionTempleProcess@@QAEXXZ PROC	; CIllusionTempleProcess::LockTimeCheckSync, COMDAT
; _this$ = ecx

; 279  : 	void LockTimeCheckSync(){this->m_bTimeCheckSync = TRUE;}

  00000	c7 81 e4 03 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+996], 1
  0000a	c3		 ret	 0
?LockTimeCheckSync@CIllusionTempleProcess@@QAEXXZ ENDP	; CIllusionTempleProcess::LockTimeCheckSync
_TEXT	ENDS
PUBLIC	?GetTimeCheckSync@CIllusionTempleProcess@@QAEHXZ ; CIllusionTempleProcess::GetTimeCheckSync
; Function compile flags: /Ogtp
;	COMDAT ?GetTimeCheckSync@CIllusionTempleProcess@@QAEHXZ
_TEXT	SEGMENT
?GetTimeCheckSync@CIllusionTempleProcess@@QAEHXZ PROC	; CIllusionTempleProcess::GetTimeCheckSync, COMDAT
; _this$ = ecx

; 280  : 	BOOL GetTimeCheckSync(){return this->m_bTimeCheckSync;}

  00000	8b 81 e4 03 00
	00		 mov	 eax, DWORD PTR [ecx+996]
  00006	c3		 ret	 0
?GetTimeCheckSync@CIllusionTempleProcess@@QAEHXZ ENDP	; CIllusionTempleProcess::GetTimeCheckSync
_TEXT	ENDS
PUBLIC	?GetOpenStatus@CIllusionTempleProcess@@QAEHXZ	; CIllusionTempleProcess::GetOpenStatus
; Function compile flags: /Ogtp
;	COMDAT ?GetOpenStatus@CIllusionTempleProcess@@QAEHXZ
_TEXT	SEGMENT
?GetOpenStatus@CIllusionTempleProcess@@QAEHXZ PROC	; CIllusionTempleProcess::GetOpenStatus, COMDAT
; _this$ = ecx

; 281  : 	BOOL GetOpenStatus(){return this->m_bOpenStatus;}

  00000	8b 81 90 03 00
	00		 mov	 eax, DWORD PTR [ecx+912]
  00006	c3		 ret	 0
?GetOpenStatus@CIllusionTempleProcess@@QAEHXZ ENDP	; CIllusionTempleProcess::GetOpenStatus
_TEXT	ENDS
PUBLIC	?GetEnteredUserCount@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetEnteredUserCount
; Function compile flags: /Ogtp
;	COMDAT ?GetEnteredUserCount@CIllusionTempleProcess@@QAEEXZ
_TEXT	SEGMENT
?GetEnteredUserCount@CIllusionTempleProcess@@QAEEXZ PROC ; CIllusionTempleProcess::GetEnteredUserCount, COMDAT
; _this$ = ecx

; 282  : 	BYTE GetEnteredUserCount(){return this->m_iEnteredUserCount;}

  00000	8a 81 28 02 00
	00		 mov	 al, BYTE PTR [ecx+552]
  00006	c3		 ret	 0
?GetEnteredUserCount@CIllusionTempleProcess@@QAEEXZ ENDP ; CIllusionTempleProcess::GetEnteredUserCount
_TEXT	ENDS
PUBLIC	?GetBallPlayerIndex@CIllusionTempleProcess@@QAEHXZ ; CIllusionTempleProcess::GetBallPlayerIndex
; Function compile flags: /Ogtp
;	COMDAT ?GetBallPlayerIndex@CIllusionTempleProcess@@QAEHXZ
_TEXT	SEGMENT
?GetBallPlayerIndex@CIllusionTempleProcess@@QAEHXZ PROC	; CIllusionTempleProcess::GetBallPlayerIndex, COMDAT
; _this$ = ecx

; 283  : 	int GetBallPlayerIndex(){return this->m_iBallPlayerIndex;}

  00000	8b 81 b8 03 00
	00		 mov	 eax, DWORD PTR [ecx+952]
  00006	c3		 ret	 0
?GetBallPlayerIndex@CIllusionTempleProcess@@QAEHXZ ENDP	; CIllusionTempleProcess::GetBallPlayerIndex
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_7CIllusionTempleEvent@@6B@			; CIllusionTempleEvent::`vftable'
PUBLIC	??0CIllusionTempleEvent@@QAE@XZ			; CIllusionTempleEvent::CIllusionTempleEvent
PUBLIC	??_R4CIllusionTempleEvent@@6B@			; CIllusionTempleEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCIllusionTempleEvent@@@8		; CIllusionTempleEvent `RTTI Type Descriptor'
PUBLIC	??_R3CIllusionTempleEvent@@8			; CIllusionTempleEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CIllusionTempleEvent@@8			; CIllusionTempleEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CIllusionTempleEvent@@8		; CIllusionTempleEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??0CIllusionTempleProcess@@QAE@XZ:PROC		; CIllusionTempleProcess::CIllusionTempleProcess
EXTRN	??1CIllusionTempleProcess@@UAE@XZ:PROC		; CIllusionTempleProcess::~CIllusionTempleProcess
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECIllusionTempleEvent@@UAEPAXI@Z:PROC	; CIllusionTempleEvent::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CIllusionTempleEvent@@8
; File e:\work\tranet_version\gs\gameserver\illusiontempleevent.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CIllusionTempleEvent@@8 DD FLAT:??_R0?AVCIllusionTempleEvent@@@8 ; CIllusionTempleEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CIllusionTempleEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CIllusionTempleEvent@@8
rdata$r	SEGMENT
??_R2CIllusionTempleEvent@@8 DD FLAT:??_R1A@?0A@EA@CIllusionTempleEvent@@8 ; CIllusionTempleEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CIllusionTempleEvent@@8
rdata$r	SEGMENT
??_R3CIllusionTempleEvent@@8 DD 00H			; CIllusionTempleEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CIllusionTempleEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCIllusionTempleEvent@@@8
_DATA	SEGMENT
??_R0?AVCIllusionTempleEvent@@@8 DD FLAT:??_7type_info@@6B@ ; CIllusionTempleEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCIllusionTempleEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CIllusionTempleEvent@@6B@
rdata$r	SEGMENT
??_R4CIllusionTempleEvent@@6B@ DD 00H			; CIllusionTempleEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCIllusionTempleEvent@@@8
	DD	FLAT:??_R3CIllusionTempleEvent@@8
rdata$r	ENDS
;	COMDAT ??_7CIllusionTempleEvent@@6B@
CONST	SEGMENT
??_7CIllusionTempleEvent@@6B@ DD FLAT:??_R4CIllusionTempleEvent@@6B@ ; CIllusionTempleEvent::`vftable'
	DD	FLAT:??_ECIllusionTempleEvent@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CIllusionTempleEvent@@QAE@XZ
_TEXT	SEGMENT
??0CIllusionTempleEvent@@QAE@XZ PROC			; CIllusionTempleEvent::CIllusionTempleEvent, COMDAT
; _this$ = ecx

; 37   : {

  00000	56		 push	 esi
  00001	68 00 00 00 00	 push	 OFFSET ??1CIllusionTempleProcess@@UAE@XZ ; CIllusionTempleProcess::~CIllusionTempleProcess
  00006	68 00 00 00 00	 push	 OFFSET ??0CIllusionTempleProcess@@QAE@XZ ; CIllusionTempleProcess::CIllusionTempleProcess
  0000b	8b f1		 mov	 esi, ecx
  0000d	6a 06		 push	 6
  0000f	68 f0 03 00 00	 push	 1008			; 000003f0H
  00014	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00017	50		 push	 eax
  00018	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CIllusionTempleEvent@@6B@
  0001e	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z

; 38   : 
; 39   : }

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	c3		 ret	 0
??0CIllusionTempleEvent@@QAE@XZ ENDP			; CIllusionTempleEvent::CIllusionTempleEvent
_TEXT	ENDS
PUBLIC	??1CIllusionTempleEvent@@UAE@XZ			; CIllusionTempleEvent::~CIllusionTempleEvent
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??1CIllusionTempleEvent@@UAE@XZ
_TEXT	SEGMENT
??1CIllusionTempleEvent@@UAE@XZ PROC			; CIllusionTempleEvent::~CIllusionTempleEvent, COMDAT
; _this$ = ecx

; 43   : 	
; 44   : }

  00000	68 00 00 00 00	 push	 OFFSET ??1CIllusionTempleProcess@@UAE@XZ ; CIllusionTempleProcess::~CIllusionTempleProcess
  00005	6a 06		 push	 6
  00007	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CIllusionTempleEvent@@6B@
  0000d	68 f0 03 00 00	 push	 1008			; 000003f0H
  00012	83 c1 08	 add	 ecx, 8
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0001b	c3		 ret	 0
??1CIllusionTempleEvent@@UAE@XZ ENDP			; CIllusionTempleEvent::~CIllusionTempleEvent
_TEXT	ENDS
PUBLIC	?Init@CIllusionTempleEvent@@QAEHXZ		; CIllusionTempleEvent::Init
EXTRN	?Init@CIllusionTempleProcess@@QAEXH@Z:PROC	; CIllusionTempleProcess::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CIllusionTempleEvent@@QAEHXZ
_TEXT	SEGMENT
?Init@CIllusionTempleEvent@@QAEHXZ PROC			; CIllusionTempleEvent::Init, COMDAT
; _this$ = ecx

; 47   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 48   : 	for(int i = 0; i < MAX_FLOOR_DATA+1; i++)

  00002	33 f6		 xor	 esi, esi
  00004	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$LL3@Init:

; 49   : 	{
; 50   : 		this->m_IllusionTempleProcess[i].Init(i);

  00007	56		 push	 esi
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 ?Init@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::Init
  0000f	46		 inc	 esi
  00010	81 c7 f0 03 00
	00		 add	 edi, 1008		; 000003f0H
  00016	83 fe 06	 cmp	 esi, 6
  00019	7c ec		 jl	 SHORT $LL3@Init

; 51   : 	}
; 52   : 	return TRUE;

  0001b	5f		 pop	 edi
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	5e		 pop	 esi

; 53   : }

  00022	c3		 ret	 0
?Init@CIllusionTempleEvent@@QAEHXZ ENDP			; CIllusionTempleEvent::Init
_TEXT	ENDS
PUBLIC	?Run@CIllusionTempleEvent@@QAEXXZ		; CIllusionTempleEvent::Run
EXTRN	?Run@CIllusionTempleProcess@@QAEXH@Z:PROC	; CIllusionTempleProcess::Run
EXTRN	?CheckSync@CIllusionTempleProcess@@QAEXXZ:PROC	; CIllusionTempleProcess::CheckSync
EXTRN	?GetRemainTime@CIllusionTempleProcess@@QAEEXZ:PROC ; CIllusionTempleProcess::GetRemainTime
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Run@CIllusionTempleEvent@@QAEXXZ
_TEXT	SEGMENT
_loc3$ = -4						; size = 4
?Run@CIllusionTempleEvent@@QAEXXZ PROC			; CIllusionTempleEvent::Run, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 	if(g_iIllusionTempleEvent == 0)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iIllusionTempleEvent@@3HA, 0 ; g_iIllusionTempleEvent
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	74 60		 je	 SHORT $LN2@Run

; 145  : 	{
; 146  : 		return;
; 147  : 	}
; 148  : 
; 149  : 	int loc2 = GetTickCount();

  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 150  : 	int loc3 = 0;
; 151  : 	int i;
; 152  : 
; 153  : 	if(this->m_IllusionTempleProcess[0].GetRemainTime() == 10 && this->m_IllusionTempleProcess[0].GetTimeCheckSync() == 0)

  00018	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0001b	8b ce		 mov	 ecx, esi
  0001d	8b d8		 mov	 ebx, eax
  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _loc3$[ebp], 0
  00026	e8 00 00 00 00	 call	 ?GetRemainTime@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetRemainTime
  0002b	3c 0a		 cmp	 al, 10			; 0000000aH
  0002d	75 17		 jne	 SHORT $LN15@Run
  0002f	83 bf ec 03 00
	00 00		 cmp	 DWORD PTR [edi+1004], 0
  00036	75 0e		 jne	 SHORT $LN15@Run

; 154  : 	{
; 155  : 		loc3 = 1;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	89 45 fc	 mov	 DWORD PTR _loc3$[ebp], eax

; 156  : 		this->m_IllusionTempleProcess[0].LockTimeCheckSync();

  00040	89 87 ec 03 00
	00		 mov	 DWORD PTR [edi+1004], eax
$LN15@Run:

; 157  : 	}
; 158  : 
; 159  : 	for(i = 0; i < MAX_FLOOR_DATA+1; i++)

  00046	bf 06 00 00 00	 mov	 edi, 6
  0004b	eb 03 8d 49 00	 npad	 5
$LL16@Run:

; 160  : 	{
; 161  : 		if(loc3 == 1)

  00050	83 7d fc 01	 cmp	 DWORD PTR _loc3$[ebp], 1
  00054	75 07		 jne	 SHORT $LN1@Run

; 162  : 		{
; 163  : 			this->m_IllusionTempleProcess[i].CheckSync();

  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?CheckSync@CIllusionTempleProcess@@QAEXXZ ; CIllusionTempleProcess::CheckSync
$LN1@Run:

; 164  : 		}
; 165  : 		this->m_IllusionTempleProcess[i].Run(loc2);

  0005d	53		 push	 ebx
  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 ?Run@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::Run
  00065	81 c6 f0 03 00
	00		 add	 esi, 1008		; 000003f0H
  0006b	4f		 dec	 edi
  0006c	75 e2		 jne	 SHORT $LL16@Run
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
$LN2@Run:
  00070	5f		 pop	 edi

; 166  : 	}
; 167  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?Run@CIllusionTempleEvent@@QAEXXZ ENDP			; CIllusionTempleEvent::Run
_TEXT	ENDS
PUBLIC	?SetRegPedestal@CIllusionTempleEvent@@QAEXEHE@Z	; CIllusionTempleEvent::SetRegPedestal
EXTRN	?UnlockTeamPedestal@CIllusionTempleProcess@@QAEXHE@Z:PROC ; CIllusionTempleProcess::UnlockTeamPedestal
; Function compile flags: /Ogtp
;	COMDAT ?SetRegPedestal@CIllusionTempleEvent@@QAEXEHE@Z
_TEXT	SEGMENT
_btMapNumber$ = 8					; size = 1
_aIndex$ = 12						; size = 4
_pos$ = 16						; size = 1
?SetRegPedestal@CIllusionTempleEvent@@QAEXEHE@Z PROC	; CIllusionTempleEvent::SetRegPedestal, COMDAT
; _this$ = ecx

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	if( CHECK_LIMIT( (btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 28		 js	 SHORT $LN2@SetRegPede
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 1a		 je	 SHORT $LN2@SetRegPede

; 172  : 	{
; 173  : 		return;
; 174  : 	}
; 175  : 	this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].UnlockTeamPedestal(aIndex, pos);

  0001f	8b 55 10	 mov	 edx, DWORD PTR _pos$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00034	e8 00 00 00 00	 call	 ?UnlockTeamPedestal@CIllusionTempleProcess@@QAEXHE@Z ; CIllusionTempleProcess::UnlockTeamPedestal
$LN2@SetRegPede:
  00039	5e		 pop	 esi

; 176  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?SetRegPedestal@CIllusionTempleEvent@@QAEXEHE@Z ENDP	; CIllusionTempleEvent::SetRegPedestal
_TEXT	ENDS
PUBLIC	?SetRelicsCarrierViewState@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::SetRelicsCarrierViewState
EXTRN	?GCSendPlayerRelicsCarrier@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleProcess::GCSendPlayerRelicsCarrier
; Function compile flags: /Ogtp
;	COMDAT ?SetRelicsCarrierViewState@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?SetRelicsCarrierViewState@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::SetRelicsCarrierViewState, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 180  : 	if( CHECK_LIMIT( (lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	0f b6 87 49 01
	00 00		 movzx	 eax, BYTE PTR [edi+329]
  0000f	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  00012	8b f1		 mov	 esi, ecx
  00014	85 d2		 test	 edx, edx
  00016	78 1f		 js	 SHORT $LN2@SetRelicsC
  00018	33 c9		 xor	 ecx, ecx
  0001a	83 fa 05	 cmp	 edx, 5
  0001d	0f 9e c1	 setle	 cl
  00020	85 c9		 test	 ecx, ecx
  00022	74 13		 je	 SHORT $LN2@SetRelicsC

; 181  : 	{
; 182  : 		return;
; 183  : 	}
; 184  : 	this->m_IllusionTempleProcess[lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GCSendPlayerRelicsCarrier(lpObj);

  00024	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0002a	57		 push	 edi
  0002b	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00032	e8 00 00 00 00	 call	 ?GCSendPlayerRelicsCarrier@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleProcess::GCSendPlayerRelicsCarrier
$LN2@SetRelicsC:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 185  : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?SetRelicsCarrierViewState@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::SetRelicsCarrierViewState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGReqIllusionTempleEnter@CIllusionTempleEvent@@QAEHHEEH@Z ; CIllusionTempleEvent::EGReqIllusionTempleEnter
EXTRN	?DataSendRank@@YAXPADH@Z:PROC			; DataSendRank
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
; Function compile flags: /Ogtp
;	COMDAT ?EGReqIllusionTempleEnter@CIllusionTempleEvent@@QAEHHEEH@Z
_TEXT	SEGMENT
_pMsg$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_FloorIndex$ = 12					; size = 1
_TicketPos$ = 16					; size = 1
_Level$ = 20						; size = 4
?EGReqIllusionTempleEnter@CIllusionTempleEvent@@QAEHHEEH@Z PROC ; CIllusionTempleEvent::EGReqIllusionTempleEnter, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 361  : 	if(DevilSquareEventConnect != 0) //season4 changed

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	74 13		 je	 SHORT $LN1@EGReqIllus

; 362  : 	{
; 363  : 		return FALSE;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 380  : 
; 381  : 	return TRUE;
; 382  : }

  00020	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00023	33 cd		 xor	 ecx, ebp
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
$LN1@EGReqIllus:

; 364  : 	}
; 365  : 
; 366  : 	PMSG_REQ_ILLUSIONTEMPLE_ENTER pMsg;
; 367  : 
; 368  : 	PHeadSetB((LPBYTE)&pMsg, 0x12, sizeof(pMsg));

  00030	6a 2c		 push	 44			; 0000002cH
  00032	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00035	6a 12		 push	 18			; 00000012H
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 369  : 
; 370  : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, 10);

  0003d	8b c6		 mov	 eax, esi
  0003f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00045	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004b	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0004e	89 4d d3	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  00051	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  00054	89 55 d7	 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00057	66 8b 48 74	 mov	 cx, WORD PTR [eax+116]
  0005b	66 89 4d db	 mov	 WORD PTR _pMsg$[ebp+11], cx

; 371  : 	memcpy(pMsg.CharacterName, gObj[aIndex].Name, 10);

  0005f	8b 50 77	 mov	 edx, DWORD PTR [eax+119]
  00062	89 55 dd	 mov	 DWORD PTR _pMsg$[ebp+13], edx
  00065	8b 48 7b	 mov	 ecx, DWORD PTR [eax+123]
  00068	89 4d e1	 mov	 DWORD PTR _pMsg$[ebp+17], ecx
  0006b	66 8b 50 7f	 mov	 dx, WORD PTR [eax+127]

; 372  : 
; 373  : 	pMsg.ServerCode = gGameServerCode;
; 374  : 	pMsg.Index = aIndex;
; 375  : 	pMsg.InventoryTicketPos = TicketPos;

  0006f	0f b6 4d 10	 movzx	 ecx, BYTE PTR _TicketPos$[ebp]
  00073	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0007a	66 89 55 e5	 mov	 WORD PTR _pMsg$[ebp+21], dx

; 376  : 	pMsg.Level = Level;

  0007e	8b 55 14	 mov	 edx, DWORD PTR _Level$[ebp]
  00081	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 377  : 	pMsg.FloorIndex = FloorIndex;
; 378  : 	
; 379  : 	DataSendRank((char *)&pMsg, pMsg.h.size); //season4 changed

  00084	0f b6 4d d1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00088	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0008b	0f b6 45 0c	 movzx	 eax, BYTE PTR _FloorIndex$[ebp]
  0008f	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+36], edx
  00092	51		 push	 ecx
  00093	8d 55 d0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00096	52		 push	 edx
  00097	89 75 ec	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  0009a	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+40], eax
  0009d	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank

; 380  : 
; 381  : 	return TRUE;
; 382  : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	83 c4 14	 add	 esp, 20			; 00000014H
  000a8	33 cd		 xor	 ecx, ebp
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	5e		 pop	 esi
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 10 00	 ret	 16			; 00000010H
?EGReqIllusionTempleEnter@CIllusionTempleEvent@@QAEHHEEH@Z ENDP ; CIllusionTempleEvent::EGReqIllusionTempleEnter
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGSetIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::EGSetIllusionTempleEnterCount
; Function compile flags: /Ogtp
;	COMDAT ?EGSetIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?EGSetIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::EGSetIllusionTempleEnterCount, COMDAT
; _this$ = ecx

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 533  : 	PMSG_REQ_ILLUSIONTEMPLE_ENTER_RESULT pMsg;
; 534  : 
; 535  : 	PHeadSetB((LPBYTE)&pMsg, 0x13, sizeof(pMsg));

  00014	6a 1c		 push	 28			; 0000001cH
  00016	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 13		 push	 19			; 00000013H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 536  : 
; 537  : 	memcpy(pMsg.AccountID, lpObj->AccountID, 10);

  00021	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
  00024	0f b7 46 74	 movzx	 eax, WORD PTR [esi+116]
  00028	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0002b	89 55 e7	 mov	 DWORD PTR _pMsg$[ebp+7], edx

; 538  : 	memcpy(pMsg.CharacterName, lpObj->Name, 10);

  0002e	8b 56 7b	 mov	 edx, DWORD PTR [esi+123]
  00031	66 89 45 eb	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00035	0f b7 46 7f	 movzx	 eax, WORD PTR [esi+127]
  00039	89 4d e3	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  0003c	8b 4e 77	 mov	 ecx, DWORD PTR [esi+119]
  0003f	89 55 f1	 mov	 DWORD PTR _pMsg$[ebp+17], edx

; 539  : 	pMsg.ServerCode = gGameServerCode;
; 540  : 	
; 541  : 	DataSendRank((char *)&pMsg, pMsg.h.size); //season4 changed

  00042	0f b6 55 e1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00046	89 4d ed	 mov	 DWORD PTR _pMsg$[ebp+13], ecx
  00049	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00050	66 89 45 f5	 mov	 WORD PTR _pMsg$[ebp+21], ax
  00054	52		 push	 edx
  00055	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00058	50		 push	 eax
  00059	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+24], ecx
  0005c	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank

; 542  : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	83 c4 14	 add	 esp, 20			; 00000014H
  00067	33 cd		 xor	 ecx, ebp
  00069	5e		 pop	 esi
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?EGSetIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::EGSetIllusionTempleEnterCount
_TEXT	ENDS
PUBLIC	?CheckEnterLevel@CIllusionTempleEvent@@QAEHHH@Z	; CIllusionTempleEvent::CheckEnterLevel
; Function compile flags: /Ogtp
;	COMDAT ?CheckEnterLevel@CIllusionTempleEvent@@QAEHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_TicketLevel$ = 12					; size = 4
?CheckEnterLevel@CIllusionTempleEvent@@QAEHHH@Z PROC	; CIllusionTempleEvent::CheckEnterLevel, COMDAT
; _this$ = ecx

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 559  : 	int loc2 = -1;
; 560  : 
; 561  : 	if( gObj[aIndex].Level < 220 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00012	03 c8		 add	 ecx, eax
  00014	0f b7 81 be 00
	00 00		 movzx	 eax, WORD PTR [ecx+190]
  0001b	ba dc 00 00 00	 mov	 edx, 220		; 000000dcH
  00020	66 3b c2	 cmp	 ax, dx

; 562  : 	{
; 563  : 		loc2 = -1;

  00023	0f 8c c9 00 00
	00		 jl	 $LN5@CheckEnter

; 564  : 	}
; 565  : 	else if( gObj[aIndex].Level < 271 )

  00029	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  0002e	66 3b c2	 cmp	 ax, dx
  00031	7d 11		 jge	 SHORT $LN17@CheckEnter

; 566  : 	{
; 567  : 		loc2 = 0;

  00033	33 c0		 xor	 eax, eax

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  00035	40		 inc	 eax
  00036	33 c9		 xor	 ecx, ecx
  00038	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  0003b	0f 94 c1	 sete	 cl
  0003e	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN17@CheckEnter:

; 568  : 	}
; 569  : 	else if( gObj[aIndex].Level < 321 )

  00044	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  00049	66 3b c2	 cmp	 ax, dx
  0004c	7d 14		 jge	 SHORT $LN15@CheckEnter

; 570  : 	{
; 571  : 		loc2 = 1;

  0004e	b8 01 00 00 00	 mov	 eax, 1

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  00053	40		 inc	 eax
  00054	33 c9		 xor	 ecx, ecx
  00056	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  00059	0f 94 c1	 sete	 cl
  0005c	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
$LN15@CheckEnter:

; 572  : 	}
; 573  : 	else if( gObj[aIndex].Level < 351 )

  00062	ba 5f 01 00 00	 mov	 edx, 351		; 0000015fH
  00067	66 3b c2	 cmp	 ax, dx
  0006a	7d 14		 jge	 SHORT $LN13@CheckEnter

; 574  : 	{
; 575  : 		loc2 = 2;

  0006c	b8 02 00 00 00	 mov	 eax, 2

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  00071	40		 inc	 eax
  00072	33 c9		 xor	 ecx, ecx
  00074	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  00077	0f 94 c1	 sete	 cl
  0007a	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN13@CheckEnter:

; 576  : 	}
; 577  : 	else if( gObj[aIndex].Level < 381 )

  00080	ba 7d 01 00 00	 mov	 edx, 381		; 0000017dH
  00085	66 3b c2	 cmp	 ax, dx
  00088	7d 14		 jge	 SHORT $LN11@CheckEnter

; 578  : 	{
; 579  : 		loc2 = 3;

  0008a	b8 03 00 00 00	 mov	 eax, 3

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  0008f	40		 inc	 eax
  00090	33 c9		 xor	 ecx, ecx
  00092	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  00095	0f 94 c1	 sete	 cl
  00098	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
$LN11@CheckEnter:

; 580  : 	}
; 581  : 	else if( gObj[aIndex].Level < 400 )

  0009e	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  000a3	66 3b c2	 cmp	 ax, dx

; 582  : 	{
; 583  : 		loc2 = 4;

  000a6	7c 0b		 jl	 SHORT $LN23@CheckEnter

; 584  : 	}
; 585  : 	else if( gObj[aIndex].Level == 400 && gObj[aIndex].ChangeUP3rd == 0)

  000a8	75 48		 jne	 SHORT $LN5@CheckEnter
  000aa	80 b9 bc 00 00
	00 00		 cmp	 BYTE PTR [ecx+188], 0
  000b1	75 14		 jne	 SHORT $LN7@CheckEnter
$LN23@CheckEnter:

; 586  : 	{
; 587  : 		loc2 = 4;

  000b3	b8 04 00 00 00	 mov	 eax, 4

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  000b8	40		 inc	 eax
  000b9	33 c9		 xor	 ecx, ecx
  000bb	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  000be	0f 94 c1	 sete	 cl
  000c1	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
$LN7@CheckEnter:

; 588  : 	}
; 589  : 	else if( gObj[aIndex].Level == 400 && gObj[aIndex].ChangeUP3rd != 0)

  000c7	66 3b c2	 cmp	 ax, dx
  000ca	75 26		 jne	 SHORT $LN5@CheckEnter
  000cc	80 b9 bc 00 00
	00 00		 cmp	 BYTE PTR [ecx+188], 0
  000d3	74 1d		 je	 SHORT $LN5@CheckEnter

; 590  : 	{
; 591  : 		if(g_iUseMaxLevelIllusionTemple != 0)

  000d5	33 c0		 xor	 eax, eax
  000d7	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iUseMaxLevelIllusionTemple@@3HA, eax ; g_iUseMaxLevelIllusionTemple
  000dd	0f 95 c0	 setne	 al

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  000e0	33 c9		 xor	 ecx, ecx
  000e2	83 c0 04	 add	 eax, 4
  000e5	40		 inc	 eax
  000e6	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  000e9	0f 94 c1	 sete	 cl
  000ec	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
$LN5@CheckEnter:

; 592  : 		{
; 593  : 			loc2 = 5;
; 594  : 		}
; 595  : 		else
; 596  : 		{
; 597  : 			loc2 = 4;
; 598  : 		}
; 599  : 	}
; 600  : 	else
; 601  : 	{
; 602  : 		loc2 = -1;

  000f2	83 c8 ff	 or	 eax, -1

; 603  : 	}
; 604  : 
; 605  : 	if(loc2+1 == TicketLevel)

  000f5	40		 inc	 eax
  000f6	33 c9		 xor	 ecx, ecx
  000f8	3b 45 0c	 cmp	 eax, DWORD PTR _TicketLevel$[ebp]
  000fb	0f 94 c1	 sete	 cl
  000fe	8b c1		 mov	 eax, ecx

; 606  : 	{
; 607  : 		return TRUE;
; 608  : 	}
; 609  : 	return FALSE;
; 610  : }

  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
?CheckEnterLevel@CIllusionTempleEvent@@QAEHHH@Z ENDP	; CIllusionTempleEvent::CheckEnterLevel
_TEXT	ENDS
PUBLIC	?SetNpcStatueUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleEvent::SetNpcStatueUser
EXTRN	?NpcStatueProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@0@Z:PROC ; CIllusionTempleProcess::NpcStatueProc
; Function compile flags: /Ogtp
;	COMDAT ?SetNpcStatueUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_lpObj$ = 12						; size = 4
_lpTargetObj$ = 16					; size = 4
?SetNpcStatueUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z PROC ; CIllusionTempleEvent::SetNpcStatueUser, COMDAT
; _this$ = ecx

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 614  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 28		 js	 SHORT $LN2@SetNpcStat
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 1a		 je	 SHORT $LN2@SetNpcStat

; 615  : 	{
; 616  : 		return;
; 617  : 	}
; 618  : 
; 619  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].NpcStatueProc(lpObj, lpTargetObj);

  0001f	8b 55 10	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00034	e8 00 00 00 00	 call	 ?NpcStatueProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleProcess::NpcStatueProc
$LN2@SetNpcStat:
  00039	5e		 pop	 esi

; 620  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?SetNpcStatueUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z ENDP ; CIllusionTempleEvent::SetNpcStatueUser
_TEXT	ENDS
PUBLIC	?SetNpcAlliedUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleEvent::SetNpcAlliedUser
EXTRN	?NpcAlliedPedestalProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@0@Z:PROC ; CIllusionTempleProcess::NpcAlliedPedestalProc
; Function compile flags: /Ogtp
;	COMDAT ?SetNpcAlliedUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_lpObj$ = 12						; size = 4
_lpTargetObj$ = 16					; size = 4
?SetNpcAlliedUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z PROC ; CIllusionTempleEvent::SetNpcAlliedUser, COMDAT
; _this$ = ecx

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 624  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 28		 js	 SHORT $LN2@SetNpcAlli
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 1a		 je	 SHORT $LN2@SetNpcAlli

; 625  : 	{
; 626  : 		return;
; 627  : 	}
; 628  : 
; 629  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].NpcAlliedPedestalProc(lpObj, lpTargetObj);

  0001f	8b 55 10	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00034	e8 00 00 00 00	 call	 ?NpcAlliedPedestalProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleProcess::NpcAlliedPedestalProc
$LN2@SetNpcAlli:
  00039	5e		 pop	 esi

; 630  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?SetNpcAlliedUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z ENDP ; CIllusionTempleEvent::SetNpcAlliedUser
_TEXT	ENDS
PUBLIC	?SetNpcRelicsUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleEvent::SetNpcRelicsUser
EXTRN	?NpcRelicsPedestalProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@0@Z:PROC ; CIllusionTempleProcess::NpcRelicsPedestalProc
; Function compile flags: /Ogtp
;	COMDAT ?SetNpcRelicsUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_lpObj$ = 12						; size = 4
_lpTargetObj$ = 16					; size = 4
?SetNpcRelicsUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z PROC ; CIllusionTempleEvent::SetNpcRelicsUser, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 634  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 28		 js	 SHORT $LN2@SetNpcReli
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 1a		 je	 SHORT $LN2@SetNpcReli

; 635  : 	{
; 636  : 		return;
; 637  : 	}
; 638  : 
; 639  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].NpcRelicsPedestalProc(lpObj, lpTargetObj);

  0001f	8b 55 10	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00034	e8 00 00 00 00	 call	 ?NpcRelicsPedestalProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleProcess::NpcRelicsPedestalProc
$LN2@SetNpcReli:
  00039	5e		 pop	 esi

; 640  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?SetNpcRelicsUser@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@0@Z ENDP ; CIllusionTempleEvent::SetNpcRelicsUser
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SetNpcMirageUser@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ; CIllusionTempleEvent::SetNpcMirageUser
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?CheckLeftMinutesBeforeOpen@CIllusionTempleProcess@@QAEEXZ:PROC ; CIllusionTempleProcess::CheckLeftMinutesBeforeOpen
EXTRN	?GetState@CIllusionTempleProcess@@QAEEXZ:PROC	; CIllusionTempleProcess::GetState
EXTRN	?CheckEnterItemPosition@CIllusionTempleProcess@@QAEHH@Z:PROC ; CIllusionTempleProcess::CheckEnterItemPosition
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
; Function compile flags: /Ogtp
;	COMDAT ?SetNpcMirageUser@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?SetNpcMirageUser@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; CIllusionTempleEvent::SetNpcMirageUser, COMDAT
; _this$ = ecx

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]

; 644  : 	if(lpTargetObj->m_IfState.use != 0 && lpTargetObj->m_IfState.type != 12)

  00014	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0001a	a8 03		 test	 al, 3
  0001c	74 10		 je	 SHORT $LN25@SetNpcMira
  0001e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00023	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  00028	0f 85 8f 01 00
	00		 jne	 $LN26@SetNpcMira
$LN25@SetNpcMira:

; 645  : 	{
; 646  : 		return;
; 647  : 	}
; 648  : 
; 649  : 	if(lpTargetObj->m_PK_Level >= 4)

  0002e	80 be 3d 01 00
	00 04		 cmp	 BYTE PTR [esi+317], 4
  00035	7c 2e		 jl	 SHORT $LN24@SetNpcMira

; 650  : 	{
; 651  : 		GCServerMsgStringSend(lMsg.Get(3400), lpTargetObj->m_Index, 1); //Player Killer are not allowed to enter Illusion Temple Event

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	6a 01		 push	 1
  0003b	50		 push	 eax
  0003c	68 48 0d 00 00	 push	 3400			; 00000d48H
$LN42@SetNpcMira:
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00046	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	5e		 pop	 esi

; 738  : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN24@SetNpcMira:

; 652  : 		return;
; 653  : 	}
; 654  : 
; 655  : 	int loc2 = -1;
; 656  : 
; 657  : 	if( lpTargetObj->Level < 220 )

  00065	0f b7 86 be 00
	00 00		 movzx	 eax, WORD PTR [esi+190]
  0006c	ba dc 00 00 00	 mov	 edx, 220		; 000000dcH
  00071	66 3b c2	 cmp	 ax, dx

; 658  : 	{
; 659  : 		loc2 = -1;

  00074	0f 8c 8c 00 00
	00		 jl	 $LN36@SetNpcMira

; 660  : 	}
; 661  : 	else if( lpTargetObj->Level < 271 )

  0007a	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  0007f	66 3b c2	 cmp	 ax, dx
  00082	7d 04		 jge	 SHORT $LN21@SetNpcMira

; 662  : 	{
; 663  : 		loc2 = 0;

  00084	33 c0		 xor	 eax, eax
  00086	eb 72		 jmp	 SHORT $LN8@SetNpcMira
$LN21@SetNpcMira:

; 664  : 	}
; 665  : 	else if( lpTargetObj->Level < 321 )

  00088	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  0008d	66 3b c2	 cmp	 ax, dx
  00090	7d 07		 jge	 SHORT $LN19@SetNpcMira

; 666  : 	{
; 667  : 		loc2 = 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	eb 61		 jmp	 SHORT $LN8@SetNpcMira
$LN19@SetNpcMira:

; 668  : 	}
; 669  : 	else if( lpTargetObj->Level < 351 )

  00099	ba 5f 01 00 00	 mov	 edx, 351		; 0000015fH
  0009e	66 3b c2	 cmp	 ax, dx
  000a1	7d 07		 jge	 SHORT $LN17@SetNpcMira

; 670  : 	{
; 671  : 		loc2 = 2;

  000a3	b8 02 00 00 00	 mov	 eax, 2
  000a8	eb 50		 jmp	 SHORT $LN8@SetNpcMira
$LN17@SetNpcMira:

; 672  : 	}
; 673  : 	else if( lpTargetObj->Level < 381 )

  000aa	ba 7d 01 00 00	 mov	 edx, 381		; 0000017dH
  000af	66 3b c2	 cmp	 ax, dx
  000b2	7d 07		 jge	 SHORT $LN15@SetNpcMira

; 674  : 	{
; 675  : 		loc2 = 3;

  000b4	b8 03 00 00 00	 mov	 eax, 3
  000b9	eb 3f		 jmp	 SHORT $LN8@SetNpcMira
$LN15@SetNpcMira:

; 676  : 	}
; 677  : 	else if( lpTargetObj->Level < 400 )

  000bb	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  000c0	66 3b c2	 cmp	 ax, dx
  000c3	7d 07		 jge	 SHORT $LN39@SetNpcMira

; 678  : 	{
; 679  : 		loc2 = 4;

  000c5	b8 04 00 00 00	 mov	 eax, 4
  000ca	eb 2e		 jmp	 SHORT $LN8@SetNpcMira
$LN39@SetNpcMira:

; 680  : 	}
; 681  : 	else if( lpTargetObj->Level == 400 && lpTargetObj->ChangeUP3rd == 0)

  000cc	75 10		 jne	 SHORT $LN11@SetNpcMira
  000ce	80 be bc 00 00
	00 00		 cmp	 BYTE PTR [esi+188], 0
  000d5	75 07		 jne	 SHORT $LN11@SetNpcMira

; 682  : 	{
; 683  : 		loc2 = 4;

  000d7	b8 04 00 00 00	 mov	 eax, 4
  000dc	eb 1c		 jmp	 SHORT $LN8@SetNpcMira
$LN11@SetNpcMira:

; 684  : 	}
; 685  : 	else if( lpTargetObj->Level == 400 && lpTargetObj->ChangeUP3rd != 0)

  000de	66 3b c2	 cmp	 ax, dx
  000e1	75 23		 jne	 SHORT $LN36@SetNpcMira
  000e3	80 be bc 00 00
	00 00		 cmp	 BYTE PTR [esi+188], 0
  000ea	74 1a		 je	 SHORT $LN36@SetNpcMira

; 686  : 	{
; 687  : 		if( g_iUseMaxLevelIllusionTemple != 0 )

  000ec	33 c0		 xor	 eax, eax
  000ee	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iUseMaxLevelIllusionTemple@@3HA, eax ; g_iUseMaxLevelIllusionTemple
  000f4	0f 95 c0	 setne	 al
  000f7	83 c0 04	 add	 eax, 4
$LN8@SetNpcMira:

; 688  : 		{
; 689  : 			loc2 = 5;
; 690  : 		}
; 691  : 		else
; 692  : 		{
; 693  : 			loc2 = 4;
; 694  : 		}
; 695  : 	}
; 696  : 	else
; 697  : 	{
; 698  : 		loc2 = -1;
; 699  : 	}
; 700  : 
; 701  : 	if(IT_TICKET_RANGE(loc2) == 0)

  000fa	33 d2		 xor	 edx, edx
  000fc	83 f8 05	 cmp	 eax, 5
  000ff	0f 9e c2	 setle	 dl
  00102	85 d2		 test	 edx, edx
  00104	75 0f		 jne	 SHORT $LN5@SetNpcMira
$LN36@SetNpcMira:

; 702  : 	{
; 703  : 		GCServerMsgStringSend(lMsg.Get(3401), lpTargetObj->m_Index, 1); //Your level is not enough to enter Illusion Temple Event

  00106	8b 06		 mov	 eax, DWORD PTR [esi]
  00108	6a 01		 push	 1
  0010a	50		 push	 eax
  0010b	68 49 0d 00 00	 push	 3401			; 00000d49H

; 704  : 		return;

  00110	e9 2c ff ff ff	 jmp	 $LN42@SetNpcMira
$LN5@SetNpcMira:

; 705  : 	}
; 706  : 
; 707  : 	int loc3 = this->m_IllusionTempleProcess[loc2].CheckEnterItemPosition(lpTargetObj->m_Index); //season 3.0 changed

  00115	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0011b	53		 push	 ebx
  0011c	57		 push	 edi
  0011d	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00120	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00122	51		 push	 ecx
  00123	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00126	e8 00 00 00 00	 call	 ?CheckEnterItemPosition@CIllusionTempleProcess@@QAEHH@Z ; CIllusionTempleProcess::CheckEnterItemPosition

; 708  : 
; 709  : 	if(loc3 == -1)

  0012b	83 f8 ff	 cmp	 eax, -1
  0012e	75 0c		 jne	 SHORT $LN4@SetNpcMira

; 710  : 	{
; 711  : 		GCServerMsgStringSend(lMsg.Get(3402), lpTargetObj->m_Index, 1); //You do not have Blood Scroll or the durability is broken to enter Illusion Temple Event

  00130	8b 16		 mov	 edx, DWORD PTR [esi]
  00132	6a 01		 push	 1
  00134	52		 push	 edx
  00135	68 4a 0d 00 00	 push	 3402			; 00000d4aH

; 712  : 		return;

  0013a	eb 6c		 jmp	 SHORT $LN40@SetNpcMira
$LN4@SetNpcMira:

; 713  : 	}
; 714  : 
; 715  : 	if(this->m_IllusionTempleProcess[loc2].GetState() != 0)

  0013c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0013f	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  00144	84 c0		 test	 al, al
  00146	74 0c		 je	 SHORT $LN3@SetNpcMira

; 716  : 	{
; 717  : 		GCServerMsgStringSend(lMsg.Get(3403), lpTargetObj->m_Index, 1); //Illusion Temple Event is not Open Yet!

  00148	8b 06		 mov	 eax, DWORD PTR [esi]
  0014a	6a 01		 push	 1
  0014c	50		 push	 eax
  0014d	68 4b 0d 00 00	 push	 3403			; 00000d4bH

; 718  : 		return;

  00152	eb 54		 jmp	 SHORT $LN40@SetNpcMira
$LN3@SetNpcMira:

; 719  : 	}
; 720  : 
; 721  : 	if(this->m_IllusionTempleProcess[loc2].GetState() != 0 || this->m_IllusionTempleProcess[loc2].GetOpenStatus() == FALSE)

  00154	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00157	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  0015c	84 c0		 test	 al, al
  0015e	75 3e		 jne	 SHORT $LN1@SetNpcMira
  00160	83 bf 98 03 00
	00 00		 cmp	 DWORD PTR [edi+920], 0
  00167	74 35		 je	 SHORT $LN1@SetNpcMira

; 724  : 		return;
; 725  : 	}
; 726  : 
; 727  : 	PMSG_TALKRESULT pMsg;
; 728  : 
; 729  : 	pMsg.h.c = 0xC3;
; 730  : 	pMsg.h.headcode = 0x30;
; 731  : 	pMsg.h.size = sizeof(pMsg);
; 732  : 	pMsg.result = 0x14;
; 733  : 
; 734  : 	pMsg.level1 = this->m_IllusionTempleProcess[loc2].CheckLeftMinutesBeforeOpen();

  00169	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0016c	c6 45 f0 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  00170	66 c7 45 f1 0b
	30		 mov	 WORD PTR _pMsg$[ebp+1], 12299 ; 0000300bH
  00176	c6 45 f3 14	 mov	 BYTE PTR _pMsg$[ebp+3], 20 ; 00000014H
  0017a	e8 00 00 00 00	 call	 ?CheckLeftMinutesBeforeOpen@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::CheckLeftMinutesBeforeOpen

; 735  : 	pMsg.level2 = this->m_IllusionTempleProcess[loc2].GetEnteredUserCount();
; 736  : 
; 737  : 	DataSend(lpTargetObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  0017f	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00183	8a 8f 30 02 00
	00		 mov	 cl, BYTE PTR [edi+560]
  00189	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0018c	52		 push	 edx
  0018d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00190	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  00193	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00195	50		 push	 eax
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0019c	eb 1a		 jmp	 SHORT $LN41@SetNpcMira
$LN1@SetNpcMira:

; 722  : 	{
; 723  : 		GCServerMsgStringSend(lMsg.Get(3404), lpTargetObj->m_Index, 1); //This is not the appropriate time

  0019e	8b 16		 mov	 edx, DWORD PTR [esi]
  001a0	6a 01		 push	 1
  001a2	52		 push	 edx
  001a3	68 4c 0d 00 00	 push	 3404			; 00000d4cH
$LN40@SetNpcMira:
  001a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001ad	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
$LN41@SetNpcMira:
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bb	5f		 pop	 edi
  001bc	5b		 pop	 ebx
$LN26@SetNpcMira:

; 738  : }

  001bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	5e		 pop	 esi
  001c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 08 00	 ret	 8
?SetNpcMirageUser@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CIllusionTempleEvent::SetNpcMirageUser
_TEXT	ENDS
PUBLIC	?SetDeleteRelicsItem@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::SetDeleteRelicsItem
EXTRN	?DeleteRelicsItem@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleProcess::DeleteRelicsItem
; Function compile flags: /Ogtp
;	COMDAT ?SetDeleteRelicsItem@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_lpObj$ = 12						; size = 4
?SetDeleteRelicsItem@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::SetDeleteRelicsItem, COMDAT
; _this$ = ecx

; 741  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 742  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 24		 js	 SHORT $LN2@SetDeleteR
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 16		 je	 SHORT $LN2@SetDeleteR

; 743  : 	{
; 744  : 		return;
; 745  : 	}
; 746  : 
; 747  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].DeleteRelicsItem(lpObj);

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	52		 push	 edx
  00029	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00030	e8 00 00 00 00	 call	 ?DeleteRelicsItem@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleProcess::DeleteRelicsItem
$LN2@SetDeleteR:
  00035	5e		 pop	 esi

; 748  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?SetDeleteRelicsItem@CIllusionTempleEvent@@QAEXEPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::SetDeleteRelicsItem
_TEXT	ENDS
PUBLIC	?SearchUserDropQuestItem@CIllusionTempleEvent@@QAEXEH@Z ; CIllusionTempleEvent::SearchUserDropQuestItem
EXTRN	?DropRelicsItem@CIllusionTempleProcess@@QAEXH@Z:PROC ; CIllusionTempleProcess::DropRelicsItem
; Function compile flags: /Ogtp
;	COMDAT ?SearchUserDropQuestItem@CIllusionTempleEvent@@QAEXEH@Z
_TEXT	SEGMENT
_btMapNumber$ = 8					; size = 1
_aIndex$ = 12						; size = 4
?SearchUserDropQuestItem@CIllusionTempleEvent@@QAEXEH@Z PROC ; CIllusionTempleEvent::SearchUserDropQuestItem, COMDAT
; _this$ = ecx

; 751  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 752  : 	if( CHECK_LIMIT( (btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 24		 js	 SHORT $LN2@SearchUser
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 16		 je	 SHORT $LN2@SearchUser

; 753  : 	{
; 754  : 		return;
; 755  : 	}
; 756  : 
; 757  : 	this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].DropRelicsItem(aIndex);

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	52		 push	 edx
  00029	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00030	e8 00 00 00 00	 call	 ?DropRelicsItem@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::DropRelicsItem
$LN2@SearchUser:
  00035	5e		 pop	 esi

; 758  : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?SearchUserDropQuestItem@CIllusionTempleEvent@@QAEXEH@Z ENDP ; CIllusionTempleEvent::SearchUserDropQuestItem
_TEXT	ENDS
PUBLIC	?OperateGMCommand@CIllusionTempleEvent@@QAEXHE@Z ; CIllusionTempleEvent::OperateGMCommand
; Function compile flags: /Ogtp
;	COMDAT ?OperateGMCommand@CIllusionTempleEvent@@QAEXHE@Z
_TEXT	SEGMENT
_iCommand$ = 8						; size = 4
_btMapNumber$ = 12					; size = 1
?OperateGMCommand@CIllusionTempleEvent@@QAEXHE@Z PROC	; CIllusionTempleEvent::OperateGMCommand, COMDAT
; _this$ = ecx

; 762  : 	return;
; 763  : 	switch ( iCommand )
; 764  : 	{
; 765  : 		case 1:
; 766  : 			if ( this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState() == 0 )
; 767  : 			{
; 768  : 				this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SetState(1);
; 769  : 			}
; 770  : 			break;
; 771  : 
; 772  : 		case 2:
; 773  : 			if ( this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState() == 1 )
; 774  : 			{
; 775  : 				this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SetState(2);
; 776  : 			}
; 777  : 			break;
; 778  : 
; 779  : 		case 3:
; 780  : 			if ( this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState() == 2 )
; 781  : 			{
; 782  : 				this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SetState(3);
; 783  : 			}
; 784  : 			break;
; 785  : 	}
; 786  : }

  00000	c2 08 00	 ret	 8
?OperateGMCommand@CIllusionTempleEvent@@QAEXHE@Z ENDP	; CIllusionTempleEvent::OperateGMCommand
_TEXT	ENDS
PUBLIC	?GetState@CIllusionTempleEvent@@QAEEE@Z		; CIllusionTempleEvent::GetState
; Function compile flags: /Ogtp
;	COMDAT ?GetState@CIllusionTempleEvent@@QAEEE@Z
_TEXT	SEGMENT
_btMapNumber$ = 8					; size = 1
?GetState@CIllusionTempleEvent@@QAEEE@Z PROC		; CIllusionTempleEvent::GetState, COMDAT
; _this$ = ecx

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 790  : 	return this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState();

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00007	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0000d	8d 8c 08 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+ecx-45352]
  00014	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState

; 791  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetState@CIllusionTempleEvent@@QAEEE@Z ENDP		; CIllusionTempleEvent::GetState
_TEXT	ENDS
PUBLIC	?CreateNPCPosition@CIllusionTempleEvent@@QAEXEHH@Z ; CIllusionTempleEvent::CreateNPCPosition
EXTRN	?SetNPCPosition@CIllusionTempleProcess@@QAEXHH@Z:PROC ; CIllusionTempleProcess::SetNPCPosition
; Function compile flags: /Ogtp
;	COMDAT ?CreateNPCPosition@CIllusionTempleEvent@@QAEXEHH@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_Class$ = 12						; size = 4
_Position$ = 16						; size = 4
?CreateNPCPosition@CIllusionTempleEvent@@QAEXEHH@Z PROC	; CIllusionTempleEvent::CreateNPCPosition, COMDAT
; _this$ = ecx

; 794  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 795  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 28		 js	 SHORT $LN2@CreateNPCP
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 1a		 je	 SHORT $LN2@CreateNPCP

; 796  : 	{
; 797  : 		return;
; 798  : 	}
; 799  : 
; 800  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SetNPCPosition(Class, Position);

  0001f	8b 55 10	 mov	 edx, DWORD PTR _Position$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _Class$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00034	e8 00 00 00 00	 call	 ?SetNPCPosition@CIllusionTempleProcess@@QAEXHH@Z ; CIllusionTempleProcess::SetNPCPosition
$LN2@CreateNPCP:
  00039	5e		 pop	 esi

; 801  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?CreateNPCPosition@CIllusionTempleEvent@@QAEXEHH@Z ENDP	; CIllusionTempleEvent::CreateNPCPosition
_TEXT	ENDS
PUBLIC	?CreateMonsterPosition@CIllusionTempleEvent@@QAEXEHH@Z ; CIllusionTempleEvent::CreateMonsterPosition
EXTRN	?SetMonsterPosition@CIllusionTempleProcess@@QAEXHH@Z:PROC ; CIllusionTempleProcess::SetMonsterPosition
; Function compile flags: /Ogtp
;	COMDAT ?CreateMonsterPosition@CIllusionTempleEvent@@QAEXEHH@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_Class$ = 12						; size = 4
_Position$ = 16						; size = 4
?CreateMonsterPosition@CIllusionTempleEvent@@QAEXEHH@Z PROC ; CIllusionTempleEvent::CreateMonsterPosition, COMDAT
; _this$ = ecx

; 804  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 805  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 28		 js	 SHORT $LN2@CreateMons
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 1a		 je	 SHORT $LN2@CreateMons

; 806  : 	{
; 807  : 		return;
; 808  : 	}
; 809  : 
; 810  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SetMonsterPosition(Class, Position);

  0001f	8b 55 10	 mov	 edx, DWORD PTR _Position$[ebp]
  00022	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _Class$[ebp]
  0002b	52		 push	 edx
  0002c	51		 push	 ecx
  0002d	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00034	e8 00 00 00 00	 call	 ?SetMonsterPosition@CIllusionTempleProcess@@QAEXHH@Z ; CIllusionTempleProcess::SetMonsterPosition
$LN2@CreateMons:
  00039	5e		 pop	 esi

; 811  : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?CreateMonsterPosition@CIllusionTempleEvent@@QAEXEHH@Z ENDP ; CIllusionTempleEvent::CreateMonsterPosition
_TEXT	ENDS
PUBLIC	?AllObjReset@CIllusionTempleEvent@@QAEXXZ	; CIllusionTempleEvent::AllObjReset
EXTRN	?ClearMonstersData@CIllusionTempleProcess@@QAEXXZ:PROC ; CIllusionTempleProcess::ClearMonstersData
; Function compile flags: /Ogtp
;	COMDAT ?AllObjReset@CIllusionTempleEvent@@QAEXXZ
_TEXT	SEGMENT
?AllObjReset@CIllusionTempleEvent@@QAEXXZ PROC		; CIllusionTempleEvent::AllObjReset, COMDAT
; _this$ = ecx

; 814  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 815  : 	for(int i = 0; i < MAX_FLOOR_DATA+1; i++)

  00002	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00005	bf 06 00 00 00	 mov	 edi, 6
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL3@AllObjRese:

; 816  : 	{
; 817  : 		this->m_IllusionTempleProcess[i].ClearMonstersData();

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?ClearMonstersData@CIllusionTempleProcess@@QAEXXZ ; CIllusionTempleProcess::ClearMonstersData
  00017	81 c6 f0 03 00
	00		 add	 esi, 1008		; 000003f0H
  0001d	4f		 dec	 edi
  0001e	75 f0		 jne	 SHORT $LL3@AllObjRese

; 818  : 	}
; 819  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	c3		 ret	 0
?AllObjReset@CIllusionTempleEvent@@QAEXXZ ENDP		; CIllusionTempleEvent::AllObjReset
_TEXT	ENDS
PUBLIC	?GetUserJoinSide@CIllusionTempleEvent@@QAEEEH@Z	; CIllusionTempleEvent::GetUserJoinSide
EXTRN	?GetUserJoinSide@CIllusionTempleProcess@@QAEEH@Z:PROC ; CIllusionTempleProcess::GetUserJoinSide
; Function compile flags: /Ogtp
;	COMDAT ?GetUserJoinSide@CIllusionTempleEvent@@QAEEEH@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GetUserJoinSide@CIllusionTempleEvent@@QAEEEH@Z PROC	; CIllusionTempleEvent::GetUserJoinSide, COMDAT
; _this$ = ecx

; 822  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 823  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 0e		 js	 SHORT $LN6@GetUserJoi
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	75 07		 jne	 SHORT $LN1@GetUserJoi
$LN6@GetUserJoi:

; 824  : 	{
; 825  : 		return -1;

  0001f	0c ff		 or	 al, 255			; 000000ffH
  00021	5e		 pop	 esi

; 828  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN1@GetUserJoi:

; 826  : 	}
; 827  : 	return this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetUserJoinSide(aIndex);

  00026	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00029	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0002f	52		 push	 edx
  00030	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00037	e8 00 00 00 00	 call	 ?GetUserJoinSide@CIllusionTempleProcess@@QAEEH@Z ; CIllusionTempleProcess::GetUserJoinSide
  0003c	5e		 pop	 esi

; 828  : }

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
?GetUserJoinSide@CIllusionTempleEvent@@QAEEEH@Z ENDP	; CIllusionTempleEvent::GetUserJoinSide
_TEXT	ENDS
PUBLIC	?SetNpcStatueRegen@CIllusionTempleEvent@@QAEXE@Z ; CIllusionTempleEvent::SetNpcStatueRegen
EXTRN	?SetNpcStatueRegen@CIllusionTempleProcess@@QAEXXZ:PROC ; CIllusionTempleProcess::SetNpcStatueRegen
; Function compile flags: /Ogtp
;	COMDAT ?SetNpcStatueRegen@CIllusionTempleEvent@@QAEXE@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
?SetNpcStatueRegen@CIllusionTempleEvent@@QAEXE@Z PROC	; CIllusionTempleEvent::SetNpcStatueRegen, COMDAT
; _this$ = ecx

; 831  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 832  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	78 20		 js	 SHORT $LN2@SetNpcStat@2
  00011	33 c9		 xor	 ecx, ecx
  00013	83 fa 05	 cmp	 edx, 5
  00016	0f 9e c1	 setle	 cl
  00019	8b d1		 mov	 edx, ecx
  0001b	85 d2		 test	 edx, edx
  0001d	74 12		 je	 SHORT $LN2@SetNpcStat@2

; 833  : 	{
; 834  : 		return;
; 835  : 	}
; 836  : 
; 837  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SetNpcStatueRegen();

  0001f	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00025	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  0002c	e8 00 00 00 00	 call	 ?SetNpcStatueRegen@CIllusionTempleProcess@@QAEXXZ ; CIllusionTempleProcess::SetNpcStatueRegen
$LN2@SetNpcStat@2:
  00031	5e		 pop	 esi

; 838  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?SetNpcStatueRegen@CIllusionTempleEvent@@QAEXE@Z ENDP	; CIllusionTempleEvent::SetNpcStatueRegen
_TEXT	ENDS
PUBLIC	??_C@_0GM@COJEOJKJ@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ ; `string'
PUBLIC	??_C@_0EJ@CFKLBJNP@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@ ; `string'
PUBLIC	??_C@_0EM@FKKOGKNO@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@ ; `string'
PUBLIC	??_C@_0GI@KCIMIBDH@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ ; `string'
PUBLIC	??_C@_0GE@DFBGLPMI@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ ; `string'
PUBLIC	??_C@_0BF@BJNLBONB@?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?0?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0FE@BHIHACNF@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ ; `string'
PUBLIC	_arg2$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?IllusionTempleChaosMix@CIllusionTempleEvent@@QAEEHHH@Z ; CIllusionTempleEvent::IllusionTempleChaosMix
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	_rand:PROC
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?g_iCrywolfApplyMvpBenefit@@3HA:DWORD		; g_iCrywolfApplyMvpBenefit
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CMixSystem::LogChaosItem
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	__imp__wsprintfA:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	__alldiv:PROC
;	COMDAT ??_C@_0GM@COJEOJKJ@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@
CONST	SEGMENT
??_C@_0GM@COJEOJKJ@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ DB '['
	DB	'Illusion Temple] ', 0c7H, 0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H
	DB	0e7H, 0b8H, 0b6H, 0b8H, 0aeH, ' Mix Chaos Mix Failed - MixRate'
	DB	' Out of Bound (Account:%s, Name:%s, Level:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@CFKLBJNP@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@
CONST	SEGMENT
??_C@_0EJ@CFKLBJNP@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@ DB '['
	DB	0c7H, 0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H, 0e7H, 0b8H, 0b6H
	DB	0b8H, 0aeH, ' Mix] [%s][%s] CBMix Fail %d Money : %d-%d, Charm'
	DB	'Rate : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@FKKOGKNO@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@
CONST	SEGMENT
??_C@_0EM@FKKOGKNO@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@ DB '['
	DB	0c7H, 0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H, 0e7H, 0b8H, 0b6H
	DB	0b8H, 0aeH, ' Mix] [%s][%s] CBMix Success %d Money : %d-%d, Ch'
	DB	'armRate : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@KCIMIBDH@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@
CONST	SEGMENT
??_C@_0GI@KCIMIBDH@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ DB '['
	DB	'Illusion Temple] ', 0c7H, 0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H
	DB	0e7H, 0b8H, 0b6H, 0b8H, 0aeH, ' Mix Chaos Mix Failed - Not Eno'
	DB	'ugh Money (Account:%s, Name:%s, Level:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@DFBGLPMI@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@
CONST	SEGMENT
??_C@_0GE@DFBGLPMI@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ DB '['
	DB	'Illusion Temple] ', 0c7H, 0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H
	DB	0e7H, 0b8H, 0b6H, 0b8H, 0aeH, ' Mix Chaos Mix Failed - MixMone'
	DB	'y < 0 (Account:%s, Name:%s, Level:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BJNLBONB@?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?0?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@BJNLBONB@?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?0?$CFd?$AA@ DB 0c7H
	DB	0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H, 0e7H, 0b8H, 0b6H, 0b8H
	DB	0aeH, ' Mix,%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@BHIHACNF@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@
CONST	SEGMENT
??_C@_0FE@BHIHACNF@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@ DB '['
	DB	'Illusion Temple] ', 0c7H, 0c7H, 0c0H, 0c7H, ' ', 0b5H, 0ceH, 0b7H
	DB	0e7H, 0b8H, 0b6H, 0b8H, 0aeH, ' Mix Chaos Mix Start (Account:%'
	DB	's, Name:%s, Level:%d)', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?IllusionTempleChaosMix@CIllusionTempleEvent@@QAEEHHH@Z
_TEXT	SEGMENT
_arg2$GSCopy$ = -48					; size = 4
_iMIX_NEED_MONEY$ = -44					; size = 4
_pMsg$ = -40						; size = 16
_szTemp$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
_arg3$ = 16						; size = 4
?IllusionTempleChaosMix@CIllusionTempleEvent@@QAEEHHH@Z PROC ; CIllusionTempleEvent::IllusionTempleChaosMix, COMDAT
; _this$ = ecx

; 925  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _arg2$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _arg1$[ebp]

; 1001 : 	}
; 1002 : 	else
; 1003 : 	{
; 1004 : 		g_MixSystem.ChaosBoxInit(&gObj[arg1]);

  00018	89 5d d0	 mov	 DWORD PTR _arg2$GSCopy$[ebp], ebx
  0001b	85 ff		 test	 edi, edi
  0001d	78 0f		 js	 SHORT $LN17@IllusionTe

; 926  : 	if( OBJMAX_RANGE(arg1) == FALSE )

  0001f	33 c0		 xor	 eax, eax
  00021	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	75 14		 jne	 SHORT $LN10@IllusionTe
$LN17@IllusionTe:
  0002e	5f		 pop	 edi

; 927  : 	{
; 928  : 		return FALSE;

  0002f	32 c0		 xor	 al, al
  00031	5b		 pop	 ebx

; 1013 : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
$LN10@IllusionTe:

; 929  : 	}
; 930  : 
; 931  : 	if ( IT_MAP_RANGE((arg2+(MAP_INDEX_ILLUSIONTEMPLE_MIN-1))) == FALSE )

  00042	8d 43 2c	 lea	 eax, DWORD PTR [ebx+44]
  00045	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00048	7c e4		 jl	 SHORT $LN17@IllusionTe
  0004a	33 c9		 xor	 ecx, ecx
  0004c	83 f8 32	 cmp	 eax, 50			; 00000032H
  0004f	0f 9e c1	 setle	 cl
  00052	8b c1		 mov	 eax, ecx
  00054	85 c0		 test	 eax, eax

; 932  : 	{
; 933  : 		return FALSE;

  00056	74 d6		 je	 SHORT $LN17@IllusionTe

; 934  : 	}
; 935  : 
; 936  : 	int loc2 = 0;
; 937  : 
; 938  : 	PMSG_CHAOSMIXRESULT pMsg;
; 939  : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00058	56		 push	 esi
  00059	6a 10		 push	 16			; 00000010H
  0005b	8d 55 d8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0005e	68 86 00 00 00	 push	 134			; 00000086H
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 940  : 	pMsg.Result = CB_ERROR;
; 941  : 
; 942  : 	gObj[arg1].ChaosLock = TRUE;

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	8b f7		 mov	 esi, edi
  00070	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00076	c6 45 db 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0007a	c7 84 06 88 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+3720], 1

; 943  : 	LogAddTD("[Illusion Temple]   Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)", gObj[arg1].AccountID, gObj[arg1].Name, arg2);

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008a	53		 push	 ebx
  0008b	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0008f	51		 push	 ecx
  00090	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00094	52		 push	 edx
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@BHIHACNF@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 944  : 
; 945  : 	char szTemp[17];
; 946  : 	wsprintf(szTemp, "  Mix,%d", arg2);

  000a0	53		 push	 ebx
  000a1	8d 45 e8	 lea	 eax, DWORD PTR _szTemp$[ebp]
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BJNLBONB@?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?0?$CFd?$AA@
  000a9	50		 push	 eax
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 947  : 
; 948  : 	g_MixSystem.LogChaosItem(&gObj[arg1], szTemp);

  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b6	83 c4 28	 add	 esp, 40			; 00000028H
  000b9	8d 4d e8	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000c0	50		 push	 eax
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  000c6	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 949  : 
; 950  : 	int iMIX_SUCCESS_RATE = g_iIT_ChoasMixSuccessRate[arg2-1]; //loc11

  000cb	8b 1c 9d fc ff
	ff ff		 mov	 ebx, DWORD PTR _g_iIT_ChoasMixSuccessRate[ebx*4-4]

; 951  : 
; 952  : 	if ( iMIX_SUCCESS_RATE < 0 || iMIX_SUCCESS_RATE > 100 )

  000d2	83 fb 64	 cmp	 ebx, 100		; 00000064H
  000d5	0f 87 d5 01 00
	00		 ja	 $LN7@IllusionTe

; 956  : 		return FALSE;
; 957  : 	}
; 958  : 
; 959  : 	if ( g_CrywolfSync.GetOccupationState() == 0 && g_iCrywolfApplyMvpBenefit )

  000db	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  000e0	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  000e5	85 c0		 test	 eax, eax
  000e7	75 14		 jne	 SHORT $LN6@IllusionTe
  000e9	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpBenefit@@3HA, eax ; g_iCrywolfApplyMvpBenefit
  000ef	74 0c		 je	 SHORT $LN6@IllusionTe

; 960  : 	{
; 961  : 		iMIX_SUCCESS_RATE += g_CrywolfSync.GetPlusChaosRate();

  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  000f6	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate
  000fb	03 d8		 add	 ebx, eax
$LN6@IllusionTe:

; 962  : 	}
; 963  : 
; 964  : 	int iMIX_NEED_MONEY = g_iIT_ChoasMixMoney[arg2-1]; //loc12

  000fd	8b 4d d0	 mov	 ecx, DWORD PTR _arg2$GSCopy$[ebp]
  00100	8b 14 8d fc ff
	ff ff		 mov	 edx, DWORD PTR _g_iIT_ChoasMixMoney[ecx*4-4]

; 965  : 
; 966  : 	int iChaosTaxMoney = (int)((__int64)(iMIX_NEED_MONEY) * (__int64)(g_CastleSiegeSync.GetTaxRateChaos(arg1)) / (__int64)100); //loc13

  00107	57		 push	 edi
  00108	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0010d	89 55 d4	 mov	 DWORD PTR _iMIX_NEED_MONEY$[ebp], edx
  00110	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00115	f7 6d d4	 imul	 DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00118	6a 00		 push	 0
  0011a	6a 64		 push	 100			; 00000064H
  0011c	52		 push	 edx
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 __alldiv

; 967  : 
; 968  : 	if ( iChaosTaxMoney < 0 )

  00123	85 c0		 test	 eax, eax
  00125	79 02		 jns	 SHORT $LN5@IllusionTe

; 969  : 	{
; 970  : 		iChaosTaxMoney = 0;

  00127	33 c0		 xor	 eax, eax
$LN5@IllusionTe:

; 971  : 	}
; 972  : 
; 973  : 	iMIX_NEED_MONEY += iChaosTaxMoney;

  00129	01 45 d4	 add	 DWORD PTR _iMIX_NEED_MONEY$[ebp], eax

; 974  : 
; 975  : 	if ( iMIX_NEED_MONEY <  0 )

  0012c	79 2c		 jns	 SHORT $LN4@IllusionTe

; 976  : 	{
; 977  : 		DataSend(arg1, (LPBYTE)&pMsg, pMsg.h.size);

  0012e	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00132	50		 push	 eax
  00133	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00136	51		 push	 ecx
  00137	57		 push	 edi
  00138	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 978  : 		LogAddTD("[Illusion Temple]   Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Level:%d)",	gObj[arg1].AccountID, gObj[arg1].Name, arg2);

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00142	8b 55 d0	 mov	 edx, DWORD PTR _arg2$GSCopy$[ebp]
  00145	52		 push	 edx
  00146	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0014a	51		 push	 ecx
  0014b	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0014f	52		 push	 edx
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@DFBGLPMI@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@

; 979  : 		return FALSE;

  00155	e9 7d 01 00 00	 jmp	 $LN20@IllusionTe
$LN4@IllusionTe:

; 980  : 	}
; 981  : 
; 982  : 	if ( (gObj[arg1].Money - iMIX_NEED_MONEY) < 0 )

  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00160	8b 94 0e f0 00
	00 00		 mov	 edx, DWORD PTR [esi+ecx+240]
  00167	2b 55 d4	 sub	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0016a	79 30		 jns	 SHORT $LN3@IllusionTe

; 983  : 	{
; 984  : 		pMsg.Result = CB_BC_NOT_ENOUGH_ZEN;
; 985  : 		DataSend(arg1, (LPBYTE)&pMsg, pMsg.h.size);

  0016c	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00170	50		 push	 eax
  00171	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00174	51		 push	 ecx
  00175	57		 push	 edi
  00176	c6 45 db 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH
  0017a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 986  : 		LogAddTD("[Illusion Temple]   Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s, Level:%d)",	gObj[arg1].AccountID, gObj[arg1].Name, arg2);

  0017f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00184	8b 55 d0	 mov	 edx, DWORD PTR _arg2$GSCopy$[ebp]
  00187	52		 push	 edx
  00188	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0018c	51		 push	 ecx
  0018d	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00191	52		 push	 edx
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@KCIMIBDH@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@

; 987  : 		return FALSE;

  00197	e9 3b 01 00 00	 jmp	 $LN20@IllusionTe
$LN3@IllusionTe:

; 988  : 	}
; 989  : 
; 990  : 	gObj[arg1].Money -= iMIX_NEED_MONEY;

  0019c	8b 55 d4	 mov	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0019f	29 94 0e f0 00
	00 00		 sub	 DWORD PTR [esi+ecx+240], edx

; 991  : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001a6	50		 push	 eax
  001a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  001ac	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 992  : 	GCMoneySend(arg1, gObj[arg1].Money);

  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b6	8b 8c 06 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+240]
  001bd	51		 push	 ecx
  001be	57		 push	 edi
  001bf	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 993  : 
; 994  : 	iMIX_SUCCESS_RATE += arg3; //season 3.0 moved

  001c4	03 5d 10	 add	 ebx, DWORD PTR _arg3$[ebp]
  001c7	83 c4 08	 add	 esp, 8

; 995  : 
; 996  : 	if ( (rand()%100) < iMIX_SUCCESS_RATE )	// Success (season 3.0 changed)

  001ca	e8 00 00 00 00	 call	 _rand
  001cf	99		 cdq
  001d0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001d5	f7 f9		 idiv	 ecx
  001d7	3b d3		 cmp	 edx, ebx
  001d9	7d 72		 jge	 SHORT $LN2@IllusionTe

; 997  : 	{
; 998  : 		int item_num = ITEMGET(13,51);	// Blood Scroll loc14
; 999  : 		ItemSerialCreateSend(arg1, -1, 0, 0, item_num, (BYTE)arg2, 0, 0, 0, 0, -1, 0, 0);

  001db	8b 55 d0	 mov	 edx, DWORD PTR _arg2$GSCopy$[ebp]
  001de	6a 00		 push	 0
  001e0	6a 00		 push	 0
  001e2	6a ff		 push	 -1
  001e4	6a 00		 push	 0
  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	6a 00		 push	 0
  001ec	52		 push	 edx
  001ed	68 33 1a 00 00	 push	 6707			; 00001a33H
  001f2	6a 00		 push	 0
  001f4	6a 00		 push	 0
  001f6	68 ff 00 00 00	 push	 255			; 000000ffH
  001fb	57		 push	 edi
  001fc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1000 : 		LogAddTD("[  Mix] [%s][%s] CBMix Success %d Money : %d-%d, CharmRate : %d",	gObj[arg1].AccountID, gObj[arg1].Name, iMIX_SUCCESS_RATE, gObj[arg1].Money, iMIX_NEED_MONEY, arg3);

  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00206	8b 4d 10	 mov	 ecx, DWORD PTR _arg3$[ebp]
  00209	8b 55 d4	 mov	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0020c	51		 push	 ecx
  0020d	8b 8c 06 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+240]
  00214	52		 push	 edx
  00215	51		 push	 ecx
  00216	53		 push	 ebx
  00217	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0021b	52		 push	 edx
  0021c	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00220	50		 push	 eax
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@FKKOGKNO@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0022c	83 c4 50	 add	 esp, 80			; 00000050H

; 1009 : 	}
; 1010 : 
; 1011 : 	::gObjInventoryCommit(arg1);

  0022f	57		 push	 edi
  00230	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00235	83 c4 04	 add	 esp, 4
  00238	5e		 pop	 esi
  00239	5f		 pop	 edi

; 1012 : 	return TRUE;

  0023a	b0 01		 mov	 al, 1
  0023c	5b		 pop	 ebx

; 1013 : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@IllusionTe:

; 1001 : 	}
; 1002 : 	else
; 1003 : 	{
; 1004 : 		g_MixSystem.ChaosBoxInit(&gObj[arg1]);

  0024d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00253	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00256	52		 push	 edx
  00257	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0025c	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 1005 : 		GCUserChaosBoxSend(&gObj[arg1], 0);

  00261	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00266	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00269	6a 00		 push	 0
  0026b	51		 push	 ecx
  0026c	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1006 : 		DataSend(arg1, (LPBYTE)&pMsg, pMsg.h.size);

  00271	0f b6 55 d9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00275	52		 push	 edx
  00276	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00279	50		 push	 eax
  0027a	57		 push	 edi
  0027b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1007 : 		LogAddTD("[  Mix] [%s][%s] CBMix Fail %d Money : %d-%d, CharmRate : %d", gObj[arg1].AccountID, gObj[arg1].Name, iMIX_SUCCESS_RATE, gObj[arg1].Money, iMIX_NEED_MONEY, arg3);

  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00285	8b 4d 10	 mov	 ecx, DWORD PTR _arg3$[ebp]
  00288	8b 55 d4	 mov	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  0028b	51		 push	 ecx
  0028c	8b 8c 06 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+240]
  00293	52		 push	 edx
  00294	51		 push	 ecx
  00295	53		 push	 ebx
  00296	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0029a	52		 push	 edx
  0029b	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@CFKLBJNP@?$FL?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBM@
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ab	83 c4 30	 add	 esp, 48			; 00000030H

; 1008 : 		return FALSE;

  002ae	eb 30		 jmp	 SHORT $LN21@IllusionTe
$LN7@IllusionTe:

; 953  : 	{
; 954  : 		DataSend(arg1, (LPBYTE)&pMsg, pMsg.h.size);

  002b0	0f b6 4d d9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  002b4	51		 push	 ecx
  002b5	8d 55 d8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002b8	52		 push	 edx
  002b9	57		 push	 edi
  002ba	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 955  : 		LogAddTD("[Illusion Temple]   Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Name:%s, Level:%d)", gObj[arg1].AccountID, gObj[arg1].Name, arg2);

  002bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c4	8b 4d d0	 mov	 ecx, DWORD PTR _arg2$GSCopy$[ebp]
  002c7	51		 push	 ecx
  002c8	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  002cc	52		 push	 edx
  002cd	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  002d1	50		 push	 eax
  002d2	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@COJEOJKJ@?$FLIllusion?5Temple?$FN?5?G?G?$MA?G?5?$LF?N?$LH?g?$LI?$LG?$LI?$KO?5@
$LN20@IllusionTe:
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002dd	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN21@IllusionTe:

; 1013 : }

  002e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e3	5e		 pop	 esi
  002e4	5f		 pop	 edi
  002e5	33 cd		 xor	 ecx, ebp
  002e7	32 c0		 xor	 al, al
  002e9	5b		 pop	 ebx
  002ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	c2 0c 00	 ret	 12			; 0000000cH
?IllusionTempleChaosMix@CIllusionTempleEvent@@QAEEHHH@Z ENDP ; CIllusionTempleEvent::IllusionTempleChaosMix
_TEXT	ENDS
PUBLIC	?CheckChoasMixItem@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckChoasMixItem
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckChoasMixItem@CIllusionTempleEvent@@QAEHH@Z
_TEXT	SEGMENT
_loc3$ = -20						; size = 4
_loc9$ = -16						; size = 4
_loc8$ = -12						; size = 4
_loc4$ = -8						; size = 4
_loc6$ = -4						; size = 4
_loc5$ = 8						; size = 4
_arg1$ = 8						; size = 4
?CheckChoasMixItem@CIllusionTempleEvent@@QAEHH@Z PROC	; CIllusionTempleEvent::CheckChoasMixItem, COMDAT
; _this$ = ecx

; 1016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1017 : 	if( OBJMAX_RANGE(arg1) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _arg1$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	3b c6		 cmp	 eax, esi
  0000e	7c 0e		 jl	 SHORT $LN36@CheckChoas
  00010	33 c9		 xor	 ecx, ecx
  00012	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00017	0f 9e c1	 setle	 cl
  0001a	3b ce		 cmp	 ecx, esi
  0001c	75 09		 jne	 SHORT $LN24@CheckChoas
$LN36@CheckChoas:

; 1018 : 	{
; 1019 : 		return FALSE;

  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN24@CheckChoas:
  00027	53		 push	 ebx
  00028	57		 push	 edi

; 1020 : 	}
; 1021 : 
; 1022 : 	int loc2 = 0;
; 1023 : 	int loc3 = 0;
; 1024 : 	int loc4 = 0;
; 1025 : 	int loc5 = 0;
; 1026 : 	int loc6 = 0;
; 1027 : 	int loc7 = 0;
; 1028 : 	int loc8 = 0;
; 1029 : 	int loc9 = 0;

  00029	8b f8		 mov	 edi, eax
  0002b	33 db		 xor	 ebx, ebx
  0002d	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00033	89 75 ec	 mov	 DWORD PTR _loc3$[ebp], esi
  00036	89 75 f8	 mov	 DWORD PTR _loc4$[ebp], esi
  00039	89 75 08	 mov	 DWORD PTR _loc5$[ebp], esi
  0003c	89 75 fc	 mov	 DWORD PTR _loc6$[ebp], esi
  0003f	89 75 f4	 mov	 DWORD PTR _loc8$[ebp], esi
  00042	89 75 f0	 mov	 DWORD PTR _loc9$[ebp], esi
  00045	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL23@CheckChoas:

; 1033 : 	{
; 1034 : 		if ( gObj[arg1].pChaosBox[n].IsItem() == TRUE )

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	8b 8c 07 78 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3704]
  0005c	03 ce		 add	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00063	83 f8 01	 cmp	 eax, 1
  00066	75 6e		 jne	 SHORT $LN22@CheckChoas

; 1035 : 		{
; 1036 : 			if( gObj[arg1].pChaosBox[n].m_Type == ITEMGET(12,15))

  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	8b 84 0f 78 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3704]
  00075	0f b7 4c 30 06	 movzx	 ecx, WORD PTR [eax+esi+6]
  0007a	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  0007f	66 3b ca	 cmp	 cx, dx
  00082	75 09		 jne	 SHORT $LN19@CheckChoas

; 1037 : 			{
; 1038 : 				loc3 = 1;

  00084	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _loc3$[ebp], 1
  0008b	eb 49		 jmp	 SHORT $LN22@CheckChoas
$LN19@CheckChoas:

; 1039 : 			}
; 1040 : 			else if( gObj[arg1].pChaosBox[n].m_Type == ITEMGET(13,49))

  0008d	ba 31 1a 00 00	 mov	 edx, 6705		; 00001a31H
  00092	66 3b ca	 cmp	 cx, dx
  00095	75 12		 jne	 SHORT $LN17@CheckChoas

; 1041 : 			{
; 1042 : 				int loc12 = gObj[arg1].pChaosBox[n].m_Level;
; 1043 : 				loc7++;
; 1044 : 				loc4 = 1; //IsItem??
; 1045 : 				loc8 = loc12;

  00097	0f bf 44 30 08	 movsx	 eax, WORD PTR [eax+esi+8]
  0009c	43		 inc	 ebx
  0009d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _loc4$[ebp], 1
  000a4	89 45 f4	 mov	 DWORD PTR _loc8$[ebp], eax
  000a7	eb 2d		 jmp	 SHORT $LN22@CheckChoas
$LN17@CheckChoas:

; 1046 : 			}
; 1047 : 			else if( gObj[arg1].pChaosBox[n].m_Type == ITEMGET(13,50))

  000a9	ba 32 1a 00 00	 mov	 edx, 6706		; 00001a32H
  000ae	66 3b ca	 cmp	 cx, dx
  000b1	75 12		 jne	 SHORT $LN15@CheckChoas

; 1048 : 			{
; 1049 : 				int loc13 = gObj[arg1].pChaosBox[n].m_Level;
; 1050 : 				loc7++;
; 1051 : 				loc5 = 1; //IsItem??
; 1052 : 				loc9 = loc13;

  000b3	0f bf 44 30 08	 movsx	 eax, WORD PTR [eax+esi+8]
  000b8	43		 inc	 ebx
  000b9	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _loc5$[ebp], 1
  000c0	89 45 f0	 mov	 DWORD PTR _loc9$[ebp], eax
  000c3	eb 11		 jmp	 SHORT $LN22@CheckChoas
$LN15@CheckChoas:

; 1053 : 			}
; 1054 : 			else if( gObj[arg1].pChaosBox[n].m_Type == ITEMGET(14,53) )

  000c5	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000ca	66 3b ca	 cmp	 cx, dx
  000cd	74 07		 je	 SHORT $LN22@CheckChoas

; 1055 : 			{
; 1056 : 				loc10+= (int)gObj[arg1].pChaosBox[n].m_Durability;
; 1057 : 			}
; 1058 : 			else
; 1059 : 			{
; 1060 : 				loc6 = 1; //invalid

  000cf	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _loc6$[ebp], 1
$LN22@CheckChoas:

; 1030 : 	int loc10 = 0;
; 1031 : 
; 1032 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++) //loc11

  000d6	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000dc	81 fe 80 1a 00
	00		 cmp	 esi, 6784		; 00001a80H
  000e2	0f 8c 68 ff ff
	ff		 jl	 $LL23@CheckChoas

; 1061 : 			}
; 1062 : 		}
; 1063 : 	}
; 1064 : 
; 1065 : 	if(loc6 != 0)

  000e8	83 7d fc 00	 cmp	 DWORD PTR _loc6$[ebp], 0
  000ec	74 0e		 je	 SHORT $LN11@CheckChoas

; 1066 : 	{
; 1067 : 		return 8;

  000ee	5f		 pop	 edi
  000ef	5b		 pop	 ebx
  000f0	b8 08 00 00 00	 mov	 eax, 8
  000f5	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 04 00	 ret	 4
$LN11@CheckChoas:

; 1068 : 	}
; 1069 : 
; 1070 : 	if(loc4 == 0 && loc5 == 0)

  000fc	83 7d f8 00	 cmp	 DWORD PTR _loc4$[ebp], 0
  00100	75 15		 jne	 SHORT $LN35@CheckChoas
  00102	83 7d 08 00	 cmp	 DWORD PTR _loc5$[ebp], 0
  00106	0f 85 a8 00 00
	00		 jne	 $LN8@CheckChoas

; 1071 : 	{
; 1072 : 		return FALSE;

  0010c	5f		 pop	 edi
  0010d	5b		 pop	 ebx
  0010e	33 c0		 xor	 eax, eax
  00110	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 04 00	 ret	 4
$LN35@CheckChoas:

; 1073 : 	}
; 1074 : 
; 1075 : 	if(loc4 == 0 || loc5 == 0)

  00117	83 7d 08 00	 cmp	 DWORD PTR _loc5$[ebp], 0
  0011b	0f 84 93 00 00
	00		 je	 $LN8@CheckChoas

; 1078 : 	}
; 1079 : 
; 1080 : 	if(loc7 > 2)

  00121	83 fb 02	 cmp	 ebx, 2
  00124	7e 0e		 jle	 SHORT $LN7@CheckChoas

; 1081 : 	{
; 1082 : 		return 12;

  00126	5f		 pop	 edi
  00127	5b		 pop	 ebx
  00128	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0012d	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
$LN7@CheckChoas:

; 1083 : 	}
; 1084 : 
; 1085 : 	if(loc8 != loc9)

  00134	8b 75 f4	 mov	 esi, DWORD PTR _loc8$[ebp]
  00137	8b 4d f0	 mov	 ecx, DWORD PTR _loc9$[ebp]
  0013a	3b f1		 cmp	 esi, ecx

; 1086 : 	{
; 1087 : 		return 9;

  0013c	75 2a		 jne	 SHORT $LN38@CheckChoas

; 1088 : 	}
; 1089 : 
; 1090 : 	if(IT_TICKET_RANGE(loc8-1) == FALSE)

  0013e	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00141	85 c0		 test	 eax, eax
  00143	78 23		 js	 SHORT $LN38@CheckChoas
  00145	33 d2		 xor	 edx, edx
  00147	83 f8 05	 cmp	 eax, 5
  0014a	0f 9e c2	 setle	 dl
  0014d	8b c2		 mov	 eax, edx
  0014f	85 c0		 test	 eax, eax

; 1091 : 	{
; 1092 : 		return 9;

  00151	74 15		 je	 SHORT $LN38@CheckChoas

; 1093 : 	}
; 1094 : 
; 1095 : 	if(IT_TICKET_RANGE(loc9-1) == FALSE)

  00153	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00156	85 c0		 test	 eax, eax
  00158	78 0e		 js	 SHORT $LN38@CheckChoas
  0015a	33 c9		 xor	 ecx, ecx
  0015c	83 f8 05	 cmp	 eax, 5
  0015f	0f 9e c1	 setle	 cl
  00162	8b c1		 mov	 eax, ecx
  00164	85 c0		 test	 eax, eax
  00166	75 0e		 jne	 SHORT $LN4@CheckChoas
$LN38@CheckChoas:
  00168	5f		 pop	 edi
  00169	5b		 pop	 ebx

; 1096 : 	{
; 1097 : 		return 9;

  0016a	b8 09 00 00 00	 mov	 eax, 9
  0016f	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 04 00	 ret	 4
$LN4@CheckChoas:

; 1098 : 	}
; 1099 : 
; 1100 : 	if(loc3 == 0)

  00176	83 7d ec 00	 cmp	 DWORD PTR _loc3$[ebp], 0
  0017a	75 0e		 jne	 SHORT $LN3@CheckChoas

; 1101 : 	{
; 1102 : 		return 10;

  0017c	5f		 pop	 edi
  0017d	5b		 pop	 ebx
  0017e	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00183	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 04 00	 ret	 4
$LN3@CheckChoas:

; 1103 : 	}
; 1104 : 
; 1105 : 	if(gObj[arg1].Level < 10)

  0018a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00190	66 83 bc 17 be
	00 00 00 0a	 cmp	 WORD PTR [edi+edx+190], 10 ; 0000000aH
  00199	7d 0e		 jge	 SHORT $LN2@CheckChoas

; 1106 : 	{
; 1107 : 		return 14;

  0019b	5f		 pop	 edi
  0019c	5b		 pop	 ebx
  0019d	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  001a2	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 04 00	 ret	 4
$LN2@CheckChoas:
  001a9	5f		 pop	 edi
  001aa	5b		 pop	 ebx

; 1108 : 	}
; 1109 : 
; 1110 : 	if(loc3 != 0 && loc4 != 0 && loc5 != 0)
; 1111 : 	{
; 1112 : 		return loc8;

  001ab	8b c6		 mov	 eax, esi
  001ad	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c2 04 00	 ret	 4
$LN8@CheckChoas:
  001b4	5f		 pop	 edi
  001b5	5b		 pop	 ebx

; 1076 : 	{
; 1077 : 		return 11;

  001b6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  001bb	5e		 pop	 esi

; 1113 : 	}
; 1114 : 
; 1115 : 	return FALSE;
; 1116 : }

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 04 00	 ret	 4
?CheckChoasMixItem@CIllusionTempleEvent@@QAEHH@Z ENDP	; CIllusionTempleEvent::CheckChoasMixItem
_TEXT	ENDS
PUBLIC	?SetKillCount@CIllusionTempleEvent@@QAEEHEE@Z	; CIllusionTempleEvent::SetKillCount
EXTRN	?IncreaseMonsterKillCount@CIllusionTempleProcess@@QAEXH@Z:PROC ; CIllusionTempleProcess::IncreaseMonsterKillCount
EXTRN	?AddKillPointToUser@CIllusionTempleProcess@@QAEEHE@Z:PROC ; CIllusionTempleProcess::AddKillPointToUser
EXTRN	?IncreaseUserKillCount@CIllusionTempleProcess@@QAEXH@Z:PROC ; CIllusionTempleProcess::IncreaseUserKillCount
; Function compile flags: /Ogtp
;	COMDAT ?SetKillCount@CIllusionTempleEvent@@QAEEHEE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_loc2$ = 12						; size = 1
_btMapNumber$ = 12					; size = 1
_btObjType$ = 16					; size = 1
?SetKillCount@CIllusionTempleEvent@@QAEEHEE@Z PROC	; CIllusionTempleEvent::SetKillCount, COMDAT
; _this$ = ecx

; 1119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1120 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	78 0f		 js	 SHORT $LN11@SetKillCou
  0000e	33 c0		 xor	 eax, eax
  00010	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN4@SetKillCou
$LN11@SetKillCou:
  0001d	5f		 pop	 edi

; 1121 : 	{
; 1122 : 		return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	5e		 pop	 esi

; 1144 : }

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
$LN4@SetKillCou:

; 1123 : 	}
; 1124 : 
; 1125 : 	if( CHECK_LIMIT( (btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00025	0f b6 45 0c	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00029	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0002c	85 d2		 test	 edx, edx
  0002e	78 ed		 js	 SHORT $LN11@SetKillCou
  00030	33 c9		 xor	 ecx, ecx
  00032	83 fa 05	 cmp	 edx, 5
  00035	0f 9e c1	 setle	 cl
  00038	8b d1		 mov	 edx, ecx
  0003a	85 d2		 test	 edx, edx

; 1126 : 	{
; 1127 : 		return FALSE;

  0003c	74 df		 je	 SHORT $LN11@SetKillCou

; 1128 : 	}
; 1129 : 
; 1130 : 	BYTE loc2 = 0;
; 1131 : 
; 1132 : 	if(btObjType == 1)
; 1133 : 	{
; 1134 : 		this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].IncreaseUserKillCount(aIndex);

  0003e	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00044	80 7d 10 01	 cmp	 BYTE PTR _btObjType$[ebp], 1
  00048	8d b4 30 d8 4e
	ff ff		 lea	 esi, DWORD PTR [eax+esi-45352]
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	75 1b		 jne	 SHORT $LN2@SetKillCou
  00054	e8 00 00 00 00	 call	 ?IncreaseUserKillCount@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::IncreaseUserKillCount

; 1135 : 		loc2 = 5;

  00059	c6 45 0c 05	 mov	 BYTE PTR _loc2$[ebp], 5

; 1141 : 	}
; 1142 : 
; 1143 : 	return this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].AddKillPointToUser(aIndex, loc2);

  0005d	8b 55 0c	 mov	 edx, DWORD PTR _loc2$[ebp]
  00060	52		 push	 edx
  00061	57		 push	 edi
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?AddKillPointToUser@CIllusionTempleProcess@@QAEEHE@Z ; CIllusionTempleProcess::AddKillPointToUser
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 1144 : }

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SetKillCou:

; 1136 : 	}
; 1137 : 	else
; 1138 : 	{
; 1139 : 		this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].IncreaseMonsterKillCount(aIndex);

  0006f	e8 00 00 00 00	 call	 ?IncreaseMonsterKillCount@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::IncreaseMonsterKillCount

; 1140 : 		loc2 = 2;

  00074	c6 45 0c 02	 mov	 BYTE PTR _loc2$[ebp], 2

; 1141 : 	}
; 1142 : 
; 1143 : 	return this->m_IllusionTempleProcess[btMapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].AddKillPointToUser(aIndex, loc2);

  00078	8b 55 0c	 mov	 edx, DWORD PTR _loc2$[ebp]
  0007b	52		 push	 edx
  0007c	57		 push	 edi
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?AddKillPointToUser@CIllusionTempleProcess@@QAEEHE@Z ; CIllusionTempleProcess::AddKillPointToUser
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 1144 : }

  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?SetKillCount@CIllusionTempleEvent@@QAEEHEE@Z ENDP	; CIllusionTempleEvent::SetKillCount
_TEXT	ENDS
PUBLIC	?RemoveKillPointFromUser@CIllusionTempleEvent@@QAEEHEE@Z ; CIllusionTempleEvent::RemoveKillPointFromUser
EXTRN	?RemoveKillPointFromUser@CIllusionTempleProcess@@QAEEHE@Z:PROC ; CIllusionTempleProcess::RemoveKillPointFromUser
; Function compile flags: /Ogtp
;	COMDAT ?RemoveKillPointFromUser@CIllusionTempleEvent@@QAEEHEE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_KillPoint$ = 16					; size = 1
?RemoveKillPointFromUser@CIllusionTempleEvent@@QAEEHEE@Z PROC ; CIllusionTempleEvent::RemoveKillPointFromUser, COMDAT
; _this$ = ecx

; 1147 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1148 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 0f		 js	 SHORT $LN9@RemoveKill
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 08		 jne	 SHORT $LN2@RemoveKill
$LN9@RemoveKill:
  0001d	5f		 pop	 edi

; 1149 : 	{
; 1150 : 		return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	5e		 pop	 esi

; 1159 : }

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
$LN2@RemoveKill:

; 1151 : 	}
; 1152 : 
; 1153 : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00025	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00029	8d 50 d3	 lea	 edx, DWORD PTR [eax-45]
  0002c	85 d2		 test	 edx, edx
  0002e	78 ed		 js	 SHORT $LN9@RemoveKill
  00030	33 c9		 xor	 ecx, ecx
  00032	83 fa 05	 cmp	 edx, 5
  00035	0f 9e c1	 setle	 cl
  00038	8b d1		 mov	 edx, ecx
  0003a	85 d2		 test	 edx, edx

; 1154 : 	{
; 1155 : 		return FALSE;

  0003c	74 df		 je	 SHORT $LN9@RemoveKill

; 1156 : 	}
; 1157 : 
; 1158 : 	return this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].RemoveKillPointFromUser(aIndex, KillPoint);

  0003e	8b 55 10	 mov	 edx, DWORD PTR _KillPoint$[ebp]
  00041	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00047	52		 push	 edx
  00048	56		 push	 esi
  00049	8d 8c 38 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+edi-45352]
  00050	e8 00 00 00 00	 call	 ?RemoveKillPointFromUser@CIllusionTempleProcess@@QAEEHE@Z ; CIllusionTempleProcess::RemoveKillPointFromUser
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 1159 : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?RemoveKillPointFromUser@CIllusionTempleEvent@@QAEEHEE@Z ENDP ; CIllusionTempleEvent::RemoveKillPointFromUser
_TEXT	ENDS
PUBLIC	?RunningSkill@CIllusionTempleEvent@@QAEXHGHE@Z	; CIllusionTempleEvent::RunningSkill
EXTRN	?RunningSkill@CIllusionTempleProcess@@QAEXHGHE@Z:PROC ; CIllusionTempleProcess::RunningSkill
; Function compile flags: /Ogtp
;	COMDAT ?RunningSkill@CIllusionTempleEvent@@QAEXHGHE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_skill$ = 12						; size = 2
_aTargetIndex$ = 16					; size = 4
_dis$ = 20						; size = 1
?RunningSkill@CIllusionTempleEvent@@QAEXHGHE@Z PROC	; CIllusionTempleEvent::RunningSkill, COMDAT
; _this$ = ecx

; 1162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1163 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 57		 js	 SHORT $LN3@RunningSki
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 48		 je	 SHORT $LN3@RunningSki

; 1164 : 	{
; 1165 : 		return;
; 1166 : 	}
; 1167 : 
; 1168 : 	if(IT_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE)

  0001a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	8b c6		 mov	 eax, esi
  00022	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00028	8a 94 10 49 01
	00 00		 mov	 dl, BYTE PTR [eax+edx+329]
  0002f	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00032	72 2e		 jb	 SHORT $LN3@RunningSki
  00034	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00039	3a c2		 cmp	 al, dl
  0003b	1b c0		 sbb	 eax, eax
  0003d	40		 inc	 eax
  0003e	74 22		 je	 SHORT $LN3@RunningSki

; 1169 : 	{
; 1170 : 		return;
; 1171 : 	}
; 1172 : 
; 1173 : 	this->m_IllusionTempleProcess[gObj[aIndex].MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].RunningSkill(aIndex, skill, aTargetIndex, dis);

  00040	8b 45 14	 mov	 eax, DWORD PTR _dis$[ebp]
  00043	0f b6 d2	 movzx	 edx, dl
  00046	50		 push	 eax
  00047	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  0004d	8b 45 10	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00050	50		 push	 eax
  00051	8b 45 0c	 mov	 eax, DWORD PTR _skill$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	8d 8c 0a d8 4e
	ff ff		 lea	 ecx, DWORD PTR [edx+ecx-45352]
  0005d	e8 00 00 00 00	 call	 ?RunningSkill@CIllusionTempleProcess@@QAEXHGHE@Z ; CIllusionTempleProcess::RunningSkill
$LN3@RunningSki:
  00062	5e		 pop	 esi

; 1174 : }

  00063	5d		 pop	 ebp
  00064	c2 10 00	 ret	 16			; 00000010H
?RunningSkill@CIllusionTempleEvent@@QAEXHGHE@Z ENDP	; CIllusionTempleEvent::RunningSkill
_TEXT	ENDS
PUBLIC	?SkillProc@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::SkillProc
EXTRN	?SkillSecondProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleProcess::SkillSecondProc
; Function compile flags: /Ogtp
;	COMDAT ?SkillProc@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?SkillProc@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::SkillProc, COMDAT
; _this$ = ecx

; 1177 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1178 : 	this->m_IllusionTempleProcess[lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].SkillSecondProc(lpObj);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	50		 push	 eax
  00007	0f b6 80 49 01
	00 00		 movzx	 eax, BYTE PTR [eax+329]
  0000e	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00014	8d 8c 08 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+ecx-45352]
  0001b	e8 00 00 00 00	 call	 ?SkillSecondProc@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleProcess::SkillSecondProc

; 1179 : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?SkillProc@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::SkillProc
_TEXT	ENDS
PUBLIC	?ResetAndClearSkills@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::ResetAndClearSkills
EXTRN	?ResetAndClearSkills@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleProcess::ResetAndClearSkills
; Function compile flags: /Ogtp
;	COMDAT ?ResetAndClearSkills@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?ResetAndClearSkills@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::ResetAndClearSkills, COMDAT
; _this$ = ecx

; 1182 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1183 : 	this->m_IllusionTempleProcess[lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].ResetAndClearSkills(lpObj);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	50		 push	 eax
  00007	0f b6 80 49 01
	00 00		 movzx	 eax, BYTE PTR [eax+329]
  0000e	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00014	8d 8c 08 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+ecx-45352]
  0001b	e8 00 00 00 00	 call	 ?ResetAndClearSkills@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleProcess::ResetAndClearSkills

; 1184 : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?ResetAndClearSkills@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::ResetAndClearSkills
_TEXT	ENDS
PUBLIC	?DeathSetShield@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::DeathSetShield
EXTRN	?ShieldSpell@CIllusionTempleProcess@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleProcess::ShieldSpell
; Function compile flags: /Ogtp
;	COMDAT ?DeathSetShield@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?DeathSetShield@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::DeathSetShield, COMDAT
; _this$ = ecx

; 1187 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1188 : 	if( OBJMAX_RANGE(lpObj->m_Index) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	78 57		 js	 SHORT $LN1@DeathSetSh
  00010	33 c9		 xor	 ecx, ecx
  00012	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00017	0f 9e c1	 setle	 cl
  0001a	8b c1		 mov	 eax, ecx
  0001c	85 c0		 test	 eax, eax
  0001e	74 47		 je	 SHORT $LN1@DeathSetSh

; 1189 : 	{
; 1190 : 		return;
; 1191 : 	}
; 1192 : 
; 1193 : 	if(IT_MAP_RANGE(lpObj->MapNumber) == FALSE || this->m_IllusionTempleProcess[lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState() != 2)

  00020	8a 8e 49 01 00
	00		 mov	 cl, BYTE PTR [esi+329]
  00026	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00029	72 3c		 jb	 SHORT $LN1@DeathSetSh
  0002b	b2 32		 mov	 dl, 50			; 00000032H
  0002d	3a d1		 cmp	 dl, cl
  0002f	1b c0		 sbb	 eax, eax
  00031	40		 inc	 eax
  00032	74 33		 je	 SHORT $LN1@DeathSetSh
  00034	0f b6 c1	 movzx	 eax, cl
  00037	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0003d	8d 8c 38 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+edi-45352]
  00044	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  00049	3c 02		 cmp	 al, 2
  0004b	75 1a		 jne	 SHORT $LN1@DeathSetSh

; 1194 : 	{
; 1195 : 		return;
; 1196 : 	}
; 1197 : 
; 1198 : 	this->m_IllusionTempleProcess[lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].ShieldSpell(lpObj);

  0004d	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00054	69 c9 f0 03 00
	00		 imul	 ecx, 1008		; 000003f0H
  0005a	56		 push	 esi
  0005b	8d 8c 39 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [ecx+edi-45352]
  00062	e8 00 00 00 00	 call	 ?ShieldSpell@CIllusionTempleProcess@@QAEHPAUOBJECTSTRUCT@@@Z ; CIllusionTempleProcess::ShieldSpell
$LN1@DeathSetSh:
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 1199 : }

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?DeathSetShield@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::DeathSetShield
_TEXT	ENDS
PUBLIC	?IncUsedKillCount@CIllusionTempleEvent@@QAEXHE@Z ; CIllusionTempleEvent::IncUsedKillCount
EXTRN	?IncreaseUsedKillCount@CIllusionTempleProcess@@QAEXH@Z:PROC ; CIllusionTempleProcess::IncreaseUsedKillCount
; Function compile flags: /Ogtp
;	COMDAT ?IncUsedKillCount@CIllusionTempleEvent@@QAEXHE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
?IncUsedKillCount@CIllusionTempleEvent@@QAEXHE@Z PROC	; CIllusionTempleEvent::IncUsedKillCount, COMDAT
; _this$ = ecx

; 1202 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1203 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 48		 js	 SHORT $LN1@IncUsedKil
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 39		 je	 SHORT $LN1@IncUsedKil

; 1204 : 	{
; 1205 : 		return;
; 1206 : 	}
; 1207 : 
; 1208 : 	if( IT_MAP_RANGE(MapNumber) == FALSE || this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState() != 2)

  0001a	8a 55 0c	 mov	 dl, BYTE PTR _MapNumber$[ebp]
  0001d	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00020	72 31		 jb	 SHORT $LN1@IncUsedKil
  00022	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00027	3a c2		 cmp	 al, dl
  00029	1b c0		 sbb	 eax, eax
  0002b	40		 inc	 eax
  0002c	74 25		 je	 SHORT $LN1@IncUsedKil
  0002e	0f b6 d2	 movzx	 edx, dl
  00031	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  00037	56		 push	 esi
  00038	8d b4 0a d8 4e
	ff ff		 lea	 esi, DWORD PTR [edx+ecx-45352]
  0003f	8b ce		 mov	 ecx, esi
  00041	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  00046	3c 02		 cmp	 al, 2
  00048	75 08		 jne	 SHORT $LN10@IncUsedKil

; 1209 : 	{
; 1210 : 		return;
; 1211 : 	}
; 1212 : 
; 1213 : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].IncreaseUsedKillCount(aIndex);

  0004a	57		 push	 edi
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ?IncreaseUsedKillCount@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::IncreaseUsedKillCount
$LN10@IncUsedKil:
  00052	5e		 pop	 esi
$LN1@IncUsedKil:
  00053	5f		 pop	 edi

; 1214 : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
?IncUsedKillCount@CIllusionTempleEvent@@QAEXHE@Z ENDP	; CIllusionTempleEvent::IncUsedKillCount
_TEXT	ENDS
PUBLIC	?SetEntranceNpcIndex@CIllusionTempleEvent@@QAEXH@Z ; CIllusionTempleEvent::SetEntranceNpcIndex
; Function compile flags: /Ogtp
;	COMDAT ?SetEntranceNpcIndex@CIllusionTempleEvent@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?SetEntranceNpcIndex@CIllusionTempleEvent@@QAEXH@Z PROC	; CIllusionTempleEvent::SetEntranceNpcIndex, COMDAT
; _this$ = ecx

; 1217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1218 : 	this->m_iEntranceNpcIndex = aIndex;

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	89 81 a8 17 00
	00		 mov	 DWORD PTR [ecx+6056], eax

; 1219 : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetEntranceNpcIndex@CIllusionTempleEvent@@QAEXH@Z ENDP	; CIllusionTempleEvent::SetEntranceNpcIndex
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::NotifyTempleEntranceInfo
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$218009 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ PROC ; CIllusionTempleEvent::NotifyTempleEntranceInfo, COMDAT
; _this$ = ecx

; 1222 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx

; 1223 : 	if(this->m_IllusionTempleProcess[1].GetState() == 0)

  00013	8d 8e f8 03 00
	00		 lea	 ecx, DWORD PTR [esi+1016]
  00019	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  0001e	84 c0		 test	 al, al
  00020	0f 85 8f 00 00
	00		 jne	 $LN3@NotifyTemp

; 1224 : 	{
; 1225 : 		if(this->m_IllusionTempleProcess[1].GetOpenStatus() == TRUE)

  00026	83 be 88 07 00
	00 01		 cmp	 DWORD PTR [esi+1928], 1
  0002d	0f 85 82 00 00
	00		 jne	 $LN3@NotifyTemp

; 1226 : 		{
; 1227 : 			PMSG_MIRAGE_ENTRANCE_INFO pMsg;
; 1228 : 
; 1229 : 			PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x03, sizeof(pMsg));

  00033	6a 0a		 push	 10			; 0000000aH
  00035	6a 03		 push	 3
  00037	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$218009[ebp]
  0003a	68 bf 00 00 00	 push	 191			; 000000bfH
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1230 : 			pMsg.btIllusionState[0] = this->m_IllusionTempleProcess[0].GetEnteredUserCount();

  00045	0f b6 8e 30 02
	00 00		 movzx	 ecx, BYTE PTR [esi+560]

; 1231 : 			pMsg.btIllusionState[1] = this->m_IllusionTempleProcess[1].GetEnteredUserCount();

  0004c	0f b6 96 20 06
	00 00		 movzx	 edx, BYTE PTR [esi+1568]

; 1232 : 			pMsg.btIllusionState[2] = this->m_IllusionTempleProcess[2].GetEnteredUserCount();

  00053	8a 86 10 0a 00
	00		 mov	 al, BYTE PTR [esi+2576]
  00059	88 4d f4	 mov	 BYTE PTR _pMsg$218009[ebp+4], cl

; 1233 : 			pMsg.btIllusionState[3] = this->m_IllusionTempleProcess[3].GetEnteredUserCount();

  0005c	0f b6 8e 00 0e
	00 00		 movzx	 ecx, BYTE PTR [esi+3584]
  00063	88 55 f5	 mov	 BYTE PTR _pMsg$218009[ebp+5], dl

; 1234 : 			pMsg.btIllusionState[4] = this->m_IllusionTempleProcess[4].GetEnteredUserCount();

  00066	0f b6 96 f0 11
	00 00		 movzx	 edx, BYTE PTR [esi+4592]
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 1235 : 
; 1236 : 			if(g_iUseMaxLevelIllusionTemple == 0)

  00070	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iUseMaxLevelIllusionTemple@@3HA, 0 ; g_iUseMaxLevelIllusionTemple
  00077	88 45 f6	 mov	 BYTE PTR _pMsg$218009[ebp+6], al
  0007a	88 4d f7	 mov	 BYTE PTR _pMsg$218009[ebp+7], cl
  0007d	88 55 f8	 mov	 BYTE PTR _pMsg$218009[ebp+8], dl
  00080	75 0b		 jne	 SHORT $LN2@NotifyTemp

; 1237 : 			{
; 1238 : 				pMsg.btIllusionState[5] = this->m_IllusionTempleProcess[5].GetEnteredUserCount();

  00082	8a 86 e0 15 00
	00		 mov	 al, BYTE PTR [esi+5600]
  00088	88 45 f9	 mov	 BYTE PTR _pMsg$218009[ebp+9], al

; 1239 : 			}
; 1240 : 			else

  0008b	eb 04		 jmp	 SHORT $LN1@NotifyTemp
$LN2@NotifyTemp:

; 1241 : 			{
; 1242 : 				pMsg.btIllusionState[5] = 0;

  0008d	c6 45 f9 00	 mov	 BYTE PTR _pMsg$218009[ebp+9], 0
$LN1@NotifyTemp:

; 1243 : 			}
; 1244 : 
; 1245 : 			MsgSendV2(&gObj[this->m_iEntranceNpcIndex],(LPBYTE)&pMsg,pMsg.h.size);

  00091	8b 86 a8 17 00
	00		 mov	 eax, DWORD PTR [esi+6056]
  00097	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$218009[ebp+1]
  0009b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000a1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a7	51		 push	 ecx
  000a8	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$218009[ebp]
  000ab	52		 push	 edx
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@NotifyTemp:

; 1246 : 		}
; 1247 : 	}
; 1248 : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5e		 pop	 esi
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ ENDP ; CIllusionTempleEvent::NotifyTempleEntranceInfo
_TEXT	ENDS
PUBLIC	?CheckWearingMOPH@CIllusionTempleEvent@@QAEHH@Z	; CIllusionTempleEvent::CheckWearingMOPH
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?CheckWearingMOPH@CIllusionTempleEvent@@QAEHH@Z
_TEXT	SEGMENT
_iUserIndex$ = 8					; size = 4
?CheckWearingMOPH@CIllusionTempleEvent@@QAEHH@Z PROC	; CIllusionTempleEvent::CheckWearingMOPH, COMDAT
; _this$ = ecx

; 1251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1252 : 	if (  gObjIsConnected(iUserIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax

; 1253 : 	{
; 1254 : 		return FALSE;

  00012	0f 84 d4 00 00
	00		 je	 $LN1@CheckWeari

; 1255 : 	}
; 1256 : 
; 1257 : 	if ( gObj[iUserIndex].pInventory[10].IsItem()  )

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00023	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  0002a	81 c1 48 08 00
	00		 add	 ecx, 2120		; 00000848H
  00030	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	85 c0		 test	 eax, eax
  0003d	74 4a		 je	 SHORT $LN7@CheckWeari

; 1258 : 	{
; 1259 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,10) )

  0003f	8b 94 0e 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+ecx+3620]
  00046	0f b7 82 4e 08
	00 00		 movzx	 eax, WORD PTR [edx+2126]
  0004d	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  00052	66 3b c2	 cmp	 ax, dx
  00055	75 0a		 jne	 SHORT $LN11@CheckWeari
$LN16@CheckWeari:

; 1260 : 		{
; 1261 : 			return TRUE;

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	5e		 pop	 esi

; 1314 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN11@CheckWeari:

; 1262 : 		}
; 1263 : 
; 1264 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,39) ) 

  00061	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  00066	66 3b c2	 cmp	 ax, dx

; 1265 : 		{
; 1266 : 			return TRUE;

  00069	74 ec		 je	 SHORT $LN16@CheckWeari

; 1267 : 		}
; 1268 : 
; 1269 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,40) )

  0006b	ba 28 1a 00 00	 mov	 edx, 6696		; 00001a28H
  00070	66 3b c2	 cmp	 ax, dx

; 1270 : 		{
; 1271 : 			return TRUE;

  00073	74 e2		 je	 SHORT $LN16@CheckWeari

; 1272 : 		}
; 1273 : 
; 1274 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,41) )

  00075	ba 29 1a 00 00	 mov	 edx, 6697		; 00001a29H
  0007a	66 3b c2	 cmp	 ax, dx

; 1275 : 		{
; 1276 : 			return TRUE;

  0007d	74 d8		 je	 SHORT $LN16@CheckWeari

; 1277 : 		}
; 1278 : 
; 1279 : 		if ( gObj[iUserIndex].pInventory[10].m_Type == ITEMGET(13,68) ) //season4 add-on

  0007f	ba 44 1a 00 00	 mov	 edx, 6724		; 00001a44H
  00084	66 3b c2	 cmp	 ax, dx

; 1280 : 		{
; 1281 : 			return TRUE;

  00087	74 ce		 je	 SHORT $LN16@CheckWeari
$LN7@CheckWeari:

; 1282 : 		}
; 1283 : 	}
; 1284 : 
; 1285 : 	if ( gObj[iUserIndex].pInventory[11].IsItem() )

  00089	8b 8c 0e 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3620]
  00090	81 c1 1c 09 00
	00		 add	 ecx, 2332		; 0000091cH
  00096	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0009b	85 c0		 test	 eax, eax
  0009d	74 4d		 je	 SHORT $LN1@CheckWeari

; 1286 : 	{
; 1287 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,10) )

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  000ab	0f b7 81 22 09
	00 00		 movzx	 eax, WORD PTR [ecx+2338]
  000b2	ba 0a 1a 00 00	 mov	 edx, 6666		; 00001a0aH
  000b7	66 3b c2	 cmp	 ax, dx

; 1288 : 		{
; 1289 : 			return TRUE;

  000ba	74 9b		 je	 SHORT $LN16@CheckWeari

; 1290 : 		}
; 1291 : 
; 1292 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,39) ) 

  000bc	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  000c1	66 3b c1	 cmp	 ax, cx

; 1293 : 		{
; 1294 : 			return TRUE;

  000c4	74 91		 je	 SHORT $LN16@CheckWeari

; 1295 : 		}
; 1296 : 
; 1297 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,40) )

  000c6	ba 28 1a 00 00	 mov	 edx, 6696		; 00001a28H
  000cb	66 3b c2	 cmp	 ax, dx

; 1298 : 		{
; 1299 : 			return TRUE;

  000ce	74 87		 je	 SHORT $LN16@CheckWeari

; 1300 : 		}
; 1301 : 
; 1302 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,41) )

  000d0	b9 29 1a 00 00	 mov	 ecx, 6697		; 00001a29H
  000d5	66 3b c1	 cmp	 ax, cx

; 1303 : 		{
; 1304 : 			return TRUE;

  000d8	0f 84 79 ff ff
	ff		 je	 $LN16@CheckWeari

; 1305 : 		}
; 1306 : 
; 1307 : 		if ( gObj[iUserIndex].pInventory[11].m_Type == ITEMGET(13,68) ) //season4 add-on

  000de	ba 44 1a 00 00	 mov	 edx, 6724		; 00001a44H
  000e3	66 3b c2	 cmp	 ax, dx

; 1308 : 		{
; 1309 : 			return TRUE;

  000e6	0f 84 6b ff ff
	ff		 je	 $LN16@CheckWeari
$LN1@CheckWeari:

; 1310 : 		}
; 1311 : 	}
; 1312 : 
; 1313 : 	return FALSE;

  000ec	33 c0		 xor	 eax, eax
  000ee	5e		 pop	 esi

; 1314 : }

  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?CheckWearingMOPH@CIllusionTempleEvent@@QAEHH@Z ENDP	; CIllusionTempleEvent::CheckWearingMOPH
_TEXT	ENDS
PUBLIC	?CheckPolymorphItem@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckPolymorphItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckPolymorphItem@CIllusionTempleEvent@@QAEHH@Z
_TEXT	SEGMENT
_iItemCode$ = 8						; size = 4
?CheckPolymorphItem@CIllusionTempleEvent@@QAEHH@Z PROC	; CIllusionTempleEvent::CheckPolymorphItem, COMDAT
; _this$ = ecx

; 1317 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1318 : 	int loc2 = 0;
; 1319 : 
; 1320 : 	switch(iItemCode)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iItemCode$[ebp]
  00006	81 c1 f6 e5 ff
	ff		 add	 ecx, -6666		; ffffe5f6H
  0000c	33 c0		 xor	 eax, eax
  0000e	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00011	77 13		 ja	 SHORT $LN2@CheckPolym
  00013	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN6@CheckPolym[ecx]
  0001a	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN7@CheckPolym[ecx*4]
$LN1@CheckPolym:

; 1321 : 	{
; 1322 : 		case ITEMGET(13,10):
; 1323 : 		case ITEMGET(13,39):
; 1324 : 		case ITEMGET(13,40):
; 1325 : 		case ITEMGET(13,41):
; 1326 : 		case ITEMGET(13,68): //season4 add-on
; 1327 : 			loc2 = 1;

  00021	b8 01 00 00 00	 mov	 eax, 1
$LN2@CheckPolym:

; 1328 : 			break;
; 1329 : 	}
; 1330 : 
; 1331 : 	return loc2;
; 1332 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
  0002a	8b ff		 npad	 2
$LN7@CheckPolym:
  0002c	00 00 00 00	 DD	 $LN1@CheckPolym
  00030	00 00 00 00	 DD	 $LN2@CheckPolym
$LN6@CheckPolym:
  00034	00		 DB	 0
  00035	01		 DB	 1
  00036	01		 DB	 1
  00037	01		 DB	 1
  00038	01		 DB	 1
  00039	01		 DB	 1
  0003a	01		 DB	 1
  0003b	01		 DB	 1
  0003c	01		 DB	 1
  0003d	01		 DB	 1
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	01		 DB	 1
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	01		 DB	 1
  00050	01		 DB	 1
  00051	00		 DB	 0
  00052	00		 DB	 0
  00053	00		 DB	 0
  00054	01		 DB	 1
  00055	01		 DB	 1
  00056	01		 DB	 1
  00057	01		 DB	 1
  00058	01		 DB	 1
  00059	01		 DB	 1
  0005a	01		 DB	 1
  0005b	01		 DB	 1
  0005c	01		 DB	 1
  0005d	01		 DB	 1
  0005e	01		 DB	 1
  0005f	01		 DB	 1
  00060	01		 DB	 1
  00061	01		 DB	 1
  00062	01		 DB	 1
  00063	01		 DB	 1
  00064	01		 DB	 1
  00065	01		 DB	 1
  00066	01		 DB	 1
  00067	01		 DB	 1
  00068	01		 DB	 1
  00069	01		 DB	 1
  0006a	01		 DB	 1
  0006b	01		 DB	 1
  0006c	01		 DB	 1
  0006d	01		 DB	 1
  0006e	00		 DB	 0
?CheckPolymorphItem@CIllusionTempleEvent@@QAEHH@Z ENDP	; CIllusionTempleEvent::CheckPolymorphItem
_TEXT	ENDS
PUBLIC	?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z	; CIllusionTempleEvent::CheckTeleport
; Function compile flags: /Ogtp
;	COMDAT ?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z PROC	; CIllusionTempleEvent::CheckTeleport, COMDAT
; _this$ = ecx

; 1335 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 1336 : 	if (  gObjIsConnected(aIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	8b d9		 mov	 ebx, ecx
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	75 08		 jne	 SHORT $LN5@CheckTelep
$LN14@CheckTelep:
  00017	5f		 pop	 edi

; 1337 : 	{
; 1338 : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	5b		 pop	 ebx

; 1352 : 	{
; 1353 : 		return TRUE;
; 1354 : 	}
; 1355 : 
; 1356 : 	return FALSE;
; 1357 : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN5@CheckTelep:

; 1339 : 	}
; 1340 : 
; 1341 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  0001f	85 ff		 test	 edi, edi
  00021	78 f4		 js	 SHORT $LN14@CheckTelep
  00023	33 c0		 xor	 eax, eax
  00025	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0002b	0f 9e c0	 setle	 al
  0002e	85 c0		 test	 eax, eax

; 1342 : 	{
; 1343 : 		return FALSE;

  00030	74 e5		 je	 SHORT $LN14@CheckTelep

; 1344 : 	}
; 1345 : 
; 1346 : 	if(IT_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE || this->m_IllusionTempleProcess[gObj[aIndex].MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetState() != 2)

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	56		 push	 esi
  00038	8b f7		 mov	 esi, edi
  0003a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00040	8a 8c 06 49 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+329]
  00047	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0004a	72 49		 jb	 SHORT $LN2@CheckTelep
  0004c	b2 32		 mov	 dl, 50			; 00000032H
  0004e	3a d1		 cmp	 dl, cl
  00050	1b c0		 sbb	 eax, eax
  00052	40		 inc	 eax
  00053	74 40		 je	 SHORT $LN2@CheckTelep
  00055	0f b6 c1	 movzx	 eax, cl
  00058	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0005e	8d 8c 18 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+ebx-45352]
  00065	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  0006a	3c 02		 cmp	 al, 2
  0006c	75 27		 jne	 SHORT $LN2@CheckTelep

; 1349 : 	}
; 1350 : 
; 1351 : 	if(aIndex == this->m_IllusionTempleProcess[gObj[aIndex].MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].GetBallPlayerIndex())

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00074	0f b6 94 0e 49
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+329]
  0007c	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  00082	33 c0		 xor	 eax, eax
  00084	3b bc 1a 90 52
	ff ff		 cmp	 edi, DWORD PTR [edx+ebx-44400]
  0008b	5e		 pop	 esi
  0008c	5f		 pop	 edi
  0008d	0f 94 c0	 sete	 al
  00090	5b		 pop	 ebx

; 1352 : 	{
; 1353 : 		return TRUE;
; 1354 : 	}
; 1355 : 
; 1356 : 	return FALSE;
; 1357 : }

  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
$LN2@CheckTelep:
  00095	5e		 pop	 esi
  00096	5f		 pop	 edi

; 1347 : 	{
; 1348 : 		return FALSE;

  00097	33 c0		 xor	 eax, eax
  00099	5b		 pop	 ebx

; 1352 : 	{
; 1353 : 		return TRUE;
; 1354 : 	}
; 1355 : 
; 1356 : 	return FALSE;
; 1357 : }

  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z ENDP	; CIllusionTempleEvent::CheckTeleport
_TEXT	ENDS
PUBLIC	?SearchNDropMonsterItem@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::SearchNDropMonsterItem
EXTRN	?DropMonsterItem@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleProcess::DropMonsterItem
; Function compile flags: /Ogtp
;	COMDAT ?SearchNDropMonsterItem@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?SearchNDropMonsterItem@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::SearchNDropMonsterItem, COMDAT
; _this$ = ecx

; 1360 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1361 : 	if(IT_MAP_RANGE(lpObj->MapNumber) == FALSE)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	8a 86 49 01 00
	00		 mov	 al, BYTE PTR [esi+329]
  0000d	3c 2d		 cmp	 al, 45			; 0000002dH
  0000f	72 22		 jb	 SHORT $LN2@SearchNDro
  00011	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  00016	3a d0		 cmp	 dl, al
  00018	1b d2		 sbb	 edx, edx
  0001a	42		 inc	 edx
  0001b	74 16		 je	 SHORT $LN2@SearchNDro

; 1362 : 	{
; 1363 : 		return;
; 1364 : 	}
; 1365 : 
; 1366 : 	this->m_IllusionTempleProcess[lpObj->MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].DropMonsterItem(lpObj);

  0001d	0f b6 c0	 movzx	 eax, al
  00020	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00026	56		 push	 esi
  00027	8d 8c 08 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+ecx-45352]
  0002e	e8 00 00 00 00	 call	 ?DropMonsterItem@CIllusionTempleProcess@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleProcess::DropMonsterItem
$LN2@SearchNDro:
  00033	5e		 pop	 esi

; 1367 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?SearchNDropMonsterItem@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::SearchNDropMonsterItem
_TEXT	ENDS
PUBLIC	?GiveItemReward@CIllusionTempleEvent@@QAEXH@Z	; CIllusionTempleEvent::GiveItemReward
EXTRN	?DropRewardItem@CIllusionTempleProcess@@QAEXH@Z:PROC ; CIllusionTempleProcess::DropRewardItem
; Function compile flags: /Ogtp
;	COMDAT ?GiveItemReward@CIllusionTempleEvent@@QAEXH@Z
_TEXT	SEGMENT
_arg1$ = 8						; size = 4
?GiveItemReward@CIllusionTempleEvent@@QAEXH@Z PROC	; CIllusionTempleEvent::GiveItemReward, COMDAT
; _this$ = ecx

; 1370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1371 : 	if(IT_MAP_RANGE(gObj[arg1].MapNumber) == FALSE)

  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _arg1$[ebp]
  0000d	8b c6		 mov	 eax, esi
  0000f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00015	8a 84 10 49 01
	00 00		 mov	 al, BYTE PTR [eax+edx+329]
  0001c	3c 2d		 cmp	 al, 45			; 0000002dH
  0001e	72 22		 jb	 SHORT $LN2@GiveItemRe
  00020	ba 32 00 00 00	 mov	 edx, 50			; 00000032H
  00025	3a d0		 cmp	 dl, al
  00027	1b d2		 sbb	 edx, edx
  00029	42		 inc	 edx
  0002a	74 16		 je	 SHORT $LN2@GiveItemRe

; 1372 : 	{
; 1373 : 		return;
; 1374 : 	}
; 1375 : 
; 1376 : 	this->m_IllusionTempleProcess[gObj[arg1].MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].DropRewardItem(arg1);

  0002c	0f b6 c0	 movzx	 eax, al
  0002f	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  00035	56		 push	 esi
  00036	8d 8c 08 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+ecx-45352]
  0003d	e8 00 00 00 00	 call	 ?DropRewardItem@CIllusionTempleProcess@@QAEXH@Z ; CIllusionTempleProcess::DropRewardItem
$LN2@GiveItemRe:
  00042	5e		 pop	 esi

; 1377 : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?GiveItemReward@CIllusionTempleEvent@@QAEXH@Z ENDP	; CIllusionTempleEvent::GiveItemReward
_TEXT	ENDS
PUBLIC	?GetRemainTime@CIllusionTempleEvent@@QAEEXZ	; CIllusionTempleEvent::GetRemainTime
EXTRN	?RemainTime@CIllusionTempleProcess@@QAEEXZ:PROC	; CIllusionTempleProcess::RemainTime
; Function compile flags: /Ogtp
;	COMDAT ?GetRemainTime@CIllusionTempleEvent@@QAEEXZ
_TEXT	SEGMENT
?GetRemainTime@CIllusionTempleEvent@@QAEEXZ PROC	; CIllusionTempleEvent::GetRemainTime, COMDAT
; _this$ = ecx

; 1381 : 	BYTE loc2 = 0;
; 1382 : 
; 1383 : 	if(g_iIllusionTempleEvent != 0)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iIllusionTempleEvent@@3HA, 0 ; g_iIllusionTempleEvent
  00007	74 08		 je	 SHORT $LN2@GetRemainT

; 1384 : 	{
; 1385 : 		loc2 = this->m_IllusionTempleProcess[0].RemainTime();

  00009	83 c1 08	 add	 ecx, 8
  0000c	e9 00 00 00 00	 jmp	 ?RemainTime@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::RemainTime
$LN2@GetRemainT:

; 1386 : 	}
; 1387 : 	else
; 1388 : 	{
; 1389 : 		loc2 = 0;

  00011	32 c0		 xor	 al, al

; 1390 : 	}
; 1391 : 	
; 1392 : 	return loc2;
; 1393 : }

  00013	c3		 ret	 0
?GetRemainTime@CIllusionTempleEvent@@QAEEXZ ENDP	; CIllusionTempleEvent::GetRemainTime
_TEXT	ENDS
PUBLIC	?GetShieldSpellStatus@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::GetShieldSpellStatus
EXTRN	?CheckShieldSpellTime@CIllusionTempleProcess@@QAEHH@Z:PROC ; CIllusionTempleProcess::CheckShieldSpellTime
; Function compile flags: /Ogtp
;	COMDAT ?GetShieldSpellStatus@CIllusionTempleEvent@@QAEHHE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
?GetShieldSpellStatus@CIllusionTempleEvent@@QAEHHE@Z PROC ; CIllusionTempleEvent::GetShieldSpellStatus, COMDAT
; _this$ = ecx

; 1396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1397 : 	if(IT_MAP_RANGE(MapNumber) == FALSE)

  00003	8a 55 0c	 mov	 dl, BYTE PTR _MapNumber$[ebp]
  00006	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00009	72 0c		 jb	 SHORT $LN6@GetShieldS
  0000b	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00010	3a c2		 cmp	 al, dl
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	75 06		 jne	 SHORT $LN1@GetShieldS
$LN6@GetShieldS:

; 1398 : 	{
; 1399 : 		return FALSE;

  00017	33 c0		 xor	 eax, eax

; 1402 : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN1@GetShieldS:

; 1400 : 	}
; 1401 : 	return this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].CheckShieldSpellTime(aIndex);

  0001d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00020	0f b6 d2	 movzx	 edx, dl
  00023	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  00029	50		 push	 eax
  0002a	8d 8c 0a d8 4e
	ff ff		 lea	 ecx, DWORD PTR [edx+ecx-45352]
  00031	e8 00 00 00 00	 call	 ?CheckShieldSpellTime@CIllusionTempleProcess@@QAEHH@Z ; CIllusionTempleProcess::CheckShieldSpellTime

; 1402 : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?GetShieldSpellStatus@CIllusionTempleEvent@@QAEHHE@Z ENDP ; CIllusionTempleEvent::GetShieldSpellStatus
_TEXT	ENDS
PUBLIC	?GetRestrictionSpellStatus@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::GetRestrictionSpellStatus
EXTRN	?CheckRestrictionSpellTime@CIllusionTempleProcess@@QAEHH@Z:PROC ; CIllusionTempleProcess::CheckRestrictionSpellTime
; Function compile flags: /Ogtp
;	COMDAT ?GetRestrictionSpellStatus@CIllusionTempleEvent@@QAEHHE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
?GetRestrictionSpellStatus@CIllusionTempleEvent@@QAEHHE@Z PROC ; CIllusionTempleEvent::GetRestrictionSpellStatus, COMDAT
; _this$ = ecx

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1406 : 	if(IT_MAP_RANGE(MapNumber) == FALSE)

  00003	8a 55 0c	 mov	 dl, BYTE PTR _MapNumber$[ebp]
  00006	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00009	72 0c		 jb	 SHORT $LN6@GetRestric
  0000b	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00010	3a c2		 cmp	 al, dl
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	75 06		 jne	 SHORT $LN1@GetRestric
$LN6@GetRestric:

; 1407 : 	{
; 1408 : 		return FALSE;

  00017	33 c0		 xor	 eax, eax

; 1411 : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN1@GetRestric:

; 1409 : 	}
; 1410 : 	return this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].CheckRestrictionSpellTime(aIndex);

  0001d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00020	0f b6 d2	 movzx	 edx, dl
  00023	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  00029	50		 push	 eax
  0002a	8d 8c 0a d8 4e
	ff ff		 lea	 ecx, DWORD PTR [edx+ecx-45352]
  00031	e8 00 00 00 00	 call	 ?CheckRestrictionSpellTime@CIllusionTempleProcess@@QAEHH@Z ; CIllusionTempleProcess::CheckRestrictionSpellTime

; 1411 : }

  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?GetRestrictionSpellStatus@CIllusionTempleEvent@@QAEHHE@Z ENDP ; CIllusionTempleEvent::GetRestrictionSpellStatus
_TEXT	ENDS
PUBLIC	??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BI@DOGCNFBC@IllusionTempleEvent?4cpp?$AA@ ; `string'
PUBLIC	?GetEnterLevel@CIllusionTempleEvent@@QAEHH@Z	; CIllusionTempleEvent::GetEnterLevel
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
;	COMDAT ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@ DB 'return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DOGCNFBC@IllusionTempleEvent?4cpp?$AA@
CONST	SEGMENT
??_C@_0BI@DOGCNFBC@IllusionTempleEvent?4cpp?$AA@ DB 'IllusionTempleEvent.'
	DB	'cpp', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetEnterLevel@CIllusionTempleEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GetEnterLevel@CIllusionTempleEvent@@QAEHH@Z PROC	; CIllusionTempleEvent::GetEnterLevel, COMDAT
; _this$ = ecx

; 1414 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1415 : 	int loc2 = 0; //?? weird
; 1416 : 
; 1417 : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1418 : 
; 1419 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00014	85 c9		 test	 ecx, ecx
  00016	78 11		 js	 SHORT $LN16@GetEnterLe
  00018	33 d2		 xor	 edx, edx
  0001a	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00020	0f 9e c2	 setle	 dl
  00023	8b ca		 mov	 ecx, edx
  00025	85 c9		 test	 ecx, ecx
  00027	75 1f		 jne	 SHORT $LN11@GetEnterLe
$LN16@GetEnterLe:

; 1420 : 	{
; 1421 : 		LogAdd("return %s %d", __FILE__, __LINE__);

  00029	68 8d 05 00 00	 push	 1421			; 0000058dH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DOGCNFBC@IllusionTempleEvent?4cpp?$AA@
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GetEnterLe:

; 1433 : 
; 1434 : 	return -1;

  00041	83 c8 ff	 or	 eax, -1

; 1435 : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN11@GetEnterLe:

; 1422 : 		return -1;
; 1423 : 	}
; 1424 : 
; 1425 : 	if( lpObj->Level < 220 ) return 0;

  00048	0f b7 88 be 00
	00 00		 movzx	 ecx, WORD PTR [eax+190]
  0004f	ba dc 00 00 00	 mov	 edx, 220		; 000000dcH
  00054	66 3b ca	 cmp	 cx, dx
  00057	7d 06		 jge	 SHORT $LN10@GetEnterLe
  00059	33 c0		 xor	 eax, eax

; 1435 : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN10@GetEnterLe:

; 1426 : 	if( lpObj->Level < 271 ) return 1;

  0005f	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  00064	66 3b ca	 cmp	 cx, dx
  00067	7d 09		 jge	 SHORT $LN9@GetEnterLe
  00069	b8 01 00 00 00	 mov	 eax, 1

; 1435 : }

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
$LN9@GetEnterLe:

; 1427 : 	if( lpObj->Level < 321 ) return 2;

  00072	ba 41 01 00 00	 mov	 edx, 321		; 00000141H
  00077	66 3b ca	 cmp	 cx, dx
  0007a	7d 09		 jge	 SHORT $LN8@GetEnterLe
  0007c	b8 02 00 00 00	 mov	 eax, 2

; 1435 : }

  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN8@GetEnterLe:

; 1428 : 	if( lpObj->Level < 351 ) return 3;

  00085	ba 5f 01 00 00	 mov	 edx, 351		; 0000015fH
  0008a	66 3b ca	 cmp	 cx, dx
  0008d	7d 09		 jge	 SHORT $LN7@GetEnterLe
  0008f	b8 03 00 00 00	 mov	 eax, 3

; 1435 : }

  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
$LN7@GetEnterLe:

; 1429 : 	if( lpObj->Level < 381 ) return 4;

  00098	ba 7d 01 00 00	 mov	 edx, 381		; 0000017dH
  0009d	66 3b ca	 cmp	 cx, dx
  000a0	7d 09		 jge	 SHORT $LN6@GetEnterLe
  000a2	b8 04 00 00 00	 mov	 eax, 4

; 1435 : }

  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
$LN6@GetEnterLe:

; 1430 : 	if( lpObj->Level < 400 ) return 5;

  000ab	ba 90 01 00 00	 mov	 edx, 400		; 00000190H
  000b0	66 3b ca	 cmp	 cx, dx
  000b3	7d 09		 jge	 SHORT $LN17@GetEnterLe
$LN18@GetEnterLe:
  000b5	b8 05 00 00 00	 mov	 eax, 5

; 1435 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN17@GetEnterLe:

; 1431 : 	if( lpObj->Level == 400 && lpObj->ChangeUP3rd == 0 ) return 5;

  000be	75 09		 jne	 SHORT $LN4@GetEnterLe
  000c0	80 b8 bc 00 00
	00 00		 cmp	 BYTE PTR [eax+188], 0
  000c7	74 ec		 je	 SHORT $LN18@GetEnterLe
$LN4@GetEnterLe:

; 1432 : 	if( lpObj->Level == 400 && lpObj->ChangeUP3rd != 0 ){ if( g_iUseMaxLevelIllusionTemple != 0 ){ return 6;}else{ return 5;}}

  000c9	66 3b ca	 cmp	 cx, dx
  000cc	0f 85 6f ff ff
	ff		 jne	 $LN1@GetEnterLe
  000d2	80 b8 bc 00 00
	00 00		 cmp	 BYTE PTR [eax+188], 0
  000d9	0f 84 62 ff ff
	ff		 je	 $LN1@GetEnterLe
  000df	33 c0		 xor	 eax, eax
  000e1	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iUseMaxLevelIllusionTemple@@3HA, eax ; g_iUseMaxLevelIllusionTemple
  000e7	0f 95 c0	 setne	 al
  000ea	83 c0 05	 add	 eax, 5

; 1435 : }

  000ed	5d		 pop	 ebp
  000ee	c2 04 00	 ret	 4
?GetEnterLevel@CIllusionTempleEvent@@QAEHH@Z ENDP	; CIllusionTempleEvent::GetEnterLevel
_TEXT	ENDS
PUBLIC	?CheckLuckyTalisman@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckLuckyTalisman
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CheckLuckyTalisman@CIllusionTempleEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckLuckyTalisman@CIllusionTempleEvent@@QAEHH@Z PROC	; CIllusionTempleEvent::CheckLuckyTalisman, COMDAT
; _this$ = ecx

; 1438 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1439 : 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN13@CheckLucky
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 1f		 jne	 SHORT $LN6@CheckLucky
$LN13@CheckLucky:

; 1440 : 	{
; 1441 : 		LogAdd("return %s %d", __FILE__, __LINE__);

  00018	68 a1 05 00 00	 push	 1441			; 000005a1H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DOGCNFBC@IllusionTempleEvent?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1442 : 		return -1;

  00030	83 c8 ff	 or	 eax, -1

; 1459 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN6@CheckLucky:

; 1443 : 	}
; 1444 : 
; 1445 : 	LPOBJ lpObj = &gObj[aIndex];

  00037	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0003d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	53		 push	 ebx
  00044	56		 push	 esi
  00045	57		 push	 edi

; 1446 : 	int loc3 = 0;

  00046	33 db		 xor	 ebx, ebx
  00048	8b f8		 mov	 edi, eax
  0004a	33 f6		 xor	 esi, esi
  0004c	8d 64 24 00	 npad	 4
$LL5@CheckLucky:

; 1449 : 	{
; 1450 : 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00050	8b 8f 78 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3704]
  00056	03 ce		 add	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 1d		 jne	 SHORT $LN4@CheckLucky

; 1451 : 		{
; 1452 : 			if( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )

  00062	8b 87 78 0e 00
	00		 mov	 eax, DWORD PTR [edi+3704]
  00068	b9 35 1c 00 00	 mov	 ecx, 7221		; 00001c35H
  0006d	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00072	75 0b		 jne	 SHORT $LN4@CheckLucky

; 1453 : 			{
; 1454 : 				loc3+= (int)lpObj->pChaosBox[n].m_Durability;

  00074	d9 44 30 24	 fld	 DWORD PTR [eax+esi+36]
  00078	e8 00 00 00 00	 call	 __ftol2_sse
  0007d	03 d8		 add	 ebx, eax
$LN4@CheckLucky:

; 1447 : 
; 1448 : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++) //loc4

  0007f	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00085	81 fe 80 1a 00
	00		 cmp	 esi, 6784		; 00001a80H
  0008b	7c c3		 jl	 SHORT $LL5@CheckLucky

; 1455 : 			}
; 1456 : 		}
; 1457 : 	}
; 1458 : 	return loc3;

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b c3		 mov	 eax, ebx
  00091	5b		 pop	 ebx

; 1459 : }

  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?CheckLuckyTalisman@CIllusionTempleEvent@@QAEHH@Z ENDP	; CIllusionTempleEvent::CheckLuckyTalisman
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGReqIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXH@Z ; CIllusionTempleEvent::EGReqIllusionTempleEnterCount
; Function compile flags: /Ogtp
;	COMDAT ?EGReqIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXH@Z PROC ; CIllusionTempleEvent::EGReqIllusionTempleEnterCount, COMDAT
; _this$ = ecx

; 1462 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1463 : 	if (  gObjIsConnected(iIndex) == FALSE )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 6c		 je	 SHORT $LN2@EGReqIllus@2

; 1464 : 	{
; 1465 : 		return;
; 1466 : 	}
; 1467 : 
; 1468 : 	PMSG_REQ_ILLUSIONTEMPLE_ENTERCOUNT pMsg;
; 1469 : 
; 1470 : 	pMsg.h.c = 0xC1;
; 1471 : 	pMsg.h.headcode = 0x14;
; 1472 : 	pMsg.h.size = sizeof(pMsg);
; 1473 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, 10);

  00021	8b c6		 mov	 eax, esi
  00023	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00029	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	c6 45 dc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00033	66 c7 45 dd 20
	14		 mov	 WORD PTR _pMsg$[ebp+1], 5152 ; 00001420H
  00039	8b 50 6c	 mov	 edx, DWORD PTR [eax+108]
  0003c	89 55 df	 mov	 DWORD PTR _pMsg$[ebp+3], edx
  0003f	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00042	89 4d e3	 mov	 DWORD PTR _pMsg$[ebp+7], ecx
  00045	66 8b 50 74	 mov	 dx, WORD PTR [eax+116]
  00049	66 89 55 e7	 mov	 WORD PTR _pMsg$[ebp+11], dx

; 1474 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, 10);

  0004d	8b 48 77	 mov	 ecx, DWORD PTR [eax+119]
  00050	89 4d e9	 mov	 DWORD PTR _pMsg$[ebp+13], ecx
  00053	8b 50 7b	 mov	 edx, DWORD PTR [eax+123]

; 1475 : 	pMsg.ServerCode = gGameServerCode / 20;

  00056	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0005d	89 55 ed	 mov	 DWORD PTR _pMsg$[ebp+17], edx
  00060	66 8b 40 7f	 mov	 ax, WORD PTR [eax+127]
  00064	66 89 45 f1	 mov	 WORD PTR _pMsg$[ebp+21], ax
  00068	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0006d	f7 e9		 imul	 ecx
  0006f	c1 fa 03	 sar	 edx, 3
  00072	8b ca		 mov	 ecx, edx
  00074	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00077	03 ca		 add	 ecx, edx

; 1476 : 	pMsg.iObjIndex = iIndex;
; 1477 : 
; 1478 : 	DataSendRank((char*)&pMsg, pMsg.h.size); //season4 changed

  00079	8d 55 dc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0007c	6a 20		 push	 32			; 00000020H
  0007e	52		 push	 edx
  0007f	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+24], ecx
  00082	89 75 f8	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  00085	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank
  0008a	83 c4 08	 add	 esp, 8
$LN2@EGReqIllus@2:

; 1479 : }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	33 cd		 xor	 ecx, ebp
  00092	5e		 pop	 esi
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?EGReqIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXH@Z ENDP ; CIllusionTempleEvent::EGReqIllusionTempleEnterCount
_TEXT	ENDS
PUBLIC	?EGAnsIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT@@@Z ; CIllusionTempleEvent::EGAnsIllusionTempleEnterCount
; Function compile flags: /Ogtp
;	COMDAT ?EGAnsIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT@@@Z
_TEXT	SEGMENT
_szName$ = -32						; size = 11
_szAccountID$ = -20					; size = 11
_pMsgSend$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
?EGAnsIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT@@@Z PROC ; CIllusionTempleEvent::EGAnsIllusionTempleEnterCount, COMDAT
; _this$ = ecx

; 1482 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 1483 : 	if ( !lpMsg)

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 84 ec 00 00
	00		 je	 $LN1@EGAnsIllus

; 1484 : 		return;
; 1485 : 
; 1486 : 	if ( !gObjIsConnected(lpMsg->iObjIndex))

  00012	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 d8 00 00
	00		 je	 $LN1@EGAnsIllus

; 1487 : 		return;
; 1488 : 
; 1489 : 	char szAccountID[11] = {0};
; 1490 : 	char szName[11] = {0};
; 1491 : 	memcpy(szAccountID, lpMsg->AccountID, 10);

  00026	8b 56 07	 mov	 edx, DWORD PTR [esi+7]
  00029	8b 4e 03	 mov	 ecx, DWORD PTR [esi+3]
  0002c	33 c0		 xor	 eax, eax
  0002e	53		 push	 ebx

; 1492 : 	memcpy(szName, lpMsg->GameID, 10);
; 1493 : 
; 1494 : 	if ( strcmp(gObj[lpMsg->iObjIndex].AccountID, szAccountID) || strcmp(gObj[lpMsg->iObjIndex].Name, szName) )

  0002f	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00032	57		 push	 edi
  00033	89 45 ed	 mov	 DWORD PTR _szAccountID$[ebp+1], eax
  00036	89 45 f1	 mov	 DWORD PTR _szAccountID$[ebp+5], eax
  00039	89 45 e1	 mov	 DWORD PTR _szName$[ebp+1], eax
  0003c	89 45 e5	 mov	 DWORD PTR _szName$[ebp+5], eax
  0003f	8b fb		 mov	 edi, ebx
  00041	66 89 45 f5	 mov	 WORD PTR _szAccountID$[ebp+9], ax
  00045	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0004b	66 89 45 e9	 mov	 WORD PTR _szName$[ebp+9], ax
  0004f	0f b7 46 0b	 movzx	 eax, WORD PTR [esi+11]
  00053	89 55 f0	 mov	 DWORD PTR _szAccountID$[ebp+4], edx
  00056	8b 56 11	 mov	 edx, DWORD PTR [esi+17]
  00059	66 89 45 f4	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  0005d	0f b7 46 15	 movzx	 eax, WORD PTR [esi+21]
  00061	89 4d ec	 mov	 DWORD PTR _szAccountID$[ebp], ecx
  00064	8b 4e 0d	 mov	 ecx, DWORD PTR [esi+13]
  00067	89 55 e4	 mov	 DWORD PTR _szName$[ebp+4], edx
  0006a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	03 fa		 add	 edi, edx
  00072	89 4d e0	 mov	 DWORD PTR _szName$[ebp], ecx
  00075	66 89 45 e8	 mov	 WORD PTR _szName$[ebp+8], ax
  00079	8d 4d ec	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  0007c	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
  0007f	90		 npad	 1
$LL7@EGAnsIllus:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN8@EGAnsIllus
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN9@EGAnsIllus
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN8@EGAnsIllus
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL7@EGAnsIllus
$LN9@EGAnsIllus:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN10@EGAnsIllus
$LN8@EGAnsIllus:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 d8 ff	 sbb	 eax, -1
$LN10@EGAnsIllus:
  000a5	85 c0		 test	 eax, eax
  000a7	75 53		 jne	 SHORT $LN15@EGAnsIllus
  000a9	8d 4d e0	 lea	 ecx, DWORD PTR _szName$[ebp]
  000ac	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  000af	90		 npad	 1
$LL11@EGAnsIllus:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN12@EGAnsIllus
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN13@EGAnsIllus
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN12@EGAnsIllus
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL11@EGAnsIllus
$LN13@EGAnsIllus:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN14@EGAnsIllus
$LN12@EGAnsIllus:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN14@EGAnsIllus:
  000d5	85 c0		 test	 eax, eax
  000d7	75 23		 jne	 SHORT $LN15@EGAnsIllus

; 1495 : 		 return;
; 1496 : 
; 1497 : 	PMSG_ANS_CL_ENTERCOUNT pMsgSend;
; 1498 : 
; 1499 : 	pMsgSend.h.c = 0xC1;
; 1500 : 	pMsgSend.h.headcode = 0x9F;
; 1501 : 	pMsgSend.h.size = sizeof(pMsgSend);
; 1502 : 	pMsgSend.btEventType = 3;
; 1503 : 	pMsgSend.btLeftEnterCount = lpMsg->iLeftCount;

  000d9	8a 46 20	 mov	 al, BYTE PTR [esi+32]

; 1504 : 
; 1505 : 	DataSend(lpMsg->iObjIndex, (LPBYTE)&pMsgSend, sizeof(pMsgSend));

  000dc	6a 05		 push	 5
  000de	8d 4d f8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  000e1	51		 push	 ecx
  000e2	53		 push	 ebx
  000e3	c6 45 f8 c1	 mov	 BYTE PTR _pMsgSend$[ebp], 193 ; 000000c1H
  000e7	66 c7 45 f9 05
	9f		 mov	 WORD PTR _pMsgSend$[ebp+1], 40709 ; 00009f05H
  000ed	c6 45 fb 03	 mov	 BYTE PTR _pMsgSend$[ebp+3], 3
  000f1	88 45 fc	 mov	 BYTE PTR _pMsgSend$[ebp+4], al
  000f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@EGAnsIllus:
  000fc	5f		 pop	 edi
  000fd	5b		 pop	 ebx
$LN1@EGAnsIllus:
  000fe	5e		 pop	 esi

; 1506 : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?EGAnsIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT@@@Z ENDP ; CIllusionTempleEvent::EGAnsIllusionTempleEnterCount
_TEXT	ENDS
PUBLIC	?_Nextnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Nextnode
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Nextnode, COMDAT

; 560  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 562  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Prevnode
; Function compile flags: /Ogtp
;	COMDAT ?_Prevnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z PROC ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Prevnode, COMDAT

; 565  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 567  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@@Z ENDP ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Prevnode
_TEXT	ENDS
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 93   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 94   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Myval@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAUILLUSIONTEMPLE_START_TIME@@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAUILLUSIONTEMPLE_START_TIME@@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAUILLUSIONTEMPLE_START_TIME@@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@@Z PROC ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Myval, COMDAT

; 570  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 572  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@SAAAUILLUSIONTEMPLE_START_TIME@@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@@Z ENDP ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Myval
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QBEIXZ ; std::allocator<ILLUSIONTEMPLE_START_TIME>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QBEIXZ PROC ; std::allocator<ILLUSIONTEMPLE_START_TIME>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QBEIXZ ENDP ; std::allocator<ILLUSIONTEMPLE_START_TIME>::max_size
_TEXT	ENDS
PUBLIC	??$addressof@UILLUSIONTEMPLE_START_TIME@@@std@@YAPAUILLUSIONTEMPLE_START_TIME@@AAU1@@Z ; std::addressof<ILLUSIONTEMPLE_START_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@UILLUSIONTEMPLE_START_TIME@@@std@@YAPAUILLUSIONTEMPLE_START_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UILLUSIONTEMPLE_START_TIME@@@std@@YAPAUILLUSIONTEMPLE_START_TIME@@AAU1@@Z PROC ; std::addressof<ILLUSIONTEMPLE_START_TIME>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UILLUSIONTEMPLE_START_TIME@@@std@@YAPAUILLUSIONTEMPLE_START_TIME@@AAU1@@Z ENDP ; std::addressof<ILLUSIONTEMPLE_START_TIME>
_TEXT	ENDS
PUBLIC	??$forward@ABUILLUSIONTEMPLE_START_TIME@@@std@@YAABUILLUSIONTEMPLE_START_TIME@@ABU1@@Z ; std::forward<ILLUSIONTEMPLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUILLUSIONTEMPLE_START_TIME@@@std@@YAABUILLUSIONTEMPLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUILLUSIONTEMPLE_START_TIME@@@std@@YAABUILLUSIONTEMPLE_START_TIME@@ABU1@@Z PROC ; std::forward<ILLUSIONTEMPLE_START_TIME const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUILLUSIONTEMPLE_START_TIME@@@std@@YAABUILLUSIONTEMPLE_START_TIME@@ABU1@@Z ENDP ; std::forward<ILLUSIONTEMPLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??$_Construct@UILLUSIONTEMPLE_START_TIME@@ABU1@@std@@YAXPAUILLUSIONTEMPLE_START_TIME@@ABU1@@Z ; std::_Construct<ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@UILLUSIONTEMPLE_START_TIME@@ABU1@@std@@YAXPAUILLUSIONTEMPLE_START_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UILLUSIONTEMPLE_START_TIME@@ABU1@@std@@YAXPAUILLUSIONTEMPLE_START_TIME@@ABU1@@Z PROC ; std::_Construct<ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@UILLUSIONTEMPLE_START_TIME@@ABU1@@std@@YAXPAUILLUSIONTEMPLE_START_TIME@@ABU1@@Z ENDP ; std::_Construct<ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCIllusionTempleEvent@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCIllusionTempleEvent@@UAEPAXI@Z PROC		; CIllusionTempleEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CIllusionTempleEvent@@UAE@XZ ; CIllusionTempleEvent::~CIllusionTempleEvent
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCIllusionTempleEvent@@UAEPAXI@Z ENDP		; CIllusionTempleEvent::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0EL@LOMGEPMJ@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5EnterUser@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	?IllusionTempleAddUser@CIllusionTempleEvent@@QAEHHEE@Z ; CIllusionTempleEvent::IllusionTempleAddUser
EXTRN	?NotifyTempleInfo@CIllusionTempleProcess@@QAEXEH@Z:PROC ; CIllusionTempleProcess::NotifyTempleInfo
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
EXTRN	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z:PROC ; CGPartyDelUser
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?AddBattleUser@CIllusionTempleProcess@@QAEHHEE@Z:PROC ; CIllusionTempleProcess::AddBattleUser
EXTRN	?RemoveInvalid@CIllusionTempleProcess@@QAEXXZ:PROC ; CIllusionTempleProcess::RemoveInvalid
EXTRN	?GetPkLevel@PartyClass@@QAEDH@Z:PROC		; PartyClass::GetPkLevel
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	?CGPShopReqClose@@YAXH@Z:PROC			; CGPShopReqClose
;	COMDAT ??_C@_0EL@LOMGEPMJ@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5EnterUser@
; File e:\work\tranet_version\gs\gameserver\illusiontempleprocess.h
CONST	SEGMENT
??_C@_0EL@LOMGEPMJ@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5EnterUser@ DB '['
	DB	'Illusion Temple] (%d) EnterUser: (%s)(%s) class:%d (Serial:%u'
	DB	'). PCRoom:%d', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\illusiontempleevent.cpp
CONST	ENDS
;	COMDAT ?IllusionTempleAddUser@CIllusionTempleEvent@@QAEHHEE@Z
_TEXT	SEGMENT
_pResult$ = -24						; size = 5
tv492 = -16						; size = 4
_pMsg$ = -12						; size = 4
tv530 = -8						; size = 4
tv529 = -8						; size = 4
tv527 = -8						; size = 4
tv513 = -8						; size = 4
tv511 = -8						; size = 4
tv503 = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_FloorIndex$ = 12					; size = 1
tv533 = 14						; size = 2
tv517 = 14						; size = 2
_TicketPos$ = 16					; size = 1
?IllusionTempleAddUser@CIllusionTempleEvent@@QAEHHEE@Z PROC ; CIllusionTempleEvent::IllusionTempleAddUser, COMDAT
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 189  : 	if(g_iIllusionTempleEvent == 0 )

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iIllusionTempleEvent@@3HA, 0 ; g_iIllusionTempleEvent
  0000d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00010	75 08		 jne	 SHORT $LN28@IllusionTe@2
$LN49@IllusionTe@2:

; 190  : 	{
; 191  : 		return FALSE;

  00012	33 c0		 xor	 eax, eax

; 357  : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
$LN28@IllusionTe@2:

; 192  : 	}
; 193  : 
; 194  : 	LPOBJ lpObj;
; 195  : 	PMSG_SEND_ILLUSION_ENTER_RESULT pResult;
; 196  : 	BOOL bPlayerKiller;
; 197  : 	int loc6;
; 198  : 	int loc7;
; 199  : 	int loc8;
; 200  : 	PMSG_PARTYDELUSER pMsg;
; 201  : 	int loc10;
; 202  : 
; 203  : 	if(CHECK_LIMIT( (FloorIndex), MAX_FLOOR_DATA+1) == FALSE)

  0001a	b8 05 00 00 00	 mov	 eax, 5
  0001f	3a 45 0c	 cmp	 al, BYTE PTR _FloorIndex$[ebp]
  00022	1b c0		 sbb	 eax, eax
  00024	40		 inc	 eax

; 204  : 	{
; 205  : 		return FALSE;

  00025	74 eb		 je	 SHORT $LN49@IllusionTe@2

; 206  : 	}
; 207  : 
; 208  : 	lpObj = &gObj[aIndex];

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	53		 push	 ebx
  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00031	56		 push	 esi
  00032	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H

; 209  : 	PHeadSubSetB((LPBYTE)&pResult, 0xBF, 0x00, sizeof(pResult));

  00038	6a 05		 push	 5
  0003a	6a 00		 push	 0
  0003c	8d 55 e8	 lea	 edx, DWORD PTR _pResult$[ebp]
  0003f	68 bf 00 00 00	 push	 191			; 000000bfH
  00044	52		 push	 edx
  00045	8d 34 0b	 lea	 esi, DWORD PTR [ebx+ecx]
  00048	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 210  : 	pResult.btResult = 0;

  00050	c6 45 ec 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 211  : 
; 212  : 	if(lpObj->Type != 1 || lpObj->Connected <= PLAYER_LOGGED)

  00054	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00059	0f 85 77 03 00
	00		 jne	 $LN25@IllusionTe@2
  0005f	83 7e 04 02	 cmp	 DWORD PTR [esi+4], 2
  00063	0f 8e 6d 03 00
	00		 jle	 $LN25@IllusionTe@2

; 215  : 	}
; 216  : 
; 217  : 	if ( lpObj->m_IfState.use != 0 && lpObj->m_IfState.type != 12 )

  00069	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0006f	a8 03		 test	 al, 3
  00071	74 10		 je	 SHORT $LN24@IllusionTe@2
  00073	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00078	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H

; 218  : 	{
; 219  : 		return FALSE;

  0007d	0f 85 53 03 00
	00		 jne	 $LN25@IllusionTe@2
$LN24@IllusionTe@2:

; 220  : 	}
; 221  : 
; 222  : 	if ( lpObj->m_bPShopOpen == true )

  00083	80 be c4 0e 00
	00 01		 cmp	 BYTE PTR [esi+3780], 1
  0008a	75 0b		 jne	 SHORT $LN23@IllusionTe@2

; 223  : 	{
; 224  : 		::CGPShopReqClose(lpObj->m_Index);

  0008c	8b 06		 mov	 eax, DWORD PTR [esi]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  00094	83 c4 04	 add	 esp, 4
$LN23@IllusionTe@2:

; 225  : 	}
; 226  : 
; 227  : 	bPlayerKiller = FALSE;

  00097	57		 push	 edi
  00098	33 ff		 xor	 edi, edi

; 228  : 
; 229  : 	if(ZtConfig.PvP.ZtPkPartySystem && lpObj->PartyNumber >= 0)

  0009a	39 3d 38 09 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2360, edi
  000a0	74 1e		 je	 SHORT $LN42@IllusionTe@2
  000a2	8b 86 2c 04 00
	00		 mov	 eax, DWORD PTR [esi+1068]
  000a8	85 c0		 test	 eax, eax
  000aa	78 14		 js	 SHORT $LN42@IllusionTe@2

; 230  : 	{
; 231  : 		if( (gParty.GetPkLevel(lpObj->PartyNumber)) >= 5)

  000ac	50		 push	 eax
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000b2	e8 00 00 00 00	 call	 ?GetPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPkLevel
  000b7	3c 05		 cmp	 al, 5
  000b9	7c 05		 jl	 SHORT $LN42@IllusionTe@2

; 232  : 		{
; 233  : 			bPlayerKiller = TRUE;

  000bb	bf 01 00 00 00	 mov	 edi, 1
$LN42@IllusionTe@2:

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	if( lpObj->m_PK_Level >= 4 )

  000c0	80 be 3d 01 00
	00 04		 cmp	 BYTE PTR [esi+317], 4

; 238  : 	{
; 239  : 		bPlayerKiller = TRUE;
; 240  : 	}
; 241  : 
; 242  : 	if(bPlayerKiller == TRUE)

  000c7	7d 05		 jge	 SHORT $LN37@IllusionTe@2
  000c9	83 ff 01	 cmp	 edi, 1
  000cc	75 24		 jne	 SHORT $LN19@IllusionTe@2
$LN37@IllusionTe@2:

; 243  : 	{
; 244  : 		pResult.btResult = 7;
; 245  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  000ce	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  000d2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000d5	51		 push	 ecx
  000d6	8d 55 e8	 lea	 edx, DWORD PTR _pResult$[ebp]
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	c6 45 ec 07	 mov	 BYTE PTR _pResult$[ebp+4], 7

; 259  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  000df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi

; 260  : 		return FALSE;

  000e9	33 c0		 xor	 eax, eax
  000eb	5b		 pop	 ebx

; 357  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 0c 00	 ret	 12			; 0000000cH
$LN19@IllusionTe@2:

; 246  : 		return FALSE;
; 247  : 	}
; 248  : 
; 249  : 	if(this->CheckWearingMOPH(aIndex) != FALSE)

  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000f5	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  000f8	51		 push	 ecx
  000f9	8b cf		 mov	 ecx, edi
  000fb	e8 00 00 00 00	 call	 ?CheckWearingMOPH@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckWearingMOPH
  00100	85 c0		 test	 eax, eax
  00102	74 09		 je	 SHORT $LN18@IllusionTe@2

; 250  : 	{
; 251  : 		pResult.btResult = 8;

  00104	c6 45 ec 08	 mov	 BYTE PTR _pResult$[ebp+4], 8

; 252  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);
; 253  : 		return FALSE;

  00108	e9 a9 02 00 00	 jmp	 $LN47@IllusionTe@2
$LN18@IllusionTe@2:

; 254  : 	}
; 255  : 
; 256  : 	if(this->m_IllusionTempleProcess[FloorIndex].GetState() != 0 || this->m_IllusionTempleProcess[FloorIndex].GetOpenStatus() == FALSE)

  0010d	0f b6 55 0c	 movzx	 edx, BYTE PTR _FloorIndex$[ebp]
  00111	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  00117	03 fa		 add	 edi, edx
  00119	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0011c	89 4d f0	 mov	 DWORD PTR tv492[ebp], ecx
  0011f	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  00124	84 c0		 test	 al, al
  00126	0f 85 86 02 00
	00		 jne	 $LN16@IllusionTe@2
  0012c	83 bf 98 03 00
	00 00		 cmp	 DWORD PTR [edi+920], 0
  00133	0f 84 79 02 00
	00		 je	 $LN16@IllusionTe@2

; 261  : 	}
; 262  : 
; 263  : 	if(gObj[aIndex].pInventory[TicketPos].IsItem() == TRUE)

  00139	0f b6 7d 10	 movzx	 edi, BYTE PTR _TicketPos$[ebp]
  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00142	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00148	8b 8c 03 24 0e
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+3620]
  0014f	03 cf		 add	 ecx, edi
  00151	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00156	83 f8 01	 cmp	 eax, 1
  00159	0f 85 4d 02 00
	00		 jne	 $LN15@IllusionTe@2

; 264  : 	{
; 265  : 		if(gObj[aIndex].pInventory[TicketPos].m_Type == ITEMGET(13,51))

  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00165	8b 84 0b 24 0e
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+3620]
  0016c	03 c7		 add	 eax, edi
  0016e	89 45 f8	 mov	 DWORD PTR tv503[ebp], eax
  00171	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  00175	ba 33 1a 00 00	 mov	 edx, 6707		; 00001a33H
  0017a	66 3b c2	 cmp	 ax, dx
  0017d	75 56		 jne	 SHORT $LN14@IllusionTe@2

; 266  : 		{
; 267  : 			loc6 = gObj[aIndex].pInventory[TicketPos].m_Level;

  0017f	8b 84 0b 24 0e
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+3620]
  00186	0f bf 5c 38 08	 movsx	 ebx, WORD PTR [eax+edi+8]

; 268  : 			loc7 = gObj[aIndex].pInventory[TicketPos].m_Number;
; 269  : 
; 270  : 			if(CHECK_LIMIT( loc6-1, MAX_FLOOR_DATA+1 ) == 0 && gObj[aIndex].pInventory[TicketPos].m_Durability != 1.0f)

  0018b	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0018e	85 c0		 test	 eax, eax
  00190	78 0e		 js	 SHORT $LN38@IllusionTe@2
  00192	33 c9		 xor	 ecx, ecx
  00194	83 f8 05	 cmp	 eax, 5
  00197	0f 9e c1	 setle	 cl
  0019a	8b c1		 mov	 eax, ecx
  0019c	85 c0		 test	 eax, eax
  0019e	75 55		 jne	 SHORT $LN39@IllusionTe@2
$LN38@IllusionTe@2:
  001a0	8b 55 f8	 mov	 edx, DWORD PTR tv503[ebp]
  001a3	d9 42 24	 fld	 DWORD PTR [edx+36]
  001a6	d9 e8		 fld1
  001a8	da e9		 fucompp
  001aa	df e0		 fnstsw	 ax
  001ac	f6 c4 44	 test	 ah, 68			; 00000044H
  001af	7b 44		 jnp	 SHORT $LN39@IllusionTe@2
$LN50@IllusionTe@2:

; 271  : 			{
; 272  : 				pResult.btResult = 1;
; 273  : 				DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  001b1	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001b5	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001b8	50		 push	 eax
  001b9	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001bc	51		 push	 ecx
  001bd	52		 push	 edx
  001be	c6 45 ec 01	 mov	 BYTE PTR _pResult$[ebp+4], 1
  001c2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	33 c0		 xor	 eax, eax
  001ce	5b		 pop	 ebx

; 357  : }

  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 0c 00	 ret	 12			; 0000000cH
$LN14@IllusionTe@2:

; 274  : 				return FALSE;
; 275  : 			}
; 276  : 		}
; 277  : 		else if(gObj[aIndex].pInventory[TicketPos].m_Type == ITEMGET(13,61))

  001d5	b9 3d 1a 00 00	 mov	 ecx, 6717		; 00001a3dH
  001da	66 3b c1	 cmp	 ax, cx
  001dd	0f 85 c9 01 00
	00		 jne	 $LN15@IllusionTe@2

; 278  : 	{
; 279  : 			loc7 = gObj[aIndex].pInventory[TicketPos].m_Number;
; 280  : 			loc6 = this->GetEnterLevel(aIndex);

  001e3	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	52		 push	 edx
  001ea	e8 00 00 00 00	 call	 ?GetEnterLevel@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::GetEnterLevel
  001ef	8b d8		 mov	 ebx, eax

; 281  : 			
; 282  : 			if(loc6 <= 0)

  001f1	85 db		 test	 ebx, ebx

; 283  : 			{
; 284  : 				pResult.btResult = 1;
; 285  : 				DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);
; 286  : 				return FALSE;

  001f3	7e bc		 jle	 SHORT $LN50@IllusionTe@2
$LN39@IllusionTe@2:

; 301  : 	}
; 302  : 	
; 303  : 	//if(this->EGReqIllusionTempleEnter(aIndex, FloorIndex, TicketPos, loc6) != FALSE)
; 304  : 	//{
; 305  : 	//	return TRUE;
; 306  : 	//}
; 307  : 
; 308  : 	if(this->CheckEnterLevel(aIndex, loc6) == FALSE)

  001f5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	53		 push	 ebx
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 ?CheckEnterLevel@CIllusionTempleEvent@@QAEHHH@Z ; CIllusionTempleEvent::CheckEnterLevel
  00202	85 c0		 test	 eax, eax
  00204	75 24		 jne	 SHORT $LN7@IllusionTe@2

; 309  : 	{
; 310  : 		pResult.btResult = 3;
; 311  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  00206	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0020a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0020d	51		 push	 ecx
  0020e	8d 55 e8	 lea	 edx, DWORD PTR _pResult$[ebp]
  00211	52		 push	 edx
  00212	50		 push	 eax
  00213	c6 45 ec 03	 mov	 BYTE PTR _pResult$[ebp+4], 3
  00217	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021f	5f		 pop	 edi
  00220	5e		 pop	 esi
  00221	33 c0		 xor	 eax, eax
  00223	5b		 pop	 ebx

; 357  : }

  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c2 0c 00	 ret	 12			; 0000000cH
$LN7@IllusionTe@2:

; 312  : 		return FALSE;
; 313  : 	}
; 314  : 
; 315  : 	this->m_IllusionTempleProcess[loc6-1].RemoveInvalid();

  0022a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0022d	8b cb		 mov	 ecx, ebx
  0022f	69 c9 f0 03 00
	00		 imul	 ecx, 1008		; 000003f0H
  00235	8d 8c 11 18 fc
	ff ff		 lea	 ecx, DWORD PTR [ecx+edx-1000]
  0023c	89 4d f8	 mov	 DWORD PTR tv529[ebp], ecx
  0023f	e8 00 00 00 00	 call	 ?RemoveInvalid@CIllusionTempleProcess@@QAEXXZ ; CIllusionTempleProcess::RemoveInvalid

; 316  : 
; 317  : 	loc8 = this->m_IllusionTempleProcess[loc6-1].AddBattleUser(aIndex, FloorIndex, TicketPos);

  00244	8b 45 10	 mov	 eax, DWORD PTR _TicketPos$[ebp]
  00247	8b 4d 0c	 mov	 ecx, DWORD PTR _FloorIndex$[ebp]
  0024a	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0024d	50		 push	 eax
  0024e	51		 push	 ecx
  0024f	8b 4d f8	 mov	 ecx, DWORD PTR tv529[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ?AddBattleUser@CIllusionTempleProcess@@QAEHHEE@Z ; CIllusionTempleProcess::AddBattleUser

; 318  : 
; 319  : 	if(loc8 == 1)

  00258	83 f8 01	 cmp	 eax, 1
  0025b	0f 85 28 01 00
	00		 jne	 $LN6@IllusionTe@2

; 320  : 	{
; 321  : 		if(lpObj->PartyNumber >= 0)

  00261	8b 86 2c 04 00
	00		 mov	 eax, DWORD PTR [esi+1068]
  00267	85 c0		 test	 eax, eax
  00269	78 28		 js	 SHORT $LN41@IllusionTe@2

; 322  : 		{
; 323  : 			loc10 = gParty.GetIndex(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);

  0026b	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  0026e	8b 16		 mov	 edx, DWORD PTR [esi]
  00270	51		 push	 ecx
  00271	52		 push	 edx
  00272	50		 push	 eax
  00273	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00278	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 324  : 
; 325  : 			if(loc10 >= 0)

  0027d	85 c0		 test	 eax, eax
  0027f	78 12		 js	 SHORT $LN41@IllusionTe@2

; 326  : 			{
; 327  : 				pMsg.Number = loc10;

  00281	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 328  : 				CGPartyDelUser(&pMsg, lpObj->m_Index);

  00284	8b 06		 mov	 eax, DWORD PTR [esi]
  00286	50		 push	 eax
  00287	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0028a	51		 push	 ecx
  0028b	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  00290	83 c4 08	 add	 esp, 8
$LN41@IllusionTe@2:

; 329  : 			}
; 330  : 		}
; 331  : 
; 332  : 		if(lpObj->pInventory[TicketPos].m_Type == ITEMGET(13,51) )

  00293	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  00299	0f b7 44 39 06	 movzx	 eax, WORD PTR [ecx+edi+6]
  0029e	ba 33 1a 00 00	 mov	 edx, 6707		; 00001a33H
  002a3	66 3b c2	 cmp	 ax, dx
  002a6	75 2f		 jne	 SHORT $LN3@IllusionTe@2

; 333  : 		{
; 334  : 			lpObj->pInventory[TicketPos].m_Durability = 0;

  002a8	d9 ee		 fldz
  002aa	8b c1		 mov	 eax, ecx
  002ac	d9 5c 38 24	 fstp	 DWORD PTR [eax+edi+36]

; 335  : 			GCItemDurSend(lpObj->m_Index, (BYTE)TicketPos, (BYTE)lpObj->pInventory[TicketPos].m_Durability, 0);

  002b0	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  002b6	d9 44 39 24	 fld	 DWORD PTR [ecx+edi+36]
  002ba	d9 7d 0e	 fnstcw	 WORD PTR tv533[ebp]
  002bd	0f b7 45 0e	 movzx	 eax, WORD PTR tv533[ebp]
  002c1	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002c6	89 45 f8	 mov	 DWORD PTR tv530[ebp], eax
  002c9	d9 6d f8	 fldcw	 WORD PTR tv530[ebp]
  002cc	db 5d f8	 fistp	 DWORD PTR tv527[ebp]
  002cf	8a 55 f8	 mov	 dl, BYTE PTR tv527[ebp]
  002d2	d9 6d 0e	 fldcw	 WORD PTR tv533[ebp]
  002d5	eb 4c		 jmp	 SHORT $LN46@IllusionTe@2
$LN3@IllusionTe@2:

; 336  : 		}
; 337  : 		else if(lpObj->pInventory[TicketPos].m_Type == ITEMGET(13,61) && lpObj->pInventory[TicketPos].m_Durability > 0.0f)

  002d7	ba 3d 1a 00 00	 mov	 edx, 6717		; 00001a3dH
  002dc	66 3b c2	 cmp	 ax, dx
  002df	75 57		 jne	 SHORT $LN1@IllusionTe@2
  002e1	d9 ee		 fldz
  002e3	d8 5c 39 24	 fcomp	 DWORD PTR [ecx+edi+36]
  002e7	df e0		 fnstsw	 ax
  002e9	f6 c4 05	 test	 ah, 5
  002ec	7a 4a		 jp	 SHORT $LN1@IllusionTe@2

; 338  : 		{
; 339  : 			lpObj->pInventory[TicketPos].m_Durability -= 1.0f;

  002ee	d9 44 39 24	 fld	 DWORD PTR [ecx+edi+36]
  002f2	8d 44 39 24	 lea	 eax, DWORD PTR [ecx+edi+36]
  002f6	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000

; 340  : 			GCItemDurSend(lpObj->m_Index, (BYTE)TicketPos, (BYTE)lpObj->pInventory[TicketPos].m_Durability, 0);

  002fc	d9 7d 0e	 fnstcw	 WORD PTR tv517[ebp]
  002ff	d9 18		 fstp	 DWORD PTR [eax]
  00301	0f b7 45 0e	 movzx	 eax, WORD PTR tv517[ebp]
  00305	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0030b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00310	89 45 f8	 mov	 DWORD PTR tv513[ebp], eax
  00313	d9 44 39 24	 fld	 DWORD PTR [ecx+edi+36]
  00317	d9 6d f8	 fldcw	 WORD PTR tv513[ebp]
  0031a	db 5d f8	 fistp	 DWORD PTR tv511[ebp]
  0031d	8a 55 f8	 mov	 dl, BYTE PTR tv511[ebp]
  00320	d9 6d 0e	 fldcw	 WORD PTR tv517[ebp]
$LN46@IllusionTe@2:
  00323	8b 4d 10	 mov	 ecx, DWORD PTR _TicketPos$[ebp]
  00326	0f b6 c2	 movzx	 eax, dl
  00329	8b 16		 mov	 edx, DWORD PTR [esi]
  0032b	6a 00		 push	 0
  0032d	50		 push	 eax
  0032e	51		 push	 ecx
  0032f	52		 push	 edx
  00330	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00335	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@IllusionTe@2:

; 341  : 		}
; 342  : 
; 343  : 		LogAddTD("[Illusion Temple] (%d) EnterUser: (%s)(%s) class:%d (Serial:%u). PCRoom:%d", loc6, lpObj->AccountID, lpObj->Name, lpObj->DbClass, lpObj->pInventory[TicketPos].m_Number, lpObj->m_iPcBangRoom); //season4 changed

  00338	8b 86 c4 1f 00
	00		 mov	 eax, DWORD PTR [esi+8132]
  0033e	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  00344	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]
  00347	50		 push	 eax
  00348	0f b6 86 ba 00
	00 00		 movzx	 eax, BYTE PTR [esi+186]
  0034f	52		 push	 edx
  00350	50		 push	 eax
  00351	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00354	51		 push	 ecx
  00355	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  00358	52		 push	 edx
  00359	53		 push	 ebx
  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LOMGEPMJ@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5EnterUser@
  0035f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 344  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  00365	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00369	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0036c	50		 push	 eax
  0036d	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00370	51		 push	 ecx
  00371	52		 push	 edx
  00372	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 345  : 
; 346  : 		gObjMoveGate(lpObj->m_Index,loc6+141);

  00377	8b 06		 mov	 eax, DWORD PTR [esi]
  00379	81 c3 8d 00 00
	00		 add	 ebx, 141		; 0000008dH
  0037f	53		 push	 ebx
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00386	83 c4 30	 add	 esp, 48			; 00000030H
$LN6@IllusionTe@2:

; 347  : 	}
; 348  : 
; 349  : 	this->m_IllusionTempleProcess[FloorIndex].NotifyTempleInfo(0, lpObj->m_Index);

  00389	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0038b	51		 push	 ecx
  0038c	8b 4d f0	 mov	 ecx, DWORD PTR tv492[ebp]
  0038f	6a 00		 push	 0
  00391	e8 00 00 00 00	 call	 ?NotifyTempleInfo@CIllusionTempleProcess@@QAEXEH@Z ; CIllusionTempleProcess::NotifyTempleInfo

; 350  : 	this->NotifyTempleEntranceInfo();

  00396	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00399	e8 00 00 00 00	 call	 ?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::NotifyTempleEntranceInfo
  0039e	5f		 pop	 edi
  0039f	5e		 pop	 esi

; 351  : 
; 352  : #if(DEBUG_IT == 1)
; 353  : 	GCServerMsgStringSend("CIllusionTempleEvent::IllusionTempleAddUser", lpObj->m_Index, 0);
; 354  : #endif
; 355  : 
; 356  : 	return TRUE;

  003a0	b8 01 00 00 00	 mov	 eax, 1
  003a5	5b		 pop	 ebx

; 357  : }

  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c2 0c 00	 ret	 12			; 0000000cH
$LN15@IllusionTe@2:

; 287  : 			}
; 288  : 		}
; 289  : 		else
; 290  : 		{
; 291  : 			pResult.btResult = 1;
; 292  : 			DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);
; 293  : 			return FALSE;
; 294  : 		}
; 295  : 	}
; 296  : 	else
; 297  : 	{
; 298  : 		pResult.btResult = 1;

  003ac	c6 45 ec 01	 mov	 BYTE PTR _pResult$[ebp+4], 1

; 299  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);
; 300  : 		return FALSE;

  003b0	eb 04		 jmp	 SHORT $LN47@IllusionTe@2
$LN16@IllusionTe@2:

; 257  : 	{
; 258  : 		pResult.btResult = 2;

  003b2	c6 45 ec 02	 mov	 BYTE PTR _pResult$[ebp+4], 2
$LN47@IllusionTe@2:

; 259  : 		DataSend(aIndex,(LPBYTE)&pResult,pResult.h.size);

  003b6	0f b6 55 e9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  003ba	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003bd	52		 push	 edx
  003be	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  003c1	50		 push	 eax
  003c2	51		 push	 ecx
  003c3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003cb	5f		 pop	 edi
  003cc	5e		 pop	 esi

; 260  : 		return FALSE;

  003cd	33 c0		 xor	 eax, eax
  003cf	5b		 pop	 ebx

; 357  : }

  003d0	8b e5		 mov	 esp, ebp
  003d2	5d		 pop	 ebp
  003d3	c2 0c 00	 ret	 12			; 0000000cH
$LN25@IllusionTe@2:
  003d6	5e		 pop	 esi

; 213  : 	{
; 214  : 		return FALSE;

  003d7	33 c0		 xor	 eax, eax
  003d9	5b		 pop	 ebx

; 357  : }

  003da	8b e5		 mov	 esp, ebp
  003dc	5d		 pop	 ebp
  003dd	c2 0c 00	 ret	 12			; 0000000cH
?IllusionTempleAddUser@CIllusionTempleEvent@@QAEHHEE@Z ENDP ; CIllusionTempleEvent::IllusionTempleAddUser
_TEXT	ENDS
PUBLIC	?EGAnsIllusionTempleEnter@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT@@@Z ; CIllusionTempleEvent::EGAnsIllusionTempleEnter
; Function compile flags: /Ogtp
;	COMDAT ?EGAnsIllusionTempleEnter@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT@@@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 5
tv478 = -16						; size = 4
_pPartyMsg$ = -12					; size = 4
tv544 = -8						; size = 4
tv542 = -8						; size = 4
_loc3$ = -8						; size = 1
_this$ = -4						; size = 4
tv625 = 8						; size = 4
tv456 = 8						; size = 4
_lpMsg$ = 8						; size = 4
tv547 = 10						; size = 2
?EGAnsIllusionTempleEnter@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT@@@Z PROC ; CIllusionTempleEvent::EGAnsIllusionTempleEnter, COMDAT
; _this$ = ecx

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	57		 push	 edi

; 386  : 	if( CHECK_LIMIT( (lpMsg->FloorIndex), MAX_FLOOR_DATA+1) == FALSE )

  00007	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0000a	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0000d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00010	85 c0		 test	 eax, eax
  00012	0f 88 f4 02 00
	00		 js	 $LN22@EGAnsIllus@2
  00018	33 c9		 xor	 ecx, ecx
  0001a	83 f8 05	 cmp	 eax, 5
  0001d	0f 9e c1	 setle	 cl
  00020	8b c1		 mov	 eax, ecx
  00022	85 c0		 test	 eax, eax
  00024	0f 84 e2 02 00
	00		 je	 $LN22@EGAnsIllus@2

; 387  : 	{
; 388  : 		return;
; 389  : 	}
; 390  : 
; 391  : 	if( OBJMAX_RANGE(lpMsg->Index) == FALSE )

  0002a	56		 push	 esi
  0002b	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  0002e	85 f6		 test	 esi, esi
  00030	0f 88 d5 02 00
	00		 js	 $LN36@EGAnsIllus@2
  00036	33 c0		 xor	 eax, eax
  00038	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0003e	0f 9e c0	 setle	 al
  00041	85 c0		 test	 eax, eax
  00043	0f 84 c2 02 00
	00		 je	 $LN36@EGAnsIllus@2

; 392  : 	{
; 393  : 		return;
; 394  : 	}
; 395  : 
; 396  : 	if( CHECK_LIMIT( (lpMsg->iPos), 75+1) == FALSE )

  00049	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0004c	85 c0		 test	 eax, eax
  0004e	0f 88 b7 02 00
	00		 js	 $LN36@EGAnsIllus@2
  00054	33 d2		 xor	 edx, edx
  00056	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00059	0f 9e c2	 setle	 dl
  0005c	8b c2		 mov	 eax, edx
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 a5 02 00
	00		 je	 $LN36@EGAnsIllus@2

; 397  : 	{
; 398  : 		return;
; 399  : 	}
; 400  : 
; 401  : 	LPOBJ lpObj = &gObj[lpMsg->Index];

  00066	53		 push	 ebx
  00067	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H

; 402  : 	BYTE loc3 = lpMsg->FloorIndex;

  0006d	8a 5f 2c	 mov	 bl, BYTE PTR [edi+44]
  00070	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 403  : 	int loc4 = 0;
; 404  : 	PMSG_SEND_ILLUSION_ENTER_RESULT pMsg;
; 405  : 
; 406  : 
; 407  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x00, sizeof(pMsg));

  00076	6a 05		 push	 5
  00078	6a 00		 push	 0
  0007a	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007d	68 bf 00 00 00	 push	 191			; 000000bfH
  00082	50		 push	 eax
  00083	88 5d f8	 mov	 BYTE PTR _loc3$[ebp], bl
  00086	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0008b	83 c4 10	 add	 esp, 16			; 00000010H

; 408  : 	pMsg.btResult = 0;
; 409  : 
; 410  : 	int loc6;
; 411  : 	int loc7;
; 412  : 
; 413  : 	if(lpMsg->IsEntered == 0)

  0008e	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00092	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00096	75 09		 jne	 SHORT $LN18@EGAnsIllus@2

; 414  : 	{
; 415  : 		pMsg.btResult = 5;

  00098	c6 45 ec 05	 mov	 BYTE PTR _pMsg$[ebp+4], 5

; 416  : 		DataSend(lpMsg->Index, (LPBYTE)&pMsg, pMsg.h.size);
; 417  : 		return;

  0009c	e9 54 02 00 00	 jmp	 $LN38@EGAnsIllus@2
$LN18@EGAnsIllus@2:

; 418  : 	}
; 419  : 
; 420  : 	if(this->m_IllusionTempleProcess[loc3].GetState() != 0 || this->m_IllusionTempleProcess[loc3].GetOpenStatus() == FALSE)

  000a1	0f b6 db	 movzx	 ebx, bl
  000a4	69 db f0 03 00
	00		 imul	 ebx, 1008		; 000003f0H
  000aa	03 5d fc	 add	 ebx, DWORD PTR _this$[ebp]
  000ad	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  000b0	89 4d f0	 mov	 DWORD PTR tv478[ebp], ecx
  000b3	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleProcess@@QAEEXZ ; CIllusionTempleProcess::GetState
  000b8	84 c0		 test	 al, al
  000ba	0f 85 31 02 00
	00		 jne	 $LN16@EGAnsIllus@2
  000c0	83 bb 98 03 00
	00 00		 cmp	 DWORD PTR [ebx+920], 0
  000c7	0f 84 24 02 00
	00		 je	 $LN16@EGAnsIllus@2

; 424  : 		return;
; 425  : 	}
; 426  : 
; 427  : 	if(lpObj->pInventory[lpMsg->iPos].IsItem() == TRUE)

  000cd	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  000d0	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  000d6	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  000dc	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000e1	83 f8 01	 cmp	 eax, 1
  000e4	75 53		 jne	 SHORT $LN12@EGAnsIllus@2

; 428  : 	{
; 429  : 		if(lpObj->pInventory[lpMsg->iPos].m_Type == ITEMGET(13,51))

  000e6	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000e9	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  000ef	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000f5	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  000fa	03 c8		 add	 ecx, eax
  000fc	b8 33 1a 00 00	 mov	 eax, 6707		; 00001a33H
  00101	66 3b d0	 cmp	 dx, ax
  00104	75 3c		 jne	 SHORT $LN13@EGAnsIllus@2

; 430  : 		{
; 431  : 			loc6 = lpObj->pInventory[lpMsg->iPos].m_Level;

  00106	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00109	8b 9e 24 0e 00
	00		 mov	 ebx, DWORD PTR [esi+3620]
  0010f	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00115	0f bf 44 18 08	 movsx	 eax, WORD PTR [eax+ebx+8]

; 432  : 			loc7 = lpObj->pInventory[lpMsg->iPos].m_Number;
; 433  : 
; 434  : 			if(CHECK_LIMIT( loc6-1, MAX_FLOOR_DATA+1 ) == 0 && lpObj->pInventory[lpMsg->iPos].m_Durability != 1.0f)

  0011a	48		 dec	 eax
  0011b	78 0e		 js	 SHORT $LN34@EGAnsIllus@2
  0011d	33 db		 xor	 ebx, ebx
  0011f	83 f8 05	 cmp	 eax, 5
  00122	0f 9e c3	 setle	 bl
  00125	8b c3		 mov	 eax, ebx
  00127	85 c0		 test	 eax, eax
  00129	75 17		 jne	 SHORT $LN13@EGAnsIllus@2
$LN34@EGAnsIllus@2:
  0012b	d9 41 24	 fld	 DWORD PTR [ecx+36]
  0012e	d9 e8		 fld1
  00130	da e9		 fucompp
  00132	df e0		 fnstsw	 ax
  00134	f6 c4 44	 test	 ah, 68			; 00000044H
  00137	7b 09		 jnp	 SHORT $LN13@EGAnsIllus@2
$LN12@EGAnsIllus@2:

; 435  : 			{
; 436  : 				pMsg.btResult = 1;

  00139	c6 45 ec 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 437  : 				DataSend(lpMsg->Index, (LPBYTE)&pMsg, pMsg.h.size);
; 438  : 				return;

  0013d	e9 b3 01 00 00	 jmp	 $LN38@EGAnsIllus@2
$LN13@EGAnsIllus@2:

; 439  : 			}
; 440  : 		}
; 441  : 
; 442  : 		if(lpObj->pInventory[lpMsg->iPos].m_Type == ITEMGET(13,61) && lpObj->pInventory[lpMsg->iPos].m_Durability > 0.0f) //fix the webzen bug

  00142	b8 3d 1a 00 00	 mov	 eax, 6717		; 00001a3dH
  00147	66 3b d0	 cmp	 dx, ax
  0014a	75 ed		 jne	 SHORT $LN12@EGAnsIllus@2
  0014c	d9 ee		 fldz
  0014e	d8 59 24	 fcomp	 DWORD PTR [ecx+36]
  00151	df e0		 fnstsw	 ax
  00153	f6 c4 05	 test	 ah, 5
  00156	7a e1		 jp	 SHORT $LN12@EGAnsIllus@2

; 443  : 		{
; 444  : 			loc7 = lpObj->pInventory[lpMsg->iPos].m_Number;
; 445  : 			loc4 = this->GetEnterLevel(lpObj->m_Index);

  00158	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0015a	51		 push	 ecx
  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?GetEnterLevel@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::GetEnterLevel
  00163	8b d8		 mov	 ebx, eax

; 446  : 			
; 447  : 			if(loc4 <= 0)

  00165	85 db		 test	 ebx, ebx
  00167	7f 22		 jg	 SHORT $LN11@EGAnsIllus@2
$LN40@EGAnsIllus@2:

; 448  : 			{
; 449  : 				pMsg.btResult = 3;
; 450  : 				DataSend(lpMsg->Index, (LPBYTE)&pMsg, pMsg.h.size);

  00169	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0016d	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00170	52		 push	 edx
  00171	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00174	50		 push	 eax
  00175	51		 push	 ecx
  00176	c6 45 ec 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3
  0017a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	5b		 pop	 ebx
  00183	5e		 pop	 esi
  00184	5f		 pop	 edi

; 525  : 
; 526  : #if(DEBUG_IT == 1)
; 527  : 	GCServerMsgStringSend("CIllusionTempleEvent::EGAnsIllusionTempleEnter", lpObj->m_Index, 0);
; 528  : #endif
; 529  : }

  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c2 04 00	 ret	 4
$LN11@EGAnsIllus@2:

; 451  : 				return;
; 452  : 			}
; 453  : 			else
; 454  : 			{
; 455  : 				loc6 = loc4;
; 456  : 			}
; 457  : 		}
; 458  : 		else
; 459  : 		{
; 460  : 			pMsg.btResult = 1;
; 461  : 			DataSend(lpMsg->Index, (LPBYTE)&pMsg, pMsg.h.size);
; 462  : 			return;
; 463  : 		}
; 464  : 	}
; 465  : 	else
; 466  : 	{
; 467  : 		pMsg.btResult = 1;
; 468  : 		DataSend(lpMsg->Index, (LPBYTE)&pMsg, pMsg.h.size);
; 469  : 		return;
; 470  : 	}
; 471  : 
; 472  : 	if(this->CheckEnterLevel(lpMsg->Index, loc6) == FALSE)

  0018b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0018e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	53		 push	 ebx
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ?CheckEnterLevel@CIllusionTempleEvent@@QAEHHH@Z ; CIllusionTempleEvent::CheckEnterLevel
  00198	85 c0		 test	 eax, eax

; 473  : 	{
; 474  : 		pMsg.btResult = 3;
; 475  : 		DataSend(lpMsg->Index,(LPBYTE)&pMsg,pMsg.h.size);
; 476  : 		return;

  0019a	74 cd		 je	 SHORT $LN40@EGAnsIllus@2

; 477  : 	}
; 478  : 
; 479  : 	this->m_IllusionTempleProcess[loc6-1].RemoveInvalid();

  0019c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	8b d3		 mov	 edx, ebx
  001a1	69 d2 f0 03 00
	00		 imul	 edx, 1008		; 000003f0H
  001a7	8d 8c 02 18 fc
	ff ff		 lea	 ecx, DWORD PTR [edx+eax-1000]
  001ae	89 4d 08	 mov	 DWORD PTR tv625[ebp], ecx
  001b1	e8 00 00 00 00	 call	 ?RemoveInvalid@CIllusionTempleProcess@@QAEXXZ ; CIllusionTempleProcess::RemoveInvalid

; 480  : 
; 481  : 	int loc8 = this->m_IllusionTempleProcess[loc6-1].AddBattleUser(lpMsg->Index, loc3, lpMsg->iPos);

  001b6	0f b6 4f 24	 movzx	 ecx, BYTE PTR [edi+36]
  001ba	8b 55 f8	 mov	 edx, DWORD PTR _loc3$[ebp]
  001bd	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  001c0	51		 push	 ecx
  001c1	8b 4d 08	 mov	 ecx, DWORD PTR tv625[ebp]
  001c4	52		 push	 edx
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ?AddBattleUser@CIllusionTempleProcess@@QAEHHEE@Z ; CIllusionTempleProcess::AddBattleUser

; 482  : 
; 483  : 	PMSG_PARTYDELUSER pPartyMsg;
; 484  : 
; 485  : 	if(loc8 == 1)

  001cb	83 f8 01	 cmp	 eax, 1
  001ce	0f 85 17 01 00
	00		 jne	 $LN6@EGAnsIllus@2

; 486  : 	{
; 487  : 		if(lpObj->PartyNumber >= 0)

  001d4	8b 86 2c 04 00
	00		 mov	 eax, DWORD PTR [esi+1068]
  001da	85 c0		 test	 eax, eax
  001dc	78 28		 js	 SHORT $LN35@EGAnsIllus@2

; 488  : 		{
; 489  : 			int loc10 = gParty.GetIndex(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);

  001de	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  001e1	8b 16		 mov	 edx, DWORD PTR [esi]
  001e3	51		 push	 ecx
  001e4	52		 push	 edx
  001e5	50		 push	 eax
  001e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001eb	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 490  : 
; 491  : 			if(loc10 >= 0) //ebp28

  001f0	85 c0		 test	 eax, eax
  001f2	78 12		 js	 SHORT $LN35@EGAnsIllus@2

; 492  : 			{
; 493  : 				
; 494  : 				pPartyMsg.Number = loc10; //Index

  001f4	88 45 f7	 mov	 BYTE PTR _pPartyMsg$[ebp+3], al

; 495  : 				CGPartyDelUser(&pPartyMsg, lpObj->m_Index);

  001f7	8b 06		 mov	 eax, DWORD PTR [esi]
  001f9	50		 push	 eax
  001fa	8d 4d f4	 lea	 ecx, DWORD PTR _pPartyMsg$[ebp]
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  00203	83 c4 08	 add	 esp, 8
$LN35@EGAnsIllus@2:

; 496  : 			}
; 497  : 		}
; 498  : 
; 499  : 		if(loc4 != 0)
; 500  : 		{
; 501  : 			lpObj->pInventory[lpMsg->iPos].m_Durability -= 1.0f;

  00206	8b 57 24	 mov	 edx, DWORD PTR [edi+36]

; 502  : 			GCItemDurSend(lpObj->m_Index, (BYTE)lpMsg->iPos, (BYTE)lpObj->pInventory[lpMsg->iPos].m_Durability, 0);

  00209	d9 7d 0a	 fnstcw	 WORD PTR tv547[ebp]
  0020c	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  00212	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00218	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  0021c	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00222	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]
  00226	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00229	8d 44 02 24	 lea	 eax, DWORD PTR [edx+eax+36]
  0022d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00233	0f b7 45 0a	 movzx	 eax, WORD PTR tv547[ebp]
  00237	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  0023d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00242	89 45 f8	 mov	 DWORD PTR tv544[ebp], eax
  00245	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  00249	0f b6 57 24	 movzx	 edx, BYTE PTR [edi+36]
  0024d	d9 6d f8	 fldcw	 WORD PTR tv544[ebp]
  00250	6a 00		 push	 0
  00252	db 5d f8	 fistp	 DWORD PTR tv542[ebp]
  00255	8a 45 f8	 mov	 al, BYTE PTR tv542[ebp]
  00258	0f b6 c8	 movzx	 ecx, al
  0025b	8b 06		 mov	 eax, DWORD PTR [esi]
  0025d	d9 6d 0a	 fldcw	 WORD PTR tv547[ebp]
  00260	51		 push	 ecx
  00261	52		 push	 edx
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend

; 503  : 		}
; 504  : 		else
; 505  : 		{
; 506  : 			lpObj->pInventory[lpMsg->iPos].m_Durability = 0;
; 507  : 			GCItemDurSend(lpObj->m_Index, (BYTE)lpMsg->iPos, (BYTE)lpObj->pInventory[lpMsg->iPos].m_Durability, 0);
; 508  : 		}
; 509  : 
; 510  : 		LogAddTD("[Illusion Temple] (%d) EnterUser: (%s)(%s) class:%d (Serial:%u). PCRoom:%d", loc6, lpObj->AccountID, lpObj->Name, lpObj->DbClass, lpObj->pInventory[lpMsg->iPos].m_Number, lpObj->m_iPcBangRoom); //season4 changed

  00268	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  0026b	8b 8e c4 1f 00
	00		 mov	 ecx, DWORD PTR [esi+8132]
  00271	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  00277	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0027d	51		 push	 ecx
  0027e	8b 0c 02	 mov	 ecx, DWORD PTR [edx+eax]
  00281	0f b6 96 ba 00
	00 00		 movzx	 edx, BYTE PTR [esi+186]
  00288	51		 push	 ecx
  00289	52		 push	 edx
  0028a	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0028d	50		 push	 eax
  0028e	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00291	51		 push	 ecx
  00292	53		 push	 ebx
  00293	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LOMGEPMJ@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5EnterUser@
  00298	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 511  : 		DataSend(lpMsg->Index,(LPBYTE)&pMsg,pMsg.h.size);

  0029e	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  002a2	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  002a5	52		 push	 edx
  002a6	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002a9	50		 push	 eax
  002aa	51		 push	 ecx
  002ab	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 512  : 
; 513  : 		gObjMoveGate(lpObj->m_Index,loc6+141);

  002b0	8b 16		 mov	 edx, DWORD PTR [esi]
  002b2	81 c3 8d 00 00
	00		 add	 ebx, 141		; 0000008dH
  002b8	53		 push	 ebx
  002b9	52		 push	 edx
  002ba	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 520  : 	}
; 521  : 
; 522  : 	this->m_IllusionTempleProcess[loc3].NotifyTempleInfo(0, lpMsg->Index);

  002bf	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  002c2	8b 4d f0	 mov	 ecx, DWORD PTR tv478[ebp]
  002c5	83 c4 40	 add	 esp, 64			; 00000040H
  002c8	50		 push	 eax
  002c9	6a 00		 push	 0
  002cb	e8 00 00 00 00	 call	 ?NotifyTempleInfo@CIllusionTempleProcess@@QAEXEH@Z ; CIllusionTempleProcess::NotifyTempleInfo

; 523  : 	this->NotifyTempleEntranceInfo();

  002d0	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  002d3	8b cf		 mov	 ecx, edi
  002d5	e8 00 00 00 00	 call	 ?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::NotifyTempleEntranceInfo

; 524  : 	this->EGSetIllusionTempleEnterCount(lpObj);

  002da	56		 push	 esi
  002db	8b cf		 mov	 ecx, edi
  002dd	e8 00 00 00 00	 call	 ?EGSetIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::EGSetIllusionTempleEnterCount
  002e2	5b		 pop	 ebx
  002e3	5e		 pop	 esi
  002e4	5f		 pop	 edi

; 525  : 
; 526  : #if(DEBUG_IT == 1)
; 527  : 	GCServerMsgStringSend("CIllusionTempleEvent::EGAnsIllusionTempleEnter", lpObj->m_Index, 0);
; 528  : #endif
; 529  : }

  002e5	8b e5		 mov	 esp, ebp
  002e7	5d		 pop	 ebp
  002e8	c2 04 00	 ret	 4
$LN6@EGAnsIllus@2:

; 514  : 	}
; 515  : 	else
; 516  : 	{
; 517  : 		pMsg.btResult = 4;

  002eb	c6 45 ec 04	 mov	 BYTE PTR _pMsg$[ebp+4], 4

; 518  : 		DataSend(lpMsg->Index,(LPBYTE)&pMsg,pMsg.h.size);
; 519  : 		return;

  002ef	eb 04		 jmp	 SHORT $LN38@EGAnsIllus@2
$LN16@EGAnsIllus@2:

; 421  : 	{
; 422  : 		pMsg.btResult = 2;

  002f1	c6 45 ec 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
$LN38@EGAnsIllus@2:

; 423  : 		DataSend(lpMsg->Index, (LPBYTE)&pMsg, pMsg.h.size);

  002f5	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  002f9	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  002fc	51		 push	 ecx
  002fd	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00300	52		 push	 edx
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00307	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030a	5b		 pop	 ebx
$LN36@EGAnsIllus@2:
  0030b	5e		 pop	 esi
$LN22@EGAnsIllus@2:
  0030c	5f		 pop	 edi

; 525  : 
; 526  : #if(DEBUG_IT == 1)
; 527  : 	GCServerMsgStringSend("CIllusionTempleEvent::EGAnsIllusionTempleEnter", lpObj->m_Index, 0);
; 528  : #endif
; 529  : }

  0030d	8b e5		 mov	 esp, ebp
  0030f	5d		 pop	 ebp
  00310	c2 04 00	 ret	 4
?EGAnsIllusionTempleEnter@CIllusionTempleEvent@@QAEXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER_RESULT@@@Z ENDP ; CIllusionTempleEvent::EGAnsIllusionTempleEnter
_TEXT	ENDS
PUBLIC	?BattleDeleteUser@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::BattleDeleteUser
EXTRN	?LeaveBattleUser@CIllusionTempleProcess@@QAEHH@Z:PROC ; CIllusionTempleProcess::LeaveBattleUser
; Function compile flags: /Ogtp
;	COMDAT ?BattleDeleteUser@CIllusionTempleEvent@@QAEHHE@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
?BattleDeleteUser@CIllusionTempleEvent@@QAEHHE@Z PROC	; CIllusionTempleEvent::BattleDeleteUser, COMDAT
; _this$ = ecx

; 545  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 	if( CHECK_LIMIT( (MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN), MAX_FLOOR_DATA+1) == FALSE )

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 48 d3	 lea	 ecx, DWORD PTR [eax-45]
  0000d	85 c9		 test	 ecx, ecx
  0000f	78 0e		 js	 SHORT $LN6@BattleDele
  00011	33 d2		 xor	 edx, edx
  00013	83 f9 05	 cmp	 ecx, 5
  00016	0f 9e c2	 setle	 dl
  00019	8b ca		 mov	 ecx, edx
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 07		 jne	 SHORT $LN1@BattleDele
$LN6@BattleDele:

; 547  : 	{
; 548  : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	5e		 pop	 esi

; 555  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN1@BattleDele:

; 549  : 	}
; 550  : 
; 551  : 	this->m_IllusionTempleProcess[MapNumber - MAP_INDEX_ILLUSIONTEMPLE_MIN].LeaveBattleUser(aIndex);

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	69 c0 f0 03 00
	00		 imul	 eax, 1008		; 000003f0H
  0002f	51		 push	 ecx
  00030	8d 8c 30 d8 4e
	ff ff		 lea	 ecx, DWORD PTR [eax+esi-45352]
  00037	e8 00 00 00 00	 call	 ?LeaveBattleUser@CIllusionTempleProcess@@QAEHH@Z ; CIllusionTempleProcess::LeaveBattleUser

; 552  : 	this->NotifyTempleEntranceInfo();

  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?NotifyTempleEntranceInfo@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::NotifyTempleEntranceInfo

; 553  : 
; 554  : 	return TRUE;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	5e		 pop	 esi

; 555  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?BattleDeleteUser@CIllusionTempleEvent@@QAEHHE@Z ENDP	; CIllusionTempleEvent::BattleDeleteUser
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?TicketChaosMix@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::TicketChaosMix
; Function compile flags: /Ogtp
;	COMDAT ?TicketChaosMix@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iRET_VAL$ = -24					; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?TicketChaosMix@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CIllusionTempleEvent::TicketChaosMix, COMDAT
; _this$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 842  : 	lpObj->ChaosLock = TRUE;
; 843  : 
; 844  : 	PMSG_CHAOSMIXRESULT pMsg;
; 845  : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00016	6a 10		 push	 16			; 00000010H
  00018	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	68 86 00 00 00	 push	 134			; 00000086H
  00020	50		 push	 eax
  00021	8b d9		 mov	 ebx, ecx
  00023	c7 87 88 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+3720], 1
  0002d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 846  : 	pMsg.Result = CB_ERROR;
; 847  : 
; 848  : 	int aIndex;
; 849  : 	int ebp18;
; 850  : 	int iRET_VAL;
; 851  : 
; 852  : 	aIndex = lpObj->m_Index;

  00032	8b 37		 mov	 esi, DWORD PTR [edi]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 853  : 	ebp18 = 0;
; 854  : 	iRET_VAL = this->CheckChoasMixItem(aIndex);

  00037	56		 push	 esi
  00038	8b cb		 mov	 ecx, ebx
  0003a	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0003e	e8 00 00 00 00	 call	 ?CheckChoasMixItem@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckChoasMixItem

; 855  : 	ebp18 = this->CheckLuckyTalisman(aIndex);

  00043	56		 push	 esi
  00044	8b cb		 mov	 ecx, ebx
  00046	89 45 e8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax
  00049	e8 00 00 00 00	 call	 ?CheckLuckyTalisman@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckLuckyTalisman

; 856  : 
; 857  : 	if(ebp18 > 10)

  0004e	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00053	3b c2		 cmp	 eax, edx
  00055	7e 07		 jle	 SHORT $LN18@TicketChao

; 858  : 	{
; 859  : 		iRET_VAL = 15;

  00057	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _iRET_VAL$[ebp], 15 ; 0000000fH
$LN18@TicketChao:

; 860  : 	}
; 861  : 
; 862  : 	if ( IT_MAP_RANGE((iRET_VAL+(MAP_INDEX_ILLUSIONTEMPLE_MIN-1))) != FALSE )

  0005e	8b 4d e8	 mov	 ecx, DWORD PTR _iRET_VAL$[ebp]
  00061	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00064	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00067	7c 26		 jl	 SHORT $LN12@TicketChao
  00069	33 d2		 xor	 edx, edx
  0006b	83 f9 32	 cmp	 ecx, 50			; 00000032H
  0006e	0f 9e c2	 setle	 dl
  00071	8b ca		 mov	 ecx, edx
  00073	85 c9		 test	 ecx, ecx
  00075	74 13		 je	 SHORT $LN20@TicketChao

; 863  : 	{
; 864  : 		if(this->IllusionTempleChaosMix(aIndex, iRET_VAL, ebp18) == FALSE)

  00077	50		 push	 eax
  00078	8b 45 e8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  0007b	50		 push	 eax
  0007c	56		 push	 esi
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?IllusionTempleChaosMix@CIllusionTempleEvent@@QAEEHHH@Z ; CIllusionTempleEvent::IllusionTempleChaosMix
  00084	84 c0		 test	 al, al
  00086	75 7e		 jne	 SHORT $LN9@TicketChao

; 865  : 		{
; 866  : 			lpObj->ChaosLock = FALSE;
; 867  : 		}
; 868  : 		return;

  00088	eb 72		 jmp	 SHORT $LN1@TicketChao
$LN20@TicketChao:
  0008a	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
$LN12@TicketChao:

; 869  : 	}
; 870  : 
; 871  : 	switch ( iRET_VAL )

  0008f	8b 45 e8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
  00092	83 c0 f7	 add	 eax, -9			; fffffff7H
  00095	83 f8 06	 cmp	 eax, 6
  00098	77 62		 ja	 SHORT $LN1@TicketChao
  0009a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@TicketChao[eax*4]
$LN8@TicketChao:

; 872  : 	{
; 873  : 		case 9:
; 874  : 			pMsg.Result = CB_NO_BC_CORRECT_ITEMS	;

  000a1	88 55 ef	 mov	 BYTE PTR _pMsg$[ebp+3], dl

; 875  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 876  : 			lpObj->m_Index;
; 877  : 			lpObj->ChaosLock = FALSE;
; 878  : 			break;

  000a4	eb 44		 jmp	 SHORT $LN21@TicketChao
$LN7@TicketChao:

; 879  : 
; 880  : 		case 10:
; 881  : 			pMsg.Result = CB_NO_BC_CORRECT_ITEMS	;
; 882  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000a6	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000aa	50		 push	 eax
  000ab	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000ae	88 55 ef	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  000b1	51		 push	 ecx

; 883  : 			lpObj->m_Index;
; 884  : 			lpObj->ChaosLock = FALSE;
; 885  : 			break;

  000b2	eb 3f		 jmp	 SHORT $LN22@TicketChao
$LN6@TicketChao:

; 886  : 
; 887  : 		case 11:
; 888  : 			pMsg.Result = CB_NO_BC_CORRECT_ITEMS	;

  000b4	88 55 ef	 mov	 BYTE PTR _pMsg$[ebp+3], dl

; 889  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000b7	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000bb	52		 push	 edx
  000bc	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000bf	50		 push	 eax

; 890  : 			lpObj->m_Index;
; 891  : 			lpObj->ChaosLock = FALSE;
; 892  : 			break;

  000c0	eb 31		 jmp	 SHORT $LN22@TicketChao
$LN5@TicketChao:

; 893  : 
; 894  : 		case 12:
; 895  : 			pMsg.Result = CB_INVALID_ITEM_LEVEL	;

  000c2	c6 45 ef 08	 mov	 BYTE PTR _pMsg$[ebp+3], 8

; 896  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 897  : 			lpObj->m_Index;
; 898  : 			lpObj->ChaosLock = FALSE;
; 899  : 			break;

  000c6	eb 22		 jmp	 SHORT $LN21@TicketChao
$LN4@TicketChao:

; 900  : 
; 901  : 		case 13:
; 902  : 			pMsg.Result = CB_BC_NOT_ENOUGH_ZEN	;
; 903  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000c8	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000cc	50		 push	 eax
  000cd	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000d0	c6 45 ef 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH
  000d4	51		 push	 ecx

; 904  : 			lpObj->m_Index;
; 905  : 			lpObj->ChaosLock = FALSE;
; 906  : 			break;

  000d5	eb 1c		 jmp	 SHORT $LN22@TicketChao
$LN3@TicketChao:

; 907  : 
; 908  : 		case 14:
; 909  : 			pMsg.Result = CB_USER_CLASS_LOW_LEVEL	;
; 910  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000d7	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000db	52		 push	 edx
  000dc	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000df	c6 45 ef 09	 mov	 BYTE PTR _pMsg$[ebp+3], 9
  000e3	50		 push	 eax

; 911  : 			lpObj->m_Index;
; 912  : 			lpObj->ChaosLock = FALSE;
; 913  : 			break;

  000e4	eb 0d		 jmp	 SHORT $LN22@TicketChao
$LN2@TicketChao:

; 914  : 		case 15:
; 915  : 			pMsg.Result = 0xF0;

  000e6	c6 45 ef f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H
$LN21@TicketChao:

; 916  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000ea	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000ee	51		 push	 ecx
  000ef	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000f2	52		 push	 edx
$LN22@TicketChao:
  000f3	56		 push	 esi
  000f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@TicketChao:

; 917  : 			lpObj->ChaosLock = FALSE;
; 918  : 			break;
; 919  : 		default:
; 920  : 			lpObj->ChaosLock = FALSE;

  000fc	c7 87 88 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+3720], 0
$LN9@TicketChao:

; 921  : 	}
; 922  : }

  00106	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	33 cd		 xor	 ecx, ebp
  0010d	5b		 pop	 ebx
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
  00119	8d 49 00	 npad	 3
$LN23@TicketChao:
  0011c	00 00 00 00	 DD	 $LN8@TicketChao
  00120	00 00 00 00	 DD	 $LN7@TicketChao
  00124	00 00 00 00	 DD	 $LN6@TicketChao
  00128	00 00 00 00	 DD	 $LN5@TicketChao
  0012c	00 00 00 00	 DD	 $LN4@TicketChao
  00130	00 00 00 00	 DD	 $LN3@TicketChao
  00134	00 00 00 00	 DD	 $LN2@TicketChao
?TicketChaosMix@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CIllusionTempleEvent::TicketChaosMix
_TEXT	ENDS
PUBLIC	?max_size@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QBEIXZ ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::max_size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?max_size@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::max_size, COMDAT
; _this$ = ecx

; 882  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 883  : 		}

  00005	c3		 ret	 0
?max_size@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T219066 = -12						; size = 12
$T219071 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 40		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 10		 ja	 SHORT $LN1@Allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00025	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00027	8d 45 08	 lea	 eax, DWORD PTR $T219071[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T219066[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T219071[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T219066[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T219066[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QAEXPAUILLUSIONTEMPLE_START_TIME@@ABU3@@Z ; std::allocator<ILLUSIONTEMPLE_START_TIME>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QAEXPAUILLUSIONTEMPLE_START_TIME@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QAEXPAUILLUSIONTEMPLE_START_TIME@@ABU3@@Z PROC ; std::allocator<ILLUSIONTEMPLE_START_TIME>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@QAEXPAUILLUSIONTEMPLE_START_TIME@@ABU3@@Z ENDP ; std::allocator<ILLUSIONTEMPLE_START_TIME>::construct
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXI@Z ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Incsize
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
CONST	ENDS
;	COMDAT ?_Incsize@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXI@Z PROC ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Incsize, COMDAT
; _this$ = ecx

; 1519 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	be fe ff ff 1f	 mov	 esi, 536870910		; 1ffffffeH
  0000f	2b f0		 sub	 esi, eax
  00011	3b f2		 cmp	 esi, edx
  00013	5e		 pop	 esi
  00014	73 0a		 jae	 SHORT $LN1@Incsize

; 1521 : 			_Xlength_error("list<T> too long");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0001b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN11@Incsize:
$LN1@Incsize:

; 1522 : 		this->_Mysize += _Count;

  00020	03 c2		 add	 eax, edx
  00022	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1523 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN10@Incsize:
?_Incsize@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXI@Z ENDP ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Incsize
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z ; std::allocator<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z
_TEXT	SEGMENT
$T219136 = -12						; size = 12
$T219128 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 40		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00015	77 10		 ja	 SHORT $LN3@allocate
  00017	c1 e1 04	 shl	 ecx, 4
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00027	8d 45 08	 lea	 eax, DWORD PTR $T219128[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f4	 lea	 ecx, DWORD PTR $T219136[ebp]
  0002e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T219128[ebp], 0
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 4d f4	 lea	 ecx, DWORD PTR $T219136[ebp]
  00042	51		 push	 ecx
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T219136[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >::_List_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >::_List_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >::_List_const_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@UILLUSIONTEMPLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UILLUSIONTEMPLE_START_TIME@@@0@PAUILLUSIONTEMPLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<ILLUSIONTEMPLE_START_TIME>,ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@UILLUSIONTEMPLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UILLUSIONTEMPLE_START_TIME@@@0@PAUILLUSIONTEMPLE_START_TIME@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@UILLUSIONTEMPLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UILLUSIONTEMPLE_START_TIME@@@0@PAUILLUSIONTEMPLE_START_TIME@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<ILLUSIONTEMPLE_START_TIME>,ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@UILLUSIONTEMPLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UILLUSIONTEMPLE_START_TIME@@@0@PAUILLUSIONTEMPLE_START_TIME@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<ILLUSIONTEMPLE_START_TIME>,ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>
_TEXT	ENDS
PUBLIC	?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Buynode
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\list
;	COMDAT ?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z
_TEXT	SEGMENT
$T219223 = -12						; size = 12
$T219207 = 8						; size = 4
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z PROC ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Buynode, COMDAT
; _this$ = ecx

; 507  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00008	6a 10		 push	 16			; 00000010H
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	83 c4 04	 add	 esp, 4
  00016	85 f6		 test	 esi, esi
  00018	74 29		 je	 SHORT $LN10@Buynode

; 509  : 
; 510  : 		_TRY_BEGIN
; 511  : 		this->_Nextnode(_Pnode) = _Next;

  0001a	8b 45 08	 mov	 eax, DWORD PTR __Next$[ebp]

; 512  : 		this->_Prevnode(_Pnode) = _Prev;
; 513  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Pnode)), _Val);

  0001d	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR __Prev$[ebp]
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	52		 push	 edx
  00026	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00029	50		 push	 eax
  0002a	83 c7 09	 add	 edi, 9
  0002d	57		 push	 edi
  0002e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00031	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@UILLUSIONTEMPLE_START_TIME@@ABU3@@std@@YAXAAV?$allocator@UILLUSIONTEMPLE_START_TIME@@@0@PAUILLUSIONTEMPLE_START_TIME@@ABU2@@Z ; std::_Cons_val<std::allocator<ILLUSIONTEMPLE_START_TIME>,ILLUSIONTEMPLE_START_TIME,ILLUSIONTEMPLE_START_TIME const &>
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	5f		 pop	 edi

; 514  : 		_CATCH_ALL
; 515  : 		this->_Alnod.deallocate(_Pnode, 1);
; 516  : 		_RERAISE;
; 517  : 		_CATCH_END
; 518  : 
; 519  : 		return (_Pnode);

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 520  : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH

; 508  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

$LN10@Buynode:
  00043	8d 4d 08	 lea	 ecx, DWORD PTR $T219207[ebp]
  00046	51		 push	 ecx
  00047	8d 4d f4	 lea	 ecx, DWORD PTR $T219223[ebp]
  0004a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T219207[ebp], 0
  00051	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00056	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005b	8d 55 f4	 lea	 edx, DWORD PTR $T219223[ebp]
  0005e	52		 push	 edx
  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T219223[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00066	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@Buynode:
$LN32@Buynode:
  0006b	cc		 int	 3
?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z ENDP ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >::_List_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >::_List_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >, COMDAT
; _this$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@std@@QAE@PAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@PBV?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >::_List_iterator<std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> > >
_TEXT	ENDS
PUBLIC	?end@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@XZ ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@XZ PROC ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Myhead, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::end
_TEXT	ENDS
PUBLIC	?_Insert@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@ABUILLUSIONTEMPLE_START_TIME@@@Z ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@ABUILLUSIONTEMPLE_START_TIME@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@ABUILLUSIONTEMPLE_START_TIME@@@Z PROC ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Insert, COMDAT
; _this$ = ecx

; 967  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 968  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 969  : 		if (_Where._Getcont() != this)
; 970  : 			_DEBUG_ERROR("list insert iterator outside range");
; 971  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 972  : 
; 973  : 		_Nodeptr _Pnode = _Where._Mynode();
; 974  : 		_Nodeptr _Newnode =
; 975  : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode), _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00010	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00013	51		 push	 ecx
  00014	52		 push	 edx
  00015	50		 push	 eax
  00016	8b ce		 mov	 ecx, esi
  00018	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Buynode

; 976  : 		_Incsize(1);

  0001d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00020	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00025	2b d1		 sub	 edx, ecx
  00027	83 fa 01	 cmp	 edx, 1
  0002a	73 0a		 jae	 SHORT $LN7@Insert
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN24@Insert:
$LN7@Insert:
  00036	41		 inc	 ecx
  00037	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 977  : 		this->_Prevnode(_Pnode) = _Newnode;

  0003a	89 07		 mov	 DWORD PTR [edi], eax

; 978  : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	5f		 pop	 edi
  00040	89 01		 mov	 DWORD PTR [ecx], eax
  00042	5e		 pop	 esi

; 979  : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN23@Insert:
?_Insert@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@@2@ABUILLUSIONTEMPLE_START_TIME@@@Z ENDP ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Insert
_TEXT	ENDS
PUBLIC	?push_back@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXABUILLUSIONTEMPLE_START_TIME@@@Z ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXABUILLUSIONTEMPLE_START_TIME@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXABUILLUSIONTEMPLE_START_TIME@@@Z PROC ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::push_back, COMDAT
; _this$ = ecx

; 926  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 927  : 		_Insert(end(), _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	57		 push	 edi
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Buynode
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00021	2b d1		 sub	 edx, ecx
  00023	83 fa 01	 cmp	 edx, 1
  00026	73 0a		 jae	 SHORT $LN19@push_back
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@push_back:
$LN19@push_back:
  00032	41		 inc	 ecx
  00033	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00036	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	5f		 pop	 edi
  0003d	89 01		 mov	 DWORD PTR [ecx], eax
  0003f	5e		 pop	 esi

; 928  : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN36@push_back:
?push_back@?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEXABUILLUSIONTEMPLE_START_TIME@@@Z ENDP ; std::list<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CL@GCHBFEEM@?$FLIllusion?5Temple?$FN?5Info?5file?5Load@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Load@CIllusionTempleEvent@@QAEHPAD@Z		; CIllusionTempleEvent::Load
EXTRN	_fclose:PROC
EXTRN	?m_listIllusionTempleOpenTime@@3V?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@A:BYTE ; m_listIllusionTempleOpenTime
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GCHBFEEM@?$FLIllusion?5Temple?$FN?5Info?5file?5Load@
CONST	SEGMENT
??_C@_0CL@GCHBFEEM@?$FLIllusion?5Temple?$FN?5Info?5file?5Load@ DB '[Illus'
	DB	'ion Temple] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\illusiontempleevent.cpp
CONST	ENDS
;	COMDAT ?Load@CIllusionTempleEvent@@QAEHPAD@Z
_TEXT	SEGMENT
_Schedule$217535 = -8					; size = 8
_lpszFileName$ = 8					; size = 4
?Load@CIllusionTempleEvent@@QAEHPAD@Z PROC		; CIllusionTempleEvent::Load, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 71   : 	SMDFile = fopen(lpszFileName, "r");

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpszFileName$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0000f	53		 push	 ebx
  00010	e8 00 00 00 00	 call	 _fopen
  00015	83 c4 08	 add	 esp, 8
  00018	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 72   : 
; 73   : 	if ( SMDFile == NULL )

  0001d	85 c0		 test	 eax, eax
  0001f	75 17		 jne	 SHORT $LN51@Load

; 74   : 	{
; 75   : 		MsgBox("[Illusion Temple] Info file Load Fail [%s]", lpszFileName);

  00021	53		 push	 ebx
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@GCHBFEEM@?$FLIllusion?5Temple?$FN?5Info?5file?5Load@
  00027	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002c	83 c4 08	 add	 esp, 8

; 76   : 		return false;

  0002f	33 c0		 xor	 eax, eax
  00031	5b		 pop	 ebx

; 140  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN51@Load:

; 77   : 	}
; 78   : 
; 79   : 	int Token;
; 80   : 	int type;
; 81   : 
; 82   : 	while ( true )
; 83   : 	{
; 84   : 		Token = GetToken();

  00038	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 85   : 
; 86   : 		if ( Token == 2 )

  0003d	83 f8 02	 cmp	 eax, 2
  00040	0f 84 60 01 00
	00		 je	 $LN57@Load
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL10@Load:

; 87   : 		{
; 88   : 			break;
; 89   : 		}
; 90   : 
; 91   : 		type = (int)TokenNumber;

  00050	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00056	e8 00 00 00 00	 call	 __ftol2_sse
  0005b	8b f8		 mov	 edi, eax
  0005d	8d 49 00	 npad	 3
$LL7@Load:

; 92   : 
; 93   : 		while ( true )
; 94   : 		{
; 95   : 			if ( type == 0 )

  00060	85 ff		 test	 edi, edi
  00062	0f 85 90 00 00
	00		 jne	 $LN5@Load

; 96   : 			{
; 97   : 				Token = GetToken();

  00068	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 98   : 
; 99   : 				if ( strcmp("end", TokenString) == 0 )

  0006d	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00072	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL58@Load:
  00077	8a 10		 mov	 dl, BYTE PTR [eax]
  00079	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0007b	75 1a		 jne	 SHORT $LN59@Load
  0007d	84 d2		 test	 dl, dl
  0007f	74 12		 je	 SHORT $LN66@Load
  00081	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00084	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00087	75 0e		 jne	 SHORT $LN59@Load
  00089	83 c0 02	 add	 eax, 2
  0008c	83 c1 02	 add	 ecx, 2
  0008f	84 d2		 test	 dl, dl
  00091	75 e4		 jne	 SHORT $LL58@Load
$LN66@Load:
  00093	33 c0		 xor	 eax, eax
  00095	eb 05		 jmp	 SHORT $LN61@Load
$LN59@Load:
  00097	1b c0		 sbb	 eax, eax
  00099	83 d8 ff	 sbb	 eax, -1
$LN61@Load:
  0009c	85 c0		 test	 eax, eax
  0009e	0f 84 f2 00 00
	00		 je	 $LN54@Load

; 100  : 				{
; 101  : 					break;
; 102  : 				}
; 103  : 
; 104  : 				m_i_IT_OpenTime = (int)TokenNumber;

  000a4	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000aa	e8 00 00 00 00	 call	 __ftol2_sse
  000af	a3 00 00 00 00	 mov	 DWORD PTR ?m_i_IT_OpenTime@@3HA, eax ; m_i_IT_OpenTime

; 105  : 
; 106  : 				Token = GetToken();

  000b4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 107  : 				m_i_IT_WaitTime = (int)TokenNumber;

  000b9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000bf	e8 00 00 00 00	 call	 __ftol2_sse
  000c4	a3 00 00 00 00	 mov	 DWORD PTR ?m_i_IT_WaitTime@@3HA, eax ; m_i_IT_WaitTime

; 108  : 
; 109  : 				Token = GetToken();

  000c9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 110  : 				m_i_IT_PlayTime = (int)TokenNumber;

  000ce	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000d4	e8 00 00 00 00	 call	 __ftol2_sse
  000d9	a3 00 00 00 00	 mov	 DWORD PTR ?m_i_IT_PlayTime@@3HA, eax ; m_i_IT_PlayTime

; 111  : 
; 112  : 				Token = GetToken();

  000de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 113  : 				m_i_IT_RestTime = (int)TokenNumber;

  000e3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000e9	e8 00 00 00 00	 call	 __ftol2_sse
  000ee	a3 00 00 00 00	 mov	 DWORD PTR ?m_i_IT_RestTime@@3HA, eax ; m_i_IT_RestTime
  000f3	e9 68 ff ff ff	 jmp	 $LL7@Load
$LN5@Load:

; 114  : 			}
; 115  : 			else if ( type == 1 )

  000f8	83 ff 01	 cmp	 edi, 1
  000fb	0f 85 5f ff ff
	ff		 jne	 $LL7@Load

; 116  : 			{
; 117  : 				Token = GetToken();

  00101	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 118  : 
; 119  : 				if ( strcmp("end", TokenString) == 0 )

  00106	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0010b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL62@Load:
  00110	8a 10		 mov	 dl, BYTE PTR [eax]
  00112	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00114	75 1a		 jne	 SHORT $LN63@Load
  00116	84 d2		 test	 dl, dl
  00118	74 12		 je	 SHORT $LN67@Load
  0011a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0011d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00120	75 0e		 jne	 SHORT $LN63@Load
  00122	83 c0 02	 add	 eax, 2
  00125	83 c1 02	 add	 ecx, 2
  00128	84 d2		 test	 dl, dl
  0012a	75 e4		 jne	 SHORT $LL62@Load
$LN67@Load:
  0012c	33 c0		 xor	 eax, eax
  0012e	eb 05		 jmp	 SHORT $LN65@Load
$LN63@Load:
  00130	1b c0		 sbb	 eax, eax
  00132	83 d8 ff	 sbb	 eax, -1
$LN65@Load:
  00135	85 c0		 test	 eax, eax
  00137	74 5d		 je	 SHORT $LN54@Load

; 120  : 				{
; 121  : 					break;
; 122  : 				}
; 123  : 
; 124  : 				ILLUSIONTEMPLE_START_TIME Schedule;
; 125  : 
; 126  : 				Schedule.m_iHour = (int)TokenNumber;

  00139	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0013f	e8 00 00 00 00	 call	 __ftol2_sse
  00144	89 45 f8	 mov	 DWORD PTR _Schedule$217535[ebp], eax

; 127  : 
; 128  : 				Token = GetToken();

  00147	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 129  : 				Schedule.m_iMinute = (int)TokenNumber;

  0014c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00152	e8 00 00 00 00	 call	 __ftol2_sse

; 130  : 
; 131  : 				m_listIllusionTempleOpenTime.push_back(Schedule);

  00157	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?m_listIllusionTempleOpenTime@@3V?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@A
  0015d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00160	89 45 fc	 mov	 DWORD PTR _Schedule$217535[ebp+4], eax
  00163	8d 45 f8	 lea	 eax, DWORD PTR _Schedule$217535[ebp]
  00166	50		 push	 eax
  00167	51		 push	 ecx
  00168	56		 push	 esi
  00169	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_listIllusionTempleOpenTime@@3V?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@A ; m_listIllusionTempleOpenTime
  0016e	e8 00 00 00 00	 call	 ?_Buynode@?$_List_val@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@QAEPAU_Node@?$_List_nod@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@2@PAU342@0ABUILLUSIONTEMPLE_START_TIME@@@Z ; std::_List_val<ILLUSIONTEMPLE_START_TIME,std::allocator<ILLUSIONTEMPLE_START_TIME> >::_Buynode
  00173	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00178	2b 15 04 00 00
	00		 sub	 edx, DWORD PTR ?m_listIllusionTempleOpenTime@@3V?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@A+4
  0017e	83 fa 01	 cmp	 edx, 1
  00181	72 4a		 jb	 SHORT $LN56@Load
  00183	ff 05 04 00 00
	00		 inc	 DWORD PTR ?m_listIllusionTempleOpenTime@@3V?$list@UILLUSIONTEMPLE_START_TIME@@V?$allocator@UILLUSIONTEMPLE_START_TIME@@@std@@@std@@A+4
  00189	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0018c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018f	89 01		 mov	 DWORD PTR [ecx], eax

; 132  : 			}
; 133  : 		}

  00191	e9 ca fe ff ff	 jmp	 $LL7@Load
$LN54@Load:

; 77   : 	}
; 78   : 
; 79   : 	int Token;
; 80   : 	int type;
; 81   : 
; 82   : 	while ( true )
; 83   : 	{
; 84   : 		Token = GetToken();

  00196	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 85   : 
; 86   : 		if ( Token == 2 )

  0019b	83 f8 02	 cmp	 eax, 2
  0019e	0f 85 ac fe ff
	ff		 jne	 $LL10@Load
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
$LN57@Load:

; 134  : 	}
; 135  : 
; 136  : 	fclose(SMDFile);

  001a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  001ac	52		 push	 edx
  001ad	e8 00 00 00 00	 call	 _fclose

; 137  : 	LogAdd("%s file load!", lpszFileName);

  001b2	53		 push	 ebx
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 
; 139  : 	return true;

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	5b		 pop	 ebx

; 140  : }

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 04 00	 ret	 4
$LN56@Load:

; 130  : 
; 131  : 				m_listIllusionTempleOpenTime.push_back(Schedule);

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  001d2	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN69@Load:
$LN68@Load:
  001d7	cc		 int	 3
?Load@CIllusionTempleEvent@@QAEHPAD@Z ENDP		; CIllusionTempleEvent::Load
_TEXT	ENDS
PUBLIC	??_C@_0CC@IKPGJAPL@IllusionTempleRewardPercentMaste@ ; `string'
PUBLIC	??_C@_0BN@GNGJMFMO@IllusionTempleMinUseSkillCnt?$AA@ ; `string'
PUBLIC	??_C@_0BM@HACPEIAK@IllusionTempleRewardPercent?$AA@ ; `string'
PUBLIC	??_C@_0BP@LBMGIHHN@SaveIllusionTempleRankingPoint?$AA@ ; `string'
PUBLIC	??_C@_0BK@OMFNOLEF@UseMaxLevelIllusionTemple?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHECNIBM@CovenantOfIllusionDropRate?$AA@ ; `string'
PUBLIC	??_C@_0BC@DAFEECGD@OldScrollDropRate?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BE@IJNGJKML@IllusionTempleEvent?$AA@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@	; `string'
PUBLIC	??_C@_0BM@MDHKOHID@?4?2Events?2IllusionTemple?4dat?$AA@ ; `string'
PUBLIC	?ReadCommonServerInfo@CIllusionTempleEvent@@QAEHXZ ; CIllusionTempleEvent::ReadCommonServerInfo
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0CC@IKPGJAPL@IllusionTempleRewardPercentMaste@
CONST	SEGMENT
??_C@_0CC@IKPGJAPL@IllusionTempleRewardPercentMaste@ DB 'IllusionTempleRe'
	DB	'wardPercentMaster', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GNGJMFMO@IllusionTempleMinUseSkillCnt?$AA@
CONST	SEGMENT
??_C@_0BN@GNGJMFMO@IllusionTempleMinUseSkillCnt?$AA@ DB 'IllusionTempleMi'
	DB	'nUseSkillCnt', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HACPEIAK@IllusionTempleRewardPercent?$AA@
CONST	SEGMENT
??_C@_0BM@HACPEIAK@IllusionTempleRewardPercent?$AA@ DB 'IllusionTempleRew'
	DB	'ardPercent', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LBMGIHHN@SaveIllusionTempleRankingPoint?$AA@
CONST	SEGMENT
??_C@_0BP@LBMGIHHN@SaveIllusionTempleRankingPoint?$AA@ DB 'SaveIllusionTe'
	DB	'mpleRankingPoint', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OMFNOLEF@UseMaxLevelIllusionTemple?$AA@
CONST	SEGMENT
??_C@_0BK@OMFNOLEF@UseMaxLevelIllusionTemple?$AA@ DB 'UseMaxLevelIllusion'
	DB	'Temple', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHECNIBM@CovenantOfIllusionDropRate?$AA@
CONST	SEGMENT
??_C@_0BL@LHECNIBM@CovenantOfIllusionDropRate?$AA@ DB 'CovenantOfIllusion'
	DB	'DropRate', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAFEECGD@OldScrollDropRate?$AA@
CONST	SEGMENT
??_C@_0BC@DAFEECGD@OldScrollDropRate?$AA@ DB 'OldScrollDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IJNGJKML@IllusionTempleEvent?$AA@
CONST	SEGMENT
??_C@_0BE@IJNGJKML@IllusionTempleEvent?$AA@ DB 'IllusionTempleEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@ DB 'commonserver.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MDHKOHID@?4?2Events?2IllusionTemple?4dat?$AA@
CONST	SEGMENT
??_C@_0BM@MDHKOHID@?4?2Events?2IllusionTemple?4dat?$AA@ DB '.\Events\Illu'
	DB	'sionTemple.dat', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReadCommonServerInfo@CIllusionTempleEvent@@QAEHXZ
_TEXT	SEGMENT
?ReadCommonServerInfo@CIllusionTempleEvent@@QAEHXZ PROC	; CIllusionTempleEvent::ReadCommonServerInfo, COMDAT
; _this$ = ecx

; 56   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 57   : 	this->Load(gDirPath.GetNewPath(".\\Events\\IllusionTemple.dat"));

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MDHKOHID@?4?2Events?2IllusionTemple?4dat?$AA@
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0000d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00012	50		 push	 eax
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?Load@CIllusionTempleEvent@@QAEHPAD@Z ; CIllusionTempleEvent::Load

; 58   : 	g_iIllusionTempleEvent = GetPrivateProfileInt("GameServerInfo","IllusionTempleEvent",0, gDirPath.GetNewPath("commonserver.cfg"));

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00024	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00029	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  0002f	50		 push	 eax
  00030	6a 00		 push	 0
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IJNGJKML@IllusionTempleEvent?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0003c	ff d6		 call	 esi

; 59   : 	g_iOldScrollDropRate = GetPrivateProfileInt("GameServerInfo","OldScrollDropRate",0, gDirPath.GetNewPath("commonserver.cfg"));

  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00048	a3 00 00 00 00	 mov	 DWORD PTR ?g_iIllusionTempleEvent@@3HA, eax ; g_iIllusionTempleEvent
  0004d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DAFEECGD@OldScrollDropRate?$AA@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0005f	ff d6		 call	 esi

; 60   : 	g_iCovenantOfIllusionDropRate = GetPrivateProfileInt("GameServerInfo","CovenantOfIllusionDropRate",0, gDirPath.GetNewPath("commonserver.cfg"));

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00066	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?g_iOldScrollDropRate@@3HA, eax ; g_iOldScrollDropRate
  00070	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00075	50		 push	 eax
  00076	6a 00		 push	 0
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LHECNIBM@CovenantOfIllusionDropRate?$AA@
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00082	ff d6		 call	 esi

; 61   : 	g_iUseMaxLevelIllusionTemple = GetPrivateProfileInt("GameServerInfo","UseMaxLevelIllusionTemple",0, gDirPath.GetNewPath("commonserver.cfg"));

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0008e	a3 00 00 00 00	 mov	 DWORD PTR ?g_iCovenantOfIllusionDropRate@@3HA, eax ; g_iCovenantOfIllusionDropRate
  00093	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00098	50		 push	 eax
  00099	6a 00		 push	 0
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OMFNOLEF@UseMaxLevelIllusionTemple?$AA@
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000a5	ff d6		 call	 esi

; 62   : 	g_iSaveIllusionTempleRankingPoint = GetPrivateProfileInt("GameServerInfo","SaveIllusionTempleRankingPoint",0, gDirPath.GetNewPath("commonserver.cfg"));

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  000ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000b1	a3 00 00 00 00	 mov	 DWORD PTR ?g_iUseMaxLevelIllusionTemple@@3HA, eax ; g_iUseMaxLevelIllusionTemple
  000b6	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000bb	50		 push	 eax
  000bc	6a 00		 push	 0
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LBMGIHHN@SaveIllusionTempleRankingPoint?$AA@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000c8	ff d6		 call	 esi

; 63   : 	g_iIllusionTempleRewardPercent = GetPrivateProfileInt("GameServerInfo","IllusionTempleRewardPercent",0, gDirPath.GetNewPath("commonserver.cfg"));

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000d4	a3 00 00 00 00	 mov	 DWORD PTR ?g_iSaveIllusionTempleRankingPoint@@3HA, eax ; g_iSaveIllusionTempleRankingPoint
  000d9	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000de	50		 push	 eax
  000df	6a 00		 push	 0
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HACPEIAK@IllusionTempleRewardPercent?$AA@
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000eb	ff d6		 call	 esi

; 64   : 	g_iIllusionTempleMinUseSkillCnt = GetPrivateProfileInt("GameServerInfo","IllusionTempleMinUseSkillCnt",0, gDirPath.GetNewPath("commonserver.cfg"));

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000f7	a3 00 00 00 00	 mov	 DWORD PTR ?g_iIllusionTempleRewardPercent@@3HA, eax ; g_iIllusionTempleRewardPercent
  000fc	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00101	50		 push	 eax
  00102	6a 00		 push	 0
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GNGJMFMO@IllusionTempleMinUseSkillCnt?$AA@
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0010e	ff d6		 call	 esi

; 65   : 	g_iIllusionTempleRewardPercentMaster = GetPrivateProfileInt("GameServerInfo","IllusionTempleRewardPercentMaster",0, gDirPath.GetNewPath("commonserver.cfg")); //season4 add-on

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0011a	a3 00 00 00 00	 mov	 DWORD PTR ?g_iIllusionTempleMinUseSkillCnt@@3HA, eax ; g_iIllusionTempleMinUseSkillCnt
  0011f	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00124	50		 push	 eax
  00125	6a 00		 push	 0
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IKPGJAPL@IllusionTempleRewardPercentMaste@
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00131	ff d6		 call	 esi
  00133	a3 00 00 00 00	 mov	 DWORD PTR ?g_iIllusionTempleRewardPercentMaster@@3HA, eax ; g_iIllusionTempleRewardPercentMaster

; 66   : 	return TRUE;

  00138	b8 01 00 00 00	 mov	 eax, 1
  0013d	5e		 pop	 esi

; 67   : }

  0013e	c3		 ret	 0
?ReadCommonServerInfo@CIllusionTempleEvent@@QAEHXZ ENDP	; CIllusionTempleEvent::ReadCommonServerInfo
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_IllusionTempleEvent@@YAXXZ
text$yc	SEGMENT
??__Eg_IllusionTempleEvent@@YAXXZ PROC			; `dynamic initializer for 'g_IllusionTempleEvent'', COMDAT

; 34   : CIllusionTempleEvent g_IllusionTempleEvent;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00005	e8 00 00 00 00	 call	 ??0CIllusionTempleEvent@@QAE@XZ ; CIllusionTempleEvent::CIllusionTempleEvent
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_IllusionTempleEvent@@YAXXZ ; `dynamic atexit destructor for 'g_IllusionTempleEvent''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_IllusionTempleEvent@@YAXXZ ENDP			; `dynamic initializer for 'g_IllusionTempleEvent''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_IllusionTempleEvent@@YAXXZ
text$yd	SEGMENT
??__Fg_IllusionTempleEvent@@YAXXZ PROC			; `dynamic atexit destructor for 'g_IllusionTempleEvent'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00005	e9 00 00 00 00	 jmp	 ??1CIllusionTempleEvent@@UAE@XZ ; CIllusionTempleEvent::~CIllusionTempleEvent
??__Fg_IllusionTempleEvent@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_IllusionTempleEvent''
text$yd	ENDS
PUBLIC	?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
_BSS	SEGMENT
?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A DB 017b0H DUP (?) ; g_IllusionTempleEvent
_BSS	ENDS
CRT$XCU	SEGMENT
_g_IllusionTempleEvent$initializer$ DD FLAT:??__Eg_IllusionTempleEvent@@YAXXZ
CRT$XCU	ENDS
END
