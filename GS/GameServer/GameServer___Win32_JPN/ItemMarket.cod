; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\ItemMarket.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?set@PWMSG_HEAD2@@QAEXPAEEEH@Z			; PWMSG_HEAD2::set
; Function compile flags: /Ogtp
;	COMDAT ?set@PWMSG_HEAD2@@QAEXPAEEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 4
?set@PWMSG_HEAD2@@QAEXPAEEEH@Z PROC			; PWMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 149  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 150  : 		lpBuf[0] = 0xC2;
; 151  : 		lpBuf[1] = SET_NUMBERH(size);

  00003	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]
  00009	8b d1		 mov	 edx, ecx
  0000b	c1 ea 08	 shr	 edx, 8
  0000e	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 152  : 		lpBuf[2] = SET_NUMBERL(size);
; 153  : 		lpBuf[3] = head;
; 154  : 		lpBuf[4] = sub;

  00011	8a 55 10	 mov	 dl, BYTE PTR _sub$[ebp]
  00014	88 48 02	 mov	 BYTE PTR [eax+2], cl
  00017	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  0001a	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H
  0001d	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00020	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 155  : 	}

  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
?set@PWMSG_HEAD2@@QAEXPAEEEH@Z ENDP			; PWMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1CItemMarket@@QAE@XZ				; CItemMarket::~CItemMarket
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\itemmarket.cpp
;	COMDAT ??1CItemMarket@@QAE@XZ
_TEXT	SEGMENT
??1CItemMarket@@QAE@XZ PROC				; CItemMarket::~CItemMarket, COMDAT
; _this$ = ecx

; 23   : }

  00000	c3		 ret	 0
??1CItemMarket@@QAE@XZ ENDP				; CItemMarket::~CItemMarket
_TEXT	ENDS
PUBLIC	?Init@CItemMarket@@QAEXXZ			; CItemMarket::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CItemMarket@@QAEXXZ
_TEXT	SEGMENT
?Init@CItemMarket@@QAEXXZ PROC				; CItemMarket::Init, COMDAT
; _this$ = ecx

; 27   : 
; 28   : }

  00000	c3		 ret	 0
?Init@CItemMarket@@QAEXXZ ENDP				; CItemMarket::Init
_TEXT	ENDS
PUBLIC	?Load@CItemMarket@@QAEXXZ			; CItemMarket::Load
; Function compile flags: /Ogtp
;	COMDAT ?Load@CItemMarket@@QAEXXZ
_TEXT	SEGMENT
?Load@CItemMarket@@QAEXXZ PROC				; CItemMarket::Load, COMDAT
; _this$ = ecx

; 32   : 
; 33   : }

  00000	c3		 ret	 0
?Load@CItemMarket@@QAEXXZ ENDP				; CItemMarket::Load
_TEXT	ENDS
PUBLIC	?Protocol@CItemMarket@@QAEXEPAE@Z		; CItemMarket::Protocol
; Function compile flags: /Ogtp
;	COMDAT ?Protocol@CItemMarket@@QAEXEPAE@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
?Protocol@CItemMarket@@QAEXEPAE@Z PROC			; CItemMarket::Protocol, COMDAT
; _this$ = ecx

; 37   : 
; 38   : }

  00000	c2 08 00	 ret	 8
?Protocol@CItemMarket@@QAEXEPAE@Z ENDP			; CItemMarket::Protocol
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqItemList@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_ITEM@@H@Z ; CItemMarket::CGReqItemList
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CGReqItemList@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_ITEM@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqItemList@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_ITEM@@H@Z PROC ; CItemMarket::CGReqItemList, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 42   : 	SDHP_REQ_MARKET_ITEM pMsg;
; 43   : 
; 44   : 	pMsg.h.set((LPBYTE)&pMsg, 0xEC, 0x00, sizeof(pMsg));
; 45   : 
; 46   : 	pMsg.Result = 1;
; 47   : 
; 48   : 	pMsg.aIndex = aIndex;
; 49   : 
; 50   : 	pMsg.PriceType = lpMsg->PriceType;

  00013	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00019	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 51   : 
; 52   : 	#if(MARKET_FILTER_DEV)
; 53   : 
; 54   : 	pMsg.Filter.FilterType = lpMsg->Filter.FilterType;

  0001c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001f	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+12], edx

; 55   : 
; 56   : 	pMsg.Filter.FilterLevel = lpMsg->Filter.FilterLevel;

  00022	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00025	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 57   : 
; 58   : 	pMsg.Filter.FilterLuck = lpMsg->Filter.FilterLuck;

  00028	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002b	89 55 e8	 mov	 DWORD PTR _pMsg$[ebp+20], edx

; 59   : 
; 60   : 	pMsg.Filter.FilterExl = lpMsg->Filter.FilterExl;

  0002e	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00031	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+24], ecx

; 61   : 
; 62   : 	pMsg.Filter.FilterAnc = lpMsg->Filter.FilterAnc;

  00034	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00037	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+28], edx

; 63   : 
; 64   : 	#endif
; 65   : 
; 66   : 	#if(MARKET_PAGE_DEV)
; 67   : 
; 68   : 	pMsg.PageNumber = lpMsg->PageNumber;

  0003a	8b 50 20	 mov	 edx, DWORD PTR [eax+32]

; 69   : 
; 70   : 	#endif
; 71   : 
; 72   : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0003d	6a 28		 push	 40			; 00000028H
  0003f	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00042	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+32], ecx
  00045	50		 push	 eax
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004b	c7 45 d4 c1 28
	ec 00		 mov	 DWORD PTR _pMsg$[ebp], 15476929 ; 00ec28c1H
  00052	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+4], 1
  00059	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+36], edx
  0005c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 73   : 
; 74   : 	//LogAddC(2, "[DATA <- SERVER] : CGReqItemList");
; 75   : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
?CGReqItemList@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_ITEM@@H@Z ENDP ; CItemMarket::CGReqItemList
_TEXT	ENDS
PUBLIC	?GDReqItemList@CItemMarket@@QAEXHH@Z		; CItemMarket::GDReqItemList
; Function compile flags: /Ogtp
;	COMDAT ?GDReqItemList@CItemMarket@@QAEXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_NumPage$ = 12						; size = 4
?GDReqItemList@CItemMarket@@QAEXHH@Z PROC		; CItemMarket::GDReqItemList, COMDAT
; _this$ = ecx

; 79   : 
; 80   : }

  00000	c2 08 00	 ret	 8
?GDReqItemList@CItemMarket@@QAEXHH@Z ENDP		; CItemMarket::GDReqItemList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqItemSell@CItemMarket@@QAEXHHHH@Z		; CItemMarket::GDReqItemSell
EXTRN	?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z:PROC	; ItemByteConvert16
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?GDReqItemSell@CItemMarket@@QAEXHHHH@Z
_TEXT	SEGMENT
_btNewOption$ = -90					; size = 1
_btSetOption$ = -89					; size = 1
_pMsg$ = -88						; size = 84
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_ItemPos$ = 12						; size = 4
_ItemPriceType$ = 16					; size = 4
_ItemPrice$ = 20					; size = 4
?GDReqItemSell@CItemMarket@@QAEXHHHH@Z PROC		; CItemMarket::GDReqItemSell, COMDAT
; _this$ = ecx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _ItemPos$[ebp]

; 141  : 	if(!OBJMAX_RANGE(aIndex))

  00017	85 c0		 test	 eax, eax
  00019	0f 88 16 01 00
	00		 js	 $LN5@GDReqItemS
  0001f	33 c9		 xor	 ecx, ecx
  00021	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	0f 84 04 01 00
	00		 je	 $LN5@GDReqItemS

; 142  : 	{
; 143  : 		return;
; 144  : 	}
; 145  : 
; 146  : 	LPOBJ lpUser = &gObj[aIndex];
; 147  : 
; 148  : 	SDHP_REQ_MARKET_SELL pMsg;
; 149  : 
; 150  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEC, 0x01, sizeof(pMsg));
; 151  : 
; 152  : 	pMsg.Result = 1;
; 153  : 
; 154  : 	pMsg.aIndex = aIndex;
; 155  : 
; 156  : 	pMsg.PriceType = ItemPriceType;
; 157  : 
; 158  : 	pMsg.Price = ItemPrice;

  00031	8b 4d 14	 mov	 ecx, DWORD PTR _ItemPrice$[ebp]
  00034	56		 push	 esi
  00035	8b f0		 mov	 esi, eax
  00037	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0003d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	89 45 b0	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00046	8b 45 10	 mov	 eax, DWORD PTR _ItemPriceType$[ebp]
  00049	89 45 cc	 mov	 DWORD PTR _pMsg$[ebp+36], eax
  0004c	c7 45 a8 c1 54
	ec 01		 mov	 DWORD PTR _pMsg$[ebp], 32265409 ; 01ec54c1H
  00053	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+4], 1
  0005a	89 4d d0	 mov	 DWORD PTR _pMsg$[ebp+40], ecx

; 159  : 	
; 160  : 	//pMsg.Account[10] = 0;
; 161  : 
; 162  : 	memcpy(pMsg.Account, lpUser->AccountID, sizeof(pMsg.Account)-1);

  0005d	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00060	89 55 b4	 mov	 DWORD PTR _pMsg$[ebp+12], edx
  00063	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00066	89 45 b8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00069	0f b7 4e 74	 movzx	 ecx, WORD PTR [esi+116]
  0006d	66 89 4d bc	 mov	 WORD PTR _pMsg$[ebp+20], cx

; 163  : 
; 164  : 	#if(MARKET_NAME_DEV)
; 165  : 
; 166  : 	//pMsg.Name[10] = 0;
; 167  : 
; 168  : 	memcpy(pMsg.Name, lpUser->Name, sizeof(pMsg.Name)-1);

  00071	8b 56 77	 mov	 edx, DWORD PTR [esi+119]
  00074	89 55 bf	 mov	 DWORD PTR _pMsg$[ebp+23], edx
  00077	8b 46 7b	 mov	 eax, DWORD PTR [esi+123]
  0007a	89 45 c3	 mov	 DWORD PTR _pMsg$[ebp+27], eax
  0007d	0f b7 4e 7f	 movzx	 ecx, WORD PTR [esi+127]

; 169  : 
; 170  : 	#endif
; 171  : 
; 172  : 	pMsg.ItemPos = ItemPos;

  00081	89 7d d4	 mov	 DWORD PTR _pMsg$[ebp+44], edi

; 173  : 
; 174  : 	ItemByteConvert16((LPBYTE)pMsg.ItemData, &lpUser->pInventory[ItemPos], 1);

  00084	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  0008a	66 89 4d c7	 mov	 WORD PTR _pMsg$[ebp+31], cx
  0008e	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  00094	6a 01		 push	 1
  00096	03 d7		 add	 edx, edi
  00098	52		 push	 edx
  00099	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp+48]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16

; 175  : 
; 176  : 	#if(MARKET_FILTER_DEV)
; 177  : 
; 178  : 	BYTE btLuck = lpUser->pInventory[ItemPos].m_Option2;

  000a2	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]

; 179  : 	
; 180  : 	BYTE btOption = lpUser->pInventory[ItemPos].m_Option3;
; 181  : 	
; 182  : 	BYTE btNewOption = lpUser->pInventory[ItemPos].m_NewOption;

  000a8	8a 94 38 97 00
	00 00		 mov	 dl, BYTE PTR [eax+edi+151]
  000af	8a 8c 38 95 00
	00 00		 mov	 cl, BYTE PTR [eax+edi+149]

; 183  : 
; 184  : 	BYTE btSetOption = lpUser->pInventory[ItemPos].m_SetOption;

  000b6	8a 84 38 ae 00
	00 00		 mov	 al, BYTE PTR [eax+edi+174]
  000bd	88 55 a6	 mov	 BYTE PTR _btNewOption$[ebp], dl
  000c0	88 45 a7	 mov	 BYTE PTR _btSetOption$[ebp], al

; 185  : 
; 186  : 	// --
; 187  : 
; 188  : 	pMsg.Filter.FilterLuck = 0;

  000c3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+72], 0

; 189  : 
; 190  : 	pMsg.Filter.FilterExl = 0;

  000ca	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+76], 0

; 191  : 
; 192  : 	pMsg.Filter.FilterAnc = 0;

  000d1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+80], 0

; 193  : 
; 194  : 	pMsg.Filter.FilterType = lpUser->pInventory[ItemPos].m_Type / 512;

  000d8	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  000de	0f bf 44 3a 06	 movsx	 eax, WORD PTR [edx+edi+6]
  000e3	99		 cdq
  000e4	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  000ea	03 c2		 add	 eax, edx
  000ec	c1 f8 09	 sar	 eax, 9
  000ef	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+64], eax

; 195  : 	
; 196  : 	pMsg.Filter.FilterLevel = lpUser->pInventory[ItemPos].m_Level;

  000f2	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  000f8	0f bf 54 38 08	 movsx	 edx, WORD PTR [eax+edi+8]
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+68], edx
  00103	5e		 pop	 esi

; 197  : 
; 198  : 	if(btLuck)
; 199  : 	{
; 200  : 		pMsg.Filter.FilterLuck = 1;

  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	84 c9		 test	 cl, cl
  0010b	74 03		 je	 SHORT $LN3@GDReqItemS
  0010d	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+72], eax
$LN3@GDReqItemS:

; 201  : 	}
; 202  : 
; 203  : 	if(btNewOption)

  00110	80 7d a6 00	 cmp	 BYTE PTR _btNewOption$[ebp], 0
  00114	74 03		 je	 SHORT $LN2@GDReqItemS

; 204  : 	{
; 205  : 		pMsg.Filter.FilterExl = 1;

  00116	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+76], eax
$LN2@GDReqItemS:

; 206  : 	}
; 207  : 
; 208  : 	if(btSetOption)

  00119	80 7d a7 00	 cmp	 BYTE PTR _btSetOption$[ebp], 0
  0011d	74 03		 je	 SHORT $LN1@GDReqItemS

; 209  : 	{
; 210  : 		pMsg.Filter.FilterAnc = 1;

  0011f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+80], eax
$LN1@GDReqItemS:

; 211  : 	}
; 212  : 
; 213  : 	#endif
; 214  : 
; 215  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00122	0f b6 45 a9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00126	50		 push	 eax
  00127	8d 4d a8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0012a	51		 push	 ecx
  0012b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00130	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN5@GDReqItemS:

; 216  : 
; 217  : 	//LogAddC(2, "[SERVER -> CLIENT] [SIZE:%d]: GDReqItemSell", sizeof(pMsg));
; 218  : }

  00135	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00138	33 cd		 xor	 ecx, ebp
  0013a	5f		 pop	 edi
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 10 00	 ret	 16			; 00000010H
?GDReqItemSell@CItemMarket@@QAEXHHHH@Z ENDP		; CItemMarket::GDReqItemSell
_TEXT	ENDS
PUBLIC	??_C@_0BN@HGLLEBP@?$FLItemMarket?$FN?5SELL?5Result?5?3?50?$AA@ ; `string'
PUBLIC	??_C@_0BN@BOHAIFFO@?$FLItemMarket?$FN?5SELL?5Result?5?3?51?$AA@ ; `string'
PUBLIC	?DGAnsItemSell@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_SELL@@@Z ; CItemMarket::DGAnsItemSell
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
;	COMDAT ??_C@_0BN@HGLLEBP@?$FLItemMarket?$FN?5SELL?5Result?5?3?50?$AA@
CONST	SEGMENT
??_C@_0BN@HGLLEBP@?$FLItemMarket?$FN?5SELL?5Result?5?3?50?$AA@ DB '[ItemM'
	DB	'arket] SELL Result : 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BOHAIFFO@?$FLItemMarket?$FN?5SELL?5Result?5?3?51?$AA@
CONST	SEGMENT
??_C@_0BN@BOHAIFFO@?$FLItemMarket?$FN?5SELL?5Result?5?3?51?$AA@ DB '[Item'
	DB	'Market] SELL Result : 1', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DGAnsItemSell@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_SELL@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DGAnsItemSell@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_SELL@@@Z PROC ; CItemMarket::DGAnsItemSell, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 222  : 	int aIndex = lpMsg->aIndex;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 223  : 
; 224  : 	if(lpMsg->Result)

  00008	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0000c	8b 77 08	 mov	 esi, DWORD PTR [edi+8]

; 225  : 	{
; 226  : 		GCServerMsgStringSend("[ItemMarket] SELL Result : 1", aIndex, 0);

  0000f	6a 00		 push	 0
  00011	56		 push	 esi
  00012	74 51		 je	 SHORT $LN2@DGAnsItemS
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BOHAIFFO@?$FLItemMarket?$FN?5SELL?5Result?5?3?51?$AA@
  00019	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 227  : 
; 228  : 		LPOBJ lpUser = &gObj[aIndex];

  0001e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00024	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 229  : 
; 230  : 		int ItemPos = lpMsg->ItemPos;

  0002a	8b 7f 0c	 mov	 edi, DWORD PTR [edi+12]

; 231  : 
; 232  : 		gObjInventoryItemSet(lpUser->m_Index, ItemPos, -1);

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	68 ff 00 00 00	 push	 255			; 000000ffH
  00034	57		 push	 edi
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 233  : 
; 234  : 		lpUser->pInventory[ItemPos].Clear();

  0003b	8b cf		 mov	 ecx, edi
  0003d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00043	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 235  : 
; 236  : 		GCInventoryItemDeleteSend(lpUser->m_Index, ItemPos, 1);

  00051	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00053	6a 01		 push	 1
  00055	57		 push	 edi
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 237  : 	}
; 238  : 	else
; 239  : 	{
; 240  : 		GCServerMsgStringSend("[ItemMarket] SELL Result : 0", aIndex, 0);

  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 241  : 	}
; 242  : }

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
$LN2@DGAnsItemS:

; 237  : 	}
; 238  : 	else
; 239  : 	{
; 240  : 		GCServerMsgStringSend("[ItemMarket] SELL Result : 0", aIndex, 0);

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HGLLEBP@?$FLItemMarket?$FN?5SELL?5Result?5?3?50?$AA@
  0006a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 241  : 	}
; 242  : }

  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
?DGAnsItemSell@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_SELL@@@Z ENDP ; CItemMarket::DGAnsItemSell
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqItemStatus@CItemMarket@@QAEXH@Z		; CItemMarket::GDReqItemStatus
; Function compile flags: /Ogtp
;	COMDAT ?GDReqItemStatus@CItemMarket@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDReqItemStatus@CItemMarket@@QAEXH@Z PROC		; CItemMarket::GDReqItemStatus, COMDAT
; _this$ = ecx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]

; 375  : 	if(!OBJMAX_RANGE(aIndex))

  00013	85 c9		 test	 ecx, ecx
  00015	78 52		 js	 SHORT $LN2@GDReqItemS@2
  00017	33 c0		 xor	 eax, eax
  00019	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0001f	0f 9e c0	 setle	 al
  00022	85 c0		 test	 eax, eax
  00024	74 43		 je	 SHORT $LN2@GDReqItemS@2

; 376  : 	{
; 377  : 		return;
; 378  : 	}
; 379  : 
; 380  : 	LPOBJ lpUser = &gObj[aIndex];

  00026	8b c1		 mov	 eax, ecx
  00028	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 381  : 
; 382  : 	SDHP_REQ_MARKET_STATUS pMsg;
; 383  : 
; 384  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEC, 0x03, sizeof(pMsg));
; 385  : 
; 386  : 	pMsg.Result = 1;
; 387  : 
; 388  : 	pMsg.aIndex = aIndex;

  00034	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00037	c7 45 e4 c1 18
	ec 03		 mov	 DWORD PTR _pMsg$[ebp], 65804481 ; 03ec18c1H
  0003e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+4], 1

; 389  : 
; 390  : 	memcpy(pMsg.Account, lpUser->AccountID, sizeof(pMsg.Account)-1);

  00045	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00048	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+12], ecx
  0004b	8b 50 70	 mov	 edx, DWORD PTR [eax+112]

; 391  : 
; 392  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0004e	6a 18		 push	 24			; 00000018H
  00050	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00053	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+16], edx
  00056	66 8b 40 74	 mov	 ax, WORD PTR [eax+116]
  0005a	51		 push	 ecx
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00060	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+20], ax
  00064	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN2@GDReqItemS@2:

; 393  : 
; 394  : 	//LogAddC(2, "[SERVER -> DATA] [SIZE:%d]: GDReqItemBuy", sizeof(pMsg));
; 395  : }

  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
?GDReqItemStatus@CItemMarket@@QAEXH@Z ENDP		; CItemMarket::GDReqItemStatus
_TEXT	ENDS
PUBLIC	??_C@_0BN@JBMIIEHG@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@ ; `string'
PUBLIC	??_C@_0BM@BGGDEPCE@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@ ; `string'
PUBLIC	??_C@_0BK@FLAKKHPF@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@ ; `string'
PUBLIC	?DGAnsItemStatus@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_STATUS@@@Z ; CItemMarket::DGAnsItemStatus
EXTRN	?ZtUserDataSend@@YAXH@Z:PROC			; ZtUserDataSend
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0BN@JBMIIEHG@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@
CONST	SEGMENT
??_C@_0BN@JBMIIEHG@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@ DB '['
	DB	'MARKET][SELL] %s +%d Credit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BGGDEPCE@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@
CONST	SEGMENT
??_C@_0BM@BGGDEPCE@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@ DB '['
	DB	'MARKET][SELL] %s +%d Wcoin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FLAKKHPF@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@
CONST	SEGMENT
??_C@_0BK@FLAKKHPF@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@ DB '['
	DB	'MARKET][SELL] %s +%d Zen', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DGAnsItemStatus@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_STATUS@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DGAnsItemStatus@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_STATUS@@@Z PROC ; CItemMarket::DGAnsItemStatus, COMDAT
; _this$ = ecx

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 399  : 	int aIndex = lpMsg->aIndex;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00008	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]

; 400  : 
; 401  : 	if(!OBJMAX_RANGE(aIndex))

  0000b	85 db		 test	 ebx, ebx
  0000d	0f 88 ca 00 00
	00		 js	 $LN1@DGAnsItemS@2
  00013	33 c0		 xor	 eax, eax
  00015	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 b7 00 00
	00		 je	 $LN1@DGAnsItemS@2

; 402  : 	{
; 403  : 		return;
; 404  : 	}
; 405  : 
; 406  : 	if(!lpMsg->Result)

  00026	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0002a	0f 84 ad 00 00
	00		 je	 $LN1@DGAnsItemS@2

; 407  : 	{
; 408  : 		return;
; 409  : 	}
; 410  : 
; 411  : 	LPOBJ lpUser = &gObj[aIndex];

  00030	56		 push	 esi
  00031	8b f3		 mov	 esi, ebx
  00033	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00039	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 412  : 
; 413  : 	if(lpMsg->PriceType == eMarketPriceTypeZen)

  0003f	83 7f 18 00	 cmp	 DWORD PTR [edi+24], 0
  00043	75 2c		 jne	 SHORT $LN3@DGAnsItemS@2

; 414  : 	{
; 415  : 		lpUser->Money += lpMsg->PriceValue;

  00045	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00048	01 86 f0 00 00
	00		 add	 DWORD PTR [esi+240], eax
  0004e	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]

; 416  : 
; 417  : 		GCMoneySend(aIndex, lpUser->Money);

  00054	50		 push	 eax
  00055	53		 push	 ebx
  00056	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 418  : 
; 419  : 		MsgOutput(aIndex, "[MARKET][SELL] %s +%d Zen", lpMsg->Account, lpMsg->PriceValue);

  0005b	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0005e	51		 push	 ecx
  0005f	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  00062	52		 push	 edx
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FLAKKHPF@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@
  00068	53		 push	 ebx
  00069	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@DGAnsItemS@2:

; 420  : 	}
; 421  : 
; 422  : 	if(lpMsg->PriceType == eMarketPriceTypeWcoin)

  00071	83 7f 18 01	 cmp	 DWORD PTR [edi+24], 1
  00075	75 32		 jne	 SHORT $LN2@DGAnsItemS@2

; 423  : 	{
; 424  : 		lpUser->GameShop.WCoinC += lpMsg->PriceValue;

  00077	db 47 1c	 fild	 DWORD PTR [edi+28]

; 425  : 
; 426  : 		gGameShop.GDSaveUserInfo(lpUser->m_Index);

  0007a	8b 06		 mov	 eax, DWORD PTR [esi]
  0007c	50		 push	 eax
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00082	dc 86 00 23 00
	00		 fadd	 QWORD PTR [esi+8960]
  00088	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
  0008e	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 427  : 
; 428  : 		MsgOutput(aIndex, "[MARKET][SELL] %s +%d Wcoin", lpMsg->Account, lpMsg->PriceValue);

  00093	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00096	51		 push	 ecx
  00097	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  0009a	52		 push	 edx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BGGDEPCE@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@
  000a0	53		 push	 ebx
  000a1	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000a6	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@DGAnsItemS@2:

; 429  : 	}
; 430  : 
; 431  : 	if(lpMsg->PriceType == eMarketPriceTypeCredit)

  000a9	83 7f 18 02	 cmp	 DWORD PTR [edi+24], 2
  000ad	75 2d		 jne	 SHORT $LN10@DGAnsItemS@2

; 432  : 	{
; 433  : 		lpUser->ZtCred += lpMsg->PriceValue;

  000af	db 47 1c	 fild	 DWORD PTR [edi+28]

; 434  : 
; 435  : 		ZtUserDataSend(lpUser->m_Index);

  000b2	8b 06		 mov	 eax, DWORD PTR [esi]
  000b4	50		 push	 eax
  000b5	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  000bb	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
  000c1	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend

; 436  : 
; 437  : 		MsgOutput(aIndex, "[MARKET][SELL] %s +%d Credit", lpMsg->Account, lpMsg->PriceValue);

  000c6	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000c9	51		 push	 ecx
  000ca	83 c7 0c	 add	 edi, 12			; 0000000cH
  000cd	57		 push	 edi
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JBMIIEHG@?$FLMARKET?$FN?$FLSELL?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@
  000d3	53		 push	 ebx
  000d4	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000d9	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@DGAnsItemS@2:
  000dc	5e		 pop	 esi
$LN1@DGAnsItemS@2:
  000dd	5f		 pop	 edi
  000de	5b		 pop	 ebx

; 438  : 	}
; 439  : }

  000df	5d		 pop	 ebp
  000e0	c2 04 00	 ret	 4
?DGAnsItemStatus@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_STATUS@@@Z ENDP ; CItemMarket::DGAnsItemStatus
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z	; CItemMarket::GetByteToItem
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z:PROC	; CItem::Convert
EXTRN	?CheckItemType@CSocketOption@@QAEEH@Z:PROC	; CSocketOption::CheckItemType
EXTRN	?g_SocketOption@@3VCSocketOption@@A:BYTE	; g_SocketOption
EXTRN	?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z:PROC ; CItemSystemFor380::Is380Item
EXTRN	?g_kItemSystemFor380@@3VCItemSystemFor380@@A:BYTE ; g_kItemSystemFor380
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
; Function compile flags: /Ogtp
;	COMDAT ?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z
_TEXT	SEGMENT
tv815 = -16						; size = 4
_SocketOptionIndex$ = -16				; size = 1
_SocketOption$ = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_lpByte$ = 12						; size = 4
?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z PROC	; CItemMarket::GetByteToItem, COMDAT
; _this$ = ecx

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _lpByte$[ebp]

; 445  : 	CItem item;

  00019	8b ce		 mov	 ecx, esi
  0001b	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 446  : 
; 447  : 	item.Clear();

  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 448  : 
; 449  : 	int n = 0;
; 450  : 
; 451  : 	int ItemDbByte = 16;
; 452  : 	
; 453  : 	int itype = lpByte[n*ItemDbByte];
; 454  : 
; 455  : 	/*
; 456  : 	if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF
; 457  : 		&& (lpMsg->dbInventory[n*ItemDbByte+7] & 0x80) == 0x80
; 458  : 		&& (lpMsg->dbInventory[n*ItemDbByte+9] & 0xF0) == 0xF0)
; 459  : 	{
; 460  : 		continue;
; 461  : 	}
; 462  : 	*/
; 463  : 
; 464  : 	itype |= (lpByte[n*ItemDbByte+9] & 0xF0) * 32;
; 465  : 
; 466  : 	itype |= (lpByte[n*ItemDbByte+7] & 0x80) * 2;

  00027	0f b6 5f 09	 movzx	 ebx, BYTE PTR [edi+9]
  0002b	0f b6 47 07	 movzx	 eax, BYTE PTR [edi+7]

; 467  : 
; 468  : 	int _type = itype;
; 469  : 
; 470  : 	item.m_Level = DBI_GET_LEVEL(lpByte[n*ItemDbByte+1]);

  0002f	8a 57 01	 mov	 dl, BYTE PTR [edi+1]
  00032	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00035	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0003a	03 c0		 add	 eax, eax
  0003c	c0 ea 03	 shr	 dl, 3
  0003f	81 e3 f0 00 00
	00		 and	 ebx, 240		; 000000f0H
  00045	80 e2 0f	 and	 dl, 15			; 0000000fH
  00048	c1 e3 05	 shl	 ebx, 5
  0004b	0b d8		 or	 ebx, eax
  0004d	0f b6 c2	 movzx	 eax, dl
  00050	66 89 46 08	 mov	 WORD PTR [esi+8], ax

; 471  : 
; 472  : 	BYTE OptionData = lpByte[n*ItemDbByte+1];

  00054	8a 47 01	 mov	 al, BYTE PTR [edi+1]

; 473  : 
; 474  : 	item.m_Option1 = ( ((OptionData) >> 7) & 0x01);
; 475  : 
; 476  : 	item.m_Option2 = DBI_GET_LUCK(OptionData);

  00057	8a d0		 mov	 dl, al
  00059	0b d9		 or	 ebx, ecx
  0005b	8a c8		 mov	 cl, al

; 477  : 
; 478  : 	item.m_Option3 = DBI_GET_OPTION(OptionData);

  0005d	24 03		 and	 al, 3
  0005f	c0 e9 07	 shr	 cl, 7
  00062	88 8e 94 00 00
	00		 mov	 BYTE PTR [esi+148], cl
  00068	c0 ea 02	 shr	 dl, 2
  0006b	88 86 96 00 00
	00		 mov	 BYTE PTR [esi+150], al
  00071	80 e2 01	 and	 dl, 1
  00074	88 96 95 00 00
	00		 mov	 BYTE PTR [esi+149], dl

; 479  : 
; 480  : 	item.m_Option3 |= DBI_GET_OPTION16(lpByte[n*ItemDbByte+7]) >> 4;

  0007a	8a 4f 07	 mov	 cl, BYTE PTR [edi+7]
  0007d	c0 e9 04	 shr	 cl, 4
  00080	80 e1 04	 and	 cl, 4
  00083	0a c8		 or	 cl, al
  00085	88 8e 96 00 00
	00		 mov	 BYTE PTR [esi+150], cl

; 481  : 
; 482  : 	item.m_Durability = lpByte[n*ItemDbByte+2];

  0008b	0f b6 57 02	 movzx	 edx, BYTE PTR [edi+2]
  0008f	89 55 f0	 mov	 DWORD PTR tv815[ebp], edx
  00092	db 45 f0	 fild	 DWORD PTR tv815[ebp]
  00095	d9 5e 24	 fstp	 DWORD PTR [esi+36]

; 483  : 
; 484  : 	item.m_JewelOfHarmonyOption = lpByte[n*ItemDbByte+10];

  00098	0f b6 47 0a	 movzx	 eax, BYTE PTR [edi+10]
  0009c	88 86 c4 00 00
	00		 mov	 BYTE PTR [esi+196], al

; 485  : 
; 486  : 	item.m_ItemOptionEx = DBI_GET_380OPTION(lpByte[n*ItemDbByte+9]);

  000a2	8a 47 09	 mov	 al, BYTE PTR [edi+9]
  000a5	24 f8		 and	 al, 248			; 000000f8H
  000a7	c0 e0 04	 shl	 al, 4
  000aa	88 86 ca 00 00
	00		 mov	 BYTE PTR [esi+202], al

; 487  : 
; 488  : 	if(item.m_ItemOptionEx)

  000b0	84 c0		 test	 al, al
  000b2	74 19		 je	 SHORT $LN9@GetByteToI

; 489  : 	{
; 490  : 		item.m_Type = itype;
; 491  : 
; 492  : 		if(g_kItemSystemFor380.Is380Item(&item)==false)

  000b4	56		 push	 esi
  000b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  000ba	66 89 5e 06	 mov	 WORD PTR [esi+6], bx
  000be	e8 00 00 00 00	 call	 ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380Item
  000c3	85 c0		 test	 eax, eax
  000c5	75 06		 jne	 SHORT $LN9@GetByteToI

; 493  : 		{
; 494  : 			item.m_ItemOptionEx = 0;

  000c7	88 86 ca 00 00
	00		 mov	 BYTE PTR [esi+202], al
$LN9@GetByteToI:

; 495  : 		}
; 496  : 	}
; 497  : 
; 498  : 	BYTE SocketOption[5];
; 499  : 
; 500  : 	BYTE SocketOptionIndex = 0xFF;
; 501  : 
; 502  : 	memset(&SocketOption, 0xFF, 5);

  000cd	83 c8 ff	 or	 eax, -1

; 503  : 
; 504  : 	if ( g_SocketOption.CheckItemType(_type) == 1 )

  000d0	53		 push	 ebx
  000d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  000d6	89 45 f4	 mov	 DWORD PTR _SocketOption$[ebp], eax
  000d9	88 45 f8	 mov	 BYTE PTR _SocketOption$[ebp+4], al
  000dc	e8 00 00 00 00	 call	 ?CheckItemType@CSocketOption@@QAEEH@Z ; CSocketOption::CheckItemType
  000e1	3c 01		 cmp	 al, 1
  000e3	75 2c		 jne	 SHORT $LN8@GetByteToI

; 505  : 	{
; 506  : 		for(int i = 0; i < 5; i++)
; 507  : 		{
; 508  : 			SocketOption[i] =  lpByte[((n*ItemDbByte)+11)+i];

  000e5	0f b6 4f 0b	 movzx	 ecx, BYTE PTR [edi+11]
  000e9	0f b6 57 0c	 movzx	 edx, BYTE PTR [edi+12]
  000ed	0f b6 47 0d	 movzx	 eax, BYTE PTR [edi+13]
  000f1	88 4d f4	 mov	 BYTE PTR _SocketOption$[ebp], cl
  000f4	0f b6 4f 0e	 movzx	 ecx, BYTE PTR [edi+14]
  000f8	88 55 f5	 mov	 BYTE PTR _SocketOption$[ebp+1], dl
  000fb	0f b6 57 0f	 movzx	 edx, BYTE PTR [edi+15]
  000ff	88 45 f6	 mov	 BYTE PTR _SocketOption$[ebp+2], al

; 509  : 		}
; 510  : 
; 511  : 		SocketOptionIndex = lpByte[n*ItemDbByte+10];

  00102	0f b6 47 0a	 movzx	 eax, BYTE PTR [edi+10]
  00106	88 4d f7	 mov	 BYTE PTR _SocketOption$[ebp+3], cl
  00109	88 55 f8	 mov	 BYTE PTR _SocketOption$[ebp+4], dl
  0010c	88 45 f0	 mov	 BYTE PTR _SocketOptionIndex$[ebp], al

; 512  : 	}
; 513  : 	else

  0010f	eb 0d		 jmp	 SHORT $LN4@GetByteToI
$LN8@GetByteToI:

; 514  : 	{
; 515  : 		for(int i = 0; i < 5; i++)
; 516  : 		{
; 517  : 			SocketOption[i] = 0xFF;

  00111	83 c8 ff	 or	 eax, -1
  00114	89 45 f4	 mov	 DWORD PTR _SocketOption$[ebp], eax
  00117	88 45 f8	 mov	 BYTE PTR _SocketOption$[ebp+4], al

; 518  : 		}
; 519  : 
; 520  : 		SocketOptionIndex = 0;

  0011a	c6 45 f0 00	 mov	 BYTE PTR _SocketOptionIndex$[ebp], 0
$LN4@GetByteToI:

; 521  : 	}
; 522  : 
; 523  : 	#ifdef PERIOD
; 524  : 
; 525  : 	item.m_PeriodItemOption = (lpByte[n*ItemDbByte+DBI_OPTION380_DATA] & 6) >> 1;

  0011e	0f b6 47 09	 movzx	 eax, BYTE PTR [edi+9]

; 526  : 
; 527  : 	item.Convert(itype,item.m_Option1,item.m_Option2,item.m_Option3,DBI_GET_NOPTION(lpByte[n*ItemDbByte+7]),lpByte[n*ItemDbByte+8],item.m_ItemOptionEx,SocketOption, SocketOptionIndex, item.m_PeriodItemOption, 3); //season4 changed

  00122	8b 4d f0	 mov	 ecx, DWORD PTR _SocketOptionIndex$[ebp]
  00125	d0 e8		 shr	 al, 1
  00127	24 03		 and	 al, 3
  00129	6a 03		 push	 3
  0012b	88 86 d2 00 00
	00		 mov	 BYTE PTR [esi+210], al
  00131	8d 55 f4	 lea	 edx, DWORD PTR _SocketOption$[ebp]
  00134	50		 push	 eax
  00135	0f b6 86 ca 00
	00 00		 movzx	 eax, BYTE PTR [esi+202]
  0013c	51		 push	 ecx
  0013d	0f b6 4f 08	 movzx	 ecx, BYTE PTR [edi+8]
  00141	52		 push	 edx
  00142	8a 57 07	 mov	 dl, BYTE PTR [edi+7]
  00145	50		 push	 eax
  00146	51		 push	 ecx
  00147	0f b6 8e 96 00
	00 00		 movzx	 ecx, BYTE PTR [esi+150]
  0014e	80 e2 3f	 and	 dl, 63			; 0000003fH
  00151	0f b6 c2	 movzx	 eax, dl
  00154	0f b6 96 95 00
	00 00		 movzx	 edx, BYTE PTR [esi+149]
  0015b	50		 push	 eax
  0015c	0f b6 86 94 00
	00 00		 movzx	 eax, BYTE PTR [esi+148]
  00163	51		 push	 ecx
  00164	52		 push	 edx
  00165	50		 push	 eax
  00166	53		 push	 ebx
  00167	8b ce		 mov	 ecx, esi
  00169	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 528  : 
; 529  : 	#else
; 530  : 		
; 531  : 	item.Convert(itype,item.m_Option1,item.m_Option2,item.m_Option3,DBI_GET_NOPTION(lpByte[n*ItemDbByte+7]),lpByte[n*ItemDbByte+8],item.m_ItemOptionEx,SocketOption, SocketOptionIndex, 0, 3); //season4 changed
; 532  : 
; 533  : 	#endif
; 534  : 
; 535  : 	WORD hiWord = ((lpByte[n*ItemDbByte+4])&0xFF)&0xFF | (((lpByte[n*ItemDbByte+3])&0xFF)&0xFF) * 256;
; 536  : 
; 537  : 	WORD loWord = ((lpByte[n*ItemDbByte+6])&0xFF)&0xFF | (((lpByte[n*ItemDbByte+5])&0xFF)&0xFF) * 256;
; 538  : 
; 539  : 	item.m_Number = ((loWord &0xFFFF)&0xFFFF) | ((hiWord & 0xFFFF)&0xFFFF) << 16;

  0016e	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00172	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00177	66 0f af ca	 imul	 cx, dx
  0017b	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  0017f	0f b7 c1	 movzx	 eax, cx
  00182	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00186	0b c1		 or	 eax, ecx
  00188	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0018d	66 0f af d1	 imul	 dx, cx
  00191	0f b6 4f 06	 movzx	 ecx, BYTE PTR [edi+6]
  00195	c1 e0 10	 shl	 eax, 16			; 00000010H
  00198	0f b7 d2	 movzx	 edx, dx
  0019b	0b c2		 or	 eax, edx
  0019d	0b c1		 or	 eax, ecx

; 540  : 
; 541  : 	return item;	
; 542  : }

  0019f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a2	89 06		 mov	 DWORD PTR [esi], eax
  001a4	5f		 pop	 edi
  001a5	8b c6		 mov	 eax, esi
  001a7	5e		 pop	 esi
  001a8	33 cd		 xor	 ecx, ebp
  001aa	5b		 pop	 ebx
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c2 08 00	 ret	 8
?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z ENDP	; CItemMarket::GetByteToItem
_TEXT	ENDS
PUBLIC	?ConnectPlayer@CItemMarket@@QAEXH@Z		; CItemMarket::ConnectPlayer
; Function compile flags: /Ogtp
;	COMDAT ?ConnectPlayer@CItemMarket@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?ConnectPlayer@CItemMarket@@QAEXH@Z PROC		; CItemMarket::ConnectPlayer, COMDAT
; _this$ = ecx

; 545  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 547  : }

  00003	5d		 pop	 ebp

; 546  : 	this->GDReqItemStatus(aIndex);

  00004	e9 00 00 00 00	 jmp	 ?GDReqItemStatus@CItemMarket@@QAEXH@Z ; CItemMarket::GDReqItemStatus
?ConnectPlayer@CItemMarket@@QAEXH@Z ENDP		; CItemMarket::ConnectPlayer
_TEXT	ENDS
PUBLIC	?GetCheckMoney@CItemMarket@@QAE_NHHH@Z		; CItemMarket::GetCheckMoney
; Function compile flags: /Ogtp
;	COMDAT ?GetCheckMoney@CItemMarket@@QAE_NHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_PriceType$ = 12					; size = 4
_PriceValue$ = 16					; size = 4
?GetCheckMoney@CItemMarket@@QAE_NHHH@Z PROC		; CItemMarket::GetCheckMoney, COMDAT
; _this$ = ecx

; 550  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 551  : 	bool Result = true;
; 552  : 
; 553  : 	LPOBJ lpUser = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 554  : 
; 555  : 	if(PriceType == eMarketPriceTypeZen)

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _PriceType$[ebp]
  00009	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	b2 01		 mov	 dl, 1
  00017	85 c9		 test	 ecx, ecx
  00019	75 11		 jne	 SHORT $LN5@GetCheckMo

; 556  : 	{
; 557  : 		if(PriceValue > lpUser->Money)

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _PriceValue$[ebp]
  0001e	3b 88 f0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+240]
  00024	7e 38		 jle	 SHORT $LN12@GetCheckMo
$LN14@GetCheckMo:

; 558  : 		{
; 559  : 			Result = false;

  00026	32 c0		 xor	 al, al

; 580  : }

  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN5@GetCheckMo:

; 560  : 		}
; 561  : 	}
; 562  : 
; 563  : 	if(PriceType == eMarketPriceTypeWcoin)

  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	75 16		 jne	 SHORT $LN3@GetCheckMo

; 564  : 	{
; 565  : 		if(PriceValue > lpUser->GameShop.WCoinC)

  00031	db 45 10	 fild	 DWORD PTR _PriceValue$[ebp]
  00034	dc 98 00 23 00
	00		 fcomp	 QWORD PTR [eax+8960]
  0003a	df e0		 fnstsw	 ax
  0003c	f6 c4 41	 test	 ah, 65			; 00000041H
  0003f	75 1d		 jne	 SHORT $LN12@GetCheckMo

; 566  : 		{
; 567  : 			Result = false;

  00041	32 c0		 xor	 al, al

; 580  : }

  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
$LN3@GetCheckMo:

; 568  : 		}
; 569  : 	}
; 570  : 
; 571  : 	if(PriceType == eMarketPriceTypeCredit)

  00047	83 f9 02	 cmp	 ecx, 2
  0004a	75 12		 jne	 SHORT $LN12@GetCheckMo

; 572  : 	{
; 573  : 		if(PriceValue > lpUser->ZtCred)

  0004c	db 45 10	 fild	 DWORD PTR _PriceValue$[ebp]
  0004f	d9 80 a8 22 00
	00		 fld	 DWORD PTR [eax+8872]
  00055	de d9		 fcompp
  00057	df e0		 fnstsw	 ax
  00059	f6 c4 05	 test	 ah, 5
  0005c	7b c8		 jnp	 SHORT $LN14@GetCheckMo
$LN12@GetCheckMo:

; 574  : 		{
; 575  : 			Result = false;
; 576  : 		}
; 577  : 	}
; 578  : 
; 579  : 	return Result;

  0005e	8a c2		 mov	 al, dl

; 580  : }

  00060	5d		 pop	 ebp
  00061	c2 0c 00	 ret	 12			; 0000000cH
?GetCheckMoney@CItemMarket@@QAE_NHHH@Z ENDP		; CItemMarket::GetCheckMoney
_TEXT	ENDS
PUBLIC	??_C@_0BM@JHCOPCCO@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@ ; `string'
PUBLIC	??_C@_0BL@EGKAAIGB@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GBKKGFMP@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@ ; `string'
PUBLIC	?PlayerMoney@CItemMarket@@QAE_NHHH@Z		; CItemMarket::PlayerMoney
;	COMDAT ??_C@_0BM@JHCOPCCO@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@
CONST	SEGMENT
??_C@_0BM@JHCOPCCO@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@ DB '['
	DB	'MARKET][BUY] %s +%d Credit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EGKAAIGB@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@
CONST	SEGMENT
??_C@_0BL@EGKAAIGB@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@ DB '['
	DB	'MARKET][BUY] %s +%d Wcoin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GBKKGFMP@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@
CONST	SEGMENT
??_C@_0BJ@GBKKGFMP@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@ DB '['
	DB	'MARKET][BUY] %s +%d Zen', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PlayerMoney@CItemMarket@@QAE_NHHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_PriceType$ = 12					; size = 4
_PriceValue$ = 16					; size = 4
?PlayerMoney@CItemMarket@@QAE_NHHH@Z PROC		; CItemMarket::PlayerMoney, COMDAT
; _this$ = ecx

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 	bool Result = this->GetCheckMoney(aIndex, PriceType, PriceValue);

  00003	8b 45 10	 mov	 eax, DWORD PTR _PriceValue$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _PriceType$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000f	50		 push	 eax
  00010	52		 push	 edx
  00011	57		 push	 edi
  00012	e8 00 00 00 00	 call	 ?GetCheckMoney@CItemMarket@@QAE_NHHH@Z ; CItemMarket::GetCheckMoney

; 585  : 
; 586  : 	LPOBJ lpUser = &gObj[aIndex];

  00017	8b f7		 mov	 esi, edi
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	8a d8		 mov	 bl, al

; 587  : 
; 588  : 	if(Result)

  00027	84 db		 test	 bl, bl
  00029	0f 84 ae 00 00
	00		 je	 $LN8@PlayerMone

; 589  : 	{
; 590  : 		if(PriceType == eMarketPriceTypeZen)

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _PriceType$[ebp]
  00032	85 c0		 test	 eax, eax
  00034	75 35		 jne	 SHORT $LN3@PlayerMone

; 591  : 		{
; 592  : 			lpUser->Money -= PriceValue;

  00036	8b 45 10	 mov	 eax, DWORD PTR _PriceValue$[ebp]
  00039	29 86 f0 00 00
	00		 sub	 DWORD PTR [esi+240], eax
  0003f	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]

; 593  : 
; 594  : 			GCMoneySend(aIndex, lpUser->Money);

  00045	50		 push	 eax
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 595  : 
; 596  : 			MsgOutput(aIndex, "[MARKET][BUY] %s +%d Zen", lpUser->AccountID, PriceValue);

  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _PriceValue$[ebp]
  0004f	51		 push	 ecx
  00050	83 c6 6c	 add	 esi, 108		; 0000006cH
  00053	56		 push	 esi
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GBKKGFMP@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Zen?$AA@
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 615  : 		}
; 616  : 	}
; 617  : 
; 618  : 	return Result;

  00064	8a c3		 mov	 al, bl
  00066	5b		 pop	 ebx

; 619  : }

  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
$LN3@PlayerMone:

; 597  : 		}
; 598  : 
; 599  : 		if(PriceType == eMarketPriceTypeWcoin)

  0006b	83 f8 01	 cmp	 eax, 1
  0006e	75 3b		 jne	 SHORT $LN2@PlayerMone

; 600  : 		{
; 601  : 			lpUser->GameShop.WCoinC -= PriceValue;

  00070	db 45 10	 fild	 DWORD PTR _PriceValue$[ebp]

; 602  : 
; 603  : 			gGameShop.GDSaveUserInfo(lpUser->m_Index);

  00073	8b 16		 mov	 edx, DWORD PTR [esi]
  00075	52		 push	 edx
  00076	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0007b	dc ae 00 23 00
	00		 fsubr	 QWORD PTR [esi+8960]
  00081	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
  00087	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 604  : 
; 605  : 			MsgOutput(aIndex, "[MARKET][BUY] %s +%d Wcoin", lpUser->AccountID, PriceValue);

  0008c	8b 45 10	 mov	 eax, DWORD PTR _PriceValue$[ebp]
  0008f	50		 push	 eax
  00090	83 c6 6c	 add	 esi, 108		; 0000006cH
  00093	56		 push	 esi
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@EGKAAIGB@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Wcoin?$AA@
  00099	57		 push	 edi
  0009a	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0009f	83 c4 10	 add	 esp, 16			; 00000010H
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi

; 615  : 		}
; 616  : 	}
; 617  : 
; 618  : 	return Result;

  000a4	8a c3		 mov	 al, bl
  000a6	5b		 pop	 ebx

; 619  : }

  000a7	5d		 pop	 ebp
  000a8	c2 0c 00	 ret	 12			; 0000000cH
$LN2@PlayerMone:

; 606  : 		}
; 607  : 
; 608  : 		if(PriceType == eMarketPriceTypeCredit)

  000ab	83 f8 02	 cmp	 eax, 2
  000ae	75 2d		 jne	 SHORT $LN8@PlayerMone

; 609  : 		{
; 610  : 			lpUser->ZtCred += PriceValue;

  000b0	db 45 10	 fild	 DWORD PTR _PriceValue$[ebp]

; 611  : 
; 612  : 			ZtUserDataSend(lpUser->m_Index);

  000b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b5	51		 push	 ecx
  000b6	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  000bc	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
  000c2	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend

; 613  : 
; 614  : 			MsgOutput(aIndex, "[MARKET][BUY] %s +%d Credit", lpUser->AccountID, PriceValue);

  000c7	8b 55 10	 mov	 edx, DWORD PTR _PriceValue$[ebp]
  000ca	52		 push	 edx
  000cb	83 c6 6c	 add	 esi, 108		; 0000006cH
  000ce	56		 push	 esi
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JHCOPCCO@?$FLMARKET?$FN?$FLBUY?$FN?5?$CFs?5?$CL?$CFd?5Credit?$AA@
  000d4	57		 push	 edi
  000d5	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000da	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@PlayerMone:

; 615  : 		}
; 616  : 	}
; 617  : 
; 618  : 	return Result;

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	8a c3		 mov	 al, bl
  000e1	5b		 pop	 ebx

; 619  : }

  000e2	5d		 pop	 ebp
  000e3	c2 0c 00	 ret	 12			; 0000000cH
?PlayerMoney@CItemMarket@@QAE_NHHH@Z ENDP		; CItemMarket::PlayerMoney
_TEXT	ENDS
PUBLIC	??_C@_0BL@LFELPFHD@?$FLItemMarket?$FN?5Item?5Recv?5?3?51?$AA@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqItemDate@CItemMarket@@QAEXPAUSDHP_REQ_MARKET_ITEMRECV@@@Z ; CItemMarket::GDReqItemDate
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?gObjInventoryInsertItem@@YAEHVCItem@@@Z:PROC	; gObjInventoryInsertItem
;	COMDAT ??_C@_0BL@LFELPFHD@?$FLItemMarket?$FN?5Item?5Recv?5?3?51?$AA@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0BL@LFELPFHD@?$FLItemMarket?$FN?5Item?5Recv?5?3?51?$AA@ DB '[ItemMa'
	DB	'rket] Item Recv : 1', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\itemmarket.cpp
CONST	ENDS
;	COMDAT ?GDReqItemDate@CItemMarket@@QAEXPAUSDHP_REQ_MARKET_ITEMRECV@@@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -444					; size = 4
$T203868 = -440						; size = 212
_item$ = -228						; size = 212
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GDReqItemDate@CItemMarket@@QAEXPAUSDHP_REQ_MARKET_ITEMRECV@@@Z PROC ; CItemMarket::GDReqItemDate, COMDAT
; _this$ = ecx

; 624  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 01 00
	00		 sub	 esp, 444		; 000001bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 625  : 	int aIndex = lpMsg->aIndex;

  00018	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx

; 628  : 	{
; 629  : 		return;
; 630  : 	}
; 631  : 
; 632  : 	SDHP_ANS_MARKET_ITEMRECV pMsg;
; 633  : 
; 634  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEC, 0x04, sizeof(pMsg));

  0001e	89 b5 44 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00024	85 db		 test	 ebx, ebx
  00026	0f 88 ae 00 00
	00		 js	 $LN3@GDReqItemD

; 626  : 
; 627  : 	if(!OBJMAX_RANGE(aIndex))

  0002c	33 c0		 xor	 eax, eax
  0002e	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00034	0f 9e c0	 setle	 al
  00037	85 c0		 test	 eax, eax
  00039	0f 84 9b 00 00
	00		 je	 $LN3@GDReqItemD

; 635  : 
; 636  : 	pMsg.Result = 1;
; 637  : 
; 638  : 	pMsg.ID = lpMsg->ID;

  0003f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 639  : 
; 640  : 	GCServerMsgStringSend("[ItemMarket] Item Recv : 1", aIndex, 0);

  00042	6a 00		 push	 0
  00044	53		 push	 ebx
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LFELPFHD@?$FLItemMarket?$FN?5Item?5Recv?5?3?51?$AA@
  0004a	c7 45 f0 c1 0c
	ec 04		 mov	 DWORD PTR _pMsg$[ebp], 82578625 ; 04ec0cc1H
  00051	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+4], 1
  00058	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0005b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 
; 642  : 	CItem item;

  00063	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00069	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 643  : 
; 644  : 	item = this->GetByteToItem(lpMsg->Item);

  0006e	83 c6 10	 add	 esi, 16			; 00000010H
  00071	56		 push	 esi
  00072	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR $T203868[ebp]
  00078	51		 push	 ecx
  00079	8b cf		 mov	 ecx, edi
  0007b	e8 00 00 00 00	 call	 ?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z ; CItemMarket::GetByteToItem
  00080	8b f0		 mov	 esi, eax
  00082	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00087	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR _item$[ebp]
  0008d	f3 a5		 rep movsd

; 645  : 
; 646  : 	BYTE btItemPos = gObjInventoryInsertItem(aIndex, item);

  0008f	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00095	8b f0		 mov	 esi, eax
  00097	8b fc		 mov	 edi, esp
  00099	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0009e	53		 push	 ebx
  0009f	f3 a5		 rep movsd
  000a1	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem

; 647  : 
; 648  : 	if(btItemPos == -1)

  000a6	0f b6 c0	 movzx	 eax, al
  000a9	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	74 26		 je	 SHORT $LN3@GDReqItemD

; 649  : 	{
; 650  : 		return;
; 651  : 	}
; 652  : 
; 653  : 	GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  000b4	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  000ba	50		 push	 eax
  000bb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 654  : 
; 655  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  000c4	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000c8	83 c4 08	 add	 esp, 8
  000cb	51		 push	 ecx
  000cc	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000cf	52		 push	 edx
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000d5	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN3@GDReqItemD:

; 656  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	33 cd		 xor	 ecx, ebp
  000e1	5b		 pop	 ebx
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
?GDReqItemDate@CItemMarket@@QAEXPAUSDHP_REQ_MARKET_ITEMRECV@@@Z ENDP ; CItemMarket::GDReqItemDate
_TEXT	ENDS
PUBLIC	??0CItemMarket@@QAE@XZ				; CItemMarket::CItemMarket
; Function compile flags: /Ogtp
;	COMDAT ??0CItemMarket@@QAE@XZ
_TEXT	SEGMENT
??0CItemMarket@@QAE@XZ PROC				; CItemMarket::CItemMarket, COMDAT
; _this$ = ecx

; 17   : {

  00000	8b c1		 mov	 eax, ecx

; 18   : 	this->Init();
; 19   : }

  00002	c3		 ret	 0
??0CItemMarket@@QAE@XZ ENDP				; CItemMarket::CItemMarket
_TEXT	ENDS
PUBLIC	??_C@_0BP@PDCEMGDO@?$FLItemMarket?$FN?5Item?5List?5Refresh?$AA@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsItemList@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_ITEM@@@Z ; CItemMarket::DGAnsItemList
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BP@PDCEMGDO@?$FLItemMarket?$FN?5Item?5List?5Refresh?$AA@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0BP@PDCEMGDO@?$FLItemMarket?$FN?5Item?5List?5Refresh?$AA@ DB '[Item'
	DB	'Market] Item List Refresh', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\itemmarket.cpp
CONST	ENDS
;	COMDAT ?DGAnsItemList@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_ITEM@@@Z
_TEXT	SEGMENT
_aIndex$ = -5260					; size = 4
_this$GSCopy$ = -5256					; size = 4
tv377 = -5252						; size = 4
tv620 = -5248						; size = 4
_lpMsg$GSCopy$ = -5248					; size = 4
tv429 = -5244						; size = 4
tv196 = -5244						; size = 4
_pMsg$ = -5240						; size = 4812
$T203688 = -428						; size = 212
_item$ = -216						; size = 212
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsItemList@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_ITEM@@@Z PROC ; CItemMarket::DGAnsItemList, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 8c 14 00 00	 mov	 eax, 5260		; 0000148cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 84   : 	int aIndex = lpMsg->aIndex;

  0001c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001f	89 85 74 eb ff
	ff		 mov	 DWORD PTR _aIndex$[ebp], eax

; 85   : 
; 86   : 	// ----
; 87   : 
; 88   : 	memset(this->m_MarketData[aIndex], 0, sizeof(this->m_MarketData[aIndex]));

  00025	69 c0 a0 0f 00
	00		 imul	 eax, 4000		; 00000fa0H
  0002b	57		 push	 edi
  0002c	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  00031	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00034	6a 00		 push	 0
  00036	57		 push	 edi
  00037	89 8d 78 eb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  0003d	89 b5 80 eb ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00043	89 bd 84 eb ff
	ff		 mov	 DWORD PTR tv196[ebp], edi
  00049	e8 00 00 00 00	 call	 _memset

; 89   : 
; 90   : 	memcpy(this->m_MarketData[aIndex], lpMsg->Data, sizeof(this->m_MarketData[aIndex]));
; 91   : 
; 92   : 	// ----
; 93   : 
; 94   : 	PMSG_ANS_MARKET_ITEM pMsg;
; 95   : 
; 96   : 	memset(&pMsg, 0, sizeof(pMsg));

  0004e	68 cc 12 00 00	 push	 4812			; 000012ccH
  00053	8d 85 88 eb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	6a 00		 push	 0
  0005b	83 c6 10	 add	 esi, 16			; 00000010H
  0005e	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00063	50		 push	 eax
  00064	f3 a5		 rep movsd
  00066	e8 00 00 00 00	 call	 _memset
  0006b	83 c4 18	 add	 esp, 24			; 00000018H

; 97   : 
; 98   : 	pMsg.h.set((LPBYTE)&pMsg, 0xFA, 0xF5, sizeof(pMsg));
; 99   : 
; 100  : 	pMsg.Result = 1;
; 101  : 
; 102  : 	CItem item;

  0006e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00074	c7 85 88 eb ff
	ff c2 12 cc fa	 mov	 DWORD PTR _pMsg$[ebp], -87289150 ; facc12c2H
  0007e	c6 85 8c eb ff
	ff f5		 mov	 BYTE PTR _pMsg$[ebp+4], 245 ; 000000f5H
  00085	c7 85 90 eb ff
	ff 01 00 00 00	 mov	 DWORD PTR _pMsg$[ebp+8], 1
  0008f	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 103  : 	
; 104  : 	for(int i = 0; i < MARKET_ITEM_MAX; i++)

  00094	8b 85 80 eb ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]

; 109  : 
; 110  : 		// ----
; 111  : 
; 112  : 		item = this->GetByteToItem(this->m_MarketData[aIndex][i].Item);

  0009a	8b 8d 84 eb ff
	ff		 mov	 ecx, DWORD PTR tv196[ebp]
  000a0	83 c0 14	 add	 eax, 20			; 00000014H
  000a3	83 c1 0f	 add	 ecx, 15			; 0000000fH
  000a6	8d 9d 98 eb ff
	ff		 lea	 ebx, DWORD PTR _pMsg$[ebp+16]
  000ac	89 85 7c eb ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
  000b2	89 8d 84 eb ff
	ff		 mov	 DWORD PTR tv429[ebp], ecx
  000b8	c7 85 80 eb ff
	ff 64 00 00 00	 mov	 DWORD PTR tv620[ebp], 100 ; 00000064H
  000c2	eb 06		 jmp	 SHORT $LN3@DGAnsItemL
$LL10@DGAnsItemL:

; 103  : 	
; 104  : 	for(int i = 0; i < MARKET_ITEM_MAX; i++)

  000c4	8b 85 7c eb ff
	ff		 mov	 eax, DWORD PTR tv377[ebp]
$LN3@DGAnsItemL:

; 105  : 	{
; 106  : 		pMsg.Info[i].ID = lpMsg->Data[i].ID;

  000ca	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 107  : 
; 108  : 		memcpy(pMsg.Info[i].Name, lpMsg->Data[i].Name, 10);

  000cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cf	89 0b		 mov	 DWORD PTR [ebx], ecx

; 109  : 
; 110  : 		// ----
; 111  : 
; 112  : 		item = this->GetByteToItem(this->m_MarketData[aIndex][i].Item);

  000d1	8b 8d 84 eb ff
	ff		 mov	 ecx, DWORD PTR tv429[ebp]
  000d7	89 53 fc	 mov	 DWORD PTR [ebx-4], edx
  000da	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000dd	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  000e1	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000e4	51		 push	 ecx
  000e5	8b 8d 78 eb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000eb	8d 95 54 fe ff
	ff		 lea	 edx, DWORD PTR $T203688[ebp]
  000f1	52		 push	 edx
  000f2	66 89 43 08	 mov	 WORD PTR [ebx+8], ax
  000f6	e8 00 00 00 00	 call	 ?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z ; CItemMarket::GetByteToItem
  000fb	8b f0		 mov	 esi, eax
  000fd	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00102	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR _item$[ebp]
  00108	f3 a5		 rep movsd

; 113  : 
; 114  : 		// ----
; 115  : 
; 116  : 		pMsg.Info[i].ItemType = item.m_Type;
; 117  : 
; 118  : 		pMsg.Info[i].ItemDurability = item.m_Durability;

  0010a	d9 85 4c ff ff
	ff		 fld	 DWORD PTR _item$[ebp+36]
  00110	d9 5b 10	 fstp	 DWORD PTR [ebx+16]
  00113	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _item$[ebp+4]
  00119	c1 e8 10	 shr	 eax, 16			; 00000010H
  0011c	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax

; 119  : 
; 120  : 		pMsg.Info[i].PriceType = lpMsg->Data[i].PriceType;

  00120	8b 85 7c eb ff
	ff		 mov	 eax, DWORD PTR tv377[ebp]
  00126	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]

; 121  : 
; 122  : 		pMsg.Info[i].Price = lpMsg->Data[i].Price;

  00129	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  0012c	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx

; 123  : 
; 124  : 		ItemByteConvert(pMsg.Info[i].ItemData, item);

  0012f	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00135	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  00138	8b fc		 mov	 edi, esp
  0013a	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0013f	8d b5 28 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00145	50		 push	 eax
  00146	89 53 28	 mov	 DWORD PTR [ebx+40], edx
  00149	f3 a5		 rep movsd
  0014b	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00150	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00155	01 85 84 eb ff
	ff		 add	 DWORD PTR tv429[ebp], eax
  0015b	01 85 7c eb ff
	ff		 add	 DWORD PTR tv377[ebp], eax
  00161	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00167	83 c3 30	 add	 ebx, 48			; 00000030H
  0016a	ff 8d 80 eb ff
	ff		 dec	 DWORD PTR tv620[ebp]
  00170	0f 85 4e ff ff
	ff		 jne	 $LL10@DGAnsItemL

; 125  : 	}
; 126  : 
; 127  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00176	8b b5 74 eb ff
	ff		 mov	 esi, DWORD PTR _aIndex$[ebp]
  0017c	68 cc 12 00 00	 push	 4812			; 000012ccH
  00181	8d 8d 88 eb ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00187	51		 push	 ecx
  00188	56		 push	 esi
  00189	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 128  : 
; 129  : 	//LogAddC(2, "[SERVER -> CLIENT] [SIZE:%d]: DGAnsItemList", sizeof(pMsg));
; 130  : 
; 131  : 	GCServerMsgStringSend("[ItemMarket] Item List Refresh", aIndex, 0);

  0018e	6a 00		 push	 0
  00190	56		 push	 esi
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PDCEMGDO@?$FLItemMarket?$FN?5Item?5List?5Refresh?$AA@
  00196	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 132  : }

  0019b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019e	83 c4 18	 add	 esp, 24			; 00000018H
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	33 cd		 xor	 ecx, ebp
  001a5	5b		 pop	 ebx
  001a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 04 00	 ret	 4
?DGAnsItemList@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_ITEM@@@Z ENDP ; CItemMarket::DGAnsItemList
_TEXT	ENDS
PUBLIC	?CGReqItemSell@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_SELL@@H@Z ; CItemMarket::CGReqItemSell
; Function compile flags: /Ogtp
;	COMDAT ?CGReqItemSell@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_SELL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqItemSell@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_SELL@@H@Z PROC ; CItemMarket::CGReqItemSell, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	this->GDReqItemSell(aIndex, lpMsg->ItemPos, lpMsg->ItemPriceType, lpMsg->ItemPrice);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00009	52		 push	 edx
  0000a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0000d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00010	52		 push	 edx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00014	50		 push	 eax
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?GDReqItemSell@CItemMarket@@QAEXHHHH@Z ; CItemMarket::GDReqItemSell

; 137  : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?CGReqItemSell@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_SELL@@H@Z ENDP ; CItemMarket::CGReqItemSell
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GDReqItemBuy@CItemMarket@@QAEXHH@Z		; CItemMarket::GDReqItemBuy
; Function compile flags: /Ogtp
;	COMDAT ?GDReqItemBuy@CItemMarket@@QAEXHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_ID$ = 12						; size = 4
?GDReqItemBuy@CItemMarket@@QAEXHH@Z PROC		; CItemMarket::GDReqItemBuy, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 253  : 	if(!OBJMAX_RANGE(aIndex))

  00015	33 f6		 xor	 esi, esi
  00017	3b fe		 cmp	 edi, esi
  00019	0f 8c ba 00 00
	00		 jl	 $LN8@GDReqItemB
  0001f	33 c0		 xor	 eax, eax
  00021	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00027	0f 9e c0	 setle	 al
  0002a	3b c6		 cmp	 eax, esi
  0002c	0f 84 a7 00 00
	00		 je	 $LN8@GDReqItemB

; 254  : 	{
; 255  : 		return;
; 256  : 	}
; 257  : 
; 258  : 	LPOBJ lpUser = &gObj[aIndex];

  00032	8b d7		 mov	 edx, edi
  00034	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0003a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	8b c7		 mov	 eax, edi
  00042	69 c0 a0 0f 00
	00		 imul	 eax, 4000		; 00000fa0H
  00048	53		 push	 ebx

; 259  : 
; 260  : 	SDHP_REQ_MARKET_BUY pMsg;
; 261  : 
; 262  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEC, 0x02, sizeof(pMsg));
; 263  : 
; 264  : 	pMsg.Result = 1;
; 265  : 
; 266  : 	pMsg.aIndex = aIndex;
; 267  : 
; 268  : 	pMsg.ID = ID;

  00049	8b 5d 0c	 mov	 ebx, DWORD PTR _ID$[ebp]
  0004c	c7 45 ec c1 10
	ec 02		 mov	 DWORD PTR _pMsg$[ebp], 49025217 ; 02ec10c1H
  00053	89 7d f4	 mov	 DWORD PTR _pMsg$[ebp+8], edi
  00056	89 5d f8	 mov	 DWORD PTR _pMsg$[ebp+12], ebx

; 269  : 
; 270  : 	pMsg.Result = 0;

  00059	89 75 f0	 mov	 DWORD PTR _pMsg$[ebp+4], esi
  0005c	03 c1		 add	 eax, ecx
  0005e	8b ff		 npad	 2
$LL6@GDReqItemB:

; 273  : 	{
; 274  : 		if(ID == this->m_MarketData[aIndex][i].ID)

  00060	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00062	74 0b		 je	 SHORT $LN15@GDReqItemB

; 271  : 
; 272  : 	for(int i = 0; i < MARKET_ITEM_MAX; i++)

  00064	46		 inc	 esi
  00065	83 c0 28	 add	 eax, 40			; 00000028H
  00068	83 fe 64	 cmp	 esi, 100		; 00000064H
  0006b	7c f3		 jl	 SHORT $LL6@GDReqItemB

; 273  : 	{
; 274  : 		if(ID == this->m_MarketData[aIndex][i].ID)

  0006d	eb 59		 jmp	 SHORT $LN1@GDReqItemB
$LN15@GDReqItemB:

; 275  : 		{
; 276  : #if(MARKET_PLAYER_BUY)
; 277  : 			if(!strcmp(lpUser->Name, this->m_MarketData[aIndex][i].Name))

  0006f	8b c7		 mov	 eax, edi
  00071	6b c0 64	 imul	 eax, 100		; 00000064H
  00074	03 c6		 add	 eax, esi
  00076	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00079	8d 1c c1	 lea	 ebx, DWORD PTR [ecx+eax*8]
  0007c	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  0007f	8d 42 77	 lea	 eax, DWORD PTR [edx+119]
$LL17@GDReqItemB:
  00082	8a 10		 mov	 dl, BYTE PTR [eax]
  00084	3a 16		 cmp	 dl, BYTE PTR [esi]
  00086	75 1a		 jne	 SHORT $LN18@GDReqItemB
  00088	84 d2		 test	 dl, dl
  0008a	74 12		 je	 SHORT $LN19@GDReqItemB
  0008c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008f	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  00092	75 0e		 jne	 SHORT $LN18@GDReqItemB
  00094	83 c0 02	 add	 eax, 2
  00097	83 c6 02	 add	 esi, 2
  0009a	84 d2		 test	 dl, dl
  0009c	75 e4		 jne	 SHORT $LL17@GDReqItemB
$LN19@GDReqItemB:
  0009e	33 c0		 xor	 eax, eax
  000a0	eb 05		 jmp	 SHORT $LN20@GDReqItemB
$LN18@GDReqItemB:
  000a2	1b c0		 sbb	 eax, eax
  000a4	83 d8 ff	 sbb	 eax, -1
$LN20@GDReqItemB:
  000a7	85 c0		 test	 eax, eax
  000a9	75 09		 jne	 SHORT $LN2@GDReqItemB

; 278  : 			{
; 279  : 				pMsg.Result = 1;

  000ab	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+4], 1

; 280  : 			}
; 281  : 			else

  000b2	eb 14		 jmp	 SHORT $LN1@GDReqItemB
$LN2@GDReqItemB:

; 282  : 			{
; 283  : 				pMsg.Result = this->GetCheckMoney(aIndex, this->m_MarketData[aIndex][i].PriceType, this->m_MarketData[aIndex][i].Price);

  000b4	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  000b7	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 ?GetCheckMoney@CItemMarket@@QAE_NHHH@Z ; CItemMarket::GetCheckMoney
  000c2	0f b6 c8	 movzx	 ecx, al
  000c5	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
$LN1@GDReqItemB:

; 284  : 			}
; 285  : #else
; 286  : 			pMsg.Result = this->GetCheckMoney(aIndex, this->m_MarketData[aIndex][i].PriceType, this->m_MarketData[aIndex][i].Price);
; 287  : #endif
; 288  : 			break;
; 289  : 		}
; 290  : 	}
; 291  : 
; 292  : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  000c8	6a 10		 push	 16			; 00000010H
  000ca	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000cd	52		 push	 edx
  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000d3	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  000d8	5b		 pop	 ebx
$LN8@GDReqItemB:

; 293  : 
; 294  : 	//LogAddC(2, "[SERVER -> CLIENT] [SIZE:%d]: GDReqItemBuy", sizeof(pMsg));
; 295  : }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	5f		 pop	 edi
  000dd	33 cd		 xor	 ecx, ebp
  000df	5e		 pop	 esi
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
?GDReqItemBuy@CItemMarket@@QAEXHH@Z ENDP		; CItemMarket::GDReqItemBuy
_TEXT	ENDS
PUBLIC	??_C@_0BM@LOKBIJMA@?$FLItemMarket?$FN?5BUY?5Result?5?3?50?$AA@ ; `string'
PUBLIC	??_C@_0BM@KHLKLIIB@?$FLItemMarket?$FN?5BUY?5Result?5?3?51?$AA@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?DGAnsItemBuy@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_BUY@@@Z ; CItemMarket::DGAnsItemBuy
;	COMDAT ??_C@_0BM@LOKBIJMA@?$FLItemMarket?$FN?5BUY?5Result?5?3?50?$AA@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0BM@LOKBIJMA@?$FLItemMarket?$FN?5BUY?5Result?5?3?50?$AA@ DB '[ItemM'
	DB	'arket] BUY Result : 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KHLKLIIB@?$FLItemMarket?$FN?5BUY?5Result?5?3?51?$AA@
CONST	SEGMENT
??_C@_0BM@KHLKLIIB@?$FLItemMarket?$FN?5BUY?5Result?5?3?51?$AA@ DB '[ItemM'
	DB	'arket] BUY Result : 1', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\itemmarket.cpp
CONST	ENDS
;	COMDAT ?DGAnsItemBuy@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_BUY@@@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -440					; size = 4
_pMsg$ = -436						; size = 8
$T203768 = -428						; size = 212
_item$203757 = -216					; size = 212
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGAnsItemBuy@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_BUY@@@Z PROC ; CItemMarket::DGAnsItemBuy, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 01 00
	00		 sub	 esp, 440		; 000001b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 299  : 	int aIndex = lpMsg->aIndex;

  00018	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx

; 360  : 	}
; 361  : 
; 362  : 	PMSG_ANS_MARKET_BUY pMsg;
; 363  : 
; 364  : 	pMsg.h.set((LPBYTE)&pMsg, 0xEC, 0x01, sizeof(pMsg));

  0001e	89 b5 48 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00024	85 db		 test	 ebx, ebx
  00026	0f 88 40 01 00
	00		 js	 $LN11@DGAnsItemB

; 300  : 
; 301  : 	if(!OBJMAX_RANGE(aIndex))

  0002c	33 c0		 xor	 eax, eax
  0002e	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00034	0f 9e c0	 setle	 al
  00037	85 c0		 test	 eax, eax
  00039	0f 84 2d 01 00
	00		 je	 $LN11@DGAnsItemB

; 302  : 	{
; 303  : 		return;
; 304  : 	}
; 305  : 
; 306  : 	if(lpMsg->Result)

  0003f	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0

; 307  : 	{
; 308  : 		GCServerMsgStringSend("[ItemMarket] BUY Result : 1", aIndex, 0);

  00043	6a 00		 push	 0
  00045	53		 push	 ebx
  00046	0f 84 ed 00 00
	00		 je	 $LN9@DGAnsItemB
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KHLKLIIB@?$FLItemMarket?$FN?5BUY?5Result?5?3?51?$AA@
  00051	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 309  : 
; 310  : 		// ----
; 311  : 
; 312  : 		CItem item;

  00059	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _item$203757[ebp]
  0005f	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00064	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  00067	8b c3		 mov	 eax, ebx
  00069	69 c0 a0 0f 00
	00		 imul	 eax, 4000		; 00000fa0H

; 313  : 
; 314  : 		for(int i = 0; i < MARKET_ITEM_MAX; i++)

  0006f	33 c9		 xor	 ecx, ecx
  00071	03 c7		 add	 eax, edi
$LL8@DGAnsItemB:

; 315  : 		{
; 316  : 			if(lpMsg->ID == this->m_MarketData[aIndex][i].ID)

  00073	3b 30		 cmp	 esi, DWORD PTR [eax]
  00075	74 0e		 je	 SHORT $LN18@DGAnsItemB

; 313  : 
; 314  : 		for(int i = 0; i < MARKET_ITEM_MAX; i++)

  00077	41		 inc	 ecx
  00078	83 c0 28	 add	 eax, 40			; 00000028H
  0007b	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0007e	7c f3		 jl	 SHORT $LL8@DGAnsItemB

; 315  : 		{
; 316  : 			if(lpMsg->ID == this->m_MarketData[aIndex][i].ID)

  00080	e9 c1 00 00 00	 jmp	 $LN1@DGAnsItemB
$LN18@DGAnsItemB:

; 317  : 			{
; 318  : #if(MARKET_PLAYER_BUY)
; 319  : 
; 320  : 				//char szbuffname[64] = { 0 };
; 321  : 				//sprintf(szbuffname, "%s = %s", gObj[aIndex].Name, this->m_MarketData[aIndex][i].Name); 
; 322  : 				//GCServerMsgStringSend(szbuffname, aIndex, 0);
; 323  : 
; 324  : 				if(!strcmp(gObj[aIndex].Name, this->m_MarketData[aIndex][i].Name))

  00085	8b c3		 mov	 eax, ebx
  00087	6b c0 64	 imul	 eax, 100		; 00000064H
  0008a	03 c1		 add	 eax, ecx
  0008c	8b d3		 mov	 edx, ebx
  0008e	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00094	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00097	8d 34 c7	 lea	 esi, DWORD PTR [edi+eax*8]
  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009f	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000a2	8d 44 02 77	 lea	 eax, DWORD PTR [edx+eax+119]
$LL20@DGAnsItemB:
  000a6	8a 10		 mov	 dl, BYTE PTR [eax]
  000a8	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000aa	75 1a		 jne	 SHORT $LN21@DGAnsItemB
  000ac	84 d2		 test	 dl, dl
  000ae	74 12		 je	 SHORT $LN22@DGAnsItemB
  000b0	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b3	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b6	75 0e		 jne	 SHORT $LN21@DGAnsItemB
  000b8	83 c0 02	 add	 eax, 2
  000bb	83 c1 02	 add	 ecx, 2
  000be	84 d2		 test	 dl, dl
  000c0	75 e4		 jne	 SHORT $LL20@DGAnsItemB
$LN22@DGAnsItemB:
  000c2	33 c0		 xor	 eax, eax
  000c4	eb 05		 jmp	 SHORT $LN23@DGAnsItemB
$LN21@DGAnsItemB:
  000c6	1b c0		 sbb	 eax, eax
  000c8	83 d8 ff	 sbb	 eax, -1
$LN23@DGAnsItemB:
  000cb	85 c0		 test	 eax, eax

; 325  : 				{
; 326  : 					item = this->GetByteToItem(this->m_MarketData[aIndex][i].Item);
; 327  : 
; 328  : 					BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, item);
; 329  : 
; 330  : 					GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  000cd	74 14		 je	 SHORT $LN24@DGAnsItemB

; 331  : 				}
; 332  : 				else if(this->PlayerMoney(aIndex, this->m_MarketData[aIndex][i].PriceType, this->m_MarketData[aIndex][i].Price))

  000cf	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  000d2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000d5	52		 push	 edx
  000d6	50		 push	 eax
  000d7	53		 push	 ebx
  000d8	8b cf		 mov	 ecx, edi
  000da	e8 00 00 00 00	 call	 ?PlayerMoney@CItemMarket@@QAE_NHHH@Z ; CItemMarket::PlayerMoney
  000df	84 c0		 test	 al, al
  000e1	74 63		 je	 SHORT $LN1@DGAnsItemB
$LN24@DGAnsItemB:

; 333  : 				{
; 334  : 					item = this->GetByteToItem(this->m_MarketData[aIndex][i].Item);

  000e3	83 c6 0f	 add	 esi, 15			; 0000000fH
  000e6	56		 push	 esi
  000e7	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T203768[ebp]
  000ed	51		 push	 ecx
  000ee	8b cf		 mov	 ecx, edi
  000f0	e8 00 00 00 00	 call	 ?GetByteToItem@CItemMarket@@QAE?AVCItem@@PAE@Z ; CItemMarket::GetByteToItem
  000f5	8b f0		 mov	 esi, eax
  000f7	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000fc	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR _item$203757[ebp]
  00102	f3 a5		 rep movsd

; 335  : 
; 336  : 					BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, item);

  00104	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0010a	8b f0		 mov	 esi, eax
  0010c	8b fc		 mov	 edi, esp
  0010e	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00113	f3 a5		 rep movsd
  00115	8b b5 48 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsg$GSCopy$[ebp]
  0011b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem

; 337  : 
; 338  : 					GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  00124	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00127	0f b6 c0	 movzx	 eax, al
  0012a	50		 push	 eax
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00131	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H

; 339  : 				}
; 340  : #else
; 341  : 				if(this->PlayerMoney(aIndex, this->m_MarketData[aIndex][i].PriceType, this->m_MarketData[aIndex][i].Price))
; 342  : 				{
; 343  : 					item = this->GetByteToItem(this->m_MarketData[aIndex][i].Item);
; 344  : 
; 345  : 					BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, item);
; 346  : 
; 347  : 					GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 348  : 				}
; 349  : #endif
; 350  : 				break;
; 351  : 			}
; 352  : 		}
; 353  : 
; 354  : 		// ----
; 355  : 
; 356  : 	}
; 357  : 	else

  00137	eb 0d		 jmp	 SHORT $LN1@DGAnsItemB
$LN9@DGAnsItemB:

; 358  : 	{
; 359  : 		GCServerMsgStringSend("[ItemMarket] BUY Result : 0", aIndex, 0);

  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LOKBIJMA@?$FLItemMarket?$FN?5BUY?5Result?5?3?50?$AA@
  0013e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DGAnsItemB:

; 365  : 
; 366  : 	pMsg.Result = 1;
; 367  : 
; 368  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00146	6a 08		 push	 8
  00148	8d 95 4c fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  0014e	52		 push	 edx
  0014f	53		 push	 ebx
  00150	c7 85 4c fe ff
	ff c1 08 ec 01	 mov	 DWORD PTR _pMsg$[ebp], 32245953 ; 01ec08c1H
  0015a	c7 85 50 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _pMsg$[ebp+4], 1
  00164	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@DGAnsItemB:

; 369  : }

  0016c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	33 cd		 xor	 ecx, ebp
  00173	5b		 pop	 ebx
  00174	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 04 00	 ret	 4
?DGAnsItemBuy@CItemMarket@@QAEXPAUSDHP_ANS_MARKET_BUY@@@Z ENDP ; CItemMarket::DGAnsItemBuy
_TEXT	ENDS
PUBLIC	?CGReqItemBuy@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_BUY@@H@Z ; CItemMarket::CGReqItemBuy
; Function compile flags: /Ogtp
;	COMDAT ?CGReqItemBuy@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_BUY@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqItemBuy@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_BUY@@H@Z PROC ; CItemMarket::CGReqItemBuy, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  : 	this->GDReqItemBuy(aIndex, lpMsg->ID);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00009	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	52		 push	 edx
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?GDReqItemBuy@CItemMarket@@QAEXHH@Z ; CItemMarket::GDReqItemBuy

; 249  : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?CGReqItemBuy@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_BUY@@H@Z ENDP ; CItemMarket::CGReqItemBuy
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_ItemMarket@@YAXXZ
text$yc	SEGMENT
??__Eg_ItemMarket@@YAXXZ PROC				; `dynamic initializer for 'g_ItemMarket'', COMDAT

; 14   : CItemMarket g_ItemMarket;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_ItemMarket@@YAXXZ ; `dynamic atexit destructor for 'g_ItemMarket''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Eg_ItemMarket@@YAXXZ ENDP				; `dynamic initializer for 'g_ItemMarket''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_ItemMarket@@YAXXZ
text$yd	SEGMENT
??__Fg_ItemMarket@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ItemMarket'', COMDAT
  00000	c3		 ret	 0
??__Fg_ItemMarket@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ItemMarket''
text$yd	ENDS
PUBLIC	?g_ItemMarket@@3VCItemMarket@@A			; g_ItemMarket
_BSS	SEGMENT
?g_ItemMarket@@3VCItemMarket@@A DB 03938700H DUP (?)	; g_ItemMarket
_BSS	ENDS
CRT$XCU	SEGMENT
_g_ItemMarket$initializer$ DD FLAT:??__Eg_ItemMarket@@YAXXZ
CRT$XCU	ENDS
END
