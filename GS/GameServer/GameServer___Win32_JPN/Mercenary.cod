; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\Mercenary.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetCastleState@CCastleSiegeSync@@QAEHXZ	; CCastleSiegeSync::GetCastleState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\castlesiegesync.h
;	COMDAT ?GetCastleState@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
?GetCastleState@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetCastleState, COMDAT
; _this$ = ecx

; 34   : 	int  GetCastleState(){return this->m_iCurCastleState;};	// line : 70

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetCastleState@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetCastleState
_TEXT	ENDS
PUBLIC	??_7CMercenary@@6B@				; CMercenary::`vftable'
PUBLIC	??0CMercenary@@QAE@XZ				; CMercenary::CMercenary
PUBLIC	??_R4CMercenary@@6B@				; CMercenary::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMercenary@@@8				; CMercenary `RTTI Type Descriptor'
PUBLIC	??_R3CMercenary@@8				; CMercenary::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMercenary@@8				; CMercenary::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMercenary@@8			; CMercenary::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMercenary@@UAEPAXI@Z:PROC			; CMercenary::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMercenary@@8
; File e:\work\tranet_version\gs\gameserver\mercenary.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMercenary@@8 DD FLAT:??_R0?AVCMercenary@@@8 ; CMercenary::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMercenary@@8
rdata$r	ENDS
;	COMDAT ??_R2CMercenary@@8
rdata$r	SEGMENT
??_R2CMercenary@@8 DD FLAT:??_R1A@?0A@EA@CMercenary@@8	; CMercenary::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMercenary@@8
rdata$r	SEGMENT
??_R3CMercenary@@8 DD 00H				; CMercenary::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMercenary@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMercenary@@@8
_DATA	SEGMENT
??_R0?AVCMercenary@@@8 DD FLAT:??_7type_info@@6B@	; CMercenary `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMercenary@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMercenary@@6B@
rdata$r	SEGMENT
??_R4CMercenary@@6B@ DD 00H				; CMercenary::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMercenary@@@8
	DD	FLAT:??_R3CMercenary@@8
rdata$r	ENDS
;	COMDAT ??_7CMercenary@@6B@
CONST	SEGMENT
??_7CMercenary@@6B@ DD FLAT:??_R4CMercenary@@6B@	; CMercenary::`vftable'
	DD	FLAT:??_ECMercenary@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CMercenary@@QAE@XZ
_TEXT	SEGMENT
??0CMercenary@@QAE@XZ PROC				; CMercenary::CMercenary, COMDAT
; _this$ = ecx

; 14   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMercenary@@6B@

; 15   : 	this->m_iMercenaryCount = 0;

  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 16   : }

  0000f	c3		 ret	 0
??0CMercenary@@QAE@XZ ENDP				; CMercenary::CMercenary
_TEXT	ENDS
PUBLIC	??1CMercenary@@UAE@XZ				; CMercenary::~CMercenary
; Function compile flags: /Ogtp
;	COMDAT ??1CMercenary@@UAE@XZ
_TEXT	SEGMENT
??1CMercenary@@UAE@XZ PROC				; CMercenary::~CMercenary, COMDAT
; _this$ = ecx

; 19   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMercenary@@6B@

; 20   : 	return;
; 21   : }

  00006	c3		 ret	 0
??1CMercenary@@UAE@XZ ENDP				; CMercenary::~CMercenary
_TEXT	ENDS
PUBLIC	??_C@_0EB@OMADJMIM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@ ; `string'
PUBLIC	??_C@_0FA@FFPEJJMM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@ ; `string'
PUBLIC	?CreateMercenary@CMercenary@@QAEHHHEE@Z		; CMercenary::CreateMercenary
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0EB@OMADJMIM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@
; File e:\work\tranet_version\gs\gameserver\castlesiegesync.h
CONST	SEGMENT
??_C@_0EB@OMADJMIM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@ DB '[Castle'
	DB	'Siege] Mercenary is summoned [%d] - [%d][%d] [%s][%s][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FFPEJJMM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@
CONST	SEGMENT
??_C@_0FA@FFPEJJMM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@ DB '[Castle'
	DB	'Siege] Mercenary is summoned [%d] - [%d][%d] [%s][%s][%d] - ('
	DB	'Guild : %s)', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\mercenary.cpp
CONST	ENDS
;	COMDAT ?CreateMercenary@CMercenary@@QAEHHHEE@Z
_TEXT	SEGMENT
_iMonsterIndex$ = -8					; size = 4
_lpattr$209059 = -4					; size = 4
_iIndex$ = 8						; size = 4
_iMercenaryTypeIndex$ = 12				; size = 4
_cTX$ = 16						; size = 1
_cTY$ = 20						; size = 1
?CreateMercenary@CMercenary@@QAEHHHEE@Z PROC		; CMercenary::CreateMercenary, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	LPOBJ lpObj = &gObj[iIndex];
; 26   : 	int iMonsterIndex = -1;
; 27   : 	BYTE cX = cTX;
; 28   : 	BYTE cY = cTY;
; 29   : 
; 30   : 	BYTE btMapAttr = MapC[lpObj->MapNumber].GetAttr(cX, cY);

  00003	0f b6 45 14	 movzx	 eax, BYTE PTR _cTY$[ebp]
  00007	83 ec 08	 sub	 esp, 8
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000f	57		 push	 edi
  00010	8b fe		 mov	 edi, esi
  00012	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00018	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001e	8b d9		 mov	 ebx, ecx
  00020	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cTX$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	0f b6 8f 49 01
	00 00		 movzx	 ecx, BYTE PTR [edi+329]
  0002d	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00033	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00039	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 31   : 
; 32   : 	if(btMapAttr & 16 != 16) //siege camp?
; 33   : 	{
; 34   : 		//return FALSE;
; 35   : 	}
; 36   : 
; 37   : 	if ( lpObj->MapNumber != MAP_INDEX_CASTLESIEGE )

  0003e	80 bf 49 01 00
	00 1e		 cmp	 BYTE PTR [edi+329], 30	; 0000001eH
  00045	74 24		 je	 SHORT $LN12@CreateMerc

; 38   : 	{
; 39   : 		::MsgOutput(iIndex, lMsg.Get(MSGGET(6, 91)));

  00047	68 5b 06 00 00	 push	 1627			; 0000065bH
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00051	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00056	50		 push	 eax
  00057	56		 push	 esi

; 122  : 		}
; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		::MsgOutput(iIndex, lMsg.Get(1633));

  00058	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0005d	83 c4 08	 add	 esp, 8
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi

; 127  : 		return FALSE;

  00062	33 c0		 xor	 eax, eax
  00064	5b		 pop	 ebx

; 131  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 10 00	 ret	 16			; 00000010H
$LN12@CreateMerc:

; 40   : 
; 41   : 		return FALSE;
; 42   : 	}
; 43   : 
; 44   : //#if(GS_CASTLE==1) //HermeX Decompilation 100%
; 45   : 	if(g_CastleSiegeSync.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)

  0006b	83 3d 04 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4, 7
  00072	74 24		 je	 SHORT $LN11@CreateMerc

; 46   : 	{
; 47   : 		::MsgOutput(iIndex, lMsg.Get(1630));

  00074	68 5e 06 00 00	 push	 1630			; 0000065eH
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0007e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00083	50		 push	 eax
  00084	56		 push	 esi

; 122  : 		}
; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		::MsgOutput(iIndex, lMsg.Get(1633));

  00085	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0008a	83 c4 08	 add	 esp, 8
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi

; 127  : 		return FALSE;

  0008f	33 c0		 xor	 eax, eax
  00091	5b		 pop	 ebx

; 131  : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 10 00	 ret	 16			; 00000010H
$LN11@CreateMerc:

; 48   : 		return FALSE;
; 49   : 	}
; 50   : 
; 51   : 	if( iMercenaryTypeIndex == 286 || iMercenaryTypeIndex == 287)

  00098	8b 45 0c	 mov	 eax, DWORD PTR _iMercenaryTypeIndex$[ebp]
  0009b	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  000a0	74 07		 je	 SHORT $LN9@CreateMerc
  000a2	3d 1f 01 00 00	 cmp	 eax, 287		; 0000011fH
  000a7	75 63		 jne	 SHORT $LN7@CreateMerc
$LN9@CreateMerc:

; 52   : 	{
; 53   : 		if( lpObj->m_btCsJoinSide != 1)

  000a9	80 bf 02 1c 00
	00 01		 cmp	 BYTE PTR [edi+7170], 1
  000b0	74 24		 je	 SHORT $LN8@CreateMerc

; 54   : 		{
; 55   : 			::MsgOutput(iIndex, lMsg.Get(1628));

  000b2	68 5c 06 00 00	 push	 1628			; 0000065cH
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000bc	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000c1	50		 push	 eax
  000c2	56		 push	 esi

; 122  : 		}
; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		::MsgOutput(iIndex, lMsg.Get(1633));

  000c3	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000c8	83 c4 08	 add	 esp, 8
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 127  : 		return FALSE;

  000cd	33 c0		 xor	 eax, eax
  000cf	5b		 pop	 ebx

; 131  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 10 00	 ret	 16			; 00000010H
$LN8@CreateMerc:

; 56   : 			return FALSE;
; 57   : 		}
; 58   : 		if(lpObj->GuildStatus != G_MASTER && lpObj->GuildStatus != G_SUB_MASTER)

  000d6	8b 87 48 04 00
	00		 mov	 eax, DWORD PTR [edi+1096]
  000dc	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000e1	74 29		 je	 SHORT $LN7@CreateMerc
  000e3	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e6	74 24		 je	 SHORT $LN7@CreateMerc

; 59   : 		{
; 60   : 			::MsgOutput(iIndex, lMsg.Get(1629));

  000e8	68 5d 06 00 00	 push	 1629			; 0000065dH
  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000f7	50		 push	 eax
  000f8	56		 push	 esi

; 122  : 		}
; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		::MsgOutput(iIndex, lMsg.Get(1633));

  000f9	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000fe	83 c4 08	 add	 esp, 8
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 127  : 		return FALSE;

  00103	33 c0		 xor	 eax, eax
  00105	5b		 pop	 ebx

; 131  : }

  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 10 00	 ret	 16			; 00000010H
$LN7@CreateMerc:

; 61   : 				return FALSE;
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	if( this->m_iMercenaryCount > 100 )

  0010c	83 7b 04 64	 cmp	 DWORD PTR [ebx+4], 100	; 00000064H
  00110	7e 24		 jle	 SHORT $LN6@CreateMerc

; 66   : 	{
; 67   : 		::MsgOutput(iIndex, lMsg.Get(1631));

  00112	68 5f 06 00 00	 push	 1631			; 0000065fH
  00117	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00121	50		 push	 eax
  00122	56		 push	 esi

; 122  : 		}
; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		::MsgOutput(iIndex, lMsg.Get(1633));

  00123	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00128	83 c4 08	 add	 esp, 8
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi

; 127  : 		return FALSE;

  0012d	33 c0		 xor	 eax, eax
  0012f	5b		 pop	 ebx

; 131  : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 10 00	 ret	 16			; 00000010H
$LN6@CreateMerc:

; 68   : 		return FALSE;
; 69   : 	}
; 70   : 
; 71   : 	iMonsterIndex = gObjAddMonster(lpObj->MapNumber);

  00136	6a 1e		 push	 30			; 0000001eH
  00138	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0013d	0f bf f0	 movsx	 esi, ax
  00140	83 c4 04	 add	 esp, 4
  00143	89 75 f8	 mov	 DWORD PTR _iMonsterIndex$[ebp], esi

; 72   : 
; 73   : 	if(iMonsterIndex >= 0)

  00146	85 f6		 test	 esi, esi
  00148	0f 88 58 02 00
	00		 js	 $LN5@CreateMerc

; 74   : 	{
; 75   : 		LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(iMercenaryTypeIndex);

  0014e	8b 55 0c	 mov	 edx, DWORD PTR _iMercenaryTypeIndex$[ebp]
  00151	52		 push	 edx
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00157	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  0015c	89 45 fc	 mov	 DWORD PTR _lpattr$209059[ebp], eax

; 76   : 
; 77   : 		if(lpattr == NULL)

  0015f	85 c0		 test	 eax, eax
  00161	75 14		 jne	 SHORT $LN4@CreateMerc

; 78   : 		{
; 79   : 			gObjDel(iMonsterIndex);

  00163	56		 push	 esi
  00164	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00169	83 c4 04	 add	 esp, 4
  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi

; 127  : 		return FALSE;

  0016e	33 c0		 xor	 eax, eax
  00170	5b		 pop	 ebx

; 131  : }

  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c2 10 00	 ret	 16			; 00000010H
$LN4@CreateMerc:

; 80   : 			return FALSE;
; 81   : 		}
; 82   : 
; 83   : 		gObjSetMonster(iMonsterIndex, iMercenaryTypeIndex);

  00177	8b 45 0c	 mov	 eax, DWORD PTR _iMercenaryTypeIndex$[ebp]
  0017a	50		 push	 eax
  0017b	56		 push	 esi
  0017c	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 84   : 
; 85   : 		gObj[iMonsterIndex].Live = 1;

  00181	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018d	c6 44 0e 6a 01	 mov	 BYTE PTR [esi+ecx+106], 1

; 86   : 		gObj[iMonsterIndex].Life = lpattr->m_Hp;

  00192	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00198	8b 45 fc	 mov	 eax, DWORD PTR _lpattr$209059[ebp]

; 87   : 		gObj[iMonsterIndex].MaxLife = lpattr->m_Hp;
; 88   : 		gObj[iMonsterIndex].m_PosNum = -1;

  0019b	83 c9 ff	 or	 ecx, -1
  0019e	83 c4 08	 add	 esp, 8
  001a1	db 40 28	 fild	 DWORD PTR [eax+40]
  001a4	d9 9c 16 fc 00
	00 00		 fstp	 DWORD PTR [esi+edx+252]
  001ab	db 40 28	 fild	 DWORD PTR [eax+40]
  001ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b3	d9 9c 06 00 01
	00 00		 fstp	 DWORD PTR [esi+eax+256]
  001ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c0	66 89 8c 16 b0
	03 00 00	 mov	 WORD PTR [esi+edx+944], cx

; 89   : 		gObj[iMonsterIndex].X = cX;

  001c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ce	0f b6 45 10	 movzx	 eax, BYTE PTR _cTX$[ebp]
  001d2	66 89 84 0e 44
	01 00 00	 mov	 WORD PTR [esi+ecx+324], ax

; 90   : 		gObj[iMonsterIndex].Y = cY;

  001da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e0	0f b6 4d 14	 movzx	 ecx, BYTE PTR _cTY$[ebp]
  001e4	66 89 8c 16 46
	01 00 00	 mov	 WORD PTR [esi+edx+326], cx

; 91   : 		gObj[iMonsterIndex].MTX = cX;

  001ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f2	66 89 84 16 80
	01 00 00	 mov	 WORD PTR [esi+edx+384], ax

; 92   : 		gObj[iMonsterIndex].MTY = cY;

  001fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00200	66 89 8c 16 82
	01 00 00	 mov	 WORD PTR [esi+edx+386], cx

; 93   : 		gObj[iMonsterIndex].TX = cX;

  00208	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020e	66 89 84 16 7c
	01 00 00	 mov	 WORD PTR [esi+edx+380], ax

; 94   : 		gObj[iMonsterIndex].TY = cY;

  00216	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021c	66 89 8c 16 7e
	01 00 00	 mov	 WORD PTR [esi+edx+382], cx

; 95   : 		gObj[iMonsterIndex].m_OldX = cX;

  00224	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022a	66 89 84 16 78
	01 00 00	 mov	 WORD PTR [esi+edx+376], ax

; 96   : 		gObj[iMonsterIndex].m_OldY = cY;

  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 97   : 		gObj[iMonsterIndex].StartX = cX;

  00237	8a 55 10	 mov	 dl, BYTE PTR _cTX$[ebp]
  0023a	66 89 8c 06 7a
	01 00 00	 mov	 WORD PTR [esi+eax+378], cx
  00242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00248	88 94 0e 76 01
	00 00		 mov	 BYTE PTR [esi+ecx+374], dl

; 98   : 		gObj[iMonsterIndex].StartY = cY;

  0024f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00254	8a 4d 14	 mov	 cl, BYTE PTR _cTY$[ebp]
  00257	88 8c 06 77 01
	00 00		 mov	 BYTE PTR [esi+eax+375], cl

; 99   : 		gObj[iMonsterIndex].MapNumber = lpObj->MapNumber;

  0025e	0f b6 97 49 01
	00 00		 movzx	 edx, BYTE PTR [edi+329]
  00265	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026a	88 94 06 49 01
	00 00		 mov	 BYTE PTR [esi+eax+329], dl

; 100  : 		gObj[iMonsterIndex].m_MoveRange = 0;

  00271	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 101  : 		gObj[iMonsterIndex].Level = lpattr->m_Level;

  00277	8b 45 fc	 mov	 eax, DWORD PTR _lpattr$209059[ebp]
  0027a	33 c9		 xor	 ecx, ecx
  0027c	66 89 8c 16 ae
	04 00 00	 mov	 WORD PTR [esi+edx+1198], cx
  00284	0f b7 48 1c	 movzx	 ecx, WORD PTR [eax+28]
  00288	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028e	66 89 8c 16 be
	00 00 00	 mov	 WORD PTR [esi+edx+190], cx

; 102  : 		gObj[iMonsterIndex].Type = OBJ_MONSTER;

  00296	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029c	b8 02 00 00 00	 mov	 eax, 2
  002a1	66 89 44 0e 68	 mov	 WORD PTR [esi+ecx+104], ax

; 103  : 		gObj[iMonsterIndex].MaxRegenTime = 1000;

  002a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ac	c7 84 16 ac 03
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+940], 1000 ; 000003e8H

; 104  : 		gObj[iMonsterIndex].Dir = 1;

  002b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bc	c6 84 06 48 01
	00 00 01	 mov	 BYTE PTR [esi+eax+328], 1

; 105  : 		gObj[iMonsterIndex].RegenTime = GetTickCount();

  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d0	89 84 0e a8 03
	00 00		 mov	 DWORD PTR [esi+ecx+936], eax

; 106  : 		gObj[iMonsterIndex].m_Attribute = 0;

  002d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002dc	33 d2		 xor	 edx, edx
  002de	66 89 94 06 b6
	04 00 00	 mov	 WORD PTR [esi+eax+1206], dx

; 107  : 		gObj[iMonsterIndex].DieRegen = 0;

  002e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ec	88 94 0e a2 03
	00 00		 mov	 BYTE PTR [esi+ecx+930], dl

; 108  : 		gObj[iMonsterIndex].m_btCsNpcType = 2;

  002f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f9	c6 84 16 f8 1b
	00 00 02	 mov	 BYTE PTR [esi+edx+7160], 2

; 109  : 		gObj[iMonsterIndex].m_btCsJoinSide = 1;

  00301	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 110  : 
; 111  : 		::MsgOutput(iIndex, lMsg.Get(1632));

  00306	68 60 06 00 00	 push	 1632			; 00000660H
  0030b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00310	c6 84 06 02 1c
	00 00 01	 mov	 BYTE PTR [esi+eax+7170], 1
  00318	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0031d	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00320	50		 push	 eax
  00321	51		 push	 ecx
  00322	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00327	83 c4 08	 add	 esp, 8

; 112  : 
; 113  : 		this->m_iMercenaryCount++;

  0032a	ff 43 04	 inc	 DWORD PTR [ebx+4]
  0032d	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]

; 114  : 
; 115  : 		if(lpObj->lpGuild != NULL)

  00330	8b 87 38 04 00
	00		 mov	 eax, DWORD PTR [edi+1080]
  00336	85 c0		 test	 eax, eax
  00338	74 38		 je	 SHORT $LN3@CreateMerc

; 116  : 		{
; 117  : 			LogAddTD("[CastleSiege] Mercenary is summoned [%d] - [%d][%d] [%s][%s][%d] - (Guild : %s)",iMonsterIndex, iMercenaryTypeIndex,this->m_iMercenaryCount,lpObj->AccountID,lpObj->Name,lpObj->GuildStatus,lpObj->lpGuild->Name);

  0033a	8b 97 48 04 00
	00		 mov	 edx, DWORD PTR [edi+1096]
  00340	8b 4d 0c	 mov	 ecx, DWORD PTR _iMercenaryTypeIndex$[ebp]
  00343	83 c0 04	 add	 eax, 4
  00346	50		 push	 eax
  00347	52		 push	 edx
  00348	8b 55 f8	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  0034b	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  0034e	50		 push	 eax
  0034f	83 c7 6c	 add	 edi, 108		; 0000006cH
  00352	57		 push	 edi
  00353	53		 push	 ebx
  00354	51		 push	 ecx
  00355	52		 push	 edx
  00356	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@FFPEJJMM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@
  0035b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00361	83 c4 20	 add	 esp, 32			; 00000020H
  00364	5f		 pop	 edi
  00365	5e		 pop	 esi

; 128  : 	}
; 129  : //#endif
; 130  : 	return TRUE;

  00366	b8 01 00 00 00	 mov	 eax, 1
  0036b	5b		 pop	 ebx

; 131  : }

  0036c	8b e5		 mov	 esp, ebp
  0036e	5d		 pop	 ebp
  0036f	c2 10 00	 ret	 16			; 00000010H
$LN3@CreateMerc:

; 118  : 		}
; 119  : 		else
; 120  : 		{
; 121  : 			LogAddTD("[CastleSiege] Mercenary is summoned [%d] - [%d][%d] [%s][%s][%d]",iMonsterIndex, iMercenaryTypeIndex,this->m_iMercenaryCount,lpObj->AccountID,lpObj->Name,lpObj->GuildStatus);

  00372	8b 87 48 04 00
	00		 mov	 eax, DWORD PTR [edi+1096]
  00378	8b 55 0c	 mov	 edx, DWORD PTR _iMercenaryTypeIndex$[ebp]
  0037b	50		 push	 eax
  0037c	8b 45 f8	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  0037f	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  00382	51		 push	 ecx
  00383	83 c7 6c	 add	 edi, 108		; 0000006cH
  00386	57		 push	 edi
  00387	53		 push	 ebx
  00388	52		 push	 edx
  00389	50		 push	 eax
  0038a	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@OMADJMIM@?$FLCastleSiege?$FN?5Mercenary?5is?5summo@
  0038f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00395	83 c4 1c	 add	 esp, 28			; 0000001cH
  00398	5f		 pop	 edi
  00399	5e		 pop	 esi

; 128  : 	}
; 129  : //#endif
; 130  : 	return TRUE;

  0039a	b8 01 00 00 00	 mov	 eax, 1
  0039f	5b		 pop	 ebx

; 131  : }

  003a0	8b e5		 mov	 esp, ebp
  003a2	5d		 pop	 ebp
  003a3	c2 10 00	 ret	 16			; 00000010H
$LN5@CreateMerc:

; 122  : 		}
; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		::MsgOutput(iIndex, lMsg.Get(1633));

  003a6	68 61 06 00 00	 push	 1633			; 00000661H
  003ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003b0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003b5	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  003b8	50		 push	 eax
  003b9	51		 push	 ecx
  003ba	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  003bf	83 c4 08	 add	 esp, 8
  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi

; 127  : 		return FALSE;

  003c4	33 c0		 xor	 eax, eax
  003c6	5b		 pop	 ebx

; 131  : }

  003c7	8b e5		 mov	 esp, ebp
  003c9	5d		 pop	 ebp
  003ca	c2 10 00	 ret	 16			; 00000010H
?CreateMercenary@CMercenary@@QAEHHHEE@Z ENDP		; CMercenary::CreateMercenary
_TEXT	ENDS
PUBLIC	??_C@_0CO@NHOFBALN@?$FLCastleSiege?$FN?5Mercenary?5is?5broke@ ; `string'
PUBLIC	?DeleteMercenary@CMercenary@@QAEHH@Z		; CMercenary::DeleteMercenary
;	COMDAT ??_C@_0CO@NHOFBALN@?$FLCastleSiege?$FN?5Mercenary?5is?5broke@
CONST	SEGMENT
??_C@_0CO@NHOFBALN@?$FLCastleSiege?$FN?5Mercenary?5is?5broke@ DB '[Castle'
	DB	'Siege] Mercenary is broken [%d] - [%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DeleteMercenary@CMercenary@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?DeleteMercenary@CMercenary@@QAEHH@Z PROC		; CMercenary::DeleteMercenary, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 136  : 	if ( iIndex < 0 || iIndex > OBJMAX-1 )

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00009	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0000f	77 2d		 ja	 SHORT $LN2@DeleteMerc

; 139  : 	}
; 140  : 
; 141  : 	this->m_iMercenaryCount--;

  00011	ff 4e 04	 dec	 DWORD PTR [esi+4]
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 142  : 
; 143  : 	LogAddTD("[CastleSiege] Mercenary is broken [%d] - [%d]", iIndex, this->m_iMercenaryCount);

  00017	50		 push	 eax
  00018	51		 push	 ecx
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@NHOFBALN@?$FLCastleSiege?$FN?5Mercenary?5is?5broke@
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 
; 145  : 	if ( this->m_iMercenaryCount < 0 )

  00027	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0002b	7d 07		 jge	 SHORT $LN1@DeleteMerc

; 146  : 	{
; 147  : 		this->m_iMercenaryCount = 0;

  0002d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN1@DeleteMerc:

; 148  : 	}
; 149  : 
; 150  : 	return TRUE;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	5e		 pop	 esi

; 151  : }

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN2@DeleteMerc:

; 137  : 	{
; 138  : 		return FALSE;

  0003e	33 c0		 xor	 eax, eax
  00040	5e		 pop	 esi

; 151  : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?DeleteMercenary@CMercenary@@QAEHH@Z ENDP		; CMercenary::DeleteMercenary
_TEXT	ENDS
PUBLIC	?SearchEnemy@CMercenary@@QAEHPAUOBJECTSTRUCT@@@Z ; CMercenary::SearchEnemy
EXTRN	__ftol2_sse:PROC
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SearchEnemy@CMercenary@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv382 = -24						; size = 4
_iTargetNumber$ = -20					; size = 4
_i$ = -16						; size = 4
tv397 = -12						; size = 4
_iAttackRange$ = -8					; size = 4
tv320 = -1						; size = 1
_lpObj$ = 8						; size = 4
?SearchEnemy@CMercenary@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CMercenary::SearchEnemy, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 158  : //#if(GS_CASTLE==1)
; 159  : 	int iTargetNumber = -1;
; 160  : 	int iAttackRange = 0;
; 161  : 
; 162  : 	lpObj->TargetNumber = -1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00009	83 c9 ff	 or	 ecx, -1
  0000c	53		 push	 ebx
  0000d	66 89 88 58 04
	00 00		 mov	 WORD PTR [eax+1112], cx

; 163  : 
; 164  : 	if(lpObj->Class == 286)

  00014	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0001b	56		 push	 esi
  0001c	33 d2		 xor	 edx, edx
  0001e	be 1e 01 00 00	 mov	 esi, 286		; 0000011eH
  00023	57		 push	 edi
  00024	89 55 f8	 mov	 DWORD PTR _iAttackRange$[ebp], edx
  00027	66 3b ce	 cmp	 cx, si
  0002a	75 09		 jne	 SHORT $LN14@SearchEnem

; 165  : 	{
; 166  : 		iAttackRange = 5;

  0002c	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _iAttackRange$[ebp], 5
  00033	eb 11		 jmp	 SHORT $LN12@SearchEnem
$LN14@SearchEnem:

; 167  : 	}
; 168  : 	else if(lpObj->Class == 287)

  00035	be 1f 01 00 00	 mov	 esi, 287		; 0000011fH
  0003a	66 3b ce	 cmp	 cx, si
  0003d	75 07		 jne	 SHORT $LN12@SearchEnem

; 169  : 	{
; 170  : 		iAttackRange = 3;

  0003f	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _iAttackRange$[ebp], 3
$LN12@SearchEnem:

; 171  : 	}
; 172  : 
; 173  : 	int i;
; 174  : 	for(i = 0; i < MAX_VIEWPORT; i++)

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
  0004f	8d 90 b4 08 00
	00		 lea	 edx, DWORD PTR [eax+2228]
  00055	89 55 f4	 mov	 DWORD PTR tv397[ebp], edx
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL27@SearchEnem:

; 175  : 	{
; 176  : 		iTargetNumber = lpObj->VpPlayer2[i].number;

  00060	8b 55 f4	 mov	 edx, DWORD PTR tv397[ebp]
  00063	0f bf 72 fa	 movsx	 esi, WORD PTR [edx-6]
  00067	89 75 ec	 mov	 DWORD PTR _iTargetNumber$[ebp], esi

; 177  : 
; 178  : 		if(iTargetNumber >= 0 && gObj[iTargetNumber].Type == 1 && gObj[iTargetNumber].Live != FALSE && gObj[iTargetNumber].Teleport == FALSE)

  0006a	85 f6		 test	 esi, esi
  0006c	0f 88 0b 01 00
	00		 js	 $LN10@SearchEnem
  00072	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00078	66 83 7c 0e 68
	01		 cmp	 WORD PTR [esi+ecx+104], 1
  0007e	0f 85 f9 00 00
	00		 jne	 $LN10@SearchEnem
  00084	80 7c 0e 6a 00	 cmp	 BYTE PTR [esi+ecx+106], 0
  00089	0f 84 ee 00 00
	00		 je	 $LN10@SearchEnem
  0008f	80 bc 0e a0 03
	00 00 00	 cmp	 BYTE PTR [esi+ecx+928], 0
  00097	0f 85 e0 00 00
	00		 jne	 $LN10@SearchEnem

; 179  : 		{
; 180  : 			if(gObj[iTargetNumber].m_btCsJoinSide == lpObj->m_btCsJoinSide)

  0009d	8a 94 0e 02 1c
	00 00		 mov	 dl, BYTE PTR [esi+ecx+7170]
  000a4	3a 90 02 1c 00
	00		 cmp	 dl, BYTE PTR [eax+7170]
  000aa	0f 84 cd 00 00
	00		 je	 $LN10@SearchEnem

; 181  : 			{
; 182  : 				continue;
; 183  : 			}
; 184  : 
; 185  : 			//Mr.Marin Decompilation 100%
; 186  : 			int iTargetDisX = lpObj->X - gObj[iTargetNumber].X;

  000b0	0f bf 94 0e 44
	01 00 00	 movsx	 edx, WORD PTR [esi+ecx+324]
  000b8	0f bf b8 44 01
	00 00		 movsx	 edi, WORD PTR [eax+324]

; 187  : 			int iTargetDisY = lpObj->Y - gObj[iTargetNumber].Y;

  000bf	0f bf 98 46 01
	00 00		 movsx	 ebx, WORD PTR [eax+326]
  000c6	0f bf 8c 0e 46
	01 00 00	 movsx	 ecx, WORD PTR [esi+ecx+326]
  000ce	2b fa		 sub	 edi, edx
  000d0	2b d9		 sub	 ebx, ecx

; 188  : 			int iTargetDist;
; 189  : 			int cY;
; 190  : 			int cX;
; 191  : 			int SquareDist = (iTargetDisX*iTargetDisX)+(iTargetDisY*iTargetDisY);

  000d2	8b d3		 mov	 edx, ebx
  000d4	8b c7		 mov	 eax, edi
  000d6	0f af d3	 imul	 edx, ebx
  000d9	0f af c7	 imul	 eax, edi
  000dc	03 d0		 add	 edx, eax

; 192  : 
; 193  : 			iTargetDist = (long)sqrt((double)SquareDist);
; 194  : 			
; 195  : 			lpObj->VpPlayer2[i].dis = iTargetDist;

  000de	89 55 e8	 mov	 DWORD PTR tv382[ebp], edx
  000e1	db 45 e8	 fild	 DWORD PTR tv382[ebp]
  000e4	e8 00 00 00 00	 call	 __CIsqrt
  000e9	e8 00 00 00 00	 call	 __ftol2_sse
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR tv397[ebp]

; 196  : 
; 197  : 			if(lpObj->Dir == 1 && abs(iTargetDisX) <= 2)

  000f1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f4	89 01		 mov	 DWORD PTR [ecx], eax
  000f6	8a 82 48 01 00
	00		 mov	 al, BYTE PTR [edx+328]
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00102	88 45 ff	 mov	 BYTE PTR tv320[ebp], al
  00105	3c 01		 cmp	 al, 1
  00107	75 3d		 jne	 SHORT $LN4@SearchEnem
  00109	8b c7		 mov	 eax, edi
  0010b	99		 cdq
  0010c	33 c2		 xor	 eax, edx
  0010e	2b c2		 sub	 eax, edx
  00110	83 f8 02	 cmp	 eax, 2
  00113	7f 2e		 jg	 SHORT $LN26@SearchEnem

; 198  : 			{
; 199  : 				cY = lpObj->Y - iAttackRange;

  00115	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00118	0f b7 92 46 01
	00 00		 movzx	 edx, WORD PTR [edx+326]

; 200  : 				if(cY <= gObj[iTargetNumber].Y)

  0011f	0f b7 84 0e 46
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+326]
  00127	0f bf d2	 movsx	 edx, dx
  0012a	2b 55 f8	 sub	 edx, DWORD PTR _iAttackRange$[ebp]
  0012d	0f bf f8	 movsx	 edi, ax
  00130	3b d7		 cmp	 edx, edi
  00132	7f 0f		 jg	 SHORT $LN26@SearchEnem

; 201  : 				{
; 202  : 					if(lpObj->Y >= gObj[iTargetNumber].Y)

  00134	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00137	0f b7 97 46 01
	00 00		 movzx	 edx, WORD PTR [edi+326]
  0013e	66 3b d0	 cmp	 dx, ax
  00141	7d 59		 jge	 SHORT $LN18@SearchEnem
$LN26@SearchEnem:
  00143	8a 45 ff	 mov	 al, BYTE PTR tv320[ebp]
$LN4@SearchEnem:

; 206  : 					}
; 207  : 				}
; 208  : 			}
; 209  : 
; 210  : 			if(lpObj->Dir == 3 && abs(iTargetDisY) <= 2)

  00146	3c 03		 cmp	 al, 3
  00148	75 30		 jne	 SHORT $LN24@SearchEnem
  0014a	8b c3		 mov	 eax, ebx
  0014c	99		 cdq
  0014d	33 c2		 xor	 eax, edx
  0014f	2b c2		 sub	 eax, edx
  00151	83 f8 02	 cmp	 eax, 2
  00154	7f 24		 jg	 SHORT $LN24@SearchEnem

; 211  : 			{
; 212  : 				cX = lpObj->X - iAttackRange;

  00156	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00159	0f b7 92 44 01
	00 00		 movzx	 edx, WORD PTR [edx+324]

; 213  : 				if(cX <= gObj[iTargetNumber].X)

  00160	0f b7 84 0e 44
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+324]
  00168	0f bf f2	 movsx	 esi, dx
  0016b	2b 75 f8	 sub	 esi, DWORD PTR _iAttackRange$[ebp]
  0016e	0f bf f8	 movsx	 edi, ax
  00171	3b f7		 cmp	 esi, edi
  00173	7f 05		 jg	 SHORT $LN24@SearchEnem

; 214  : 				{
; 215  : 					if(lpObj->X >= gObj[iTargetNumber].X)

  00175	66 3b d0	 cmp	 dx, ax
  00178	7d 3b		 jge	 SHORT $LN19@SearchEnem
$LN24@SearchEnem:
  0017a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
$LN10@SearchEnem:

; 171  : 	}
; 172  : 
; 173  : 	int i;
; 174  : 	for(i = 0; i < MAX_VIEWPORT; i++)

  0017d	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00180	83 45 f4 0c	 add	 DWORD PTR tv397[ebp], 12 ; 0000000cH
  00184	42		 inc	 edx
  00185	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
  00188	83 fa 4b	 cmp	 edx, 75			; 0000004bH
  0018b	0f 8c cf fe ff
	ff		 jl	 $LL27@SearchEnem

; 219  : 					}
; 220  : 				}
; 221  : 			}
; 222  : 
; 223  : 		}
; 224  : 
; 225  : 
; 226  : 	}
; 227  : //#endif
; 228  : 	return 0;

  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	33 c0		 xor	 eax, eax
  00195	5b		 pop	 ebx

; 229  : }

  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 04 00	 ret	 4
$LN18@SearchEnem:

; 203  : 					{
; 204  : 						lpObj->TargetNumber = iTargetNumber;

  0019c	66 8b 45 ec	 mov	 ax, WORD PTR _iTargetNumber$[ebp]
  001a0	66 89 87 58 04
	00 00		 mov	 WORD PTR [edi+1112], ax
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi

; 205  : 						return 1;

  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	5b		 pop	 ebx

; 229  : }

  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c2 04 00	 ret	 4
$LN19@SearchEnem:

; 216  : 					{
; 217  : 						lpObj->TargetNumber = iTargetNumber;

  001b5	66 8b 4d ec	 mov	 cx, WORD PTR _iTargetNumber$[ebp]
  001b9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	66 89 8a 58 04
	00 00		 mov	 WORD PTR [edx+1112], cx

; 218  : 						return 1;

  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	5b		 pop	 ebx

; 229  : }

  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c2 04 00	 ret	 4
?SearchEnemy@CMercenary@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CMercenary::SearchEnemy
_TEXT	ENDS
PUBLIC	?MercenaryAct@CMercenary@@QAEXH@Z		; CMercenary::MercenaryAct
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?MercenaryAct@CMercenary@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?MercenaryAct@CMercenary@@QAEXH@Z PROC			; CMercenary::MercenaryAct, COMDAT
; _this$ = ecx

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 236  : 	if ( ::gObjIsConnected(iIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	74 51		 je	 SHORT $LN1@MercenaryA

; 237  : 	{
; 238  : 		return;
; 239  : 	}
; 240  : 
; 241  : 	LPOBJ lpObj = &gObj[iIndex];

  00017	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 242  : 
; 243  : 
; 244  : 	if ( lpObj->VPCount2 < 1 )

  00023	83 be 34 0c 00
	00 01		 cmp	 DWORD PTR [esi+3124], 1
  0002a	7c 3c		 jl	 SHORT $LN1@MercenaryA

; 245  : 	{
; 246  : 		return;
; 247  : 	}
; 248  : 
; 249  : 	if ( this->SearchEnemy(lpObj) != 0 && lpObj->TargetNumber >= 0)

  0002c	56		 push	 esi
  0002d	8b cf		 mov	 ecx, edi
  0002f	e8 00 00 00 00	 call	 ?SearchEnemy@CMercenary@@QAEHPAUOBJECTSTRUCT@@@Z ; CMercenary::SearchEnemy
  00034	85 c0		 test	 eax, eax
  00036	74 23		 je	 SHORT $LN2@MercenaryA
  00038	66 83 be 58 04
	00 00 00	 cmp	 WORD PTR [esi+1112], 0
  00040	7c 19		 jl	 SHORT $LN2@MercenaryA

; 250  : 	{
; 251  : 		lpObj->m_ActState.Attack = 1;
; 252  : 		lpObj->NextActionTime = lpObj->m_AttackSpeed;

  00042	8b 86 8c 04 00
	00		 mov	 eax, DWORD PTR [esi+1164]
  00048	83 8e 18 02 00
	00 02		 or	 DWORD PTR [esi+536], 2
  0004f	5f		 pop	 edi
  00050	89 86 bc 03 00
	00		 mov	 DWORD PTR [esi+956], eax
  00056	5e		 pop	 esi

; 257  : 	}
; 258  : }

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN2@MercenaryA:

; 253  : 	}
; 254  : 	else
; 255  : 	{
; 256  : 		lpObj->NextActionTime = lpObj->m_MoveSpeed;

  0005b	0f bf 8e ac 04
	00 00		 movsx	 ecx, WORD PTR [esi+1196]
  00062	89 8e bc 03 00
	00		 mov	 DWORD PTR [esi+956], ecx
$LN1@MercenaryA:
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 257  : 	}
; 258  : }

  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?MercenaryAct@CMercenary@@QAEXH@Z ENDP			; CMercenary::MercenaryAct
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCMercenary@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMercenary@@UAEPAXI@Z PROC				; CMercenary::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMercenary@@UAE@XZ	; CMercenary::~CMercenary
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMercenary@@UAEPAXI@Z ENDP				; CMercenary::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_CsNPC_Mercenary@@YAXXZ
text$yc	SEGMENT
??__Eg_CsNPC_Mercenary@@YAXXZ PROC			; `dynamic initializer for 'g_CsNPC_Mercenary'', COMDAT

; 11   : CMercenary g_CsNPC_Mercenary;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  00005	e8 00 00 00 00	 call	 ??0CMercenary@@QAE@XZ	; CMercenary::CMercenary
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_CsNPC_Mercenary@@YAXXZ ; `dynamic atexit destructor for 'g_CsNPC_Mercenary''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_CsNPC_Mercenary@@YAXXZ ENDP			; `dynamic initializer for 'g_CsNPC_Mercenary''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_CsNPC_Mercenary@@YAXXZ
text$yd	SEGMENT
??__Fg_CsNPC_Mercenary@@YAXXZ PROC			; `dynamic atexit destructor for 'g_CsNPC_Mercenary'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  00005	e9 00 00 00 00	 jmp	 ??1CMercenary@@UAE@XZ	; CMercenary::~CMercenary
??__Fg_CsNPC_Mercenary@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_CsNPC_Mercenary''
text$yd	ENDS
PUBLIC	?g_CsNPC_Mercenary@@3VCMercenary@@A		; g_CsNPC_Mercenary
_BSS	SEGMENT
?g_CsNPC_Mercenary@@3VCMercenary@@A DQ 01H DUP (?)	; g_CsNPC_Mercenary
_BSS	ENDS
CRT$XCU	SEGMENT
_g_CsNPC_Mercenary$initializer$ DD FLAT:??__Eg_CsNPC_Mercenary@@YAXXZ
CRT$XCU	ENDS
END
