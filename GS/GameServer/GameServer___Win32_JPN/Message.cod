; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\Message.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 80   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 82   : 		lpBuf[1] = size;

  00006	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]

; 83   : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  0000f	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00012	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 84   : 	};	// line : 22

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MsgNormal@@YAXHPADZZ				; MsgNormal
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	_vsprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\message.cpp
;	COMDAT ?MsgNormal@@YAXHPADZZ
_TEXT	SEGMENT
_szTemp$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szMsg$ = 12						; size = 4
?MsgNormal@@YAXHPADZZ PROC				; MsgNormal, COMDAT

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10   : #if(ENABLE_TEXTCHANGE)
; 11   : 	if(g_ZtLicense.CheckUser(eZtUB::masonX) || g_ZtLicense.CheckUser(eZtUB::Local))
; 12   : 	{
; 13   : 		szMsg = g_Text.Change(szMsg);
; 14   : 	}
; 15   : #endif
; 16   : 
; 17   : 	char szTemp[1024];
; 18   : 	va_list pArguments;
; 19   : 	va_start(pArguments,szMsg);
; 20   : 	vsprintf(szTemp,szMsg,pArguments);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _szMsg$[ebp]
  00016	8d 45 10	 lea	 eax, DWORD PTR _szMsg$[ebp+4]
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _vsprintf

; 21   : 	va_end(pArguments);
; 22   : 	
; 23   : 	GCServerMsgStringSend(szTemp, aIndex,1); // 0 = Global MSG; 1 = System information; 2 = Guild notice

  00027	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002a	6a 01		 push	 1
  0002c	50		 push	 eax
  0002d	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 24   : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	33 cd		 xor	 ecx, ebp
  0003e	83 c4 18	 add	 esp, 24			; 00000018H
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?MsgNormal@@YAXHPADZZ ENDP				; MsgNormal
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MessageChat@@YAXHPADZZ				; MessageChat
EXTRN	_free:PROC
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	_malloc:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?MessageChat@@YAXHPADZZ
_TEXT	SEGMENT
_Message$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szMsg$ = 12						; size = 4
?MessageChat@@YAXHPADZZ PROC				; MessageChat, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 29   : #if(ENABLE_TEXTCHANGE)
; 30   : 	if(g_ZtLicense.CheckUser(eZtUB::masonX) || g_ZtLicense.CheckUser(eZtUB::Local))
; 31   : 	{
; 32   : 		szMsg = g_Text.Change(szMsg);
; 33   : 	}
; 34   : #endif
; 35   : 
; 36   : 	char Message[1024];
; 37   : 	va_list pArguments;
; 38   :     va_start(pArguments,szMsg);
; 39   : 	//vsprintf_s(Message,sizeof(Message), szMsg, pArguments);
; 40   : 	vsprintf(Message,szMsg,pArguments);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _szMsg$[ebp]
  00016	56		 push	 esi
  00017	8d 45 10	 lea	 eax, DWORD PTR _szMsg$[ebp+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _Message$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _vsprintf

; 41   : 	va_end(pArguments);
; 42   : 	BYTE *Packet;
; 43   : 	Packet = (BYTE*) malloc(200);

  00028	68 c8 00 00 00	 push	 200			; 000000c8H
  0002d	e8 00 00 00 00	 call	 _malloc

; 44   : 	memset(Packet, 0x00, 200);

  00032	68 c8 00 00 00	 push	 200			; 000000c8H
  00037	8b f0		 mov	 esi, eax
  00039	6a 00		 push	 0
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memset

; 45   : 	*Packet = 0xC1;
; 46   : 	*(Packet+2) = 0x00;
; 47   : 	memcpy((Packet+13), Message, strlen(Message));

  00041	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _Message$[ebp]
  00047	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004a	c6 06 c1	 mov	 BYTE PTR [esi], 193	; 000000c1H
  0004d	c6 46 02 00	 mov	 BYTE PTR [esi+2], 0
  00051	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL3@MessageCha:
  00054	8a 08		 mov	 cl, BYTE PTR [eax]
  00056	40		 inc	 eax
  00057	84 c9		 test	 cl, cl
  00059	75 f9		 jne	 SHORT $LL3@MessageCha
  0005b	2b c2		 sub	 eax, edx
  0005d	50		 push	 eax
  0005e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _Message$[ebp]
  00064	50		 push	 eax
  00065	8d 4e 0d	 lea	 ecx, DWORD PTR [esi+13]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy

; 48   : 	int Len = (strlen(Message) + 0x13);

  0006e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _Message$[ebp]
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL4@MessageCha:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $LL4@MessageCha
  00087	2b c2		 sub	 eax, edx

; 49   : 	*(Packet+1) = Len;
; 50   : 	DataSend(aIndex,Packet, Len);

  00089	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0008c	83 c0 13	 add	 eax, 19			; 00000013H
  0008f	50		 push	 eax
  00090	56		 push	 esi
  00091	52		 push	 edx
  00092	88 46 01	 mov	 BYTE PTR [esi+1], al
  00095	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 51   : 	free (Packet);

  0009a	56		 push	 esi
  0009b	e8 00 00 00 00	 call	 _free

; 52   : }

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5e		 pop	 esi
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?MessageChat@@YAXHPADZZ ENDP				; MessageChat
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MessageAllChat@@YAXHPADZZ			; MessageAllChat
EXTRN	?DataSendAll@@YAXPAEH@Z:PROC			; DataSendAll
; Function compile flags: /Ogtp
;	COMDAT ?MessageAllChat@@YAXHPADZZ
_TEXT	SEGMENT
_Message$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szMsg$ = 12						; size = 4
?MessageAllChat@@YAXHPADZZ PROC				; MessageAllChat, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 57   : 	char Message[1024];
; 58   : 	va_list pArguments;
; 59   :     va_start(pArguments,szMsg);
; 60   : 	//vsprintf_s(Message,sizeof(Message), szMsg, pArguments);
; 61   : 	vsprintf(Message,szMsg,pArguments);

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _szMsg$[ebp]
  00016	56		 push	 esi
  00017	8d 45 10	 lea	 eax, DWORD PTR _szMsg$[ebp+4]
  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _Message$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _vsprintf

; 62   : 	va_end(pArguments);
; 63   : 	BYTE *Packet;
; 64   : 	Packet = (BYTE*) malloc(200);

  00028	68 c8 00 00 00	 push	 200			; 000000c8H
  0002d	e8 00 00 00 00	 call	 _malloc

; 65   : 	memset(Packet, 0x00, 200);

  00032	68 c8 00 00 00	 push	 200			; 000000c8H
  00037	8b f0		 mov	 esi, eax
  00039	6a 00		 push	 0
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memset

; 66   : 	*Packet = 0xC1;
; 67   : 	*(Packet+2) = 0x00;
; 68   : 	memcpy((Packet+13), Message, strlen(Message));

  00041	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _Message$[ebp]
  00047	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004a	c6 06 c1	 mov	 BYTE PTR [esi], 193	; 000000c1H
  0004d	c6 46 02 00	 mov	 BYTE PTR [esi+2], 0
  00051	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL3@MessageAll:
  00054	8a 08		 mov	 cl, BYTE PTR [eax]
  00056	40		 inc	 eax
  00057	84 c9		 test	 cl, cl
  00059	75 f9		 jne	 SHORT $LL3@MessageAll
  0005b	2b c2		 sub	 eax, edx
  0005d	50		 push	 eax
  0005e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _Message$[ebp]
  00064	50		 push	 eax
  00065	8d 4e 0d	 lea	 ecx, DWORD PTR [esi+13]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy

; 69   : 	int Len = (strlen(Message) + 0x13);

  0006e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _Message$[ebp]
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL4@MessageAll:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	84 c9		 test	 cl, cl
  00085	75 f9		 jne	 SHORT $LL4@MessageAll
  00087	2b c2		 sub	 eax, edx
  00089	83 c0 13	 add	 eax, 19			; 00000013H

; 70   : 	*(Packet+1) = Len;
; 71   : 	DataSendAll(Packet, Len);

  0008c	50		 push	 eax
  0008d	56		 push	 esi
  0008e	88 46 01	 mov	 BYTE PTR [esi+1], al
  00091	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll

; 72   : 	free (Packet);

  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 _free

; 73   : }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a2	33 cd		 xor	 ecx, ebp
  000a4	5e		 pop	 esi
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?MessageAllChat@@YAXHPADZZ ENDP				; MessageAllChat
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MessaageAllGlobal@@YAXPADZZ			; MessaageAllGlobal
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
; Function compile flags: /Ogtp
;	COMDAT ?MessaageAllGlobal@@YAXPADZZ
_TEXT	SEGMENT
_szTemp$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_szMsg$ = 8						; size = 4
?MessaageAllGlobal@@YAXPADZZ PROC			; MessaageAllGlobal, COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 78   : #if(ENABLE_TEXTCHANGE)
; 79   : 	if(g_ZtLicense.CheckUser(eZtUB::masonX) || g_ZtLicense.CheckUser(eZtUB::Local))
; 80   : 	{
; 81   : 		szMsg = g_Text.Change(szMsg);
; 82   : 	}
; 83   : #endif
; 84   : 	char szTemp[1024];
; 85   : 	va_list pArguments;
; 86   : 	va_start(pArguments,szMsg);
; 87   : 	vsprintf(szTemp,szMsg,pArguments);

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _szMsg$[ebp]
  00016	8d 45 0c	 lea	 eax, DWORD PTR _szMsg$[ebp+4]
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _vsprintf

; 88   : 	va_end(pArguments);
; 89   : 	AllSendServerMsg(szTemp);

  00027	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 90   : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?MessaageAllGlobal@@YAXPADZZ ENDP			; MessaageAllGlobal
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChatMessageOne@@YAXHPADZZ			; ChatMessageOne
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?ChatMessageOne@@YAXHPADZZ
_TEXT	SEGMENT
_pWhisper$ = -108					; size = 102
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_msg$ = 12						; size = 4
?ChatMessageOne@@YAXHPADZZ PROC				; ChatMessageOne, COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 94   : 	PMSG_CHATDATA pWhisper;
; 95   : 	PHeadSetB((LPBYTE)&pWhisper, 0x00, sizeof(pWhisper));

  00010	6a 66		 push	 102			; 00000066H
  00012	8d 45 94	 lea	 eax, DWORD PTR _pWhisper$[ebp]
  00015	6a 00		 push	 0
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 96   : 	strcpy(pWhisper.chatid, gObj[aIndex].Name);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00020	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0002c	8d 44 11 77	 lea	 eax, DWORD PTR [ecx+edx+119]
  00030	8d 55 97	 lea	 edx, DWORD PTR _pWhisper$[ebp+3]
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	2b d0		 sub	 edx, eax
$LL4@ChatMessag:
  00038	8a 08		 mov	 cl, BYTE PTR [eax]
  0003a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0003d	40		 inc	 eax
  0003e	84 c9		 test	 cl, cl
  00040	75 f6		 jne	 SHORT $LL4@ChatMessag

; 97   : 	memcpy(pWhisper.chatmsg, msg, sizeof(pWhisper.chatmsg));

  00042	56		 push	 esi
  00043	8b 75 0c	 mov	 esi, DWORD PTR _msg$[ebp]
  00046	57		 push	 edi
  00047	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0004c	8d 7d a1	 lea	 edi, DWORD PTR _pWhisper$[ebp+13]
  0004f	f3 a5		 rep movsd
  00051	a4		 movsb

; 98   : 	int len = strlen(pWhisper.chatmsg);

  00052	8d 45 a1	 lea	 eax, DWORD PTR _pWhisper$[ebp+13]
  00055	5f		 pop	 edi
  00056	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00059	5e		 pop	 esi
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL6@ChatMessag:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL6@ChatMessag
  00067	2b c2		 sub	 eax, edx

; 99   : 
; 100  : 	if ( len > 0 )

  00069	85 c0		 test	 eax, eax
  0006b	7e 1a		 jle	 SHORT $LN1@ChatMessag

; 101  : 	{
; 102  : 		pWhisper.h.size -= sizeof(pWhisper.chatmsg);
; 103  : 		pWhisper.h.size += len + 1;

  0006d	8a 4d 95	 mov	 cl, BYTE PTR _pWhisper$[ebp+1]
  00070	2c 58		 sub	 al, 88			; 00000058H
  00072	02 c8		 add	 cl, al

; 104  : 
; 105  : 		DataSendAll((LPBYTE)&pWhisper, pWhisper.h.size);

  00074	0f b6 c1	 movzx	 eax, cl
  00077	88 4d 95	 mov	 BYTE PTR _pWhisper$[ebp+1], cl
  0007a	50		 push	 eax
  0007b	8d 4d 94	 lea	 ecx, DWORD PTR _pWhisper$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  00084	83 c4 08	 add	 esp, 8
$LN1@ChatMessag:

; 106  : 	}
; 107  : }

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?ChatMessageOne@@YAXHPADZZ ENDP				; ChatMessageOne
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChatMessageTwo@@YAXHPADZZ			; ChatMessageTwo
; Function compile flags: /Ogtp
;	COMDAT ?ChatMessageTwo@@YAXHPADZZ
_TEXT	SEGMENT
_pWhisper$ = -108					; size = 102
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_msg$ = 12						; size = 4
?ChatMessageTwo@@YAXHPADZZ PROC				; ChatMessageTwo, COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 111  : 	PMSG_CHATDATA_WHISPER pWhisper;
; 112  : 	PHeadSetB((LPBYTE)&pWhisper, 0x02, sizeof(pWhisper));

  00010	6a 66		 push	 102			; 00000066H
  00012	8d 45 94	 lea	 eax, DWORD PTR _pWhisper$[ebp]
  00015	6a 02		 push	 2
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 113  : 	strcpy(pWhisper.id, gObj[aIndex].Name);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00020	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0002c	8d 44 11 77	 lea	 eax, DWORD PTR [ecx+edx+119]
  00030	8d 55 97	 lea	 edx, DWORD PTR _pWhisper$[ebp+3]
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	2b d0		 sub	 edx, eax
$LL4@ChatMessag@2:
  00038	8a 08		 mov	 cl, BYTE PTR [eax]
  0003a	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0003d	40		 inc	 eax
  0003e	84 c9		 test	 cl, cl
  00040	75 f6		 jne	 SHORT $LL4@ChatMessag@2

; 114  : 	memcpy(pWhisper.chatmsg, msg, sizeof(pWhisper.chatmsg));

  00042	56		 push	 esi
  00043	8b 75 0c	 mov	 esi, DWORD PTR _msg$[ebp]
  00046	57		 push	 edi
  00047	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0004c	8d 7d a1	 lea	 edi, DWORD PTR _pWhisper$[ebp+13]
  0004f	f3 a5		 rep movsd
  00051	a4		 movsb

; 115  : 	int len = strlen(pWhisper.chatmsg);

  00052	8d 45 a1	 lea	 eax, DWORD PTR _pWhisper$[ebp+13]
  00055	5f		 pop	 edi
  00056	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00059	5e		 pop	 esi
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL6@ChatMessag@2:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL6@ChatMessag@2
  00067	2b c2		 sub	 eax, edx

; 116  : 
; 117  : 	if ( len > 0 )

  00069	85 c0		 test	 eax, eax
  0006b	7e 1a		 jle	 SHORT $LN1@ChatMessag@2

; 118  : 	{
; 119  : 		pWhisper.h.size -= sizeof(pWhisper.chatmsg);
; 120  : 		pWhisper.h.size += len + 1;

  0006d	8a 4d 95	 mov	 cl, BYTE PTR _pWhisper$[ebp+1]
  00070	2c 58		 sub	 al, 88			; 00000058H
  00072	02 c8		 add	 cl, al

; 121  : 
; 122  : 		DataSendAll((LPBYTE)&pWhisper, pWhisper.h.size);

  00074	0f b6 c1	 movzx	 eax, cl
  00077	88 4d 95	 mov	 BYTE PTR _pWhisper$[ebp+1], cl
  0007a	50		 push	 eax
  0007b	8d 4d 94	 lea	 ecx, DWORD PTR _pWhisper$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  00084	83 c4 08	 add	 esp, 8
$LN1@ChatMessag@2:

; 123  : 	}
; 124  : }

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?ChatMessageTwo@@YAXHPADZZ ENDP				; ChatMessageTwo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MessageSendEx@@YAXHHPAD0ZZ			; MessageSendEx
; Function compile flags: /Ogtp
;	COMDAT ?MessageSendEx@@YAXHHPAD0ZZ
_TEXT	SEGMENT
_pMessage$ = -1132					; size = 104
_szTemp$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 4
_Sender$ = 16						; size = 4
_Message$ = 20						; size = 4
?MessageSendEx@@YAXHHPAD0ZZ PROC			; MessageSendEx, COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 04 00
	00		 sub	 esp, 1132		; 0000046cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 138  : #if(ENABLE_TEXTCHANGE)
; 139  : 	if(g_ZtLicense.CheckUser(eZtUB::masonX) || g_ZtLicense.CheckUser(eZtUB::Local))
; 140  : 	{
; 141  : 		Message = g_Text.Change(Message);
; 142  : 	}
; 143  : #endif
; 144  : 
; 145  : 	char szTemp[1024];
; 146  : 	
; 147  : #ifdef FIX_CRASH_PROCENT_IN_PRIVATE_CHAT
; 148  : 	strcpy(szTemp, Message);

  00013	8b 45 14	 mov	 eax, DWORD PTR _Message$[ebp]
  00016	56		 push	 esi
  00017	8b 75 10	 mov	 esi, DWORD PTR _Sender$[ebp]
  0001a	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00020	57		 push	 edi
  00021	2b d0		 sub	 edx, eax
$LL3@MessageSen:
  00023	8a 08		 mov	 cl, BYTE PTR [eax]
  00025	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00028	40		 inc	 eax
  00029	84 c9		 test	 cl, cl
  0002b	75 f6		 jne	 SHORT $LL3@MessageSen

; 149  : #else
; 150  : 	va_list pArguments;
; 151  : 	va_start(pArguments, Message);
; 152  : 	vsprintf(szTemp, Message, pArguments);
; 153  : 	va_end(pArguments);
; 154  : #endif // FIX_CRASH_PROCENT_IN_PRIVATE_CHAT
; 155  : 
; 156  : 	// ----
; 157  : 	CHAT_WHISPER_EX pMessage;
; 158  : 	memcpy(pMessage.Name, Sender, 10);

  0002d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  00036	89 8d 9b fb ff
	ff		 mov	 DWORD PTR _pMessage$[ebp+7], ecx
  0003c	89 85 97 fb ff
	ff		 mov	 DWORD PTR _pMessage$[ebp+3], eax

; 159  : 	memcpy(pMessage.Message, szTemp, 90);
; 160  : 	pMessage.Type = Type;	//Test na Crash

  00042	8a 45 0c	 mov	 al, BYTE PTR _Type$[ebp]
  00045	66 89 95 9f fb
	ff ff		 mov	 WORD PTR _pMessage$[ebp+11], dx

; 161  : 	pMessage.Head.set((LPBYTE)&pMessage, 2, sizeof(CHAT_WHISPER_EX));
; 162  : 	DataSend(aIndex,(LPBYTE)&pMessage, pMessage.Head.size);

  0004c	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0004f	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00054	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _szTemp$[ebp]
  0005a	8d bd a1 fb ff
	ff		 lea	 edi, DWORD PTR _pMessage$[ebp+13]
  00060	f3 a5		 rep movsd
  00062	6a 68		 push	 104			; 00000068H
  00064	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR _pMessage$[ebp]
  0006a	66 a5		 movsw
  0006c	51		 push	 ecx
  0006d	52		 push	 edx
  0006e	88 85 fb fb ff
	ff		 mov	 BYTE PTR _pMessage$[ebp+103], al
  00074	66 c7 85 94 fb
	ff ff c1 68	 mov	 WORD PTR _pMessage$[ebp], 26817 ; 000068c1H
  0007d	c6 85 96 fb ff
	ff 02		 mov	 BYTE PTR _pMessage$[ebp+2], 2
  00084	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 163  : }

  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	5f		 pop	 edi
  00090	33 cd		 xor	 ecx, ebp
  00092	5e		 pop	 esi
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?MessageSendEx@@YAXHHPAD0ZZ ENDP			; MessageSendEx
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?MessageSendAllEx@@YAXHPAD0ZZ			; MessageSendAllEx
; Function compile flags: /Ogtp
;	COMDAT ?MessageSendAllEx@@YAXHPAD0ZZ
_TEXT	SEGMENT
_pMessage$ = -1132					; size = 104
_szTemp$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_Type$ = 8						; size = 4
_Sender$ = 12						; size = 4
_Message$ = 16						; size = 4
?MessageSendAllEx@@YAXHPAD0ZZ PROC			; MessageSendAllEx, COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 04 00
	00		 sub	 esp, 1132		; 0000046cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 167  : #if(ENABLE_TEXTCHANGE)
; 168  : 	if(g_ZtLicense.CheckUser(eZtUB::masonX) || g_ZtLicense.CheckUser(eZtUB::Local))
; 169  : 	{
; 170  : 		Message = g_Text.Change(Message);
; 171  : 	}
; 172  : #endif
; 173  : 
; 174  : 	char szTemp[1024];
; 175  : 	va_list pArguments;
; 176  : 	va_start(pArguments, Message);
; 177  : 	vsprintf(szTemp, Message, pArguments);

  00013	8b 4d 10	 mov	 ecx, DWORD PTR _Message$[ebp]
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _Sender$[ebp]
  0001a	57		 push	 edi
  0001b	8d 45 14	 lea	 eax, DWORD PTR _Message$[ebp+4]
  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _vsprintf

; 178  : 	va_end(pArguments);
; 179  : 	// ----
; 180  : 	CHAT_WHISPER_EX pMessage;
; 181  : 	memcpy(pMessage.Name, Sender, 10);

  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  00035	89 8d 9b fb ff
	ff		 mov	 DWORD PTR _pMessage$[ebp+7], ecx
  0003b	89 85 97 fb ff
	ff		 mov	 DWORD PTR _pMessage$[ebp+3], eax

; 182  : 	memcpy(pMessage.Message, szTemp, 90);
; 183  : 	pMessage.Type = Type;	//Test na Crash

  00041	8a 45 08	 mov	 al, BYTE PTR _Type$[ebp]
  00044	66 89 95 9f fb
	ff ff		 mov	 WORD PTR _pMessage$[ebp+11], dx
  0004b	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00050	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _szTemp$[ebp]
  00056	8d bd a1 fb ff
	ff		 lea	 edi, DWORD PTR _pMessage$[ebp+13]
  0005c	f3 a5		 rep movsd
  0005e	66 a5		 movsw

; 184  : 	pMessage.Head.set((LPBYTE)&pMessage, 2, sizeof(CHAT_WHISPER_EX));
; 185  : 	DataSendAll((LPBYTE)&pMessage, pMessage.Head.size);

  00060	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR _pMessage$[ebp]
  00066	6a 68		 push	 104			; 00000068H
  00068	51		 push	 ecx
  00069	88 85 fb fb ff
	ff		 mov	 BYTE PTR _pMessage$[ebp+103], al
  0006f	66 c7 85 94 fb
	ff ff c1 68	 mov	 WORD PTR _pMessage$[ebp], 26817 ; 000068c1H
  00078	c6 85 96 fb ff
	ff 02		 mov	 BYTE PTR _pMessage$[ebp+2], 2
  0007f	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll

; 186  : 
; 187  : #if(ZTLICENSE_SERVER)
; 188  : 	//g_ZtLicenseProtocol.GLChatMessage(pMessage.Name, pMessage.Message);
; 189  : #endif
; 190  : }

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	83 c4 14	 add	 esp, 20			; 00000014H
  0008a	5f		 pop	 edi
  0008b	33 cd		 xor	 ecx, ebp
  0008d	5e		 pop	 esi
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?MessageSendAllEx@@YAXHPAD0ZZ ENDP			; MessageSendAllEx
_TEXT	ENDS
END
