; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\MuLua.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_sentinel_ DD	00H
CONST	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	?DoFile@MULua@@QAE_NPBD@Z			; MULua::DoFile
EXTRN	_lua_pcall:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_lua_tolstring:PROC
EXTRN	_luaL_loadfile:PROC
;	COMDAT ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
; File e:\work\tranet_version\gs\gameserver\mulua.cpp
CONST	SEGMENT
??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ DB 'E'
	DB	'rror!!, : %s : State = %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ DB 'Error!!, : %s', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DoFile@MULua@@QAE_NPBD@Z
_TEXT	SEGMENT
_szFileName$ = 8					; size = 4
?DoFile@MULua@@QAE_NPBD@Z PROC				; MULua::DoFile, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	int iState = 0;
; 32   : 
; 33   : 	if ( luaL_loadfile(m_luaState, szFileName) )

  00003	8b 45 08	 mov	 eax, DWORD PTR _szFileName$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _luaL_loadfile
  00012	83 c4 08	 add	 esp, 8

; 34   : 	{		
; 35   : 		MsgBox("Error!!, : %s\n", lua_tolstring(m_luaState, -1, 0) );

  00015	6a 00		 push	 0
  00017	6a ff		 push	 -1
  00019	85 c0		 test	 eax, eax
  0001b	74 1d		 je	 SHORT $LN2@DoFile
  0001d	8b 16		 mov	 edx, DWORD PTR [esi]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _lua_tolstring
  00025	50		 push	 eax
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
  0002b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00030	83 c4 14	 add	 esp, 20			; 00000014H

; 36   : 		return false;

  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 48   : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN2@DoFile:

; 37   : 	}
; 38   : 
; 39   :     iState = lua_pcall(m_luaState, 0, -1, 0);

  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _lua_pcall
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 40   : 
; 41   : 	if ( iState )

  00047	85 c0		 test	 eax, eax
  00049	74 25		 je	 SHORT $LN1@DoFile

; 42   : 	{
; 43   : 		MsgBox("Error!!, : %s : State = %d\n", lua_tolstring(m_luaState, -1, 0) , iState);

  0004b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004d	50		 push	 eax
  0004e	6a 00		 push	 0
  00050	6a ff		 push	 -1
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _lua_tolstring
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
  00061	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 		return false;

  00069	32 c0		 xor	 al, al
  0006b	5e		 pop	 esi

; 48   : }

  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
$LN1@DoFile:

; 45   : 	}
; 46   : 
; 47   : 	return true;	

  00070	b0 01		 mov	 al, 1
  00072	5e		 pop	 esi

; 48   : }

  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?DoFile@MULua@@QAE_NPBD@Z ENDP				; MULua::DoFile
_TEXT	ENDS
PUBLIC	?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z		; MULua::DoFile
; Function compile flags: /Ogtp
;	COMDAT ?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_szFileName$ = 12					; size = 4
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z PROC		; MULua::DoFile, COMDAT
; _this$ = ecx

; 52   : 	return true;

  00000	b0 01		 mov	 al, 1

; 53   : }

  00002	c2 08 00	 ret	 8
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z ENDP		; MULua::DoFile
_TEXT	ENDS
PUBLIC	?GetLua@MULua@@QAEPAUlua_State@@XZ		; MULua::GetLua
; Function compile flags: /Ogtp
;	COMDAT ?GetLua@MULua@@QAEPAUlua_State@@XZ
_TEXT	SEGMENT
?GetLua@MULua@@QAEPAUlua_State@@XZ PROC			; MULua::GetLua, COMDAT
; _this$ = ecx

; 62   : 	return m_luaState;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 63   : }

  00002	c3		 ret	 0
?GetLua@MULua@@QAEPAUlua_State@@XZ ENDP			; MULua::GetLua
_TEXT	ENDS
PUBLIC	?Register@MULua@@QAEXPAX@Z			; MULua::Register
; Function compile flags: /Ogtp
;	COMDAT ?Register@MULua@@QAEXPAX@Z
_TEXT	SEGMENT
_pLua$ = 8						; size = 4
?Register@MULua@@QAEXPAX@Z PROC				; MULua::Register, COMDAT
; _this$ = ecx

; 79   : 	lua_State* pLuaState = (lua_State*)pLua;
; 80   : }

  00000	c2 04 00	 ret	 4
?Register@MULua@@QAEXPAX@Z ENDP				; MULua::Register
_TEXT	ENDS
PUBLIC	?Release@MULua@@QAEXXZ				; MULua::Release
EXTRN	_lua_close:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Release@MULua@@QAEXXZ
_TEXT	SEGMENT
?Release@MULua@@QAEXXZ PROC				; MULua::Release, COMDAT
; _this$ = ecx

; 83   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 84   : 	if(m_luaState)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN1@Release

; 85   : 	{
; 86   : 		lua_close(m_luaState);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lua_close
  0000f	83 c4 04	 add	 esp, 4

; 87   : 		m_luaState = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Release:
  00018	5e		 pop	 esi

; 88   : 	}
; 89   : }

  00019	c3		 ret	 0
?Release@MULua@@QAEXXZ ENDP				; MULua::Release
_TEXT	ENDS
PUBLIC	?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z	; MULua::CreateWinConsole
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	?StartConsole@CWinConsole@@SAPAUHWND__@@PAUHINSTANCE__@@PAUlua_State@@@Z:PROC ; CWinConsole::StartConsole
; Function compile flags: /Ogtp
;	COMDAT ?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z PROC	; MULua::CreateWinConsole, COMDAT
; _this$ = ecx

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   : 	HWND hWnd = NULL;
; 95   : 
; 96   : 	hWnd = CWinConsole::StartConsole(hInstance, m_luaState);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00008	50		 push	 eax
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 ?StartConsole@CWinConsole@@SAPAUHWND__@@PAUHINSTANCE__@@PAUlua_State@@@Z ; CWinConsole::StartConsole
  0000f	83 c4 08	 add	 esp, 8

; 97   : 
; 98   : 	if ( hWnd )

  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $LN1@CreateWinC

; 99   : 		ShowWindow(hWnd, SW_HIDE);

  00016	6a 00		 push	 0
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN1@CreateWinC:

; 100  : 
; 101  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?CreateWinConsole@MULua@@QAEXPAUHINSTANCE__@@@Z ENDP	; MULua::CreateWinConsole
_TEXT	ENDS
PUBLIC	?DestroyWinConsole@MULua@@QAEXXZ		; MULua::DestroyWinConsole
EXTRN	?StopConsole@CWinConsole@@SAXXZ:PROC		; CWinConsole::StopConsole
; Function compile flags: /Ogtp
;	COMDAT ?DestroyWinConsole@MULua@@QAEXXZ
_TEXT	SEGMENT
?DestroyWinConsole@MULua@@QAEXXZ PROC			; MULua::DestroyWinConsole, COMDAT
; _this$ = ecx

; 106  : 	CWinConsole::StopConsole();

  00000	e9 00 00 00 00	 jmp	 ?StopConsole@CWinConsole@@SAXXZ ; CWinConsole::StopConsole
?DestroyWinConsole@MULua@@QAEXXZ ENDP			; MULua::DestroyWinConsole
_TEXT	ENDS
PUBLIC	??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@ ; `string'
PUBLIC	??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@ ; `string'
PUBLIC	??_C@_07PINPBNPB@_LOADED?$AA@			; `string'
PUBLIC	??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?MuRequire@@YAHPAUlua_State@@@Z			; MuRequire
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_pushboolean:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_call:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_luaL_error:PROC
EXTRN	_lua_touserdata:PROC
EXTRN	_lua_toboolean:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_settop:PROC
EXTRN	_sprintf:PROC
EXTRN	_luaL_checklstring:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@
CONST	SEGMENT
??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@ DB 'error '
	DB	'loading module ''%s'' from file ''%s'':', 0aH, 09H, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@
CONST	SEGMENT
??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@ DB 'loop or pre'
	DB	'vious error loading module ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PINPBNPB@_LOADED?$AA@
CONST	SEGMENT
??_C@_07PINPBNPB@_LOADED?$AA@ DB '_LOADED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@ DB '..\Data\Lua\%s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MuRequire@@YAHPAUlua_State@@@Z
_TEXT	SEGMENT
_name$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_L$ = 8							; size = 4
?MuRequire@@YAHPAUlua_State@@@Z PROC			; MuRequire, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _L$[ebp]

; 116  : 	//char *name = NULL;
; 117  : 	char name[MAX_PATH] = { 0 };

  00017	68 03 01 00 00	 push	 259			; 00000103H
  0001c	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp+1]
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _name$[ebp], 0
  0002c	e8 00 00 00 00	 call	 _memset

; 118  : 	sprintf(name, "..\\Data\\Lua\\%s", (LPCSTR)luaL_checklstring(L, 1, 0));

  00031	6a 00		 push	 0
  00033	6a 01		 push	 1
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 _luaL_checklstring
  0003b	50		 push	 eax
  0003c	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LAACJHM@?4?4?2Data?2Lua?2?$CFs?$AA@
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _sprintf

; 119  : 	//name = gDirPath.GetNewPath((LPCSTR)luaL_checklstring(L, 1, 0) );
; 120  : 	lua_settop(L, 1);

  0004d	6a 01		 push	 1
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 _lua_settop

; 121  : 
; 122  : 	lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_07PINPBNPB@_LOADED?$AA@
  0005a	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 _lua_getfield

; 123  : 	lua_getfield(L, 2, name);

  00065	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  0006b	52		 push	 edx
  0006c	6a 02		 push	 2
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _lua_getfield
  00074	83 c4 44	 add	 esp, 68			; 00000044H

; 124  : 
; 125  : 	if ( lua_toboolean(L, -1) )

  00077	6a ff		 push	 -1
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 _lua_toboolean
  0007f	83 c4 08	 add	 esp, 8
  00082	85 c0		 test	 eax, eax
  00084	74 3f		 je	 SHORT $LN5@MuRequire

; 126  : 	{
; 127  : 		if ( lua_touserdata(L, -1) == sentinel )

  00086	6a ff		 push	 -1
  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 _lua_touserdata
  0008e	83 c4 08	 add	 esp, 8
  00091	3d 00 00 00 00	 cmp	 eax, OFFSET _sentinel_
  00096	0f 85 03 01 00
	00		 jne	 $LN1@MuRequire

; 128  : 			luaL_error(L, "loop or previous error loading module '%s'", name);

  0009c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 _luaL_error
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 	}
; 156  : 
; 157  : 	return 1;

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	5e		 pop	 esi

; 158  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN5@MuRequire:

; 129  : 
; 130  : 		return 1;
; 131  : 	}
; 132  : 
; 133  : 
; 134  : 	if ( luaL_loadfile(L, name) )

  000c5	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  000cb	51		 push	 ecx
  000cc	56		 push	 esi
  000cd	e8 00 00 00 00	 call	 _luaL_loadfile
  000d2	83 c4 08	 add	 esp, 8
  000d5	85 c0		 test	 eax, eax
  000d7	74 31		 je	 SHORT $LN3@MuRequire

; 135  : 	{
; 136  : 		luaL_error(L, "error loading module '%s' from file '%s':\n\t%s", 
; 137  : 			lua_tolstring(L, 1, 0), name, lua_tolstring(L, -1, 0));

  000d9	6a 00		 push	 0
  000db	6a ff		 push	 -1
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 _lua_tolstring
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	50		 push	 eax
  000e7	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  000ed	52		 push	 edx
  000ee	6a 00		 push	 0
  000f0	6a 01		 push	 1
  000f2	56		 push	 esi
  000f3	e8 00 00 00 00	 call	 _lua_tolstring
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fb	50		 push	 eax
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@
  00101	56		 push	 esi
  00102	e8 00 00 00 00	 call	 _luaL_error
  00107	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@MuRequire:

; 138  : 	}
; 139  : 
; 140  : 	lua_pushlightuserdata(L, sentinel);

  0010a	68 00 00 00 00	 push	 OFFSET _sentinel_
  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 _lua_pushlightuserdata

; 141  : 	lua_setfield(L, 2, name);

  00115	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  0011b	50		 push	 eax
  0011c	6a 02		 push	 2
  0011e	56		 push	 esi
  0011f	e8 00 00 00 00	 call	 _lua_setfield

; 142  : 	lua_pushstring(L, name);

  00124	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  0012a	51		 push	 ecx
  0012b	56		 push	 esi
  0012c	e8 00 00 00 00	 call	 _lua_pushstring

; 143  : 	lua_call(L, 1, 1);

  00131	6a 01		 push	 1
  00133	6a 01		 push	 1
  00135	56		 push	 esi
  00136	e8 00 00 00 00	 call	 _lua_call

; 144  : 
; 145  : 	if ( lua_type(L, -1) )

  0013b	6a ff		 push	 -1
  0013d	56		 push	 esi
  0013e	e8 00 00 00 00	 call	 _lua_type
  00143	83 c4 30	 add	 esp, 48			; 00000030H
  00146	85 c0		 test	 eax, eax
  00148	74 12		 je	 SHORT $LN2@MuRequire

; 146  : 		lua_setfield(L, 2, name);

  0014a	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  00150	52		 push	 edx
  00151	6a 02		 push	 2
  00153	56		 push	 esi
  00154	e8 00 00 00 00	 call	 _lua_setfield
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@MuRequire:

; 147  : 
; 148  : 	lua_getfield(L, 2, name);

  0015c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00162	50		 push	 eax
  00163	6a 02		 push	 2
  00165	56		 push	 esi
  00166	e8 00 00 00 00	 call	 _lua_getfield

; 149  : 
; 150  : 	if ( lua_touserdata(L, -1) == sentinel )

  0016b	6a ff		 push	 -1
  0016d	56		 push	 esi
  0016e	e8 00 00 00 00	 call	 _lua_touserdata
  00173	83 c4 14	 add	 esp, 20			; 00000014H
  00176	3d 00 00 00 00	 cmp	 eax, OFFSET _sentinel_
  0017b	75 22		 jne	 SHORT $LN1@MuRequire

; 151  : 	{
; 152  : 		lua_pushboolean(L, 1);

  0017d	6a 01		 push	 1
  0017f	56		 push	 esi
  00180	e8 00 00 00 00	 call	 _lua_pushboolean

; 153  : 		lua_pushvalue(L, -1);

  00185	6a ff		 push	 -1
  00187	56		 push	 esi
  00188	e8 00 00 00 00	 call	 _lua_pushvalue

; 154  : 		lua_setfield(L, 2, name);

  0018d	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  00193	51		 push	 ecx
  00194	6a 02		 push	 2
  00196	56		 push	 esi
  00197	e8 00 00 00 00	 call	 _lua_setfield
  0019c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@MuRequire:

; 158  : }

  0019f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a2	33 cd		 xor	 ecx, ebp
  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	5e		 pop	 esi
  001aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
?MuRequire@@YAHPAUlua_State@@@Z ENDP			; MuRequire
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 		}

  00003	5d		 pop	 ebp

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 527  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  0000b	88 0a		 mov	 BYTE PTR [edx], cl

; 528  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 459  : 		}

  00000	c3		 ret	 0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2003 : 		{	// determine current pointer to buffer for mutable string

  00000	8b c1		 mov	 eax, ecx

; 2004 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2005 : 			: this->_Bx._Buf);

  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 02		 jb	 SHORT $LN4@Myptr
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Myptr:

; 2006 : 		}

  0000a	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	??1MULua@@QAE@XZ				; MULua::~MULua
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\mulua.cpp
;	COMDAT ??1MULua@@QAE@XZ
_TEXT	SEGMENT
??1MULua@@QAE@XZ PROC					; MULua::~MULua, COMDAT
; _this$ = ecx

; 26   : 	Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@MULua@@QAEXXZ	; MULua::Release
??1MULua@@QAE@XZ ENDP					; MULua::~MULua
_TEXT	ENDS
PUBLIC	??_C@_09ENDOEBPC@murequire?$AA@			; `string'
PUBLIC	?Create@MULua@@AAE_NXZ				; MULua::Create
EXTRN	_lua_gc:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_luaL_openlibs:PROC
EXTRN	_luaL_newstate:PROC
;	COMDAT ??_C@_09ENDOEBPC@murequire?$AA@
CONST	SEGMENT
??_C@_09ENDOEBPC@murequire?$AA@ DB 'murequire', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Create@MULua@@AAE_NXZ
_TEXT	SEGMENT
?Create@MULua@@AAE_NXZ PROC				; MULua::Create, COMDAT
; _this$ = ecx

; 66   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 67   : 	m_luaState = luaL_newstate();

  00003	e8 00 00 00 00	 call	 _luaL_newstate

; 68   : 
; 69   : 	luaL_openlibs(m_luaState);

  00008	50		 push	 eax
  00009	89 06		 mov	 DWORD PTR [esi], eax
  0000b	e8 00 00 00 00	 call	 _luaL_openlibs

; 70   : 	lua_pushcclosure(m_luaState, MuRequire, 0);

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET ?MuRequire@@YAHPAUlua_State@@@Z ; MuRequire
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _lua_pushcclosure

; 71   : 	lua_setfield(m_luaState, LUA_GLOBALSINDEX, "murequire");

  0001f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_09ENDOEBPC@murequire?$AA@
  00026	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _lua_setfield

; 72   : 	lua_gc(m_luaState, LUA_GCCOLLECT, 0);

  00031	8b 16		 mov	 edx, DWORD PTR [esi]
  00033	6a 00		 push	 0
  00035	6a 02		 push	 2
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _lua_gc
  0003d	83 c4 28	 add	 esp, 40			; 00000028H

; 73   : 
; 74   : 	return true;

  00040	b0 01		 mov	 al, 1
  00042	5e		 pop	 esi

; 75   : }

  00043	c3		 ret	 0
?Create@MULua@@AAE_NXZ ENDP				; MULua::Create
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1953 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1954 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0000a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000d	72 02		 jb	 SHORT $LN5@Eos
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN5@Eos:
  00011	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1955 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	??0MULua@@QAE@XZ				; MULua::MULua
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\mulua.cpp
;	COMDAT ??0MULua@@QAE@XZ
_TEXT	SEGMENT
??0MULua@@QAE@XZ PROC					; MULua::MULua, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 20   : 	Create();

  00009	e8 00 00 00 00	 call	 ?Create@MULua@@AAE_NXZ	; MULua::Create

; 21   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0MULua@@QAE@XZ ENDP					; MULua::MULua
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1988 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1989 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 22		 je	 SHORT $LN9@Tidy

; 1990 : 			;
; 1991 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1c		 jb	 SHORT $LN9@Tidy

; 1992 : 			{	// copy any leftovers to small buffer and deallocate
; 1993 : 			_Elem *_Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1994 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN7@Tidy

; 1995 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@Tidy:

; 1996 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
  00031	5b		 pop	 ebx
$LN9@Tidy:

; 1997 : 			}
; 1998 : 		this->_Myres = this->_BUF_SIZE - 1;
; 1999 : 		_Eos(_Newsize);

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00035	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 2000 : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 753  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 754  : 		_Tidy(true);

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0b		 jb	 SHORT $LN11@basic_stri
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	83 c4 04	 add	 esp, 4
$LN11@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0
  00025	5e		 pop	 esi

; 755  : 		}

  00026	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MULua::DoString
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\mulua.cpp
;	COMDAT ?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_kString$ = 8						; size = 28
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; MULua::DoString, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return true;

  00003	83 7d 1c 10	 cmp	 DWORD PTR _kString$[ebp+20], 16 ; 00000010H
  00007	72 0c		 jb	 SHORT $LN26@DoString
  00009	8b 45 08	 mov	 eax, DWORD PTR _kString$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN26@DoString:
  00015	b0 01		 mov	 al, 1

; 58   : }

  00017	5d		 pop	 ebp
  00018	c2 1c 00	 ret	 28			; 0000001cH
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; MULua::DoString
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_MuLuaQuestExp@@YAXXZ
text$yc	SEGMENT
??__Eg_MuLuaQuestExp@@YAXXZ PROC			; `dynamic initializer for 'g_MuLuaQuestExp'', COMDAT

; 14   : MULua g_MuLuaQuestExp;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuLuaQuestExp@@3VMULua@@A ; g_MuLuaQuestExp
  00005	e8 00 00 00 00	 call	 ??0MULua@@QAE@XZ	; MULua::MULua
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_MuLuaQuestExp@@YAXXZ ; `dynamic atexit destructor for 'g_MuLuaQuestExp''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_MuLuaQuestExp@@YAXXZ ENDP			; `dynamic initializer for 'g_MuLuaQuestExp''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_MuLuaQuestExp@@YAXXZ
text$yd	SEGMENT
??__Fg_MuLuaQuestExp@@YAXXZ PROC			; `dynamic atexit destructor for 'g_MuLuaQuestExp'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuLuaQuestExp@@3VMULua@@A ; g_MuLuaQuestExp
  00005	e9 00 00 00 00	 jmp	 ??1MULua@@QAE@XZ	; MULua::~MULua
??__Fg_MuLuaQuestExp@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_MuLuaQuestExp''
text$yd	ENDS
PUBLIC	?g_MuLuaQuestExp@@3VMULua@@A			; g_MuLuaQuestExp
_BSS	SEGMENT
?g_MuLuaQuestExp@@3VMULua@@A DD 01H DUP (?)		; g_MuLuaQuestExp
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MuLuaQuestExp$initializer$ DD FLAT:??__Eg_MuLuaQuestExp@@YAXXZ
CRT$XCU	ENDS
END
