; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\MuMsg.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?nMsg@@3HA					; nMsg
_BSS	SEGMENT
?nMsg@@3HA DD	01H DUP (?)				; nMsg
_BSS	ENDS
PUBLIC	?fnMsg@@YAHXZ					; fnMsg
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\mumsg.cpp
;	COMDAT ?fnMsg@@YAHXZ
_TEXT	SEGMENT
?fnMsg@@YAHXZ PROC					; fnMsg, COMDAT

; 8    : 	return 42;

  00000	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH

; 9    : }

  00005	c3		 ret	 0
?fnMsg@@YAHXZ ENDP					; fnMsg
_TEXT	ENDS
PUBLIC	??_C@_09OPBDKGIP@Msg?5error?$AA@		; `string'
PUBLIC	??0CMsg@@QAE@XZ					; CMsg::CMsg
EXTRN	_memset:PROC
;	COMDAT ??_C@_09OPBDKGIP@Msg?5error?$AA@
CONST	SEGMENT
??_C@_09OPBDKGIP@Msg?5error?$AA@ DB 'Msg error', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CMsg@@QAE@XZ
_TEXT	SEGMENT
??0CMsg@@QAE@XZ PROC					; CMsg::CMsg, COMDAT
; _this$ = ecx

; 12   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 13   : 	memset(&this->szDefaultMsg  , 0, sizeof(this->szDefaultMsg ) );

  00004	6a 32		 push	 50			; 00000032H
  00006	8d b7 24 00 02
	00		 lea	 esi, DWORD PTR [edi+131108]
  0000c	6a 00		 push	 0
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memset

; 14   : 	this->Msghead = NULL;

  00014	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 15   : 	strcpy(this->szDefaultMsg , "Msg error");

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_09OPBDKGIP@Msg?5error?$AA@
  0001f	89 06		 mov	 DWORD PTR [esi], eax
  00021	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_09OPBDKGIP@Msg?5error?$AA@+4
  00027	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0002a	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR ??_C@_09OPBDKGIP@Msg?5error?$AA@+8
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16   : }

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	66 89 56 08	 mov	 WORD PTR [esi+8], dx
  0003b	5e		 pop	 esi
  0003c	c3		 ret	 0
??0CMsg@@QAE@XZ ENDP					; CMsg::CMsg
_TEXT	ENDS
PUBLIC	?XorBuffer@CMsg@@AAEXPADH@Z			; CMsg::XorBuffer
; Function compile flags: /Ogtp
;	COMDAT ?XorBuffer@CMsg@@AAEXPADH@Z
_TEXT	SEGMENT
_buff$ = 8						; size = 4
_len$ = 12						; size = 4
?XorBuffer@CMsg@@AAEXPADH@Z PROC			; CMsg::XorBuffer, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (len <=0)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _len$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	7e 12		 jle	 SHORT $LN1@XorBuffer

; 26   : 	{
; 27   : 		return;
; 28   : 	}
; 29   : 
; 30   : 	for(int iCounter=0;iCounter<len;iCounter++)

  0000a	33 c0		 xor	 eax, eax
  0000c	85 d2		 test	 edx, edx
  0000e	7e 0c		 jle	 SHORT $LN1@XorBuffer
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
$LL3@XorBuffer:

; 31   : 	{
; 32   : 		buff[iCounter] = buff[iCounter]^0xCA;

  00013	80 34 08 ca	 xor	 BYTE PTR [eax+ecx], -54	; ffffffcaH
  00017	40		 inc	 eax
  00018	3b c2		 cmp	 eax, edx
  0001a	7c f7		 jl	 SHORT $LL3@XorBuffer
$LN1@XorBuffer:

; 33   : 	}
; 34   : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?XorBuffer@CMsg@@AAEXPADH@Z ENDP			; CMsg::XorBuffer
_TEXT	ENDS
PUBLIC	??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	?lMsgListInit@CMsg@@AAEHXZ			; CMsg::lMsgListInit
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@ DB 'Memo'
	DB	'ry Allocation Error (MuMsg)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?lMsgListInit@CMsg@@AAEHXZ
_TEXT	SEGMENT
?lMsgListInit@CMsg@@AAEHXZ PROC				; CMsg::lMsgListInit, COMDAT
; _this$ = ecx

; 99   : {

  00000	56		 push	 esi

; 100  : 	LPMSG_STRUCT msg = new MSG_STRUCT;

  00001	6a 0c		 push	 12			; 0000000cH
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 101  : 
; 102  : 	if ( msg == NULL )

  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 c4 04	 add	 esp, 4
  0000f	3b c1		 cmp	 eax, ecx
  00011	75 16		 jne	 SHORT $LN1@lMsgListIn

; 103  : 	{
; 104  : 		MessageBox(NULL, "Memory Allocation Error (MuMsg)", "Error", MB_OK);

  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OBAGPFFE@Memory?5Allocation?5Error?5?$CIMuMsg?$CJ?$AA@
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 105  : 		return 0;

  00025	33 c0		 xor	 eax, eax
  00027	5e		 pop	 esi

; 112  : }

  00028	c3		 ret	 0
$LN1@lMsgListIn:

; 106  : 	}
; 107  : 	msg->next  =NULL;
; 108  : 	msg->number  =0;
; 109  : 	msg->msg = NULL;
; 110  : 	memset(this->MsgIndex, 0, sizeof(this->MsgIndex));

  00029	68 00 00 02 00	 push	 131072			; 00020000H
  0002e	51		 push	 ecx
  0002f	83 c6 08	 add	 esi, 8
  00032	56		 push	 esi
  00033	89 08		 mov	 DWORD PTR [eax], ecx
  00035	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00038	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  : 	return 1;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	5e		 pop	 esi

; 112  : }

  00049	c3		 ret	 0
?lMsgListInit@CMsg@@AAEHXZ ENDP				; CMsg::lMsgListInit
_TEXT	ENDS
PUBLIC	?lMsgFree@CMsg@@AAEXXZ				; CMsg::lMsgFree
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtp
;	COMDAT ?lMsgFree@CMsg@@AAEXXZ
_TEXT	SEGMENT
?lMsgFree@CMsg@@AAEXXZ PROC				; CMsg::lMsgFree, COMDAT
; _this$ = ecx

; 115  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 116  : 	for ( int n = 0; n < 32768; n++ )

  00002	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00005	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@lMsgFree:

; 117  : 	{
; 118  : 		if ( this->MsgIndex[n] != 0 )

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	85 c0		 test	 eax, eax
  00014	74 14		 je	 SHORT $LN3@lMsgFree

; 119  : 		{
; 120  : 			delete [] this->MsgIndex[n]->msg ;

  00016	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 121  : 			delete this->MsgIndex[n];

  0001f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN3@lMsgFree:

; 116  : 	for ( int n = 0; n < 32768; n++ )

  0002a	83 c6 04	 add	 esi, 4
  0002d	4f		 dec	 edi
  0002e	75 e0		 jne	 SHORT $LL4@lMsgFree

; 122  : 		}
; 123  : 	}
; 124  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	c3		 ret	 0
?lMsgFree@CMsg@@AAEXXZ ENDP				; CMsg::lMsgFree
_TEXT	ENDS
PUBLIC	?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ		; CMsg::lMsgListNew
; Function compile flags: /Ogtp
;	COMDAT ?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ
_TEXT	SEGMENT
?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ PROC		; CMsg::lMsgListNew, COMDAT
; _this$ = ecx

; 128  : 	return new MSG_STRUCT;

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 129  : }

  0000a	c3		 ret	 0
?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ ENDP		; CMsg::lMsgListNew
_TEXT	ENDS
PUBLIC	??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@ ; `string'
PUBLIC	??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@ ; `string'
PUBLIC	?lMsgListAdd@CMsg@@AAEHHPAE@Z			; CMsg::lMsgListAdd
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT ??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@
CONST	SEGMENT
??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@ DB 'Message In'
	DB	'dex Table Make Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@
CONST	SEGMENT
??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@ DB 'Memory '
	DB	'Allocation Error #2(MuMsg)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?lMsgListAdd@CMsg@@AAEHHPAE@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
_smsg$ = 12						; size = 4
?lMsgListAdd@CMsg@@AAEHHPAE@Z PROC			; CMsg::lMsgListAdd, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 	int MsgLen=strlen((char*)smsg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _smsg$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000e	8b ff		 npad	 2
$LL11@lMsgListAd:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL11@lMsgListAd
  00017	2b c2		 sub	 eax, edx
  00019	8b d8		 mov	 ebx, eax

; 134  : 	char* pPointer;
; 135  : 	
; 136  : 	if ( MsgLen > 0 )

  0001b	85 db		 test	 ebx, ebx
  0001d	0f 8e 87 00 00
	00		 jle	 $LN1@lMsgListAd

; 137  : 	{
; 138  : 		this->MsgIndex[index]=this->lMsgListNew();

  00023	8b cf		 mov	 ecx, edi
  00025	e8 00 00 00 00	 call	 ?lMsgListNew@CMsg@@AAEPAUMSG_STRUCT@@XZ ; CMsg::lMsgListNew
  0002a	8b 75 08	 mov	 esi, DWORD PTR _index$[ebp]
  0002d	89 44 b7 08	 mov	 DWORD PTR [edi+esi*4+8], eax

; 139  : 	
; 140  : 		if (this->MsgIndex[index] == 0)

  00031	85 c0		 test	 eax, eax
  00033	75 1b		 jne	 SHORT $LN5@lMsgListAd

; 141  : 		{
; 142  : 			MessageBox(NULL, "Memory Allocation Error #2(MuMsg)", "Error", MB_OK);

  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PKJPBHBB@Memory?5Allocation?5Error?5?$CD2?$CIMuMsg@
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 143  : 			return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	5b		 pop	 ebx

; 170  : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN5@lMsgListAd:

; 144  : 		}
; 145  : 
; 146  : 		pPointer = new char[MsgLen+1];

  00050	43		 inc	 ebx
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00057	83 c4 04	 add	 esp, 4

; 147  : 		
; 148  : 		if ( pPointer  != 0 )

  0005a	85 c0		 test	 eax, eax
  0005c	74 4c		 je	 SHORT $LN1@lMsgListAd

; 149  : 		{
; 150  : 			this->MsgIndex[index]->number=index;

  0005e	8b 4c b7 08	 mov	 ecx, DWORD PTR [edi+esi*4+8]
  00062	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 151  : 		
; 152  : 			
; 153  : 			if ( index >= 0 || index < 32767 )

  00065	85 f6		 test	 esi, esi
  00067	79 25		 jns	 SHORT $LN2@lMsgListAd
  00069	81 fe ff 7f 00
	00		 cmp	 esi, 32767		; 00007fffH
  0006f	7c 1d		 jl	 SHORT $LN2@lMsgListAd

; 157  : 				return 1;
; 158  : 			}
; 159  : 			else
; 160  : 			{
; 161  : 				MessageBox(NULL, "Message Index Table Make Error", "Error", MB_OK);

  00071	6a 00		 push	 0
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CIHPAEKD@Message?5Index?5Table?5Make?5Error?$AA@
  0007d	6a 00		 push	 0
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi

; 162  : 				return 0;

  00087	33 c0		 xor	 eax, eax
  00089	5b		 pop	 ebx

; 170  : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN2@lMsgListAd:

; 154  : 			{
; 155  : 				this->MsgIndex[index]->msg = (unsigned char*)pPointer;

  0008e	8b 54 b7 08	 mov	 edx, DWORD PTR [edi+esi*4+8]

; 156  : 				strcpy((char*)this->MsgIndex[index]->msg , (char*)smsg);

  00092	8b 4d 0c	 mov	 ecx, DWORD PTR _smsg$[ebp]
  00095	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00098	8b 44 b7 08	 mov	 eax, DWORD PTR [edi+esi*4+8]
  0009c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0009f	90		 npad	 1
$LL9@lMsgListAd:
  000a0	8a 01		 mov	 al, BYTE PTR [ecx]
  000a2	88 02		 mov	 BYTE PTR [edx], al
  000a4	41		 inc	 ecx
  000a5	42		 inc	 edx
  000a6	84 c0		 test	 al, al
  000a8	75 f6		 jne	 SHORT $LL9@lMsgListAd
$LN1@lMsgListAd:
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi

; 163  : 			}
; 164  : 
; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 
; 169  : 	return 1;

  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	5b		 pop	 ebx

; 170  : }

  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
?lMsgListAdd@CMsg@@AAEHHPAE@Z ENDP			; CMsg::lMsgListAdd
_TEXT	ENDS
PUBLIC	??_C@_07BEIHKDLJ@Message?$AA@			; `string'
PUBLIC	?lMsgListPrint@CMsg@@AAEXXZ			; CMsg::lMsgListPrint
;	COMDAT ??_C@_07BEIHKDLJ@Message?$AA@
CONST	SEGMENT
??_C@_07BEIHKDLJ@Message?$AA@ DB 'Message', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?lMsgListPrint@CMsg@@AAEXXZ
_TEXT	SEGMENT
?lMsgListPrint@CMsg@@AAEXXZ PROC			; CMsg::lMsgListPrint, COMDAT
; _this$ = ecx

; 173  : {

  00000	53		 push	 ebx

; 174  : 	for ( int n = 0; n<32768 ; n++)

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MessageBoxA@16
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  0000c	bf 00 80 00 00	 mov	 edi, 32768		; 00008000H
$LL4@lMsgListPr:

; 175  : 	{
; 176  : 		if ( this->MsgIndex[n] != 0 )

  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	85 c0		 test	 eax, eax
  00015	74 0f		 je	 SHORT $LN3@lMsgListPr

; 177  : 		{
; 178  : 			MessageBox(NULL, (char*)this->MsgIndex[n]->msg, "Message", MB_OK);

  00017	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001a	6a 00		 push	 0
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_07BEIHKDLJ@Message?$AA@
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	ff d3		 call	 ebx
$LN3@lMsgListPr:

; 174  : 	for ( int n = 0; n<32768 ; n++)

  00026	83 c6 04	 add	 esi, 4
  00029	4f		 dec	 edi
  0002a	75 e5		 jne	 SHORT $LL4@lMsgListPr

; 179  : 		}
; 180  : 	}
; 181  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	c3		 ret	 0
?lMsgListPrint@CMsg@@AAEXXZ ENDP			; CMsg::lMsgListPrint
_TEXT	ENDS
PUBLIC	?Get@CMsg@@QAEPADH@Z				; CMsg::Get
; Function compile flags: /Ogtp
;	COMDAT ?Get@CMsg@@QAEPADH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?Get@CMsg@@QAEPADH@Z PROC				; CMsg::Get, COMDAT
; _this$ = ecx

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 185  : 	if ( index >= 0 && index < 32768 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00006	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0000b	77 14		 ja	 SHORT $LN4@Get

; 186  : 	{
; 187  : 		if ( this->MsgIndex[index] == 0 )

  0000d	8b 44 81 08	 mov	 eax, DWORD PTR [ecx+eax*4+8]
  00011	85 c0		 test	 eax, eax

; 188  : 		{
; 189  : 			return this->szDefaultMsg;

  00013	74 0c		 je	 SHORT $LN4@Get

; 190  : 		}
; 191  : 			
; 192  : 		if ( this->MsgIndex[index]->msg == 0 )

  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	85 c0		 test	 eax, eax

; 193  : 		{
; 194  : 			return this->szDefaultMsg;

  0001a	74 05		 je	 SHORT $LN4@Get

; 195  : 		}
; 196  : 
; 197  : 		if ( *this->MsgIndex[index]->msg == 0 )

  0001c	80 38 00	 cmp	 BYTE PTR [eax], 0

; 198  : 		{
; 199  : 			return this->szDefaultMsg;
; 200  : 		}
; 201  : 
; 202  : 		return (char*)this->MsgIndex[index]->msg;

  0001f	75 06		 jne	 SHORT $LN5@Get
$LN4@Get:

; 203  : 	}
; 204  : 	return (char*)this->szDefaultMsg;

  00021	8d 81 24 00 02
	00		 lea	 eax, DWORD PTR [ecx+131108]
$LN5@Get:

; 205  : 		
; 206  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Get@CMsg@@QAEPADH@Z ENDP				; CMsg::Get
_TEXT	ENDS
PUBLIC	??1CMsg@@QAE@XZ					; CMsg::~CMsg
; Function compile flags: /Ogtp
;	COMDAT ??1CMsg@@QAE@XZ
_TEXT	SEGMENT
??1CMsg@@QAE@XZ PROC					; CMsg::~CMsg, COMDAT
; _this$ = ecx

; 20   : 	this->lMsgFree();

  00000	e9 00 00 00 00	 jmp	 ?lMsgFree@CMsg@@AAEXXZ	; CMsg::lMsgFree
??1CMsg@@QAE@XZ ENDP					; CMsg::~CMsg
_TEXT	ENDS
PUBLIC	??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z	; CMsg::DataFileLoadVer01
EXTRN	_fread:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@ DB 0c0H
	DB	0d0H, 0b4H, 0c2H, 0c1H, 0dfH, ' ', 0b5H, 0a5H, 0c0H, 0ccH, 0c5H
	DB	0cdH, 0c0H, 0c7H, 0b0H, 0b3H, 0bcH, 0f6H, ' ', 0bfH, 0a1H, 0b7H
	DB	0afH, ' ', 0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z
_TEXT	SEGMENT
_Index$ = -268						; size = 2
_Len$ = -264						; size = 2
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z PROC		; CMsg::DataFileLoadVer01, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	57		 push	 edi

; 38   : 	unsigned char szTemp[256];
; 39   : 	short Index;
; 40   : 	unsigned short Len;
; 41   : 
; 42   : 	int Max=this->LoadHeader.count;

  0001b	8b bb 20 00 02
	00		 mov	 edi, DWORD PTR [ebx+131104]

; 43   : 
; 44   : 	if (Max <= 0)

  00021	85 ff		 test	 edi, edi
  00023	7f 2b		 jg	 SHORT $LL2@DataFileLo

; 45   : 	{
; 46   : 		MessageBox(NULL, "읽는중 데이터의개수 에러 입니다."	, "Error", MB_OK|MB_APPLMODAL); // Modification error data while reading

  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JGNNNKFK@?$MA?P?$LE?B?A?$NP?5?$LF?$KF?$MA?L?E?M?$MA?G?$LA?$LD?$LM?v?5?$LP?$KB?$LH?$KP?5?$MA?T?$LE?O?$LE?Y?4@
  00031	6a 00		 push	 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 61   : 	} 
; 62   : }

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
  0004c	8d 64 24 00	 npad	 4
$LL2@DataFileLo:

; 47   : 		return;
; 48   : 	}
; 49   : 
; 50   : 	while ( Max-- )
; 51   : 	{
; 52   : 		memset(&szTemp, 0, sizeof(szTemp) );

  00050	68 00 01 00 00	 push	 256			; 00000100H
  00055	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0005b	6a 00		 push	 0
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memset

; 53   : 
; 54   : 		fread(&Index , 2, 1, filename);

  00063	56		 push	 esi
  00064	6a 01		 push	 1
  00066	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _Index$[ebp]
  0006c	6a 02		 push	 2
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _fread

; 55   : 		fread(&Len , 2, 1, filename);

  00074	56		 push	 esi
  00075	6a 01		 push	 1
  00077	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _Len$[ebp]
  0007d	6a 02		 push	 2
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 _fread

; 56   : 		fread(szTemp , Len , 1, filename);

  00085	0f b7 85 f8 fe
	ff ff		 movzx	 eax, WORD PTR _Len$[ebp]
  0008c	56		 push	 esi
  0008d	6a 01		 push	 1
  0008f	50		 push	 eax
  00090	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _fread

; 57   : 		szTemp[Len]=0;

  0009c	0f b7 85 f8 fe
	ff ff		 movzx	 eax, WORD PTR _Len$[ebp]
  000a3	83 c4 3c	 add	 esp, 60			; 0000003cH

; 58   : 
; 59   : 		this->XorBuffer((char*)szTemp , Len );

  000a6	50		 push	 eax
  000a7	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  000ad	52		 push	 edx
  000ae	8b cb		 mov	 ecx, ebx
  000b0	c6 84 05 fc fe
	ff ff 00	 mov	 BYTE PTR _szTemp$[ebp+eax], 0
  000b8	e8 00 00 00 00	 call	 ?XorBuffer@CMsg@@AAEXPADH@Z ; CMsg::XorBuffer

; 60   : 		this->lMsgListAdd( Index, (unsigned char*) szTemp);

  000bd	0f bf 8d f4 fe
	ff ff		 movsx	 ecx, WORD PTR _Index$[ebp]
  000c4	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  000ca	50		 push	 eax
  000cb	51		 push	 ecx
  000cc	8b cb		 mov	 ecx, ebx
  000ce	e8 00 00 00 00	 call	 ?lMsgListAdd@CMsg@@AAEHHPAE@Z ; CMsg::lMsgListAdd
  000d3	4f		 dec	 edi
  000d4	0f 85 76 ff ff
	ff		 jne	 $LL2@DataFileLo

; 61   : 	} 
; 62   : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	33 cd		 xor	 ecx, ebp
  000e1	5b		 pop	 ebx
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z ENDP		; CMsg::DataFileLoadVer01
_TEXT	ENDS
PUBLIC	??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@ ; `string'
PUBLIC	??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@	; `string'
PUBLIC	??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadWTF@CMsg@@QAEXPAD@Z			; CMsg::LoadWTF
EXTRN	_fclose:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@
CONST	SEGMENT
??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@ DB 0c1H
	DB	0f6H, 0bfH, 0f8H, 0c7H, 0cfH, 0c1H, 0f6H, ' ', 0beH, 0caH, 0b4H
	DB	0c2H, ' ', 0b9H, 0f6H, 0c1H, 0afH, ' ', 0b5H, 0a5H, 0c0H, 0ccH
	DB	0c5H, 0cdH, ' ', 0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@
CONST	SEGMENT
??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@ DB 'TextCode Type Wrong.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@ DB 'Could not open %s.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadWTF@CMsg@@QAEXPAD@Z
_TEXT	SEGMENT
_szBufferError$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?LoadWTF@CMsg@@QAEXPAD@Z PROC				; CMsg::LoadWTF, COMDAT
; _this$ = ecx

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _filename$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 66   : 	FILE* WTFFile;
; 67   : 	char szBufferError[128];
; 68   : 	
; 69   : 	WTFFile =fopen(filename, "rb");	//ok

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0001e	53		 push	 ebx
  0001f	8b f9		 mov	 edi, ecx
  00021	e8 00 00 00 00	 call	 _fopen
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 08	 add	 esp, 8

; 70   : 	
; 71   : 	if (WTFFile == 0 )

  0002b	85 f6		 test	 esi, esi
  0002d	75 3d		 jne	 SHORT $LN6@LoadWTF

; 72   : 	{
; 73   : 		wsprintf(szBufferError, "Could not open %s.", filename);	

  0002f	53		 push	 ebx
  00030	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szBufferError$[ebp]
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LBFAGOFH@Could?5not?5open?5?$CFs?4?$AA@
  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 74   : 		MessageBox(NULL, szBufferError, "Error", MB_OK|MB_APPLMODAL);

  00045	56		 push	 esi
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  0004b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szBufferError$[ebp]
  00051	51		 push	 ecx
  00052	56		 push	 esi
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 95   : 	}
; 96   : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
$LN6@LoadWTF:

; 75   : 		return;
; 76   : 	}
; 77   : 
; 78   : 	if (this->lMsgListInit() != 0)

  0006c	8b cf		 mov	 ecx, edi
  0006e	e8 00 00 00 00	 call	 ?lMsgListInit@CMsg@@AAEHXZ ; CMsg::lMsgListInit
  00073	85 c0		 test	 eax, eax
  00075	74 60		 je	 SHORT $LN5@LoadWTF

; 79   : 	{
; 80   : 		fread(&this->LoadHeader, 28, 1, WTFFile);

  00077	56		 push	 esi
  00078	6a 01		 push	 1
  0007a	8d 9f 08 00 02
	00		 lea	 ebx, DWORD PTR [edi+131080]
  00080	6a 1c		 push	 28			; 0000001cH
  00082	53		 push	 ebx
  00083	e8 00 00 00 00	 call	 _fread
  00088	83 c4 10	 add	 esp, 16			; 00000010H

; 81   : 
; 82   : 		if (this->LoadHeader.headcode != 0xCC)

  0008b	80 3b cc	 cmp	 BYTE PTR [ebx], 204	; 000000ccH
  0008e	74 16		 je	 SHORT $LN4@LoadWTF

; 83   : 		{
; 84   : 			MessageBox(NULL, "TextCode Type Wrong.", "Error", MB_OK|MB_APPLMODAL);

  00090	6a 00		 push	 0
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OLFGABCH@TextCode?5Type?5Wrong?4?$AA@
  0009c	6a 00		 push	 0
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  000a4	eb 28		 jmp	 SHORT $LN1@LoadWTF
$LN4@LoadWTF:

; 85   : 		}
; 86   : 		else if ( (this->LoadHeader.version -1) != 0)

  000a6	0f b6 97 09 00
	02 00		 movzx	 edx, BYTE PTR [edi+131081]
  000ad	4a		 dec	 edx
  000ae	74 16		 je	 SHORT $LN2@LoadWTF

; 87   : 		{
; 88   : 			MessageBox(NULL, "지원하지 않는 버젼 데이터 입니다.", "Error", MB_OK|MB_APPLMODAL);

  000b0	6a 00		 push	 0
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_05NAOIJFC@Error?$AA@
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ILABMKML@?A?v?$LP?x?G?O?A?v?5?$LO?J?$LE?B?5?$LJ?v?A?$KP?5?$LF?$KF?$MA?L?E?M?5?$MA?T?$LE?O?$LE?Y@
  000bc	6a 00		 push	 0
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 89   : 		}
; 90   : 		else

  000c4	eb 08		 jmp	 SHORT $LN1@LoadWTF
$LN2@LoadWTF:

; 91   : 		{
; 92   : 			DataFileLoadVer01(WTFFile);

  000c6	56		 push	 esi
  000c7	8b cf		 mov	 ecx, edi
  000c9	e8 00 00 00 00	 call	 ?DataFileLoadVer01@CMsg@@AAEXPAU_iobuf@@@Z ; CMsg::DataFileLoadVer01
$LN1@LoadWTF:

; 93   : 		}
; 94   : 		fclose(WTFFile);

  000ce	56		 push	 esi
  000cf	e8 00 00 00 00	 call	 _fclose
  000d4	83 c4 04	 add	 esp, 4
$LN5@LoadWTF:

; 95   : 	}
; 96   : }

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	33 cd		 xor	 ecx, ebp
  000de	5b		 pop	 ebx
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
?LoadWTF@CMsg@@QAEXPAD@Z ENDP				; CMsg::LoadWTF
_TEXT	ENDS
END
