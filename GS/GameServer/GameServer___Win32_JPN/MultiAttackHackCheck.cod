; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\MultiAttackHackCheck.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\skilladditioninfo.h
;	COMDAT ?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial, COMDAT
; _this$ = ecx

; 53   : 	int GetFireScreamMaxAttackCountSameSerial(){return this->m_iFireScreamMaxAttackCountSameSerial;}

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00003	c3		 ret	 0
?GetFireScreamMaxAttackCountSameSerial@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamMaxAttackCountSameSerial
_TEXT	ENDS
PUBLIC	?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetFireScreamSerialInitCount
; Function compile flags: /Ogtp
;	COMDAT ?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetFireScreamSerialInitCount, COMDAT
; _this$ = ecx

; 55   : 	int GetFireScreamSerialInitCount(){return this->m_iFireScreamSerialInitCount;}

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	c3		 ret	 0
?GetFireScreamSerialInitCount@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetFireScreamSerialInitCount
_TEXT	ENDS
PUBLIC	?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ; CSkillAdditionInfo::GetCheckFireScreamSkill
; Function compile flags: /Ogtp
;	COMDAT ?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ
_TEXT	SEGMENT
?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ PROC ; CSkillAdditionInfo::GetCheckFireScreamSkill, COMDAT
; _this$ = ecx

; 57   : 	BOOL GetCheckFireScreamSkill(){return this->m_bCheckFireScreamSerial;}

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	c3		 ret	 0
?GetCheckFireScreamSkill@CSkillAdditionInfo@@QAEHXZ ENDP ; CSkillAdditionInfo::GetCheckFireScreamSkill
_TEXT	ENDS
PUBLIC	??_7CMultiAttackHackCheck@@6B@			; CMultiAttackHackCheck::`vftable'
PUBLIC	??1CMultiAttackHackCheck@@UAE@XZ		; CMultiAttackHackCheck::~CMultiAttackHackCheck
PUBLIC	??_R4CMultiAttackHackCheck@@6B@			; CMultiAttackHackCheck::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMultiAttackHackCheck@@@8		; CMultiAttackHackCheck `RTTI Type Descriptor'
PUBLIC	??_R3CMultiAttackHackCheck@@8			; CMultiAttackHackCheck::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMultiAttackHackCheck@@8			; CMultiAttackHackCheck::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMultiAttackHackCheck@@8		; CMultiAttackHackCheck::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMultiAttackHackCheck@@UAEPAXI@Z:PROC	; CMultiAttackHackCheck::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMultiAttackHackCheck@@8
; File e:\work\tranet_version\gs\gameserver\multiattackhackcheck.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMultiAttackHackCheck@@8 DD FLAT:??_R0?AVCMultiAttackHackCheck@@@8 ; CMultiAttackHackCheck::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_R2CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R2CMultiAttackHackCheck@@8 DD FLAT:??_R1A@?0A@EA@CMultiAttackHackCheck@@8 ; CMultiAttackHackCheck::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R3CMultiAttackHackCheck@@8 DD 00H			; CMultiAttackHackCheck::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMultiAttackHackCheck@@@8
_DATA	SEGMENT
??_R0?AVCMultiAttackHackCheck@@@8 DD FLAT:??_7type_info@@6B@ ; CMultiAttackHackCheck `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMultiAttackHackCheck@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMultiAttackHackCheck@@6B@
rdata$r	SEGMENT
??_R4CMultiAttackHackCheck@@6B@ DD 00H			; CMultiAttackHackCheck::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMultiAttackHackCheck@@@8
	DD	FLAT:??_R3CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_7CMultiAttackHackCheck@@6B@
CONST	SEGMENT
??_7CMultiAttackHackCheck@@6B@ DD FLAT:??_R4CMultiAttackHackCheck@@6B@ ; CMultiAttackHackCheck::`vftable'
	DD	FLAT:??_ECMultiAttackHackCheck@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CMultiAttackHackCheck@@UAE@XZ
_TEXT	SEGMENT
??1CMultiAttackHackCheck@@UAE@XZ PROC			; CMultiAttackHackCheck::~CMultiAttackHackCheck, COMDAT
; _this$ = ecx

; 18   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMultiAttackHackCheck@@6B@

; 19   : 	return;
; 20   : }

  00006	c3		 ret	 0
??1CMultiAttackHackCheck@@UAE@XZ ENDP			; CMultiAttackHackCheck::~CMultiAttackHackCheck
_TEXT	ENDS
PUBLIC	?Init@CMultiAttackHackCheck@@QAEXXZ		; CMultiAttackHackCheck::Init
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Init@CMultiAttackHackCheck@@QAEXXZ
_TEXT	SEGMENT
?Init@CMultiAttackHackCheck@@QAEXXZ PROC		; CMultiAttackHackCheck::Init, COMDAT
; _this$ = ecx

; 23   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 24   : 	this->m_iCount = 0;

  00002	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00009	8d 71 0a	 lea	 esi, DWORD PTR [ecx+10]
  0000c	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
$LL3@Init:

; 25   : 
; 26   : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)
; 27   : 	{
; 28   : 		this->m_Table[i].number = -1;
; 29   : 		memset(this->m_Table[i].Serial, 0, sizeof(this->m_Table[i].Serial));

  00011	68 ff 00 00 00	 push	 255			; 000000ffH
  00016	83 c8 ff	 or	 eax, -1
  00019	6a 00		 push	 0
  0001b	56		 push	 esi
  0001c	66 89 46 fe	 mov	 WORD PTR [esi-2], ax
  00020	e8 00 00 00 00	 call	 _memset
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	81 c6 02 01 00
	00		 add	 esi, 258		; 00000102H
  0002e	4f		 dec	 edi
  0002f	75 e0		 jne	 SHORT $LL3@Init

; 30   : 	}
; 31   : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	c3		 ret	 0
?Init@CMultiAttackHackCheck@@QAEXXZ ENDP		; CMultiAttackHackCheck::Init
_TEXT	ENDS
PUBLIC	?Insert@CMultiAttackHackCheck@@QAEHHEE@Z	; CMultiAttackHackCheck::Insert
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?Insert@CMultiAttackHackCheck@@QAEHHEE@Z
_TEXT	SEGMENT
tv431 = -8						; size = 4
_i$202653 = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
_skillnum$ = 12						; size = 1
_serial$ = 16						; size = 1
?Insert@CMultiAttackHackCheck@@QAEHHEE@Z PROC		; CMultiAttackHackCheck::Insert, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	if ( gObj[aTargetIndex].Type == OBJ_MONSTER )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00006	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000c	83 ec 08	 sub	 esp, 8
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	66 83 7c 08 68
	02		 cmp	 WORD PTR [eax+ecx+104], 2
  0001e	75 0c		 jne	 SHORT $LN12@Insert
$LN22@Insert:

; 39   : 	{
; 40   : 		return TRUE;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	5e		 pop	 esi

; 81   : 	}
; 82   : 
; 83   : 	return TRUE;
; 84   : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN12@Insert:

; 41   : 	}
; 42   : 
; 43   : 	if ( skillnum == 12 )

  0002c	80 7d 0c 0c	 cmp	 BYTE PTR _skillnum$[ebp], 12 ; 0000000cH

; 44   : 	{
; 45   : 		return TRUE;

  00030	74 ee		 je	 SHORT $LN22@Insert

; 46   : 	}
; 47   : 
; 48   : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  00032	53		 push	 ebx
  00033	8a 5d 10	 mov	 bl, BYTE PTR _serial$[ebp]
  00036	ba f8 ff ff ff	 mov	 edx, -8			; fffffff8H
  0003b	2b d6		 sub	 edx, esi
  0003d	57		 push	 edi
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$202653[ebp], 0
  00045	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00048	89 55 f8	 mov	 DWORD PTR tv431[ebp], edx
  0004b	eb 03 8d 49 00	 npad	 5
$LL19@Insert:

; 49   : 	{
; 50   : 		if ( this->m_Table[i].number == aTargetIndex )

  00050	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00053	3b 45 08	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]
  00056	75 39		 jne	 SHORT $LN9@Insert

; 51   : 		{
; 52   : 			if ( serial == (BYTE)-1  && this->m_Table[i].Serial[serial]  != 0 )

  00058	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0005b	75 1f		 jne	 SHORT $LN6@Insert
  0005d	80 bf 01 01 00
	00 00		 cmp	 BYTE PTR [edi+257], 0
  00064	74 16		 je	 SHORT $LN6@Insert

; 53   : 			{
; 54   : 				memset(this->m_Table[i].Serial, 0, MULTI_ATTACK_SERIAL_SIZE);

  00066	68 ff 00 00 00	 push	 255			; 000000ffH
  0006b	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  0006e	6a 00		 push	 0
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _memset
  00076	8b 55 f8	 mov	 edx, DWORD PTR tv431[ebp]
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Insert:

; 55   : 			}
; 56   : 
; 57   : 			this->m_Table[i].Serial[serial]++;

  0007c	0f b6 c3	 movzx	 eax, bl
  0007f	03 c2		 add	 eax, edx
  00081	03 c7		 add	 eax, edi
  00083	8d 4c 30 0a	 lea	 ecx, DWORD PTR [eax+esi+10]
  00087	8a 01		 mov	 al, BYTE PTR [ecx]
  00089	fe c0		 inc	 al
  0008b	88 01		 mov	 BYTE PTR [ecx], al

; 58   : 
; 59   : 			if ( skillnum == 9 )
; 60   : 			{
; 61   : 				if ( this->m_Table[i].Serial[serial] > 6 )
; 62   : 				{
; 63   : 					return FALSE;
; 64   : 				}
; 65   : 			}
; 66   : 			else if ( this->m_Table[i].Serial[serial] > 6 )

  0008d	3c 06		 cmp	 al, 6
  0008f	77 58		 ja	 SHORT $LN17@Insert
$LN9@Insert:

; 46   : 	}
; 47   : 
; 48   : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  00091	8b 45 fc	 mov	 eax, DWORD PTR _i$202653[ebp]
  00094	40		 inc	 eax
  00095	81 c7 02 01 00
	00		 add	 edi, 258		; 00000102H
  0009b	89 45 fc	 mov	 DWORD PTR _i$202653[ebp], eax
  0009e	83 f8 28	 cmp	 eax, 40			; 00000028H
  000a1	7c ad		 jl	 SHORT $LL19@Insert

; 69   : 			}
; 70   : 		}
; 71   : 	}
; 72   : 
; 73   : 	this->m_Table[this->m_iCount].number = aTargetIndex;

  000a3	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000a6	66 8b 55 08	 mov	 dx, WORD PTR _aTargetIndex$[ebp]
  000aa	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  000b0	66 89 54 31 08	 mov	 WORD PTR [ecx+esi+8], dx

; 74   : 	this->m_Table[this->m_iCount].Serial[serial]++;

  000b5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b8	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  000be	0f b6 cb	 movzx	 ecx, bl
  000c1	03 c6		 add	 eax, esi
  000c3	fe 44 01 0a	 inc	 BYTE PTR [ecx+eax+10]
  000c7	8d 44 01 0a	 lea	 eax, DWORD PTR [ecx+eax+10]

; 75   : 	this->m_iCount++;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	01 46 04	 add	 DWORD PTR [esi+4], eax

; 76   : 
; 77   : 
; 78   : 	if ( this->m_iCount >= MAX_MULTI_ATTACK_INFO )

  000d3	83 7e 04 28	 cmp	 DWORD PTR [esi+4], 40	; 00000028H
  000d7	7c 07		 jl	 SHORT $LN20@Insert

; 79   : 	{
; 80   : 		this->m_iCount = 0;

  000d9	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN20@Insert:
  000e0	5f		 pop	 edi
  000e1	5b		 pop	 ebx
  000e2	5e		 pop	 esi

; 81   : 	}
; 82   : 
; 83   : 	return TRUE;
; 84   : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 0c 00	 ret	 12			; 0000000cH
$LN17@Insert:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 67   : 			{
; 68   : 				return FALSE;

  000eb	33 c0		 xor	 eax, eax
  000ed	5e		 pop	 esi

; 81   : 	}
; 82   : 
; 83   : 	return TRUE;
; 84   : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 0c 00	 ret	 12			; 0000000cH
?Insert@CMultiAttackHackCheck@@QAEHHEE@Z ENDP		; CMultiAttackHackCheck::Insert
_TEXT	ENDS
PUBLIC	?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ; CMultiAttackHackCheck::CheckPenetrationSkill
; Function compile flags: /Ogtp
;	COMDAT ?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z
_TEXT	SEGMENT
_aTargetIndex$ = 8					; size = 4
_i$202673 = 12						; size = 4
_skillnum$ = 12						; size = 1
tv385 = 16						; size = 4
_serial$ = 16						; size = 1
?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z PROC ; CMultiAttackHackCheck::CheckPenetrationSkill, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   : 	if ( skillnum != 52 )

  00003	80 7d 0c 34	 cmp	 BYTE PTR _skillnum$[ebp], 52 ; 00000034H
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 0a		 je	 SHORT $LN9@CheckPenet

; 92   : 	{
; 93   : 		return TRUE;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	5e		 pop	 esi

; 127  : 	}
; 128  : 
; 129  : 	return TRUE;
; 130  : }

  00012	5d		 pop	 ebp
  00013	c2 0c 00	 ret	 12			; 0000000cH
$LN9@CheckPenet:
  00016	53		 push	 ebx

; 94   : 	}
; 95   : 
; 96   : 	if ( serial == 10 )

  00017	8a 5d 10	 mov	 bl, BYTE PTR _serial$[ebp]
  0001a	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  0001d	75 05		 jne	 SHORT $LN8@CheckPenet

; 97   : 	{
; 98   : 		this->Init();

  0001f	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init
$LN8@CheckPenet:

; 99   : 	}
; 100  : 
; 101  : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  00024	b9 f8 ff ff ff	 mov	 ecx, -8			; fffffff8H
  00029	2b ce		 sub	 ecx, esi
  0002b	57		 push	 edi
  0002c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _i$202673[ebp], 0
  00033	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00036	89 4d 10	 mov	 DWORD PTR tv385[ebp], ecx
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL7@CheckPenet:

; 102  : 	{
; 103  : 		if ( this->m_Table[i].number == aTargetIndex )

  00040	0f bf 07	 movsx	 eax, WORD PTR [edi]
  00043	3b 45 08	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]
  00046	75 37		 jne	 SHORT $LN6@CheckPenet

; 104  : 		{
; 105  : 			if ( serial == 10 && this->m_Table[i].Serial[serial] != 0 )

  00048	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  0004b	75 1c		 jne	 SHORT $LN15@CheckPenet
  0004d	80 7f 0c 00	 cmp	 BYTE PTR [edi+12], 0
  00051	74 16		 je	 SHORT $LN15@CheckPenet

; 106  : 			{
; 107  : 				memset(this->m_Table[i].Serial , 0, MULTI_ATTACK_SERIAL_SIZE);

  00053	68 ff 00 00 00	 push	 255			; 000000ffH
  00058	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  0005b	6a 00		 push	 0
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _memset
  00063	8b 4d 10	 mov	 ecx, DWORD PTR tv385[ebp]
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@CheckPenet:

; 108  : 			}
; 109  : 			
; 110  : 			this->m_Table[i].Serial[serial]++;

  00069	0f b6 d3	 movzx	 edx, bl
  0006c	03 d1		 add	 edx, ecx
  0006e	03 d7		 add	 edx, edi
  00070	fe 44 32 0a	 inc	 BYTE PTR [edx+esi+10]

; 111  : 
; 112  : 			if ( this->m_Table[i].Serial[serial] > 1 )

  00074	80 7c 32 0a 01	 cmp	 BYTE PTR [edx+esi+10], 1
  00079	8d 44 32 0a	 lea	 eax, DWORD PTR [edx+esi+10]
  0007d	77 56		 ja	 SHORT $LN13@CheckPenet
$LN6@CheckPenet:

; 99   : 	}
; 100  : 
; 101  : 	for ( int i=0;i<MAX_MULTI_ATTACK_INFO;i++)

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _i$202673[ebp]
  00082	40		 inc	 eax
  00083	81 c7 02 01 00
	00		 add	 edi, 258		; 00000102H
  00089	89 45 0c	 mov	 DWORD PTR _i$202673[ebp], eax
  0008c	83 f8 28	 cmp	 eax, 40			; 00000028H
  0008f	7c af		 jl	 SHORT $LL7@CheckPenet

; 115  : 			}
; 116  : 		}
; 117  : 	}
; 118  : 
; 119  : 	this->m_Table[this->m_iCount].number = aTargetIndex;

  00091	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00094	66 8b 4d 08	 mov	 cx, WORD PTR _aTargetIndex$[ebp]
  00098	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  0009e	66 89 4c 30 08	 mov	 WORD PTR [eax+esi+8], cx

; 120  : 	this->m_Table[this->m_iCount].Serial[serial]++;

  000a3	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000a6	69 d2 02 01 00
	00		 imul	 edx, 258		; 00000102H
  000ac	0f b6 c3	 movzx	 eax, bl
  000af	03 d6		 add	 edx, esi
  000b1	fe 44 10 0a	 inc	 BYTE PTR [eax+edx+10]
  000b5	8d 44 10 0a	 lea	 eax, DWORD PTR [eax+edx+10]

; 121  : 	this->m_iCount++;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	01 46 04	 add	 DWORD PTR [esi+4], eax

; 122  : 
; 123  : 
; 124  : 	if ( this->m_iCount >= MAX_MULTI_ATTACK_INFO )

  000c1	83 7e 04 28	 cmp	 DWORD PTR [esi+4], 40	; 00000028H
  000c5	7c 07		 jl	 SHORT $LN19@CheckPenet

; 125  : 	{
; 126  : 		this->m_iCount = 0;

  000c7	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN19@CheckPenet:
  000ce	5f		 pop	 edi
  000cf	5b		 pop	 ebx
  000d0	5e		 pop	 esi

; 127  : 	}
; 128  : 
; 129  : 	return TRUE;
; 130  : }

  000d1	5d		 pop	 ebp
  000d2	c2 0c 00	 ret	 12			; 0000000cH
$LN13@CheckPenet:
  000d5	5f		 pop	 edi
  000d6	5b		 pop	 ebx

; 113  : 			{
; 114  : 				return FALSE;

  000d7	33 c0		 xor	 eax, eax
  000d9	5e		 pop	 esi

; 127  : 	}
; 128  : 
; 129  : 	return TRUE;
; 130  : }

  000da	5d		 pop	 ebp
  000db	c2 0c 00	 ret	 12			; 0000000cH
?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ENDP ; CMultiAttackHackCheck::CheckPenetrationSkill
_TEXT	ENDS
PUBLIC	?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z ; CMultiAttackHackCheck::CheckFireScreamSkill
EXTRN	?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A:BYTE ; g_SkillAdditionInfo
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
; Function compile flags: /Ogtp
;	COMDAT ?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z
_TEXT	SEGMENT
_iTargetIndex$ = 8					; size = 4
_btSkillNum$ = 12					; size = 1
_btSerial$ = 16						; size = 1
?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z PROC ; CMultiAttackHackCheck::CheckFireScreamSkill, COMDAT
; _this$ = ecx

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 137  : 	if( g_ZtLicense.CheckUser(eZtUB::Local)		 || 
; 138  : 		g_ZtLicense.CheckUser(eZtUB::Gredy)		 || 
; 139  : 		g_ZtLicense.CheckUser(eZtUB::GredyLocal) ||
; 140  : 		g_ZtLicense.CheckUser(eZtUB::Gredy2)	 ||
; 141  : 		g_ZtLicense.CheckUser(eZtUB::SILVER1)	 || 
; 142  : 		g_ZtLicense.CheckUser(eZtUB::SILVER2) )

  00006	6a 00		 push	 0
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00012	84 c0		 test	 al, al
  00014	75 59		 jne	 SHORT $LN9@CheckFireS
  00016	6a 20		 push	 32			; 00000020H
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0001d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00022	84 c0		 test	 al, al
  00024	75 49		 jne	 SHORT $LN9@CheckFireS
  00026	6a 21		 push	 33			; 00000021H
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0002d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00032	84 c0		 test	 al, al
  00034	75 39		 jne	 SHORT $LN9@CheckFireS
  00036	6a 22		 push	 34			; 00000022H
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0003d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00042	84 c0		 test	 al, al
  00044	75 29		 jne	 SHORT $LN9@CheckFireS
  00046	6a 07		 push	 7
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0004d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00052	84 c0		 test	 al, al
  00054	75 19		 jne	 SHORT $LN9@CheckFireS
  00056	6a 08		 push	 8
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0005d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00062	84 c0		 test	 al, al
  00064	75 09		 jne	 SHORT $LN9@CheckFireS

; 143  : 	{
; 144  : 		return true;
; 145  : 	}
; 146  : 
; 147  : 	if ( g_SkillAdditionInfo.GetCheckFireScreamSkill() == FALSE )

  00066	83 3d 30 00 00
	00 00		 cmp	 DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+48, 0
  0006d	75 0a		 jne	 SHORT $LN8@CheckFireS
$LN9@CheckFireS:

; 148  : 		return TRUE;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	5e		 pop	 esi

; 176  : }

  00075	5d		 pop	 ebp
  00076	c2 0c 00	 ret	 12			; 0000000cH
$LN8@CheckFireS:

; 149  : 
; 150  : 	if ( btSerial > g_SkillAdditionInfo.GetFireScreamSerialInitCount()- 4)//NEW 

  00079	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+44
  0007e	57		 push	 edi
  0007f	0f b6 7d 10	 movzx	 edi, BYTE PTR _btSerial$[ebp]
  00083	83 c0 fc	 add	 eax, -4			; fffffffcH
  00086	3b f8		 cmp	 edi, eax
  00088	7e 07		 jle	 SHORT $LN7@CheckFireS

; 151  : 		this->Init();

  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init
$LN7@CheckFireS:

; 152  : 
; 153  : 	for ( int iCount = 0 ; iCount < MAX_MULTI_ATTACK_INFO ; iCount++)

  00091	8b 55 08	 mov	 edx, DWORD PTR _iTargetIndex$[ebp]
  00094	33 c0		 xor	 eax, eax
  00096	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00099	53		 push	 ebx
  0009a	8d 9b 00 00 00
	00		 npad	 6
$LL6@CheckFireS:

; 154  : 	{
; 155  : 		if ( this->m_Table[iCount].number == iTargetIndex )

  000a0	0f bf 19	 movsx	 ebx, WORD PTR [ecx]
  000a3	3b da		 cmp	 ebx, edx
  000a5	74 49		 je	 SHORT $LN20@CheckFireS

; 152  : 
; 153  : 	for ( int iCount = 0 ; iCount < MAX_MULTI_ATTACK_INFO ; iCount++)

  000a7	40		 inc	 eax
  000a8	81 c1 02 01 00
	00		 add	 ecx, 258		; 00000102H
  000ae	83 f8 28	 cmp	 eax, 40			; 00000028H
  000b1	7c ed		 jl	 SHORT $LL6@CheckFireS

; 160  : 			{
; 161  : 				return FALSE;
; 162  : 			}
; 163  : 
; 164  : 			return TRUE;//NEW
; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	this->m_Table[this->m_iCount].number = iTargetIndex;

  000b3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b6	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  000bc	66 89 54 30 08	 mov	 WORD PTR [eax+esi+8], dx

; 169  : 	this->m_Table[this->m_iCount].Serial[btSerial]+=1;

  000c1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c4	69 c9 02 01 00
	00		 imul	 ecx, 258		; 00000102H
  000ca	03 cf		 add	 ecx, edi
  000cc	fe 44 31 0a	 inc	 BYTE PTR [ecx+esi+10]

; 170  : 	this->m_iCount++;

  000d0	ff 46 04	 inc	 DWORD PTR [esi+4]

; 171  : 
; 172  : 	if ( this->m_iCount >= MAX_MULTI_ATTACK_INFO )

  000d3	83 7e 04 28	 cmp	 DWORD PTR [esi+4], 40	; 00000028H
  000d7	8d 44 31 0a	 lea	 eax, DWORD PTR [ecx+esi+10]
  000db	7c 07		 jl	 SHORT $LN1@CheckFireS

; 173  : 		this->m_iCount = 0;

  000dd	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN1@CheckFireS:
  000e4	5b		 pop	 ebx
  000e5	5f		 pop	 edi

; 174  : 
; 175  : 	return TRUE;

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	5e		 pop	 esi

; 176  : }

  000ec	5d		 pop	 ebp
  000ed	c2 0c 00	 ret	 12			; 0000000cH
$LN20@CheckFireS:

; 156  : 		{
; 157  : 			this->m_Table[iCount].Serial[btSerial]+=1;

  000f0	69 c0 02 01 00
	00		 imul	 eax, 258		; 00000102H
  000f6	03 c7		 add	 eax, edi
  000f8	fe 44 30 0a	 inc	 BYTE PTR [eax+esi+10]

; 158  : 
; 159  : 			if ( this->m_Table[iCount].Serial[btSerial] > g_SkillAdditionInfo.GetFireScreamMaxAttackCountSameSerial() )

  000fc	0f b6 4c 30 0a	 movzx	 ecx, BYTE PTR [eax+esi+10]
  00101	8d 44 30 0a	 lea	 eax, DWORD PTR [eax+esi+10]
  00105	33 c0		 xor	 eax, eax
  00107	3b 0d 28 00 00
	00		 cmp	 ecx, DWORD PTR ?g_SkillAdditionInfo@@3VCSkillAdditionInfo@@A+40
  0010d	5b		 pop	 ebx
  0010e	5f		 pop	 edi
  0010f	0f 9e c0	 setle	 al
  00112	5e		 pop	 esi

; 176  : }

  00113	5d		 pop	 ebp
  00114	c2 0c 00	 ret	 12			; 0000000cH
?CheckFireScreamSkill@CMultiAttackHackCheck@@QAEHHEE@Z ENDP ; CMultiAttackHackCheck::CheckFireScreamSkill
_TEXT	ENDS
PUBLIC	??0CMultiAttackHackCheck@@QAE@XZ		; CMultiAttackHackCheck::CMultiAttackHackCheck
; Function compile flags: /Ogtp
;	COMDAT ??0CMultiAttackHackCheck@@QAE@XZ
_TEXT	SEGMENT
??0CMultiAttackHackCheck@@QAE@XZ PROC			; CMultiAttackHackCheck::CMultiAttackHackCheck, COMDAT
; _this$ = ecx

; 11   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMultiAttackHackCheck@@6B@

; 12   : 	this->Init();

  00009	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init

; 13   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CMultiAttackHackCheck@@QAE@XZ ENDP			; CMultiAttackHackCheck::CMultiAttackHackCheck
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCMultiAttackHackCheck@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMultiAttackHackCheck@@UAEPAXI@Z PROC		; CMultiAttackHackCheck::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMultiAttackHackCheck@@UAEPAXI@Z ENDP		; CMultiAttackHackCheck::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__EgMultiAttackHackCheck@@YAXXZ
text$yc	SEGMENT
??__EgMultiAttackHackCheck@@YAXXZ PROC			; `dynamic initializer for 'gMultiAttackHackCheck'', COMDAT

; 8    : CMultiAttackHackCheck gMultiAttackHackCheck[OBJMAX];

  00000	68 00 00 00 00	 push	 OFFSET ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  00005	68 00 00 00 00	 push	 OFFSET ??0CMultiAttackHackCheck@@QAE@XZ ; CMultiAttackHackCheck::CMultiAttackHackCheck
  0000a	68 98 3a 00 00	 push	 15000			; 00003a98H
  0000f	68 58 28 00 00	 push	 10328			; 00002858H
  00014	68 00 00 00 00	 push	 OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  00019	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001e	68 00 00 00 00	 push	 OFFSET ??__FgMultiAttackHackCheck@@YAXXZ ; `dynamic atexit destructor for 'gMultiAttackHackCheck''
  00023	e8 00 00 00 00	 call	 _atexit
  00028	59		 pop	 ecx
  00029	c3		 ret	 0
??__EgMultiAttackHackCheck@@YAXXZ ENDP			; `dynamic initializer for 'gMultiAttackHackCheck''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__FgMultiAttackHackCheck@@YAXXZ
text$yd	SEGMENT
??__FgMultiAttackHackCheck@@YAXXZ PROC			; `dynamic atexit destructor for 'gMultiAttackHackCheck'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  00005	68 98 3a 00 00	 push	 15000			; 00003a98H
  0000a	68 58 28 00 00	 push	 10328			; 00002858H
  0000f	68 00 00 00 00	 push	 OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  00014	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00019	c3		 ret	 0
??__FgMultiAttackHackCheck@@YAXXZ ENDP			; `dynamic atexit destructor for 'gMultiAttackHackCheck''
text$yd	ENDS
PUBLIC	?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
_BSS	SEGMENT
?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A DB 093be440H DUP (?) ; gMultiAttackHackCheck
_BSS	ENDS
CRT$XCU	SEGMENT
_gMultiAttackHackCheck$initializer$ DD FLAT:??__EgMultiAttackHackCheck@@YAXXZ
CRT$XCU	ENDS
END
