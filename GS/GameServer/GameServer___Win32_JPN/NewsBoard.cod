; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\NewsBoard.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atol:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_dwTokenNumber DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	06a4H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript_zt.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -1704					; size = 1700
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 06 00
	00		 sub	 esp, 1704		; 000006a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 28   : 	char ch;
; 29   : 	char* p;
; 30   : 	char TempString[1700];
; 31   : 
; 32   : 	TokenString[0]=0;

  00013	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  0001a	53		 push	 ebx
  0001b	eb 03 8d 49 00	 npad	 5
$LL31@GetToken:

; 33   : 
; 34   : 	do
; 35   : 	{
; 36   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 39   : 		}
; 40   : 		else
; 41   : 		{	
; 42   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 43   : 			{
; 44   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 45   : 				{
; 46   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 47   : 					{
; 48   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 49   : 					}
; 50   : 	
; 51   : 					if (ch == -1)
; 52   : 					{
; 53   : 						return END;	// End of FILE
; 54   : 					}
; 55   : 				}
; 56   : 			}
; 57   : 		}
; 58   : 	}
; 59   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 60   : 
; 61   : 	
; 62   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 47 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 37   : 		{
; 38   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 63   : 	{
; 64   : 
; 65   : 	case 0x23:	// #
; 66   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 b5 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 67   : 		break;
; 68   : 	
; 69   : 	case 0x3B:	// ;
; 70   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 ab 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 71   : 		break;
; 72   : 	
; 73   : 	case 0x2C:	// ,
; 74   : 
; 75   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 a1 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 76   : 		break;
; 77   : 	
; 78   : 	case 0x7B:	// {
; 79   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 97 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 80   : 		break;
; 81   : 
; 82   : 	case 0x7D:	// }
; 83   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 8d 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 84   : 		break;
; 85   : 	// Nice Index Table :)	by Deathway
; 86   : 	// Numbers Case
; 87   : 	case 0x2D:	//-
; 88   : 	case 0x2E:	//.
; 89   : 	case '0':	//0
; 90   : 	case '1':	//1
; 91   : 	case '2':	//2
; 92   : 	case '3':	//3
; 93   : 	case '4':	//4		
; 94   : 	case '5':	//5
; 95   : 	case '6':	//6
; 96   : 	case '7':	//7
; 97   : 	case '8':	//8
; 98   : 	case '9':	//9
; 99   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 100  : 		p = TempString;
; 101  : 		
; 102  : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d b5 58 f9 ff
	ff		 lea	 esi, DWORD PTR _TempString$[ebp]
  000f8	e8 00 00 00 00	 call	 _getc
  000fd	8a d8		 mov	 bl, al
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	80 fb ff	 cmp	 bl, -1
  00105	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00107	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  0010a	74 15		 je	 SHORT $LN11@GetToken
  0010c	0f be cb	 movsx	 ecx, bl
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _isdigit
  00115	83 c4 04	 add	 esp, 4
  00118	85 c0		 test	 eax, eax
  0011a	75 05		 jne	 SHORT $LN11@GetToken
  0011c	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011f	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  00121	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 103  : 		{
; 104  : 			*p = ch;	// Construct a String

  00127	88 1e		 mov	 BYTE PTR [esi], bl
  00129	52		 push	 edx

; 105  : 			p++;

  0012a	46		 inc	 esi
  0012b	e8 00 00 00 00	 call	 _getc
  00130	8a d8		 mov	 bl, al
  00132	83 c4 04	 add	 esp, 4
  00135	80 fb ff	 cmp	 bl, -1
  00138	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 106  : 		}		
; 107  : 		*p = 0;
; 108  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  0013a	8d 85 58 f9 ff
	ff		 lea	 eax, DWORD PTR _TempString$[ebp]
  00140	50		 push	 eax
  00141	c6 06 00	 mov	 BYTE PTR [esi], 0
  00144	e8 00 00 00 00	 call	 _atof
  00149	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber

; 109  : 		dwTokenNumber = (DWORD)atol(TempString);

  0014f	8d 8d 58 f9 ff
	ff		 lea	 ecx, DWORD PTR _TempString$[ebp]
  00155	51		 push	 ecx
  00156	e8 00 00 00 00	 call	 _atol
  0015b	83 c4 08	 add	 esp, 8
  0015e	5e		 pop	 esi
  0015f	a3 00 00 00 00	 mov	 DWORD PTR _dwTokenNumber, eax

; 110  : 		return CurrentToken  = NUMBER ;

  00164	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	5b		 pop	 ebx

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  00174	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00177	33 cd		 xor	 ecx, ebp
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
$LN10@GetToken:

; 111  : 		break;
; 112  : 
; 113  : 	case '\"':	// "	String Case
; 114  : 		p=&TokenString[0];
; 115  : 
; 116  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  00188	52		 push	 edx
  00189	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  0018e	e8 00 00 00 00	 call	 _getc
  00193	83 c4 04	 add	 esp, 4
  00196	3c ff		 cmp	 al, -1
  00198	74 23		 je	 SHORT $LN8@GetToken
  0019a	8d 9b 00 00 00
	00		 npad	 6
$LL9@GetToken:
  001a0	3c 22		 cmp	 al, 34			; 00000022H
  001a2	0f 84 a0 00 00
	00		 je	 $LN7@GetToken

; 117  : 		{
; 118  : 			*p = ch;

  001a8	88 06		 mov	 BYTE PTR [esi], al
  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001af	50		 push	 eax

; 119  : 			p++;

  001b0	46		 inc	 esi
  001b1	e8 00 00 00 00	 call	 _getc
  001b6	83 c4 04	 add	 esp, 4
  001b9	3c ff		 cmp	 al, -1
  001bb	75 e3		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 120  : 		}
; 121  : 		if (ch != 0x22 )

  001bd	3c 22		 cmp	 al, 34			; 00000022H
  001bf	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 122  : 		{
; 123  : 			ungetc(ch, SMDFile);

  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001cb	0f be d0	 movsx	 edx, al
  001ce	51		 push	 ecx
  001cf	52		 push	 edx

; 124  : 		}
; 125  : 		*p = 0;
; 126  : 		return CurrentToken = NAME;

  001d0	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 127  : 		break;
; 128  : 
; 129  : 	default:	// Others
; 130  : 		if (isalpha(ch))

  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _isalpha
  001d8	83 c4 04	 add	 esp, 4
  001db	85 c0		 test	 eax, eax
  001dd	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 131  : 		{
; 132  : 			p=&TokenString[0];
; 133  : 			*p=ch;
; 134  : 			p++;
; 135  : 
; 136  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001e8	50		 push	 eax
  001e9	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001ef	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001f4	e8 00 00 00 00	 call	 _getc
  001f9	8a d8		 mov	 bl, al
  001fb	83 c4 04	 add	 esp, 4
  001fe	80 fb ff	 cmp	 bl, -1
  00201	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  00203	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00206	74 15		 je	 SHORT $LN2@GetToken
  00208	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  0020b	74 10		 je	 SHORT $LN2@GetToken
  0020d	0f be cb	 movsx	 ecx, bl
  00210	51		 push	 ecx
  00211	e8 00 00 00 00	 call	 _isalnum
  00216	83 c4 04	 add	 esp, 4
  00219	85 c0		 test	 eax, eax
  0021b	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  0021d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 137  : 			{
; 138  : 				*p=ch;

  00223	88 1e		 mov	 BYTE PTR [esi], bl
  00225	52		 push	 edx

; 139  : 				p++;

  00226	46		 inc	 esi
  00227	e8 00 00 00 00	 call	 _getc
  0022c	8a d8		 mov	 bl, al
  0022e	83 c4 04	 add	 esp, 4
  00231	80 fb ff	 cmp	 bl, -1
  00234	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 140  : 			}
; 141  : 
; 142  : 			ungetc(ch, SMDFile);

  00236	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0023b	0f be cb	 movsx	 ecx, bl
  0023e	50		 push	 eax
  0023f	51		 push	 ecx
$LN49@GetToken:
  00240	e8 00 00 00 00	 call	 _ungetc
  00245	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 143  : 			*p=0;

  00248	c6 06 00	 mov	 BYTE PTR [esi], 0
  0024b	5e		 pop	 esi

; 144  : 			CurrentToken=NAME;

  0024c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 145  : 			return CurrentToken;

  00256	33 c0		 xor	 eax, eax
  00258	5b		 pop	 ebx

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  00259	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025c	33 cd		 xor	 ecx, ebp
  0025e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
$LN5@GetToken:

; 146  : 		}
; 147  : 		else
; 148  : 		{
; 149  : 			return CurrentToken = SMD_ERROR; // '<'

  00267	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 150  : 		}
; 151  : 		break;
; 152  : 
; 153  : 	}
; 154  : 
; 155  : 	return NAME;
; 156  : }

  0026c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026f	5e		 pop	 esi
  00270	33 cd		 xor	 ecx, ebp
  00272	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  00277	5b		 pop	 ebx
  00278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027d	8b e5		 mov	 esp, ebp
  0027f	5d		 pop	 ebp
  00280	c3		 ret	 0
  00281	8d 49 00	 npad	 3
$LN50@GetToken:
  00284	00 00 00 00	 DD	 $LN10@GetToken
  00288	00 00 00 00	 DD	 $LN19@GetToken
  0028c	00 00 00 00	 DD	 $LN17@GetToken
  00290	00 00 00 00	 DD	 $LN14@GetToken
  00294	00 00 00 00	 DD	 $LN18@GetToken
  00298	00 00 00 00	 DD	 $LN16@GetToken
  0029c	00 00 00 00	 DD	 $LN15@GetToken
  002a0	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  002a4	00		 DB	 0
  002a5	01		 DB	 1
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	02		 DB	 2
  002af	03		 DB	 3
  002b0	03		 DB	 3
  002b1	07		 DB	 7
  002b2	03		 DB	 3
  002b3	03		 DB	 3
  002b4	03		 DB	 3
  002b5	03		 DB	 3
  002b6	03		 DB	 3
  002b7	03		 DB	 3
  002b8	03		 DB	 3
  002b9	03		 DB	 3
  002ba	03		 DB	 3
  002bb	03		 DB	 3
  002bc	07		 DB	 7
  002bd	04		 DB	 4
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	07		 DB	 7
  002e7	07		 DB	 7
  002e8	07		 DB	 7
  002e9	07		 DB	 7
  002ea	07		 DB	 7
  002eb	07		 DB	 7
  002ec	07		 DB	 7
  002ed	07		 DB	 7
  002ee	07		 DB	 7
  002ef	07		 DB	 7
  002f0	07		 DB	 7
  002f1	07		 DB	 7
  002f2	07		 DB	 7
  002f3	07		 DB	 7
  002f4	07		 DB	 7
  002f5	07		 DB	 7
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	05		 DB	 5
  002fe	07		 DB	 7
  002ff	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??1NewsBoard@@QAE@XZ				; NewsBoard::~NewsBoard
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\newsboard.cpp
;	COMDAT ??1NewsBoard@@QAE@XZ
_TEXT	SEGMENT
??1NewsBoard@@QAE@XZ PROC				; NewsBoard::~NewsBoard, COMDAT
; _this$ = ecx

; 23   : 	// ----
; 24   : }

  00000	c3		 ret	 0
??1NewsBoard@@QAE@XZ ENDP				; NewsBoard::~NewsBoard
_TEXT	ENDS
PUBLIC	?Init@NewsBoard@@QAEXXZ				; NewsBoard::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@NewsBoard@@QAEXXZ
_TEXT	SEGMENT
?Init@NewsBoard@@QAEXXZ PROC				; NewsBoard::Init, COMDAT
; _this$ = ecx

; 29   : 	this->m_LoadedCount = 0;

  00000	33 d2		 xor	 edx, edx
  00002	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 30   : 	this->m_ShowOnLogin	= false;

  00005	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  00008	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0000b	8d 4a 0c	 lea	 ecx, DWORD PTR [edx+12]
  0000e	8b ff		 npad	 2
$LL3@Init:

; 31   : 	// ----
; 32   : 	for( int i = 0; i < MAX_NEWS_LIST; i++ )
; 33   : 	{
; 34   : 		this->m_Data[i].Title.Date[0]	= 0;

  00010	88 50 f4	 mov	 BYTE PTR [eax-12], dl

; 35   : 		this->m_Data[i].Title.Time[0]	= 0;

  00013	88 10		 mov	 BYTE PTR [eax], dl

; 36   : 		this->m_Data[i].Title.Text[0]	= 0;

  00015	88 50 07	 mov	 BYTE PTR [eax+7], dl

; 37   : 		this->m_Data[i].Text[0]			= 0;

  00018	88 50 4d	 mov	 BYTE PTR [eax+77], dl
  0001b	05 59 04 00 00	 add	 eax, 1113		; 00000459H
  00020	49		 dec	 ecx
  00021	75 ed		 jne	 SHORT $LL3@Init

; 38   : 	}
; 39   : }

  00023	c3		 ret	 0
?Init@NewsBoard@@QAEXXZ ENDP				; NewsBoard::Init
_TEXT	ENDS
PUBLIC	??_C@_0CH@HAEKFCOF@?$FLNewsBoard?$FN?5?$FL?$CFd?$FN?5Item?5loaded?5fro@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?ReadListData@NewsBoard@@QAEXPAD@Z		; NewsBoard::ReadListData
EXTRN	_fclose:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	_fopen:PROC
;	COMDAT ??_C@_0CH@HAEKFCOF@?$FLNewsBoard?$FN?5?$FL?$CFd?$FN?5Item?5loaded?5fro@
CONST	SEGMENT
??_C@_0CH@HAEKFCOF@?$FLNewsBoard?$FN?5?$FL?$CFd?$FN?5Item?5loaded?5fro@ DB '['
	DB	'NewsBoard] [%d] Item loaded from list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReadListData@NewsBoard@@QAEXPAD@Z
_TEXT	SEGMENT
_File$ = 8						; size = 4
?ReadListData@NewsBoard@@QAEXPAD@Z PROC			; NewsBoard::ReadListData, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 44   : 	int Token;
; 45   : 	// ----
; 46   : 	SMDFile = fopen(File, "r");

  00005	8b 75 08	 mov	 esi, DWORD PTR _File$[ebp]
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0000d	56		 push	 esi
  0000e	8b d9		 mov	 ebx, ecx
  00010	e8 00 00 00 00	 call	 _fopen
  00015	83 c4 08	 add	 esp, 8
  00018	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 47   : 	// ----
; 48   : 	if( SMDFile == 0 )

  0001d	85 c0		 test	 eax, eax
  0001f	75 1c		 jne	 SHORT $LN9@ReadListDa

; 49   : 	{
; 50   : 		MsgBox(lMsg.Get(MSGGET(0, 112)), File);

  00021	56		 push	 esi
  00022	6a 70		 push	 112			; 00000070H
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00029	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00034	83 c4 08	 add	 esp, 8
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 78   : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN9@ReadListDa:

; 51   : 		return;
; 52   : 	}
; 53   : 	// ----
; 54   : 	while(true) 
; 55   : 	{
; 56   : 		Token = GetToken();

  0003d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 57   : 		// ----
; 58   : 		if( Token == END || !strcmp(TokenString, "end") || this->m_LoadedCount >= MAX_NEWS_LIST)

  00042	83 f8 02	 cmp	 eax, 2
  00045	0f 84 f4 00 00
	00		 je	 $LN10@ReadListDa
  0004b	57		 push	 edi
  0004c	8d 64 24 00	 npad	 4
$LL5@ReadListDa:
  00050	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00055	b8 00 00 00 00	 mov	 eax, OFFSET _TokenString
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL11@ReadListDa:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	3a 0e		 cmp	 cl, BYTE PTR [esi]
  00064	75 1a		 jne	 SHORT $LN12@ReadListDa
  00066	84 c9		 test	 cl, cl
  00068	74 12		 je	 SHORT $LN13@ReadListDa
  0006a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0006d	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00070	75 0e		 jne	 SHORT $LN12@ReadListDa
  00072	83 c0 02	 add	 eax, 2
  00075	83 c6 02	 add	 esi, 2
  00078	84 c9		 test	 cl, cl
  0007a	75 e4		 jne	 SHORT $LL11@ReadListDa
$LN13@ReadListDa:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN14@ReadListDa
$LN12@ReadListDa:
  00080	1b c0		 sbb	 eax, eax
  00082	83 d8 ff	 sbb	 eax, -1
$LN14@ReadListDa:
  00085	85 c0		 test	 eax, eax
  00087	0f 84 b1 00 00
	00		 je	 $LN16@ReadListDa
  0008d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00090	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00093	0f 8d a5 00 00
	00		 jge	 $LN16@ReadListDa

; 59   : 		{
; 60   : 			break;
; 61   : 		}
; 62   : 		else
; 63   : 		{
; 64   : 			memcpy(this->m_Data[this->m_LoadedCount].Title.Date, TokenString, 11);

  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TokenString
  0009f	69 c0 59 04 00
	00		 imul	 eax, 1113		; 00000459H
  000a5	8d 44 18 18	 lea	 eax, DWORD PTR [eax+ebx+24]
  000a9	89 08		 mov	 DWORD PTR [eax], ecx
  000ab	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _TokenString+4
  000b1	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000b4	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR _TokenString+8
  000bb	66 89 48 08	 mov	 WORD PTR [eax+8], cx
  000bf	8a 15 0a 00 00
	00		 mov	 dl, BYTE PTR _TokenString+10
  000c5	88 50 0a	 mov	 BYTE PTR [eax+10], dl

; 65   : 			Token = GetToken();

  000c8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 66   : 			memcpy(this->m_Data[this->m_LoadedCount].Title.Time, TokenString, 6);

  000cd	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TokenString
  000d6	69 c0 59 04 00
	00		 imul	 eax, 1113		; 00000459H
  000dc	8d 44 18 24	 lea	 eax, DWORD PTR [eax+ebx+36]
  000e0	89 08		 mov	 DWORD PTR [eax], ecx
  000e2	66 8b 15 04 00
	00 00		 mov	 dx, WORD PTR _TokenString+4
  000e9	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 67   : 			Token = GetToken();

  000ed	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 68   : 			memcpy(this->m_Data[this->m_LoadedCount].Title.Text, TokenString, 69);

  000f2	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000f5	69 c0 59 04 00
	00		 imul	 eax, 1113		; 00000459H
  000fb	8d 7c 18 2b	 lea	 edi, DWORD PTR [eax+ebx+43]
  000ff	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00104	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00109	f3 a5		 rep movsd
  0010b	a4		 movsb

; 69   : 			Token = GetToken();

  0010c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 70   : 			memcpy(this->m_Data[this->m_LoadedCount].Text, TokenString, 1024-1);

  00111	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00114	69 c9 59 04 00
	00		 imul	 ecx, 1113		; 00000459H
  0011a	8d 7c 19 71	 lea	 edi, DWORD PTR [ecx+ebx+113]
  0011e	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00123	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00128	f3 a5		 rep movsd
  0012a	66 a5		 movsw
  0012c	a4		 movsb

; 71   : 			// ----
; 72   : 			this->m_LoadedCount++;

  0012d	ff 43 14	 inc	 DWORD PTR [ebx+20]
  00130	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00135	83 f8 02	 cmp	 eax, 2
  00138	0f 85 12 ff ff
	ff		 jne	 $LL5@ReadListDa
$LN16@ReadListDa:
  0013e	5f		 pop	 edi
$LN10@ReadListDa:

; 73   : 		}
; 74   : 	}
; 75   : 	// ----
; 76   : 	LogAddTD("[NewsBoard] [%d] Item loaded from list", this->m_LoadedCount);

  0013f	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  00142	52		 push	 edx
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@HAEKFCOF@?$FLNewsBoard?$FN?5?$FL?$CFd?$FN?5Item?5loaded?5fro@
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 77   : 	fclose(SMDFile);	

  0014e	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _fclose
  00159	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx

; 78   : }

  0015e	5d		 pop	 ebp
  0015f	c2 04 00	 ret	 4
?ReadListData@NewsBoard@@QAEXPAD@Z ENDP			; NewsBoard::ReadListData
_TEXT	ENDS
PUBLIC	??_C@_0M@MDLDIDLO@ShowOnLogin?$AA@		; `string'
PUBLIC	??_C@_05MGEEICMI@NPC_Y?$AA@			; `string'
PUBLIC	??_C@_05NPFPLDIJ@NPC_X?$AA@			; `string'
PUBLIC	??_C@_07LJMEGBCH@NPC_Map?$AA@			; `string'
PUBLIC	??_C@_09JIOKDDGI@NPC_Class?$AA@			; `string'
PUBLIC	??_C@_06CNKIADGI@ZtTeam?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	?ReadMainData@NewsBoard@@QAEXPAD@Z		; NewsBoard::ReadMainData
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
;	COMDAT ??_C@_0M@MDLDIDLO@ShowOnLogin?$AA@
CONST	SEGMENT
??_C@_0M@MDLDIDLO@ShowOnLogin?$AA@ DB 'ShowOnLogin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGEEICMI@NPC_Y?$AA@
CONST	SEGMENT
??_C@_05MGEEICMI@NPC_Y?$AA@ DB 'NPC_Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NPFPLDIJ@NPC_X?$AA@
CONST	SEGMENT
??_C@_05NPFPLDIJ@NPC_X?$AA@ DB 'NPC_X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LJMEGBCH@NPC_Map?$AA@
CONST	SEGMENT
??_C@_07LJMEGBCH@NPC_Map?$AA@ DB 'NPC_Map', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JIOKDDGI@NPC_Class?$AA@
CONST	SEGMENT
??_C@_09JIOKDDGI@NPC_Class?$AA@ DB 'NPC_Class', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNKIADGI@ZtTeam?$AA@
CONST	SEGMENT
??_C@_06CNKIADGI@ZtTeam?$AA@ DB 'ZtTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReadMainData@NewsBoard@@QAEXPAD@Z
_TEXT	SEGMENT
_File$ = 8						; size = 4
?ReadMainData@NewsBoard@@QAEXPAD@Z PROC			; NewsBoard::ReadMainData, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 83   : 	this->Enable = GetPrivateProfileInt("ZtTeam", "Enable", 1, File);

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetPrivateProfileIntA@16
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _File$[ebp]
  0000f	57		 push	 edi
  00010	6a 01		 push	 1
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  0001c	8b f1		 mov	 esi, ecx
  0001e	ff d3		 call	 ebx

; 84   : 	this->NPC_Class = GetPrivateProfileInt("ZtTeam", "NPC_Class", 0, File);

  00020	57		 push	 edi
  00021	6a 00		 push	 0
  00023	85 c0		 test	 eax, eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_09JIOKDDGI@NPC_Class?$AA@
  0002a	0f 95 c0	 setne	 al
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00032	88 06		 mov	 BYTE PTR [esi], al
  00034	ff d3		 call	 ebx

; 85   : 	this->NPC_Map = GetPrivateProfileInt("ZtTeam", "NPC_Map", 0, File);

  00036	57		 push	 edi
  00037	6a 00		 push	 0
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_07LJMEGBCH@NPC_Map?$AA@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00046	ff d3		 call	 ebx

; 86   : 	this->NPC_X = GetPrivateProfileInt("ZtTeam", "NPC_X", 0, File);

  00048	57		 push	 edi
  00049	6a 00		 push	 0
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_05NPFPLDIJ@NPC_X?$AA@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00058	ff d3		 call	 ebx

; 87   : 	this->NPC_Y = GetPrivateProfileInt("ZtTeam", "NPC_Y", 0, File);

  0005a	57		 push	 edi
  0005b	6a 00		 push	 0
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_05MGEEICMI@NPC_Y?$AA@
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00067	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0006a	ff d3		 call	 ebx

; 88   : 	this->m_ShowOnLogin	= GetPrivateProfileIntA("ZtTeam", "ShowOnLogin", 0, File);

  0006c	57		 push	 edi
  0006d	6a 00		 push	 0
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MDLDIDLO@ShowOnLogin?$AA@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_06CNKIADGI@ZtTeam?$AA@
  00079	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0007c	ff d3		 call	 ebx
  0007e	85 c0		 test	 eax, eax
  00080	0f 95 c1	 setne	 cl
  00083	5f		 pop	 edi
  00084	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 89   : }

  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?ReadMainData@NewsBoard@@QAEXPAD@Z ENDP			; NewsBoard::ReadMainData
_TEXT	ENDS
PUBLIC	??_C@_0BE@LHLFKAAM@ZtData?2NewsMain?4ini?$AA@	; `string'
PUBLIC	??_C@_0BE@FHHMHBBL@ZtData?2NewsList?4txt?$AA@	; `string'
PUBLIC	?Load@NewsBoard@@QAEXXZ				; NewsBoard::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0BE@LHLFKAAM@ZtData?2NewsMain?4ini?$AA@
CONST	SEGMENT
??_C@_0BE@LHLFKAAM@ZtData?2NewsMain?4ini?$AA@ DB 'ZtData\NewsMain.ini', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHHMHBBL@ZtData?2NewsList?4txt?$AA@
CONST	SEGMENT
??_C@_0BE@FHHMHBBL@ZtData?2NewsList?4txt?$AA@ DB 'ZtData\NewsList.txt', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@NewsBoard@@QAEXXZ
_TEXT	SEGMENT
?Load@NewsBoard@@QAEXXZ PROC				; NewsBoard::Load, COMDAT
; _this$ = ecx

; 93   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 94   : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@NewsBoard@@QAEXXZ	; NewsBoard::Init

; 95   : 	this->ReadListData(gDirPath.GetNewPath("ZtData\\NewsList.txt"));

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FHHMHBBL@ZtData?2NewsList?4txt?$AA@
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00012	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00017	50		 push	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?ReadListData@NewsBoard@@QAEXPAD@Z ; NewsBoard::ReadListData

; 96   : 	this->ReadMainData(gDirPath.GetNewPath("ZtData\\NewsMain.ini"));

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LHLFKAAM@ZtData?2NewsMain?4ini?$AA@
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00029	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0002e	50		 push	 eax
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?ReadMainData@NewsBoard@@QAEXPAD@Z ; NewsBoard::ReadMainData
  00036	5e		 pop	 esi

; 97   : }

  00037	c3		 ret	 0
?Load@NewsBoard@@QAEXXZ ENDP				; NewsBoard::Load
_TEXT	ENDS
PUBLIC	_lpUser$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z	; NewsBoard::OpenMain
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpUser$GSCopy$ = -1084					; size = 4
_pAnswer$ = -1080					; size = 1073
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; NewsBoard::OpenMain, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 04 00
	00		 sub	 esp, 1084		; 0000043cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpUser$[ebp]
  00018	8b f1		 mov	 esi, ecx

; 130  : 	if(!this->Enable)

  0001a	80 3e 00	 cmp	 BYTE PTR [esi], 0

; 144  : 	// ----
; 145  : 	for( int i = 0; i < this->m_LoadedCount; i++ )

  0001d	89 bd c4 fb ff
	ff		 mov	 DWORD PTR _lpUser$GSCopy$[ebp], edi
  00023	0f 84 be 00 00
	00		 je	 $LN6@OpenMain

; 131  : 	{
; 132  :  		return;
; 133  : 	}
; 134  : 
; 135  : 	if( lpUser->Connected != PLAYER_PLAYING )

  00029	83 7f 04 03	 cmp	 DWORD PTR [edi+4], 3
  0002d	0f 85 b4 00 00
	00		 jne	 $LN6@OpenMain

; 136  : 	{
; 137  : 		return;
; 138  : 	}
; 139  : 	// ----
; 140  : 	NEWS_ANS_TITLES pAnswer = { 0 };

  00033	68 30 04 00 00	 push	 1072			; 00000430H
  00038	8d 85 c9 fb ff
	ff		 lea	 eax, DWORD PTR _pAnswer$[ebp+1]
  0003e	6a 00		 push	 0
  00040	50		 push	 eax
  00041	c6 85 c8 fb ff
	ff 00		 mov	 BYTE PTR _pAnswer$[ebp], 0
  00048	e8 00 00 00 00	 call	 _memset

; 141  : 	PHeadSetW((LPBYTE)&pAnswer, 0xFD, sizeof(NEWS_ANS_TITLES));

  0004d	68 31 04 00 00	 push	 1073			; 00000431H
  00052	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  00058	68 fd 00 00 00	 push	 253			; 000000fdH
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  00063	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 142  : 	// ----
; 143  : 	pAnswer.RealCount = this->m_LoadedCount;

  00066	8a 56 14	 mov	 dl, BYTE PTR [esi+20]
  00069	83 c4 18	 add	 esp, 24			; 00000018H
  0006c	88 95 cc fb ff
	ff		 mov	 BYTE PTR _pAnswer$[ebp+4], dl

; 144  : 	// ----
; 145  : 	for( int i = 0; i < this->m_LoadedCount; i++ )

  00072	85 c0		 test	 eax, eax
  00074	7e 5a		 jle	 SHORT $LN1@OpenMain

; 136  : 	{
; 137  : 		return;
; 138  : 	}
; 139  : 	// ----
; 140  : 	NEWS_ANS_TITLES pAnswer = { 0 };

  00076	53		 push	 ebx
  00077	8d bd d9 fb ff
	ff		 lea	 edi, DWORD PTR _pAnswer$[ebp+17]
  0007d	83 c6 24	 add	 esi, 36			; 00000024H
  00080	8b d8		 mov	 ebx, eax
$LL3@OpenMain:

; 146  : 	{
; 147  : 		strcpy(pAnswer.Titles[i].Date, this->m_Data[i].Title.Date);

  00082	8d 46 f4	 lea	 eax, DWORD PTR [esi-12]
  00085	8b d7		 mov	 edx, edi
  00087	2b d0		 sub	 edx, eax
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL8@OpenMain:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	88 4c 02 f4	 mov	 BYTE PTR [edx+eax-12], cl
  00096	40		 inc	 eax
  00097	84 c9		 test	 cl, cl
  00099	75 f5		 jne	 SHORT $LL8@OpenMain

; 148  : 		strcpy(pAnswer.Titles[i].Time, this->m_Data[i].Title.Time);

  0009b	8b d7		 mov	 edx, edi
  0009d	8b c6		 mov	 eax, esi
  0009f	2b d6		 sub	 edx, esi
$LL9@OpenMain:
  000a1	8a 08		 mov	 cl, BYTE PTR [eax]
  000a3	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000a6	40		 inc	 eax
  000a7	84 c9		 test	 cl, cl
  000a9	75 f6		 jne	 SHORT $LL9@OpenMain

; 149  : 		strcpy(pAnswer.Titles[i].Text, this->m_Data[i].Title.Text);

  000ab	8d 46 07	 lea	 eax, DWORD PTR [esi+7]
  000ae	8b d7		 mov	 edx, edi
  000b0	2b d0		 sub	 edx, eax
$LL10@OpenMain:
  000b2	8a 08		 mov	 cl, BYTE PTR [eax]
  000b4	88 4c 02 07	 mov	 BYTE PTR [edx+eax+7], cl
  000b8	40		 inc	 eax
  000b9	84 c9		 test	 cl, cl
  000bb	75 f5		 jne	 SHORT $LL10@OpenMain

; 144  : 	// ----
; 145  : 	for( int i = 0; i < this->m_LoadedCount; i++ )

  000bd	83 c7 59	 add	 edi, 89			; 00000059H
  000c0	81 c6 59 04 00
	00		 add	 esi, 1113		; 00000459H
  000c6	4b		 dec	 ebx
  000c7	75 b9		 jne	 SHORT $LL3@OpenMain
  000c9	8b bd c4 fb ff
	ff		 mov	 edi, DWORD PTR _lpUser$GSCopy$[ebp]
  000cf	5b		 pop	 ebx
$LN1@OpenMain:

; 150  : 	}
; 151  : 	// ----
; 152  : 	DataSend(lpUser->m_Index, (LPBYTE)&pAnswer, sizeof(NEWS_ANS_TITLES));

  000d0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d2	68 31 04 00 00	 push	 1073			; 00000431H
  000d7	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _pAnswer$[ebp]
  000dd	50		 push	 eax
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@OpenMain:

; 153  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	5f		 pop	 edi
  000eb	33 cd		 xor	 ecx, ebp
  000ed	5e		 pop	 esi
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 04 00	 ret	 4
?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; NewsBoard::OpenMain
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?OpenItem@NewsBoard@@QAEXPAUOBJECTSTRUCT@@PAUNEWS_REQ_NEWS@@@Z ; NewsBoard::OpenItem
; Function compile flags: /Ogtp
;	COMDAT ?OpenItem@NewsBoard@@QAEXPAUOBJECTSTRUCT@@PAUNEWS_REQ_NEWS@@@Z
_TEXT	SEGMENT
_pAnswer$ = -1124					; size = 1118
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
_Request$ = 12						; size = 4
?OpenItem@NewsBoard@@QAEXPAUOBJECTSTRUCT@@PAUNEWS_REQ_NEWS@@@Z PROC ; NewsBoard::OpenItem, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 04 00
	00		 sub	 esp, 1124		; 00000464H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpUser$[ebp]
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 158  : 	if(!this->Enable)

  0001a	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _Request$[ebp]
  00021	0f 84 da 00 00
	00		 je	 $LN1@OpenItem

; 159  : 	{
; 160  :  		return;
; 161  : 	}
; 162  : 
; 163  : 	if( lpUser->Connected != PLAYER_PLAYING )

  00027	83 7b 04 03	 cmp	 DWORD PTR [ebx+4], 3
  0002b	0f 85 d0 00 00
	00		 jne	 $LN1@OpenItem

; 164  : 	{
; 165  : 		return;
; 166  : 	}
; 167  : 	// ----
; 168  : 	if( Request->ID < 0 || Request->ID >= MAX_NEWS_LIST )

  00031	80 7f 03 0c	 cmp	 BYTE PTR [edi+3], 12	; 0000000cH
  00035	0f 83 c6 00 00
	00		 jae	 $LN1@OpenItem

; 169  : 	{
; 170  : 		return;
; 171  : 	}
; 172  : 	// ----
; 173  : 	NEWS_ANS_NEWS pAnswer = { 0 };

  0003b	68 5d 04 00 00	 push	 1117			; 0000045dH
  00040	8d 85 9d fb ff
	ff		 lea	 eax, DWORD PTR _pAnswer$[ebp+1]
  00046	6a 00		 push	 0
  00048	50		 push	 eax
  00049	c6 85 9c fb ff
	ff 00		 mov	 BYTE PTR _pAnswer$[ebp], 0
  00050	e8 00 00 00 00	 call	 _memset

; 174  : 	PHeadSetW((LPBYTE)&pAnswer, 0xFE, sizeof(NEWS_ANS_NEWS));

  00055	68 5e 04 00 00	 push	 1118			; 0000045eH
  0005a	8d 8d 9c fb ff
	ff		 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  00060	68 fe 00 00 00	 push	 254			; 000000feH
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 175  : 	// ----
; 176  : 	pAnswer.ID = Request->ID;

  0006b	8a 47 03	 mov	 al, BYTE PTR [edi+3]

; 177  : 	// ----
; 178  : 	strcpy(pAnswer.News.Title.Date, this->m_Data[Request->ID].Title.Date);

  0006e	0f b6 d0	 movzx	 edx, al
  00071	69 d2 59 04 00
	00		 imul	 edx, 1113		; 00000459H
  00077	88 85 a0 fb ff
	ff		 mov	 BYTE PTR _pAnswer$[ebp+4], al
  0007d	8d 44 32 18	 lea	 eax, DWORD PTR [edx+esi+24]
  00081	8d 95 a1 fb ff
	ff		 lea	 edx, DWORD PTR _pAnswer$[ebp+5]
  00087	83 c4 18	 add	 esp, 24			; 00000018H
  0008a	2b d0		 sub	 edx, eax
  0008c	8d 64 24 00	 npad	 4
$LL7@OpenItem:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00095	40		 inc	 eax
  00096	84 c9		 test	 cl, cl
  00098	75 f6		 jne	 SHORT $LL7@OpenItem

; 179  : 	strcpy(pAnswer.News.Title.Time, this->m_Data[Request->ID].Title.Time);

  0009a	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0009e	69 c0 59 04 00
	00		 imul	 eax, 1113		; 00000459H
  000a4	03 f0		 add	 esi, eax
  000a6	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  000a9	8d 95 ad fb ff
	ff		 lea	 edx, DWORD PTR _pAnswer$[ebp+17]
  000af	2b d0		 sub	 edx, eax
$LL8@OpenItem:
  000b1	8a 08		 mov	 cl, BYTE PTR [eax]
  000b3	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000b6	40		 inc	 eax
  000b7	84 c9		 test	 cl, cl
  000b9	75 f6		 jne	 SHORT $LL8@OpenItem

; 180  : 	strcpy(pAnswer.News.Title.Text, this->m_Data[Request->ID].Title.Text);

  000bb	8d 46 2b	 lea	 eax, DWORD PTR [esi+43]
  000be	8d 95 b4 fb ff
	ff		 lea	 edx, DWORD PTR _pAnswer$[ebp+24]
  000c4	2b d0		 sub	 edx, eax
$LL9@OpenItem:
  000c6	8a 08		 mov	 cl, BYTE PTR [eax]
  000c8	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000cb	40		 inc	 eax
  000cc	84 c9		 test	 cl, cl
  000ce	75 f6		 jne	 SHORT $LL9@OpenItem

; 181  : 	strcpy(pAnswer.News.Text, this->m_Data[Request->ID].Text);

  000d0	8d 46 71	 lea	 eax, DWORD PTR [esi+113]
  000d3	8d 95 fa fb ff
	ff		 lea	 edx, DWORD PTR _pAnswer$[ebp+94]
  000d9	2b d0		 sub	 edx, eax
  000db	eb 03 8d 49 00	 npad	 5
$LL10@OpenItem:
  000e0	8a 08		 mov	 cl, BYTE PTR [eax]
  000e2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000e5	40		 inc	 eax
  000e6	84 c9		 test	 cl, cl
  000e8	75 f6		 jne	 SHORT $LL10@OpenItem

; 182  : 	// ----
; 183  : 	DataSend(lpUser->m_Index, (LPBYTE)&pAnswer, sizeof(NEWS_ANS_NEWS));

  000ea	8b 13		 mov	 edx, DWORD PTR [ebx]
  000ec	68 5e 04 00 00	 push	 1118			; 0000045eH
  000f1	8d 8d 9c fb ff
	ff		 lea	 ecx, DWORD PTR _pAnswer$[ebp]
  000f7	51		 push	 ecx
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@OpenItem:

; 184  : }

  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	33 cd		 xor	 ecx, ebp
  00108	5b		 pop	 ebx
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 08 00	 ret	 8
?OpenItem@NewsBoard@@QAEXPAUOBJECTSTRUCT@@PAUNEWS_REQ_NEWS@@@Z ENDP ; NewsBoard::OpenItem
_TEXT	ENDS
PUBLIC	??0NewsBoard@@QAE@XZ				; NewsBoard::NewsBoard
; Function compile flags: /Ogtp
;	COMDAT ??0NewsBoard@@QAE@XZ
_TEXT	SEGMENT
??0NewsBoard@@QAE@XZ PROC				; NewsBoard::NewsBoard, COMDAT
; _this$ = ecx

; 16   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 17   : 	this->Init();

  00003	e8 00 00 00 00	 call	 ?Init@NewsBoard@@QAEXXZ	; NewsBoard::Init

; 18   : }

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0NewsBoard@@QAE@XZ ENDP				; NewsBoard::NewsBoard
_TEXT	ENDS
PUBLIC	?Dialog@NewsBoard@@QAE_NHH@Z			; NewsBoard::Dialog
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnectedZt@@YA_NH@Z:PROC		; gObjIsConnectedZt
; Function compile flags: /Ogtp
;	COMDAT ?Dialog@NewsBoard@@QAE_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aNpcIndex$ = 12					; size = 4
?Dialog@NewsBoard@@QAE_NHH@Z PROC			; NewsBoard::Dialog, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 102  : 	if(!this->Enable)

  00006	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00009	75 07		 jne	 SHORT $LN3@Dialog

; 103  : 	{
; 104  :  		return false;

  0000b	32 c0		 xor	 al, al
  0000d	5e		 pop	 esi

; 125  : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN3@Dialog:
  00012	57		 push	 edi

; 105  : 	}
; 106  : 
; 107  : 	if(!gObjIsConnectedZt(aIndex))

  00013	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ?gObjIsConnectedZt@@YA_NH@Z ; gObjIsConnectedZt
  0001c	83 c4 04	 add	 esp, 4
  0001f	84 c0		 test	 al, al

; 108  : 	{
; 109  : 		return false;

  00021	74 5a		 je	 SHORT $LN1@Dialog

; 113  : 	LPOBJ lpNpc = &gObj[aNpcIndex];

  00023	8b 45 0c	 mov	 eax, DWORD PTR _aNpcIndex$[ebp]
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H

; 114  : 
; 115  : 	if(		lpNpc->Class		== this->NPC_Class 
; 116  : 		&&	lpNpc->MapNumber	== this->NPC_Map
; 117  : 		&&	lpNpc->X			== this->NPC_X
; 118  : 		&&	lpNpc->Y			== this->NPC_Y )

  00032	0f b7 94 08 b8
	00 00 00	 movzx	 edx, WORD PTR [eax+ecx+184]
  0003a	03 c1		 add	 eax, ecx
  0003c	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  0003f	75 3c		 jne	 SHORT $LN1@Dialog
  00041	0f b6 90 49 01
	00 00		 movzx	 edx, BYTE PTR [eax+329]
  00048	3b 56 08	 cmp	 edx, DWORD PTR [esi+8]
  0004b	75 30		 jne	 SHORT $LN1@Dialog
  0004d	0f bf 90 44 01
	00 00		 movsx	 edx, WORD PTR [eax+324]
  00054	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  00057	75 24		 jne	 SHORT $LN1@Dialog
  00059	0f bf 80 46 01
	00 00		 movsx	 eax, WORD PTR [eax+326]
  00060	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00063	75 18		 jne	 SHORT $LN1@Dialog

; 110  : 	}
; 111  : 
; 112  : 	LPOBJ lpUser = &gObj[aIndex];

  00065	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0006b	03 f9		 add	 edi, ecx

; 119  : 	{
; 120  : 		this->OpenMain(lpUser);

  0006d	57		 push	 edi
  0006e	8b ce		 mov	 ecx, esi
  00070	e8 00 00 00 00	 call	 ?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z ; NewsBoard::OpenMain
  00075	5f		 pop	 edi

; 121  : 		return true;

  00076	b0 01		 mov	 al, 1
  00078	5e		 pop	 esi

; 125  : }

  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN1@Dialog:
  0007d	5f		 pop	 edi

; 122  : 	}
; 123  : 	// ----
; 124  : 	return false;

  0007e	32 c0		 xor	 al, al
  00080	5e		 pop	 esi

; 125  : }

  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?Dialog@NewsBoard@@QAE_NHH@Z ENDP			; NewsBoard::Dialog
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_NewsBoard@@YAXXZ
text$yc	SEGMENT
??__Eg_NewsBoard@@YAXXZ PROC				; `dynamic initializer for 'g_NewsBoard'', COMDAT

; 12   : NewsBoard g_NewsBoard;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewsBoard@@3VNewsBoard@@A ; g_NewsBoard
  00005	e8 00 00 00 00	 call	 ??0NewsBoard@@QAE@XZ	; NewsBoard::NewsBoard
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_NewsBoard@@YAXXZ ; `dynamic atexit destructor for 'g_NewsBoard''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_NewsBoard@@YAXXZ ENDP				; `dynamic initializer for 'g_NewsBoard''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_NewsBoard@@YAXXZ
text$yd	SEGMENT
??__Fg_NewsBoard@@YAXXZ PROC				; `dynamic atexit destructor for 'g_NewsBoard'', COMDAT
  00000	c3		 ret	 0
??__Fg_NewsBoard@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_NewsBoard''
text$yd	ENDS
PUBLIC	?g_NewsBoard@@3VNewsBoard@@A			; g_NewsBoard
_BSS	SEGMENT
?g_NewsBoard@@3VNewsBoard@@A DB 03444H DUP (?)		; g_NewsBoard
_BSS	ENDS
CRT$XCU	SEGMENT
_g_NewsBoard$initializer$ DD FLAT:??__Eg_NewsBoard@@YAXXZ
CRT$XCU	ENDS
END
