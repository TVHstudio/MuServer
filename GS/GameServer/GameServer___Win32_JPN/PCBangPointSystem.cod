; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\PCBangPointSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_btPcBangPointSystemLevel@@3EA		; g_btPcBangPointSystemLevel
PUBLIC	?g_sPCBangFirstRuleTime@@3FA			; g_sPCBangFirstRuleTime
PUBLIC	?g_sPCBangFirstRuleTimePoint@@3FA		; g_sPCBangFirstRuleTimePoint
PUBLIC	?g_sPCBangCommonRuleTime@@3FA			; g_sPCBangCommonRuleTime
PUBLIC	?g_sPCBangCommonRuleTimePoint@@3FA		; g_sPCBangCommonRuleTimePoint
PUBLIC	?g_sPCBangMaxPoint@@3FA				; g_sPCBangMaxPoint
PUBLIC	?g_sPCBangFeverStartHour@@3FA			; g_sPCBangFeverStartHour
PUBLIC	?g_sPCBangFeverEndHour@@3FA			; g_sPCBangFeverEndHour
PUBLIC	?g_sPCBangFeverMultipleValue@@3FA		; g_sPCBangFeverMultipleValue
PUBLIC	?g_sPCBangResetDayOfWeek@@3FA			; g_sPCBangResetDayOfWeek
PUBLIC	?g_sPCBangResetHour@@3FA			; g_sPCBangResetHour
PUBLIC	?g_fPCBangAddExperience@@3MA			; g_fPCBangAddExperience
_BSS	SEGMENT
?g_btPcBangPointSystemLevel@@3EA DB 01H DUP (?)		; g_btPcBangPointSystemLevel
_BSS	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	070H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
	DD	010eH
?g_sPCBangFirstRuleTime@@3FA DW 0258H			; g_sPCBangFirstRuleTime
	ORG $+2
?g_sPCBangFirstRuleTimePoint@@3FA DW 01H		; g_sPCBangFirstRuleTimePoint
	ORG $+2
?g_sPCBangCommonRuleTime@@3FA DW 0258H			; g_sPCBangCommonRuleTime
	ORG $+2
?g_sPCBangCommonRuleTimePoint@@3FA DW 01H		; g_sPCBangCommonRuleTimePoint
	ORG $+2
?g_sPCBangMaxPoint@@3FA DW 03f0H			; g_sPCBangMaxPoint
	ORG $+2
?g_sPCBangFeverStartHour@@3FA DW 014H			; g_sPCBangFeverStartHour
	ORG $+2
?g_sPCBangFeverEndHour@@3FA DW 018H			; g_sPCBangFeverEndHour
	ORG $+2
?g_sPCBangFeverMultipleValue@@3FA DW 02H		; g_sPCBangFeverMultipleValue
	ORG $+2
?g_sPCBangResetDayOfWeek@@3FA DW 02H			; g_sPCBangResetDayOfWeek
	ORG $+2
?g_sPCBangResetHour@@3FA DW 09H				; g_sPCBangResetHour
	ORG $+2
?g_fPCBangAddExperience@@3MA DD 03f800000r	; 1	; g_fPCBangAddExperience
_DATA	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
	ALIGN	4

_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7CPCBangPointTimeCondition@@6B@		; CPCBangPointTimeCondition::`vftable'
PUBLIC	??0CPCBangPointTimeCondition@@QAE@XZ		; CPCBangPointTimeCondition::CPCBangPointTimeCondition
PUBLIC	??_R4CPCBangPointTimeCondition@@6B@		; CPCBangPointTimeCondition::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPCBangPointTimeCondition@@@8		; CPCBangPointTimeCondition `RTTI Type Descriptor'
PUBLIC	??_R3CPCBangPointTimeCondition@@8		; CPCBangPointTimeCondition::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPCBangPointTimeCondition@@8		; CPCBangPointTimeCondition::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPCBangPointTimeCondition@@8	; CPCBangPointTimeCondition::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECPCBangPointTimeCondition@@UAEPAXI@Z:PROC	; CPCBangPointTimeCondition::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CPCBangPointTimeCondition@@8
; File e:\work\tranet_version\gs\gameserver\pcbangpointsystem.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CPCBangPointTimeCondition@@8 DD FLAT:??_R0?AVCPCBangPointTimeCondition@@@8 ; CPCBangPointTimeCondition::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPCBangPointTimeCondition@@8
rdata$r	ENDS
;	COMDAT ??_R2CPCBangPointTimeCondition@@8
rdata$r	SEGMENT
??_R2CPCBangPointTimeCondition@@8 DD FLAT:??_R1A@?0A@EA@CPCBangPointTimeCondition@@8 ; CPCBangPointTimeCondition::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CPCBangPointTimeCondition@@8
rdata$r	SEGMENT
??_R3CPCBangPointTimeCondition@@8 DD 00H		; CPCBangPointTimeCondition::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CPCBangPointTimeCondition@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPCBangPointTimeCondition@@@8
_DATA	SEGMENT
??_R0?AVCPCBangPointTimeCondition@@@8 DD FLAT:??_7type_info@@6B@ ; CPCBangPointTimeCondition `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPCBangPointTimeCondition@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CPCBangPointTimeCondition@@6B@
rdata$r	SEGMENT
??_R4CPCBangPointTimeCondition@@6B@ DD 00H		; CPCBangPointTimeCondition::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPCBangPointTimeCondition@@@8
	DD	FLAT:??_R3CPCBangPointTimeCondition@@8
rdata$r	ENDS
;	COMDAT ??_7CPCBangPointTimeCondition@@6B@
CONST	SEGMENT
??_7CPCBangPointTimeCondition@@6B@ DD FLAT:??_R4CPCBangPointTimeCondition@@6B@ ; CPCBangPointTimeCondition::`vftable'
	DD	FLAT:??_ECPCBangPointTimeCondition@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CPCBangPointTimeCondition@@QAE@XZ
_TEXT	SEGMENT
??0CPCBangPointTimeCondition@@QAE@XZ PROC		; CPCBangPointTimeCondition::CPCBangPointTimeCondition, COMDAT
; _this$ = ecx

; 25   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPCBangPointTimeCondition@@6B@

; 26   : 	return;
; 27   : }

  00008	c3		 ret	 0
??0CPCBangPointTimeCondition@@QAE@XZ ENDP		; CPCBangPointTimeCondition::CPCBangPointTimeCondition
_TEXT	ENDS
PUBLIC	??1CPCBangPointTimeCondition@@UAE@XZ		; CPCBangPointTimeCondition::~CPCBangPointTimeCondition
; Function compile flags: /Ogtp
;	COMDAT ??1CPCBangPointTimeCondition@@UAE@XZ
_TEXT	SEGMENT
??1CPCBangPointTimeCondition@@UAE@XZ PROC		; CPCBangPointTimeCondition::~CPCBangPointTimeCondition, COMDAT
; _this$ = ecx

; 30   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CPCBangPointTimeCondition@@6B@

; 31   : 	return;
; 32   : }

  00006	c3		 ret	 0
??1CPCBangPointTimeCondition@@UAE@XZ ENDP		; CPCBangPointTimeCondition::~CPCBangPointTimeCondition
_TEXT	ENDS
PUBLIC	?GetTimeDate@CPCBangPointTimeCondition@@QAEHHHH@Z ; CPCBangPointTimeCondition::GetTimeDate
; Function compile flags: /Ogtp
;	COMDAT ?GetTimeDate@CPCBangPointTimeCondition@@QAEHHHH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
?GetTimeDate@CPCBangPointTimeCondition@@QAEHHHH@Z PROC	; CPCBangPointTimeCondition::GetTimeDate, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 36   : 	if(iMonth < 3)
; 37   : 	{
; 38   : 		iYear--;

  00004	8b 75 08	 mov	 esi, DWORD PTR _iYear$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR _iMonth$[ebp]
  0000b	83 ff 03	 cmp	 edi, 3
  0000e	7d 04		 jge	 SHORT $LN1@GetTimeDat
  00010	4e		 dec	 esi

; 39   : 		iMonth += 12;

  00011	83 c7 0c	 add	 edi, 12			; 0000000cH
$LN1@GetTimeDat:

; 40   : 	}
; 41   : 
; 42   : 	int loc2 = iYear / 100; //
; 43   : 	int loc3 = iYear % 100; //

  00014	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00019	f7 ee		 imul	 esi
  0001b	c1 fa 05	 sar	 edx, 5
  0001e	8b ca		 mov	 ecx, edx
  00020	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00023	03 ca		 add	 ecx, edx

; 44   : 
; 45   : 	int loc4 = ((21 * loc2) / 4) + ((5 * loc3) / 4) + ( iDay + (iMonth + 1) * 26 / 10) - 1;

  00025	8b c1		 mov	 eax, ecx
  00027	6b c0 64	 imul	 eax, 100		; 00000064H
  0002a	2b f0		 sub	 esi, eax
  0002c	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0002f	99		 cdq
  00030	83 e2 03	 and	 edx, 3
  00033	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00036	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  00039	6b d2 1a	 imul	 edx, 26			; 0000001aH
  0003c	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00041	f7 ea		 imul	 edx
  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c1		 mov	 eax, ecx
  00048	6b c0 15	 imul	 eax, 21			; 00000015H
  0004b	8b fa		 mov	 edi, edx
  0004d	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00050	03 fa		 add	 edi, edx
  00052	03 7d 10	 add	 edi, DWORD PTR _iDay$[ebp]
  00055	99		 cdq
  00056	83 e2 03	 and	 edx, 3
  00059	03 c2		 add	 eax, edx
  0005b	c1 f8 02	 sar	 eax, 2
  0005e	c1 fe 02	 sar	 esi, 2
  00061	03 fe		 add	 edi, esi
  00063	8d 4c 38 ff	 lea	 ecx, DWORD PTR [eax+edi-1]

; 46   : 
; 47   : 	loc4 = loc4%7;

  00067	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0006c	f7 e9		 imul	 ecx
  0006e	03 d1		 add	 edx, ecx
  00070	c1 fa 02	 sar	 edx, 2
  00073	8b c2		 mov	 eax, edx
  00075	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00078	03 c2		 add	 eax, edx
  0007a	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00081	2b d0		 sub	 edx, eax
  00083	8b c1		 mov	 eax, ecx
  00085	5f		 pop	 edi
  00086	2b c2		 sub	 eax, edx
  00088	5e		 pop	 esi

; 48   : 
; 49   : 	return loc4;
; 50   : }

  00089	5d		 pop	 ebp
  0008a	c2 0c 00	 ret	 12			; 0000000cH
?GetTimeDate@CPCBangPointTimeCondition@@QAEHHHH@Z ENDP	; CPCBangPointTimeCondition::GetTimeDate
_TEXT	ENDS
PUBLIC	?IsLeapYear@CPCBangPointTimeCondition@@QAEEH@Z	; CPCBangPointTimeCondition::IsLeapYear
; Function compile flags: /Ogtp
;	COMDAT ?IsLeapYear@CPCBangPointTimeCondition@@QAEEH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
?IsLeapYear@CPCBangPointTimeCondition@@QAEEH@Z PROC	; CPCBangPointTimeCondition::IsLeapYear, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	int loc2;
; 56   : 
; 57   : 	if( (iYear % 400) != 0 && ((iYear % 4) != 0 || (iYear % 100) == 0) )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iYear$[ebp]
  00006	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0000b	f7 e9		 imul	 ecx
  0000d	c1 fa 07	 sar	 edx, 7
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx
  00017	69 c0 90 01 00
	00		 imul	 eax, 400		; 00000190H
  0001d	8b d1		 mov	 edx, ecx
  0001f	2b d0		 sub	 edx, eax
  00021	74 2e		 je	 SHORT $LN3@IsLeapYear
  00023	8b c1		 mov	 eax, ecx
  00025	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0002a	79 05		 jns	 SHORT $LN6@IsLeapYear
  0002c	48		 dec	 eax
  0002d	83 c8 fc	 or	 eax, -4			; fffffffcH
  00030	40		 inc	 eax
$LN6@IsLeapYear:
  00031	75 18		 jne	 SHORT $LN2@IsLeapYear
  00033	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00038	f7 e9		 imul	 ecx
  0003a	c1 fa 05	 sar	 edx, 5
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00042	03 c2		 add	 eax, edx
  00044	6b c0 64	 imul	 eax, 100		; 00000064H
  00047	2b c8		 sub	 ecx, eax
  00049	75 06		 jne	 SHORT $LN3@IsLeapYear
$LN2@IsLeapYear:

; 58   : 	{
; 59   : 		loc2 = 0;

  0004b	33 c0		 xor	 eax, eax

; 64   : 	}
; 65   : 
; 66   : 	return loc2;
; 67   : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN3@IsLeapYear:

; 60   : 	}
; 61   : 	else
; 62   : 	{
; 63   : 		loc2 = 1;

  00051	b8 01 00 00 00	 mov	 eax, 1

; 64   : 	}
; 65   : 
; 66   : 	return loc2;
; 67   : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?IsLeapYear@CPCBangPointTimeCondition@@QAEEH@Z ENDP	; CPCBangPointTimeCondition::IsLeapYear
_TEXT	ENDS
PUBLIC	?GetNumberedDays@CPCBangPointTimeCondition@@QAEHHH@Z ; CPCBangPointTimeCondition::GetNumberedDays
; Function compile flags: /Ogtp
;	COMDAT ?GetNumberedDays@CPCBangPointTimeCondition@@QAEHHH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
?GetNumberedDays@CPCBangPointTimeCondition@@QAEHHH@Z PROC ; CPCBangPointTimeCondition::GetNumberedDays, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	switch(iMonth)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMonth$[ebp]
  00006	83 c0 fe	 add	 eax, -2			; fffffffeH
  00009	83 f8 09	 cmp	 eax, 9
  0000c	77 2e		 ja	 SHORT $LN1@GetNumbere
  0000e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN8@GetNumbere[eax]
  00015	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN9@GetNumbere[eax*4]
$LN3@GetNumbere:

; 72   : 	{
; 73   : 	case 2:
; 74   : 		return !!IsLeapYear(iYear) + 28;

  0001c	8b 55 08	 mov	 edx, DWORD PTR _iYear$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?IsLeapYear@CPCBangPointTimeCondition@@QAEEH@Z ; CPCBangPointTimeCondition::IsLeapYear
  00025	33 c9		 xor	 ecx, ecx
  00027	84 c0		 test	 al, al
  00029	0f 95 c1	 setne	 cl
  0002c	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]

; 84   : 	}
; 85   : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN2@GetNumbere:

; 75   : 		break;
; 76   : 	case 4:
; 77   : 	case 6:
; 78   : 	case 9:
; 79   : 	case 11:
; 80   : 		return 30;

  00033	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH

; 84   : 	}
; 85   : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN1@GetNumbere:

; 81   : 		break;
; 82   : 	default:
; 83   : 		return 31;

  0003c	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH

; 84   : 	}
; 85   : }

  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
  00045	8d 49 00	 npad	 3
$LN9@GetNumbere:
  00048	00 00 00 00	 DD	 $LN3@GetNumbere
  0004c	00 00 00 00	 DD	 $LN2@GetNumbere
  00050	00 00 00 00	 DD	 $LN1@GetNumbere
$LN8@GetNumbere:
  00054	00		 DB	 0
  00055	02		 DB	 2
  00056	01		 DB	 1
  00057	02		 DB	 2
  00058	01		 DB	 1
  00059	02		 DB	 2
  0005a	02		 DB	 2
  0005b	01		 DB	 1
  0005c	02		 DB	 2
  0005d	01		 DB	 1
?GetNumberedDays@CPCBangPointTimeCondition@@QAEHHH@Z ENDP ; CPCBangPointTimeCondition::GetNumberedDays
_TEXT	ENDS
PUBLIC	?ModifyTimeDate@CPCBangPointTimeCondition@@QAEXHPAH00@Z ; CPCBangPointTimeCondition::ModifyTimeDate
; Function compile flags: /Ogtp
;	COMDAT ?ModifyTimeDate@CPCBangPointTimeCondition@@QAEXHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iDayOfWeek$ = 8					; size = 4
_iYear$ = 12						; size = 4
_iMonth$ = 16						; size = 4
_iDay$ = 20						; size = 4
?ModifyTimeDate@CPCBangPointTimeCondition@@QAEXHPAH00@Z PROC ; CPCBangPointTimeCondition::ModifyTimeDate, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 89   : 	int loc2 = this->GetTimeDate(*iYear, *iMonth, *iDay);

  00004	8b 45 14	 mov	 eax, DWORD PTR _iDay$[ebp]
  00007	8b 55 10	 mov	 edx, DWORD PTR _iMonth$[ebp]
  0000a	53		 push	 ebx
  0000b	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0000d	56		 push	 esi
  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8b 45 0c	 mov	 eax, DWORD PTR _iYear$[ebp]
  00013	8b 10		 mov	 edx, DWORD PTR [eax]
  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	53		 push	 ebx
  00018	52		 push	 edx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	e8 00 00 00 00	 call	 ?GetTimeDate@CPCBangPointTimeCondition@@QAEHHHH@Z ; CPCBangPointTimeCondition::GetTimeDate

; 90   : 	int loc3 = ((loc2 + 7) - iDayOfWeek)%7;

  00021	b9 07 00 00 00	 mov	 ecx, 7
  00026	2b 4d 08	 sub	 ecx, DWORD PTR _iDayOfWeek$[ebp]
  00029	03 c1		 add	 eax, ecx
  0002b	99		 cdq
  0002c	b9 07 00 00 00	 mov	 ecx, 7
  00031	f7 f9		 idiv	 ecx
  00033	8b fa		 mov	 edi, edx

; 91   : 
; 92   : 	if(*iDay > loc3)

  00035	3b f7		 cmp	 esi, edi
  00037	7e 10		 jle	 SHORT $LN4@ModifyTime

; 93   : 	{
; 94   : 		*iDay -= loc3;

  00039	8b 55 14	 mov	 edx, DWORD PTR _iDay$[ebp]
  0003c	2b f7		 sub	 esi, edi
  0003e	5f		 pop	 edi
  0003f	89 32		 mov	 DWORD PTR [edx], esi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 110  : 	}
; 111  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 10 00	 ret	 16			; 00000010H
$LN4@ModifyTime:

; 95   : 	}
; 96   : 	else
; 97   : 	{
; 98   : 		loc3 -= *iDay;

  00049	2b fe		 sub	 edi, esi

; 99   : 
; 100  : 		if(*iMonth == 1)

  0004b	83 fb 01	 cmp	 ebx, 1
  0004e	75 10		 jne	 SHORT $LN2@ModifyTime

; 101  : 		{
; 102  : 			*iMonth = 12;

  00050	8b 45 10	 mov	 eax, DWORD PTR _iMonth$[ebp]
  00053	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 103  : 			*iYear -= 1;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _iYear$[ebp]
  0005c	ff 08		 dec	 DWORD PTR [eax]

; 104  : 		}
; 105  : 		else

  0005e	eb 09		 jmp	 SHORT $LN1@ModifyTime
$LN2@ModifyTime:

; 106  : 		{
; 107  : 			*iMonth -= 1;

  00060	8b 4d 10	 mov	 ecx, DWORD PTR _iMonth$[ebp]
  00063	8b 45 0c	 mov	 eax, DWORD PTR _iYear$[ebp]
  00066	4b		 dec	 ebx
  00067	89 19		 mov	 DWORD PTR [ecx], ebx
$LN1@ModifyTime:

; 108  : 		}
; 109  : 		*iDay = this->GetNumberedDays(*iYear, *iMonth) - loc3;

  00069	8b 55 10	 mov	 edx, DWORD PTR _iMonth$[ebp]
  0006c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0006e	8b 10		 mov	 edx, DWORD PTR [eax]
  00070	51		 push	 ecx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?GetNumberedDays@CPCBangPointTimeCondition@@QAEHHH@Z ; CPCBangPointTimeCondition::GetNumberedDays
  0007a	8b 4d 14	 mov	 ecx, DWORD PTR _iDay$[ebp]
  0007d	2b c7		 sub	 eax, edi
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	89 01		 mov	 DWORD PTR [ecx], eax
  00083	5b		 pop	 ebx

; 110  : 	}
; 111  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 10 00	 ret	 16			; 00000010H
?ModifyTimeDate@CPCBangPointTimeCondition@@QAEXHPAH00@Z ENDP ; CPCBangPointTimeCondition::ModifyTimeDate
_TEXT	ENDS
PUBLIC	?CheckUserTimeDate@CPCBangPointTimeCondition@@QAEHHHHHHHHH@Z ; CPCBangPointTimeCondition::CheckUserTimeDate
; Function compile flags: /Ogtp
;	COMDAT ?CheckUserTimeDate@CPCBangPointTimeCondition@@QAEHHHHHHHHH@Z
_TEXT	SEGMENT
_iUSR_Year$ = 8						; size = 4
_iUSR_Month$ = 12					; size = 4
_iUSR_Day$ = 16						; size = 4
_iUSR_Hour$ = 20					; size = 4
_iSVR_Year$ = 24					; size = 4
_iSVR_Month$ = 28					; size = 4
_iSVR_Day$ = 32						; size = 4
_iSVR_Hour$ = 36					; size = 4
?CheckUserTimeDate@CPCBangPointTimeCondition@@QAEHHHHHHHHH@Z PROC ; CPCBangPointTimeCondition::CheckUserTimeDate, COMDAT
; _this$ = ecx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 115  : 	if( iUSR_Year == iSVR_Year &&
; 116  : 		iUSR_Month == iSVR_Month &&
; 117  : 		iUSR_Day == iSVR_Day &&
; 118  : 		iUSR_Hour == iSVR_Hour )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iUSR_Year$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	3b 45 18	 cmp	 eax, DWORD PTR _iSVR_Year$[ebp]
  0000c	75 37		 jne	 SHORT $LN1@CheckUserT
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _iUSR_Month$[ebp]
  00011	8b 5d 1c	 mov	 ebx, DWORD PTR _iSVR_Month$[ebp]
  00014	3b fb		 cmp	 edi, ebx
  00016	75 2b		 jne	 SHORT $LN9@CheckUserT
  00018	8b 45 10	 mov	 eax, DWORD PTR _iUSR_Day$[ebp]
  0001b	8b 4d 20	 mov	 ecx, DWORD PTR _iSVR_Day$[ebp]
  0001e	8b 55 24	 mov	 edx, DWORD PTR _iSVR_Hour$[ebp]
  00021	8b 75 14	 mov	 esi, DWORD PTR _iUSR_Hour$[ebp]
  00024	3b c1		 cmp	 eax, ecx
  00026	75 17		 jne	 SHORT $LN11@CheckUserT
  00028	3b f2		 cmp	 esi, edx
  0002a	75 09		 jne	 SHORT $LN6@CheckUserT

; 119  : 	{
; 120  : 		return 0;

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	33 c0		 xor	 eax, eax
  00030	5b		 pop	 ebx

; 132  : }

  00031	5d		 pop	 ebp
  00032	c2 20 00	 ret	 32			; 00000020H
$LN6@CheckUserT:

; 121  : 	}
; 122  : 
; 123  : 	if( (iUSR_Year == iSVR_Year && iUSR_Month == iSVR_Month && iUSR_Day == iSVR_Day && iUSR_Hour > iSVR_Hour) ||
; 124  : 		(iUSR_Year == iSVR_Year && iUSR_Month == iSVR_Month && iUSR_Day > iSVR_Day) ||	
; 125  : 		(iUSR_Year == iSVR_Year && iUSR_Month > iSVR_Month) ||			 
; 126  : 		(iUSR_Year > iSVR_Year) )

  00035	3b c1		 cmp	 eax, ecx
  00037	75 06		 jne	 SHORT $LN11@CheckUserT
  00039	3b f2		 cmp	 esi, edx
  0003b	7f 10		 jg	 SHORT $LN4@CheckUserT
  0003d	3b c1		 cmp	 eax, ecx
$LN11@CheckUserT:
  0003f	7f 0c		 jg	 SHORT $LN4@CheckUserT
  00041	3b fb		 cmp	 edi, ebx
$LN9@CheckUserT:
  00043	7f 08		 jg	 SHORT $LN4@CheckUserT
$LN1@CheckUserT:
  00045	8b 4d 18	 mov	 ecx, DWORD PTR _iSVR_Year$[ebp]
  00048	39 4d 08	 cmp	 DWORD PTR _iUSR_Year$[ebp], ecx
  0004b	7e 0c		 jle	 SHORT $LN5@CheckUserT
$LN4@CheckUserT:
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi

; 127  : 	{
; 128  : 		return 1;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	5b		 pop	 ebx

; 132  : }

  00055	5d		 pop	 ebp
  00056	c2 20 00	 ret	 32			; 00000020H
$LN5@CheckUserT:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi

; 129  : 	}
; 130  : 
; 131  : 	return -1; //mismatch :)

  0005b	83 c8 ff	 or	 eax, -1
  0005e	5b		 pop	 ebx

; 132  : }

  0005f	5d		 pop	 ebp
  00060	c2 20 00	 ret	 32			; 00000020H
?CheckUserTimeDate@CPCBangPointTimeCondition@@QAEHHHHHHHHH@Z ENDP ; CPCBangPointTimeCondition::CheckUserTimeDate
_TEXT	ENDS
PUBLIC	??_7CPCBangPointTimer@@6B@			; CPCBangPointTimer::`vftable'
PUBLIC	??0CPCBangPointTimer@@QAE@XZ			; CPCBangPointTimer::CPCBangPointTimer
PUBLIC	??_R4CPCBangPointTimer@@6B@			; CPCBangPointTimer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPCBangPointTimer@@@8			; CPCBangPointTimer `RTTI Type Descriptor'
PUBLIC	??_R3CPCBangPointTimer@@8			; CPCBangPointTimer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPCBangPointTimer@@8			; CPCBangPointTimer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPCBangPointTimer@@8		; CPCBangPointTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECPCBangPointTimer@@UAEPAXI@Z:PROC		; CPCBangPointTimer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CPCBangPointTimer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPCBangPointTimer@@8 DD FLAT:??_R0?AVCPCBangPointTimer@@@8 ; CPCBangPointTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPCBangPointTimer@@8
rdata$r	ENDS
;	COMDAT ??_R2CPCBangPointTimer@@8
rdata$r	SEGMENT
??_R2CPCBangPointTimer@@8 DD FLAT:??_R1A@?0A@EA@CPCBangPointTimer@@8 ; CPCBangPointTimer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CPCBangPointTimeCondition@@8
rdata$r	ENDS
;	COMDAT ??_R3CPCBangPointTimer@@8
rdata$r	SEGMENT
??_R3CPCBangPointTimer@@8 DD 00H			; CPCBangPointTimer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPCBangPointTimer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPCBangPointTimer@@@8
_DATA	SEGMENT
??_R0?AVCPCBangPointTimer@@@8 DD FLAT:??_7type_info@@6B@ ; CPCBangPointTimer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPCBangPointTimer@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CPCBangPointTimer@@6B@
rdata$r	SEGMENT
??_R4CPCBangPointTimer@@6B@ DD 00H			; CPCBangPointTimer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPCBangPointTimer@@@8
	DD	FLAT:??_R3CPCBangPointTimer@@8
rdata$r	ENDS
;	COMDAT ??_7CPCBangPointTimer@@6B@
CONST	SEGMENT
??_7CPCBangPointTimer@@6B@ DD FLAT:??_R4CPCBangPointTimer@@6B@ ; CPCBangPointTimer::`vftable'
	DD	FLAT:??_ECPCBangPointTimer@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CPCBangPointTimer@@QAE@XZ
_TEXT	SEGMENT
??0CPCBangPointTimer@@QAE@XZ PROC			; CPCBangPointTimer::CPCBangPointTimer, COMDAT
; _this$ = ecx

; 136  : {

  00000	e8 00 00 00 00	 call	 ??0CPCBangPointTimeCondition@@QAE@XZ ; CPCBangPointTimeCondition::CPCBangPointTimeCondition
  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00010	33 c0		 xor	 eax, eax
  00012	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00015	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00018	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0001b	89 41 34	 mov	 DWORD PTR [ecx+52], eax
  0001e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CPCBangPointTimer@@6B@
  00024	c7 41 04 d0 07
	00 00		 mov	 DWORD PTR [ecx+4], 2000	; 000007d0H

; 137  : 	return;
; 138  : }

  0002b	8b c1		 mov	 eax, ecx
  0002d	c3		 ret	 0
??0CPCBangPointTimer@@QAE@XZ ENDP			; CPCBangPointTimer::CPCBangPointTimer
_TEXT	ENDS
PUBLIC	??1CPCBangPointTimer@@UAE@XZ			; CPCBangPointTimer::~CPCBangPointTimer
; Function compile flags: /Ogtp
;	COMDAT ??1CPCBangPointTimer@@UAE@XZ
_TEXT	SEGMENT
??1CPCBangPointTimer@@UAE@XZ PROC			; CPCBangPointTimer::~CPCBangPointTimer, COMDAT
; _this$ = ecx

; 142  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CPCBangPointTimer@@6B@

; 143  : 	return;
; 144  : }

  00006	e9 00 00 00 00	 jmp	 ??1CPCBangPointTimeCondition@@UAE@XZ ; CPCBangPointTimeCondition::~CPCBangPointTimeCondition
??1CPCBangPointTimer@@UAE@XZ ENDP			; CPCBangPointTimer::~CPCBangPointTimer
_TEXT	ENDS
PUBLIC	?SetResetTimeData@CPCBangPointTimer@@QAEXHHHHHHP6AXPAV1@H@ZH@Z ; CPCBangPointTimer::SetResetTimeData
; Function compile flags: /Ogtp
;	COMDAT ?SetResetTimeData@CPCBangPointTimer@@QAEXHHHHHHP6AXPAV1@H@ZH@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
_iHour$ = 20						; size = 4
_iSvrDayWeek$ = 24					; size = 4
_iSvrHour$ = 28						; size = 4
_iTUserIndex$ = 32					; size = 4
_aIndex$ = 36						; size = 4
?SetResetTimeData@CPCBangPointTimer@@QAEXHHHHHHP6AXPAV1@H@ZH@Z PROC ; CPCBangPointTimer::SetResetTimeData, COMDAT
; _this$ = ecx

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  : 	//User Data
; 150  : 	this->m_iUSR_ResetYear = iYear;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]

; 151  : 	this->m_iUSR_ResetMonth = iMonth;

  00006	8b 55 0c	 mov	 edx, DWORD PTR _iMonth$[ebp]
  00009	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 152  : 	this->m_iUSR_ResetDay = iDay;

  0000c	8b 45 10	 mov	 eax, DWORD PTR _iDay$[ebp]
  0000f	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 153  : 	this->m_iUSR_ResetHour = iHour;

  00012	8b 55 14	 mov	 edx, DWORD PTR _iHour$[ebp]
  00015	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 154  : 
; 155  : 	//CommonServer Data
; 156  : 	this->m_iSVR_ResetDayOfWeek = iSvrDayWeek;

  00018	8b 45 18	 mov	 eax, DWORD PTR _iSvrDayWeek$[ebp]
  0001b	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 157  : 	this->m_iSVR_ResetHour = iSvrHour;

  0001e	8b 55 1c	 mov	 edx, DWORD PTR _iSvrHour$[ebp]
  00021	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 158  : 	this->m_iTUserIndex = iTUserIndex;

  00024	8b 45 20	 mov	 eax, DWORD PTR _iTUserIndex$[ebp]
  00027	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 159  : 
; 160  : 	this->m_iUserIndex = aIndex;

  0002a	8b 55 24	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00030	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 161  : }

  00033	5d		 pop	 ebp
  00034	c2 20 00	 ret	 32			; 00000020H
?SetResetTimeData@CPCBangPointTimer@@QAEXHHHHHHP6AXPAV1@H@ZH@Z ENDP ; CPCBangPointTimer::SetResetTimeData
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CheckTime@CPCBangPointTimer@@QAEHXZ		; CPCBangPointTimer::CheckTime
EXTRN	__imp__GetLocalTime@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CheckTime@CPCBangPointTimer@@QAEHXZ
_TEXT	SEGMENT
tv215 = -40						; size = 4
tv219 = -36						; size = 4
_iSVR_iMonth$ = -32					; size = 4
_iSVR_iYear$ = -28					; size = 4
_iSVR_iDay$ = -24					; size = 4
_m_tmTime$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
?CheckTime@CPCBangPointTimer@@QAEHXZ PROC		; CPCBangPointTimer::CheckTime, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx

; 172  : 	int iSVR_iYear, iSVR_iMonth, iSVR_iDay, iSVR_ResetHour;
; 173  : 	SYSTEMTIME m_tmTime; //
; 174  : 
; 175  : 	if(this->m_bSetTimer == FALSE) //always false lol

  00013	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00017	75 14		 jne	 SHORT $LN4@CheckTime

; 176  : 	{
; 177  : 		return 1;

  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	5e		 pop	 esi

; 212  : 	}
; 213  : 
; 214  : 	return 1;
; 215  : }

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00022	33 cd		 xor	 ecx, ebp
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN4@CheckTime:
  0002d	53		 push	 ebx

; 178  : 	}
; 179  : 
; 180  : 	GetLocalTime(&m_tmTime);

  0002e	8d 45 ec	 lea	 eax, DWORD PTR _m_tmTime$[ebp]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 181  : 
; 182  : 	if( this->m_tmPcBangResetTime.wYear == m_tmTime.wYear &&
; 183  : 		this->m_tmPcBangResetTime.wMonth == m_tmTime.wMonth &&
; 184  : 		this->m_tmPcBangResetTime.wDay == m_tmTime.wDay &&
; 185  : 		this->m_tmPcBangResetTime.wHour == m_tmTime.wHour)

  00038	8b 45 ec	 mov	 eax, DWORD PTR _m_tmTime$[ebp]
  0003b	8b 4d f4	 mov	 ecx, DWORD PTR _m_tmTime$[ebp+8]
  0003e	66 8b 55 f2	 mov	 dx, WORD PTR _m_tmTime$[ebp+6]
  00042	66 8b 5d ee	 mov	 bx, WORD PTR _m_tmTime$[ebp+2]
  00046	66 39 46 24	 cmp	 WORD PTR [esi+36], ax
  0004a	75 27		 jne	 SHORT $LN3@CheckTime
  0004c	66 39 5e 26	 cmp	 WORD PTR [esi+38], bx
  00050	75 21		 jne	 SHORT $LN3@CheckTime
  00052	66 39 56 2a	 cmp	 WORD PTR [esi+42], dx
  00056	75 1b		 jne	 SHORT $LN3@CheckTime
  00058	66 39 4e 2c	 cmp	 WORD PTR [esi+44], cx
  0005c	75 15		 jne	 SHORT $LN3@CheckTime

; 186  : 	{
; 187  : 		return 1;

  0005e	5b		 pop	 ebx
  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5e		 pop	 esi

; 212  : 	}
; 213  : 
; 214  : 	return 1;
; 215  : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN3@CheckTime:
  00073	57		 push	 edi

; 188  : 	}
; 189  : 
; 190  : 	this->m_tmPcBangResetTime = m_tmTime;

  00074	8b 7d f0	 mov	 edi, DWORD PTR _m_tmTime$[ebp+4]
  00077	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0007a	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0007d	8b 7d f8	 mov	 edi, DWORD PTR _m_tmTime$[ebp+12]
  00080	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00083	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 191  : 
; 192  : 	iSVR_iYear = m_tmTime.wYear; //loc2

  00086	0f b7 f8	 movzx	 edi, ax

; 193  : 	iSVR_iMonth = m_tmTime.wMonth; //loc3
; 194  : 	iSVR_iDay = m_tmTime.wDay; //loc4
; 195  : 	iSVR_ResetHour = this->m_iSVR_ResetHour; //loc5
; 196  : 
; 197  : 	if( this->m_iSVR_ResetHour > m_tmTime.wHour )

  00089	0f b7 c9	 movzx	 ecx, cx
  0008c	0f b7 c2	 movzx	 eax, dx
  0008f	0f b7 db	 movzx	 ebx, bx
  00092	89 7d e4	 mov	 DWORD PTR _iSVR_iYear$[ebp], edi
  00095	89 5d e0	 mov	 DWORD PTR _iSVR_iMonth$[ebp], ebx
  00098	89 45 d8	 mov	 DWORD PTR tv215[ebp], eax
  0009b	89 45 e8	 mov	 DWORD PTR _iSVR_iDay$[ebp], eax
  0009e	89 4d dc	 mov	 DWORD PTR tv219[ebp], ecx
  000a1	39 4e 18	 cmp	 DWORD PTR [esi+24], ecx
  000a4	7e 03		 jle	 SHORT $LN2@CheckTime

; 198  : 	{
; 199  : 		iSVR_iDay--;

  000a6	ff 4d e8	 dec	 DWORD PTR _iSVR_iDay$[ebp]
$LN2@CheckTime:

; 200  : 	}
; 201  : 
; 202  : 	this->ModifyTimeDate(this->m_iSVR_ResetDayOfWeek, &iSVR_iYear, &iSVR_iMonth, &iSVR_iDay);

  000a9	8d 4d e8	 lea	 ecx, DWORD PTR _iSVR_iDay$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000b0	8d 55 e0	 lea	 edx, DWORD PTR _iSVR_iMonth$[ebp]
  000b3	52		 push	 edx
  000b4	8d 45 e4	 lea	 eax, DWORD PTR _iSVR_iYear$[ebp]
  000b7	50		 push	 eax
  000b8	51		 push	 ecx
  000b9	8b ce		 mov	 ecx, esi
  000bb	e8 00 00 00 00	 call	 ?ModifyTimeDate@CPCBangPointTimeCondition@@QAEXHPAH00@Z ; CPCBangPointTimeCondition::ModifyTimeDate

; 203  : 
; 204  : 	if(this->CheckUserTimeDate(this->m_iUSR_ResetYear, this->m_iUSR_ResetMonth, this->m_iUSR_ResetDay, this->m_iUSR_ResetHour, iSVR_iYear, iSVR_iMonth, iSVR_iDay, iSVR_ResetHour) < 0)

  000c0	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000c3	8b 55 e8	 mov	 edx, DWORD PTR _iSVR_iDay$[ebp]
  000c6	8b 4d e4	 mov	 ecx, DWORD PTR _iSVR_iYear$[ebp]
  000c9	50		 push	 eax
  000ca	8b 45 e0	 mov	 eax, DWORD PTR _iSVR_iMonth$[ebp]
  000cd	52		 push	 edx
  000ce	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000d1	50		 push	 eax
  000d2	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000d5	51		 push	 ecx
  000d6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d9	52		 push	 edx
  000da	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000dd	50		 push	 eax
  000de	51		 push	 ecx
  000df	52		 push	 edx
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?CheckUserTimeDate@CPCBangPointTimeCondition@@QAEHHHHHHHHH@Z ; CPCBangPointTimeCondition::CheckUserTimeDate
  000e7	85 c0		 test	 eax, eax
  000e9	79 35		 jns	 SHORT $LN1@CheckTime

; 205  : 	{
; 206  : 		this->m_iUSR_ResetYear = m_tmTime.wYear;
; 207  : 		this->m_iUSR_ResetMonth = m_tmTime.wMonth;
; 208  : 		this->m_iUSR_ResetDay = m_tmTime.wDay;
; 209  : 		this->m_iUSR_ResetHour = m_tmTime.wHour;
; 210  : 		this->m_iTUserIndex(this, this->m_iUserIndex); //identical ok you are missing the other call...

  000eb	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000ee	8b 45 d8	 mov	 eax, DWORD PTR tv215[ebp]
  000f1	8b 4d dc	 mov	 ecx, DWORD PTR tv219[ebp]
  000f4	52		 push	 edx
  000f5	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000f8	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000fb	56		 push	 esi
  000fc	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000ff	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00102	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00105	ff d0		 call	 eax
  00107	83 c4 08	 add	 esp, 8
  0010a	5f		 pop	 edi
  0010b	5b		 pop	 ebx

; 211  : 		return 2;

  0010c	b8 02 00 00 00	 mov	 eax, 2
  00111	5e		 pop	 esi

; 212  : 	}
; 213  : 
; 214  : 	return 1;
; 215  : }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN1@CheckTime:
  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	5f		 pop	 edi
  00124	5b		 pop	 ebx
  00125	33 cd		 xor	 ecx, ebp
  00127	b8 01 00 00 00	 mov	 eax, 1
  0012c	5e		 pop	 esi
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
?CheckTime@CPCBangPointTimer@@QAEHXZ ENDP		; CPCBangPointTimer::CheckTime
_TEXT	ENDS
PUBLIC	?SetCheckTimer@CPCBangPointTimer@@QAEXH@Z	; CPCBangPointTimer::SetCheckTimer
; Function compile flags: /Ogtp
;	COMDAT ?SetCheckTimer@CPCBangPointTimer@@QAEXH@Z
_TEXT	SEGMENT
_bResult$ = 8						; size = 4
?SetCheckTimer@CPCBangPointTimer@@QAEXH@Z PROC		; CPCBangPointTimer::SetCheckTimer, COMDAT
; _this$ = ecx

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  : 	this->m_bSetTimer = bResult;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bResult$[ebp]
  00006	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 221  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetCheckTimer@CPCBangPointTimer@@QAEXH@Z ENDP		; CPCBangPointTimer::SetCheckTimer
_TEXT	ENDS
PUBLIC	?ChangeTimeDate@CPCBangPointTimer@@QAEXPAH000@Z	; CPCBangPointTimer::ChangeTimeDate
; Function compile flags: /Ogtp
;	COMDAT ?ChangeTimeDate@CPCBangPointTimer@@QAEXPAH000@Z
_TEXT	SEGMENT
_iYear$ = 8						; size = 4
_iMonth$ = 12						; size = 4
_iDay$ = 16						; size = 4
_iHour$ = 20						; size = 4
?ChangeTimeDate@CPCBangPointTimer@@QAEXPAH000@Z PROC	; CPCBangPointTimer::ChangeTimeDate, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 226  : 	this->m_iUSR_ResetYear = *iYear;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iYear$[ebp]
  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 227  : 	this->m_iUSR_ResetMonth = *iMonth;

  00008	8b 45 0c	 mov	 eax, DWORD PTR _iMonth$[ebp]
  0000b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0000e	8b 10		 mov	 edx, DWORD PTR [eax]

; 228  : 	this->m_iUSR_ResetDay = *iDay;

  00010	8b 45 10	 mov	 eax, DWORD PTR _iDay$[ebp]
  00013	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00016	8b 10		 mov	 edx, DWORD PTR [eax]

; 229  : 	this->m_iUSR_ResetHour = *iHour;

  00018	8b 45 14	 mov	 eax, DWORD PTR _iHour$[ebp]
  0001b	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 230  : }

  00023	5d		 pop	 ebp
  00024	c2 10 00	 ret	 16			; 00000010H
?ChangeTimeDate@CPCBangPointTimer@@QAEXPAH000@Z ENDP	; CPCBangPointTimer::ChangeTimeDate
_TEXT	ENDS
PUBLIC	??_7CPCBangPointSystem@@6B@			; CPCBangPointSystem::`vftable'
PUBLIC	??1CPCBangPointSystem@@UAE@XZ			; CPCBangPointSystem::~CPCBangPointSystem
PUBLIC	??_R4CPCBangPointSystem@@6B@			; CPCBangPointSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPCBangPointSystem@@@8			; CPCBangPointSystem `RTTI Type Descriptor'
PUBLIC	??_R3CPCBangPointSystem@@8			; CPCBangPointSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPCBangPointSystem@@8			; CPCBangPointSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPCBangPointSystem@@8		; CPCBangPointSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECPCBangPointSystem@@UAEPAXI@Z:PROC		; CPCBangPointSystem::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CPCBangPointSystem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPCBangPointSystem@@8 DD FLAT:??_R0?AVCPCBangPointSystem@@@8 ; CPCBangPointSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPCBangPointSystem@@8
rdata$r	ENDS
;	COMDAT ??_R2CPCBangPointSystem@@8
rdata$r	SEGMENT
??_R2CPCBangPointSystem@@8 DD FLAT:??_R1A@?0A@EA@CPCBangPointSystem@@8 ; CPCBangPointSystem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CPCBangPointSystem@@8
rdata$r	SEGMENT
??_R3CPCBangPointSystem@@8 DD 00H			; CPCBangPointSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CPCBangPointSystem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPCBangPointSystem@@@8
_DATA	SEGMENT
??_R0?AVCPCBangPointSystem@@@8 DD FLAT:??_7type_info@@6B@ ; CPCBangPointSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPCBangPointSystem@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CPCBangPointSystem@@6B@
rdata$r	SEGMENT
??_R4CPCBangPointSystem@@6B@ DD 00H			; CPCBangPointSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPCBangPointSystem@@@8
	DD	FLAT:??_R3CPCBangPointSystem@@8
rdata$r	ENDS
;	COMDAT ??_7CPCBangPointSystem@@6B@
CONST	SEGMENT
??_7CPCBangPointSystem@@6B@ DD FLAT:??_R4CPCBangPointSystem@@6B@ ; CPCBangPointSystem::`vftable'
	DD	FLAT:??_ECPCBangPointSystem@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CPCBangPointSystem@@UAE@XZ
_TEXT	SEGMENT
??1CPCBangPointSystem@@UAE@XZ PROC			; CPCBangPointSystem::~CPCBangPointSystem, COMDAT
; _this$ = ecx

; 261  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CPCBangPointSystem@@6B@

; 262  : 
; 263  : }

  00006	c3		 ret	 0
??1CPCBangPointSystem@@UAE@XZ ENDP			; CPCBangPointSystem::~CPCBangPointSystem
_TEXT	ENDS
PUBLIC	?Init@CPCBangPointSystem@@QAEXXZ		; CPCBangPointSystem::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CPCBangPointSystem@@QAEXXZ
_TEXT	SEGMENT
?Init@CPCBangPointSystem@@QAEXXZ PROC			; CPCBangPointSystem::Init, COMDAT
; _this$ = ecx

; 267  : 	for (int i = 0; i <= MAX_PCBANG_ITEM_COUNT; i++)

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00003	ba 07 00 00 00	 mov	 edx, 7
$LL3@Init:

; 268  : 	{
; 269  : 		memset(&this->m_PcBangSystem[i], 0, sizeof(this->m_PcBangSystem[i]));

  00008	33 c9		 xor	 ecx, ecx
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00013	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00016	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 270  : 		this->m_PcBangSystem[i].Index = -1;

  00019	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0001f	83 c0 18	 add	 eax, 24			; 00000018H
  00022	4a		 dec	 edx
  00023	75 e3		 jne	 SHORT $LL3@Init

; 271  : 	}
; 272  : }

  00025	c3		 ret	 0
?Init@CPCBangPointSystem@@QAEXXZ ENDP			; CPCBangPointSystem::Init
_TEXT	ENDS
PUBLIC	??_C@_0DI@OHBCGPFP@?$FLPCBangPointSystem?$FN?5?9?5File?5load?5@ ; `string'
PUBLIC	??_C@_0DI@HNBKFLKH@?$FLPCBangPointSystem?$FN?5Loading?5Exce@ ; `string'
PUBLIC	??_C@_0DB@ICJBIAPN@?$FLPCBangPointSystem?$FN?5?9?5Exceed?5Max@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0FB@EFBNKEEK@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@ ; `string'
PUBLIC	??_C@_0BE@NPBBFCEO@PCBangAddExperience?$AA@	; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_0BA@EPKHAMIK@PCBangResetHour?$AA@		; `string'
PUBLIC	??_C@_0BF@MGMAKGGP@PCBangResetDayOfWeek?$AA@	; `string'
PUBLIC	??_C@_0BO@ECDPNBAK@PCBangPointFeverMultipleValue?$AA@ ; `string'
PUBLIC	??_C@_0BI@NPAJILED@PCBangPointFeverEndHour?$AA@	; `string'
PUBLIC	??_C@_0BK@CLHDOELN@PCBangPointFeverStartHour?$AA@ ; `string'
PUBLIC	??_C@_0P@HABBLMLD@PCBangMaxPoint?$AA@		; `string'
PUBLIC	??_C@_0BP@PNIMHFPA@PCBangPointCommonRuleTimePoint?$AA@ ; `string'
PUBLIC	??_C@_0BK@GNCMODK@PCBangPointCommonRuleTime?$AA@ ; `string'
PUBLIC	??_C@_0BO@KJAFKACF@PCBangPointFirstRuleTimePoint?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JPIIKFLP@PCBangPointFirstRuleTime?$AA@ ; `string'
PUBLIC	??_C@_0BI@EGCJFFDF@PCBangPointRankingEvent?$AA@	; `string'
PUBLIC	??_C@_0BH@MBOBKADC@PCBangPointSystemLevel?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BE@KLAKJAFG@PCBangPointSystemOn?$AA@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@	; `string'
PUBLIC	??_C@_0CI@KDHNLGGF@?$FLPCBangPointSystem?$FN?5?9?5?$CFs?5file?5is@ ; `string'
PUBLIC	??_C@_0CF@CBPEGMGA@?$FLPCBangPointSystem?$FN?5?9?5Can?8t?5Open@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_lpszFileName$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Load@CPCBangPointSystem@@QAEHPAD@Z		; CPCBangPointSystem::Load
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp__GetLastError@0:PROC
EXTRN	_fopen:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DI@OHBCGPFP@?$FLPCBangPointSystem?$FN?5?9?5File?5load?5@
CONST	SEGMENT
??_C@_0DI@OHBCGPFP@?$FLPCBangPointSystem?$FN?5?9?5File?5load?5@ DB '[PCBa'
	DB	'ngPointSystem] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HNBKFLKH@?$FLPCBangPointSystem?$FN?5Loading?5Exce@
CONST	SEGMENT
??_C@_0DI@HNBKFLKH@?$FLPCBangPointSystem?$FN?5Loading?5Exce@ DB '[PCBangP'
	DB	'ointSystem] Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@ICJBIAPN@?$FLPCBangPointSystem?$FN?5?9?5Exceed?5Max@
CONST	SEGMENT
??_C@_0DB@ICJBIAPN@?$FLPCBangPointSystem?$FN?5?9?5Exceed?5Max@ DB '[PCBan'
	DB	'gPointSystem] - Exceed Max Item Count (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@EFBNKEEK@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@
CONST	SEGMENT
??_C@_0FB@EFBNKEEK@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@ DB '[PCBang'
	DB	'PointSystem][SetPCBangPointInfo] SystemOn:%d, Level:%d, Ranki'
	DB	'ngEventOn:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NPBBFCEO@PCBangAddExperience?$AA@
CONST	SEGMENT
??_C@_0BE@NPBBFCEO@PCBangAddExperience?$AA@ DB 'PCBangAddExperience', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EPKHAMIK@PCBangResetHour?$AA@
CONST	SEGMENT
??_C@_0BA@EPKHAMIK@PCBangResetHour?$AA@ DB 'PCBangResetHour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGMAKGGP@PCBangResetDayOfWeek?$AA@
CONST	SEGMENT
??_C@_0BF@MGMAKGGP@PCBangResetDayOfWeek?$AA@ DB 'PCBangResetDayOfWeek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECDPNBAK@PCBangPointFeverMultipleValue?$AA@
CONST	SEGMENT
??_C@_0BO@ECDPNBAK@PCBangPointFeverMultipleValue?$AA@ DB 'PCBangPointFeve'
	DB	'rMultipleValue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NPAJILED@PCBangPointFeverEndHour?$AA@
CONST	SEGMENT
??_C@_0BI@NPAJILED@PCBangPointFeverEndHour?$AA@ DB 'PCBangPointFeverEndHo'
	DB	'ur', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CLHDOELN@PCBangPointFeverStartHour?$AA@
CONST	SEGMENT
??_C@_0BK@CLHDOELN@PCBangPointFeverStartHour?$AA@ DB 'PCBangPointFeverSta'
	DB	'rtHour', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HABBLMLD@PCBangMaxPoint?$AA@
CONST	SEGMENT
??_C@_0P@HABBLMLD@PCBangMaxPoint?$AA@ DB 'PCBangMaxPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNIMHFPA@PCBangPointCommonRuleTimePoint?$AA@
CONST	SEGMENT
??_C@_0BP@PNIMHFPA@PCBangPointCommonRuleTimePoint?$AA@ DB 'PCBangPointCom'
	DB	'monRuleTimePoint', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GNCMODK@PCBangPointCommonRuleTime?$AA@
CONST	SEGMENT
??_C@_0BK@GNCMODK@PCBangPointCommonRuleTime?$AA@ DB 'PCBangPointCommonRul'
	DB	'eTime', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KJAFKACF@PCBangPointFirstRuleTimePoint?$AA@
CONST	SEGMENT
??_C@_0BO@KJAFKACF@PCBangPointFirstRuleTimePoint?$AA@ DB 'PCBangPointFirs'
	DB	'tRuleTimePoint', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JPIIKFLP@PCBangPointFirstRuleTime?$AA@
CONST	SEGMENT
??_C@_0BJ@JPIIKFLP@PCBangPointFirstRuleTime?$AA@ DB 'PCBangPointFirstRule'
	DB	'Time', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EGCJFFDF@PCBangPointRankingEvent?$AA@
CONST	SEGMENT
??_C@_0BI@EGCJFFDF@PCBangPointRankingEvent?$AA@ DB 'PCBangPointRankingEve'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MBOBKADC@PCBangPointSystemLevel?$AA@
CONST	SEGMENT
??_C@_0BH@MBOBKADC@PCBangPointSystemLevel?$AA@ DB 'PCBangPointSystemLevel'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KLAKJAFG@PCBangPointSystemOn?$AA@
CONST	SEGMENT
??_C@_0BE@KLAKJAFG@PCBangPointSystemOn?$AA@ DB 'PCBangPointSystemOn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@ DB 'commonserver.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KDHNLGGF@?$FLPCBangPointSystem?$FN?5?9?5?$CFs?5file?5is@
CONST	SEGMENT
??_C@_0CI@KDHNLGGF@?$FLPCBangPointSystem?$FN?5?9?5?$CFs?5file?5is@ DB '[P'
	DB	'CBangPointSystem] - %s file is Loaded', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CBPEGMGA@?$FLPCBangPointSystem?$FN?5?9?5Can?8t?5Open@
CONST	SEGMENT
??_C@_0CF@CBPEGMGA@?$FLPCBangPointSystem?$FN?5?9?5Can?8t?5Open@ DB '[PCBa'
	DB	'ngPointSystem] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Load@CPCBangPointSystem@@QAEHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Load@CPCBangPointSystem@@QAEHPAD@Z$0
__unwindtable$?Load@CPCBangPointSystem@@QAEHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Load@CPCBangPointSystem@@QAEHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?Load@CPCBangPointSystem@@QAEHPAD@Z$2
__ehfuncinfo$?Load@CPCBangPointSystem@@QAEHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Load@CPCBangPointSystem@@QAEHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Load@CPCBangPointSystem@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?Load@CPCBangPointSystem@@QAEHPAD@Z
_TEXT	SEGMENT
_iCondition$215457 = -320				; size = 2
_iKeepTime$215459 = -316				; size = 4
_iGetItemPercent$215461 = -312				; size = 2
_iAddExpPercent$215460 = -308				; size = 2
_iType$215453 = -304					; size = 4
_this$GSCopy$ = -300					; size = 4
_iItemCount$215451 = -296				; size = 4
_lpszFileName$GSCopy$ = -292				; size = 4
_iAbility$215458 = -285					; size = 1
tv426 = -284						; size = 4
tv424 = -284						; size = 4
tv416 = -284						; size = 4
tv414 = -284						; size = 4
tv408 = -284						; size = 4
tv406 = -284						; size = 4
tv400 = -284						; size = 4
tv398 = -284						; size = 4
tv391 = -284						; size = 4
tv389 = -284						; size = 4
tv352 = -284						; size = 4
tv349 = -284						; size = 4
tv340 = -284						; size = 4
tv160 = -284						; size = 4
tv131 = -284						; size = 4
tv95 = -284						; size = 4
tv429 = -278						; size = 2
tv419 = -278						; size = 2
tv411 = -278						; size = 2
tv403 = -278						; size = 2
tv395 = -278						; size = 2
tv351 = -278						; size = 2
tv137 = -278						; size = 2
tv86 = -278						; size = 2
_iStopExp$215462 = -277					; size = 1
_szTemp$ = -276						; size = 256
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?Load@CPCBangPointSystem@@QAEHPAD@Z PROC		; CPCBangPointSystem::Load, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CPCBangPointSystem@@QAEHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR _lpszFileName$[ebp]

; 276  : 	this->m_iPcBangIndex = 0;

  00034	33 db		 xor	 ebx, ebx
  00036	8b f9		 mov	 edi, ecx
  00038	89 bd d4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  0003e	89 b5 dc fe ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$[ebp], esi
  00044	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 277  : 
; 278  : 	if( lpszFileName == 0 || strcmp(lpszFileName, "") == 0 )

  00047	3b f3		 cmp	 esi, ebx
  00049	0f 84 33 06 00
	00		 je	 $LN14@Load
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00054	8b c6		 mov	 eax, esi
$LL26@Load:
  00056	8a 10		 mov	 dl, BYTE PTR [eax]
  00058	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0005a	75 1a		 jne	 SHORT $LN27@Load
  0005c	84 d2		 test	 dl, dl
  0005e	74 12		 je	 SHORT $LN28@Load
  00060	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00063	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00066	75 0e		 jne	 SHORT $LN27@Load
  00068	83 c0 02	 add	 eax, 2
  0006b	83 c1 02	 add	 ecx, 2
  0006e	84 d2		 test	 dl, dl
  00070	75 e4		 jne	 SHORT $LL26@Load
$LN28@Load:
  00072	33 c0		 xor	 eax, eax
  00074	eb 05		 jmp	 SHORT $LN29@Load
$LN27@Load:
  00076	1b c0		 sbb	 eax, eax
  00078	83 d8 ff	 sbb	 eax, -1
$LN29@Load:
  0007b	3b c3		 cmp	 eax, ebx
  0007d	0f 84 ff 05 00
	00		 je	 $LN14@Load

; 282  : 	}
; 283  : 
; 284  : 	DWORD dwGetLastError;
; 285  : 
; 286  : 	try
; 287  : 	{
; 288  : 		SMDFile = fopen(lpszFileName, "r");

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00088	56		 push	 esi
  00089	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0008c	e8 00 00 00 00	 call	 _fopen
  00091	83 c4 08	 add	 esp, 8
  00094	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 289  : 
; 290  : 		if( SMDFile == NULL )

  00099	3b c3		 cmp	 eax, ebx
  0009b	75 19		 jne	 SHORT $LN12@Load

; 291  : 		{
; 292  : 			dwGetLastError = GetLastError();

  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 293  : 			MsgBox("[PCBangPointSystem] - Can't Open %s ", lpszFileName);

  000a3	56		 push	 esi
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CBPEGMGA@?$FLPCBangPointSystem?$FN?5?9?5Can?8t?5Open@
  000a9	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000ae	83 c4 08	 add	 esp, 8

; 294  : 			return 0;

  000b1	e9 d9 05 00 00	 jmp	 $LN40@Load
$LN12@Load:

; 295  : 		}
; 296  : 
; 297  : 		this->Init();

  000b6	8b cf		 mov	 ecx, edi
  000b8	e8 00 00 00 00	 call	 ?Init@CPCBangPointSystem@@QAEXXZ ; CPCBangPointSystem::Init

; 298  : 
; 299  : 		int iItemCount = 0;

  000bd	89 9d d8 fe ff
	ff		 mov	 DWORD PTR _iItemCount$215451[ebp], ebx
$LL11@Load:

; 300  : 		SMDToken Token;
; 301  : 		int iType = -1;
; 302  : 		WORD iItemType = 0;
; 303  : 		WORD iItemIndex = 0;
; 304  : 		WORD iBuyPoint = 0;
; 305  : 		WORD iCondition = 0;
; 306  : 		BYTE iAbility = 0;
; 307  : 		int iKeepTime = 0;
; 308  : 		WORD iAddExpPercent = 0;
; 309  : 		WORD iGetItemPercent = 0;
; 310  : 		BYTE iStopExp = 0;
; 311  : 		PCBANG_LOAD_INFO* m_PcBangInfo;
; 312  : 
; 313  : 		while( true )
; 314  : 		{
; 315  : 			Token = GetToken();

  000c3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 316  : 
; 317  : 			if( Token == 2 )

  000c8	83 f8 02	 cmp	 eax, 2
  000cb	0f 85 68 02 00
	00		 jne	 $LN9@Load

; 399  : 
; 400  : 		fclose(SMDFile);

  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _fclose

; 401  : 		LogAddC(2, "[PCBangPointSystem] - %s file is Loaded", lpszFileName);

  000dc	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _lpszFileName$GSCopy$[ebp]
  000e2	51		 push	 ecx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KDHNLGGF@?$FLPCBangPointSystem?$FN?5?9?5?$CFs?5file?5is@
  000e8	6a 02		 push	 2
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000f0	83 c4 10	 add	 esp, 16			; 00000010H
  000f3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN21@Load:

; 408  : 
; 409  : 	this->m_bPointSystemOn = GetPrivateProfileInt("GameServerInfo", "PCBangPointSystemOn", TRUE, gDirPath.GetNewPath("commonserver.cfg"));

  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00104	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00109	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  0010f	50		 push	 eax
  00110	6a 01		 push	 1
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KLAKJAFG@PCBangPointSystemOn?$AA@
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0011c	ff d6		 call	 esi
  0011e	8b bd d4 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$[ebp]

; 410  : 	
; 411  : 	g_btPcBangPointSystemLevel = GetPrivateProfileInt("GameServerInfo", "PCBangPointSystemLevel", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0012e	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00131	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00136	50		 push	 eax
  00137	6a 01		 push	 1
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MBOBKADC@PCBangPointSystemLevel?$AA@
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00143	ff d6		 call	 esi

; 412  : 	
; 413  : 	this->m_bPointRankEvent = GetPrivateProfileInt("GameServerInfo", "PCBangPointRankingEvent", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0014a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0014f	a2 00 00 00 00	 mov	 BYTE PTR ?g_btPcBangPointSystemLevel@@3EA, al ; g_btPcBangPointSystemLevel
  00154	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00159	50		 push	 eax
  0015a	6a 01		 push	 1
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EGCJFFDF@PCBangPointRankingEvent?$AA@
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00166	ff d6		 call	 esi

; 414  : 
; 415  : 	g_sPCBangFirstRuleTime = GetPrivateProfileInt("GameServerInfo", "PCBangPointFirstRuleTime", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0016d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00172	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00175	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0017a	50		 push	 eax
  0017b	6a 01		 push	 1
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JPIIKFLP@PCBangPointFirstRuleTime?$AA@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00187	ff d6		 call	 esi

; 416  : 	g_sPCBangFirstRuleTimePoint = GetPrivateProfileInt("GameServerInfo", "PCBangPointFirstRuleTimePoint", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0018e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00193	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangFirstRuleTime@@3FA, ax ; g_sPCBangFirstRuleTime
  00199	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0019e	50		 push	 eax
  0019f	6a 01		 push	 1
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KJAFKACF@PCBangPointFirstRuleTimePoint?$AA@
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001ab	ff d6		 call	 esi

; 417  : 	g_sPCBangCommonRuleTime = GetPrivateProfileInt("GameServerInfo", "PCBangPointCommonRuleTime", 1, gDirPath.GetNewPath("commonserver.cfg"));

  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  001b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001b7	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangFirstRuleTimePoint@@3FA, ax ; g_sPCBangFirstRuleTimePoint
  001bd	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001c2	50		 push	 eax
  001c3	6a 01		 push	 1
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@GNCMODK@PCBangPointCommonRuleTime?$AA@
  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001cf	ff d6		 call	 esi

; 418  : 	g_sPCBangCommonRuleTimePoint = GetPrivateProfileInt("GameServerInfo", "PCBangPointCommonRuleTimePoint", 1, gDirPath.GetNewPath("commonserver.cfg"));

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  001d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001db	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangCommonRuleTime@@3FA, ax ; g_sPCBangCommonRuleTime
  001e1	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001e6	50		 push	 eax
  001e7	6a 01		 push	 1
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PNIMHFPA@PCBangPointCommonRuleTimePoint?$AA@
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  001f3	ff d6		 call	 esi

; 419  : 	g_sPCBangMaxPoint = GetPrivateProfileInt("GameServerInfo", "PCBangMaxPoint", 1, gDirPath.GetNewPath("commonserver.cfg"));

  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  001fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001ff	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangCommonRuleTimePoint@@3FA, ax ; g_sPCBangCommonRuleTimePoint
  00205	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0020a	50		 push	 eax
  0020b	6a 01		 push	 1
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HABBLMLD@PCBangMaxPoint?$AA@
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00217	ff d6		 call	 esi

; 420  : 	g_sPCBangFeverStartHour = GetPrivateProfileInt("GameServerInfo", "PCBangPointFeverStartHour", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00219	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0021e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00223	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangMaxPoint@@3FA, ax ; g_sPCBangMaxPoint
  00229	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0022e	50		 push	 eax
  0022f	6a 01		 push	 1
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CLHDOELN@PCBangPointFeverStartHour?$AA@
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0023b	ff d6		 call	 esi

; 421  : 	g_sPCBangFeverEndHour = GetPrivateProfileInt("GameServerInfo", "PCBangPointFeverEndHour", 1, gDirPath.GetNewPath("commonserver.cfg"));

  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00242	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00247	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangFeverStartHour@@3FA, ax ; g_sPCBangFeverStartHour
  0024d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00252	50		 push	 eax
  00253	6a 01		 push	 1
  00255	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NPAJILED@PCBangPointFeverEndHour?$AA@
  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0025f	ff d6		 call	 esi

; 422  : 	g_sPCBangFeverMultipleValue = GetPrivateProfileInt("GameServerInfo", "PCBangPointFeverMultipleValue", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00261	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  00266	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0026b	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangFeverEndHour@@3FA, ax ; g_sPCBangFeverEndHour
  00271	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00276	50		 push	 eax
  00277	6a 01		 push	 1
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@ECDPNBAK@PCBangPointFeverMultipleValue?$AA@
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00283	ff d6		 call	 esi

; 423  : 	g_sPCBangResetDayOfWeek = GetPrivateProfileInt("GameServerInfo", "PCBangResetDayOfWeek", 1, gDirPath.GetNewPath("commonserver.cfg"));

  00285	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  0028a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0028f	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangFeverMultipleValue@@3FA, ax ; g_sPCBangFeverMultipleValue
  00295	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0029a	50		 push	 eax
  0029b	6a 01		 push	 1
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MGMAKGGP@PCBangResetDayOfWeek?$AA@
  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  002a7	ff d6		 call	 esi

; 424  : 	g_sPCBangResetHour = GetPrivateProfileInt("GameServerInfo", "PCBangResetHour", 1, gDirPath.GetNewPath("commonserver.cfg"));

  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  002ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  002b3	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangResetDayOfWeek@@3FA, ax ; g_sPCBangResetDayOfWeek
  002b9	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  002be	50		 push	 eax
  002bf	6a 01		 push	 1
  002c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EPKHAMIK@PCBangResetHour?$AA@
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  002cb	ff d6		 call	 esi

; 425  : 		
; 426  : 	char szTemp[256];
; 427  : 	GetPrivateProfileString("GameServerInfo", "PCBangAddExperience", "1", szTemp, 5, gDirPath.GetNewPath("commonserver.cfg"));

  002cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg?$AA@
  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  002d7	66 a3 00 00 00
	00		 mov	 WORD PTR ?g_sPCBangResetHour@@3FA, ax ; g_sPCBangResetHour
  002dd	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  002e2	50		 push	 eax
  002e3	6a 05		 push	 5
  002e5	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  002eb	51		 push	 ecx
  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1?$AA@
  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NPBBFCEO@PCBangAddExperience?$AA@
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 428  : 	g_fPCBangAddExperience = atof(szTemp);

  00301	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00307	52		 push	 edx
  00308	e8 00 00 00 00	 call	 _atof
  0030d	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?g_fPCBangAddExperience@@3MA ; g_fPCBangAddExperience

; 429  : 
; 430  : 	LogAdd("[PCBangPointSystem][SetPCBangPointInfo] SystemOn:%d, Level:%d, RankingEventOn:%d", this->m_bPointSystemOn, g_btPcBangPointSystemLevel, this->m_bPointRankEvent); 

  00313	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00316	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?g_btPcBangPointSystemLevel@@3EA ; g_btPcBangPointSystemLevel
  0031d	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00320	50		 push	 eax
  00321	51		 push	 ecx
  00322	52		 push	 edx
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@EFBNKEEK@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@
  00328	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 431  : 
; 432  : 	return this->m_iPcBangIndex;

  0032e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00331	83 c4 14	 add	 esp, 20			; 00000014H
  00334	e9 58 03 00 00	 jmp	 $LN16@Load
$LN9@Load:

; 318  : 			{
; 319  : 				break;
; 320  : 			}
; 321  : 
; 322  : 			iType = (int)TokenNumber;

  00339	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0033f	e8 00 00 00 00	 call	 __ftol2_sse
  00344	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _iType$215453[ebp], eax
  0034a	8d 9b 00 00 00
	00		 npad	 6
$LL8@Load:

; 323  : 
; 324  : 			while( true )
; 325  : 			{
; 326  : 				if( iType == 0 )
; 327  : 				{
; 328  : 					iItemType = 0;
; 329  : 					iItemIndex = 0;
; 330  : 					iBuyPoint = 0;
; 331  : 					iCondition = 0;
; 332  : 					iAbility = 0;
; 333  : 					iKeepTime = 0;
; 334  : 					iAddExpPercent = 0;
; 335  : 					iGetItemPercent = 0;
; 336  : 					iStopExp = 0;
; 337  : 
; 338  : 					Token = GetToken();

  00350	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00355	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _iType$215453[ebp], 0

; 339  : 
; 340  : 					if( strcmp("end", TokenString) == 0 )

  0035c	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00361	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  00366	0f 85 e4 02 00
	00		 jne	 $LL34@Load
  0036c	8d 64 24 00	 npad	 4
$LL30@Load:
  00370	8a 10		 mov	 dl, BYTE PTR [eax]
  00372	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00374	75 1a		 jne	 SHORT $LN31@Load
  00376	84 d2		 test	 dl, dl
  00378	74 12		 je	 SHORT $LN32@Load
  0037a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0037d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00380	75 0e		 jne	 SHORT $LN31@Load
  00382	83 c0 02	 add	 eax, 2
  00385	83 c1 02	 add	 ecx, 2
  00388	84 d2		 test	 dl, dl
  0038a	75 e4		 jne	 SHORT $LL30@Load
$LN32@Load:
  0038c	33 c0		 xor	 eax, eax
  0038e	eb 05		 jmp	 SHORT $LN33@Load
$LN31@Load:
  00390	1b c0		 sbb	 eax, eax
  00392	83 d8 ff	 sbb	 eax, -1
$LN33@Load:
  00395	85 c0		 test	 eax, eax
  00397	0f 84 26 fd ff
	ff		 je	 $LL11@Load

; 341  : 					{
; 342  : 						break;
; 343  : 					}
; 344  : 
; 345  : 					iItemType = (WORD)TokenNumber;

  0039d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003a3	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv429[ebp]
  003a9	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv429[ebp]
  003b0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003b5	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv426[ebp], eax
  003bb	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv426[ebp]
  003c1	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv424[ebp]
  003c7	0f b7 b5 e4 fe
	ff ff		 movzx	 esi, WORD PTR tv424[ebp]
  003ce	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv429[ebp]

; 346  : 					Token = GetToken();

  003d4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 347  : 
; 348  : 					iItemIndex = (WORD)TokenNumber;

  003d9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  003df	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv419[ebp]
  003e5	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv419[ebp]
  003ec	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003f1	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv416[ebp], eax
  003f7	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv416[ebp]
  003fd	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv414[ebp]
  00403	66 8b 85 e4 fe
	ff ff		 mov	 ax, WORD PTR tv414[ebp]
  0040a	0f b7 f8	 movzx	 edi, ax
  0040d	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv419[ebp]

; 349  : 					Token = GetToken();

  00413	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 350  : 
; 351  : 					iBuyPoint = (WORD)TokenNumber;

  00418	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0041e	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv411[ebp]
  00424	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv411[ebp]
  0042b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00430	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv408[ebp], eax
  00436	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv408[ebp]
  0043c	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv406[ebp]
  00442	0f b7 9d e4 fe
	ff ff		 movzx	 ebx, WORD PTR tv406[ebp]
  00449	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv411[ebp]

; 352  : 					Token = GetToken();

  0044f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 353  : 
; 354  : 					iCondition = (WORD)TokenNumber;

  00454	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0045a	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv403[ebp]
  00460	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv403[ebp]
  00467	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0046c	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv400[ebp], eax
  00472	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv400[ebp]
  00478	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv398[ebp]
  0047e	0f b7 85 e4 fe
	ff ff		 movzx	 eax, WORD PTR tv398[ebp]
  00485	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _iCondition$215457[ebp], eax
  0048b	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv403[ebp]

; 355  : 					Token = GetToken();

  00491	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 356  : 
; 357  : 					iAbility = (BYTE)TokenNumber;

  00496	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0049c	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv395[ebp]
  004a2	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv395[ebp]
  004a9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004ae	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv391[ebp], eax
  004b4	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv391[ebp]
  004ba	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv389[ebp]
  004c0	8a 8d e4 fe ff
	ff		 mov	 cl, BYTE PTR tv389[ebp]
  004c6	88 8d e3 fe ff
	ff		 mov	 BYTE PTR _iAbility$215458[ebp], cl
  004cc	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv395[ebp]

; 358  : 					Token = GetToken();

  004d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 359  : 
; 360  : 					iKeepTime = (int)TokenNumber;

  004d7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004dd	e8 00 00 00 00	 call	 __ftol2_sse
  004e2	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _iKeepTime$215459[ebp], eax

; 361  : 					Token = GetToken();

  004e8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 362  : 
; 363  : 					iAddExpPercent = (WORD)TokenNumber;

  004ed	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004f3	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv351[ebp]
  004f9	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv351[ebp]
  00500	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00505	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv340[ebp], eax
  0050b	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv340[ebp]
  00511	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv160[ebp]
  00517	0f b7 85 e4 fe
	ff ff		 movzx	 eax, WORD PTR tv160[ebp]
  0051e	89 85 cc fe ff
	ff		 mov	 DWORD PTR _iAddExpPercent$215460[ebp], eax
  00524	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv351[ebp]

; 364  : 					Token = GetToken();

  0052a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 365  : 
; 366  : 					iGetItemPercent = (WORD)TokenNumber;

  0052f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00535	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv137[ebp]
  0053b	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv137[ebp]
  00542	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00547	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv131[ebp], eax
  0054d	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv131[ebp]
  00553	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv95[ebp]
  00559	0f b7 95 e4 fe
	ff ff		 movzx	 edx, WORD PTR tv95[ebp]
  00560	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _iGetItemPercent$215461[ebp], edx
  00566	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv137[ebp]

; 367  : 					Token = GetToken();

  0056c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 368  : 
; 369  : 					iStopExp = (BYTE)TokenNumber;

  00571	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00577	d9 bd ea fe ff
	ff		 fnstcw	 WORD PTR tv86[ebp]
  0057d	0f b7 85 ea fe
	ff ff		 movzx	 eax, WORD PTR tv86[ebp]

; 370  : 					
; 371  : 					if( iItemCount < 0 || iItemCount > MAX_PCBANG_ITEM_COUNT )

  00584	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _iItemCount$215451[ebp]
  0058a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0058f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv352[ebp], eax
  00595	d9 ad e4 fe ff
	ff		 fldcw	 WORD PTR tv352[ebp]
  0059b	db 9d e4 fe ff
	ff		 fistp	 DWORD PTR tv349[ebp]
  005a1	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR tv349[ebp]
  005a7	d9 ad ea fe ff
	ff		 fldcw	 WORD PTR tv86[ebp]
  005ad	88 85 eb fe ff
	ff		 mov	 BYTE PTR _iStopExp$215462[ebp], al
  005b3	83 f9 06	 cmp	 ecx, 6
  005b6	77 64		 ja	 SHORT $LN3@Load

; 375  : 					}
; 376  : 
; 377  : 					m_PcBangInfo = (PCBANG_LOAD_INFO*)&this->m_PcBangSystem[iItemCount].Index;

  005b8	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  005be	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  005c1	8d 44 d0 14	 lea	 eax, DWORD PTR [eax+edx*8+20]

; 378  : 					m_PcBangInfo->Index = (iItemType << 9) + iItemIndex;

  005c5	8b d6		 mov	 edx, esi
  005c7	c1 e2 09	 shl	 edx, 9
  005ca	03 d7		 add	 edx, edi
  005cc	89 10		 mov	 DWORD PTR [eax], edx

; 379  : 					m_PcBangInfo->BuyPoint = iBuyPoint;
; 380  : 					m_PcBangInfo->Condition = iCondition;

  005ce	0f b7 95 c0 fe
	ff ff		 movzx	 edx, WORD PTR _iCondition$215457[ebp]
  005d5	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 381  : 					m_PcBangInfo->Ability = iAbility;

  005d9	0f b6 95 e3 fe
	ff ff		 movzx	 edx, BYTE PTR _iAbility$215458[ebp]
  005e0	88 50 08	 mov	 BYTE PTR [eax+8], dl

; 382  : 					m_PcBangInfo->KeepTime = iKeepTime;

  005e3	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _iKeepTime$215459[ebp]
  005e9	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 383  : 					m_PcBangInfo->AddExpPercent = iAddExpPercent;

  005ec	0f b7 95 cc fe
	ff ff		 movzx	 edx, WORD PTR _iAddExpPercent$215460[ebp]
  005f3	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 384  : 					m_PcBangInfo->GetItemPercent = iGetItemPercent;

  005f7	0f b7 95 c8 fe
	ff ff		 movzx	 edx, WORD PTR _iGetItemPercent$215461[ebp]
  005fe	66 89 50 12	 mov	 WORD PTR [eax+18], dx

; 385  : 					m_PcBangInfo->StopExp = iStopExp;

  00602	0f b6 95 eb fe
	ff ff		 movzx	 edx, BYTE PTR _iStopExp$215462[ebp]

; 386  : 					iItemCount++;

  00609	41		 inc	 ecx
  0060a	66 89 58 04	 mov	 WORD PTR [eax+4], bx
  0060e	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00611	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _iItemCount$215451[ebp], ecx

; 387  : 				}
; 388  : 				else

  00617	e9 34 fd ff ff	 jmp	 $LL8@Load
$LN3@Load:

; 372  : 					{
; 373  : 						MsgBox("[PCBangPointSystem] - Exceed Max Item Count (%d)", iItemCount);

  0061c	51		 push	 ecx
  0061d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@ICJBIAPN@?$FLPCBangPointSystem?$FN?5?9?5Exceed?5Max@
  00622	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00627	83 c4 08	 add	 esp, 8

; 374  : 						break;

  0062a	e9 94 fa ff ff	 jmp	 $LL11@Load
__catch$?Load@CPCBangPointSystem@@QAEHPAD@Z$0:

; 402  : 	}
; 403  : 	
; 404  : 	catch(...)
; 405  : 	{
; 406  : 		MsgBox("[PCBangPointSystem] Loading Exception Error (%s) File. ", lpszFileName);

  0062f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _lpszFileName$GSCopy$[ebp]
  00635	50		 push	 eax
  00636	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNBKFLKH@?$FLPCBangPointSystem?$FN?5Loading?5Exce@
  0063b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00640	83 c4 08	 add	 esp, 8

; 407  : 	}

  00643	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0064a	b8 00 00 00 00	 mov	 eax, $LN21@Load
  0064f	c3		 ret	 0
$LL34@Load:

; 389  : 				{
; 390  : 					Token = GetToken();
; 391  : 
; 392  : 					if( strcmp("end", TokenString) == 0 )

  00650	8a 10		 mov	 dl, BYTE PTR [eax]
  00652	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00654	75 1a		 jne	 SHORT $LN35@Load
  00656	84 d2		 test	 dl, dl
  00658	74 12		 je	 SHORT $LN36@Load
  0065a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0065d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00660	75 0e		 jne	 SHORT $LN35@Load
  00662	83 c0 02	 add	 eax, 2
  00665	83 c1 02	 add	 ecx, 2
  00668	84 d2		 test	 dl, dl
  0066a	75 e4		 jne	 SHORT $LL34@Load
$LN36@Load:
  0066c	33 c0		 xor	 eax, eax
  0066e	eb 05		 jmp	 SHORT $LN37@Load
$LN35@Load:
  00670	1b c0		 sbb	 eax, eax
  00672	83 d8 ff	 sbb	 eax, -1
$LN37@Load:
  00675	85 c0		 test	 eax, eax
  00677	0f 85 d3 fc ff
	ff		 jne	 $LL8@Load

; 393  : 					{
; 394  : 						break;
; 395  : 					}
; 396  : 				}
; 397  : 			}
; 398  : 		}

  0067d	e9 41 fa ff ff	 jmp	 $LL11@Load
$LN14@Load:

; 279  : 	{
; 280  : 		MsgBox("[PCBangPointSystem] - File load error : File Name Error");

  00682	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OHBCGPFP@?$FLPCBangPointSystem?$FN?5?9?5File?5load?5@
  00687	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0068c	83 c4 04	 add	 esp, 4
$LN40@Load:

; 281  : 		return 0;

  0068f	33 c0		 xor	 eax, eax
$LN16@Load:

; 433  : }

  00691	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00694	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0069b	59		 pop	 ecx
  0069c	5f		 pop	 edi
  0069d	5e		 pop	 esi
  0069e	5b		 pop	 ebx
  0069f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006a2	33 cd		 xor	 ecx, ebp
  006a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a9	8b e5		 mov	 esp, ebp
  006ab	5d		 pop	 ebp
  006ac	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Load@CPCBangPointSystem@@QAEHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a bc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-324]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CPCBangPointSystem@@QAEHPAD@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CPCBangPointSystem@@QAEHPAD@Z ENDP		; CPCBangPointSystem::Load
PUBLIC	?CheckPcBangRuleTime@CPCBangPointSystem@@QAEHH@Z ; CPCBangPointSystem::CheckPcBangRuleTime
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?CheckPcBangRuleTime@CPCBangPointSystem@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CheckPcBangRuleTime@CPCBangPointSystem@@QAEHH@Z PROC	; CPCBangPointSystem::CheckPcBangRuleTime, COMDAT
; _this$ = ecx

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 437  : 	LPOBJ lpObj = &gObj[aIndex];

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 438  : 
; 439  : 	if (lpObj->m_iPcBangConnectionType == 1)

  00006	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00012	33 c9		 xor	 ecx, ecx
  00014	83 bc 10 1c 20
	00 00 01	 cmp	 DWORD PTR [eax+edx+8220], 1
  0001c	0f 94 c1	 sete	 cl
  0001f	8b c1		 mov	 eax, ecx

; 440  : 	{
; 441  : 		return TRUE;
; 442  : 	}
; 443  : 
; 444  : 	return FALSE;
; 445  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?CheckPcBangRuleTime@CPCBangPointSystem@@QAEHH@Z ENDP	; CPCBangPointSystem::CheckPcBangRuleTime
_TEXT	ENDS
PUBLIC	?GetItemIndex@CPCBangPointSystem@@QAEHH@Z	; CPCBangPointSystem::GetItemIndex
; Function compile flags: /Ogtp
;	COMDAT ?GetItemIndex@CPCBangPointSystem@@QAEHH@Z
_TEXT	SEGMENT
_iItemIndex$ = 8					; size = 4
?GetItemIndex@CPCBangPointSystem@@QAEHH@Z PROC		; CPCBangPointSystem::GetItemIndex, COMDAT
; _this$ = ecx

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  : 	PCBANG_LOAD_INFO* m_PcBangInfo = this->m_PcBangSystem;
; 450  : 
; 451  : 	for (int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++)

  00003	8b 55 08	 mov	 edx, DWORD PTR _iItemIndex$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	83 c1 14	 add	 ecx, 20			; 00000014H
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@GetItemInd:

; 452  : 	{
; 453  : 		if (this->m_PcBangSystem[n].Index == iItemIndex)

  00010	39 11		 cmp	 DWORD PTR [ecx], edx
  00012	74 0f		 je	 SHORT $LN8@GetItemInd

; 449  : 	PCBANG_LOAD_INFO* m_PcBangInfo = this->m_PcBangSystem;
; 450  : 
; 451  : 	for (int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++)

  00014	40		 inc	 eax
  00015	83 c1 18	 add	 ecx, 24			; 00000018H
  00018	83 f8 06	 cmp	 eax, 6
  0001b	7c f3		 jl	 SHORT $LL4@GetItemInd

; 456  : 		}
; 457  : 	}
; 458  : 
; 459  : 	return 0;

  0001d	33 c0		 xor	 eax, eax

; 460  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN8@GetItemInd:

; 454  : 		{
; 455  : 			return 1;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 460  : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?GetItemIndex@CPCBangPointSystem@@QAEHH@Z ENDP		; CPCBangPointSystem::GetItemIndex
_TEXT	ENDS
PUBLIC	?ShopMapCheck@CPCBangPointSystem@@QAEHEFF@Z	; CPCBangPointSystem::ShopMapCheck
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
; Function compile flags: /Ogtp
;	COMDAT ?ShopMapCheck@CPCBangPointSystem@@QAEHEFF@Z
_TEXT	SEGMENT
_MapNumber$ = 8						; size = 1
_X$ = 12						; size = 2
_Y$ = 16						; size = 2
?ShopMapCheck@CPCBangPointSystem@@QAEHEFF@Z PROC	; CPCBangPointSystem::ShopMapCheck, COMDAT
; _this$ = ecx

; 463  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 464  : 	if( BC_MAP_RANGE(MapNumber) ||
; 465  : 		CC_MAP_RANGE(MapNumber) ||
; 466  : 		DS_MAP_RANGE(MapNumber) ||
; 467  : 		IT_MAP_RANGE(MapNumber) ||
; 468  : 		MapNumber == MAP_INDEX_KANTURU_BOSS )

  00003	8a 45 08	 mov	 al, BYTE PTR _MapNumber$[ebp]
  00006	3c 34		 cmp	 al, 52			; 00000034H
  00008	74 71		 je	 SHORT $LN2@ShopMapChe
  0000a	3c 0b		 cmp	 al, 11			; 0000000bH
  0000c	72 0c		 jb	 SHORT $LN18@ShopMapChe
  0000e	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00013	3a c8		 cmp	 cl, al
  00015	1b c9		 sbb	 ecx, ecx
  00017	41		 inc	 ecx
  00018	75 61		 jne	 SHORT $LN2@ShopMapChe
$LN18@ShopMapChe:
  0001a	3c 35		 cmp	 al, 53			; 00000035H
  0001c	74 5d		 je	 SHORT $LN2@ShopMapChe
  0001e	3c 12		 cmp	 al, 18			; 00000012H
  00020	72 09		 jb	 SHORT $LN19@ShopMapChe
  00022	b2 17		 mov	 dl, 23			; 00000017H
  00024	3a d0		 cmp	 dl, al
  00026	1b c9		 sbb	 ecx, ecx
  00028	41		 inc	 ecx
  00029	75 50		 jne	 SHORT $LN2@ShopMapChe
$LN19@ShopMapChe:
  0002b	3c 09		 cmp	 al, 9
  0002d	74 4c		 je	 SHORT $LN2@ShopMapChe
  0002f	33 c9		 xor	 ecx, ecx
  00031	3c 20		 cmp	 al, 32			; 00000020H
  00033	0f 94 c1	 sete	 cl
  00036	85 c9		 test	 ecx, ecx
  00038	75 41		 jne	 SHORT $LN2@ShopMapChe
  0003a	3c 2d		 cmp	 al, 45			; 0000002dH
  0003c	72 0c		 jb	 SHORT $LN20@ShopMapChe
  0003e	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00043	3a c8		 cmp	 cl, al
  00045	1b c9		 sbb	 ecx, ecx
  00047	41		 inc	 ecx
  00048	75 31		 jne	 SHORT $LN2@ShopMapChe
$LN20@ShopMapChe:
  0004a	3c 27		 cmp	 al, 39			; 00000027H
  0004c	74 2d		 je	 SHORT $LN2@ShopMapChe

; 471  : 	}
; 472  : 
; 473  : 	BYTE attr = MapC[MapNumber].GetAttr(X, Y);
; 474  : 
; 475  : 	if( (attr &1) == 1 )

  0004e	0f bf 55 10	 movsx	 edx, WORD PTR _Y$[ebp]
  00052	0f bf 4d 0c	 movsx	 ecx, WORD PTR _X$[ebp]
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	0f b6 c8	 movzx	 ecx, al
  0005b	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00061	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00067	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0006c	24 01		 and	 al, 1
  0006e	33 d2		 xor	 edx, edx
  00070	3c 01		 cmp	 al, 1
  00072	0f 94 c2	 sete	 dl
  00075	8b c2		 mov	 eax, edx

; 476  : 	{
; 477  : 		return 1;
; 478  : 	}
; 479  : 
; 480  : 	return 0;
; 481  : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
$LN2@ShopMapChe:

; 469  : 	{
; 470  : 		return 0;

  0007b	33 c0		 xor	 eax, eax

; 476  : 	{
; 477  : 		return 1;
; 478  : 	}
; 479  : 
; 480  : 	return 0;
; 481  : }

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
?ShopMapCheck@CPCBangPointSystem@@QAEHEFF@Z ENDP	; CPCBangPointSystem::ShopMapCheck
_TEXT	ENDS
PUBLIC	??_C@_0CM@BGBOIGIB@?$FLPCBangPointSystem?$FN?$FLUser?5Connect@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?EGUserConnectTest@CPCBangPointSystem@@QAEXH@Z	; CPCBangPointSystem::EGUserConnectTest
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
;	COMDAT ??_C@_0CM@BGBOIGIB@?$FLPCBangPointSystem?$FN?$FLUser?5Connect@
CONST	SEGMENT
??_C@_0CM@BGBOIGIB@?$FLPCBangPointSystem?$FN?$FLUser?5Connect@ DB '[PCBan'
	DB	'gPointSystem][User Connect] [%s] - %s', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?EGUserConnectTest@CPCBangPointSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$215615 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?EGUserConnectTest@CPCBangPointSystem@@QAEXH@Z PROC	; CPCBangPointSystem::EGUserConnectTest, COMDAT
; _this$ = ecx

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 614  : 	if(gObj[aIndex].m_iPcBangConnectionType == 1) //LocalServer

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001a	8b f7		 mov	 esi, edi
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	83 bc 06 1c 20
	00 00 01	 cmp	 DWORD PTR [esi+eax+8220], 1
  0002a	75 72		 jne	 SHORT $LN1@EGUserConn

; 615  : 	{
; 616  : 		PMSG_REQ_REG_PC_POINT pMsg = {0};

  0002c	33 c0		 xor	 eax, eax

; 617  : 
; 618  : 		PHeadSetB((LPBYTE)&pMsg, 0x23, sizeof(pMsg));

  0002e	6a 12		 push	 18			; 00000012H
  00030	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$215615[ebp]
  00033	6a 23		 push	 35			; 00000023H
  00035	51		 push	 ecx
  00036	c6 45 e8 00	 mov	 BYTE PTR _pMsg$215615[ebp], 0
  0003a	89 45 e9	 mov	 DWORD PTR _pMsg$215615[ebp+1], eax
  0003d	89 45 ed	 mov	 DWORD PTR _pMsg$215615[ebp+5], eax
  00040	89 45 f1	 mov	 DWORD PTR _pMsg$215615[ebp+9], eax
  00043	89 45 f5	 mov	 DWORD PTR _pMsg$215615[ebp+13], eax
  00046	88 45 f9	 mov	 BYTE PTR _pMsg$215615[ebp+17], al
  00049	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 619  : 
; 620  : 		pMsg.aIndex = aIndex;
; 621  : 
; 622  : 		memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	66 89 7d ec	 mov	 WORD PTR _pMsg$215615[ebp+4], di
  00057	8b 54 06 6c	 mov	 edx, DWORD PTR [esi+eax+108]
  0005b	89 55 ef	 mov	 DWORD PTR _pMsg$215615[ebp+7], edx
  0005e	8b 4c 06 70	 mov	 ecx, DWORD PTR [esi+eax+112]
  00062	89 4d f3	 mov	 DWORD PTR _pMsg$215615[ebp+11], ecx
  00065	66 8b 54 06 74	 mov	 dx, WORD PTR [esi+eax+116]

; 623  : 
; 624  : 		pMsg.btResult = 0;
; 625  : 
; 626  : 		pMsg.AccountID[10] = '\0';
; 627  : 
; 628  : 		DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  0006a	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$215615[ebp]
  0006d	6a 12		 push	 18			; 00000012H
  0006f	50		 push	 eax
  00070	66 89 55 f7	 mov	 WORD PTR _pMsg$215615[ebp+15], dx
  00074	c6 45 ee 00	 mov	 BYTE PTR _pMsg$215615[ebp+6], 0
  00078	c6 45 f9 00	 mov	 BYTE PTR _pMsg$215615[ebp+17], 0
  0007c	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 629  : 
; 630  : 		LogAdd("[PCBangPointSystem][User Connect] [%s] - %s", 
; 631  : 			gObj[aIndex].AccountID, gObj[aIndex].Ip_addr);

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	8d 4c 06 18	 lea	 ecx, DWORD PTR [esi+eax+24]
  0008a	51		 push	 ecx
  0008b	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0008f	52		 push	 edx
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGBOIGIB@?$FLPCBangPointSystem?$FN?$FLUser?5Connect@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0009b	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@EGUserConn:

; 632  : 	}
; 633  : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	5f		 pop	 edi
  000a2	33 cd		 xor	 ecx, ebp
  000a4	5e		 pop	 esi
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
?EGUserConnectTest@CPCBangPointSystem@@QAEXH@Z ENDP	; CPCBangPointSystem::EGUserConnectTest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo
; Function compile flags: /Ogtp
;	COMDAT ?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXH@Z PROC ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo, COMDAT
; _this$ = ecx

; 655  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 656  : 	PMSG_ANS_REG_PC_POINT pMsg = {0};

  00010	33 c0		 xor	 eax, eax
  00012	56		 push	 esi
  00013	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 657  : 
; 658  : 	PHeadSetB((LPBYTE)&pMsg, 0x24, sizeof(pMsg));

  00016	6a 1c		 push	 28			; 0000001cH
  00018	89 45 e1	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  0001b	89 45 e5	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  0001e	89 45 e9	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  00021	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+13], eax
  00024	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+17], eax
  00027	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+21], eax
  0002a	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+25], ax
  0002e	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+27], al
  00031	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	6a 24		 push	 36			; 00000024H
  00036	50		 push	 eax
  00037	c6 45 e0 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 659  : 
; 660  : 	pMsg.aIndex = aIndex;
; 661  : 
; 662  : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	66 89 75 e4	 mov	 WORD PTR _pMsg$[ebp+4], si
  0004a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00050	8b 54 0e 6c	 mov	 edx, DWORD PTR [esi+ecx+108]
  00054	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00057	89 55 e6	 mov	 DWORD PTR _pMsg$[ebp+6], edx
  0005a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0005d	89 4d ea	 mov	 DWORD PTR _pMsg$[ebp+10], ecx
  00060	66 8b 50 74	 mov	 dx, WORD PTR [eax+116]
  00064	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+14], dx

; 663  : 
; 664  : 	pMsg.AccountID[10] = '\0';

  00068	66 c7 45 f0 00
	00		 mov	 WORD PTR _pMsg$[ebp+16], 0

; 665  : 
; 666  : 	pMsg.btShopItemBuy = 0;
; 667  : 
; 668  : 	pMsg.sPoint = gObj[aIndex].m_PcBangPointSystem.m_iPcBangAccumulatedPoint;

  0006e	66 8b 80 2c 20
	00 00		 mov	 ax, WORD PTR [eax+8236]

; 669  : 
; 670  : 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00075	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00078	6a 1c		 push	 28			; 0000001cH
  0007a	51		 push	 ecx
  0007b	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+18], ax
  0007f	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 671  : }

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	83 c4 14	 add	 esp, 20			; 00000014H
  0008a	33 cd		 xor	 ecx, ebp
  0008c	5e		 pop	 esi
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXH@Z ENDP ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXHF@Z ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo
; Function compile flags: /Ogtp
;	COMDAT ?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXHF@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_sPCBangPoint$ = 12					; size = 2
?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXHF@Z PROC ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo, COMDAT
; _this$ = ecx

; 690  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 691  : 	if(this->m_bPointRankEvent == FALSE)

  00010	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	74 6b		 je	 SHORT $LN2@EGReqUpdat

; 692  : 	{
; 693  : 		return;
; 694  : 	}
; 695  : 
; 696  : 	PMSG_REQ_UPDATE_PCBANG_USER_POINT pMsg = {0};

  0001a	33 c0		 xor	 eax, eax

; 697  : 	
; 698  : 	PHeadSetB((LPBYTE)&pMsg, 0x25, sizeof(pMsg));

  0001c	6a 14		 push	 20			; 00000014H
  0001e	89 45 e9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00021	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  00024	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  00027	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+13], eax
  0002a	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+17], ax
  0002e	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+19], al
  00031	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	6a 25		 push	 37			; 00000025H
  00036	50		 push	 eax
  00037	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 699  : 
; 700  : 	pMsg.aIndex = aIndex;
; 701  : 
; 702  : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	66 89 75 ec	 mov	 WORD PTR _pMsg$[ebp+4], si
  0004a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00050	8b 54 0e 6c	 mov	 edx, DWORD PTR [esi+ecx+108]
  00054	8d 44 0e 6c	 lea	 eax, DWORD PTR [esi+ecx+108]
  00058	89 55 ee	 mov	 DWORD PTR _pMsg$[ebp+6], edx
  0005b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005e	89 4d f2	 mov	 DWORD PTR _pMsg$[ebp+10], ecx
  00061	66 8b 50 08	 mov	 dx, WORD PTR [eax+8]

; 703  : 
; 704  : 	pMsg.AccountID[10] = '\0';
; 705  : 
; 706  : 	pMsg.btResult = 0;
; 707  : 
; 708  : 	pMsg.sPoint = sPCBangPoint;

  00065	66 8b 45 0c	 mov	 ax, WORD PTR _sPCBangPoint$[ebp]

; 709  : 
; 710  : 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00069	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0006c	6a 14		 push	 20			; 00000014H
  0006e	51		 push	 ecx
  0006f	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+14], dx
  00073	66 c7 45 f8 00
	00		 mov	 WORD PTR _pMsg$[ebp+16], 0
  00079	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+18], ax
  0007d	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00082	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@EGReqUpdat:

; 711  : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	5e		 pop	 esi
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXHF@Z ENDP ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::GCSendPcBangUserPoint
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z PROC	; CPCBangPointSystem::GCSendPcBangUserPoint, COMDAT
; _this$ = ecx

; 714  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 715  : 	PMSG_ANS_PCBANG_POINT_INFO pMsg = {0};

  00014	33 c0		 xor	 eax, eax

; 716  : 
; 717  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD0, 0x04, sizeof(pMsg));

  00016	6a 0a		 push	 10			; 0000000aH
  00018	6a 04		 push	 4
  0001a	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp], al
  0001d	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00020	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  00023	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+9], al
  00026	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	68 d0 00 00 00	 push	 208			; 000000d0H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 718  : 
; 719  : 	pMsg.m_sPoint = gObj[aIndex].m_PcBangPointSystem.m_iPcBangAccumulatedPoint;
; 720  : 	pMsg.m_sMaxPoint = g_sPCBangMaxPoint;

  00034	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_sPCBangMaxPoint@@3FA ; g_sPCBangMaxPoint
  0003b	8b c6		 mov	 eax, esi
  0003d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00043	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 721  : 	pMsg.m_btType = gObj[aIndex].m_iPcBangConnectionType;
; 722  : 
; 723  : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00049	6a 0a		 push	 10			; 0000000aH
  0004b	66 8b 88 2c 20
	00 00		 mov	 cx, WORD PTR [eax+8236]
  00052	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+4], cx
  00056	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00059	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  0005d	8a 80 1c 20 00
	00		 mov	 al, BYTE PTR [eax+8220]
  00063	51		 push	 ecx
  00064	56		 push	 esi
  00065	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+8], al
  00068	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 724  : }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	83 c4 1c	 add	 esp, 28			; 0000001cH
  00073	33 cd		 xor	 ecx, ebp
  00075	5e		 pop	 esi
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z ENDP	; CPCBangPointSystem::GCSendPcBangUserPoint
_TEXT	ENDS
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ ; `string'
PUBLIC	??_C@_0BG@DBBIFFBK@PCBangPointSystem?4cpp?$AA@	; `string'
PUBLIC	??_C@_0DK@HCKMKNMO@?$FLANTI?9HACK?$FN?$FLPCBangPointShopOpen?$FN@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?PCBangShopOpen@CPCBangPointSystem@@QAEXH@Z	; CPCBangPointSystem::PCBangShopOpen
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	?gObjFixInventoryPointer@@YA_NH@Z:PROC		; gObjFixInventoryPointer
EXTRN	?ShopC@@3PAVCShop@@A:BYTE			; ShopC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ DB '['
	DB	'Fix Inv.Ptr] False Location - %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DBBIFFBK@PCBangPointSystem?4cpp?$AA@
CONST	SEGMENT
??_C@_0BG@DBBIFFBK@PCBangPointSystem?4cpp?$AA@ DB 'PCBangPointSystem.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HCKMKNMO@?$FLANTI?9HACK?$FN?$FLPCBangPointShopOpen?$FN@
CONST	SEGMENT
??_C@_0DK@HCKMKNMO@?$FLANTI?9HACK?$FN?$FLPCBangPointShopOpen?$FN@ DB '[AN'
	DB	'TI-HACK][PCBangPointShopOpen] Couldn''t Open.. (%s)(%s)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PCBangShopOpen@CPCBangPointSystem@@QAEXH@Z
_TEXT	SEGMENT
_pShopItem$ = -1044					; size = 6
_pMsg$ = -1036						; size = 5
_SendByte$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?PCBangShopOpen@CPCBangPointSystem@@QAEXH@Z PROC	; CPCBangPointSystem::PCBangShopOpen, COMDAT
; _this$ = ecx

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi

; 728  : 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b f3		 mov	 esi, ebx
  0001a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00020	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	57		 push	 edi

; 729  : 
; 730  : 	if( lpObj->CloseType != -1 )

  00027	80 7e 0b ff	 cmp	 BYTE PTR [esi+11], -1
  0002b	8b f9		 mov	 edi, ecx
  0002d	0f 85 1b 02 00
	00		 jne	 $LN8@PCBangShop

; 731  : 	{
; 732  : 		return;
; 733  : 	}
; 734  : 
; 735  : 	if( gObjIsConnectedGP(aIndex) == 0 )

  00033	53		 push	 ebx
  00034	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00039	83 c4 04	 add	 esp, 4
  0003c	85 c0		 test	 eax, eax
  0003e	75 29		 jne	 SHORT $LN6@PCBangShop

; 736  : 	{
; 737  : 		LogAddTD("[ANTI-HACK][PCBangPointShopOpen] Couldn't Open.. (%s)(%s)", lpObj->AccountID, lpObj->Name);

  00040	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00043	50		 push	 eax
  00044	83 c6 6c	 add	 esi, 108		; 0000006cH
  00047	56		 push	 esi
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HCKMKNMO@?$FLANTI?9HACK?$FN?$FLPCBangPointShopOpen?$FN@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx

; 800  : } 

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
$LN6@PCBangShop:

; 738  : 		return;
; 739  : 	}
; 740  : 
; 741  : 	PMSG_SHOP_INFO pMsg = {0};
; 742  : 
; 743  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD0, 0x06, sizeof(pMsg));

  00069	6a 05		 push	 5
  0006b	6a 06		 push	 6
  0006d	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00073	68 d0 00 00 00	 push	 208			; 000000d0H
  00078	51		 push	 ecx
  00079	c6 85 f4 fb ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp], 0
  00080	c7 85 f5 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _pMsg$[ebp+1], 0
  0008a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 744  : 	pMsg.Result = 0;

  0008f	c6 85 f8 fb ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 745  : 
; 746  : 	if( this->ShopMapCheck(lpObj->MapNumber, lpObj->X, lpObj->Y) == 0 )

  00096	0f b7 96 46 01
	00 00		 movzx	 edx, WORD PTR [esi+326]
  0009d	0f b7 86 44 01
	00 00		 movzx	 eax, WORD PTR [esi+324]
  000a4	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000ab	83 c4 10	 add	 esp, 16			; 00000010H
  000ae	52		 push	 edx
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	8b cf		 mov	 ecx, edi
  000b3	e8 00 00 00 00	 call	 ?ShopMapCheck@CPCBangPointSystem@@QAEHEFF@Z ; CPCBangPointSystem::ShopMapCheck
  000b8	85 c0		 test	 eax, eax
  000ba	75 32		 jne	 SHORT $LN5@PCBangShop

; 747  : 	{
; 748  : 		pMsg.Result = 1;

  000bc	c6 85 f8 fb ff
	ff 01		 mov	 BYTE PTR _pMsg$[ebp+4], 1
$LN10@PCBangShop:

; 749  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000c3	0f b6 95 f5 fb
	ff ff		 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000ca	52		 push	 edx
  000cb	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000d1	50		 push	 eax
$LN11@PCBangShop:
  000d2	53		 push	 ebx
  000d3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 800  : } 

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 cd		 xor	 ecx, ebp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 04 00	 ret	 4
$LN5@PCBangShop:

; 750  : 		return;
; 751  : 	}
; 752  : 
; 753  : 	if( ShopC[this->m_btPcBangShopNumber].ItemCount < 1 )

  000ee	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  000f2	69 c9 9c 6f 00
	00		 imul	 ecx, 28572		; 00006f9cH
  000f8	83 b9 7c 00 00
	00 01		 cmp	 DWORD PTR ?ShopC@@3PAVCShop@@A[ecx+124], 1
  000ff	7d 09		 jge	 SHORT $LN4@PCBangShop

; 754  : 	{
; 755  : 		pMsg.Result = 2;

  00101	c6 85 f8 fb ff
	ff 02		 mov	 BYTE PTR _pMsg$[ebp+4], 2

; 756  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 757  : 		return;

  00108	eb b9		 jmp	 SHORT $LN10@PCBangShop
$LN4@PCBangShop:

; 758  : 	}
; 759  : 
; 760  : 	if( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type != 18 )

  0010a	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  00110	b1 03		 mov	 cl, 3
  00112	84 c1		 test	 al, cl
  00114	76 23		 jbe	 SHORT $LN3@PCBangShop
  00116	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0011b	3d 80 04 00 00	 cmp	 eax, 1152		; 00000480H
  00120	74 17		 je	 SHORT $LN3@PCBangShop

; 761  : 	{
; 762  : 		pMsg.Result = 3;

  00122	88 8d f8 fb ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 763  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00128	0f b6 8d f5 fb
	ff ff		 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0012f	51		 push	 ecx
  00130	8d 95 f4 fb ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00136	52		 push	 edx

; 764  : 		return;

  00137	eb 99		 jmp	 SHORT $LN11@PCBangShop
$LN3@PCBangShop:

; 765  : 	}
; 766  : 
; 767  : 	if( lpObj->m_ReqWarehouseOpen != 0 )

  00139	80 be 1c 11 00
	00 00		 cmp	 BYTE PTR [esi+4380], 0
  00140	74 1a		 je	 SHORT $LN2@PCBangShop

; 768  : 	{
; 769  : 		pMsg.Result = 3;
; 770  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00142	0f b6 85 f5 fb
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00149	88 8d f8 fb ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0014f	50		 push	 eax
  00150	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00156	51		 push	 ecx

; 771  : 		return;

  00157	e9 76 ff ff ff	 jmp	 $LN11@PCBangShop
$LN2@PCBangShop:

; 772  : 	}
; 773  : 
; 774  : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0015c	0f b6 95 f5 fb
	ff ff		 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00163	52		 push	 edx
  00164	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016a	50		 push	 eax
  0016b	53		 push	 ebx
  0016c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 775  : 
; 776  : 	if( gObjFixInventoryPointer(aIndex) == 0 )

  00171	53		 push	 ebx
  00172	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00177	83 c4 10	 add	 esp, 16			; 00000010H
  0017a	84 c0		 test	 al, al
  0017c	75 18		 jne	 SHORT $LN1@PCBangShop

; 777  : 	{
; 778  : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0017e	68 0a 03 00 00	 push	 778			; 0000030aH
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DBBIFFBK@PCBangPointSystem?4cpp?$AA@
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@PCBangShop:

; 779  : 	}
; 780  : 	
; 781  : 	PMSG_SHOP_ITEM_COUNT pShopItem;
; 782  : 	BYTE SendByte[1024];
; 783  : 
; 784  : 	int lOfs = 0;
; 785  : 	lpObj->TargetShopNumber = this->m_btPcBangShopNumber;
; 786  : 	lpObj->m_IfState.use = 1;
; 787  : 	lpObj->m_IfState.type = 18;

  00196	8b 96 1c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3612]
  0019c	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  001a0	81 e2 bd 04 ff
	ff		 and	 edx, -64323		; ffff04bdH
  001a6	66 89 8e 5a 04
	00 00		 mov	 WORD PTR [esi+1114], cx
  001ad	81 ca 81 04 00
	00		 or	 edx, 1153		; 00000481H
  001b3	89 96 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], edx

; 788  : 	lpObj->m_ShopTime = 0;

  001b9	c6 86 90 03 00
	00 00		 mov	 BYTE PTR [esi+912], 0

; 789  : 	lOfs += sizeof(pShopItem);
; 790  : 
; 791  : 	int size = lOfs + ShopC[this->m_btPcBangShopNumber].SendItemDataLen;

  001c0	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  001c4	69 c0 9c 6f 00
	00		 imul	 eax, 28572		; 00006f9cH
  001ca	8b b0 f8 69 00
	00		 mov	 esi, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+27128]
  001d0	83 c6 06	 add	 esi, 6

; 792  : 	PHeadSetW((LPBYTE)&pShopItem, 0x31, size);

  001d3	56		 push	 esi
  001d4	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _pShopItem$[ebp]
  001da	6a 31		 push	 49			; 00000031H
  001dc	51		 push	 ecx
  001dd	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 793  : 	pShopItem.Type = 0;
; 794  : 	pShopItem.count = ShopC[this->m_btPcBangShopNumber].ItemCount;

  001e2	0f b6 57 10	 movzx	 edx, BYTE PTR [edi+16]

; 795  : 
; 796  : 	memcpy(SendByte, &pShopItem, sizeof(pShopItem));

  001e6	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _pShopItem$[ebp]
  001ec	69 d2 9c 6f 00
	00		 imul	 edx, 28572		; 00006f9cH
  001f2	8a 82 7c 00 00
	00		 mov	 al, BYTE PTR ?ShopC@@3PAVCShop@@A[edx+124]
  001f8	88 85 f1 fb ff
	ff		 mov	 BYTE PTR _pShopItem$[ebp+5], al

; 797  : 	memcpy(&SendByte[lOfs], ShopC[this->m_btPcBangShopNumber].SendItemData, ShopC[this->m_btPcBangShopNumber].SendItemDataLen);

  001fe	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  00202	69 c0 9c 6f 00
	00		 imul	 eax, 28572		; 00006f9cH
  00208	c6 85 f0 fb ff
	ff 00		 mov	 BYTE PTR _pShopItem$[ebp+4], 0
  0020f	66 8b 95 f0 fb
	ff ff		 mov	 dx, WORD PTR _pShopItem$[ebp+4]
  00216	89 8d fc fb ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], ecx
  0021c	8b 88 f8 69 00
	00		 mov	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+27128]
  00222	66 89 95 00 fc
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], dx
  00229	51		 push	 ecx
  0022a	8d 90 e0 63 00
	00		 lea	 edx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+25568]
  00230	52		 push	 edx
  00231	8d 85 02 fc ff
	ff		 lea	 eax, DWORD PTR _SendByte$[ebp+6]
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _memcpy

; 798  : 
; 799  : 	DataSend(aIndex, SendByte, size);

  0023d	56		 push	 esi
  0023e	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  00244	51		 push	 ecx
  00245	53		 push	 ebx
  00246	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0024b	83 c4 24	 add	 esp, 36			; 00000024H
$LN8@PCBangShop:

; 800  : } 

  0024e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00251	5f		 pop	 edi
  00252	5e		 pop	 esi
  00253	33 cd		 xor	 ecx, ebp
  00255	5b		 pop	 ebx
  00256	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025b	8b e5		 mov	 esp, ebp
  0025d	5d		 pop	 ebp
  0025e	c2 04 00	 ret	 4
?PCBangShopOpen@CPCBangPointSystem@@QAEXH@Z ENDP	; CPCBangPointSystem::PCBangShopOpen
_TEXT	ENDS
PUBLIC	?SetUserTimer@CPCBangPointTimer@@SAXPAV1@H@Z	; CPCBangPointTimer::SetUserTimer
; Function compile flags: /Ogtp
;	COMDAT ?SetUserTimer@CPCBangPointTimer@@SAXPAV1@H@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_index$ = 12						; size = 4
?SetUserTimer@CPCBangPointTimer@@SAXPAV1@H@Z PROC	; CPCBangPointTimer::SetUserTimer, COMDAT

; 1003 : 	short aIndex = index;
; 1004 : 
; 1005 : 	return;
; 1006 : 	pthis->m_iUserIndex = aIndex;
; 1007 : 	pthis->SetCheckTimer(TRUE);
; 1008 : 
; 1009 : 	int iYear = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetYear;
; 1010 : 	int iMonth = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetMonth;
; 1011 : 	int iDay = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetDay;
; 1012 : 	int iHour = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetHour;
; 1013 : 
; 1014 : 	pthis->ChangeTimeDate(&iYear, &iMonth, &iDay, &iHour);
; 1015 : }

  00000	c3		 ret	 0
?SetUserTimer@CPCBangPointTimer@@SAXPAV1@H@Z ENDP	; CPCBangPointTimer::SetUserTimer
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGUserConnectPcBang@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGUserConnectPcBang
; Function compile flags: /Ogtp
;	COMDAT ?EGUserConnectPcBang@CPCBangPointSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?EGUserConnectPcBang@CPCBangPointSystem@@QAEXH@Z PROC	; CPCBangPointSystem::EGUserConnectPcBang, COMDAT
; _this$ = ecx

; 1018 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1019 : 	PMSG_REQ_REG_PC_POINT pMsg = {0};

  00010	33 c0		 xor	 eax, eax
  00012	56		 push	 esi
  00013	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 1020 : 
; 1021 : 	PHeadSetB((LPBYTE)&pMsg, 0x29, sizeof(pMsg));

  00016	6a 12		 push	 18			; 00000012H
  00018	89 45 e9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  0001b	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  0001e	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  00021	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+13], eax
  00024	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+17], al
  00027	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002a	6a 29		 push	 41			; 00000029H
  0002c	50		 push	 eax
  0002d	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00031	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1022 : 
; 1023 : 	pMsg.aIndex = aIndex;
; 1024 : 
; 1025 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	66 89 75 ec	 mov	 WORD PTR _pMsg$[ebp+4], si
  0003f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00045	8b 4c 06 6c	 mov	 ecx, DWORD PTR [esi+eax+108]
  00049	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+7], ecx
  0004c	8b 54 06 70	 mov	 edx, DWORD PTR [esi+eax+112]
  00050	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+11], edx
  00053	66 8b 44 06 74	 mov	 ax, WORD PTR [esi+eax+116]

; 1026 : 
; 1027 : 	pMsg.btResult = 0;
; 1028 : 
; 1029 : 	pMsg.AccountID[10] = '\0';
; 1030 : 
; 1031 : 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00058	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005b	6a 12		 push	 18			; 00000012H
  0005d	51		 push	 ecx
  0005e	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+15], ax
  00062	c6 45 ee 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
  00066	c6 45 f9 00	 mov	 BYTE PTR _pMsg$[ebp+17], 0
  0006a	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 1032 : 
; 1033 : 	LogAdd("[PCBangPointSystem][User Connect] [%s] - %s", 
; 1034 : 		gObj[aIndex].AccountID, gObj[aIndex].Ip_addr);

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00074	8d 54 06 18	 lea	 edx, DWORD PTR [esi+eax+24]
  00078	52		 push	 edx
  00079	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGBOIGIB@?$FLPCBangPointSystem?$FN?$FLUser?5Connect@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1035 : }

  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	83 c4 20	 add	 esp, 32			; 00000020H
  0008f	33 cd		 xor	 ecx, ebp
  00091	5e		 pop	 esi
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?EGUserConnectPcBang@CPCBangPointSystem@@QAEXH@Z ENDP	; CPCBangPointSystem::EGUserConnectPcBang
_TEXT	ENDS
PUBLIC	?EGAnsUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ; CPCBangPointSystem::EGAnsUpdatePcBangResetPointInfo
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?EGAnsUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aRecv$ = 8						; size = 4
?EGAnsUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z PROC ; CPCBangPointSystem::EGAnsUpdatePcBangResetPointInfo, COMDAT
; _this$ = ecx

; 1038 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 1039 : 	PMSG_ANS_REG_PC_POINT* m_PCInfo = aRecv;
; 1040 : 	int aIndex = m_PCInfo->aIndex;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]
  00009	0f bf 5f 04	 movsx	 ebx, WORD PTR [edi+4]
  0000d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1041 : 
; 1042 : 	if( OBJMAX_RANGE(aIndex) == 0 )

  00010	85 db		 test	 ebx, ebx
  00012	0f 88 c4 00 00
	00		 js	 $LN1@EGAnsUpdat
  00018	33 c0		 xor	 eax, eax
  0001a	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00020	0f 9e c0	 setle	 al
  00023	85 c0		 test	 eax, eax
  00025	0f 84 b1 00 00
	00		 je	 $LN1@EGAnsUpdat

; 1043 : 	{
; 1044 : 		return;
; 1045 : 	}
; 1046 : 
; 1047 : 	LPOBJ lpObj = &gObj[aIndex];

  0002b	56		 push	 esi
  0002c	8b f3		 mov	 esi, ebx
  0002e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00034	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1048 : 
; 1049 : 	lpObj->m_PcBangPointSystem.m_bPcBangPointEnable = TRUE;

  0003a	c7 86 20 20 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+8224], 1

; 1050 : 
; 1051 : 	lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = m_PCInfo->sPoint;

  00044	0f bf 47 12	 movsx	 eax, WORD PTR [edi+18]
  00048	89 86 2c 20 00
	00		 mov	 DWORD PTR [esi+8236], eax

; 1052 : 	lpObj->m_PcBangPointSystem.m_dwPcBangPointTick = GetTickCount();

  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00054	89 86 34 20 00
	00		 mov	 DWORD PTR [esi+8244], eax

; 1053 : 
; 1054 : 	lpObj->m_PcBangPointSystem.m_sPcBangResetYear = m_PCInfo->sPcBangResetYear;

  0005a	66 8b 4f 14	 mov	 cx, WORD PTR [edi+20]
  0005e	66 89 8e 38 20
	00 00		 mov	 WORD PTR [esi+8248], cx

; 1055 : 	lpObj->m_PcBangPointSystem.m_sPcBangResetMonth = m_PCInfo->sPcBangResetMonth;

  00065	66 8b 57 16	 mov	 dx, WORD PTR [edi+22]
  00069	66 89 96 3a 20
	00 00		 mov	 WORD PTR [esi+8250], dx

; 1056 : 	lpObj->m_PcBangPointSystem.m_sPcBangResetDay = m_PCInfo->sPcBangResetDay;

  00070	66 8b 47 18	 mov	 ax, WORD PTR [edi+24]
  00074	66 89 86 3c 20
	00 00		 mov	 WORD PTR [esi+8252], ax

; 1057 : 	lpObj->m_PcBangPointSystem.m_sPcBangResetHour = m_PCInfo->sPcBangResetHour;

  0007b	0f b7 47 1a	 movzx	 eax, WORD PTR [edi+26]

; 1058 : 
; 1059 : 	lpObj->m_PCBangPointTimer.SetResetTimeData(lpObj->m_PcBangPointSystem.m_sPcBangResetYear, lpObj->m_PcBangPointSystem.m_sPcBangResetMonth, lpObj->m_PcBangPointSystem.m_sPcBangResetDay, lpObj->m_PcBangPointSystem.m_sPcBangResetHour, g_sPCBangResetDayOfWeek, g_sPCBangResetHour, CPCBangPointTimer::SetUserTimer, aIndex);

  0007f	53		 push	 ebx
  00080	66 89 86 3e 20
	00 00		 mov	 WORD PTR [esi+8254], ax
  00087	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?g_sPCBangResetHour@@3FA ; g_sPCBangResetHour
  0008e	68 00 00 00 00	 push	 OFFSET ?SetUserTimer@CPCBangPointTimer@@SAXPAV1@H@Z ; CPCBangPointTimer::SetUserTimer
  00093	52		 push	 edx
  00094	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?g_sPCBangResetDayOfWeek@@3FA ; g_sPCBangResetDayOfWeek
  0009b	52		 push	 edx
  0009c	0f bf 96 3c 20
	00 00		 movsx	 edx, WORD PTR [esi+8252]
  000a3	98		 cwde
  000a4	50		 push	 eax
  000a5	0f bf 86 3a 20
	00 00		 movsx	 eax, WORD PTR [esi+8250]
  000ac	52		 push	 edx
  000ad	0f bf 96 38 20
	00 00		 movsx	 edx, WORD PTR [esi+8248]
  000b4	50		 push	 eax
  000b5	8d 8e 40 20 00
	00		 lea	 ecx, DWORD PTR [esi+8256]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 ?SetResetTimeData@CPCBangPointTimer@@QAEXHHHHHHP6AXPAV1@H@ZH@Z ; CPCBangPointTimer::SetResetTimeData

; 1060 : 
; 1061 : 	lpObj->m_PCBangPointTimer.SetCheckTimer(FALSE);

  000c1	6a 00		 push	 0
  000c3	e8 00 00 00 00	 call	 ?SetCheckTimer@CPCBangPointTimer@@QAEXH@Z ; CPCBangPointTimer::SetCheckTimer

; 1062 : 
; 1063 : 	if(lpObj->m_PCBangPointTimer.CheckTime() != 2)

  000c8	e8 00 00 00 00	 call	 ?CheckTime@CPCBangPointTimer@@QAEHXZ ; CPCBangPointTimer::CheckTime
  000cd	5e		 pop	 esi
  000ce	83 f8 02	 cmp	 eax, 2
  000d1	74 09		 je	 SHORT $LN1@EGAnsUpdat

; 1064 : 	{
; 1065 : 		this->GCSendPcBangUserPoint(aIndex);

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	53		 push	 ebx
  000d7	e8 00 00 00 00	 call	 ?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::GCSendPcBangUserPoint
$LN1@EGAnsUpdat:
  000dc	5f		 pop	 edi
  000dd	5b		 pop	 ebx

; 1066 : 	}
; 1067 : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 04 00	 ret	 4
?EGAnsUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ENDP ; CPCBangPointSystem::EGAnsUpdatePcBangResetPointInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGReqUpdatePcBangResetPointInfo
; Function compile flags: /Ogtp
;	COMDAT ?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z PROC ; CPCBangPointSystem::EGReqUpdatePcBangResetPointInfo, COMDAT
; _this$ = ecx

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1071 : 	PMSG_ANS_REG_PC_POINT pMsg = {0};

  00010	33 c0		 xor	 eax, eax
  00012	56		 push	 esi
  00013	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 1072 : 
; 1073 : 	PHeadSetB((LPBYTE)&pMsg, 0x30, sizeof(pMsg));

  00016	6a 1c		 push	 28			; 0000001cH
  00018	89 45 e1	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  0001b	89 45 e5	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  0001e	89 45 e9	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  00021	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+13], eax
  00024	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+17], eax
  00027	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+21], eax
  0002a	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+25], ax
  0002e	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+27], al
  00031	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	6a 30		 push	 48			; 00000030H
  00036	50		 push	 eax
  00037	c6 45 e0 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1074 : 
; 1075 : 	pMsg.aIndex = aIndex;
; 1076 : 
; 1077 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	66 89 75 e4	 mov	 WORD PTR _pMsg$[ebp+4], si
  0004a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00050	8b 54 0e 6c	 mov	 edx, DWORD PTR [esi+ecx+108]
  00054	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00057	89 55 e6	 mov	 DWORD PTR _pMsg$[ebp+6], edx
  0005a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0005d	89 4d ea	 mov	 DWORD PTR _pMsg$[ebp+10], ecx
  00060	0f b7 50 74	 movzx	 edx, WORD PTR [eax+116]
  00064	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+14], dx

; 1078 : 
; 1079 : 	pMsg.AccountID[10] = '\0';

  00068	66 c7 45 f0 00
	00		 mov	 WORD PTR _pMsg$[ebp+16], 0

; 1080 : 
; 1081 : 	pMsg.btShopItemBuy = 0;
; 1082 : 
; 1083 : 	pMsg.sPoint = gObj[aIndex].m_PcBangPointSystem.m_iPcBangAccumulatedPoint;

  0006e	0f b7 88 2c 20
	00 00		 movzx	 ecx, WORD PTR [eax+8236]
  00075	66 89 4d f2	 mov	 WORD PTR _pMsg$[ebp+18], cx

; 1084 : 
; 1085 : 	pMsg.sPcBangResetYear = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetYear;

  00079	0f b7 90 38 20
	00 00		 movzx	 edx, WORD PTR [eax+8248]
  00080	66 89 55 f4	 mov	 WORD PTR _pMsg$[ebp+20], dx

; 1086 : 	pMsg.sPcBangResetMonth = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetMonth;

  00084	0f b7 88 3a 20
	00 00		 movzx	 ecx, WORD PTR [eax+8250]
  0008b	66 89 4d f6	 mov	 WORD PTR _pMsg$[ebp+22], cx

; 1087 : 	pMsg.sPcBangResetDay = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetDay;

  0008f	0f b7 90 3c 20
	00 00		 movzx	 edx, WORD PTR [eax+8252]
  00096	66 89 55 f8	 mov	 WORD PTR _pMsg$[ebp+24], dx

; 1088 : 	pMsg.sPcBangResetHour = gObj[aIndex].m_PcBangPointSystem.m_sPcBangResetHour;

  0009a	66 8b 80 3e 20
	00 00		 mov	 ax, WORD PTR [eax+8254]

; 1089 : 
; 1090 : 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  000a1	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000a4	6a 1c		 push	 28			; 0000001cH
  000a6	51		 push	 ecx
  000a7	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+26], ax
  000ab	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 1091 : }

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5e		 pop	 esi
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z ENDP ; CPCBangPointSystem::EGReqUpdatePcBangResetPointInfo
_TEXT	ENDS
PUBLIC	?EGAnsUserPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ; CPCBangPointSystem::EGAnsUserPcBangUpdatePoint
; Function compile flags: /Ogtp
;	COMDAT ?EGAnsUserPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?EGAnsUserPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z PROC ; CPCBangPointSystem::EGAnsUserPcBangUpdatePoint, COMDAT
; _this$ = ecx

; 1094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1095 : 	PMSG_ANS_REG_PC_POINT* m_PCInfo = aRecv;
; 1096 : 	int aIndex = m_PCInfo->aIndex;

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	0f bf 46 04	 movsx	 eax, WORD PTR [esi+4]

; 1097 : 
; 1098 : 	if( OBJMAX_RANGE(aIndex) == 0 )

  0000b	85 c0		 test	 eax, eax
  0000d	78 1a		 js	 SHORT $LN1@EGAnsUserP
  0000f	33 d2		 xor	 edx, edx
  00011	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00016	0f 9e c2	 setle	 dl
  00019	85 d2		 test	 edx, edx
  0001b	74 0c		 je	 SHORT $LN1@EGAnsUserP

; 1099 : 	{
; 1100 : 		return;
; 1101 : 	}
; 1102 : 
; 1103 : 	if(m_PCInfo->btShopItemBuy == 1)

  0001d	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  00021	75 06		 jne	 SHORT $LN1@EGAnsUserP

; 1104 : 	{
; 1105 : 		this->GCSendPcBangUserPoint(aIndex);

  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::GCSendPcBangUserPoint
$LN1@EGAnsUserP:
  00029	5e		 pop	 esi

; 1106 : 	}
; 1107 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?EGAnsUserPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ENDP ; CPCBangPointSystem::EGAnsUserPcBangUpdatePoint
_TEXT	ENDS
PUBLIC	?AddExperience@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@AA_J@Z ; CPCBangPointSystem::AddExperience
; Function compile flags: /Ogtp
;	COMDAT ?AddExperience@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@AA_J@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Experience$ = 12					; size = 4
?AddExperience@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@AA_J@Z PROC ; CPCBangPointSystem::AddExperience, COMDAT
; _this$ = ecx

; 1110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1111 : 	if(lpObj->m_iPcBangConnectionType == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	83 b8 1c 20 00
	00 00		 cmp	 DWORD PTR [eax+8220], 0
  0000d	75 06		 jne	 SHORT $LN1@AddExperie

; 1112 : 	{
; 1113 : 		return FALSE;

  0000f	33 c0		 xor	 eax, eax

; 1121 : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
$LN1@AddExperie:
  00015	56		 push	 esi

; 1114 : 	}
; 1115 : 
; 1116 : 	__int64 iCAL_EXP = int(Experience * g_fPCBangAddExperience);
; 1117 : 
; 1118 : 	Experience = iCAL_EXP;

  00016	8b 75 0c	 mov	 esi, DWORD PTR _Experience$[ebp]
  00019	df 2e		 fild	 QWORD PTR [esi]
  0001b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR ?g_fPCBangAddExperience@@3MA ; g_fPCBangAddExperience
  00021	e8 00 00 00 00	 call	 __ftol2_sse
  00026	99		 cdq
  00027	89 06		 mov	 DWORD PTR [esi], eax
  00029	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1119 : 
; 1120 : 	return TRUE;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	5e		 pop	 esi

; 1121 : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?AddExperience@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@AA_J@Z ENDP ; CPCBangPointSystem::AddExperience
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCPCBangPointTimeCondition@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPCBangPointTimeCondition@@UAEPAXI@Z PROC		; CPCBangPointTimeCondition::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPCBangPointTimeCondition@@UAE@XZ ; CPCBangPointTimeCondition::~CPCBangPointTimeCondition
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPCBangPointTimeCondition@@UAEPAXI@Z ENDP		; CPCBangPointTimeCondition::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCPCBangPointTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPCBangPointTimer@@UAEPAXI@Z PROC			; CPCBangPointTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPCBangPointTimer@@UAE@XZ ; CPCBangPointTimer::~CPCBangPointTimer
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPCBangPointTimer@@UAEPAXI@Z ENDP			; CPCBangPointTimer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Clear@CPCBangPointTimer@@QAEXXZ		; CPCBangPointTimer::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CPCBangPointTimer@@QAEXXZ
_TEXT	SEGMENT
?Clear@CPCBangPointTimer@@QAEXXZ PROC			; CPCBangPointTimer::Clear, COMDAT
; _this$ = ecx

; 166  : 	this->SetCheckTimer(FALSE);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 ?SetCheckTimer@CPCBangPointTimer@@QAEXH@Z ; CPCBangPointTimer::SetCheckTimer

; 167  : }

  00007	c3		 ret	 0
?Clear@CPCBangPointTimer@@QAEXXZ ENDP			; CPCBangPointTimer::Clear
_TEXT	ENDS
PUBLIC	??0CPCBangPointSystem@@QAE@XZ			; CPCBangPointSystem::CPCBangPointSystem
; Function compile flags: /Ogtp
;	COMDAT ??0CPCBangPointSystem@@QAE@XZ
_TEXT	SEGMENT
??0CPCBangPointSystem@@QAE@XZ PROC			; CPCBangPointSystem::CPCBangPointSystem, COMDAT
; _this$ = ecx

; 252  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 253  : 	this->m_bPointSystemOn = FALSE;

  00003	33 c0		 xor	 eax, eax
  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CPCBangPointSystem@@6B@
  0000b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 254  : 	this->m_bPointRankEvent = FALSE;

  0000e	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 255  : 	g_btPcBangPointSystemLevel = 1;

  00011	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_btPcBangPointSystemLevel@@3EA, 1 ; g_btPcBangPointSystemLevel

; 256  : 	this->m_btPcBangShopNumber = 14;

  00018	c6 46 10 0e	 mov	 BYTE PTR [esi+16], 14	; 0000000eH

; 257  : 	this->Init();

  0001c	e8 00 00 00 00	 call	 ?Init@CPCBangPointSystem@@QAEXXZ ; CPCBangPointSystem::Init

; 258  : }

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	c3		 ret	 0
??0CPCBangPointSystem@@QAE@XZ ENDP			; CPCBangPointSystem::CPCBangPointSystem
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCPCBangPointSystem@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPCBangPointSystem@@UAEPAXI@Z PROC			; CPCBangPointSystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPCBangPointSystem@@UAE@XZ ; CPCBangPointSystem::~CPCBangPointSystem
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@3
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@3:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCPCBangPointSystem@@UAEPAXI@Z ENDP			; CPCBangPointSystem::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0CN@LJIFMDKJ@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@ ; `string'
PUBLIC	?SetPointUser@CPCBangPointSystem@@QAEXHH@Z	; CPCBangPointSystem::SetPointUser
;	COMDAT ??_C@_0CN@LJIFMDKJ@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@
CONST	SEGMENT
??_C@_0CN@LJIFMDKJ@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@ DB '[PCBang'
	DB	'PointSystem][SetPCBangPointUser] [%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetPointUser@CPCBangPointSystem@@QAEXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_iRuleTime$ = 12					; size = 4
?SetPointUser@CPCBangPointSystem@@QAEXHH@Z PROC		; CPCBangPointSystem::SetPointUser, COMDAT
; _this$ = ecx

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 485  : 	if( gObj[aIndex].Type != OBJ_USER )

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	8b c6		 mov	 eax, esi
  0000f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00015	66 83 7c 08 68
	01		 cmp	 WORD PTR [eax+ecx+104], 1
  0001b	75 66		 jne	 SHORT $LN8@SetPointUs

; 486  : 	{
; 487  : 		return;
; 488  : 	}
; 489  : 
; 490  : 	if( g_btPcBangPointSystemLevel == 0 )

  0001d	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?g_btPcBangPointSystemLevel@@3EA ; g_btPcBangPointSystemLevel
  00023	84 d2		 test	 dl, dl
  00025	75 0d		 jne	 SHORT $LN6@SetPointUs

; 491  : 	{
; 492  : 		gObj[aIndex].m_iPcBangConnectionType = 0;

  00027	c7 84 08 1c 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+ecx+8220], 0

; 493  : 	}
; 494  : 	else

  00032	eb 21		 jmp	 SHORT $LN10@SetPointUs
$LN6@SetPointUs:

; 495  : 	{
; 496  : 		if( g_btPcBangPointSystemLevel == 1 )

  00034	80 fa 01	 cmp	 dl, 1
  00037	75 0c		 jne	 SHORT $LN4@SetPointUs

; 497  : 		{
; 498  : 			gObj[aIndex].m_iPcBangConnectionType = iRuleTime;

  00039	8b 55 0c	 mov	 edx, DWORD PTR _iRuleTime$[ebp]
  0003c	89 94 08 1c 20
	00 00		 mov	 DWORD PTR [eax+ecx+8220], edx
  00043	eb 10		 jmp	 SHORT $LN10@SetPointUs
$LN4@SetPointUs:

; 499  : 		}
; 500  : 		else if( g_btPcBangPointSystemLevel == 2 )

  00045	80 fa 02	 cmp	 dl, 2
  00048	75 11		 jne	 SHORT $LN2@SetPointUs

; 501  : 		{
; 502  : 			gObj[aIndex].m_iPcBangConnectionType = 1;

  0004a	c7 84 08 1c 20
	00 00 01 00 00
	00		 mov	 DWORD PTR [eax+ecx+8220], 1
$LN10@SetPointUs:
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@SetPointUs:

; 503  : 		}
; 504  : 	}
; 505  : 
; 506  : 	if( gObj[aIndex].m_iPcBangConnectionType == 1 )

  0005b	83 bc 08 1c 20
	00 00 01	 cmp	 DWORD PTR [eax+ecx+8220], 1
  00063	75 13		 jne	 SHORT $LN1@SetPointUs

; 507  : 	{
; 508  : 		LogAdd("[PCBangPointSystem][SetPCBangPointUser] [%s]", gObj[aIndex].AccountID);

  00065	8d 44 08 6c	 lea	 eax, DWORD PTR [eax+ecx+108]
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@LJIFMDKJ@?$FLPCBangPointSystem?$FN?$FLSetPCBangPoi@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00075	83 c4 08	 add	 esp, 8
$LN1@SetPointUs:

; 509  : 	}
; 510  : 
; 511  : 	g_PCBangPointSystem.EGUserConnectPcBang(aIndex);

  00078	56		 push	 esi
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PCBangPointSystem@@3VCPCBangPointSystem@@A ; g_PCBangPointSystem
  0007e	e8 00 00 00 00	 call	 ?EGUserConnectPcBang@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGUserConnectPcBang
$LN8@SetPointUs:
  00083	5e		 pop	 esi

; 512  : }

  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
?SetPointUser@CPCBangPointSystem@@QAEXHH@Z ENDP		; CPCBangPointSystem::SetPointUser
_TEXT	ENDS
PUBLIC	??_C@_0DJ@BGACMBPK@?$FLPCBangPointSystem?$FN?$FLAdd?5Point?$FN?5?$FL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?AddPoint@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CPCBangPointSystem::AddPoint
EXTRN	__imp__wsprintfA:PROC
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0DJ@BGACMBPK@?$FLPCBangPointSystem?$FN?$FLAdd?5Point?$FN?5?$FL@
CONST	SEGMENT
??_C@_0DJ@BGACMBPK@?$FLPCBangPointSystem?$FN?$FLAdd?5Point?$FN?5?$FL@ DB '['
	DB	'PCBangPointSystem][Add Point] [%s] %d/Total:%d Rule(%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?AddPoint@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$ = -280						; size = 4
_sysTime$ = -276					; size = 16
_szTemp$215607 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?AddPoint@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CPCBangPointSystem::AddPoint, COMDAT
; _this$ = ecx

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	57		 push	 edi

; 516  : 	if( lpObj->Type != OBJ_USER )

  00018	bf 01 00 00 00	 mov	 edi, 1
  0001d	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00023	66 39 7e 68	 cmp	 WORD PTR [esi+104], di

; 517  : 	{
; 518  : 		return TRUE;

  00027	75 29		 jne	 SHORT $LN26@AddPoint

; 519  : 	}
; 520  : 
; 521  : 	if( this->m_bPointSystemOn == FALSE )

  00029	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0

; 522  : 	{
; 523  : 		return TRUE;

  0002d	74 23		 je	 SHORT $LN26@AddPoint

; 524  : 	}
; 525  : 
; 526  : 	if( lpObj->Connected < PLAYER_CONNECTED )

  0002f	39 7e 04	 cmp	 DWORD PTR [esi+4], edi

; 527  : 	{
; 528  : 		return TRUE;

  00032	7c 1e		 jl	 SHORT $LN26@AddPoint

; 529  : 	}
; 530  : 
; 531  : 	if( lpObj->m_PcBangPointSystem.m_bPcBangPointEnable == FALSE )

  00034	83 be 20 20 00
	00 00		 cmp	 DWORD PTR [esi+8224], 0

; 532  : 	{
; 533  : 		return TRUE;

  0003b	74 15		 je	 SHORT $LN26@AddPoint

; 534  : 	}
; 535  : 
; 536  : 	if( lpObj->m_PcBangPointSystem.m_dwPcBangPointTick <= 0  )

  0003d	83 be 34 20 00
	00 00		 cmp	 DWORD PTR [esi+8244], 0
  00044	77 20		 ja	 SHORT $LN14@AddPoint

; 537  : 	{
; 538  : 		lpObj->m_PcBangPointSystem.m_dwPcBangPointTick = GetTickCount();

  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004c	89 86 34 20 00
	00		 mov	 DWORD PTR [esi+8244], eax
$LN26@AddPoint:

; 539  : 		return TRUE;

  00052	8b c7		 mov	 eax, edi
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 604  : 				}
; 605  : 			}
; 606  : 		}
; 607  : 	}
; 608  : 
; 609  : 	return TRUE;
; 610  : }

  00056	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00059	33 cd		 xor	 ecx, ebp
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
$LN14@AddPoint:
  00066	53		 push	 ebx

; 540  : 	}
; 541  : 
; 542  : 	BOOL bFeverTime; //loc2
; 543  : 
; 544  : 	SYSTEMTIME sysTime; //
; 545  : 	GetLocalTime(&sysTime); //

  00067	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _sysTime$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 546  : 	
; 547  : 	bFeverTime = FALSE;
; 548  : 
; 549  : 	if( g_sPCBangFeverStartHour <= g_sPCBangFeverEndHour )

  00074	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?g_sPCBangFeverStartHour@@3FA ; g_sPCBangFeverStartHour
  0007a	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_sPCBangFeverEndHour@@3FA ; g_sPCBangFeverEndHour

; 550  : 	{
; 551  : 		if( sysTime.wHour >= g_sPCBangFeverStartHour && sysTime.wHour < g_sPCBangFeverEndHour)

  00081	0f b7 8d f4 fe
	ff ff		 movzx	 ecx, WORD PTR _sysTime$[ebp+8]
  00088	33 db		 xor	 ebx, ebx
  0008a	66 3b c2	 cmp	 ax, dx
  0008d	98		 cwde
  0008e	7f 06		 jg	 SHORT $LN13@AddPoint
  00090	3b c8		 cmp	 ecx, eax
  00092	7c 0f		 jl	 SHORT $LN10@AddPoint

; 552  : 		{
; 553  : 			bFeverTime = TRUE;
; 554  : 		}
; 555  : 	}

  00094	eb 04		 jmp	 SHORT $LN25@AddPoint
$LN13@AddPoint:

; 556  : 	else if( sysTime.wHour >= g_sPCBangFeverStartHour || sysTime.wHour < g_sPCBangFeverEndHour )

  00096	3b c8		 cmp	 ecx, eax
  00098	7d 07		 jge	 SHORT $LN9@AddPoint
$LN25@AddPoint:
  0009a	0f bf d2	 movsx	 edx, dx
  0009d	3b ca		 cmp	 ecx, edx
  0009f	7d 02		 jge	 SHORT $LN10@AddPoint
$LN9@AddPoint:

; 557  : 	{
; 558  : 		bFeverTime = TRUE;

  000a1	8b df		 mov	 ebx, edi
$LN10@AddPoint:

; 559  : 	}
; 560  : 
; 561  : 	DWORD iCommonRuleTime = (GetTickCount() - lpObj->m_PcBangPointSystem.m_dwPcBangPointTick) / 1000; //loc7

  000a3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  000a9	ff d7		 call	 edi
  000ab	8b c8		 mov	 ecx, eax
  000ad	2b 8e 34 20 00
	00		 sub	 ecx, DWORD PTR [esi+8244]
  000b3	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  000b8	f7 e1		 mul	 ecx

; 562  : 
; 563  : 	if( iCommonRuleTime >= lpObj->m_PcBangPointSystem.m_sPcBangCommonRuleTime )

  000ba	0f bf 86 26 20
	00 00		 movsx	 eax, WORD PTR [esi+8230]
  000c1	c1 ea 06	 shr	 edx, 6
  000c4	3b d0		 cmp	 edx, eax
  000c6	0f 82 38 01 00
	00		 jb	 $LN23@AddPoint

; 564  : 	{
; 565  : 		//Timer Class Start
; 566  : 		if(lpObj->m_PCBangPointTimer.CheckTime() != 2)

  000cc	8d 8e 40 20 00
	00		 lea	 ecx, DWORD PTR [esi+8256]
  000d2	e8 00 00 00 00	 call	 ?CheckTime@CPCBangPointTimer@@QAEHXZ ; CPCBangPointTimer::CheckTime
  000d7	83 f8 02	 cmp	 eax, 2
  000da	0f 84 24 01 00
	00		 je	 $LN23@AddPoint

; 567  : 		{
; 568  : 			lpObj->m_PcBangPointSystem.m_dwPcBangPointTick = GetTickCount();

  000e0	ff d7		 call	 edi

; 569  : 
; 570  : 			if(this->CheckPcBangRuleTime(lpObj->m_Index) == 1)

  000e2	8b 3e		 mov	 edi, DWORD PTR [esi]
  000e4	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	57		 push	 edi
  000eb	89 86 34 20 00
	00		 mov	 DWORD PTR [esi+8244], eax
  000f1	e8 00 00 00 00	 call	 ?CheckPcBangRuleTime@CPCBangPointSystem@@QAEHH@Z ; CPCBangPointSystem::CheckPcBangRuleTime
  000f6	83 f8 01	 cmp	 eax, 1
  000f9	0f 85 05 01 00
	00		 jne	 $LN23@AddPoint

; 571  : 			{
; 572  : 				int iPointValue = (bFeverTime == TRUE)?(lpObj->m_PcBangPointSystem.m_sPcBangGainPoint * g_sPCBangFeverMultipleValue):(lpObj->m_PcBangPointSystem.m_sPcBangGainPoint); //epic :)

  000ff	3b d8		 cmp	 ebx, eax
  00101	75 13		 jne	 SHORT $LN21@AddPoint
  00103	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?g_sPCBangFeverMultipleValue@@3FA ; g_sPCBangFeverMultipleValue
  0010a	0f bf 8e 28 20
	00 00		 movsx	 ecx, WORD PTR [esi+8232]
  00111	0f af c1	 imul	 eax, ecx
  00114	eb 07		 jmp	 SHORT $LN22@AddPoint
$LN21@AddPoint:
  00116	0f bf 86 28 20
	00 00		 movsx	 eax, WORD PTR [esi+8232]
$LN22@AddPoint:

; 573  : 
; 574  : 				lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint += iPointValue;

  0011d	01 86 2c 20 00
	00		 add	 DWORD PTR [esi+8236], eax
  00123	8b 96 2c 20 00
	00		 mov	 edx, DWORD PTR [esi+8236]

; 575  : 
; 576  : 				if(lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint < 0)

  00129	79 0c		 jns	 SHORT $LN5@AddPoint

; 577  : 				{
; 578  : 					lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = 0;

  0012b	c7 86 2c 20 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+8236], 0
  00135	eb 60		 jmp	 SHORT $LN2@AddPoint
$LN5@AddPoint:

; 579  : 				}
; 580  : 				else if(lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint > g_sPCBangMaxPoint)

  00137	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?g_sPCBangMaxPoint@@3FA ; g_sPCBangMaxPoint
  0013e	3b d1		 cmp	 edx, ecx
  00140	7e 23		 jle	 SHORT $LN3@AddPoint

; 581  : 				{
; 582  : 					lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = g_sPCBangMaxPoint;
; 583  : 					GCServerMsgStringSend(lMsg.Get(3393), lpObj->m_Index, 1);

  00142	6a 01		 push	 1
  00144	57		 push	 edi
  00145	89 8e 2c 20 00
	00		 mov	 DWORD PTR [esi+8236], ecx
  0014b	68 41 0d 00 00	 push	 3393			; 00000d41H
  00150	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00155	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 584  : 				}
; 585  : 				else

  00163	eb 32		 jmp	 SHORT $LN2@AddPoint
$LN3@AddPoint:

; 586  : 				{
; 587  : 					char szTemp[256];
; 588  : 					wsprintf(szTemp, lMsg.Get(3392), iPointValue);

  00165	50		 push	 eax
  00166	68 40 0d 00 00	 push	 3392			; 00000d40H
  0016b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00170	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00175	50		 push	 eax
  00176	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$215607[ebp]
  0017c	52		 push	 edx
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 589  : 					GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  00183	8b 06		 mov	 eax, DWORD PTR [esi]
  00185	6a 01		 push	 1
  00187	50		 push	 eax
  00188	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$215607[ebp]
  0018e	51		 push	 ecx
  0018f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00194	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@AddPoint:

; 590  : 				}
; 591  : 
; 592  : 				this->EGReqUpdatePcBangResetPointInfo(lpObj->m_Index);

  00197	8b 16		 mov	 edx, DWORD PTR [esi]
  00199	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	52		 push	 edx
  001a0	e8 00 00 00 00	 call	 ?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGReqUpdatePcBangResetPointInfo

; 593  : 
; 594  : 				LogAddTD("[PCBangPointSystem][Add Point] [%s] %d/Total:%d Rule(%d)", 
; 595  : 					lpObj->AccountID, lpObj->m_PcBangPointSystem.m_sPcBangGainPoint, 
; 596  : 					lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint, lpObj->m_PcBangPointSystem.m_bPcBangCommonRule);

  001a5	0f b6 86 24 20
	00 00		 movzx	 eax, BYTE PTR [esi+8228]
  001ac	8b 8e 2c 20 00
	00		 mov	 ecx, DWORD PTR [esi+8236]
  001b2	0f bf 96 28 20
	00 00		 movsx	 edx, WORD PTR [esi+8232]
  001b9	50		 push	 eax
  001ba	51		 push	 ecx
  001bb	52		 push	 edx
  001bc	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  001bf	50		 push	 eax
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@BGACMBPK@?$FLPCBangPointSystem?$FN?$FLAdd?5Point?$FN?5?$FL@
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001cb	83 c4 14	 add	 esp, 20			; 00000014H

; 597  : 
; 598  : 				if(lpObj->m_PcBangPointSystem.m_bPcBangInfoSet == FALSE)

  001ce	83 be 30 20 00
	00 00		 cmp	 DWORD PTR [esi+8240], 0
  001d5	75 2d		 jne	 SHORT $LN23@AddPoint

; 599  : 				{
; 600  : 					lpObj->m_PcBangPointSystem.m_bPcBangCommonRule = 1;

  001d7	c6 86 24 20 00
	00 01		 mov	 BYTE PTR [esi+8228], 1

; 601  : 					lpObj->m_PcBangPointSystem.m_bPcBangInfoSet = TRUE;

  001de	c7 86 30 20 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+8240], 1

; 602  : 					lpObj->m_PcBangPointSystem.m_sPcBangCommonRuleTime = g_sPCBangCommonRuleTime;

  001e8	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?g_sPCBangCommonRuleTime@@3FA ; g_sPCBangCommonRuleTime
  001ef	66 89 8e 26 20
	00 00		 mov	 WORD PTR [esi+8230], cx

; 603  : 					lpObj->m_PcBangPointSystem.m_sPcBangGainPoint = g_sPCBangCommonRuleTimePoint;

  001f6	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_sPCBangCommonRuleTimePoint@@3FA ; g_sPCBangCommonRuleTimePoint
  001fd	66 89 96 28 20
	00 00		 mov	 WORD PTR [esi+8232], dx
$LN23@AddPoint:

; 604  : 				}
; 605  : 			}
; 606  : 		}
; 607  : 	}
; 608  : 
; 609  : 	return TRUE;
; 610  : }

  00204	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00207	5b		 pop	 ebx
  00208	5f		 pop	 edi
  00209	33 cd		 xor	 ecx, ebp
  0020b	b8 01 00 00 00	 mov	 eax, 1
  00210	5e		 pop	 esi
  00211	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00216	8b e5		 mov	 esp, ebp
  00218	5d		 pop	 ebp
  00219	c2 04 00	 ret	 4
?AddPoint@CPCBangPointSystem@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CPCBangPointSystem::AddPoint
_TEXT	ENDS
PUBLIC	?EGAnsPcBangPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ; CPCBangPointSystem::EGAnsPcBangPointInfo
; Function compile flags: /Ogtp
;	COMDAT ?EGAnsPcBangPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?EGAnsPcBangPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z PROC ; CPCBangPointSystem::EGAnsPcBangPointInfo, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 	PMSG_ANS_REG_PC_POINT* m_PCInfo = aRecv;
; 638  : 	int aIndex = m_PCInfo->aIndex;

  00003	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	0f bf 78 04	 movsx	 edi, WORD PTR [eax+4]
  0000c	8b d9		 mov	 ebx, ecx

; 639  : 
; 640  : 	if( OBJMAX_RANGE(aIndex) == 0 )

  0000e	85 ff		 test	 edi, edi
  00010	78 47		 js	 SHORT $LN2@EGAnsPcBan
  00012	33 c9		 xor	 ecx, ecx
  00014	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0001a	0f 9e c1	 setle	 cl
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 38		 je	 SHORT $LN2@EGAnsPcBan

; 641  : 	{
; 642  : 		return;
; 643  : 	}
; 644  : 
; 645  : 	LPOBJ lpObj = &gObj[aIndex];

  00021	56		 push	 esi
  00022	8b f7		 mov	 esi, edi
  00024	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 646  : 
; 647  : 	lpObj->m_PcBangPointSystem.m_bPcBangPointEnable = TRUE;

  00030	c7 86 20 20 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+8224], 1

; 648  : 	lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = m_PCInfo->sPoint;

  0003a	0f bf 40 12	 movsx	 eax, WORD PTR [eax+18]
  0003e	89 86 2c 20 00
	00		 mov	 DWORD PTR [esi+8236], eax

; 649  : 	lpObj->m_PcBangPointSystem.m_dwPcBangPointTick = GetTickCount();

  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 650  : 
; 651  : 	this->GCSendPcBangUserPoint(aIndex);

  0004a	57		 push	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	89 86 34 20 00
	00		 mov	 DWORD PTR [esi+8244], eax
  00053	e8 00 00 00 00	 call	 ?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::GCSendPcBangUserPoint
  00058	5e		 pop	 esi
$LN2@EGAnsPcBan:
  00059	5f		 pop	 edi
  0005a	5b		 pop	 ebx

; 652  : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?EGAnsPcBangPointInfo@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ENDP ; CPCBangPointSystem::EGAnsPcBangPointInfo
_TEXT	ENDS
PUBLIC	?EGAnsUserFirstPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ; CPCBangPointSystem::EGAnsUserFirstPcBangUpdatePoint
; Function compile flags: /Ogtp
;	COMDAT ?EGAnsUserFirstPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?EGAnsUserFirstPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z PROC ; CPCBangPointSystem::EGAnsUserFirstPcBangUpdatePoint, COMDAT
; _this$ = ecx

; 674  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 675  : 	PMSG_ANS_REG_PC_POINT* m_PCInfo = aRecv;
; 676  : 	int aIndex = m_PCInfo->aIndex;

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	0f bf 46 04	 movsx	 eax, WORD PTR [esi+4]

; 677  : 
; 678  : 	if( OBJMAX_RANGE(aIndex) == 0 )

  0000b	85 c0		 test	 eax, eax
  0000d	78 1a		 js	 SHORT $LN1@EGAnsUserF
  0000f	33 d2		 xor	 edx, edx
  00011	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00016	0f 9e c2	 setle	 dl
  00019	85 d2		 test	 edx, edx
  0001b	74 0c		 je	 SHORT $LN1@EGAnsUserF

; 679  : 	{
; 680  : 		return;
; 681  : 	}
; 682  : 
; 683  : 	if(m_PCInfo->btShopItemBuy == 1)

  0001d	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  00021	75 06		 jne	 SHORT $LN1@EGAnsUserF

; 684  : 	{
; 685  : 		this->GCSendPcBangUserPoint(aIndex);

  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?GCSendPcBangUserPoint@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::GCSendPcBangUserPoint
$LN1@EGAnsUserF:
  00029	5e		 pop	 esi

; 686  : 	}
; 687  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?EGAnsUserFirstPcBangUpdatePoint@CPCBangPointSystem@@QAEXPAUPMSG_ANS_REG_PC_POINT@@@Z ENDP ; CPCBangPointSystem::EGAnsUserFirstPcBangUpdatePoint
_TEXT	ENDS
PUBLIC	??_C@_0FN@OPFCOMF@?$FLPCBangPointSystem?$FN?$FLBuyItem?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	_ItemPosition$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PCBangBuyItem@CPCBangPointSystem@@QAEHHE@Z	; CPCBangPointSystem::PCBangBuyItem
EXTRN	?gObjInventoryInsertItem@@YAEHVCItem@@@Z:PROC	; gObjInventoryInsertItem
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSetItemEffect
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
;	COMDAT ??_C@_0FN@OPFCOMF@?$FLPCBangPointSystem?$FN?$FLBuyItem?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0FN@OPFCOMF@?$FLPCBangPointSystem?$FN?$FLBuyItem?$FN?$FL?$CFs?$FN@ DB '['
	DB	'PCBangPointSystem][BuyItem][%s][%s](%d/%d/%d) (%d) [%s][%d] L'
	DB	'EV:%d, DUR:%d, OP:[%d][%d][%d]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PCBangBuyItem@CPCBangPointSystem@@QAEHHE@Z
_TEXT	SEGMENT
tv758 = -52						; size = 4
tv717 = -48						; size = 4
_iShopNumber$ = -44					; size = 4
_this$GSCopy$ = -40					; size = 4
tv718 = -36						; size = 4
_ItemPosition$GSCopy$ = -29				; size = 1
_aIndex$GSCopy$ = -28					; size = 4
_pMsg$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_ItemPosition$ = 12					; size = 1
?PCBangBuyItem@CPCBangPointSystem@@QAEHHE@Z PROC	; CPCBangPointSystem::PCBangBuyItem, COMDAT
; _this$ = ecx

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8a 45 0c	 mov	 al, BYTE PTR _ItemPosition$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	57		 push	 edi

; 982  : 			{
; 983  : 				lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = 0;

  00019	89 75 e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	6a 12		 push	 18			; 00000012H
  00024	6a 05		 push	 5
  00026	8b f9		 mov	 edi, ecx
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00031	68 d0 00 00 00	 push	 208			; 000000d0H
  00036	52		 push	 edx
  00037	89 7d d8	 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  0003a	88 45 e3	 mov	 BYTE PTR _ItemPosition$GSCopy$[ebp], al
  0003d	8d 1c 0e	 lea	 ebx, DWORD PTR [esi+ecx]
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	66 c7 45 ec 06
	ff		 mov	 WORD PTR _pMsg$[ebp+4], 65286 ; 0000ff06H
  0004e	80 7b 0b ff	 cmp	 BYTE PTR [ebx+11], -1
  00052	75 3c		 jne	 SHORT $LN53@PCBangBuyI

; 804  : 	LPOBJ lpObj = &gObj[aIndex];
; 805  : 	
; 806  : 	PMSG_POINT_BUY_ITEM pMsg;
; 807  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD0, 0x05, sizeof(pMsg));
; 808  : 	pMsg.Result = 6;
; 809  : 	pMsg.ItemPos = -1;
; 810  : 
; 811  : 	if( lpObj->CloseType != -1 )
; 812  : 	{
; 813  : 		return 0;
; 814  : 	}
; 815  : 
; 816  : 	if( this->ShopMapCheck(lpObj->MapNumber, lpObj->X, lpObj->Y) == 0 )

  00054	0f b7 83 46 01
	00 00		 movzx	 eax, WORD PTR [ebx+326]
  0005b	0f b7 8b 44 01
	00 00		 movzx	 ecx, WORD PTR [ebx+324]
  00062	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00069	50		 push	 eax
  0006a	51		 push	 ecx
  0006b	52		 push	 edx
  0006c	8b cf		 mov	 ecx, edi
  0006e	e8 00 00 00 00	 call	 ?ShopMapCheck@CPCBangPointSystem@@QAEHEFF@Z ; CPCBangPointSystem::ShopMapCheck
  00073	85 c0		 test	 eax, eax
  00075	75 2e		 jne	 SHORT $LN30@PCBangBuyI

; 817  : 	{
; 818  : 		pMsg.Result = 1;

  00077	c6 45 ec 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
$LN23@PCBangBuyI:

; 857  : 	{
; 858  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007b	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007f	8b 55 e4	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00082	50		 push	 eax
  00083	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00086	51		 push	 ecx
  00087	52		 push	 edx
$LN54@PCBangBuyI:
  00088	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@PCBangBuyI:

; 859  : 		return 0;

  00090	33 c0		 xor	 eax, eax

; 999  : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 cd		 xor	 ecx, ebp
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 08 00	 ret	 8
$LN30@PCBangBuyI:

; 819  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 820  : 		return 0;
; 821  : 	}
; 822  : 
; 823  : 	if( gObjFixInventoryPointer(aIndex) == 0 )

  000a5	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000ae	83 c4 04	 add	 esp, 4
  000b1	84 c0		 test	 al, al
  000b3	75 18		 jne	 SHORT $LN29@PCBangBuyI

; 824  : 	{
; 825  : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000b5	68 39 03 00 00	 push	 825			; 00000339H
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DBBIFFBK@PCBangPointSystem?4cpp?$AA@
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@PCBangBuyI:

; 826  : 	}
; 827  : 
; 828  : 	if( gObj[aIndex].m_ShopTime == 0 )

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	80 bc 06 90 03
	00 00 00	 cmp	 BYTE PTR [esi+eax+912], 0
  000da	75 0d		 jne	 SHORT $LN28@PCBangBuyI

; 829  : 	{
; 830  : 		gObj[aIndex].m_ShopTime = 1;

  000dc	c6 84 06 90 03
	00 00 01	 mov	 BYTE PTR [esi+eax+912], 1
  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN28@PCBangBuyI:

; 831  : 	}
; 832  : 
; 833  : 	if( gObj[aIndex].m_ShopTime > 60 )

  000e9	80 bc 06 90 03
	00 00 3c	 cmp	 BYTE PTR [esi+eax+912], 60 ; 0000003cH

; 834  : 	{
; 835  : 		if( lpObj->m_IfState.use != 0 && lpObj->m_IfState.type == 18 )

  000f1	8b 83 1c 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3612]
  000f7	76 32		 jbe	 SHORT $LN27@PCBangBuyI
  000f9	a8 03		 test	 al, 3
  000fb	74 25		 je	 SHORT $LN26@PCBangBuyI
  000fd	8b c8		 mov	 ecx, eax
  000ff	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00105	81 f9 80 04 00
	00		 cmp	 ecx, 1152		; 00000480H
  0010b	75 15		 jne	 SHORT $LN26@PCBangBuyI

; 836  : 		{
; 837  : 			lpObj->TargetShopNumber = -1;

  0010d	83 ca ff	 or	 edx, -1

; 838  : 			lpObj->m_IfState.use = 0;
; 839  : 			lpObj->m_IfState.type = 0;

  00110	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  00115	66 89 93 5a 04
	00 00		 mov	 WORD PTR [ebx+1114], dx
  0011c	89 83 1c 0e 00
	00		 mov	 DWORD PTR [ebx+3612], eax
$LN26@PCBangBuyI:

; 840  : 		}
; 841  : 
; 842  : 		pMsg.Result = 7;

  00122	c6 45 ec 07	 mov	 BYTE PTR _pMsg$[ebp+4], 7

; 843  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 844  : 		return 0;

  00126	e9 50 ff ff ff	 jmp	 $LN23@PCBangBuyI
$LN27@PCBangBuyI:

; 845  : 	}
; 846  : 
; 847  : 	if( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type != 18 )

  0012b	a8 03		 test	 al, 3
  0012d	76 15		 jbe	 SHORT $LN25@PCBangBuyI
  0012f	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00134	3d 80 04 00 00	 cmp	 eax, 1152		; 00000480H
  00139	74 09		 je	 SHORT $LN25@PCBangBuyI

; 848  : 	{
; 849  : 		pMsg.Result = 5;

  0013b	c6 45 ec 05	 mov	 BYTE PTR _pMsg$[ebp+4], 5

; 850  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 851  : 		return 0;

  0013f	e9 37 ff ff ff	 jmp	 $LN23@PCBangBuyI
$LN25@PCBangBuyI:

; 852  : 	}
; 853  : 
; 854  : 	int iShopNumber = lpObj->TargetShopNumber;

  00144	0f bf 83 5a 04
	00 00		 movsx	 eax, WORD PTR [ebx+1114]
  0014b	89 45 d4	 mov	 DWORD PTR _iShopNumber$[ebp], eax

; 855  : 
; 856  : 	if( iShopNumber < 0 || iShopNumber > MAX_SHOP-1 )

  0014e	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00151	0f 87 24 ff ff
	ff		 ja	 $LN23@PCBangBuyI

; 860  : 	}
; 861  : 
; 862  : 	if( ItemPosition > MAX_ITEM_IN_SHOP-1 )

  00157	8a 4d e3	 mov	 cl, BYTE PTR _ItemPosition$GSCopy$[ebp]
  0015a	80 f9 77	 cmp	 cl, 119			; 00000077H

; 863  : 	{
; 864  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 865  : 		return 0;

  0015d	0f 87 18 ff ff
	ff		 ja	 $LN23@PCBangBuyI

; 866  : 	}
; 867  : 	
; 868  : 	if( ShopC[iShopNumber].m_item[ItemPosition].IsItem() == 0 )

  00163	0f b6 f1	 movzx	 esi, cl
  00166	69 c0 9c 6f 00
	00		 imul	 eax, 28572		; 00006f9cH
  0016c	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00172	03 f0		 add	 esi, eax
  00174	8d 8e 80 00 00
	00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[esi+128]
  0017a	89 75 d0	 mov	 DWORD PTR tv717[ebp], esi
  0017d	89 4d dc	 mov	 DWORD PTR tv718[ebp], ecx
  00180	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00185	85 c0		 test	 eax, eax
  00187	75 16		 jne	 SHORT $LN21@PCBangBuyI

; 869  : 	{
; 870  : 		pMsg.Result = 2;
; 871  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00189	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0018d	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00190	52		 push	 edx
  00191	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00194	50		 push	 eax
  00195	c6 45 ec 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  00199	51		 push	 ecx

; 872  : 		return 0;

  0019a	e9 e9 fe ff ff	 jmp	 $LN54@PCBangBuyI
$LN21@PCBangBuyI:

; 873  : 	}
; 874  : 
; 875  : 	BOOL bItem = FALSE;
; 876  : 	int iItemType = ShopC[iShopNumber].m_item[ItemPosition].m_Type;

  0019f	0f bf 96 86 00
	00 00		 movsx	 edx, WORD PTR ?ShopC@@3PAVCShop@@A[esi+134]
  001a6	33 c9		 xor	 ecx, ecx

; 877  : 	int iPos = 0;

  001a8	33 c0		 xor	 eax, eax

; 878  : 	PCBANG_LOAD_INFO* m_PCBangInfo = this->m_PcBangSystem;
; 879  : 
; 880  : 	for( int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++ )
; 881  : 	{
; 882  : 		if( this->m_PcBangSystem[n].Index == iItemType )

  001aa	39 57 14	 cmp	 DWORD PTR [edi+20], edx
  001ad	75 03		 jne	 SHORT $LN19@PCBangBuyI

; 885  : 			bItem = TRUE;

  001af	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LN19@PCBangBuyI:

; 878  : 	PCBANG_LOAD_INFO* m_PCBangInfo = this->m_PcBangSystem;
; 879  : 
; 880  : 	for( int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++ )
; 881  : 	{
; 882  : 		if( this->m_PcBangSystem[n].Index == iItemType )

  001b2	39 57 2c	 cmp	 DWORD PTR [edi+44], edx
  001b5	75 07		 jne	 SHORT $LN50@PCBangBuyI

; 883  : 		{
; 884  : 			iPos = n;

  001b7	b8 01 00 00 00	 mov	 eax, 1

; 885  : 			bItem = TRUE;

  001bc	8b c8		 mov	 ecx, eax
$LN50@PCBangBuyI:

; 878  : 	PCBANG_LOAD_INFO* m_PCBangInfo = this->m_PcBangSystem;
; 879  : 
; 880  : 	for( int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++ )
; 881  : 	{
; 882  : 		if( this->m_PcBangSystem[n].Index == iItemType )

  001be	39 57 44	 cmp	 DWORD PTR [edi+68], edx
  001c1	75 08		 jne	 SHORT $LN51@PCBangBuyI

; 883  : 		{
; 884  : 			iPos = n;

  001c3	b8 02 00 00 00	 mov	 eax, 2

; 885  : 			bItem = TRUE;

  001c8	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
$LN51@PCBangBuyI:

; 878  : 	PCBANG_LOAD_INFO* m_PCBangInfo = this->m_PcBangSystem;
; 879  : 
; 880  : 	for( int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++ )
; 881  : 	{
; 882  : 		if( this->m_PcBangSystem[n].Index == iItemType )

  001cb	39 57 5c	 cmp	 DWORD PTR [edi+92], edx
  001ce	75 08		 jne	 SHORT $LN52@PCBangBuyI

; 883  : 		{
; 884  : 			iPos = n;

  001d0	b8 03 00 00 00	 mov	 eax, 3

; 885  : 			bItem = TRUE;

  001d5	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
$LN52@PCBangBuyI:

; 878  : 	PCBANG_LOAD_INFO* m_PCBangInfo = this->m_PcBangSystem;
; 879  : 
; 880  : 	for( int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++ )
; 881  : 	{
; 882  : 		if( this->m_PcBangSystem[n].Index == iItemType )

  001d8	39 57 74	 cmp	 DWORD PTR [edi+116], edx
  001db	75 08		 jne	 SHORT $LN46@PCBangBuyI

; 883  : 		{
; 884  : 			iPos = n;

  001dd	b8 04 00 00 00	 mov	 eax, 4

; 885  : 			bItem = TRUE;

  001e2	8d 48 fd	 lea	 ecx, DWORD PTR [eax-3]
$LN46@PCBangBuyI:

; 878  : 	PCBANG_LOAD_INFO* m_PCBangInfo = this->m_PcBangSystem;
; 879  : 
; 880  : 	for( int n = 0; n < MAX_PCBANG_ITEM_COUNT; n++ )
; 881  : 	{
; 882  : 		if( this->m_PcBangSystem[n].Index == iItemType )

  001e5	39 97 8c 00 00
	00		 cmp	 DWORD PTR [edi+140], edx
  001eb	75 25		 jne	 SHORT $LN48@PCBangBuyI

; 883  : 		{
; 884  : 			iPos = n;

  001ed	b8 05 00 00 00	 mov	 eax, 5
$LN16@PCBangBuyI:

; 894  : 	}
; 895  : 
; 896  : 	if( lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint < this->m_PcBangSystem[iPos].BuyPoint )

  001f2	8b 8b 2c 20 00
	00		 mov	 ecx, DWORD PTR [ebx+8236]
  001f8	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001fb	8d 04 d7	 lea	 eax, DWORD PTR [edi+edx*8]
  001fe	0f bf 50 18	 movsx	 edx, WORD PTR [eax+24]
  00202	89 45 cc	 mov	 DWORD PTR tv758[ebp], eax
  00205	3b ca		 cmp	 ecx, edx
  00207	7d 23		 jge	 SHORT $LN15@PCBangBuyI

; 897  : 	{
; 898  : 		pMsg.Result = 9;

  00209	c6 45 ec 09	 mov	 BYTE PTR _pMsg$[ebp+4], 9

; 899  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 900  : 		return 0;

  0020d	e9 69 fe ff ff	 jmp	 $LN23@PCBangBuyI
$LN48@PCBangBuyI:

; 886  : 		}
; 887  : 	}
; 888  : 
; 889  : 	if( bItem == FALSE )

  00212	85 c9		 test	 ecx, ecx
  00214	75 dc		 jne	 SHORT $LN16@PCBangBuyI

; 890  : 	{
; 891  : 		pMsg.Result = 8;
; 892  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00216	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0021a	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0021d	52		 push	 edx
  0021e	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00221	50		 push	 eax
  00222	c6 45 ec 08	 mov	 BYTE PTR _pMsg$[ebp+4], 8
  00226	51		 push	 ecx

; 893  : 		return 0;

  00227	e9 5c fe ff ff	 jmp	 $LN54@PCBangBuyI
$LN15@PCBangBuyI:

; 901  : 	}
; 902  : 
; 903  : 	if( lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint < this->m_PcBangSystem[iPos].Condition ) //wz bug

  0022c	0f bf 50 1a	 movsx	 edx, WORD PTR [eax+26]
  00230	3b ca		 cmp	 ecx, edx
  00232	7d 09		 jge	 SHORT $LN14@PCBangBuyI

; 904  : 	{
; 905  : 		pMsg.Result = 4;

  00234	c6 45 ec 04	 mov	 BYTE PTR _pMsg$[ebp+4], 4

; 906  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 907  : 		return 0;

  00238	e9 3e fe ff ff	 jmp	 $LN23@PCBangBuyI
$LN14@PCBangBuyI:

; 908  : 	}
; 909  : 
; 910  : 	if( this->m_PcBangSystem[iPos].Ability == 1 )
; 911  : 	{
; 912  : 		ItemByteConvert((LPBYTE)&pMsg.ItemInfo, ShopC[iShopNumber].m_item[ItemPosition]);

  0023d	8b 75 dc	 mov	 esi, DWORD PTR tv718[ebp]
  00240	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00246	80 78 1c 01	 cmp	 BYTE PTR [eax+28], 1
  0024a	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0024f	8b fc		 mov	 edi, esp
  00251	f3 a5		 rep movsd
  00253	0f 85 34 01 00
	00		 jne	 $LN13@PCBangBuyI
  00259	8d 45 ee	 lea	 eax, DWORD PTR _pMsg$[ebp+6]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 913  : 		pMsg.Result = 0;
; 914  : 		pMsg.ItemPos = -1;
; 915  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00262	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00266	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00269	51		 push	 ecx
  0026a	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0026d	52		 push	 edx
  0026e	50		 push	 eax
  0026f	66 c7 45 ec 00
	ff		 mov	 WORD PTR _pMsg$[ebp+4], 65280 ; 0000ff00H
  00275	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 916  : 
; 917  : 		int iEffectIndex = 0;
; 918  : 
; 919  : 		if( ShopC[iShopNumber].m_item[ItemPosition].m_Type == ITEMGET(13,43) )

  0027a	8b 75 d0	 mov	 esi, DWORD PTR tv717[ebp]
  0027d	0f b7 86 86 00
	00 00		 movzx	 eax, WORD PTR ?ShopC@@3PAVCShop@@A[esi+134]
  00284	ba 2b 1a 00 00	 mov	 edx, 6699		; 00001a2bH
  00289	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0028f	33 c9		 xor	 ecx, ecx
  00291	66 3b c2	 cmp	 ax, dx
  00294	75 07		 jne	 SHORT $LN12@PCBangBuyI

; 920  : 		{
; 921  : 			iEffectIndex = AT_PCBANG_SEAL_OF_ASCENSION;

  00296	b9 1d 00 00 00	 mov	 ecx, 29			; 0000001dH
  0029b	eb 31		 jmp	 SHORT $LN6@PCBangBuyI
$LN12@PCBangBuyI:

; 922  : 		}
; 923  : 		else if( ShopC[iShopNumber].m_item[ItemPosition].m_Type == ITEMGET(13,44) )

  0029d	ba 2c 1a 00 00	 mov	 edx, 6700		; 00001a2cH
  002a2	66 3b c2	 cmp	 ax, dx
  002a5	75 07		 jne	 SHORT $LN10@PCBangBuyI

; 924  : 		{
; 925  : 			iEffectIndex = AT_PCBANG_SEAL_OF_WEALTH;

  002a7	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  002ac	eb 20		 jmp	 SHORT $LN6@PCBangBuyI
$LN10@PCBangBuyI:

; 926  : 		}
; 927  : 		else if( ShopC[iShopNumber].m_item[ItemPosition].m_Type == ITEMGET(13,45) )

  002ae	ba 2d 1a 00 00	 mov	 edx, 6701		; 00001a2dH
  002b3	66 3b c2	 cmp	 ax, dx
  002b6	75 07		 jne	 SHORT $LN8@PCBangBuyI

; 928  : 		{
; 929  : 			iEffectIndex = AT_PCBANG_SEAL_OF_SUSTENANCE;

  002b8	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  002bd	eb 0f		 jmp	 SHORT $LN6@PCBangBuyI
$LN8@PCBangBuyI:

; 930  : 		}
; 931  : 		else if( ShopC[iShopNumber].m_item[ItemPosition].m_Type == ITEMGET(13,96) )

  002bf	ba 60 1a 00 00	 mov	 edx, 6752		; 00001a60H
  002c4	66 3b c2	 cmp	 ax, dx
  002c7	75 05		 jne	 SHORT $LN6@PCBangBuyI

; 932  : 		{
; 933  : 			iEffectIndex = AT_PCBANG_SEAL_OF_BALANCE;

  002c9	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
$LN6@PCBangBuyI:

; 934  : 		}
; 935  : 
; 936  : 		gObjSetItemEffect(lpObj, iEffectIndex);

  002ce	51		 push	 ecx
  002cf	53		 push	 ebx
  002d0	e8 00 00 00 00	 call	 ?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSetItemEffect

; 937  : 
; 938  : 		lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint -= this->m_PcBangSystem[iPos].BuyPoint;

  002d5	8b 7d cc	 mov	 edi, DWORD PTR tv758[ebp]
  002d8	0f bf 47 18	 movsx	 eax, WORD PTR [edi+24]
  002dc	83 c4 08	 add	 esp, 8
  002df	29 83 2c 20 00
	00		 sub	 DWORD PTR [ebx+8236], eax

; 939  : 
; 940  : 		if( lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint < 0 )

  002e5	79 0a		 jns	 SHORT $LN5@PCBangBuyI

; 941  : 		{
; 942  : 			lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = 0;

  002e7	c7 83 2c 20 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+8236], 0
$LN5@PCBangBuyI:

; 943  : 		}
; 944  : 
; 945  : 		this->EGReqUpdatePcBangResetPointInfo(aIndex); //Update Reset Time Date In Database

  002f1	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002f4	51		 push	 ecx
  002f5	8b 4d d8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002f8	e8 00 00 00 00	 call	 ?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGReqUpdatePcBangResetPointInfo

; 946  : 
; 947  : 		this->EGReqUpdatePcBangPointInfo(aIndex, this->m_PcBangSystem[iPos].BuyPoint); //Decrease Point in Database if Rank activated

  002fd	0f b7 57 18	 movzx	 edx, WORD PTR [edi+24]
  00301	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00304	8b 4d d8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00307	52		 push	 edx
  00308	50		 push	 eax
  00309	e8 00 00 00 00	 call	 ?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXHF@Z ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo

; 948  : 
; 949  : 		LogAddTD("[PCBangPointSystem][BuyItem][%s][%s](%d/%d/%d) (%d) [%s][%d] LEV:%d, DUR:%d, OP:[%d][%d][%d]", 
; 950  : 			lpObj->AccountID, lpObj->Name, this->m_PcBangSystem[iPos].BuyPoint, lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint, 
; 951  : 			g_sPCBangMaxPoint, iShopNumber, ShopC[iShopNumber].m_item[ItemPosition].GetName(), this->m_PcBangSystem[iPos].KeepTime, 
; 952  : 			ShopC[iShopNumber].m_item[ItemPosition].m_Level, 
; 953  : 			(int)(ShopC[iShopNumber].m_item[ItemPosition].m_Durability), 
; 954  : 			ShopC[iShopNumber].m_item[ItemPosition].m_Option1, 
; 955  : 			ShopC[iShopNumber].m_item[ItemPosition].m_Option2, 
; 956  : 			ShopC[iShopNumber].m_item[ItemPosition].m_Option3);

  0030e	0f b6 8e 16 01
	00 00		 movzx	 ecx, BYTE PTR ?ShopC@@3PAVCShop@@A[esi+278]
  00315	d9 86 a4 00 00
	00		 fld	 DWORD PTR ?ShopC@@3PAVCShop@@A[esi+164]
  0031b	0f b6 96 15 01
	00 00		 movzx	 edx, BYTE PTR ?ShopC@@3PAVCShop@@A[esi+277]
  00322	0f b6 86 14 01
	00 00		 movzx	 eax, BYTE PTR ?ShopC@@3PAVCShop@@A[esi+276]
  00329	51		 push	 ecx
  0032a	52		 push	 edx
  0032b	50		 push	 eax
  0032c	e8 00 00 00 00	 call	 __ftol2_sse
  00331	0f bf 8e 88 00
	00 00		 movsx	 ecx, WORD PTR ?ShopC@@3PAVCShop@@A[esi+136]
  00338	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  0033b	50		 push	 eax
  0033c	51		 push	 ecx
  0033d	8b 4d dc	 mov	 ecx, DWORD PTR tv718[ebp]
  00340	52		 push	 edx
  00341	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00346	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?g_sPCBangMaxPoint@@3FA ; g_sPCBangMaxPoint
  0034d	8b 93 2c 20 00
	00		 mov	 edx, DWORD PTR [ebx+8236]
  00353	50		 push	 eax
  00354	8b 45 d4	 mov	 eax, DWORD PTR _iShopNumber$[ebp]
  00357	50		 push	 eax
  00358	0f bf 47 18	 movsx	 eax, WORD PTR [edi+24]
  0035c	51		 push	 ecx
  0035d	52		 push	 edx
  0035e	50		 push	 eax
  0035f	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00362	51		 push	 ecx
  00363	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00366	53		 push	 ebx
  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@OPFCOMF@?$FLPCBangPointSystem?$FN?$FLBuyItem?$FN?$FL?$CFs?$FN@
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00372	83 c4 38	 add	 esp, 56			; 00000038H

; 995  : 		}
; 996  : 	}
; 997  : 
; 998  : 	return 1;

  00375	b8 01 00 00 00	 mov	 eax, 1

; 999  : }

  0037a	5f		 pop	 edi
  0037b	5e		 pop	 esi
  0037c	5b		 pop	 ebx
  0037d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00380	33 cd		 xor	 ecx, ebp
  00382	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00387	8b e5		 mov	 esp, ebp
  00389	5d		 pop	 ebp
  0038a	c2 08 00	 ret	 8
$LN13@PCBangBuyI:

; 957  : 	}
; 958  : 	else
; 959  : 	{
; 960  : 		pMsg.ItemPos = gObjInventoryInsertItem(aIndex, ShopC[iShopNumber].m_item[ItemPosition]);

  0038d	8b 75 e4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00390	56		 push	 esi
  00391	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  00396	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0039c	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 961  : 
; 962  : 		if( pMsg.ItemPos != 0xFF )

  0039f	3c ff		 cmp	 al, 255			; 000000ffH
  003a1	0f 84 f4 00 00
	00		 je	 $LN3@PCBangBuyI

; 963  : 		{
; 964  : 			ItemByteConvert((LPBYTE)&pMsg.ItemInfo, ShopC[iShopNumber].m_item[ItemPosition]);

  003a7	8b 75 dc	 mov	 esi, DWORD PTR tv718[ebp]
  003aa	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  003b0	8d 55 ee	 lea	 edx, DWORD PTR _pMsg$[ebp+6]
  003b3	8b fc		 mov	 edi, esp
  003b5	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  003ba	52		 push	 edx
  003bb	f3 a5		 rep movsd
  003bd	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 965  : 			pMsg.Result = 0;
; 966  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003c2	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  003c6	8b 55 e4	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  003c9	50		 push	 eax
  003ca	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  003cd	51		 push	 ecx
  003ce	52		 push	 edx
  003cf	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  003d3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 967  : 
; 968  : 			lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint -= this->m_PcBangSystem[iPos].BuyPoint;

  003d8	8b 7d cc	 mov	 edi, DWORD PTR tv758[ebp]
  003db	0f bf 47 18	 movsx	 eax, WORD PTR [edi+24]
  003df	29 83 2c 20 00
	00		 sub	 DWORD PTR [ebx+8236], eax

; 969  : 
; 970  : 			LogAddTD("[PCBangPointSystem][BuyItem][%s][%s](%d/%d/%d) (%d) [%s][%d] LEV:%d, DUR:%d, OP:[%d][%d][%d]", 
; 971  : 				lpObj->AccountID, lpObj->Name, this->m_PcBangSystem[iPos].BuyPoint, 
; 972  : 				lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint, g_sPCBangMaxPoint, iShopNumber, 
; 973  : 				ShopC[iShopNumber].m_item[ItemPosition].GetName(), 
; 974  : 				this->m_PcBangSystem[iPos].KeepTime, 
; 975  : 				ShopC[iShopNumber].m_item[ItemPosition].m_Level, 
; 976  : 				(int)ShopC[iShopNumber].m_item[ItemPosition].m_Durability, 
; 977  : 				ShopC[iShopNumber].m_item[ItemPosition].m_Option1, 
; 978  : 				ShopC[iShopNumber].m_item[ItemPosition].m_Option2, 
; 979  : 				ShopC[iShopNumber].m_item[ItemPosition].m_Option3);

  003e5	8b 75 d0	 mov	 esi, DWORD PTR tv717[ebp]
  003e8	0f b6 8e 16 01
	00 00		 movzx	 ecx, BYTE PTR ?ShopC@@3PAVCShop@@A[esi+278]
  003ef	d9 86 a4 00 00
	00		 fld	 DWORD PTR ?ShopC@@3PAVCShop@@A[esi+164]
  003f5	0f b6 96 15 01
	00 00		 movzx	 edx, BYTE PTR ?ShopC@@3PAVCShop@@A[esi+277]
  003fc	0f b6 86 14 01
	00 00		 movzx	 eax, BYTE PTR ?ShopC@@3PAVCShop@@A[esi+276]
  00403	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00409	51		 push	 ecx
  0040a	52		 push	 edx
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 __ftol2_sse
  00411	0f bf 8e 88 00
	00 00		 movsx	 ecx, WORD PTR ?ShopC@@3PAVCShop@@A[esi+136]
  00418	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  0041b	50		 push	 eax
  0041c	51		 push	 ecx
  0041d	8b 4d dc	 mov	 ecx, DWORD PTR tv718[ebp]
  00420	52		 push	 edx
  00421	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00426	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?g_sPCBangMaxPoint@@3FA ; g_sPCBangMaxPoint
  0042d	8b 93 2c 20 00
	00		 mov	 edx, DWORD PTR [ebx+8236]
  00433	50		 push	 eax
  00434	8b 45 d4	 mov	 eax, DWORD PTR _iShopNumber$[ebp]
  00437	50		 push	 eax
  00438	0f bf 47 18	 movsx	 eax, WORD PTR [edi+24]
  0043c	51		 push	 ecx
  0043d	52		 push	 edx
  0043e	50		 push	 eax
  0043f	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00442	51		 push	 ecx
  00443	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00446	52		 push	 edx
  00447	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@OPFCOMF@?$FLPCBangPointSystem?$FN?$FLBuyItem?$FN?$FL?$CFs?$FN@
  0044c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00452	83 c4 38	 add	 esp, 56			; 00000038H

; 980  : 			
; 981  : 			if( lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint < 0 )

  00455	83 bb 2c 20 00
	00 00		 cmp	 DWORD PTR [ebx+8236], 0
  0045c	7d 0a		 jge	 SHORT $LN2@PCBangBuyI

; 982  : 			{
; 983  : 				lpObj->m_PcBangPointSystem.m_iPcBangAccumulatedPoint = 0;

  0045e	c7 83 2c 20 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+8236], 0
$LN2@PCBangBuyI:

; 984  : 			}
; 985  : 
; 986  : 			this->EGReqUpdatePcBangResetPointInfo(aIndex); //Update Reset Time Date In Database

  00468	8b 5d e4	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  0046b	8b 75 d8	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  0046e	53		 push	 ebx
  0046f	8b ce		 mov	 ecx, esi
  00471	e8 00 00 00 00	 call	 ?EGReqUpdatePcBangResetPointInfo@CPCBangPointSystem@@QAEXH@Z ; CPCBangPointSystem::EGReqUpdatePcBangResetPointInfo

; 987  : 
; 988  : 			this->EGReqUpdatePcBangPointInfo(aIndex, this->m_PcBangSystem[iPos].BuyPoint); //Decrease Point in Database if Rank activated

  00476	0f b7 47 18	 movzx	 eax, WORD PTR [edi+24]
  0047a	50		 push	 eax
  0047b	53		 push	 ebx
  0047c	8b ce		 mov	 ecx, esi
  0047e	e8 00 00 00 00	 call	 ?EGReqUpdatePcBangPointInfo@CPCBangPointSystem@@QAEXHF@Z ; CPCBangPointSystem::EGReqUpdatePcBangPointInfo

; 999  : }

  00483	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00486	5f		 pop	 edi
  00487	5e		 pop	 esi
  00488	33 cd		 xor	 ecx, ebp
  0048a	b8 01 00 00 00	 mov	 eax, 1
  0048f	5b		 pop	 ebx
  00490	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00495	8b e5		 mov	 esp, ebp
  00497	5d		 pop	 ebp
  00498	c2 08 00	 ret	 8
$LN3@PCBangBuyI:

; 989  : 		}
; 990  : 		else
; 991  : 		{
; 992  : 			pMsg.Result = 3;
; 993  : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0049b	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0049f	51		 push	 ecx
  004a0	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  004a3	52		 push	 edx
  004a4	c6 45 ec 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3
  004a8	56		 push	 esi

; 994  : 			return 0;

  004a9	e9 da fb ff ff	 jmp	 $LN54@PCBangBuyI
?PCBangBuyItem@CPCBangPointSystem@@QAEHHE@Z ENDP	; CPCBangPointSystem::PCBangBuyItem
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_PCBangPointSystem@@YAXXZ
text$yc	SEGMENT
??__Eg_PCBangPointSystem@@YAXXZ PROC			; `dynamic initializer for 'g_PCBangPointSystem'', COMDAT

; 249  : CPCBangPointSystem g_PCBangPointSystem;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PCBangPointSystem@@3VCPCBangPointSystem@@A ; g_PCBangPointSystem
  00005	e8 00 00 00 00	 call	 ??0CPCBangPointSystem@@QAE@XZ ; CPCBangPointSystem::CPCBangPointSystem
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_PCBangPointSystem@@YAXXZ ; `dynamic atexit destructor for 'g_PCBangPointSystem''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_PCBangPointSystem@@YAXXZ ENDP			; `dynamic initializer for 'g_PCBangPointSystem''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_PCBangPointSystem@@YAXXZ
text$yd	SEGMENT
??__Fg_PCBangPointSystem@@YAXXZ PROC			; `dynamic atexit destructor for 'g_PCBangPointSystem'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PCBangPointSystem@@3VCPCBangPointSystem@@A ; g_PCBangPointSystem
  00005	e9 00 00 00 00	 jmp	 ??1CPCBangPointSystem@@UAE@XZ ; CPCBangPointSystem::~CPCBangPointSystem
??__Fg_PCBangPointSystem@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_PCBangPointSystem''
text$yd	ENDS
PUBLIC	?g_PCBangPointSystem@@3VCPCBangPointSystem@@A	; g_PCBangPointSystem
_BSS	SEGMENT
?g_PCBangPointSystem@@3VCPCBangPointSystem@@A DB 0a4H DUP (?) ; g_PCBangPointSystem
_BSS	ENDS
CRT$XCU	SEGMENT
_g_PCBangPointSystem$initializer$ DD FLAT:??__Eg_PCBangPointSystem@@YAXXZ
CRT$XCU	ENDS
END
