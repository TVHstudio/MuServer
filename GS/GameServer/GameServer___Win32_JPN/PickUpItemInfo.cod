; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\PickUpItemInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CPickUpItemInfo@@QAE@XZ			; CPickUpItemInfo::CPickUpItemInfo
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\pickupiteminfo.cpp
;	COMDAT ??0CPickUpItemInfo@@QAE@XZ
_TEXT	SEGMENT
??0CPickUpItemInfo@@QAE@XZ PROC				; CPickUpItemInfo::CPickUpItemInfo, COMDAT
; _this$ = ecx

; 12   : {

  00000	8b c1		 mov	 eax, ecx

; 13   : }

  00002	c3		 ret	 0
??0CPickUpItemInfo@@QAE@XZ ENDP				; CPickUpItemInfo::CPickUpItemInfo
_TEXT	ENDS
PUBLIC	??1CPickUpItemInfo@@QAE@XZ			; CPickUpItemInfo::~CPickUpItemInfo
; Function compile flags: /Ogtp
;	COMDAT ??1CPickUpItemInfo@@QAE@XZ
_TEXT	SEGMENT
??1CPickUpItemInfo@@QAE@XZ PROC				; CPickUpItemInfo::~CPickUpItemInfo, COMDAT
; _this$ = ecx

; 17   : }

  00000	c3		 ret	 0
??1CPickUpItemInfo@@QAE@XZ ENDP				; CPickUpItemInfo::~CPickUpItemInfo
_TEXT	ENDS
PUBLIC	?Init@CPickUpItemInfo@@QAEXXZ			; CPickUpItemInfo::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CPickUpItemInfo@@QAEXXZ
_TEXT	SEGMENT
?Init@CPickUpItemInfo@@QAEXXZ PROC			; CPickUpItemInfo::Init, COMDAT
; _this$ = ecx

; 21   : }

  00000	c3		 ret	 0
?Init@CPickUpItemInfo@@QAEXXZ ENDP			; CPickUpItemInfo::Init
_TEXT	ENDS
PUBLIC	?Load@CPickUpItemInfo@@QAEXXZ			; CPickUpItemInfo::Load
; Function compile flags: /Ogtp
;	COMDAT ?Load@CPickUpItemInfo@@QAEXXZ
_TEXT	SEGMENT
?Load@CPickUpItemInfo@@QAEXXZ PROC			; CPickUpItemInfo::Load, COMDAT
; _this$ = ecx

; 25   : 	this->Init();
; 26   : }

  00000	c3		 ret	 0
?Load@CPickUpItemInfo@@QAEXXZ ENDP			; CPickUpItemInfo::Load
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?InfoRecv@CPickUpItemInfo@@QAEXPAUPMSG_REQ_PICKUP_INFO@@H@Z ; CPickUpItemInfo::InfoRecv
EXTRN	?ItemByteConvert@@YAXPAEHEEEEEEEEEQAEEE@Z:PROC	; ItemByteConvert
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?InfoRecv@CPickUpItemInfo@@QAEXPAUPMSG_REQ_PICKUP_INFO@@H@Z
_TEXT	SEGMENT
tv324 = -36						; size = 4
tv322 = -36						; size = 4
tv327 = -30						; size = 2
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?InfoRecv@CPickUpItemInfo@@QAEXPAUPMSG_REQ_PICKUP_INFO@@H@Z PROC ; CPickUpItemInfo::InfoRecv, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 30   : 	if(!g_ZtLicense.user.PickUpItemInfo)

  00010	80 3d f1 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+241, 0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001e	0f 84 61 01 00
	00		 je	 $LN5@InfoRecv

; 31   : 	{
; 32   : 		return;
; 33   : 	}
; 34   : 
; 35   : 	if(!OBJMAX_RANGE(aIndex))

  00024	85 f6		 test	 esi, esi
  00026	0f 88 59 01 00
	00		 js	 $LN5@InfoRecv
  0002c	33 c0		 xor	 eax, eax
  0002e	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00034	0f 9e c0	 setle	 al
  00037	85 c0		 test	 eax, eax
  00039	0f 84 46 01 00
	00		 je	 $LN5@InfoRecv

; 36   : 	{
; 37   : 		return;
; 38   : 	}
; 39   : 
; 40   : 	PMSG_ANS_PICKUP_INFO pMsg;
; 41   : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xBF, sizeof(pMsg));
; 42   : 
; 43   : 	int item_num = lpMsg->ItemNum;

  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	c7 45 e4 c1 18
	fb bf		 mov	 DWORD PTR _pMsg$[ebp], -1074063167 ; bffb18c1H

; 44   : 
; 45   : 	if ( MAX_ITEM_TYPE_RANGE(item_num) == FALSE )

  00049	85 c9		 test	 ecx, ecx
  0004b	78 0f		 js	 SHORT $LN15@InfoRecv
  0004d	33 c0		 xor	 eax, eax
  0004f	81 f9 2b 01 00
	00		 cmp	 ecx, 299		; 0000012bH
  00055	0f 9e c0	 setle	 al
  00058	85 c0		 test	 eax, eax
  0005a	75 24		 jne	 SHORT $LN2@InfoRecv
$LN15@InfoRecv:

; 46   : 	{
; 47   : 		pMsg.result = 0;
; 48   : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0005c	6a 18		 push	 24			; 00000018H
  0005e	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	5e		 pop	 esi

; 83   : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN2@InfoRecv:

; 49   : 		return;
; 50   : 	}
; 51   : 
; 52   : 	int map_num = gObj[aIndex].MapNumber;

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	8b d6		 mov	 edx, esi
  00087	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0008d	0f b6 84 02 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+eax+329]

; 53   : 
; 54   : 	if ( MAX_MAP_RANGE(map_num) == FALSE )

  00095	85 c0		 test	 eax, eax
  00097	78 0c		 js	 SHORT $LN16@InfoRecv
  00099	33 d2		 xor	 edx, edx
  0009b	83 f8 52	 cmp	 eax, 82			; 00000052H
  0009e	0f 9e c2	 setle	 dl
  000a1	85 d2		 test	 edx, edx
  000a3	75 24		 jne	 SHORT $LN1@InfoRecv
$LN16@InfoRecv:

; 55   : 	{
; 56   : 		pMsg.result = 0;
; 57   : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000a5	6a 18		 push	 24			; 00000018H
  000a7	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000aa	51		 push	 ecx
  000ab	56		 push	 esi
  000ac	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  000b0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	5e		 pop	 esi

; 83   : }

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	33 cd		 xor	 ecx, ebp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
$LN1@InfoRecv:

; 58   : 		return;
; 59   : 	}
; 60   : 
; 61   : 	CMapItem * lpItem = &MapC[map_num].m_cItem[item_num];

  000c9	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  000cf	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H

; 62   : 
; 63   : 	pMsg.result = 1;
; 64   : 
; 65   : 	pMsg.Type = lpItem->m_Type;
; 66   : 	pMsg.Durability = lpItem->m_Durability;
; 67   : 
; 68   : 	ItemByteConvert((LPBYTE)&pMsg.Data[0], 
; 69   : 		lpItem->m_Type, 
; 70   : 		lpItem->m_Option1, 
; 71   : 		lpItem->m_Option2,	
; 72   : 		lpItem->m_Option3, 
; 73   : 		(BYTE)lpItem->m_Level, 
; 74   : 		(BYTE)lpItem->m_Durability, 
; 75   : 		lpItem->m_NewOption, 
; 76   : 		lpItem->m_SetOption, 
; 77   : 		lpItem->m_JewelOfHarmonyOption, 
; 78   : 		lpItem->m_ItemOptionEx, 
; 79   : 		lpItem->m_SocketOption, 
; 80   : 		(BYTE)lpItem->m_SocketOptionIndex, 0);

  000d5	d9 7d e2	 fnstcw	 WORD PTR tv327[ebp]
  000d8	d9 84 08 48 00
	00 00		 fld	 DWORD PTR ?MapC@@3PAVMapClass@@A[eax+ecx+72]
  000df	d9 5d ec	 fstp	 DWORD PTR _pMsg$[ebp+8]
  000e2	d9 84 08 48 00
	00 00		 fld	 DWORD PTR ?MapC@@3PAVMapClass@@A[eax+ecx+72]
  000e9	8d 8c 08 20 00
	00 00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+ecx+32]
  000f0	0f b6 81 cf 00
	00 00		 movzx	 eax, BYTE PTR [ecx+207]
  000f7	6a 00		 push	 0
  000f9	50		 push	 eax
  000fa	8d 81 d0 00 00
	00		 lea	 eax, DWORD PTR [ecx+208]
  00100	50		 push	 eax
  00101	0f b6 81 ce 00
	00 00		 movzx	 eax, BYTE PTR [ecx+206]
  00108	50		 push	 eax
  00109	0f b6 81 c8 00
	00 00		 movzx	 eax, BYTE PTR [ecx+200]
  00110	50		 push	 eax
  00111	0f b6 81 b2 00
	00 00		 movzx	 eax, BYTE PTR [ecx+178]
  00118	50		 push	 eax
  00119	0f b6 81 9b 00
	00 00		 movzx	 eax, BYTE PTR [ecx+155]
  00120	50		 push	 eax
  00121	0f b7 45 e2	 movzx	 eax, WORD PTR tv327[ebp]
  00125	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0012a	89 45 dc	 mov	 DWORD PTR tv324[ebp], eax
  0012d	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  00131	d9 6d dc	 fldcw	 WORD PTR tv324[ebp]
  00134	66 89 55 ea	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00138	0f bf d2	 movsx	 edx, dx
  0013b	db 5d dc	 fistp	 DWORD PTR tv322[ebp]
  0013e	c6 45 e8 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  00142	8a 45 dc	 mov	 al, BYTE PTR tv322[ebp]
  00145	0f b6 c0	 movzx	 eax, al
  00148	50		 push	 eax
  00149	0f b6 41 0c	 movzx	 eax, BYTE PTR [ecx+12]
  0014d	d9 6d e2	 fldcw	 WORD PTR tv327[ebp]
  00150	50		 push	 eax
  00151	0f b6 81 9a 00
	00 00		 movzx	 eax, BYTE PTR [ecx+154]
  00158	50		 push	 eax
  00159	0f b6 81 99 00
	00 00		 movzx	 eax, BYTE PTR [ecx+153]
  00160	0f b6 89 98 00
	00 00		 movzx	 ecx, BYTE PTR [ecx+152]
  00167	50		 push	 eax
  00168	51		 push	 ecx
  00169	52		 push	 edx
  0016a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp+12]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEHEEEEEEEEEQAEEE@Z ; ItemByteConvert

; 81   : 
; 82   : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00173	0f b6 4d e5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00177	51		 push	 ecx
  00178	8d 55 e4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0017b	52		 push	 edx
  0017c	56		 push	 esi
  0017d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00182	83 c4 44	 add	 esp, 68			; 00000044H
$LN5@InfoRecv:

; 83   : }

  00185	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00188	33 cd		 xor	 ecx, ebp
  0018a	5e		 pop	 esi
  0018b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c2 08 00	 ret	 8
?InfoRecv@CPickUpItemInfo@@QAEXPAUPMSG_REQ_PICKUP_INFO@@H@Z ENDP ; CPickUpItemInfo::InfoRecv
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_PickUpItemInfo@@YAXXZ
text$yc	SEGMENT
??__Eg_PickUpItemInfo@@YAXXZ PROC			; `dynamic initializer for 'g_PickUpItemInfo'', COMDAT

; 9    : CPickUpItemInfo g_PickUpItemInfo;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_PickUpItemInfo@@YAXXZ ; `dynamic atexit destructor for 'g_PickUpItemInfo''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Eg_PickUpItemInfo@@YAXXZ ENDP			; `dynamic initializer for 'g_PickUpItemInfo''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_PickUpItemInfo@@YAXXZ
text$yd	SEGMENT
??__Fg_PickUpItemInfo@@YAXXZ PROC			; `dynamic atexit destructor for 'g_PickUpItemInfo'', COMDAT
  00000	c3		 ret	 0
??__Fg_PickUpItemInfo@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_PickUpItemInfo''
text$yd	ENDS
PUBLIC	?g_PickUpItemInfo@@3VCPickUpItemInfo@@A		; g_PickUpItemInfo
_BSS	SEGMENT
?g_PickUpItemInfo@@3VCPickUpItemInfo@@A DB 01H DUP (?)	; g_PickUpItemInfo
_BSS	ENDS
CRT$XCU	SEGMENT
_g_PickUpItemInfo$initializer$ DD FLAT:??__Eg_PickUpItemInfo@@YAXXZ
CRT$XCU	ENDS
END
