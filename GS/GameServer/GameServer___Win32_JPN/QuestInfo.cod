; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\QuestInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?QuestBitMask@@3PAEA				; QuestBitMask
PUBLIC	?sQuestString@@3PAY0DC@DA			; sQuestString
_BSS	SEGMENT
?QuestBitMask@@3PAEA DB 08H DUP (?)			; QuestBitMask
_BSS	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
?sQuestString@@3PAY0DC@DA DB 'None', 00H		; sQuestString
	ORG $+45
	DB	'Accept', 00H
	ORG $+43
	DB	'Clear', 00H
	ORG $+44
	DB	'None', 00H
	ORG $+45
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetQeustCount@CQuestInfo@@QAEHXZ		; CQuestInfo::GetQeustCount
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\questinfo.h
;	COMDAT ?GetQeustCount@CQuestInfo@@QAEHXZ
_TEXT	SEGMENT
?GetQeustCount@CQuestInfo@@QAEHXZ PROC			; CQuestInfo::GetQeustCount, COMDAT
; _this$ = ecx

; 102  : 	int GetQeustCount(){return m_QuestCount;}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetQeustCount@CQuestInfo@@QAEHXZ ENDP			; CQuestInfo::GetQeustCount
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_7CQuestInfo@@6B@				; CQuestInfo::`vftable'
PUBLIC	??1CQuestInfo@@UAE@XZ				; CQuestInfo::~CQuestInfo
PUBLIC	??_R4CQuestInfo@@6B@				; CQuestInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCQuestInfo@@@8				; CQuestInfo `RTTI Type Descriptor'
PUBLIC	??_R3CQuestInfo@@8				; CQuestInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CQuestInfo@@8				; CQuestInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CQuestInfo@@8			; CQuestInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECQuestInfo@@UAEPAXI@Z:PROC			; CQuestInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CQuestInfo@@8
; File e:\work\tranet_version\gs\gameserver\questinfo.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CQuestInfo@@8 DD FLAT:??_R0?AVCQuestInfo@@@8 ; CQuestInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CQuestInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CQuestInfo@@8
rdata$r	SEGMENT
??_R2CQuestInfo@@8 DD FLAT:??_R1A@?0A@EA@CQuestInfo@@8	; CQuestInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CQuestInfo@@8
rdata$r	SEGMENT
??_R3CQuestInfo@@8 DD 00H				; CQuestInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CQuestInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCQuestInfo@@@8
_DATA	SEGMENT
??_R0?AVCQuestInfo@@@8 DD FLAT:??_7type_info@@6B@	; CQuestInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCQuestInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CQuestInfo@@6B@
rdata$r	SEGMENT
??_R4CQuestInfo@@6B@ DD 00H				; CQuestInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCQuestInfo@@@8
	DD	FLAT:??_R3CQuestInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CQuestInfo@@6B@
CONST	SEGMENT
??_7CQuestInfo@@6B@ DD FLAT:??_R4CQuestInfo@@6B@	; CQuestInfo::`vftable'
	DD	FLAT:??_ECQuestInfo@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CQuestInfo@@UAE@XZ
_TEXT	SEGMENT
??1CQuestInfo@@UAE@XZ PROC				; CQuestInfo::~CQuestInfo, COMDAT
; _this$ = ecx

; 42   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CQuestInfo@@6B@

; 43   : 	return;
; 44   : }

  00006	c3		 ret	 0
??1CQuestInfo@@UAE@XZ ENDP				; CQuestInfo::~CQuestInfo
_TEXT	ENDS
PUBLIC	?Init@CQuestInfo@@QAEXXZ			; CQuestInfo::Init
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Init@CQuestInfo@@QAEXXZ
_TEXT	SEGMENT
?Init@CQuestInfo@@QAEXXZ PROC				; CQuestInfo::Init, COMDAT
; _this$ = ecx

; 47   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 48   : 	this->m_QuestCount = 0;
; 49   : 	memset(this->QuestInfo, -1, sizeof(this->QuestInfo));

  00003	68 80 45 03 00	 push	 214400			; 00034580H
  00008	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000b	6a ff		 push	 -1
  0000d	50		 push	 eax
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  00020	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00025	5e		 pop	 esi
  00026	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL3@Init:

; 50   : 
; 51   : 	for ( int i=0;i<MAX_QUEST_INFO;i++)
; 52   : 	{
; 53   : 		this->QuestInfo[i].QuestConditionCount=0;

  00030	c7 80 d4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+724], 0

; 54   : 		this->QuestInfo[i].QuestSubInfoCount= 0;

  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00040	05 30 04 00 00	 add	 eax, 1072		; 00000430H
  00045	49		 dec	 ecx
  00046	75 e8		 jne	 SHORT $LL3@Init

; 55   : 	}
; 56   : }

  00048	c3		 ret	 0
?Init@CQuestInfo@@QAEXXZ ENDP				; CQuestInfo::Init
_TEXT	ENDS
PUBLIC	?IsQuest@CQuestInfo@@QAEHH@Z			; CQuestInfo::IsQuest
; Function compile flags: /Ogtp
;	COMDAT ?IsQuest@CQuestInfo@@QAEHH@Z
_TEXT	SEGMENT
_QuestIndex$ = 8					; size = 4
?IsQuest@CQuestInfo@@QAEHH@Z PROC			; CQuestInfo::IsQuest, COMDAT
; _this$ = ecx

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 482  : 	if ( QuestIndex < 0 || QuestIndex > MAX_QUEST_INFO )

  00003	8b 45 08	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00006	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0000b	77 16		 ja	 SHORT $LN2@IsQuest

; 485  : 	}
; 486  : 
; 487  : 	if ( this->QuestInfo[QuestIndex].QuestIndex == -1 )

  0000d	69 c0 30 04 00
	00		 imul	 eax, 1072		; 00000430H
  00013	33 d2		 xor	 edx, edx
  00015	83 7c 08 3c ff	 cmp	 DWORD PTR [eax+ecx+60], -1
  0001a	0f 95 c2	 setne	 dl
  0001d	8b c2		 mov	 eax, edx

; 488  : 	{
; 489  : 		return false;
; 490  : 	}
; 491  : 
; 492  : 	return true;
; 493  : }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN2@IsQuest:

; 483  : 	{
; 484  : 		return false;

  00023	33 c0		 xor	 eax, eax

; 488  : 	{
; 489  : 		return false;
; 490  : 	}
; 491  : 
; 492  : 	return true;
; 493  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?IsQuest@CQuestInfo@@QAEHH@Z ENDP			; CQuestInfo::IsQuest
_TEXT	ENDS
PUBLIC	?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
; Function compile flags: /Ogtp
;	COMDAT ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z PROC ; CQuestInfo::GetQuestState, COMDAT
; _this$ = ecx

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 498  : 	if ( QuestIndex < 0 || QuestIndex > MAX_QUEST_INFO )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _QuestIndex$[ebp]
  00006	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  0000c	77 2e		 ja	 SHORT $LN1@GetQuestSt

; 501  : 	}
; 502  : 
; 503  : 	int index = (QuestIndex) /4;

  0000e	8b c1		 mov	 eax, ecx
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx

; 505  : 	return (lpObj->m_Quest[index] >> shift) &3;

  00016	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00019	c1 f8 02	 sar	 eax, 2
  0001c	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  00022	0f b6 84 10 8c
	10 00 00	 movzx	 eax, BYTE PTR [eax+edx+4236]
  0002a	79 05		 jns	 SHORT $LN5@GetQuestSt

; 504  : 	int shift = (QuestIndex % 4) *2;

  0002c	49		 dec	 ecx
  0002d	83 c9 fc	 or	 ecx, -4			; fffffffcH
  00030	41		 inc	 ecx
$LN5@GetQuestSt:
  00031	02 c9		 add	 cl, cl

; 505  : 	return (lpObj->m_Quest[index] >> shift) &3;

  00033	d3 e8		 shr	 eax, cl
  00035	83 e0 03	 and	 eax, 3

; 506  : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN1@GetQuestSt:

; 499  : 	{
; 500  : 		return false;

  0003c	33 c0		 xor	 eax, eax

; 506  : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP ; CQuestInfo::GetQuestState
_TEXT	ENDS
PUBLIC	?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
; Function compile flags: /Ogtp
;	COMDAT ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z PROC ; CQuestInfo::GetQuestStateBYTE, COMDAT
; _this$ = ecx

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 510  : 	if ( QuestIndex < 0 || QuestIndex > MAX_QUEST_INFO )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00006	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0000b	77 17		 ja	 SHORT $LN1@GetQuestSt@2

; 513  : 	}
; 514  : 	
; 515  : 	int index = (QuestIndex / 4);
; 516  : 	return lpObj->m_Quest[index];

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00010	99		 cdq
  00011	83 e2 03	 and	 edx, 3
  00014	03 c2		 add	 eax, edx
  00016	c1 f8 02	 sar	 eax, 2
  00019	8a 84 08 8c 10
	00 00		 mov	 al, BYTE PTR [eax+ecx+4236]

; 517  : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN1@GetQuestSt@2:

; 511  : 	{
; 512  : 		return false;

  00024	32 c0		 xor	 al, al

; 517  : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ENDP ; CQuestInfo::GetQuestStateBYTE
_TEXT	ENDS
PUBLIC	?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState
; Function compile flags: /Ogtp
;	COMDAT ?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z PROC ; CQuestInfo::ReSetQuestState, COMDAT
; _this$ = ecx

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 568  : 	int State = 3;
; 569  : 	int index = (QuestIndex/4);

  00005	8b 75 0c	 mov	 esi, DWORD PTR _QuestIndex$[ebp]
  00008	8b c6		 mov	 eax, esi
  0000a	99		 cdq
  0000b	83 e2 03	 and	 edx, 3
  0000e	57		 push	 edi
  0000f	8d 3c 02	 lea	 edi, DWORD PTR [edx+eax]
  00012	c1 ff 02	 sar	 edi, 2

; 570  : 	int shift = (QuestIndex % 4)*2;

  00015	81 e6 03 00 00
	80		 and	 esi, -2147483645	; 80000003H
  0001b	79 05		 jns	 SHORT $LN3@ReSetQuest
  0001d	4e		 dec	 esi
  0001e	83 ce fc	 or	 esi, -4			; fffffffcH
  00021	46		 inc	 esi
$LN3@ReSetQuest:

; 571  : 	lpObj->m_Quest[index] &= QuestBitMask[shift];

  00022	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00025	8a 94 36 00 00
	00 00		 mov	 dl, BYTE PTR ?QuestBitMask@@3PAEA[esi+esi]
  0002c	22 94 07 8c 10
	00 00		 and	 dl, BYTE PTR [edi+eax+4236]
  00033	03 f6		 add	 esi, esi

; 572  : 	lpObj->m_Quest[index] |= (State&3) << shift;

  00035	b3 03		 mov	 bl, 3
  00037	8b ce		 mov	 ecx, esi
  00039	d2 e3		 shl	 bl, cl
  0003b	0a d3		 or	 dl, bl
  0003d	88 94 07 8c 10
	00 00		 mov	 BYTE PTR [edi+eax+4236], dl
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 573  : 
; 574  : 	return 0;

  00046	32 c0		 xor	 al, al
  00048	5b		 pop	 ebx

; 575  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?ReSetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ENDP ; CQuestInfo::ReSetQuestState
_TEXT	ENDS
PUBLIC	?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z	; CQuestInfo::GetQuestInfo
; Function compile flags: /Ogtp
;	COMDAT ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z
_TEXT	SEGMENT
_QuestIndex$ = 8					; size = 4
?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z PROC	; CQuestInfo::GetQuestInfo, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  : 	if ( QuestIndex < 0 || QuestIndex > MAX_QUEST_INFO )

  00003	8b 45 08	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00006	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0000b	77 15		 ja	 SHORT $LN2@GetQuestIn

; 582  : 	}
; 583  : 	
; 584  : 	if ( this->QuestInfo[QuestIndex].QuestIndex == -1 )

  0000d	69 c0 30 04 00
	00		 imul	 eax, 1072		; 00000430H
  00013	03 c1		 add	 eax, ecx
  00015	83 78 3c ff	 cmp	 DWORD PTR [eax+60], -1

; 585  : 	{
; 586  : 		return NULL;

  00019	74 07		 je	 SHORT $LN2@GetQuestIn

; 587  : 	}
; 588  : 
; 589  : 	return &this->QuestInfo[QuestIndex];

  0001b	83 c0 08	 add	 eax, 8

; 590  : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN2@GetQuestIn:

; 580  : 	{
; 581  : 		return false;

  00022	33 c0		 xor	 eax, eax

; 590  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ENDP	; CQuestInfo::GetQuestInfo
_TEXT	ENDS
PUBLIC	?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
; Function compile flags: /Ogtp
;	COMDAT ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpQuestInfo$ = 12					; size = 4
_subquestindex$ = 16					; size = 4
?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z PROC ; CQuestInfo::GetSubquestInfo, COMDAT
; _this$ = ecx

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 	if ( lpQuestInfo == NULL )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _lpQuestInfo$[ebp]
  00006	85 c9		 test	 ecx, ecx

; 595  : 	{
; 596  : 		return NULL;

  00008	74 33		 je	 SHORT $LN4@GetSubques

; 597  : 	}
; 598  : 
; 599  : 	if ( subquestindex < 0 || subquestindex > MAX_SUBINFO_QUEST )

  0000a	8b 45 10	 mov	 eax, DWORD PTR _subquestindex$[ebp]
  0000d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00010	77 2b		 ja	 SHORT $LN4@GetSubques

; 602  : 	}
; 603  : 
; 604  : 	LPQUEST_SUB_INFO lpSubInfo = &lpQuestInfo->QuestSubInfo[subquestindex];
; 605  : 	int Class = lpObj->Class;
; 606  : 	int ChangeUP = lpObj->ChangeUP;
; 607  : 	int requireclass = lpSubInfo->RequireClass[Class];

  00012	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00015	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00018	8d 44 c1 44	 lea	 eax, DWORD PTR [ecx+eax*8+68]
  0001c	0f b7 8a b8 00
	00 00		 movzx	 ecx, WORD PTR [edx+184]
  00023	0f b6 4c 01 40	 movzx	 ecx, BYTE PTR [ecx+eax+64]

; 608  : 
; 609  : 	if ( requireclass == 0 )

  00028	85 c9		 test	 ecx, ecx

; 610  : 	{
; 611  : 		return NULL;

  0002a	74 11		 je	 SHORT $LN4@GetSubques

; 612  : 	}
; 613  : 
; 614  : 	if ( requireclass > 1 )

  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	7e 0e		 jle	 SHORT $LN7@GetSubques

; 615  : 	{
; 616  : 		if ( requireclass != (ChangeUP + 1) )

  00031	0f b6 92 bb 00
	00 00		 movzx	 edx, BYTE PTR [edx+187]
  00038	42		 inc	 edx
  00039	3b ca		 cmp	 ecx, edx

; 617  : 		{
; 618  : 			return NULL;
; 619  : 		}
; 620  : 	}
; 621  : 
; 622  : 	return lpSubInfo;

  0003b	74 02		 je	 SHORT $LN7@GetSubques
$LN4@GetSubques:

; 600  : 	{
; 601  : 		return NULL;

  0003d	33 c0		 xor	 eax, eax
$LN7@GetSubques:

; 623  : }

  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ENDP ; CQuestInfo::GetSubquestInfo
_TEXT	ENDS
PUBLIC	?GetQuestCondition@CQuestInfo@@QAEPAUQUEST_CONDITION@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestCondition
; Function compile flags: /Ogtp
;	COMDAT ?GetQuestCondition@CQuestInfo@@QAEPAUQUEST_CONDITION@@PAUQUEST_INFO@@H@Z
_TEXT	SEGMENT
_lpQuestInfo$ = 8					; size = 4
_conditionindex$ = 12					; size = 4
?GetQuestCondition@CQuestInfo@@QAEPAUQUEST_CONDITION@@PAUQUEST_INFO@@H@Z PROC ; CQuestInfo::GetQuestCondition, COMDAT
; _this$ = ecx

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 	if ( lpQuestInfo == NULL )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpQuestInfo$[ebp]
  00006	85 c9		 test	 ecx, ecx

; 628  : 	{
; 629  : 		return NULL;

  00008	74 1c		 je	 SHORT $LN1@GetQuestCo

; 630  : 	}
; 631  : 
; 632  : 	if ( conditionindex < 0 || conditionindex > MAX_CONDITION_QUEST )

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _conditionindex$[ebp]
  0000d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00010	77 14		 ja	 SHORT $LN1@GetQuestCo

; 635  : 	}
; 636  : 
; 637  : 	return &lpQuestInfo->QuestCondition[conditionindex];

  00012	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00019	2b d0		 sub	 edx, eax
  0001b	8d 84 91 18 03
	00 00		 lea	 eax, DWORD PTR [ecx+edx*4+792]

; 638  : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN1@GetQuestCo:

; 633  : 	{
; 634  : 		return NULL;

  00026	33 c0		 xor	 eax, eax

; 638  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?GetQuestCondition@CQuestInfo@@QAEPAUQUEST_CONDITION@@PAUQUEST_INFO@@H@Z ENDP ; CQuestInfo::GetQuestCondition
_TEXT	ENDS
PUBLIC	?QuestClearConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestClearConditionCheck
EXTRN	?gObjGetItemCountInIventory@@YAHHHHH@Z:PROC	; gObjGetItemCountInIventory
; Function compile flags: /Ogtp
;	COMDAT ?QuestClearConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_subquestcount$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_bFoundSubQuest$ = 12					; size = 4
_QuestIndex$ = 12					; size = 4
?QuestClearConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z PROC ; CQuestInfo::QuestClearConditionCheck, COMDAT
; _this$ = ecx

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 642  : 	LPQUEST_INFO lpQuestInfo = this->GetQuestInfo(QuestIndex);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00014	8b d8		 mov	 ebx, eax

; 643  : 
; 644  : 	if ( lpQuestInfo == NULL )

  00016	33 ff		 xor	 edi, edi
  00018	3b df		 cmp	 ebx, edi
  0001a	75 0a		 jne	 SHORT $LN8@QuestClear

; 645  : 	{
; 646  : 		return -1;

  0001c	5f		 pop	 edi
  0001d	0c ff		 or	 al, 255			; 000000ffH
  0001f	5b		 pop	 ebx

; 680  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN8@QuestClear:

; 647  : 	}
; 648  : 
; 649  : 	int subquestcount = lpQuestInfo->QuestSubInfoCount;

  00026	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00029	56		 push	 esi
  0002a	89 45 f8	 mov	 DWORD PTR _subquestcount$[ebp], eax

; 650  : 	int concount = lpQuestInfo->QuestConditionCount;
; 651  : 	LPQUEST_SUB_INFO lpSubInfo;
; 652  : 	BOOL bFoundSubQuest = FALSE;

  0002d	89 7d 0c	 mov	 DWORD PTR _bFoundSubQuest$[ebp], edi

; 653  : 	
; 654  : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  00030	3b c7		 cmp	 eax, edi
  00032	7e 4d		 jle	 SHORT $LN14@QuestClear
  00034	eb 03		 jmp	 SHORT $LN7@QuestClear
$LL15@QuestClear:
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@QuestClear:

; 655  : 	{
; 656  : 		lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, subquest);

  00039	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003c	57		 push	 edi
  0003d	53		 push	 ebx
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
  00044	8b f0		 mov	 esi, eax

; 657  : 
; 658  : 		if ( lpSubInfo != NULL )

  00046	85 f6		 test	 esi, esi
  00048	74 2b		 je	 SHORT $LN6@QuestClear

; 659  : 		{
; 660  : 			bFoundSubQuest = TRUE;
; 661  : 
; 662  : 			if ( lpSubInfo->QuestType == 1 )

  0004a	83 3e 01	 cmp	 DWORD PTR [esi], 1
  0004d	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _bFoundSubQuest$[ebp], 1
  00054	75 1f		 jne	 SHORT $LN6@QuestClear

; 663  : 			{
; 664  : 				int NumberItemQuestFound = gObjGetItemCountInIventory(lpObj->m_Index, lpSubInfo->NeedType, lpSubInfo->NeedSubType, lpSubInfo->ItemLevel);

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0005c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0005f	50		 push	 eax
  00060	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	51		 push	 ecx
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	52		 push	 edx
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 665  : 
; 666  : 				if ( NumberItemQuestFound < lpSubInfo->NeedNumber)

  00070	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00073	7c 17		 jl	 SHORT $LN12@QuestClear
$LN6@QuestClear:

; 653  : 	
; 654  : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  00075	47		 inc	 edi
  00076	3b 7d f8	 cmp	 edi, DWORD PTR _subquestcount$[ebp]
  00079	7c bb		 jl	 SHORT $LL15@QuestClear

; 669  : 				}
; 670  : 			}
; 671  : 		}
; 672  : 	}
; 673  : 
; 674  : 	if ( bFoundSubQuest == FALSE )

  0007b	83 7d 0c 00	 cmp	 DWORD PTR _bFoundSubQuest$[ebp], 0
  0007f	75 16		 jne	 SHORT $LN1@QuestClear
$LN14@QuestClear:
  00081	5e		 pop	 esi
  00082	5f		 pop	 edi

; 675  : 	{
; 676  : 		return -1;

  00083	0c ff		 or	 al, 255			; 000000ffH
  00085	5b		 pop	 ebx

; 680  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN12@QuestClear:
  0008c	5e		 pop	 esi
  0008d	5f		 pop	 edi

; 667  : 				{
; 668  : 					return 1;

  0008e	b0 01		 mov	 al, 1
  00090	5b		 pop	 ebx

; 680  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
$LN1@QuestClear:
  00097	5e		 pop	 esi
  00098	5f		 pop	 edi

; 677  : 	}
; 678  : 
; 679  : 	return 0;

  00099	32 c0		 xor	 al, al
  0009b	5b		 pop	 ebx

; 680  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
?QuestClearConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ENDP ; CQuestInfo::QuestClearConditionCheck
_TEXT	ENDS
PUBLIC	?CompareCondition@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@PAUQUEST_CONDITION@@@Z ; CQuestInfo::CompareCondition
; Function compile flags: /Ogtp
;	COMDAT ?CompareCondition@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@PAUQUEST_CONDITION@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpCondition$ = 12					; size = 4
?CompareCondition@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@PAUQUEST_CONDITION@@@Z PROC ; CQuestInfo::CompareCondition, COMDAT
; _this$ = ecx

; 742  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 743  : 	if ( lpCondition->NeedQuestIndex != -1 )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _lpCondition$[ebp]
  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000e	83 f8 ff	 cmp	 eax, -1
  00011	74 14		 je	 SHORT $LN7@CompareCon

; 744  : 	{
; 745  : 		if ( this->GetQuestState(lpObj, lpCondition->NeedQuestIndex) != 2 )

  00013	50		 push	 eax
  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  0001a	83 f8 02	 cmp	 eax, 2
  0001d	74 08		 je	 SHORT $LN7@CompareCon
$LN11@CompareCon:
  0001f	5f		 pop	 edi

; 746  : 		{
; 747  : 			return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	5e		 pop	 esi

; 773  : 	{
; 774  : 		return FALSE;
; 775  : 	}
; 776  : 
; 777  : 	return TRUE;
; 778  : 
; 779  : }

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN7@CompareCon:

; 748  : 		}
; 749  : 	}
; 750  : 
; 751  : 	if ( lpCondition->MinLevel != 0 )

  00027	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0002a	85 c0		 test	 eax, eax
  0002c	74 0b		 je	 SHORT $LN5@CompareCon

; 752  : 	{
; 753  : 		if ( lpCondition->MinLevel > lpObj->Level )

  0002e	0f bf 8f be 00
	00 00		 movsx	 ecx, WORD PTR [edi+190]
  00035	3b c1		 cmp	 eax, ecx

; 754  : 		{
; 755  : 			return FALSE;

  00037	7f e6		 jg	 SHORT $LN11@CompareCon
$LN5@CompareCon:

; 756  : 		}
; 757  : 	}
; 758  : 
; 759  : 	if ( lpCondition->MaxLevel != 0 )

  00039	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 0b		 je	 SHORT $LN3@CompareCon

; 760  : 	{
; 761  : 		if ( lpCondition->MaxLevel < lpObj->Level )

  00040	0f bf 97 be 00
	00 00		 movsx	 edx, WORD PTR [edi+190]
  00047	3b c2		 cmp	 eax, edx

; 762  : 		{
; 763  : 			return FALSE;

  00049	7c d4		 jl	 SHORT $LN11@CompareCon
$LN3@CompareCon:

; 764  : 		}
; 765  : 	}
; 766  : 
; 767  : 	if ( lpCondition->NeedZen > lpObj->Money )

  0004b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0004e	3b 87 f0 00 00
	00		 cmp	 eax, DWORD PTR [edi+240]

; 768  : 	{
; 769  : 		return FALSE;

  00054	7f c9		 jg	 SHORT $LN11@CompareCon

; 770  : 	}
; 771  : 
; 772  : 	if ( lpCondition->ReqStr > lpObj->Strength + lpObj->AddStrength)

  00056	0f bf 8f 20 01
	00 00		 movsx	 ecx, WORD PTR [edi+288]
  0005d	0f b7 97 f4 00
	00 00		 movzx	 edx, WORD PTR [edi+244]
  00064	03 ca		 add	 ecx, edx
  00066	33 c0		 xor	 eax, eax
  00068	39 4e 10	 cmp	 DWORD PTR [esi+16], ecx
  0006b	5f		 pop	 edi
  0006c	0f 9e c0	 setle	 al
  0006f	5e		 pop	 esi

; 773  : 	{
; 774  : 		return FALSE;
; 775  : 	}
; 776  : 
; 777  : 	return TRUE;
; 778  : 
; 779  : }

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
?CompareCondition@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@PAUQUEST_CONDITION@@@Z ENDP ; CQuestInfo::CompareCondition
_TEXT	ENDS
PUBLIC	??_C@_0DL@ODHGIMOD@?$FLQuest?$FN?5Quest?5Item?5Drop?$CIParty?$CJ?5?$FL@ ; `string'
PUBLIC	?MonsterItemDropParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z ; CQuestInfo::MonsterItemDropParty
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	_rand:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
;	COMDAT ??_C@_0DL@ODHGIMOD@?$FLQuest?$FN?5Quest?5Item?5Drop?$CIParty?$CJ?5?$FL@
; File e:\work\tranet_version\gs\gameserver\questinfo.h
CONST	SEGMENT
??_C@_0DL@ODHGIMOD@?$FLQuest?$FN?5Quest?5Item?5Drop?$CIParty?$CJ?5?$FL@ DB '['
	DB	'Quest] Quest Item Drop(Party) [%s]: [%s][%s] (%s) (%d,%d)', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\questinfo.cpp
CONST	ENDS
;	COMDAT ?MonsterItemDropParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_y$ = -28						; size = 4
_questcount$ = -28					; size = 4
tv408 = -24						; size = 4
_x$ = -24						; size = 4
_n$ = -20						; size = 4
_i$ = -16						; size = 4
_foundquest$ = -12					; size = 4
tv272 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_level$ = 12						; size = 4
_lpTargetObj$ = 12					; size = 4
?MonsterItemDropParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z PROC ; CQuestInfo::MonsterItemDropParty, COMDAT
; _this$ = ecx

; 939  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 940  : 	int questcount = this->GetQeustCount(); //loc1

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	89 45 e4	 mov	 DWORD PTR _questcount$[ebp], eax

; 941  : 	int foundquest = 0; //loc2
; 942  : 	LPQUEST_INFO lpQuestInfo;
; 943  : 	LPQUEST_SUB_INFO lpSubInfo;
; 944  : 	int type;
; 945  : 	int level;
; 946  : 	int x;
; 947  : 	int y;
; 948  : 	float dur = 0; //loc10
; 949  : 	int Option1 = 0; //loc11
; 950  : 	int Option2 = 0; //loc12
; 951  : 	int Option3 = 0; //loc13
; 952  : 	int TargetPartyNumber = lpTargetObj->PartyNumber; //loc14

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0000f	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  00015	33 d2		 xor	 edx, edx
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	89 55 f4	 mov	 DWORD PTR _foundquest$[ebp], edx

; 953  : 	int LocalPartyNumber; //loc15
; 954  : 
; 955  : 	if(TargetPartyNumber < 0)

  0001d	3b c2		 cmp	 eax, edx
  0001f	7d 08		 jge	 SHORT $LN21@MonsterIte

; 956  : 	{
; 957  : 		return false;

  00021	33 c0		 xor	 eax, eax

; 1033 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN21@MonsterIte:

; 958  : 	}
; 959  : 
; 960  : 	LPOBJ loc16; //loc16
; 961  : 
; 962  : 	int n; //loc17
; 963  : 	int i; //loc18
; 964  : 	int j; //loc19
; 965  : 
; 966  : 	for ( n=0;n<MAX_USER_IN_PARTY;n++)

  00029	6b c0 68	 imul	 eax, 104		; 00000068H
  0002c	53		 push	 ebx
  0002d	56		 push	 esi
  0002e	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  00033	57		 push	 edi
  00034	89 55 ec	 mov	 DWORD PTR _n$[ebp], edx
  00037	89 45 e8	 mov	 DWORD PTR tv408[ebp], eax
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL43@MonsterIte:

; 967  : 	{
; 968  : 		LocalPartyNumber = gParty.m_PartyS[TargetPartyNumber].Number[n];

  00040	8b 00		 mov	 eax, DWORD PTR [eax]

; 969  : 
; 970  : 		if(LocalPartyNumber < 0)

  00042	85 c0		 test	 eax, eax
  00044	0f 88 d9 00 00
	00		 js	 $LN19@MonsterIte

; 971  : 		{
; 972  : 			continue;
; 973  : 		}
; 974  : 
; 975  : 		if (gObj[LocalPartyNumber].MapNumber != lpTargetObj->MapNumber)

  0004a	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0004d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00053	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00059	89 45 f8	 mov	 DWORD PTR tv272[ebp], eax
  0005c	8a 80 49 01 00
	00		 mov	 al, BYTE PTR [eax+329]
  00062	3a 82 49 01 00
	00		 cmp	 al, BYTE PTR [edx+329]
  00068	0f 85 b5 00 00
	00		 jne	 $LN19@MonsterIte

; 976  : 		{
; 977  : 			continue;
; 978  : 		}
; 979  : 
; 980  : 		loc16 = &gObj[LocalPartyNumber];
; 981  : 
; 982  : 		for ( i=0;i<MAX_QUEST_INFO;i++)

  0006e	33 d2		 xor	 edx, edx
  00070	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
$LL44@MonsterIte:

; 983  : 		{
; 984  : 			lpQuestInfo = this->GetQuestInfo(i);

  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00079	8b f8		 mov	 edi, eax

; 985  : 
; 986  : 			if ( lpQuestInfo == NULL )

  0007b	85 ff		 test	 edi, edi
  0007d	0f 84 90 00 00
	00		 je	 $LN14@MonsterIte

; 987  : 			{
; 988  : 				continue;
; 989  : 			}
; 990  : 
; 991  : 			for ( j=0;j<lpQuestInfo->QuestSubInfoCount;j++)

  00083	33 db		 xor	 ebx, ebx
  00085	39 5f 40	 cmp	 DWORD PTR [edi+64], ebx
  00088	7e 7d		 jle	 SHORT $LN9@MonsterIte
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL11@MonsterIte:

; 992  : 			{
; 993  : 				lpSubInfo = this->GetSubquestInfo(loc16, lpQuestInfo, j);

  00090	8b 45 f8	 mov	 eax, DWORD PTR tv272[ebp]
  00093	53		 push	 ebx
  00094	57		 push	 edi
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
  0009b	8b f0		 mov	 esi, eax

; 994  : 			
; 995  : 				if ( lpSubInfo == NULL )

  0009d	85 f6		 test	 esi, esi
  0009f	74 5a		 je	 SHORT $LN10@MonsterIte

; 996  : 				{
; 997  : 					continue;
; 998  : 				}
; 999  : 				
; 1000 : 				if ( lpSubInfo->QuestType == 1 )

  000a1	83 3e 01	 cmp	 DWORD PTR [esi], 1
  000a4	75 55		 jne	 SHORT $LN10@MonsterIte

; 1001 : 				{
; 1002 : 					if( (lpSubInfo->NeedTargetMinLevel > 0) && (lpObj->Level >= lpSubInfo->NeedTargetMinLevel) && (lpObj->Level <= lpSubInfo->NeedTargetMaxLevel) || (lpSubInfo->NeedTargetMinLevel == -1) && (lpObj->Class == lpSubInfo->NeedTargetMaxLevel))

  000a6	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a9	85 c0		 test	 eax, eax
  000ab	7e 13		 jle	 SHORT $LN36@MonsterIte
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b0	0f bf 89 be 00
	00 00		 movsx	 ecx, WORD PTR [ecx+190]
  000b7	3b c8		 cmp	 ecx, eax
  000b9	7c 05		 jl	 SHORT $LN36@MonsterIte
  000bb	3b 4e 18	 cmp	 ecx, DWORD PTR [esi+24]
  000be	7e 14		 jle	 SHORT $LN5@MonsterIte
$LN36@MonsterIte:
  000c0	83 f8 ff	 cmp	 eax, -1
  000c3	75 36		 jne	 SHORT $LN10@MonsterIte
  000c5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c8	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  000cf	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  000d2	75 27		 jne	 SHORT $LN10@MonsterIte
$LN5@MonsterIte:

; 1003 : 					{
; 1004 : 						if ( this->GetQuestState(loc16, lpQuestInfo->QuestIndex) == TRUE )

  000d4	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  000d7	8b 55 f8	 mov	 edx, DWORD PTR tv272[ebp]
  000da	51		 push	 ecx
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000e4	83 f8 01	 cmp	 eax, 1
  000e7	75 12		 jne	 SHORT $LN10@MonsterIte

; 1005 : 						{
; 1006 : 							if ( (rand() % ITEM_QUEST_DROP_PROBABILITY) < lpSubInfo->NeedDropRate)

  000e9	e8 00 00 00 00	 call	 _rand
  000ee	99		 cdq
  000ef	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000f4	f7 f9		 idiv	 ecx
  000f6	3b 56 1c	 cmp	 edx, DWORD PTR [esi+28]
  000f9	7c 4c		 jl	 SHORT $LN29@MonsterIte
$LN10@MonsterIte:

; 987  : 			{
; 988  : 				continue;
; 989  : 			}
; 990  : 
; 991  : 			for ( j=0;j<lpQuestInfo->QuestSubInfoCount;j++)

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	43		 inc	 ebx
  000ff	3b 5f 40	 cmp	 ebx, DWORD PTR [edi+64]
  00102	7c 8c		 jl	 SHORT $LL11@MonsterIte
  00104	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
$LN9@MonsterIte:

; 1016 : 							}
; 1017 : 						}
; 1018 : 					}					
; 1019 : 				}
; 1020 : 			}
; 1021 : 
; 1022 : 			foundquest++;

  00107	8b 45 f4	 mov	 eax, DWORD PTR _foundquest$[ebp]
  0010a	40		 inc	 eax
  0010b	89 45 f4	 mov	 DWORD PTR _foundquest$[ebp], eax

; 1023 : 
; 1024 : 			if ( foundquest == questcount )

  0010e	3b 45 e4	 cmp	 eax, DWORD PTR _questcount$[ebp]
  00111	74 10		 je	 SHORT $LN19@MonsterIte
$LN14@MonsterIte:

; 976  : 		{
; 977  : 			continue;
; 978  : 		}
; 979  : 
; 980  : 		loc16 = &gObj[LocalPartyNumber];
; 981  : 
; 982  : 		for ( i=0;i<MAX_QUEST_INFO;i++)

  00113	42		 inc	 edx
  00114	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx
  00117	81 fa c8 00 00
	00		 cmp	 edx, 200		; 000000c8H
  0011d	0f 8c 50 ff ff
	ff		 jl	 $LL44@MonsterIte
$LN19@MonsterIte:

; 958  : 	}
; 959  : 
; 960  : 	LPOBJ loc16; //loc16
; 961  : 
; 962  : 	int n; //loc17
; 963  : 	int i; //loc18
; 964  : 	int j; //loc19
; 965  : 
; 966  : 	for ( n=0;n<MAX_USER_IN_PARTY;n++)

  00123	8b 55 ec	 mov	 edx, DWORD PTR _n$[ebp]
  00126	8b 45 e8	 mov	 eax, DWORD PTR tv408[ebp]
  00129	42		 inc	 edx
  0012a	83 c0 04	 add	 eax, 4
  0012d	89 55 ec	 mov	 DWORD PTR _n$[ebp], edx
  00130	89 45 e8	 mov	 DWORD PTR tv408[ebp], eax
  00133	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00136	0f 8c 04 ff ff
	ff		 jl	 $LL43@MonsterIte

; 1025 : 			{
; 1026 : 				break;
; 1027 : 			}
; 1028 : 
; 1029 : 		}
; 1030 : 	}
; 1031 : 
; 1032 : 	return false;

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	33 c0		 xor	 eax, eax
  00140	5b		 pop	 ebx

; 1033 : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c2 08 00	 ret	 8
$LN29@MonsterIte:

; 1007 : 							{
; 1008 : 								dur = 0;
; 1009 : 								x = lpTargetObj->X;

  00147	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$[ebp]
  0014a	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]

; 1010 : 								y = lpTargetObj->Y;

  00151	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]

; 1011 : 								level = lpSubInfo->ItemLevel;

  00158	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0015b	89 55 e8	 mov	 DWORD PTR _x$[ebp], edx

; 1012 : 								type = ItemGetNumberMake(lpSubInfo->NeedType, lpSubInfo->NeedSubType);

  0015e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00161	89 45 e4	 mov	 DWORD PTR _y$[ebp], eax
  00164	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00167	52		 push	 edx
  00168	50		 push	 eax
  00169	89 4d 0c	 mov	 DWORD PTR _level$[ebp], ecx
  0016c	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 1013 : 								ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, x, y, type, level, dur, Option1, Option2, Option3, lpTargetObj->m_Index, 0, 0);

  00171	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00173	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00176	6a 00		 push	 0
  00178	6a 00		 push	 0
  0017a	51		 push	 ecx
  0017b	6a 00		 push	 0
  0017d	6a 00		 push	 0
  0017f	6a 00		 push	 0
  00181	6a 00		 push	 0
  00183	52		 push	 edx
  00184	8b 55 e8	 mov	 edx, DWORD PTR _x$[ebp]
  00187	50		 push	 eax
  00188	8b 45 e4	 mov	 eax, DWORD PTR _y$[ebp]
  0018b	50		 push	 eax
  0018c	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  00193	52		 push	 edx
  00194	50		 push	 eax
  00195	51		 push	 ecx
  00196	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 1014 : 								LogAddTD("[Quest] Quest Item Drop(Party) [%s]: [%s][%s] (%s) (%d,%d)", lpObj->Name,	lpTargetObj->AccountID, lpTargetObj->Name, lpQuestInfo->Name, lpSubInfo->NeedType, lpSubInfo->NeedSubType);

  0019b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0019e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  001a1	51		 push	 ecx
  001a2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a5	52		 push	 edx
  001a6	57		 push	 edi
  001a7	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  001aa	50		 push	 eax
  001ab	83 c3 6c	 add	 ebx, 108		; 0000006cH
  001ae	53		 push	 ebx
  001af	83 c1 77	 add	 ecx, 119		; 00000077H
  001b2	51		 push	 ecx
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ODHGIMOD@?$FLQuest?$FN?5Quest?5Item?5Drop?$CIParty?$CJ?5?$FL@
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001be	83 c4 58	 add	 esp, 88			; 00000058H
  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi

; 1015 : 								return true;

  001c3	b8 01 00 00 00	 mov	 eax, 1
  001c8	5b		 pop	 ebx

; 1033 : }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
?MonsterItemDropParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP ; CQuestInfo::MonsterItemDropParty
_TEXT	ENDS
PUBLIC	??_C@_0DM@DEIPHGLI@?$FLQuest?$FN?5Quest?5Accept?5?9?5MonsterKi@ ; `string'
PUBLIC	?QuestAccept@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestAccept
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
;	COMDAT ??_C@_0DM@DEIPHGLI@?$FLQuest?$FN?5Quest?5Accept?5?9?5MonsterKi@
CONST	SEGMENT
??_C@_0DM@DEIPHGLI@?$FLQuest?$FN?5Quest?5Accept?5?9?5MonsterKi@ DB '[Ques'
	DB	't] Quest Accept - MonsterKillCount Set (%s) : [%s][%s]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?QuestAccept@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_subquestcount$ = -20					; size = 4
_subquest$213820 = -16					; size = 4
_concount$ = -12					; size = 4
_this$ = -8						; size = 4
_NeedZen$ = -4						; size = 4
_lpSubInfo$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?QuestAccept@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z PROC	; CQuestInfo::QuestAccept, COMDAT
; _this$ = ecx

; 1036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1037 : 	LPQUEST_INFO lpQuestInfo = this->GetQuestInfo(QuestIndex);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00009	53		 push	 ebx
  0000a	50		 push	 eax
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00013	8b d8		 mov	 ebx, eax

; 1038 : 
; 1039 : 	if ( lpQuestInfo == NULL )

  00015	33 c0		 xor	 eax, eax
  00017	3b d8		 cmp	 ebx, eax
  00019	75 0c		 jne	 SHORT $LN17@QuestAccep

; 1040 : 	{
; 1041 : 		return 0xFF;

  0001b	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00020	5b		 pop	 ebx

; 1096 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN17@QuestAccep:

; 1042 : 	}
; 1043 : 
; 1044 : 	int subquestcount = lpQuestInfo->QuestSubInfoCount;

  00027	8b 53 40	 mov	 edx, DWORD PTR [ebx+64]
  0002a	56		 push	 esi

; 1045 : 	int concount = lpQuestInfo->QuestConditionCount;

  0002b	8b b3 14 03 00
	00		 mov	 esi, DWORD PTR [ebx+788]
  00031	57		 push	 edi

; 1046 : 	LPQUEST_SUB_INFO lpSubInfo;
; 1047 : 	LPQUEST_CONDITION lpCondition;
; 1048 : 	int NeedZen = 0;
; 1049 : 
; 1050 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  00032	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00035	89 55 ec	 mov	 DWORD PTR _subquestcount$[ebp], edx
  00038	89 75 f4	 mov	 DWORD PTR _concount$[ebp], esi
  0003b	89 45 fc	 mov	 DWORD PTR _NeedZen$[ebp], eax
  0003e	89 45 f0	 mov	 DWORD PTR _subquest$213820[ebp], eax
  00041	3b d0		 cmp	 edx, eax
  00043	0f 8e c6 00 00
	00		 jle	 $LN14@QuestAccep
  00049	eb 08		 jmp	 SHORT $LN16@QuestAccep
  0004b	eb 03 8d 49 00	 npad	 5
$LL28@QuestAccep:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
$LN16@QuestAccep:

; 1051 : 	{
; 1052 : 		lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, subquest);

  00053	50		 push	 eax
  00054	53		 push	 ebx
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
  0005b	8b d0		 mov	 edx, eax
  0005d	89 55 08	 mov	 DWORD PTR _lpSubInfo$[ebp], edx

; 1053 : 
; 1054 : 		if ( lpSubInfo != NULL )

  00060	85 d2		 test	 edx, edx
  00062	0f 84 97 00 00
	00		 je	 $LN15@QuestAccep

; 1055 : 		{
; 1056 : 			for ( int n = 0;n<concount;n++)

  00068	33 f6		 xor	 esi, esi
  0006a	39 75 f4	 cmp	 DWORD PTR _concount$[ebp], esi
  0006d	7e 35		 jle	 SHORT $LN10@QuestAccep
  0006f	90		 npad	 1
$LL12@QuestAccep:

; 1057 : 			{
; 1058 : 				lpCondition = this->GetQuestCondition(lpQuestInfo, n);

  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	56		 push	 esi
  00074	53		 push	 ebx
  00075	e8 00 00 00 00	 call	 ?GetQuestCondition@CQuestInfo@@QAEPAUQUEST_CONDITION@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestCondition

; 1059 : 
; 1060 : 				if(lpCondition != 0 && lpCondition->Index == -1) //Season 2.5 changed

  0007a	85 c0		 test	 eax, eax
  0007c	74 1d		 je	 SHORT $LN11@QuestAccep
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	83 f9 ff	 cmp	 ecx, -1
  00083	75 08		 jne	 SHORT $LN9@QuestAccep

; 1061 : 				{
; 1062 : 					NeedZen += lpCondition->NeedZen;

  00085	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00088	01 4d fc	 add	 DWORD PTR _NeedZen$[ebp], ecx
  0008b	eb 0e		 jmp	 SHORT $LN11@QuestAccep
$LN9@QuestAccep:

; 1063 : 				}
; 1064 : 				else if(lpCondition != 0 && (lpCondition->Index == lpSubInfo->LinkConditionIndex)) //season 2.5 add-on

  0008d	8b 55 08	 mov	 edx, DWORD PTR _lpSubInfo$[ebp]
  00090	3b 4a 2c	 cmp	 ecx, DWORD PTR [edx+44]
  00093	75 06		 jne	 SHORT $LN11@QuestAccep

; 1065 : 				{
; 1066 : 					NeedZen += lpCondition->NeedZen;

  00095	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00098	01 45 fc	 add	 DWORD PTR _NeedZen$[ebp], eax
$LN11@QuestAccep:

; 1055 : 		{
; 1056 : 			for ( int n = 0;n<concount;n++)

  0009b	46		 inc	 esi
  0009c	3b 75 f4	 cmp	 esi, DWORD PTR _concount$[ebp]
  0009f	7c cf		 jl	 SHORT $LL12@QuestAccep
  000a1	8b 55 08	 mov	 edx, DWORD PTR _lpSubInfo$[ebp]
$LN10@QuestAccep:

; 1067 : 				}
; 1068 : 			}
; 1069 : 
; 1070 : 			if(lpSubInfo->QuestType == 2) //season 2.5 add-on

  000a4	83 3a 02	 cmp	 DWORD PTR [edx], 2
  000a7	75 56		 jne	 SHORT $LN15@QuestAccep

; 1071 : 			{
; 1072 : 				if(lpObj->m_i3rdQuestIndex == -1)

  000a9	83 bf 60 10 00
	00 ff		 cmp	 DWORD PTR [edi+4192], -1
  000b0	75 09		 jne	 SHORT $LN5@QuestAccep

; 1073 : 				{
; 1074 : 					lpObj->m_i3rdQuestIndex = QuestIndex;

  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _QuestIndex$[ebp]
  000b5	89 8f 60 10 00
	00		 mov	 DWORD PTR [edi+4192], ecx
$LN5@QuestAccep:

; 1075 : 				}
; 1076 : 
; 1077 : 				for ( int n = 0;n<5;n++)

  000bb	33 c0		 xor	 eax, eax
  000bd	8d 8f 64 10 00
	00		 lea	 ecx, DWORD PTR [edi+4196]
$LL4@QuestAccep:

; 1078 : 				{
; 1079 : 					if(lpObj->MonsterKillInfo[n].MonIndex == -1)

  000c3	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  000c6	74 0b		 je	 SHORT $LN23@QuestAccep

; 1075 : 				}
; 1076 : 
; 1077 : 				for ( int n = 0;n<5;n++)

  000c8	40		 inc	 eax
  000c9	83 c1 08	 add	 ecx, 8
  000cc	83 f8 05	 cmp	 eax, 5
  000cf	7c f2		 jl	 SHORT $LL4@QuestAccep

; 1078 : 				{
; 1079 : 					if(lpObj->MonsterKillInfo[n].MonIndex == -1)

  000d1	eb 15		 jmp	 SHORT $LN2@QuestAccep
$LN23@QuestAccep:

; 1080 : 					{
; 1081 : 						lpObj->MonsterKillInfo[n].MonIndex = lpSubInfo->NeedType;

  000d3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000d6	89 94 c7 64 10
	00 00		 mov	 DWORD PTR [edi+eax*8+4196], edx

; 1082 : 						lpObj->MonsterKillInfo[n].KillCount = 0;

  000dd	c7 84 c7 68 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax*8+4200], 0
$LN2@QuestAccep:

; 1083 : 						break;
; 1084 : 					}
; 1085 : 				}
; 1086 : 
; 1087 : 				LogAddTD("[Quest] Quest Accept - MonsterKillCount Set (%s) : [%s][%s]", lpQuestInfo, lpObj->AccountID, lpObj->Name);

  000e8	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  000eb	50		 push	 eax
  000ec	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  000ef	51		 push	 ecx
  000f0	53		 push	 ebx
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DEIPHGLI@?$FLQuest?$FN?5Quest?5Accept?5?9?5MonsterKi@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fc	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@QuestAccep:

; 1046 : 	LPQUEST_SUB_INFO lpSubInfo;
; 1047 : 	LPQUEST_CONDITION lpCondition;
; 1048 : 	int NeedZen = 0;
; 1049 : 
; 1050 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  000ff	8b 45 f0	 mov	 eax, DWORD PTR _subquest$213820[ebp]
  00102	40		 inc	 eax
  00103	89 45 f0	 mov	 DWORD PTR _subquest$213820[ebp], eax
  00106	3b 45 ec	 cmp	 eax, DWORD PTR _subquestcount$[ebp]
  00109	0f 8c 41 ff ff
	ff		 jl	 $LL28@QuestAccep
$LN14@QuestAccep:

; 1088 : 			}
; 1089 : 
; 1090 : 		}
; 1091 : 	}
; 1092 : 
; 1093 : 	lpObj->Money -= NeedZen;

  0010f	8b 55 fc	 mov	 edx, DWORD PTR _NeedZen$[ebp]
  00112	29 97 f0 00 00
	00		 sub	 DWORD PTR [edi+240], edx
  00118	8b 87 f0 00 00
	00		 mov	 eax, DWORD PTR [edi+240]

; 1094 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  0011e	50		 push	 eax
  0011f	8b 07		 mov	 eax, DWORD PTR [edi]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00127	83 c4 08	 add	 esp, 8
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi

; 1095 : 	return true;

  0012c	b8 01 00 00 00	 mov	 eax, 1
  00131	5b		 pop	 ebx

; 1096 : }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 08 00	 ret	 8
?QuestAccept@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP	; CQuestInfo::QuestAccept
_TEXT	ENDS
PUBLIC	??_C@_0ED@KLNCEAII@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0DN@GBDKNIEG@?$FLQuest?$FN?5Quest?5Clear?5?9?5MonsterKil@ ; `string'
PUBLIC	??_C@_0DP@MIGJKFOH@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0CP@JAPDAPMO@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0DK@CADKKHAN@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0DA@FJIJPLFD@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0DK@OGOONICP@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	?QuestClear@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestClear
EXTRN	?gObjDelteItemCountInInventory@@YAXHHHH@Z:PROC	; gObjDelteItemCountInInventory
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?GCSendQuestPrize@@YAXHEE@Z:PROC		; GCSendQuestPrize
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
;	COMDAT ??_C@_0ED@KLNCEAII@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0ED@KLNCEAII@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d), Class:%d Plus'
	DB	'Stat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GBDKNIEG@?$FLQuest?$FN?5Quest?5Clear?5?9?5MonsterKil@
CONST	SEGMENT
??_C@_0DN@GBDKNIEG@?$FLQuest?$FN?5Quest?5Clear?5?9?5MonsterKil@ DB '[Ques'
	DB	't] Quest Clear - MonsterKillCount Reset (%s) : [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MIGJKFOH@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DP@MIGJKFOH@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Quest] Quest Clear (%s) : [%s][%s] Class:%d(%d), 3rd ChangeUp'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JAPDAPMO@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0CP@JAPDAPMO@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Quest] Quest Clear (%s) : [%s][%s] ComboSkill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CADKKHAN@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DK@CADKKHAN@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d), PlusStat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FJIJPLFD@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DA@FJIJPLFD@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OGOONICP@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DK@OGOONICP@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d), ChangeUp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?QuestClear@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_subquestcount$ = -12					; size = 4
_this$ = -8						; size = 4
_subquest$213851 = -4					; size = 4
_btClass$213872 = 8					; size = 1
_lpObj$ = 8						; size = 4
_lpQuestInfo$ = 12					; size = 4
_QuestIndex$ = 12					; size = 4
?QuestClear@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z PROC	; CQuestInfo::QuestClear, COMDAT
; _this$ = ecx

; 1099 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1100 : 	LPQUEST_INFO lpQuestInfo = this->GetQuestInfo(QuestIndex);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	50		 push	 eax
  0000e	89 7d f8	 mov	 DWORD PTR _this$[ebp], edi
  00011	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo

; 1101 : 
; 1102 : 	if ( szAuthKey[18] != AUTHKEY18 )

  00016	80 3d 12 00 00
	00 db		 cmp	 BYTE PTR ?szAuthKey@@3PADA+18, -37 ; ffffffdbH
  0001d	8b d8		 mov	 ebx, eax
  0001f	89 5d 0c	 mov	 DWORD PTR _lpQuestInfo$[ebp], ebx
  00022	74 05		 je	 SHORT $LN23@QuestClear@2

; 1103 : 	{
; 1104 : 		DestroyGIocp();

  00024	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN23@QuestClear@2:

; 1105 : 	}
; 1106 : 
; 1107 : 	if ( lpQuestInfo == NULL )

  00029	85 db		 test	 ebx, ebx
  0002b	75 0d		 jne	 SHORT $LN22@QuestClear@2

; 1108 : 	{
; 1109 : 		return 0xFF;

  0002d	5f		 pop	 edi
  0002e	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00033	5b		 pop	 ebx

; 1216 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
$LN22@QuestClear@2:

; 1110 : 	}
; 1111 : 
; 1112 : 	int subquestcount = lpQuestInfo->QuestSubInfoCount;

  0003a	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  0003d	89 45 f4	 mov	 DWORD PTR _subquestcount$[ebp], eax

; 1113 : 	int concount = lpQuestInfo->QuestConditionCount;
; 1114 : 	LPQUEST_SUB_INFO lpSubInfo;
; 1115 : 
; 1116 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _subquest$213851[ebp], 0
  00047	85 c0		 test	 eax, eax
  00049	0f 8e df 02 00
	00		 jle	 $LN19@QuestClear@2
  0004f	56		 push	 esi
  00050	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00053	eb 03		 jmp	 SHORT $LN21@QuestClear@2
$LL38@QuestClear@2:
  00055	8b 7d f8	 mov	 edi, DWORD PTR _this$[ebp]
$LN21@QuestClear@2:

; 1117 : 	{
; 1118 : 		lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, subquest);

  00058	8b 4d fc	 mov	 ecx, DWORD PTR _subquest$213851[ebp]
  0005b	51		 push	 ecx
  0005c	53		 push	 ebx
  0005d	56		 push	 esi
  0005e	8b cf		 mov	 ecx, edi
  00060	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
  00065	8b f8		 mov	 edi, eax

; 1119 : 
; 1120 : 		if ( lpSubInfo != NULL )

  00067	85 ff		 test	 edi, edi
  00069	0f 84 ae 02 00
	00		 je	 $LN20@QuestClear@2

; 1121 : 		{
; 1122 : 			if ( lpSubInfo->RewardType == QUEST_COMPENSATION_CHANGEUP )

  0006f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00072	3d c9 00 00 00	 cmp	 eax, 201		; 000000c9H
  00077	75 7f		 jne	 SHORT $LN17@QuestClear@2

; 1123 : 			{
; 1124 : 				lpObj->LevelUpPoint += lpSubInfo->RewardCount;

  00079	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  0007c	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx

; 1125 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_STATUP, lpSubInfo->RewardCount );

  00082	0f b6 47 28	 movzx	 eax, BYTE PTR [edi+40]
  00086	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00088	50		 push	 eax
  00089	68 c8 00 00 00	 push	 200			; 000000c8H
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1126 : 				lpObj->ChangeUP = 1;
; 1127 : 				lpObj->DbClass |= 1;
; 1128 : 				gObjMakePreviewCharSet(lpObj->m_Index);

  00094	8b 16		 mov	 edx, DWORD PTR [esi]
  00096	80 8e ba 00 00
	00 01		 or	 BYTE PTR [esi+186], 1
  0009d	52		 push	 edx
  0009e	c6 86 bb 00 00
	00 01		 mov	 BYTE PTR [esi+187], 1
  000a5	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 1129 : 				BYTE btClass = (lpObj->Class<<5)&0xE0;
; 1130 : 				btClass |= (lpObj->ChangeUP<<4)&0x10;
; 1131 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_CHANGEUP, btClass);

  000aa	8a 86 b8 00 00
	00		 mov	 al, BYTE PTR [esi+184]
  000b0	8a 8e bb 00 00
	00		 mov	 cl, BYTE PTR [esi+187]
  000b6	02 c0		 add	 al, al
  000b8	80 e1 01	 and	 cl, 1
  000bb	0a c1		 or	 al, cl
  000bd	c0 e0 04	 shl	 al, 4
  000c0	0f b6 d0	 movzx	 edx, al
  000c3	8b 06		 mov	 eax, DWORD PTR [esi]
  000c5	52		 push	 edx
  000c6	68 c9 00 00 00	 push	 201			; 000000c9H
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1132 : 				LogAddTD("[Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d), ChangeUp",
; 1133 : 					lpQuestInfo->Name, lpObj->AccountID, lpObj->Name, lpObj->LevelUpPoint,
; 1134 : 					lpSubInfo->RewardCount );

  000d1	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  000d4	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]
  000da	51		 push	 ecx
  000db	52		 push	 edx
  000dc	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  000df	50		 push	 eax
  000e0	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  000e3	51		 push	 ecx
  000e4	53		 push	 ebx
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@OGOONICP@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f0	83 c4 34	 add	 esp, 52			; 00000034H
  000f3	e9 5a 01 00 00	 jmp	 $LN36@QuestClear@2
$LN17@QuestClear@2:

; 1135 : 			}
; 1136 : 			else if ( lpSubInfo->RewardType == QUEST_COMPENSATION_STATUP )

  000f8	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  000fd	75 42		 jne	 SHORT $LN15@QuestClear@2

; 1137 : 			{
; 1138 : 				lpObj->LevelUpPoint += lpSubInfo->RewardCount;

  000ff	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00102	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx

; 1139 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_STATUP, lpSubInfo->RewardCount );

  00108	0f b6 47 28	 movzx	 eax, BYTE PTR [edi+40]
  0010c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0010e	50		 push	 eax
  0010f	68 c8 00 00 00	 push	 200			; 000000c8H
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1140 : 				LogAddTD("[Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d)",
; 1141 : 					lpQuestInfo->Name, lpObj->AccountID, lpObj->Name, lpObj->LevelUpPoint,
; 1142 : 					lpSubInfo->RewardCount );

  0011a	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  0011d	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00123	52		 push	 edx
  00124	50		 push	 eax
  00125	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00128	51		 push	 ecx
  00129	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  0012c	52		 push	 edx
  0012d	53		 push	 ebx
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FJIJPLFD@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00139	83 c4 24	 add	 esp, 36			; 00000024H
  0013c	e9 11 01 00 00	 jmp	 $LN36@QuestClear@2
$LN15@QuestClear@2:

; 1143 : 			}
; 1144 : 			else if ( lpSubInfo->RewardType == QUEST_COMPENSATION_PLUSSSTAT )

  00141	3d ca 00 00 00	 cmp	 eax, 202		; 000000caH
  00146	75 55		 jne	 SHORT $LN13@QuestClear@2

; 1145 : 			{
; 1146 : 				int level = lpObj->Level - QUEST_MINLEVEL_PLUSSTAT;

  00148	0f bf 9e be 00
	00 00		 movsx	 ebx, WORD PTR [esi+190]
  0014f	81 eb dc 00 00
	00		 sub	 ebx, 220		; 000000dcH

; 1147 : 
; 1148 : 				if ( level <= 0 )

  00155	85 db		 test	 ebx, ebx
  00157	7f 02		 jg	 SHORT $LN12@QuestClear@2

; 1149 : 				{
; 1150 : 					level = 0;

  00159	33 db		 xor	 ebx, ebx
$LN12@QuestClear@2:

; 1151 : 				}
; 1152 : 
; 1153 : 				lpObj->LevelUpPoint += level;
; 1154 : 				lpObj->PlusStatQuestClear = true;
; 1155 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_PLUSSSTAT, level );

  0015b	8b 06		 mov	 eax, DWORD PTR [esi]
  0015d	01 9e c0 00 00
	00		 add	 DWORD PTR [esi+192], ebx
  00163	53		 push	 ebx
  00164	68 ca 00 00 00	 push	 202			; 000000caH
  00169	50		 push	 eax
  0016a	c6 86 a5 00 00
	00 01		 mov	 BYTE PTR [esi+165], 1
  00171	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1156 : 				LogAddTD("[Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d), PlusStat",
; 1157 : 					lpQuestInfo->Name, lpObj->AccountID, lpObj->Name, lpObj->LevelUpPoint, level);

  00176	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  0017c	53		 push	 ebx
  0017d	51		 push	 ecx
  0017e	8b 4d 0c	 mov	 ecx, DWORD PTR _lpQuestInfo$[ebp]
  00181	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00184	52		 push	 edx
  00185	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  00188	50		 push	 eax
  00189	51		 push	 ecx
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@CADKKHAN@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00195	83 c4 24	 add	 esp, 36			; 00000024H
  00198	e9 b2 00 00 00	 jmp	 $LN39@QuestClear@2
$LN13@QuestClear@2:

; 1158 : 			}
; 1159 : 			else if ( lpSubInfo->RewardType == QUEST_COMPENSATION_COMBOSKILL )

  0019d	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  001a2	75 2e		 jne	 SHORT $LN10@QuestClear@2

; 1160 : 			{
; 1161 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_COMBOSKILL, 0 );

  001a4	8b 16		 mov	 edx, DWORD PTR [esi]
  001a6	6a 00		 push	 0
  001a8	50		 push	 eax
  001a9	52		 push	 edx
  001aa	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1162 : 				lpObj->ComboSkillquestClear = true;
; 1163 : 				LogAddTD("[Quest] Quest Clear (%s) : [%s][%s] ComboSkill",
; 1164 : 					lpQuestInfo->Name, lpObj->AccountID, lpObj->Name);

  001af	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  001b2	50		 push	 eax
  001b3	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  001b6	51		 push	 ecx
  001b7	53		 push	 ebx
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JAPDAPMO@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
  001bd	c6 86 a6 00 00
	00 01		 mov	 BYTE PTR [esi+166], 1
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001ca	83 c4 1c	 add	 esp, 28			; 0000001cH
  001cd	e9 80 00 00 00	 jmp	 $LN36@QuestClear@2
$LN10@QuestClear@2:

; 1165 : 			}
; 1166 : 			else if ( lpSubInfo->RewardType == QUEST_COMPENSATION_ThirdChangeUp ) //season 2.5 add-on

  001d2	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  001d7	75 79		 jne	 SHORT $LN36@QuestClear@2

; 1167 : 			{
; 1168 : 				lpObj->ChangeUP3rd = 1;
; 1169 : 				lpObj->DbClass |= 2;
; 1170 : 				gObjMakePreviewCharSet(lpObj->m_Index);

  001d9	8b 16		 mov	 edx, DWORD PTR [esi]
  001db	80 8e ba 00 00
	00 02		 or	 BYTE PTR [esi+186], 2
  001e2	52		 push	 edx
  001e3	c6 86 bc 00 00
	00 01		 mov	 BYTE PTR [esi+188], 1
  001ea	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 1171 : 				BYTE btClass = (lpObj->Class<<5)&0xE0;
; 1172 : 				btClass |= (lpObj->ChangeUP<<4)&0x10;
; 1173 : 				btClass |= (lpObj->ChangeUP3rd<<0x03)&0x08;

  001ef	8a 86 b8 00 00
	00		 mov	 al, BYTE PTR [esi+184]
  001f5	8a 9e bb 00 00
	00		 mov	 bl, BYTE PTR [esi+187]
  001fb	8a 8e bc 00 00
	00		 mov	 cl, BYTE PTR [esi+188]
  00201	80 e3 01	 and	 bl, 1
  00204	02 c0		 add	 al, al
  00206	0a d8		 or	 bl, al

; 1174 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_ThirdChangeUp, btClass );

  00208	8b 06		 mov	 eax, DWORD PTR [esi]
  0020a	02 db		 add	 bl, bl
  0020c	80 e1 01	 and	 cl, 1
  0020f	0a d9		 or	 bl, cl
  00211	02 db		 add	 bl, bl
  00213	02 db		 add	 bl, bl
  00215	02 db		 add	 bl, bl
  00217	88 5d 08	 mov	 BYTE PTR _btClass$213872[ebp], bl
  0021a	8b 55 08	 mov	 edx, DWORD PTR _btClass$213872[ebp]
  0021d	52		 push	 edx
  0021e	68 cc 00 00 00	 push	 204			; 000000ccH
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1175 : 
; 1176 : 				LogAddTD("[Quest] Quest Clear (%s) : [%s][%s] Class:%d(%d), 3rd ChangeUp",
; 1177 : 					lpQuestInfo->Name, lpObj->AccountID, lpObj->Name, lpObj->DbClass, btClass);

  00229	0f b6 96 ba 00
	00 00		 movzx	 edx, BYTE PTR [esi+186]
  00230	0f b6 cb	 movzx	 ecx, bl
  00233	51		 push	 ecx
  00234	52		 push	 edx
  00235	8b 55 0c	 mov	 edx, DWORD PTR _lpQuestInfo$[ebp]
  00238	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0023b	50		 push	 eax
  0023c	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0023f	51		 push	 ecx
  00240	52		 push	 edx
  00241	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MIGJKFOH@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0024c	83 c4 28	 add	 esp, 40			; 00000028H
$LN39@QuestClear@2:
  0024f	8b 5d 0c	 mov	 ebx, DWORD PTR _lpQuestInfo$[ebp]
$LN36@QuestClear@2:

; 1178 : 			}
; 1179 : 			
; 1180 : 			if ( lpObj->ChangeUP == 1 ) //HermeX Add-on for fixing registers
; 1181 : 			{
; 1182 : #if(TESTSERVER==1)
; 1183 : 				LogAddTD("[Quest] Quest Clear - ChangeUP (%d) DbClass (%d) : [%s][%s]", lpObj->ChangeUP, lpObj->DbClass, lpObj->AccountID, lpObj->Name);
; 1184 : #endif
; 1185 : 			}
; 1186 : 
; 1187 : 			if ( lpSubInfo->QuestType == 1 )

  00252	83 3f 01	 cmp	 DWORD PTR [edi], 1
  00255	75 17		 jne	 SHORT $LN6@QuestClear@2

; 1188 : 			{
; 1189 : 				gObjDelteItemCountInInventory(lpObj->m_Index, lpSubInfo->NeedType, lpSubInfo->NeedSubType,
; 1190 : 					lpSubInfo->NeedNumber);

  00257	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0025a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0025d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00260	50		 push	 eax
  00261	8b 06		 mov	 eax, DWORD PTR [esi]
  00263	51		 push	 ecx
  00264	52		 push	 edx
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 ?gObjDelteItemCountInInventory@@YAXHHHH@Z ; gObjDelteItemCountInInventory
  0026b	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@QuestClear@2:

; 1191 : 			}
; 1192 : 
; 1193 : 			if ( lpSubInfo->QuestType == 2 ) //season 2.5 add-on

  0026e	83 3f 02	 cmp	 DWORD PTR [edi], 2
  00271	75 5c		 jne	 SHORT $LN5@QuestClear@2

; 1194 : 			{
; 1195 : 				lpObj->m_i3rdQuestIndex = -1;

  00273	83 c8 ff	 or	 eax, -1
  00276	89 86 60 10 00
	00		 mov	 DWORD PTR [esi+4192], eax

; 1196 : 				
; 1197 : 				for ( int n = 0;n<5;n++)
; 1198 : 				{
; 1199 : 					lpObj->MonsterKillInfo[n].MonIndex = -1;
; 1200 : 					lpObj->MonsterKillInfo[n].KillCount = -1;
; 1201 : 				}
; 1202 : 				LogAddTD("[Quest] Quest Clear - MonsterKillCount Reset (%s) : [%s][%s]", lpQuestInfo, lpObj->AccountID, lpObj->Name);

  0027c	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0027f	51		 push	 ecx
  00280	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  00283	52		 push	 edx
  00284	53		 push	 ebx
  00285	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GBDKNIEG@?$FLQuest?$FN?5Quest?5Clear?5?9?5MonsterKil@
  0028a	89 86 64 10 00
	00		 mov	 DWORD PTR [esi+4196], eax
  00290	89 86 68 10 00
	00		 mov	 DWORD PTR [esi+4200], eax
  00296	89 86 6c 10 00
	00		 mov	 DWORD PTR [esi+4204], eax
  0029c	89 86 70 10 00
	00		 mov	 DWORD PTR [esi+4208], eax
  002a2	89 86 74 10 00
	00		 mov	 DWORD PTR [esi+4212], eax
  002a8	89 86 78 10 00
	00		 mov	 DWORD PTR [esi+4216], eax
  002ae	89 86 7c 10 00
	00		 mov	 DWORD PTR [esi+4220], eax
  002b4	89 86 80 10 00
	00		 mov	 DWORD PTR [esi+4224], eax
  002ba	89 86 84 10 00
	00		 mov	 DWORD PTR [esi+4228], eax
  002c0	89 86 88 10 00
	00		 mov	 DWORD PTR [esi+4232], eax
  002c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002cc	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@QuestClear@2:

; 1203 : 			}
; 1204 : 
; 1205 : 			if( lpSubInfo->RewardSubType == QUEST_COMPENSATION_STATUP) //season 2.5 add-on

  002cf	81 7f 24 c8 00
	00 00		 cmp	 DWORD PTR [edi+36], 200	; 000000c8H
  002d6	75 45		 jne	 SHORT $LN20@QuestClear@2

; 1206 : 			{
; 1207 : 				lpObj->LevelUpPoint += lpSubInfo->RewardCount;

  002d8	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  002db	01 86 c0 00 00
	00		 add	 DWORD PTR [esi+192], eax

; 1208 : 				GCSendQuestPrize(lpObj->m_Index, QUEST_COMPENSATION_STATUP, lpSubInfo->RewardCount );

  002e1	0f b6 4f 28	 movzx	 ecx, BYTE PTR [edi+40]
  002e5	8b 16		 mov	 edx, DWORD PTR [esi]
  002e7	51		 push	 ecx
  002e8	68 c8 00 00 00	 push	 200			; 000000c8H
  002ed	52		 push	 edx
  002ee	e8 00 00 00 00	 call	 ?GCSendQuestPrize@@YAXHEE@Z ; GCSendQuestPrize

; 1209 : 				LogAddTD("[Quest] Quest Clear (%s) : [%s][%s] Stat(%d,%d), Class:%d PlusStat",
; 1210 : 					lpQuestInfo->Name, lpObj->AccountID, lpObj->Name, lpObj->LevelUpPoint,
; 1211 : 					lpSubInfo->RewardCount, lpObj->DbClass );

  002f3	0f b6 86 ba 00
	00 00		 movzx	 eax, BYTE PTR [esi+186]
  002fa	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  002fd	8b 96 c0 00 00
	00		 mov	 edx, DWORD PTR [esi+192]
  00303	50		 push	 eax
  00304	51		 push	 ecx
  00305	52		 push	 edx
  00306	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00309	50		 push	 eax
  0030a	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0030d	51		 push	 ecx
  0030e	53		 push	 ebx
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KLNCEAII@?$FLQuest?$FN?5Quest?5Clear?5?$CI?$CFs?$CJ?5?3?5?$FL?$CFs?$FN?$FL@
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0031a	83 c4 28	 add	 esp, 40			; 00000028H
$LN20@QuestClear@2:

; 1113 : 	int concount = lpQuestInfo->QuestConditionCount;
; 1114 : 	LPQUEST_SUB_INFO lpSubInfo;
; 1115 : 
; 1116 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  0031d	8b 45 fc	 mov	 eax, DWORD PTR _subquest$213851[ebp]
  00320	40		 inc	 eax
  00321	89 45 fc	 mov	 DWORD PTR _subquest$213851[ebp], eax
  00324	3b 45 f4	 cmp	 eax, DWORD PTR _subquestcount$[ebp]
  00327	0f 8c 28 fd ff
	ff		 jl	 $LL38@QuestClear@2
  0032d	5e		 pop	 esi
$LN19@QuestClear@2:
  0032e	5f		 pop	 edi

; 1212 : 			}
; 1213 : 		}
; 1214 : 	}
; 1215 : 	return TRUE;

  0032f	b8 01 00 00 00	 mov	 eax, 1
  00334	5b		 pop	 ebx

; 1216 : }

  00335	8b e5		 mov	 esp, ebp
  00337	5d		 pop	 ebp
  00338	c2 08 00	 ret	 8
?QuestClear@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP	; CQuestInfo::QuestClear
_TEXT	ENDS
PUBLIC	??_C@_0DI@HHHLGGKH@?$FLQuest?$FN?5QuestSave?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5index@ ; `string'
PUBLIC	?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestInfo::QuestInfoSave
;	COMDAT ??_C@_0DI@HHHLGGKH@?$FLQuest?$FN?5QuestSave?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5index@
; File e:\work\tranet_version\gs\gameserver\questinfo.h
CONST	SEGMENT
??_C@_0DI@HHHLGGKH@?$FLQuest?$FN?5QuestSave?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5index@ DB '['
	DB	'Quest] QuestSave [%s][%s] index(%d) name(%s) state(%s)', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\questinfo.cpp
CONST	ENDS
;	COMDAT ?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_questcount$ = -8					; size = 4
_foundquest$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CQuestInfo::QuestInfoSave, COMDAT
; _this$ = ecx

; 1220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1221 : 	int questcount = this->GetQeustCount();

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1222 : 	int foundquest = 0;

  0000b	33 f6		 xor	 esi, esi
  0000d	57		 push	 edi

; 1223 : 	LPQUEST_INFO lpQuestInfo;
; 1224 : 
; 1225 : 	for ( int i = 0 ; i<MAX_QUEST_INFO;i++)

  0000e	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00011	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00014	89 45 f8	 mov	 DWORD PTR _questcount$[ebp], eax
  00017	89 75 fc	 mov	 DWORD PTR _foundquest$[ebp], esi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL15@QuestInfoS:

; 1226 : 	{
; 1227 : 		lpQuestInfo = this->GetQuestInfo(i);

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00026	8b d8		 mov	 ebx, eax

; 1228 : 
; 1229 : 		if ( lpQuestInfo == NULL )

  00028	85 db		 test	 ebx, ebx
  0002a	74 37		 je	 SHORT $LN4@QuestInfoS

; 1230 : 		{
; 1231 : 			continue;
; 1232 : 		}
; 1233 : 
; 1234 : 		LogAddTD("[Quest] QuestSave [%s][%s] index(%d) name(%s) state(%s)",
; 1235 : 			lpObj->AccountID, lpObj->Name, i, lpQuestInfo->Name,
; 1236 : 			sQuestString[this->GetQuestState(lpObj, i)]);

  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00033	6b c0 32	 imul	 eax, 50			; 00000032H
  00036	05 00 00 00 00	 add	 eax, OFFSET ?sQuestString@@3PAY0DC@DA ; sQuestString
  0003b	50		 push	 eax
  0003c	53		 push	 ebx
  0003d	56		 push	 esi
  0003e	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  00041	51		 push	 ecx
  00042	8d 57 6c	 lea	 edx, DWORD PTR [edi+108]
  00045	52		 push	 edx
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HHHLGGKH@?$FLQuest?$FN?5QuestSave?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5index@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1237 : 		foundquest++;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _foundquest$[ebp]
  00054	40		 inc	 eax
  00055	83 c4 18	 add	 esp, 24			; 00000018H
  00058	89 45 fc	 mov	 DWORD PTR _foundquest$[ebp], eax

; 1238 : 
; 1239 : 		if ( foundquest == questcount )

  0005b	3b 45 f8	 cmp	 eax, DWORD PTR _questcount$[ebp]
  0005e	74 0c		 je	 SHORT $LN11@QuestInfoS
  00060	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
$LN4@QuestInfoS:

; 1223 : 	LPQUEST_INFO lpQuestInfo;
; 1224 : 
; 1225 : 	for ( int i = 0 ; i<MAX_QUEST_INFO;i++)

  00063	46		 inc	 esi
  00064	81 fe c8 00 00
	00		 cmp	 esi, 200		; 000000c8H
  0006a	7c b4		 jl	 SHORT $LL15@QuestInfoS
$LN11@QuestInfoS:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 1240 : 		{
; 1241 : 			break;
; 1242 : 		}
; 1243 : 	}
; 1244 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CQuestInfo::QuestInfoSave
_TEXT	ENDS
PUBLIC	?MonsterPlusKillCountParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z ; CQuestInfo::MonsterPlusKillCountParty
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
; Function compile flags: /Ogtp
;	COMDAT ?MonsterPlusKillCountParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv213 = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?MonsterPlusKillCountParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z PROC ; CQuestInfo::MonsterPlusKillCountParty, COMDAT
; _this$ = ecx

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1248 : 	if(lpTargetObj->Connected < PLAYER_PLAYING)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  00008	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  0000c	7d 0f		 jge	 SHORT $LN23@MonsterPlu

; 1249 : 	{
; 1250 : 		if(lpTargetObj->Live != FALSE)

  0000e	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0
  00012	74 09		 je	 SHORT $LN23@MonsterPlu

; 1251 : 		{
; 1252 : 			return FALSE;

  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 1335 : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN23@MonsterPlu:

; 1253 : 		}
; 1254 : 	}
; 1255 : 
; 1256 : 	int PartyNumber = lpTargetObj->PartyNumber;

  0001d	8b 86 2c 04 00
	00		 mov	 eax, DWORD PTR [esi+1068]
  00023	53		 push	 ebx

; 1257 : 
; 1258 : 	if(PartyNumber < 0)

  00024	85 c0		 test	 eax, eax
  00026	79 57		 jns	 SHORT $LN22@MonsterPlu

; 1259 : 	{
; 1260 : 		if(lpTargetObj->m_i3rdQuestIndex == -1)
; 1261 : 		{
; 1262 : 			return FALSE;

  00028	33 c0		 xor	 eax, eax
  0002a	83 be 60 10 00
	00 ff		 cmp	 DWORD PTR [esi+4192], -1
  00031	0f 84 e1 00 00
	00		 je	 $LN37@MonsterPlu

; 1263 : 		}
; 1264 : 
; 1265 : 		for ( int n = 0;n<5;n++)

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003a	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  00041	8d 8e 68 10 00
	00		 lea	 ecx, DWORD PTR [esi+4200]
  00047	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL20@MonsterPlu:

; 1266 : 		{
; 1267 : 			if(lpObj->Class == lpTargetObj->MonsterKillInfo[n].MonIndex)

  00050	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  00053	75 05		 jne	 SHORT $LN19@MonsterPlu

; 1268 : 			{
; 1269 : 				if(lpTargetObj->MonsterKillInfo[n].KillCount <= 50)

  00055	83 39 32	 cmp	 DWORD PTR [ecx], 50	; 00000032H
  00058	7e 14		 jle	 SHORT $LN30@MonsterPlu
$LN19@MonsterPlu:

; 1263 : 		}
; 1264 : 
; 1265 : 		for ( int n = 0;n<5;n++)

  0005a	03 c3		 add	 eax, ebx
  0005c	83 c1 08	 add	 ecx, 8
  0005f	83 f8 05	 cmp	 eax, 5
  00062	7c ec		 jl	 SHORT $LL20@MonsterPlu

; 1327 : 							break;
; 1328 : 						}
; 1329 : 					}
; 1330 : 				}
; 1331 : 			}
; 1332 : 	}
; 1333 : 
; 1334 : 	return TRUE;

  00064	8b c3		 mov	 eax, ebx
  00066	5b		 pop	 ebx
  00067	5e		 pop	 esi

; 1335 : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
$LN30@MonsterPlu:

; 1270 : 				{
; 1271 : 					lpTargetObj->MonsterKillInfo[n].KillCount++;

  0006e	01 9c c6 68 10
	00 00		 add	 DWORD PTR [esi+eax*8+4200], ebx

; 1327 : 							break;
; 1328 : 						}
; 1329 : 					}
; 1330 : 				}
; 1331 : 			}
; 1332 : 	}
; 1333 : 
; 1334 : 	return TRUE;

  00075	8b c3		 mov	 eax, ebx
  00077	5b		 pop	 ebx
  00078	5e		 pop	 esi

; 1335 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
$LN22@MonsterPlu:

; 1272 : 					break;
; 1273 : 				}
; 1274 : 			}
; 1275 : 		}
; 1276 : 	}
; 1277 : 	else
; 1278 : 	{
; 1279 : 			int TargetPartyNumber = lpTargetObj->PartyNumber; //loc4

  0007f	6b c0 68	 imul	 eax, 104		; 00000068H
  00082	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  00087	57		 push	 edi
  00088	8b f8		 mov	 edi, eax
  0008a	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR tv213[ebp], 10 ; 0000000aH
  00091	bb 01 00 00 00	 mov	 ebx, 1
$LL36@MonsterPlu:

; 1285 : 			{
; 1286 : 				LocalPartyNumber = gParty.m_PartyS[TargetPartyNumber].Number[n];

  00096	8b 37		 mov	 esi, DWORD PTR [edi]

; 1287 : 
; 1288 : 				if(LocalPartyNumber < 0)

  00098	85 f6		 test	 esi, esi
  0009a	78 71		 js	 SHORT $LN13@MonsterPlu

; 1289 : 				{
; 1290 : 					continue;
; 1291 : 				}
; 1292 : 
; 1293 : 				loc6 = &gObj[LocalPartyNumber];

  0009c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000a2	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1294 : 
; 1295 : 				if(loc6->Connected < 3)

  000a8	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  000ac	7d 06		 jge	 SHORT $LN9@MonsterPlu

; 1296 : 				{
; 1297 : 					if(loc6->Live != FALSE)

  000ae	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0
  000b2	75 59		 jne	 SHORT $LN13@MonsterPlu
$LN9@MonsterPlu:

; 1298 : 					{
; 1299 : 						continue;
; 1300 : 					}
; 1301 : 				}
; 1302 : 				
; 1303 : 				if (lpTargetObj->MapNumber != loc6->MapNumber)

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000b7	8a 90 49 01 00
	00		 mov	 dl, BYTE PTR [eax+329]
  000bd	3a 96 49 01 00
	00		 cmp	 dl, BYTE PTR [esi+329]
  000c3	75 48		 jne	 SHORT $LN13@MonsterPlu

; 1304 : 				{
; 1305 : 					continue;
; 1306 : 				}
; 1307 : 
; 1308 : 				dis = gObjCalDistance(lpTargetObj,loc6);

  000c5	56		 push	 esi
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000cc	83 c4 08	 add	 esp, 8

; 1309 : 
; 1310 : 				if(dis > 25)

  000cf	83 f8 19	 cmp	 eax, 25			; 00000019H
  000d2	7f 39		 jg	 SHORT $LN13@MonsterPlu

; 1311 : 				{
; 1312 : 					continue;
; 1313 : 				}
; 1314 : 
; 1315 : 				if(loc6->m_i3rdQuestIndex == -1)

  000d4	83 be 60 10 00
	00 ff		 cmp	 DWORD PTR [esi+4192], -1
  000db	74 30		 je	 SHORT $LN13@MonsterPlu

; 1316 : 				{
; 1317 : 					continue;
; 1318 : 				}
; 1319 : 
; 1320 : 				for ( int n=0;n<5;n++)

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e0	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  000e7	33 c0		 xor	 eax, eax
  000e9	8d 8e 68 10 00
	00		 lea	 ecx, DWORD PTR [esi+4200]
  000ef	90		 npad	 1
$LL5@MonsterPlu:

; 1321 : 				{
; 1322 : 					if(lpObj->Class == loc6->MonsterKillInfo[n].MonIndex)

  000f0	3b 51 fc	 cmp	 edx, DWORD PTR [ecx-4]
  000f3	75 05		 jne	 SHORT $LN4@MonsterPlu

; 1323 : 					{
; 1324 : 						if(loc6->MonsterKillInfo[n].KillCount <= 50)

  000f5	83 39 32	 cmp	 DWORD PTR [ecx], 50	; 00000032H
  000f8	7e 0c		 jle	 SHORT $LN31@MonsterPlu
$LN4@MonsterPlu:

; 1316 : 				{
; 1317 : 					continue;
; 1318 : 				}
; 1319 : 
; 1320 : 				for ( int n=0;n<5;n++)

  000fa	03 c3		 add	 eax, ebx
  000fc	83 c1 08	 add	 ecx, 8
  000ff	83 f8 05	 cmp	 eax, 5
  00102	7c ec		 jl	 SHORT $LL5@MonsterPlu

; 1323 : 					{
; 1324 : 						if(loc6->MonsterKillInfo[n].KillCount <= 50)

  00104	eb 07		 jmp	 SHORT $LN13@MonsterPlu
$LN31@MonsterPlu:

; 1325 : 						{
; 1326 : 							loc6->MonsterKillInfo[n].KillCount++;

  00106	01 9c c6 68 10
	00 00		 add	 DWORD PTR [esi+eax*8+4200], ebx
$LN13@MonsterPlu:

; 1280 : 			int LocalPartyNumber; //loc5
; 1281 : 			LPOBJ loc6; //loc6
; 1282 : 			int dis = 0;
; 1283 : 
; 1284 : 			for ( int n=0;n<MAX_USER_IN_PARTY;n++) //loc8

  0010d	83 c7 04	 add	 edi, 4
  00110	29 5d fc	 sub	 DWORD PTR tv213[ebp], ebx
  00113	75 81		 jne	 SHORT $LL36@MonsterPlu

; 1327 : 							break;
; 1328 : 						}
; 1329 : 					}
; 1330 : 				}
; 1331 : 			}
; 1332 : 	}
; 1333 : 
; 1334 : 	return TRUE;

  00115	5f		 pop	 edi
  00116	8b c3		 mov	 eax, ebx
$LN37@MonsterPlu:
  00118	5b		 pop	 ebx
  00119	5e		 pop	 esi

; 1335 : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 08 00	 ret	 8
?MonsterPlusKillCountParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP ; CQuestInfo::MonsterPlusKillCountParty
_TEXT	ENDS
PUBLIC	??_C@_0EM@GFMDAEDC@?$FLQuest?$FN?5Error?5?9?5Invalid?5MonsterK@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_QuestIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendQuestKillCountInfo@CQuestInfo@@QAEHHH@Z	; CQuestInfo::GCSendQuestKillCountInfo
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestUtil::Quest3rdRequestInfo
EXTRN	?g_QuestUtil@@3VCQuestUtil@@A:DWORD		; g_QuestUtil
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
;	COMDAT ??_C@_0EM@GFMDAEDC@?$FLQuest?$FN?5Error?5?9?5Invalid?5MonsterK@
CONST	SEGMENT
??_C@_0EM@GFMDAEDC@?$FLQuest?$FN?5Error?5?9?5Invalid?5MonsterK@ DB '[Ques'
	DB	't] Error - Invalid MonsterKillInfo [%s][%s] (QuestIndex:%d/DB'
	DB	'Index:%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCSendQuestKillCountInfo@CQuestInfo@@QAEHHH@Z
_TEXT	SEGMENT
_lpQuestInfo$ = -68					; size = 4
_aIndex$GSCopy$ = -64					; size = 4
_subquestcount$ = -60					; size = 4
_QuestIndex$GSCopy$ = -56				; size = 4
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_QuestIndex$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GCSendQuestKillCountInfo@CQuestInfo@@QAEHHH@Z PROC	; CQuestInfo::GCSendQuestKillCountInfo, COMDAT
; _this$ = ecx

; 1338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 1339 : 	PMSG_SETQUEST_KILLCOUNT pMsg;
; 1340 : 
; 1341 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xA4, 0x00, sizeof(pMsg));

  00018	6a 30		 push	 48			; 00000030H
  0001a	6a 00		 push	 0
  0001c	8b d9		 mov	 ebx, ecx
  0001e	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00021	68 a4 00 00 00	 push	 164			; 000000a4H
  00026	51		 push	 ecx

; 1362 : 	int concount = lpQuestInfo->QuestConditionCount; //loc18
; 1363 : 	LPQUEST_SUB_INFO lpSubInfo; //loc19
; 1364 : 
; 1365 : 	int loc20 = 0; //loc20
; 1366 : 
; 1367 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  00027	89 45 c8	 mov	 DWORD PTR _QuestIndex$GSCopy$[ebp], eax
  0002a	89 75 c0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00032	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00038	8b 45 c8	 mov	 eax, DWORD PTR _QuestIndex$GSCopy$[ebp]
  0003b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	50		 push	 eax
  00045	56		 push	 esi
  00046	8b cb		 mov	 ecx, ebx
  00048	c6 45 d0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0004c	88 45 d1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0004f	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00054	83 f8 01	 cmp	 eax, 1
  00057	74 17		 je	 SHORT $LN14@GCSendQues
$LN31@GCSendQues:
  00059	5e		 pop	 esi

; 1342 : 	pMsg.Result = 0; //loc12
; 1343 : 	pMsg.QuestIndex = QuestIndex; //loc13
; 1344 : 
; 1345 : 	LPOBJ lpObj = &gObj[aIndex]; //loc14
; 1346 : 
; 1347 : 	int QuestState = this->GetQuestState(lpObj, QuestIndex); //loc15
; 1348 : 
; 1349 : 	if(QuestState != TRUE)
; 1350 : 	{
; 1351 : 		return TRUE;

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	5b		 pop	 ebx

; 1410 : 	}
; 1411 : 
; 1412 : 	return TRUE;
; 1413 : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
$LN14@GCSendQues:

; 1352 : 	}
; 1353 : 
; 1354 : 	LPQUEST_INFO lpQuestInfo = this->GetQuestInfo(QuestIndex); //loc16

  00070	8b 55 c8	 mov	 edx, DWORD PTR _QuestIndex$GSCopy$[ebp]
  00073	52		 push	 edx
  00074	8b cb		 mov	 ecx, ebx
  00076	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  0007b	89 45 bc	 mov	 DWORD PTR _lpQuestInfo$[ebp], eax

; 1355 : 
; 1356 : 	if(lpQuestInfo == NULL)

  0007e	85 c0		 test	 eax, eax

; 1357 : 	{
; 1358 : 		return TRUE;

  00080	74 d7		 je	 SHORT $LN31@GCSendQues

; 1359 : 	}
; 1360 : 
; 1361 : 	int subquestcount = lpQuestInfo->QuestSubInfoCount; //loc17

  00082	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00085	57		 push	 edi

; 1362 : 	int concount = lpQuestInfo->QuestConditionCount; //loc18
; 1363 : 	LPQUEST_SUB_INFO lpSubInfo; //loc19
; 1364 : 
; 1365 : 	int loc20 = 0; //loc20
; 1366 : 
; 1367 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  00086	33 ff		 xor	 edi, edi
  00088	89 4d c4	 mov	 DWORD PTR _subquestcount$[ebp], ecx
  0008b	85 c9		 test	 ecx, ecx
  0008d	0f 8e 22 01 00
	00		 jle	 $LN1@GCSendQues
  00093	eb 03		 jmp	 SHORT $LN12@GCSendQues
$LL29@GCSendQues:
  00095	8b 45 bc	 mov	 eax, DWORD PTR _lpQuestInfo$[ebp]
$LN12@GCSendQues:

; 1368 : 	{
; 1369 : 		lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, subquest);

  00098	57		 push	 edi
  00099	50		 push	 eax
  0009a	56		 push	 esi
  0009b	8b cb		 mov	 ecx, ebx
  0009d	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo

; 1370 : 
; 1371 : 		if ( lpSubInfo != NULL )

  000a2	85 c0		 test	 eax, eax
  000a4	74 05		 je	 SHORT $LN11@GCSendQues

; 1372 : 		{
; 1373 : 			loc20 = 1;
; 1374 : 			if(lpSubInfo->QuestType == 2)

  000a6	83 38 02	 cmp	 DWORD PTR [eax], 2
  000a9	74 0b		 je	 SHORT $LN19@GCSendQues
$LN11@GCSendQues:

; 1362 : 	int concount = lpQuestInfo->QuestConditionCount; //loc18
; 1363 : 	LPQUEST_SUB_INFO lpSubInfo; //loc19
; 1364 : 
; 1365 : 	int loc20 = 0; //loc20
; 1366 : 
; 1367 : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  000ab	47		 inc	 edi
  000ac	3b 7d c4	 cmp	 edi, DWORD PTR _subquestcount$[ebp]
  000af	7c e4		 jl	 SHORT $LL29@GCSendQues

; 1372 : 		{
; 1373 : 			loc20 = 1;
; 1374 : 			if(lpSubInfo->QuestType == 2)

  000b1	e9 ff 00 00 00	 jmp	 $LN1@GCSendQues
$LN19@GCSendQues:

; 1375 : 			{
; 1376 : 				if(lpObj->m_i3rdQuestState == 0)

  000b6	8b 86 5c 10 00
	00		 mov	 eax, DWORD PTR [esi+4188]
  000bc	85 c0		 test	 eax, eax
  000be	75 20		 jne	 SHORT $LN7@GCSendQues

; 1377 : 				{
; 1378 : 					g_QuestUtil.Quest3rdRequestInfo(lpObj);

  000c0	56		 push	 esi
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestUtil@@3VCQuestUtil@@A ; g_QuestUtil
  000c6	e8 00 00 00 00	 call	 ?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestUtil::Quest3rdRequestInfo
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 1379 : 					return FALSE;

  000cd	33 c0		 xor	 eax, eax
  000cf	5b		 pop	 ebx

; 1410 : 	}
; 1411 : 
; 1412 : 	return TRUE;
; 1413 : }

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d3	33 cd		 xor	 ecx, ebp
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 08 00	 ret	 8
$LN7@GCSendQues:

; 1380 : 				}
; 1381 : 				if(lpObj->m_i3rdQuestState == 1)

  000e0	83 f8 01	 cmp	 eax, 1
  000e3	75 54		 jne	 SHORT $LN5@GCSendQues

; 1382 : 				{
; 1383 : 					if(lpObj->m_i3rdQuestIndex == -1)

  000e5	83 be 60 10 00
	00 ff		 cmp	 DWORD PTR [esi+4192], -1
  000ec	75 4b		 jne	 SHORT $LN5@GCSendQues

; 1384 : 					{
; 1385 : 						lpObj->m_i3rdQuestState = 0;
; 1386 : 						g_QuestUtil.Quest3rdRequestInfo(lpObj);

  000ee	56		 push	 esi
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestUtil@@3VCQuestUtil@@A ; g_QuestUtil
  000f4	c7 86 5c 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4188], 0
  000fe	e8 00 00 00 00	 call	 ?Quest3rdRequestInfo@CQuestUtil@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestUtil::Quest3rdRequestInfo

; 1387 : 						LogAddTD("[Quest] Error - Invalid MonsterKillInfo [%s][%s] (QuestIndex:%d/DBIndex:%d)",lpObj->AccountID, lpObj->Name, QuestIndex, lpObj->m_i3rdQuestIndex);

  00103	8b 86 60 10 00
	00		 mov	 eax, DWORD PTR [esi+4192]
  00109	8b 4d c8	 mov	 ecx, DWORD PTR _QuestIndex$GSCopy$[ebp]
  0010c	50		 push	 eax
  0010d	51		 push	 ecx
  0010e	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00111	52		 push	 edx
  00112	83 c6 6c	 add	 esi, 108		; 0000006cH
  00115	56		 push	 esi
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@GFMDAEDC@?$FLQuest?$FN?5Error?5?9?5Invalid?5MonsterK@
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00121	83 c4 14	 add	 esp, 20			; 00000014H
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi

; 1388 : 						return FALSE;

  00126	33 c0		 xor	 eax, eax
  00128	5b		 pop	 ebx

; 1410 : 	}
; 1411 : 
; 1412 : 	return TRUE;
; 1413 : }

  00129	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012c	33 cd		 xor	 ecx, ebp
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
$LN5@GCSendQues:

; 1389 : 					}
; 1390 : 				}
; 1391 : 				
; 1392 : 				pMsg.Result = 1;

  00139	c6 45 d0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 1393 : 				pMsg.QuestIndex = lpObj->m_i3rdQuestIndex;

  0013d	8a 86 60 10 00
	00		 mov	 al, BYTE PTR [esi+4192]
  00143	88 45 d1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 1394 : 
; 1395 : 				int loc22 = 0; //loc22
; 1396 : 
; 1397 : 				for ( int n=0;n<5;n++) //loc23
; 1398 : 				{
; 1399 : 					pMsg.dwData[loc22] = lpObj->MonsterKillInfo[n].MonIndex; loc22++;

  00146	8b 8e 64 10 00
	00		 mov	 ecx, DWORD PTR [esi+4196]
  0014c	89 4d d4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 1400 : 					pMsg.dwData[loc22] = lpObj->MonsterKillInfo[n].KillCount; loc22++;

  0014f	8b 96 68 10 00
	00		 mov	 edx, DWORD PTR [esi+4200]
  00155	89 55 d8	 mov	 DWORD PTR _pMsg$[ebp+12], edx
  00158	8b 86 6c 10 00
	00		 mov	 eax, DWORD PTR [esi+4204]
  0015e	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00161	8b 8e 70 10 00
	00		 mov	 ecx, DWORD PTR [esi+4208]
  00167	89 4d e0	 mov	 DWORD PTR _pMsg$[ebp+20], ecx
  0016a	8b 96 74 10 00
	00		 mov	 edx, DWORD PTR [esi+4212]
  00170	89 55 e4	 mov	 DWORD PTR _pMsg$[ebp+24], edx
  00173	8b 86 78 10 00
	00		 mov	 eax, DWORD PTR [esi+4216]
  00179	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+28], eax
  0017c	8b 8e 7c 10 00
	00		 mov	 ecx, DWORD PTR [esi+4220]
  00182	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+32], ecx
  00185	8b 96 80 10 00
	00		 mov	 edx, DWORD PTR [esi+4224]
  0018b	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+36], edx
  0018e	8b 86 84 10 00
	00		 mov	 eax, DWORD PTR [esi+4228]

; 1401 : 				}
; 1402 : 				break;
; 1403 : 			}
; 1404 : 		}
; 1405 : 	}
; 1406 : 	//
; 1407 : 	if(pMsg.Result == 1)
; 1408 : 	{
; 1409 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00194	0f b6 55 cd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00198	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+40], eax
  0019b	8b 8e 88 10 00
	00		 mov	 ecx, DWORD PTR [esi+4232]
  001a1	52		 push	 edx
  001a2	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001a5	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+44], ecx
  001a8	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001ab	50		 push	 eax
  001ac	51		 push	 ecx
  001ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendQues:

; 1410 : 	}
; 1411 : 
; 1412 : 	return TRUE;
; 1413 : }

  001b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi
  001ba	33 cd		 xor	 ecx, ebp
  001bc	b8 01 00 00 00	 mov	 eax, 1
  001c1	5b		 pop	 ebx
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 08 00	 ret	 8
?GCSendQuestKillCountInfo@CQuestInfo@@QAEHHH@Z ENDP	; CQuestInfo::GCSendQuestKillCountInfo
_TEXT	ENDS
PUBLIC	?GCReqWerewolfMove@CQuestInfo@@QAEXH@Z		; CQuestInfo::GCReqWerewolfMove
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
; Function compile flags: /Ogtp
;	COMDAT ?GCReqWerewolfMove@CQuestInfo@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
tv185 = -4						; size = 4
_aIndex$ = 8						; size = 4
?GCReqWerewolfMove@CQuestInfo@@QAEXH@Z PROC		; CQuestInfo::GCReqWerewolfMove, COMDAT
; _this$ = ecx

; 1417 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1418 : 	LPOBJ lpObj = &gObj[aIndex]; //loc2

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fb		 mov	 edi, ebx
  0000e	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00014	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	8b f1		 mov	 esi, ecx

; 1419 : 
; 1420 : 	if(lpObj == NULL)

  0001c	0f 84 40 01 00
	00		 je	 $LN13@GCReqWerew

; 1421 : 	{
; 1422 : 		return;
; 1423 : 	}
; 1424 : 
; 1425 : 	PMSG_WEREWOLF_MOVE pMsg;
; 1426 : 
; 1427 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD0, 0x07, sizeof(pMsg));

  00022	6a 05		 push	 5
  00024	6a 07		 push	 7
  00026	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	68 d0 00 00 00	 push	 208			; 000000d0H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1428 : 	pMsg.result = 0;
; 1429 : 	
; 1430 : 	int ReqZen = 3000000; //loc5
; 1431 : 	int ReqLvl = 350; //loc6
; 1432 : 
; 1433 : 	if(lpObj->Level < 350 || lpObj->Money < ReqZen)

  00034	b9 5e 01 00 00	 mov	 ecx, 350		; 0000015eH
  00039	83 c4 10	 add	 esp, 16			; 00000010H
  0003c	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00040	66 39 8f be 00
	00 00		 cmp	 WORD PTR [edi+190], cx
  00047	0f 8c ff 00 00
	00		 jl	 $LN14@GCReqWerew
  0004d	81 bf f0 00 00
	00 c0 c6 2d 00	 cmp	 DWORD PTR [edi+240], 3000000 ; 002dc6c0H
  00057	0f 8c ef 00 00
	00		 jl	 $LN14@GCReqWerew

; 1437 : 		return;
; 1438 : 	}
; 1439 : 
; 1440 : 	int QuestState = this->GetQuestState(lpObj, 5); //loc7

  0005d	6a 05		 push	 5
  0005f	57		 push	 edi
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState

; 1441 : 	
; 1442 : 	if(QuestState == 1 || QuestState == 2)

  00067	83 f8 01	 cmp	 eax, 1
  0006a	74 09		 je	 SHORT $LN12@GCReqWerew
  0006c	83 f8 02	 cmp	 eax, 2
  0006f	0f 85 ed 00 00
	00		 jne	 $LN13@GCReqWerew
$LN12@GCReqWerew:

; 1443 : 	{
; 1444 : 		LPOBJ loc8; //loc8
; 1445 : 		int PartyNumber = lpObj->PartyNumber; //loc9

  00075	8b 87 2c 04 00
	00		 mov	 eax, DWORD PTR [edi+1068]

; 1446 : 		int LocalPartyNumber; //loc10
; 1447 : 		int dis; //loc11
; 1448 : 		BOOL bMoveGateSuccess = FALSE; //loc12
; 1449 : 
; 1450 : 		if(PartyNumber >=0)

  0007b	85 c0		 test	 eax, eax
  0007d	0f 88 87 00 00
	00		 js	 $LN8@GCReqWerew

; 1451 : 		{
; 1452 : 			for ( int n=0;n<MAX_USER_IN_PARTY;n++) //loc13

  00083	6b c0 68	 imul	 eax, 104		; 00000068H
  00086	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  0008b	8b d8		 mov	 ebx, eax
  0008d	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR tv185[ebp], 10 ; 0000000aH
$LL10@GCReqWerew:

; 1453 : 			{
; 1454 : 				LocalPartyNumber = gParty.m_PartyS[PartyNumber].Number[n];

  00094	8b 33		 mov	 esi, DWORD PTR [ebx]

; 1455 : 
; 1456 : 				if(LocalPartyNumber < 0)

  00096	85 f6		 test	 esi, esi
  00098	78 65		 js	 SHORT $LN9@GCReqWerew

; 1457 : 				{
; 1458 : 					continue;
; 1459 : 				}
; 1460 : 
; 1461 : 				if(aIndex == LocalPartyNumber)

  0009a	39 75 08	 cmp	 DWORD PTR _aIndex$[ebp], esi
  0009d	74 60		 je	 SHORT $LN9@GCReqWerew

; 1462 : 				{
; 1463 : 					continue;
; 1464 : 				}
; 1465 : 
; 1466 : 				loc8 = &gObj[LocalPartyNumber];

  0009f	8b c6		 mov	 eax, esi
  000a1	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000a7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1467 : 
; 1468 : 				if(loc8->Level < ReqLvl)

  000ad	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  000b2	66 39 90 be 00
	00 00		 cmp	 WORD PTR [eax+190], dx
  000b9	7c 44		 jl	 SHORT $LN9@GCReqWerew

; 1469 : 				{
; 1470 : 					continue;
; 1471 : 				}
; 1472 : 
; 1473 : 				if(lpObj->MapNumber == loc8->MapNumber)

  000bb	8a 8f 49 01 00
	00		 mov	 cl, BYTE PTR [edi+329]
  000c1	3a 88 49 01 00
	00		 cmp	 cl, BYTE PTR [eax+329]
  000c7	75 36		 jne	 SHORT $LN9@GCReqWerew

; 1474 : 				{
; 1475 : 					dis = gObjCalDistance(lpObj,loc8);

  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000d0	83 c4 08	 add	 esp, 8

; 1476 : 
; 1477 : 					if(dis < 10)

  000d3	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000d6	7d 27		 jge	 SHORT $LN9@GCReqWerew

; 1478 : 					{
; 1479 : 						bMoveGateSuccess = gObjMoveGate(LocalPartyNumber,256);

  000d8	68 00 01 00 00	 push	 256			; 00000100H
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000e3	83 c4 08	 add	 esp, 8

; 1480 : 						
; 1481 : 						if(bMoveGateSuccess == FALSE)

  000e6	85 c0		 test	 eax, eax
  000e8	75 15		 jne	 SHORT $LN9@GCReqWerew

; 1482 : 						{
; 1483 : 							pMsg.result = 0;
; 1484 : 							DataSend(LocalPartyNumber, (LPBYTE)&pMsg, pMsg.h.size);

  000ea	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000ee	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al
  000f1	52		 push	 edx
  000f2	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000f5	50		 push	 eax
  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@GCReqWerew:

; 1451 : 		{
; 1452 : 			for ( int n=0;n<MAX_USER_IN_PARTY;n++) //loc13

  000ff	83 c3 04	 add	 ebx, 4
  00102	ff 4d fc	 dec	 DWORD PTR tv185[ebp]
  00105	75 8d		 jne	 SHORT $LL10@GCReqWerew
  00107	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
$LN8@GCReqWerew:

; 1485 : 						}
; 1486 : 					}
; 1487 : 				}
; 1488 : 
; 1489 : 			}
; 1490 : 		}
; 1491 : 
; 1492 : 		bMoveGateSuccess = gObjMoveGate(aIndex,256);

  0010a	68 00 01 00 00	 push	 256			; 00000100H
  0010f	53		 push	 ebx
  00110	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00115	83 c4 08	 add	 esp, 8

; 1493 : 						
; 1494 : 		if(bMoveGateSuccess != FALSE)

  00118	85 c0		 test	 eax, eax
  0011a	74 25		 je	 SHORT $LN1@GCReqWerew

; 1495 : 		{
; 1496 : 			lpObj->Money -= ReqZen;

  0011c	81 87 f0 00 00
	00 40 39 d2 ff	 add	 DWORD PTR [edi+240], -3000000 ; ffd23940H
  00126	8b 87 f0 00 00
	00		 mov	 eax, DWORD PTR [edi+240]

; 1497 : 			GCMoneySend(lpObj->m_Index,lpObj->Money);

  0012c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0012e	50		 push	 eax
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00135	83 c4 08	 add	 esp, 8
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx

; 1503 : 	}
; 1504 : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 04 00	 ret	 4
$LN1@GCReqWerew:

; 1498 : 			return;
; 1499 : 		}
; 1500 : 		
; 1501 : 		pMsg.result = 0;
; 1502 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00141	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00145	52		 push	 edx
  00146	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00149	50		 push	 eax
  0014a	eb 09		 jmp	 SHORT $LN22@GCReqWerew
$LN14@GCReqWerew:

; 1434 : 	{
; 1435 : 		pMsg.result = 0;
; 1436 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0014c	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00150	51		 push	 ecx
  00151	8d 55 f4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00154	52		 push	 edx
$LN22@GCReqWerew:
  00155	53		 push	 ebx
  00156	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0015a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@GCReqWerew:
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 1503 : 	}
; 1504 : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 04 00	 ret	 4
?GCReqWerewolfMove@CQuestInfo@@QAEXH@Z ENDP		; CQuestInfo::GCReqWerewolfMove
_TEXT	ENDS
PUBLIC	?GCReqGateKeeperMove@CQuestInfo@@QAEXH@Z	; CQuestInfo::GCReqGateKeeperMove
; Function compile flags: /Ogtp
;	COMDAT ?GCReqGateKeeperMove@CQuestInfo@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
tv284 = -4						; size = 4
_aIndex$ = 8						; size = 4
?GCReqGateKeeperMove@CQuestInfo@@QAEXH@Z PROC		; CQuestInfo::GCReqGateKeeperMove, COMDAT
; _this$ = ecx

; 1508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1509 : 	LPOBJ lpObj = &gObj[aIndex]; //loc2

  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	57		 push	 edi
  0000b	8b fe		 mov	 edi, esi
  0000d	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00013	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1510 : 
; 1511 : 	if(lpObj == NULL)

  00019	0f 84 15 01 00
	00		 je	 $LN1@GCReqGateK

; 1512 : 	{
; 1513 : 		return;
; 1514 : 	}
; 1515 : 
; 1516 : 	PMSG_GATEKEEPER_MOVE pMsg;
; 1517 : 
; 1518 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD0, 0x08, sizeof(pMsg));

  0001f	6a 05		 push	 5
  00021	6a 08		 push	 8
  00023	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00026	68 d0 00 00 00	 push	 208			; 000000d0H
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 1519 : 	pMsg.result = 0;
; 1520 : 	
; 1521 : 	int ReqLvl = 350; //loc5
; 1522 : 
; 1523 : 	if(lpObj->Level < ReqLvl)

  00031	b9 5e 01 00 00	 mov	 ecx, 350		; 0000015eH
  00036	83 c4 10	 add	 esp, 16			; 00000010H
  00039	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0003d	66 39 8f be 00
	00 00		 cmp	 WORD PTR [edi+190], cx
  00044	7d 1e		 jge	 SHORT $LN13@GCReqGateK

; 1524 : 	{
; 1525 : 		pMsg.result = 0;
; 1526 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00046	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0004a	52		 push	 edx
  0004b	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004e	50		 push	 eax
  0004f	56		 push	 esi
  00050	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 1591 : 	}
; 1592 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
$LN13@GCReqGateK:

; 1527 : 		return;
; 1528 : 	}
; 1529 : 
; 1530 : 	if(lpObj->m_i3rdQuestIndex != 6)

  00064	83 bf 60 10 00
	00 06		 cmp	 DWORD PTR [edi+4192], 6
  0006b	74 1e		 je	 SHORT $LN12@GCReqGateK

; 1531 : 	{
; 1532 : 		pMsg.result = 0;
; 1533 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0006d	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00071	51		 push	 ecx
  00072	8d 55 f4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00075	52		 push	 edx
  00076	56		 push	 esi
  00077	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 1591 : 	}
; 1592 : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$LN12@GCReqGateK:

; 1534 : 		return;
; 1535 : 	}
; 1536 : 
; 1537 : 	LPOBJ loc6; //loc6
; 1538 : 	int PartyNumber = lpObj->PartyNumber; //loc7

  0008b	8b 87 2c 04 00
	00		 mov	 eax, DWORD PTR [edi+1068]
  00091	53		 push	 ebx

; 1539 : 	int LocalPartyNumber; //loc8
; 1540 : 	int dis; //loc9
; 1541 : 	BOOL bMoveGateSuccess = FALSE; //loc10
; 1542 : 
; 1543 : 	if(PartyNumber >=0)

  00092	85 c0		 test	 eax, eax
  00094	78 75		 js	 SHORT $LN8@GCReqGateK

; 1544 : 	{
; 1545 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++) //loc11

  00096	6b c0 68	 imul	 eax, 104		; 00000068H
  00099	33 db		 xor	 ebx, ebx
  0009b	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  000a0	89 45 fc	 mov	 DWORD PTR tv284[ebp], eax
$LL23@GCReqGateK:

; 1546 : 		{
; 1547 : 			LocalPartyNumber = gParty.m_PartyS[PartyNumber].Number[n];

  000a3	8b 30		 mov	 esi, DWORD PTR [eax]

; 1548 : 
; 1549 : 			if(LocalPartyNumber < 0)

  000a5	85 f6		 test	 esi, esi
  000a7	78 50		 js	 SHORT $LN9@GCReqGateK

; 1550 : 			{
; 1551 : 				continue;
; 1552 : 			}
; 1553 : 
; 1554 : 			if(aIndex == LocalPartyNumber)

  000a9	39 75 08	 cmp	 DWORD PTR _aIndex$[ebp], esi
  000ac	74 4b		 je	 SHORT $LN9@GCReqGateK

; 1555 : 			{
; 1556 : 				continue;
; 1557 : 			}
; 1558 : 
; 1559 : 			loc6 = &gObj[LocalPartyNumber];

  000ae	8b c6		 mov	 eax, esi
  000b0	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000b6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1560 : 
; 1561 : 			if(loc6->Level < ReqLvl)

  000bc	b9 5e 01 00 00	 mov	 ecx, 350		; 0000015eH
  000c1	66 39 88 be 00
	00 00		 cmp	 WORD PTR [eax+190], cx
  000c8	7c 2f		 jl	 SHORT $LN9@GCReqGateK

; 1562 : 			{
; 1563 : 				continue;
; 1564 : 			}
; 1565 : 
; 1566 : 			if(lpObj->MapNumber == loc6->MapNumber)

  000ca	8a 97 49 01 00
	00		 mov	 dl, BYTE PTR [edi+329]
  000d0	3a 90 49 01 00
	00		 cmp	 dl, BYTE PTR [eax+329]
  000d6	75 21		 jne	 SHORT $LN9@GCReqGateK

; 1567 : 			{
; 1568 : 				dis = gObjCalDistance(lpObj,loc6);

  000d8	50		 push	 eax
  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000df	83 c4 08	 add	 esp, 8

; 1569 : 
; 1570 : 				if(dis < 10)

  000e2	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  000e5	7d 12		 jge	 SHORT $LN9@GCReqGateK

; 1571 : 				{
; 1572 : 					bMoveGateSuccess = gObjMoveGate(LocalPartyNumber,257);

  000e7	68 01 01 00 00	 push	 257			; 00000101H
  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000f2	83 c4 08	 add	 esp, 8

; 1573 : 				
; 1574 : 					if(bMoveGateSuccess == FALSE)

  000f5	85 c0		 test	 eax, eax
  000f7	74 43		 je	 SHORT $LN18@GCReqGateK
$LN9@GCReqGateK:

; 1544 : 	{
; 1545 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++) //loc11

  000f9	8b 45 fc	 mov	 eax, DWORD PTR tv284[ebp]
  000fc	43		 inc	 ebx
  000fd	83 c0 04	 add	 eax, 4
  00100	89 45 fc	 mov	 DWORD PTR tv284[ebp], eax
  00103	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00106	7c 9b		 jl	 SHORT $LL23@GCReqGateK

; 1573 : 				
; 1574 : 					if(bMoveGateSuccess == FALSE)

  00108	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
$LN8@GCReqGateK:

; 1579 : 					}
; 1580 : 				}
; 1581 : 			}		
; 1582 : 		}
; 1583 : 	}
; 1584 : 	//
; 1585 : 	bMoveGateSuccess = gObjMoveGate(aIndex,257);

  0010b	68 01 01 00 00	 push	 257			; 00000101H
  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00116	83 c4 08	 add	 esp, 8

; 1586 : 						
; 1587 : 	if(bMoveGateSuccess == FALSE)

  00119	85 c0		 test	 eax, eax
  0011b	75 16		 jne	 SHORT $LN24@GCReqGateK

; 1588 : 	{
; 1589 : 		pMsg.result = 0;
; 1590 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0011d	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00121	52		 push	 edx
  00122	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00125	50		 push	 eax
$LN25@GCReqGateK:
  00126	56		 push	 esi
  00127	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0012b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@GCReqGateK:
  00133	5b		 pop	 ebx
$LN1@GCReqGateK:
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi

; 1591 : 	}
; 1592 : }

  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 04 00	 ret	 4
$LN18@GCReqGateK:

; 1575 : 					{
; 1576 : 						pMsg.result = 0;
; 1577 : 						DataSend(LocalPartyNumber, (LPBYTE)&pMsg, pMsg.h.size);

  0013c	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00140	50		 push	 eax
  00141	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00144	51		 push	 ecx

; 1578 : 						return;

  00145	eb df		 jmp	 SHORT $LN25@GCReqGateK
?GCReqGateKeeperMove@CQuestInfo@@QAEXH@Z ENDP		; CQuestInfo::GCReqGateKeeperMove
_TEXT	ENDS
PUBLIC	?QuestSuccessCommand@CQuestInfo@@QAEXHH@Z	; CQuestInfo::QuestSuccessCommand
; Function compile flags: /Ogtp
;	COMDAT ?QuestSuccessCommand@CQuestInfo@@QAEXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?QuestSuccessCommand@CQuestInfo@@QAEXHH@Z PROC		; CQuestInfo::QuestSuccessCommand, COMDAT
; _this$ = ecx

; 1596 : #if(TESTSERVER == 0)
; 1597 : 	return;
; 1598 : #endif
; 1599 : 	
; 1600 : 	LPOBJ lpObj = &gObj[aIndex];
; 1601 : 
; 1602 : 	if(lpObj->ChangeUP3rd == 1) return;
; 1603 : 
; 1604 : 	int State = 2;	//Clear Condition
; 1605 : 	int index = (QuestIndex/4);
; 1606 : 	int shift = (QuestIndex % 4)*2;
; 1607 : 
; 1608 : 	//Set Quest Clear Condition (prevent reload in case quest still active)
; 1609 : 	lpObj->m_Quest[index] &= QuestBitMask[shift];
; 1610 : 	lpObj->m_Quest[index] |= (State&3) << shift;
; 1611 : 
; 1612 : 	//Send User New Class Statistics
; 1613 : 	if(QuestIndex == 6)
; 1614 : 	{
; 1615 : 		lpObj->ChangeUP3rd = true;
; 1616 : 		lpObj->DbClass |= 2;
; 1617 : 		g_MasterLevelSystem.GDReqMasterLevelInfo(lpObj); //season 4.5 add-on
; 1618 : 	}
; 1619 : 
; 1620 : 	gObjMakePreviewCharSet(lpObj->m_Index);
; 1621 : 
; 1622 : 	//Clear 3rd Quest User State
; 1623 : 	lpObj->m_i3rdQuestState = 1;	//Loaded (prevent reload)
; 1624 : 	lpObj->m_i3rdQuestIndex = -1;	//Set 0 (prevent reload when open Priest Devin)
; 1625 : 
; 1626 : 	//Clear 3rd Quest Monster Kill State
; 1627 : 	for(int i = 0; i < 5; i++)
; 1628 : 	{
; 1629 : 		lpObj->MonsterKillInfo[i].MonIndex = -1;	//ReSet
; 1630 : 		lpObj->MonsterKillInfo[i].KillCount = -1;	//ReSet
; 1631 : 	}
; 1632 : 
; 1633 : 	GCServerMsgStringSend(" ",lpObj->m_Index,1); //Quest Success
; 1634 : }

  00000	c2 08 00	 ret	 8
?QuestSuccessCommand@CQuestInfo@@QAEXHH@Z ENDP		; CQuestInfo::QuestSuccessCommand
_TEXT	ENDS
PUBLIC	?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z ; CQuestInfo::CountQuestItemInInventory
EXTRN	?gObjGetItemCountInIventory@@YAHHH@Z:PROC	; gObjGetItemCountInIventory
; Function compile flags: /Ogtp
;	COMDAT ?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z
_TEXT	SEGMENT
tv161 = -4						; size = 4
_aIndex$ = 8						; size = 4
_arg2$ = 12						; size = 2
_arg3$ = 16						; size = 2
?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z PROC	; CQuestInfo::CountQuestItemInInventory, COMDAT
; _this$ = ecx

; 1637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1638 : 	if(gObj[aIndex].m_i3rdQuestIndex != -1)

  00004	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00007	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00013	57		 push	 edi
  00014	83 b8 60 10 00
	00 ff		 cmp	 DWORD PTR [eax+4192], -1
  0001b	8b f9		 mov	 edi, ecx
  0001d	89 45 fc	 mov	 DWORD PTR tv161[ebp], eax
  00020	74 09		 je	 SHORT $LN13@CountQuest

; 1639 : 	{
; 1640 : 		return FALSE;

  00022	33 c0		 xor	 eax, eax
  00024	5f		 pop	 edi

; 1700 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 0c 00	 ret	 12			; 0000000cH
$LN13@CountQuest:
  0002b	53		 push	 ebx
  0002c	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0002f	56		 push	 esi

; 1641 : 	}
; 1642 : 
; 1643 : 	LPOBJ lpObj = &gObj[aIndex]; //loc2
; 1644 : 
; 1645 : 	LPQUEST_INFO lpQuestInfo; //loc3
; 1646 : 	LPQUEST_SUB_INFO lpSubInfo; //loc4
; 1647 : 
; 1648 : 	int loc5; //loc5
; 1649 : 	int loc6 = 3; //loc6
; 1650 : 
; 1651 : 	for ( int i=0;i<this->m_QuestCount;i++) //loc7

  00030	33 f6		 xor	 esi, esi
  00032	85 db		 test	 ebx, ebx
  00034	7f 0e		 jg	 SHORT $LN12@CountQuest
$LN10@CountQuest:
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 1692 : 					}
; 1693 : 				}
; 1694 : 			}
; 1695 : 			return FALSE;
; 1696 : 		}
; 1697 : 	}
; 1698 : 
; 1699 : 	return FALSE;

  00038	33 c0		 xor	 eax, eax
  0003a	5f		 pop	 edi

; 1700 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
$LL23@CountQuest:

; 1641 : 	}
; 1642 : 
; 1643 : 	LPOBJ lpObj = &gObj[aIndex]; //loc2
; 1644 : 
; 1645 : 	LPQUEST_INFO lpQuestInfo; //loc3
; 1646 : 	LPQUEST_SUB_INFO lpSubInfo; //loc4
; 1647 : 
; 1648 : 	int loc5; //loc5
; 1649 : 	int loc6 = 3; //loc6
; 1650 : 
; 1651 : 	for ( int i=0;i<this->m_QuestCount;i++) //loc7

  00041	8b 45 fc	 mov	 eax, DWORD PTR tv161[ebp]
$LN12@CountQuest:

; 1652 : 	{
; 1653 : 		loc6 = this->GetQuestState(lpObj, i);

  00044	56		 push	 esi
  00045	50		 push	 eax
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState

; 1654 : 
; 1655 : 		if(loc6 == 1)

  0004d	83 f8 01	 cmp	 eax, 1
  00050	74 10		 je	 SHORT $LN18@CountQuest

; 1641 : 	}
; 1642 : 
; 1643 : 	LPOBJ lpObj = &gObj[aIndex]; //loc2
; 1644 : 
; 1645 : 	LPQUEST_INFO lpQuestInfo; //loc3
; 1646 : 	LPQUEST_SUB_INFO lpSubInfo; //loc4
; 1647 : 
; 1648 : 	int loc5; //loc5
; 1649 : 	int loc6 = 3; //loc6
; 1650 : 
; 1651 : 	for ( int i=0;i<this->m_QuestCount;i++) //loc7

  00052	46		 inc	 esi
  00053	3b f3		 cmp	 esi, ebx
  00055	7c ea		 jl	 SHORT $LL23@CountQuest

; 1692 : 					}
; 1693 : 				}
; 1694 : 			}
; 1695 : 			return FALSE;
; 1696 : 		}
; 1697 : 	}
; 1698 : 
; 1699 : 	return FALSE;

  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	33 c0		 xor	 eax, eax
  0005b	5f		 pop	 edi

; 1700 : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
$LN18@CountQuest:

; 1656 : 		{
; 1657 : 			lpQuestInfo = this->GetQuestInfo(i);

  00062	56		 push	 esi
  00063	8b cf		 mov	 ecx, edi
  00065	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  0006a	8b d8		 mov	 ebx, eax

; 1658 : 
; 1659 : 			if(lpQuestInfo == NULL)

  0006c	85 db		 test	 ebx, ebx

; 1660 : 			{
; 1661 : 				return FALSE;

  0006e	74 c6		 je	 SHORT $LN10@CountQuest

; 1662 : 			}
; 1663 : 
; 1664 : 			loc5 = lpQuestInfo->QuestSubInfoCount;

  00070	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]

; 1665 : 
; 1666 : 			for ( int j=0;j<loc5;j++)

  00073	33 f6		 xor	 esi, esi
  00075	85 c0		 test	 eax, eax
  00077	7e bd		 jle	 SHORT $LN10@CountQuest
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL7@CountQuest:

; 1667 : 			{
; 1668 : 				lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, j);

  00080	8b 55 fc	 mov	 edx, DWORD PTR tv161[ebp]
  00083	56		 push	 esi
  00084	53		 push	 ebx
  00085	52		 push	 edx
  00086	8b cf		 mov	 ecx, edi
  00088	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo

; 1669 : 
; 1670 : 				if(lpSubInfo == NULL)

  0008d	85 c0		 test	 eax, eax
  0008f	74 1f		 je	 SHORT $LN6@CountQuest

; 1671 : 				{
; 1672 : 					continue;
; 1673 : 				}
; 1674 : 
; 1675 : 				if(lpSubInfo->QuestType != 1)

  00091	83 38 01	 cmp	 DWORD PTR [eax], 1
  00094	75 a0		 jne	 SHORT $LN10@CountQuest

; 1676 : 				{
; 1677 : 					return FALSE;
; 1678 : 				}
; 1679 : 
; 1680 : 				if(arg2 == ITEMGET(lpSubInfo->NeedType, lpSubInfo->NeedSubType))

  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	0f bf 55 0c	 movsx	 edx, WORD PTR _arg2$[ebp]
  0009d	c1 e1 09	 shl	 ecx, 9
  000a0	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000a3	3b d1		 cmp	 edx, ecx
  000a5	75 09		 jne	 SHORT $LN6@CountQuest

; 1681 : 				{
; 1682 : 					if(arg3 == lpSubInfo->ItemLevel)

  000a7	0f bf 4d 10	 movsx	 ecx, WORD PTR _arg3$[ebp]
  000ab	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000ae	74 11		 je	 SHORT $LN20@CountQuest
$LN6@CountQuest:

; 1665 : 
; 1666 : 			for ( int j=0;j<loc5;j++)

  000b0	46		 inc	 esi
  000b1	3b 73 40	 cmp	 esi, DWORD PTR [ebx+64]
  000b4	7c ca		 jl	 SHORT $LL7@CountQuest

; 1692 : 					}
; 1693 : 				}
; 1694 : 			}
; 1695 : 			return FALSE;
; 1696 : 		}
; 1697 : 	}
; 1698 : 
; 1699 : 	return FALSE;

  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	33 c0		 xor	 eax, eax
  000ba	5f		 pop	 edi

; 1700 : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 0c 00	 ret	 12			; 0000000cH
$LN20@CountQuest:

; 1683 : 					{
; 1684 : 						int NumberItemQuestFound = gObjGetItemCountInIventory(aIndex, arg2);

  000c1	0f bf 55 0c	 movsx	 edx, WORD PTR _arg2$[ebp]
  000c5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000c8	52		 push	 edx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHH@Z ; gObjGetItemCountInIventory
  000cf	83 c4 08	 add	 esp, 8
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 1685 : 
; 1686 : 						//if ( NumberItemQuestFound >= lpSubInfo->NeedNumber)
; 1687 : 						//{
; 1688 : 						//	LogAdd("[Quest] Too many has quest items [%s][%s] (%d/%d)",	lpObj->AccountID, lpObj->Name, arg2, NumberItemQuestFound);
; 1689 : 						//	return FALSE;
; 1690 : 						//}
; 1691 : 						return TRUE;

  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	5f		 pop	 edi

; 1700 : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 0c 00	 ret	 12			; 0000000cH
?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z ENDP	; CQuestInfo::CountQuestItemInInventory
_TEXT	ENDS
PUBLIC	??0CQuestInfo@@QAE@XZ				; CQuestInfo::CQuestInfo
; Function compile flags: /Ogtp
;	COMDAT ??0CQuestInfo@@QAE@XZ
_TEXT	SEGMENT
??0CQuestInfo@@QAE@XZ PROC				; CQuestInfo::CQuestInfo, COMDAT
; _this$ = ecx

; 27   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CQuestInfo@@6B@

; 28   : 	QuestBitMask[0]=0xFC;

  00009	c7 05 00 00 00
	00 fc fc f3 f3	 mov	 DWORD PTR ?QuestBitMask@@3PAEA, -202113796 ; f3f3fcfcH

; 29   : 	QuestBitMask[1]=0xFC;
; 30   : 	QuestBitMask[2]=0xF3;
; 31   : 	QuestBitMask[3]=0xF3;
; 32   : 	QuestBitMask[4]=0xCF;

  00013	c7 05 04 00 00
	00 cf cf 3f 3f	 mov	 DWORD PTR ?QuestBitMask@@3PAEA+4, 1061146575 ; 3f3fcfcfH

; 33   : 	QuestBitMask[5]=0xCF;
; 34   : 	QuestBitMask[6]=0x3F;
; 35   : 	QuestBitMask[7]=0x3F;
; 36   : 
; 37   : 	this->Init();

  0001d	e8 00 00 00 00	 call	 ?Init@CQuestInfo@@QAEXXZ ; CQuestInfo::Init

; 38   : }

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	c3		 ret	 0
??0CQuestInfo@@QAE@XZ ENDP				; CQuestInfo::CQuestInfo
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCQuestInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCQuestInfo@@UAEPAXI@Z PROC				; CQuestInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CQuestInfo@@UAE@XZ	; CQuestInfo::~CQuestInfo
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCQuestInfo@@UAEPAXI@Z ENDP				; CQuestInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BK@EGHNLLGE@?$FLQuest?$FN?5?$FLSetQuestItem?$FN?5?$CFs?$AA@ ; `string'
PUBLIC	?InitQuestItem@CQuestInfo@@QAEXXZ		; CQuestInfo::InitQuestItem
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
;	COMDAT ??_C@_0BK@EGHNLLGE@?$FLQuest?$FN?5?$FLSetQuestItem?$FN?5?$CFs?$AA@
; File e:\work\tranet_version\gs\gameserver\questinfo.h
CONST	SEGMENT
??_C@_0BK@EGHNLLGE@?$FLQuest?$FN?5?$FLSetQuestItem?$FN?5?$CFs?$AA@ DB '[Q'
	DB	'uest] [SetQuestItem] %s', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\questinfo.cpp
CONST	ENDS
;	COMDAT ?InitQuestItem@CQuestInfo@@QAEXXZ
_TEXT	SEGMENT
_questcount$ = -16					; size = 4
_this$ = -12						; size = 4
_i$213530 = -8						; size = 4
_foundquest$ = -4					; size = 4
?InitQuestItem@CQuestInfo@@QAEXXZ PROC			; CQuestInfo::InitQuestItem, COMDAT
; _this$ = ecx

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 441  : 	int questcount = this->GetQeustCount();

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	53		 push	 ebx

; 442  : 	int foundquest = 0;

  0000a	33 d2		 xor	 edx, edx
  0000c	56		 push	 esi
  0000d	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00010	89 45 f0	 mov	 DWORD PTR _questcount$[ebp], eax
  00013	89 55 fc	 mov	 DWORD PTR _foundquest$[ebp], edx

; 443  : 	LPQUEST_INFO lpQuestInfo;
; 444  : 	LPQUEST_SUB_INFO lpSubInfo;
; 445  : 
; 446  : 	for (int i=0;i<MAX_QUEST_INFO;i++)

  00016	89 55 f8	 mov	 DWORD PTR _i$213530[ebp], edx
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL23@InitQuestI:

; 447  : 	{
; 448  : 		lpQuestInfo = this->GetQuestInfo(i);

  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00026	8b f8		 mov	 edi, eax

; 449  : 
; 450  : 		if ( lpQuestInfo == NULL )

  00028	85 ff		 test	 edi, edi
  0002a	74 52		 je	 SHORT $LN9@InitQuestI

; 451  : 		{
; 452  : 			continue;
; 453  : 		}
; 454  : 
; 455  : 		for ( int n=0;n<lpQuestInfo->QuestSubInfoCount;n++)

  0002c	33 db		 xor	 ebx, ebx
  0002e	39 5f 40	 cmp	 DWORD PTR [edi+64], ebx
  00031	7e 3f		 jle	 SHORT $LN4@InitQuestI
  00033	8d 77 44	 lea	 esi, DWORD PTR [edi+68]
$LL6@InitQuestI:

; 456  : 		{
; 457  : 			lpSubInfo = &lpQuestInfo->QuestSubInfo[n];
; 458  : 
; 459  : 			if ( lpSubInfo != NULL )

  00036	85 f6		 test	 esi, esi
  00038	74 29		 je	 SHORT $LN5@InitQuestI

; 460  : 			{
; 461  : 				if ( lpSubInfo->QuestType == 1 )

  0003a	83 3e 01	 cmp	 DWORD PTR [esi], 1
  0003d	75 24		 jne	 SHORT $LN5@InitQuestI

; 462  : 				{
; 463  : 					LPITEM_ATTRIBUTE p = &ItemAttribute[ITEMGET(lpSubInfo->NeedType, lpSubInfo->NeedSubType) ];

  0003f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00042	c1 e0 09	 shl	 eax, 9
  00045	03 46 08	 add	 eax, DWORD PTR [esi+8]
  00048	6b c0 70	 imul	 eax, 112		; 00000070H
  0004b	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute

; 464  : 					p->QuestItem = TRUE;
; 465  : 					LogAddTD("[Quest] [SetQuestItem] %s", p->Name);

  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EGHNLLGE@?$FLQuest?$FN?5?$FLSetQuestItem?$FN?5?$CFs?$AA@
  00056	c6 40 60 01	 mov	 BYTE PTR [eax+96], 1
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00060	83 c4 08	 add	 esp, 8
$LN5@InitQuestI:

; 451  : 		{
; 452  : 			continue;
; 453  : 		}
; 454  : 
; 455  : 		for ( int n=0;n<lpQuestInfo->QuestSubInfoCount;n++)

  00063	43		 inc	 ebx
  00064	83 c6 48	 add	 esi, 72			; 00000048H
  00067	3b 5f 40	 cmp	 ebx, DWORD PTR [edi+64]
  0006a	7c ca		 jl	 SHORT $LL6@InitQuestI
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _i$213530[ebp]
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
$LN4@InitQuestI:

; 466  : 				}
; 467  : 			}
; 468  : 		}
; 469  : 
; 470  : 		foundquest++;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _foundquest$[ebp]
  00075	40		 inc	 eax
  00076	89 45 fc	 mov	 DWORD PTR _foundquest$[ebp], eax

; 471  : 
; 472  : 		if ( foundquest == questcount )

  00079	3b 45 f0	 cmp	 eax, DWORD PTR _questcount$[ebp]
  0007c	74 0c		 je	 SHORT $LN17@InitQuestI
$LN9@InitQuestI:

; 443  : 	LPQUEST_INFO lpQuestInfo;
; 444  : 	LPQUEST_SUB_INFO lpSubInfo;
; 445  : 
; 446  : 	for (int i=0;i<MAX_QUEST_INFO;i++)

  0007e	42		 inc	 edx
  0007f	89 55 f8	 mov	 DWORD PTR _i$213530[ebp], edx
  00082	81 fa c8 00 00
	00		 cmp	 edx, 200		; 000000c8H
  00088	7c 96		 jl	 SHORT $LL23@InitQuestI
$LN17@InitQuestI:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 473  : 		{
; 474  : 			return;
; 475  : 		}
; 476  : 	}
; 477  : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?InitQuestItem@CQuestInfo@@QAEXXZ ENDP			; CQuestInfo::InitQuestItem
_TEXT	ENDS
PUBLIC	?QuestRunConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestRunConditionCheck
; Function compile flags: /Ogtp
;	COMDAT ?QuestRunConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_subquestcount$ = -20					; size = 4
_lpSubInfo$ = -16					; size = 4
_bFoundSubQuest$ = -12					; size = 4
_subquest$213661 = -8					; size = 4
_lpQuestInfo$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_concount$ = 12						; size = 4
_QuestIndex$ = 12					; size = 4
?QuestRunConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z PROC ; CQuestInfo::QuestRunConditionCheck, COMDAT
; _this$ = ecx

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 684  : 	LPQUEST_INFO lpQuestInfo = this->GetQuestInfo(QuestIndex);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	8b f9		 mov	 edi, ecx
  0000e	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00013	8b f0		 mov	 esi, eax

; 685  : 
; 686  : 	if ( lpQuestInfo == NULL )

  00015	33 c0		 xor	 eax, eax
  00017	89 75 fc	 mov	 DWORD PTR _lpQuestInfo$[ebp], esi
  0001a	3b f0		 cmp	 esi, eax
  0001c	75 0a		 jne	 SHORT $LN16@QuestRunCo

; 687  : 	{
; 688  : 		return -1;

  0001e	5f		 pop	 edi
  0001f	0c ff		 or	 al, 255			; 000000ffH
  00021	5e		 pop	 esi

; 739  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
$LN16@QuestRunCo:

; 689  : 	}
; 690  : 
; 691  : 	int subquestcount = lpQuestInfo->QuestSubInfoCount;

  00028	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]

; 692  : 	int concount = lpQuestInfo->QuestConditionCount;

  0002b	8b 96 14 03 00
	00		 mov	 edx, DWORD PTR [esi+788]
  00031	53		 push	 ebx
  00032	89 4d ec	 mov	 DWORD PTR _subquestcount$[ebp], ecx
  00035	89 55 0c	 mov	 DWORD PTR _concount$[ebp], edx

; 693  : 	LPQUEST_SUB_INFO lpSubInfo;
; 694  : 	LPQUEST_CONDITION lpCondition;
; 695  : 	BOOL bFoundSubQuest = FALSE;

  00038	89 45 f4	 mov	 DWORD PTR _bFoundSubQuest$[ebp], eax

; 696  : 
; 697  : 
; 698  : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  0003b	89 45 f8	 mov	 DWORD PTR _subquest$213661[ebp], eax
  0003e	3b c8		 cmp	 ecx, eax
  00040	7e 72		 jle	 SHORT $LN26@QuestRunCo
$LL31@QuestRunCo:

; 699  : 	{
; 700  : 		lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, subquest);

  00042	50		 push	 eax
  00043	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	56		 push	 esi
  00047	50		 push	 eax
  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
  0004f	89 45 f0	 mov	 DWORD PTR _lpSubInfo$[ebp], eax

; 701  : 
; 702  : 		if ( lpSubInfo != NULL )

  00052	85 c0		 test	 eax, eax
  00054	74 4c		 je	 SHORT $LN14@QuestRunCo

; 703  : 		{
; 704  : 			bFoundSubQuest = TRUE;
; 705  : 
; 706  : 			for ( int i=0;i<concount;i++)

  00056	33 db		 xor	 ebx, ebx
  00058	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bFoundSubQuest$[ebp], 1
  0005f	39 5d 0c	 cmp	 DWORD PTR _concount$[ebp], ebx
  00062	7e 3e		 jle	 SHORT $LN14@QuestRunCo
$LL11@QuestRunCo:

; 707  : 			{
; 708  : 				lpCondition = this->GetQuestCondition(lpQuestInfo, i);

  00064	53		 push	 ebx
  00065	56		 push	 esi
  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?GetQuestCondition@CQuestInfo@@QAEPAUQUEST_CONDITION@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestCondition
  0006d	8b f0		 mov	 esi, eax

; 709  : 
; 710  : 				if ( lpCondition != NULL && lpCondition->Index == -1)

  0006f	85 f6		 test	 esi, esi
  00071	74 41		 je	 SHORT $LN26@QuestRunCo
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	83 f8 ff	 cmp	 eax, -1
  00078	75 07		 jne	 SHORT $LN8@QuestRunCo

; 711  : 				{
; 712  : 					if ( this->CompareCondition(lpObj, lpCondition) == FALSE )

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007d	56		 push	 esi
  0007e	51		 push	 ecx

; 713  : 					{
; 714  : 						return lpCondition->StartContext;
; 715  : 					}
; 716  : 				}

  0007f	eb 0d		 jmp	 SHORT $LN34@QuestRunCo
$LN8@QuestRunCo:

; 717  : 				else if ( lpCondition != NULL && lpCondition->Index == lpSubInfo->LinkConditionIndex )

  00081	8b 55 f0	 mov	 edx, DWORD PTR _lpSubInfo$[ebp]
  00084	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  00087	75 10		 jne	 SHORT $LN10@QuestRunCo

; 718  : 				{
; 719  : 					if ( this->CompareCondition(lpObj, lpCondition) == 0)

  00089	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	56		 push	 esi
  0008d	50		 push	 eax
$LN34@QuestRunCo:
  0008e	8b cf		 mov	 ecx, edi
  00090	e8 00 00 00 00	 call	 ?CompareCondition@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@PAUQUEST_CONDITION@@@Z ; CQuestInfo::CompareCondition
  00095	85 c0		 test	 eax, eax
  00097	74 26		 je	 SHORT $LN22@QuestRunCo
$LN10@QuestRunCo:

; 703  : 		{
; 704  : 			bFoundSubQuest = TRUE;
; 705  : 
; 706  : 			for ( int i=0;i<concount;i++)

  00099	8b 75 fc	 mov	 esi, DWORD PTR _lpQuestInfo$[ebp]
  0009c	43		 inc	 ebx
  0009d	3b 5d 0c	 cmp	 ebx, DWORD PTR _concount$[ebp]
  000a0	7c c2		 jl	 SHORT $LL11@QuestRunCo
$LN14@QuestRunCo:

; 696  : 
; 697  : 
; 698  : 	for ( int subquest=0;subquest<subquestcount;subquest++)

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _subquest$213661[ebp]
  000a5	40		 inc	 eax
  000a6	89 45 f8	 mov	 DWORD PTR _subquest$213661[ebp], eax
  000a9	3b 45 ec	 cmp	 eax, DWORD PTR _subquestcount$[ebp]
  000ac	7c 94		 jl	 SHORT $LL31@QuestRunCo

; 722  : 					}
; 723  : 				}
; 724  : 				else if ( lpCondition == NULL )
; 725  : 				{
; 726  : 					return -1;
; 727  : 				}
; 728  : 			}
; 729  : 
; 730  : 		}
; 731  : 	}
; 732  : 
; 733  : 	if ( bFoundSubQuest == FALSE )

  000ae	83 7d f4 00	 cmp	 DWORD PTR _bFoundSubQuest$[ebp], 0
  000b2	75 17		 jne	 SHORT $LN1@QuestRunCo
$LN26@QuestRunCo:
  000b4	5b		 pop	 ebx
  000b5	5f		 pop	 edi

; 734  : 	{
; 735  : 		return -1;

  000b6	0c ff		 or	 al, 255			; 000000ffH
  000b8	5e		 pop	 esi

; 739  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 08 00	 ret	 8
$LN22@QuestRunCo:

; 720  : 					{
; 721  : 						return lpCondition->StartContext;

  000bf	8a 46 18	 mov	 al, BYTE PTR [esi+24]
  000c2	5b		 pop	 ebx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi

; 739  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
$LN1@QuestRunCo:
  000cb	5b		 pop	 ebx
  000cc	5f		 pop	 edi

; 736  : 	}
; 737  : 
; 738  : 	return 0;

  000cd	32 c0		 xor	 al, al
  000cf	5e		 pop	 esi

; 739  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 08 00	 ret	 8
?QuestRunConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ENDP ; CQuestInfo::QuestRunConditionCheck
_TEXT	ENDS
PUBLIC	?NpcTalk@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z	; CQuestInfo::NpcTalk
EXTRN	?GCSendQuestInfo@@YAXHH@Z:PROC			; GCSendQuestInfo
; Function compile flags: /Ogtp
;	COMDAT ?NpcTalk@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_i$213701 = -16						; size = 4
_foundquest$ = -12					; size = 4
_questindex$ = -8					; size = 4
_queststate$ = -4					; size = 4
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?NpcTalk@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z PROC	; CQuestInfo::NpcTalk, COMDAT
; _this$ = ecx

; 782  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 783  : 	int questcount = this->GetQeustCount();
; 784  : 	int foundquest = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi

; 785  : 	LPQUEST_INFO lpQuestInfo;
; 786  : 	int queststate = -1;

  0000a	83 ca ff	 or	 edx, -1
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	89 5d f4	 mov	 DWORD PTR _foundquest$[ebp], ebx
  00013	89 55 fc	 mov	 DWORD PTR _queststate$[ebp], edx

; 787  : 	int questindex = -1;

  00016	89 55 f8	 mov	 DWORD PTR _questindex$[ebp], edx

; 788  : 
; 789  : 	for ( int i = 0; i<MAX_QUEST_INFO;i++)

  00019	89 5d f0	 mov	 DWORD PTR _i$213701[ebp], ebx
  0001c	8d 64 24 00	 npad	 4
$LL16@NpcTalk:

; 790  : 	{
; 791  : 		lpQuestInfo = this->GetQuestInfo(i);

  00020	53		 push	 ebx
  00021	8b cf		 mov	 ecx, edi
  00023	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00028	8b f0		 mov	 esi, eax

; 792  : 
; 793  : 		if ( lpQuestInfo == NULL )

  0002a	85 f6		 test	 esi, esi
  0002c	0f 84 7c 00 00
	00		 je	 $LN15@NpcTalk

; 794  : 		{
; 795  : 			continue;
; 796  : 		}
; 797  : 
; 798  : 		if ( lpQuestInfo->QuestStartType == 2 )

  00032	83 7e 38 02	 cmp	 DWORD PTR [esi+56], 2
  00036	75 67		 jne	 SHORT $LN26@NpcTalk

; 799  : 		{
; 800  : 			if ( lpNpc->Class == lpQuestInfo->QuestStartSubType)

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpNpc$[ebp]
  0003b	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00042	3b 4e 3c	 cmp	 ecx, DWORD PTR [esi+60]
  00045	75 58		 jne	 SHORT $LN26@NpcTalk

; 801  : 			{
; 802  : 				if ( queststate == -1 )

  00047	83 fa ff	 cmp	 edx, -1
  0004a	75 17		 jne	 SHORT $LN10@NpcTalk

; 803  : 				{
; 804  : 					questindex = lpQuestInfo->QuestIndex;

  0004c	8b 76 34	 mov	 esi, DWORD PTR [esi+52]

; 805  : 					queststate = this->GetQuestState(lpObj, lpQuestInfo->QuestIndex);

  0004f	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00052	56		 push	 esi
  00053	52		 push	 edx
  00054	8b cf		 mov	 ecx, edi
  00056	89 75 f8	 mov	 DWORD PTR _questindex$[ebp], esi
  00059	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  0005e	89 45 fc	 mov	 DWORD PTR _queststate$[ebp], eax
  00061	eb 39		 jmp	 SHORT $LN32@NpcTalk
$LN10@NpcTalk:

; 806  : 				}
; 807  : 				else if ( queststate == 2 )

  00063	83 fa 02	 cmp	 edx, 2
  00066	75 37		 jne	 SHORT $LN26@NpcTalk

; 808  : 				{
; 809  : 					for ( int n=0;n<lpQuestInfo->QuestSubInfoCount ;n++)

  00068	33 db		 xor	 ebx, ebx
  0006a	39 5e 40	 cmp	 DWORD PTR [esi+64], ebx
  0006d	7e 30		 jle	 SHORT $LN26@NpcTalk
  0006f	90		 npad	 1
$LL7@NpcTalk:

; 810  : 					{
; 811  : 						LPQUEST_SUB_INFO lpSubInfo = this->GetSubquestInfo(lpObj, lpQuestInfo, n);

  00070	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00073	53		 push	 ebx
  00074	56		 push	 esi
  00075	50		 push	 eax
  00076	8b cf		 mov	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo

; 812  : 
; 813  : 						if ( lpSubInfo != NULL )

  0007d	85 c0		 test	 eax, eax
  0007f	74 15		 je	 SHORT $LN6@NpcTalk

; 814  : 						{
; 815  : 							questindex = lpQuestInfo->QuestIndex;

  00081	8b 46 34	 mov	 eax, DWORD PTR [esi+52]

; 816  : 							queststate = this->GetQuestState(lpObj, lpQuestInfo->QuestIndex);

  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00087	50		 push	 eax
  00088	51		 push	 ecx
  00089	8b cf		 mov	 ecx, edi
  0008b	89 45 f8	 mov	 DWORD PTR _questindex$[ebp], eax
  0008e	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00093	89 45 fc	 mov	 DWORD PTR _queststate$[ebp], eax
$LN6@NpcTalk:

; 808  : 				{
; 809  : 					for ( int n=0;n<lpQuestInfo->QuestSubInfoCount ;n++)

  00096	43		 inc	 ebx
  00097	3b 5e 40	 cmp	 ebx, DWORD PTR [esi+64]
  0009a	7c d4		 jl	 SHORT $LL7@NpcTalk
$LN32@NpcTalk:
  0009c	8b 55 fc	 mov	 edx, DWORD PTR _queststate$[ebp]
$LN26@NpcTalk:

; 817  : 						}
; 818  : 					}
; 819  : 				}
; 820  : 			}
; 821  : 		}
; 822  : 
; 823  : 		foundquest++;

  0009f	8b 45 f4	 mov	 eax, DWORD PTR _foundquest$[ebp]
  000a2	40		 inc	 eax
  000a3	89 45 f4	 mov	 DWORD PTR _foundquest$[ebp], eax

; 824  : 
; 825  : 		if ( foundquest == questcount )

  000a6	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  000a9	74 13		 je	 SHORT $LN30@NpcTalk
  000ab	8b 5d f0	 mov	 ebx, DWORD PTR _i$213701[ebp]
$LN15@NpcTalk:

; 788  : 
; 789  : 	for ( int i = 0; i<MAX_QUEST_INFO;i++)

  000ae	43		 inc	 ebx
  000af	89 5d f0	 mov	 DWORD PTR _i$213701[ebp], ebx
  000b2	81 fb c8 00 00
	00		 cmp	 ebx, 200		; 000000c8H
  000b8	0f 8c 62 ff ff
	ff		 jl	 $LL16@NpcTalk
$LN30@NpcTalk:

; 826  : 		{
; 827  : 			break;
; 828  : 		}
; 829  : 	}
; 830  : 
; 831  : 	if ( queststate != -1 )

  000be	83 fa ff	 cmp	 edx, -1
  000c1	74 47		 je	 SHORT $LN2@NpcTalk

; 832  : 	{
; 833  : 		int loc10 = this->GCSendQuestKillCountInfo(questindex, lpObj->m_Index);

  000c3	8b 75 0c	 mov	 esi, DWORD PTR _lpObj$[ebp]
  000c6	8b 16		 mov	 edx, DWORD PTR [esi]
  000c8	8b 5d f8	 mov	 ebx, DWORD PTR _questindex$[ebp]
  000cb	52		 push	 edx
  000cc	53		 push	 ebx
  000cd	8b cf		 mov	 ecx, edi
  000cf	e8 00 00 00 00	 call	 ?GCSendQuestKillCountInfo@CQuestInfo@@QAEHHH@Z ; CQuestInfo::GCSendQuestKillCountInfo

; 834  : 		
; 835  : 		if(loc10 == 0)

  000d4	85 c0		 test	 eax, eax

; 836  : 		{
; 837  : 			return true;

  000d6	74 24		 je	 SHORT $LN33@NpcTalk

; 838  : 		}
; 839  : 		
; 840  : 		GCSendQuestInfo(lpObj->m_Index, questindex);

  000d8	8b 06		 mov	 eax, DWORD PTR [esi]
  000da	53		 push	 ebx
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?GCSendQuestInfo@@YAXHH@Z ; GCSendQuestInfo

; 841  : 		lpObj->m_IfState.type = 10;
; 842  : 		lpObj->m_IfState.state = 0;
; 843  : 		lpObj->m_IfState.use = 1;

  000e1	8b 8e 1c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3612]
  000e7	81 e1 81 02 ff
	ff		 and	 ecx, -64895		; ffff0281H
  000ed	83 c4 08	 add	 esp, 8
  000f0	81 c9 81 02 00
	00		 or	 ecx, 641		; 00000281H
  000f6	89 8e 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], ecx
$LN33@NpcTalk:

; 844  : 		return true;

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	b8 01 00 00 00	 mov	 eax, 1
  00103	5b		 pop	 ebx

; 848  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 08 00	 ret	 8
$LN2@NpcTalk:
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi

; 845  : 	}
; 846  : 
; 847  : 	return false;

  0010c	33 c0		 xor	 eax, eax
  0010e	5b		 pop	 ebx

; 848  : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 08 00	 ret	 8
?NpcTalk@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP	; CQuestInfo::NpcTalk
_TEXT	ENDS
PUBLIC	??_C@_0DE@CLGCKBPA@?$FLQuest?$FN?5Quest?5Item?5Drop?5?$FL?$CFs?$FN?3?5?$FL?$CF@ ; `string'
PUBLIC	?MonsterItemDrop@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@@Z ; CQuestInfo::MonsterItemDrop
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
;	COMDAT ??_C@_0DE@CLGCKBPA@?$FLQuest?$FN?5Quest?5Item?5Drop?5?$FL?$CFs?$FN?3?5?$FL?$CF@
; File e:\work\tranet_version\gs\gameserver\questinfo.h
CONST	SEGMENT
??_C@_0DE@CLGCKBPA@?$FLQuest?$FN?5Quest?5Item?5Drop?5?$FL?$CFs?$FN?3?5?$FL?$CF@ DB '['
	DB	'Quest] Quest Item Drop [%s]: [%s][%s] (%s) (%d,%d)', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\questinfo.cpp
CONST	ENDS
;	COMDAT ?MonsterItemDrop@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_level$ = -24						; size = 4
_questcount$ = -24					; size = 4
_MaxHitUser$ = -20					; size = 4
_y$ = -16						; size = 4
_i$213743 = -16						; size = 4
_foundquest$ = -12					; size = 4
_lpTarget$ = -8						; size = 4
_n$213748 = -4						; size = 4
_lpObj$ = 8						; size = 4
?MonsterItemDrop@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CQuestInfo::MonsterItemDrop, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 852  : 	int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj); //loc1

  00008	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000b	57		 push	 edi
  0000c	8b d9		 mov	 ebx, ecx
  0000e	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 ec	 mov	 DWORD PTR _MaxHitUser$[ebp], eax

; 853  : 
; 854  : 	if ( MaxHitUser == -1 )

  00019	83 f8 ff	 cmp	 eax, -1
  0001c	75 0a		 jne	 SHORT $LN18@MonsterIte@2

; 855  : 	{
; 856  : 		return false;

  0001e	5f		 pop	 edi
  0001f	33 c0		 xor	 eax, eax
  00021	5b		 pop	 ebx

; 936  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN18@MonsterIte@2:
  00028	56		 push	 esi

; 857  : 	}
; 858  : 
; 859  : 	int partycount = gParty.GetPartyCount(gObj[MaxHitUser].PartyNumber); //loc3

  00029	8b f0		 mov	 esi, eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00036	8b 8c 06 2c 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1068]
  0003d	51		 push	 ecx
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00043	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 860  : 
; 861  : 	if ( partycount > 0 ) //Season 2.5 changed
; 862  : 	{
; 863  : 		int MaxHitUserInParty = this->MonsterItemDropParty(lpObj,&gObj[MaxHitUser]);

  00048	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004e	85 c0		 test	 eax, eax
  00050	7e 12		 jle	 SHORT $LN17@MonsterIte@2
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	8b cb		 mov	 ecx, ebx
  00056	e8 00 00 00 00	 call	 ?MonsterItemDropParty@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@0@Z ; CQuestInfo::MonsterItemDropParty
  0005b	5e		 pop	 esi
  0005c	5f		 pop	 edi
  0005d	5b		 pop	 ebx

; 936  : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
$LN17@MonsterIte@2:

; 864  : 		return MaxHitUserInParty;
; 865  : 	}
; 866  : 
; 867  : 	LPOBJ lpTarget = &gObj[MaxHitUser];
; 868  : 	int questcount = this->GetQeustCount();

  00064	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 869  : 	int foundquest = 0;

  00067	33 d2		 xor	 edx, edx
  00069	89 75 f8	 mov	 DWORD PTR _lpTarget$[ebp], esi
  0006c	89 4d e8	 mov	 DWORD PTR _questcount$[ebp], ecx
  0006f	89 55 f4	 mov	 DWORD PTR _foundquest$[ebp], edx

; 870  : 	LPQUEST_INFO lpQuestInfo;
; 871  : 	LPQUEST_SUB_INFO lpSubInfo;
; 872  : 	int type;
; 873  : 	int level;
; 874  : 	int x;
; 875  : 	int y;
; 876  : 	float dur = 0;
; 877  : 	int Option1 = 0;
; 878  : 	int Option2 = 0;
; 879  : 	int Option3 = 0;
; 880  : 
; 881  : 	for ( int i=0;i<MAX_QUEST_INFO;i++)

  00072	89 55 f0	 mov	 DWORD PTR _i$213743[ebp], edx
$LL34@MonsterIte@2:

; 882  : 	{
; 883  : 		lpQuestInfo = this->GetQuestInfo(i);

  00075	52		 push	 edx
  00076	8b cb		 mov	 ecx, ebx
  00078	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  0007d	8b f8		 mov	 edi, eax

; 884  : 
; 885  : 		if ( lpQuestInfo == NULL )

  0007f	85 ff		 test	 edi, edi
  00081	0f 84 bc 00 00
	00		 je	 $LN15@MonsterIte@2

; 886  : 		{
; 887  : 			continue;
; 888  : 		}
; 889  : 
; 890  : 		for ( int n =0;n<lpQuestInfo->QuestSubInfoCount;n++)

  00087	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  0008b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$213748[ebp], 0
  00092	0f 8e 9f 00 00
	00		 jle	 $LN10@MonsterIte@2
$LL30@MonsterIte@2:

; 891  : 		{
; 892  : 			lpSubInfo = this->GetSubquestInfo(lpTarget, lpQuestInfo, n);

  00098	8b 55 fc	 mov	 edx, DWORD PTR _n$213748[ebp]
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  0009e	52		 push	 edx
  0009f	57		 push	 edi
  000a0	50		 push	 eax
  000a1	8b cb		 mov	 ecx, ebx
  000a3	e8 00 00 00 00	 call	 ?GetSubquestInfo@CQuestInfo@@QAEPAUQUEST_SUB_INFO@@PAUOBJECTSTRUCT@@PAUQUEST_INFO@@H@Z ; CQuestInfo::GetSubquestInfo
  000a8	8b f0		 mov	 esi, eax

; 893  : 			
; 894  : 			if ( lpSubInfo != NULL )

  000aa	85 f6		 test	 esi, esi
  000ac	74 76		 je	 SHORT $LN11@MonsterIte@2

; 895  : 			{
; 896  : 				if ( lpSubInfo->QuestType == 1 )

  000ae	83 3e 01	 cmp	 DWORD PTR [esi], 1
  000b1	75 71		 jne	 SHORT $LN11@MonsterIte@2

; 897  : 				{
; 898  : 					if( (lpSubInfo->NeedTargetMinLevel > 0) && (lpObj->Level >= lpSubInfo->NeedTargetMinLevel) && (lpObj->Level <= lpSubInfo->NeedTargetMaxLevel) || (lpSubInfo->NeedTargetMinLevel == -1) && (lpObj->Class == lpSubInfo->NeedTargetMaxLevel))

  000b3	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000b6	85 c0		 test	 eax, eax
  000b8	7e 13		 jle	 SHORT $LN31@MonsterIte@2
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bd	0f bf 89 be 00
	00 00		 movsx	 ecx, WORD PTR [ecx+190]
  000c4	3b c8		 cmp	 ecx, eax
  000c6	7c 05		 jl	 SHORT $LN31@MonsterIte@2
  000c8	3b 4e 18	 cmp	 ecx, DWORD PTR [esi+24]
  000cb	7e 14		 jle	 SHORT $LN6@MonsterIte@2
$LN31@MonsterIte@2:
  000cd	83 f8 ff	 cmp	 eax, -1
  000d0	75 52		 jne	 SHORT $LN11@MonsterIte@2
  000d2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d5	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  000dc	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  000df	75 43		 jne	 SHORT $LN11@MonsterIte@2
$LN6@MonsterIte@2:

; 899  : 					{
; 900  : 						if ( this->GetQuestState(lpTarget, lpQuestInfo->QuestIndex) == TRUE )

  000e1	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR _lpTarget$[ebp]
  000e7	51		 push	 ecx
  000e8	52		 push	 edx
  000e9	8b cb		 mov	 ecx, ebx
  000eb	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000f0	83 f8 01	 cmp	 eax, 1
  000f3	75 2f		 jne	 SHORT $LN11@MonsterIte@2

; 901  : 						{
; 902  : 							if ( (rand() % ITEM_QUEST_DROP_PROBABILITY) < lpSubInfo->NeedDropRate)

  000f5	e8 00 00 00 00	 call	 _rand
  000fa	99		 cdq
  000fb	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00100	f7 f9		 idiv	 ecx
  00102	3b 56 1c	 cmp	 edx, DWORD PTR [esi+28]
  00105	7d 1d		 jge	 SHORT $LN11@MonsterIte@2

; 903  : 							{
; 904  : 									int itemcount = gObjGetItemCountInIventory(MaxHitUser, lpSubInfo->NeedType,
; 905  : 										lpSubInfo->NeedSubType, lpSubInfo->ItemLevel);

  00107	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0010a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0010d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00110	52		 push	 edx
  00111	8b 55 ec	 mov	 edx, DWORD PTR _MaxHitUser$[ebp]
  00114	50		 push	 eax
  00115	51		 push	 ecx
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0011c	83 c4 10	 add	 esp, 16			; 00000010H

; 906  : 
; 907  : 									if ( itemcount >= lpSubInfo->NeedNumber)

  0011f	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00122	7c 3a		 jl	 SHORT $LN2@MonsterIte@2
$LN11@MonsterIte@2:

; 886  : 		{
; 887  : 			continue;
; 888  : 		}
; 889  : 
; 890  : 		for ( int n =0;n<lpQuestInfo->QuestSubInfoCount;n++)

  00124	8b 45 fc	 mov	 eax, DWORD PTR _n$213748[ebp]
  00127	40		 inc	 eax
  00128	89 45 fc	 mov	 DWORD PTR _n$213748[ebp], eax
  0012b	3b 47 40	 cmp	 eax, DWORD PTR [edi+64]
  0012e	0f 8c 64 ff ff
	ff		 jl	 $LL30@MonsterIte@2
  00134	8b 55 f0	 mov	 edx, DWORD PTR _i$213743[ebp]
$LN10@MonsterIte@2:

; 920  : 							}
; 921  : 						}
; 922  : 					}
; 923  : 				}
; 924  : 			}
; 925  : 		}
; 926  : 
; 927  : 		foundquest++;

  00137	8b 45 f4	 mov	 eax, DWORD PTR _foundquest$[ebp]
  0013a	40		 inc	 eax
  0013b	89 45 f4	 mov	 DWORD PTR _foundquest$[ebp], eax

; 928  : 
; 929  : 		if ( foundquest == questcount )

  0013e	3b 45 e8	 cmp	 eax, DWORD PTR _questcount$[ebp]
  00141	74 10		 je	 SHORT $LN25@MonsterIte@2
$LN15@MonsterIte@2:

; 870  : 	LPQUEST_INFO lpQuestInfo;
; 871  : 	LPQUEST_SUB_INFO lpSubInfo;
; 872  : 	int type;
; 873  : 	int level;
; 874  : 	int x;
; 875  : 	int y;
; 876  : 	float dur = 0;
; 877  : 	int Option1 = 0;
; 878  : 	int Option2 = 0;
; 879  : 	int Option3 = 0;
; 880  : 
; 881  : 	for ( int i=0;i<MAX_QUEST_INFO;i++)

  00143	42		 inc	 edx
  00144	89 55 f0	 mov	 DWORD PTR _i$213743[ebp], edx
  00147	81 fa c8 00 00
	00		 cmp	 edx, 200		; 000000c8H
  0014d	0f 8c 22 ff ff
	ff		 jl	 $LL34@MonsterIte@2
$LN25@MonsterIte@2:
  00153	5e		 pop	 esi
  00154	5f		 pop	 edi

; 930  : 		{
; 931  : 			break;
; 932  : 		}
; 933  : 	}
; 934  : 
; 935  : 	return false;

  00155	33 c0		 xor	 eax, eax
  00157	5b		 pop	 ebx

; 936  : }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
$LN2@MonsterIte@2:

; 908  : 									{
; 909  : 										continue;
; 910  : 									}
; 911  : 
; 912  : 									dur = 0;
; 913  : 									x = lpObj->X;

  0015e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00161	0f bf 98 44 01
	00 00		 movsx	 ebx, WORD PTR [eax+324]

; 914  : 									y = lpObj->Y;

  00168	8b c8		 mov	 ecx, eax
  0016a	0f bf 91 46 01
	00 00		 movsx	 edx, WORD PTR [ecx+326]

; 915  : 									level = lpSubInfo->ItemLevel;
; 916  : 									type = ItemGetNumberMake(lpSubInfo->NeedType, lpSubInfo->NeedSubType);

  00171	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00174	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00177	89 55 f0	 mov	 DWORD PTR _y$[ebp], edx
  0017a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0017d	51		 push	 ecx
  0017e	52		 push	 edx
  0017f	89 45 e8	 mov	 DWORD PTR _level$[ebp], eax
  00182	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 917  : 									ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur, Option1,	Option2, Option3, MaxHitUser, 0, 0);

  00187	8b 4d ec	 mov	 ecx, DWORD PTR _MaxHitUser$[ebp]
  0018a	8b 55 e8	 mov	 edx, DWORD PTR _level$[ebp]
  0018d	6a 00		 push	 0
  0018f	6a 00		 push	 0
  00191	51		 push	 ecx
  00192	6a 00		 push	 0
  00194	6a 00		 push	 0
  00196	6a 00		 push	 0
  00198	6a 00		 push	 0
  0019a	52		 push	 edx
  0019b	50		 push	 eax
  0019c	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0019f	50		 push	 eax
  001a0	53		 push	 ebx
  001a1	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  001a4	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  001ab	8b 13		 mov	 edx, DWORD PTR [ebx]
  001ad	51		 push	 ecx
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 918  : 									LogAddTD("[Quest] Quest Item Drop [%s]: [%s][%s] (%s) (%d,%d)", lpObj->Name, lpTarget->AccountID, lpTarget->Name, lpQuestInfo->Name, lpSubInfo->NeedType, lpSubInfo->NeedSubType);

  001b4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001b7	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001ba	50		 push	 eax
  001bb	8b 45 f8	 mov	 eax, DWORD PTR _lpTarget$[ebp]
  001be	51		 push	 ecx
  001bf	57		 push	 edi
  001c0	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  001c3	52		 push	 edx
  001c4	83 c0 6c	 add	 eax, 108		; 0000006cH
  001c7	50		 push	 eax
  001c8	83 c3 77	 add	 ebx, 119		; 00000077H
  001cb	53		 push	 ebx
  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@CLGCKBPA@?$FLQuest?$FN?5Quest?5Item?5Drop?5?$FL?$CFs?$FN?3?5?$FL?$CF@
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d7	83 c4 58	 add	 esp, 88			; 00000058H
  001da	5e		 pop	 esi
  001db	5f		 pop	 edi

; 919  : 									return true;

  001dc	b8 01 00 00 00	 mov	 eax, 1
  001e1	5b		 pop	 ebx

; 936  : }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c2 04 00	 ret	 4
?MonsterItemDrop@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CQuestInfo::MonsterItemDrop
_TEXT	ENDS
PUBLIC	??_C@_0BF@JAOCNINL@Quest?5Info?5Read?5Fail?$AA@	; `string'
PUBLIC	??_C@_0CO@IPPCPA@?$FLQuest?$FN?5?$CI?$CFs?$CJ?5Load?5?3?5Index?5?$CFd?0?5Su@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0O@NOCIMNHO@load?5error?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?LoadQuestInfo@CQuestInfo@@QAEHPAD@Z		; CQuestInfo::LoadQuestInfo
EXTRN	_fclose:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BF@JAOCNINL@Quest?5Info?5Read?5Fail?$AA@
CONST	SEGMENT
??_C@_0BF@JAOCNINL@Quest?5Info?5Read?5Fail?$AA@ DB 'Quest Info Read Fail', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPPCPA@?$FLQuest?$FN?5?$CI?$CFs?$CJ?5Load?5?3?5Index?5?$CFd?0?5Su@
CONST	SEGMENT
??_C@_0CO@IPPCPA@?$FLQuest?$FN?5?$CI?$CFs?$CJ?5Load?5?3?5Index?5?$CFd?0?5Su@ DB '['
	DB	'Quest] (%s) Load : Index %d, SubInfoCount %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOCIMNHO@load?5error?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0O@NOCIMNHO@load?5error?5?$CFs?$AA@ DB 'load error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadQuestInfo@CQuestInfo@@QAEHPAD@Z
_TEXT	SEGMENT
tv621 = -20						; size = 4
_iQuestIndex$213460 = -16				; size = 4
tv546 = -12						; size = 4
tv482 = -12						; size = 4
tv464 = -12						; size = 4
tv461 = -12						; size = 4
tv451 = -12						; size = 4
tv446 = -12						; size = 4
tv435 = -12						; size = 4
tv426 = -12						; size = 4
tv347 = -12						; size = 4
tv327 = -12						; size = 4
tv270 = -12						; size = 4
tv252 = -12						; size = 4
tv198 = -12						; size = 4
tv180 = -12						; size = 4
_iSubInfoCount$213464 = -8				; size = 4
tv628 = -4						; size = 4
_iFailInfoCount$213475 = 8				; size = 4
_filename$ = 8						; size = 4
tv584 = 10						; size = 2
tv470 = 10						; size = 2
tv455 = 10						; size = 2
tv442 = 10						; size = 2
tv402 = 10						; size = 2
tv297 = 10						; size = 2
tv225 = 10						; size = 2
?LoadQuestInfo@CQuestInfo@@QAEHPAD@Z PROC		; CQuestInfo::LoadQuestInfo, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 60   : 	int Token;
; 61   : 	int n;
; 62   : 
; 63   : 	SMDFile = fopen(filename, "r");	//ok

  00007	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0000a	57		 push	 edi
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00010	56		 push	 esi
  00011	8b f9		 mov	 edi, ecx
  00013	e8 00 00 00 00	 call	 _fopen
  00018	83 c4 08	 add	 esp, 8
  0001b	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 64   : 
; 65   : 	if ( SMDFile == NULL )

  00020	85 c0		 test	 eax, eax
  00022	75 18		 jne	 SHORT $LN18@LoadQuestI

; 66   : 	{
; 67   : 		MsgBox("load error %s", filename);

  00024	56		 push	 esi
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NOCIMNHO@load?5error?5?$CFs?$AA@
  0002a	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002f	83 c4 08	 add	 esp, 8
  00032	5f		 pop	 edi

; 68   : 		return false;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 249  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN18@LoadQuestI:
  0003c	53		 push	 ebx

; 69   : 	}
; 70   : 
; 71   : 	this->Init();

  0003d	8b cf		 mov	 ecx, edi
  0003f	e8 00 00 00 00	 call	 ?Init@CQuestInfo@@QAEXXZ ; CQuestInfo::Init

; 72   : 
; 73   : 	n = 0;
; 74   : 
; 75   : 	while ( true )
; 76   : 	{
; 77   : 		Token = GetToken();

  00044	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 78   : 
; 79   : 		if ( Token == 2 )

  00049	83 f8 02	 cmp	 eax, 2
  0004c	0f 84 8a 03 00
	00		 je	 $LN38@LoadQuestI
$LL17@LoadQuestI:

; 80   : 		{
; 81   : 			break;
; 82   : 		}
; 83   : 		else
; 84   : 		{
; 85   : 			if ( Token == 1 )

  00052	83 f8 01	 cmp	 eax, 1
  00055	0f 85 73 03 00
	00		 jne	 $LN39@LoadQuestI

; 86   : 			{
; 87   : 				int Type = TokenNumber;

  0005b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00061	e8 00 00 00 00	 call	 __ftol2_sse

; 88   : 
; 89   : 				if ( Type == 0 )

  00066	85 c0		 test	 eax, eax
  00068	0f 85 92 03 00
	00		 jne	 $LN12@LoadQuestI

; 90   : 				{
; 91   : 					Token = GetToken();

  0006e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 92   : 					int iQuestIndex = TokenNumber;

  00073	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00079	e8 00 00 00 00	 call	 __ftol2_sse

; 93   : 					this->QuestInfo[iQuestIndex].QuestIndex = iQuestIndex;

  0007e	8b d8		 mov	 ebx, eax
  00080	69 db 30 04 00
	00		 imul	 ebx, 1072		; 00000430H
  00086	89 45 f0	 mov	 DWORD PTR _iQuestIndex$213460[ebp], eax
  00089	89 44 3b 3c	 mov	 DWORD PTR [ebx+edi+60], eax

; 94   : 
; 95   : 					Token = GetToken();

  0008d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 96   : 					this->QuestInfo[iQuestIndex].QuestStartType = TokenNumber;

  00092	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00098	e8 00 00 00 00	 call	 __ftol2_sse
  0009d	89 44 3b 40	 mov	 DWORD PTR [ebx+edi+64], eax

; 97   : 
; 98   : 					Token = GetToken();

  000a1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 99   : 					this->QuestInfo[iQuestIndex].QuestStartSubType = TokenNumber;

  000a6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000ac	e8 00 00 00 00	 call	 __ftol2_sse
  000b1	89 44 3b 44	 mov	 DWORD PTR [ebx+edi+68], eax

; 100  : 
; 101  : 					Token = GetToken();

  000b5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 102  : 					strcpy( this->QuestInfo[iQuestIndex].Name, TokenString);

  000ba	8d 54 3b 08	 lea	 edx, DWORD PTR [ebx+edi+8]
  000be	b8 00 00 00 00	 mov	 eax, OFFSET _TokenString
  000c3	89 55 ec	 mov	 DWORD PTR tv621[ebp], edx
  000c6	2b d0		 sub	 edx, eax
$LL21@LoadQuestI:
  000c8	8a 08		 mov	 cl, BYTE PTR [eax]
  000ca	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000cd	40		 inc	 eax
  000ce	84 c9		 test	 cl, cl
  000d0	75 f6		 jne	 SHORT $LL21@LoadQuestI

; 103  : 
; 104  : 					this->QuestInfo[iQuestIndex].QuestSubInfoCount = 0;

  000d2	8d 44 3b 48	 lea	 eax, DWORD PTR [ebx+edi+72]
  000d6	89 45 fc	 mov	 DWORD PTR tv628[ebp], eax
  000d9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000df	90		 npad	 1
$LL11@LoadQuestI:

; 105  : 
; 106  : 					while ( true )
; 107  : 					{
; 108  : 						int iSubInfoCount = this->QuestInfo[iQuestIndex].QuestSubInfoCount;

  000e0	8b 30		 mov	 esi, DWORD PTR [eax]
  000e2	89 75 f8	 mov	 DWORD PTR _iSubInfoCount$213464[ebp], esi

; 109  : 
; 110  : 						Token = GetToken();

  000e5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 111  : 
; 112  : 						if ( Token == 0 )

  000ea	85 c0		 test	 eax, eax
  000ec	75 3a		 jne	 SHORT $LN8@LoadQuestI

; 113  : 						{
; 114  : 							if ( strcmp("end", TokenString) == 0 )

  000ee	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  000f3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL30@LoadQuestI:
  000f8	8a 10		 mov	 dl, BYTE PTR [eax]
  000fa	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000fc	75 1a		 jne	 SHORT $LN31@LoadQuestI
  000fe	84 d2		 test	 dl, dl
  00100	74 12		 je	 SHORT $LN32@LoadQuestI
  00102	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00105	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00108	75 0e		 jne	 SHORT $LN31@LoadQuestI
  0010a	83 c0 02	 add	 eax, 2
  0010d	83 c1 02	 add	 ecx, 2
  00110	84 d2		 test	 dl, dl
  00112	75 e4		 jne	 SHORT $LL30@LoadQuestI
$LN32@LoadQuestI:
  00114	33 c0		 xor	 eax, eax
  00116	eb 05		 jmp	 SHORT $LN33@LoadQuestI
$LN31@LoadQuestI:
  00118	1b c0		 sbb	 eax, eax
  0011a	83 d8 ff	 sbb	 eax, -1
$LN33@LoadQuestI:
  0011d	85 c0		 test	 eax, eax
  0011f	0f 84 8a 02 00
	00		 je	 $LN27@LoadQuestI
  00125	8b 75 f8	 mov	 esi, DWORD PTR _iSubInfoCount$213464[ebp]
$LN8@LoadQuestI:

; 115  : 							{
; 116  : 								break;
; 117  : 							}
; 118  : 						}
; 119  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].QuestType = TokenNumber;

  00128	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0012e	8d 04 f6	 lea	 eax, DWORD PTR [esi+esi*8]
  00131	8d 34 c3	 lea	 esi, DWORD PTR [ebx+eax*8]
  00134	03 f7		 add	 esi, edi
  00136	e8 00 00 00 00	 call	 __ftol2_sse
  0013b	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 120  : 
; 121  : 						Token = GetToken();

  0013e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 122  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedType = TokenNumber;

  00143	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00149	e8 00 00 00 00	 call	 __ftol2_sse
  0014e	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 123  : 
; 124  : 						Token = GetToken();

  00151	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 125  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedSubType = TokenNumber;

  00156	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0015c	e8 00 00 00 00	 call	 __ftol2_sse
  00161	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 126  : 
; 127  : 						Token = GetToken();

  00164	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 128  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ItemLevel = TokenNumber;

  00169	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0016f	e8 00 00 00 00	 call	 __ftol2_sse
  00174	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 129  : 
; 130  : 						Token = GetToken();

  00177	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 131  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedNumber = TokenNumber;

  0017c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00182	e8 00 00 00 00	 call	 __ftol2_sse
  00187	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 132  : 
; 133  : 						Token = GetToken();

  0018a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 134  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedTargetMinLevel = TokenNumber;

  0018f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00195	e8 00 00 00 00	 call	 __ftol2_sse
  0019a	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 135  : 
; 136  : 						Token = GetToken();

  0019d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 137  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedTargetMaxLevel = TokenNumber;

  001a2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a8	e8 00 00 00 00	 call	 __ftol2_sse
  001ad	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 138  : 
; 139  : 						Token = GetToken();

  001b0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 140  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedDropRate = TokenNumber;

  001b5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001bb	e8 00 00 00 00	 call	 __ftol2_sse
  001c0	89 46 68	 mov	 DWORD PTR [esi+104], eax

; 141  : 
; 142  : 						Token = GetToken();

  001c3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 143  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RewardType = TokenNumber;

  001c8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001ce	e8 00 00 00 00	 call	 __ftol2_sse
  001d3	89 46 6c	 mov	 DWORD PTR [esi+108], eax

; 144  : 
; 145  : 						Token = GetToken();

  001d6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 146  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RewardSubType = TokenNumber;

  001db	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e1	e8 00 00 00 00	 call	 __ftol2_sse
  001e6	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 147  : 
; 148  : 						Token = GetToken();

  001e9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 149  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RewardCount = TokenNumber;

  001ee	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f4	e8 00 00 00 00	 call	 __ftol2_sse
  001f9	89 46 74	 mov	 DWORD PTR [esi+116], eax

; 150  : 
; 151  : 						Token = GetToken();

  001fc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 152  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].LinkConditionIndex = TokenNumber;

  00201	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00207	e8 00 00 00 00	 call	 __ftol2_sse
  0020c	89 46 78	 mov	 DWORD PTR [esi+120], eax

; 153  : 
; 154  : 						Token = GetToken();

  0020f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 155  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextBeforeReg = TokenNumber;

  00214	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0021a	e8 00 00 00 00	 call	 __ftol2_sse
  0021f	89 46 7c	 mov	 DWORD PTR [esi+124], eax

; 156  : 
; 157  : 						Token = GetToken();

  00222	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 158  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextAfterReg = TokenNumber;

  00227	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0022d	e8 00 00 00 00	 call	 __ftol2_sse
  00232	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax

; 159  : 
; 160  : 						Token = GetToken();

  00238	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 161  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextCompleteQuest = TokenNumber;

  0023d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00243	e8 00 00 00 00	 call	 __ftol2_sse
  00248	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax

; 162  : 
; 163  : 						Token = GetToken();

  0024e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 164  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextQuestClear = TokenNumber;

  00253	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00259	e8 00 00 00 00	 call	 __ftol2_sse
  0025e	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax

; 165  : 
; 166  : 						Token = GetToken();

  00264	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 167  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_WIZARD] = TokenNumber;

  00269	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0026f	d9 7d 0a	 fnstcw	 WORD PTR tv584[ebp]
  00272	0f b7 45 0a	 movzx	 eax, WORD PTR tv584[ebp]
  00276	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0027b	89 45 f4	 mov	 DWORD PTR tv546[ebp], eax
  0027e	d9 6d f4	 fldcw	 WORD PTR tv546[ebp]
  00281	db 5d f4	 fistp	 DWORD PTR tv482[ebp]
  00284	0f b6 55 f4	 movzx	 edx, BYTE PTR tv482[ebp]
  00288	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  0028e	d9 6d 0a	 fldcw	 WORD PTR tv584[ebp]

; 168  : 
; 169  : 						Token = GetToken();

  00291	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 170  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_KNIGHT] = TokenNumber;

  00296	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0029c	d9 7d 0a	 fnstcw	 WORD PTR tv470[ebp]
  0029f	0f b7 45 0a	 movzx	 eax, WORD PTR tv470[ebp]
  002a3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002a8	89 45 f4	 mov	 DWORD PTR tv464[ebp], eax
  002ab	d9 6d f4	 fldcw	 WORD PTR tv464[ebp]
  002ae	db 5d f4	 fistp	 DWORD PTR tv461[ebp]
  002b1	8a 45 f4	 mov	 al, BYTE PTR tv461[ebp]
  002b4	88 86 8d 00 00
	00		 mov	 BYTE PTR [esi+141], al
  002ba	d9 6d 0a	 fldcw	 WORD PTR tv470[ebp]

; 171  : 
; 172  : 						Token = GetToken();

  002bd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 173  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_ELF] = TokenNumber;

  002c2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002c8	d9 7d 0a	 fnstcw	 WORD PTR tv455[ebp]
  002cb	0f b7 45 0a	 movzx	 eax, WORD PTR tv455[ebp]
  002cf	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002d4	89 45 f4	 mov	 DWORD PTR tv451[ebp], eax
  002d7	d9 6d f4	 fldcw	 WORD PTR tv451[ebp]
  002da	db 5d f4	 fistp	 DWORD PTR tv446[ebp]
  002dd	0f b6 4d f4	 movzx	 ecx, BYTE PTR tv446[ebp]
  002e1	88 8e 8e 00 00
	00		 mov	 BYTE PTR [esi+142], cl
  002e7	d9 6d 0a	 fldcw	 WORD PTR tv455[ebp]

; 174  : 
; 175  : 						Token = GetToken();

  002ea	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 176  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_MAGUMSA] = TokenNumber;

  002ef	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002f5	d9 7d 0a	 fnstcw	 WORD PTR tv442[ebp]
  002f8	0f b7 45 0a	 movzx	 eax, WORD PTR tv442[ebp]
  002fc	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00301	89 45 f4	 mov	 DWORD PTR tv435[ebp], eax
  00304	d9 6d f4	 fldcw	 WORD PTR tv435[ebp]
  00307	db 5d f4	 fistp	 DWORD PTR tv426[ebp]
  0030a	0f b6 55 f4	 movzx	 edx, BYTE PTR tv426[ebp]
  0030e	88 96 8f 00 00
	00		 mov	 BYTE PTR [esi+143], dl
  00314	d9 6d 0a	 fldcw	 WORD PTR tv442[ebp]

; 177  : 
; 178  : 						Token = GetToken();

  00317	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 179  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_DARKLORD] = TokenNumber;

  0031c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00322	d9 7d 0a	 fnstcw	 WORD PTR tv402[ebp]
  00325	0f b7 45 0a	 movzx	 eax, WORD PTR tv402[ebp]
  00329	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0032e	89 45 f4	 mov	 DWORD PTR tv347[ebp], eax
  00331	8b 45 f8	 mov	 eax, DWORD PTR _iSubInfoCount$213464[ebp]
  00334	8d 54 c0 12	 lea	 edx, DWORD PTR [eax+eax*8+18]
  00338	d9 6d f4	 fldcw	 WORD PTR tv347[ebp]
  0033b	8d 04 d3	 lea	 eax, DWORD PTR [ebx+edx*8]
  0033e	db 5d f4	 fistp	 DWORD PTR tv327[ebp]
  00341	0f b6 4d f4	 movzx	 ecx, BYTE PTR tv327[ebp]
  00345	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
  00348	d9 6d 0a	 fldcw	 WORD PTR tv402[ebp]

; 180  : 
; 181  : 						Token = GetToken();

  0034b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 182  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_SUMMONER] = TokenNumber;

  00350	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00356	d9 7d 0a	 fnstcw	 WORD PTR tv297[ebp]
  00359	0f b7 45 0a	 movzx	 eax, WORD PTR tv297[ebp]
  0035d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00362	89 45 f4	 mov	 DWORD PTR tv270[ebp], eax
  00365	d9 6d f4	 fldcw	 WORD PTR tv270[ebp]
  00368	db 5d f4	 fistp	 DWORD PTR tv252[ebp]
  0036b	0f b6 4d f4	 movzx	 ecx, BYTE PTR tv252[ebp]
  0036f	88 8e 91 00 00
	00		 mov	 BYTE PTR [esi+145], cl
  00375	d9 6d 0a	 fldcw	 WORD PTR tv297[ebp]

; 183  : 
; 184  : 						Token = GetToken();

  00378	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 185  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_MONK] = TokenNumber;

  0037d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00383	d9 7d 0a	 fnstcw	 WORD PTR tv225[ebp]
  00386	0f b7 45 0a	 movzx	 eax, WORD PTR tv225[ebp]
  0038a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0038f	89 45 f4	 mov	 DWORD PTR tv198[ebp], eax

; 186  : 
; 187  : 						this->QuestInfo[iQuestIndex].QuestSubInfoCount++;

  00392	8b 45 fc	 mov	 eax, DWORD PTR tv628[ebp]
  00395	d9 6d f4	 fldcw	 WORD PTR tv198[ebp]
  00398	db 5d f4	 fistp	 DWORD PTR tv180[ebp]
  0039b	0f b6 55 f4	 movzx	 edx, BYTE PTR tv180[ebp]
  0039f	88 96 92 00 00
	00		 mov	 BYTE PTR [esi+146], dl
  003a5	ff 00		 inc	 DWORD PTR [eax]
  003a7	d9 6d 0a	 fldcw	 WORD PTR tv225[ebp]

; 188  : 
; 189  : 					
; 190  : 					}

  003aa	e9 31 fd ff ff	 jmp	 $LL11@LoadQuestI
$LN27@LoadQuestI:

; 191  : 					
; 192  : 					LogAdd("[Quest] (%s) Load : Index %d, SubInfoCount %d",	this->QuestInfo[iQuestIndex].Name, iQuestIndex,	this->QuestInfo[iQuestIndex].QuestSubInfoCount );

  003af	8b 45 fc	 mov	 eax, DWORD PTR tv628[ebp]
  003b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b4	8b 55 f0	 mov	 edx, DWORD PTR _iQuestIndex$213460[ebp]
  003b7	8b 45 ec	 mov	 eax, DWORD PTR tv621[ebp]
  003ba	51		 push	 ecx
  003bb	52		 push	 edx
  003bc	50		 push	 eax
  003bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@IPPCPA@?$FLQuest?$FN?5?$CI?$CFs?$CJ?5Load?5?3?5Index?5?$CFd?0?5Su@
  003c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003c8	83 c4 10	 add	 esp, 16			; 00000010H

; 193  : 					this->m_QuestCount++;

  003cb	ff 47 04	 inc	 DWORD PTR [edi+4]
$LN39@LoadQuestI:

; 78   : 
; 79   : 		if ( Token == 2 )

  003ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003d3	83 f8 02	 cmp	 eax, 2
  003d6	0f 85 76 fc ff
	ff		 jne	 $LL17@LoadQuestI
$LN38@LoadQuestI:

; 241  : 				}
; 242  : 			}
; 243  : 		}
; 244  : 	}
; 245  : 
; 246  : 	fclose(SMDFile);

  003dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  003e2	52		 push	 edx
  003e3	e8 00 00 00 00	 call	 _fclose
  003e8	83 c4 04	 add	 esp, 4

; 247  : 	this->InitQuestItem();

  003eb	8b cf		 mov	 ecx, edi
  003ed	e8 00 00 00 00	 call	 ?InitQuestItem@CQuestInfo@@QAEXXZ ; CQuestInfo::InitQuestItem
  003f2	5b		 pop	 ebx
  003f3	5f		 pop	 edi

; 248  : 	return true;

  003f4	b8 01 00 00 00	 mov	 eax, 1
  003f9	5e		 pop	 esi

; 249  : }

  003fa	8b e5		 mov	 esp, ebp
  003fc	5d		 pop	 ebp
  003fd	c2 04 00	 ret	 4
$LN12@LoadQuestI:

; 194  : 				}
; 195  : 				else if ( Type == 1 )

  00400	83 f8 01	 cmp	 eax, 1
  00403	0f 85 22 01 00
	00		 jne	 $LN6@LoadQuestI

; 196  : 				{
; 197  : 					Token = GetToken();

  00409	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 198  : 					int iQuestIndex = TokenNumber;

  0040e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00414	e8 00 00 00 00	 call	 __ftol2_sse
  00419	8b d8		 mov	 ebx, eax
  0041b	69 db 30 04 00
	00		 imul	 ebx, 1072		; 00000430H
$LL5@LoadQuestI:

; 199  : 
; 200  : 					while ( true )
; 201  : 					{
; 202  : 						auto iFailInfoCount = this->QuestInfo[iQuestIndex].QuestConditionCount;

  00421	8b b4 3b 1c 03
	00 00		 mov	 esi, DWORD PTR [ebx+edi+796]
  00428	89 75 08	 mov	 DWORD PTR _iFailInfoCount$213475[ebp], esi

; 203  : 						Token = GetToken();

  0042b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 204  : 
; 205  : 						if ( Token == 0 )

  00430	85 c0		 test	 eax, eax
  00432	75 39		 jne	 SHORT $LN2@LoadQuestI

; 206  : 						{
; 207  : 							if ( strcmp("end", TokenString) == 0 )

  00434	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00439	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0043e	8b ff		 npad	 2
$LL34@LoadQuestI:
  00440	8a 10		 mov	 dl, BYTE PTR [eax]
  00442	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00444	75 1a		 jne	 SHORT $LN35@LoadQuestI
  00446	84 d2		 test	 dl, dl
  00448	74 12		 je	 SHORT $LN36@LoadQuestI
  0044a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0044d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00450	75 0e		 jne	 SHORT $LN35@LoadQuestI
  00452	83 c0 02	 add	 eax, 2
  00455	83 c1 02	 add	 ecx, 2
  00458	84 d2		 test	 dl, dl
  0045a	75 e4		 jne	 SHORT $LL34@LoadQuestI
$LN36@LoadQuestI:
  0045c	33 c0		 xor	 eax, eax
  0045e	eb 05		 jmp	 SHORT $LN37@LoadQuestI
$LN35@LoadQuestI:
  00460	1b c0		 sbb	 eax, eax
  00462	83 d8 ff	 sbb	 eax, -1
$LN37@LoadQuestI:
  00465	85 c0		 test	 eax, eax
  00467	0f 84 61 ff ff
	ff		 je	 $LN39@LoadQuestI
$LN2@LoadQuestI:

; 208  : 							{
; 209  : 								break;
; 210  : 							}
; 211  : 						}
; 212  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].Index = TokenNumber;

  0046d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00473	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*8]
  0047a	2b ce		 sub	 ecx, esi
  0047c	8d 34 8b	 lea	 esi, DWORD PTR [ebx+ecx*4]
  0047f	03 f7		 add	 esi, edi
  00481	e8 00 00 00 00	 call	 __ftol2_sse
  00486	89 86 20 03 00
	00		 mov	 DWORD PTR [esi+800], eax

; 213  : 
; 214  : 							Token = GetToken();

  0048c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 215  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].NeedQuestIndex = TokenNumber;

  00491	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00497	e8 00 00 00 00	 call	 __ftol2_sse
  0049c	89 86 24 03 00
	00		 mov	 DWORD PTR [esi+804], eax

; 216  : 
; 217  : 							Token = GetToken();

  004a2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 218  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].MinLevel = TokenNumber;

  004a7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004ad	e8 00 00 00 00	 call	 __ftol2_sse
  004b2	89 86 28 03 00
	00		 mov	 DWORD PTR [esi+808], eax

; 219  : 
; 220  : 							Token = GetToken();

  004b8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 221  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].MaxLevel = TokenNumber;

  004bd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004c3	e8 00 00 00 00	 call	 __ftol2_sse
  004c8	8b 4d 08	 mov	 ecx, DWORD PTR _iFailInfoCount$213475[ebp]
  004cb	83 c1 1d	 add	 ecx, 29			; 0000001dH
  004ce	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  004d5	2b d1		 sub	 edx, ecx
  004d7	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  004da	89 04 39	 mov	 DWORD PTR [ecx+edi], eax

; 222  : 
; 223  : 							Token = GetToken();

  004dd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 224  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].ReqStr = TokenNumber;

  004e2	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004e8	e8 00 00 00 00	 call	 __ftol2_sse
  004ed	89 86 30 03 00
	00		 mov	 DWORD PTR [esi+816], eax

; 225  : 
; 226  : 							Token = GetToken();

  004f3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 227  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].NeedZen = TokenNumber;

  004f8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004fe	e8 00 00 00 00	 call	 __ftol2_sse
  00503	89 86 34 03 00
	00		 mov	 DWORD PTR [esi+820], eax

; 228  : 
; 229  : 							Token = GetToken();

  00509	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 230  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].StartContext = TokenNumber;

  0050e	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00514	e8 00 00 00 00	 call	 __ftol2_sse
  00519	89 86 38 03 00
	00		 mov	 DWORD PTR [esi+824], eax

; 231  : 
; 232  : 							this->QuestInfo[iQuestIndex].QuestConditionCount++;

  0051f	ff 84 3b 1c 03
	00 00		 inc	 DWORD PTR [ebx+edi+796]

; 233  : 						
; 234  : 					}

  00526	e9 f6 fe ff ff	 jmp	 $LL5@LoadQuestI
$LN6@LoadQuestI:

; 235  : 				}
; 236  : 				else
; 237  : 				{
; 238  : 					MsgBox("Quest Info Read Fail");

  0052b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAOCNINL@Quest?5Info?5Read?5Fail?$AA@
  00530	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 239  : 					fclose(SMDFile);

  00535	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0053a	50		 push	 eax
  0053b	e8 00 00 00 00	 call	 _fclose
  00540	83 c4 08	 add	 esp, 8
  00543	5b		 pop	 ebx
  00544	5f		 pop	 edi

; 240  : 					return false;

  00545	33 c0		 xor	 eax, eax
  00547	5e		 pop	 esi

; 249  : }

  00548	8b e5		 mov	 esp, ebp
  0054a	5d		 pop	 ebp
  0054b	c2 04 00	 ret	 4
?LoadQuestInfo@CQuestInfo@@QAEHPAD@Z ENDP		; CQuestInfo::LoadQuestInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z		; CQuestInfo::LoadQuestInfo
EXTRN	??1CWzMemScript@@UAE@XZ:PROC			; CWzMemScript::~CWzMemScript
EXTRN	?GetString@CWzMemScript@@QAEPADXZ:PROC		; CWzMemScript::GetString
EXTRN	?GetNumber@CWzMemScript@@QAEHXZ:PROC		; CWzMemScript::GetNumber
EXTRN	?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ:PROC ; CWzMemScript::GetToken
EXTRN	?SetBuffer@CWzMemScript@@QAEHPADH@Z:PROC	; CWzMemScript::SetBuffer
EXTRN	??0CWzMemScript@@QAE@XZ:PROC			; CWzMemScript::CWzMemScript
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z$0
__ehfuncinfo$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z
_TEXT	SEGMENT
_iSubInfoCount$213506 = -164				; size = 4
_iQuestIndex$213501 = -160				; size = 4
tv683 = -156						; size = 4
_iFailInfoCount$213516 = -156				; size = 4
tv690 = -152						; size = 4
_WzMemScript$ = -148					; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Buffer$ = 8						; size = 4
_iSize$ = 12						; size = 4
?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z PROC		; CQuestInfo::LoadQuestInfo, COMDAT
; _this$ = ecx

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 75 08	 mov	 esi, DWORD PTR _Buffer$[ebp]
  00031	8b f9		 mov	 edi, ecx

; 254  : 	CWzMemScript WzMemScript;

  00033	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00039	e8 00 00 00 00	 call	 ??0CWzMemScript@@QAE@XZ	; CWzMemScript::CWzMemScript

; 255  : 	int Token;
; 256  : 	int n;
; 257  : 
; 258  : 	WzMemScript.SetBuffer(Buffer, iSize);

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00041	50		 push	 eax
  00042	56		 push	 esi
  00043	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	e8 00 00 00 00	 call	 ?SetBuffer@CWzMemScript@@QAEHPADH@Z ; CWzMemScript::SetBuffer

; 259  : 	this->Init();

  00055	8b cf		 mov	 ecx, edi
  00057	e8 00 00 00 00	 call	 ?Init@CQuestInfo@@QAEXXZ ; CQuestInfo::Init

; 260  : 
; 261  : 	n = 0;
; 262  : 
; 263  : 	while ( true )
; 264  : 	{
; 265  : 		Token = WzMemScript.GetToken();

  0005c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00062	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 266  : 
; 267  : 		if ( Token == 2 )

  00067	83 f8 02	 cmp	 eax, 2
  0006a	0f 84 c1 03 00
	00		 je	 $LN29@LoadQuestI@2
$LN17@LoadQuestI@2:

; 268  : 		{
; 269  : 			break;
; 270  : 		}
; 271  : 		else
; 272  : 		{
; 273  : 			if ( Token == 1 )

  00070	83 f8 01	 cmp	 eax, 1
  00073	0f 85 a4 03 00
	00		 jne	 $LN28@LoadQuestI@2

; 274  : 			{
; 275  : 				int Type = WzMemScript.GetNumber();

  00079	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0007f	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 276  : 
; 277  : 				if ( Type == 0 )

  00084	85 c0		 test	 eax, eax
  00086	0f 85 c8 03 00
	00		 jne	 $LN12@LoadQuestI@2

; 278  : 				{
; 279  : 					Token = WzMemScript.GetToken();

  0008c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00092	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 280  : 					auto iQuestIndex = WzMemScript.GetNumber();

  00097	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0009d	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 281  : 					this->QuestInfo[iQuestIndex].QuestIndex = iQuestIndex;

  000a2	8b d8		 mov	 ebx, eax
  000a4	69 db 30 04 00
	00		 imul	 ebx, 1072		; 00000430H

; 282  : 
; 283  : 					Token = WzMemScript.GetToken();

  000aa	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  000b0	89 85 60 ff ff
	ff		 mov	 DWORD PTR _iQuestIndex$213501[ebp], eax
  000b6	89 44 3b 3c	 mov	 DWORD PTR [ebx+edi+60], eax
  000ba	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 284  : 					this->QuestInfo[iQuestIndex].QuestStartType = WzMemScript.GetNumber();

  000bf	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  000c5	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 285  : 
; 286  : 					Token = WzMemScript.GetToken();

  000ca	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  000d0	89 44 3b 40	 mov	 DWORD PTR [ebx+edi+64], eax
  000d4	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 287  : 					this->QuestInfo[iQuestIndex].QuestStartSubType = WzMemScript.GetNumber();

  000d9	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  000df	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 288  : 
; 289  : 					Token = WzMemScript.GetToken();

  000e4	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  000ea	89 44 3b 44	 mov	 DWORD PTR [ebx+edi+68], eax
  000ee	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 290  : 					strcpy( this->QuestInfo[iQuestIndex].Name, WzMemScript.GetString());

  000f3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  000f9	e8 00 00 00 00	 call	 ?GetString@CWzMemScript@@QAEPADXZ ; CWzMemScript::GetString
  000fe	8d 54 3b 08	 lea	 edx, DWORD PTR [ebx+edi+8]
  00102	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv683[ebp], edx
  00108	2b d0		 sub	 edx, eax
  0010a	8d 9b 00 00 00
	00		 npad	 6
$LL20@LoadQuestI@2:
  00110	8a 08		 mov	 cl, BYTE PTR [eax]
  00112	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00115	40		 inc	 eax
  00116	84 c9		 test	 cl, cl
  00118	75 f6		 jne	 SHORT $LL20@LoadQuestI@2

; 291  : 
; 292  : 					this->QuestInfo[iQuestIndex].QuestSubInfoCount = 0;

  0011a	8d 44 3b 48	 lea	 eax, DWORD PTR [ebx+edi+72]
  0011e	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv690[ebp], eax
  00124	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0012a	8d 9b 00 00 00
	00		 npad	 6
$LL11@LoadQuestI@2:

; 293  : 
; 294  : 					while ( true )
; 295  : 					{
; 296  : 						int iSubInfoCount = this->QuestInfo[iQuestIndex].QuestSubInfoCount;

  00130	8b 30		 mov	 esi, DWORD PTR [eax]

; 297  : 
; 298  : 						Token = WzMemScript.GetToken();

  00132	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00138	89 b5 5c ff ff
	ff		 mov	 DWORD PTR _iSubInfoCount$213506[ebp], esi
  0013e	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 299  : 
; 300  : 						if ( Token == 0 )

  00143	85 c0		 test	 eax, eax
  00145	75 3d		 jne	 SHORT $LN8@LoadQuestI@2

; 301  : 						{
; 302  : 							if ( strcmp("end", WzMemScript.GetString()) == 0 )

  00147	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0014d	e8 00 00 00 00	 call	 ?GetString@CWzMemScript@@QAEPADXZ ; CWzMemScript::GetString
  00152	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL30@LoadQuestI@2:
  00157	8a 11		 mov	 dl, BYTE PTR [ecx]
  00159	3a 10		 cmp	 dl, BYTE PTR [eax]
  0015b	75 1a		 jne	 SHORT $LN31@LoadQuestI@2
  0015d	84 d2		 test	 dl, dl
  0015f	74 12		 je	 SHORT $LN32@LoadQuestI@2
  00161	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00164	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00167	75 0e		 jne	 SHORT $LN31@LoadQuestI@2
  00169	83 c1 02	 add	 ecx, 2
  0016c	83 c0 02	 add	 eax, 2
  0016f	84 d2		 test	 dl, dl
  00171	75 e4		 jne	 SHORT $LL30@LoadQuestI@2
$LN32@LoadQuestI@2:
  00173	33 c0		 xor	 eax, eax
  00175	eb 05		 jmp	 SHORT $LN33@LoadQuestI@2
$LN31@LoadQuestI@2:
  00177	1b c0		 sbb	 eax, eax
  00179	83 d8 ff	 sbb	 eax, -1
$LN33@LoadQuestI@2:
  0017c	85 c0		 test	 eax, eax
  0017e	0f 84 71 02 00
	00		 je	 $LN27@LoadQuestI@2
$LN8@LoadQuestI@2:

; 303  : 							{
; 304  : 								break;
; 305  : 							}
; 306  : 						}
; 307  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].QuestType = WzMemScript.GetNumber();

  00184	8d 0c f6	 lea	 ecx, DWORD PTR [esi+esi*8]
  00187	8d 34 cb	 lea	 esi, DWORD PTR [ebx+ecx*8]
  0018a	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00190	03 f7		 add	 esi, edi
  00192	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 308  : 
; 309  : 						Token = WzMemScript.GetToken();

  00197	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0019d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  001a0	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 310  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedType = WzMemScript.GetNumber();

  001a5	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001ab	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 311  : 
; 312  : 						Token = WzMemScript.GetToken();

  001b0	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001b6	89 46 50	 mov	 DWORD PTR [esi+80], eax
  001b9	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 313  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedSubType = WzMemScript.GetNumber();

  001be	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001c4	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 314  : 
; 315  : 						Token = WzMemScript.GetToken();

  001c9	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001cf	89 46 54	 mov	 DWORD PTR [esi+84], eax
  001d2	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 316  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ItemLevel = WzMemScript.GetNumber();

  001d7	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001dd	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 317  : 
; 318  : 						Token = WzMemScript.GetToken();

  001e2	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001e8	89 46 58	 mov	 DWORD PTR [esi+88], eax
  001eb	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 319  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedNumber = WzMemScript.GetNumber();

  001f0	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  001f6	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 320  : 
; 321  : 						Token = WzMemScript.GetToken();

  001fb	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00201	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00204	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 322  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedTargetMinLevel = WzMemScript.GetNumber();

  00209	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0020f	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 323  : 
; 324  : 						Token = WzMemScript.GetToken();

  00214	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0021a	89 46 60	 mov	 DWORD PTR [esi+96], eax
  0021d	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 325  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedTargetMaxLevel = WzMemScript.GetNumber();

  00222	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00228	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 326  : 
; 327  : 						Token = WzMemScript.GetToken();

  0022d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00233	89 46 64	 mov	 DWORD PTR [esi+100], eax
  00236	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 328  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].NeedDropRate = WzMemScript.GetNumber();

  0023b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00241	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 329  : 
; 330  : 						Token = WzMemScript.GetToken();

  00246	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0024c	89 46 68	 mov	 DWORD PTR [esi+104], eax
  0024f	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 331  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RewardType = WzMemScript.GetNumber();

  00254	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0025a	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 332  : 
; 333  : 						Token = WzMemScript.GetToken();

  0025f	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00265	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00268	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 334  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RewardSubType = WzMemScript.GetNumber();

  0026d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00273	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 335  : 
; 336  : 						Token = WzMemScript.GetToken();

  00278	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0027e	89 46 70	 mov	 DWORD PTR [esi+112], eax
  00281	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 337  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RewardCount = WzMemScript.GetNumber();

  00286	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0028c	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 338  : 
; 339  : 						Token = WzMemScript.GetToken();

  00291	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00297	89 46 74	 mov	 DWORD PTR [esi+116], eax
  0029a	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 340  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].LinkConditionIndex = WzMemScript.GetNumber();

  0029f	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002a5	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 341  : 
; 342  : 						Token = WzMemScript.GetToken();

  002aa	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002b0	89 46 78	 mov	 DWORD PTR [esi+120], eax
  002b3	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 343  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextBeforeReg = WzMemScript.GetNumber();

  002b8	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002be	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 344  : 
; 345  : 						Token = WzMemScript.GetToken();

  002c3	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002c9	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  002cc	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 346  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextAfterReg = WzMemScript.GetNumber();

  002d1	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002d7	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 347  : 
; 348  : 						Token = WzMemScript.GetToken();

  002dc	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002e2	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  002e8	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 349  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextCompleteQuest = WzMemScript.GetNumber();

  002ed	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002f3	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 350  : 
; 351  : 						Token = WzMemScript.GetToken();

  002f8	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  002fe	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00304	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 352  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].ContextQuestClear = WzMemScript.GetNumber();

  00309	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0030f	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  00314	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax

; 353  : 
; 354  : 						Token = WzMemScript.GetToken();

  0031a	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00320	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 355  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_WIZARD] = WzMemScript.GetNumber();

  00325	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0032b	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 356  : 
; 357  : 						Token = WzMemScript.GetToken();

  00330	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00336	88 86 8c 00 00
	00		 mov	 BYTE PTR [esi+140], al
  0033c	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 358  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_KNIGHT] = WzMemScript.GetNumber();

  00341	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00347	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 359  : 
; 360  : 						Token = WzMemScript.GetToken();

  0034c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00352	88 86 8d 00 00
	00		 mov	 BYTE PTR [esi+141], al
  00358	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 361  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_ELF] = WzMemScript.GetNumber();

  0035d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00363	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 362  : 
; 363  : 						Token = WzMemScript.GetToken();

  00368	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0036e	88 86 8e 00 00
	00		 mov	 BYTE PTR [esi+142], al
  00374	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 364  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_MAGUMSA] = WzMemScript.GetNumber();

  00379	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0037f	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 365  : 
; 366  : 						Token = WzMemScript.GetToken();

  00384	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0038a	88 86 8f 00 00
	00		 mov	 BYTE PTR [esi+143], al
  00390	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 367  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_DARKLORD] = WzMemScript.GetNumber();

  00395	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0039b	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  003a0	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _iSubInfoCount$213506[ebp]
  003a6	8d 4c c9 12	 lea	 ecx, DWORD PTR [ecx+ecx*8+18]
  003aa	8d 14 cb	 lea	 edx, DWORD PTR [ebx+ecx*8]

; 368  : 
; 369  : 						Token = WzMemScript.GetToken();

  003ad	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  003b3	88 04 3a	 mov	 BYTE PTR [edx+edi], al
  003b6	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 370  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_SUMMONER] = WzMemScript.GetNumber();

  003bb	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  003c1	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 371  : 
; 372  : 						Token = WzMemScript.GetToken();

  003c6	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  003cc	88 86 91 00 00
	00		 mov	 BYTE PTR [esi+145], al
  003d2	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 373  : 						this->QuestInfo[iQuestIndex].QuestSubInfo[iSubInfoCount].RequireClass[CLASS_MONK] = WzMemScript.GetNumber();

  003d7	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  003dd	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  003e2	88 86 92 00 00
	00		 mov	 BYTE PTR [esi+146], al

; 374  : 
; 375  : 						this->QuestInfo[iQuestIndex].QuestSubInfoCount++;

  003e8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv690[ebp]
  003ee	ff 00		 inc	 DWORD PTR [eax]

; 376  : 
; 377  : 					
; 378  : 					}

  003f0	e9 3b fd ff ff	 jmp	 $LL11@LoadQuestI@2
$LN27@LoadQuestI@2:

; 379  : 					
; 380  : 					LogAdd("[Quest] (%s) Load : Index %d, SubInfoCount %d",	this->QuestInfo[iQuestIndex].Name, iQuestIndex,	this->QuestInfo[iQuestIndex].QuestSubInfoCount );

  003f5	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv690[ebp]
  003fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fd	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _iQuestIndex$213501[ebp]
  00403	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv683[ebp]
  00409	51		 push	 ecx
  0040a	52		 push	 edx
  0040b	50		 push	 eax
  0040c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@IPPCPA@?$FLQuest?$FN?5?$CI?$CFs?$CJ?5Load?5?3?5Index?5?$CFd?0?5Su@
  00411	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00417	83 c4 10	 add	 esp, 16			; 00000010H

; 381  : 					this->m_QuestCount++;

  0041a	ff 47 04	 inc	 DWORD PTR [edi+4]
$LN28@LoadQuestI@2:

; 260  : 
; 261  : 	n = 0;
; 262  : 
; 263  : 	while ( true )
; 264  : 	{
; 265  : 		Token = WzMemScript.GetToken();

  0041d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00423	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 266  : 
; 267  : 		if ( Token == 2 )

  00428	83 f8 02	 cmp	 eax, 2
  0042b	0f 85 3f fc ff
	ff		 jne	 $LN17@LoadQuestI@2
$LN29@LoadQuestI@2:

; 429  : 				}
; 430  : 			}
; 431  : 		}
; 432  : 	}
; 433  : 
; 434  : 	this->InitQuestItem();

  00431	8b cf		 mov	 ecx, edi
  00433	e8 00 00 00 00	 call	 ?InitQuestItem@CQuestInfo@@QAEXXZ ; CQuestInfo::InitQuestItem

; 435  : 	return true;

  00438	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0043e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00445	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  0044a	b8 01 00 00 00	 mov	 eax, 1
  0044f	e9 9b 01 00 00	 jmp	 $LN18@LoadQuestI@2
$LN12@LoadQuestI@2:

; 382  : 				}
; 383  : 				else if ( Type == 1 )

  00454	83 f8 01	 cmp	 eax, 1
  00457	0f 85 65 01 00
	00		 jne	 $LN6@LoadQuestI@2

; 384  : 				{
; 385  : 					Token = WzMemScript.GetToken();

  0045d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00463	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 386  : 					auto iQuestIndex = WzMemScript.GetNumber();

  00468	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0046e	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  00473	8b d8		 mov	 ebx, eax
  00475	69 db 30 04 00
	00		 imul	 ebx, 1072		; 00000430H
  0047b	eb 03 8d 49 00	 npad	 5
$LL5@LoadQuestI@2:

; 387  : 
; 388  : 					while ( true )
; 389  : 					{
; 390  : 						auto iFailInfoCount = this->QuestInfo[iQuestIndex].QuestConditionCount;

  00480	8b b4 3b 1c 03
	00 00		 mov	 esi, DWORD PTR [ebx+edi+796]

; 391  : 						Token = WzMemScript.GetToken();

  00487	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0048d	89 b5 64 ff ff
	ff		 mov	 DWORD PTR _iFailInfoCount$213516[ebp], esi
  00493	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 392  : 
; 393  : 						if ( Token == 0 )

  00498	85 c0		 test	 eax, eax
  0049a	75 41		 jne	 SHORT $LN2@LoadQuestI@2

; 394  : 						{
; 395  : 							if ( strcmp("end", WzMemScript.GetString()) == 0 )

  0049c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  004a2	e8 00 00 00 00	 call	 ?GetString@CWzMemScript@@QAEPADXZ ; CWzMemScript::GetString
  004a7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  004ac	8d 64 24 00	 npad	 4
$LL34@LoadQuestI@2:
  004b0	8a 11		 mov	 dl, BYTE PTR [ecx]
  004b2	3a 10		 cmp	 dl, BYTE PTR [eax]
  004b4	75 1a		 jne	 SHORT $LN35@LoadQuestI@2
  004b6	84 d2		 test	 dl, dl
  004b8	74 12		 je	 SHORT $LN36@LoadQuestI@2
  004ba	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  004bd	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  004c0	75 0e		 jne	 SHORT $LN35@LoadQuestI@2
  004c2	83 c1 02	 add	 ecx, 2
  004c5	83 c0 02	 add	 eax, 2
  004c8	84 d2		 test	 dl, dl
  004ca	75 e4		 jne	 SHORT $LL34@LoadQuestI@2
$LN36@LoadQuestI@2:
  004cc	33 c0		 xor	 eax, eax
  004ce	eb 05		 jmp	 SHORT $LN37@LoadQuestI@2
$LN35@LoadQuestI@2:
  004d0	1b c0		 sbb	 eax, eax
  004d2	83 d8 ff	 sbb	 eax, -1
$LN37@LoadQuestI@2:
  004d5	85 c0		 test	 eax, eax
  004d7	0f 84 40 ff ff
	ff		 je	 $LN28@LoadQuestI@2
$LN2@LoadQuestI@2:

; 396  : 							{
; 397  : 								break;
; 398  : 							}
; 399  : 						}	
; 400  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].Index = WzMemScript.GetNumber();

  004dd	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*8]
  004e4	2b ce		 sub	 ecx, esi
  004e6	8d 34 8b	 lea	 esi, DWORD PTR [ebx+ecx*4]
  004e9	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  004ef	03 f7		 add	 esi, edi
  004f1	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 401  : 
; 402  : 							Token = WzMemScript.GetToken();

  004f6	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  004fc	89 86 20 03 00
	00		 mov	 DWORD PTR [esi+800], eax
  00502	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 403  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].NeedQuestIndex = WzMemScript.GetNumber();

  00507	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0050d	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 404  : 
; 405  : 							Token = WzMemScript.GetToken();

  00512	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00518	89 86 24 03 00
	00		 mov	 DWORD PTR [esi+804], eax
  0051e	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 406  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].MinLevel = WzMemScript.GetNumber();

  00523	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00529	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 407  : 
; 408  : 							Token = WzMemScript.GetToken();

  0052e	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00534	89 86 28 03 00
	00		 mov	 DWORD PTR [esi+808], eax
  0053a	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 409  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].MaxLevel = WzMemScript.GetNumber();

  0053f	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00545	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  0054a	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _iFailInfoCount$213516[ebp]
  00550	83 c1 1d	 add	 ecx, 29			; 0000001dH
  00553	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0055a	2b d1		 sub	 edx, ecx
  0055c	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  0055f	89 04 39	 mov	 DWORD PTR [ecx+edi], eax

; 410  : 
; 411  : 							Token = WzMemScript.GetToken();

  00562	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00568	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 412  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].ReqStr = WzMemScript.GetNumber();

  0056d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00573	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 413  : 
; 414  : 							Token = WzMemScript.GetToken();

  00578	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0057e	89 86 30 03 00
	00		 mov	 DWORD PTR [esi+816], eax
  00584	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 415  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].NeedZen = WzMemScript.GetNumber();

  00589	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0058f	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber

; 416  : 
; 417  : 							Token = WzMemScript.GetToken();

  00594	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  0059a	89 86 34 03 00
	00		 mov	 DWORD PTR [esi+820], eax
  005a0	e8 00 00 00 00	 call	 ?GetToken@CWzMemScript@@QAE?AW4SMDToken@@XZ ; CWzMemScript::GetToken

; 418  : 							this->QuestInfo[iQuestIndex].QuestCondition[iFailInfoCount].StartContext = WzMemScript.GetNumber();

  005a5	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  005ab	e8 00 00 00 00	 call	 ?GetNumber@CWzMemScript@@QAEHXZ ; CWzMemScript::GetNumber
  005b0	89 86 38 03 00
	00		 mov	 DWORD PTR [esi+824], eax

; 419  : 
; 420  : 							this->QuestInfo[iQuestIndex].QuestConditionCount++;

  005b6	ff 84 3b 1c 03
	00 00		 inc	 DWORD PTR [ebx+edi+796]

; 421  : 						
; 422  : 					}

  005bd	e9 be fe ff ff	 jmp	 $LL5@LoadQuestI@2
$LN6@LoadQuestI@2:

; 423  : 				}
; 424  : 				else
; 425  : 				{
; 426  : 					MsgBox("Quest Info Read Fail");

  005c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JAOCNINL@Quest?5Info?5Read?5Fail?$AA@
  005c7	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 427  : 					fclose(SMDFile);

  005cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  005d2	52		 push	 edx
  005d3	e8 00 00 00 00	 call	 _fclose
  005d8	83 c4 08	 add	 esp, 8

; 428  : 					return false;

  005db	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  005e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005e8	e8 00 00 00 00	 call	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
  005ed	33 c0		 xor	 eax, eax
$LN18@LoadQuestI@2:

; 436  : }

  005ef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005f9	59		 pop	 ecx
  005fa	5f		 pop	 edi
  005fb	5e		 pop	 esi
  005fc	5b		 pop	 ebx
  005fd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00600	33 cd		 xor	 ecx, ebp
  00602	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00607	8b e5		 mov	 esp, ebp
  00609	5d		 pop	 ebp
  0060a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z$0:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _WzMemScript$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CWzMemScript@@UAE@XZ	; CWzMemScript::~CWzMemScript
__ehhandler$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadQuestInfo@CQuestInfo@@QAEHPADH@Z ENDP		; CQuestInfo::LoadQuestInfo
PUBLIC	??_C@_0CC@BPALCPGE@?$FLQuest?$FN?5AcceptQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs@ ; `string'
PUBLIC	??_C@_0CB@KKBMLGHJ@?$FLQuest?$FN?5ClearQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z ; CQuestInfo::SetQuestState
;	COMDAT ??_C@_0CC@BPALCPGE@?$FLQuest?$FN?5AcceptQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs@
CONST	SEGMENT
??_C@_0CC@BPALCPGE@?$FLQuest?$FN?5AcceptQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs@ DB '['
	DB	'Quest] AcceptQuest [%s][%s] (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KKBMLGHJ@?$FLQuest?$FN?5ClearQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0CB@KKBMLGHJ@?$FLQuest?$FN?5ClearQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs?$CJ@ DB '['
	DB	'Quest] ClearQuest [%s][%s] (%s)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
_State$ = 16						; size = 4
?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z PROC ; CQuestInfo::SetQuestState, COMDAT
; _this$ = ecx

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 521  : 	if ( QuestIndex < 0 || QuestIndex > MAX_QUEST_INFO )

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _QuestIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	81 ff c8 00 00
	00		 cmp	 edi, 200		; 000000c8H
  00010	0f 87 db 00 00
	00		 ja	 $LN8@SetQuestSt

; 524  : 	}
; 525  : 
; 526  : 	int QuestState = this->GetQuestState(lpObj, QuestIndex);

  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001a	57		 push	 edi
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState

; 527  : 
; 528  : 	if ( QuestState == 3 || QuestState == 0)

  00021	83 f8 03	 cmp	 eax, 3
  00024	74 50		 je	 SHORT $LN6@SetQuestSt
  00026	85 c0		 test	 eax, eax
  00028	74 4c		 je	 SHORT $LN6@SetQuestSt

; 540  : 	}
; 541  : 	else if ( QuestState == 1 )

  0002a	83 f8 01	 cmp	 eax, 1
  0002d	75 3e		 jne	 SHORT $LN3@SetQuestSt

; 542  : 	{
; 543  : 		BYTE btCond = this->QuestClearConditionCheck(lpObj, QuestIndex);

  0002f	57		 push	 edi
  00030	56		 push	 esi
  00031	8b cb		 mov	 ecx, ebx
  00033	e8 00 00 00 00	 call	 ?QuestClearConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestClearConditionCheck

; 544  : 
; 545  : 		if ( btCond != 0 )

  00038	84 c0		 test	 al, al

; 546  : 		{
; 547  : 			return btCond;

  0003a	75 33		 jne	 SHORT $LN12@SetQuestSt

; 548  : 		}
; 549  : 
; 550  : 		this->QuestClear(lpObj, QuestIndex);

  0003c	57		 push	 edi
  0003d	56		 push	 esi
  0003e	8b cb		 mov	 ecx, ebx
  00040	e8 00 00 00 00	 call	 ?QuestClear@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestClear

; 551  : 		State = 2;
; 552  : 		LogAddTD("[Quest] ClearQuest [%s][%s] (%s)", lpObj->AccountID, lpObj->Name,	this->GetQuestInfo(QuestIndex)->Name);

  00045	57		 push	 edi
  00046	8b cb		 mov	 ecx, ebx
  00048	c7 45 10 02 00
	00 00		 mov	 DWORD PTR _State$[ebp], 2
  0004f	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00054	50		 push	 eax
  00055	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00058	50		 push	 eax
  00059	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  0005c	51		 push	 ecx
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KKBMLGHJ@?$FLQuest?$FN?5ClearQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs?$CJ@
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 553  : 	}
; 554  : 	else

  00068	8a 5d 10	 mov	 bl, BYTE PTR _State$[ebp]
  0006b	eb 40		 jmp	 SHORT $LN14@SetQuestSt
$LN3@SetQuestSt:

; 555  : 	{
; 556  : 		return -1;

  0006d	0c ff		 or	 al, 255			; 000000ffH
$LN12@SetQuestSt:
  0006f	5e		 pop	 esi
  00070	5f		 pop	 edi
  00071	5b		 pop	 ebx

; 564  : }

  00072	5d		 pop	 ebp
  00073	c2 0c 00	 ret	 12			; 0000000cH
$LN6@SetQuestSt:

; 529  : 	{
; 530  : 		BYTE btCond = this->QuestRunConditionCheck(lpObj, QuestIndex);

  00076	57		 push	 edi
  00077	56		 push	 esi
  00078	8b cb		 mov	 ecx, ebx
  0007a	e8 00 00 00 00	 call	 ?QuestRunConditionCheck@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestRunConditionCheck

; 531  : 
; 532  : 		if ( btCond != 0 )

  0007f	84 c0		 test	 al, al

; 533  : 		{
; 534  : 			return btCond;

  00081	75 ec		 jne	 SHORT $LN12@SetQuestSt

; 535  : 		}
; 536  : 
; 537  : 		this->QuestAccept(lpObj, QuestIndex);

  00083	57		 push	 edi
  00084	56		 push	 esi
  00085	8b cb		 mov	 ecx, ebx
  00087	e8 00 00 00 00	 call	 ?QuestAccept@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::QuestAccept

; 538  : 		LogAddTD("[Quest] AcceptQuest [%s][%s] (%s)", lpObj->AccountID, lpObj->Name, this->GetQuestInfo(QuestIndex)->Name);

  0008c	57		 push	 edi
  0008d	8b cb		 mov	 ecx, ebx
  0008f	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  00094	50		 push	 eax
  00095	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00098	52		 push	 edx
  00099	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  0009c	50		 push	 eax
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BPALCPGE@?$FLQuest?$FN?5AcceptQuest?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFs@
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 539  : 		State = 1;

  000a8	bb 01 00 00 00	 mov	 ebx, 1
$LN14@SetQuestSt:

; 557  : 	}
; 558  : 
; 559  : 	int index = (QuestIndex / 4);

  000ad	8b c7		 mov	 eax, edi
  000af	99		 cdq
  000b0	83 e2 03	 and	 edx, 3
  000b3	03 c2		 add	 eax, edx

; 560  : 	int shift =  (QuestIndex % 4) *2;

  000b5	8b cf		 mov	 ecx, edi
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	c1 f8 02	 sar	 eax, 2
  000bd	81 e1 03 00 00
	80		 and	 ecx, -2147483645	; 80000003H
  000c3	79 05		 jns	 SHORT $LN13@SetQuestSt
  000c5	49		 dec	 ecx
  000c6	83 c9 fc	 or	 ecx, -4			; fffffffcH
  000c9	41		 inc	 ecx
$LN13@SetQuestSt:

; 561  : 	lpObj->m_Quest[index] &= QuestBitMask[shift];

  000ca	8a 94 09 00 00
	00 00		 mov	 dl, BYTE PTR ?QuestBitMask@@3PAEA[ecx+ecx]
  000d1	22 94 30 8c 10
	00 00		 and	 dl, BYTE PTR [eax+esi+4236]
  000d8	03 c9		 add	 ecx, ecx

; 562  : 	lpObj->m_Quest[index] |= (State&3) << shift;

  000da	80 e3 03	 and	 bl, 3
  000dd	d2 e3		 shl	 bl, cl
  000df	0a d3		 or	 dl, bl
  000e1	88 94 30 8c 10
	00 00		 mov	 BYTE PTR [eax+esi+4236], dl
  000e8	5e		 pop	 esi
  000e9	5f		 pop	 edi

; 563  : 	return 0;

  000ea	32 c0		 xor	 al, al
  000ec	5b		 pop	 ebx

; 564  : }

  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
$LN8@SetQuestSt:
  000f1	5f		 pop	 edi

; 522  : 	{
; 523  : 		return -1;

  000f2	0c ff		 or	 al, 255			; 000000ffH
  000f4	5b		 pop	 ebx

; 564  : }

  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z ENDP ; CQuestInfo::SetQuestState
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_QuestInfo@@YAXXZ
text$yc	SEGMENT
??__Eg_QuestInfo@@YAXXZ PROC				; `dynamic initializer for 'g_QuestInfo'', COMDAT

; 22   : CQuestInfo g_QuestInfo;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00005	e8 00 00 00 00	 call	 ??0CQuestInfo@@QAE@XZ	; CQuestInfo::CQuestInfo
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_QuestInfo@@YAXXZ ; `dynamic atexit destructor for 'g_QuestInfo''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_QuestInfo@@YAXXZ ENDP				; `dynamic initializer for 'g_QuestInfo''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_QuestInfo@@YAXXZ
text$yd	SEGMENT
??__Fg_QuestInfo@@YAXXZ PROC				; `dynamic atexit destructor for 'g_QuestInfo'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00005	e9 00 00 00 00	 jmp	 ??1CQuestInfo@@UAE@XZ	; CQuestInfo::~CQuestInfo
??__Fg_QuestInfo@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_QuestInfo''
text$yd	ENDS
PUBLIC	?g_QuestInfo@@3VCQuestInfo@@A			; g_QuestInfo
_BSS	SEGMENT
?g_QuestInfo@@3VCQuestInfo@@A DB 034588H DUP (?)	; g_QuestInfo
_BSS	ENDS
CRT$XCU	SEGMENT
_g_QuestInfo$initializer$ DD FLAT:??__Eg_QuestInfo@@YAXXZ
CRT$XCU	ENDS
END
