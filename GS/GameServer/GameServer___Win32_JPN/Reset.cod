; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\Reset.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@ ; `string'
PUBLIC	?ExResetSystemFunciton@cResetSystem@@QAEXH@Z	; cResetSystem::ExResetSystemFunciton
EXTRN	?ResetUp@CAchievements@@QAEXH@Z:PROC		; CAchievements::ResetUp
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; ResetSystemGC_CharUpdate
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?GCManaSend@@YAXHHEEH@Z:PROC			; GCManaSend
EXTRN	?GCReFillSend@@YAXHHEEH@Z:PROC			; GCReFillSend
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?ZtFireCracker@@YAXHEE@Z:PROC			; ZtFireCracker
EXTRN	?gGrandReset@@3VcGrandReset@@A:BYTE		; gGrandReset
EXTRN	?ZtUserDataSend@@YAXH@Z:PROC			; ZtUserDataSend
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?gObjDeleteItemsCount@@YAHHFFH@Z:PROC		; gObjDeleteItemsCount
EXTRN	?gObjGetItemCountInInventory@@YAHHHH@Z:PROC	; gObjGetItemCountInInventory
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?ReturnCalc@cSystemOfRage@@QAEHHHH@Z:PROC	; cSystemOfRage::ReturnCalc
EXTRN	?gSystemOfRage@@3VcSystemOfRage@@A:BYTE		; gSystemOfRage
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
EXTRN	?GetText@CZtText@@QAEPADH@Z:PROC		; CZtText::GetText
EXTRN	?g_ZtText@@3VCZtText@@A:BYTE			; g_ZtText
EXTRN	?ztMapName@@YAPADH@Z:PROC			; ztMapName
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@
; File e:\work\tranet_version\gs\gameserver\reset.cpp
CONST	SEGMENT
??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@ DB '['
	DB	'ResetSystem] Accaunt: %s , Name: %s , Reset: %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ExResetSystemFunciton@cResetSystem@@QAEXH@Z
_TEXT	SEGMENT
tv1710 = -20						; size = 4
tv1705 = -20						; size = 4
tv1700 = -20						; size = 4
tv1695 = -20						; size = 4
tv1690 = -20						; size = 4
tv1523 = -20						; size = 4
tv1514 = -20						; size = 4
tv1508 = -20						; size = 4
tv1239 = -20						; size = 4
_CreditMoney$ = -20					; size = 4
tv1544 = -16						; size = 4
_WCoinMoney$ = -16					; size = 4
tv1372 = -12						; size = 4
_ZenMoney$ = -8						; size = 4
_SearchRes$213775 = -1					; size = 1
_aIndex$ = 8						; size = 4
?ExResetSystemFunciton@cResetSystem@@QAEXH@Z PROC	; cResetSystem::ExResetSystemFunciton, COMDAT
; _this$ = ecx

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 190  : 	if(!this->EnableResetSystem)return;

  00009	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0000c	0f 84 41 0b 00
	00		 je	 $LN1@ExResetSys

; 191  : 
; 192  : 	LPOBJ lpObj = &gObj[aIndex];

  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00017	8b f7		 mov	 esi, edi
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 193  : 
; 194  : 	int ZenMoney = 0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ZenMoney$[ebp], 0

; 195  : 
; 196  : 	if ( (GetTickCount() - lpObj->MySelfDefenseTime ) < 60000)

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00032	2b 86 1c 04 00
	00		 sub	 eax, DWORD PTR [esi+1052]
  00038	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  0003d	73 31		 jae	 SHORT $LN93@ExResetSys

; 197  : 	{
; 198  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), lpObj->m_Index, 1);

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	6a 01		 push	 1
  00043	50		 push	 eax
  00044	68 6d 04 00 00	 push	 1133			; 0000046dH
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 199  : 		GCCloseMsgSend(aIndex,-1); //Season 2.5 add-on

  00059	68 ff 00 00 00	 push	 255			; 000000ffH
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00064	83 c4 14	 add	 esp, 20			; 00000014H
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
$LN93@ExResetSys:

; 200  : 		return;
; 201  : 	}
; 202  : 
; 203  : 	if(lpObj->SkillRecallParty_Time != 0)

  00070	66 83 be 74 12
	00 00 00	 cmp	 WORD PTR [esi+4724], 0
  00078	0f 85 d3 0a 00
	00		 jne	 $LN114@ExResetSys

; 204  : 	{
; 205  : 		return;
; 206  : 	}
; 207  : 
; 208  : 	if(lpObj->MapNumber != this->m_iMapForReset)

  0007e	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00085	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00088	3b c8		 cmp	 ecx, eax
  0008a	74 29		 je	 SHORT $LN91@ExResetSys

; 209  : 	{
; 210  : 		MsgNormal(aIndex, g_ZtText.GetText(3), ztMapName(this->m_iMapForReset));

  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?ztMapName@@YAPADH@Z	; ztMapName
  00092	83 c4 04	 add	 esp, 4
  00095	50		 push	 eax
  00096	6a 03		 push	 3
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0009d	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  000a2	50		 push	 eax
  000a3	57		 push	 edi
  000a4	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
$LN91@ExResetSys:

; 211  : 		return;
; 212  : 	}
; 213  : 
; 214  : 	if(gMoveCommand.CheckInterfaceToMove(lpObj) == 0)

  000b5	56		 push	 esi
  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000bb	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000c0	85 c0		 test	 eax, eax
  000c2	75 23		 jne	 SHORT $LN90@ExResetSys

; 215  : 	{
; 216  : 		GCServerMsgStringSend(g_ZtText.GetText(4),lpObj->m_Index,1);

  000c4	8b 16		 mov	 edx, DWORD PTR [esi]
  000c6	6a 01		 push	 1
  000c8	52		 push	 edx
  000c9	6a 04		 push	 4
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  000d0	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 04 00	 ret	 4
$LN90@ExResetSys:

; 217  : 		return;
; 218  : 	}
; 219  : 
; 220  : 	//Проверка на максимальное количество ресето?
; 221  : 	if(lpObj->Reset >= this->Maxres)

  000e7	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000ea	39 86 90 22 00
	00		 cmp	 DWORD PTR [esi+8848], eax
  000f0	7c 20		 jl	 SHORT $LN89@ExResetSys

; 222  : 	{
; 223  : 		MsgNormal(aIndex,g_ZtText.GetText(5),this->Maxres);

  000f2	50		 push	 eax
  000f3	6a 05		 push	 5
  000f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  000fa	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  000ff	50		 push	 eax
  00100	57		 push	 edi
  00101	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 04 00	 ret	 4
$LN89@ExResetSys:

; 224  : 		return;
; 225  : 	}
; 226  : 	
; 227  : 	//Проверка на уровен?
; 228  : 	if(g_ZtLicense.user.Rage)

  00112	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  00119	74 59		 je	 SHORT $LN88@ExResetSys

; 229  : 	{
; 230  : 		if((this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpObj->Level))

  0011b	6a 00		 push	 0
  0011d	6a 07		 push	 7
  0011f	57		 push	 edi
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00125	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  0012a	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0012d	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00134	2b c8		 sub	 ecx, eax
  00136	3b ca		 cmp	 ecx, edx
  00138	0f 8e 4a 01 00
	00		 jle	 $LN77@ExResetSys

; 231  : 		{
; 232  : 			MsgNormal(aIndex,g_ZtText.GetText(6),this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0));

  0013e	6a 00		 push	 0
  00140	6a 07		 push	 7
  00142	8b f7		 mov	 esi, edi
  00144	56		 push	 esi
  00145	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  0014a	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  0014f	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00152	2b c8		 sub	 ecx, eax
  00154	51		 push	 ecx
  00155	6a 06		 push	 6
  00157	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0015c	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00161	50		 push	 eax
  00162	56		 push	 esi
  00163	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 04 00	 ret	 4
$LN88@ExResetSys:

; 233  : 			return;
; 234  : 		}
; 235  : 	}
; 236  : 	else
; 237  : 	{
; 238  : #ifdef PRIVATE_MODULE
; 239  : 		if(g_ZtLicense.CheckUser(eZtUB::Cherkashin) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::AlterMU) || g_ZtLicense.CheckUser(eZtUB::EpicMU))

  00174	6a 12		 push	 18			; 00000012H
  00176	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0017b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00180	84 c0		 test	 al, al
  00182	75 64		 jne	 SHORT $LN84@ExResetSys
  00184	6a 1c		 push	 28			; 0000001cH
  00186	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0018b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00190	84 c0		 test	 al, al
  00192	75 54		 jne	 SHORT $LN84@ExResetSys
  00194	6a 3e		 push	 62			; 0000003eH
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0019b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001a0	84 c0		 test	 al, al
  001a2	75 44		 jne	 SHORT $LN84@ExResetSys
  001a4	6a 3b		 push	 59			; 0000003bH
  001a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001ab	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001b0	84 c0		 test	 al, al
  001b2	75 34		 jne	 SHORT $LN84@ExResetSys

; 259  : 					return;
; 260  : 				} 
; 261  : 			}
; 262  : 			
; 263  : 		 
; 264  : 		}
; 265  : 		else
; 266  : 		{
; 267  : 			if(this->NeedLevel > lpObj->Level)

  001b4	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  001bb	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  001be	3b c2		 cmp	 eax, edx
  001c0	0f 8e c2 00 00
	00		 jle	 $LN77@ExResetSys

; 268  : 			{
; 269  : 				MsgNormal(aIndex,g_ZtText.GetText(6),this->NeedLevel);

  001c6	50		 push	 eax
  001c7	6a 06		 push	 6
  001c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  001ce	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  001d3	50		 push	 eax
  001d4	8b c7		 mov	 eax, edi
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001df	5f		 pop	 edi
  001e0	5e		 pop	 esi
  001e1	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c2 04 00	 ret	 4
$LN84@ExResetSys:
  001e8	8b 8b c4 7d 00
	00		 mov	 ecx, DWORD PTR [ebx+32196]

; 240  : 		{
; 241  : 			bool SearchRes = false;
; 242  : 			for(int i=0;i<lCount;i++)

  001ee	33 ff		 xor	 edi, edi
  001f0	c6 45 ff 00	 mov	 BYTE PTR _SearchRes$213775[ebp], 0
  001f4	85 c9		 test	 ecx, ecx
  001f6	7e 35		 jle	 SHORT $LN104@ExResetSys

; 243  : 			{
; 244  : 				if(this->LevelRes[i].Res == (lpObj->Reset + 1))

  001f8	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  001fe	40		 inc	 eax
  001ff	89 45 ec	 mov	 DWORD PTR tv1239[ebp], eax
  00202	8d 83 88 5e 00
	00		 lea	 eax, DWORD PTR [ebx+24200]
$LL111@ExResetSys:
  00208	8b 55 ec	 mov	 edx, DWORD PTR tv1239[ebp]
  0020b	39 50 fc	 cmp	 DWORD PTR [eax-4], edx
  0020e	75 0f		 jne	 SHORT $LN82@ExResetSys

; 245  : 				{
; 246  : 					if(this->LevelRes[i].Level > lpObj->Level)

  00210	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00217	39 10		 cmp	 DWORD PTR [eax], edx
  00219	7f 43		 jg	 SHORT $LN99@ExResetSys

; 249  : 						return;
; 250  : 					} 
; 251  : 					SearchRes = true; 

  0021b	c6 45 ff 01	 mov	 BYTE PTR _SearchRes$213775[ebp], 1
$LN82@ExResetSys:

; 240  : 		{
; 241  : 			bool SearchRes = false;
; 242  : 			for(int i=0;i<lCount;i++)

  0021f	47		 inc	 edi
  00220	83 c0 08	 add	 eax, 8
  00223	3b f9		 cmp	 edi, ecx
  00225	7c e1		 jl	 SHORT $LL111@ExResetSys

; 252  : 				}
; 253  : 			} 
; 254  : 			if (!SearchRes)

  00227	80 7d ff 00	 cmp	 BYTE PTR _SearchRes$213775[ebp], 0
  0022b	75 5b		 jne	 SHORT $LN77@ExResetSys
$LN104@ExResetSys:

; 255  : 			{
; 256  : 				if(this->NeedLevel > lpObj->Level)

  0022d	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00234	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00237	3b c2		 cmp	 eax, edx
  00239	7e 4d		 jle	 SHORT $LN77@ExResetSys

; 257  : 				{
; 258  : 					MsgNormal(aIndex,g_ZtText.GetText(6),this->NeedLevel);

  0023b	50		 push	 eax
  0023c	6a 06		 push	 6
  0023e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  00243	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00248	50		 push	 eax
  00249	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00252	83 c4 0c	 add	 esp, 12			; 0000000cH
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 04 00	 ret	 4
$LN99@ExResetSys:

; 247  : 					{
; 248  : 						MsgNormal(aIndex,g_ZtText.GetText(6),this->LevelRes[i].Level);

  0025e	8b 84 fb 88 5e
	00 00		 mov	 eax, DWORD PTR [ebx+edi*8+24200]
  00265	50		 push	 eax
  00266	6a 06		 push	 6
  00268	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0026d	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00272	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00275	50		 push	 eax
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027f	5f		 pop	 edi
  00280	5e		 pop	 esi
  00281	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  00282	8b e5		 mov	 esp, ebp
  00284	5d		 pop	 ebp
  00285	c2 04 00	 ret	 4
$LN77@ExResetSys:

; 270  : 				return;
; 271  : 			} 
; 272  : 		}
; 273  : 
; 274  : #else
; 275  : 		if(this->NeedLevel > lpObj->Level)
; 276  : 		{
; 277  : 			MsgNormal(aIndex,g_ZtText.GetText(6),this->NeedLevel);
; 278  : 			return;
; 279  : 		}
; 280  : #endif
; 281  : 		
; 282  : 	}
; 283  : 
; 284  : 	//Проверка на зе?
; 285  : 	switch(this->ZenForm)

  00288	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0028b	48		 dec	 eax
  0028c	74 0b		 je	 SHORT $LN72@ExResetSys
  0028e	48		 dec	 eax
  0028f	75 16		 jne	 SHORT $LN73@ExResetSys

; 288  : 		case 2: ZenMoney = this->NeedZen; break;

  00291	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00294	89 4d f8	 mov	 DWORD PTR _ZenMoney$[ebp], ecx
  00297	eb 0e		 jmp	 SHORT $LN73@ExResetSys
$LN72@ExResetSys:

; 286  : 	{
; 287  : 		case 1: ZenMoney = this->NeedZen * ( lpObj->Reset + 1 ); break;

  00299	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  0029f	40		 inc	 eax
  002a0	0f af 43 0c	 imul	 eax, DWORD PTR [ebx+12]
  002a4	89 45 f8	 mov	 DWORD PTR _ZenMoney$[ebp], eax
$LN73@ExResetSys:

; 289  : 	}
; 290  : 
; 291  : #ifdef PRIVATE_MODULE
; 292  : 	int WCoinMoney = 0;

  002a7	33 ff		 xor	 edi, edi

; 293  : 	int CreditMoney = 0;
; 294  : 	if(g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(SILVER1) || g_ZtLicense.CheckUser(SILVER2) || g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  002a9	6a 1c		 push	 28			; 0000001cH
  002ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002b0	89 7d f0	 mov	 DWORD PTR _WCoinMoney$[ebp], edi
  002b3	89 7d ec	 mov	 DWORD PTR _CreditMoney$[ebp], edi
  002b6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002bb	84 c0		 test	 al, al
  002bd	75 44		 jne	 SHORT $LN105@ExResetSys
  002bf	6a 07		 push	 7
  002c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002c6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002cb	84 c0		 test	 al, al
  002cd	75 34		 jne	 SHORT $LN105@ExResetSys
  002cf	6a 08		 push	 8
  002d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002d6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002db	84 c0		 test	 al, al
  002dd	75 24		 jne	 SHORT $LN105@ExResetSys
  002df	6a 01		 push	 1
  002e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002e6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002eb	84 c0		 test	 al, al
  002ed	75 14		 jne	 SHORT $LN105@ExResetSys
  002ef	6a 12		 push	 18			; 00000012H
  002f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002f6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002fb	84 c0		 test	 al, al
  002fd	0f 84 87 00 00
	00		 je	 $LN112@ExResetSys
$LN105@ExResetSys:

; 295  : 		{
; 296  : 		WCoinMoney  = this->NeedWCoinToReset * ( lpObj->Reset + 1 );

  00303	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  00309	8b 8b b4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+180]

; 297  : 		
; 298  : #if _CONFLICT_
; 299  : 		CreditMoney  = this->NeedCreditToReset * ( lpObj->Reset + 1 );

  0030f	8b 93 b8 00 00
	00		 mov	 edx, DWORD PTR [ebx+184]
  00315	40		 inc	 eax
  00316	0f af c8	 imul	 ecx, eax
  00319	0f af d0	 imul	 edx, eax
  0031c	89 4d f0	 mov	 DWORD PTR _WCoinMoney$[ebp], ecx
  0031f	89 55 ec	 mov	 DWORD PTR _CreditMoney$[ebp], edx

; 300  : #endif
; 301  : 		if( lpObj->GameShop.WCoinC < WCoinMoney)

  00322	db 45 f0	 fild	 DWORD PTR _WCoinMoney$[ebp]
  00325	dc 9e 00 23 00
	00		 fcomp	 QWORD PTR [esi+8960]
  0032b	df e0		 fnstsw	 ax
  0032d	f6 c4 41	 test	 ah, 65			; 00000041H
  00330	75 23		 jne	 SHORT $LN68@ExResetSys

; 302  : 		{
; 303  : 				MsgNormal(aIndex,g_ZtText.GetText(7),WCoinMoney);

  00332	51		 push	 ecx
  00333	6a 07		 push	 7
  00335	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0033a	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  0033f	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00342	50		 push	 eax
  00343	52		 push	 edx
  00344	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00349	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034c	5f		 pop	 edi
  0034d	5e		 pop	 esi
  0034e	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c2 04 00	 ret	 4
$LN68@ExResetSys:

; 304  : 				return;	
; 305  : 		}
; 306  : 		
; 307  : #if _CONFLICT_
; 308  : 	
; 309  : 
; 310  : 		if( lpObj->ZtCred < CreditMoney)

  00355	d9 86 a8 22 00
	00		 fld	 DWORD PTR [esi+8872]
  0035b	db 45 ec	 fild	 DWORD PTR _CreditMoney$[ebp]
  0035e	de d9		 fcompp
  00360	df e0		 fnstsw	 ax
  00362	f6 c4 41	 test	 ah, 65			; 00000041H
  00365	75 23		 jne	 SHORT $LN112@ExResetSys

; 311  : 		{
; 312  : 			MsgNormal(aIndex, g_ZtText.GetText(8),CreditMoney);

  00367	52		 push	 edx
  00368	6a 08		 push	 8
  0036a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0036f	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00374	50		 push	 eax
  00375	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00378	50		 push	 eax
  00379	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0037e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00381	5f		 pop	 edi
  00382	5e		 pop	 esi
  00383	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c2 04 00	 ret	 4
$LN112@ExResetSys:

; 313  : 				return;	
; 314  : 		}
; 315  : #endif
; 316  : 	}
; 317  : #endif
; 318  : 	
; 319  : 	if(this->ZenForm != 0)

  0038a	39 7b 08	 cmp	 DWORD PTR [ebx+8], edi
  0038d	74 2e		 je	 SHORT $LN109@ExResetSys

; 320  : 	{
; 321  : 		if(lpObj->Money < ZenMoney)

  0038f	8b 45 f8	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  00392	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  00398	7d 23		 jge	 SHORT $LN109@ExResetSys

; 322  : 		{
; 323  : 			MsgNormal(aIndex, g_ZtText.GetText(9), ZenMoney);

  0039a	50		 push	 eax
  0039b	6a 09		 push	 9
  0039d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  003a2	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  003a7	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003aa	50		 push	 eax
  003ab	51		 push	 ecx
  003ac	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  003b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b4	5f		 pop	 edi
  003b5	5e		 pop	 esi
  003b6	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  003b7	8b e5		 mov	 esp, ebp
  003b9	5d		 pop	 ebp
  003ba	c2 04 00	 ret	 4
$LN109@ExResetSys:

; 324  : 			return;
; 325  : 		}
; 326  : 	}
; 327  : 	//Проверка на пустой инвентар?
; 328  : 	if(this->NeedEmptyInv)

  003bd	39 7b 34	 cmp	 DWORD PTR [ebx+52], edi
  003c0	0f 84 94 00 00
	00		 je	 $LN63@ExResetSys

; 329  : 	{
; 330  : 		if(lpObj->pInventory[0].m_Type != -1 || lpObj->pInventory[1].m_Type != -1 || lpObj->pInventory[2].m_Type != -1 ||
; 331  : 		   lpObj->pInventory[3].m_Type != -1 || lpObj->pInventory[4].m_Type != -1 || lpObj->pInventory[5].m_Type != -1 ||
; 332  : 		   lpObj->pInventory[6].m_Type != -1 || lpObj->pInventory[7].m_Type != -1 || lpObj->pInventory[8].m_Type != -1 ||
; 333  : 		   lpObj->pInventory[9].m_Type != -1 || lpObj->pInventory[10].m_Type != -1|| lpObj->pInventory[11].m_Type != -1)

  003c6	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  003cc	83 c9 ff	 or	 ecx, -1
  003cf	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  003d3	75 63		 jne	 SHORT $LN62@ExResetSys
  003d5	66 39 88 da 00
	00 00		 cmp	 WORD PTR [eax+218], cx
  003dc	75 5a		 jne	 SHORT $LN62@ExResetSys
  003de	66 39 88 ae 01
	00 00		 cmp	 WORD PTR [eax+430], cx
  003e5	75 51		 jne	 SHORT $LN62@ExResetSys
  003e7	66 39 88 82 02
	00 00		 cmp	 WORD PTR [eax+642], cx
  003ee	75 48		 jne	 SHORT $LN62@ExResetSys
  003f0	66 39 88 56 03
	00 00		 cmp	 WORD PTR [eax+854], cx
  003f7	75 3f		 jne	 SHORT $LN62@ExResetSys
  003f9	66 39 88 2a 04
	00 00		 cmp	 WORD PTR [eax+1066], cx
  00400	75 36		 jne	 SHORT $LN62@ExResetSys
  00402	66 39 88 fe 04
	00 00		 cmp	 WORD PTR [eax+1278], cx
  00409	75 2d		 jne	 SHORT $LN62@ExResetSys
  0040b	66 39 88 d2 05
	00 00		 cmp	 WORD PTR [eax+1490], cx
  00412	75 24		 jne	 SHORT $LN62@ExResetSys
  00414	66 39 88 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], cx
  0041b	75 1b		 jne	 SHORT $LN62@ExResetSys
  0041d	66 39 88 7a 07
	00 00		 cmp	 WORD PTR [eax+1914], cx
  00424	75 12		 jne	 SHORT $LN62@ExResetSys
  00426	66 39 88 4e 08
	00 00		 cmp	 WORD PTR [eax+2126], cx
  0042d	75 09		 jne	 SHORT $LN62@ExResetSys
  0042f	66 39 88 22 09
	00 00		 cmp	 WORD PTR [eax+2338], cx
  00436	74 22		 je	 SHORT $LN63@ExResetSys
$LN62@ExResetSys:

; 334  : 		{
; 335  : 			MsgNormal(aIndex, g_ZtText.GetText(10));

  00438	6a 0a		 push	 10			; 0000000aH
  0043a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0043f	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00444	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00447	50		 push	 eax
  00448	52		 push	 edx
  00449	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0044e	83 c4 08	 add	 esp, 8
  00451	5f		 pop	 edi
  00452	5e		 pop	 esi
  00453	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	c2 04 00	 ret	 4
$LN63@ExResetSys:

; 336  : 			return;
; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : #ifdef PRIVATE_MODULE
; 341  : 	if(g_ZtLicense.CheckUser(eZtUB::Vadim) || g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  0045a	6a 09		 push	 9
  0045c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00461	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00466	84 c0		 test	 al, al
  00468	75 34		 jne	 SHORT $LN60@ExResetSys
  0046a	6a 01		 push	 1
  0046c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00471	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00476	84 c0		 test	 al, al
  00478	75 24		 jne	 SHORT $LN60@ExResetSys
  0047a	6a 1c		 push	 28			; 0000001cH
  0047c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00481	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00486	84 c0		 test	 al, al
  00488	75 14		 jne	 SHORT $LN60@ExResetSys
  0048a	6a 12		 push	 18			; 00000012H
  0048c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00491	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00496	84 c0		 test	 al, al
  00498	0f 84 b5 00 00
	00		 je	 $LN57@ExResetSys
$LN60@ExResetSys:
  0049e	8b 93 80 5e 00
	00		 mov	 edx, DWORD PTR [ebx+24192]

; 342  : 	{
; 343  : 		for(int i=0;i<iCount;i++)

  004a4	33 c0		 xor	 eax, eax
  004a6	3b d7		 cmp	 edx, edi
  004a8	0f 8e a5 00 00
	00		 jle	 $LN57@ExResetSys
  004ae	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  004b4	47		 inc	 edi
  004b5	8d 8b 00 20 00
	00		 lea	 ecx, DWORD PTR [ebx+8192]
  004bb	eb 03 8d 49 00	 npad	 5
$LL59@ExResetSys:

; 344  : 		{
; 345  : 			if(this->ItemsRes[i].Res == (lpObj->Reset + 1))

  004c0	39 39		 cmp	 DWORD PTR [ecx], edi
  004c2	74 0d		 je	 SHORT $LN100@ExResetSys

; 342  : 	{
; 343  : 		for(int i=0;i<iCount;i++)

  004c4	40		 inc	 eax
  004c5	83 c1 10	 add	 ecx, 16			; 00000010H
  004c8	3b c2		 cmp	 eax, edx
  004ca	7c f4		 jl	 SHORT $LL59@ExResetSys

; 344  : 		{
; 345  : 			if(this->ItemsRes[i].Res == (lpObj->Reset + 1))

  004cc	e9 82 00 00 00	 jmp	 $LN57@ExResetSys
$LN100@ExResetSys:

; 346  : 			{
; 347  : 				if(gObjGetItemCountInInventory(aIndex,ITEMGET(this->ItemsRes[i].ItemType,this->ItemsRes[i].ItemIndex),0) < this->ItemsRes[i].ItemCount)

  004d1	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004d4	03 c0		 add	 eax, eax
  004d6	8b 8c c3 04 20
	00 00		 mov	 ecx, DWORD PTR [ebx+eax*8+8196]
  004dd	8d 3c c3	 lea	 edi, DWORD PTR [ebx+eax*8]
  004e0	8b 87 0c 20 00
	00		 mov	 eax, DWORD PTR [edi+8204]
  004e6	c1 e1 09	 shl	 ecx, 9
  004e9	03 8f 08 20 00
	00		 add	 ecx, DWORD PTR [edi+8200]
  004ef	6a 00		 push	 0
  004f1	51		 push	 ecx
  004f2	52		 push	 edx
  004f3	89 45 f4	 mov	 DWORD PTR tv1372[ebp], eax
  004f6	e8 00 00 00 00	 call	 ?gObjGetItemCountInInventory@@YAHHHH@Z ; gObjGetItemCountInInventory
  004fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fe	3b 45 f4	 cmp	 eax, DWORD PTR tv1372[ebp]
  00501	7d 26		 jge	 SHORT $LN55@ExResetSys

; 348  : 				{
; 349  : 					MsgNormal(aIndex, g_ZtText.GetText(11),this->ItemsRes[i].ItemCount);

  00503	8b 45 f4	 mov	 eax, DWORD PTR tv1372[ebp]
  00506	50		 push	 eax
  00507	6a 0b		 push	 11			; 0000000bH
  00509	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0050e	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00513	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00516	50		 push	 eax
  00517	51		 push	 ecx
  00518	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0051d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00520	5f		 pop	 edi
  00521	5e		 pop	 esi
  00522	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  00523	8b e5		 mov	 esp, ebp
  00525	5d		 pop	 ebp
  00526	c2 04 00	 ret	 4
$LN55@ExResetSys:

; 350  : 					return;
; 351  : 				}
; 352  : 				gObjDeleteItemsCount(aIndex,ITEMGET(this->ItemsRes[i].ItemType,this->ItemsRes[i].ItemIndex),0,this->ItemsRes[i].ItemCount);

  00529	8b 55 f4	 mov	 edx, DWORD PTR tv1372[ebp]
  0052c	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00531	66 0f af 87 04
	20 00 00	 imul	 ax, WORD PTR [edi+8196]
  00539	66 03 87 08 20
	00 00		 add	 ax, WORD PTR [edi+8200]
  00540	52		 push	 edx
  00541	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00544	0f b7 c8	 movzx	 ecx, ax
  00547	6a 00		 push	 0
  00549	51		 push	 ecx
  0054a	52		 push	 edx
  0054b	e8 00 00 00 00	 call	 ?gObjDeleteItemsCount@@YAHHFFH@Z ; gObjDeleteItemsCount
  00550	83 c4 10	 add	 esp, 16			; 00000010H
$LN57@ExResetSys:

; 353  : 				break;
; 354  : 			}
; 355  : 		}
; 356  : 	}
; 357  : #endif
; 358  : 
; 359  : 	/////////////////////
; 360  : 	//Выполнение ресета//
; 361  : 	/////////////////////
; 362  : 	lpObj->Money -= ZenMoney;

  00553	8b 45 f8	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  00556	29 86 f0 00 00
	00		 sub	 DWORD PTR [esi+240], eax

; 363  : #ifdef PRIVATE_MODULE
; 364  : if(g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(SILVER1) || g_ZtLicense.CheckUser(SILVER2) || g_ZtLicense.CheckUser(eZtUB::drynea)|| g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  0055c	6a 1c		 push	 28			; 0000001cH
  0055e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00563	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00568	84 c0		 test	 al, al
  0056a	75 40		 jne	 SHORT $LN113@ExResetSys
  0056c	6a 07		 push	 7
  0056e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00573	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00578	84 c0		 test	 al, al
  0057a	75 30		 jne	 SHORT $LN113@ExResetSys
  0057c	6a 08		 push	 8
  0057e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00583	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00588	84 c0		 test	 al, al
  0058a	75 20		 jne	 SHORT $LN113@ExResetSys
  0058c	6a 01		 push	 1
  0058e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00593	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00598	84 c0		 test	 al, al
  0059a	75 10		 jne	 SHORT $LN113@ExResetSys
  0059c	6a 12		 push	 18			; 00000012H
  0059e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005a3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005a8	84 c0		 test	 al, al
  005aa	74 36		 je	 SHORT $LN54@ExResetSys
$LN113@ExResetSys:

; 365  : 			{
; 366  : 		lpObj->GameShop.WCoinC -= WCoinMoney;

  005ac	db 45 f0	 fild	 DWORD PTR _WCoinMoney$[ebp]

; 367  : 		gGameShop.GDSaveUserInfo(lpObj->m_Index);

  005af	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005b1	51		 push	 ecx
  005b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  005b7	dc ae 00 23 00
	00		 fsubr	 QWORD PTR [esi+8960]
  005bd	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
  005c3	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 368  : #if _CONFLICT_
; 369  : 		lpObj->ZtCred -= CreditMoney;

  005c8	d9 86 a8 22 00
	00		 fld	 DWORD PTR [esi+8872]

; 370  : 		ZtUserDataSend(lpObj->m_Index);

  005ce	8b 16		 mov	 edx, DWORD PTR [esi]
  005d0	da 65 ec	 fisub	 DWORD PTR _CreditMoney$[ebp]
  005d3	52		 push	 edx
  005d4	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
  005da	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  005df	83 c4 04	 add	 esp, 4
$LN54@ExResetSys:

; 371  : #endif
; 372  : 	}
; 373  : #endif
; 374  : 
; 375  : 	lpObj->Level = 1;

  005e2	b8 01 00 00 00	 mov	 eax, 1
  005e7	66 89 86 be 00
	00 00		 mov	 WORD PTR [esi+190], ax

; 376  : 	lpObj->Experience = 0;

  005ee	c7 86 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+200], 0

; 377  : 	lpObj->NextExp = 100;

  005f8	c7 86 cc 00 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+204], 100 ; 00000064H

; 378  : 	if(this->AddForm == 2)

  00602	83 7b 14 02	 cmp	 DWORD PTR [ebx+20], 2
  00606	75 5a		 jne	 SHORT $LN50@ExResetSys

; 379  : 	{
; 380  : 		lpObj->Strength = 25;
; 381  : 		lpObj->Dexterity = 25;
; 382  : 		lpObj->Vitality = 25;
; 383  : 		lpObj->Energy = 25;
; 384  : 		if(g_ZtLicense.CheckUser(eZtUB::DavitRazmadze) || g_ZtLicense.CheckUser(eZtUB::DavitRazmadze2) || g_ZtLicense.CheckUser(eZtUB::DavitRazmadze3))

  00608	6a 0a		 push	 10			; 0000000aH
  0060a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0060f	c7 86 f4 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+244], 1638425 ; 00190019H
  00619	c7 86 f8 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+248], 1638425 ; 00190019H
  00623	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00628	84 c0		 test	 al, al
  0062a	75 36		 jne	 SHORT $LN50@ExResetSys
  0062c	6a 19		 push	 25			; 00000019H
  0062e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00633	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00638	84 c0		 test	 al, al
  0063a	75 26		 jne	 SHORT $LN50@ExResetSys
  0063c	6a 1d		 push	 29			; 0000001dH
  0063e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00643	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00648	84 c0		 test	 al, al
  0064a	75 16		 jne	 SHORT $LN50@ExResetSys

; 385  : 		{
; 386  : 		}
; 387  : 		else
; 388  : 		{
; 389  : 			if(lpObj->Class == 4)

  0064c	66 83 be b8 00
	00 00 04	 cmp	 WORD PTR [esi+184], 4
  00654	75 0c		 jne	 SHORT $LN50@ExResetSys

; 390  : 				lpObj->Leadership = 25;

  00656	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
  0065b	66 89 96 18 01
	00 00		 mov	 WORD PTR [esi+280], dx
$LN50@ExResetSys:

; 391  : 		}
; 392  : 	}
; 393  : 	//Поинта за ресе?
; 394  : 	if(this->AddForm == 1 || this->AddForm == 2)

  00662	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00665	83 f8 01	 cmp	 eax, 1
  00668	74 09		 je	 SHORT $LN46@ExResetSys
  0066a	83 f8 02	 cmp	 eax, 2
  0066d	0f 85 8a 00 00
	00		 jne	 $LN44@ExResetSys
$LN46@ExResetSys:

; 395  : 	{
; 396  : 		switch (lpObj->Class)

  00673	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  0067a	83 f8 06	 cmp	 eax, 6
  0067d	77 7e		 ja	 SHORT $LN44@ExResetSys
  0067f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN119@ExResetSys[eax*4]
$LN43@ExResetSys:

; 397  : 		{
; 398  : 			case 0: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsDW ;  break;

  00686	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  0068c	40		 inc	 eax
  0068d	0f af 43 18	 imul	 eax, DWORD PTR [ebx+24]
  00691	eb 64		 jmp	 SHORT $LN116@ExResetSys
$LN42@ExResetSys:

; 399  : 			case 1: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsDK ;  break;

  00693	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  00699	41		 inc	 ecx
  0069a	0f af 4b 1c	 imul	 ecx, DWORD PTR [ebx+28]
  0069e	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx
  006a4	eb 57		 jmp	 SHORT $LN44@ExResetSys
$LN41@ExResetSys:

; 400  : 			case 2: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsELF ; break;

  006a6	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  006ac	42		 inc	 edx
  006ad	0f af 53 20	 imul	 edx, DWORD PTR [ebx+32]
  006b1	89 96 c0 00 00
	00		 mov	 DWORD PTR [esi+192], edx
  006b7	eb 44		 jmp	 SHORT $LN44@ExResetSys
$LN40@ExResetSys:

; 401  : 			case 3: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsMG ;  break;

  006b9	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  006bf	40		 inc	 eax
  006c0	0f af 43 28	 imul	 eax, DWORD PTR [ebx+40]
  006c4	eb 31		 jmp	 SHORT $LN116@ExResetSys
$LN39@ExResetSys:

; 402  : 			case 4: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsDL ;  break;

  006c6	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  006cc	41		 inc	 ecx
  006cd	0f af 4b 2c	 imul	 ecx, DWORD PTR [ebx+44]
  006d1	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx
  006d7	eb 24		 jmp	 SHORT $LN44@ExResetSys
$LN38@ExResetSys:

; 403  : 			case 5: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsSUM ; break;

  006d9	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  006df	42		 inc	 edx
  006e0	0f af 53 24	 imul	 edx, DWORD PTR [ebx+36]
  006e4	89 96 c0 00 00
	00		 mov	 DWORD PTR [esi+192], edx
  006ea	eb 11		 jmp	 SHORT $LN44@ExResetSys
$LN37@ExResetSys:

; 404  : 			case 6: lpObj->LevelUpPoint = ( lpObj->Reset + 1 ) * this->AddPointsRF ; break;

  006ec	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  006f2	40		 inc	 eax
  006f3	0f af 43 30	 imul	 eax, DWORD PTR [ebx+48]
$LN116@ExResetSys:
  006f7	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
$LN44@ExResetSys:

; 405  : 		}
; 406  : 	}
; 407  : 	//Поинта от гран?ресета
; 408  : 	if(gGrandReset.EnableGrandResetSystem)

  006fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A, 0
  00704	0f 84 6f 01 00
	00		 je	 $LN20@ExResetSys

; 409  : 	{
; 410  : 		if(lpObj->GReset > 0)

  0070a	8b 86 94 22 00
	00		 mov	 eax, DWORD PTR [esi+8852]
  00710	85 c0		 test	 eax, eax
  00712	0f 8e 61 01 00
	00		 jle	 $LN20@ExResetSys

; 411  : 		{
; 412  : 			if(gGrandReset.AddForm == 1)

  00718	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24
  0071e	83 f9 01	 cmp	 ecx, 1
  00721	75 19		 jne	 SHORT $LN103@ExResetSys

; 413  : 			{
; 414  : 				lpObj->LevelUpPoint += lpObj->LevelUpPoint;;;;

  00723	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  00729	03 c9		 add	 ecx, ecx
  0072b	89 8e c0 00 00
	00		 mov	 DWORD PTR [esi+192], ecx

; 415  : 			}
; 416  : 
; 417  : 			if(gGrandReset.AddForm == 1 || gGrandReset.AddForm == 2)

  00731	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24
  00737	83 f9 01	 cmp	 ecx, 1
  0073a	74 05		 je	 SHORT $LN32@ExResetSys
$LN103@ExResetSys:
  0073c	83 f9 02	 cmp	 ecx, 2
  0073f	75 76		 jne	 SHORT $LN30@ExResetSys
$LN32@ExResetSys:

; 418  : 			{
; 419  : 				switch (lpObj->Class)

  00741	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  00748	83 f9 06	 cmp	 ecx, 6
  0074b	77 6a		 ja	 SHORT $LN30@ExResetSys
  0074d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN120@ExResetSys[ecx*4]
$LN29@ExResetSys:

; 420  : 				{
; 421  : 					case 0: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDW ;  break;

  00754	8b d0		 mov	 edx, eax
  00756	0f af 15 1c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  0075d	eb 52		 jmp	 SHORT $LN117@ExResetSys
$LN28@ExResetSys:

; 422  : 					case 1: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDK ;  break;

  0075f	8b c8		 mov	 ecx, eax
  00761	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  00768	01 8e c0 00 00
	00		 add	 DWORD PTR [esi+192], ecx
  0076e	eb 47		 jmp	 SHORT $LN30@ExResetSys
$LN27@ExResetSys:

; 423  : 					case 2: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsELF ; break;

  00770	8b d0		 mov	 edx, eax
  00772	0f af 15 24 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  00779	eb 36		 jmp	 SHORT $LN117@ExResetSys
$LN26@ExResetSys:

; 424  : 					case 3: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsMG ;  break;

  0077b	8b c8		 mov	 ecx, eax
  0077d	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  00784	01 8e c0 00 00
	00		 add	 DWORD PTR [esi+192], ecx
  0078a	eb 2b		 jmp	 SHORT $LN30@ExResetSys
$LN25@ExResetSys:

; 425  : 					case 4: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDL ;  break;

  0078c	8b d0		 mov	 edx, eax
  0078e	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  00795	eb 1a		 jmp	 SHORT $LN117@ExResetSys
$LN24@ExResetSys:

; 426  : 					case 5: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsSUM ; break;

  00797	8b c8		 mov	 ecx, eax
  00799	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  007a0	01 8e c0 00 00
	00		 add	 DWORD PTR [esi+192], ecx
  007a6	eb 0f		 jmp	 SHORT $LN30@ExResetSys
$LN23@ExResetSys:

; 427  : 					case 6: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsRF ; break;

  007a8	8b d0		 mov	 edx, eax
  007aa	0f af 15 34 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
$LN117@ExResetSys:
  007b1	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx
$LN30@ExResetSys:

; 428  : 				}
; 429  : 			}
; 430  : 			if(gGrandReset.AddForm == 3)

  007b7	83 3d 18 00 00
	00 03		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 3
  007be	0f 85 b5 00 00
	00		 jne	 $LN20@ExResetSys

; 431  : 			{
; 432  : 				switch (lpObj->Class)

  007c4	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  007cb	83 f9 06	 cmp	 ecx, 6
  007ce	0f 87 a5 00 00
	00		 ja	 $LN20@ExResetSys
  007d4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN121@ExResetSys[ecx*4]
$LN19@ExResetSys:

; 433  : 				{
; 434  : 					case 0: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDW  * ( lpObj->Reset+1 ); break;

  007db	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  007e1	41		 inc	 ecx
  007e2	0f af c8	 imul	 ecx, eax
  007e5	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  007ec	e9 82 00 00 00	 jmp	 $LN118@ExResetSys
$LN18@ExResetSys:

; 435  : 					case 1: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDK  * ( lpObj->Reset+1 ); break;

  007f1	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  007f7	42		 inc	 edx
  007f8	0f af d0	 imul	 edx, eax
  007fb	0f af 15 20 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  00802	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx
  00808	eb 6f		 jmp	 SHORT $LN20@ExResetSys
$LN17@ExResetSys:

; 436  : 					case 2: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsELF * ( lpObj->Reset+1 ); break;

  0080a	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  00810	41		 inc	 ecx
  00811	0f af c8	 imul	 ecx, eax
  00814	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  0081b	eb 56		 jmp	 SHORT $LN118@ExResetSys
$LN16@ExResetSys:

; 437  : 					case 3: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsMG  * ( lpObj->Reset+1 ); break;

  0081d	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00823	42		 inc	 edx
  00824	0f af d0	 imul	 edx, eax
  00827	0f af 15 2c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  0082e	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx
  00834	eb 43		 jmp	 SHORT $LN20@ExResetSys
$LN15@ExResetSys:

; 438  : 					case 4: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsDL  * ( lpObj->Reset+1 ); break;

  00836	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  0083c	41		 inc	 ecx
  0083d	0f af c8	 imul	 ecx, eax
  00840	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  00847	eb 2a		 jmp	 SHORT $LN118@ExResetSys
$LN14@ExResetSys:

; 439  : 					case 5: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsSUM * ( lpObj->Reset+1 ); break;

  00849	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0084f	42		 inc	 edx
  00850	0f af d0	 imul	 edx, eax
  00853	0f af 15 28 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  0085a	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx
  00860	eb 17		 jmp	 SHORT $LN20@ExResetSys
$LN13@ExResetSys:

; 440  : 					case 6: lpObj->LevelUpPoint += lpObj->GReset * gGrandReset.AddPointsRF * ( lpObj->Reset+1 ); break;

  00862	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  00868	41		 inc	 ecx
  00869	0f af c8	 imul	 ecx, eax
  0086c	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
$LN118@ExResetSys:
  00873	01 8e c0 00 00
	00		 add	 DWORD PTR [esi+192], ecx
$LN20@ExResetSys:

; 441  : 				}
; 442  : 			}
; 443  : 		}
; 444  : 	}
; 445  : 
; 446  : 	lpObj->LevelUpPoint += lpObj->ZtFreePoints;

  00879	8b 96 8c 22 00
	00		 mov	 edx, DWORD PTR [esi+8844]
  0087f	01 96 c0 00 00
	00		 add	 DWORD PTR [esi+192], edx

; 447  : 	
; 448  : 	lpObj->Reset += 1;

  00885	ff 86 90 22 00
	00		 inc	 DWORD PTR [esi+8848]

; 449  : 
; 450  : 	if(this->AddCredits > 0)

  0088b	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  0088f	7e 2a		 jle	 SHORT $LN10@ExResetSys

; 451  : 	{
; 452  : 		if(g_ZtLicense.CheckUser(eZtUB::NSGames))

  00891	6a 51		 push	 81			; 00000051H
  00893	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00898	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0089d	84 c0		 test	 al, al
  0089f	74 0b		 je	 SHORT $LN11@ExResetSys

; 453  : 		{
; 454  : 			lpObj->PCPoint += this->AddCredits;	

  008a1	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  008a4	01 86 88 22 00
	00		 add	 DWORD PTR [esi+8840], eax

; 455  : 		}
; 456  : 		else

  008aa	eb 0f		 jmp	 SHORT $LN10@ExResetSys
$LN11@ExResetSys:

; 457  : 		{
; 458  : 			lpObj->ZtCred += this->AddCredits;		

  008ac	db 43 38	 fild	 DWORD PTR [ebx+56]
  008af	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  008b5	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
$LN10@ExResetSys:

; 459  : 		}
; 460  : 	}
; 461  : 	if(this->AddWcoinC > 0)

  008bb	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  008be	89 45 ec	 mov	 DWORD PTR tv1508[ebp], eax
  008c1	85 c0		 test	 eax, eax
  008c3	7e 0f		 jle	 SHORT $LN9@ExResetSys

; 462  : 	{
; 463  : 		lpObj->GameShop.WCoinC += this->AddWcoinC;

  008c5	db 45 ec	 fild	 DWORD PTR tv1508[ebp]
  008c8	dc 86 00 23 00
	00		 fadd	 QWORD PTR [esi+8960]
  008ce	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
$LN9@ExResetSys:

; 464  : 	}
; 465  : 	if(this->AddWcoinP > 0)

  008d4	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  008d7	89 45 ec	 mov	 DWORD PTR tv1514[ebp], eax
  008da	85 c0		 test	 eax, eax
  008dc	7e 0f		 jle	 SHORT $LN8@ExResetSys

; 466  : 	{
; 467  : 		lpObj->GameShop.WCoinP += this->AddWcoinP;

  008de	db 45 ec	 fild	 DWORD PTR tv1514[ebp]
  008e1	dc 86 f8 22 00
	00		 fadd	 QWORD PTR [esi+8952]
  008e7	dd 9e f8 22 00
	00		 fstp	 QWORD PTR [esi+8952]
$LN8@ExResetSys:

; 468  : 	}
; 469  : 	if(this->AddGoblinPoint > 0)

  008ed	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  008f0	89 45 ec	 mov	 DWORD PTR tv1523[ebp], eax
  008f3	85 c0		 test	 eax, eax
  008f5	7e 0f		 jle	 SHORT $LN7@ExResetSys

; 470  : 	{
; 471  : 		lpObj->GameShop.GoblinPoint += this->AddGoblinPoint;

  008f7	db 45 ec	 fild	 DWORD PTR tv1523[ebp]
  008fa	dc 86 08 23 00
	00		 fadd	 QWORD PTR [esi+8968]
  00900	dd 9e 08 23 00
	00		 fstp	 QWORD PTR [esi+8968]
$LN7@ExResetSys:

; 472  : 	}
; 473  : 
; 474  : 	if(this->AddWcoinC > 0 || this->AddWcoinP > 0 || this->AddGoblinPoint > 0)

  00906	83 7b 3c 00	 cmp	 DWORD PTR [ebx+60], 0
  0090a	7f 0c		 jg	 SHORT $LN5@ExResetSys
  0090c	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  00910	7f 06		 jg	 SHORT $LN5@ExResetSys
  00912	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0
  00916	7e 0e		 jle	 SHORT $LN6@ExResetSys
$LN5@ExResetSys:

; 475  : 	{
; 476  : 		gGameShop.GDSaveUserInfo(aIndex);

  00918	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0091b	51		 push	 ecx
  0091c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00921	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN6@ExResetSys:

; 477  : 	}	
; 478  : 
; 479  : 	ZtFireCracker(aIndex, lpObj->X, lpObj->Y);

  00926	0f b6 96 46 01
	00 00		 movzx	 edx, BYTE PTR [esi+326]
  0092d	0f b6 86 44 01
	00 00		 movzx	 eax, BYTE PTR [esi+324]
  00934	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00937	52		 push	 edx
  00938	50		 push	 eax
  00939	51		 push	 ecx
  0093a	e8 00 00 00 00	 call	 ?ZtFireCracker@@YAXHEE@Z ; ZtFireCracker

; 480  : 
; 481  : 	lpObj->Life = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  0093f	0f bf 96 d0 00
	00 00		 movsx	 edx, WORD PTR [esi+208]
  00946	0f bf 86 be 00
	00 00		 movsx	 eax, WORD PTR [esi+190]
  0094d	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00951	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00958	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  0095e	0f b7 90 0c 00
	00 00		 movzx	 edx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  00965	89 4d ec	 mov	 DWORD PTR tv1710[ebp], ecx
  00968	0f b7 8e f8 00
	00 00		 movzx	 ecx, WORD PTR [esi+248]
  0096f	db 45 ec	 fild	 DWORD PTR tv1710[ebp]
  00972	8b f9		 mov	 edi, ecx
  00974	2b fa		 sub	 edi, edx
  00976	d9 5d f0	 fstp	 DWORD PTR tv1544[ebp]

; 482  : 	lpObj->Mana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  00979	0f b7 96 fa 00
	00 00		 movzx	 edx, WORD PTR [esi+250]
  00980	89 7d ec	 mov	 DWORD PTR tv1705[ebp], edi
  00983	8b da		 mov	 ebx, edx
  00985	db 45 ec	 fild	 DWORD PTR tv1705[ebp]
  00988	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  0098e	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00994	d9 45 f0	 fld	 DWORD PTR tv1544[ebp]
  00997	d9 c0		 fld	 ST(0)
  00999	de ca		 fmulp	 ST(2), ST(0)
  0099b	d9 80 14 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  009a1	de c2		 faddp	 ST(2), ST(0)
  009a3	d9 ca		 fxch	 ST(2)
  009a5	de c1		 faddp	 ST(1), ST(0)
  009a7	d9 9e fc 00 00
	00		 fstp	 DWORD PTR [esi+252]
  009ad	0f b7 b8 0e 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  009b4	2b df		 sub	 ebx, edi
  009b6	89 5d ec	 mov	 DWORD PTR tv1700[ebp], ebx
  009b9	db 45 ec	 fild	 DWORD PTR tv1700[ebp]
  009bc	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  009c2	d9 c1		 fld	 ST(1)
  009c4	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  009ca	d8 80 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  009d0	de c1		 faddp	 ST(1), ST(0)
  009d2	d9 9e 10 01 00
	00		 fstp	 DWORD PTR [esi+272]

; 483  : 
; 484  : 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  009d8	0f b7 b8 0c 00
	00 00		 movzx	 edi, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  009df	2b cf		 sub	 ecx, edi
  009e1	89 4d ec	 mov	 DWORD PTR tv1695[ebp], ecx

; 485  : 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level + lpObj->MLevel - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);
; 486  : 
; 487  : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;
; 488  : 	lpObj->EnergyToMana = DCInfo.DefClass[lpObj->Class].EnergyToMana;
; 489  : 
; 490  : 	::gObjSetBP(aIndex);

  009e4	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  009e7	57		 push	 edi
  009e8	db 45 ec	 fild	 DWORD PTR tv1695[ebp]
  009eb	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  009f1	d9 80 10 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  009f7	d8 ca		 fmul	 ST(0), ST(2)
  009f9	d8 80 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  009ff	de c1		 faddp	 ST(1), ST(0)
  00a01	d9 9e 00 01 00
	00		 fstp	 DWORD PTR [esi+256]
  00a07	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  00a0e	2b d1		 sub	 edx, ecx
  00a10	89 55 ec	 mov	 DWORD PTR tv1690[ebp], edx
  00a13	db 45 ec	 fild	 DWORD PTR tv1690[ebp]
  00a16	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00a1c	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00a22	de ca		 fmulp	 ST(2), ST(0)
  00a24	d9 80 20 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  00a2a	de c2		 faddp	 ST(2), ST(0)
  00a2c	de c1		 faddp	 ST(1), ST(0)
  00a2e	d9 9e 14 01 00
	00		 fstp	 DWORD PTR [esi+276]
  00a34	d9 80 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  00a3a	d9 9e 34 01 00
	00		 fstp	 DWORD PTR [esi+308]
  00a40	d9 80 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00a46	d9 9e 38 01 00
	00		 fstp	 DWORD PTR [esi+312]
  00a4c	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 491  : 	lpObj->BP = lpObj->MaxBP / 2;

  00a51	8b 86 2c 01 00
	00		 mov	 eax, DWORD PTR [esi+300]
  00a57	99		 cdq
  00a58	2b c2		 sub	 eax, edx
  00a5a	d1 f8		 sar	 eax, 1

; 492  : 	::gObjCalcMaxLifePower(aIndex);

  00a5c	57		 push	 edi
  00a5d	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax
  00a63	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 493  : 
; 494  : 	GCReFillSend(aIndex, (int)lpObj->MaxLife + lpObj->AddLife, 0xFE, 0, lpObj->iMaxShield + lpObj->iAddShield);

  00a68	8b 96 5c 01 00
	00		 mov	 edx, DWORD PTR [esi+348]
  00a6e	83 c4 14	 add	 esp, 20			; 00000014H
  00a71	03 96 58 01 00
	00		 add	 edx, DWORD PTR [esi+344]
  00a77	d9 86 00 01 00
	00		 fld	 DWORD PTR [esi+256]
  00a7d	52		 push	 edx
  00a7e	6a 00		 push	 0
  00a80	68 fe 00 00 00	 push	 254			; 000000feH
  00a85	e8 00 00 00 00	 call	 __ftol2_sse
  00a8a	03 86 4c 01 00
	00		 add	 eax, DWORD PTR [esi+332]
  00a90	50		 push	 eax
  00a91	57		 push	 edi
  00a92	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 495  : 	//gObjSetBP(aIndex);
; 496  : 	GCManaSend(aIndex,(int)lpObj->MaxMana + lpObj->AddMana, 0xFE, 0, lpObj->MaxBP + lpObj->AddBP);

  00a97	d9 86 14 01 00
	00		 fld	 DWORD PTR [esi+276]
  00a9d	8b 86 30 01 00
	00		 mov	 eax, DWORD PTR [esi+304]
  00aa3	03 86 2c 01 00
	00		 add	 eax, DWORD PTR [esi+300]
  00aa9	83 c4 14	 add	 esp, 20			; 00000014H
  00aac	50		 push	 eax
  00aad	6a 00		 push	 0
  00aaf	68 fe 00 00 00	 push	 254			; 000000feH
  00ab4	e8 00 00 00 00	 call	 __ftol2_sse
  00ab9	03 86 50 01 00
	00		 add	 eax, DWORD PTR [esi+336]
  00abf	50		 push	 eax
  00ac0	57		 push	 edi
  00ac1	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 497  : 	gObjCalCharacter(aIndex);

  00ac6	57		 push	 edi
  00ac7	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 498  : 
; 499  : 	//gObjCloseSet(aIndex, 1);
; 500  : 	ResetSystemGC_CharUpdate(lpObj);

  00acc	56		 push	 esi
  00acd	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate

; 501  : 
; 502  : 	GCMoneySend(aIndex, lpObj->Money);

  00ad2	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  00ad8	51		 push	 ecx
  00ad9	57		 push	 edi
  00ada	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00adf	83 c4 24	 add	 esp, 36			; 00000024H

; 503  : 
; 504  : #if(CUSTOM_NOOBBUFF)
; 505  : 	if(ZtConfig.CommonServer.bNoobBuffEnable)

  00ae2	80 3d 20 01 00
	00 00		 cmp	 BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+288, 0
  00ae9	74 2e		 je	 SHORT $LN2@ExResetSys

; 506  : 	{
; 507  : 		if(ZtConfig.CommonServer.iNoobBuffMaxReset > lpObj->Reset)

  00aeb	8b 15 24 01 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+292
  00af1	3b 96 90 22 00
	00		 cmp	 edx, DWORD PTR [esi+8848]
  00af7	7e 20		 jle	 SHORT $LN2@ExResetSys

; 508  : 		{
; 509  : 			if(gObjSearchActiveEffect(lpObj,AT_NOOB_BUFF) == TRUE)

  00af9	68 b6 00 00 00	 push	 182			; 000000b6H
  00afe	56		 push	 esi
  00aff	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00b04	83 c4 08	 add	 esp, 8
  00b07	3c 01		 cmp	 al, 1
  00b09	75 0e		 jne	 SHORT $LN2@ExResetSys

; 510  : 			{
; 511  : 				gObjRemoveBuffEffect(lpObj,AT_NOOB_BUFF);

  00b0b	68 b6 00 00 00	 push	 182			; 000000b6H
  00b10	56		 push	 esi
  00b11	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00b16	83 c4 08	 add	 esp, 8
$LN2@ExResetSys:

; 512  : 			}
; 513  : 		}
; 514  : 	}
; 515  : #endif
; 516  : 
; 517  : 	LogAddTD("[ResetSystem] Accaunt: %s , Name: %s , Reset: %d",lpObj->AccountID, lpObj->Name,lpObj->Reset);

  00b19	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  00b1f	50		 push	 eax
  00b20	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00b23	51		 push	 ecx
  00b24	83 c6 6c	 add	 esi, 108		; 0000006cH
  00b27	56		 push	 esi
  00b28	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@
  00b2d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b33	83 c4 10	 add	 esp, 16			; 00000010H

; 518  : 
; 519  : #if(SYSTEM_ACHIEVEMENTS)
; 520  : 	if(!g_ZtLicense.CheckUser(NSGames))

  00b36	6a 51		 push	 81			; 00000051H
  00b38	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00b3d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00b42	84 c0		 test	 al, al
  00b44	75 0b		 jne	 SHORT $LN114@ExResetSys

; 521  : 	{
; 522  : 		g_Achievements.ResetUp(aIndex);

  00b46	57		 push	 edi
  00b47	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00b4c	e8 00 00 00 00	 call	 ?ResetUp@CAchievements@@QAEXH@Z ; CAchievements::ResetUp
$LN114@ExResetSys:
  00b51	5f		 pop	 edi
  00b52	5e		 pop	 esi
$LN1@ExResetSys:
  00b53	5b		 pop	 ebx

; 523  : 	}
; 524  : #endif
; 525  : }

  00b54	8b e5		 mov	 esp, ebp
  00b56	5d		 pop	 ebp
  00b57	c2 04 00	 ret	 4
  00b5a	8b ff		 npad	 2
$LN119@ExResetSys:
  00b5c	00 00 00 00	 DD	 $LN43@ExResetSys
  00b60	00 00 00 00	 DD	 $LN42@ExResetSys
  00b64	00 00 00 00	 DD	 $LN41@ExResetSys
  00b68	00 00 00 00	 DD	 $LN40@ExResetSys
  00b6c	00 00 00 00	 DD	 $LN39@ExResetSys
  00b70	00 00 00 00	 DD	 $LN38@ExResetSys
  00b74	00 00 00 00	 DD	 $LN37@ExResetSys
$LN120@ExResetSys:
  00b78	00 00 00 00	 DD	 $LN29@ExResetSys
  00b7c	00 00 00 00	 DD	 $LN28@ExResetSys
  00b80	00 00 00 00	 DD	 $LN27@ExResetSys
  00b84	00 00 00 00	 DD	 $LN26@ExResetSys
  00b88	00 00 00 00	 DD	 $LN25@ExResetSys
  00b8c	00 00 00 00	 DD	 $LN24@ExResetSys
  00b90	00 00 00 00	 DD	 $LN23@ExResetSys
$LN121@ExResetSys:
  00b94	00 00 00 00	 DD	 $LN19@ExResetSys
  00b98	00 00 00 00	 DD	 $LN18@ExResetSys
  00b9c	00 00 00 00	 DD	 $LN17@ExResetSys
  00ba0	00 00 00 00	 DD	 $LN16@ExResetSys
  00ba4	00 00 00 00	 DD	 $LN15@ExResetSys
  00ba8	00 00 00 00	 DD	 $LN14@ExResetSys
  00bac	00 00 00 00	 DD	 $LN13@ExResetSys
?ExResetSystemFunciton@cResetSystem@@QAEXH@Z ENDP	; cResetSystem::ExResetSystemFunciton
_TEXT	ENDS
PUBLIC	?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z	; cResetSystem::Main
EXTRN	?gAddExperience@@3MA:DWORD			; gAddExperience
; Function compile flags: /Ogtp
;	COMDAT ?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; cResetSystem::Main, COMDAT
; _this$ = ecx

; 528  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 	if(!this->EnableResetSystem || !this->DinamicExp)

  00003	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00006	74 52		 je	 SHORT $LN5@Main
  00008	80 79 4c 00	 cmp	 BYTE PTR [ecx+76], 0
  0000c	74 4c		 je	 SHORT $LN5@Main

; 532  : 	}
; 533  : 
; 534  : 	for(int i=0;i<this->rCount;i++)

  0000e	56		 push	 esi
  0000f	8b b1 fc 1f 00
	00		 mov	 esi, DWORD PTR [ecx+8188]
  00015	33 c0		 xor	 eax, eax
  00017	57		 push	 edi
  00018	85 f6		 test	 esi, esi
  0001a	7e 20		 jle	 SHORT $LN2@Main
  0001c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0001f	8b ba 90 22 00
	00		 mov	 edi, DWORD PTR [edx+8848]
  00025	8d 91 bc 00 00
	00		 lea	 edx, DWORD PTR [ecx+188]
  0002b	eb 03 8d 49 00	 npad	 5
$LL4@Main:

; 535  : 	{
; 536  : 		if(this->Number[i].Res == lpObj->Reset)

  00030	39 3a		 cmp	 DWORD PTR [edx], edi
  00032	74 19		 je	 SHORT $LN10@Main

; 532  : 	}
; 533  : 
; 534  : 	for(int i=0;i<this->rCount;i++)

  00034	40		 inc	 eax
  00035	83 c2 08	 add	 edx, 8
  00038	3b c6		 cmp	 eax, esi
  0003a	7c f4		 jl	 SHORT $LL4@Main
$LN2@Main:

; 539  : 		}
; 540  : 	}
; 541  : 
; 542  : 	return gAddExperience;

  0003c	d9 05 00 00 00
	00		 fld	 DWORD PTR ?gAddExperience@@3MA ; gAddExperience
  00042	e8 00 00 00 00	 call	 __ftol2_sse
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 543  : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN10@Main:

; 537  : 		{
; 538  : 			return this->Number[i].Exp;

  0004d	8b 84 c1 c0 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+192]
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 543  : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN5@Main:

; 530  : 	{
; 531  : 		return gAddExperience;

  0005a	d9 05 00 00 00
	00		 fld	 DWORD PTR ?gAddExperience@@3MA ; gAddExperience
  00060	e8 00 00 00 00	 call	 __ftol2_sse

; 543  : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
?Main@cResetSystem@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; cResetSystem::Main
_TEXT	ENDS
PUBLIC	?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z	; cResetSystem::SearchItem
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?CheckOptionItem@@YA_NHHH@Z:PROC		; CheckOptionItem
; Function compile flags: /Ogtp
;	COMDAT ?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_iType$ = 12						; size = 2
_Type$ = 12						; size = 4
_Index$ = 16						; size = 4
_Level$ = 20						; size = 4
_Skill$ = 24						; size = 1
_Luck$ = 28						; size = 1
_Opt$ = 32						; size = 1
_Exl$ = 36						; size = 1
_Anc$ = 40						; size = 1
_count$ = 44						; size = 4
_iDelCount$214129 = 48					; size = 4
_del$ = 48						; size = 1
?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z PROC	; cResetSystem::SearchItem, COMDAT
; _this$ = ecx

; 1146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1147 : 	LPOBJ lpUser = &gObj[aIndex];
; 1148 : 	int iCount = 0;
; 1149 : 	short iType = ITEMGET(Type, Index);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _Type$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00012	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	c1 e0 09	 shl	 eax, 9
  0001b	03 45 10	 add	 eax, DWORD PTR _Index$[ebp]
  0001e	57		 push	 edi
  0001f	0f b7 d8	 movzx	 ebx, ax
  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
  00029	89 5d 0c	 mov	 DWORD PTR _iType$[ebp], ebx
  0002c	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
$LL22@SearchItem:

; 1152 : 	{
; 1153 : 		if( lpUser->pInventory[i].m_Type == iType && 
; 1154 : 			lpUser->pInventory[i].m_Level >= Level &&
; 1155 : 			CheckOptionItem(lpUser->pInventory[i].m_Option1, Skill, FALSE) &&
; 1156 : 			CheckOptionItem(lpUser->pInventory[i].m_Option2, Luck, FALSE) &&
; 1157 : 			CheckOptionItem(lpUser->pInventory[i].m_Option3, Opt, FALSE) &&
; 1158 : 			CheckOptionItem(lpUser->pInventory[i].m_NewOption, Exl, FALSE) &&
; 1159 : 			CheckOptionItem(lpUser->pInventory[i].m_SetOption, Anc, FALSE) )

  00031	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  00037	66 39 5c 0f 06	 cmp	 WORD PTR [edi+ecx+6], bx
  0003c	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0003f	0f 85 b7 00 00
	00		 jne	 $LN11@SearchItem
  00045	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]
  00049	3b 55 14	 cmp	 edx, DWORD PTR _Level$[ebp]
  0004c	0f 8c aa 00 00
	00		 jl	 $LN11@SearchItem
  00052	0f b6 4d 18	 movzx	 ecx, BYTE PTR _Skill$[ebp]
  00056	0f b6 90 94 00
	00 00		 movzx	 edx, BYTE PTR [eax+148]
  0005d	6a 00		 push	 0
  0005f	51		 push	 ecx
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	84 c0		 test	 al, al
  0006b	0f 84 8b 00 00
	00		 je	 $LN11@SearchItem
  00071	0f b6 45 1c	 movzx	 eax, BYTE PTR _Luck$[ebp]
  00075	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0007b	0f b6 94 0f 95
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+149]
  00083	6a 00		 push	 0
  00085	50		 push	 eax
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	84 c0		 test	 al, al
  00091	74 69		 je	 SHORT $LN11@SearchItem
  00093	0f b6 45 20	 movzx	 eax, BYTE PTR _Opt$[ebp]
  00097	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0009d	0f b6 94 0f 96
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+150]
  000a5	6a 00		 push	 0
  000a7	50		 push	 eax
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	84 c0		 test	 al, al
  000b3	74 47		 je	 SHORT $LN11@SearchItem
  000b5	0f b6 45 24	 movzx	 eax, BYTE PTR _Exl$[ebp]
  000b9	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  000bf	0f b6 94 0f 97
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+151]
  000c7	6a 00		 push	 0
  000c9	50		 push	 eax
  000ca	52		 push	 edx
  000cb	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	84 c0		 test	 al, al
  000d5	74 25		 je	 SHORT $LN11@SearchItem
  000d7	0f b6 45 28	 movzx	 eax, BYTE PTR _Anc$[ebp]
  000db	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  000e1	0f b6 94 0f ae
	00 00 00	 movzx	 edx, BYTE PTR [edi+ecx+174]
  000e9	6a 00		 push	 0
  000eb	50		 push	 eax
  000ec	52		 push	 edx
  000ed	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	84 c0		 test	 al, al
  000f7	74 03		 je	 SHORT $LN11@SearchItem

; 1160 : 		{
; 1161 : 			iCount++;

  000f9	ff 45 fc	 inc	 DWORD PTR _iCount$[ebp]
$LN11@SearchItem:

; 1150 : 
; 1151 : 	for (int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  000fc	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00102	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  00108	0f 8c 23 ff ff
	ff		 jl	 $LL22@SearchItem

; 1162 : 		}
; 1163 : 	}
; 1164 : 
; 1165 : 	if(iCount >= count)

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _iCount$[ebp]
  00111	3b 45 2c	 cmp	 eax, DWORD PTR _count$[ebp]
  00114	0f 8c 39 01 00
	00		 jl	 $LN8@SearchItem

; 1166 : 	{
; 1167 : 		if(del)

  0011a	80 7d 30 00	 cmp	 BYTE PTR _del$[ebp], 0
  0011e	0f 84 24 01 00
	00		 je	 $LN17@SearchItem

; 1168 : 		{
; 1169 : 			int iDelCount = 0;

  00124	c7 45 30 00 00
	00 00		 mov	 DWORD PTR _iDelCount$214129[ebp], 0

; 1170 : 			for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  0012b	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  00130	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  00135	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL6@SearchItem:

; 1171 : 			{
; 1172 : 				if( lpUser->pInventory[i].m_Type == iType && 
; 1173 : 					lpUser->pInventory[i].m_Level >= Level &&
; 1174 : 					CheckOptionItem(lpUser->pInventory[i].m_Option1, Skill, FALSE) &&
; 1175 : 					CheckOptionItem(lpUser->pInventory[i].m_Option2, Luck, FALSE) &&
; 1176 : 					CheckOptionItem(lpUser->pInventory[i].m_Option3, Opt, FALSE) &&
; 1177 : 					CheckOptionItem(lpUser->pInventory[i].m_NewOption, Exl, FALSE) &&
; 1178 : 					CheckOptionItem(lpUser->pInventory[i].m_SetOption, Anc, FALSE) )

  00140	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  00146	66 8b 55 0c	 mov	 dx, WORD PTR _iType$[ebp]
  0014a	66 39 54 0f 06	 cmp	 WORD PTR [edi+ecx+6], dx
  0014f	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  00152	0f 85 dd 00 00
	00		 jne	 $LN5@SearchItem
  00158	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0015c	3b 4d 14	 cmp	 ecx, DWORD PTR _Level$[ebp]
  0015f	0f 8c d0 00 00
	00		 jl	 $LN5@SearchItem
  00165	0f b6 55 18	 movzx	 edx, BYTE PTR _Skill$[ebp]
  00169	0f b6 80 94 00
	00 00		 movzx	 eax, BYTE PTR [eax+148]
  00170	6a 00		 push	 0
  00172	52		 push	 edx
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	84 c0		 test	 al, al
  0017e	0f 84 b1 00 00
	00		 je	 $LN5@SearchItem
  00184	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _Luck$[ebp]
  00188	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  0018e	0f b6 84 17 95
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+149]
  00196	6a 00		 push	 0
  00198	51		 push	 ecx
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a2	84 c0		 test	 al, al
  001a4	0f 84 8b 00 00
	00		 je	 $LN5@SearchItem
  001aa	0f b6 4d 20	 movzx	 ecx, BYTE PTR _Opt$[ebp]
  001ae	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  001b4	0f b6 84 17 96
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+150]
  001bc	6a 00		 push	 0
  001be	51		 push	 ecx
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c8	84 c0		 test	 al, al
  001ca	74 69		 je	 SHORT $LN5@SearchItem
  001cc	0f b6 4d 24	 movzx	 ecx, BYTE PTR _Exl$[ebp]
  001d0	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  001d6	0f b6 84 17 97
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+151]
  001de	6a 00		 push	 0
  001e0	51		 push	 ecx
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ea	84 c0		 test	 al, al
  001ec	74 47		 je	 SHORT $LN5@SearchItem
  001ee	0f b6 4d 28	 movzx	 ecx, BYTE PTR _Anc$[ebp]
  001f2	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  001f8	0f b6 84 17 ae
	00 00 00	 movzx	 eax, BYTE PTR [edi+edx+174]
  00200	6a 00		 push	 0
  00202	51		 push	 ecx
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?CheckOptionItem@@YA_NHHH@Z ; CheckOptionItem
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020c	84 c0		 test	 al, al
  0020e	74 25		 je	 SHORT $LN5@SearchItem

; 1179 : 				{
; 1180 : 					gObjInventoryDeleteItem(aIndex, i);

  00210	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00213	53		 push	 ebx
  00214	51		 push	 ecx
  00215	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 1181 : 					GCInventoryItemDeleteSend(aIndex, i, 1);

  0021a	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0021d	6a 01		 push	 1
  0021f	53		 push	 ebx
  00220	52		 push	 edx
  00221	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 1182 : 					iDelCount++;

  00226	8b 45 30	 mov	 eax, DWORD PTR _iDelCount$214129[ebp]
  00229	40		 inc	 eax
  0022a	83 c4 14	 add	 esp, 20			; 00000014H
  0022d	89 45 30	 mov	 DWORD PTR _iDelCount$214129[ebp], eax

; 1183 : 					if(iDelCount == count)

  00230	3b 45 2c	 cmp	 eax, DWORD PTR _count$[ebp]
  00233	74 13		 je	 SHORT $LN17@SearchItem
$LN5@SearchItem:

; 1170 : 			for(int i = INVETORY_WEAR_SIZE; i < INVENTORY_SIZE; i++)

  00235	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0023b	43		 inc	 ebx
  0023c	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  00242	0f 8c f8 fe ff
	ff		 jl	 $LL6@SearchItem
$LN17@SearchItem:
  00248	5f		 pop	 edi
  00249	5e		 pop	 esi

; 1184 : 					{
; 1185 : 						return true;

  0024a	b0 01		 mov	 al, 1
  0024c	5b		 pop	 ebx

; 1195 : 	}
; 1196 : }

  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c2 2c 00	 ret	 44			; 0000002cH
$LN8@SearchItem:
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi

; 1186 : 					}
; 1187 : 				}
; 1188 : 			}
; 1189 : 		}
; 1190 : 		return true;
; 1191 : 	}
; 1192 : 	else
; 1193 : 	{
; 1194 : 		return false;

  00255	32 c0		 xor	 al, al
  00257	5b		 pop	 ebx

; 1195 : 	}
; 1196 : }

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 2c 00	 ret	 44			; 0000002cH
?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z ENDP	; cResetSystem::SearchItem
_TEXT	ENDS
PUBLIC	?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size, COMDAT
; _this$ = ecx

; 878  : 		{	// return length of sequence

  00000	56		 push	 esi

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	2b 31		 sub	 esi, DWORD PTR [ecx]
  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 880  : 		}

  0001a	c3		 ret	 0
?size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000d	2b d0		 sub	 edx, eax
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 941  : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEAAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 880  : 		}

  00016	c3		 ret	 0
?size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 941  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEAAURESET_REWARD_DATA@@I@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBE_NPBURESET_NEEDITEM_DATA@@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXPAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ PROC	; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside@2
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside@2
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside@2:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBE_NPBURESET_REWARD_DATA@@@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXPAURESET_REWARD_DATA@@0@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ	; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ PROC	; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity, COMDAT
; _this$ = ecx

; 776  : 		{	// return current length of allocated storage

  00000	56		 push	 esi

; 777  : 		return (this->_Myend - this->_Myfirst);

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	2b 31		 sub	 esi, DWORD PTR [ecx]
  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 778  : 		}

  0001a	c3		 ret	 0
?capacity@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@URESET_NEEDITEM_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::allocator<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 778  : 		}

  00016	c3		 ret	 0
?capacity@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::capacity
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen
; Function compile flags: /Ogtp
;	COMDAT ?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen@2:
$LN3@Xlen@2:
  0000a	cc		 int	 3
?_Xlen@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@URESET_REWARD_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::allocator<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z PROC ; std::allocator<RESET_REWARD_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@I@Z ENDP ; std::allocator<RESET_REWARD_DATA>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ; std::allocator<RESET_NEEDITEM_DATA>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ PROC ; std::allocator<RESET_NEEDITEM_DATA>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@URESET_NEEDITEM_DATA@@@std@@QBEIXZ ENDP ; std::allocator<RESET_NEEDITEM_DATA>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ ; std::allocator<RESET_REWARD_DATA>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ PROC ; std::allocator<RESET_REWARD_DATA>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@URESET_REWARD_DATA@@@std@@QBEIXZ ENDP ; std::allocator<RESET_REWARD_DATA>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Compat
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat
; Function compile flags: /Ogtp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ; std::addressof<RESET_NEEDITEM_DATA const >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::addressof<RESET_NEEDITEM_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBURESET_NEEDITEM_DATA@@@std@@YAPBURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::addressof<RESET_NEEDITEM_DATA const >
_TEXT	ENDS
PUBLIC	??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z ; std::addressof<RESET_REWARD_DATA const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z PROC ; std::addressof<RESET_REWARD_DATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBURESET_REWARD_DATA@@@std@@YAPBURESET_REWARD_DATA@@ABU1@@Z ENDP ; std::addressof<RESET_REWARD_DATA const >
_TEXT	ENDS
PUBLIC	??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAURESET_NEEDITEM_DATA@@@std@@YAAAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct:
  00017	5f		 pop	 edi

; 209  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@AAURESET_NEEDITEM_DATA@@@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@AAU2@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct<RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ; std::forward<RESET_NEEDITEM_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABURESET_NEEDITEM_DATA@@@std@@YAABURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA const &>
_TEXT	ENDS
PUBLIC	??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z PROC ; std::forward<RESET_REWARD_DATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAURESET_REWARD_DATA@@@std@@YAAAURESET_REWARD_DATA@@AAU1@@Z ENDP ; std::forward<RESET_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z PROC ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@2
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@2:
  00017	5f		 pop	 edi

; 209  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??$construct@AAURESET_REWARD_DATA@@@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@AAU2@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::construct<RESET_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z ; std::forward<RESET_REWARD_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z PROC ; std::forward<RESET_REWARD_DATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABURESET_REWARD_DATA@@@std@@YAABURESET_REWARD_DATA@@ABU1@@Z ENDP ; std::forward<RESET_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z PROC ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@URESET_NEEDITEM_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::_Ptr_cat<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z PROC ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@URESET_REWARD_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAURESET_REWARD_DATA@@0@Z ENDP ; std::_Ptr_cat<RESET_REWARD_DATA,RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z PROC ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@Construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@Construct:
  00017	5f		 pop	 edi

; 49   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Construct@URESET_NEEDITEM_DATA@@ABU1@@std@@YAXPAURESET_NEEDITEM_DATA@@ABU1@@Z ENDP ; std::_Construct<RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z PROC ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@Construct@2
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@Construct@2:
  00017	5f		 pop	 edi

; 49   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Construct@URESET_REWARD_DATA@@ABU1@@std@@YAXPAURESET_REWARD_DATA@@ABU1@@Z ENDP ; std::_Construct<RESET_REWARD_DATA,RESET_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::move<RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::move<RESET_NEEDITEM_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAURESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::move<RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::move<RESET_REWARD_DATA &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z PROC ; std::move<RESET_REWARD_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAURESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ENDP ; std::move<RESET_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ; std::_Val_type<RESET_NEEDITEM_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z PROC ; std::_Val_type<RESET_NEEDITEM_DATA *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAURESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@@Z ENDP ; std::_Val_type<RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z ; std::_Val_type<RESET_REWARD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z PROC ; std::_Val_type<RESET_REWARD_DATA *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAURESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@PAU1@@Z ENDP ; std::_Val_type<RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ; std::_Destroy<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z PROC ; std::_Destroy<RESET_NEEDITEM_DATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@URESET_NEEDITEM_DATA@@@std@@YAXPAURESET_NEEDITEM_DATA@@@Z ENDP ; std::_Destroy<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z ; std::_Destroy<RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z PROC ; std::_Destroy<RESET_REWARD_DATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@URESET_REWARD_DATA@@@std@@YAXPAURESET_REWARD_DATA@@@Z ENDP ; std::_Destroy<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ; std::forward<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z PROC ; std::forward<RESET_NEEDITEM_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@URESET_NEEDITEM_DATA@@@std@@YA$$QAURESET_NEEDITEM_DATA@@AAU1@@Z ENDP ; std::forward<RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ; std::forward<RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z PROC ; std::forward<RESET_REWARD_DATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@URESET_REWARD_DATA@@@std@@YA$$QAURESET_REWARD_DATA@@AAU1@@Z ENDP ; std::forward<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@ ; `string'
PUBLIC	??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@ ; `string'
PUBLIC	??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCDialogInfo@cResetSystem@@QAEXH@Z		; cResetSystem::GCDialogInfo
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@ DB '[Rese'
	DB	't]: You need Empty Inventory to Reset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@
CONST	SEGMENT
??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@ DB '[Reset]: '
	DB	'Interface Disable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@
CONST	SEGMENT
??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@ DB '[Rese'
	DB	't]: Skill Recall Party Time', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\reset.cpp
CONST	ENDS
;	COMDAT ?GCDialogInfo@cResetSystem@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -72					; size = 4
_pMsg$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCDialogInfo@cResetSystem@@QAEXH@Z PROC		; cResetSystem::GCDialogInfo, COMDAT
; _this$ = ecx

; 597  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	56		 push	 esi

; 598  : 	LPOBJ lpUser = &gObj[aIndex];

  00015	8b f3		 mov	 esi, ebx
  00017	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	57		 push	 edi
  00024	8b f9		 mov	 edi, ecx

; 762  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF  * ( lpUser->Reset+1 ); break;

  00026	89 5d b8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00029	c7 45 bc c1 40
	fb 43		 mov	 DWORD PTR _pMsg$[ebp], 1140539585 ; 43fb40c1H
  00030	c6 45 c0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003a	2b 86 1c 04 00
	00		 sub	 eax, DWORD PTR [esi+1052]
  00040	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00045	73 39		 jae	 SHORT $LN70@GCDialogIn

; 599  : 
; 600  : 	GC_RESET_DATA pMsg;
; 601  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x43, sizeof(pMsg));
; 602  : 
; 603  : 	pMsg.Result = true;
; 604  : 
; 605  : 	if((GetTickCount() - lpUser->MySelfDefenseTime ) < 60000)
; 606  : 	{
; 607  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), aIndex, 1);

  00047	6a 01		 push	 1
  00049	53		 push	 ebx
  0004a	68 6d 04 00 00	 push	 1133			; 0000046dH
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00054	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 608  : 		GCCloseMsgSend(aIndex,-1);

  0005f	68 ff 00 00 00	 push	 255			; 000000ffH
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  0006a	83 c4 14	 add	 esp, 20			; 00000014H
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx

; 841  : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
$LN70@GCDialogIn:

; 609  : 		return;
; 610  : 	}
; 611  : 
; 612  : 	if(lpUser->MapNumber != this->m_iMapForReset)

  00080	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00087	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0008a	3b c8		 cmp	 ecx, eax
  0008c	74 22		 je	 SHORT $LN69@GCDialogIn

; 613  : 	{
; 614  : 		MsgNormal(aIndex, g_ZtText.GetText(3), ztMapName(this->m_iMapForReset));

  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?ztMapName@@YAPADH@Z	; ztMapName
  00094	83 c4 04	 add	 esp, 4
  00097	50		 push	 eax
  00098	6a 03		 push	 3
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  0009f	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  000a4	50		 push	 eax
  000a5	53		 push	 ebx
  000a6	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal

; 615  : 		return;

  000ab	e9 5c 05 00 00	 jmp	 $LN95@GCDialogIn
$LN69@GCDialogIn:

; 616  : 	}
; 617  : 
; 618  : 	if(lpUser->SkillRecallParty_Time != 0)

  000b0	66 83 be 74 12
	00 00 00	 cmp	 WORD PTR [esi+4724], 0
  000b8	74 21		 je	 SHORT $LN68@GCDialogIn

; 619  : 	{
; 620  : 		MsgNormal(aIndex,"[Reset]: Skill Recall Party Time");

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@
  000bf	53		 push	 ebx
  000c0	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000c5	83 c4 08	 add	 esp, 8
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx

; 841  : }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
$LN68@GCDialogIn:

; 621  : 		return;
; 622  : 	}
; 623  : 	
; 624  : 	if(gMoveCommand.CheckInterfaceToMove(lpUser) == 0)

  000db	56		 push	 esi
  000dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000e1	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000e6	85 c0		 test	 eax, eax
  000e8	75 14		 jne	 SHORT $LN67@GCDialogIn

; 625  : 	{
; 626  : 		GCServerMsgStringSend("[Reset]: Interface Disable",lpUser->m_Index,1);

  000ea	8b 16		 mov	 edx, DWORD PTR [esi]
  000ec	6a 01		 push	 1
  000ee	52		 push	 edx
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@
  000f4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 627  : 		return;

  000f9	e9 0e 05 00 00	 jmp	 $LN95@GCDialogIn
$LN67@GCDialogIn:

; 628  : 	}
; 629  : 
; 630  : 	pMsg.Reset = lpUser->Reset;

  000fe	66 8b 86 90 22
	00 00		 mov	 ax, WORD PTR [esi+8848]

; 631  : 	pMsg.MaxReset = this->Maxres;

  00105	66 8b 4f 04	 mov	 cx, WORD PTR [edi+4]
  00109	66 89 45 c2	 mov	 WORD PTR _pMsg$[ebp+6], ax
  0010d	66 89 4d c4	 mov	 WORD PTR _pMsg$[ebp+8], cx

; 632  : 	if(lpUser->Reset >= this->Maxres)

  00111	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00117	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0011a	7c 04		 jl	 SHORT $LN66@GCDialogIn

; 633  : 	{
; 634  : 		pMsg.Result = false;

  0011c	c6 45 c0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN66@GCDialogIn:
  00120	8b 8f c4 7d 00
	00		 mov	 ecx, DWORD PTR [edi+32196]

; 635  : 	}
; 636  : 	
; 637  : 	//Проверка на уровен?
; 638  : 	pMsg.NeedLevel = this->NeedLevel;

  00126	66 8b 47 10	 mov	 ax, WORD PTR [edi+16]

; 639  : 
; 640  : 	bool SearchRes = false;
; 641  : 	for(int i=0; i<this->lCount; i++)

  0012a	33 db		 xor	 ebx, ebx
  0012c	66 89 45 c6	 mov	 WORD PTR _pMsg$[ebp+10], ax
  00130	85 c9		 test	 ecx, ecx
  00132	7e 19		 jle	 SHORT $LN92@GCDialogIn

; 635  : 	}
; 636  : 	
; 637  : 	//Проверка на уровен?
; 638  : 	pMsg.NeedLevel = this->NeedLevel;

  00134	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0013a	42		 inc	 edx
  0013b	8d 87 84 5e 00
	00		 lea	 eax, DWORD PTR [edi+24196]
$LL65@GCDialogIn:

; 642  : 	{
; 643  : 		if(this->LevelRes[i].Res == (lpUser->Reset + 1))

  00141	39 10		 cmp	 DWORD PTR [eax], edx
  00143	74 33		 je	 SHORT $LN86@GCDialogIn

; 639  : 
; 640  : 	bool SearchRes = false;
; 641  : 	for(int i=0; i<this->lCount; i++)

  00145	43		 inc	 ebx
  00146	83 c0 08	 add	 eax, 8
  00149	3b d9		 cmp	 ebx, ecx
  0014b	7c f4		 jl	 SHORT $LL65@GCDialogIn
$LN92@GCDialogIn:

; 668  : 	{
; 669  : 		if(g_ZtLicense.user.Rage)

  0014d	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  00154	74 76		 je	 SHORT $LN56@GCDialogIn

; 670  : 		{
; 671  : 			if((this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpUser->Level))

  00156	8b 45 b8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00159	6a 00		 push	 0
  0015b	6a 07		 push	 7
  0015d	50		 push	 eax
  0015e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00163	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  00168	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0016b	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00172	2b c8		 sub	 ecx, eax
  00174	3b ca		 cmp	 ecx, edx

; 672  : 			{
; 673  : 				pMsg.Result = false;
; 674  : 			}
; 675  : 		}
; 676  : 		else

  00176	eb 5e		 jmp	 SHORT $LN96@GCDialogIn
$LN86@GCDialogIn:

; 644  : 		{
; 645  : 			if(g_ZtLicense.user.Rage)

  00178	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  0017f	74 2f		 je	 SHORT $LN61@GCDialogIn

; 646  : 			{
; 647  : 				pMsg.NeedLevel = this->LevelRes[i].Level - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0);

  00181	8b 4d b8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00184	6a 00		 push	 0
  00186	6a 07		 push	 7
  00188	51		 push	 ecx
  00189	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  0018e	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  00193	66 8b 9c df 88
	5e 00 00	 mov	 bx, WORD PTR [edi+ebx*8+24200]
  0019b	66 2b d8	 sub	 bx, ax
  0019e	66 89 5d c6	 mov	 WORD PTR _pMsg$[ebp+10], bx

; 648  : 				if(pMsg.NeedLevel > lpUser->Level)

  001a2	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  001a9	0f b7 c3	 movzx	 eax, bx
  001ac	3b c2		 cmp	 eax, edx

; 649  : 				{
; 650  : 					pMsg.Result = false;
; 651  : 				} 
; 652  : 				SearchRes = true; 
; 653  : 				break;

  001ae	eb 26		 jmp	 SHORT $LN96@GCDialogIn
$LN61@GCDialogIn:

; 654  : 			}
; 655  : 			else
; 656  : 			{
; 657  : 				pMsg.NeedLevel = this->LevelRes[i].Level;

  001b0	66 8b 8c df 88
	5e 00 00	 mov	 cx, WORD PTR [edi+ebx*8+24200]
  001b8	66 89 4d c6	 mov	 WORD PTR _pMsg$[ebp+10], cx

; 658  : 				if(this->LevelRes[i].Level > lpUser->Level)

  001bc	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  001c3	39 94 df 88 5e
	00 00		 cmp	 DWORD PTR [edi+ebx*8+24200], edx

; 659  : 				{
; 660  : 					pMsg.Result = false;
; 661  : 				} 
; 662  : 				SearchRes = true; 
; 663  : 				break;
; 664  : 			}
; 665  : 		}
; 666  : 	} 
; 667  : 	if (!SearchRes)

  001ca	eb 0a		 jmp	 SHORT $LN96@GCDialogIn
$LN56@GCDialogIn:

; 677  : 		{
; 678  : 			if(this->NeedLevel > lpUser->Level)

  001cc	0f bf 86 be 00
	00 00		 movsx	 eax, WORD PTR [esi+190]
  001d3	39 47 10	 cmp	 DWORD PTR [edi+16], eax
$LN96@GCDialogIn:
  001d6	7e 04		 jle	 SHORT $LN53@GCDialogIn

; 679  : 			{
; 680  : 				pMsg.Result = false;

  001d8	c6 45 c0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN53@GCDialogIn:

; 681  : 			} 
; 682  : 		}
; 683  : 	}
; 684  : 
; 685  : 	//Проверка на зе?
; 686  : 	int ZenMoney = 0;
; 687  : 
; 688  : 	switch(this->ZenForm)

  001dc	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  001df	8b ca		 mov	 ecx, edx
  001e1	33 c0		 xor	 eax, eax
  001e3	49		 dec	 ecx
  001e4	74 08		 je	 SHORT $LN50@GCDialogIn
  001e6	49		 dec	 ecx
  001e7	75 10		 jne	 SHORT $LN51@GCDialogIn

; 691  : 		case 2: ZenMoney = this->NeedZen; break;

  001e9	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  001ec	eb 0b		 jmp	 SHORT $LN51@GCDialogIn
$LN50@GCDialogIn:

; 689  : 	{
; 690  : 		case 1: ZenMoney = this->NeedZen * ( lpUser->Reset + 1 ); break;

  001ee	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  001f4	40		 inc	 eax
  001f5	0f af 47 0c	 imul	 eax, DWORD PTR [edi+12]
$LN51@GCDialogIn:

; 692  : 	}
; 693  : 
; 694  : 	if(this->ZenForm != 0)

  001f9	85 d2		 test	 edx, edx
  001fb	74 0c		 je	 SHORT $LN47@GCDialogIn

; 695  : 	{
; 696  : 		if(lpUser->Money < ZenMoney)

  001fd	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  00203	7d 04		 jge	 SHORT $LN47@GCDialogIn

; 697  : 		{
; 698  : 			pMsg.Result = false;

  00205	c6 45 c0 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
$LN47@GCDialogIn:

; 699  : 		}
; 700  : 	}
; 701  : 
; 702  : 	pMsg.NeedMoney = ZenMoney;
; 703  : 
; 704  : 	//Проверка на пустой инвентар?
; 705  : 	if(this->NeedEmptyInv)

  00209	83 cb ff	 or	 ebx, -1
  0020c	83 7f 34 00	 cmp	 DWORD PTR [edi+52], 0
  00210	89 45 c8	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00213	0f 84 93 00 00
	00		 je	 $LN45@GCDialogIn

; 706  : 	{
; 707  : 		if(lpUser->pInventory[0].m_Type != -1 || lpUser->pInventory[1].m_Type != -1 || lpUser->pInventory[2].m_Type != -1 ||
; 708  : 		   lpUser->pInventory[3].m_Type != -1 || lpUser->pInventory[4].m_Type != -1 || lpUser->pInventory[5].m_Type != -1 ||
; 709  : 		   lpUser->pInventory[6].m_Type != -1 || lpUser->pInventory[7].m_Type != -1 || lpUser->pInventory[8].m_Type != -1 ||
; 710  : 		   lpUser->pInventory[9].m_Type != -1 || lpUser->pInventory[10].m_Type != -1|| lpUser->pInventory[11].m_Type != -1)

  00219	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  0021f	66 39 58 06	 cmp	 WORD PTR [eax+6], bx
  00223	75 63		 jne	 SHORT $LN44@GCDialogIn
  00225	66 39 98 da 00
	00 00		 cmp	 WORD PTR [eax+218], bx
  0022c	75 5a		 jne	 SHORT $LN44@GCDialogIn
  0022e	66 39 98 ae 01
	00 00		 cmp	 WORD PTR [eax+430], bx
  00235	75 51		 jne	 SHORT $LN44@GCDialogIn
  00237	66 39 98 82 02
	00 00		 cmp	 WORD PTR [eax+642], bx
  0023e	75 48		 jne	 SHORT $LN44@GCDialogIn
  00240	66 39 98 56 03
	00 00		 cmp	 WORD PTR [eax+854], bx
  00247	75 3f		 jne	 SHORT $LN44@GCDialogIn
  00249	66 39 98 2a 04
	00 00		 cmp	 WORD PTR [eax+1066], bx
  00250	75 36		 jne	 SHORT $LN44@GCDialogIn
  00252	66 39 98 fe 04
	00 00		 cmp	 WORD PTR [eax+1278], bx
  00259	75 2d		 jne	 SHORT $LN44@GCDialogIn
  0025b	66 39 98 d2 05
	00 00		 cmp	 WORD PTR [eax+1490], bx
  00262	75 24		 jne	 SHORT $LN44@GCDialogIn
  00264	66 39 98 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], bx
  0026b	75 1b		 jne	 SHORT $LN44@GCDialogIn
  0026d	66 39 98 7a 07
	00 00		 cmp	 WORD PTR [eax+1914], bx
  00274	75 12		 jne	 SHORT $LN44@GCDialogIn
  00276	66 39 98 4e 08
	00 00		 cmp	 WORD PTR [eax+2126], bx
  0027d	75 09		 jne	 SHORT $LN44@GCDialogIn
  0027f	66 39 98 22 09
	00 00		 cmp	 WORD PTR [eax+2338], bx
  00286	74 24		 je	 SHORT $LN45@GCDialogIn
$LN44@GCDialogIn:

; 711  : 		{
; 712  : 			MsgNormal(aIndex,"[Reset]: You need Empty Inventory to Reset");

  00288	8b 4d b8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@
  00290	51		 push	 ecx
  00291	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00296	83 c4 08	 add	 esp, 8
  00299	5f		 pop	 edi
  0029a	5e		 pop	 esi
  0029b	5b		 pop	 ebx

; 841  : }

  0029c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029f	33 cd		 xor	 ecx, ebp
  002a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a6	8b e5		 mov	 esp, ebp
  002a8	5d		 pop	 ebp
  002a9	c2 04 00	 ret	 4
$LN45@GCDialogIn:

; 713  : 			return;
; 714  : 		}
; 715  : 	}
; 716  : 
; 717  : 	//Поинта за ресе?
; 718  : 	int LevelUpPoint = 0;
; 719  : 
; 720  : 	if(this->AddForm == 1 || this->AddForm == 2)

  002ac	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  002af	33 c0		 xor	 eax, eax
  002b1	83 f9 01	 cmp	 ecx, 1
  002b4	74 05		 je	 SHORT $LN42@GCDialogIn
  002b6	83 f9 02	 cmp	 ecx, 2
  002b9	75 6c		 jne	 SHORT $LN40@GCDialogIn
$LN42@GCDialogIn:

; 721  : 	{
; 722  : 		switch (lpUser->Class)

  002bb	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  002c2	83 f9 06	 cmp	 ecx, 6
  002c5	77 60		 ja	 SHORT $LN40@GCDialogIn
  002c7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN99@GCDialogIn[ecx*4]
$LN39@GCDialogIn:

; 723  : 		{
; 724  : 			case 0: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDW ;  break;

  002ce	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  002d4	40		 inc	 eax
  002d5	0f af 47 18	 imul	 eax, DWORD PTR [edi+24]
  002d9	eb 4c		 jmp	 SHORT $LN40@GCDialogIn
$LN38@GCDialogIn:

; 725  : 			case 1: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDK ;  break;

  002db	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  002e1	40		 inc	 eax
  002e2	0f af 47 1c	 imul	 eax, DWORD PTR [edi+28]
  002e6	eb 3f		 jmp	 SHORT $LN40@GCDialogIn
$LN37@GCDialogIn:

; 726  : 			case 2: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsELF ; break;

  002e8	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  002ee	40		 inc	 eax
  002ef	0f af 47 20	 imul	 eax, DWORD PTR [edi+32]
  002f3	eb 32		 jmp	 SHORT $LN40@GCDialogIn
$LN36@GCDialogIn:

; 727  : 			case 3: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsMG ;  break;

  002f5	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  002fb	40		 inc	 eax
  002fc	0f af 47 28	 imul	 eax, DWORD PTR [edi+40]
  00300	eb 25		 jmp	 SHORT $LN40@GCDialogIn
$LN35@GCDialogIn:

; 728  : 			case 4: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDL ;  break;

  00302	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  00308	40		 inc	 eax
  00309	0f af 47 2c	 imul	 eax, DWORD PTR [edi+44]
  0030d	eb 18		 jmp	 SHORT $LN40@GCDialogIn
$LN34@GCDialogIn:

; 729  : 			case 5: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsSUM ; break;

  0030f	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  00315	40		 inc	 eax
  00316	0f af 47 24	 imul	 eax, DWORD PTR [edi+36]
  0031a	eb 0b		 jmp	 SHORT $LN40@GCDialogIn
$LN33@GCDialogIn:

; 730  : 			case 6: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsRF ; break;

  0031c	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  00322	40		 inc	 eax
  00323	0f af 47 30	 imul	 eax, DWORD PTR [edi+48]
$LN40@GCDialogIn:

; 731  : 		}
; 732  : 	}
; 733  : 
; 734  : 	//Поинта от гран?ресета
; 735  : 	if(gGrandReset.EnableGrandResetSystem)

  00327	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A, 0
  0032e	0f 84 2a 01 00
	00		 je	 $LN17@GCDialogIn

; 736  : 	{
; 737  : 		if(lpUser->GReset > 0)

  00334	8b 8e 94 22 00
	00		 mov	 ecx, DWORD PTR [esi+8852]
  0033a	85 c9		 test	 ecx, ecx
  0033c	0f 8e 1c 01 00
	00		 jle	 $LN17@GCDialogIn

; 738  : 		{
; 739  : 			if(gGrandReset.AddForm == 1 || gGrandReset.AddForm == 2)

  00342	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24
  00348	83 fa 01	 cmp	 edx, 1
  0034b	74 05		 je	 SHORT $LN29@GCDialogIn
  0034d	83 fa 02	 cmp	 edx, 2
  00350	75 63		 jne	 SHORT $LN94@GCDialogIn
$LN29@GCDialogIn:

; 740  : 			{
; 741  : 				switch (lpUser->Class)

  00352	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR [esi+184]
  00359	83 fa 06	 cmp	 edx, 6
  0035c	77 57		 ja	 SHORT $LN94@GCDialogIn
  0035e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN100@GCDialogIn[edx*4]
$LN26@GCDialogIn:

; 742  : 				{
; 743  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW ;  break;

  00365	8b d1		 mov	 edx, ecx
  00367	0f af 15 1c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  0036e	eb 40		 jmp	 SHORT $LN97@GCDialogIn
$LN25@GCDialogIn:

; 744  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK ;  break;

  00370	8b d1		 mov	 edx, ecx
  00372	0f af 15 20 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  00379	eb 35		 jmp	 SHORT $LN97@GCDialogIn
$LN24@GCDialogIn:

; 745  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF ; break;

  0037b	8b d1		 mov	 edx, ecx
  0037d	0f af 15 24 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  00384	eb 2a		 jmp	 SHORT $LN97@GCDialogIn
$LN23@GCDialogIn:

; 746  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG ;  break;

  00386	8b d1		 mov	 edx, ecx
  00388	0f af 15 2c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  0038f	eb 1f		 jmp	 SHORT $LN97@GCDialogIn
$LN22@GCDialogIn:

; 747  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL ;  break;

  00391	8b d1		 mov	 edx, ecx
  00393	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  0039a	eb 14		 jmp	 SHORT $LN97@GCDialogIn
$LN21@GCDialogIn:

; 748  : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM ; break;

  0039c	8b d1		 mov	 edx, ecx
  0039e	0f af 15 28 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  003a5	eb 09		 jmp	 SHORT $LN97@GCDialogIn
$LN20@GCDialogIn:

; 749  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF ; break;

  003a7	8b d1		 mov	 edx, ecx
  003a9	0f af 15 34 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
$LN97@GCDialogIn:
  003b0	03 c2		 add	 eax, edx
  003b2	83 cb ff	 or	 ebx, -1
$LN94@GCDialogIn:

; 750  : 				}
; 751  : 			}
; 752  : 			if(gGrandReset.AddForm == 3)

  003b5	83 3d 18 00 00
	00 03		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 3
  003bc	0f 85 9c 00 00
	00		 jne	 $LN17@GCDialogIn

; 753  : 			{
; 754  : 				switch (lpUser->Class)

  003c2	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR [esi+184]
  003c9	83 fa 06	 cmp	 edx, 6
  003cc	0f 87 8c 00 00
	00		 ja	 $LN17@GCDialogIn
  003d2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN101@GCDialogIn[edx*4]
$LN16@GCDialogIn:

; 755  : 				{
; 756  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW  * ( lpUser->Reset+1 ); break;

  003d9	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  003df	42		 inc	 edx
  003e0	0f af d1	 imul	 edx, ecx
  003e3	0f af 15 1c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  003ea	eb 70		 jmp	 SHORT $LN98@GCDialogIn
$LN15@GCDialogIn:

; 757  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK  * ( lpUser->Reset+1 ); break;

  003ec	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  003f2	42		 inc	 edx
  003f3	0f af d1	 imul	 edx, ecx
  003f6	0f af 15 20 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  003fd	eb 5d		 jmp	 SHORT $LN98@GCDialogIn
$LN14@GCDialogIn:

; 758  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF * ( lpUser->Reset+1 ); break;

  003ff	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00405	42		 inc	 edx
  00406	0f af d1	 imul	 edx, ecx
  00409	0f af 15 24 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  00410	eb 4a		 jmp	 SHORT $LN98@GCDialogIn
$LN13@GCDialogIn:

; 759  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG  * ( lpUser->Reset+1 ); break;

  00412	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00418	42		 inc	 edx
  00419	0f af d1	 imul	 edx, ecx
  0041c	0f af 15 2c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  00423	eb 37		 jmp	 SHORT $LN98@GCDialogIn
$LN12@GCDialogIn:

; 760  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL  * ( lpUser->Reset+1 ); break;

  00425	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0042b	42		 inc	 edx
  0042c	0f af d1	 imul	 edx, ecx
  0042f	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  00436	eb 24		 jmp	 SHORT $LN98@GCDialogIn
$LN11@GCDialogIn:

; 761  : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM * ( lpUser->Reset+1 ); break;

  00438	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0043e	42		 inc	 edx
  0043f	0f af d1	 imul	 edx, ecx
  00442	0f af 15 28 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  00449	eb 11		 jmp	 SHORT $LN98@GCDialogIn
$LN10@GCDialogIn:

; 762  : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF  * ( lpUser->Reset+1 ); break;

  0044b	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00451	42		 inc	 edx
  00452	0f af d1	 imul	 edx, ecx
  00455	0f af 15 34 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
$LN98@GCDialogIn:
  0045c	03 c2		 add	 eax, edx
$LN17@GCDialogIn:

; 763  : 				}
; 764  : 			}
; 765  : 		}
; 766  : 	}
; 767  : 
; 768  : 	LevelUpPoint += lpUser->ZtFreePoints;

  0045e	8b 8e 8c 22 00
	00		 mov	 ecx, DWORD PTR [esi+8844]

; 769  : 	pMsg.RewardPoint = LevelUpPoint;
; 770  : 
; 771  : 	pMsg.AddCredits = this->AddCredits;

  00464	0f b7 57 38	 movzx	 edx, WORD PTR [edi+56]
  00468	03 c8		 add	 ecx, eax

; 772  : 	pMsg.AddWcoinC = this->AddWcoinC;

  0046a	66 8b 47 3c	 mov	 ax, WORD PTR [edi+60]
  0046e	89 4d cc	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 773  : 	pMsg.AddWcoinP = this->AddWcoinP;

  00471	66 8b 4f 40	 mov	 cx, WORD PTR [edi+64]
  00475	66 89 4d d4	 mov	 WORD PTR _pMsg$[ebp+24], cx

; 774  : 	pMsg.AddWcoinG = this->AddGoblinPoint;
; 775  : 
; 776  : 	// Need Item
; 777  : 	pMsg.AddEnableItem = false;
; 778  : 	pMsg.AddItem = -1;
; 779  : 	pMsg.AddItemLevel = 0;
; 780  : 	pMsg.AddItemSkill = 0;
; 781  : 	pMsg.AddItemLuck = 0;
; 782  : 	pMsg.AddItemOpt = 0;
; 783  : 	pMsg.AddItemExl = 0;
; 784  : 	pMsg.AddItemAnc = 0;
; 785  : 	pMsg.AddItemCount = 0;
; 786  : 
; 787  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  00479	8b 8f dc 7d 00
	00		 mov	 ecx, DWORD PTR [edi+32220]
  0047f	2b 8f d8 7d 00
	00		 sub	 ecx, DWORD PTR [edi+32216]
  00485	66 89 55 d0	 mov	 WORD PTR _pMsg$[ebp+20], dx
  00489	0f b7 57 44	 movzx	 edx, WORD PTR [edi+68]
  0048d	66 89 45 d2	 mov	 WORD PTR _pMsg$[ebp+22], ax
  00491	66 89 55 d6	 mov	 WORD PTR _pMsg$[ebp+26], dx
  00495	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0049a	f7 e9		 imul	 ecx
  0049c	03 d1		 add	 edx, ecx
  0049e	c1 fa 04	 sar	 edx, 4
  004a1	8b ca		 mov	 ecx, edx
  004a3	89 5d e0	 mov	 DWORD PTR _pMsg$[ebp+36], ebx
  004a6	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004a9	33 db		 xor	 ebx, ebx
  004ab	03 ca		 add	 ecx, edx
  004ad	c6 45 dc 00	 mov	 BYTE PTR _pMsg$[ebp+32], 0
  004b1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+40], 0
  004b8	66 c7 45 e8 00
	00		 mov	 WORD PTR _pMsg$[ebp+44], 0
  004be	c6 45 ea 00	 mov	 BYTE PTR _pMsg$[ebp+46], 0
  004c2	0f 84 9c 00 00
	00		 je	 $LN93@GCDialogIn

; 763  : 				}
; 764  : 			}
; 765  : 		}
; 766  : 	}
; 767  : 
; 768  : 	LevelUpPoint += lpUser->ZtFreePoints;

  004c8	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  004ce	8b 87 d8 7d 00
	00		 mov	 eax, DWORD PTR [edi+32216]
  004d4	42		 inc	 edx
$LL9@GCDialogIn:

; 788  : 	{
; 789  : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];
; 790  : 		if(nitem.ResetNum == (lpUser->Reset + 1))

  004d5	39 10		 cmp	 DWORD PTR [eax], edx
  004d7	74 0d		 je	 SHORT $LN87@GCDialogIn

; 774  : 	pMsg.AddWcoinG = this->AddGoblinPoint;
; 775  : 
; 776  : 	// Need Item
; 777  : 	pMsg.AddEnableItem = false;
; 778  : 	pMsg.AddItem = -1;
; 779  : 	pMsg.AddItemLevel = 0;
; 780  : 	pMsg.AddItemSkill = 0;
; 781  : 	pMsg.AddItemLuck = 0;
; 782  : 	pMsg.AddItemOpt = 0;
; 783  : 	pMsg.AddItemExl = 0;
; 784  : 	pMsg.AddItemAnc = 0;
; 785  : 	pMsg.AddItemCount = 0;
; 786  : 
; 787  : 	for(int i = 0; i < this->m_needitem.size(); i++)

  004d9	43		 inc	 ebx
  004da	83 c0 1c	 add	 eax, 28			; 0000001cH
  004dd	3b d9		 cmp	 ebx, ecx
  004df	72 f4		 jb	 SHORT $LL9@GCDialogIn

; 822  : 	{
; 823  : 		RESET_REWARD_DATA & ritem = this->m_reward[i];
; 824  : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  004e1	e9 7e 00 00 00	 jmp	 $LN93@GCDialogIn
$LN87@GCDialogIn:

; 791  : 		{
; 792  : 			pMsg.AddEnableItem = true;

  004e6	c6 45 dc 01	 mov	 BYTE PTR _pMsg$[ebp+32], 1

; 793  : 			pMsg.AddItem = ITEMGET(nitem.Type, nitem.Index);

  004ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004ed	c1 e1 09	 shl	 ecx, 9
  004f0	03 48 08	 add	 ecx, DWORD PTR [eax+8]

; 794  : 			pMsg.AddItemLevel = nitem.Level;
; 795  : 			pMsg.AddItemSkill = nitem.Skill;
; 796  : 			pMsg.AddItemLuck = nitem.Luck;
; 797  : 			pMsg.AddItemOpt = nitem.Opt;
; 798  : 			pMsg.AddItemExl = nitem.Exl;
; 799  : 			pMsg.AddItemAnc = nitem.Anc;
; 800  : 			pMsg.AddItemCount = nitem.Count;
; 801  : 
; 802  : 			if(!SearchItem(aIndex, nitem.Type, nitem.Index, nitem.Level, nitem.Skill, nitem.Luck, nitem.Opt, nitem.Exl, nitem.Anc, nitem.Count, false))

  004f3	6a 00		 push	 0
  004f5	89 4d e0	 mov	 DWORD PTR _pMsg$[ebp+36], ecx
  004f8	0f b6 50 0c	 movzx	 edx, BYTE PTR [eax+12]
  004fc	88 55 e4	 mov	 BYTE PTR _pMsg$[ebp+40], dl
  004ff	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00503	88 4d e5	 mov	 BYTE PTR _pMsg$[ebp+41], cl
  00506	0f b6 50 11	 movzx	 edx, BYTE PTR [eax+17]
  0050a	88 55 e6	 mov	 BYTE PTR _pMsg$[ebp+42], dl
  0050d	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  00511	88 4d e7	 mov	 BYTE PTR _pMsg$[ebp+43], cl
  00514	0f b6 50 13	 movzx	 edx, BYTE PTR [eax+19]
  00518	88 55 e8	 mov	 BYTE PTR _pMsg$[ebp+44], dl
  0051b	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  0051f	88 4d e9	 mov	 BYTE PTR _pMsg$[ebp+45], cl
  00522	0f b6 50 18	 movzx	 edx, BYTE PTR [eax+24]
  00526	88 55 ea	 mov	 BYTE PTR _pMsg$[ebp+46], dl
  00529	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0052c	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  00530	51		 push	 ecx
  00531	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00535	52		 push	 edx
  00536	0f b6 50 12	 movzx	 edx, BYTE PTR [eax+18]
  0053a	51		 push	 ecx
  0053b	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  0053f	52		 push	 edx
  00540	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  00544	51		 push	 ecx
  00545	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00548	52		 push	 edx
  00549	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0054c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0054f	51		 push	 ecx
  00550	8b 4d b8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00553	52		 push	 edx
  00554	50		 push	 eax
  00555	51		 push	 ecx
  00556	8b cf		 mov	 ecx, edi
  00558	e8 00 00 00 00	 call	 ?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z ; cResetSystem::SearchItem
  0055d	84 c0		 test	 al, al
  0055f	75 03		 jne	 SHORT $LN93@GCDialogIn

; 803  : 			{
; 804  : 				pMsg.Result = false;

  00561	88 45 c0	 mov	 BYTE PTR _pMsg$[ebp+4], al
$LN93@GCDialogIn:

; 813  : 	pMsg.RewardItem = 0;
; 814  : 	pMsg.RewardLevel = 0;
; 815  : 	pMsg.RewardSkill = 0;
; 816  : 	pMsg.RewardLuck = 0;
; 817  : 	pMsg.RewardOpt = 0;
; 818  : 	pMsg.RewardExl = 0;
; 819  : 	pMsg.RewardAnc = 0;
; 820  : 
; 821  : 	for(int i = 0; i < this->m_reward.size(); i++)

  00564	8b 8f e8 7d 00
	00		 mov	 ecx, DWORD PTR [edi+32232]
  0056a	8b bf ec 7d 00
	00		 mov	 edi, DWORD PTR [edi+32236]
  00570	2b f9		 sub	 edi, ecx
  00572	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00577	f7 ef		 imul	 edi
  00579	c1 fa 03	 sar	 edx, 3
  0057c	33 db		 xor	 ebx, ebx
  0057e	8b c2		 mov	 eax, edx
  00580	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00583	03 c2		 add	 eax, edx
  00585	c6 45 eb 00	 mov	 BYTE PTR _pMsg$[ebp+47], 0
  00589	89 5d ec	 mov	 DWORD PTR _pMsg$[ebp+48], ebx
  0058c	89 5d f0	 mov	 DWORD PTR _pMsg$[ebp+52], ebx
  0058f	89 5d f4	 mov	 DWORD PTR _pMsg$[ebp+56], ebx
  00592	88 5d f8	 mov	 BYTE PTR _pMsg$[ebp+60], bl
  00595	74 63		 je	 SHORT $LN2@GCDialogIn

; 805  : 			}
; 806  : 
; 807  : 			break;
; 808  : 		}
; 809  : 	}
; 810  : 
; 811  : 	//reward Item
; 812  : 	pMsg.RewardEnableItem = false;

  00597	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0059d	42		 inc	 edx
  0059e	8b ff		 npad	 2
$LL4@GCDialogIn:

; 822  : 	{
; 823  : 		RESET_REWARD_DATA & ritem = this->m_reward[i];
; 824  : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  005a0	39 11		 cmp	 DWORD PTR [ecx], edx
  005a2	74 0a		 je	 SHORT $LN88@GCDialogIn

; 813  : 	pMsg.RewardItem = 0;
; 814  : 	pMsg.RewardLevel = 0;
; 815  : 	pMsg.RewardSkill = 0;
; 816  : 	pMsg.RewardLuck = 0;
; 817  : 	pMsg.RewardOpt = 0;
; 818  : 	pMsg.RewardExl = 0;
; 819  : 	pMsg.RewardAnc = 0;
; 820  : 
; 821  : 	for(int i = 0; i < this->m_reward.size(); i++)

  005a4	43		 inc	 ebx
  005a5	83 c1 24	 add	 ecx, 36			; 00000024H
  005a8	3b d8		 cmp	 ebx, eax
  005aa	72 f4		 jb	 SHORT $LL4@GCDialogIn

; 822  : 	{
; 823  : 		RESET_REWARD_DATA & ritem = this->m_reward[i];
; 824  : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  005ac	eb 4c		 jmp	 SHORT $LN2@GCDialogIn
$LN88@GCDialogIn:

; 825  : 		{
; 826  : 			pMsg.AddWcoinC = ritem.WcoinC;

  005ae	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  005b2	66 89 55 d2	 mov	 WORD PTR _pMsg$[ebp+22], dx

; 827  : 			pMsg.RewardEnableItem = ritem.EnableItem;

  005b6	0f b6 41 08	 movzx	 eax, BYTE PTR [ecx+8]
  005ba	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+47], al

; 828  : 			pMsg.RewardItem = ITEMGET(ritem.Type, ritem.Index);

  005bd	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  005c0	c1 e2 09	 shl	 edx, 9
  005c3	03 51 10	 add	 edx, DWORD PTR [ecx+16]
  005c6	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+48], edx

; 829  : 			pMsg.RewardLevel = ritem.Level;

  005c9	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  005cc	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+52], eax

; 830  : 			pMsg.RewardSkill = ritem.Skill;

  005cf	0f b6 51 18	 movzx	 edx, BYTE PTR [ecx+24]
  005d3	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+56], dl

; 831  : 			pMsg.RewardLuck = ritem.Luck;

  005d6	0f b6 41 19	 movzx	 eax, BYTE PTR [ecx+25]
  005da	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+57], al

; 832  : 			pMsg.RewardOpt = ritem.Opt;

  005dd	0f b6 51 1a	 movzx	 edx, BYTE PTR [ecx+26]
  005e1	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+58], dl

; 833  : 			pMsg.RewardExl = ritem.Exl;

  005e4	0f b6 41 1b	 movzx	 eax, BYTE PTR [ecx+27]
  005e8	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+59], al

; 834  : 			pMsg.RewardAnc = ritem.Anc;

  005eb	0f b6 51 1c	 movzx	 edx, BYTE PTR [ecx+28]
  005ef	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+60], dl

; 835  : 			pMsg.AddCredits = ritem.Credit;

  005f2	66 8b 41 20	 mov	 ax, WORD PTR [ecx+32]
  005f6	66 89 45 d0	 mov	 WORD PTR _pMsg$[ebp+20], ax
$LN2@GCDialogIn:

; 836  : 			break;
; 837  : 		}
; 838  : 	}
; 839  : 
; 840  : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  005fa	0f b6 4d bd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  005fe	8b 45 b8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00601	51		 push	 ecx
  00602	8d 55 bc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00605	52		 push	 edx
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
$LN95@GCDialogIn:

; 841  : }

  0060c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0060f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00612	5f		 pop	 edi
  00613	5e		 pop	 esi
  00614	33 cd		 xor	 ecx, ebp
  00616	5b		 pop	 ebx
  00617	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061c	8b e5		 mov	 esp, ebp
  0061e	5d		 pop	 ebp
  0061f	c2 04 00	 ret	 4
  00622	8b ff		 npad	 2
$LN99@GCDialogIn:
  00624	00 00 00 00	 DD	 $LN39@GCDialogIn
  00628	00 00 00 00	 DD	 $LN38@GCDialogIn
  0062c	00 00 00 00	 DD	 $LN37@GCDialogIn
  00630	00 00 00 00	 DD	 $LN36@GCDialogIn
  00634	00 00 00 00	 DD	 $LN35@GCDialogIn
  00638	00 00 00 00	 DD	 $LN34@GCDialogIn
  0063c	00 00 00 00	 DD	 $LN33@GCDialogIn
$LN100@GCDialogIn:
  00640	00 00 00 00	 DD	 $LN26@GCDialogIn
  00644	00 00 00 00	 DD	 $LN25@GCDialogIn
  00648	00 00 00 00	 DD	 $LN24@GCDialogIn
  0064c	00 00 00 00	 DD	 $LN23@GCDialogIn
  00650	00 00 00 00	 DD	 $LN22@GCDialogIn
  00654	00 00 00 00	 DD	 $LN21@GCDialogIn
  00658	00 00 00 00	 DD	 $LN20@GCDialogIn
$LN101@GCDialogIn:
  0065c	00 00 00 00	 DD	 $LN16@GCDialogIn
  00660	00 00 00 00	 DD	 $LN15@GCDialogIn
  00664	00 00 00 00	 DD	 $LN14@GCDialogIn
  00668	00 00 00 00	 DD	 $LN13@GCDialogIn
  0066c	00 00 00 00	 DD	 $LN12@GCDialogIn
  00670	00 00 00 00	 DD	 $LN11@GCDialogIn
  00674	00 00 00 00	 DD	 $LN10@GCDialogIn
?GCDialogInfo@cResetSystem@@QAEXH@Z ENDP		; cResetSystem::GCDialogInfo
_TEXT	ENDS
PUBLIC	??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@ ; `string'
PUBLIC	??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@ ; `string'
PUBLIC	??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@ ; `string'
PUBLIC	??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@ ; `string'
PUBLIC	?CGResulInfo@cResetSystem@@QAEXH@Z		; cResetSystem::CGResulInfo
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
;	COMDAT ??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@ DB '[Reset]: '
	DB	'Need Reset Items', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@
CONST	SEGMENT
??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@ DB '['
	DB	'Reset]: You need above %d Zen to Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
CONST	SEGMENT
??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@ DB '['
	DB	'Reset]: You need above %d Level to Reset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@ DB '[Reset]: M'
	DB	'ax Reset %d', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\reset.cpp
CONST	ENDS
;	COMDAT ?CGResulInfo@cResetSystem@@QAEXH@Z
_TEXT	SEGMENT
tv1496 = -16						; size = 4
tv1449 = -16						; size = 4
tv1431 = -16						; size = 4
tv1422 = -16						; size = 4
tv1414 = -16						; size = 4
_this$ = -16						; size = 4
tv1884 = -12						; size = 4
tv1386 = -12						; size = 4
tv1332 = -12						; size = 4
tv1096 = -12						; size = 4
_i$214079 = -8						; size = 4
tv1084 = -4						; size = 4
_ZenMoney$ = -4						; size = 4
tv1692 = 8						; size = 4
tv1687 = 8						; size = 4
tv1682 = 8						; size = 4
tv1677 = 8						; size = 4
tv1672 = 8						; size = 4
_aIndex$ = 8						; size = 4
?CGResulInfo@cResetSystem@@QAEXH@Z PROC			; cResetSystem::CGResulInfo, COMDAT
; _this$ = ecx

; 844  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 845  : 	if(!this->EnableResetSystem)return;

  00009	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0000c	89 5d f0	 mov	 DWORD PTR _this$[ebp], ebx
  0000f	0f 84 f9 08 00
	00		 je	 $LN84@CGResulInf

; 846  : 
; 847  : 	LPOBJ lpUser = &gObj[aIndex];

  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001a	8b f7		 mov	 esi, edi
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 848  : 
; 849  : 	if((GetTickCount() - lpUser->MySelfDefenseTime ) < 60000)

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002e	2b 86 1c 04 00
	00		 sub	 eax, DWORD PTR [esi+1052]
  00034	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00039	73 2f		 jae	 SHORT $LN82@CGResulInf

; 850  : 	{
; 851  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 109)), aIndex, 1);

  0003b	6a 01		 push	 1
  0003d	57		 push	 edi
  0003e	68 6d 04 00 00	 push	 1133			; 0000046dH
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00048	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 852  : 		GCCloseMsgSend(aIndex,-1);

  00053	68 ff 00 00 00	 push	 255			; 000000ffH
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  0005e	83 c4 14	 add	 esp, 20			; 00000014H
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
$LN82@CGResulInf:

; 853  : 		return;
; 854  : 	}
; 855  : 
; 856  : 	if(lpUser->MapNumber != this->m_iMapForReset)

  0006a	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00071	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00074	3b c8		 cmp	 ecx, eax
  00076	74 29		 je	 SHORT $LN81@CGResulInf

; 857  : 	{
; 858  : 		MsgNormal(aIndex, g_ZtText.GetText(3), ztMapName(this->m_iMapForReset));

  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?ztMapName@@YAPADH@Z	; ztMapName
  0007e	83 c4 04	 add	 esp, 4
  00081	50		 push	 eax
  00082	6a 03		 push	 3
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  00089	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  0008e	50		 push	 eax
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN81@CGResulInf:

; 859  : 		return;
; 860  : 	}
; 861  : 
; 862  : 	if(lpUser->SkillRecallParty_Time != 0)

  000a1	66 83 be 74 12
	00 00 00	 cmp	 WORD PTR [esi+4724], 0
  000a9	74 17		 je	 SHORT $LN80@CGResulInf

; 863  : 	{
; 864  : 		MsgNormal(aIndex,"[Reset]: Skill Recall Party Time");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PEPODKFL@?$FLReset?$FN?3?5Skill?5Recall?5Party?5Time@
  000b0	57		 push	 edi
  000b1	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  000b6	83 c4 08	 add	 esp, 8
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
$LN80@CGResulInf:

; 865  : 		return;
; 866  : 	}
; 867  : 	
; 868  : 	if(gMoveCommand.CheckInterfaceToMove(lpUser) == 0)

  000c2	56		 push	 esi
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  000c8	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  000cd	85 c0		 test	 eax, eax
  000cf	75 1b		 jne	 SHORT $LN79@CGResulInf

; 869  : 	{
; 870  : 		GCServerMsgStringSend("[Reset]: Interface Disable",lpUser->m_Index,1);

  000d1	8b 16		 mov	 edx, DWORD PTR [esi]
  000d3	6a 01		 push	 1
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DMAJGMEH@?$FLReset?$FN?3?5Interface?5Disable?$AA@
  000db	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 04 00	 ret	 4
$LN79@CGResulInf:

; 871  : 		return;
; 872  : 	}
; 873  : 
; 874  : 	if(lpUser->Reset >= this->Maxres)

  000ec	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000ef	39 86 90 22 00
	00		 cmp	 DWORD PTR [esi+8848], eax
  000f5	7c 18		 jl	 SHORT $LN78@CGResulInf

; 875  : 	{
; 876  : 		MsgNormal(aIndex,"[Reset]: Max Reset %d",this->Maxres);

  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BDFKKKDA@?$FLReset?$FN?3?5Max?5Reset?5?$CFd?$AA@
  000fd	57		 push	 edi
  000fe	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
$LN78@CGResulInf:
  0010f	8b 8b c4 7d 00
	00		 mov	 ecx, DWORD PTR [ebx+32196]

; 877  : 		return;
; 878  : 	}
; 879  : 	
; 880  : 	//Проверка на уровен?
; 881  : 	int iNeedLevel = this->NeedLevel;
; 882  : 
; 883  : 	bool SearchRes = false;
; 884  : 	for(int i=0; i<this->lCount; i++)

  00115	33 c0		 xor	 eax, eax
  00117	85 c9		 test	 ecx, ecx
  00119	7e 70		 jle	 SHORT $LN105@CGResulInf
  0011b	8d bb 84 5e 00
	00		 lea	 edi, DWORD PTR [ebx+24196]
$LL112@CGResulInf:

; 885  : 	{
; 886  : 		if(g_ZtLicense.user.Rage)
; 887  : 		{
; 888  : 			if(this->LevelRes[i].Res == (lpUser->Reset + 1))

  00121	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00127	42		 inc	 edx
  00128	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  0012f	74 4b		 je	 SHORT $LN74@CGResulInf
  00131	39 17		 cmp	 DWORD PTR [edi], edx
  00133	75 4b		 jne	 SHORT $LN76@CGResulInf

; 889  : 			{
; 890  : 				if(this->LevelRes[i].Level - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpUser->Level)

  00135	8b bc c3 88 5e
	00 00		 mov	 edi, DWORD PTR [ebx+eax*8+24200]
  0013c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0013f	6a 00		 push	 0
  00141	6a 07		 push	 7
  00143	50		 push	 eax
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00149	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  0014e	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00155	8b cf		 mov	 ecx, edi
  00157	2b c8		 sub	 ecx, eax
  00159	3b ca		 cmp	 ecx, edx
  0015b	0f 8e d5 00 00
	00		 jle	 $LN64@CGResulInf

; 891  : 				{
; 892  : 					MsgNormal(aIndex,"[Reset]: You need above %d Level to Reset",this->LevelRes[i].Level);

  00161	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00164	57		 push	 edi
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00170	83 c4 0c	 add	 esp, 12			; 0000000cH
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c2 04 00	 ret	 4
$LN74@CGResulInf:

; 893  : 					return;
; 894  : 				} 
; 895  : 				SearchRes = true; 
; 896  : 				break;
; 897  : 			}
; 898  : 		}
; 899  : 		else
; 900  : 		{
; 901  : 			if(this->LevelRes[i].Res == (lpUser->Reset + 1))

  0017c	39 17		 cmp	 DWORD PTR [edi], edx
  0017e	74 63		 je	 SHORT $LN98@CGResulInf
$LN76@CGResulInf:

; 877  : 		return;
; 878  : 	}
; 879  : 	
; 880  : 	//Проверка на уровен?
; 881  : 	int iNeedLevel = this->NeedLevel;
; 882  : 
; 883  : 	bool SearchRes = false;
; 884  : 	for(int i=0; i<this->lCount; i++)

  00180	40		 inc	 eax
  00181	83 c7 08	 add	 edi, 8
  00184	3b c1		 cmp	 eax, ecx
  00186	7c 99		 jl	 SHORT $LL112@CGResulInf

; 1047 : 	{
; 1048 : 		RESET_REWARD_DATA & ritem = this->m_reward[i];
; 1049 : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  00188	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
$LN105@CGResulInf:

; 906  : 					return;
; 907  : 				} 
; 908  : 				SearchRes = true; 
; 909  : 				break;
; 910  : 			}
; 911  : 		}
; 912  : 	} 
; 913  : 	if(!SearchRes)
; 914  : 	{
; 915  : 		if(g_ZtLicense.user.Rage)

  0018b	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  00192	74 7c		 je	 SHORT $LN67@CGResulInf

; 916  : 		{
; 917  : 			if((this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0) > lpUser->Level))

  00194	6a 00		 push	 0
  00196	6a 07		 push	 7
  00198	57		 push	 edi
  00199	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  0019e	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  001a3	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  001a6	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  001ad	2b c8		 sub	 ecx, eax
  001af	3b ca		 cmp	 ecx, edx
  001b1	0f 8e 7f 00 00
	00		 jle	 $LN64@CGResulInf

; 918  : 			{
; 919  : 				MsgNormal(aIndex, "[Reset]: You need above %d Level to Reset", (this->NeedLevel - gSystemOfRage.ReturnCalc(aIndex,eSkill7,0)));

  001b7	6a 00		 push	 0
  001b9	6a 07		 push	 7
  001bb	57		 push	 edi
  001bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  001c1	e8 00 00 00 00	 call	 ?ReturnCalc@cSystemOfRage@@QAEHHHH@Z ; cSystemOfRage::ReturnCalc
  001c6	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  001c9	2b c8		 sub	 ecx, eax
  001cb	51		 push	 ecx
  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  001d1	57		 push	 edi
  001d2	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  001d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c2 04 00	 ret	 4
$LN98@CGResulInf:

; 902  : 			{
; 903  : 				if(this->LevelRes[i].Level > lpUser->Level)

  001e3	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  001ea	8b 84 c3 88 5e
	00 00		 mov	 eax, DWORD PTR [ebx+eax*8+24200]
  001f1	3b c1		 cmp	 eax, ecx
  001f3	7e 41		 jle	 SHORT $LN64@CGResulInf

; 904  : 				{
; 905  : 					MsgNormal(aIndex,"[Reset]: You need above %d Level to Reset",this->LevelRes[i].Level);

  001f5	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001f8	50		 push	 eax
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  001fe	52		 push	 edx
  001ff	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00204	83 c4 0c	 add	 esp, 12			; 0000000cH
  00207	5f		 pop	 edi
  00208	5e		 pop	 esi
  00209	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 04 00	 ret	 4
$LN67@CGResulInf:

; 920  : 				return;
; 921  : 			}
; 922  : 		}
; 923  : 		else
; 924  : 		{
; 925  : 			if(this->NeedLevel > lpUser->Level)

  00210	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00217	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0021a	3b c2		 cmp	 eax, edx
  0021c	7e 18		 jle	 SHORT $LN64@CGResulInf

; 926  : 			{
; 927  : 				MsgNormal(aIndex,"[Reset]: You need above %d Level to Reset",this->NeedLevel);

  0021e	50		 push	 eax
  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JOKEILBF@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Level@
  00224	57		 push	 edi
  00225	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022d	5f		 pop	 edi
  0022e	5e		 pop	 esi
  0022f	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c2 04 00	 ret	 4
$LN64@CGResulInf:

; 928  : 				return;
; 929  : 			} 
; 930  : 		}
; 931  : 	}
; 932  : 
; 933  : 	//Проверка на зе?
; 934  : 	int ZenMoney = 0;
; 935  : 
; 936  : 	switch(this->ZenForm)

  00236	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00239	33 c0		 xor	 eax, eax
  0023b	8b ca		 mov	 ecx, edx
  0023d	49		 dec	 ecx
  0023e	89 45 fc	 mov	 DWORD PTR _ZenMoney$[ebp], eax
  00241	74 08		 je	 SHORT $LN61@CGResulInf
  00243	49		 dec	 ecx
  00244	75 13		 jne	 SHORT $LN62@CGResulInf

; 939  : 		case 2: ZenMoney = this->NeedZen; break;

  00246	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00249	eb 0b		 jmp	 SHORT $LN115@CGResulInf
$LN61@CGResulInf:

; 937  : 	{
; 938  : 		case 1: ZenMoney = this->NeedZen * ( lpUser->Reset + 1 ); break;

  0024b	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  00251	40		 inc	 eax
  00252	0f af 43 0c	 imul	 eax, DWORD PTR [ebx+12]
$LN115@CGResulInf:
  00256	89 45 fc	 mov	 DWORD PTR _ZenMoney$[ebp], eax
$LN62@CGResulInf:

; 940  : 	}
; 941  : 
; 942  : 	if(this->ZenForm != 0)

  00259	85 d2		 test	 edx, edx
  0025b	74 23		 je	 SHORT $LN58@CGResulInf

; 943  : 	{
; 944  : 		if(lpUser->Money < ZenMoney)

  0025d	39 86 f0 00 00
	00		 cmp	 DWORD PTR [esi+240], eax
  00263	7d 1b		 jge	 SHORT $LN58@CGResulInf

; 945  : 		{
; 946  : 			MsgNormal(aIndex,"[Reset]: You need above %d Zen to Reset",ZenMoney);

  00265	50		 push	 eax
  00266	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOEBMPOL@?$FLReset?$FN?3?5You?5need?5above?5?$CFd?5Zen?5t@
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00274	83 c4 0c	 add	 esp, 12			; 0000000cH
  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  0027a	8b e5		 mov	 esp, ebp
  0027c	5d		 pop	 ebp
  0027d	c2 04 00	 ret	 4
$LN58@CGResulInf:

; 947  : 			return;
; 948  : 		}
; 949  : 	}
; 950  : 
; 951  : 	//Проверка на пустой инвентар?
; 952  : 	if(this->NeedEmptyInv)

  00280	83 7b 34 00	 cmp	 DWORD PTR [ebx+52], 0
  00284	0f 84 8c 00 00
	00		 je	 $LN56@CGResulInf

; 953  : 	{
; 954  : 		if(lpUser->pInventory[0].m_Type != -1 || lpUser->pInventory[1].m_Type != -1 || lpUser->pInventory[2].m_Type != -1 ||
; 955  : 		   lpUser->pInventory[3].m_Type != -1 || lpUser->pInventory[4].m_Type != -1 || lpUser->pInventory[5].m_Type != -1 ||
; 956  : 		   lpUser->pInventory[6].m_Type != -1 || lpUser->pInventory[7].m_Type != -1 || lpUser->pInventory[8].m_Type != -1 ||
; 957  : 		   lpUser->pInventory[9].m_Type != -1 || lpUser->pInventory[10].m_Type != -1|| lpUser->pInventory[11].m_Type != -1)

  0028a	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  00290	83 c9 ff	 or	 ecx, -1
  00293	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  00297	75 63		 jne	 SHORT $LN55@CGResulInf
  00299	66 39 88 da 00
	00 00		 cmp	 WORD PTR [eax+218], cx
  002a0	75 5a		 jne	 SHORT $LN55@CGResulInf
  002a2	66 39 88 ae 01
	00 00		 cmp	 WORD PTR [eax+430], cx
  002a9	75 51		 jne	 SHORT $LN55@CGResulInf
  002ab	66 39 88 82 02
	00 00		 cmp	 WORD PTR [eax+642], cx
  002b2	75 48		 jne	 SHORT $LN55@CGResulInf
  002b4	66 39 88 56 03
	00 00		 cmp	 WORD PTR [eax+854], cx
  002bb	75 3f		 jne	 SHORT $LN55@CGResulInf
  002bd	66 39 88 2a 04
	00 00		 cmp	 WORD PTR [eax+1066], cx
  002c4	75 36		 jne	 SHORT $LN55@CGResulInf
  002c6	66 39 88 fe 04
	00 00		 cmp	 WORD PTR [eax+1278], cx
  002cd	75 2d		 jne	 SHORT $LN55@CGResulInf
  002cf	66 39 88 d2 05
	00 00		 cmp	 WORD PTR [eax+1490], cx
  002d6	75 24		 jne	 SHORT $LN55@CGResulInf
  002d8	66 39 88 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], cx
  002df	75 1b		 jne	 SHORT $LN55@CGResulInf
  002e1	66 39 88 7a 07
	00 00		 cmp	 WORD PTR [eax+1914], cx
  002e8	75 12		 jne	 SHORT $LN55@CGResulInf
  002ea	66 39 88 4e 08
	00 00		 cmp	 WORD PTR [eax+2126], cx
  002f1	75 09		 jne	 SHORT $LN55@CGResulInf
  002f3	66 39 88 22 09
	00 00		 cmp	 WORD PTR [eax+2338], cx
  002fa	74 1a		 je	 SHORT $LN56@CGResulInf
$LN55@CGResulInf:

; 958  : 		{
; 959  : 			MsgNormal(aIndex,"[Reset]: You need Empty Inventory to Reset");

  002fc	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HNIKKPDH@?$FLReset?$FN?3?5You?5need?5Empty?5Inventor@
  00304	51		 push	 ecx
  00305	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0030a	83 c4 08	 add	 esp, 8
  0030d	5f		 pop	 edi
  0030e	5e		 pop	 esi
  0030f	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  00310	8b e5		 mov	 esp, ebp
  00312	5d		 pop	 ebp
  00313	c2 04 00	 ret	 4
$LN56@CGResulInf:

; 960  : 			return;
; 961  : 		}
; 962  : 	}
; 963  : 
; 964  : 	//Поинта за ресе?
; 965  : 	int LevelUpPoint = 0;
; 966  : 
; 967  : 	if(this->AddForm == 1 || this->AddForm == 2)

  00316	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00319	33 ff		 xor	 edi, edi
  0031b	83 f8 01	 cmp	 eax, 1
  0031e	74 05		 je	 SHORT $LN53@CGResulInf
  00320	83 f8 02	 cmp	 eax, 2
  00323	75 6c		 jne	 SHORT $LN51@CGResulInf
$LN53@CGResulInf:

; 968  : 	{
; 969  : 		switch (lpUser->Class)

  00325	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  0032c	83 f8 06	 cmp	 eax, 6
  0032f	77 60		 ja	 SHORT $LN51@CGResulInf
  00331	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN118@CGResulInf[eax*4]
$LN50@CGResulInf:

; 970  : 		{
; 971  : 			case 0: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDW ;  break;

  00338	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  0033e	47		 inc	 edi
  0033f	0f af 7b 18	 imul	 edi, DWORD PTR [ebx+24]
  00343	eb 4c		 jmp	 SHORT $LN51@CGResulInf
$LN49@CGResulInf:

; 972  : 			case 1: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDK ;  break;

  00345	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  0034b	47		 inc	 edi
  0034c	0f af 7b 1c	 imul	 edi, DWORD PTR [ebx+28]
  00350	eb 3f		 jmp	 SHORT $LN51@CGResulInf
$LN48@CGResulInf:

; 973  : 			case 2: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsELF ; break;

  00352	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  00358	47		 inc	 edi
  00359	0f af 7b 20	 imul	 edi, DWORD PTR [ebx+32]
  0035d	eb 32		 jmp	 SHORT $LN51@CGResulInf
$LN47@CGResulInf:

; 974  : 			case 3: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsMG ;  break;

  0035f	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  00365	47		 inc	 edi
  00366	0f af 7b 28	 imul	 edi, DWORD PTR [ebx+40]
  0036a	eb 25		 jmp	 SHORT $LN51@CGResulInf
$LN46@CGResulInf:

; 975  : 			case 4: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsDL ;  break;

  0036c	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  00372	47		 inc	 edi
  00373	0f af 7b 2c	 imul	 edi, DWORD PTR [ebx+44]
  00377	eb 18		 jmp	 SHORT $LN51@CGResulInf
$LN45@CGResulInf:

; 976  : 			case 5: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsSUM ; break;

  00379	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  0037f	47		 inc	 edi
  00380	0f af 7b 24	 imul	 edi, DWORD PTR [ebx+36]
  00384	eb 0b		 jmp	 SHORT $LN51@CGResulInf
$LN44@CGResulInf:

; 977  : 			case 6: LevelUpPoint = ( lpUser->Reset + 1 ) * this->AddPointsRF ; break;

  00386	8b be 90 22 00
	00		 mov	 edi, DWORD PTR [esi+8848]
  0038c	47		 inc	 edi
  0038d	0f af 7b 30	 imul	 edi, DWORD PTR [ebx+48]
$LN51@CGResulInf:

; 978  : 		}
; 979  : 	}
; 980  : 
; 981  : 	//Поинта от гран?ресета
; 982  : 	if(gGrandReset.EnableGrandResetSystem)

  00391	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A, 0
  00398	0f 84 3b 01 00
	00		 je	 $LN27@CGResulInf

; 983  : 	{
; 984  : 		if(lpUser->GReset > 0)

  0039e	8b 86 94 22 00
	00		 mov	 eax, DWORD PTR [esi+8852]
  003a4	85 c0		 test	 eax, eax
  003a6	0f 8e 2d 01 00
	00		 jle	 $LN27@CGResulInf

; 985  : 		{
; 986  : 			if(gGrandReset.AddForm == 1)

  003ac	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24
  003b2	83 f9 01	 cmp	 ecx, 1
  003b5	75 08		 jne	 SHORT $LN104@CGResulInf

; 987  : 			{
; 988  : 				LevelUpPoint += lpUser->LevelUpPoint;;;;

  003b7	03 be c0 00 00
	00		 add	 edi, DWORD PTR [esi+192]

; 989  : 			}
; 990  : 
; 991  : 			if(gGrandReset.AddForm == 1 || gGrandReset.AddForm == 2)

  003bd	eb 05		 jmp	 SHORT $LN39@CGResulInf
$LN104@CGResulInf:
  003bf	83 f9 02	 cmp	 ecx, 2
  003c2	75 66		 jne	 SHORT $LN37@CGResulInf
$LN39@CGResulInf:

; 992  : 			{
; 993  : 				switch (lpUser->Class)

  003c4	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  003cb	83 f9 06	 cmp	 ecx, 6
  003ce	77 5a		 ja	 SHORT $LN37@CGResulInf
  003d0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN119@CGResulInf[ecx*4]
$LN36@CGResulInf:

; 994  : 				{
; 995  : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW ;  break;

  003d7	8b d0		 mov	 edx, eax
  003d9	0f af 15 1c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  003e0	eb 46		 jmp	 SHORT $LN116@CGResulInf
$LN35@CGResulInf:

; 996  : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK ;  break;

  003e2	8b c8		 mov	 ecx, eax
  003e4	0f af 0d 20 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  003eb	03 f9		 add	 edi, ecx
  003ed	eb 3b		 jmp	 SHORT $LN37@CGResulInf
$LN34@CGResulInf:

; 997  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF ; break;

  003ef	8b d0		 mov	 edx, eax
  003f1	0f af 15 24 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  003f8	eb 2e		 jmp	 SHORT $LN116@CGResulInf
$LN33@CGResulInf:

; 998  : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG ;  break;

  003fa	8b c8		 mov	 ecx, eax
  003fc	0f af 0d 2c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  00403	03 f9		 add	 edi, ecx
  00405	eb 23		 jmp	 SHORT $LN37@CGResulInf
$LN32@CGResulInf:

; 999  : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL ;  break;

  00407	8b d0		 mov	 edx, eax
  00409	0f af 15 30 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  00410	eb 16		 jmp	 SHORT $LN116@CGResulInf
$LN31@CGResulInf:

; 1000 : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM ; break;

  00412	8b c8		 mov	 ecx, eax
  00414	0f af 0d 28 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  0041b	03 f9		 add	 edi, ecx
  0041d	eb 0b		 jmp	 SHORT $LN37@CGResulInf
$LN30@CGResulInf:

; 1001 : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF ; break;

  0041f	8b d0		 mov	 edx, eax
  00421	0f af 15 34 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
$LN116@CGResulInf:
  00428	03 fa		 add	 edi, edx
$LN37@CGResulInf:

; 1002 : 				}
; 1003 : 			}
; 1004 : 
; 1005 : 			if(gGrandReset.AddForm == 3)

  0042a	83 3d 18 00 00
	00 03		 cmp	 DWORD PTR ?gGrandReset@@3VcGrandReset@@A+24, 3
  00431	0f 85 a2 00 00
	00		 jne	 $LN27@CGResulInf

; 1006 : 			{
; 1007 : 				switch (lpUser->Class)

  00437	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  0043e	83 f9 06	 cmp	 ecx, 6
  00441	0f 87 92 00 00
	00		 ja	 $LN27@CGResulInf
  00447	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN120@CGResulInf[ecx*4]
$LN26@CGResulInf:

; 1008 : 				{
; 1009 : 					case 0: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDW  * ( lpUser->Reset+1 ); break;

  0044e	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  00454	41		 inc	 ecx
  00455	0f af c8	 imul	 ecx, eax
  00458	0f af 0d 1c 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+28
  0045f	eb 76		 jmp	 SHORT $LN117@CGResulInf
$LN25@CGResulInf:

; 1010 : 					case 1: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDK  * ( lpUser->Reset+1 ); break;

  00461	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  00467	42		 inc	 edx
  00468	0f af d0	 imul	 edx, eax
  0046b	0f af 15 20 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+32
  00472	03 fa		 add	 edi, edx
  00474	eb 63		 jmp	 SHORT $LN27@CGResulInf
$LN24@CGResulInf:

; 1011 : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF * ( lpUser->Reset+1 ); break;

  00476	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  0047c	41		 inc	 ecx
  0047d	0f af c8	 imul	 ecx, eax
  00480	0f af 0d 24 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+36
  00487	eb 4e		 jmp	 SHORT $LN117@CGResulInf
$LN23@CGResulInf:

; 1012 : 					case 3: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsMG  * ( lpUser->Reset+1 ); break;

  00489	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0048f	42		 inc	 edx
  00490	0f af d0	 imul	 edx, eax
  00493	0f af 15 2c 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+44
  0049a	03 fa		 add	 edi, edx
  0049c	eb 3b		 jmp	 SHORT $LN27@CGResulInf
$LN22@CGResulInf:

; 1013 : 					case 4: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsDL  * ( lpUser->Reset+1 ); break;

  0049e	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  004a4	41		 inc	 ecx
  004a5	0f af c8	 imul	 ecx, eax
  004a8	0f af 0d 30 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+48
  004af	eb 26		 jmp	 SHORT $LN117@CGResulInf
$LN21@CGResulInf:

; 1014 : 					case 5: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsSUM * ( lpUser->Reset+1 ); break;

  004b1	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  004b7	42		 inc	 edx
  004b8	0f af d0	 imul	 edx, eax
  004bb	0f af 15 28 00
	00 00		 imul	 edx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+40
  004c2	03 fa		 add	 edi, edx
  004c4	eb 13		 jmp	 SHORT $LN27@CGResulInf
$LN20@CGResulInf:

; 1015 : 					case 6: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsRF  * ( lpUser->Reset+1 ); break;

  004c6	8b 8e 90 22 00
	00		 mov	 ecx, DWORD PTR [esi+8848]
  004cc	41		 inc	 ecx
  004cd	0f af c8	 imul	 ecx, eax
  004d0	0f af 0d 34 00
	00 00		 imul	 ecx, DWORD PTR ?gGrandReset@@3VcGrandReset@@A+52
$LN117@CGResulInf:
  004d7	03 f9		 add	 edi, ecx
$LN27@CGResulInf:

; 1022 : 
; 1023 : 	/*
; 1024 : 	pMsg.AddCredits = this->AddCredits;
; 1025 : 	pMsg.AddWcoinC = this->AddWcoinC;
; 1026 : 	pMsg.AddWcoinP = this->AddWcoinP;
; 1027 : 	pMsg.AddWcoinG = this->AddGoblinPoint;
; 1028 : 	*/
; 1029 : 
; 1030 : 	// Need Item
; 1031 : 	for(int i = 0; i < this->m_needitem.size(); i++)

  004d9	8b 8b dc 7d 00
	00		 mov	 ecx, DWORD PTR [ebx+32220]
  004df	2b 8b d8 7d 00
	00		 sub	 ecx, DWORD PTR [ebx+32216]
  004e5	03 be 8c 22 00
	00		 add	 edi, DWORD PTR [esi+8844]
  004eb	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  004f0	f7 e9		 imul	 ecx
  004f2	03 d1		 add	 edx, ecx
  004f4	c1 fa 04	 sar	 edx, 4
  004f7	8b ca		 mov	 ecx, edx
  004f9	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004fc	03 ca		 add	 ecx, edx
  004fe	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$214079[ebp], 0
  00505	74 25		 je	 SHORT $LN109@CGResulInf

; 997  : 					case 2: LevelUpPoint += lpUser->GReset * gGrandReset.AddPointsELF ; break;

  00507	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  0050d	40		 inc	 eax
  0050e	89 45 f4	 mov	 DWORD PTR tv1096[ebp], eax

; 1016 : 				}
; 1017 : 			}
; 1018 : 		}
; 1019 : 	}
; 1020 : 
; 1021 : 	LevelUpPoint += lpUser->ZtFreePoints;

  00511	8b 83 d8 7d 00
	00		 mov	 eax, DWORD PTR [ebx+32216]
$LL108@CGResulInf:

; 1032 : 	{
; 1033 : 		RESET_NEEDITEM_DATA & nitem = this->m_needitem[i];
; 1034 : 		if(nitem.ResetNum == (lpUser->Reset + 1))

  00517	8b 55 f4	 mov	 edx, DWORD PTR tv1096[ebp]
  0051a	39 10		 cmp	 DWORD PTR [eax], edx
  0051c	74 53		 je	 SHORT $LN99@CGResulInf

; 1022 : 
; 1023 : 	/*
; 1024 : 	pMsg.AddCredits = this->AddCredits;
; 1025 : 	pMsg.AddWcoinC = this->AddWcoinC;
; 1026 : 	pMsg.AddWcoinP = this->AddWcoinP;
; 1027 : 	pMsg.AddWcoinG = this->AddGoblinPoint;
; 1028 : 	*/
; 1029 : 
; 1030 : 	// Need Item
; 1031 : 	for(int i = 0; i < this->m_needitem.size(); i++)

  0051e	8b 55 f8	 mov	 edx, DWORD PTR _i$214079[ebp]
  00521	42		 inc	 edx
  00522	83 c0 1c	 add	 eax, 28			; 0000001cH
  00525	89 55 f8	 mov	 DWORD PTR _i$214079[ebp], edx
  00528	3b d1		 cmp	 edx, ecx
  0052a	72 eb		 jb	 SHORT $LL108@CGResulInf
$LN109@CGResulInf:

; 1039 : 				return;
; 1040 : 			}
; 1041 : 			break;
; 1042 : 		}
; 1043 : 	}
; 1044 : 
; 1045 : 	//reward Item
; 1046 : 	for(int i = 0; i < this->m_reward.size(); i++)

  0052c	8b 83 e8 7d 00
	00		 mov	 eax, DWORD PTR [ebx+32232]
  00532	8b 9b ec 7d 00
	00		 mov	 ebx, DWORD PTR [ebx+32236]
  00538	89 45 f4	 mov	 DWORD PTR tv1332[ebp], eax
  0053b	2b d8		 sub	 ebx, eax
  0053d	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00542	f7 eb		 imul	 ebx
  00544	c1 fa 03	 sar	 edx, 3
  00547	8b c2		 mov	 eax, edx
  00549	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0054c	33 c9		 xor	 ecx, ecx
  0054e	03 c2		 add	 eax, edx
  00550	0f 84 03 01 00
	00		 je	 $LN106@CGResulInf
  00556	8b 96 90 22 00
	00		 mov	 edx, DWORD PTR [esi+8848]
  0055c	8b 5d f4	 mov	 ebx, DWORD PTR tv1332[ebp]
  0055f	42		 inc	 edx
$LL14@CGResulInf:

; 1047 : 	{
; 1048 : 		RESET_REWARD_DATA & ritem = this->m_reward[i];
; 1049 : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  00560	39 13		 cmp	 DWORD PTR [ebx], edx
  00562	74 61		 je	 SHORT $LN100@CGResulInf

; 1039 : 				return;
; 1040 : 			}
; 1041 : 			break;
; 1042 : 		}
; 1043 : 	}
; 1044 : 
; 1045 : 	//reward Item
; 1046 : 	for(int i = 0; i < this->m_reward.size(); i++)

  00564	41		 inc	 ecx
  00565	83 c3 24	 add	 ebx, 36			; 00000024H
  00568	3b c8		 cmp	 ecx, eax
  0056a	72 f4		 jb	 SHORT $LL14@CGResulInf

; 1047 : 	{
; 1048 : 		RESET_REWARD_DATA & ritem = this->m_reward[i];
; 1049 : 		if(ritem.ResetNum == (lpUser->Reset + 1))

  0056c	e9 e8 00 00 00	 jmp	 $LN106@CGResulInf
$LN99@CGResulInf:

; 1035 : 		{
; 1036 : 			if(!SearchItem(aIndex, nitem.Type, nitem.Index, nitem.Level, nitem.Skill, nitem.Luck, nitem.Opt, nitem.Exl, nitem.Anc, nitem.Count, true))

  00571	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00574	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  00578	6a 01		 push	 1
  0057a	51		 push	 ecx
  0057b	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  0057f	52		 push	 edx
  00580	0f b6 50 12	 movzx	 edx, BYTE PTR [eax+18]
  00584	51		 push	 ecx
  00585	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  00589	52		 push	 edx
  0058a	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  0058e	51		 push	 ecx
  0058f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00592	52		 push	 edx
  00593	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00596	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00599	51		 push	 ecx
  0059a	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0059d	52		 push	 edx
  0059e	50		 push	 eax
  0059f	51		 push	 ecx
  005a0	8b cb		 mov	 ecx, ebx
  005a2	e8 00 00 00 00	 call	 ?SearchItem@cResetSystem@@QAE_NHHHH_N0000H0@Z ; cResetSystem::SearchItem
  005a7	84 c0		 test	 al, al
  005a9	75 81		 jne	 SHORT $LN109@CGResulInf

; 1037 : 			{
; 1038 : 				MsgNormal(aIndex,"[Reset]: Need Reset Items");

  005ab	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JGHMBOOH@?$FLReset?$FN?3?5Need?5Reset?5Items?$AA@
  005b3	52		 push	 edx
  005b4	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  005b9	83 c4 08	 add	 esp, 8
  005bc	5f		 pop	 edi
  005bd	5e		 pop	 esi
  005be	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c2 04 00	 ret	 4
$LN100@CGResulInf:

; 1050 : 		{
; 1051 : 			if(ritem.WcoinC > 0)

  005c5	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  005c8	89 45 f4	 mov	 DWORD PTR tv1884[ebp], eax
  005cb	85 c0		 test	 eax, eax
  005cd	7e 1c		 jle	 SHORT $LN111@CGResulInf

; 1052 : 			{
; 1053 : 				lpUser->GameShop.WCoinC += ritem.WcoinC;

  005cf	db 45 f4	 fild	 DWORD PTR tv1884[ebp]

; 1054 : 				gGameShop.GDSaveUserInfo(lpUser->m_Index);

  005d2	8b 06		 mov	 eax, DWORD PTR [esi]
  005d4	50		 push	 eax
  005d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  005da	dc 86 00 23 00
	00		 fadd	 QWORD PTR [esi+8960]
  005e0	dd 9e 00 23 00
	00		 fstp	 QWORD PTR [esi+8960]
  005e6	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN111@CGResulInf:

; 1055 : 			}
; 1056 : 			if(ritem.EnableItem)

  005eb	80 7b 08 00	 cmp	 BYTE PTR [ebx+8], 0
  005ef	74 4f		 je	 SHORT $LN9@CGResulInf

; 1057 : 			{
; 1058 : 				ItemSerialCreateSend(aIndex,lpUser->MapNumber,lpUser->X,lpUser->Y,ITEMGET(ritem.Type, ritem.Index),ritem.Level,0,ritem.Skill,ritem.Luck,ritem.Opt,aIndex,ritem.Exl,ritem.Anc);

  005f1	0f b6 4b 1c	 movzx	 ecx, BYTE PTR [ebx+28]
  005f5	0f b6 53 1b	 movzx	 edx, BYTE PTR [ebx+27]
  005f9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005fc	51		 push	 ecx
  005fd	0f b6 4b 1a	 movzx	 ecx, BYTE PTR [ebx+26]
  00601	52		 push	 edx
  00602	0f b6 53 19	 movzx	 edx, BYTE PTR [ebx+25]
  00606	50		 push	 eax
  00607	51		 push	 ecx
  00608	0f b6 4b 18	 movzx	 ecx, BYTE PTR [ebx+24]
  0060c	52		 push	 edx
  0060d	0f b6 53 14	 movzx	 edx, BYTE PTR [ebx+20]
  00611	51		 push	 ecx
  00612	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00615	6a 00		 push	 0
  00617	52		 push	 edx
  00618	0f b6 96 46 01
	00 00		 movzx	 edx, BYTE PTR [esi+326]
  0061f	c1 e1 09	 shl	 ecx, 9
  00622	03 4b 10	 add	 ecx, DWORD PTR [ebx+16]
  00625	51		 push	 ecx
  00626	0f b6 8e 44 01
	00 00		 movzx	 ecx, BYTE PTR [esi+324]
  0062d	52		 push	 edx
  0062e	0f b6 96 49 01
	00 00		 movzx	 edx, BYTE PTR [esi+329]
  00635	51		 push	 ecx
  00636	52		 push	 edx
  00637	50		 push	 eax
  00638	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0063d	83 c4 34	 add	 esp, 52			; 00000034H
$LN9@CGResulInf:

; 1059 : 			}
; 1060 : 			if(ritem.Credit > 0)

  00640	8b 5b 20	 mov	 ebx, DWORD PTR [ebx+32]
  00643	89 5d f4	 mov	 DWORD PTR tv1386[ebp], ebx
  00646	85 db		 test	 ebx, ebx
  00648	7e 0f		 jle	 SHORT $LN106@CGResulInf

; 1061 : 			{
; 1062 : 				lpUser->ZtCred += ritem.Credit;

  0064a	db 45 f4	 fild	 DWORD PTR tv1386[ebp]
  0064d	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  00653	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
$LN106@CGResulInf:

; 1063 : 			}
; 1064 : 			break;
; 1065 : 		}
; 1066 : 	}
; 1067 : 
; 1068 : 	/////////////////////
; 1069 : 	//Выполнение ресета//
; 1070 : 	/////////////////////
; 1071 : 	lpUser->Money -= ZenMoney;

  00659	8b 45 fc	 mov	 eax, DWORD PTR _ZenMoney$[ebp]
  0065c	29 86 f0 00 00
	00		 sub	 DWORD PTR [esi+240], eax

; 1072 : 	lpUser->Level = 1;
; 1073 : 	lpUser->Experience = 0;
; 1074 : 	lpUser->NextExp = 100;
; 1075 : 	if(this->AddForm == 2)

  00662	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00665	b9 01 00 00 00	 mov	 ecx, 1
  0066a	66 89 8e be 00
	00 00		 mov	 WORD PTR [esi+190], cx
  00671	c7 86 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+200], 0
  0067b	c7 86 cc 00 00
	00 64 00 00 00	 mov	 DWORD PTR [esi+204], 100 ; 00000064H
  00685	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  00689	75 2a		 jne	 SHORT $LN6@CGResulInf

; 1076 : 	{
; 1077 : 		lpUser->Strength = 25;
; 1078 : 		lpUser->Dexterity = 25;
; 1079 : 		lpUser->Vitality = 25;
; 1080 : 		lpUser->Energy = 25;
; 1081 : 
; 1082 : 		if(lpUser->Class == 4)

  0068b	66 83 be b8 00
	00 00 04	 cmp	 WORD PTR [esi+184], 4
  00693	c7 86 f4 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+244], 1638425 ; 00190019H
  0069d	c7 86 f8 00 00
	00 19 00 19 00	 mov	 DWORD PTR [esi+248], 1638425 ; 00190019H
  006a7	75 0c		 jne	 SHORT $LN6@CGResulInf

; 1083 : 		{
; 1084 : 			lpUser->Leadership = 25;

  006a9	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
  006ae	66 89 96 18 01
	00 00		 mov	 WORD PTR [esi+280], dx
$LN6@CGResulInf:

; 1085 : 		}
; 1086 : 	}
; 1087 : 	lpUser->LevelUpPoint = LevelUpPoint;
; 1088 : 	
; 1089 : 	lpUser->Reset++;

  006b5	ff 86 90 22 00
	00		 inc	 DWORD PTR [esi+8848]
  006bb	89 be c0 00 00
	00		 mov	 DWORD PTR [esi+192], edi

; 1090 : 
; 1091 : 	if(this->AddCredits>0)

  006c1	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  006c4	89 4d f0	 mov	 DWORD PTR tv1414[ebp], ecx
  006c7	85 c9		 test	 ecx, ecx
  006c9	7e 0f		 jle	 SHORT $LN5@CGResulInf

; 1092 : 	{
; 1093 : 		lpUser->ZtCred += AddCredits;

  006cb	db 45 f0	 fild	 DWORD PTR tv1414[ebp]
  006ce	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  006d4	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
$LN5@CGResulInf:

; 1094 : 	}
; 1095 : 
; 1096 : 	/*if(this->AddWcoinC > 0)
; 1097 : 	{
; 1098 : 		lpUser->GameShop.WCoinC += this->AddWcoinC;
; 1099 : 	}*/
; 1100 : 	if(this->AddWcoinP > 0)

  006da	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  006dd	89 4d f0	 mov	 DWORD PTR tv1422[ebp], ecx
  006e0	85 c9		 test	 ecx, ecx
  006e2	7e 0f		 jle	 SHORT $LN4@CGResulInf

; 1101 : 	{
; 1102 : 		lpUser->GameShop.WCoinP += this->AddWcoinP;

  006e4	db 45 f0	 fild	 DWORD PTR tv1422[ebp]
  006e7	dc 86 f8 22 00
	00		 fadd	 QWORD PTR [esi+8952]
  006ed	dd 9e f8 22 00
	00		 fstp	 QWORD PTR [esi+8952]
$LN4@CGResulInf:

; 1103 : 	}
; 1104 : 	if(this->AddGoblinPoint > 0)

  006f3	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  006f6	89 4d f0	 mov	 DWORD PTR tv1431[ebp], ecx
  006f9	85 c9		 test	 ecx, ecx
  006fb	7e 0f		 jle	 SHORT $LN3@CGResulInf

; 1105 : 	{
; 1106 : 		lpUser->GameShop.GoblinPoint += this->AddGoblinPoint;

  006fd	db 45 f0	 fild	 DWORD PTR tv1431[ebp]
  00700	dc 86 08 23 00
	00		 fadd	 QWORD PTR [esi+8968]
  00706	dd 9e 08 23 00
	00		 fstp	 QWORD PTR [esi+8968]
$LN3@CGResulInf:

; 1107 : 	}
; 1108 : 
; 1109 : 	if(this->AddWcoinC > 0 || this->AddWcoinP > 0 || this->AddGoblinPoint > 0)

  0070c	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00710	7f 0c		 jg	 SHORT $LN1@CGResulInf
  00712	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00716	7f 06		 jg	 SHORT $LN1@CGResulInf
  00718	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0071c	7e 10		 jle	 SHORT $LN107@CGResulInf
$LN1@CGResulInf:

; 1110 : 	{
; 1111 : 		gGameShop.GDSaveUserInfo(aIndex);

  0071e	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00721	57		 push	 edi
  00722	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00727	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
  0072c	eb 03		 jmp	 SHORT $LN2@CGResulInf
$LN107@CGResulInf:
  0072e	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
$LN2@CGResulInf:

; 1112 : 	}	
; 1113 : 
; 1114 : 	ZtFireCracker(aIndex, lpUser->X, lpUser->Y);

  00731	0f b6 86 46 01
	00 00		 movzx	 eax, BYTE PTR [esi+326]
  00738	0f b6 8e 44 01
	00 00		 movzx	 ecx, BYTE PTR [esi+324]
  0073f	50		 push	 eax
  00740	51		 push	 ecx
  00741	57		 push	 edi
  00742	e8 00 00 00 00	 call	 ?ZtFireCracker@@YAXHEE@Z ; ZtFireCracker

; 1115 : 
; 1116 : 	lpUser->Life = DCInfo.DefClass[lpUser->Class].Life + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelLife  + ((lpUser->Vitality - DCInfo.DefClass[lpUser->Class].Vitality ) * DCInfo.DefClass[lpUser->Class].VitalityToLife);

  00747	0f bf 96 d0 00
	00 00		 movsx	 edx, WORD PTR [esi+208]
  0074e	0f bf 86 be 00
	00 00		 movsx	 eax, WORD PTR [esi+190]
  00755	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00759	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00760	69 c0 c8 0b 00
	00		 imul	 eax, 3016		; 00000bc8H
  00766	0f b7 90 0c 00
	00 00		 movzx	 edx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  0076d	89 4d 08	 mov	 DWORD PTR tv1692[ebp], ecx
  00770	0f b7 8e f8 00
	00 00		 movzx	 ecx, WORD PTR [esi+248]
  00777	db 45 08	 fild	 DWORD PTR tv1692[ebp]
  0077a	8b d9		 mov	 ebx, ecx
  0077c	2b da		 sub	 ebx, edx
  0077e	d9 5d f0	 fstp	 DWORD PTR tv1449[ebp]

; 1117 : 	lpUser->Mana = DCInfo.DefClass[lpUser->Class].Mana + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelMana  + ((lpUser->Energy - DCInfo.DefClass[lpUser->Class].Energy ) * DCInfo.DefClass[lpUser->Class].EnergyToMana);

  00781	0f b7 96 fa 00
	00 00		 movzx	 edx, WORD PTR [esi+250]
  00788	89 5d 08	 mov	 DWORD PTR tv1687[ebp], ebx

; 1118 : 
; 1119 : 	lpUser->MaxLife = DCInfo.DefClass[lpUser->Class].Life + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelLife  + ((lpUser->Vitality - DCInfo.DefClass[lpUser->Class].Vitality ) * DCInfo.DefClass[lpUser->Class].VitalityToLife);
; 1120 : 	lpUser->MaxMana = DCInfo.DefClass[lpUser->Class].Mana + (lpUser->Level + lpUser->MLevel - 1) * DCInfo.DefClass[lpUser->Class].LevelMana  + ((lpUser->Energy - DCInfo.DefClass[lpUser->Class].Energy ) * DCInfo.DefClass[lpUser->Class].EnergyToMana);
; 1121 : 
; 1122 : 	lpUser->VitalityToLife = DCInfo.DefClass[lpUser->Class].VitalityToLife;
; 1123 : 	lpUser->EnergyToMana = DCInfo.DefClass[lpUser->Class].EnergyToMana;
; 1124 : 
; 1125 : 	::gObjSetBP(aIndex);

  0078b	57		 push	 edi
  0078c	db 45 08	 fild	 DWORD PTR tv1687[ebp]
  0078f	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  00795	d9 45 f0	 fld	 DWORD PTR tv1449[ebp]
  00798	89 55 f0	 mov	 DWORD PTR tv1496[ebp], edx
  0079b	d9 c0		 fld	 ST(0)
  0079d	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  007a3	d8 80 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  007a9	de c2		 faddp	 ST(2), ST(0)
  007ab	d9 c9		 fxch	 ST(1)
  007ad	d9 9e fc 00 00
	00		 fstp	 DWORD PTR [esi+252]
  007b3	0f b7 98 0e 00
	00 00		 movzx	 ebx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  007ba	2b d3		 sub	 edx, ebx
  007bc	89 55 08	 mov	 DWORD PTR tv1682[ebp], edx
  007bf	db 45 08	 fild	 DWORD PTR tv1682[ebp]
  007c2	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  007c8	d9 c1		 fld	 ST(1)
  007ca	d8 88 1c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  007d0	d8 80 20 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  007d6	de c1		 faddp	 ST(1), ST(0)
  007d8	d9 9e 10 01 00
	00		 fstp	 DWORD PTR [esi+272]
  007de	0f b7 90 0c 00
	00 00		 movzx	 edx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  007e5	2b ca		 sub	 ecx, edx
  007e7	89 4d 08	 mov	 DWORD PTR tv1677[ebp], ecx
  007ea	8b 4d f0	 mov	 ecx, DWORD PTR tv1496[ebp]
  007ed	db 45 08	 fild	 DWORD PTR tv1677[ebp]
  007f0	d8 88 28 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  007f6	d9 c1		 fld	 ST(1)
  007f8	d8 88 10 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  007fe	d8 80 14 00 00
	00		 fadd	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+20]
  00804	de c1		 faddp	 ST(1), ST(0)
  00806	d9 9e 00 01 00
	00		 fstp	 DWORD PTR [esi+256]
  0080c	0f b7 90 0e 00
	00 00		 movzx	 edx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  00813	2b ca		 sub	 ecx, edx
  00815	89 4d 08	 mov	 DWORD PTR tv1672[ebp], ecx
  00818	db 45 08	 fild	 DWORD PTR tv1672[ebp]
  0081b	d8 88 2c 00 00
	00		 fmul	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  00821	d9 80 1c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00827	de ca		 fmulp	 ST(2), ST(0)
  00829	d9 80 20 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+32]
  0082f	de c2		 faddp	 ST(2), ST(0)
  00831	de c1		 faddp	 ST(1), ST(0)
  00833	d9 9e 14 01 00
	00		 fstp	 DWORD PTR [esi+276]
  00839	d9 80 28 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+40]
  0083f	d9 9e 34 01 00
	00		 fstp	 DWORD PTR [esi+308]
  00845	d9 80 2c 00 00
	00		 fld	 DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+44]
  0084b	d9 9e 38 01 00
	00		 fstp	 DWORD PTR [esi+312]
  00851	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 1126 : 	lpUser->BP = lpUser->MaxBP / 2;

  00856	8b 86 2c 01 00
	00		 mov	 eax, DWORD PTR [esi+300]
  0085c	99		 cdq
  0085d	2b c2		 sub	 eax, edx
  0085f	d1 f8		 sar	 eax, 1

; 1127 : 	::gObjCalcMaxLifePower(aIndex);

  00861	57		 push	 edi
  00862	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax
  00868	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower

; 1128 : 
; 1129 : 	GCReFillSend(aIndex, (int)lpUser->MaxLife + lpUser->AddLife, 0xFE, 0, lpUser->iMaxShield + lpUser->iAddShield);

  0086d	8b 86 5c 01 00
	00		 mov	 eax, DWORD PTR [esi+348]
  00873	83 c4 14	 add	 esp, 20			; 00000014H
  00876	03 86 58 01 00
	00		 add	 eax, DWORD PTR [esi+344]
  0087c	50		 push	 eax
  0087d	6a 00		 push	 0
  0087f	68 fe 00 00 00	 push	 254			; 000000feH
  00884	d9 86 00 01 00
	00		 fld	 DWORD PTR [esi+256]
  0088a	e8 00 00 00 00	 call	 __ftol2_sse
  0088f	03 86 4c 01 00
	00		 add	 eax, DWORD PTR [esi+332]
  00895	50		 push	 eax
  00896	57		 push	 edi
  00897	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 1130 : 	//gObjSetBP(aIndex);
; 1131 : 	GCManaSend(aIndex,(int)lpUser->MaxMana + lpUser->AddMana, 0xFE, 0, lpUser->MaxBP + lpUser->AddBP);

  0089c	d9 86 14 01 00
	00		 fld	 DWORD PTR [esi+276]
  008a2	8b 8e 30 01 00
	00		 mov	 ecx, DWORD PTR [esi+304]
  008a8	03 8e 2c 01 00
	00		 add	 ecx, DWORD PTR [esi+300]
  008ae	83 c4 14	 add	 esp, 20			; 00000014H
  008b1	51		 push	 ecx
  008b2	6a 00		 push	 0
  008b4	68 fe 00 00 00	 push	 254			; 000000feH
  008b9	e8 00 00 00 00	 call	 __ftol2_sse
  008be	03 86 50 01 00
	00		 add	 eax, DWORD PTR [esi+336]
  008c4	50		 push	 eax
  008c5	57		 push	 edi
  008c6	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 1132 : 	gObjCalCharacter(aIndex);

  008cb	57		 push	 edi
  008cc	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 1133 : 
; 1134 : 	//gObjCloseSet(aIndex, 1);
; 1135 : 	ResetSystemGC_CharUpdate(lpUser);

  008d1	56		 push	 esi
  008d2	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate

; 1136 : 
; 1137 : 	GCMoneySend(aIndex, lpUser->Money);

  008d7	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  008dd	52		 push	 edx
  008de	57		 push	 edi
  008df	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 1138 : 	LogAddTD("[ResetSystem] Accaunt: %s , Name: %s , Reset: %d",lpUser->AccountID, lpUser->Name,lpUser->Reset);

  008e4	8b 86 90 22 00
	00		 mov	 eax, DWORD PTR [esi+8848]
  008ea	50		 push	 eax
  008eb	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  008ee	51		 push	 ecx
  008ef	83 c6 6c	 add	 esi, 108		; 0000006cH
  008f2	56		 push	 esi
  008f3	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HFHBLLAG@?$FLResetSystem?$FN?5Accaunt?3?5?$CFs?5?0?5Name@
  008f8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  008fe	83 c4 34	 add	 esp, 52			; 00000034H

; 1139 : 
; 1140 : #if(SYSTEM_ACHIEVEMENTS)
; 1141 : 	g_Achievements.ResetUp(aIndex);

  00901	57		 push	 edi
  00902	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00907	e8 00 00 00 00	 call	 ?ResetUp@CAchievements@@QAEXH@Z ; CAchievements::ResetUp
  0090c	5f		 pop	 edi
  0090d	5e		 pop	 esi
$LN84@CGResulInf:
  0090e	5b		 pop	 ebx

; 1142 : #endif
; 1143 : }

  0090f	8b e5		 mov	 esp, ebp
  00911	5d		 pop	 ebp
  00912	c2 04 00	 ret	 4
  00915	8d 49 00	 npad	 3
$LN118@CGResulInf:
  00918	00 00 00 00	 DD	 $LN50@CGResulInf
  0091c	00 00 00 00	 DD	 $LN49@CGResulInf
  00920	00 00 00 00	 DD	 $LN48@CGResulInf
  00924	00 00 00 00	 DD	 $LN47@CGResulInf
  00928	00 00 00 00	 DD	 $LN46@CGResulInf
  0092c	00 00 00 00	 DD	 $LN45@CGResulInf
  00930	00 00 00 00	 DD	 $LN44@CGResulInf
$LN119@CGResulInf:
  00934	00 00 00 00	 DD	 $LN36@CGResulInf
  00938	00 00 00 00	 DD	 $LN35@CGResulInf
  0093c	00 00 00 00	 DD	 $LN34@CGResulInf
  00940	00 00 00 00	 DD	 $LN33@CGResulInf
  00944	00 00 00 00	 DD	 $LN32@CGResulInf
  00948	00 00 00 00	 DD	 $LN31@CGResulInf
  0094c	00 00 00 00	 DD	 $LN30@CGResulInf
$LN120@CGResulInf:
  00950	00 00 00 00	 DD	 $LN26@CGResulInf
  00954	00 00 00 00	 DD	 $LN25@CGResulInf
  00958	00 00 00 00	 DD	 $LN24@CGResulInf
  0095c	00 00 00 00	 DD	 $LN23@CGResulInf
  00960	00 00 00 00	 DD	 $LN22@CGResulInf
  00964	00 00 00 00	 DD	 $LN21@CGResulInf
  00968	00 00 00 00	 DD	 $LN20@CGResulInf
?CGResulInfo@cResetSystem@@QAEXH@Z ENDP			; cResetSystem::CGResulInfo
_TEXT	ENDS
PUBLIC	?CGResetMenu@cResetSystem@@QAEXH@Z		; cResetSystem::CGResetMenu
; Function compile flags: /Ogtp
;	COMDAT ?CGResetMenu@cResetSystem@@QAEXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGResetMenu@cResetSystem@@QAEXH@Z PROC			; cResetSystem::CGResetMenu, COMDAT
; _this$ = ecx

; 1199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1200 : 	if( !g_ZtLicense.CheckUser(eZtUB::Local) && 
; 1201 : 		!g_ZtLicense.CheckUser(eZtUB::Gredy) &&
; 1202 : 		!g_ZtLicense.CheckUser(eZtUB::Gredy2) && 
; 1203 : 		!g_ZtLicense.CheckUser(eZtUB::GredyLocal) &&
; 1204 : 		!g_ZtLicense.CheckUser(eZtUB::MedoniAndrei) &&
; 1205 : 		!g_ZtLicense.CheckUser(eZtUB::MUCustom) &&
; 1206 : 		!g_ZtLicense.CheckUser(eZtUB::AsteraMU))

  00006	6a 00		 push	 0
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00012	84 c0		 test	 al, al
  00014	75 60		 jne	 SHORT $LN1@CGResetMen
  00016	6a 20		 push	 32			; 00000020H
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0001d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00022	84 c0		 test	 al, al
  00024	75 50		 jne	 SHORT $LN1@CGResetMen
  00026	6a 22		 push	 34			; 00000022H
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0002d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00032	84 c0		 test	 al, al
  00034	75 40		 jne	 SHORT $LN1@CGResetMen
  00036	6a 21		 push	 33			; 00000021H
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0003d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00042	84 c0		 test	 al, al
  00044	75 30		 jne	 SHORT $LN1@CGResetMen
  00046	6a 32		 push	 50			; 00000032H
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0004d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00052	84 c0		 test	 al, al
  00054	75 20		 jne	 SHORT $LN1@CGResetMen
  00056	6a 55		 push	 85			; 00000055H
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0005d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00062	84 c0		 test	 al, al
  00064	75 10		 jne	 SHORT $LN1@CGResetMen
  00066	6a 62		 push	 98			; 00000062H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0006d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00072	84 c0		 test	 al, al
  00074	74 0b		 je	 SHORT $LN2@CGResetMen
$LN1@CGResetMen:

; 1207 : 	{
; 1208 : 		return;
; 1209 : 	}
; 1210 : 
; 1211 : 	this->GCDialogInfo(aIndex);

  00076	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00079	50		 push	 eax
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?GCDialogInfo@cResetSystem@@QAEXH@Z ; cResetSystem::GCDialogInfo
$LN2@CGResetMen:
  00081	5e		 pop	 esi

; 1212 : }

  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?CGResetMenu@cResetSystem@@QAEXH@Z ENDP			; cResetSystem::CGResetMenu
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z PROC ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@V?$allocator@URESET_NEEDITEM_DATA@@@1@@Z ENDP ; std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z PROC ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@V?$allocator@URESET_REWARD_DATA@@@1@@Z ENDP ; std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1275 : 		size_type _Capacity = capacity();

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	2b 31		 sub	 esi, DWORD PTR [ecx]
  00009	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000e	f7 ee		 imul	 esi
  00010	03 d6		 add	 edx, esi
  00012	c1 fa 04	 sar	 edx, 4
  00015	8b c2		 mov	 eax, edx
  00017	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001a	03 c2		 add	 eax, edx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0001c	8b c8		 mov	 ecx, eax
  0001e	d1 e9		 shr	 ecx, 1
  00020	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  00025	2b d1		 sub	 edx, ecx
  00027	5e		 pop	 esi
  00028	3b d0		 cmp	 edx, eax
  0002a	73 04		 jae	 SHORT $LN4@Grow_to
  0002c	33 c0		 xor	 eax, eax
  0002e	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00030	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00035	3b c1		 cmp	 eax, ecx
  00037	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00039	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Grow_to@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	2b 11		 sub	 edx, DWORD PTR [ecx]
  00008	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0000d	f7 ea		 imul	 edx
  0000f	c1 fa 03	 sar	 edx, 3
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00019	8b c8		 mov	 ecx, eax
  0001b	d1 e9		 shr	 ecx, 1
  0001d	ba c7 71 1c 07	 mov	 edx, 119304647		; 071c71c7H
  00022	2b d1		 sub	 edx, ecx
  00024	3b d0		 cmp	 edx, eax
  00026	73 04		 jae	 SHORT $LN4@Grow_to@2
  00028	33 c0		 xor	 eax, eax
  0002a	eb 02		 jmp	 SHORT $LN5@Grow_to@2
$LN4@Grow_to@2:
  0002c	03 c1		 add	 eax, ecx
$LN5@Grow_to@2:

; 1279 : 		if (_Capacity < _Count)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	3b c1		 cmp	 eax, ecx
  00033	73 02		 jae	 SHORT $LN1@Grow_to@2

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00035	8b c1		 mov	 eax, ecx
$LN1@Grow_to@2:

; 1282 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Grow_to@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@2
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@2:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ; std::_Allocate<RESET_NEEDITEM_DATA>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T216474 = -12						; size = 12
$T216479 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z PROC ; std::_Allocate<RESET_NEEDITEM_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 4a		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN1@Allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002f	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T216479[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T216474[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216479[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T216474[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216474[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@URESET_NEEDITEM_DATA@@@std@@YAPAURESET_NEEDITEM_DATA@@IPAU1@@Z ENDP ; std::_Allocate<RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z ; std::_Allocate<RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z
_TEXT	SEGMENT
$T216487 = -12						; size = 12
$T216491 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z PROC ; std::_Allocate<RESET_REWARD_DATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 14		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T216491[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T216487[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216491[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T216487[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216487[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@URESET_REWARD_DATA@@@std@@YAPAURESET_REWARD_DATA@@IPAU1@@Z ENDP ; std::_Allocate<RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 197  : 		_Construct(_Ptr, _Val);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN5@construct@3
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN5@construct@3:
  00017	5f		 pop	 edi

; 198  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@ABU3@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z ; std::allocator<RESET_REWARD_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z PROC ; std::allocator<RESET_REWARD_DATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 197  : 		_Construct(_Ptr, _Val);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN5@construct@4
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN5@construct@4:
  00017	5f		 pop	 edi

; 198  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@ABU3@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::construct
_TEXT	ENDS
PUBLIC	??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 19		 je	 SHORT $LN1@Move
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax
  00017	83 c2 1c	 add	 edx, 28			; 0000001cH
  0001a	b9 07 00 00 00	 mov	 ecx, 7
  0001f	83 c0 1c	 add	 eax, 28			; 0000001cH
  00022	f3 a5		 rep movsd
  00024	3b d3		 cmp	 edx, ebx
  00026	75 eb		 jne	 SHORT $LL3@Move
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$LN1@Move:
  0002a	5b		 pop	 ebx

; 2515 : 	return (_Dest);
; 2516 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 19		 je	 SHORT $LN1@Move@2
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL3@Move@2:

; 2514 : 		*_Dest = _STD move(*_First);

  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax
  00017	83 c2 24	 add	 edx, 36			; 00000024H
  0001a	b9 09 00 00 00	 mov	 ecx, 9
  0001f	83 c0 24	 add	 eax, 36			; 00000024H
  00022	f3 a5		 rep movsd
  00024	3b d3		 cmp	 edx, ebx
  00026	75 eb		 jne	 SHORT $LL3@Move@2
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$LN1@Move@2:
  0002a	5b		 pop	 ebx

; 2515 : 	return (_Dest);
; 2516 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ; std::allocator<RESET_NEEDITEM_DATA>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z ; std::allocator<RESET_REWARD_DATA>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z PROC ; std::allocator<RESET_REWARD_DATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ; std::allocator<RESET_NEEDITEM_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@5
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@5:
  00017	5f		 pop	 edi

; 203  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEXPAURESET_NEEDITEM_DATA@@$$QAU3@@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::construct
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z ; std::allocator<RESET_REWARD_DATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z PROC ; std::allocator<RESET_REWARD_DATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN3@construct@6
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN3@construct@6:
  00017	5f		 pop	 edi

; 203  : 		}

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?construct@?$allocator@URESET_REWARD_DATA@@@std@@QAEXPAURESET_REWARD_DATA@@$$QAU3@@Z ENDP ; std::allocator<RESET_REWARD_DATA>::construct
_TEXT	ENDS
PUBLIC	?NpcDialog@cResetSystem@@QAE_NHH@Z		; cResetSystem::NpcDialog
EXTRN	?GetCustom@CZtLicense@@QAEHXZ:PROC		; CZtLicense::GetCustom
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\reset.cpp
;	COMDAT ?NpcDialog@cResetSystem@@QAE_NHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_aNpcIndex$ = 12					; size = 4
?NpcDialog@cResetSystem@@QAE_NHH@Z PROC			; cResetSystem::NpcDialog, COMDAT
; _this$ = ecx

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 547  : 	if( !g_ZtLicense.CheckUser(eZtUB::Local) && 
; 548  : 		!g_ZtLicense.CheckUser(eZtUB::ulasevich) && 
; 549  : 		!g_ZtLicense.CheckUser(eZtUB::ulasevich2)&& 
; 550  : 		!g_ZtLicense.CheckUser(eZtUB::MU2Play)  && 
; 551  : 		!g_ZtLicense.CheckUser(eZtUB::Sentinel) &&
; 552  : 		!g_ZtLicense.CheckUser(eZtUB::EpicMU) && 
; 553  : 		!g_ZtLicense.CheckUser(eZtUB::Escalate) &&
; 554  : 		!g_ZtLicense.CheckUser(eZtUB::Artem) && 
; 555  : 		!g_ZtLicense.CheckUser(eZtUB::Artem2) &&
; 556  : 		!g_ZtLicense.CheckUser(eZtUB::RevoMU) &&
; 557  : 		!g_ZtLicense.CheckUser(eZtUB::GloryMU) &&
; 558  : 		!g_ZtLicense.CheckUser(eZtUB::MedoniAndrei)&&
; 559  : 		!g_ZtLicense.CheckUser(eZtUB::mu4you) &&
; 560  : 		!g_ZtLicense.CheckUser(eZtUB::eternalmu) &&
; 561  : 		!g_ZtLicense.CheckUser(eZtUB::NSGames) &&
; 562  : 		!g_ZtLicense.CheckUser(eZtUB::MUCustom) &&
; 563  : 		!g_ZtLicense.CheckUser(eZtUB::AsteraMU))

  00006	6a 00		 push	 0
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00012	84 c0		 test	 al, al
  00014	0f 85 36 01 00
	00		 jne	 $LN4@NpcDialog
  0001a	6a 17		 push	 23			; 00000017H
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00021	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00026	84 c0		 test	 al, al
  00028	0f 85 22 01 00
	00		 jne	 $LN4@NpcDialog
  0002e	6a 24		 push	 36			; 00000024H
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00035	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0003a	84 c0		 test	 al, al
  0003c	0f 85 0e 01 00
	00		 jne	 $LN4@NpcDialog
  00042	6a 36		 push	 54			; 00000036H
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00049	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0004e	84 c0		 test	 al, al
  00050	0f 85 fa 00 00
	00		 jne	 $LN4@NpcDialog
  00056	6a 38		 push	 56			; 00000038H
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0005d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00062	84 c0		 test	 al, al
  00064	0f 85 e6 00 00
	00		 jne	 $LN4@NpcDialog
  0006a	6a 3b		 push	 59			; 0000003bH
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00071	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00076	84 c0		 test	 al, al
  00078	0f 85 d2 00 00
	00		 jne	 $LN4@NpcDialog
  0007e	6a 40		 push	 64			; 00000040H
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00085	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0008a	84 c0		 test	 al, al
  0008c	0f 85 be 00 00
	00		 jne	 $LN4@NpcDialog
  00092	6a 30		 push	 48			; 00000030H
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00099	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0009e	84 c0		 test	 al, al
  000a0	0f 85 aa 00 00
	00		 jne	 $LN4@NpcDialog
  000a6	6a 31		 push	 49			; 00000031H
  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000ad	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000b2	84 c0		 test	 al, al
  000b4	0f 85 96 00 00
	00		 jne	 $LN4@NpcDialog
  000ba	6a 43		 push	 67			; 00000043H
  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000c1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000c6	84 c0		 test	 al, al
  000c8	0f 85 82 00 00
	00		 jne	 $LN4@NpcDialog
  000ce	6a 46		 push	 70			; 00000046H
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000d5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000da	84 c0		 test	 al, al
  000dc	75 72		 jne	 SHORT $LN4@NpcDialog
  000de	6a 32		 push	 50			; 00000032H
  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000e5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000ea	84 c0		 test	 al, al
  000ec	75 62		 jne	 SHORT $LN4@NpcDialog
  000ee	6a 4e		 push	 78			; 0000004eH
  000f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000f5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000fa	84 c0		 test	 al, al
  000fc	75 52		 jne	 SHORT $LN4@NpcDialog
  000fe	6a 4f		 push	 79			; 0000004fH
  00100	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00105	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0010a	84 c0		 test	 al, al
  0010c	75 42		 jne	 SHORT $LN4@NpcDialog
  0010e	6a 51		 push	 81			; 00000051H
  00110	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00115	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0011a	84 c0		 test	 al, al
  0011c	75 32		 jne	 SHORT $LN4@NpcDialog
  0011e	6a 55		 push	 85			; 00000055H
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00125	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0012a	84 c0		 test	 al, al
  0012c	75 22		 jne	 SHORT $LN4@NpcDialog
  0012e	6a 62		 push	 98			; 00000062H
  00130	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00135	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0013a	84 c0		 test	 al, al
  0013c	75 12		 jne	 SHORT $LN4@NpcDialog

; 564  : 	{
; 565  : 		if(!g_ZtLicense.GetCustom())

  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00143	e8 00 00 00 00	 call	 ?GetCustom@CZtLicense@@QAEHXZ ; CZtLicense::GetCustom
  00148	85 c0		 test	 eax, eax

; 566  : 		{
; 567  : 			return false;

  0014a	0f 84 95 00 00
	00		 je	 $LN1@NpcDialog
$LN4@NpcDialog:

; 568  : 		}
; 569  : 	}
; 570  : 
; 571  : 	if(!OBJMAX_RANGE(aIndex) && !OBJMAX_RANGE(aNpcIndex))

  00150	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00153	8b 45 0c	 mov	 eax, DWORD PTR _aNpcIndex$[ebp]
  00156	85 d2		 test	 edx, edx
  00158	78 0f		 js	 SHORT $LN12@NpcDialog
  0015a	33 c9		 xor	 ecx, ecx
  0015c	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00162	0f 9e c1	 setle	 cl
  00165	85 c9		 test	 ecx, ecx
  00167	75 12		 jne	 SHORT $LN3@NpcDialog
$LN12@NpcDialog:
  00169	85 c0		 test	 eax, eax
  0016b	78 78		 js	 SHORT $LN1@NpcDialog
  0016d	33 c9		 xor	 ecx, ecx
  0016f	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00174	0f 9e c1	 setle	 cl
  00177	85 c9		 test	 ecx, ecx

; 572  : 	{
; 573  : 		return false;

  00179	74 6a		 je	 SHORT $LN1@NpcDialog
$LN3@NpcDialog:

; 574  : 	}
; 575  : 
; 576  : 	LPOBJ lpUser = &gObj[aIndex];
; 577  : 	LPOBJ lpNpc = &gObj[aNpcIndex];

  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00181	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00187	57		 push	 edi
  00188	8b fa		 mov	 edi, edx
  0018a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00190	03 c1		 add	 eax, ecx

; 578  : 
; 579  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00192	83 7c 0f 04 03	 cmp	 DWORD PTR [edi+ecx+4], 3
  00197	5f		 pop	 edi

; 580  : 	{
; 581  : 		return false;

  00198	7c 4b		 jl	 SHORT $LN1@NpcDialog

; 582  : 	}
; 583  : 
; 584  : 	if(lpNpc->Class		== this->Reset_NPC_ID  &&
; 585  : 	   lpNpc->MapNumber	== this->Reset_NPC_MAP &&
; 586  : 	   lpNpc->X			== this->Reset_NPC_X   &&
; 587  : 	   lpNpc->Y			== this->Reset_NPC_Y )

  0019a	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  001a1	3b 8e c8 7d 00
	00		 cmp	 ecx, DWORD PTR [esi+32200]
  001a7	75 3c		 jne	 SHORT $LN1@NpcDialog
  001a9	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  001b0	3b 8e cc 7d 00
	00		 cmp	 ecx, DWORD PTR [esi+32204]
  001b6	75 2d		 jne	 SHORT $LN1@NpcDialog
  001b8	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  001bf	3b 8e d0 7d 00
	00		 cmp	 ecx, DWORD PTR [esi+32208]
  001c5	75 1e		 jne	 SHORT $LN1@NpcDialog
  001c7	0f bf 80 46 01
	00 00		 movsx	 eax, WORD PTR [eax+326]
  001ce	3b 86 d4 7d 00
	00		 cmp	 eax, DWORD PTR [esi+32212]
  001d4	75 0f		 jne	 SHORT $LN1@NpcDialog

; 588  : 	{
; 589  : 		this->GCDialogInfo(aIndex);

  001d6	52		 push	 edx
  001d7	8b ce		 mov	 ecx, esi
  001d9	e8 00 00 00 00	 call	 ?GCDialogInfo@cResetSystem@@QAEXH@Z ; cResetSystem::GCDialogInfo

; 590  : 		return true;

  001de	b0 01		 mov	 al, 1
  001e0	5e		 pop	 esi

; 594  : }

  001e1	5d		 pop	 ebp
  001e2	c2 08 00	 ret	 8
$LN1@NpcDialog:

; 591  : 	}
; 592  : 
; 593  : 	return false;

  001e5	32 c0		 xor	 al, al
  001e7	5e		 pop	 esi

; 594  : }

  001e8	5d		 pop	 ebp
  001e9	c2 08 00	 ret	 8
?NpcDialog@cResetSystem@@QAE_NHH@Z ENDP			; cResetSystem::NpcDialog
_TEXT	ENDS
PUBLIC	??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QAE@PAURESET_NEEDITEM_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QAE@PAURESET_REWARD_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::_Vector_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z
_TEXT	SEGMENT
$T216693 = -12						; size = 12
$T216685 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z PROC ; std::allocator<RESET_NEEDITEM_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 4a		 je	 SHORT $LN1@allocate
  0000f	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00015	77 1a		 ja	 SHORT $LN3@allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	2b c1		 sub	 eax, ecx
  00020	03 c0		 add	 eax, eax
  00022	03 c0		 add	 eax, eax
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00031	8d 4d 08	 lea	 ecx, DWORD PTR $T216685[ebp]
  00034	51		 push	 ecx
  00035	8d 4d f4	 lea	 ecx, DWORD PTR $T216693[ebp]
  00038	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216685[ebp], 0
  0003f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00044	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00049	8d 55 f4	 lea	 edx, DWORD PTR $T216693[ebp]
  0004c	52		 push	 edx
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216693[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ENDP ; std::allocator<RESET_NEEDITEM_DATA>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z
_TEXT	SEGMENT
$T216716 = -12						; size = 12
$T216708 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z PROC ; std::allocator<RESET_REWARD_DATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 14		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T216708[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T216716[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T216708[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T216716[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T216716[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z ENDP ; std::allocator<RESET_REWARD_DATA>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN9@Cons_val@3
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN9@Cons_val@3:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN9@Cons_val@4
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN9@Cons_val@4:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z PROC ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 19		 je	 SHORT $LN5@Move@3
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL7@Move@3:
  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax
  00017	83 c2 1c	 add	 edx, 28			; 0000001cH
  0001a	b9 07 00 00 00	 mov	 ecx, 7
  0001f	83 c0 1c	 add	 eax, 28			; 0000001cH
  00022	f3 a5		 rep movsd
  00024	3b d3		 cmp	 edx, ebx
  00026	75 eb		 jne	 SHORT $LL7@Move@3
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$LN5@Move@3:
  0002a	5b		 pop	 ebx

; 2536 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Move@PAURESET_NEEDITEM_DATA@@PAU1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00@Z ENDP ; std::_Move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z PROC ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	3b d3		 cmp	 edx, ebx
  0000f	74 19		 je	 SHORT $LN5@Move@4
  00011	56		 push	 esi
  00012	57		 push	 edi
$LL7@Move@4:
  00013	8b f2		 mov	 esi, edx
  00015	8b f8		 mov	 edi, eax
  00017	83 c2 24	 add	 edx, 36			; 00000024H
  0001a	b9 09 00 00 00	 mov	 ecx, 9
  0001f	83 c0 24	 add	 eax, 36			; 00000024H
  00022	f3 a5		 rep movsd
  00024	3b d3		 cmp	 edx, ebx
  00026	75 eb		 jne	 SHORT $LL7@Move@4
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
$LN5@Move@4:
  0002a	5b		 pop	 ebx

; 2536 : 	}

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Move@PAURESET_REWARD_DATA@@PAU1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00@Z ENDP ; std::_Move<RESET_REWARD_DATA *,RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z PROC ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z PROC ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@5
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@5:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Pdest$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 0c		 je	 SHORT $LN7@Cons_val@6
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR __Src$[ebp]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	f3 a5		 rep movsd
  00016	5e		 pop	 esi
$LN7@Cons_val@6:
  00017	5f		 pop	 edi

; 281  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin
; Function compile flags: /Ogtp
;	COMDAT ?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@U3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA>
  0001e	83 c6 1c	 add	 esi, 28			; 0000001cH
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 1c	 add	 edi, 28			; 0000001cH
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov@2
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov@2:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@U3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA>
  0001e	83 c6 24	 add	 esi, 36			; 00000024H
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 24	 add	 edi, 36			; 00000024H
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov@2

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov@2:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAXPAURESET_NEEDITEM_DATA@@0AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAXPAURESET_REWARD_DATA@@0AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z
_TEXT	SEGMENT
__Cat$217073 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$217073[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z
_TEXT	SEGMENT
__Cat$217083 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$217083[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXPAURESET_NEEDITEM_DATA@@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXPAURESET_REWARD_DATA@@0@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$217109 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$217109[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURESET_NEEDITEM_DATA@@@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEPAURESET_NEEDITEM_DATA@@PAU2@00@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Umove<RESET_NEEDITEM_DATA *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$217128 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$217128[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAURESET_REWARD_DATA@@@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEPAURESET_REWARD_DATA@@PAU2@00@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Umove<RESET_REWARD_DATA *>
_TEXT	ENDS
PUBLIC	?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR __First_arg$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00012	89 1e		 mov	 DWORD PTR [esi], ebx
  00014	3b da		 cmp	 ebx, edx
  00016	74 27		 je	 SHORT $LN39@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00018	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001b	3b d0		 cmp	 edx, eax
  0001d	74 1d		 je	 SHORT $LN30@erase
  0001f	57		 push	 edi
$LL32@erase:
  00020	8b f2		 mov	 esi, edx
  00022	8b fb		 mov	 edi, ebx
  00024	83 c2 1c	 add	 edx, 28			; 0000001cH
  00027	b9 07 00 00 00	 mov	 ecx, 7
  0002c	83 c3 1c	 add	 ebx, 28			; 0000001cH
  0002f	f3 a5		 rep movsd
  00031	3b d0		 cmp	 edx, eax
  00033	75 eb		 jne	 SHORT $LL32@erase
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	5f		 pop	 edi
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  0003c	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN39@erase:

; 1212 : 			}
; 1213 : 		return (_First);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 1214 : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR __First_arg$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00012	89 1e		 mov	 DWORD PTR [esi], ebx
  00014	3b da		 cmp	 ebx, edx
  00016	74 27		 je	 SHORT $LN39@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00018	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001b	3b d0		 cmp	 edx, eax
  0001d	74 1d		 je	 SHORT $LN30@erase@2
  0001f	57		 push	 edi
$LL32@erase@2:
  00020	8b f2		 mov	 esi, edx
  00022	8b fb		 mov	 edi, ebx
  00024	83 c2 24	 add	 edx, 36			; 00000024H
  00027	b9 09 00 00 00	 mov	 ecx, 9
  0002c	83 c3 24	 add	 ebx, 36			; 00000024H
  0002f	f3 a5		 rep movsd
  00031	3b d0		 cmp	 edx, eax
  00033	75 eb		 jne	 SHORT $LL32@erase@2
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	5f		 pop	 edi
$LN30@erase@2:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  0003c	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN39@erase@2:

; 1212 : 			}
; 1213 : 		return (_First);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 1214 : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$214619 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$217413 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	81 fb 49 92 24
	09		 cmp	 ebx, 153391689		; 09249249H
  00036	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00047	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0004c	f7 e9		 imul	 ecx
  0004e	03 d1		 add	 edx, ecx
  00050	c1 fa 04	 sar	 edx, 4
  00053	8b c2		 mov	 eax, edx
  00055	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00058	03 c2		 add	 eax, edx
  0005a	3b c3		 cmp	 eax, ebx
  0005c	73 79		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005e	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00061	53		 push	 ebx
  00062	8b cf		 mov	 ecx, edi
  00064	e8 00 00 00 00	 call	 ?allocate@?$allocator@URESET_NEEDITEM_DATA@@@std@@QAEPAURESET_NEEDITEM_DATA@@I@Z ; std::allocator<RESET_NEEDITEM_DATA>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00069	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$217413[ebp]
  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	53		 push	 ebx
  00072	6a 00		 push	 0
  00074	57		 push	 edi
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	52		 push	 edx
  00078	89 45 ec	 mov	 DWORD PTR __Ptr$214619[ebp], eax
  0007b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00082	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_NEEDITEM_DATA@@PAU1@V?$allocator@URESET_NEEDITEM_DATA@@@std@@U1@@std@@YAPAURESET_NEEDITEM_DATA@@PAU1@00AAV?$allocator@URESET_NEEDITEM_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_NEEDITEM_DATA *,RESET_NEEDITEM_DATA *,std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00087	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00089	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008c	2b cb		 sub	 ecx, ebx
  0008e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00093	f7 e9		 imul	 ecx
  00095	03 d1		 add	 edx, ecx
  00097	c1 fa 04	 sar	 edx, 4
  0009a	8b fa		 mov	 edi, edx
  0009c	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0009f	83 c4 18	 add	 esp, 24			; 00000018H
  000a2	03 fa		 add	 edi, edx

; 761  : 			if (this->_Myfirst != 0)

  000a4	85 db		 test	 ebx, ebx
  000a6	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000a8	53		 push	 ebx
  000a9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ae	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  000b1	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000b4	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000bb	2b c8		 sub	 ecx, eax
  000bd	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214619[ebp]
  000c0	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]

; 770  : 			this->_Mylast = _Ptr + _Size;

  000c3	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  000ca	2b cf		 sub	 ecx, edi
  000cc	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000cf	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  000d2	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000d5	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
__catch$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000eb	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214619[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f4	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  00100	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
PUBLIC	?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$214660 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$217499 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	81 fb c7 71 1c
	07		 cmp	 ebx, 119304647		; 071c71c7H
  00036	76 0a		 jbe	 SHORT $LN5@reserve@2

; 748  : 			_Xlen();	// result too long

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve@2:
$LN5@reserve@2:

; 749  : 		else if (capacity() < _Count)

  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00047	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0004c	f7 e9		 imul	 ecx
  0004e	c1 fa 03	 sar	 edx, 3
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00056	03 c2		 add	 eax, edx
  00058	3b c3		 cmp	 eax, ebx
  0005a	73 6b		 jae	 SHORT $LN3@reserve@2

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005c	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  0005f	53		 push	 ebx
  00060	8b cf		 mov	 ecx, edi
  00062	e8 00 00 00 00	 call	 ?allocate@?$allocator@URESET_REWARD_DATA@@@std@@QAEPAURESET_REWARD_DATA@@I@Z ; std::allocator<RESET_REWARD_DATA>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00067	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$217499[ebp]
  0006a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006d	8b 16		 mov	 edx, DWORD PTR [esi]
  0006f	53		 push	 ebx
  00070	6a 00		 push	 0
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	52		 push	 edx
  00076	89 45 ec	 mov	 DWORD PTR __Ptr$214660[ebp], eax
  00079	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00080	e8 00 00 00 00	 call	 ??$_Uninit_move@PAURESET_REWARD_DATA@@PAU1@V?$allocator@URESET_REWARD_DATA@@@std@@U1@@std@@YAPAURESET_REWARD_DATA@@PAU1@00AAV?$allocator@URESET_REWARD_DATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<RESET_REWARD_DATA *,RESET_REWARD_DATA *,std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00085	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00087	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008a	2b cb		 sub	 ecx, ebx
  0008c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00091	f7 e9		 imul	 ecx
  00093	c1 fa 03	 sar	 edx, 3
  00096	8b fa		 mov	 edi, edx
  00098	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0009b	83 c4 18	 add	 esp, 24			; 00000018H
  0009e	03 fa		 add	 edi, edx

; 761  : 			if (this->_Myfirst != 0)

  000a0	85 db		 test	 ebx, ebx
  000a2	74 09		 je	 SHORT $LN35@reserve@2

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$LN35@reserve@2:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  000ad	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000b0	8d 0c c0	 lea	 ecx, DWORD PTR [eax+eax*8]
  000b3	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214660[ebp]
  000b6	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]

; 770  : 			this->_Mylast = _Ptr + _Size;

  000b9	8d 0c ff	 lea	 ecx, DWORD PTR [edi+edi*8]
  000bc	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000bf	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  000c2	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000c5	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve@2:

; 772  : 			}
; 773  : 		}

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d1	59		 pop	 ecx
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
__catch$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000db	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$214660[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e4	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve@2:
$LN41@reserve@2:
  000f0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve
PUBLIC	??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::~vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	53		 push	 ebx
  00008	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	3b da		 cmp	 ebx, edx
  0000f	74 2c		 je	 SHORT $LN19@clear
  00011	8b c2		 mov	 eax, edx
  00013	3b d2		 cmp	 edx, edx
  00015	74 23		 je	 SHORT $LN48@clear
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL50@clear:
  00020	8b f0		 mov	 esi, eax
  00022	8b fb		 mov	 edi, ebx
  00024	83 c0 1c	 add	 eax, 28			; 0000001cH
  00027	b9 07 00 00 00	 mov	 ecx, 7
  0002c	83 c3 1c	 add	 ebx, 28			; 0000001cH
  0002f	f3 a5		 rep movsd
  00031	3b c2		 cmp	 eax, edx
  00033	75 eb		 jne	 SHORT $LL50@clear
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
$LN48@clear:
  0003a	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN19@clear:
  0003d	5b		 pop	 ebx

; 1219 : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?clear@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@3
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@3:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::~vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1218 : 		erase(begin(), end());

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	53		 push	 ebx
  00008	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	3b da		 cmp	 ebx, edx
  0000f	74 2c		 je	 SHORT $LN19@clear@2
  00011	8b c2		 mov	 eax, edx
  00013	3b d2		 cmp	 edx, edx
  00015	74 23		 je	 SHORT $LN48@clear@2
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL50@clear@2:
  00020	8b f0		 mov	 esi, eax
  00022	8b fb		 mov	 edi, ebx
  00024	83 c0 24	 add	 eax, 36			; 00000024H
  00027	b9 09 00 00 00	 mov	 ecx, 9
  0002c	83 c3 24	 add	 ebx, 36			; 00000024H
  0002f	f3 a5		 rep movsd
  00031	3b c2		 cmp	 eax, edx
  00033	75 eb		 jne	 SHORT $LL50@clear@2
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
$LN48@clear@2:
  0003a	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN19@clear@2:
  0003d	5b		 pop	 ebx

; 1219 : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?clear@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1291 : 		size_type _Size = size();

  00004	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00006	56		 push	 esi
  00007	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000a	2b f3		 sub	 esi, ebx
  0000c	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00011	f7 ee		 imul	 esi

; 1292 : 		if (max_size() - _Count < _Size)

  00013	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00016	03 d6		 add	 edx, esi
  00018	c1 fa 04	 sar	 edx, 4
  0001b	8b f2		 mov	 esi, edx
  0001d	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00020	03 f2		 add	 esi, edx
  00022	ba 49 92 24 09	 mov	 edx, 153391689		; 09249249H
  00027	2b d0		 sub	 edx, eax
  00029	57		 push	 edi
  0002a	3b d6		 cmp	 edx, esi
  0002c	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00033	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00038	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  0003b	03 f0		 add	 esi, eax
  0003d	2b fb		 sub	 edi, ebx
  0003f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00044	f7 ef		 imul	 edi
  00046	03 d7		 add	 edx, edi
  00048	c1 fa 04	 sar	 edx, 4
  0004b	8b c2		 mov	 eax, edx
  0004d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00050	03 c2		 add	 eax, edx
  00052	3b f0		 cmp	 esi, eax
  00054	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00056	8b d0		 mov	 edx, eax
  00058	d1 ea		 shr	 edx, 1
  0005a	bf 49 92 24 09	 mov	 edi, 153391689		; 09249249H
  0005f	2b fa		 sub	 edi, edx
  00061	3b f8		 cmp	 edi, eax
  00063	73 04		 jae	 SHORT $LN23@Reserve
  00065	33 c0		 xor	 eax, eax
  00067	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00069	03 c2		 add	 eax, edx
$LN24@Reserve:
  0006b	3b c6		 cmp	 eax, esi
  0006d	73 02		 jae	 SHORT $LN20@Reserve
  0006f	8b c6		 mov	 eax, esi
$LN20@Reserve:
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::reserve
$LN1@Reserve:
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 1298 : 		}

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000a	2b d7		 sub	 edx, edi
  0000c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00011	f7 ea		 imul	 edx

; 1292 : 		if (max_size() - _Count < _Size)

  00013	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00016	c1 fa 03	 sar	 edx, 3
  00019	8b f2		 mov	 esi, edx
  0001b	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001e	03 f2		 add	 esi, edx
  00020	ba c7 71 1c 07	 mov	 edx, 119304647		; 071c71c7H
  00025	2b d0		 sub	 edx, eax
  00027	3b d6		 cmp	 edx, esi
  00029	73 0a		 jae	 SHORT $LN4@Reserve@2

; 1293 : 			_Xlen();

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00030	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve@2:
$LN4@Reserve@2:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	03 f0		 add	 esi, eax
  0003a	2b d7		 sub	 edx, edi
  0003c	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00041	f7 ea		 imul	 edx
  00043	c1 fa 03	 sar	 edx, 3
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	3b f0		 cmp	 esi, eax
  0004f	76 21		 jbe	 SHORT $LN1@Reserve@2

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00051	8b d0		 mov	 edx, eax
  00053	d1 ea		 shr	 edx, 1
  00055	bf c7 71 1c 07	 mov	 edi, 119304647		; 071c71c7H
  0005a	2b fa		 sub	 edi, edx
  0005c	3b f8		 cmp	 edi, eax
  0005e	73 04		 jae	 SHORT $LN23@Reserve@2
  00060	33 c0		 xor	 eax, eax
  00062	eb 02		 jmp	 SHORT $LN24@Reserve@2
$LN23@Reserve@2:
  00064	03 c2		 add	 eax, edx
$LN24@Reserve@2:
  00066	3b c6		 cmp	 eax, esi
  00068	73 02		 jae	 SHORT $LN20@Reserve@2
  0006a	8b c6		 mov	 eax, esi
$LN20@Reserve@2:
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::reserve
$LN1@Reserve@2:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 1298 : 		}

  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
$LN33@Reserve@2:
?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
_TEXT	ENDS
PUBLIC	??0cResetSystem@@QAE@XZ				; cResetSystem::cResetSystem
; Function compile flags: /Ogtp
;	COMDAT ??0cResetSystem@@QAE@XZ
_TEXT	SEGMENT
??0cResetSystem@@QAE@XZ PROC				; cResetSystem::cResetSystem, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 88 d8 7d 00
	00		 mov	 DWORD PTR [eax+32216], ecx
  0000a	89 88 dc 7d 00
	00		 mov	 DWORD PTR [eax+32220], ecx
  00010	89 88 e0 7d 00
	00		 mov	 DWORD PTR [eax+32224], ecx
  00016	89 88 e8 7d 00
	00		 mov	 DWORD PTR [eax+32232], ecx
  0001c	89 88 ec 7d 00
	00		 mov	 DWORD PTR [eax+32236], ecx
  00022	89 88 f0 7d 00
	00		 mov	 DWORD PTR [eax+32240], ecx
  00028	c3		 ret	 0
??0cResetSystem@@QAE@XZ ENDP				; cResetSystem::cResetSystem
_TEXT	ENDS
PUBLIC	??1cResetSystem@@QAE@XZ				; cResetSystem::~cResetSystem
; Function compile flags: /Ogtp
;	COMDAT ??1cResetSystem@@QAE@XZ
_TEXT	SEGMENT
??1cResetSystem@@QAE@XZ PROC				; cResetSystem::~cResetSystem, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 86 e8 7d 00
	00		 mov	 eax, DWORD PTR [esi+32232]
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	3b c7		 cmp	 eax, edi
  0000e	74 09		 je	 SHORT $LN12@cResetSyst
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN12@cResetSyst:
  00019	89 be e8 7d 00
	00		 mov	 DWORD PTR [esi+32232], edi
  0001f	89 be ec 7d 00
	00		 mov	 DWORD PTR [esi+32236], edi
  00025	89 be f0 7d 00
	00		 mov	 DWORD PTR [esi+32240], edi
  0002b	8b 86 d8 7d 00
	00		 mov	 eax, DWORD PTR [esi+32216]
  00031	3b c7		 cmp	 eax, edi
  00033	74 09		 je	 SHORT $LN23@cResetSyst
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
$LN23@cResetSyst:
  0003e	89 be d8 7d 00
	00		 mov	 DWORD PTR [esi+32216], edi
  00044	89 be dc 7d 00
	00		 mov	 DWORD PTR [esi+32220], edi
  0004a	89 be e0 7d 00
	00		 mov	 DWORD PTR [esi+32224], edi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??1cResetSystem@@QAE@XZ ENDP				; cResetSystem::~cResetSystem
_TEXT	ENDS
PUBLIC	?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z PROC ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 52		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 4c		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001e	f7 ef		 imul	 edi
  00020	03 d7		 add	 edx, edi
  00022	c1 fa 04	 sar	 edx, 4
  00025	8b fa		 mov	 edi, edx
  00027	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0002a	03 fa		 add	 edi, edx

; 980  : 			if (this->_Mylast == this->_Myend)

  0002c	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00031	6a 01		 push	 1
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0003a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003c	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  00043	2b c7		 sub	 eax, edi
  00045	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	52		 push	 edx
  0004c	50		 push	 eax
  0004d	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00059	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  00063	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00066	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  00068	6a 01		 push	 1
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00071	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00074	57		 push	 edi
  00075	52		 push	 edx
  00076	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_NEEDITEM_DATA@@@std@@URESET_NEEDITEM_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_NEEDITEM_DATA@@@0@PAURESET_NEEDITEM_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_NEEDITEM_DATA>,RESET_NEEDITEM_DATA,RESET_NEEDITEM_DATA const &>
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00082	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ENDP ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z PROC ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4a		 jae	 SHORT $LN4@push_back@2
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 44		 ja	 SHORT $LN4@push_back@2

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0001e	f7 ef		 imul	 edi
  00020	c1 fa 03	 sar	 edx, 3
  00023	8b fa		 mov	 edi, edx
  00025	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00028	03 fa		 add	 edi, edx

; 980  : 			if (this->_Mylast == this->_Myend)

  0002a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002d	75 09		 jne	 SHORT $LN3@push_back@2

; 981  : 				_Reserve(1);

  0002f	6a 01		 push	 1
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
$LN3@push_back@2:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	8d 04 ff	 lea	 eax, DWORD PTR [edi+edi*8]
  0003d	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@AAU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@AAU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00051	83 46 04 24	 add	 DWORD PTR [esi+4], 36	; 00000024H
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN4@push_back@2:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0005b	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0005e	75 09		 jne	 SHORT $LN1@push_back@2

; 991  : 				_Reserve(1);

  00060	6a 01		 push	 1
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?_Reserve@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@IAEXI@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::_Reserve
$LN1@push_back@2:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00069	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0006c	57		 push	 edi
  0006d	52		 push	 edx
  0006e	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@URESET_REWARD_DATA@@@std@@URESET_REWARD_DATA@@ABU3@@std@@YAXAAV?$allocator@URESET_REWARD_DATA@@@0@PAURESET_REWARD_DATA@@ABU2@@Z ; std::_Cons_val<std::allocator<RESET_REWARD_DATA>,RESET_REWARD_DATA,RESET_REWARD_DATA const &>
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  0007a	83 46 04 24	 add	 DWORD PTR [esi+4], 36	; 00000024H
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z ENDP ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@		; `string'
PUBLIC	??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@		; `string'
PUBLIC	??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@		; `string'
PUBLIC	??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@		; `string'
PUBLIC	??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@	; `string'
PUBLIC	??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@		; `string'
PUBLIC	??_C@_03LGLGIONO@cmd?$AA@			; `string'
PUBLIC	??_C@_06DAJLIHEI@?1reset?$AA@			; `string'
PUBLIC	??_C@_0L@JFOEGHOM@DinamicExp?$AA@		; `string'
PUBLIC	??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@		; `string'
PUBLIC	??_C@_09PFIPMMFI@AddWcoinP?$AA@			; `string'
PUBLIC	??_C@_09JEGAINMK@AddWcoinC?$AA@			; `string'
PUBLIC	??_C@_0L@KDJHOFMG@AddCredits?$AA@		; `string'
PUBLIC	??_C@_0M@POBAKBPM@MapForReset?$AA@		; `string'
PUBLIC	??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@		; `string'
PUBLIC	??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@		; `string'
PUBLIC	??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@		; `string'
PUBLIC	??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@		; `string'
PUBLIC	??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@		; `string'
PUBLIC	??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@		; `string'
PUBLIC	??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@		; `string'
PUBLIC	??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@		; `string'
PUBLIC	??_C@_08PFDBLNIM@Add?4Form?$AA@			; `string'
PUBLIC	??_C@_0L@BKBHHLKP@Need?4Level?$AA@		; `string'
PUBLIC	??_C@_08LCGFICFE@Need?4Zen?$AA@			; `string'
PUBLIC	??_C@_07IGJLCBJI@ZenForm?$AA@			; `string'
PUBLIC	??_C@_07BHDMOFNL@Max?4res?$AA@			; `string'
PUBLIC	??_C@_05CCGMLFNG@Reset?$AA@			; `string'
PUBLIC	??_C@_06CKGENIKG@Enable?$AA@			; `string'
PUBLIC	??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Load@cResetSystem@@QAEXXZ			; cResetSystem::Load
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	?Zt_IsBadFileLine@@YA_NPADAAH@Z:PROC		; Zt_IsBadFileLine
EXTRN	_fgets:PROC
EXTRN	_feof:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_fopen:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
;	COMDAT ??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
CONST	SEGMENT
??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%'
	DB	'd %d %d %d %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB '%d %d %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@ DB '%d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
CONST	SEGMENT
??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@ DB 'LOAD FILE ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@
CONST	SEGMENT
??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@ DB 'Reset_NPC_Y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@
CONST	SEGMENT
??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@ DB 'Reset_NPC_X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@
CONST	SEGMENT
??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@ DB 'Reset_NPC_MAP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@
CONST	SEGMENT
??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@ DB 'Reset_NPC_ID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@
CONST	SEGMENT
??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@ DB 'NeedCreditToReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@
CONST	SEGMENT
??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@ DB 'NeedWCoinToReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGLGIONO@cmd?$AA@
CONST	SEGMENT
??_C@_03LGLGIONO@cmd?$AA@ DB 'cmd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAJLIHEI@?1reset?$AA@
CONST	SEGMENT
??_C@_06DAJLIHEI@?1reset?$AA@ DB '/reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFOEGHOM@DinamicExp?$AA@
CONST	SEGMENT
??_C@_0L@JFOEGHOM@DinamicExp?$AA@ DB 'DinamicExp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@
CONST	SEGMENT
??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@ DB 'AddGoblinPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFIPMMFI@AddWcoinP?$AA@
CONST	SEGMENT
??_C@_09PFIPMMFI@AddWcoinP?$AA@ DB 'AddWcoinP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEGAINMK@AddWcoinC?$AA@
CONST	SEGMENT
??_C@_09JEGAINMK@AddWcoinC?$AA@ DB 'AddWcoinC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDJHOFMG@AddCredits?$AA@
CONST	SEGMENT
??_C@_0L@KDJHOFMG@AddCredits?$AA@ DB 'AddCredits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POBAKBPM@MapForReset?$AA@
CONST	SEGMENT
??_C@_0M@POBAKBPM@MapForReset?$AA@ DB 'MapForReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@
CONST	SEGMENT
??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@ DB 'Need.EmptyInv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@
CONST	SEGMENT
??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@ DB 'Add.PointsRF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@
CONST	SEGMENT
??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@ DB 'Add.PointsDL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@
CONST	SEGMENT
??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@ DB 'Add.PointsMG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@
CONST	SEGMENT
??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@ DB 'Add.PointsSUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@
CONST	SEGMENT
??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@ DB 'Add.PointsELF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@
CONST	SEGMENT
??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@ DB 'Add.PointsDK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@
CONST	SEGMENT
??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@ DB 'Add.PointsDW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFDBLNIM@Add?4Form?$AA@
CONST	SEGMENT
??_C@_08PFDBLNIM@Add?4Form?$AA@ DB 'Add.Form', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKBHHLKP@Need?4Level?$AA@
CONST	SEGMENT
??_C@_0L@BKBHHLKP@Need?4Level?$AA@ DB 'Need.Level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LCGFICFE@Need?4Zen?$AA@
CONST	SEGMENT
??_C@_08LCGFICFE@Need?4Zen?$AA@ DB 'Need.Zen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGJLCBJI@ZenForm?$AA@
CONST	SEGMENT
??_C@_07IGJLCBJI@ZenForm?$AA@ DB 'ZenForm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHDMOFNL@Max?4res?$AA@
CONST	SEGMENT
??_C@_07BHDMOFNL@Max?4res?$AA@ DB 'Max.res', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGMLFNG@Reset?$AA@
CONST	SEGMENT
??_C@_05CCGMLFNG@Reset?$AA@ DB 'Reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable?$AA@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable?$AA@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
CONST	SEGMENT
??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@ DB '..\Data\ZtData'
	DB	'\Reset.ini', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\reset.cpp
CONST	ENDS
;	COMDAT ?Load@cResetSystem@@QAEXXZ
_TEXT	SEGMENT
_n$213738 = -336					; size = 8
_n$213748 = -328					; size = 8
_Flag$ = -320						; size = 4
$T218679 = -316						; size = 4
$T218418 = -316						; size = 4
_file$ = -316						; size = 4
_list$213756 = -312					; size = 36
_list$213752 = -304					; size = 28
_n$213743 = -276					; size = 16
_Buff$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
?Load@cResetSystem@@QAEXXZ PROC				; cResetSystem::Load, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 27   : #if(ADD_RESET_WINDOW)
; 28   : 	this->Reset_NPC_ID = 0;

  00018	33 ff		 xor	 edi, edi
  0001a	89 bb c8 7d 00
	00		 mov	 DWORD PTR [ebx+32200], edi

; 29   : 	this->Reset_NPC_MAP = 0;

  00020	89 bb cc 7d 00
	00		 mov	 DWORD PTR [ebx+32204], edi

; 30   : 	this->Reset_NPC_X = 0;

  00026	89 bb d0 7d 00
	00		 mov	 DWORD PTR [ebx+32208], edi

; 31   : 	this->Reset_NPC_Y = 0;

  0002c	89 bb d4 7d 00
	00		 mov	 DWORD PTR [ebx+32212], edi

; 32   : 
; 33   : 	this->m_needitem.clear();

  00032	8b 8b d8 7d 00
	00		 mov	 ecx, DWORD PTR [ebx+32216]
  00038	8b 83 dc 7d 00
	00		 mov	 eax, DWORD PTR [ebx+32220]
  0003e	3b c8		 cmp	 ecx, eax
  00040	74 39		 je	 SHORT $LN42@Load
  00042	89 8d c4 fe ff
	ff		 mov	 DWORD PTR $T218418[ebp], ecx
  00048	8b d0		 mov	 edx, eax
  0004a	3b c0		 cmp	 eax, eax
  0004c	74 21		 je	 SHORT $LN71@Load
  0004e	8b ff		 npad	 2
$LL141@Load:
  00050	8b bd c4 fe ff
	ff		 mov	 edi, DWORD PTR $T218418[ebp]
  00056	83 85 c4 fe ff
	ff 1c		 add	 DWORD PTR $T218418[ebp], 28 ; 0000001cH
  0005d	8b f2		 mov	 esi, edx
  0005f	83 c2 1c	 add	 edx, 28			; 0000001cH
  00062	b9 07 00 00 00	 mov	 ecx, 7
  00067	f3 a5		 rep movsd
  00069	3b d0		 cmp	 edx, eax
  0006b	75 e3		 jne	 SHORT $LL141@Load
  0006d	33 ff		 xor	 edi, edi
$LN71@Load:
  0006f	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T218418[ebp]
  00075	89 83 dc 7d 00
	00		 mov	 DWORD PTR [ebx+32220], eax
$LN42@Load:

; 34   : 	this->m_reward.clear();

  0007b	8b 83 e8 7d 00
	00		 mov	 eax, DWORD PTR [ebx+32232]
  00081	8b 93 ec 7d 00
	00		 mov	 edx, DWORD PTR [ebx+32236]
  00087	3b c2		 cmp	 eax, edx
  00089	74 40		 je	 SHORT $LN96@Load
  0008b	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T218679[ebp], eax
  00091	8b c2		 mov	 eax, edx
  00093	3b d2		 cmp	 edx, edx
  00095	74 28		 je	 SHORT $LN125@Load
  00097	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL140@Load:
  000a0	8b bd c4 fe ff
	ff		 mov	 edi, DWORD PTR $T218679[ebp]
  000a6	83 85 c4 fe ff
	ff 24		 add	 DWORD PTR $T218679[ebp], 36 ; 00000024H
  000ad	8b f0		 mov	 esi, eax
  000af	83 c0 24	 add	 eax, 36			; 00000024H
  000b2	b9 09 00 00 00	 mov	 ecx, 9
  000b7	f3 a5		 rep movsd
  000b9	3b c2		 cmp	 eax, edx
  000bb	75 e3		 jne	 SHORT $LL140@Load
  000bd	33 ff		 xor	 edi, edi
$LN125@Load:
  000bf	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR $T218679[ebp]
  000c5	89 8b ec 7d 00
	00		 mov	 DWORD PTR [ebx+32236], ecx
$LN96@Load:

; 35   : #endif
; 36   : 
; 37   : 	this->EnableResetSystem = GetPrivateProfileInt("Reset","Enable",0,Reset_DIR);	

  000cb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  000d6	57		 push	 edi
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_06CKGENIKG@Enable?$AA@
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  000e1	ff d6		 call	 esi

; 38   : 	this->Maxres = GetPrivateProfileInt("Reset","Max.res",100,Reset_DIR);

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  000e8	6a 64		 push	 100			; 00000064H
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_07BHDMOFNL@Max?4res?$AA@
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  000f4	89 03		 mov	 DWORD PTR [ebx], eax
  000f6	ff d6		 call	 esi

; 39   : 	this->ZenForm = GetPrivateProfileInt("Reset","ZenForm",0,Reset_DIR);

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  000fd	57		 push	 edi
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_07IGJLCBJI@ZenForm?$AA@
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00108	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0010b	ff d6		 call	 esi

; 40   : 	this->NeedZen = GetPrivateProfileInt("Reset","Need.Zen",0,Reset_DIR);

  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00112	57		 push	 edi
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_08LCGFICFE@Need?4Zen?$AA@
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0011d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00120	ff d6		 call	 esi

; 41   : 	this->NeedLevel = GetPrivateProfileInt("Reset","Need.Level",0,Reset_DIR);

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00127	57		 push	 edi
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BKBHHLKP@Need?4Level?$AA@
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00132	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00135	ff d6		 call	 esi

; 42   : 	this->AddForm = GetPrivateProfileInt("Reset","Add.Form",0,Reset_DIR);

  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  0013c	57		 push	 edi
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_08PFDBLNIM@Add?4Form?$AA@
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00147	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0014a	ff d6		 call	 esi

; 43   : 	this->AddPointsDW = GetPrivateProfileInt("Reset","Add.PointsDW",0,Reset_DIR);

  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00151	57		 push	 edi
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KKKFEDHC@Add?4PointsDW?$AA@
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0015c	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  0015f	ff d6		 call	 esi

; 44   : 	this->AddPointsDK = GetPrivateProfileInt("Reset","Add.PointsDK",0,Reset_DIR);

  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00166	57		 push	 edi
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMNCBOCP@Add?4PointsDK?$AA@
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00171	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  00174	ff d6		 call	 esi

; 45   : 	this->AddPointsELF = GetPrivateProfileInt("Reset","Add.PointsELF",0,Reset_DIR);

  00176	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  0017b	57		 push	 edi
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LAENHGCE@Add?4PointsELF?$AA@
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00186	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00189	ff d6		 call	 esi

; 46   : 	this->AddPointsSUM = GetPrivateProfileInt("Reset","Add.PointsSUM",0,Reset_DIR);

  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00190	57		 push	 edi
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DFDMDPFD@Add?4PointsSUM?$AA@
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0019b	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  0019e	ff d6		 call	 esi

; 47   : 	this->AddPointsMG = GetPrivateProfileInt("Reset","Add.PointsMG",0,Reset_DIR);

  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  001a5	57		 push	 edi
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OPLGGKKM@Add?4PointsMG?$AA@
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001b0	89 43 24	 mov	 DWORD PTR [ebx+36], eax
  001b3	ff d6		 call	 esi

; 48   : 	this->AddPointsDL = GetPrivateProfileInt("Reset","Add.PointsDL",0,Reset_DIR);

  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  001ba	57		 push	 edi
  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DJDIIOI@Add?4PointsDL?$AA@
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001c5	89 43 28	 mov	 DWORD PTR [ebx+40], eax
  001c8	ff d6		 call	 esi

; 49   : 	this->AddPointsRF = GetPrivateProfileInt("Reset","Add.PointsRF",0,Reset_DIR);

  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  001cf	57		 push	 edi
  001d0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OBNHLPKA@Add?4PointsRF?$AA@
  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001da	89 43 2c	 mov	 DWORD PTR [ebx+44], eax
  001dd	ff d6		 call	 esi

; 50   : 	this->NeedEmptyInv = GetPrivateProfileInt("Reset","Need.EmptyInv",1,Reset_DIR);

  001df	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  001e4	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  001e7	6a 01		 push	 1
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DMBAEBEI@Need?4EmptyInv?$AA@
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  001f3	ff d6		 call	 esi

; 51   : 
; 52   : 	this->m_iMapForReset = GetPrivateProfileInt("Reset","MapForReset",0,Reset_DIR);

  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  001fa	57		 push	 edi
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@POBAKBPM@MapForReset?$AA@
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00205	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00208	ff d6		 call	 esi

; 53   : 
; 54   : 	this->AddCredits = GetPrivateProfileInt("Reset","AddCredits",0,Reset_DIR);

  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  0020f	57		 push	 edi
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KDJHOFMG@AddCredits?$AA@
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0021a	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  0021d	ff d6		 call	 esi

; 55   : 	this->AddWcoinC = GetPrivateProfileInt("Reset","AddWcoinC",0,Reset_DIR);

  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00224	57		 push	 edi
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_09JEGAINMK@AddWcoinC?$AA@
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0022f	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00232	ff d6		 call	 esi

; 56   : 	this->AddWcoinP = GetPrivateProfileInt("Reset","AddWcoinP",0,Reset_DIR);

  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00239	57		 push	 edi
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_09PFIPMMFI@AddWcoinP?$AA@
  0023f	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00244	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00247	ff d6		 call	 esi

; 57   : 	this->AddGoblinPoint = GetPrivateProfileInt("Reset","AddGoblinPoint",0,Reset_DIR);

  00249	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  0024e	57		 push	 edi
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEHAPABJ@AddGoblinPoint?$AA@
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00259	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  0025c	ff d6		 call	 esi

; 58   : 
; 59   : 	this->DinamicExp = GetPrivateProfileInt("Reset","DinamicExp",1,Reset_DIR);

  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00263	6a 01		 push	 1
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JFOEGHOM@DinamicExp?$AA@
  0026a	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0026f	89 43 44	 mov	 DWORD PTR [ebx+68], eax
  00272	ff d6		 call	 esi

; 60   : 
; 61   : 	GetPrivateProfileString("Reset", "cmd","/reset",this->CommandReset,100,Reset_DIR);

  00274	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00279	6a 64		 push	 100			; 00000064H
  0027b	85 c0		 test	 eax, eax
  0027d	8d 43 4d	 lea	 eax, DWORD PTR [ebx+77]
  00280	50		 push	 eax
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_06DAJLIHEI@?1reset?$AA@
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_03LGLGIONO@cmd?$AA@
  0028b	0f 95 c2	 setne	 dl
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00293	88 53 4c	 mov	 BYTE PTR [ebx+76], dl
  00296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 62   : 
; 63   : #ifdef PRIVATE_MODULE
; 64   : 	if(g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(SILVER1) || g_ZtLicense.CheckUser(SILVER2) || g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::Cherkashin))

  0029c	6a 1c		 push	 28			; 0000001cH
  0029e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002a3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002a8	84 c0		 test	 al, al
  002aa	75 40		 jne	 SHORT $LN20@Load
  002ac	6a 07		 push	 7
  002ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002b3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002b8	84 c0		 test	 al, al
  002ba	75 30		 jne	 SHORT $LN20@Load
  002bc	6a 08		 push	 8
  002be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002c3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002c8	84 c0		 test	 al, al
  002ca	75 20		 jne	 SHORT $LN20@Load
  002cc	6a 01		 push	 1
  002ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002d3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002d8	84 c0		 test	 al, al
  002da	75 10		 jne	 SHORT $LN20@Load
  002dc	6a 12		 push	 18			; 00000012H
  002de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002e3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002e8	84 c0		 test	 al, al
  002ea	74 30		 je	 SHORT $LN21@Load
$LN20@Load:

; 65   : 		{
; 66   : 		this->NeedWCoinToReset = GetPrivateProfileInt("Reset","NeedWCoinToReset",0,Reset_DIR);

  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  002f1	57		 push	 edi
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EBKFBAK@NeedWCoinToReset?$AA@
  002f7	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  002fc	ff d6		 call	 esi

; 67   : 		
; 68   : #if _CONFLICT_
; 69   : 		this->NeedCreditToReset = GetPrivateProfileInt("Reset","NeedCreditToReset",0,Reset_DIR);

  002fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00303	57		 push	 edi
  00304	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MAKHOLFG@NeedCreditToReset?$AA@
  00309	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0030e	89 83 b4 00 00
	00		 mov	 DWORD PTR [ebx+180], eax
  00314	ff d6		 call	 esi
  00316	89 83 b8 00 00
	00		 mov	 DWORD PTR [ebx+184], eax
$LN21@Load:

; 70   : #endif
; 71   : 		
; 72   : 		}
; 73   : #endif
; 74   : #if(ADD_RESET_WINDOW)
; 75   : 	this->Reset_NPC_ID = GetPrivateProfileInt("Reset", "Reset_NPC_ID", 0, Reset_DIR);

  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00321	57		 push	 edi
  00322	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CHDCKPNK@Reset_NPC_ID?$AA@
  00327	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0032c	ff d6		 call	 esi

; 76   : 	this->Reset_NPC_MAP = GetPrivateProfileInt("Reset", "Reset_NPC_MAP", 0, Reset_DIR);

  0032e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00333	57		 push	 edi
  00334	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FFDDABIN@Reset_NPC_MAP?$AA@
  00339	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0033e	89 83 c8 7d 00
	00		 mov	 DWORD PTR [ebx+32200], eax
  00344	ff d6		 call	 esi

; 77   : 	this->Reset_NPC_X = GetPrivateProfileInt("Reset", "Reset_NPC_X", 0, Reset_DIR);

  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  0034b	57		 push	 edi
  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BCIGNGOI@Reset_NPC_X?$AA@
  00351	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  00356	89 83 cc 7d 00
	00		 mov	 DWORD PTR [ebx+32204], eax
  0035c	ff d6		 call	 esi

; 78   : 	this->Reset_NPC_Y = GetPrivateProfileInt("Reset", "Reset_NPC_Y", 0, Reset_DIR);

  0035e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  00363	57		 push	 edi
  00364	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LJNOHKJ@Reset_NPC_Y?$AA@
  00369	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
  0036e	89 83 d0 7d 00
	00		 mov	 DWORD PTR [ebx+32208], eax
  00374	ff d6		 call	 esi
  00376	89 83 d4 7d 00
	00		 mov	 DWORD PTR [ebx+32212], eax
  0037c	8d 83 08 20 00
	00		 lea	 eax, DWORD PTR [ebx+8200]
  00382	8d 8b c0 00 00
	00		 lea	 ecx, DWORD PTR [ebx+192]
  00388	ba e8 03 00 00	 mov	 edx, 1000		; 000003e8H
  0038d	8d 49 00	 npad	 3
$LL19@Load:

; 79   : #endif
; 80   : 
; 81   : 	for(int i(0);i<RESET_EXP_MAX_RES;i++)
; 82   : 	{
; 83   : 		this->Number[i].Res = 0;

  00390	89 79 fc	 mov	 DWORD PTR [ecx-4], edi

; 84   : 		this->Number[i].Exp = 0;

  00393	89 39		 mov	 DWORD PTR [ecx], edi

; 85   : 		
; 86   : #ifdef PRIVATE_MODULE
; 87   : 		this->ItemsRes[i].ItemCount = 0;

  00395	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 88   : 		this->ItemsRes[i].ItemIndex = 0;

  00398	89 38		 mov	 DWORD PTR [eax], edi

; 89   : 		this->ItemsRes[i].ItemType = 0;

  0039a	89 78 fc	 mov	 DWORD PTR [eax-4], edi

; 90   : 		this->ItemsRes[i].Res = 0;

  0039d	89 78 f8	 mov	 DWORD PTR [eax-8], edi

; 91   : 		this->LevelRes[i].Res = 0;

  003a0	89 b9 c4 5d 00
	00		 mov	 DWORD PTR [ecx+24004], edi

; 92   : 		this->LevelRes[i].Level = 0;

  003a6	89 b9 c8 5d 00
	00		 mov	 DWORD PTR [ecx+24008], edi
  003ac	83 c0 10	 add	 eax, 16			; 00000010H
  003af	83 c1 08	 add	 ecx, 8
  003b2	4a		 dec	 edx
  003b3	75 db		 jne	 SHORT $LL19@Load

; 93   : #endif
; 94   : 	}
; 95   : 	FILE * file = fopen(Reset_DIR,"r");

  003b5	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  003bf	e8 00 00 00 00	 call	 _fopen
  003c4	8b f0		 mov	 esi, eax
  003c6	83 c4 08	 add	 esp, 8
  003c9	89 b5 c4 fe ff
	ff		 mov	 DWORD PTR _file$[ebp], esi

; 96   : 	if(file == NULL)

  003cf	3b f7		 cmp	 esi, edi
  003d1	75 19		 jne	 SHORT $LN16@Load

; 97   : 	{
; 98   : 		MessageBoxA(0,Reset_DIR,"LOAD FILE ERROR",0);

  003d3	57		 push	 edi
  003d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIOFNAIM@LOAD?5FILE?5ERROR?$AA@
  003d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DBIGOLCO@?4?4?2Data?2ZtData?2Reset?4ini?$AA@
  003de	57		 push	 edi
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 99   : 		ExitProcess(0);

  003e5	57		 push	 edi
  003e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExitProcess@4
$LN146@Load:
$LN16@Load:

; 100  : 	}
; 101  : 
; 102  : 	char Buff[256];
; 103  : 	int Flag = 0;
; 104  : 	this->rCount = 0;
; 105  : 	this->iCount = 0;
; 106  : 	this->lCount = 0;
; 107  : 
; 108  : 	while(!feof(file))

  003ec	56		 push	 esi
  003ed	89 bd c0 fe ff
	ff		 mov	 DWORD PTR _Flag$[ebp], edi
  003f3	89 bb fc 1f 00
	00		 mov	 DWORD PTR [ebx+8188], edi
  003f9	89 bb 80 5e 00
	00		 mov	 DWORD PTR [ebx+24192], edi
  003ff	89 bb c4 7d 00
	00		 mov	 DWORD PTR [ebx+32196], edi
  00405	e8 00 00 00 00	 call	 _feof
  0040a	83 c4 04	 add	 esp, 4
  0040d	85 c0		 test	 eax, eax
  0040f	0f 85 a2 05 00
	00		 jne	 $LN14@Load
  00415	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL15@Load:

; 109  : 	{
; 110  : 		fgets(Buff,256,file);

  00420	56		 push	 esi
  00421	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00427	68 00 01 00 00	 push	 256			; 00000100H
  0042c	51		 push	 ecx
  0042d	e8 00 00 00 00	 call	 _fgets

; 111  : 		if(Zt_IsBadFileLine(Buff, Flag))

  00432	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _Flag$[ebp]
  00438	52		 push	 edx
  00439	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  0043f	50		 push	 eax
  00440	e8 00 00 00 00	 call	 ?Zt_IsBadFileLine@@YA_NPADAAH@Z ; Zt_IsBadFileLine
  00445	83 c4 14	 add	 esp, 20			; 00000014H
  00448	84 c0		 test	 al, al
  0044a	0f 85 56 05 00
	00		 jne	 $LN1@Load

; 112  : 			continue;
; 113  : 		if(Flag == 1)

  00450	be 01 00 00 00	 mov	 esi, 1
  00455	39 b5 c0 fe ff
	ff		 cmp	 DWORD PTR _Flag$[ebp], esi
  0045b	75 4e		 jne	 SHORT $LN12@Load

; 114  : 		{
; 115  : 			int n[2];
; 116  : 			sscanf(Buff, "%d %d", &n[0], &n[1]);

  0045d	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _n$213738[ebp+4]
  00463	51		 push	 ecx
  00464	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _n$213738[ebp]
  0046a	52		 push	 edx
  0046b	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  00471	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  00476	50		 push	 eax
  00477	e8 00 00 00 00	 call	 _sscanf

; 117  : 			this->Number[this->rCount].Res = n[0];

  0047c	8b 8b fc 1f 00
	00		 mov	 ecx, DWORD PTR [ebx+8188]
  00482	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _n$213738[ebp]
  00488	89 94 cb bc 00
	00 00		 mov	 DWORD PTR [ebx+ecx*8+188], edx

; 118  : 			this->Number[this->rCount].Exp = n[1];

  0048f	8b 83 fc 1f 00
	00		 mov	 eax, DWORD PTR [ebx+8188]
  00495	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$213738[ebp+4]
  0049b	83 c4 10	 add	 esp, 16			; 00000010H
  0049e	89 8c c3 c0 00
	00 00		 mov	 DWORD PTR [ebx+eax*8+192], ecx

; 119  : 			this->rCount++;

  004a5	01 b3 fc 1f 00
	00		 add	 DWORD PTR [ebx+8188], esi
$LN12@Load:

; 120  : 		}
; 121  : #ifdef PRIVATE_MODULE
; 122  : 		if(g_ZtLicense.CheckUser(eZtUB::Vadim) || g_ZtLicense.CheckUser(eZtUB::drynea) || g_ZtLicense.CheckUser(eZtUB::Local3) || 
; 123  : 			g_ZtLicense.CheckUser(eZtUB::Cherkashin) || g_ZtLicense.CheckUser(eZtUB::EpicMU) || 
; 124  : 			g_ZtLicense.CheckUser(Gredy) || g_ZtLicense.CheckUser(Gredy2) || g_ZtLicense.CheckUser(GredyLocal))

  004ab	6a 09		 push	 9
  004ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004b2	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004b7	84 c0		 test	 al, al
  004b9	75 73		 jne	 SHORT $LN142@Load
  004bb	56		 push	 esi
  004bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004c1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004c6	84 c0		 test	 al, al
  004c8	75 64		 jne	 SHORT $LN142@Load
  004ca	6a 1c		 push	 28			; 0000001cH
  004cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004d1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004d6	84 c0		 test	 al, al
  004d8	75 54		 jne	 SHORT $LN142@Load
  004da	6a 12		 push	 18			; 00000012H
  004dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004e1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004e6	84 c0		 test	 al, al
  004e8	75 44		 jne	 SHORT $LN142@Load
  004ea	6a 3b		 push	 59			; 0000003bH
  004ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004f1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004f6	84 c0		 test	 al, al
  004f8	75 34		 jne	 SHORT $LN142@Load
  004fa	6a 20		 push	 32			; 00000020H
  004fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00501	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00506	84 c0		 test	 al, al
  00508	75 24		 jne	 SHORT $LN142@Load
  0050a	6a 22		 push	 34			; 00000022H
  0050c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00511	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00516	84 c0		 test	 al, al
  00518	75 14		 jne	 SHORT $LN142@Load
  0051a	6a 21		 push	 33			; 00000021H
  0051c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00521	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00526	84 c0		 test	 al, al
  00528	0f 84 99 00 00
	00		 je	 $LN9@Load
$LN142@Load:

; 125  : 		{
; 126  : 			if(Flag == 2)

  0052e	83 bd c0 fe ff
	ff 02		 cmp	 DWORD PTR _Flag$[ebp], 2
  00535	0f 85 8c 00 00
	00		 jne	 $LN9@Load

; 127  : 			{
; 128  : 				int n[4];
; 129  : 				sscanf(Buff, "%d %d %d %d", &n[0], &n[1], &n[2], &n[3]);

  0053b	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _n$213743[ebp+12]
  00541	52		 push	 edx
  00542	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _n$213743[ebp+8]
  00548	50		 push	 eax
  00549	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _n$213743[ebp+4]
  0054f	51		 push	 ecx
  00550	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _n$213743[ebp]
  00556	52		 push	 edx
  00557	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _Buff$[ebp]
  0055d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FMGEODLN@?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 _sscanf

; 130  : 				this->ItemsRes[this->iCount].Res = n[0];

  00568	8b 8b 80 5e 00
	00		 mov	 ecx, DWORD PTR [ebx+24192]
  0056e	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _n$213743[ebp]
  00574	81 c1 00 02 00
	00		 add	 ecx, 512		; 00000200H
  0057a	03 c9		 add	 ecx, ecx
  0057c	89 14 cb	 mov	 DWORD PTR [ebx+ecx*8], edx

; 131  : 				this->ItemsRes[this->iCount].ItemType = n[1];

  0057f	8b 83 80 5e 00
	00		 mov	 eax, DWORD PTR [ebx+24192]
  00585	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _n$213743[ebp+4]
  0058b	03 c0		 add	 eax, eax
  0058d	89 8c c3 04 20
	00 00		 mov	 DWORD PTR [ebx+eax*8+8196], ecx

; 132  : 				this->ItemsRes[this->iCount].ItemIndex = n[2];

  00594	8b 93 80 5e 00
	00		 mov	 edx, DWORD PTR [ebx+24192]
  0059a	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _n$213743[ebp+8]
  005a0	03 d2		 add	 edx, edx
  005a2	89 84 d3 08 20
	00 00		 mov	 DWORD PTR [ebx+edx*8+8200], eax

; 133  : 				this->ItemsRes[this->iCount].ItemCount = n[3];

  005a9	8b 8b 80 5e 00
	00		 mov	 ecx, DWORD PTR [ebx+24192]
  005af	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _n$213743[ebp+12]
  005b5	03 c9		 add	 ecx, ecx
  005b7	83 c4 18	 add	 esp, 24			; 00000018H
  005ba	89 94 cb 0c 20
	00 00		 mov	 DWORD PTR [ebx+ecx*8+8204], edx

; 134  : 				this->iCount++;

  005c1	01 b3 80 5e 00
	00		 add	 DWORD PTR [ebx+24192], esi
$LN9@Load:

; 135  : 			}
; 136  : 		}
; 137  : 		if(g_ZtLicense.CheckUser(eZtUB::Local) || 
; 138  : 			g_ZtLicense.CheckUser(eZtUB::ulasevich) || 
; 139  : 			g_ZtLicense.CheckUser(eZtUB::Cherkashin) || 
; 140  : 			g_ZtLicense.CheckUser(eZtUB::Local3) || 
; 141  : 			g_ZtLicense.CheckUser(eZtUB::MU2Play) || g_ZtLicense.CheckUser(eZtUB::Sentinel) || g_ZtLicense.CheckUser(eZtUB::EpicMU) || g_ZtLicense.CheckUser(eZtUB::AlterMU) ||
; 142  : 			g_ZtLicense.CheckUser(eZtUB::EpicMU) || g_ZtLicense.CheckUser(eZtUB::Escalate) || g_ZtLicense.CheckUser(eZtUB::eternalmu) ||
; 143  : 			g_ZtLicense.CheckUser(eZtUB::Gredy) ||
; 144  : 			g_ZtLicense.CheckUser(eZtUB::Gredy2) || 
; 145  : 			g_ZtLicense.CheckUser(eZtUB::GredyLocal) ||
; 146  : 			g_ZtLicense.CheckUser(eZtUB::mu4you) ||
; 147  : 			g_ZtLicense.CheckUser(eZtUB::NSGames) ||
; 148  : 			g_ZtLicense.GetCustom())

  005c7	57		 push	 edi
  005c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005cd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005d2	84 c0		 test	 al, al
  005d4	0f 85 1a 01 00
	00		 jne	 $LN7@Load
  005da	6a 17		 push	 23			; 00000017H
  005dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005e1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005e6	84 c0		 test	 al, al
  005e8	0f 85 06 01 00
	00		 jne	 $LN7@Load
  005ee	6a 12		 push	 18			; 00000012H
  005f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005f5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005fa	84 c0		 test	 al, al
  005fc	0f 85 f2 00 00
	00		 jne	 $LN7@Load
  00602	6a 1c		 push	 28			; 0000001cH
  00604	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00609	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0060e	84 c0		 test	 al, al
  00610	0f 85 de 00 00
	00		 jne	 $LN7@Load
  00616	6a 36		 push	 54			; 00000036H
  00618	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0061d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00622	84 c0		 test	 al, al
  00624	0f 85 ca 00 00
	00		 jne	 $LN7@Load
  0062a	6a 38		 push	 56			; 00000038H
  0062c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00631	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00636	84 c0		 test	 al, al
  00638	0f 85 b6 00 00
	00		 jne	 $LN7@Load
  0063e	6a 3b		 push	 59			; 0000003bH
  00640	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00645	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0064a	84 c0		 test	 al, al
  0064c	0f 85 a2 00 00
	00		 jne	 $LN7@Load
  00652	6a 3e		 push	 62			; 0000003eH
  00654	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00659	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0065e	84 c0		 test	 al, al
  00660	0f 85 8e 00 00
	00		 jne	 $LN7@Load
  00666	6a 3b		 push	 59			; 0000003bH
  00668	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0066d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00672	84 c0		 test	 al, al
  00674	75 7e		 jne	 SHORT $LN7@Load
  00676	6a 40		 push	 64			; 00000040H
  00678	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0067d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00682	84 c0		 test	 al, al
  00684	75 6e		 jne	 SHORT $LN7@Load
  00686	6a 4f		 push	 79			; 0000004fH
  00688	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0068d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00692	84 c0		 test	 al, al
  00694	75 5e		 jne	 SHORT $LN7@Load
  00696	6a 20		 push	 32			; 00000020H
  00698	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0069d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  006a2	84 c0		 test	 al, al
  006a4	75 4e		 jne	 SHORT $LN7@Load
  006a6	6a 22		 push	 34			; 00000022H
  006a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  006ad	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  006b2	84 c0		 test	 al, al
  006b4	75 3e		 jne	 SHORT $LN7@Load
  006b6	6a 21		 push	 33			; 00000021H
  006b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  006bd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  006c2	84 c0		 test	 al, al
  006c4	75 2e		 jne	 SHORT $LN7@Load
  006c6	6a 4e		 push	 78			; 0000004eH
  006c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  006cd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  006d2	84 c0		 test	 al, al
  006d4	75 1e		 jne	 SHORT $LN7@Load
  006d6	6a 51		 push	 81			; 00000051H
  006d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  006dd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  006e2	84 c0		 test	 al, al
  006e4	75 0e		 jne	 SHORT $LN7@Load
  006e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  006eb	e8 00 00 00 00	 call	 ?GetCustom@CZtLicense@@QAEHXZ ; CZtLicense::GetCustom
  006f0	85 c0		 test	 eax, eax
  006f2	74 57		 je	 SHORT $LN6@Load
$LN7@Load:

; 149  : 		{
; 150  : 			if(Flag == 3)

  006f4	83 bd c0 fe ff
	ff 03		 cmp	 DWORD PTR _Flag$[ebp], 3
  006fb	75 4e		 jne	 SHORT $LN6@Load

; 151  : 			{
; 152  : 				int n[2];
; 153  : 				sscanf(Buff, "%d %d", &n[0], &n[1]);

  006fd	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _n$213748[ebp+4]
  00703	50		 push	 eax
  00704	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _n$213748[ebp]
  0070a	51		 push	 ecx
  0070b	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  00711	68 00 00 00 00	 push	 OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
  00716	52		 push	 edx
  00717	e8 00 00 00 00	 call	 _sscanf

; 154  : 				this->LevelRes[this->lCount].Res = n[0];

  0071c	8b 83 c4 7d 00
	00		 mov	 eax, DWORD PTR [ebx+32196]
  00722	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _n$213748[ebp]
  00728	89 8c c3 84 5e
	00 00		 mov	 DWORD PTR [ebx+eax*8+24196], ecx

; 155  : 				this->LevelRes[this->lCount].Level = n[1];

  0072f	8b 93 c4 7d 00
	00		 mov	 edx, DWORD PTR [ebx+32196]
  00735	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _n$213748[ebp+4]
  0073b	83 c4 10	 add	 esp, 16			; 00000010H
  0073e	89 84 d3 88 5e
	00 00		 mov	 DWORD PTR [ebx+edx*8+24200], eax

; 156  : 				this->lCount++;

  00745	01 b3 c4 7d 00
	00		 add	 DWORD PTR [ebx+32196], esi
$LN6@Load:

; 157  : 			}
; 158  : 		}
; 159  : 		if(g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::ulasevich2) || g_ZtLicense.CheckUser(eZtUB::MU2Play)
; 160  : 			 || g_ZtLicense.CheckUser(eZtUB::Sentinel) || g_ZtLicense.CheckUser(eZtUB::EpicMU) ||
; 161  : 				g_ZtLicense.CheckUser(eZtUB::Gredy) ||
; 162  : 				g_ZtLicense.CheckUser(eZtUB::Gredy2) || 
; 163  : 				g_ZtLicense.CheckUser(eZtUB::GredyLocal) || g_ZtLicense.CheckUser(eZtUB::Escalate) || g_ZtLicense.CheckUser(eZtUB::eternalmu) ||
; 164  : 				g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2) ||
; 165  : 				g_ZtLicense.CheckUser(eZtUB::RevoMU) || g_ZtLicense.CheckUser(eZtUB::GloryMU) ||
; 166  : 				g_ZtLicense.CheckUser(eZtUB::MedoniAndrei) ||
; 167  : 				g_ZtLicense.CheckUser(eZtUB::mu4you) || g_ZtLicense.CheckUser(eZtUB::NSGames) ||
; 168  : 				g_ZtLicense.GetCustom())

  0074b	57		 push	 edi
  0074c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00751	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00756	84 c0		 test	 al, al
  00758	0f 85 4a 01 00
	00		 jne	 $LN4@Load
  0075e	6a 17		 push	 23			; 00000017H
  00760	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00765	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0076a	84 c0		 test	 al, al
  0076c	0f 85 36 01 00
	00		 jne	 $LN4@Load
  00772	6a 24		 push	 36			; 00000024H
  00774	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00779	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0077e	84 c0		 test	 al, al
  00780	0f 85 22 01 00
	00		 jne	 $LN4@Load
  00786	6a 36		 push	 54			; 00000036H
  00788	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0078d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00792	84 c0		 test	 al, al
  00794	0f 85 0e 01 00
	00		 jne	 $LN4@Load
  0079a	6a 38		 push	 56			; 00000038H
  0079c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007a1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007a6	84 c0		 test	 al, al
  007a8	0f 85 fa 00 00
	00		 jne	 $LN4@Load
  007ae	6a 3b		 push	 59			; 0000003bH
  007b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007b5	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007ba	84 c0		 test	 al, al
  007bc	0f 85 e6 00 00
	00		 jne	 $LN4@Load
  007c2	6a 20		 push	 32			; 00000020H
  007c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007c9	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007ce	84 c0		 test	 al, al
  007d0	0f 85 d2 00 00
	00		 jne	 $LN4@Load
  007d6	6a 22		 push	 34			; 00000022H
  007d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007dd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007e2	84 c0		 test	 al, al
  007e4	0f 85 be 00 00
	00		 jne	 $LN4@Load
  007ea	6a 21		 push	 33			; 00000021H
  007ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007f1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007f6	84 c0		 test	 al, al
  007f8	0f 85 aa 00 00
	00		 jne	 $LN4@Load
  007fe	6a 40		 push	 64			; 00000040H
  00800	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00805	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0080a	84 c0		 test	 al, al
  0080c	0f 85 96 00 00
	00		 jne	 $LN4@Load
  00812	6a 4f		 push	 79			; 0000004fH
  00814	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00819	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0081e	84 c0		 test	 al, al
  00820	0f 85 82 00 00
	00		 jne	 $LN4@Load
  00826	6a 30		 push	 48			; 00000030H
  00828	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0082d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00832	84 c0		 test	 al, al
  00834	75 72		 jne	 SHORT $LN4@Load
  00836	6a 31		 push	 49			; 00000031H
  00838	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0083d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00842	84 c0		 test	 al, al
  00844	75 62		 jne	 SHORT $LN4@Load
  00846	6a 43		 push	 67			; 00000043H
  00848	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0084d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00852	84 c0		 test	 al, al
  00854	75 52		 jne	 SHORT $LN4@Load
  00856	6a 46		 push	 70			; 00000046H
  00858	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0085d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00862	84 c0		 test	 al, al
  00864	75 42		 jne	 SHORT $LN4@Load
  00866	6a 32		 push	 50			; 00000032H
  00868	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0086d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00872	84 c0		 test	 al, al
  00874	75 32		 jne	 SHORT $LN4@Load
  00876	6a 4e		 push	 78			; 0000004eH
  00878	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0087d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00882	84 c0		 test	 al, al
  00884	75 22		 jne	 SHORT $LN4@Load
  00886	6a 51		 push	 81			; 00000051H
  00888	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0088d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00892	84 c0		 test	 al, al
  00894	75 12		 jne	 SHORT $LN4@Load
  00896	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0089b	e8 00 00 00 00	 call	 ?GetCustom@CZtLicense@@QAEHXZ ; CZtLicense::GetCustom
  008a0	85 c0		 test	 eax, eax
  008a2	0f 84 f8 00 00
	00		 je	 $LN144@Load
$LN4@Load:

; 169  : 		{
; 170  : 			if(Flag == 4)

  008a8	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _Flag$[ebp]
  008ae	83 f8 04	 cmp	 eax, 4
  008b1	75 6e		 jne	 SHORT $LN3@Load

; 171  : 			{
; 172  : 				RESET_NEEDITEM_DATA list;
; 173  : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d", &list.ResetNum,&list.Type,&list.Index,&list.Level,&list.Skill,&list.Luck,&list.Opt,&list.Exl,&list.Anc,&list.Count);

  008b3	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213752[ebp+24]
  008b9	51		 push	 ecx
  008ba	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _list$213752[ebp+20]
  008c0	52		 push	 edx
  008c1	8d 85 e3 fe ff
	ff		 lea	 eax, DWORD PTR _list$213752[ebp+19]
  008c7	50		 push	 eax
  008c8	8d 8d e2 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213752[ebp+18]
  008ce	51		 push	 ecx
  008cf	8d 95 e1 fe ff
	ff		 lea	 edx, DWORD PTR _list$213752[ebp+17]
  008d5	52		 push	 edx
  008d6	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _list$213752[ebp+16]
  008dc	50		 push	 eax
  008dd	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _list$213752[ebp+12]
  008e3	51		 push	 ecx
  008e4	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _list$213752[ebp+8]
  008ea	52		 push	 edx
  008eb	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _list$213752[ebp+4]
  008f1	50		 push	 eax
  008f2	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213752[ebp]
  008f8	51		 push	 ecx
  008f9	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _Buff$[ebp]
  008ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FPCDDDHG@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00904	52		 push	 edx
  00905	e8 00 00 00 00	 call	 _sscanf
  0090a	83 c4 30	 add	 esp, 48			; 00000030H

; 174  : 				this->m_needitem.push_back(list);

  0090d	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _list$213752[ebp]
  00913	50		 push	 eax
  00914	8d 8b d8 7d 00
	00		 lea	 ecx, DWORD PTR [ebx+32216]
  0091a	e8 00 00 00 00	 call	 ?push_back@?$vector@URESET_NEEDITEM_DATA@@V?$allocator@URESET_NEEDITEM_DATA@@@std@@@std@@QAEXABURESET_NEEDITEM_DATA@@@Z ; std::vector<RESET_NEEDITEM_DATA,std::allocator<RESET_NEEDITEM_DATA> >::push_back
  0091f	eb 7f		 jmp	 SHORT $LN144@Load
$LN3@Load:

; 175  : 			}
; 176  : 			else if(Flag == 5)

  00921	83 f8 05	 cmp	 eax, 5
  00924	75 7a		 jne	 SHORT $LN144@Load

; 177  : 			{
; 178  : 				RESET_REWARD_DATA list;
; 179  : 				sscanf(Buff, "%d %d %d %d %d %d %d %d %d %d %d %d",&list.ResetNum,&list.WcoinC,&list.EnableItem,&list.Type,&list.Index,&list.Level,&list.Skill,&list.Luck,&list.Opt,&list.Exl,&list.Anc,&list.Credit);

  00926	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213756[ebp+32]
  0092c	51		 push	 ecx
  0092d	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _list$213756[ebp+28]
  00933	52		 push	 edx
  00934	8d 85 e3 fe ff
	ff		 lea	 eax, DWORD PTR _list$213756[ebp+27]
  0093a	50		 push	 eax
  0093b	8d 8d e2 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213756[ebp+26]
  00941	51		 push	 ecx
  00942	8d 95 e1 fe ff
	ff		 lea	 edx, DWORD PTR _list$213756[ebp+25]
  00948	52		 push	 edx
  00949	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _list$213756[ebp+24]
  0094f	50		 push	 eax
  00950	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _list$213756[ebp+20]
  00956	51		 push	 ecx
  00957	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _list$213756[ebp+16]
  0095d	52		 push	 edx
  0095e	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _list$213756[ebp+12]
  00964	50		 push	 eax
  00965	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _list$213756[ebp+8]
  0096b	51		 push	 ecx
  0096c	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _list$213756[ebp+4]
  00972	52		 push	 edx
  00973	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _list$213756[ebp]
  00979	50		 push	 eax
  0097a	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _Buff$[ebp]
  00980	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IFNGLMNF@?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  00985	51		 push	 ecx
  00986	e8 00 00 00 00	 call	 _sscanf
  0098b	83 c4 38	 add	 esp, 56			; 00000038H

; 180  : 				this->m_reward.push_back(list);

  0098e	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _list$213756[ebp]
  00994	52		 push	 edx
  00995	8d 8b e8 7d 00
	00		 lea	 ecx, DWORD PTR [ebx+32232]
  0099b	e8 00 00 00 00	 call	 ?push_back@?$vector@URESET_REWARD_DATA@@V?$allocator@URESET_REWARD_DATA@@@std@@@std@@QAEXABURESET_REWARD_DATA@@@Z ; std::vector<RESET_REWARD_DATA,std::allocator<RESET_REWARD_DATA> >::push_back
$LN144@Load:
  009a0	8b b5 c4 fe ff
	ff		 mov	 esi, DWORD PTR _file$[ebp]
$LN1@Load:

; 100  : 	}
; 101  : 
; 102  : 	char Buff[256];
; 103  : 	int Flag = 0;
; 104  : 	this->rCount = 0;
; 105  : 	this->iCount = 0;
; 106  : 	this->lCount = 0;
; 107  : 
; 108  : 	while(!feof(file))

  009a6	56		 push	 esi
  009a7	e8 00 00 00 00	 call	 _feof
  009ac	83 c4 04	 add	 esp, 4
  009af	85 c0		 test	 eax, eax
  009b1	0f 84 69 fa ff
	ff		 je	 $LL15@Load
$LN14@Load:

; 181  : 			}
; 182  : 		}
; 183  : #endif
; 184  : 	}
; 185  : 	fclose(file);

  009b7	56		 push	 esi
  009b8	e8 00 00 00 00	 call	 _fclose

; 186  : }

  009bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009c0	83 c4 04	 add	 esp, 4
  009c3	5f		 pop	 edi
  009c4	5e		 pop	 esi
  009c5	33 cd		 xor	 ecx, ebp
  009c7	5b		 pop	 ebx
  009c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009cd	8b e5		 mov	 esp, ebp
  009cf	5d		 pop	 ebp
  009d0	c3		 ret	 0
$LN145@Load:
?Load@cResetSystem@@QAEXXZ ENDP				; cResetSystem::Load
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgResetSystem@@YAXXZ
text$yc	SEGMENT
??__EgResetSystem@@YAXXZ PROC				; `dynamic initializer for 'gResetSystem'', COMDAT

; 23   : cResetSystem gResetSystem;

  00000	68 00 00 00 00	 push	 OFFSET ??__FgResetSystem@@YAXXZ ; `dynamic atexit destructor for 'gResetSystem''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EgResetSystem@@YAXXZ ENDP				; `dynamic initializer for 'gResetSystem''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgResetSystem@@YAXXZ
text$yd	SEGMENT
??__FgResetSystem@@YAXXZ PROC				; `dynamic atexit destructor for 'gResetSystem'', COMDAT
  00000	a1 e8 7d 00 00	 mov	 eax, DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32232
  00005	56		 push	 esi
  00006	33 f6		 xor	 esi, esi
  00008	3b c6		 cmp	 eax, esi
  0000a	74 09		 je	 SHORT $LN12@dynamic
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN12@dynamic:
  00015	a1 d8 7d 00 00	 mov	 eax, DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32216
  0001a	89 35 e8 7d 00
	00		 mov	 DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32232, esi
  00020	89 35 ec 7d 00
	00		 mov	 DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32236, esi
  00026	89 35 f0 7d 00
	00		 mov	 DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32240, esi
  0002c	3b c6		 cmp	 eax, esi
  0002e	74 09		 je	 SHORT $LN23@dynamic
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00036	83 c4 04	 add	 esp, 4
$LN23@dynamic:
  00039	89 35 d8 7d 00
	00		 mov	 DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32216, esi
  0003f	89 35 dc 7d 00
	00		 mov	 DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32220, esi
  00045	89 35 e0 7d 00
	00		 mov	 DWORD PTR ?gResetSystem@@3VcResetSystem@@A+32224, esi
  0004b	5e		 pop	 esi
  0004c	c3		 ret	 0
??__FgResetSystem@@YAXXZ ENDP				; `dynamic atexit destructor for 'gResetSystem''
text$yd	ENDS
PUBLIC	?gResetSystem@@3VcResetSystem@@A		; gResetSystem
_BSS	SEGMENT
?gResetSystem@@3VcResetSystem@@A DB 07df8H DUP (?)	; gResetSystem
_BSS	ENDS
CRT$XCU	SEGMENT
_gResetSystem$initializer$ DD FLAT:??__EgResetSystem@@YAXXZ
CRT$XCU	ENDS
END
