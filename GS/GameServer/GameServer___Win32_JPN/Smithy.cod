; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\Smithy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?GCInitItem@CSmithy@@QAEXH@Z			; CSmithy::GCInitItem
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\smithy.cpp
;	COMDAT ?GCInitItem@CSmithy@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
?GCInitItem@CSmithy@@QAEXH@Z PROC			; CSmithy::GCInitItem, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 	if(OBJMAX_RANGE(aIndex) == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 28		 js	 SHORT $LN2@GCInitItem
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	74 1a		 je	 SHORT $LN2@GCInitItem

; 225  : 	{
; 226  : 		return;
; 227  : 	}
; 228  : 
; 229  : 	GC_SmithyInit pMsg;
; 230  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x1E,  sizeof(pMsg));
; 231  : 	pMsg.result = true;
; 232  : 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  0001b	6a 05		 push	 5
  0001d	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00020	51		 push	 ecx
  00021	50		 push	 eax
  00022	c7 45 f8 c1 05
	fb 1e		 mov	 DWORD PTR _pMsg$[ebp], 519767489 ; 1efb05c1H
  00029	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCInitItem:

; 233  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?GCInitItem@CSmithy@@QAEXH@Z ENDP			; CSmithy::GCInitItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSettingsSend@CSmithy@@QAEXH@Z		; CSmithy::GCSettingsSend
; Function compile flags: /Ogtp
;	COMDAT ?GCSettingsSend@CSmithy@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 26
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCSettingsSend@CSmithy@@QAEXH@Z PROC			; CSmithy::GCSettingsSend, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b c1		 mov	 eax, ecx

; 263  : 	if(OBJMAX_RANGE(aIndex) == 0)

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00015	85 c9		 test	 ecx, ecx
  00017	78 7a		 js	 SHORT $LN2@GCSettings
  00019	33 d2		 xor	 edx, edx
  0001b	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00021	0f 9e c2	 setle	 dl
  00024	85 d2		 test	 edx, edx
  00026	74 6b		 je	 SHORT $LN2@GCSettings

; 264  : 	{
; 265  : 		return;
; 266  : 	}
; 267  : 
; 268  : 	GC_SmithySettings pMsg;
; 269  : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x1C,  sizeof(pMsg));
; 270  : 	pMsg.MaxLevel = this->MaxLevel;

  00028	8a 10		 mov	 dl, BYTE PTR [eax]
  0002a	88 55 e4	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 271  : 	pMsg.LevelPrice = this->LevelPrice;

  0002d	0f b7 50 02	 movzx	 edx, WORD PTR [eax+2]
  00031	66 89 55 e6	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 272  : 	pMsg.LuckPrice = this->LuckPrice;

  00035	0f b7 50 04	 movzx	 edx, WORD PTR [eax+4]
  00039	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+8], dx

; 273  : 	pMsg.AddPrice = this->AddPrice;

  0003d	0f b7 50 06	 movzx	 edx, WORD PTR [eax+6]
  00041	66 89 55 ea	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 274  : 	pMsg.Opt1Price = this->Opt1Price;

  00045	0f b7 50 08	 movzx	 edx, WORD PTR [eax+8]
  00049	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+12], dx

; 275  : 	pMsg.Opt2Price = this->Opt2Price;

  0004d	0f b7 50 0a	 movzx	 edx, WORD PTR [eax+10]
  00051	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+14], dx

; 276  : 	pMsg.Opt3Price = this->Opt3Price;

  00055	0f b7 50 0c	 movzx	 edx, WORD PTR [eax+12]
  00059	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+16], dx

; 277  : 	pMsg.Opt4Price = this->Opt4Price;

  0005d	0f b7 50 0e	 movzx	 edx, WORD PTR [eax+14]
  00061	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+18], dx

; 278  : 	pMsg.Opt5Price = this->Opt5Price;

  00065	0f b7 50 10	 movzx	 edx, WORD PTR [eax+16]
  00069	66 89 55 f4	 mov	 WORD PTR _pMsg$[ebp+20], dx

; 279  : 	pMsg.Opt6Price = this->Opt6Price;

  0006d	0f b7 50 12	 movzx	 edx, WORD PTR [eax+18]

; 280  : 	pMsg.MaxExlOpt = this->MaxExlOpt;

  00071	66 8b 40 14	 mov	 ax, WORD PTR [eax+20]
  00075	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+22], dx

; 281  : 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  00079	6a 1a		 push	 26			; 0000001aH
  0007b	8d 55 e0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0007e	52		 push	 edx
  0007f	51		 push	 ecx
  00080	c7 45 e0 c1 1a
	fb 1c		 mov	 DWORD PTR _pMsg$[ebp], 486218433 ; 1cfb1ac1H
  00087	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+24], ax
  0008b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCSettings:

; 282  : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?GCSettingsSend@CSmithy@@QAEXH@Z ENDP			; CSmithy::GCSettingsSend
_TEXT	ENDS
PUBLIC	?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[], COMDAT
; _this$ = ecx

; 928  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00008	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 941  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEAAUSmithyDATA@@I@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::operator[]
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBE_NPBUSmithyDATA@@@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXPAUSmithyDATA@@0@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::~_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@USmithyDATA@@@std@@QAE@XZ	; std::allocator<SmithyDATA>::allocator<SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@USmithyDATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USmithyDATA@@@std@@QAE@XZ PROC		; std::allocator<SmithyDATA>::allocator<SmithyDATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@USmithyDATA@@@std@@QAE@XZ ENDP		; std::allocator<SmithyDATA>::allocator<SmithyDATA>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEXXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z	; std::allocator<SmithyDATA>::allocator<SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z PROC	; std::allocator<SmithyDATA>::allocator<SmithyDATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@USmithyDATA@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<SmithyDATA>::allocator<SmithyDATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z PROC ; std::allocator<SmithyDATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@I@Z ENDP ; std::allocator<SmithyDATA>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ	; std::allocator<SmithyDATA>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ PROC	; std::allocator<SmithyDATA>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@USmithyDATA@@@std@@QBEIXZ ENDP	; std::allocator<SmithyDATA>::max_size
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Compat
_TEXT	ENDS
PUBLIC	??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z ; std::addressof<SmithyDATA const >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z PROC ; std::addressof<SmithyDATA const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUSmithyDATA@@@std@@YAPBUSmithyDATA@@ABU1@@Z ENDP ; std::addressof<SmithyDATA const >
_TEXT	ENDS
PUBLIC	??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z PROC ; std::forward<SmithyDATA &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUSmithyDATA@@@std@@YAAAUSmithyDATA@@AAU1@@Z ENDP ; std::forward<SmithyDATA &>
_TEXT	ENDS
PUBLIC	??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z ; std::allocator<SmithyDATA>::construct<SmithyDATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z PROC ; std::allocator<SmithyDATA>::construct<SmithyDATA &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@AAUSmithyDATA@@@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@AAU2@@Z ENDP ; std::allocator<SmithyDATA>::construct<SmithyDATA &>
_TEXT	ENDS
PUBLIC	??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z ; std::forward<SmithyDATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z PROC ; std::forward<SmithyDATA const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUSmithyDATA@@@std@@YAABUSmithyDATA@@ABU1@@Z ENDP ; std::forward<SmithyDATA const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z PROC ; std::_Ptr_cat<SmithyDATA,SmithyDATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@USmithyDATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSmithyDATA@@0@Z ENDP ; std::_Ptr_cat<SmithyDATA,SmithyDATA>
_TEXT	ENDS
PUBLIC	??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z ; std::_Construct<SmithyDATA,SmithyDATA const &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z PROC ; std::_Construct<SmithyDATA,SmithyDATA const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct:

; 49   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Construct@USmithyDATA@@ABU1@@std@@YAXPAUSmithyDATA@@ABU1@@Z ENDP ; std::_Construct<SmithyDATA,SmithyDATA const &>
_TEXT	ENDS
PUBLIC	??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::move<SmithyDATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z PROC ; std::move<SmithyDATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUSmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ENDP ; std::move<SmithyDATA &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z ; std::_Val_type<SmithyDATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z PROC ; std::_Val_type<SmithyDATA *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUSmithyDATA@@@std@@YAPAUSmithyDATA@@PAU1@@Z ENDP ; std::_Val_type<SmithyDATA *>
_TEXT	ENDS
PUBLIC	??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z ; std::_Destroy<SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z PROC ; std::_Destroy<SmithyDATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@USmithyDATA@@@std@@YAXPAUSmithyDATA@@@Z ENDP ; std::_Destroy<SmithyDATA>
_TEXT	ENDS
PUBLIC	??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ; std::forward<SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z PROC ; std::forward<SmithyDATA>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@USmithyDATA@@@std@@YA$$QAUSmithyDATA@@AAU1@@Z ENDP ; std::forward<SmithyDATA>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCIemSend@CSmithy@@QAEXH@Z			; CSmithy::GCIemSend
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\smithy.cpp
;	COMDAT ?GCIemSend@CSmithy@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$210756 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCIemSend@CSmithy@@QAEXH@Z PROC			; CSmithy::GCIemSend, COMDAT
; _this$ = ecx

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 237  : 	if(!g_ZtLicense.user.Smithy)

  00010	80 3d e0 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+224, 0
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	74 7a		 je	 SHORT $LN1@GCIemSend

; 238  : 	{
; 239  : 		return;
; 240  : 	}
; 241  : 
; 242  : 	if(OBJMAX_RANGE(aIndex) == 0)

  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00020	85 db		 test	 ebx, ebx
  00022	78 71		 js	 SHORT $LN24@GCIemSend
  00024	33 c0		 xor	 eax, eax
  00026	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0002c	0f 9e c0	 setle	 al
  0002f	85 c0		 test	 eax, eax
  00031	74 62		 je	 SHORT $LN24@GCIemSend

; 243  : 	{
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	this->GCSettingsSend(aIndex);

  00033	57		 push	 edi
  00034	53		 push	 ebx
  00035	e8 00 00 00 00	 call	 ?GCSettingsSend@CSmithy@@QAEXH@Z ; CSmithy::GCSettingsSend

; 248  : 	this->GCInitItem(aIndex);

  0003a	53		 push	 ebx
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ?GCInitItem@CSmithy@@QAEXH@Z ; CSmithy::GCInitItem

; 249  : 	for(int i = 0; i < itemdata.size(); i++)

  00042	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00045	2b 46 18	 sub	 eax, DWORD PTR [esi+24]
  00048	33 ff		 xor	 edi, edi
  0004a	c1 f8 03	 sar	 eax, 3
  0004d	85 c0		 test	 eax, eax
  0004f	74 43		 je	 SHORT $LN25@GCIemSend
$LL3@GCIemSend:
  00051	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00054	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]

; 250  : 	{
; 251  : 		GC_SmithyDATA pMsg;
; 252  : 		pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x1D,  sizeof(pMsg));

  00057	c7 45 f0 c1 0c
	fb 1d		 mov	 DWORD PTR _pMsg$210756[ebp], 502992065 ; 1dfb0cc1H

; 253  : 		pMsg.Class = itemdata[i].Class;

  0005e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00061	88 55 f4	 mov	 BYTE PTR _pMsg$210756[ebp+4], dl

; 254  : 		pMsg.Type = itemdata[i].Type;

  00064	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00067	88 4d f5	 mov	 BYTE PTR _pMsg$210756[ebp+5], cl

; 255  : 		pMsg.Index = itemdata[i].Index;

  0006a	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]

; 256  : 		pMsg.Price = itemdata[i].Price;
; 257  : 		DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  0006e	6a 0c		 push	 12			; 0000000cH
  00070	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$210756[ebp]
  00073	88 55 f6	 mov	 BYTE PTR _pMsg$210756[ebp+6], dl
  00076	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00079	51		 push	 ecx
  0007a	53		 push	 ebx
  0007b	89 45 f8	 mov	 DWORD PTR _pMsg$210756[ebp+8], eax
  0007e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00083	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00086	2b 56 18	 sub	 edx, DWORD PTR [esi+24]
  00089	47		 inc	 edi
  0008a	c1 fa 03	 sar	 edx, 3
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	3b fa		 cmp	 edi, edx
  00092	72 bd		 jb	 SHORT $LL3@GCIemSend
$LN25@GCIemSend:
  00094	5f		 pop	 edi
$LN24@GCIemSend:
  00095	5b		 pop	 ebx
$LN1@GCIemSend:

; 258  : 	}
; 259  : }

  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	33 cd		 xor	 ecx, ebp
  0009b	5e		 pop	 esi
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?GCIemSend@CSmithy@@QAEXH@Z ENDP			; CSmithy::GCIemSend
_TEXT	ENDS
PUBLIC	??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@ ; `string'
PUBLIC	??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@ ; `string'
PUBLIC	?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z ; CSmithy::CGCreateItem
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ZtUserDataSend@@YAXH@Z:PROC			; ZtUserDataSend
EXTRN	?BuyDonateShopItem@CAchievements@@QAEXHH@Z:PROC	; CAchievements::BuyDonateShopItem
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; CheckInventoryEmptySpace
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@ DB '[Smithy]: Crea'
	DB	'te Item', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@ DB '[Smithy]: Pr'
	DB	'ice: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@
CONST	SEGMENT
??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@ DB '[Smi'
	DB	'thy]: Need space in the inventory (%dx%d)', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\smithy.cpp
CONST	ENDS
;	COMDAT ?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z
_TEXT	SEGMENT
tv578 = -20						; size = 4
_iWidth$ = -20						; size = 4
_iType$ = -16						; size = 2
_lpUser$ = -12						; size = 4
_result$ = -8						; size = 4
tv431 = -1						; size = 1
_NewOption$ = 8						; size = 1
_aRecv$ = 8						; size = 4
tv436 = 11						; size = 1
_aIndex$ = 12						; size = 4
?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z PROC ; CSmithy::CGCreateItem, COMDAT
; _this$ = ecx

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 286  : 	if(!g_ZtLicense.user.Smithy)

  00006	80 3d e0 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+224, 0
  0000d	0f 84 0e 03 00
	00		 je	 $LN21@CGCreateIt

; 287  : 	{
; 288  : 		return;
; 289  : 	}
; 290  : 	
; 291  : 	if(OBJMAX_RANGE(aIndex) == 0)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	0f 88 03 03 00
	00		 js	 $LN21@CGCreateIt
  0001e	33 d2		 xor	 edx, edx
  00020	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00025	0f 9e c2	 setle	 dl
  00028	8b c2		 mov	 eax, edx
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 ef 02 00
	00		 je	 $LN21@CGCreateIt

; 292  : 	{
; 293  : 		return;
; 294  : 	}
; 295  : 
; 296  : 	int iTotalExlOpt = aRecv->ItemOpt1 + aRecv->ItemOpt2 + aRecv->ItemOpt3 + aRecv->ItemOpt4 + aRecv->ItemOpt5 + aRecv->ItemOpt6;

  00032	53		 push	 ebx
  00033	56		 push	 esi
  00034	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00037	0f b6 5e 0c	 movzx	 ebx, BYTE PTR [esi+12]

; 297  : 
; 298  : 	if(iTotalExlOpt > this->MaxExlOpt)

  0003b	0f b6 56 0d	 movzx	 edx, BYTE PTR [esi+13]
  0003f	0f b6 46 0e	 movzx	 eax, BYTE PTR [esi+14]
  00043	88 5d ff	 mov	 BYTE PTR tv431[ebp], bl
  00046	0f b6 5e 0b	 movzx	 ebx, BYTE PTR [esi+11]
  0004a	57		 push	 edi
  0004b	0f b6 7e 09	 movzx	 edi, BYTE PTR [esi+9]
  0004f	88 5d 0b	 mov	 BYTE PTR tv436[ebp], bl
  00052	0f b6 5e 0a	 movzx	 ebx, BYTE PTR [esi+10]
  00056	03 fb		 add	 edi, ebx
  00058	0f b6 5d 0b	 movzx	 ebx, BYTE PTR tv436[ebp]
  0005c	03 fb		 add	 edi, ebx
  0005e	0f b6 5d ff	 movzx	 ebx, BYTE PTR tv431[ebp]
  00062	03 fb		 add	 edi, ebx
  00064	03 fa		 add	 edi, edx
  00066	0f b7 51 14	 movzx	 edx, WORD PTR [ecx+20]
  0006a	03 f8		 add	 edi, eax
  0006c	3b fa		 cmp	 edi, edx
  0006e	0f 8f aa 02 00
	00		 jg	 $LN30@CGCreateIt

; 299  : 	{
; 300  : 		return;
; 301  : 	}
; 302  : 
; 303  : 	LPOBJ lpUser = &gObj[aIndex];

  00074	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00077	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0007d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 304  : 
; 305  : 	if(lpUser->Connected < PLAYER_PLAYING)

  00083	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00087	89 45 f4	 mov	 DWORD PTR _lpUser$[ebp], eax
  0008a	0f 8c 8e 02 00
	00		 jl	 $LN30@CGCreateIt

; 306  : 	{
; 307  : 		return;
; 308  : 	}
; 309  : 
; 310  : 	unsigned short id = aRecv->Item;
; 311  : 
; 312  : 	if(id > itemdata.size())

  00090	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00093	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00096	0f b7 7e 04	 movzx	 edi, WORD PTR [esi+4]
  0009a	2b c2		 sub	 eax, edx
  0009c	c1 f8 03	 sar	 eax, 3
  0009f	3b f8		 cmp	 edi, eax
  000a1	0f 87 77 02 00
	00		 ja	 $LN30@CGCreateIt

; 313  : 	{
; 314  : 		return;
; 315  : 	}
; 316  : 
; 317  : 	SmithyDATA smItem =  this->itemdata[id];

  000a7	8b 04 fa	 mov	 eax, DWORD PTR [edx+edi*8]
  000aa	8b 54 fa 04	 mov	 edx, DWORD PTR [edx+edi*8+4]

; 318  : 
; 319  : 	short iType = ITEMGET(smItem.Type,smItem.Index);

  000ae	8b d8		 mov	 ebx, eax
  000b0	c1 eb 08	 shr	 ebx, 8
  000b3	0f b6 fb	 movzx	 edi, bl
  000b6	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  000bb	66 0f af fb	 imul	 di, bx

; 320  : 
; 321  : 	int result = smItem.Price;
; 322  : 	result += aRecv->ItemLevel * this->LevelPrice;
; 323  : 	result += aRecv->ItemAdd * this->AddPrice;

  000bf	0f b6 5e 07	 movzx	 ebx, BYTE PTR [esi+7]
  000c3	c1 e8 10	 shr	 eax, 16			; 00000010H
  000c6	0f b6 c0	 movzx	 eax, al
  000c9	66 03 f8	 add	 di, ax
  000cc	0f b7 c7	 movzx	 eax, di
  000cf	0f b6 7e 06	 movzx	 edi, BYTE PTR [esi+6]
  000d3	89 45 f0	 mov	 DWORD PTR _iType$[ebp], eax
  000d6	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  000da	0f af c7	 imul	 eax, edi
  000dd	0f b7 79 06	 movzx	 edi, WORD PTR [ecx+6]
  000e1	0f af fb	 imul	 edi, ebx
  000e4	03 c2		 add	 eax, edx
  000e6	03 f8		 add	 edi, eax

; 324  : 	BYTE NewOption = 0;
; 325  : 
; 326  : 	if(aRecv->ItemLuck)

  000e8	80 7e 08 00	 cmp	 BYTE PTR [esi+8], 0
  000ec	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
  000ef	c6 45 08 00	 mov	 BYTE PTR _NewOption$[ebp], 0
  000f3	74 09		 je	 SHORT $LN15@CGCreateIt

; 327  : 	{
; 328  : 		result += this->LuckPrice;

  000f5	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  000f9	03 fa		 add	 edi, edx
  000fb	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
$LN15@CGCreateIt:

; 329  : 	}
; 330  : 	if(aRecv->ItemOpt1)

  000fe	80 7e 09 00	 cmp	 BYTE PTR [esi+9], 0
  00102	74 0d		 je	 SHORT $LN14@CGCreateIt

; 331  : 	{
; 332  : 		result += this->Opt1Price;

  00104	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00108	03 f8		 add	 edi, eax
  0010a	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi

; 333  : 		 NewOption |= 0x20;

  0010d	c6 45 08 20	 mov	 BYTE PTR _NewOption$[ebp], 32 ; 00000020H
$LN14@CGCreateIt:

; 334  : 	}
; 335  : 	if(aRecv->ItemOpt2)

  00111	80 7e 0a 00	 cmp	 BYTE PTR [esi+10], 0
  00115	74 0d		 je	 SHORT $LN13@CGCreateIt

; 336  : 	{
; 337  : 		result += this->Opt2Price;

  00117	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  0011b	03 fa		 add	 edi, edx

; 338  : 		NewOption |= 0x10;

  0011d	80 4d 08 10	 or	 BYTE PTR _NewOption$[ebp], 16 ; 00000010H
  00121	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
$LN13@CGCreateIt:

; 339  : 	}
; 340  : 	if(aRecv->ItemOpt3)

  00124	80 7e 0b 00	 cmp	 BYTE PTR [esi+11], 0
  00128	74 0d		 je	 SHORT $LN12@CGCreateIt

; 341  : 	{
; 342  : 		result += this->Opt3Price;

  0012a	0f b7 41 0c	 movzx	 eax, WORD PTR [ecx+12]
  0012e	03 f8		 add	 edi, eax

; 343  : 		NewOption |= 0x08;

  00130	80 4d 08 08	 or	 BYTE PTR _NewOption$[ebp], 8
  00134	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
$LN12@CGCreateIt:

; 344  : 	}
; 345  : 	if(aRecv->ItemOpt4)

  00137	80 7e 0c 00	 cmp	 BYTE PTR [esi+12], 0
  0013b	74 0d		 je	 SHORT $LN11@CGCreateIt

; 346  : 	{
; 347  : 		result += this->Opt4Price;

  0013d	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00141	03 fa		 add	 edi, edx

; 348  : 		NewOption |= 0x04;

  00143	80 4d 08 04	 or	 BYTE PTR _NewOption$[ebp], 4
  00147	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
$LN11@CGCreateIt:

; 349  : 	}
; 350  : 	if(aRecv->ItemOpt5)

  0014a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0014e	74 0d		 je	 SHORT $LN10@CGCreateIt

; 351  : 	{
; 352  : 		result += this->Opt5Price;

  00150	0f b7 41 10	 movzx	 eax, WORD PTR [ecx+16]
  00154	03 f8		 add	 edi, eax

; 353  : 		NewOption |= 0x02;

  00156	80 4d 08 02	 or	 BYTE PTR _NewOption$[ebp], 2
  0015a	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
$LN10@CGCreateIt:

; 354  : 	}
; 355  : 	if(aRecv->ItemOpt6)

  0015d	80 7e 0e 00	 cmp	 BYTE PTR [esi+14], 0
  00161	74 0d		 je	 SHORT $LN9@CGCreateIt

; 356  : 	{
; 357  : 		result += this->Opt6Price;

  00163	0f b7 49 12	 movzx	 ecx, WORD PTR [ecx+18]
  00167	03 f9		 add	 edi, ecx

; 358  : 		NewOption |= 0x01;

  00169	80 4d 08 01	 or	 BYTE PTR _NewOption$[ebp], 1
  0016d	89 7d f8	 mov	 DWORD PTR _result$[ebp], edi
$LN9@CGCreateIt:

; 359  : 	}
; 360  : 
; 361  : 	int iHeight = ItemAttribute[iType].Height;

  00170	0f bf 45 f0	 movsx	 eax, WORD PTR _iType$[ebp]

; 362  : 	int iWidth = ItemAttribute[iType].Width;
; 363  : 					
; 364  : 	if(CheckInventoryEmptySpace(lpUser,iHeight,iWidth) == false)

  00174	8b 55 f4	 mov	 edx, DWORD PTR _lpUser$[ebp]
  00177	6b c0 70	 imul	 eax, 112		; 00000070H
  0017a	0f b6 98 24 00
	00 00		 movzx	 ebx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+36]
  00181	0f b6 80 23 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+35]
  00188	50		 push	 eax
  00189	53		 push	 ebx
  0018a	52		 push	 edx
  0018b	89 45 ec	 mov	 DWORD PTR _iWidth$[ebp], eax
  0018e	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
  00196	85 c0		 test	 eax, eax
  00198	75 1f		 jne	 SHORT $LN8@CGCreateIt

; 365  : 	{
; 366  : 		MsgOutput(aIndex, "[Smithy]: Need space in the inventory (%dx%d)", iHeight, iWidth);

  0019a	8b 45 ec	 mov	 eax, DWORD PTR _iWidth$[ebp]
  0019d	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001a0	50		 push	 eax
  001a1	53		 push	 ebx
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@DMANOCGH@?$FLSmithy?$FN?3?5Need?5space?5in?5the?5inve@
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  001ad	83 c4 10	 add	 esp, 16			; 00000010H
  001b0	5f		 pop	 edi
  001b1	5e		 pop	 esi
  001b2	5b		 pop	 ebx

; 403  : }

  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c2 08 00	 ret	 8
$LN8@CGCreateIt:

; 367  : 		return;
; 368  : 	}
; 369  : 
; 370  : 	if(g_ZtLicense.CheckUser(eZtUB::Local)		  || 
; 371  : 		g_ZtLicense.CheckUser(eZtUB::SILVER1)	  || 
; 372  : 		g_ZtLicense.CheckUser(eZtUB::SILVER2)	  ||	
; 373  : 		g_ZtLicense.CheckUser(eZtUB::SILVER_Local) )

  001b9	6a 00		 push	 0
  001bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001c0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001c5	84 c0		 test	 al, al
  001c7	75 7b		 jne	 SHORT $LN6@CGCreateIt
  001c9	6a 07		 push	 7
  001cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001d0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001d5	84 c0		 test	 al, al
  001d7	75 6b		 jne	 SHORT $LN6@CGCreateIt
  001d9	6a 08		 push	 8
  001db	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001e0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001e5	84 c0		 test	 al, al
  001e7	75 5b		 jne	 SHORT $LN6@CGCreateIt
  001e9	6a 2b		 push	 43			; 0000002bH
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001f0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001f5	84 c0		 test	 al, al
  001f7	75 4b		 jne	 SHORT $LN6@CGCreateIt

; 381  : 	}
; 382  : 	else
; 383  : 	{
; 384  : 		if(result > lpUser->GameShop.WCoinC)

  001f9	db 45 f8	 fild	 DWORD PTR _result$[ebp]
  001fc	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  001ff	dc 91 00 23 00
	00		 fcom	 QWORD PTR [ecx+8960]
  00205	df e0		 fnstsw	 ax
  00207	f6 c4 41	 test	 ah, 65			; 00000041H
  0020a	75 1d		 jne	 SHORT $LN3@CGCreateIt

; 385  : 		{
; 386  : 			MsgOutput(aIndex, "[Smithy]: Price: %d", result);

  0020c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0020f	dd d8		 fstp	 ST(0)
  00211	57		 push	 edi
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@
  00217	52		 push	 edx
  00218	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0021d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5b		 pop	 ebx

; 403  : }

  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	c2 08 00	 ret	 8
$LN3@CGCreateIt:

; 387  : 			return;
; 388  : 		}
; 389  : 		lpUser->GameShop.WCoinC -= result;

  00229	dc a9 00 23 00
	00		 fsubr	 QWORD PTR [ecx+8960]

; 390  : 		gGameShop.GDSaveUserInfo(lpUser->m_Index);

  0022f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00231	50		 push	 eax
  00232	dd 99 00 23 00
	00		 fstp	 QWORD PTR [ecx+8960]
  00238	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  0023d	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
  00242	eb 44		 jmp	 SHORT $LN4@CGCreateIt
$LN6@CGCreateIt:

; 374  : 	{
; 375  : 		if(result > lpUser->ZtCred)

  00244	db 45 f8	 fild	 DWORD PTR _result$[ebp]
  00247	8b 4d f4	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0024a	d9 5d ec	 fstp	 DWORD PTR tv578[ebp]
  0024d	d9 45 ec	 fld	 DWORD PTR tv578[ebp]
  00250	d9 81 a8 22 00
	00		 fld	 DWORD PTR [ecx+8872]
  00256	d8 d9		 fcomp	 ST(1)
  00258	df e0		 fnstsw	 ax
  0025a	f6 c4 05	 test	 ah, 5
  0025d	7a 1d		 jp	 SHORT $LN5@CGCreateIt

; 376  : 		{
; 377  : 			MsgOutput(aIndex, "[Smithy]: Price: %d", result);

  0025f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00262	dd d8		 fstp	 ST(0)
  00264	57		 push	 edi
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CGICHGDD@?$FLSmithy?$FN?3?5Price?3?5?$CFd?$AA@
  0026a	51		 push	 ecx
  0026b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00270	83 c4 0c	 add	 esp, 12			; 0000000cH
  00273	5f		 pop	 edi
  00274	5e		 pop	 esi
  00275	5b		 pop	 ebx

; 403  : }

  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c2 08 00	 ret	 8
$LN5@CGCreateIt:

; 378  : 			return;
; 379  : 		}
; 380  : 		lpUser->ZtCred -= result;

  0027c	d8 a9 a8 22 00
	00		 fsubr	 DWORD PTR [ecx+8872]
  00282	d9 99 a8 22 00
	00		 fstp	 DWORD PTR [ecx+8872]
$LN4@CGCreateIt:

; 391  : 	}
; 392  : 
; 393  : #if(SYSTEM_ACHIEVEMENTS)
; 394  : 	if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || g_ZtLicense.CheckUser(eZtUB::GredyLocal))

  00288	6a 20		 push	 32			; 00000020H
  0028a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0028f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00294	84 c0		 test	 al, al
  00296	75 20		 jne	 SHORT $LN1@CGCreateIt
  00298	6a 22		 push	 34			; 00000022H
  0029a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0029f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002a4	84 c0		 test	 al, al
  002a6	75 10		 jne	 SHORT $LN1@CGCreateIt
  002a8	6a 21		 push	 33			; 00000021H
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002af	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002b4	84 c0		 test	 al, al
  002b6	74 11		 je	 SHORT $LN29@CGCreateIt
$LN1@CGCreateIt:

; 395  : 	{
; 396  : 		g_Achievements.BuyDonateShopItem(aIndex, result);

  002b8	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  002bb	57		 push	 edi
  002bc	53		 push	 ebx
  002bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  002c2	e8 00 00 00 00	 call	 ?BuyDonateShopItem@CAchievements@@QAEXHH@Z ; CAchievements::BuyDonateShopItem
  002c7	eb 03		 jmp	 SHORT $LN2@CGCreateIt
$LN29@CGCreateIt:
  002c9	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
$LN2@CGCreateIt:

; 397  : 	}
; 398  : #endif
; 399  : 
; 400  : 	ZtUserDataSend(aIndex);

  002cc	53		 push	 ebx
  002cd	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend

; 401  : 	ItemSerialCreateSend(aIndex, 235, lpUser->X, lpUser->Y, iType, aRecv->ItemLevel, 0, 1, aRecv->ItemLuck, aRecv->ItemAdd, aIndex, NewOption, 0);

  002d2	8b 55 08	 mov	 edx, DWORD PTR _NewOption$[ebp]
  002d5	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  002d9	0f b6 4e 08	 movzx	 ecx, BYTE PTR [esi+8]
  002dd	6a 00		 push	 0
  002df	52		 push	 edx
  002e0	0f b6 56 06	 movzx	 edx, BYTE PTR [esi+6]
  002e4	53		 push	 ebx
  002e5	50		 push	 eax
  002e6	0f bf 45 f0	 movsx	 eax, WORD PTR _iType$[ebp]
  002ea	51		 push	 ecx
  002eb	6a 01		 push	 1
  002ed	6a 00		 push	 0
  002ef	52		 push	 edx
  002f0	50		 push	 eax
  002f1	8b 45 f4	 mov	 eax, DWORD PTR _lpUser$[ebp]
  002f4	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  002fb	0f b6 90 44 01
	00 00		 movzx	 edx, BYTE PTR [eax+324]
  00302	51		 push	 ecx
  00303	52		 push	 edx
  00304	68 eb 00 00 00	 push	 235			; 000000ebH
  00309	53		 push	 ebx
  0030a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 402  : 	MsgOutput(aIndex, "[Smithy]: Create Item", result);

  0030f	57		 push	 edi
  00310	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PFFJBJKG@?$FLSmithy?$FN?3?5Create?5Item?$AA@
  00315	53		 push	 ebx
  00316	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0031b	83 c4 44	 add	 esp, 68			; 00000044H
$LN30@CGCreateIt:
  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
$LN21@CGCreateIt:

; 403  : }

  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c2 08 00	 ret	 8
?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z ENDP ; CSmithy::CGCreateItem
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z PROC ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@V?$allocator@USmithyDATA@@@1@@Z ENDP ; std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00008	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0000d	c1 f8 03	 sar	 eax, 3
  00010	8b c8		 mov	 ecx, eax
  00012	d1 e9		 shr	 ecx, 1
  00014	2b d1		 sub	 edx, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	73 04		 jae	 SHORT $LN4@Grow_to
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001e	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	3b c1		 cmp	 eax, ecx
  00025	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00027	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IBEII@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z PROC ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ENDP ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z ; std::_Allocate<SmithyDATA>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z
_TEXT	SEGMENT
$T212036 = -12						; size = 12
$T212041 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z PROC ; std::_Allocate<SmithyDATA>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T212041[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T212036[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T212041[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T212036[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T212036[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@USmithyDATA@@@std@@YAPAUSmithyDATA@@IPAU1@@Z ENDP ; std::_Allocate<SmithyDATA>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z ; std::allocator<SmithyDATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z PROC ; std::allocator<SmithyDATA>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN5@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN5@construct@2:

; 198  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@ABU3@@Z ENDP ; std::allocator<SmithyDATA>::construct
_TEXT	ENDS
PUBLIC	??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<SmithyDATA *,SmithyDATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<SmithyDATA *,SmithyDATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL3@Move
  00025	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<SmithyDATA *,SmithyDATA *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z ; std::allocator<SmithyDATA>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z PROC ; std::allocator<SmithyDATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@@Z ENDP ; std::allocator<SmithyDATA>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z ; std::allocator<SmithyDATA>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z PROC ; std::allocator<SmithyDATA>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@3:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@USmithyDATA@@@std@@QAEXPAUSmithyDATA@@$$QAU3@@Z ENDP ; std::allocator<SmithyDATA>::construct
_TEXT	ENDS
PUBLIC	??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::vector<SmithyDATA,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QAE@PAUSmithyDATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::_Vector_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<SmithyDATA,std::allocator<SmithyDATA> > >::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::allocate
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z
_TEXT	SEGMENT
$T212144 = -12						; size = 12
$T212142 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z PROC ; std::allocator<SmithyDATA>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T212142[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T212144[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T212142[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T212144[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T212144[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z ENDP ; std::allocator<SmithyDATA>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z PROC ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN9@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Cons_val@2:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ENDP ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z ; std::_Move<SmithyDATA *,SmithyDATA *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z PROC ; std::_Move<SmithyDATA *,SmithyDATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN5@Move@2
  00010	56		 push	 esi
$LL7@Move@2:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL7@Move@2
  00025	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUSmithyDATA@@PAU1@@std@@YAPAUSmithyDATA@@PAU1@00@Z ENDP ; std::_Move<SmithyDATA *,SmithyDATA *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z PROC ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@@Z ENDP ; std::_Dest_val<std::allocator<SmithyDATA>,SmithyDATA>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@3:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>
_TEXT	ENDS
PUBLIC	?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<SmithyDATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@U3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@$$QAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA>
  0001e	83 c6 08	 add	 esi, 8
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 08	 add	 edi, 8
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z ; std::_Destroy_range<std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SmithyDATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@USmithyDATA@@@std@@@std@@YAXPAUSmithyDATA@@0AAV?$allocator@USmithyDATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z
_TEXT	SEGMENT
__Cat$212337 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z PROC ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$212337[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@@Z ENDP ; std::_Uninitialized_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXPAUSmithyDATA@@0@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$212359 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$212359[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUSmithyDATA@@@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEPAUSmithyDATA@@PAU2@00@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Umove<SmithyDATA *>
_TEXT	ENDS
PUBLIC	?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 26		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 1a		 je	 SHORT $LN30@erase
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00027	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002a	83 c2 08	 add	 edx, 8
  0002d	83 c6 08	 add	 esi, 8
  00030	3b d7		 cmp	 edx, edi
  00032	75 ec		 jne	 SHORT $LL32@erase
  00034	5b		 pop	 ebx
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00035	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00038	5f		 pop	 edi
$LN1@erase:
  00039	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$211045 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$212530 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00030	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00035	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00041	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00044	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00046	c1 f9 03	 sar	 ecx, 3
  00049	3b c8		 cmp	 ecx, eax
  0004b	73 56		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0004d	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00050	50		 push	 eax
  00051	8b cf		 mov	 ecx, edi
  00053	e8 00 00 00 00	 call	 ?allocate@?$allocator@USmithyDATA@@@std@@QAEPAUSmithyDATA@@I@Z ; std::allocator<SmithyDATA>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00058	8b 55 08	 mov	 edx, DWORD PTR __Cat$212530[ebp]
  0005b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b d8		 mov	 ebx, eax
  00062	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00065	57		 push	 edi
  00066	53		 push	 ebx
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	89 5d ec	 mov	 DWORD PTR __Ptr$211045[ebp], ebx
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00073	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSmithyDATA@@PAU1@V?$allocator@USmithyDATA@@@std@@U1@@std@@YAPAUSmithyDATA@@PAU1@00AAV?$allocator@USmithyDATA@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SmithyDATA *,SmithyDATA *,std::allocator<SmithyDATA>,SmithyDATA>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00078	8b 06		 mov	 eax, DWORD PTR [esi]
  0007a	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0007d	2b f8		 sub	 edi, eax
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	c1 ff 03	 sar	 edi, 3

; 761  : 			if (this->_Myfirst != 0)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00095	8d 0c c3	 lea	 ecx, DWORD PTR [ebx+eax*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  00098	8d 14 fb	 lea	 edx, DWORD PTR [ebx+edi*8]
  0009b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0009e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000a1	89 1e		 mov	 DWORD PTR [esi], ebx
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
__catch$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000b7	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$211045[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c0	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
PUBLIC	??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::~vector<SmithyDATA,std::allocator<SmithyDATA> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear, COMDAT
; _this$ = ecx

; 1218 : 		erase(begin(), end());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	3b d6		 cmp	 edx, esi
  00008	74 1f		 je	 SHORT $LN19@clear
  0000a	8b c6		 mov	 eax, esi
  0000c	3b f6		 cmp	 esi, esi
  0000e	74 16		 je	 SHORT $LN48@clear
  00010	57		 push	 edi
$LL50@clear:
  00011	8b 38		 mov	 edi, DWORD PTR [eax]
  00013	89 3a		 mov	 DWORD PTR [edx], edi
  00015	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00018	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  0001b	83 c0 08	 add	 eax, 8
  0001e	83 c2 08	 add	 edx, 8
  00021	3b c6		 cmp	 eax, esi
  00023	75 ec		 jne	 SHORT $LL50@clear
  00025	5f		 pop	 edi
$LN48@clear:
  00026	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN19@clear:
  00029	5e		 pop	 esi

; 1219 : 		}

  0002a	c3		 ret	 0
?clear@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXXZ ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1292 : 		if (max_size() - _Count < _Size)

  00006	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	57		 push	 edi
  0000d	2b c6		 sub	 eax, esi
  0000f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00014	c1 f8 03	 sar	 eax, 3
  00017	2b fa		 sub	 edi, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00022	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00027	03 c2		 add	 eax, edx
  00029	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002c	2b d6		 sub	 edx, esi
  0002e	c1 fa 03	 sar	 edx, 3
  00031	3b c2		 cmp	 eax, edx
  00033	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00035	8b f2		 mov	 esi, edx
  00037	d1 ee		 shr	 esi, 1
  00039	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003e	2b fe		 sub	 edi, esi
  00040	3b fa		 cmp	 edi, edx
  00042	73 04		 jae	 SHORT $LN23@Reserve
  00044	33 d2		 xor	 edx, edx
  00046	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00048	03 d6		 add	 edx, esi
$LN24@Reserve:
  0004a	3b d0		 cmp	 edx, eax
  0004c	73 02		 jae	 SHORT $LN20@Reserve
  0004e	8b d0		 mov	 edx, eax
$LN20@Reserve:
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
$LN1@Reserve:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1298 : 		}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
_TEXT	ENDS
PUBLIC	??1CSmithy@@QAE@XZ				; CSmithy::~CSmithy
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\smithy.cpp
;	COMDAT ??1CSmithy@@QAE@XZ
_TEXT	SEGMENT
??1CSmithy@@QAE@XZ PROC					; CSmithy::~CSmithy, COMDAT
; _this$ = ecx

; 21   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 22   : }

  00003	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN11@CSmithy
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN11@CSmithy:
  00013	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0001a	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00021	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00028	5e		 pop	 esi
  00029	c3		 ret	 0
??1CSmithy@@QAE@XZ ENDP					; CSmithy::~CSmithy
_TEXT	ENDS
PUBLIC	?Init@CSmithy@@QAEXXZ				; CSmithy::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CSmithy@@QAEXXZ
_TEXT	SEGMENT
?Init@CSmithy@@QAEXXZ PROC				; CSmithy::Init, COMDAT
; _this$ = ecx

; 26   : 	this->itemdata.clear();

  00000	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00003	56		 push	 esi
  00004	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  00007	3b d6		 cmp	 edx, esi
  00009	74 1f		 je	 SHORT $LN21@Init
  0000b	8b c6		 mov	 eax, esi
  0000d	3b f6		 cmp	 esi, esi
  0000f	74 16		 je	 SHORT $LN50@Init
  00011	57		 push	 edi
$LL52@Init:
  00012	8b 38		 mov	 edi, DWORD PTR [eax]
  00014	89 3a		 mov	 DWORD PTR [edx], edi
  00016	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00019	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  0001c	83 c0 08	 add	 eax, 8
  0001f	83 c2 08	 add	 edx, 8
  00022	3b c6		 cmp	 eax, esi
  00024	75 ec		 jne	 SHORT $LL52@Init
  00026	5f		 pop	 edi
$LN50@Init:
  00027	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
$LN21@Init:

; 27   : 	this->MaxLevel = 0;
; 28   : 	this->LevelPrice = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0002f	89 41 02	 mov	 DWORD PTR [ecx+2], eax

; 29   : 	this->LuckPrice = 0;
; 30   : 	this->AddPrice = 0;

  00032	89 41 06	 mov	 DWORD PTR [ecx+6], eax

; 31   : 	this->Opt1Price = 0;
; 32   : 	this->Opt2Price = 0;

  00035	89 41 0a	 mov	 DWORD PTR [ecx+10], eax

; 33   : 	this->Opt3Price = 0;
; 34   : 	this->Opt4Price = 0;

  00038	89 41 0e	 mov	 DWORD PTR [ecx+14], eax

; 35   : 	this->Opt5Price = 0;
; 36   : 	this->Opt6Price = 0;

  0003b	c7 41 12 00 00
	06 00		 mov	 DWORD PTR [ecx+18], 393216 ; 00060000H
  00042	5e		 pop	 esi

; 37   : 	this->MaxExlOpt = 6;
; 38   : }

  00043	c3		 ret	 0
?Init@CSmithy@@QAEXXZ ENDP				; CSmithy::Init
_TEXT	ENDS
PUBLIC	?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z PROC ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 39		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 33		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00032	51		 push	 ecx
  00033	52		 push	 edx
  00034	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00040	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0004a	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@IAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	57		 push	 edi
  0005c	51		 push	 ecx
  0005d	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00069	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ENDP ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
_TEXT	ENDS
PUBLIC	??0CSmithy@@QAE@XZ				; CSmithy::CSmithy
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\smithy.cpp
;	COMDAT ??0CSmithy@@QAE@XZ
_TEXT	SEGMENT
??0CSmithy@@QAE@XZ PROC					; CSmithy::CSmithy, COMDAT
; _this$ = ecx

; 16   : {

  00000	33 c0		 xor	 eax, eax
  00002	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00005	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00008	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 17   : 	this->Init();

  0000b	e8 00 00 00 00	 call	 ?Init@CSmithy@@QAEXXZ	; CSmithy::Init

; 18   : }

  00010	8b c1		 mov	 eax, ecx
  00012	c3		 ret	 0
??0CSmithy@@QAE@XZ ENDP					; CSmithy::CSmithy
_TEXT	ENDS
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?Read@CSmithy@@QAEXPAD@Z			; CSmithy::Read
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@ DB '[Smit'
	DB	'hy] %s file not found', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\smithy.cpp
CONST	ENDS
;	COMDAT ?Read@CSmithy@@QAEXPAD@Z
_TEXT	SEGMENT
_lpData$210736 = -76					; size = 8
_lpData$210732 = -68					; size = 8
_lpData$210728 = -60					; size = 8
_lpData$210724 = -52					; size = 8
_lpData$210720 = -44					; size = 8
_lpData$210716 = -36					; size = 8
_lpData$210712 = -28					; size = 8
tv2188 = -20						; size = 8
tv2128 = -20						; size = 8
tv2068 = -20						; size = 8
tv2005 = -20						; size = 8
tv1947 = -20						; size = 8
tv1904 = -20						; size = 8
tv1861 = -20						; size = 8
tv2320 = -16						; size = 4
tv2318 = -16						; size = 4
tv2312 = -16						; size = 4
tv2310 = -16						; size = 4
tv2303 = -16						; size = 4
tv2301 = -16						; size = 4
tv2295 = -16						; size = 4
tv2293 = -16						; size = 4
tv2286 = -16						; size = 4
tv2284 = -16						; size = 4
tv2278 = -16						; size = 4
tv2276 = -16						; size = 4
tv2269 = -16						; size = 4
tv2266 = -16						; size = 4
tv2260 = -16						; size = 4
tv2258 = -16						; size = 4
tv2252 = -16						; size = 4
tv2250 = -16						; size = 4
tv2244 = -16						; size = 4
tv2242 = -16						; size = 4
tv2236 = -16						; size = 4
tv2234 = -16						; size = 4
tv2209 = -16						; size = 4
tv2206 = -16						; size = 4
tv2200 = -16						; size = 4
tv2198 = -16						; size = 4
tv2191 = -16						; size = 4
tv2148 = -16						; size = 4
tv2145 = -16						; size = 4
tv2139 = -16						; size = 4
tv2137 = -16						; size = 4
tv2131 = -16						; size = 4
tv2086 = -16						; size = 4
tv2084 = -16						; size = 4
tv2078 = -16						; size = 4
tv2076 = -16						; size = 4
tv2070 = -16						; size = 4
tv2023 = -16						; size = 4
tv2021 = -16						; size = 4
tv2015 = -16						; size = 4
tv2013 = -16						; size = 4
tv2007 = -16						; size = 4
tv1965 = -16						; size = 4
tv1963 = -16						; size = 4
tv1957 = -16						; size = 4
tv1955 = -16						; size = 4
tv1949 = -16						; size = 4
tv1922 = -16						; size = 4
tv1920 = -16						; size = 4
tv1914 = -16						; size = 4
tv1912 = -16						; size = 4
tv1906 = -16						; size = 4
tv1879 = -16						; size = 4
tv1877 = -16						; size = 4
tv1871 = -16						; size = 4
tv1869 = -16						; size = 4
tv1863 = -16						; size = 4
_Type$210702 = -12					; size = 4
_this$ = -8						; size = 4
tv2323 = -2						; size = 2
tv2315 = -2						; size = 2
tv2307 = -2						; size = 2
tv2298 = -2						; size = 2
tv2290 = -2						; size = 2
tv2281 = -2						; size = 2
tv2272 = -2						; size = 2
tv2263 = -2						; size = 2
tv2255 = -2						; size = 2
tv2247 = -2						; size = 2
tv2239 = -2						; size = 2
tv2212 = -2						; size = 2
tv2203 = -2						; size = 2
tv2194 = -2						; size = 2
tv2151 = -2						; size = 2
tv2142 = -2						; size = 2
tv2134 = -2						; size = 2
tv2089 = -2						; size = 2
tv2081 = -2						; size = 2
tv2073 = -2						; size = 2
tv2027 = -2						; size = 2
tv2018 = -2						; size = 2
tv2010 = -2						; size = 2
tv1968 = -2						; size = 2
tv1960 = -2						; size = 2
tv1952 = -2						; size = 2
tv1925 = -2						; size = 2
tv1917 = -2						; size = 2
tv1909 = -2						; size = 2
tv1882 = -2						; size = 2
tv1874 = -2						; size = 2
tv1866 = -2						; size = 2
_filename$ = 8						; size = 4
?Read@CSmithy@@QAEXPAD@Z PROC				; CSmithy::Read, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 52   : 	SMDToken Token;
; 53   : 	SMDFile = fopen(filename, "r");

  00008	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00012	56		 push	 esi
  00013	89 5d f8	 mov	 DWORD PTR _this$[ebp], ebx
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	83 c4 08	 add	 esp, 8
  0001e	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 54   : 
; 55   : 	if(!SMDFile)

  00023	85 c0		 test	 eax, eax
  00025	75 16		 jne	 SHORT $LN365@Read

; 56   : 	{
; 57   : 		MsgBox("[Smithy] %s file not found", filename);

  00027	56		 push	 esi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CEHJIBPA@?$FLSmithy?$FN?5?$CFs?5file?5not?5found?$AA@
  0002d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00032	83 c4 08	 add	 esp, 8
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 220  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN365@Read:

; 58   : 		return;
; 59   : 	}
; 60   : 
; 61   : 	while(true)
; 62   : 	{
; 63   : 		SMDToken Token = GetToken();

  0003d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 64   : 
; 65   : 		if( Token == END )

  00042	83 f8 02	 cmp	 eax, 2
  00045	0f 84 df 09 00
	00		 je	 $LN384@Read
  0004b	57		 push	 edi
  0004c	8d 64 24 00	 npad	 4
$LL27@Read:

; 66   : 		{
; 67   : 			break;
; 68   : 		}
; 69   : 
; 70   : 		int Type = (int)TokenNumber;

  00050	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00056	e8 00 00 00 00	 call	 __ftol2_sse
  0005b	89 45 f4	 mov	 DWORD PTR _Type$210702[ebp], eax
  0005e	8b ff		 npad	 2
$LL24@Read:

; 71   : 
; 72   : 		while(true)
; 73   : 		{
; 74   : 			if(Type == 0)

  00060	8b 45 f4	 mov	 eax, DWORD PTR _Type$210702[ebp]
  00063	85 c0		 test	 eax, eax
  00065	0f 85 18 02 00
	00		 jne	 $LN22@Read

; 75   : 			{
; 76   : 				Token = GetToken();

  0006b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 77   : 				if(!strcmp("end", TokenString))

  00070	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00075	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL389@Read:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN390@Read
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN421@Read
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN390@Read
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL389@Read
$LN421@Read:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN392@Read
$LN390@Read:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 d8 ff	 sbb	 eax, -1
$LN392@Read:
  000a5	85 c0		 test	 eax, eax
  000a7	0f 84 6b 09 00
	00		 je	 $LN423@Read

; 78   : 				{
; 79   : 					break;
; 80   : 				}
; 81   : 				this->MaxLevel = TokenNumber;

  000ad	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000b3	d9 7d fe	 fnstcw	 WORD PTR tv2323[ebp]
  000b6	0f b7 45 fe	 movzx	 eax, WORD PTR tv2323[ebp]
  000ba	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000bf	89 45 f0	 mov	 DWORD PTR tv2320[ebp], eax
  000c2	d9 6d f0	 fldcw	 WORD PTR tv2320[ebp]
  000c5	db 5d f0	 fistp	 DWORD PTR tv2318[ebp]
  000c8	8a 45 f0	 mov	 al, BYTE PTR tv2318[ebp]
  000cb	88 03		 mov	 BYTE PTR [ebx], al
  000cd	d9 6d fe	 fldcw	 WORD PTR tv2323[ebp]

; 82   : 				Token = GetToken();

  000d0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 83   : 				this->LevelPrice = TokenNumber;

  000d5	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000db	d9 7d fe	 fnstcw	 WORD PTR tv2315[ebp]
  000de	0f b7 45 fe	 movzx	 eax, WORD PTR tv2315[ebp]
  000e2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000e7	89 45 f0	 mov	 DWORD PTR tv2312[ebp], eax
  000ea	d9 6d f0	 fldcw	 WORD PTR tv2312[ebp]
  000ed	db 5d f0	 fistp	 DWORD PTR tv2310[ebp]
  000f0	0f b7 4d f0	 movzx	 ecx, WORD PTR tv2310[ebp]
  000f4	66 89 4b 02	 mov	 WORD PTR [ebx+2], cx
  000f8	d9 6d fe	 fldcw	 WORD PTR tv2315[ebp]

; 84   : 				Token = GetToken();

  000fb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 85   : 				this->LuckPrice = TokenNumber;

  00100	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00106	d9 7d fe	 fnstcw	 WORD PTR tv2307[ebp]
  00109	0f b7 45 fe	 movzx	 eax, WORD PTR tv2307[ebp]
  0010d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00112	89 45 f0	 mov	 DWORD PTR tv2303[ebp], eax
  00115	d9 6d f0	 fldcw	 WORD PTR tv2303[ebp]
  00118	db 5d f0	 fistp	 DWORD PTR tv2301[ebp]
  0011b	0f b7 55 f0	 movzx	 edx, WORD PTR tv2301[ebp]
  0011f	66 89 53 04	 mov	 WORD PTR [ebx+4], dx
  00123	d9 6d fe	 fldcw	 WORD PTR tv2307[ebp]

; 86   : 				Token = GetToken();

  00126	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 87   : 				this->AddPrice = TokenNumber;

  0012b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00131	d9 7d fe	 fnstcw	 WORD PTR tv2298[ebp]
  00134	0f b7 45 fe	 movzx	 eax, WORD PTR tv2298[ebp]
  00138	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0013d	89 45 f0	 mov	 DWORD PTR tv2295[ebp], eax
  00140	d9 6d f0	 fldcw	 WORD PTR tv2295[ebp]
  00143	db 5d f0	 fistp	 DWORD PTR tv2293[ebp]
  00146	0f b7 45 f0	 movzx	 eax, WORD PTR tv2293[ebp]
  0014a	66 89 43 06	 mov	 WORD PTR [ebx+6], ax
  0014e	d9 6d fe	 fldcw	 WORD PTR tv2298[ebp]

; 88   : 				Token = GetToken();

  00151	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 89   : 				this->Opt1Price = TokenNumber;

  00156	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0015c	d9 7d fe	 fnstcw	 WORD PTR tv2290[ebp]
  0015f	0f b7 45 fe	 movzx	 eax, WORD PTR tv2290[ebp]
  00163	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00168	89 45 f0	 mov	 DWORD PTR tv2286[ebp], eax
  0016b	d9 6d f0	 fldcw	 WORD PTR tv2286[ebp]
  0016e	db 5d f0	 fistp	 DWORD PTR tv2284[ebp]
  00171	0f b7 4d f0	 movzx	 ecx, WORD PTR tv2284[ebp]
  00175	66 89 4b 08	 mov	 WORD PTR [ebx+8], cx
  00179	d9 6d fe	 fldcw	 WORD PTR tv2290[ebp]

; 90   : 				Token = GetToken();

  0017c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 91   : 				this->Opt2Price = TokenNumber;

  00181	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00187	d9 7d fe	 fnstcw	 WORD PTR tv2281[ebp]
  0018a	0f b7 45 fe	 movzx	 eax, WORD PTR tv2281[ebp]
  0018e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00193	89 45 f0	 mov	 DWORD PTR tv2278[ebp], eax
  00196	d9 6d f0	 fldcw	 WORD PTR tv2278[ebp]
  00199	db 5d f0	 fistp	 DWORD PTR tv2276[ebp]
  0019c	0f b7 55 f0	 movzx	 edx, WORD PTR tv2276[ebp]
  001a0	66 89 53 0a	 mov	 WORD PTR [ebx+10], dx
  001a4	d9 6d fe	 fldcw	 WORD PTR tv2281[ebp]

; 92   : 				Token = GetToken();

  001a7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 93   : 				this->Opt3Price = TokenNumber;

  001ac	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001b2	d9 7d fe	 fnstcw	 WORD PTR tv2272[ebp]
  001b5	0f b7 45 fe	 movzx	 eax, WORD PTR tv2272[ebp]
  001b9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001be	89 45 f0	 mov	 DWORD PTR tv2269[ebp], eax
  001c1	d9 6d f0	 fldcw	 WORD PTR tv2269[ebp]
  001c4	db 5d f0	 fistp	 DWORD PTR tv2266[ebp]
  001c7	0f b7 45 f0	 movzx	 eax, WORD PTR tv2266[ebp]
  001cb	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
  001cf	d9 6d fe	 fldcw	 WORD PTR tv2272[ebp]

; 94   : 				Token = GetToken();

  001d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 95   : 				this->Opt4Price = TokenNumber;

  001d7	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001dd	d9 7d fe	 fnstcw	 WORD PTR tv2263[ebp]
  001e0	0f b7 45 fe	 movzx	 eax, WORD PTR tv2263[ebp]
  001e4	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001e9	89 45 f0	 mov	 DWORD PTR tv2260[ebp], eax
  001ec	d9 6d f0	 fldcw	 WORD PTR tv2260[ebp]
  001ef	db 5d f0	 fistp	 DWORD PTR tv2258[ebp]
  001f2	0f b7 4d f0	 movzx	 ecx, WORD PTR tv2258[ebp]
  001f6	66 89 4b 0e	 mov	 WORD PTR [ebx+14], cx
  001fa	d9 6d fe	 fldcw	 WORD PTR tv2263[ebp]

; 96   : 				Token = GetToken();

  001fd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 97   : 				this->Opt5Price = TokenNumber;

  00202	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00208	d9 7d fe	 fnstcw	 WORD PTR tv2255[ebp]
  0020b	0f b7 45 fe	 movzx	 eax, WORD PTR tv2255[ebp]
  0020f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00214	89 45 f0	 mov	 DWORD PTR tv2252[ebp], eax
  00217	d9 6d f0	 fldcw	 WORD PTR tv2252[ebp]
  0021a	db 5d f0	 fistp	 DWORD PTR tv2250[ebp]
  0021d	0f b7 55 f0	 movzx	 edx, WORD PTR tv2250[ebp]
  00221	66 89 53 10	 mov	 WORD PTR [ebx+16], dx
  00225	d9 6d fe	 fldcw	 WORD PTR tv2255[ebp]

; 98   : 				Token = GetToken();

  00228	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 99   : 				this->Opt6Price = TokenNumber;

  0022d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00233	d9 7d fe	 fnstcw	 WORD PTR tv2247[ebp]
  00236	0f b7 45 fe	 movzx	 eax, WORD PTR tv2247[ebp]
  0023a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0023f	89 45 f0	 mov	 DWORD PTR tv2244[ebp], eax
  00242	d9 6d f0	 fldcw	 WORD PTR tv2244[ebp]
  00245	db 5d f0	 fistp	 DWORD PTR tv2242[ebp]
  00248	0f b7 45 f0	 movzx	 eax, WORD PTR tv2242[ebp]
  0024c	66 89 43 12	 mov	 WORD PTR [ebx+18], ax
  00250	d9 6d fe	 fldcw	 WORD PTR tv2247[ebp]

; 100  : 				Token = GetToken();

  00253	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 101  : 				this->MaxExlOpt = TokenNumber;

  00258	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0025e	d9 7d fe	 fnstcw	 WORD PTR tv2239[ebp]
  00261	0f b7 45 fe	 movzx	 eax, WORD PTR tv2239[ebp]
  00265	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0026a	89 45 f0	 mov	 DWORD PTR tv2236[ebp], eax
  0026d	d9 6d f0	 fldcw	 WORD PTR tv2236[ebp]
  00270	db 5d f0	 fistp	 DWORD PTR tv2234[ebp]
  00273	0f b7 4d f0	 movzx	 ecx, WORD PTR tv2234[ebp]
  00277	66 89 4b 14	 mov	 WORD PTR [ebx+20], cx
  0027b	d9 6d fe	 fldcw	 WORD PTR tv2239[ebp]

; 102  : 			}
; 103  : 			if(Type == 1)

  0027e	e9 dd fd ff ff	 jmp	 $LL24@Read
$LN22@Read:
  00283	83 f8 01	 cmp	 eax, 1
  00286	0f 85 8c 01 00
	00		 jne	 $LN20@Read

; 104  : 			{
; 105  : 				Token = GetToken();

  0028c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 106  : 				if(!strcmp("end", TokenString))

  00291	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00296	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0029b	eb 03 8d 49 00	 npad	 5
$LL393@Read:
  002a0	8a 10		 mov	 dl, BYTE PTR [eax]
  002a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002a4	75 1a		 jne	 SHORT $LN394@Read
  002a6	84 d2		 test	 dl, dl
  002a8	74 12		 je	 SHORT $LN422@Read
  002aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002b0	75 0e		 jne	 SHORT $LN394@Read
  002b2	83 c0 02	 add	 eax, 2
  002b5	83 c1 02	 add	 ecx, 2
  002b8	84 d2		 test	 dl, dl
  002ba	75 e4		 jne	 SHORT $LL393@Read
$LN422@Read:
  002bc	33 c0		 xor	 eax, eax
  002be	eb 05		 jmp	 SHORT $LN396@Read
$LN394@Read:
  002c0	1b c0		 sbb	 eax, eax
  002c2	83 d8 ff	 sbb	 eax, -1
$LN396@Read:
  002c5	85 c0		 test	 eax, eax
  002c7	0f 84 4b 07 00
	00		 je	 $LN423@Read

; 107  : 				{
; 108  : 					break;
; 109  : 				}
; 110  : 				SmithyDATA lpData;
; 111  : 				lpData.Type = TokenNumber;

  002cd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002d3	d9 7d fe	 fnstcw	 WORD PTR tv2212[ebp]
  002d6	0f b7 45 fe	 movzx	 eax, WORD PTR tv2212[ebp]
  002da	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002df	89 45 f0	 mov	 DWORD PTR tv2209[ebp], eax
  002e2	d9 6d f0	 fldcw	 WORD PTR tv2209[ebp]
  002e5	db 5d f0	 fistp	 DWORD PTR tv2206[ebp]
  002e8	8a 55 f0	 mov	 dl, BYTE PTR tv2206[ebp]
  002eb	88 55 e5	 mov	 BYTE PTR _lpData$210712[ebp+1], dl
  002ee	d9 6d fe	 fldcw	 WORD PTR tv2212[ebp]

; 112  : 				Token = GetToken();

  002f1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 113  : 				lpData.Index = TokenNumber;
; 114  : 				lpData.Class = Type-1;

  002f6	c6 45 e4 00	 mov	 BYTE PTR _lpData$210712[ebp], 0
  002fa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00300	d9 7d fe	 fnstcw	 WORD PTR tv2203[ebp]
  00303	0f b7 45 fe	 movzx	 eax, WORD PTR tv2203[ebp]
  00307	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0030c	89 45 f0	 mov	 DWORD PTR tv2200[ebp], eax
  0030f	d9 6d f0	 fldcw	 WORD PTR tv2200[ebp]
  00312	db 5d f0	 fistp	 DWORD PTR tv2198[ebp]
  00315	8a 45 f0	 mov	 al, BYTE PTR tv2198[ebp]
  00318	88 45 e6	 mov	 BYTE PTR _lpData$210712[ebp+2], al
  0031b	d9 6d fe	 fldcw	 WORD PTR tv2203[ebp]

; 115  : 				Token = GetToken();

  0031e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 116  : 				lpData.Price = TokenNumber;
; 117  : 				this->itemdata.push_back(lpData);

  00323	8d 73 18	 lea	 esi, DWORD PTR [ebx+24]
  00326	8d 55 e4	 lea	 edx, DWORD PTR _lpData$210712[ebp]
  00329	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0032f	d9 7d fe	 fnstcw	 WORD PTR tv2194[ebp]
  00332	0f b7 45 fe	 movzx	 eax, WORD PTR tv2194[ebp]
  00336	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0033b	89 45 f0	 mov	 DWORD PTR tv2191[ebp], eax
  0033e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00341	d9 6d f0	 fldcw	 WORD PTR tv2191[ebp]
  00344	df 7d ec	 fistp	 QWORD PTR tv2188[ebp]
  00347	8b 4d ec	 mov	 ecx, DWORD PTR tv2188[ebp]
  0034a	89 4d e8	 mov	 DWORD PTR _lpData$210712[ebp+4], ecx
  0034d	d9 6d fe	 fldcw	 WORD PTR tv2194[ebp]
  00350	3b d0		 cmp	 edx, eax
  00352	73 76		 jae	 SHORT $LN34@Read
  00354	8b 16		 mov	 edx, DWORD PTR [esi]
  00356	8d 4d e4	 lea	 ecx, DWORD PTR _lpData$210712[ebp]
  00359	3b d1		 cmp	 edx, ecx
  0035b	77 6d		 ja	 SHORT $LN34@Read
  0035d	8b f9		 mov	 edi, ecx
$LN428@Read:
  0035f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00362	2b fa		 sub	 edi, edx
  00364	c1 ff 03	 sar	 edi, 3
  00367	3b c1		 cmp	 eax, ecx
  00369	75 40		 jne	 SHORT $LN45@Read
  0036b	2b c2		 sub	 eax, edx
  0036d	c1 f8 03	 sar	 eax, 3
  00370	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00375	0f 87 d2 06 00
	00		 ja	 $LN370@Read
  0037b	2b ca		 sub	 ecx, edx
  0037d	40		 inc	 eax
  0037e	c1 f9 03	 sar	 ecx, 3
  00381	3b c1		 cmp	 eax, ecx
  00383	76 26		 jbe	 SHORT $LN45@Read
  00385	8b d1		 mov	 edx, ecx
  00387	d1 ea		 shr	 edx, 1
  00389	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH
  0038e	2b da		 sub	 ebx, edx
  00390	3b d9		 cmp	 ebx, ecx
  00392	73 04		 jae	 SHORT $LN67@Read
  00394	33 c9		 xor	 ecx, ecx
  00396	eb 02		 jmp	 SHORT $LN68@Read
$LN67@Read:
  00398	03 ca		 add	 ecx, edx
$LN68@Read:
  0039a	3b c8		 cmp	 ecx, eax
  0039c	73 02		 jae	 SHORT $LN64@Read
  0039e	8b c8		 mov	 ecx, eax
$LN64@Read:
  003a0	51		 push	 ecx
  003a1	8b ce		 mov	 ecx, esi
  003a3	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
  003a8	8b 5d f8	 mov	 ebx, DWORD PTR _this$[ebp]
$LN45@Read:
  003ab	8b 16		 mov	 edx, DWORD PTR [esi]
  003ad	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  003b0	8d 04 fa	 lea	 eax, DWORD PTR [edx+edi*8]
  003b3	50		 push	 eax
  003b4	51		 push	 ecx
  003b5	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  003b8	52		 push	 edx
  003b9	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@AAU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@AAU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA &>

; 164  : 				lpData.Price = TokenNumber;
; 165  : 				this->itemdata.push_back(lpData);

  003be	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c1	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  003c5	e9 96 fc ff ff	 jmp	 $LL24@Read

; 116  : 				lpData.Price = TokenNumber;
; 117  : 				this->itemdata.push_back(lpData);

$LN34@Read:
  003ca	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  003cd	3b c1		 cmp	 eax, ecx
  003cf	75 3f		 jne	 SHORT $LN80@Read
  003d1	8b 16		 mov	 edx, DWORD PTR [esi]
  003d3	2b c2		 sub	 eax, edx
  003d5	c1 f8 03	 sar	 eax, 3
  003d8	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  003dd	0f 87 6a 06 00
	00		 ja	 $LN370@Read
  003e3	2b ca		 sub	 ecx, edx
  003e5	40		 inc	 eax
  003e6	c1 f9 03	 sar	 ecx, 3
  003e9	3b c1		 cmp	 eax, ecx
  003eb	76 23		 jbe	 SHORT $LN80@Read
  003ed	8b d1		 mov	 edx, ecx
  003ef	d1 ea		 shr	 edx, 1
  003f1	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  003f6	2b fa		 sub	 edi, edx
  003f8	3b f9		 cmp	 edi, ecx
  003fa	73 04		 jae	 SHORT $LN102@Read
  003fc	33 c9		 xor	 ecx, ecx
  003fe	eb 02		 jmp	 SHORT $LN103@Read
$LN102@Read:
  00400	03 ca		 add	 ecx, edx
$LN103@Read:
  00402	3b c8		 cmp	 ecx, eax
  00404	73 02		 jae	 SHORT $LN99@Read
  00406	8b c8		 mov	 ecx, eax
$LN99@Read:
  00408	51		 push	 ecx
  00409	8b ce		 mov	 ecx, esi
  0040b	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
$LN80@Read:
  00410	8d 45 e4	 lea	 eax, DWORD PTR _lpData$210712[ebp]
  00413	e9 72 03 00 00	 jmp	 $LN425@Read
$LN20@Read:

; 118  : 			}
; 119  : 			else if(Type == 2)

  00418	83 f8 02	 cmp	 eax, 2
  0041b	0f 85 1e 01 00
	00		 jne	 $LN17@Read

; 120  : 			{
; 121  : 				Token = GetToken();

  00421	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 122  : 				if(!strcmp("end", TokenString))

  00426	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0042b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL397@Read:
  00430	8a 10		 mov	 dl, BYTE PTR [eax]
  00432	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00434	75 1a		 jne	 SHORT $LN398@Read
  00436	84 d2		 test	 dl, dl
  00438	74 12		 je	 SHORT $LN399@Read
  0043a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0043d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00440	75 0e		 jne	 SHORT $LN398@Read
  00442	83 c0 02	 add	 eax, 2
  00445	83 c1 02	 add	 ecx, 2
  00448	84 d2		 test	 dl, dl
  0044a	75 e4		 jne	 SHORT $LL397@Read
$LN399@Read:
  0044c	33 c0		 xor	 eax, eax
  0044e	eb 05		 jmp	 SHORT $LN400@Read
$LN398@Read:
  00450	1b c0		 sbb	 eax, eax
  00452	83 d8 ff	 sbb	 eax, -1
$LN400@Read:
  00455	85 c0		 test	 eax, eax
  00457	0f 84 bb 05 00
	00		 je	 $LN423@Read

; 123  : 				{
; 124  : 					break;
; 125  : 				}
; 126  : 				SmithyDATA lpData;
; 127  : 				lpData.Type = TokenNumber;

  0045d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00463	d9 7d fe	 fnstcw	 WORD PTR tv2151[ebp]
  00466	0f b7 45 fe	 movzx	 eax, WORD PTR tv2151[ebp]
  0046a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0046f	89 45 f0	 mov	 DWORD PTR tv2148[ebp], eax
  00472	d9 6d f0	 fldcw	 WORD PTR tv2148[ebp]
  00475	db 5d f0	 fistp	 DWORD PTR tv2145[ebp]
  00478	8a 45 f0	 mov	 al, BYTE PTR tv2145[ebp]
  0047b	88 45 dd	 mov	 BYTE PTR _lpData$210716[ebp+1], al
  0047e	d9 6d fe	 fldcw	 WORD PTR tv2151[ebp]

; 128  : 				Token = GetToken();

  00481	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 129  : 				lpData.Index = TokenNumber;
; 130  : 				lpData.Class = Type-1;

  00486	c6 45 dc 01	 mov	 BYTE PTR _lpData$210716[ebp], 1
  0048a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00490	d9 7d fe	 fnstcw	 WORD PTR tv2142[ebp]
  00493	0f b7 45 fe	 movzx	 eax, WORD PTR tv2142[ebp]
  00497	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0049c	89 45 f0	 mov	 DWORD PTR tv2139[ebp], eax
  0049f	d9 6d f0	 fldcw	 WORD PTR tv2139[ebp]
  004a2	db 5d f0	 fistp	 DWORD PTR tv2137[ebp]
  004a5	8a 4d f0	 mov	 cl, BYTE PTR tv2137[ebp]
  004a8	88 4d de	 mov	 BYTE PTR _lpData$210716[ebp+2], cl
  004ab	d9 6d fe	 fldcw	 WORD PTR tv2142[ebp]

; 131  : 				Token = GetToken();

  004ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 132  : 				lpData.Price = TokenNumber;
; 133  : 				this->itemdata.push_back(lpData);

  004b3	8d 73 18	 lea	 esi, DWORD PTR [ebx+24]
  004b6	8d 4d dc	 lea	 ecx, DWORD PTR _lpData$210716[ebp]
  004b9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  004bf	d9 7d fe	 fnstcw	 WORD PTR tv2134[ebp]
  004c2	0f b7 45 fe	 movzx	 eax, WORD PTR tv2134[ebp]
  004c6	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004cb	89 45 f0	 mov	 DWORD PTR tv2131[ebp], eax
  004ce	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  004d1	d9 6d f0	 fldcw	 WORD PTR tv2131[ebp]
  004d4	df 7d ec	 fistp	 QWORD PTR tv2128[ebp]
  004d7	8b 55 ec	 mov	 edx, DWORD PTR tv2128[ebp]
  004da	89 55 e0	 mov	 DWORD PTR _lpData$210716[ebp+4], edx
  004dd	d9 6d fe	 fldcw	 WORD PTR tv2134[ebp]
  004e0	3b c8		 cmp	 ecx, eax
  004e2	73 0d		 jae	 SHORT $LN118@Read
  004e4	8b 16		 mov	 edx, DWORD PTR [esi]
  004e6	3b d1		 cmp	 edx, ecx
  004e8	77 07		 ja	 SHORT $LN118@Read
  004ea	8b f9		 mov	 edi, ecx
  004ec	e9 6e fe ff ff	 jmp	 $LN428@Read
$LN118@Read:
  004f1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004f4	3b c1		 cmp	 eax, ecx
  004f6	75 3f		 jne	 SHORT $LN164@Read
  004f8	8b 16		 mov	 edx, DWORD PTR [esi]
  004fa	2b c2		 sub	 eax, edx
  004fc	c1 f8 03	 sar	 eax, 3
  004ff	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00504	0f 87 43 05 00
	00		 ja	 $LN370@Read
  0050a	2b ca		 sub	 ecx, edx
  0050c	40		 inc	 eax
  0050d	c1 f9 03	 sar	 ecx, 3
  00510	3b c1		 cmp	 eax, ecx
  00512	76 23		 jbe	 SHORT $LN164@Read
  00514	8b d1		 mov	 edx, ecx
  00516	d1 ea		 shr	 edx, 1
  00518	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0051d	2b fa		 sub	 edi, edx
  0051f	3b f9		 cmp	 edi, ecx
  00521	73 04		 jae	 SHORT $LN186@Read
  00523	33 c9		 xor	 ecx, ecx
  00525	eb 02		 jmp	 SHORT $LN187@Read
$LN186@Read:
  00527	03 ca		 add	 ecx, edx
$LN187@Read:
  00529	3b c8		 cmp	 ecx, eax
  0052b	73 02		 jae	 SHORT $LN183@Read
  0052d	8b c8		 mov	 ecx, eax
$LN183@Read:
  0052f	51		 push	 ecx
  00530	8b ce		 mov	 ecx, esi
  00532	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
$LN164@Read:
  00537	8d 45 dc	 lea	 eax, DWORD PTR _lpData$210716[ebp]
  0053a	e9 4b 02 00 00	 jmp	 $LN425@Read
$LN17@Read:

; 134  : 			}
; 135  : 			else if(Type == 3)

  0053f	83 f8 03	 cmp	 eax, 3
  00542	0f 85 1e 01 00
	00		 jne	 $LN14@Read

; 136  : 			{
; 137  : 				Token = GetToken();

  00548	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 138  : 				if(!strcmp("end", TokenString))

  0054d	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00552	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL401@Read:
  00557	8a 10		 mov	 dl, BYTE PTR [eax]
  00559	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0055b	75 1a		 jne	 SHORT $LN402@Read
  0055d	84 d2		 test	 dl, dl
  0055f	74 12		 je	 SHORT $LN403@Read
  00561	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00564	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00567	75 0e		 jne	 SHORT $LN402@Read
  00569	83 c0 02	 add	 eax, 2
  0056c	83 c1 02	 add	 ecx, 2
  0056f	84 d2		 test	 dl, dl
  00571	75 e4		 jne	 SHORT $LL401@Read
$LN403@Read:
  00573	33 c0		 xor	 eax, eax
  00575	eb 05		 jmp	 SHORT $LN404@Read
$LN402@Read:
  00577	1b c0		 sbb	 eax, eax
  00579	83 d8 ff	 sbb	 eax, -1
$LN404@Read:
  0057c	85 c0		 test	 eax, eax
  0057e	0f 84 94 04 00
	00		 je	 $LN423@Read

; 139  : 				{
; 140  : 					break;
; 141  : 				}
; 142  : 				SmithyDATA lpData;
; 143  : 				lpData.Type = TokenNumber;

  00584	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0058a	d9 7d fe	 fnstcw	 WORD PTR tv2089[ebp]
  0058d	0f b7 45 fe	 movzx	 eax, WORD PTR tv2089[ebp]
  00591	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00596	89 45 f0	 mov	 DWORD PTR tv2086[ebp], eax
  00599	d9 6d f0	 fldcw	 WORD PTR tv2086[ebp]
  0059c	db 5d f0	 fistp	 DWORD PTR tv2084[ebp]
  0059f	8a 45 f0	 mov	 al, BYTE PTR tv2084[ebp]
  005a2	88 45 d5	 mov	 BYTE PTR _lpData$210720[ebp+1], al
  005a5	d9 6d fe	 fldcw	 WORD PTR tv2089[ebp]

; 144  : 				Token = GetToken();

  005a8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 145  : 				lpData.Index = TokenNumber;
; 146  : 				lpData.Class = Type-1;

  005ad	c6 45 d4 02	 mov	 BYTE PTR _lpData$210720[ebp], 2
  005b1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005b7	d9 7d fe	 fnstcw	 WORD PTR tv2081[ebp]
  005ba	0f b7 45 fe	 movzx	 eax, WORD PTR tv2081[ebp]
  005be	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005c3	89 45 f0	 mov	 DWORD PTR tv2078[ebp], eax
  005c6	d9 6d f0	 fldcw	 WORD PTR tv2078[ebp]
  005c9	db 5d f0	 fistp	 DWORD PTR tv2076[ebp]
  005cc	8a 4d f0	 mov	 cl, BYTE PTR tv2076[ebp]
  005cf	88 4d d6	 mov	 BYTE PTR _lpData$210720[ebp+2], cl
  005d2	d9 6d fe	 fldcw	 WORD PTR tv2081[ebp]

; 147  : 				Token = GetToken();

  005d5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 148  : 				lpData.Price = TokenNumber;
; 149  : 				this->itemdata.push_back(lpData);

  005da	8d 73 18	 lea	 esi, DWORD PTR [ebx+24]
  005dd	8d 4d d4	 lea	 ecx, DWORD PTR _lpData$210720[ebp]
  005e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  005e6	d9 7d fe	 fnstcw	 WORD PTR tv2073[ebp]
  005e9	0f b7 45 fe	 movzx	 eax, WORD PTR tv2073[ebp]
  005ed	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005f2	89 45 f0	 mov	 DWORD PTR tv2070[ebp], eax
  005f5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  005f8	d9 6d f0	 fldcw	 WORD PTR tv2070[ebp]
  005fb	df 7d ec	 fistp	 QWORD PTR tv2068[ebp]
  005fe	8b 55 ec	 mov	 edx, DWORD PTR tv2068[ebp]
  00601	89 55 d8	 mov	 DWORD PTR _lpData$210720[ebp+4], edx
  00604	d9 6d fe	 fldcw	 WORD PTR tv2073[ebp]
  00607	3b c8		 cmp	 ecx, eax
  00609	73 0d		 jae	 SHORT $LN201@Read
  0060b	8b 16		 mov	 edx, DWORD PTR [esi]
  0060d	3b d1		 cmp	 edx, ecx
  0060f	77 07		 ja	 SHORT $LN201@Read
  00611	8b f9		 mov	 edi, ecx
  00613	e9 47 fd ff ff	 jmp	 $LN428@Read
$LN201@Read:
  00618	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0061b	3b c1		 cmp	 eax, ecx
  0061d	75 3f		 jne	 SHORT $LN247@Read
  0061f	8b 16		 mov	 edx, DWORD PTR [esi]
  00621	2b c2		 sub	 eax, edx
  00623	c1 f8 03	 sar	 eax, 3
  00626	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  0062b	0f 87 1c 04 00
	00		 ja	 $LN370@Read
  00631	2b ca		 sub	 ecx, edx
  00633	40		 inc	 eax
  00634	c1 f9 03	 sar	 ecx, 3
  00637	3b c1		 cmp	 eax, ecx
  00639	76 23		 jbe	 SHORT $LN247@Read
  0063b	8b d1		 mov	 edx, ecx
  0063d	d1 ea		 shr	 edx, 1
  0063f	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  00644	2b fa		 sub	 edi, edx
  00646	3b f9		 cmp	 edi, ecx
  00648	73 04		 jae	 SHORT $LN269@Read
  0064a	33 c9		 xor	 ecx, ecx
  0064c	eb 02		 jmp	 SHORT $LN270@Read
$LN269@Read:
  0064e	03 ca		 add	 ecx, edx
$LN270@Read:
  00650	3b c8		 cmp	 ecx, eax
  00652	73 02		 jae	 SHORT $LN266@Read
  00654	8b c8		 mov	 ecx, eax
$LN266@Read:
  00656	51		 push	 ecx
  00657	8b ce		 mov	 ecx, esi
  00659	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
$LN247@Read:
  0065e	8d 45 d4	 lea	 eax, DWORD PTR _lpData$210720[ebp]
  00661	e9 24 01 00 00	 jmp	 $LN425@Read
$LN14@Read:

; 150  : 			}
; 151  : 			else if(Type == 4)

  00666	83 f8 04	 cmp	 eax, 4
  00669	0f 85 35 01 00
	00		 jne	 $LN11@Read

; 152  : 			{
; 153  : 				Token = GetToken();

  0066f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 154  : 				if(!strcmp("end", TokenString))

  00674	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00679	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0067e	8b ff		 npad	 2
$LL405@Read:
  00680	8a 10		 mov	 dl, BYTE PTR [eax]
  00682	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00684	75 1a		 jne	 SHORT $LN406@Read
  00686	84 d2		 test	 dl, dl
  00688	74 12		 je	 SHORT $LN407@Read
  0068a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0068d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00690	75 0e		 jne	 SHORT $LN406@Read
  00692	83 c0 02	 add	 eax, 2
  00695	83 c1 02	 add	 ecx, 2
  00698	84 d2		 test	 dl, dl
  0069a	75 e4		 jne	 SHORT $LL405@Read
$LN407@Read:
  0069c	33 c0		 xor	 eax, eax
  0069e	eb 05		 jmp	 SHORT $LN408@Read
$LN406@Read:
  006a0	1b c0		 sbb	 eax, eax
  006a2	83 d8 ff	 sbb	 eax, -1
$LN408@Read:
  006a5	85 c0		 test	 eax, eax
  006a7	0f 84 6b 03 00
	00		 je	 $LN423@Read

; 155  : 				{
; 156  : 					break;
; 157  : 				}
; 158  : 				SmithyDATA lpData;
; 159  : 				lpData.Type = TokenNumber;

  006ad	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006b3	d9 7d fe	 fnstcw	 WORD PTR tv2027[ebp]
  006b6	0f b7 45 fe	 movzx	 eax, WORD PTR tv2027[ebp]
  006ba	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  006bf	89 45 f0	 mov	 DWORD PTR tv2023[ebp], eax
  006c2	d9 6d f0	 fldcw	 WORD PTR tv2023[ebp]
  006c5	db 5d f0	 fistp	 DWORD PTR tv2021[ebp]
  006c8	8a 45 f0	 mov	 al, BYTE PTR tv2021[ebp]
  006cb	88 45 cd	 mov	 BYTE PTR _lpData$210724[ebp+1], al
  006ce	d9 6d fe	 fldcw	 WORD PTR tv2027[ebp]

; 160  : 				Token = GetToken();

  006d1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 161  : 				lpData.Index = TokenNumber;
; 162  : 				lpData.Class = Type-1;

  006d6	c6 45 cc 03	 mov	 BYTE PTR _lpData$210724[ebp], 3
  006da	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  006e0	d9 7d fe	 fnstcw	 WORD PTR tv2018[ebp]
  006e3	0f b7 45 fe	 movzx	 eax, WORD PTR tv2018[ebp]
  006e7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  006ec	89 45 f0	 mov	 DWORD PTR tv2015[ebp], eax
  006ef	d9 6d f0	 fldcw	 WORD PTR tv2015[ebp]
  006f2	db 5d f0	 fistp	 DWORD PTR tv2013[ebp]
  006f5	8a 4d f0	 mov	 cl, BYTE PTR tv2013[ebp]
  006f8	88 4d ce	 mov	 BYTE PTR _lpData$210724[ebp+2], cl
  006fb	d9 6d fe	 fldcw	 WORD PTR tv2018[ebp]

; 163  : 				Token = GetToken();

  006fe	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 164  : 				lpData.Price = TokenNumber;
; 165  : 				this->itemdata.push_back(lpData);

  00703	8d 73 18	 lea	 esi, DWORD PTR [ebx+24]
  00706	8d 4d cc	 lea	 ecx, DWORD PTR _lpData$210724[ebp]
  00709	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0070f	d9 7d fe	 fnstcw	 WORD PTR tv2010[ebp]
  00712	0f b7 45 fe	 movzx	 eax, WORD PTR tv2010[ebp]
  00716	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0071b	89 45 f0	 mov	 DWORD PTR tv2007[ebp], eax
  0071e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00721	d9 6d f0	 fldcw	 WORD PTR tv2007[ebp]
  00724	df 7d ec	 fistp	 QWORD PTR tv2005[ebp]
  00727	8b 55 ec	 mov	 edx, DWORD PTR tv2005[ebp]
  0072a	89 55 d0	 mov	 DWORD PTR _lpData$210724[ebp+4], edx
  0072d	d9 6d fe	 fldcw	 WORD PTR tv2010[ebp]
  00730	3b c8		 cmp	 ecx, eax
  00732	73 0d		 jae	 SHORT $LN284@Read
  00734	8b 16		 mov	 edx, DWORD PTR [esi]
  00736	3b d1		 cmp	 edx, ecx
  00738	77 07		 ja	 SHORT $LN284@Read
  0073a	8b f9		 mov	 edi, ecx
  0073c	e9 1e fc ff ff	 jmp	 $LN428@Read
$LN284@Read:
  00741	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00744	3b c1		 cmp	 eax, ecx
  00746	75 3f		 jne	 SHORT $LN330@Read
  00748	8b 16		 mov	 edx, DWORD PTR [esi]
  0074a	2b c2		 sub	 eax, edx
  0074c	c1 f8 03	 sar	 eax, 3
  0074f	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  00754	0f 87 f3 02 00
	00		 ja	 $LN370@Read
  0075a	2b ca		 sub	 ecx, edx
  0075c	40		 inc	 eax
  0075d	c1 f9 03	 sar	 ecx, 3
  00760	3b c1		 cmp	 eax, ecx
  00762	76 23		 jbe	 SHORT $LN330@Read
  00764	8b d1		 mov	 edx, ecx
  00766	d1 ea		 shr	 edx, 1
  00768	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0076d	2b fa		 sub	 edi, edx
  0076f	3b f9		 cmp	 edi, ecx
  00771	73 04		 jae	 SHORT $LN352@Read
  00773	33 c9		 xor	 ecx, ecx
  00775	eb 02		 jmp	 SHORT $LN353@Read
$LN352@Read:
  00777	03 ca		 add	 ecx, edx
$LN353@Read:
  00779	3b c8		 cmp	 ecx, eax
  0077b	73 02		 jae	 SHORT $LN349@Read
  0077d	8b c8		 mov	 ecx, eax
$LN349@Read:
  0077f	51		 push	 ecx
  00780	8b ce		 mov	 ecx, esi
  00782	e8 00 00 00 00	 call	 ?reserve@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXI@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::reserve
$LN330@Read:
  00787	8d 45 cc	 lea	 eax, DWORD PTR _lpData$210724[ebp]
$LN425@Read:
  0078a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0078d	50		 push	 eax
  0078e	51		 push	 ecx
  0078f	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00792	52		 push	 edx
  00793	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@USmithyDATA@@@std@@USmithyDATA@@ABU3@@std@@YAXAAV?$allocator@USmithyDATA@@@0@PAUSmithyDATA@@ABU2@@Z ; std::_Cons_val<std::allocator<SmithyDATA>,SmithyDATA,SmithyDATA const &>
  00798	83 c4 0c	 add	 esp, 12			; 0000000cH
  0079b	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0079f	e9 bc f8 ff ff	 jmp	 $LL24@Read
$LN11@Read:

; 166  : 			}
; 167  : 			else if(Type == 5)

  007a4	83 f8 05	 cmp	 eax, 5
  007a7	0f 85 cb 00 00
	00		 jne	 $LN8@Read

; 168  : 			{
; 169  : 				Token = GetToken();

  007ad	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 170  : 				if(!strcmp("end", TokenString))

  007b2	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  007b7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  007bc	8d 64 24 00	 npad	 4
$LL409@Read:
  007c0	8a 10		 mov	 dl, BYTE PTR [eax]
  007c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  007c4	75 1a		 jne	 SHORT $LN410@Read
  007c6	84 d2		 test	 dl, dl
  007c8	74 12		 je	 SHORT $LN411@Read
  007ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  007cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  007d0	75 0e		 jne	 SHORT $LN410@Read
  007d2	83 c0 02	 add	 eax, 2
  007d5	83 c1 02	 add	 ecx, 2
  007d8	84 d2		 test	 dl, dl
  007da	75 e4		 jne	 SHORT $LL409@Read
$LN411@Read:
  007dc	33 c0		 xor	 eax, eax
  007de	eb 05		 jmp	 SHORT $LN412@Read
$LN410@Read:
  007e0	1b c0		 sbb	 eax, eax
  007e2	83 d8 ff	 sbb	 eax, -1
$LN412@Read:
  007e5	85 c0		 test	 eax, eax
  007e7	0f 84 2b 02 00
	00		 je	 $LN423@Read

; 171  : 				{
; 172  : 					break;
; 173  : 				}
; 174  : 				SmithyDATA lpData;
; 175  : 				lpData.Type = TokenNumber;

  007ed	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  007f3	d9 7d fe	 fnstcw	 WORD PTR tv1968[ebp]
  007f6	0f b7 45 fe	 movzx	 eax, WORD PTR tv1968[ebp]
  007fa	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  007ff	89 45 f0	 mov	 DWORD PTR tv1965[ebp], eax
  00802	d9 6d f0	 fldcw	 WORD PTR tv1965[ebp]
  00805	db 5d f0	 fistp	 DWORD PTR tv1963[ebp]
  00808	8a 45 f0	 mov	 al, BYTE PTR tv1963[ebp]
  0080b	88 45 c5	 mov	 BYTE PTR _lpData$210728[ebp+1], al
  0080e	d9 6d fe	 fldcw	 WORD PTR tv1968[ebp]

; 176  : 				Token = GetToken();

  00811	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 177  : 				lpData.Index = TokenNumber;
; 178  : 				lpData.Class = Type-1;

  00816	c6 45 c4 04	 mov	 BYTE PTR _lpData$210728[ebp], 4
  0081a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00820	d9 7d fe	 fnstcw	 WORD PTR tv1960[ebp]
  00823	0f b7 45 fe	 movzx	 eax, WORD PTR tv1960[ebp]
  00827	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0082c	89 45 f0	 mov	 DWORD PTR tv1957[ebp], eax
  0082f	d9 6d f0	 fldcw	 WORD PTR tv1957[ebp]
  00832	db 5d f0	 fistp	 DWORD PTR tv1955[ebp]
  00835	8a 4d f0	 mov	 cl, BYTE PTR tv1955[ebp]
  00838	88 4d c6	 mov	 BYTE PTR _lpData$210728[ebp+2], cl
  0083b	d9 6d fe	 fldcw	 WORD PTR tv1960[ebp]

; 179  : 				Token = GetToken();

  0083e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 180  : 				lpData.Price = TokenNumber;
; 181  : 				this->itemdata.push_back(lpData);

  00843	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00846	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0084c	d9 7d fe	 fnstcw	 WORD PTR tv1952[ebp]
  0084f	0f b7 45 fe	 movzx	 eax, WORD PTR tv1952[ebp]
  00853	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00858	89 45 f0	 mov	 DWORD PTR tv1949[ebp], eax
  0085b	8d 45 c4	 lea	 eax, DWORD PTR _lpData$210728[ebp]
  0085e	50		 push	 eax
  0085f	d9 6d f0	 fldcw	 WORD PTR tv1949[ebp]
  00862	df 7d ec	 fistp	 QWORD PTR tv1947[ebp]
  00865	8b 55 ec	 mov	 edx, DWORD PTR tv1947[ebp]
  00868	89 55 c8	 mov	 DWORD PTR _lpData$210728[ebp+4], edx
  0086b	d9 6d fe	 fldcw	 WORD PTR tv1952[ebp]
  0086e	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00873	e9 e8 f7 ff ff	 jmp	 $LL24@Read
$LN8@Read:

; 182  : 			}
; 183  : 			else if(Type == 6)

  00878	83 f8 06	 cmp	 eax, 6
  0087b	0f 85 c7 00 00
	00		 jne	 $LN5@Read

; 184  : 			{
; 185  : 				Token = GetToken();

  00881	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 186  : 				if(!strcmp("end", TokenString))

  00886	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0088b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL413@Read:
  00890	8a 10		 mov	 dl, BYTE PTR [eax]
  00892	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00894	75 1a		 jne	 SHORT $LN414@Read
  00896	84 d2		 test	 dl, dl
  00898	74 12		 je	 SHORT $LN415@Read
  0089a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0089d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  008a0	75 0e		 jne	 SHORT $LN414@Read
  008a2	83 c0 02	 add	 eax, 2
  008a5	83 c1 02	 add	 ecx, 2
  008a8	84 d2		 test	 dl, dl
  008aa	75 e4		 jne	 SHORT $LL413@Read
$LN415@Read:
  008ac	33 c0		 xor	 eax, eax
  008ae	eb 05		 jmp	 SHORT $LN416@Read
$LN414@Read:
  008b0	1b c0		 sbb	 eax, eax
  008b2	83 d8 ff	 sbb	 eax, -1
$LN416@Read:
  008b5	85 c0		 test	 eax, eax
  008b7	0f 84 5b 01 00
	00		 je	 $LN423@Read

; 187  : 				{
; 188  : 					break;
; 189  : 				}
; 190  : 				SmithyDATA lpData;
; 191  : 				lpData.Type = TokenNumber;

  008bd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  008c3	d9 7d fe	 fnstcw	 WORD PTR tv1925[ebp]
  008c6	0f b7 45 fe	 movzx	 eax, WORD PTR tv1925[ebp]
  008ca	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  008cf	89 45 f0	 mov	 DWORD PTR tv1922[ebp], eax
  008d2	d9 6d f0	 fldcw	 WORD PTR tv1922[ebp]
  008d5	db 5d f0	 fistp	 DWORD PTR tv1920[ebp]
  008d8	8a 4d f0	 mov	 cl, BYTE PTR tv1920[ebp]
  008db	88 4d bd	 mov	 BYTE PTR _lpData$210732[ebp+1], cl
  008de	d9 6d fe	 fldcw	 WORD PTR tv1925[ebp]

; 192  : 				Token = GetToken();

  008e1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 193  : 				lpData.Index = TokenNumber;
; 194  : 				lpData.Class = Type-1;

  008e6	c6 45 bc 05	 mov	 BYTE PTR _lpData$210732[ebp], 5
  008ea	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  008f0	d9 7d fe	 fnstcw	 WORD PTR tv1917[ebp]
  008f3	0f b7 45 fe	 movzx	 eax, WORD PTR tv1917[ebp]
  008f7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  008fc	89 45 f0	 mov	 DWORD PTR tv1914[ebp], eax
  008ff	d9 6d f0	 fldcw	 WORD PTR tv1914[ebp]
  00902	db 5d f0	 fistp	 DWORD PTR tv1912[ebp]
  00905	8a 55 f0	 mov	 dl, BYTE PTR tv1912[ebp]
  00908	88 55 be	 mov	 BYTE PTR _lpData$210732[ebp+2], dl
  0090b	d9 6d fe	 fldcw	 WORD PTR tv1917[ebp]

; 195  : 				Token = GetToken();

  0090e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 196  : 				lpData.Price = TokenNumber;
; 197  : 				this->itemdata.push_back(lpData);

  00913	8d 55 bc	 lea	 edx, DWORD PTR _lpData$210732[ebp]
  00916	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00919	52		 push	 edx
  0091a	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00920	d9 7d fe	 fnstcw	 WORD PTR tv1909[ebp]
  00923	0f b7 45 fe	 movzx	 eax, WORD PTR tv1909[ebp]
  00927	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0092c	89 45 f0	 mov	 DWORD PTR tv1906[ebp], eax
  0092f	d9 6d f0	 fldcw	 WORD PTR tv1906[ebp]
  00932	df 7d ec	 fistp	 QWORD PTR tv1904[ebp]
  00935	8b 45 ec	 mov	 eax, DWORD PTR tv1904[ebp]
  00938	89 45 c0	 mov	 DWORD PTR _lpData$210732[ebp+4], eax
  0093b	d9 6d fe	 fldcw	 WORD PTR tv1909[ebp]
  0093e	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back
  00943	e9 18 f7 ff ff	 jmp	 $LL24@Read
$LN5@Read:

; 198  : 			}
; 199  : 			else if(Type == 7)

  00948	83 f8 07	 cmp	 eax, 7
  0094b	0f 85 0f f7 ff
	ff		 jne	 $LL24@Read

; 200  : 			{
; 201  : 				Token = GetToken();

  00951	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 202  : 				if(!strcmp("end", TokenString))

  00956	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0095b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL417@Read:
  00960	8a 10		 mov	 dl, BYTE PTR [eax]
  00962	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00964	75 1a		 jne	 SHORT $LN418@Read
  00966	84 d2		 test	 dl, dl
  00968	74 12		 je	 SHORT $LN419@Read
  0096a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0096d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00970	75 0e		 jne	 SHORT $LN418@Read
  00972	83 c0 02	 add	 eax, 2
  00975	83 c1 02	 add	 ecx, 2
  00978	84 d2		 test	 dl, dl
  0097a	75 e4		 jne	 SHORT $LL417@Read
$LN419@Read:
  0097c	33 c0		 xor	 eax, eax
  0097e	eb 05		 jmp	 SHORT $LN420@Read
$LN418@Read:
  00980	1b c0		 sbb	 eax, eax
  00982	83 d8 ff	 sbb	 eax, -1
$LN420@Read:
  00985	85 c0		 test	 eax, eax
  00987	0f 84 8b 00 00
	00		 je	 $LN423@Read

; 203  : 				{
; 204  : 					break;
; 205  : 				}
; 206  : 				SmithyDATA lpData;
; 207  : 				lpData.Type = TokenNumber;

  0098d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00993	d9 7d fe	 fnstcw	 WORD PTR tv1882[ebp]
  00996	0f b7 45 fe	 movzx	 eax, WORD PTR tv1882[ebp]
  0099a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0099f	89 45 f0	 mov	 DWORD PTR tv1879[ebp], eax
  009a2	d9 6d f0	 fldcw	 WORD PTR tv1879[ebp]
  009a5	db 5d f0	 fistp	 DWORD PTR tv1877[ebp]
  009a8	8a 45 f0	 mov	 al, BYTE PTR tv1877[ebp]
  009ab	88 45 b5	 mov	 BYTE PTR _lpData$210736[ebp+1], al
  009ae	d9 6d fe	 fldcw	 WORD PTR tv1882[ebp]

; 208  : 				Token = GetToken();

  009b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 209  : 				lpData.Index = TokenNumber;
; 210  : 				lpData.Class = Type-1;

  009b6	c6 45 b4 06	 mov	 BYTE PTR _lpData$210736[ebp], 6
  009ba	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009c0	d9 7d fe	 fnstcw	 WORD PTR tv1874[ebp]
  009c3	0f b7 45 fe	 movzx	 eax, WORD PTR tv1874[ebp]
  009c7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  009cc	89 45 f0	 mov	 DWORD PTR tv1871[ebp], eax
  009cf	d9 6d f0	 fldcw	 WORD PTR tv1871[ebp]
  009d2	db 5d f0	 fistp	 DWORD PTR tv1869[ebp]
  009d5	8a 4d f0	 mov	 cl, BYTE PTR tv1869[ebp]
  009d8	88 4d b6	 mov	 BYTE PTR _lpData$210736[ebp+2], cl
  009db	d9 6d fe	 fldcw	 WORD PTR tv1874[ebp]

; 211  : 				Token = GetToken();

  009de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 212  : 				lpData.Price = TokenNumber;
; 213  : 				this->itemdata.push_back(lpData);

  009e3	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  009e6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  009ec	d9 7d fe	 fnstcw	 WORD PTR tv1866[ebp]
  009ef	0f b7 45 fe	 movzx	 eax, WORD PTR tv1866[ebp]
  009f3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  009f8	89 45 f0	 mov	 DWORD PTR tv1863[ebp], eax
  009fb	8d 45 b4	 lea	 eax, DWORD PTR _lpData$210736[ebp]
  009fe	50		 push	 eax
  009ff	d9 6d f0	 fldcw	 WORD PTR tv1863[ebp]
  00a02	df 7d ec	 fistp	 QWORD PTR tv1861[ebp]
  00a05	8b 55 ec	 mov	 edx, DWORD PTR tv1861[ebp]
  00a08	89 55 b8	 mov	 DWORD PTR _lpData$210736[ebp+4], edx
  00a0b	d9 6d fe	 fldcw	 WORD PTR tv1866[ebp]
  00a0e	e8 00 00 00 00	 call	 ?push_back@?$vector@USmithyDATA@@V?$allocator@USmithyDATA@@@std@@@std@@QAEXABUSmithyDATA@@@Z ; std::vector<SmithyDATA,std::allocator<SmithyDATA> >::push_back

; 214  : 			}
; 215  : 		}

  00a13	e9 48 f6 ff ff	 jmp	 $LL24@Read
$LN423@Read:

; 58   : 		return;
; 59   : 	}
; 60   : 
; 61   : 	while(true)
; 62   : 	{
; 63   : 		SMDToken Token = GetToken();

  00a18	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 64   : 
; 65   : 		if( Token == END )

  00a1d	83 f8 02	 cmp	 eax, 2
  00a20	0f 85 2a f6 ff
	ff		 jne	 $LL27@Read
  00a26	8b 75 08	 mov	 esi, DWORD PTR _filename$[ebp]
  00a29	5f		 pop	 edi
$LN384@Read:

; 216  : 	}
; 217  : 
; 218  : 	fclose(SMDFile);

  00a2a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00a30	51		 push	 ecx
  00a31	e8 00 00 00 00	 call	 _fclose

; 219  : 	LogAdd("%s file load!", filename);

  00a36	56		 push	 esi
  00a37	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00a3c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00a42	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a45	5e		 pop	 esi
  00a46	5b		 pop	 ebx

; 220  : }

  00a47	8b e5		 mov	 esp, ebp
  00a49	5d		 pop	 ebp
  00a4a	c2 04 00	 ret	 4
$LN370@Read:

; 116  : 				lpData.Price = TokenNumber;
; 117  : 				this->itemdata.push_back(lpData);

  00a4d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00a52	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN430@Read:
$LN424@Read:
  00a57	cc		 int	 3
?Read@CSmithy@@QAEXPAD@Z ENDP				; CSmithy::Read
_TEXT	ENDS
PUBLIC	??_C@_0BC@FGOMOBFE@ZtData?2Smithy?4ini?$AA@	; `string'
PUBLIC	?Load@CSmithy@@QAEXXZ				; CSmithy::Load
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0BC@FGOMOBFE@ZtData?2Smithy?4ini?$AA@
CONST	SEGMENT
??_C@_0BC@FGOMOBFE@ZtData?2Smithy?4ini?$AA@ DB 'ZtData\Smithy.ini', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Load@CSmithy@@QAEXXZ
_TEXT	SEGMENT
?Load@CSmithy@@QAEXXZ PROC				; CSmithy::Load, COMDAT
; _this$ = ecx

; 42   : 	if(!g_ZtLicense.user.Smithy)

  00000	80 3d e0 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+224, 0
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 1c		 je	 SHORT $LN2@Load

; 43   : 	{
; 44   : 		return;
; 45   : 	}
; 46   : 	this->Init();

  0000c	e8 00 00 00 00	 call	 ?Init@CSmithy@@QAEXXZ	; CSmithy::Init

; 47   : 	this->Read(gDirPath.GetNewPath("ZtData\\Smithy.ini"));

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FGOMOBFE@ZtData?2Smithy?4ini?$AA@
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0001b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00020	50		 push	 eax
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?Read@CSmithy@@QAEXPAD@Z ; CSmithy::Read
$LN2@Load:
  00028	5e		 pop	 esi

; 48   : }

  00029	c3		 ret	 0
?Load@CSmithy@@QAEXXZ ENDP				; CSmithy::Load
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_Smithy@@YAXXZ
text$yc	SEGMENT
??__Eg_Smithy@@YAXXZ PROC				; `dynamic initializer for 'g_Smithy'', COMDAT

; 13   : CSmithy g_Smithy;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Smithy@@3VCSmithy@@A ; g_Smithy
  00005	e8 00 00 00 00	 call	 ??0CSmithy@@QAE@XZ	; CSmithy::CSmithy
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_Smithy@@YAXXZ ; `dynamic atexit destructor for 'g_Smithy''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_Smithy@@YAXXZ ENDP				; `dynamic initializer for 'g_Smithy''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_Smithy@@YAXXZ
text$yd	SEGMENT
??__Fg_Smithy@@YAXXZ PROC				; `dynamic atexit destructor for 'g_Smithy'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Smithy@@3VCSmithy@@A ; g_Smithy
  00005	e9 00 00 00 00	 jmp	 ??1CSmithy@@QAE@XZ	; CSmithy::~CSmithy
??__Fg_Smithy@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_Smithy''
text$yd	ENDS
PUBLIC	?g_Smithy@@3VCSmithy@@A				; g_Smithy
_BSS	SEGMENT
?g_Smithy@@3VCSmithy@@A DB 028H DUP (?)			; g_Smithy
_BSS	ENDS
CRT$XCU	SEGMENT
_g_Smithy$initializer$ DD FLAT:??__Eg_Smithy@@YAXXZ
CRT$XCU	ENDS
END
