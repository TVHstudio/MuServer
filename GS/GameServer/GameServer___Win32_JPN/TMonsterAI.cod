; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\TMonsterAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7TMonsterAI@@6B@				; TMonsterAI::`vftable'
PUBLIC	??0TMonsterAI@@QAE@XZ				; TMonsterAI::TMonsterAI
PUBLIC	??_R4TMonsterAI@@6B@				; TMonsterAI::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAI@@@8				; TMonsterAI `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAI@@8				; TMonsterAI::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAI@@8				; TMonsterAI::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAI@@8			; TMonsterAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAI@@UAEPAXI@Z:PROC			; TMonsterAI::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAI@@8
; File e:\work\tranet_version\gs\gameserver\tmonsterai.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAI@@8 DD FLAT:??_R0?AVTMonsterAI@@@8 ; TMonsterAI::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAI@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAI@@8
rdata$r	SEGMENT
??_R2TMonsterAI@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAI@@8	; TMonsterAI::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAI@@8
rdata$r	SEGMENT
??_R3TMonsterAI@@8 DD 00H				; TMonsterAI::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAI@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAI@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAI `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAI@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAI@@6B@
rdata$r	SEGMENT
??_R4TMonsterAI@@6B@ DD 00H				; TMonsterAI::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAI@@@8
	DD	FLAT:??_R3TMonsterAI@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAI@@6B@
CONST	SEGMENT
??_7TMonsterAI@@6B@ DD FLAT:??_R4TMonsterAI@@6B@	; TMonsterAI::`vftable'
	DD	FLAT:??_ETMonsterAI@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0TMonsterAI@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterAI@@QAE@XZ PROC				; TMonsterAI::TMonsterAI, COMDAT
; _this$ = ecx

; 24   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAI@@6B@

; 25   : 
; 26   : }

  00008	c3		 ret	 0
??0TMonsterAI@@QAE@XZ ENDP				; TMonsterAI::TMonsterAI
_TEXT	ENDS
PUBLIC	??1TMonsterAI@@UAE@XZ				; TMonsterAI::~TMonsterAI
; Function compile flags: /Ogtp
;	COMDAT ??1TMonsterAI@@UAE@XZ
_TEXT	SEGMENT
??1TMonsterAI@@UAE@XZ PROC				; TMonsterAI::~TMonsterAI, COMDAT
; _this$ = ecx

; 29   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAI@@6B@

; 30   : 
; 31   : }

  00006	c3		 ret	 0
??1TMonsterAI@@UAE@XZ ENDP				; TMonsterAI::~TMonsterAI
_TEXT	ENDS
PUBLIC	?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z ; TMonsterAI::ProcessStateMsg
EXTRN	?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z:PROC	; gObjBackSpring2
EXTRN	?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjApplyBuffEffectDuration
EXTRN	?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; retResistance
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?DelAgro@TMonsterAIAgro@@QAEHH@Z:PROC		; TMonsterAIAgro::DelAgro
EXTRN	?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjBackSpring
EXTRN	?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z:PROC ; gObjMonsterDieGiveItem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iMsgCode$ = 12						; size = 4
_iIndex$ = 16						; size = 4
_aMsgSubCode$ = 20					; size = 4
?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z PROC ; TMonsterAI::ProcessStateMsg, COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 109  : 	switch ( iMsgCode )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMsgCode$[ebp]
  00006	48		 dec	 eax
  00007	83 f8 38	 cmp	 eax, 56			; 00000038H
  0000a	0f 87 5c 01 00
	00		 ja	 $LN12@ProcessSta
  00010	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN16@ProcessSta[eax]
  00017	56		 push	 esi
  00018	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@ProcessSta[eax*4]
$LN11@ProcessSta:

; 110  : 	{
; 111  : 		case 1:
; 112  : 			gObjMonsterDieGiveItem(lpObj, &gObj[iIndex]);

  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00025	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0002b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	51		 push	 ecx
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterDieGiveItem
  00038	83 c4 08	 add	 esp, 8
  0003b	5e		 pop	 esi

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN10@ProcessSta:

; 113  : 			break;
; 114  : 
; 115  : 		case 2:
; 116  : 			if ( gObj[iIndex].Live != FALSE )

  0003e	8b 45 10	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00041	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00047	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	80 78 6a 00	 cmp	 BYTE PTR [eax+106], 0
  00051	0f 84 14 01 00
	00		 je	 $LN17@ProcessSta

; 117  : 			{
; 118  : 				gObjBackSpring(lpObj, &gObj[iIndex]);

  00057	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005a	50		 push	 eax
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjBackSpring
  00061	83 c4 08	 add	 esp, 8
  00064	5e		 pop	 esi

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN8@ProcessSta:

; 119  : 			}
; 120  : 			break;
; 121  : 
; 122  : 		case 3:
; 123  : 			if ( lpObj->TargetNumber != -1 )

  00067	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0006a	0f b7 86 58 04
	00 00		 movzx	 eax, WORD PTR [esi+1112]
  00071	66 83 f8 ff	 cmp	 ax, -1
  00075	74 0d		 je	 SHORT $LN7@ProcessSta

; 124  : 			{
; 125  : 				lpObj->m_Agro.DelAgro(lpObj->TargetNumber);

  00077	98		 cwde
  00078	50		 push	 eax
  00079	8d 8e 94 1c 00
	00		 lea	 ecx, DWORD PTR [esi+7316]
  0007f	e8 00 00 00 00	 call	 ?DelAgro@TMonsterAIAgro@@QAEHH@Z ; TMonsterAIAgro::DelAgro
$LN7@ProcessSta:

; 126  : 			}
; 127  : 
; 128  : 			lpObj->TargetNumber = -1;

  00084	83 c9 ff	 or	 ecx, -1

; 129  : 			lpObj->LastAttackerID = -1;

  00087	0b d1		 or	 edx, ecx

; 130  : 			lpObj->m_ActState.Emotion = 0;
; 131  : 			lpObj->m_ActState.Attack = 0;
; 132  : 			lpObj->m_ActState.Move = 0;

  00089	81 a6 18 02 00
	00 09 ff ff ff	 and	 DWORD PTR [esi+536], -247 ; ffffff09H
  00093	66 89 8e 58 04
	00 00		 mov	 WORD PTR [esi+1112], cx
  0009a	66 89 96 5e 04
	00 00		 mov	 WORD PTR [esi+1118], dx

; 133  : 			lpObj->NextActionTime = 1000;

  000a1	c7 86 bc 03 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+956], 1000 ; 000003e8H
  000ab	5e		 pop	 esi

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
$LN6@ProcessSta:

; 134  : 			break;
; 135  : 
; 136  : 		case 4:
; 137  : 			lpObj->m_ActState.Emotion = 3;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b1	8b 88 18 02 00
	00		 mov	 ecx, DWORD PTR [eax+536]
  000b7	81 e1 3f ff ff
	ff		 and	 ecx, -193		; ffffff3fH
  000bd	83 c9 30	 or	 ecx, 48			; 00000030H
  000c0	89 88 18 02 00
	00		 mov	 DWORD PTR [eax+536], ecx

; 138  : 			lpObj->m_ActState.EmotionCount = 1;

  000c6	c6 80 19 02 00
	00 01		 mov	 BYTE PTR [eax+537], 1
  000cd	5e		 pop	 esi

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN5@ProcessSta:

; 139  : 			break;
; 140  : 
; 141  : 		case 55:
; 142  : 			gObjAttack(lpObj, &gObj[iIndex], NULL, FALSE, FALSE, 0, FALSE,0,0);

  000d0	8b 55 10	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000d3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d6	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000dc	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	6a 00		 push	 0
  000ea	6a 00		 push	 0
  000ec	6a 00		 push	 0
  000ee	6a 00		 push	 0
  000f0	52		 push	 edx
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  000f7	83 c4 24	 add	 esp, 36			; 00000024H
  000fa	5e		 pop	 esi

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN4@ProcessSta:

; 143  : 			break;
; 144  : 
; 145  : 		case 56:
; 146  : 			{
; 147  : 				LPOBJ lpTargetObj = &gObj[iIndex];

  000fd	8b 75 10	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00100	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00106	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 148  : 				
; 149  : 				if(gObjSearchActiveEffect(lpTargetObj, AT_POISON) == 0)

  0010c	6a 37		 push	 55			; 00000037H
  0010e	56		 push	 esi
  0010f	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00114	83 c4 08	 add	 esp, 8
  00117	84 c0		 test	 al, al
  00119	75 50		 jne	 SHORT $LN17@ProcessSta

; 150  : 				{
; 151  : 					if ( retResistance(lpTargetObj, 1) == FALSE )

  0011b	6a 01		 push	 1
  0011d	56		 push	 esi
  0011e	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  00123	83 c4 08	 add	 esp, 8
  00126	85 c0		 test	 eax, eax
  00128	75 41		 jne	 SHORT $LN17@ProcessSta

; 152  : 					{
; 153  : 						lpTargetObj->lpAttackObj = lpObj;
; 154  : 						gObjApplyBuffEffectDuration(lpTargetObj, AT_POISON, 19, 3, 0, 0, aMsgSubCode);

  0012a	8b 55 14	 mov	 edx, DWORD PTR _aMsgSubCode$[ebp]
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00130	52		 push	 edx
  00131	50		 push	 eax
  00132	50		 push	 eax
  00133	6a 03		 push	 3
  00135	6a 13		 push	 19			; 00000013H
  00137	6a 37		 push	 55			; 00000037H
  00139	56		 push	 esi
  0013a	89 8e d4 03 00
	00		 mov	 DWORD PTR [esi+980], ecx
  00140	e8 00 00 00 00	 call	 ?gObjApplyBuffEffectDuration@@YAEPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjApplyBuffEffectDuration
  00145	83 c4 1c	 add	 esp, 28			; 0000001cH
  00148	5e		 pop	 esi

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
$LN1@ProcessSta:

; 155  : 					}
; 156  : 				}
; 157  : 			}
; 158  : 			break;
; 159  : 
; 160  : 		case 57:
; 161  : 			{
; 162  : 				LPOBJ lpTargetObj = &gObj[iIndex];

  0014b	8b 55 10	 mov	 edx, DWORD PTR _iIndex$[ebp]

; 163  : 				gObjBackSpring2(lpTargetObj, lpObj, aMsgSubCode);

  0014e	8b 45 14	 mov	 eax, DWORD PTR _aMsgSubCode$[ebp]
  00151	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0015a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00160	50		 push	 eax
  00161	51		 push	 ecx
  00162	52		 push	 edx
  00163	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@ProcessSta:
  0016b	5e		 pop	 esi
$LN12@ProcessSta:

; 164  : 			}
; 165  : 			break;
; 166  : 	}
; 167  : }

  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
  0016e	8b ff		 npad	 2
$LN18@ProcessSta:
  00170	00 00 00 00	 DD	 $LN11@ProcessSta
  00174	00 00 00 00	 DD	 $LN10@ProcessSta
  00178	00 00 00 00	 DD	 $LN8@ProcessSta
  0017c	00 00 00 00	 DD	 $LN6@ProcessSta
  00180	00 00 00 00	 DD	 $LN5@ProcessSta
  00184	00 00 00 00	 DD	 $LN4@ProcessSta
  00188	00 00 00 00	 DD	 $LN1@ProcessSta
  0018c	00 00 00 00	 DD	 $LN17@ProcessSta
$LN16@ProcessSta:
  00190	00		 DB	 0
  00191	01		 DB	 1
  00192	02		 DB	 2
  00193	03		 DB	 3
  00194	07		 DB	 7
  00195	07		 DB	 7
  00196	07		 DB	 7
  00197	07		 DB	 7
  00198	07		 DB	 7
  00199	07		 DB	 7
  0019a	07		 DB	 7
  0019b	07		 DB	 7
  0019c	07		 DB	 7
  0019d	07		 DB	 7
  0019e	07		 DB	 7
  0019f	07		 DB	 7
  001a0	07		 DB	 7
  001a1	07		 DB	 7
  001a2	07		 DB	 7
  001a3	07		 DB	 7
  001a4	07		 DB	 7
  001a5	07		 DB	 7
  001a6	07		 DB	 7
  001a7	07		 DB	 7
  001a8	07		 DB	 7
  001a9	07		 DB	 7
  001aa	07		 DB	 7
  001ab	07		 DB	 7
  001ac	07		 DB	 7
  001ad	07		 DB	 7
  001ae	07		 DB	 7
  001af	07		 DB	 7
  001b0	07		 DB	 7
  001b1	07		 DB	 7
  001b2	07		 DB	 7
  001b3	07		 DB	 7
  001b4	07		 DB	 7
  001b5	07		 DB	 7
  001b6	07		 DB	 7
  001b7	07		 DB	 7
  001b8	07		 DB	 7
  001b9	07		 DB	 7
  001ba	07		 DB	 7
  001bb	07		 DB	 7
  001bc	07		 DB	 7
  001bd	07		 DB	 7
  001be	07		 DB	 7
  001bf	07		 DB	 7
  001c0	07		 DB	 7
  001c1	07		 DB	 7
  001c2	07		 DB	 7
  001c3	07		 DB	 7
  001c4	07		 DB	 7
  001c5	07		 DB	 7
  001c6	04		 DB	 4
  001c7	05		 DB	 5
  001c8	06		 DB	 6
?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z ENDP ; TMonsterAI::ProcessStateMsg
_TEXT	ENDS
PUBLIC	??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@ ; `string'
PUBLIC	?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z		; TMonsterAI::UpdateCurrentAIUnit
EXTRN	?SendCrywolfChattingMsg@CCrywolfUtil@@QAAXHPADZZ:PROC ; CCrywolfUtil::SendCrywolfChattingMsg
EXTRN	?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z:PROC	; TMonsterAIUnit::FindAIUnit
EXTRN	?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z:PROC	; TMonsterAIRule::GetCurrentAIUnit
;	COMDAT ??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@ DB 0a1H
	DB	0daH, 'AI %s ', 0bfH, 0a1H, 0bcH, 0adH, ' %s ', 0b7H, 0ceH, ' '
	DB	0b9H, 0d9H, 0b2H, 0dbH, 0b4H, 0d9H, '!!', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z PROC		; TMonsterAI::UpdateCurrentAIUnit, COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 176  : 	LPOBJ lpObj = &gObj[iIndex];

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0000d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 177  : 
; 178  : 	if ( lpObj->Live == FALSE )

  00013	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0
  00017	75 05		 jne	 SHORT $LN4@UpdateCurr

; 179  : 		return FALSE;

  00019	33 c0		 xor	 eax, eax
  0001b	5e		 pop	 esi

; 200  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN4@UpdateCurr:

; 180  : 
; 181  : 	int iOldCurrentAI = lpObj->m_iCurrentAI;
; 182  : 	int iCurrentAI = TMonsterAIRule::GetCurrentAIUnit(lpObj->Class);

  0001e	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00025	57		 push	 edi
  00026	8b be 78 1c 00
	00		 mov	 edi, DWORD PTR [esi+7288]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?GetCurrentAIUnit@TMonsterAIRule@@SAHH@Z ; TMonsterAIRule::GetCurrentAIUnit
  00032	83 c4 04	 add	 esp, 4

; 183  : 
; 184  : 	if ( iCurrentAI == 0 )

  00035	85 c0		 test	 eax, eax
  00037	75 0c		 jne	 SHORT $LN2@UpdateCurr

; 185  : 	{
; 186  : 		if ( lpObj->m_iBasicAI != 0 )

  00039	8b 8e 74 1c 00
	00		 mov	 ecx, DWORD PTR [esi+7284]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 02		 je	 SHORT $LN2@UpdateCurr

; 187  : 		{
; 188  : 			iCurrentAI = lpObj->m_iBasicAI;

  00043	8b c1		 mov	 eax, ecx
$LN2@UpdateCurr:

; 189  : 		}
; 190  : 	}
; 191  : 
; 192  : 	lpObj->m_iCurrentAI = iCurrentAI;

  00045	89 86 78 1c 00
	00		 mov	 DWORD PTR [esi+7288], eax

; 193  : 
; 194  : 	if ( iOldCurrentAI != iCurrentAI )

  0004b	3b f8		 cmp	 edi, eax
  0004d	74 2f		 je	 SHORT $LN1@UpdateCurr

; 195  : 	{
; 196  : 		UTIL.SendCrywolfChattingMsg(lpObj->m_Index, "★AI %s 에서 %s 로 바꾼다!!", TMonsterAIUnit::FindAIUnit(iOldCurrentAI)->m_szUnitName, TMonsterAIUnit::FindAIUnit(iCurrentAI)->m_szUnitName);

  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ; TMonsterAIUnit::FindAIUnit
  00055	83 c4 04	 add	 esp, 4
  00058	83 c0 04	 add	 eax, 4
  0005b	50		 push	 eax
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ; TMonsterAIUnit::FindAIUnit
  00062	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00064	83 c4 04	 add	 esp, 4
  00067	83 c0 04	 add	 eax, 4
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BBFBOFLB@?$KB?ZAI?5?$CFs?5?$LP?$KB?$LM?$KN?5?$CFs?5?$LH?N?5?$LJ?Y?$LC?$NL?$LE?Y?$CB?$CB?$AA@
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET _UTIL
  00076	e8 00 00 00 00	 call	 ?SendCrywolfChattingMsg@CCrywolfUtil@@QAAXHPADZZ ; CCrywolfUtil::SendCrywolfChattingMsg
  0007b	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@UpdateCurr:

; 197  : 	}
; 198  : 
; 199  : 	return TRUE;

  0007e	5f		 pop	 edi
  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	5e		 pop	 esi

; 200  : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z ENDP		; TMonsterAI::UpdateCurrentAIUnit
_TEXT	ENDS
PUBLIC	__real@3ff4cccccccccccd
PUBLIC	__real@41f0000000000000
PUBLIC	?MonsterMove@TMonsterAI@@SAXH@Z			; TMonsterAI::MonsterMove
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; TMonsterAIUtil::CheckMovingCondition
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff4cccccccccccd
CONST	SEGMENT
__real@3ff4cccccccccccd DQ 03ff4cccccccccccdr	; 1.3
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MonsterMove@TMonsterAI@@SAXH@Z
_TEXT	SEGMENT
tv286 = -12						; size = 8
tv292 = -8						; size = 4
tv288 = -8						; size = 4
tv291 = -2						; size = 2
_iIndex$ = 8						; size = 4
?MonsterMove@TMonsterAI@@SAXH@Z PROC			; TMonsterAI::MonsterMove, COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 220  : 	LPOBJ lpObj = &gObj[iIndex];

  00008	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00011	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 221  : 
; 222  : 	if ( MONSTER_UTIL.CheckMovingCondition(lpObj) == FALSE )

  00017	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::CheckMovingCondition

; 223  : 	{
; 224  : 		lpObj->PathCur = 0;

  00022	33 db		 xor	 ebx, ebx
  00024	85 c0		 test	 eax, eax

; 225  : 		lpObj->PathCount = 0;
; 226  : 		lpObj->PathStartEnd = 0;
; 227  : 		memset(lpObj->PathX, 0, sizeof(lpObj->PathX));
; 228  : 		memset(lpObj->PathY, 0, sizeof(lpObj->PathY));
; 229  : 		memset(lpObj->PathDir, 0, sizeof(lpObj->PathY)); //check this out
; 230  : 
; 231  : 		return ;

  00026	0f 84 21 01 00
	00		 je	 $LN8@MonsterMov

; 232  : 	}
; 233  : 
; 234  : 	if ( lpObj->PathCount != 0 )

  0002c	39 9e 84 01 00
	00		 cmp	 DWORD PTR [esi+388], ebx
  00032	0f 84 15 01 00
	00		 je	 $LN8@MonsterMov

; 235  : 	{
; 236  : 		DWORD dwMoveTime = 0;
; 237  : 		DWORD dwDelayTime = 0;
; 238  : 
; 239  : 		if ( lpObj->DelayLevel != 0 )

  00038	0f be 86 c4 03
	00 00		 movsx	 eax, BYTE PTR [esi+964]

; 240  : 			dwDelayTime = 300;
; 241  : 		else
; 242  : 			dwDelayTime = 0;
; 243  : 
; 244  : 		lpObj->m_MoveSpeed = 300;
; 245  : 		
; 246  : 		if ( (lpObj->PathDir[lpObj->PathCur] % 2 ) == 0 )

  0003f	8b 96 88 01 00
	00		 mov	 edx, DWORD PTR [esi+392]
  00045	b9 2c 01 00 00	 mov	 ecx, 300		; 0000012cH
  0004a	f7 d8		 neg	 eax
  0004c	66 89 8e ac 04
	00 00		 mov	 WORD PTR [esi+1196], cx
  00053	0f be 8c 32 e8
	01 00 00	 movsx	 ecx, BYTE PTR [edx+esi+488]
  0005b	1b c0		 sbb	 eax, eax
  0005d	25 2c 01 00 00	 and	 eax, 300		; 0000012cH
  00062	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  00068	57		 push	 edi
  00069	79 05		 jns	 SHORT $LN12@MonsterMov
  0006b	49		 dec	 ecx
  0006c	83 c9 fe	 or	 ecx, -2			; fffffffeH
  0006f	41		 inc	 ecx
$LN12@MonsterMov:
  00070	75 36		 jne	 SHORT $LN5@MonsterMov

; 247  : 			dwMoveTime = (DWORD)((double)(lpObj->m_MoveSpeed + dwDelayTime) * 1.3);

  00072	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00077	89 45 f8	 mov	 DWORD PTR tv292[ebp], eax
  0007a	db 45 f8	 fild	 DWORD PTR tv292[ebp]
  0007d	79 06		 jns	 SHORT $LN13@MonsterMov
  0007f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN13@MonsterMov:
  00085	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff4cccccccccccd
  0008b	d9 7d fe	 fnstcw	 WORD PTR tv291[ebp]
  0008e	0f b7 45 fe	 movzx	 eax, WORD PTR tv291[ebp]
  00092	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00097	89 45 f8	 mov	 DWORD PTR tv288[ebp], eax
  0009a	d9 6d f8	 fldcw	 WORD PTR tv288[ebp]
  0009d	df 7d f4	 fistp	 QWORD PTR tv286[ebp]
  000a0	8b 7d f4	 mov	 edi, DWORD PTR tv286[ebp]
  000a3	d9 6d fe	 fldcw	 WORD PTR tv291[ebp]

; 248  : 		else

  000a6	eb 06		 jmp	 SHORT $LN4@MonsterMov
$LN5@MonsterMov:

; 249  : 			dwMoveTime = lpObj->m_MoveSpeed + dwDelayTime;

  000a8	8d b8 2c 01 00
	00		 lea	 edi, DWORD PTR [eax+300]
$LN4@MonsterMov:

; 250  : 
; 251  : 		if ( (GetTickCount() - lpObj->PathTime) > dwMoveTime )

  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000b4	2b 86 f8 01 00
	00		 sub	 eax, DWORD PTR [esi+504]
  000ba	3b c7		 cmp	 eax, edi
  000bc	5f		 pop	 edi
  000bd	0f 86 31 01 00
	00		 jbe	 $LN10@MonsterMov

; 252  : 		{
; 253  : 			if ( lpObj->PathCur < 15 )

  000c3	8b 86 88 01 00
	00		 mov	 eax, DWORD PTR [esi+392]
  000c9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000cc	7d 5d		 jge	 SHORT $LN1@MonsterMov

; 254  : 			{
; 255  : 				lpObj->X = lpObj->PathX[lpObj->PathCur];

  000ce	66 8b 94 46 ac
	01 00 00	 mov	 dx, WORD PTR [esi+eax*2+428]
  000d6	66 89 96 44 01
	00 00		 mov	 WORD PTR [esi+324], dx

; 256  : 				lpObj->Y = lpObj->PathY[lpObj->PathCur];

  000dd	66 8b 8c 46 ca
	01 00 00	 mov	 cx, WORD PTR [esi+eax*2+458]
  000e5	66 89 8e 46 01
	00 00		 mov	 WORD PTR [esi+326], cx

; 257  : 				lpObj->Dir = lpObj->PathDir[lpObj->PathCur];

  000ec	8a 94 30 e8 01
	00 00		 mov	 dl, BYTE PTR [eax+esi+488]
  000f3	88 96 48 01 00
	00		 mov	 BYTE PTR [esi+328], dl

; 258  : 				lpObj->PathTime = GetTickCount();

  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 259  : 				lpObj->PathCur++;

  000ff	ff 86 88 01 00
	00		 inc	 DWORD PTR [esi+392]
  00105	89 86 f8 01 00
	00		 mov	 DWORD PTR [esi+504], eax
  0010b	8b 86 88 01 00
	00		 mov	 eax, DWORD PTR [esi+392]

; 260  : 
; 261  : 				if ( lpObj->PathCur >= lpObj->PathCount )

  00111	3b 86 84 01 00
	00		 cmp	 eax, DWORD PTR [esi+388]
  00117	7c 12		 jl	 SHORT $LN1@MonsterMov

; 262  : 				{
; 263  : 					lpObj->PathCur = 0;

  00119	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx

; 264  : 					lpObj->PathCount = 0;

  0011f	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx

; 265  : 					lpObj->PathStartEnd = 0;

  00125	88 9e 8c 01 00
	00		 mov	 BYTE PTR [esi+396], bl
$LN1@MonsterMov:

; 266  : 				}
; 267  : 			}
; 268  : 
; 269  : 			CreateFrustrum(lpObj->X, lpObj->Y, iIndex);

  0012b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0012e	0f bf 8e 46 01
	00 00		 movsx	 ecx, WORD PTR [esi+326]
  00135	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  0013c	50		 push	 eax
  0013d	51		 push	 ecx
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx

; 282  : }

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
$LN8@MonsterMov:

; 270  : 		}
; 271  : 
; 272  : 		return;
; 273  : 
; 274  : 	}
; 275  : 
; 276  : 	lpObj->PathCur = 0;
; 277  : 	lpObj->PathCount = 0;
; 278  : 	lpObj->PathStartEnd = 0;
; 279  : 	memset(lpObj->PathX, 0, sizeof(lpObj->PathX));

  0014d	33 c0		 xor	 eax, eax
  0014f	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx
  00155	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx
  0015b	88 9e 8c 01 00
	00		 mov	 BYTE PTR [esi+396], bl
  00161	89 86 ac 01 00
	00		 mov	 DWORD PTR [esi+428], eax
  00167	89 86 b0 01 00
	00		 mov	 DWORD PTR [esi+432], eax
  0016d	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax
  00173	89 86 b8 01 00
	00		 mov	 DWORD PTR [esi+440], eax
  00179	89 86 bc 01 00
	00		 mov	 DWORD PTR [esi+444], eax
  0017f	89 86 c0 01 00
	00		 mov	 DWORD PTR [esi+448], eax
  00185	89 86 c4 01 00
	00		 mov	 DWORD PTR [esi+452], eax
  0018b	66 89 86 c8 01
	00 00		 mov	 WORD PTR [esi+456], ax

; 280  : 	memset(lpObj->PathY, 0, sizeof(lpObj->PathY));

  00192	89 86 ca 01 00
	00		 mov	 DWORD PTR [esi+458], eax
  00198	89 86 ce 01 00
	00		 mov	 DWORD PTR [esi+462], eax
  0019e	89 86 d2 01 00
	00		 mov	 DWORD PTR [esi+466], eax
  001a4	89 86 d6 01 00
	00		 mov	 DWORD PTR [esi+470], eax
  001aa	89 86 da 01 00
	00		 mov	 DWORD PTR [esi+474], eax
  001b0	89 86 de 01 00
	00		 mov	 DWORD PTR [esi+478], eax
  001b6	89 86 e2 01 00
	00		 mov	 DWORD PTR [esi+482], eax
  001bc	66 89 86 e6 01
	00 00		 mov	 WORD PTR [esi+486], ax

; 281  : 	memset(lpObj->PathDir, 0, sizeof(lpObj->PathY)); //check this out

  001c3	89 86 e8 01 00
	00		 mov	 DWORD PTR [esi+488], eax
  001c9	89 86 ec 01 00
	00		 mov	 DWORD PTR [esi+492], eax
  001cf	89 86 f0 01 00
	00		 mov	 DWORD PTR [esi+496], eax
  001d5	89 86 f4 01 00
	00		 mov	 DWORD PTR [esi+500], eax
  001db	89 86 f8 01 00
	00		 mov	 DWORD PTR [esi+504], eax
  001e1	89 86 fc 01 00
	00		 mov	 DWORD PTR [esi+508], eax
  001e7	89 86 00 02 00
	00		 mov	 DWORD PTR [esi+512], eax
  001ed	66 89 86 04 02
	00 00		 mov	 WORD PTR [esi+516], ax
$LN10@MonsterMov:
  001f4	5e		 pop	 esi
  001f5	5b		 pop	 ebx

; 282  : }

  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c3		 ret	 0
?MonsterMove@TMonsterAI@@SAXH@Z ENDP			; TMonsterAI::MonsterMove
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GTMonsterAI@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTMonsterAI@@UAEPAXI@Z PROC				; TMonsterAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1TMonsterAI@@UAE@XZ	; TMonsterAI::~TMonsterAI
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GTMonsterAI@@UAEPAXI@Z ENDP				; TMonsterAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?MonsterStateMsgProc@TMonsterAI@@SAXH@Z		; TMonsterAI::MonsterStateMsgProc
EXTRN	?gSMMsg@@3PAY0DC@UMessageStateMachine@@A:BYTE	; gSMMsg
; Function compile flags: /Ogtp
;	COMDAT ?MonsterStateMsgProc@TMonsterAI@@SAXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?MonsterStateMsgProc@TMonsterAI@@SAXH@Z PROC		; TMonsterAI::MonsterStateMsgProc, COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 89   : 	LPOBJ lpObj = &gObj[iIndex];

  00005	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	57		 push	 edi
  00009	8b fe		 mov	 edi, esi
  0000b	69 f6 20 03 00
	00		 imul	 esi, 800		; 00000320H
  00011	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00017	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	81 c6 00 00 00
	00		 add	 esi, OFFSET ?gSMMsg@@3PAY0DC@UMessageStateMachine@@A ; gSMMsg
  00023	bb 32 00 00 00	 mov	 ebx, 50			; 00000032H
$LL5@MonsterSta:

; 92   : 	{
; 93   : 		if ( gSMMsg[iIndex][i].MsgCode >= 0 )

  00028	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0002b	7c 25		 jl	 SHORT $LN4@MonsterSta

; 94   : 		{
; 95   : 			if ( GetTickCount() > gSMMsg[iIndex][i].MsgTime )

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00033	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00036	76 1a		 jbe	 SHORT $LN4@MonsterSta

; 96   : 			{
; 97   : 				TMonsterAI::ProcessStateMsg(lpObj, gSMMsg[iIndex][i].MsgCode, gSMMsg[iIndex][i].SendUser, gSMMsg[iIndex][i].SubCode);

  00038	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0003e	8b 16		 mov	 edx, DWORD PTR [esi]
  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	52		 push	 edx
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 ?ProcessStateMsg@TMonsterAI@@SAXPAUOBJECTSTRUCT@@HHH@Z ; TMonsterAI::ProcessStateMsg
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 98   : 				gSMMsg[iIndex][i].MsgCode = -1;

  0004c	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN4@MonsterSta:

; 90   : 
; 91   : 	for ( int i=0;i<MAX_MONSTER_SEND_MSG;i++)

  00052	83 c6 10	 add	 esi, 16			; 00000010H
  00055	4b		 dec	 ebx
  00056	75 d0		 jne	 SHORT $LL5@MonsterSta
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 99   : 			}
; 100  : 		}
; 101  : 	}
; 102  : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?MonsterStateMsgProc@TMonsterAI@@SAXH@Z ENDP		; TMonsterAI::MonsterStateMsgProc
_TEXT	ENDS
PUBLIC	?MonsterMoveProc@TMonsterAI@@SAXXZ		; TMonsterAI::MonsterMoveProc
; Function compile flags: /Ogtp
;	COMDAT ?MonsterMoveProc@TMonsterAI@@SAXXZ
_TEXT	SEGMENT
?MonsterMoveProc@TMonsterAI@@SAXXZ PROC			; TMonsterAI::MonsterMoveProc, COMDAT

; 205  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 206  : 	for ( int i=0;i<OBJ_MAXMONSTER;i++)

  00002	33 ff		 xor	 edi, edi
  00004	33 f6		 xor	 esi, esi
  00006	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL4@MonsterMov@2:

; 207  : 	{
; 208  : 		if ( gObj[i].m_iCurrentAI !=  0 )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	83 bc 06 78 1c
	00 00 00	 cmp	 DWORD PTR [esi+eax+7288], 0
  0001d	74 09		 je	 SHORT $LN3@MonsterMov@2

; 209  : 		{
; 210  : 			TMonsterAI::MonsterMove(i);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ?MonsterMove@TMonsterAI@@SAXH@Z ; TMonsterAI::MonsterMove
  00025	83 c4 04	 add	 esp, 4
$LN3@MonsterMov@2:

; 206  : 	for ( int i=0;i<OBJ_MAXMONSTER;i++)

  00028	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  0002e	47		 inc	 edi
  0002f	81 fe 80 76 97
	08		 cmp	 esi, 144144000		; 08977680H
  00035	7c d9		 jl	 SHORT $LL4@MonsterMov@2

; 211  : 		}
; 212  : 	}
; 213  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
?MonsterMoveProc@TMonsterAI@@SAXXZ ENDP			; TMonsterAI::MonsterMoveProc
_TEXT	ENDS
PUBLIC	?RunAI@TMonsterAI@@SAHHH@Z			; TMonsterAI::RunAI
EXTRN	?RunAIUnit@TMonsterAIUnit@@QAEHH@Z:PROC		; TMonsterAIUnit::RunAIUnit
; Function compile flags: /Ogtp
;	COMDAT ?RunAI@TMonsterAI@@SAHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iMonsterClass$ = 12					; size = 4
?RunAI@TMonsterAI@@SAHHH@Z PROC				; TMonsterAI::RunAI, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 62   : 	LPOBJ lpObj = &gObj[iIndex];

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00010	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 63   : 
; 64   : 	TMonsterAI::MonsterStateMsgProc(iIndex);

  00016	53		 push	 ebx
  00017	e8 00 00 00 00	 call	 ?MonsterStateMsgProc@TMonsterAI@@SAXH@Z ; TMonsterAI::MonsterStateMsgProc

; 65   : 
; 66   : 	if ( lpObj->m_iCurrentAI == 0 )

  0001c	8b 86 78 1c 00
	00		 mov	 eax, DWORD PTR [esi+7288]
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	75 04		 jne	 SHORT $LN4@RunAI
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx

; 83   : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN4@RunAI:
  0002d	57		 push	 edi

; 67   : 		return FALSE;
; 68   : 
; 69   : 	TMonsterAIUnit * lpAIUnit = TMonsterAIUnit::FindAIUnit(lpObj->m_iCurrentAI);

  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?FindAIUnit@TMonsterAIUnit@@SAPAV1@H@Z ; TMonsterAIUnit::FindAIUnit
  00034	8b f8		 mov	 edi, eax
  00036	83 c4 04	 add	 esp, 4

; 70   : 
; 71   : 	if ( lpAIUnit == NULL )

  00039	85 ff		 test	 edi, edi

; 72   : 		return FALSE;

  0003b	74 1d		 je	 SHORT $LN8@RunAI

; 73   : 
; 74   : 	if ( (GetTickCount() - lpObj->m_iLastAIRunTime) < lpAIUnit->m_iDelayTime )

  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00043	2b 86 80 1c 00
	00		 sub	 eax, DWORD PTR [esi+7296]
  00049	3b 47 3c	 cmp	 eax, DWORD PTR [edi+60]

; 75   : 		return FALSE;

  0004c	72 0c		 jb	 SHORT $LN8@RunAI

; 76   : 
; 77   : 	if ( lpAIUnit->RunAIUnit(iIndex) == FALSE )

  0004e	53		 push	 ebx
  0004f	8b cf		 mov	 ecx, edi
  00051	e8 00 00 00 00	 call	 ?RunAIUnit@TMonsterAIUnit@@QAEHH@Z ; TMonsterAIUnit::RunAIUnit
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN1@RunAI
$LN8@RunAI:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 78   : 		return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	5b		 pop	 ebx

; 83   : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN1@RunAI:

; 79   : 
; 80   : 	lpObj->m_iLastAIRunTime = GetTickCount();

  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00067	5f		 pop	 edi
  00068	89 86 80 1c 00
	00		 mov	 DWORD PTR [esi+7296], eax
  0006e	5e		 pop	 esi

; 81   : 
; 82   : 	return TRUE;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	5b		 pop	 ebx

; 83   : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?RunAI@TMonsterAI@@SAHHH@Z ENDP				; TMonsterAI::RunAI
_TEXT	ENDS
PUBLIC	?MonsterAIProc@TMonsterAI@@SAXXZ		; TMonsterAI::MonsterAIProc
EXTRN	?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ:PROC	; TMonsterAIRule::MonsterAIRuleProc
; Function compile flags: /Ogtp
;	COMDAT ?MonsterAIProc@TMonsterAI@@SAXXZ
_TEXT	SEGMENT
?MonsterAIProc@TMonsterAI@@SAXXZ PROC			; TMonsterAI::MonsterAIProc, COMDAT

; 35   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 36   : 	TMonsterAIRule::MonsterAIRuleProc();

  00002	e8 00 00 00 00	 call	 ?MonsterAIRuleProc@TMonsterAIRule@@SAXXZ ; TMonsterAIRule::MonsterAIRuleProc
  00007	33 ff		 xor	 edi, edi
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL12@MonsterAIP:

; 39   : 	{
; 40   : 		LPOBJ lpObj = &gObj[n];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]

; 41   : 
; 42   : 		if ( lpObj->m_iCurrentAI == 0 || lpObj->Live == FALSE ||lpObj->Connected != PLAYER_PLAYING )

  00018	8b 86 78 1c 00
	00		 mov	 eax, DWORD PTR [esi+7288]
  0001e	85 c0		 test	 eax, eax
  00020	74 38		 je	 SHORT $LN6@MonsterAIP
  00022	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0
  00026	74 23		 je	 SHORT $LN3@MonsterAIP
  00028	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  0002c	75 1d		 jne	 SHORT $LN3@MonsterAIP

; 47   : 			}
; 48   : 			continue;
; 49   : 		}
; 50   : 		else
; 51   : 		{
; 52   : 			TMonsterAI::UpdateCurrentAIUnit(lpObj->m_Index);

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?UpdateCurrentAIUnit@TMonsterAI@@SAHH@Z ; TMonsterAI::UpdateCurrentAIUnit

; 53   : 			TMonsterAI::RunAI(lpObj->m_Index, lpObj->Class);

  00036	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR [esi+184]
  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	52		 push	 edx
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?RunAI@TMonsterAI@@SAHHH@Z ; TMonsterAI::RunAI
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 54   : 		}
; 55   : 	}

  00049	eb 0f		 jmp	 SHORT $LN6@MonsterAIP
$LN3@MonsterAIP:

; 43   : 		{
; 44   : 			if ( lpObj->m_iCurrentAI != 0 )

  0004b	85 c0		 test	 eax, eax
  0004d	74 0b		 je	 SHORT $LN6@MonsterAIP

; 45   : 			{
; 46   : 				TMonsterAI::MonsterStateMsgProc(lpObj->m_Index);

  0004f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?MonsterStateMsgProc@TMonsterAI@@SAXH@Z ; TMonsterAI::MonsterStateMsgProc
  00057	83 c4 04	 add	 esp, 4
$LN6@MonsterAIP:

; 37   : 
; 38   : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0005a	81 c7 50 2b 00
	00		 add	 edi, 11088		; 00002b50H
  00060	81 ff 80 76 97
	08		 cmp	 edi, 144144000		; 08977680H
  00066	7c a8		 jl	 SHORT $LL12@MonsterAIP

; 56   : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	c3		 ret	 0
?MonsterAIProc@TMonsterAI@@SAXXZ ENDP			; TMonsterAI::MonsterAIProc
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??0TMonsterAIUtil@@QAE@XZ:PROC			; TMonsterAIUtil::TMonsterAIUtil
; Function compile flags: /Ogtp
;	COMDAT ??__EMONSTER_UTIL@@YAXXZ
text$yc	SEGMENT
??__EMONSTER_UTIL@@YAXXZ PROC				; `dynamic initializer for 'MONSTER_UTIL'', COMDAT

; 16   : static TMonsterAIUtil MONSTER_UTIL;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00005	e8 00 00 00 00	 call	 ??0TMonsterAIUtil@@QAE@XZ ; TMonsterAIUtil::TMonsterAIUtil
  0000a	68 00 00 00 00	 push	 OFFSET ??__FMONSTER_UTIL@@YAXXZ ; `dynamic atexit destructor for 'MONSTER_UTIL''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EMONSTER_UTIL@@YAXXZ ENDP				; `dynamic initializer for 'MONSTER_UTIL''
text$yc	ENDS
EXTRN	??0CCrywolfUtil@@QAE@XZ:PROC			; CCrywolfUtil::CCrywolfUtil
; Function compile flags: /Ogtp
;	COMDAT ??__EUTIL@@YAXXZ
text$yc	SEGMENT
??__EUTIL@@YAXXZ PROC					; `dynamic initializer for 'UTIL'', COMDAT

; 17   : static CCrywolfUtil UTIL;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _UTIL
  00005	e8 00 00 00 00	 call	 ??0CCrywolfUtil@@QAE@XZ	; CCrywolfUtil::CCrywolfUtil
  0000a	68 00 00 00 00	 push	 OFFSET ??__FUTIL@@YAXXZ	; `dynamic atexit destructor for 'UTIL''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EUTIL@@YAXXZ ENDP					; `dynamic initializer for 'UTIL''
text$yc	ENDS
EXTRN	??1TMonsterAIUtil@@UAE@XZ:PROC			; TMonsterAIUtil::~TMonsterAIUtil
; Function compile flags: /Ogtp
;	COMDAT ??__FMONSTER_UTIL@@YAXXZ
text$yd	SEGMENT
??__FMONSTER_UTIL@@YAXXZ PROC				; `dynamic atexit destructor for 'MONSTER_UTIL'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00005	e9 00 00 00 00	 jmp	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
??__FMONSTER_UTIL@@YAXXZ ENDP				; `dynamic atexit destructor for 'MONSTER_UTIL''
text$yd	ENDS
EXTRN	??1CCrywolfUtil@@UAE@XZ:PROC			; CCrywolfUtil::~CCrywolfUtil
; Function compile flags: /Ogtp
;	COMDAT ??__FUTIL@@YAXXZ
text$yd	SEGMENT
??__FUTIL@@YAXXZ PROC					; `dynamic atexit destructor for 'UTIL'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _UTIL
  00005	e9 00 00 00 00	 jmp	 ??1CCrywolfUtil@@UAE@XZ	; CCrywolfUtil::~CCrywolfUtil
??__FUTIL@@YAXXZ ENDP					; `dynamic atexit destructor for 'UTIL''
text$yd	ENDS
_BSS	SEGMENT
_UTIL	DD	01H DUP (?)
_MONSTER_UTIL DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_MONSTER_UTIL$initializer$ DD FLAT:??__EMONSTER_UTIL@@YAXXZ
_UTIL$initializer$ DD FLAT:??__EUTIL@@YAXXZ
CRT$XCU	ENDS
END
