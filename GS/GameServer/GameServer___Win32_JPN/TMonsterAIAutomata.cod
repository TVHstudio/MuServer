; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\TMonsterAIAutomata.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_bDataLoad@TMonsterAIAutomata@@2HA		; TMonsterAIAutomata::s_bDataLoad
_BSS	SEGMENT
?s_bDataLoad@TMonsterAIAutomata@@2HA DD 01H DUP (?)	; TMonsterAIAutomata::s_bDataLoad
_BSS	ENDS
PUBLIC	?Reset@TMonsterAIState@@QAEXXZ			; TMonsterAIState::Reset
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsteraistate.h
;	COMDAT ?Reset@TMonsterAIState@@QAEXXZ
_TEXT	SEGMENT
?Reset@TMonsterAIState@@QAEXXZ PROC			; TMonsterAIState::Reset, COMDAT
; _this$ = ecx

; 48   : 		this->m_iPriority = -1;

  00000	83 c8 ff	 or	 eax, -1

; 49   : 		this->m_iCurrentState = -1;
; 50   : 		this->m_iNextState = -1;
; 51   : 		this->m_iTransitionType = -1;
; 52   : 		this->m_iTransitionRate = -1;
; 53   : 		this->m_iTransitionValueType = -1;
; 54   : 		this->m_iTransitionValue = -1;
; 55   : 		this->m_iDelayTime = -1;
; 56   : 		memset(this->m_szStateTransitionDesc, 0, sizeof(this->m_szStateTransitionDesc));

  00003	6a 64		 push	 100			; 00000064H
  00005	89 01		 mov	 DWORD PTR [ecx], eax
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00010	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00013	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00016	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00019	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0001c	83 c1 20	 add	 ecx, 32			; 00000020H
  0001f	6a 00		 push	 0
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 57   : 	}

  0002a	c3		 ret	 0
?Reset@TMonsterAIState@@QAEXXZ ENDP			; TMonsterAIState::Reset
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_7TMonsterAIAutomata@@6B@			; TMonsterAIAutomata::`vftable'
PUBLIC	??1TMonsterAIAutomata@@UAE@XZ			; TMonsterAIAutomata::~TMonsterAIAutomata
PUBLIC	??_R4TMonsterAIAutomata@@6B@			; TMonsterAIAutomata::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIAutomata@@@8			; TMonsterAIAutomata `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIAutomata@@8			; TMonsterAIAutomata::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIAutomata@@8			; TMonsterAIAutomata::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIAutomata@@8		; TMonsterAIAutomata::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAIAutomata@@UAEPAXI@Z:PROC		; TMonsterAIAutomata::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAIAutomata@@8
; File e:\work\tranet_version\gs\gameserver\tmonsteraiautomata.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIAutomata@@8 DD FLAT:??_R0?AVTMonsterAIAutomata@@@8 ; TMonsterAIAutomata::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIAutomata@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIAutomata@@8
rdata$r	SEGMENT
??_R2TMonsterAIAutomata@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIAutomata@@8 ; TMonsterAIAutomata::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIAutomata@@8
rdata$r	SEGMENT
??_R3TMonsterAIAutomata@@8 DD 00H			; TMonsterAIAutomata::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIAutomata@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIAutomata@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAIAutomata@@@8 DD FLAT:??_7type_info@@6B@ ; TMonsterAIAutomata `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIAutomata@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAIAutomata@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIAutomata@@6B@ DD 00H			; TMonsterAIAutomata::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIAutomata@@@8
	DD	FLAT:??_R3TMonsterAIAutomata@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIAutomata@@6B@
CONST	SEGMENT
??_7TMonsterAIAutomata@@6B@ DD FLAT:??_R4TMonsterAIAutomata@@6B@ ; TMonsterAIAutomata::`vftable'
	DD	FLAT:??_ETMonsterAIAutomata@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1TMonsterAIAutomata@@UAE@XZ
_TEXT	SEGMENT
??1TMonsterAIAutomata@@UAE@XZ PROC			; TMonsterAIAutomata::~TMonsterAIAutomata, COMDAT
; _this$ = ecx

; 27   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAIAutomata@@6B@

; 28   : 	return;
; 29   : }

  00006	c3		 ret	 0
??1TMonsterAIAutomata@@UAE@XZ ENDP			; TMonsterAIAutomata::~TMonsterAIAutomata
_TEXT	ENDS
PUBLIC	?Reset@TMonsterAIAutomata@@QAEXXZ		; TMonsterAIAutomata::Reset
; Function compile flags: /Ogtp
;	COMDAT ?Reset@TMonsterAIAutomata@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv817 = -4						; size = 4
?Reset@TMonsterAIAutomata@@QAEXXZ PROC			; TMonsterAIAutomata::Reset, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	for ( int i=0;i<MAX_AI_STATE;i++)

  0000c	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  0000f	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR tv817[ebp], 8
  00016	83 cf ff	 or	 edi, -1
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL9@Reset:

; 36   : 	{
; 37   : 		for ( int j=0;j<MAX_AI_PRIORITY;j++)

  00020	bb 1e 00 00 00	 mov	 ebx, 30			; 0000001eH
$LL6@Reset:

; 38   : 		{
; 39   : 			this->m_AIState[i][j].Reset();

  00025	6a 64		 push	 100			; 00000064H
  00027	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0002a	6a 00		 push	 0
  0002c	50		 push	 eax
  0002d	89 7e f8	 mov	 DWORD PTR [esi-8], edi
  00030	89 7e fc	 mov	 DWORD PTR [esi-4], edi
  00033	89 3e		 mov	 DWORD PTR [esi], edi
  00035	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00038	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003b	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003e	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00041	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00044	e8 00 00 00 00	 call	 _memset
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	81 c6 84 00 00
	00		 add	 esi, 132		; 00000084H
  00052	4b		 dec	 ebx
  00053	75 d0		 jne	 SHORT $LL6@Reset

; 35   : 	for ( int i=0;i<MAX_AI_STATE;i++)

  00055	ff 4d fc	 dec	 DWORD PTR tv817[ebp]
  00058	75 c6		 jne	 SHORT $LL9@Reset

; 40   : 		}
; 41   : 	}
; 42   : 
; 43   : 	for ( int k=0;k<MAX_AI_STATE;k++)
; 44   : 	{
; 45   : 		this->m_AIStateTransCount[k] = 0;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	33 c9		 xor	 ecx, ecx
  0005f	89 88 c8 7b 00
	00		 mov	 DWORD PTR [eax+31688], ecx
  00065	89 88 cc 7b 00
	00		 mov	 DWORD PTR [eax+31692], ecx
  0006b	89 88 d0 7b 00
	00		 mov	 DWORD PTR [eax+31696], ecx
  00071	89 88 d4 7b 00
	00		 mov	 DWORD PTR [eax+31700], ecx
  00077	89 88 d8 7b 00
	00		 mov	 DWORD PTR [eax+31704], ecx
  0007d	89 88 dc 7b 00
	00		 mov	 DWORD PTR [eax+31708], ecx
  00083	89 88 e0 7b 00
	00		 mov	 DWORD PTR [eax+31712], ecx
  00089	89 88 e4 7b 00
	00		 mov	 DWORD PTR [eax+31716], ecx

; 46   : 	}
; 47   : 
; 48   : 	this->m_iAutomataNumber = -1;

  0008f	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 49   : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?Reset@TMonsterAIAutomata@@QAEXXZ ENDP			; TMonsterAIAutomata::Reset
_TEXT	ENDS
PUBLIC	?DelAllAutomata@TMonsterAIAutomata@@SAHXZ	; TMonsterAIAutomata::DelAllAutomata
; Function compile flags: /Ogtp
;	COMDAT ?DelAllAutomata@TMonsterAIAutomata@@SAHXZ
_TEXT	SEGMENT
?DelAllAutomata@TMonsterAIAutomata@@SAHXZ PROC		; TMonsterAIAutomata::DelAllAutomata, COMDAT

; 199  : {

  00000	56		 push	 esi

; 200  : 	for ( int i =0;i<MAX_MONSTER_AI_AUTOMATA;i++)

  00001	be 00 00 00 00	 mov	 esi, OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
$LL3@DelAllAuto:

; 201  : 	{
; 202  : 		TMonsterAIAutomata::s_MonsterAIAutomataArray[i].Reset();

  00006	8b ce		 mov	 ecx, esi
  00008	e8 00 00 00 00	 call	 ?Reset@TMonsterAIAutomata@@QAEXXZ ; TMonsterAIAutomata::Reset
  0000d	81 c6 e8 7b 00
	00		 add	 esi, 31720		; 00007be8H
  00013	81 fe e0 33 91
	00		 cmp	 esi, OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A+9516000
  00019	7c eb		 jl	 SHORT $LL3@DelAllAuto

; 203  : 	}
; 204  : 
; 205  : 	return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	5e		 pop	 esi

; 206  : }

  0001e	c3		 ret	 0
?DelAllAutomata@TMonsterAIAutomata@@SAHXZ ENDP		; TMonsterAIAutomata::DelAllAutomata
_TEXT	ENDS
PUBLIC	??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@ ; `string'
PUBLIC	?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z	; TMonsterAIAutomata::FindAutomata
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@
CONST	SEGMENT
??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@ DB '[Monste'
	DB	'r AI Automata] FindAutomata() Error - (AutomataNumber=%d) ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z
_TEXT	SEGMENT
_iAutomataNumber$ = 8					; size = 4
?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z PROC	; TMonsterAIAutomata::FindAutomata, COMDAT

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 211  : 	if ( iAutomataNumber < 0 || iAutomataNumber >= MAX_MONSTER_AI_AUTOMATA )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iAutomataNumber$[ebp]
  00006	81 f9 2b 01 00
	00		 cmp	 ecx, 299		; 0000012bH
  0000c	77 18		 ja	 SHORT $LN2@FindAutoma

; 215  : 	}
; 216  : 
; 217  : 	if ( TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_iAutomataNumber == iAutomataNumber )

  0000e	8b c1		 mov	 eax, ecx
  00010	69 c0 e8 7b 00
	00		 imul	 eax, 31720		; 00007be8H
  00016	39 88 04 00 00
	00		 cmp	 DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax+4], ecx
  0001c	75 08		 jne	 SHORT $LN2@FindAutoma

; 218  : 	{
; 219  : 		return &TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber];

  0001e	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax]

; 220  : 	}
; 221  : 	
; 222  : 	LogAddTD("[Monster AI Automata] FindAutomata() Error - (AutomataNumber=%d) ", iAutomataNumber);
; 223  : 
; 224  : 	return NULL;
; 225  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN2@FindAutoma:

; 212  : 	{
; 213  : 		LogAddTD("[Monster AI Automata] FindAutomata() Error - (AutomataNumber=%d) ", iAutomataNumber);

  00026	51		 push	 ecx
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@CMBJNBHF@?$FLMonster?5AI?5Automata?$FN?5FindAutoma@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00032	83 c4 08	 add	 esp, 8

; 214  : 		return NULL;

  00035	33 c0		 xor	 eax, eax

; 220  : 	}
; 221  : 	
; 222  : 	LogAddTD("[Monster AI Automata] FindAutomata() Error - (AutomataNumber=%d) ", iAutomataNumber);
; 223  : 
; 224  : 	return NULL;
; 225  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?FindAutomata@TMonsterAIAutomata@@SAPAV1@H@Z ENDP	; TMonsterAIAutomata::FindAutomata
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z ; TMonsterAIAutomata::RunAutomata
EXTRN	_rand:PROC
EXTRN	?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z:PROC ; TMonsterAIGroup::FindGroupMemberToHeal
EXTRN	?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z:PROC ; TMonsterAIGroup::FindGroupMemberToSommon
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?GetAgro@TMonsterAIAgro@@QAEHH@Z:PROC		; TMonsterAIAgro::GetAgro
EXTRN	?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z:PROC ; TMonsterAIUtil::FindMonViewportObj
EXTRN	?GetMaxAgroUserIndex@TMonsterAIAgro@@QAEHH@Z:PROC ; TMonsterAIAgro::GetMaxAgroUserIndex
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z
_TEXT	SEGMENT
_iCurrentState$ = -24					; size = 4
_iMaxStateTransCount$ = -20				; size = 4
_this$ = -16						; size = 4
tv557 = -12						; size = 4
tv166 = -12						; size = 4
_iPriority$202496 = -8					; size = 4
_iMaxAgro$ = -4						; size = 4
_lpTargetObj$ = 8					; size = 4
_iIndex$ = 8						; size = 4
?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z PROC ; TMonsterAIAutomata::RunAutomata, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 231  : 	LPOBJ lpObj = &gObj[iIndex];

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00010	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00016	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 232  : 
; 233  : 	if ( MAX_AI_STATE_RANGE(lpObj->m_iCurrentAIState) == FALSE )

  00019	8b 86 7c 1c 00
	00		 mov	 eax, DWORD PTR [esi+7292]
  0001f	85 c0		 test	 eax, eax
  00021	78 0e		 js	 SHORT $LN48@RunAutomat
  00023	33 c9		 xor	 ecx, ecx
  00025	83 f8 07	 cmp	 eax, 7
  00028	0f 9e c1	 setle	 cl
  0002b	8b c1		 mov	 eax, ecx
  0002d	85 c0		 test	 eax, eax
  0002f	75 09		 jne	 SHORT $LN36@RunAutomat
$LN48@RunAutomat:

; 234  : 		return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 377  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN36@RunAutomat:

; 235  : 
; 236  : 	LPOBJ lpTargetObj = NULL;
; 237  : 	int iMaxAgro = -1;
; 238  : 
; 239  : 	int iTargetIndex = lpObj->m_Agro.GetMaxAgroUserIndex(lpObj->m_Index);

  0003a	8b 16		 mov	 edx, DWORD PTR [esi]
  0003c	53		 push	 ebx
  0003d	57		 push	 edi
  0003e	52		 push	 edx
  0003f	8d 8e 94 1c 00
	00		 lea	 ecx, DWORD PTR [esi+7316]
  00045	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lpTargetObj$[ebp], 0
  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iMaxAgro$[ebp], -1
  00053	e8 00 00 00 00	 call	 ?GetMaxAgroUserIndex@TMonsterAIAgro@@QAEHH@Z ; TMonsterAIAgro::GetMaxAgroUserIndex
  00058	8b f8		 mov	 edi, eax

; 240  : 
; 241  : 	// Search The user with Max Agro to make its enemy
; 242  : 	if ( iTargetIndex != -1 )

  0005a	83 ff ff	 cmp	 edi, -1
  0005d	74 39		 je	 SHORT $LN52@RunAutomat

; 243  : 	{
; 244  : 		lpTargetObj = &gObj[iTargetIndex];
; 245  : 
; 246  : 		if ( MONSTER_UTIL.FindMonViewportObj(lpObj->m_Index, lpTargetObj->m_Index) )

  0005f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00061	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00067	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	89 45 08	 mov	 DWORD PTR _lpTargetObj$[ebp], eax
  00070	8b 00		 mov	 eax, DWORD PTR [eax]
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00079	e8 00 00 00 00	 call	 ?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z ; TMonsterAIUtil::FindMonViewportObj
  0007e	85 c0		 test	 eax, eax
  00080	74 63		 je	 SHORT $LN34@RunAutomat

; 247  : 		{
; 248  : 			iMaxAgro = lpObj->m_Agro.GetAgro(iTargetIndex);

  00082	57		 push	 edi
  00083	8d 8e 94 1c 00
	00		 lea	 ecx, DWORD PTR [esi+7316]
  00089	e8 00 00 00 00	 call	 ?GetAgro@TMonsterAIAgro@@QAEHH@Z ; TMonsterAIAgro::GetAgro
  0008e	89 45 fc	 mov	 DWORD PTR _iMaxAgro$[ebp], eax

; 249  : 			lpObj->TargetNumber = iTargetIndex;

  00091	66 89 be 58 04
	00 00		 mov	 WORD PTR [esi+1112], di
$LN52@RunAutomat:

; 250  : 		}
; 251  : 		else

  00098	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
$LN33@RunAutomat:

; 255  : 		}
; 256  : 	}
; 257  : 
; 258  : 	BOOL bRateSuccess = FALSE;
; 259  : 
; 260  : 	int iCurrentState = lpObj->m_iCurrentAIState;

  0009b	8b 86 7c 1c 00
	00		 mov	 eax, DWORD PTR [esi+7292]

; 261  : 	int iMaxStateTransCount = this->m_AIStateTransCount[iCurrentState];

  000a1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8b bc 81 c8 7b
	00 00		 mov	 edi, DWORD PTR [ecx+eax*4+31688]
  000ab	89 45 e8	 mov	 DWORD PTR _iCurrentState$[ebp], eax
  000ae	89 7d ec	 mov	 DWORD PTR _iMaxStateTransCount$[ebp], edi

; 262  : 
; 263  : 	for ( int iPriority=0;iPriority<iMaxStateTransCount;iPriority++)

  000b1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iPriority$202496[ebp], 0
  000b8	85 ff		 test	 edi, edi
  000ba	0f 8e 93 01 00
	00		 jle	 $LN30@RunAutomat

; 255  : 		}
; 256  : 	}
; 257  : 
; 258  : 	BOOL bRateSuccess = FALSE;
; 259  : 
; 260  : 	int iCurrentState = lpObj->m_iCurrentAIState;

  000c0	69 c0 78 0f 00
	00		 imul	 eax, 3960		; 00000f78H
  000c6	8d 7c 08 20	 lea	 edi, DWORD PTR [eax+ecx+32]
  000ca	8d 9b 00 00 00
	00		 npad	 6
$LL58@RunAutomat:

; 264  : 	{
; 265  : 		TMonsterAIState * AIState = &this->m_AIState[iCurrentState][iPriority];
; 266  : 		BOOL bTransition = MAI_STATE_TRANS_VALUE_;	// If there is an apropiate Value it is set to TRUE
; 267  : 
; 268  : 		// Choose the right action according Transation Type 
; 269  : 		switch ( AIState->m_iTransitionType )

  000d0	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  000d3	33 db		 xor	 ebx, ebx
  000d5	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  000d8	0f 87 5f 01 00
	00		 ja	 $LN31@RunAutomat
  000de	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN63@RunAutomat[eax*4]
$LN34@RunAutomat:

; 252  : 		{
; 253  : 			lpObj->TargetNumber = -1;

  000e5	83 ca ff	 or	 edx, -1
  000e8	66 89 96 58 04
	00 00		 mov	 WORD PTR [esi+1112], dx

; 254  : 			lpTargetObj = NULL;

  000ef	33 d2		 xor	 edx, edx
  000f1	89 55 08	 mov	 DWORD PTR _lpTargetObj$[ebp], edx
  000f4	eb a5		 jmp	 SHORT $LN33@RunAutomat
$LN27@RunAutomat:

; 270  : 		{
; 271  : 			case MAI_STATE_TRANS_NO_ENEMY:
; 272  : 				if ( lpTargetObj == NULL )

  000f6	85 d2		 test	 edx, edx
  000f8	0f 85 3f 01 00
	00		 jne	 $LN31@RunAutomat

; 273  : 				{
; 274  : 					bTransition = TRUE;
; 275  : 				}
; 276  : 				break;

  000fe	e9 25 01 00 00	 jmp	 $LN54@RunAutomat
$LN25@RunAutomat:

; 277  : 
; 278  : 			case MAI_STATE_TRANS_IN_ENEMY:
; 279  : 				if ( lpTargetObj )

  00103	85 d2		 test	 edx, edx
  00105	0f 84 32 01 00
	00		 je	 $LN31@RunAutomat

; 280  : 				{
; 281  : 					if ( gObjCalDistance(lpObj, lpTargetObj) <= lpObj->m_AttackRange )

  0010b	52		 push	 edx
  0010c	56		 push	 esi
  0010d	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00112	0f bf 8e b0 04
	00 00		 movsx	 ecx, WORD PTR [esi+1200]
  00119	83 c4 08	 add	 esp, 8
  0011c	3b c1		 cmp	 eax, ecx
  0011e	0f 8f 16 01 00
	00		 jg	 $LN56@RunAutomat

; 282  : 					{
; 283  : 						bTransition = TRUE;
; 284  : 					}
; 285  : 				}
; 286  : 				break;

  00124	e9 ff 00 00 00	 jmp	 $LN54@RunAutomat
$LN22@RunAutomat:

; 287  : 
; 288  : 			case MAI_STATE_TRANS_OUT_ENEMY:
; 289  : 				if ( lpTargetObj )

  00129	85 d2		 test	 edx, edx
  0012b	0f 84 0c 01 00
	00		 je	 $LN31@RunAutomat

; 290  : 				{
; 291  : 					if ( gObjCalDistance(lpObj, lpTargetObj) > lpObj->m_AttackRange )

  00131	52		 push	 edx
  00132	56		 push	 esi
  00133	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00138	0f bf 96 b0 04
	00 00		 movsx	 edx, WORD PTR [esi+1200]
  0013f	83 c4 08	 add	 esp, 8
  00142	3b c2		 cmp	 eax, edx
  00144	0f 8e f0 00 00
	00		 jle	 $LN56@RunAutomat

; 292  : 					{
; 293  : 						bTransition =  TRUE;
; 294  : 					}
; 295  : 				}
; 296  : 				break;

  0014a	e9 d9 00 00 00	 jmp	 $LN54@RunAutomat
$LN19@RunAutomat:

; 297  : 
; 298  : 			//case MAI_STATE_TRANS_DIE_ENEMY:
; 299  : 
; 300  : 			case MAI_STATE_TRANS_DEC_HP:
; 301  : 				if ( AIState->m_iTransitionValue > lpObj->Life )

  0014f	db 07		 fild	 DWORD PTR [edi]
  00151	d9 86 fc 00 00
	00		 fld	 DWORD PTR [esi+252]
  00157	de d9		 fcompp
  00159	df e0		 fnstsw	 ax
  0015b	f6 c4 05	 test	 ah, 5
  0015e	0f 8a d9 00 00
	00		 jp	 $LN31@RunAutomat

; 302  : 				{
; 303  : 					bTransition = TRUE;
; 304  : 				}
; 305  : 				break;

  00164	e9 bf 00 00 00	 jmp	 $LN54@RunAutomat
$LN16@RunAutomat:

; 306  : 
; 307  : 			case MAI_STATE_TRANS_IMMEDIATELY:
; 308  : 				bTransition = TRUE;
; 309  : 				break;
; 310  : 
; 311  : 			case MAI_STATE_TRANS_DEC_HP_PER:
; 312  : 				{
; 313  : 					AIState->m_iTransitionValue = (AIState->m_iTransitionValue > 0)? AIState->m_iTransitionValue : 0;

  00169	8b 07		 mov	 eax, DWORD PTR [edi]
  0016b	33 c9		 xor	 ecx, ecx
  0016d	85 c0		 test	 eax, eax
  0016f	0f 9e c1	 setle	 cl
  00172	49		 dec	 ecx
  00173	23 c1		 and	 eax, ecx
  00175	89 07		 mov	 DWORD PTR [edi], eax

; 314  : 					AIState->m_iTransitionValue = (AIState->m_iTransitionValue < 100 )? AIState->m_iTransitionValue : 100 ;

  00177	83 f8 64	 cmp	 eax, 100		; 00000064H
  0017a	7c 05		 jl	 SHORT $LN62@RunAutomat
  0017c	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
$LN62@RunAutomat:
  00181	89 07		 mov	 DWORD PTR [edi], eax

; 315  : 					int iLife = (int)(((float)lpObj->AddLife + lpObj->MaxLife) * (float)AIState->m_iTransitionValue / 100.0f);
; 316  : 
; 317  : 					if ( iLife > lpObj->Life )

  00183	db 86 4c 01 00
	00		 fild	 DWORD PTR [esi+332]
  00189	89 45 f4	 mov	 DWORD PTR tv166[ebp], eax
  0018c	d8 86 00 01 00
	00		 fadd	 DWORD PTR [esi+256]
  00192	da 4d f4	 fimul	 DWORD PTR tv166[ebp]
  00195	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  0019b	e8 00 00 00 00	 call	 __ftol2_sse
  001a0	89 45 f4	 mov	 DWORD PTR tv557[ebp], eax
  001a3	db 45 f4	 fild	 DWORD PTR tv557[ebp]
  001a6	d9 86 fc 00 00
	00		 fld	 DWORD PTR [esi+252]
  001ac	de d9		 fcompp
  001ae	df e0		 fnstsw	 ax
  001b0	f6 c4 05	 test	 ah, 5
  001b3	0f 8a 81 00 00
	00		 jp	 $LN56@RunAutomat

; 318  : 					{
; 319  : 						bTransition = TRUE;
; 320  : 					}
; 321  : 				}
; 322  : 				break;

  001b9	eb 6d		 jmp	 SHORT $LN54@RunAutomat
$LN14@RunAutomat:

; 323  : 
; 324  : 			case MAI_STATE_TRANS_AGRO_UP:
; 325  : 				if ( lpTargetObj )

  001bb	85 d2		 test	 edx, edx
  001bd	74 7e		 je	 SHORT $LN31@RunAutomat

; 326  : 				{
; 327  : 					if ( iMaxAgro >= AIState->m_iTransitionValue )

  001bf	8b 45 fc	 mov	 eax, DWORD PTR _iMaxAgro$[ebp]
  001c2	3b 07		 cmp	 eax, DWORD PTR [edi]
  001c4	7c 77		 jl	 SHORT $LN31@RunAutomat

; 328  : 					{
; 329  : 						bTransition = TRUE;
; 330  : 					}
; 331  : 				}
; 332  : 				break;

  001c6	eb 60		 jmp	 SHORT $LN54@RunAutomat
$LN11@RunAutomat:

; 333  : 
; 334  : 			case MAI_STATE_TRANS_AGRO_DOWN:
; 335  : 				if ( lpTargetObj )

  001c8	85 d2		 test	 edx, edx
  001ca	74 71		 je	 SHORT $LN31@RunAutomat

; 336  : 				{
; 337  : 					if ( iMaxAgro <= AIState->m_iTransitionValue )

  001cc	8b 4d fc	 mov	 ecx, DWORD PTR _iMaxAgro$[ebp]
  001cf	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  001d1	7f 6a		 jg	 SHORT $LN31@RunAutomat

; 338  : 					{
; 339  : 						bTransition = TRUE;
; 340  : 					}
; 341  : 				}
; 342  : 				break;

  001d3	eb 53		 jmp	 SHORT $LN54@RunAutomat
$LN8@RunAutomat:

; 343  : 
; 344  : 			case MAI_STATE_TRANS_GROUP_SOMMON:
; 345  : 				if ( lpObj->m_iGroupNumber )

  001d5	8b 86 84 1c 00
	00		 mov	 eax, DWORD PTR [esi+7300]
  001db	85 c0		 test	 eax, eax
  001dd	74 1f		 je	 SHORT $LN59@RunAutomat

; 346  : 				{
; 347  : 					if ( TMonsterAIGroup::FindGroupMemberToSommon(lpObj->m_Index, lpObj->m_iGroupNumber, lpObj->m_iGroupMemberGuid) )

  001df	8b 96 8c 1c 00
	00		 mov	 edx, DWORD PTR [esi+7308]
  001e5	52		 push	 edx
  001e6	50		 push	 eax
  001e7	8b 06		 mov	 eax, DWORD PTR [esi]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?FindGroupMemberToSommon@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHH@Z ; TMonsterAIGroup::FindGroupMemberToSommon

; 348  : 					{
; 349  : 						bTransition = TRUE;

  001ef	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  001f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f5	85 c0		 test	 eax, eax
  001f7	74 05		 je	 SHORT $LN59@RunAutomat
  001f9	bb 01 00 00 00	 mov	 ebx, 1
$LN59@RunAutomat:

; 350  : 					}
; 351  : 				}
; 352  : 
; 353  : 			case MAI_STATE_TRANS_GROUP_HEAL:
; 354  : 				if ( lpObj->m_iGroupNumber )

  001fe	8b 86 84 1c 00
	00		 mov	 eax, DWORD PTR [esi+7300]
  00204	85 c0		 test	 eax, eax
  00206	74 1c		 je	 SHORT $LN3@RunAutomat

; 355  : 				{
; 356  : 					if ( TMonsterAIGroup::FindGroupMemberToHeal(lpObj->m_Index, lpObj->m_iGroupNumber, lpObj->m_iGroupMemberGuid, 5) )

  00208	8b 8e 8c 1c 00
	00		 mov	 ecx, DWORD PTR [esi+7308]
  0020e	8b 16		 mov	 edx, DWORD PTR [esi]
  00210	6a 05		 push	 5
  00212	51		 push	 ecx
  00213	50		 push	 eax
  00214	52		 push	 edx
  00215	e8 00 00 00 00	 call	 ?FindGroupMemberToHeal@TMonsterAIGroup@@SAPAVTMonsterAIGroupMember@@HHHH@Z ; TMonsterAIGroup::FindGroupMemberToHeal
  0021a	83 c4 10	 add	 esp, 16			; 00000010H
  0021d	85 c0		 test	 eax, eax

; 357  : 					{
; 358  : 						bTransition = TRUE;
; 359  : 					}
; 360  : 				}
; 361  : 				break;
; 362  : 		}
; 363  : 
; 364  : 		// If is Wrong State
; 365  : 		if ( bTransition == FALSE )	

  0021f	75 07		 jne	 SHORT $LN54@RunAutomat
  00221	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
$LN3@RunAutomat:
  00224	85 db		 test	 ebx, ebx
  00226	74 15		 je	 SHORT $LN31@RunAutomat
$LN54@RunAutomat:

; 366  : 			continue;
; 367  : 
; 368  : 		if ( (rand()%100) < AIState->m_iTransitionRate )

  00228	e8 00 00 00 00	 call	 _rand
  0022d	99		 cdq
  0022e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00233	f7 f9		 idiv	 ecx
  00235	3b 57 f8	 cmp	 edx, DWORD PTR [edi-8]
  00238	7c 24		 jl	 SHORT $LN46@RunAutomat
$LN56@RunAutomat:
  0023a	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
$LN31@RunAutomat:

; 262  : 
; 263  : 	for ( int iPriority=0;iPriority<iMaxStateTransCount;iPriority++)

  0023d	8b 45 f8	 mov	 eax, DWORD PTR _iPriority$202496[ebp]
  00240	40		 inc	 eax
  00241	81 c7 84 00 00
	00		 add	 edi, 132		; 00000084H
  00247	89 45 f8	 mov	 DWORD PTR _iPriority$202496[ebp], eax
  0024a	3b 45 ec	 cmp	 eax, DWORD PTR _iMaxStateTransCount$[ebp]
  0024d	0f 8c 7d fe ff
	ff		 jl	 $LL58@RunAutomat
$LN30@RunAutomat:
  00253	5f		 pop	 edi
  00254	5b		 pop	 ebx

; 373  : 		}
; 374  : 	}
; 375  : 
; 376  : 	return NULL;

  00255	33 c0		 xor	 eax, eax
  00257	5e		 pop	 esi

; 377  : }

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 04 00	 ret	 4
$LN46@RunAutomat:

; 369  : 		{
; 370  : 			bRateSuccess = TRUE;
; 371  : 			lpObj->m_iLastAutomataDelay = AIState->m_iDelayTime;
; 372  : 			return &this->m_AIState[iCurrentState][iPriority];

  0025e	8b 45 e8	 mov	 eax, DWORD PTR _iCurrentState$[ebp]
  00261	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00264	8b c8		 mov	 ecx, eax
  00266	c1 e1 04	 shl	 ecx, 4
  00269	2b c8		 sub	 ecx, eax
  0026b	89 96 bc 1f 00
	00		 mov	 DWORD PTR [esi+8124], edx
  00271	8b 55 f8	 mov	 edx, DWORD PTR _iPriority$202496[ebp]
  00274	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00277	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	69 c0 84 00 00
	00		 imul	 eax, 132		; 00000084H
  00280	5f		 pop	 edi
  00281	5b		 pop	 ebx
  00282	8d 44 08 08	 lea	 eax, DWORD PTR [eax+ecx+8]
  00286	5e		 pop	 esi

; 377  : }

  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c2 04 00	 ret	 4
  0028d	8d 49 00	 npad	 3
$LN63@RunAutomat:
  00290	00 00 00 00	 DD	 $LN27@RunAutomat
  00294	00 00 00 00	 DD	 $LN25@RunAutomat
  00298	00 00 00 00	 DD	 $LN22@RunAutomat
  0029c	00 00 00 00	 DD	 $LN31@RunAutomat
  002a0	00 00 00 00	 DD	 $LN19@RunAutomat
  002a4	00 00 00 00	 DD	 $LN16@RunAutomat
  002a8	00 00 00 00	 DD	 $LN54@RunAutomat
  002ac	00 00 00 00	 DD	 $LN14@RunAutomat
  002b0	00 00 00 00	 DD	 $LN11@RunAutomat
  002b4	00 00 00 00	 DD	 $LN31@RunAutomat
  002b8	00 00 00 00	 DD	 $LN8@RunAutomat
  002bc	00 00 00 00	 DD	 $LN59@RunAutomat
?RunAutomata@TMonsterAIAutomata@@QAEPAVTMonsterAIState@@H@Z ENDP ; TMonsterAIAutomata::RunAutomata
_TEXT	ENDS
PUBLIC	??0TMonsterAIState@@QAE@XZ			; TMonsterAIState::TMonsterAIState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsteraistate.h
;	COMDAT ??0TMonsterAIState@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterAIState@@QAE@XZ PROC				; TMonsterAIState::TMonsterAIState, COMDAT
; _this$ = ecx

; 42   : 	{
; 43   : 		this->Reset();

  00000	83 c8 ff	 or	 eax, -1
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	6a 64		 push	 100			; 00000064H
  00008	89 06		 mov	 DWORD PTR [esi], eax
  0000a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00010	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00013	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00016	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00019	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0001c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0001f	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memset
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 	}

  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
??0TMonsterAIState@@QAE@XZ ENDP				; TMonsterAIState::TMonsterAIState
_TEXT	ENDS
PUBLIC	??0TMonsterAIAutomata@@QAE@XZ			; TMonsterAIAutomata::TMonsterAIAutomata
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsteraiautomata.cpp
;	COMDAT ??0TMonsterAIAutomata@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TMonsterAIAutomata@@QAE@XZ PROC			; TMonsterAIAutomata::TMonsterAIAutomata, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAIAutomata@@6B@
  00010	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00013	bb ef 00 00 00	 mov	 ebx, 239		; 000000efH
  00018	83 cf ff	 or	 edi, -1
  0001b	eb 03 8d 49 00	 npad	 5
$LL4@TMonsterAI:
  00020	6a 64		 push	 100			; 00000064H
  00022	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00025	6a 00		 push	 0
  00027	50		 push	 eax
  00028	89 3e		 mov	 DWORD PTR [esi], edi
  0002a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0002d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00030	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00033	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00036	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00039	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0003c	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0003f	e8 00 00 00 00	 call	 _memset
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	81 c6 84 00 00
	00		 add	 esi, 132		; 00000084H
  0004d	4b		 dec	 ebx
  0004e	79 d0		 jns	 SHORT $LL4@TMonsterAI

; 23   : 	this->Reset();

  00050	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?Reset@TMonsterAIAutomata@@QAEXXZ ; TMonsterAIAutomata::Reset
  0005a	5f		 pop	 edi

; 24   : }

  0005b	8b c6		 mov	 eax, esi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??0TMonsterAIAutomata@@QAE@XZ ENDP			; TMonsterAIAutomata::TMonsterAIAutomata
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GTMonsterAIAutomata@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTMonsterAIAutomata@@UAEPAXI@Z PROC			; TMonsterAIAutomata::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1TMonsterAIAutomata@@UAE@XZ ; TMonsterAIAutomata::~TMonsterAIAutomata
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GTMonsterAIAutomata@@UAEPAXI@Z ENDP			; TMonsterAIAutomata::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@ ; `string'
PUBLIC	??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@ ; `string'
PUBLIC	??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@ ; `string'
PUBLIC	??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@ ; `string'
PUBLIC	??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@ ; `string'
PUBLIC	??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@ ; `string'
PUBLIC	??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@ ; `string'
PUBLIC	??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?LoadData@TMonsterAIAutomata@@SAHPAD@Z		; TMonsterAIAutomata::LoadData
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@
CONST	SEGMENT
??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@ DB '[Mon'
	DB	'ster AI Automata] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@
CONST	SEGMENT
??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@ DB '[Mon'
	DB	'ster AI Automata] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@
CONST	SEGMENT
??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@ DB '[Mons'
	DB	'ter AI Automata] - AutomataNumber(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@
CONST	SEGMENT
??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@ DB '[Mons'
	DB	'ter AI Automata] - CurrentState(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@
CONST	SEGMENT
??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@ DB '[Mons'
	DB	'ter AI Automata] - NextState(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@
CONST	SEGMENT
??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@ DB '[Mons'
	DB	'ter AI Automata] - Priority(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@
CONST	SEGMENT
??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@ DB '[Monst'
	DB	'er AI Automata] Loaded Transition Desc . [ %s ]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@
CONST	SEGMENT
??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@ DB '['
	DB	'Monster AI Automata] - %s file is Loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@
CONST	SEGMENT
??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@ DB '[Mo'
	DB	'nster AI Automata] - Can''t Open %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterAIAutomata@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?LoadData@TMonsterAIAutomata@@SAHPAD@Z
_TEXT	SEGMENT
_szStateTransitionDesc$202421 = -148			; size = 100
_iTransitionRate$202427 = -48				; size = 4
_iCurrentState$202424 = -44				; size = 4
_iType$202410 = -40					; size = 4
_iAutomataNumber$202422 = -36				; size = 4
_iTransitionType$202426 = -32				; size = 4
_iTransitionValue$202429 = -28				; size = 4
_iTransitionValueType$202428 = -24			; size = 4
_iNextState$202425 = -20				; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterAIAutomata@@SAHPAD@Z PROC		; TMonsterAIAutomata::LoadData, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 54   : 	TMonsterAIAutomata::s_bDataLoad = FALSE;
; 55   : 
; 56   : 	if ( lpszFileName == NULL || strcmp(lpszFileName, "") == 0 )

  0002e	8b 75 08	 mov	 esi, DWORD PTR _lpszFileName$[ebp]
  00031	33 ff		 xor	 edi, edi
  00033	89 3d 00 00 00
	00		 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIAutomata@@2HA, edi ; TMonsterAIAutomata::s_bDataLoad
  00039	3b f7		 cmp	 esi, edi
  0003b	0f 84 f9 02 00
	00		 je	 $LN18@LoadData
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00046	8b c6		 mov	 eax, esi
$LL30@LoadData:
  00048	8a 10		 mov	 dl, BYTE PTR [eax]
  0004a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0004c	75 1a		 jne	 SHORT $LN31@LoadData
  0004e	84 d2		 test	 dl, dl
  00050	74 12		 je	 SHORT $LN32@LoadData
  00052	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00055	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00058	75 0e		 jne	 SHORT $LN31@LoadData
  0005a	83 c0 02	 add	 eax, 2
  0005d	83 c1 02	 add	 ecx, 2
  00060	84 d2		 test	 dl, dl
  00062	75 e4		 jne	 SHORT $LL30@LoadData
$LN32@LoadData:
  00064	33 c0		 xor	 eax, eax
  00066	eb 05		 jmp	 SHORT $LN33@LoadData
$LN31@LoadData:
  00068	1b c0		 sbb	 eax, eax
  0006a	83 d8 ff	 sbb	 eax, -1
$LN33@LoadData:
  0006d	3b c7		 cmp	 eax, edi
  0006f	0f 84 c5 02 00
	00		 je	 $LN18@LoadData

; 60   : 	}
; 61   : 
; 62   : 	try
; 63   : 	{
; 64   : 		SMDToken Token;
; 65   : 		SMDFile = fopen(lpszFileName, "r");

  00075	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0007a	56		 push	 esi
  0007b	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  0007e	e8 00 00 00 00	 call	 _fopen
  00083	83 c4 08	 add	 esp, 8
  00086	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 66   : 
; 67   : 		if ( SMDFile == NULL )

  0008b	3b c7		 cmp	 eax, edi
  0008d	75 22		 jne	 SHORT $LN16@LoadData

; 68   : 		{
; 69   : 			MsgBox("[Monster AI Automata] - Can't Open %s ", lpszFileName);

  0008f	56		 push	 esi
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GONAGODC@?$FLMonster?5AI?5Automata?$FN?5?9?5Can?8t?5Op@
  00095	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0009a	83 c4 08	 add	 esp, 8
  0009d	33 c0		 xor	 eax, eax

; 190  : 
; 191  : 	return FALSE;
; 192  : }

  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN16@LoadData:

; 70   : 			return FALSE;
; 71   : 		}
; 72   : 
; 73   : 		TMonsterAIAutomata::DelAllAutomata();

  000b1	e8 00 00 00 00	 call	 ?DelAllAutomata@TMonsterAIAutomata@@SAHXZ ; TMonsterAIAutomata::DelAllAutomata
$LL15@LoadData:

; 74   : 
; 75   : 		int iType = -1;
; 76   : 
; 77   : 		while ( true )
; 78   : 		{
; 79   : 			Token = (SMDToken)GetToken();

  000b6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 80   : 
; 81   : 			if ( Token == END )

  000bb	83 f8 02	 cmp	 eax, 2
  000be	75 3a		 jne	 SHORT $LN13@LoadData

; 177  : 				}
; 178  : 			}
; 179  : 		
; 180  : 		}
; 181  : 
; 182  : 		fclose(SMDFile);

  000c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _fclose

; 183  : 		LogAddC(2,"[Monster AI Automata] - %s file is Loaded", lpszFileName);

  000cb	56		 push	 esi
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MCHAMKKH@?$FLMonster?5AI?5Automata?$FN?5?9?5?$CFs?5file?5@
  000d1	6a 02		 push	 2
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 184  : 		TMonsterAIAutomata::s_bDataLoad = TRUE;

  000dc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterAIAutomata@@2HA, 1 ; TMonsterAIAutomata::s_bDataLoad
  000e6	33 c0		 xor	 eax, eax

; 190  : 
; 191  : 	return FALSE;
; 192  : }

  000e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f2	59		 pop	 ecx
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
$LN13@LoadData:

; 82   : 				break;
; 83   : 
; 84   : 			iType = (int)TokenNumber;

  000fa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00100	e8 00 00 00 00	 call	 __ftol2_sse
  00105	89 45 d8	 mov	 DWORD PTR _iType$202410[ebp], eax
$LL12@LoadData:

; 85   : 
; 86   : 			while ( true )
; 87   : 			{
; 88   : 				if ( iType == 0 )

  00108	83 7d d8 00	 cmp	 DWORD PTR _iType$202410[ebp], 0
  0010c	75 fa		 jne	 SHORT $LL12@LoadData

; 89   : 				{
; 90   : 					char szStateTransitionDesc[100] = {0};
; 91   : 					int iAutomataNumber = -1;
; 92   : 					int iPriority = -1;
; 93   : 					int iCurrentState = -1;
; 94   : 					int iNextState = -1;
; 95   : 					int iTransitionType = -1;
; 96   : 					int iTransitionRate = -1;
; 97   : 					int iTransitionValueType = -1;
; 98   : 					int iTransitionValue = -1;
; 99   : 					int iDelayTime = -1;
; 100  : 
; 101  : 					Token = (SMDToken)GetToken();

  0010e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 102  : 
; 103  : 					if ( strcmp("end", TokenString) == 0 )

  00113	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00118	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0011d	8d 49 00	 npad	 3
$LL34@LoadData:
  00120	8a 10		 mov	 dl, BYTE PTR [eax]
  00122	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00124	75 1a		 jne	 SHORT $LN35@LoadData
  00126	84 d2		 test	 dl, dl
  00128	74 12		 je	 SHORT $LN36@LoadData
  0012a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0012d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00130	75 0e		 jne	 SHORT $LN35@LoadData
  00132	83 c0 02	 add	 eax, 2
  00135	83 c1 02	 add	 ecx, 2
  00138	84 d2		 test	 dl, dl
  0013a	75 e4		 jne	 SHORT $LL34@LoadData
$LN36@LoadData:
  0013c	33 c0		 xor	 eax, eax
  0013e	eb 05		 jmp	 SHORT $LN37@LoadData
$LN35@LoadData:
  00140	1b c0		 sbb	 eax, eax
  00142	83 d8 ff	 sbb	 eax, -1
$LN37@LoadData:
  00145	85 c0		 test	 eax, eax
  00147	0f 84 ce 01 00
	00		 je	 $LN38@LoadData

; 104  : 						break;
; 105  : 
; 106  : 					iAutomataNumber = (int)TokenNumber;

  0014d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00153	e8 00 00 00 00	 call	 __ftol2_sse
  00158	8b d8		 mov	 ebx, eax
  0015a	89 5d dc	 mov	 DWORD PTR _iAutomataNumber$202422[ebp], ebx

; 107  : 
; 108  : 					Token = (SMDToken)GetToken();

  0015d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 109  : 					memcpy(szStateTransitionDesc, TokenString, sizeof(szStateTransitionDesc));

  00162	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00167	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  0016c	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR _szStateTransitionDesc$202421[ebp]
  00172	f3 a5		 rep movsd

; 110  : 
; 111  : 					Token = (SMDToken)GetToken();

  00174	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 112  : 					iPriority = (int)TokenNumber;

  00179	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0017f	e8 00 00 00 00	 call	 __ftol2_sse
  00184	8b f8		 mov	 edi, eax

; 113  : 
; 114  : 					Token = (SMDToken)GetToken();

  00186	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 115  : 					iCurrentState = (int)TokenNumber;

  0018b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00191	e8 00 00 00 00	 call	 __ftol2_sse
  00196	8b f0		 mov	 esi, eax
  00198	89 75 d4	 mov	 DWORD PTR _iCurrentState$202424[ebp], esi

; 116  : 
; 117  : 					Token = (SMDToken)GetToken();

  0019b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 118  : 					iNextState = (int)TokenNumber;

  001a0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001a6	e8 00 00 00 00	 call	 __ftol2_sse
  001ab	89 45 ec	 mov	 DWORD PTR _iNextState$202425[ebp], eax

; 119  : 
; 120  : 					Token = (SMDToken)GetToken();

  001ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 121  : 					iTransitionType = (int)TokenNumber;

  001b3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001b9	e8 00 00 00 00	 call	 __ftol2_sse
  001be	89 45 e0	 mov	 DWORD PTR _iTransitionType$202426[ebp], eax

; 122  : 
; 123  : 					Token = (SMDToken)GetToken();

  001c1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 124  : 					iTransitionRate = (int)TokenNumber;

  001c6	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001cc	e8 00 00 00 00	 call	 __ftol2_sse
  001d1	89 45 d0	 mov	 DWORD PTR _iTransitionRate$202427[ebp], eax

; 125  : 
; 126  : 					Token = (SMDToken)GetToken();

  001d4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 127  : 					iTransitionValueType = (int)TokenNumber;

  001d9	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001df	e8 00 00 00 00	 call	 __ftol2_sse
  001e4	89 45 e8	 mov	 DWORD PTR _iTransitionValueType$202428[ebp], eax

; 128  : 
; 129  : 					Token = (SMDToken)GetToken();

  001e7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 130  : 					iTransitionValue = (int)TokenNumber;

  001ec	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f2	e8 00 00 00 00	 call	 __ftol2_sse
  001f7	89 45 e4	 mov	 DWORD PTR _iTransitionValue$202429[ebp], eax

; 131  : 
; 132  : 					Token = (SMDToken)GetToken();

  001fa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 133  : 					iDelayTime = (int)TokenNumber;

  001ff	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00205	e8 00 00 00 00	 call	 __ftol2_sse

; 134  : 
; 135  : 					if ( iAutomataNumber < 0 || iAutomataNumber >= MAX_MONSTER_AI_AUTOMATA )

  0020a	81 fb 2b 01 00
	00		 cmp	 ebx, 299		; 0000012bH
  00210	0f 87 ee 00 00
	00		 ja	 $LN7@LoadData

; 139  : 					}
; 140  : 
; 141  : 					if ( iCurrentState < 0 || iCurrentState >= MAX_AI_STATE )

  00216	83 fe 07	 cmp	 esi, 7
  00219	0f 87 ce 00 00
	00		 ja	 $LN5@LoadData

; 145  : 					}
; 146  : 
; 147  : 					if ( iNextState < 0 || iNextState >= MAX_AI_STATE )

  0021f	8b 4d ec	 mov	 ecx, DWORD PTR _iNextState$202425[ebp]
  00222	83 f9 07	 cmp	 ecx, 7
  00225	0f 87 ab 00 00
	00		 ja	 $LN3@LoadData

; 151  : 					}
; 152  : 
; 153  : 					if ( iPriority < 0 || iPriority >= MAX_AI_PRIORITY )

  0022b	83 ff 1d	 cmp	 edi, 29			; 0000001dH
  0022e	0f 87 8b 00 00
	00		 ja	 $LN1@LoadData

; 157  : 					}
; 158  : 
; 159  : 
; 160  : 					TMonsterAIState * AIState = &TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_AIState[iCurrentState][iPriority];

  00234	8b ce		 mov	 ecx, esi
  00236	69 db e8 7b 00
	00		 imul	 ebx, 31720		; 00007be8H
  0023c	c1 e1 04	 shl	 ecx, 4
  0023f	2b ce		 sub	 ecx, esi
  00241	8d 14 4f	 lea	 edx, DWORD PTR [edi+ecx*2]
  00244	69 d2 84 00 00
	00		 imul	 edx, 132		; 00000084H
  0024a	8d 8c 1a 08 00
	00 00		 lea	 ecx, DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[edx+ebx+8]

; 161  : 
; 162  : 					AIState->m_iPriority = iPriority;
; 163  : 					AIState->m_iCurrentState = iCurrentState;
; 164  : 					AIState->m_iNextState = iNextState;

  00251	8b 55 ec	 mov	 edx, DWORD PTR _iNextState$202425[ebp]
  00254	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 165  : 					AIState->m_iTransitionType = iTransitionType;

  00257	8b 55 e0	 mov	 edx, DWORD PTR _iTransitionType$202426[ebp]
  0025a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 166  : 					AIState->m_iTransitionRate = iTransitionRate;

  0025d	8b 55 d0	 mov	 edx, DWORD PTR _iTransitionRate$202427[ebp]
  00260	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 167  : 					AIState->m_iTransitionValueType = iTransitionValueType;

  00263	8b 55 e8	 mov	 edx, DWORD PTR _iTransitionValueType$202428[ebp]

; 168  : 					AIState->m_iTransitionValue = iTransitionValue;
; 169  : 					AIState->m_iDelayTime = iDelayTime;

  00266	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 170  : 
; 171  : 					memcpy(AIState->m_szStateTransitionDesc, szStateTransitionDesc, sizeof(szStateTransitionDesc));

  00269	8d 41 20	 lea	 eax, DWORD PTR [ecx+32]
  0026c	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  0026f	8b 55 e4	 mov	 edx, DWORD PTR _iTransitionValue$202429[ebp]

; 172  : 
; 173  : 					LogAddC(2,"[Monster AI Automata] Loaded Transition Desc . [ %s ]", AIState->m_szStateTransitionDesc);

  00272	50		 push	 eax
  00273	89 39		 mov	 DWORD PTR [ecx], edi
  00275	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00278	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0027b	8b f8		 mov	 edi, eax
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@IGNAMLCG@?$FLMonster?5AI?5Automata?$FN?5Loaded?5Tra@
  00282	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00287	8d b5 6c ff ff
	ff		 lea	 esi, DWORD PTR _szStateTransitionDesc$202421[ebp]
  0028d	6a 02		 push	 2
  0028f	f3 a5		 rep movsd
  00291	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 174  : 
; 175  : 					TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_iAutomataNumber = iAutomataNumber;

  00297	8b 45 dc	 mov	 eax, DWORD PTR _iAutomataNumber$202422[ebp]
  0029a	89 83 04 00 00
	00		 mov	 DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[ebx+4], eax

; 176  : 					TMonsterAIAutomata::s_MonsterAIAutomataArray[iAutomataNumber].m_AIStateTransCount[iCurrentState]++;

  002a0	69 c0 fa 1e 00
	00		 imul	 eax, 7930		; 00001efaH
  002a6	03 45 d4	 add	 eax, DWORD PTR _iCurrentState$202424[ebp]
  002a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ac	ff 04 85 c8 7b
	00 00		 inc	 DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax*4+31688]
  002b3	8d 04 85 c8 7b
	00 00		 lea	 eax, DWORD PTR ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A[eax*4+31688]
  002ba	e9 49 fe ff ff	 jmp	 $LL12@LoadData
$LN1@LoadData:

; 154  : 					{
; 155  : 						MsgBox("[Monster AI Automata] - Priority(%d) Error (%s) File. ",iPriority, lpszFileName);

  002bf	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  002c2	50		 push	 eax
  002c3	57		 push	 edi
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DPDJANEP@?$FLMonster?5AI?5Automata?$FN?5?9?5Priority@
  002c9	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 						continue;

  002d1	e9 32 fe ff ff	 jmp	 $LL12@LoadData
$LN3@LoadData:

; 148  : 					{
; 149  : 						MsgBox("[Monster AI Automata] - NextState(%d) Error (%s) File. ",iNextState, lpszFileName);

  002d6	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  002d9	52		 push	 edx
  002da	51		 push	 ecx
  002db	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LIGGCJGB@?$FLMonster?5AI?5Automata?$FN?5?9?5NextStat@
  002e0	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 						continue;

  002e8	e9 1b fe ff ff	 jmp	 $LL12@LoadData
$LN5@LoadData:

; 142  : 					{
; 143  : 						MsgBox("[Monster AI Automata] - CurrentState(%d) Error (%s) File. ",iCurrentState, lpszFileName);

  002ed	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  002f0	50		 push	 eax
  002f1	56		 push	 esi
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@BLGGHICH@?$FLMonster?5AI?5Automata?$FN?5?9?5CurrentS@
  002f7	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 						continue;

  002ff	e9 04 fe ff ff	 jmp	 $LL12@LoadData
$LN7@LoadData:

; 136  : 					{
; 137  : 						MsgBox("[Monster AI Automata] - AutomataNumber(%d) Error (%s) File. ",iAutomataNumber, lpszFileName);

  00304	8b 4d 08	 mov	 ecx, DWORD PTR _lpszFileName$[ebp]
  00307	51		 push	 ecx
  00308	53		 push	 ebx
  00309	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CKMDEDIJ@?$FLMonster?5AI?5Automata?$FN?5?9?5Automata@
  0030e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 						continue;

  00316	e9 ed fd ff ff	 jmp	 $LL12@LoadData
$LN38@LoadData:
  0031b	8b 75 08	 mov	 esi, DWORD PTR _lpszFileName$[ebp]
  0031e	e9 93 fd ff ff	 jmp	 $LL15@LoadData
__catch$?LoadData@TMonsterAIAutomata@@SAHPAD@Z$0:

; 185  : 	}
; 186  : 	catch(...)
; 187  : 	{
; 188  : 		MsgBox("[Monster AI Automata] - Loading Exception Error (%s) File. ", lpszFileName);

  00323	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  00326	52		 push	 edx
  00327	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@IPIEEFNB@?$FLMonster?5AI?5Automata?$FN?5?9?5Loading?5@
  0032c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00331	83 c4 08	 add	 esp, 8

; 189  : 	}

  00334	b8 00 00 00 00	 mov	 eax, $LN40@LoadData
  00339	c3		 ret	 0
$LN18@LoadData:

; 57   : 	{
; 58   : 		MsgBox("[Monster AI Automata] - File load error : File Name Error");

  0033a	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DFAHFBPK@?$FLMonster?5AI?5Automata?$FN?5?9?5File?5loa@
  0033f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00344	83 c4 04	 add	 esp, 4
$LN40@LoadData:

; 59   : 		return FALSE;

  00347	33 c0		 xor	 eax, eax

; 190  : 
; 191  : 	return FALSE;
; 192  : }

  00349	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0034c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00353	59		 pop	 ecx
  00354	5f		 pop	 edi
  00355	5e		 pop	 esi
  00356	5b		 pop	 ebx
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterAIAutomata@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterAIAutomata@@SAHPAD@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterAIAutomata@@SAHPAD@Z ENDP		; TMonsterAIAutomata::LoadData
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ
text$yc	SEGMENT
??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterAIAutomata::s_MonsterAIAutomataArray'', COMDAT

; 14   : TMonsterAIAutomata TMonsterAIAutomata::s_MonsterAIAutomataArray[MAX_MONSTER_AI_AUTOMATA];

  00000	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIAutomata@@UAE@XZ ; TMonsterAIAutomata::~TMonsterAIAutomata
  00005	68 00 00 00 00	 push	 OFFSET ??0TMonsterAIAutomata@@QAE@XZ ; TMonsterAIAutomata::TMonsterAIAutomata
  0000a	68 2c 01 00 00	 push	 300			; 0000012cH
  0000f	68 e8 7b 00 00	 push	 31720			; 00007be8H
  00014	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
  00019	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001e	68 00 00 00 00	 push	 OFFSET ??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ; `dynamic atexit destructor for 'TMonsterAIAutomata::s_MonsterAIAutomataArray''
  00023	e8 00 00 00 00	 call	 _atexit
  00028	59		 pop	 ecx
  00029	c3		 ret	 0
??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterAIAutomata::s_MonsterAIAutomataArray''
text$yc	ENDS
EXTRN	??0TMonsterAIUtil@@QAE@XZ:PROC			; TMonsterAIUtil::TMonsterAIUtil
; Function compile flags: /Ogtp
;	COMDAT ??__EMONSTER_UTIL@@YAXXZ
text$yc	SEGMENT
??__EMONSTER_UTIL@@YAXXZ PROC				; `dynamic initializer for 'MONSTER_UTIL'', COMDAT

; 15   : static TMonsterAIUtil MONSTER_UTIL;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00005	e8 00 00 00 00	 call	 ??0TMonsterAIUtil@@QAE@XZ ; TMonsterAIUtil::TMonsterAIUtil
  0000a	68 00 00 00 00	 push	 OFFSET ??__FMONSTER_UTIL@@YAXXZ ; `dynamic atexit destructor for 'MONSTER_UTIL''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EMONSTER_UTIL@@YAXXZ ENDP				; `dynamic initializer for 'MONSTER_UTIL''
text$yc	ENDS
EXTRN	??1TMonsterAIUtil@@UAE@XZ:PROC			; TMonsterAIUtil::~TMonsterAIUtil
; Function compile flags: /Ogtp
;	COMDAT ??__FMONSTER_UTIL@@YAXXZ
text$yd	SEGMENT
??__FMONSTER_UTIL@@YAXXZ PROC				; `dynamic atexit destructor for 'MONSTER_UTIL'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET _MONSTER_UTIL
  00005	e9 00 00 00 00	 jmp	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
??__FMONSTER_UTIL@@YAXXZ ENDP				; `dynamic atexit destructor for 'MONSTER_UTIL''
text$yd	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ
text$yd	SEGMENT
??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ PROC ; `dynamic atexit destructor for 'TMonsterAIAutomata::s_MonsterAIAutomataArray'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1TMonsterAIAutomata@@UAE@XZ ; TMonsterAIAutomata::~TMonsterAIAutomata
  00005	68 2c 01 00 00	 push	 300			; 0000012cH
  0000a	68 e8 7b 00 00	 push	 31720			; 00007be8H
  0000f	68 00 00 00 00	 push	 OFFSET ?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
  00014	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00019	c3		 ret	 0
??__F?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'TMonsterAIAutomata::s_MonsterAIAutomataArray''
text$yd	ENDS
PUBLIC	?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A ; TMonsterAIAutomata::s_MonsterAIAutomataArray
_BSS	SEGMENT
_MONSTER_UTIL DD 01H DUP (?)
?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A DB 09133e0H DUP (?) ; TMonsterAIAutomata::s_MonsterAIAutomataArray
_BSS	ENDS
CRT$XCU	SEGMENT
?s_MonsterAIAutomataArray$initializer$@TMonsterAIAutomata@@2P6AXXZA DD FLAT:??__E?s_MonsterAIAutomataArray@TMonsterAIAutomata@@2PAV1@A@@YAXXZ ; TMonsterAIAutomata::s_MonsterAIAutomataArray$initializer$
_MONSTER_UTIL$initializer$ DD FLAT:??__EMONSTER_UTIL@@YAXXZ
CRT$XCU	ENDS
END
