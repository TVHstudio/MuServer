; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\TMonsterAIRuleInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Reset@TMonsterAIRuleInfo@@QAEXXZ		; TMonsterAIRuleInfo::Reset
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterairuleinfo.cpp
;	COMDAT ?Reset@TMonsterAIRuleInfo@@QAEXXZ
_TEXT	SEGMENT
?Reset@TMonsterAIRuleInfo@@QAEXXZ PROC			; TMonsterAIRuleInfo::Reset, COMDAT
; _this$ = ecx

; 21   : 	this->m_iRuleNumber = -1;

  00000	83 c8 ff	 or	 eax, -1

; 22   : 	this->m_iMonsterClass = -1;
; 23   : 	this->m_iMonsterAIUnit = 0;
; 24   : 	this->m_iRuleCondition = -1;
; 25   : 	this->m_iWaitTime = -1;
; 26   : 	this->m_iContinuanceTime = -1;
; 27   : 	this->m_iMonth = -1;
; 28   : 	this->m_iDay = -1;
; 29   : 	this->m_iWeekDay = -1;
; 30   : 	this->m_iHour = -1;
; 31   : 	this->m_iMinute = -1;
; 32   : 	this->m_iAppliedTime = -1;
; 33   : 	this->m_iApplyingTime = -1;
; 34   : 	memset(this->m_szRuleDesc, 0, sizeof(this->m_szRuleDesc));

  00003	6a 64		 push	 100			; 00000064H
  00005	89 01		 mov	 DWORD PTR [ecx], eax
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00011	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00014	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00017	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0001a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0001d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00020	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00023	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00026	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  00029	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  0002c	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  0002f	83 c1 34	 add	 ecx, 52			; 00000034H
  00032	6a 00		 push	 0
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : }

  0003d	c3		 ret	 0
?Reset@TMonsterAIRuleInfo@@QAEXXZ ENDP			; TMonsterAIRuleInfo::Reset
_TEXT	ENDS
PUBLIC	?CheckConditionCrywolfStart@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::CheckConditionCrywolfStart
; Function compile flags: /Ogtp
;	COMDAT ?CheckConditionCrywolfStart@TMonsterAIRuleInfo@@QAEHXZ
_TEXT	SEGMENT
?CheckConditionCrywolfStart@TMonsterAIRuleInfo@@QAEHXZ PROC ; TMonsterAIRuleInfo::CheckConditionCrywolfStart, COMDAT
; _this$ = ecx

; 166  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 167  : }

  00002	c3		 ret	 0
?CheckConditionCrywolfStart@TMonsterAIRuleInfo@@QAEHXZ ENDP ; TMonsterAIRuleInfo::CheckConditionCrywolfStart
_TEXT	ENDS
PUBLIC	?CheckConditionCrywolfEnd@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::CheckConditionCrywolfEnd
; Function compile flags: /Ogtp
;	COMDAT ?CheckConditionCrywolfEnd@TMonsterAIRuleInfo@@QAEHXZ
_TEXT	SEGMENT
?CheckConditionCrywolfEnd@TMonsterAIRuleInfo@@QAEHXZ PROC ; TMonsterAIRuleInfo::CheckConditionCrywolfEnd, COMDAT
; _this$ = ecx

; 172  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 173  : }

  00002	c3		 ret	 0
?CheckConditionCrywolfEnd@TMonsterAIRuleInfo@@QAEHXZ ENDP ; TMonsterAIRuleInfo::CheckConditionCrywolfEnd
_TEXT	ENDS
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
EXTRN	?AfxThrowOleException@@YGXJ@Z:PROC		; AfxThrowOleException
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  0000b	75 05		 jne	 SHORT $LN2@AtlThrowIm

; 69   : 	{
; 70   : 		AfxThrowMemoryException();

  0000d	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$LN6@AtlThrowIm:
$LN2@AtlThrowIm:

; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$LN7@AtlThrowIm:
$LN5@AtlThrowIm:
  00018	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
PUBLIC	??0CTimeSpan@ATL@@QAE@JHHH@Z			; ATL::CTimeSpan::CTimeSpan
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\atltime.inl
;	COMDAT ??0CTimeSpan@ATL@@QAE@JHHH@Z
_TEXT	SEGMENT
_lDays$ = 8						; size = 4
_nHours$ = 12						; size = 4
_nMins$ = 16						; size = 4
_nSecs$ = 20						; size = 4
??0CTimeSpan@ATL@@QAE@JHHH@Z PROC			; ATL::CTimeSpan::CTimeSpan, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   :  	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));

  00003	8b 45 08	 mov	 eax, DWORD PTR _lDays$[ebp]
  00006	99		 cdq
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax
  0000a	57		 push	 edi
  0000b	8b fa		 mov	 edi, edx
  0000d	0f a4 c2 01	 shld	 edx, eax, 1
  00011	03 c0		 add	 eax, eax
  00013	03 f0		 add	 esi, eax
  00015	13 fa		 adc	 edi, edx
  00017	8b 45 0c	 mov	 eax, DWORD PTR _nHours$[ebp]
  0001a	0f a4 f7 03	 shld	 edi, esi, 3
  0001e	99		 cdq
  0001f	03 f6		 add	 esi, esi
  00021	03 f6		 add	 esi, esi
  00023	03 f6		 add	 esi, esi
  00025	03 f0		 add	 esi, eax
  00027	13 fa		 adc	 edi, edx
  00029	8b c6		 mov	 eax, esi
  0002b	8b d7		 mov	 edx, edi
  0002d	0f a4 c2 04	 shld	 edx, eax, 4
  00031	c1 e0 04	 shl	 eax, 4
  00034	2b c6		 sub	 eax, esi
  00036	1b d7		 sbb	 edx, edi
  00038	8b f0		 mov	 esi, eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR _nMins$[ebp]
  0003d	8b fa		 mov	 edi, edx
  0003f	0f a4 f7 02	 shld	 edi, esi, 2
  00043	99		 cdq
  00044	03 f6		 add	 esi, esi
  00046	03 f6		 add	 esi, esi
  00048	03 f0		 add	 esi, eax
  0004a	13 fa		 adc	 edi, edx
  0004c	8b c6		 mov	 eax, esi
  0004e	8b d7		 mov	 edx, edi
  00050	0f a4 c2 04	 shld	 edx, eax, 4
  00054	c1 e0 04	 shl	 eax, 4
  00057	2b c6		 sub	 eax, esi
  00059	1b d7		 sbb	 edx, edi
  0005b	0f a4 c2 02	 shld	 edx, eax, 2
  0005f	03 c0		 add	 eax, eax
  00061	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  00064	8b 45 14	 mov	 eax, DWORD PTR _nSecs$[ebp]
  00067	8b fa		 mov	 edi, edx
  00069	99		 cdq
  0006a	03 f0		 add	 esi, eax
  0006c	13 fa		 adc	 edi, edx
  0006e	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00071	5f		 pop	 edi
  00072	89 31		 mov	 DWORD PTR [ecx], esi

; 43   : }

  00074	8b c1		 mov	 eax, ecx
  00076	5e		 pop	 esi
  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
??0CTimeSpan@ATL@@QAE@JHHH@Z ENDP			; ATL::CTimeSpan::CTimeSpan
_TEXT	ENDS
PUBLIC	?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ		; ATL::CTimeSpan::GetTimeSpan
; Function compile flags: /Ogtp
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ PROC		; ATL::CTimeSpan::GetTimeSpan, COMDAT
; _this$ = ecx

; 82   : 	return( m_timeSpan );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 83   : }

  00005	c3		 ret	 0
?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ ENDP		; ATL::CTimeSpan::GetTimeSpan
_TEXT	ENDS
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
; Function compile flags: /Ogtp
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC				; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp+4]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _time$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 172  : }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	??0CTime@ATL@@QAE@HHHHHHH@Z			; ATL::CTime::CTime
EXTRN	__mktime64:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT
_atm$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_nYear$ = 8						; size = 4
_nMonth$ = 12						; size = 4
_nDay$ = 16						; size = 4
_nHour$ = 20						; size = 4
_nMin$ = 24						; size = 4
_nSec$ = 28						; size = 4
_nDST$ = 32						; size = 4
??0CTime@ATL@@QAE@HHHHHHH@Z PROC			; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 183  : #pragma warning (push)
; 184  : #pragma warning (disable: 4127)  // conditional expression constant
; 185  : 
; 186  : 	ATLENSURE( nYear >= 1900 );

  00010	8b 55 08	 mov	 edx, DWORD PTR _nYear$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	81 fa 6c 07 00
	00		 cmp	 edx, 1900		; 0000076cH
  0001c	7d 0a		 jge	 SHORT $LN66@CTime
  0001e	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00023	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN86@CTime:
$LN66@CTime:

; 187  : 	ATLENSURE( nMonth >= 1 && nMonth <= 12 );

  00028	8b 45 0c	 mov	 eax, DWORD PTR _nMonth$[ebp]
  0002b	48		 dec	 eax
  0002c	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0002f	76 0a		 jbe	 SHORT $LN56@CTime
  00031	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00036	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN87@CTime:
$LN56@CTime:
  0003b	53		 push	 ebx

; 188  : 	ATLENSURE( nDay >= 1 && nDay <= 31 );

  0003c	8b 5d 10	 mov	 ebx, DWORD PTR _nDay$[ebp]
  0003f	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00042	57		 push	 edi
  00043	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00046	76 0a		 jbe	 SHORT $LN46@CTime
  00048	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0004d	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN88@CTime:
$LN46@CTime:

; 189  : 	ATLENSURE( nHour >= 0 && nHour <= 23 );

  00052	8b 7d 14	 mov	 edi, DWORD PTR _nHour$[ebp]
  00055	83 ff 17	 cmp	 edi, 23			; 00000017H
  00058	76 0a		 jbe	 SHORT $LN36@CTime
  0005a	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0005f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN89@CTime:
$LN36@CTime:

; 190  : 	ATLENSURE( nMin >= 0 && nMin <= 59 );

  00064	8b 4d 18	 mov	 ecx, DWORD PTR _nMin$[ebp]
  00067	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  0006a	76 0a		 jbe	 SHORT $LN26@CTime
  0006c	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00071	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN90@CTime:
$LN26@CTime:

; 191  : 	ATLENSURE( nSec >= 0 && nSec <= 59 );

  00076	8b 45 1c	 mov	 eax, DWORD PTR _nSec$[ebp]
  00079	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0007c	76 0a		 jbe	 SHORT $LN16@CTime
  0007e	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00083	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN91@CTime:
$LN16@CTime:

; 192  : 
; 193  : #pragma warning (pop)
; 194  : 
; 195  : 	struct tm atm;
; 196  : 
; 197  : 	atm.tm_sec = nSec;
; 198  : 	atm.tm_min = nMin;
; 199  : 	atm.tm_hour = nHour;
; 200  : 	atm.tm_mday = nDay;
; 201  : 	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
; 202  : 	atm.tm_year = nYear - 1900;     // tm_year is 1900 based

  00088	81 c2 94 f8 ff
	ff		 add	 edx, -1900		; fffff894H
  0008e	89 45 d8	 mov	 DWORD PTR _atm$[ebp], eax
  00091	8b 45 0c	 mov	 eax, DWORD PTR _nMonth$[ebp]
  00094	89 55 ec	 mov	 DWORD PTR _atm$[ebp+20], edx
  00097	89 4d dc	 mov	 DWORD PTR _atm$[ebp+4], ecx

; 203  : 	atm.tm_isdst = nDST;

  0009a	8b 4d 20	 mov	 ecx, DWORD PTR _nDST$[ebp]

; 204  : 
; 205  : 	m_time = _mktime64(&atm);

  0009d	8d 55 d8	 lea	 edx, DWORD PTR _atm$[ebp]
  000a0	48		 dec	 eax
  000a1	52		 push	 edx
  000a2	89 7d e0	 mov	 DWORD PTR _atm$[ebp+8], edi
  000a5	89 5d e4	 mov	 DWORD PTR _atm$[ebp+12], ebx
  000a8	89 45 e8	 mov	 DWORD PTR _atm$[ebp+16], eax
  000ab	89 4d f8	 mov	 DWORD PTR _atm$[ebp+32], ecx
  000ae	e8 00 00 00 00	 call	 __mktime64
  000b3	83 c4 04	 add	 esp, 4
  000b6	89 06		 mov	 DWORD PTR [esi], eax

; 206  : 	ATLASSUME(m_time != -1);       // indicates an illegal input time
; 207  : 	if(m_time == -1)

  000b8	23 c2		 and	 eax, edx
  000ba	5f		 pop	 edi
  000bb	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000be	5b		 pop	 ebx
  000bf	83 f8 ff	 cmp	 eax, -1
  000c2	75 0a		 jne	 SHORT $LN1@CTime

; 208  : 	{
; 209  : 		AtlThrow(E_INVALIDARG);

  000c4	68 57 00 07 80	 push	 -2147024809		; 80070057H
  000c9	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN92@CTime:
$LN1@CTime:

; 210  : 	}
; 211  : }

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d1	8b c6		 mov	 eax, esi
  000d3	33 cd		 xor	 ecx, ebp
  000d5	5e		 pop	 esi
  000d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 1c 00	 ret	 28			; 0000001cH
$LN85@CTime:
??0CTime@ATL@@QAE@HHHHHHH@Z ENDP			; ATL::CTime::CTime
_TEXT	ENDS
PUBLIC	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z		; ATL::CTime::operator+
; Function compile flags: /Ogtp
;	COMDAT ??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_span$ = 12						; size = 8
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z PROC		; ATL::CTime::operator+, COMDAT
; _this$ = ecx

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 315  : 	return( CTime( m_time+span.GetTimeSpan() ) );

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	03 55 0c	 add	 edx, DWORD PTR _span$[ebp]
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	13 4d 10	 adc	 ecx, DWORD PTR _span$[ebp+4]
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00011	89 10		 mov	 DWORD PTR [eax], edx
  00013	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 316  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z ENDP		; ATL::CTime::operator+
_TEXT	ENDS
PUBLIC	??MCTime@ATL@@QBE_NV01@@Z			; ATL::CTime::operator<
; Function compile flags: /Ogtp
;	COMDAT ??MCTime@ATL@@QBE_NV01@@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??MCTime@ATL@@QBE_NV01@@Z PROC				; ATL::CTime::operator<, COMDAT
; _this$ = ecx

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return( m_time < time.m_time );

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR _time$[ebp+4]
  00009	7f 12		 jg	 SHORT $LN3@operator
  0000b	7c 07		 jl	 SHORT $LN5@operator
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _time$[ebp]
  00012	73 09		 jae	 SHORT $LN3@operator
$LN5@operator:
  00014	b8 01 00 00 00	 mov	 eax, 1

; 331  : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN3@operator:

; 330  : 	return( m_time < time.m_time );

  0001d	33 c0		 xor	 eax, eax

; 331  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??MCTime@ATL@@QBE_NV01@@Z ENDP				; ATL::CTime::operator<
_TEXT	ENDS
PUBLIC	??OCTime@ATL@@QBE_NV01@@Z			; ATL::CTime::operator>
; Function compile flags: /Ogtp
;	COMDAT ??OCTime@ATL@@QBE_NV01@@Z
_TEXT	SEGMENT
_time$ = 8						; size = 8
??OCTime@ATL@@QBE_NV01@@Z PROC				; ATL::CTime::operator>, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 	return( m_time > time.m_time );

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR _time$[ebp+4]
  00009	7c 12		 jl	 SHORT $LN3@operator@2
  0000b	7f 07		 jg	 SHORT $LN5@operator@2
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _time$[ebp]
  00012	76 09		 jbe	 SHORT $LN3@operator@2
$LN5@operator@2:
  00014	b8 01 00 00 00	 mov	 eax, 1

; 336  : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN3@operator@2:

; 335  : 	return( m_time > time.m_time );

  0001d	33 c0		 xor	 eax, eax

; 336  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??OCTime@ATL@@QBE_NV01@@Z ENDP				; ATL::CTime::operator>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z	; ATL::CTime::GetLocalTm
EXTRN	__localtime64_s:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z
_TEXT	SEGMENT
_ptmTemp$86878 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_ptm$ = 8						; size = 4
?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z PROC		; ATL::CTime::GetLocalTm, COMDAT
; _this$ = ecx

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _ptm$[ebp]

; 370  : 	// Ensure ptm is valid
; 371  : 	ATLENSURE( ptm != NULL );

  00014	85 db		 test	 ebx, ebx
  00016	75 0a		 jne	 SHORT $LN15@GetLocalTm
  00018	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0001d	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN17@GetLocalTm:
$LN15@GetLocalTm:

; 372  : 
; 373  : 	if (ptm != NULL)
; 374  : 	{
; 375  : 		struct tm ptmTemp;
; 376  : 		errno_t err = _localtime64_s(&ptmTemp, &m_time);

  00022	51		 push	 ecx
  00023	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$86878[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __localtime64_s
  0002c	83 c4 08	 add	 esp, 8

; 377  : 
; 378  : 		if (err != 0)

  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN1@GetLocalTm

; 379  : 		{
; 380  : 			return NULL;    // indicates that m_time was not initialized!

  00033	33 c0		 xor	 eax, eax
  00035	5b		 pop	 ebx

; 384  : 		return ptm;
; 385  : 	}
; 386  : 
; 387  : 	return NULL;
; 388  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
$LN1@GetLocalTm:
  00046	56		 push	 esi
  00047	57		 push	 edi

; 381  : 		}
; 382  : 
; 383  : 		*ptm = ptmTemp;

  00048	8b fb		 mov	 edi, ebx
  0004a	b9 09 00 00 00	 mov	 ecx, 9
  0004f	8d 75 d8	 lea	 esi, DWORD PTR _ptmTemp$86878[ebp]
  00052	f3 a5		 rep movsd

; 384  : 		return ptm;
; 385  : 	}
; 386  : 
; 387  : 	return NULL;
; 388  : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	8b c3		 mov	 eax, ebx
  0005b	33 cd		 xor	 ecx, ebp
  0005d	5b		 pop	 ebx
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
$LN16@GetLocalTm:
?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z ENDP		; ATL::CTime::GetLocalTm
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetYear@CTime@ATL@@QBEHXZ			; ATL::CTime::GetYear
; Function compile flags: /Ogtp
;	COMDAT ?GetYear@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
_ptmTemp$187750 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?GetYear@CTime@ATL@@QBEHXZ PROC				; ATL::CTime::GetYear, COMDAT
; _this$ = ecx

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 420  : 	struct tm ttm;
; 421  : 	struct tm * ptm;
; 422  : 
; 423  : 	ptm = GetLocalTm(&ttm);

  00010	51		 push	 ecx
  00011	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$187750[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __localtime64_s
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 16		 jne	 SHORT $LN3@GetYear

; 424  : 	return ptm ? (ptm->tm_year) + 1900 : 0 ;

  00021	8b 45 ec	 mov	 eax, DWORD PTR _ptmTemp$187750[ebp+20]
  00024	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH

; 425  : }

  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN3@GetYear:
  00037	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003a	33 cd		 xor	 ecx, ebp
  0003c	33 c0		 xor	 eax, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GetYear@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetYear
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetMonth@CTime@ATL@@QBEHXZ			; ATL::CTime::GetMonth
; Function compile flags: /Ogtp
;	COMDAT ?GetMonth@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
_ptmTemp$187778 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?GetMonth@CTime@ATL@@QBEHXZ PROC			; ATL::CTime::GetMonth, COMDAT
; _this$ = ecx

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 429  : 	struct tm ttm;
; 430  : 	struct tm * ptm;
; 431  : 
; 432  : 	ptm = GetLocalTm(&ttm);

  00010	51		 push	 ecx
  00011	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$187778[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __localtime64_s
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 12		 jne	 SHORT $LN3@GetMonth

; 433  : 	return ptm ? ptm->tm_mon + 1 : 0;

  00021	8b 45 e8	 mov	 eax, DWORD PTR _ptmTemp$187778[ebp+16]
  00024	40		 inc	 eax

; 434  : }

  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN3@GetMonth:
  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	33 c0		 xor	 eax, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GetMonth@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetMonth
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetDay@CTime@ATL@@QBEHXZ			; ATL::CTime::GetDay
; Function compile flags: /Ogtp
;	COMDAT ?GetDay@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
_ptmTemp$187806 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?GetDay@CTime@ATL@@QBEHXZ PROC				; ATL::CTime::GetDay, COMDAT
; _this$ = ecx

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 438  : 	struct tm ttm;
; 439  : 	struct tm * ptm;
; 440  : 
; 441  : 	ptm = GetLocalTm(&ttm);

  00010	51		 push	 ecx
  00011	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$187806[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __localtime64_s

; 442  : 	return ptm ? ptm->tm_mday : 0 ;
; 443  : }

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0001d	83 c4 08	 add	 esp, 8
  00020	f7 d8		 neg	 eax
  00022	1b c0		 sbb	 eax, eax
  00024	f7 d0		 not	 eax
  00026	23 45 e4	 and	 eax, DWORD PTR _ptmTemp$187806[ebp+12]
  00029	33 cd		 xor	 ecx, ebp
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GetDay@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetDay
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetHour@CTime@ATL@@QBEHXZ			; ATL::CTime::GetHour
; Function compile flags: /Ogtp
;	COMDAT ?GetHour@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
_ptmTemp$187834 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?GetHour@CTime@ATL@@QBEHXZ PROC				; ATL::CTime::GetHour, COMDAT
; _this$ = ecx

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 447  : 	struct tm ttm;
; 448  : 	struct tm * ptm;
; 449  : 
; 450  : 	ptm = GetLocalTm(&ttm);

  00010	51		 push	 ecx
  00011	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$187834[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __localtime64_s
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 11		 jne	 SHORT $LN3@GetHour

; 451  : 	return ptm ? ptm->tm_hour : -1 ;

  00021	8b 45 e0	 mov	 eax, DWORD PTR _ptmTemp$187834[ebp+8]

; 452  : }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00027	33 cd		 xor	 ecx, ebp
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN3@GetHour:
  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	83 c8 ff	 or	 eax, -1
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GetHour@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetHour
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetMinute@CTime@ATL@@QBEHXZ			; ATL::CTime::GetMinute
; Function compile flags: /Ogtp
;	COMDAT ?GetMinute@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
_ptmTemp$187862 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?GetMinute@CTime@ATL@@QBEHXZ PROC			; ATL::CTime::GetMinute, COMDAT
; _this$ = ecx

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 456  : 	struct tm ttm;
; 457  : 	struct tm * ptm;
; 458  : 
; 459  : 	ptm = GetLocalTm(&ttm);

  00010	51		 push	 ecx
  00011	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$187862[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __localtime64_s
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 11		 jne	 SHORT $LN3@GetMinute

; 460  : 	return ptm ? ptm->tm_min : -1 ;

  00021	8b 45 dc	 mov	 eax, DWORD PTR _ptmTemp$187862[ebp+4]

; 461  : }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00027	33 cd		 xor	 ecx, ebp
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN3@GetMinute:
  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	83 c8 ff	 or	 eax, -1
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GetMinute@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetMinute
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetDayOfWeek@CTime@ATL@@QBEHXZ			; ATL::CTime::GetDayOfWeek
; Function compile flags: /Ogtp
;	COMDAT ?GetDayOfWeek@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
_ptmTemp$187890 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?GetDayOfWeek@CTime@ATL@@QBEHXZ PROC			; ATL::CTime::GetDayOfWeek, COMDAT
; _this$ = ecx

; 473  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 474  : 	struct tm ttm;
; 475  : 	struct tm * ptm;
; 476  : 
; 477  : 	ptm = GetLocalTm(&ttm);

  00010	51		 push	 ecx
  00011	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$187890[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __localtime64_s
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 12		 jne	 SHORT $LN3@GetDayOfWe

; 478  : 	return ptm ? ptm->tm_wday + 1 : 0 ;

  00021	8b 45 f0	 mov	 eax, DWORD PTR _ptmTemp$187890[ebp+24]
  00024	40		 inc	 eax

; 479  : }

  00025	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00028	33 cd		 xor	 ecx, ebp
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN3@GetDayOfWe:
  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	33 c0		 xor	 eax, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GetDayOfWeek@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetDayOfWeek
_TEXT	ENDS
PUBLIC	??0TMonsterAIRuleInfo@@QAE@XZ			; TMonsterAIRuleInfo::TMonsterAIRuleInfo
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterairuleinfo.cpp
;	COMDAT ??0TMonsterAIRuleInfo@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterAIRuleInfo@@QAE@XZ PROC			; TMonsterAIRuleInfo::TMonsterAIRuleInfo, COMDAT
; _this$ = ecx

; 14   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 15   : 	this->Reset();

  00003	e8 00 00 00 00	 call	 ?Reset@TMonsterAIRuleInfo@@QAEXXZ ; TMonsterAIRuleInfo::Reset

; 16   : }

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0TMonsterAIRuleInfo@@QAE@XZ ENDP			; TMonsterAIRuleInfo::TMonsterAIRuleInfo
_TEXT	ENDS
PUBLIC	?GetTickCount@CTime@ATL@@SG?AV12@XZ		; ATL::CTime::GetTickCount
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\atltime.inl
;	COMDAT ?GetTickCount@CTime@ATL@@SG?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ PROC		; ATL::CTime::GetTickCount, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  : 	return( CTime( ::_time64( NULL ) ) );

  00003	6a 00		 push	 0
  00005	e8 00 00 00 00	 call	 __time64
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	89 01		 mov	 DWORD PTR [ecx], eax
  0000f	83 c4 04	 add	 esp, 4
  00012	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00015	8b c1		 mov	 eax, ecx

; 144  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?GetTickCount@CTime@ATL@@SG?AV12@XZ ENDP		; ATL::CTime::GetTickCount
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CheckConditionSpecificDate@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::CheckConditionSpecificDate
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterairuleinfo.cpp
;	COMDAT ?CheckConditionSpecificDate@TMonsterAIRuleInfo@@QAEHXZ
_TEXT	SEGMENT
_iDayOfWeek$ = -84					; size = 4
_tConditionTime$187611 = -80				; size = 8
_iMinute$ = -76						; size = 4
_iDay$ = -72						; size = 4
_tValidRange$ = -68					; size = 8
_iHour$ = -60						; size = 4
_iYear$ = -56						; size = 4
_iMonth$ = -52						; size = 4
_tCurrentTime$ = -48					; size = 8
_atm$188585 = -40					; size = 36
_atm$188444 = -40					; size = 36
_ptmTemp$188231 = -40					; size = 36
_ptmTemp$188181 = -40					; size = 36
_ptmTemp$188131 = -40					; size = 36
_ptmTemp$188081 = -40					; size = 36
_ptmTemp$188031 = -40					; size = 36
_ptmTemp$187980 = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?CheckConditionSpecificDate@TMonsterAIRuleInfo@@QAEHXZ PROC ; TMonsterAIRuleInfo::CheckConditionSpecificDate, COMDAT
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 82   : 	CTime tCurrentTime = CTime::GetTickCount();

  00013	33 ff		 xor	 edi, edi
  00015	57		 push	 edi
  00016	8b d9		 mov	 ebx, ecx
  00018	e8 00 00 00 00	 call	 __time64
  0001d	89 45 d0	 mov	 DWORD PTR _tCurrentTime$[ebp], eax

; 83   : 	CTimeSpan tValidRange(0, 0, 0, this->m_iWaitTime+this->m_iContinuanceTime);

  00020	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00023	03 43 10	 add	 eax, DWORD PTR [ebx+16]
  00026	89 55 d4	 mov	 DWORD PTR _tCurrentTime$[ebp+4], edx
  00029	99		 cdq
  0002a	89 45 bc	 mov	 DWORD PTR _tValidRange$[ebp], eax

; 84   : 
; 85   : 	int iYear = tCurrentTime.GetYear();

  0002d	8d 45 d0	 lea	 eax, DWORD PTR _tCurrentTime$[ebp]
  00030	50		 push	 eax
  00031	8d 4d d8	 lea	 ecx, DWORD PTR _ptmTemp$187980[ebp]
  00034	51		 push	 ecx
  00035	89 55 c0	 mov	 DWORD PTR _tValidRange$[ebp+4], edx
  00038	e8 00 00 00 00	 call	 __localtime64_s
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	85 c0		 test	 eax, eax
  00042	75 0e		 jne	 SHORT $LN41@CheckCondi
  00044	8b 75 ec	 mov	 esi, DWORD PTR _ptmTemp$187980[ebp+20]
  00047	81 c6 6c 07 00
	00		 add	 esi, 1900		; 0000076cH
  0004d	89 75 c8	 mov	 DWORD PTR _iYear$[ebp], esi
  00050	eb 05		 jmp	 SHORT $LN42@CheckCondi
$LN41@CheckCondi:
  00052	89 7d c8	 mov	 DWORD PTR _iYear$[ebp], edi
  00055	8b f7		 mov	 esi, edi
$LN42@CheckCondi:

; 86   : 	int iMonth = tCurrentTime.GetMonth();

  00057	8d 55 d0	 lea	 edx, DWORD PTR _tCurrentTime$[ebp]
  0005a	52		 push	 edx
  0005b	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$188031[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 __localtime64_s
  00064	83 c4 08	 add	 esp, 8
  00067	85 c0		 test	 eax, eax
  00069	75 09		 jne	 SHORT $LN61@CheckCondi
  0006b	8b 4d e8	 mov	 ecx, DWORD PTR _ptmTemp$188031[ebp+16]
  0006e	41		 inc	 ecx
  0006f	89 4d cc	 mov	 DWORD PTR _iMonth$[ebp], ecx
  00072	eb 03		 jmp	 SHORT $LN62@CheckCondi
$LN61@CheckCondi:
  00074	89 7d cc	 mov	 DWORD PTR _iMonth$[ebp], edi
$LN62@CheckCondi:

; 87   : 	int iDay = tCurrentTime.GetDay();

  00077	8d 55 d0	 lea	 edx, DWORD PTR _tCurrentTime$[ebp]
  0007a	52		 push	 edx
  0007b	8d 45 d8	 lea	 eax, DWORD PTR _ptmTemp$188081[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 __localtime64_s
  00084	f7 d8		 neg	 eax
  00086	1b ff		 sbb	 edi, edi

; 88   : 	int iDayOfWeek = tCurrentTime.GetDayOfWeek();

  00088	8d 4d d0	 lea	 ecx, DWORD PTR _tCurrentTime$[ebp]
  0008b	f7 d7		 not	 edi
  0008d	23 7d e4	 and	 edi, DWORD PTR _ptmTemp$188081[ebp+12]
  00090	51		 push	 ecx
  00091	8d 55 d8	 lea	 edx, DWORD PTR _ptmTemp$188131[ebp]
  00094	52		 push	 edx
  00095	89 7d b8	 mov	 DWORD PTR _iDay$[ebp], edi
  00098	e8 00 00 00 00	 call	 __localtime64_s
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	85 c0		 test	 eax, eax
  000a2	75 09		 jne	 SHORT $LN99@CheckCondi
  000a4	8b 45 f0	 mov	 eax, DWORD PTR _ptmTemp$188131[ebp+24]
  000a7	40		 inc	 eax
  000a8	89 45 ac	 mov	 DWORD PTR _iDayOfWeek$[ebp], eax
  000ab	eb 07		 jmp	 SHORT $LN100@CheckCondi
$LN99@CheckCondi:
  000ad	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _iDayOfWeek$[ebp], 0
$LN100@CheckCondi:

; 89   : 	int iHour = tCurrentTime.GetHour();

  000b4	8d 4d d0	 lea	 ecx, DWORD PTR _tCurrentTime$[ebp]
  000b7	51		 push	 ecx
  000b8	8d 55 d8	 lea	 edx, DWORD PTR _ptmTemp$188181[ebp]
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 __localtime64_s
  000c1	83 c4 08	 add	 esp, 8
  000c4	85 c0		 test	 eax, eax
  000c6	75 08		 jne	 SHORT $LN118@CheckCondi
  000c8	8b 45 e0	 mov	 eax, DWORD PTR _ptmTemp$188181[ebp+8]
  000cb	89 45 c4	 mov	 DWORD PTR _iHour$[ebp], eax
  000ce	eb 07		 jmp	 SHORT $LN119@CheckCondi
$LN118@CheckCondi:
  000d0	c7 45 c4 ff ff
	ff ff		 mov	 DWORD PTR _iHour$[ebp], -1
$LN119@CheckCondi:

; 90   : 	int iMinute = tCurrentTime.GetMinute();

  000d7	8d 4d d0	 lea	 ecx, DWORD PTR _tCurrentTime$[ebp]
  000da	51		 push	 ecx
  000db	8d 55 d8	 lea	 edx, DWORD PTR _ptmTemp$188231[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 __localtime64_s
  000e4	83 c4 08	 add	 esp, 8
  000e7	85 c0		 test	 eax, eax
  000e9	75 08		 jne	 SHORT $LN137@CheckCondi
  000eb	8b 45 dc	 mov	 eax, DWORD PTR _ptmTemp$188231[ebp+4]
  000ee	89 45 b4	 mov	 DWORD PTR _iMinute$[ebp], eax
  000f1	eb 07		 jmp	 SHORT $LN138@CheckCondi
$LN137@CheckCondi:
  000f3	c7 45 b4 ff ff
	ff ff		 mov	 DWORD PTR _iMinute$[ebp], -1
$LN138@CheckCondi:

; 91   : 
; 92   : 	if ( this->m_iMonth != -1 )

  000fa	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  000fd	83 f9 ff	 cmp	 ecx, -1
  00100	74 22		 je	 SHORT $LN470@CheckCondi

; 93   : 	{
; 94   : 		if ( this->m_iMonth != iMonth )

  00102	3b 4d cc	 cmp	 ecx, DWORD PTR _iMonth$[ebp]
  00105	74 1d		 je	 SHORT $LN470@CheckCondi

; 95   : 		{
; 96   : 			CTime tConditionTime(iYear, this->m_iMonth, 0, 0, 0, 0, -1) ;

  00107	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0010c	81 fe 6c 07 00
	00		 cmp	 esi, 1900		; 0000076cH
  00112	7d 05		 jge	 SHORT $LN219@CheckCondi
$LN209@CheckCondi:
  00114	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN473@CheckCondi:
$LN219@CheckCondi:
  00119	49		 dec	 ecx
  0011a	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0011d	76 f5		 jbe	 SHORT $LN209@CheckCondi
  0011f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN474@CheckCondi:
$LN470@CheckCondi:

; 97   : 
; 98   : 			if ( tCurrentTime < tConditionTime  ||
; 99   : 				 tCurrentTime > tConditionTime+tValidRange )
; 100  : 			{
; 101  : 				return FALSE;
; 102  : 			}
; 103  : 		}
; 104  : 	}
; 105  : 
; 106  : 	if ( this->m_iDay != -1 )

  00124	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00127	83 f8 ff	 cmp	 eax, -1
  0012a	0f 84 bd 00 00
	00		 je	 $LN12@CheckCondi

; 107  : 	{
; 108  : 		if ( this->m_iDay != iDay )

  00130	3b c7		 cmp	 eax, edi
  00132	0f 84 b5 00 00
	00		 je	 $LN12@CheckCondi

; 109  : 		{
; 110  : 			CTime tConditionTime(iYear, (this->m_iMonth == -1)?iMonth : this->m_iMonth , this->m_iDay, 0, 0, 0, -1);

  00138	83 f9 ff	 cmp	 ecx, -1
  0013b	75 03		 jne	 SHORT $LN21@CheckCondi
  0013d	8b 4d cc	 mov	 ecx, DWORD PTR _iMonth$[ebp]
$LN21@CheckCondi:
  00140	81 fe 6c 07 00
	00		 cmp	 esi, 1900		; 0000076cH
  00146	7d 0a		 jge	 SHORT $LN312@CheckCondi
  00148	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0014d	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN475@CheckCondi:
$LN312@CheckCondi:
  00152	49		 dec	 ecx
  00153	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00156	76 0a		 jbe	 SHORT $LN302@CheckCondi
  00158	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0015d	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN476@CheckCondi:
$LN302@CheckCondi:
  00162	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00165	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  00168	76 0a		 jbe	 SHORT $LN292@CheckCondi
  0016a	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0016f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN477@CheckCondi:
$LN292@CheckCondi:
  00174	33 d2		 xor	 edx, edx
  00176	89 45 e4	 mov	 DWORD PTR _atm$188444[ebp+12], eax
  00179	8d 45 d8	 lea	 eax, DWORD PTR _atm$188444[ebp]
  0017c	81 c6 94 f8 ff
	ff		 add	 esi, -1900		; fffff894H
  00182	50		 push	 eax
  00183	89 55 d8	 mov	 DWORD PTR _atm$188444[ebp], edx
  00186	89 55 dc	 mov	 DWORD PTR _atm$188444[ebp+4], edx
  00189	89 55 e0	 mov	 DWORD PTR _atm$188444[ebp+8], edx
  0018c	89 4d e8	 mov	 DWORD PTR _atm$188444[ebp+16], ecx
  0018f	89 75 ec	 mov	 DWORD PTR _atm$188444[ebp+20], esi
  00192	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _atm$188444[ebp+32], -1
  00199	e8 00 00 00 00	 call	 __mktime64
  0019e	8b c8		 mov	 ecx, eax
  001a0	23 ca		 and	 ecx, edx
  001a2	83 c4 04	 add	 esp, 4
  001a5	83 f9 ff	 cmp	 ecx, -1
  001a8	75 0a		 jne	 SHORT $LN247@CheckCondi
  001aa	68 57 00 07 80	 push	 -2147024809		; 80070057H
  001af	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN478@CheckCondi:
$LN247@CheckCondi:

; 111  : 
; 112  : 			if ( tCurrentTime < tConditionTime  ||
; 113  : 				 tCurrentTime > tConditionTime+tValidRange )

  001b4	8b 4d d4	 mov	 ecx, DWORD PTR _tCurrentTime$[ebp+4]
  001b7	3b ca		 cmp	 ecx, edx
  001b9	7c 19		 jl	 SHORT $LN463@CheckCondi
  001bb	8b 7d d0	 mov	 edi, DWORD PTR _tCurrentTime$[ebp]
  001be	7f 04		 jg	 SHORT $LN462@CheckCondi
  001c0	3b f8		 cmp	 edi, eax
  001c2	72 10		 jb	 SHORT $LN463@CheckCondi
$LN462@CheckCondi:
  001c4	03 45 bc	 add	 eax, DWORD PTR _tValidRange$[ebp]
  001c7	13 55 c0	 adc	 edx, DWORD PTR _tValidRange$[ebp+4]
  001ca	3b ca		 cmp	 ecx, edx
  001cc	7c 19		 jl	 SHORT $LN468@CheckCondi
  001ce	7f 04		 jg	 SHORT $LN463@CheckCondi
  001d0	3b f8		 cmp	 edi, eax
  001d2	76 13		 jbe	 SHORT $LN468@CheckCondi
$LN463@CheckCondi:
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi

; 114  : 			{
; 115  : 				return FALSE;

  001d6	33 c0		 xor	 eax, eax
  001d8	5b		 pop	 ebx

; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 
; 160  : 	return TRUE;
; 161  : }	

  001d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001dc	33 cd		 xor	 ecx, ebp
  001de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
$LN468@CheckCondi:

; 111  : 
; 112  : 			if ( tCurrentTime < tConditionTime  ||
; 113  : 				 tCurrentTime > tConditionTime+tValidRange )

  001e7	8b 7d b8	 mov	 edi, DWORD PTR _iDay$[ebp]
  001ea	8b 75 c8	 mov	 esi, DWORD PTR _iYear$[ebp]
$LN12@CheckCondi:

; 116  : 			}
; 117  : 		}
; 118  : 	}
; 119  : 
; 120  : 	if ( this->m_iWeekDay != -1 )

  001ed	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  001f0	83 f8 ff	 cmp	 eax, -1
  001f3	74 05		 je	 SHORT $LN9@CheckCondi

; 121  : 	{
; 122  : 		if ( this->m_iWeekDay != iDayOfWeek )

  001f5	3b 45 ac	 cmp	 eax, DWORD PTR _iDayOfWeek$[ebp]

; 123  : 		{
; 124  : 			return FALSE;

  001f8	75 da		 jne	 SHORT $LN463@CheckCondi
$LN9@CheckCondi:

; 125  : 		}
; 126  : 	}
; 127  : 
; 128  : 	if ( this->m_iHour != -1 )

  001fa	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  001fd	83 fa ff	 cmp	 edx, -1
  00200	0f 84 d6 00 00
	00		 je	 $LN471@CheckCondi

; 129  : 	{
; 130  : 		if ( this->m_iHour != iHour )

  00206	3b 55 c4	 cmp	 edx, DWORD PTR _iHour$[ebp]
  00209	0f 84 cd 00 00
	00		 je	 $LN471@CheckCondi

; 131  : 		{
; 132  : 			CTime tConditionTime(iYear, (this->m_iMonth == -1)?iMonth : this->m_iMonth,
; 133  : 				(this->m_iDay == -1)?iDay : this->m_iDay, this->m_iHour, 0, 0, -1) ;

  0020f	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00212	8b cf		 mov	 ecx, edi
  00214	83 f8 ff	 cmp	 eax, -1
  00217	74 02		 je	 SHORT $LN24@CheckCondi
  00219	8b c8		 mov	 ecx, eax
$LN24@CheckCondi:
  0021b	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0021e	83 f8 ff	 cmp	 eax, -1
  00221	75 03		 jne	 SHORT $LN25@CheckCondi
  00223	8b 45 cc	 mov	 eax, DWORD PTR _iMonth$[ebp]
$LN25@CheckCondi:
  00226	81 fe 6c 07 00
	00		 cmp	 esi, 1900		; 0000076cH
  0022c	7d 0a		 jge	 SHORT $LN405@CheckCondi
  0022e	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00233	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN479@CheckCondi:
$LN405@CheckCondi:
  00238	48		 dec	 eax
  00239	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0023c	76 0a		 jbe	 SHORT $LN395@CheckCondi
  0023e	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00243	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN480@CheckCondi:
$LN395@CheckCondi:
  00248	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0024b	83 ff 1e	 cmp	 edi, 30			; 0000001eH
  0024e	76 0a		 jbe	 SHORT $LN385@CheckCondi
  00250	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00255	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN481@CheckCondi:
$LN385@CheckCondi:
  0025a	83 fa 17	 cmp	 edx, 23			; 00000017H
  0025d	76 0a		 jbe	 SHORT $LN375@CheckCondi
  0025f	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00264	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN482@CheckCondi:
$LN375@CheckCondi:
  00269	89 55 e0	 mov	 DWORD PTR _atm$188585[ebp+8], edx
  0026c	8d 55 d8	 lea	 edx, DWORD PTR _atm$188585[ebp]
  0026f	33 ff		 xor	 edi, edi
  00271	81 c6 94 f8 ff
	ff		 add	 esi, -1900		; fffff894H
  00277	52		 push	 edx
  00278	89 7d d8	 mov	 DWORD PTR _atm$188585[ebp], edi
  0027b	89 7d dc	 mov	 DWORD PTR _atm$188585[ebp+4], edi
  0027e	89 4d e4	 mov	 DWORD PTR _atm$188585[ebp+12], ecx
  00281	89 45 e8	 mov	 DWORD PTR _atm$188585[ebp+16], eax
  00284	89 75 ec	 mov	 DWORD PTR _atm$188585[ebp+20], esi
  00287	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _atm$188585[ebp+32], -1
  0028e	e8 00 00 00 00	 call	 __mktime64
  00293	8b c8		 mov	 ecx, eax
  00295	23 ca		 and	 ecx, edx
  00297	83 c4 04	 add	 esp, 4
  0029a	83 f9 ff	 cmp	 ecx, -1
  0029d	75 0a		 jne	 SHORT $LN340@CheckCondi
  0029f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  002a4	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN483@CheckCondi:
$LN340@CheckCondi:

; 134  : 
; 135  : 			if ( tCurrentTime < tConditionTime  ||
; 136  : 				 tCurrentTime > tConditionTime+tValidRange )

  002a9	8b 4d d4	 mov	 ecx, DWORD PTR _tCurrentTime$[ebp+4]
  002ac	3b ca		 cmp	 ecx, edx
  002ae	0f 8c 20 ff ff
	ff		 jl	 $LN463@CheckCondi
  002b4	8b 7d d0	 mov	 edi, DWORD PTR _tCurrentTime$[ebp]
  002b7	7f 08		 jg	 SHORT $LN464@CheckCondi
  002b9	3b f8		 cmp	 edi, eax
  002bb	0f 82 13 ff ff
	ff		 jb	 $LN463@CheckCondi
$LN464@CheckCondi:
  002c1	03 45 bc	 add	 eax, DWORD PTR _tValidRange$[ebp]
  002c4	13 55 c0	 adc	 edx, DWORD PTR _tValidRange$[ebp+4]
  002c7	3b ca		 cmp	 ecx, edx
  002c9	7c 0e		 jl	 SHORT $LN469@CheckCondi
  002cb	0f 8f 03 ff ff
	ff		 jg	 $LN463@CheckCondi
  002d1	3b f8		 cmp	 edi, eax

; 137  : 			{
; 138  : 				return FALSE;

  002d3	0f 87 fb fe ff
	ff		 ja	 $LN463@CheckCondi
$LN469@CheckCondi:

; 134  : 
; 135  : 			if ( tCurrentTime < tConditionTime  ||
; 136  : 				 tCurrentTime > tConditionTime+tValidRange )

  002d9	8b 7d b8	 mov	 edi, DWORD PTR _iDay$[ebp]
$LN471@CheckCondi:

; 139  : 			}
; 140  : 		}
; 141  : 	}
; 142  : 
; 143  : 	if ( this->m_iMinute != -1 )

  002dc	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  002df	83 fa ff	 cmp	 edx, -1
  002e2	74 71		 je	 SHORT $LN2@CheckCondi

; 144  : 	{
; 145  : 		if ( this->m_iMinute != iMinute )

  002e4	3b 55 b4	 cmp	 edx, DWORD PTR _iMinute$[ebp]
  002e7	74 6c		 je	 SHORT $LN2@CheckCondi

; 146  : 		{
; 147  : 			CTime tConditionTime(iYear, (this->m_iMonth == -1)?iMonth : this->m_iMonth,
; 148  : 										(this->m_iDay == -1)?iDay : this->m_iDay,
; 149  : 										(this->m_iHour == -1)?iHour : this->m_iHour,
; 150  : 										 this->m_iMinute, 0, -1) ;

  002e9	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  002ec	8b 75 c4	 mov	 esi, DWORD PTR _iHour$[ebp]
  002ef	83 f8 ff	 cmp	 eax, -1
  002f2	74 02		 je	 SHORT $LN28@CheckCondi
  002f4	8b f0		 mov	 esi, eax
$LN28@CheckCondi:
  002f6	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  002f9	83 f9 ff	 cmp	 ecx, -1
  002fc	75 02		 jne	 SHORT $LN29@CheckCondi
  002fe	8b cf		 mov	 ecx, edi
$LN29@CheckCondi:
  00300	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00303	83 f8 ff	 cmp	 eax, -1
  00306	75 03		 jne	 SHORT $LN31@CheckCondi
  00308	8b 45 cc	 mov	 eax, DWORD PTR _iMonth$[ebp]
$LN31@CheckCondi:
  0030b	6a ff		 push	 -1
  0030d	6a 00		 push	 0
  0030f	52		 push	 edx
  00310	8b 55 c8	 mov	 edx, DWORD PTR _iYear$[ebp]
  00313	56		 push	 esi
  00314	51		 push	 ecx
  00315	50		 push	 eax
  00316	52		 push	 edx
  00317	8d 4d b0	 lea	 ecx, DWORD PTR _tConditionTime$187611[ebp]
  0031a	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@HHHHHHH@Z ; ATL::CTime::CTime

; 151  : 
; 152  : 			if ( tCurrentTime < tConditionTime  ||
; 153  : 				 tCurrentTime > tConditionTime+tValidRange )

  0031f	8b 55 d4	 mov	 edx, DWORD PTR _tCurrentTime$[ebp+4]
  00322	8b 45 b4	 mov	 eax, DWORD PTR _tConditionTime$187611[ebp+4]
  00325	3b d0		 cmp	 edx, eax
  00327	0f 8c a7 fe ff
	ff		 jl	 $LN463@CheckCondi
  0032d	8b 75 d0	 mov	 esi, DWORD PTR _tCurrentTime$[ebp]
  00330	8b 4d b0	 mov	 ecx, DWORD PTR _tConditionTime$187611[ebp]
  00333	7f 08		 jg	 SHORT $LN466@CheckCondi
  00335	3b f1		 cmp	 esi, ecx
  00337	0f 82 97 fe ff
	ff		 jb	 $LN463@CheckCondi
$LN466@CheckCondi:
  0033d	03 4d bc	 add	 ecx, DWORD PTR _tValidRange$[ebp]
  00340	13 45 c0	 adc	 eax, DWORD PTR _tValidRange$[ebp+4]
  00343	3b d0		 cmp	 edx, eax
  00345	7c 0e		 jl	 SHORT $LN2@CheckCondi
  00347	0f 8f 87 fe ff
	ff		 jg	 $LN463@CheckCondi
  0034d	3b f1		 cmp	 esi, ecx

; 154  : 			{
; 155  : 				return FALSE;

  0034f	0f 87 7f fe ff
	ff		 ja	 $LN463@CheckCondi
$LN2@CheckCondi:

; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 
; 160  : 	return TRUE;
; 161  : }	

  00355	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	33 cd		 xor	 ecx, ebp
  0035c	b8 01 00 00 00	 mov	 eax, 1
  00361	5b		 pop	 ebx
  00362	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00367	8b e5		 mov	 esp, ebp
  00369	5d		 pop	 ebp
  0036a	c3		 ret	 0
$LN472@CheckCondi:
?CheckConditionSpecificDate@TMonsterAIRuleInfo@@QAEHXZ ENDP ; TMonsterAIRuleInfo::CheckConditionSpecificDate
_TEXT	ENDS
PUBLIC	?IsValid@TMonsterAIRuleInfo@@QAEHXZ		; TMonsterAIRuleInfo::IsValid
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?IsValid@TMonsterAIRuleInfo@@QAEHXZ
_TEXT	SEGMENT
?IsValid@TMonsterAIRuleInfo@@QAEHXZ PROC		; TMonsterAIRuleInfo::IsValid, COMDAT
; _this$ = ecx

; 40   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 41   : 	BOOL bIsValid = FALSE;
; 42   : 
; 43   : 	switch ( this->m_iRuleCondition )

  00003	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00006	48		 dec	 eax
  00007	74 16		 je	 SHORT $LN7@IsValid
  00009	83 e8 46	 sub	 eax, 70			; 00000046H
  0000c	74 0a		 je	 SHORT $LN6@IsValid
  0000e	48		 dec	 eax
  0000f	75 17		 jne	 SHORT $LN12@IsValid

; 52   : 
; 53   : 		case MAR_CONDITION_CRYWOLF_END:
; 54   : 			bIsValid = this->CheckConditionCrywolfEnd();

  00011	e8 00 00 00 00	 call	 ?CheckConditionCrywolfEnd@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::CheckConditionCrywolfEnd

; 55   : 			break;

  00016	eb 0c		 jmp	 SHORT $LN8@IsValid
$LN6@IsValid:

; 47   : 			break;
; 48   : 
; 49   : 		case MAR_CONDITION_CRYWOLF_START:
; 50   : 			bIsValid = this->CheckConditionCrywolfStart();

  00018	e8 00 00 00 00	 call	 ?CheckConditionCrywolfStart@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::CheckConditionCrywolfStart

; 51   : 			break;

  0001d	eb 05		 jmp	 SHORT $LN8@IsValid
$LN7@IsValid:

; 44   : 	{
; 45   : 		case MAR_CONDITION_SPECIFIC_DATE:
; 46   : 			bIsValid = this->CheckConditionSpecificDate();

  0001f	e8 00 00 00 00	 call	 ?CheckConditionSpecificDate@TMonsterAIRuleInfo@@QAEHXZ ; TMonsterAIRuleInfo::CheckConditionSpecificDate
$LN8@IsValid:

; 56   : 	}
; 57   : 
; 58   : 	if ( !bIsValid )

  00024	85 c0		 test	 eax, eax
  00026	75 0d		 jne	 SHORT $LN4@IsValid
$LN12@IsValid:

; 59   : 	{
; 60   : 		this->m_iAppliedTime = -1;

  00028	83 c8 ff	 or	 eax, -1
  0002b	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 61   : 		this->m_iApplyingTime = -1;

  0002e	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 62   : 
; 63   : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 73   : 		return FALSE;
; 74   : 
; 75   : 	return TRUE;
; 76   : }

  00034	c3		 ret	 0
$LN4@IsValid:

; 64   : 	}
; 65   : 
; 66   : 	if ( this->m_iAppliedTime == -1 )

  00035	83 7e 2c ff	 cmp	 DWORD PTR [esi+44], -1
  00039	57		 push	 edi
  0003a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00040	75 05		 jne	 SHORT $LN3@IsValid

; 67   : 		this->m_iAppliedTime = GetTickCount();

  00042	ff d7		 call	 edi
  00044	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN3@IsValid:

; 68   : 
; 69   : 	if ( (this->m_iAppliedTime + (this->m_iWaitTime * 1000)) > GetTickCount() )

  00047	ff d7		 call	 edi
  00049	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0004c	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  00052	03 4e 2c	 add	 ecx, DWORD PTR [esi+44]
  00055	3b c8		 cmp	 ecx, eax
  00057	76 05		 jbe	 SHORT $LN2@IsValid

; 70   : 		return FALSE;

  00059	5f		 pop	 edi
  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi

; 73   : 		return FALSE;
; 74   : 
; 75   : 	return TRUE;
; 76   : }

  0005d	c3		 ret	 0
$LN2@IsValid:

; 71   : 
; 72   : 	if ( (  this->m_iAppliedTime + this->m_iWaitTime * 1000 + this->m_iContinuanceTime * 1000) < GetTickCount() )

  0005e	ff d7		 call	 edi
  00060	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00063	03 56 10	 add	 edx, DWORD PTR [esi+16]
  00066	5f		 pop	 edi
  00067	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0006d	03 56 2c	 add	 edx, DWORD PTR [esi+44]
  00070	5e		 pop	 esi
  00071	3b d0		 cmp	 edx, eax
  00073	1b c0		 sbb	 eax, eax
  00075	40		 inc	 eax

; 73   : 		return FALSE;
; 74   : 
; 75   : 	return TRUE;
; 76   : }

  00076	c3		 ret	 0
?IsValid@TMonsterAIRuleInfo@@QAEHXZ ENDP		; TMonsterAIRuleInfo::IsValid
_TEXT	ENDS
END
