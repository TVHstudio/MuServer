; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\TMonsterAIUtil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7TMonsterAIUtil@@6B@				; TMonsterAIUtil::`vftable'
PUBLIC	??0TMonsterAIUtil@@QAE@XZ			; TMonsterAIUtil::TMonsterAIUtil
PUBLIC	??_R4TMonsterAIUtil@@6B@			; TMonsterAIUtil::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTMonsterAIUtil@@@8			; TMonsterAIUtil `RTTI Type Descriptor'
PUBLIC	??_R3TMonsterAIUtil@@8				; TMonsterAIUtil::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TMonsterAIUtil@@8				; TMonsterAIUtil::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TMonsterAIUtil@@8			; TMonsterAIUtil::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ETMonsterAIUtil@@UAEPAXI@Z:PROC		; TMonsterAIUtil::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@TMonsterAIUtil@@8
; File e:\work\tranet_version\gs\gameserver\tmonsteraiutil.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@TMonsterAIUtil@@8 DD FLAT:??_R0?AVTMonsterAIUtil@@@8 ; TMonsterAIUtil::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TMonsterAIUtil@@8
rdata$r	ENDS
;	COMDAT ??_R2TMonsterAIUtil@@8
rdata$r	SEGMENT
??_R2TMonsterAIUtil@@8 DD FLAT:??_R1A@?0A@EA@TMonsterAIUtil@@8 ; TMonsterAIUtil::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3TMonsterAIUtil@@8
rdata$r	SEGMENT
??_R3TMonsterAIUtil@@8 DD 00H				; TMonsterAIUtil::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2TMonsterAIUtil@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTMonsterAIUtil@@@8
_DATA	SEGMENT
??_R0?AVTMonsterAIUtil@@@8 DD FLAT:??_7type_info@@6B@	; TMonsterAIUtil `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTMonsterAIUtil@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TMonsterAIUtil@@6B@
rdata$r	SEGMENT
??_R4TMonsterAIUtil@@6B@ DD 00H				; TMonsterAIUtil::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTMonsterAIUtil@@@8
	DD	FLAT:??_R3TMonsterAIUtil@@8
rdata$r	ENDS
;	COMDAT ??_7TMonsterAIUtil@@6B@
CONST	SEGMENT
??_7TMonsterAIUtil@@6B@ DD FLAT:??_R4TMonsterAIUtil@@6B@ ; TMonsterAIUtil::`vftable'
	DD	FLAT:??_ETMonsterAIUtil@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0TMonsterAIUtil@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterAIUtil@@QAE@XZ PROC				; TMonsterAIUtil::TMonsterAIUtil, COMDAT
; _this$ = ecx

; 18   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7TMonsterAIUtil@@6B@

; 19   : 	return;
; 20   : }

  00008	c3		 ret	 0
??0TMonsterAIUtil@@QAE@XZ ENDP				; TMonsterAIUtil::TMonsterAIUtil
_TEXT	ENDS
PUBLIC	??1TMonsterAIUtil@@UAE@XZ			; TMonsterAIUtil::~TMonsterAIUtil
; Function compile flags: /Ogtp
;	COMDAT ??1TMonsterAIUtil@@UAE@XZ
_TEXT	SEGMENT
??1TMonsterAIUtil@@UAE@XZ PROC				; TMonsterAIUtil::~TMonsterAIUtil, COMDAT
; _this$ = ecx

; 23   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TMonsterAIUtil@@6B@

; 24   : 	return;
; 25   : }

  00006	c3		 ret	 0
??1TMonsterAIUtil@@UAE@XZ ENDP				; TMonsterAIUtil::~TMonsterAIUtil
_TEXT	ENDS
PUBLIC	?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z	; TMonsterAIUtil::FindMonViewportObj
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z
_TEXT	SEGMENT
_iObjIndex$ = 8						; size = 4
_iTargetObjIndex$ = 12					; size = 4
?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z PROC	; TMonsterAIUtil::FindMonViewportObj, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	if ( OBJMON_RANGE(iObjIndex) ==  FALSE || OBJMAX_RANGE(iTargetObjIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iObjIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 61		 js	 SHORT $LN6@FindMonVie
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d c7 32 00 00	 cmp	 eax, 12999		; 000032c7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	74 53		 je	 SHORT $LN6@FindMonVie
  00018	8b 55 0c	 mov	 edx, DWORD PTR _iTargetObjIndex$[ebp]
  0001b	85 d2		 test	 edx, edx
  0001d	78 4c		 js	 SHORT $LN6@FindMonVie
  0001f	33 c9		 xor	 ecx, ecx
  00021	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00027	0f 9e c1	 setle	 cl
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 3d		 je	 SHORT $LN6@FindMonVie

; 32   : 
; 33   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  0002e	33 c9		 xor	 ecx, ecx
  00030	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00036	56		 push	 esi
  00037	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	8d 84 30 28 05
	00 00		 lea	 eax, DWORD PTR [eax+esi+1320]
$LL5@FindMonVie:

; 34   : 	{
; 35   : 		if ( gObj[iObjIndex].VpPlayer[i].state != FALSE )

  00044	80 38 00	 cmp	 BYTE PTR [eax], 0
  00047	74 08		 je	 SHORT $LN4@FindMonVie

; 36   : 		{
; 37   : 			if ( iTargetObjIndex == gObj[iObjIndex].VpPlayer[i].number )

  00049	0f bf 70 02	 movsx	 esi, WORD PTR [eax+2]
  0004d	3b d6		 cmp	 edx, esi
  0004f	74 10		 je	 SHORT $LN15@FindMonVie
$LN4@FindMonVie:

; 32   : 
; 33   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00051	41		 inc	 ecx
  00052	83 c0 0c	 add	 eax, 12			; 0000000cH
  00055	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  00058	7c ea		 jl	 SHORT $LL5@FindMonVie

; 40   : 			}
; 41   : 		}
; 42   : 	}
; 43   : 
; 44   : 	return FALSE;

  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi

; 45   : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
$LN15@FindMonVie:

; 38   : 			{
; 39   : 				return TRUE;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5e		 pop	 esi

; 45   : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN6@FindMonVie:

; 31   : 		return FALSE;

  0006b	33 c0		 xor	 eax, eax

; 45   : }

  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
?FindMonViewportObj@TMonsterAIUtil@@QAEHHH@Z ENDP	; TMonsterAIUtil::FindMonViewportObj
_TEXT	ENDS
PUBLIC	?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z	; TMonsterAIUtil::FindMonViewportObj2
; Function compile flags: /Ogtp
;	COMDAT ?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z
_TEXT	SEGMENT
_iObjIndex$ = 8						; size = 4
_iTargetObjIndex$ = 12					; size = 4
?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z PROC	; TMonsterAIUtil::FindMonViewportObj2, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	if ( OBJMON_RANGE(iObjIndex) ==  FALSE || OBJMAX_RANGE(iTargetObjIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iObjIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 61		 js	 SHORT $LN6@FindMonVie@2
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d c7 32 00 00	 cmp	 eax, 12999		; 000032c7H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	74 53		 je	 SHORT $LN6@FindMonVie@2
  00018	8b 55 0c	 mov	 edx, DWORD PTR _iTargetObjIndex$[ebp]
  0001b	85 d2		 test	 edx, edx
  0001d	78 4c		 js	 SHORT $LN6@FindMonVie@2
  0001f	33 c9		 xor	 ecx, ecx
  00021	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00027	0f 9e c1	 setle	 cl
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 3d		 je	 SHORT $LN6@FindMonVie@2

; 51   : 
; 52   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  0002e	33 c9		 xor	 ecx, ecx
  00030	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00036	56		 push	 esi
  00037	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	8d 84 30 ac 08
	00 00		 lea	 eax, DWORD PTR [eax+esi+2220]
$LL5@FindMonVie@2:

; 53   : 	{
; 54   : 		if ( gObj[iObjIndex].VpPlayer2[i].state != FALSE )

  00044	80 38 00	 cmp	 BYTE PTR [eax], 0
  00047	74 08		 je	 SHORT $LN4@FindMonVie@2

; 55   : 		{
; 56   : 			if ( iTargetObjIndex == gObj[iObjIndex].VpPlayer2[i].number )

  00049	0f bf 70 02	 movsx	 esi, WORD PTR [eax+2]
  0004d	3b d6		 cmp	 edx, esi
  0004f	74 10		 je	 SHORT $LN15@FindMonVie@2
$LN4@FindMonVie@2:

; 51   : 
; 52   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00051	41		 inc	 ecx
  00052	83 c0 0c	 add	 eax, 12			; 0000000cH
  00055	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  00058	7c ea		 jl	 SHORT $LL5@FindMonVie@2

; 59   : 			}
; 60   : 		}
; 61   : 	}
; 62   : 
; 63   : 	return FALSE;

  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi

; 64   : }

  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
$LN15@FindMonVie@2:

; 57   : 			{
; 58   : 				return TRUE;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	5e		 pop	 esi

; 64   : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN6@FindMonVie@2:

; 50   : 		return FALSE;

  0006b	33 c0		 xor	 eax, eax

; 64   : }

  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
?FindMonViewportObj2@TMonsterAIUtil@@QAEHHH@Z ENDP	; TMonsterAIUtil::FindMonViewportObj2
_TEXT	ENDS
PUBLIC	?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z ; TMonsterAIUtil::SendMonsterV2Msg
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
_size$ = 16						; size = 4
?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z PROC ; TMonsterAIUtil::SendMonsterV2Msg, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 71   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	8d b7 ae 08 00
	00		 lea	 esi, DWORD PTR [edi+2222]
  0000f	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
$LL7@SendMonste:

; 72   : 	{
; 73   : 		if ( lpObj->VpPlayer2[i].type == OBJ_USER )

  00014	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  00018	75 38		 jne	 SHORT $LN6@SendMonste

; 74   : 		{
; 75   : 			if ( lpObj->VpPlayer2[i].state != FALSE )

  0001a	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  0001e	74 32		 je	 SHORT $LN6@SendMonste

; 76   : 			{
; 77   : 				if ( lpObj->Connected > PLAYER_CONNECTED && lpObj->Live != FALSE)

  00020	83 7f 04 01	 cmp	 DWORD PTR [edi+4], 1
  00024	7e 1c		 jle	 SHORT $LN2@SendMonste
  00026	80 7f 6a 00	 cmp	 BYTE PTR [edi+106], 0
  0002a	74 16		 je	 SHORT $LN2@SendMonste

; 78   : 				{
; 79   : 					DataSend(lpObj->VpPlayer2[i].number, lpMsg, size);

  0002c	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00032	0f bf 16	 movsx	 edx, WORD PTR [esi]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   : 				}
; 81   : 				else

  00040	eb 10		 jmp	 SHORT $LN6@SendMonste
$LN2@SendMonste:

; 82   : 				{
; 83   : 					lpObj->VpPlayer2[i].number = -1;

  00042	83 c8 ff	 or	 eax, -1
  00045	66 89 06	 mov	 WORD PTR [esi], ax

; 84   : 					lpObj->VpPlayer2[i].state = FALSE;

  00048	c6 46 fe 00	 mov	 BYTE PTR [esi-2], 0

; 85   : 					lpObj->VPCount2--;

  0004c	ff 8f 34 0c 00
	00		 dec	 DWORD PTR [edi+3124]
$LN6@SendMonste:

; 71   : 	for ( int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00052	83 c6 0c	 add	 esi, 12			; 0000000cH
  00055	4b		 dec	 ebx
  00056	75 bc		 jne	 SHORT $LL7@SendMonste
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 86   : 				}
; 87   : 			}
; 88   : 		}
; 89   : 	}
; 90   : }

  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z ENDP ; TMonsterAIUtil::SendMonsterV2Msg
_TEXT	ENDS
PUBLIC	?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::CheckMovingCondition
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
; Function compile flags: /Ogtp
;	COMDAT ?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::CheckMovingCondition, COMDAT
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 173  : 	if ( !lpObj->Live )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0

; 174  : 		return FALSE;

  0000b	74 52		 je	 SHORT $LN2@CheckMovin

; 175  : 
; 176  : 	if ( lpObj->RegenOk > 0 )

  0000d	80 be a3 03 00
	00 00		 cmp	 BYTE PTR [esi+931], 0

; 177  : 		return FALSE;

  00014	7f 49		 jg	 SHORT $LN2@CheckMovin

; 178  : 
; 179  : 	if ( lpObj->Teleport )

  00016	80 be a0 03 00
	00 00		 cmp	 BYTE PTR [esi+928], 0

; 180  : 		return FALSE;

  0001d	75 40		 jne	 SHORT $LN2@CheckMovin

; 181  : 
; 182  : 	if ( lpObj->m_State != 2 )

  0001f	83 be 20 02 00
	00 02		 cmp	 DWORD PTR [esi+544], 2

; 183  : 		return FALSE;

  00026	75 37		 jne	 SHORT $LN2@CheckMovin

; 184  : 
; 185  : 	if(gObjSearchActiveEffect(lpObj, AT_ICE_ARROW) == 1 || gObjSearchActiveEffect(lpObj, AT_STUN) == 1)

  00028	6a 39		 push	 57			; 00000039H
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00030	83 c4 08	 add	 esp, 8
  00033	3c 01		 cmp	 al, 1
  00035	74 28		 je	 SHORT $LN2@CheckMovin
  00037	6a 3d		 push	 61			; 0000003dH
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0003f	83 c4 08	 add	 esp, 8
  00042	3c 01		 cmp	 al, 1
  00044	74 19		 je	 SHORT $LN2@CheckMovin

; 188  : 	}
; 189  : 
; 190  : 	if(gObjSearchActiveEffect(lpObj, AT_SLEEP) == 1)

  00046	6a 48		 push	 72			; 00000048H
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0004e	33 c9		 xor	 ecx, ecx
  00050	83 c4 08	 add	 esp, 8
  00053	3c 01		 cmp	 al, 1
  00055	0f 95 c1	 setne	 cl
  00058	5e		 pop	 esi
  00059	8b c1		 mov	 eax, ecx

; 191  : 	{
; 192  : 		return FALSE;
; 193  : 	}
; 194  : 
; 195  : 	return TRUE;
; 196  : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN2@CheckMovin:

; 186  : 	{
; 187  : 		return FALSE;

  0005f	33 c0		 xor	 eax, eax
  00061	5e		 pop	 esi

; 191  : 	{
; 192  : 		return FALSE;
; 193  : 	}
; 194  : 
; 195  : 	return TRUE;
; 196  : }

  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::CheckMovingCondition
_TEXT	ENDS
PUBLIC	?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z ; TMonsterAIUtil::CheckMoveRange
; Function compile flags: /Ogtp
;	COMDAT ?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_iTargetX$ = 12						; size = 4
_iTargetY$ = 16						; size = 4
?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z PROC ; TMonsterAIUtil::CheckMoveRange, COMDAT
; _this$ = ecx

; 201  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 202  : }

  00002	c2 0c 00	 ret	 12			; 0000000cH
?CheckMoveRange@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HH@Z ENDP ; TMonsterAIUtil::CheckMoveRange
_TEXT	ENDS
PUBLIC	?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::GetXYToPatrol
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	_rand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN8@GetXYToPat
	DD	FLAT:$LN9@GetXYToPat
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_searchc$ = -36						; size = 4
_maxmoverange$ = -32					; size = 4
_tpy$ = -26						; size = 1
_tpx$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::GetXYToPatrol, COMDAT
; _this$ = ecx

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 14	 sub	 esp, 20			; 00000014H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 208  : 	int maxmoverange = lpObj->m_MoveRange*2+1;

  00033	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00036	0f bf 86 ae 04
	00 00		 movsx	 eax, WORD PTR [esi+1198]
  0003d	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  00041	89 4d e0	 mov	 DWORD PTR _maxmoverange$[ebp], ecx

; 209  : 	int searchc=10;

  00044	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 210  : 	lpObj->NextActionTime = 1000;

  00049	c7 86 bc 03 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+956], 1000 ; 000003e8H
$LL4@GetXYToPat:

; 211  : 	BYTE tpx;
; 212  : 	BYTE tpy;
; 213  : 
; 214  : 	while ( searchc-- != 0 )

  00053	8b d7		 mov	 edx, edi
  00055	4f		 dec	 edi
  00056	89 7d dc	 mov	 DWORD PTR _searchc$[ebp], edi
  00059	85 d2		 test	 edx, edx
  0005b	0f 84 c3 00 00
	00		 je	 $LN3@GetXYToPat

; 215  : 	{
; 216  : 		__try

  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 217  : 		{
; 218  : 			tpx = (lpObj->X - lpObj->m_MoveRange) + (rand()%maxmoverange);

  00068	e8 00 00 00 00	 call	 _rand
  0006d	8b 4d e0	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00070	99		 cdq
  00071	f7 f9		 idiv	 ecx
  00073	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  0007a	03 d0		 add	 edx, eax
  0007c	0f bf 8e ae 04
	00 00		 movsx	 ecx, WORD PTR [esi+1198]
  00083	2b d1		 sub	 edx, ecx
  00085	88 55 e7	 mov	 BYTE PTR _tpx$[ebp], dl

; 219  : 			tpy = (lpObj->Y - lpObj->m_MoveRange) + (rand()%maxmoverange);

  00088	e8 00 00 00 00	 call	 _rand
  0008d	8b 4d e0	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00090	99		 cdq
  00091	f7 f9		 idiv	 ecx
  00093	0f bf 9e 46 01
	00 00		 movsx	 ebx, WORD PTR [esi+326]
  0009a	03 da		 add	 ebx, edx
  0009c	0f bf 8e ae 04
	00 00		 movsx	 ecx, WORD PTR [esi+1198]
  000a3	2b d9		 sub	 ebx, ecx
  000a5	88 5d e6	 mov	 BYTE PTR _tpy$[ebp], bl

; 220  : 		}

  000a8	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000af	eb 1c		 jmp	 SHORT $LN11@GetXYToPat
$LN8@GetXYToPat:
$LN14@GetXYToPat:

; 221  : 		__except(maxmoverange=1, 1)

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	89 45 e0	 mov	 DWORD PTR _maxmoverange$[ebp], eax
$LN13@GetXYToPat:
$LN10@GetXYToPat:
  000b9	c3		 ret	 0
$LN9@GetXYToPat:
  000ba	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 222  : 		{
; 223  : 
; 224  : 		}

  000bd	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000c4	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  000c7	8b 7d dc	 mov	 edi, DWORD PTR _searchc$[ebp]
  000ca	8a 5d e6	 mov	 bl, BYTE PTR _tpy$[ebp]
$LN11@GetXYToPat:

; 225  : 
; 226  : 		BYTE attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  000cd	0f b6 d3	 movzx	 edx, bl
  000d0	52		 push	 edx
  000d1	0f b6 45 e7	 movzx	 eax, BYTE PTR _tpx$[ebp]
  000d5	50		 push	 eax
  000d6	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000dd	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000e3	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000e9	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 227  : 
; 228  : 		if ( (attr&1)!=1 && (attr&2)!=2 && (attr&4)!=4 && (attr&8)!= 8 )

  000ee	a8 0f		 test	 al, 15			; 0000000fH
  000f0	0f 85 5d ff ff
	ff		 jne	 $LL4@GetXYToPat

; 229  : 		{
; 230  : 			lpObj->MTX = tpx;

  000f6	0f b6 4d e7	 movzx	 ecx, BYTE PTR _tpx$[ebp]
  000fa	66 89 8e 80 01
	00 00		 mov	 WORD PTR [esi+384], cx

; 231  : 			lpObj->MTY = tpy;

  00101	0f b6 d3	 movzx	 edx, bl
  00104	66 89 96 82 01
	00 00		 mov	 WORD PTR [esi+386], dx

; 232  : 			return TRUE;

  0010b	b8 01 00 00 00	 mov	 eax, 1

; 237  : }

  00110	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00113	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011a	59		 pop	 ecx
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 04 00	 ret	 4
$LN3@GetXYToPat:

; 233  : 		}
; 234  : 	}
; 235  : 
; 236  : 	return FALSE;

  00124	33 c0		 xor	 eax, eax

; 237  : }

  00126	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00129	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00130	59		 pop	 ecx
  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 04 00	 ret	 4
?GetXYToPatrol@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::GetXYToPatrol
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::GetXYToEascape
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?GetStandAttr@MapClass@@QAEHHH@Z:PROC		; MapClass::GetStandAttr
EXTRN	?GetPathPacketDirPos@@YAEHH@Z:PROC		; GetPathPacketDirPos
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_mty$ = -24						; size = 4
_mtx$ = -20						; size = 4
_searchcount$ = -16					; size = 4
tv352 = -12						; size = 8
tv373 = -8						; size = 4
_searchp$ = -8						; size = 4
_ty$ = -4						; size = 4
_tx$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::GetXYToEascape, COMDAT
; _this$ = ecx

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 242  : 	int tpx;	// Target Player X
; 243  : 	int tpy;
; 244  : 	int mtx;	// Monster Target X
; 245  : 	int mty;
; 246  : 	int tx;
; 247  : 	int ty;
; 248  : 	int searchp = 0;
; 249  : 	int sn = 0;
; 250  : 	int searchcount = MAX_ROAD_PATH_TABLE/2-1;
; 251  : 	BYTE attr;
; 252  : 	BOOL result = 0;
; 253  : 	LPOBJ lpTargetObj;
; 254  : 
; 255  : 	if ( OBJMAX_RANGE(lpObj->TargetNumber) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	0f b7 86 58 04
	00 00		 movzx	 eax, WORD PTR [esi+1112]
  00011	c7 45 f0 07 00
	00 00		 mov	 DWORD PTR _searchcount$[ebp], 7
  00018	66 85 c0	 test	 ax, ax
  0001b	78 13		 js	 SHORT $LN19@GetXYToEas
  0001d	33 d2		 xor	 edx, edx
  0001f	b9 97 3a 00 00	 mov	 ecx, 14999		; 00003a97H
  00024	66 3b c1	 cmp	 ax, cx
  00027	0f 9e c2	 setle	 dl
  0002a	8b ca		 mov	 ecx, edx
  0002c	85 c9		 test	 ecx, ecx
  0002e	75 09		 jne	 SHORT $LN11@GetXYToEas
$LN19@GetXYToEas:

; 256  : 	{
; 257  : 		return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	5e		 pop	 esi

; 327  : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN11@GetXYToEas:

; 258  : 	}
; 259  : 
; 260  : 	lpTargetObj = &gObj[lpObj->TargetNumber];

  00039	98		 cwde
  0003a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00040	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	53		 push	 ebx

; 261  : 	tpx = lpTargetObj->X;
; 262  : 	mtx = tpx;

  00047	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]

; 263  : 	tpy = lpTargetObj->Y;
; 264  : 	mty = tpy;

  0004e	0f bf 90 46 01
	00 00		 movsx	 edx, WORD PTR [eax+326]

; 265  : 	tx = lpObj->X;
; 266  : 	ty = lpObj->Y;
; 267  : 	int dis = (int)(lpObj->m_AttackRange / sqrt(2.0));

  00055	0f bf 86 b0 04
	00 00		 movsx	 eax, WORD PTR [esi+1200]
  0005c	0f bf 9e 46 01
	00 00		 movsx	 ebx, WORD PTR [esi+326]
  00063	89 45 f8	 mov	 DWORD PTR tv373[ebp], eax
  00066	57		 push	 edi
  00067	0f bf be 44 01
	00 00		 movsx	 edi, WORD PTR [esi+324]
  0006e	db 45 f8	 fild	 DWORD PTR tv373[ebp]
  00071	89 4d ec	 mov	 DWORD PTR _mtx$[ebp], ecx
  00074	dd 5d f4	 fstp	 QWORD PTR tv352[ebp]
  00077	89 55 e8	 mov	 DWORD PTR _mty$[ebp], edx
  0007a	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  00080	89 7d 08	 mov	 DWORD PTR _tx$[ebp], edi
  00083	89 5d fc	 mov	 DWORD PTR _ty$[ebp], ebx
  00086	e8 00 00 00 00	 call	 __CIsqrt
  0008b	dc 7d f4	 fdivr	 QWORD PTR tv352[ebp]
  0008e	e8 00 00 00 00	 call	 __ftol2_sse

; 268  : 
; 269  : 	if ( lpObj->X < mtx )

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _mtx$[ebp]
  00096	3b f9		 cmp	 edi, ecx
  00098	7d 05		 jge	 SHORT $LN28@GetXYToEas

; 270  : 	{
; 271  : 		tx -= dis;

  0009a	29 45 08	 sub	 DWORD PTR _tx$[ebp], eax

; 272  : 	}
; 273  : 
; 274  : 	if ( lpObj->X > mtx )

  0009d	3b f9		 cmp	 edi, ecx
$LN28@GetXYToEas:
  0009f	7e 03		 jle	 SHORT $LN9@GetXYToEas

; 275  : 	{
; 276  : 		tx += dis;

  000a1	01 45 08	 add	 DWORD PTR _tx$[ebp], eax
$LN9@GetXYToEas:

; 277  : 	}
; 278  : 
; 279  : 	if ( lpObj->Y < mty )

  000a4	8b 4d e8	 mov	 ecx, DWORD PTR _mty$[ebp]
  000a7	3b d9		 cmp	 ebx, ecx
  000a9	7d 05		 jge	 SHORT $LN29@GetXYToEas

; 280  : 	{
; 281  : 		ty -= dis;

  000ab	29 45 fc	 sub	 DWORD PTR _ty$[ebp], eax

; 282  : 	}
; 283  : 
; 284  : 	if ( lpObj->Y > mty )

  000ae	3b d9		 cmp	 ebx, ecx
$LN29@GetXYToEas:
  000b0	7e 03		 jle	 SHORT $LN7@GetXYToEas

; 285  : 	{
; 286  : 		ty += dis;

  000b2	01 45 fc	 add	 DWORD PTR _ty$[ebp], eax
$LN7@GetXYToEas:

; 287  : 	}
; 288  : 
; 289  : 	searchp = GetPathPacketDirPos( (lpObj->X - tx), (lpObj->Y - tx) ) * 2;

  000b5	8b 45 08	 mov	 eax, DWORD PTR _tx$[ebp]
  000b8	2b d8		 sub	 ebx, eax
  000ba	2b f8		 sub	 edi, eax
  000bc	53		 push	 ebx
  000bd	57		 push	 edi
  000be	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 290  : 
; 291  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tx, ty) == 0 )

  000c3	8b 7d fc	 mov	 edi, DWORD PTR _ty$[ebp]
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _tx$[ebp]
  000c9	83 c4 08	 add	 esp, 8
  000cc	57		 push	 edi
  000cd	51		 push	 ecx
  000ce	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000d5	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000db	0f b6 d8	 movzx	 ebx, al
  000de	03 db		 add	 ebx, ebx
  000e0	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000e6	89 5d f8	 mov	 DWORD PTR _searchp$[ebp], ebx
  000e9	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  000ee	85 c0		 test	 eax, eax
  000f0	74 41		 je	 SHORT $LN5@GetXYToEas

; 311  : 			}
; 312  : 		}
; 313  : 
; 314  : 		return FALSE;
; 315  : 	}
; 316  : 
; 317  : 	attr = MapC[lpObj->MapNumber].GetAttr(tx, ty);

  000f2	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000f9	8b 5d 08	 mov	 ebx, DWORD PTR _tx$[ebp]
  000fc	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00102	57		 push	 edi
  00103	53		 push	 ebx
  00104	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0010a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 318  : 
; 319  : 	if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  0010f	a8 0f		 test	 al, 15			; 0000000fH
  00111	75 7e		 jne	 SHORT $LN1@GetXYToEas

; 320  : 	{
; 321  : 		lpObj->MTX = tx;
; 322  : 		lpObj->MTY = ty;

  00113	66 89 be 82 01
	00 00		 mov	 WORD PTR [esi+386], di
  0011a	5f		 pop	 edi
  0011b	66 89 9e 80 01
	00 00		 mov	 WORD PTR [esi+384], bx
  00122	5b		 pop	 ebx

; 323  : 		return TRUE;

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	5e		 pop	 esi

; 327  : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 04 00	 ret	 4
  0012f	90		 npad	 1
$LL22@GetXYToEas:

; 290  : 
; 291  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tx, ty) == 0 )

  00130	8b 5d f8	 mov	 ebx, DWORD PTR _searchp$[ebp]
$LN5@GetXYToEas:

; 294  : 		{
; 295  : 			mtx = lpObj->X + RoadPathTable[searchp];
; 296  : 			mty = lpObj->Y + RoadPathTable[1+searchp];
; 297  : 			attr = MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  00133	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  0013a	0f bf 3c 5d 00
	00 00 00	 movsx	 edi, WORD PTR ?RoadPathTable@@3PAFA[ebx*2]
  00142	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00148	0f bf 1c 5d 02
	00 00 00	 movsx	 ebx, WORD PTR ?RoadPathTable@@3PAFA[ebx*2+2]
  00150	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  00157	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  0015e	ff 4d f0	 dec	 DWORD PTR _searchcount$[ebp]
  00161	03 d8		 add	 ebx, eax
  00163	03 fa		 add	 edi, edx
  00165	53		 push	 ebx
  00166	57		 push	 edi
  00167	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0016d	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 298  : 			
; 299  : 			if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  00172	a8 0f		 test	 al, 15			; 0000000fH
  00174	74 26		 je	 SHORT $LN17@GetXYToEas

; 303  : 				return TRUE;
; 304  : 			}
; 305  : 
; 306  : 			searchp += 2;

  00176	8b 45 f8	 mov	 eax, DWORD PTR _searchp$[ebp]
  00179	83 c0 02	 add	 eax, 2
  0017c	89 45 f8	 mov	 DWORD PTR _searchp$[ebp], eax

; 307  : 
; 308  : 			if ( searchp > MAX_ROAD_PATH_TABLE-1 )

  0017f	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00182	7e 07		 jle	 SHORT $LN23@GetXYToEas

; 309  : 			{
; 310  : 				searchp = 0;

  00184	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
$LN23@GetXYToEas:

; 292  : 	{
; 293  : 		while ( searchcount-- )

  0018b	83 7d f0 00	 cmp	 DWORD PTR _searchcount$[ebp], 0
  0018f	75 9f		 jne	 SHORT $LL22@GetXYToEas
$LN1@GetXYToEas:
  00191	5f		 pop	 edi
  00192	5b		 pop	 ebx

; 324  : 	}
; 325  : 
; 326  : 	return FALSE;

  00193	33 c0		 xor	 eax, eax
  00195	5e		 pop	 esi

; 327  : }

  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 04 00	 ret	 4
$LN17@GetXYToEas:

; 300  : 			{
; 301  : 				lpObj->MTX = mtx;

  0019c	66 89 be 80 01
	00 00		 mov	 WORD PTR [esi+384], di
  001a3	5f		 pop	 edi

; 302  : 				lpObj->MTY = mty;

  001a4	66 89 9e 82 01
	00 00		 mov	 WORD PTR [esi+386], bx
  001ab	5b		 pop	 ebx

; 323  : 		return TRUE;

  001ac	b8 01 00 00 00	 mov	 eax, 1
  001b1	5e		 pop	 esi

; 327  : }

  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c2 04 00	 ret	 4
?GetXYToEascape@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::GetXYToEascape
_TEXT	ENDS
PUBLIC	?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::GetXYToChase
; Function compile flags: /Ogtp
;	COMDAT ?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv300 = -28						; size = 4
tv304 = -24						; size = 4
_mty$ = -20						; size = 4
_mtx$ = -16						; size = 4
_searchcount$ = -12					; size = 4
tv359 = -8						; size = 8
tv379 = -4						; size = 4
_searchp$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::GetXYToChase, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 334  : 	int tpx;	// Target Player X
; 335  : 	int tpy;
; 336  : 	int mtx;	// Monster Target X
; 337  : 	int mty;
; 338  : 	int searchp = 0;
; 339  : 	int sn = 0;
; 340  : 	int searchcount = MAX_ROAD_PATH_TABLE/2-1;
; 341  : 	BYTE attr;
; 342  : 	BOOL result = 0;
; 343  : 	LPOBJ lpTargetObj;
; 344  : 
; 345  : 	if ( OBJMAX_RANGE(lpObj->TargetNumber) == FALSE )

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00009	0f b7 81 58 04
	00 00		 movzx	 eax, WORD PTR [ecx+1112]
  00010	53		 push	 ebx
  00011	c7 45 f4 07 00
	00 00		 mov	 DWORD PTR _searchcount$[ebp], 7
  00018	66 85 c0	 test	 ax, ax
  0001b	78 13		 js	 SHORT $LN19@GetXYToCha
  0001d	33 db		 xor	 ebx, ebx
  0001f	ba 97 3a 00 00	 mov	 edx, 14999		; 00003a97H
  00024	66 3b c2	 cmp	 ax, dx
  00027	0f 9e c3	 setle	 bl
  0002a	8b d3		 mov	 edx, ebx
  0002c	85 d2		 test	 edx, edx
  0002e	75 09		 jne	 SHORT $LN11@GetXYToCha
$LN19@GetXYToCha:

; 346  : 	{
; 347  : 		return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 415  : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN11@GetXYToCha:
  00039	56		 push	 esi

; 348  : 	}
; 349  : 
; 350  : 	lpTargetObj = &gObj[lpObj->TargetNumber];

  0003a	0f bf f0	 movsx	 esi, ax

; 351  : 	tpx = lpTargetObj->X;
; 352  : 	mtx = tpx;
; 353  : 	tpy = lpTargetObj->Y;
; 354  : 	mty = tpy;
; 355  : 	int dis = (int)(lpObj->m_AttackRange / sqrt(2.0));

  0003d	0f bf 81 b0 04
	00 00		 movsx	 eax, WORD PTR [ecx+1200]
  00044	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0004a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00050	89 45 fc	 mov	 DWORD PTR tv379[ebp], eax
  00053	0f bf 9e 46 01
	00 00		 movsx	 ebx, WORD PTR [esi+326]
  0005a	db 45 fc	 fild	 DWORD PTR tv379[ebp]
  0005d	57		 push	 edi
  0005e	0f bf be 44 01
	00 00		 movsx	 edi, WORD PTR [esi+324]
  00065	dd 5d f8	 fstp	 QWORD PTR tv359[ebp]
  00068	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  0006e	89 7d e4	 mov	 DWORD PTR tv300[ebp], edi
  00071	89 7d f0	 mov	 DWORD PTR _mtx$[ebp], edi
  00074	89 5d e8	 mov	 DWORD PTR tv304[ebp], ebx
  00077	89 5d ec	 mov	 DWORD PTR _mty$[ebp], ebx
  0007a	e8 00 00 00 00	 call	 __CIsqrt
  0007f	dc 7d f8	 fdivr	 QWORD PTR tv359[ebp]
  00082	e8 00 00 00 00	 call	 __ftol2_sse

; 356  : 
; 357  : 	if ( lpObj->X < mtx )

  00087	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008a	0f bf 8a 44 01
	00 00		 movsx	 ecx, WORD PTR [edx+324]
  00091	3b cf		 cmp	 ecx, edi
  00093	7d 02		 jge	 SHORT $LN10@GetXYToCha

; 358  : 	{
; 359  : 		tpx -= dis;

  00095	2b f8		 sub	 edi, eax
$LN10@GetXYToCha:

; 360  : 	}
; 361  : 
; 362  : 	if ( lpObj->X > mtx )

  00097	3b 4d f0	 cmp	 ecx, DWORD PTR _mtx$[ebp]
  0009a	7e 02		 jle	 SHORT $LN9@GetXYToCha

; 363  : 	{
; 364  : 		tpx += dis;

  0009c	03 f8		 add	 edi, eax
$LN9@GetXYToCha:

; 365  : 	}
; 366  : 
; 367  : 	if ( lpObj->Y < mty )

  0009e	0f bf 8a 46 01
	00 00		 movsx	 ecx, WORD PTR [edx+326]
  000a5	3b cb		 cmp	 ecx, ebx
  000a7	7d 02		 jge	 SHORT $LN8@GetXYToCha

; 368  : 	{
; 369  : 		tpy -= dis;

  000a9	2b d8		 sub	 ebx, eax
$LN8@GetXYToCha:

; 370  : 	}
; 371  : 
; 372  : 	if ( lpObj->Y > mty )

  000ab	3b 4d ec	 cmp	 ecx, DWORD PTR _mty$[ebp]
  000ae	7e 02		 jle	 SHORT $LN7@GetXYToCha

; 373  : 	{
; 374  : 		tpy += dis;

  000b0	03 d8		 add	 ebx, eax
$LN7@GetXYToCha:

; 375  : 	}
; 376  : 
; 377  : 	searchp = GetPathPacketDirPos( (lpTargetObj->X - tpx), (lpTargetObj->Y - tpy) ) * 2;

  000b2	8b 45 e8	 mov	 eax, DWORD PTR tv304[ebp]
  000b5	2b c3		 sub	 eax, ebx
  000b7	50		 push	 eax
  000b8	8b 45 e4	 mov	 eax, DWORD PTR tv300[ebp]
  000bb	2b c7		 sub	 eax, edi
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 378  : 
; 379  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tpx, tpy) == 0 )

  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c6	0f b6 89 49 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+329]
  000cd	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000d3	83 c4 08	 add	 esp, 8
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	53		 push	 ebx
  000da	03 c0		 add	 eax, eax
  000dc	57		 push	 edi
  000dd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000e3	89 45 fc	 mov	 DWORD PTR _searchp$[ebp], eax
  000e6	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  000eb	85 c0		 test	 eax, eax
  000ed	0f 85 8e 00 00
	00		 jne	 $LN6@GetXYToCha
$LL5@GetXYToCha:

; 382  : 		{
; 383  : 			mtx = lpTargetObj->X + RoadPathTable[searchp];
; 384  : 			mty = lpTargetObj->Y + RoadPathTable[1+searchp];
; 385  : 			attr = MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f6	0f b6 89 49 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+329]
  000fd	8b 45 fc	 mov	 eax, DWORD PTR _searchp$[ebp]
  00100	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00106	0f bf 3c 45 00
	00 00 00	 movsx	 edi, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  0010e	0f bf 1c 45 02
	00 00 00	 movsx	 ebx, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  00116	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  0011d	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  00124	ff 4d f4	 dec	 DWORD PTR _searchcount$[ebp]
  00127	03 d8		 add	 ebx, eax
  00129	03 fa		 add	 edi, edx
  0012b	53		 push	 ebx
  0012c	57		 push	 edi
  0012d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00133	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 386  : 			
; 387  : 			if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  00138	a8 0f		 test	 al, 15			; 0000000fH
  0013a	74 26		 je	 SHORT $LN17@GetXYToCha

; 391  : 				return TRUE;
; 392  : 			}
; 393  : 
; 394  : 			searchp += 2;

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _searchp$[ebp]
  0013f	83 c0 02	 add	 eax, 2
  00142	89 45 fc	 mov	 DWORD PTR _searchp$[ebp], eax

; 395  : 
; 396  : 			if ( searchp > MAX_ROAD_PATH_TABLE-1 )

  00145	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00148	7e 07		 jle	 SHORT $LN23@GetXYToCha

; 397  : 			{
; 398  : 				searchp = 0;

  0014a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
$LN23@GetXYToCha:

; 380  : 	{
; 381  : 		while ( searchcount-- )

  00151	83 7d f4 00	 cmp	 DWORD PTR _searchcount$[ebp], 0
  00155	75 9c		 jne	 SHORT $LL5@GetXYToCha
$LN1@GetXYToCha:
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi

; 412  : 	}
; 413  : 
; 414  : 	return FALSE;

  00159	33 c0		 xor	 eax, eax
  0015b	5b		 pop	 ebx

; 415  : }

  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c2 04 00	 ret	 4
$LN17@GetXYToCha:

; 388  : 			{
; 389  : 				lpObj->MTX = mtx;

  00162	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00165	66 89 b8 80 01
	00 00		 mov	 WORD PTR [eax+384], di
  0016c	5f		 pop	 edi

; 390  : 				lpObj->MTY = mty;

  0016d	66 89 98 82 01
	00 00		 mov	 WORD PTR [eax+386], bx
  00174	5e		 pop	 esi

; 411  : 		return TRUE;

  00175	b8 01 00 00 00	 mov	 eax, 1
  0017a	5b		 pop	 ebx

; 415  : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 04 00	 ret	 4
$LN6@GetXYToCha:

; 399  : 			}
; 400  : 		}
; 401  : 
; 402  : 		return FALSE;
; 403  : 	}
; 404  : 
; 405  : 	attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  00181	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00184	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  0018b	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00191	53		 push	 ebx
  00192	57		 push	 edi
  00193	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00199	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 406  : 
; 407  : 	if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8  )

  0019e	a8 0f		 test	 al, 15			; 0000000fH
  001a0	75 b5		 jne	 SHORT $LN1@GetXYToCha

; 408  : 	{
; 409  : 		lpObj->MTX = tpx;

  001a2	66 89 be 80 01
	00 00		 mov	 WORD PTR [esi+384], di
  001a9	5f		 pop	 edi

; 410  : 		lpObj->MTY = tpy;

  001aa	66 89 9e 82 01
	00 00		 mov	 WORD PTR [esi+386], bx
  001b1	5e		 pop	 esi

; 411  : 		return TRUE;

  001b2	b8 01 00 00 00	 mov	 eax, 1
  001b7	5b		 pop	 ebx

; 415  : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 04 00	 ret	 4
?GetXYToChase@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::GetXYToChase
_TEXT	ENDS
PUBLIC	?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::SendMonsterMoveMsg
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 8
_lpObj$ = 8						; size = 4
?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; TMonsterAIUtil::SendMonsterMoveMsg, COMDAT
; _this$ = ecx

; 421  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 422  : 	PMSG_RECVMOVE pMove;
; 423  : 
; 424  : 	PHeadSetB((LPBYTE)&pMove, PROTOCOL_MOVE, sizeof(pMove));

  00007	6a 08		 push	 8
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  0000c	68 d4 00 00 00	 push	 212			; 000000d4H
  00011	50		 push	 eax
  00012	8b f1		 mov	 esi, ecx
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 425  : 	pMove.NumberH = SET_NUMBERH(lpObj->m_Index);

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]

; 426  : 	pMove.NumberL = SET_NUMBERL(lpObj->m_Index);

  0001e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00021	c1 e9 08	 shr	 ecx, 8
  00024	88 4d fb	 mov	 BYTE PTR _pMove$[ebp+3], cl

; 427  : 	pMove.X = lpObj->MTX;

  00027	0f b6 88 80 01
	00 00		 movzx	 ecx, BYTE PTR [eax+384]
  0002e	88 55 fc	 mov	 BYTE PTR _pMove$[ebp+4], dl

; 428  : 	pMove.Y = lpObj->MTY;

  00031	0f b6 90 82 01
	00 00		 movzx	 edx, BYTE PTR [eax+386]
  00038	88 4d fd	 mov	 BYTE PTR _pMove$[ebp+5], cl

; 429  : 	pMove.Path = lpObj->Dir << 4;

  0003b	0f b6 88 48 01
	00 00		 movzx	 ecx, BYTE PTR [eax+328]
  00042	88 55 fe	 mov	 BYTE PTR _pMove$[ebp+6], dl

; 430  : 
; 431  : 	this->SendMonsterV2Msg(lpObj, (LPBYTE)&pMove, pMove.h.size);

  00045	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMove$[ebp+1]
  00049	c0 e1 04	 shl	 cl, 4
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	88 4d ff	 mov	 BYTE PTR _pMove$[ebp+7], cl
  00052	52		 push	 edx
  00053	8d 4d f8	 lea	 ecx, DWORD PTR _pMove$[ebp]
  00056	51		 push	 ecx
  00057	50		 push	 eax
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?SendMonsterV2Msg@TMonsterAIUtil@@QAEXPAUOBJECTSTRUCT@@PAEH@Z ; TMonsterAIUtil::SendMonsterV2Msg

; 432  : 	return TRUE;

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	5e		 pop	 esi

; 433  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; TMonsterAIUtil::SendMonsterMoveMsg
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ	; TMonsterAIUtil::SendChattingMsg
EXTRN	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z:PROC ; ChatTargetSend
EXTRN	_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ
_TEXT	SEGMENT
_szBuffer$ = -576					; size = 512
_szChat$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_iObjIndex$ = 12					; size = 4
_lpszMsg$ = 16						; size = 4
?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ PROC	; TMonsterAIUtil::SendChattingMsg, COMDAT

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 02 00
	00		 sub	 esp, 576		; 00000240H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _iObjIndex$[ebp]
  00016	56		 push	 esi

; 439  : 	if ( !lpszMsg )

  00017	8b 75 10	 mov	 esi, DWORD PTR _lpszMsg$[ebp]
  0001a	85 f6		 test	 esi, esi
  0001c	0f 84 b4 00 00
	00		 je	 $LN3@SendChatti

; 440  : 		return;
; 441  : 
; 442  : 	if ( !OBJMAX_RANGE(iObjIndex))

  00022	85 c0		 test	 eax, eax
  00024	0f 88 ac 00 00
	00		 js	 $LN3@SendChatti
  0002a	33 c9		 xor	 ecx, ecx
  0002c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00031	0f 9e c1	 setle	 cl
  00034	85 c9		 test	 ecx, ecx
  00036	0f 84 9a 00 00
	00		 je	 $LN3@SendChatti

; 443  : 		return;
; 444  : 
; 445  : 	LPOBJ lpObj = &gObj[iObjIndex];

  0003c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00042	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	53		 push	 ebx
  00049	57		 push	 edi

; 446  : 	char szBuffer[512] = "";

  0004a	68 ff 01 00 00	 push	 511			; 000001ffH
  0004f	8b d8		 mov	 ebx, eax
  00051	8d 85 c1 fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  00057	6a 00		 push	 0
  00059	50		 push	 eax
  0005a	c6 85 c0 fd ff
	ff 00		 mov	 BYTE PTR _szBuffer$[ebp], 0
  00061	e8 00 00 00 00	 call	 _memset

; 447  : 	va_list pArguments;
; 448  : 
; 449  : 	va_start(pArguments, lpszMsg);
; 450  : 	vsprintf(szBuffer, lpszMsg, pArguments);

  00066	8d 4d 14	 lea	 ecx, DWORD PTR _lpszMsg$[ebp+4]
  00069	51		 push	 ecx
  0006a	8d 95 c0 fd ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  00070	56		 push	 esi
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 _vsprintf

; 451  : 	va_end(pArguments);
; 452  : 
; 453  : 	char szChat[60] = {0};

  00077	6a 3b		 push	 59			; 0000003bH
  00079	8d 45 c1	 lea	 eax, DWORD PTR _szChat$[ebp+1]
  0007c	6a 00		 push	 0
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _memset

; 454  : 	memcpy(szChat, szBuffer, sizeof(szChat)-1);

  00084	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00089	8d b5 c0 fd ff
	ff		 lea	 esi, DWORD PTR _szBuffer$[ebp]
  0008f	8d 7d c0	 lea	 edi, DWORD PTR _szChat$[ebp]
  00092	f3 a5		 rep movsd
  00094	66 a5		 movsw
  00096	a4		 movsb
  00097	83 c4 24	 add	 esp, 36			; 00000024H
  0009a	8d b3 ae 08 00
	00		 lea	 esi, DWORD PTR [ebx+2222]
  000a0	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
$LL5@SendChatti:

; 457  : 	{
; 458  : 		if ( lpObj->VpPlayer2[i].state )

  000a5	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  000a9	74 23		 je	 SHORT $LN4@SendChatti

; 459  : 		{
; 460  : 			int tObjNum = lpObj->VpPlayer2[i].number;

  000ab	0f bf 06	 movsx	 eax, WORD PTR [esi]

; 461  : 
; 462  : 			if ( OBJMAX_RANGE(tObjNum) )

  000ae	85 c0		 test	 eax, eax
  000b0	78 1c		 js	 SHORT $LN4@SendChatti
  000b2	33 c9		 xor	 ecx, ecx
  000b4	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  000b9	0f 9e c1	 setle	 cl
  000bc	85 c9		 test	 ecx, ecx
  000be	74 0e		 je	 SHORT $LN4@SendChatti

; 463  : 			{
; 464  : 				ChatTargetSend(lpObj, szChat, tObjNum);

  000c0	50		 push	 eax
  000c1	8d 4d c0	 lea	 ecx, DWORD PTR _szChat$[ebp]
  000c4	51		 push	 ecx
  000c5	53		 push	 ebx
  000c6	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendChatti:

; 455  : 
; 456  : 	for(int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  000ce	83 c6 0c	 add	 esi, 12			; 0000000cH
  000d1	4f		 dec	 edi
  000d2	75 d1		 jne	 SHORT $LL5@SendChatti
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx
$LN3@SendChatti:

; 465  : 			}
; 466  : 		}
; 467  : 	}
; 468  : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	5e		 pop	 esi
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?SendChattingMsg@TMonsterAIUtil@@QAAXHPADZZ ENDP	; TMonsterAIUtil::SendChattingMsg
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GTMonsterAIUtil@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTMonsterAIUtil@@UAEPAXI@Z PROC			; TMonsterAIUtil::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1TMonsterAIUtil@@UAE@XZ ; TMonsterAIUtil::~TMonsterAIUtil
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GTMonsterAIUtil@@UAEPAXI@Z ENDP			; TMonsterAIUtil::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z ; TMonsterAIUtil::FindPathToMoveMonster
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding4
EXTRN	?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding3
EXTRN	?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding2
; Function compile flags: /Ogtp
;	COMDAT ?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_iTargetX$209530 = -160					; size = 4
_this$ = -156						; size = 4
_iTargetY$209531 = -152					; size = 4
tv297 = -148						; size = 4
tv293 = -144						; size = 4
_iResultY$209535 = -140					; size = 4
_iResultX$209534 = -136					; size = 4
_Path$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iTargetX$ = 12						; size = 4
_iTargetY$ = 16						; size = 4
_iMaxPathCount$ = 20					; size = 4
_bPreventOverMoving$ = 24				; size = 4
?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z PROC ; TMonsterAIUtil::FindPathToMoveMonster, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 96   : 	if ( TMonsterAIUtil::CheckMovingCondition(lpObj)==FALSE)

  00017	56		 push	 esi
  00018	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0001e	e8 00 00 00 00	 call	 ?CheckMovingCondition@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::CheckMovingCondition
  00023	85 c0		 test	 eax, eax

; 97   : 		return FALSE;

  00025	0f 84 93 02 00
	00		 je	 $LN6@FindPathTo

; 98   : 
; 99   : 	PATH_t Path;
; 100  : 	BOOL bPathFound = FALSE;
; 101  : 
; 102  : 	if ( bPreventOverMoving == 1 )

  0002b	8b 45 18	 mov	 eax, DWORD PTR _bPreventOverMoving$[ebp]
  0002e	83 f8 01	 cmp	 eax, 1
  00031	75 39		 jne	 SHORT $LN10@FindPathTo

; 103  : 		bPathFound = MapC[lpObj->MapNumber].PathFinding2(lpObj->X, lpObj->Y, iTargetX, iTargetY, &Path);

  00033	8b 4d 10	 mov	 ecx, DWORD PTR _iTargetY$[ebp]
  00036	8b 55 0c	 mov	 edx, DWORD PTR _iTargetX$[ebp]
  00039	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _Path$[ebp]
  0003f	50		 push	 eax
  00040	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  00047	51		 push	 ecx
  00048	0f bf 8e 44 01
	00 00		 movsx	 ecx, WORD PTR [esi+324]
  0004f	52		 push	 edx
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00059	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0005f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00065	e8 00 00 00 00	 call	 ?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding2
  0006a	eb 75		 jmp	 SHORT $LN18@FindPathTo
$LN10@FindPathTo:

; 104  : 	else if ( bPreventOverMoving == 2 )

  0006c	83 f8 02	 cmp	 eax, 2
  0006f	75 39		 jne	 SHORT $LN8@FindPathTo

; 105  : 		bPathFound = MapC[lpObj->MapNumber].PathFinding3(lpObj->X, lpObj->Y, iTargetX, iTargetY, &Path);

  00071	8b 45 10	 mov	 eax, DWORD PTR _iTargetY$[ebp]
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _iTargetX$[ebp]
  00077	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _Path$[ebp]
  0007d	52		 push	 edx
  0007e	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  00085	50		 push	 eax
  00086	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  0008d	51		 push	 ecx
  0008e	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00095	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0009b	52		 push	 edx
  0009c	50		 push	 eax
  0009d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000a3	e8 00 00 00 00	 call	 ?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding3

; 106  : 	else

  000a8	eb 37		 jmp	 SHORT $LN18@FindPathTo
$LN8@FindPathTo:

; 107  : 		bPathFound = MapC[lpObj->MapNumber].PathFinding4(lpObj->X, lpObj->Y, iTargetX, iTargetY, &Path);

  000aa	8b 55 10	 mov	 edx, DWORD PTR _iTargetY$[ebp]
  000ad	8b 45 0c	 mov	 eax, DWORD PTR _iTargetX$[ebp]
  000b0	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _Path$[ebp]
  000b6	51		 push	 ecx
  000b7	0f bf 8e 46 01
	00 00		 movsx	 ecx, WORD PTR [esi+326]
  000be	52		 push	 edx
  000bf	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  000c6	50		 push	 eax
  000c7	51		 push	 ecx
  000c8	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  000cf	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000d5	52		 push	 edx
  000d6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000dc	e8 00 00 00 00	 call	 ?PathFinding4@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding4
$LN18@FindPathTo:
  000e1	0f b6 c0	 movzx	 eax, al

; 108  : 
; 109  : 	if (bPathFound )

  000e4	85 c0		 test	 eax, eax
  000e6	0f 84 d2 01 00
	00		 je	 $LN6@FindPathTo

; 110  : 	{
; 111  : 		lpObj->m_LastMoveTime = GetTickCount();

  000ec	53		 push	 ebx
  000ed	57		 push	 edi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 112  : 
; 113  : 		int iTargetX;
; 114  : 		int iTargetY;
; 115  : 		int iStartX;
; 116  : 		int iStartY;
; 117  : 		int iResultX;
; 118  : 		int iResultY;
; 119  : 		BYTE btTargetDir = 0;
; 120  : 
; 121  : 		iStartX = lpObj->X;
; 122  : 		iStartY = lpObj->Y;

  000f4	0f b7 8e 46 01
	00 00		 movzx	 ecx, WORD PTR [esi+326]

; 123  : 		iResultX = lpObj->X;
; 124  : 		iResultY = lpObj->Y;
; 125  : 		lpObj->PathCount = Path.PathNum;

  000fb	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _Path$[ebp]
  00101	89 86 68 03 00
	00		 mov	 DWORD PTR [esi+872], eax
  00107	0f b7 86 44 01
	00 00		 movzx	 eax, WORD PTR [esi+324]
  0010e	0f bf d8	 movsx	 ebx, ax
  00111	0f bf d1	 movsx	 edx, cx
  00114	89 be 84 01 00
	00		 mov	 DWORD PTR [esi+388], edi

; 126  : 		lpObj->PathCur = 1;
; 127  : 		lpObj->PathStartEnd = 1;
; 128  : 
; 129  : 		if ( lpObj->PathCount > iMaxPathCount )

  0011a	8b 7d 14	 mov	 edi, DWORD PTR _iMaxPathCount$[ebp]
  0011d	89 9d 6c ff ff
	ff		 mov	 DWORD PTR tv297[ebp], ebx
  00123	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv293[ebp], edx
  00129	89 9d 78 ff ff
	ff		 mov	 DWORD PTR _iResultX$209534[ebp], ebx
  0012f	89 95 74 ff ff
	ff		 mov	 DWORD PTR _iResultY$209535[ebp], edx
  00135	c7 86 88 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+392], 1
  0013f	c6 86 8c 01 00
	00 01		 mov	 BYTE PTR [esi+396], 1
  00146	39 bd 7c ff ff
	ff		 cmp	 DWORD PTR _Path$[ebp], edi
  0014c	7e 06		 jle	 SHORT $LN5@FindPathTo

; 130  : 			lpObj->PathCount = iMaxPathCount;

  0014e	89 be 84 01 00
	00		 mov	 DWORD PTR [esi+388], edi
$LN5@FindPathTo:

; 131  : 
; 132  : 		lpObj->PathX[0] = lpObj->X;

  00154	66 89 86 ac 01
	00 00		 mov	 WORD PTR [esi+428], ax

; 133  : 		lpObj->PathY[0] = lpObj->Y;
; 134  : 		lpObj->PathDir[0] = lpObj->Dir;

  0015b	8a 86 48 01 00
	00		 mov	 al, BYTE PTR [esi+328]

; 135  : 
; 136  : 		for(int n=1;n<lpObj->PathCount;n++)

  00161	bf 01 00 00 00	 mov	 edi, 1
  00166	66 89 8e ca 01
	00 00		 mov	 WORD PTR [esi+458], cx
  0016d	88 86 e8 01 00
	00		 mov	 BYTE PTR [esi+488], al
  00173	39 be 84 01 00
	00		 cmp	 DWORD PTR [esi+388], edi
  00179	0f 8e 8e 00 00
	00		 jle	 $LN17@FindPathTo

; 131  : 
; 132  : 		lpObj->PathX[0] = lpObj->X;

  0017f	8d 9e cc 01 00
	00		 lea	 ebx, DWORD PTR [esi+460]
  00185	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL16@FindPathTo:

; 137  : 		{
; 138  : 			iTargetX = Path.PathX[n];
; 139  : 			iTargetY = Path.PathY[n];

  00190	8b 4c bd bc	 mov	 ecx, DWORD PTR _Path$[ebp+edi*4+64]
  00194	8b 44 bd 80	 mov	 eax, DWORD PTR _Path$[ebp+edi*4+4]
  00198	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _iTargetY$209531[ebp], ecx
  0019e	89 85 60 ff ff
	ff		 mov	 DWORD PTR _iTargetX$209530[ebp], eax

; 140  : 			btTargetDir = GetPathPacketDirPos(iTargetX-iStartX, iTargetY-iStartY);

  001a4	2b 85 6c ff ff
	ff		 sub	 eax, DWORD PTR tv297[ebp]
  001aa	2b ca		 sub	 ecx, edx
  001ac	51		 push	 ecx
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 141  : 			lpObj->PathX[n] = iTargetX;

  001b3	66 8b 8d 60 ff
	ff ff		 mov	 cx, WORD PTR _iTargetX$209530[ebp]

; 142  : 			lpObj->PathY[n] = iTargetY;

  001ba	66 8b 95 68 ff
	ff ff		 mov	 dx, WORD PTR _iTargetY$209531[ebp]
  001c1	66 89 13	 mov	 WORD PTR [ebx], dx
  001c4	66 89 4b e2	 mov	 WORD PTR [ebx-30], cx

; 143  : 			lpObj->PathDir[n] = btTargetDir;

  001c8	88 84 3e e8 01
	00 00		 mov	 BYTE PTR [esi+edi+488], al

; 144  : 			iResultX += RoadPathTable[btTargetDir*2];

  001cf	0f b6 c0	 movzx	 eax, al
  001d2	03 c0		 add	 eax, eax

; 145  : 			iResultY += RoadPathTable[btTargetDir*2+1];

  001d4	0f bf 94 00 02
	00 00 00	 movsx	 edx, WORD PTR ?RoadPathTable@@3PAFA[eax+eax+2]
  001dc	0f bf 8c 00 00
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax+eax]
  001e4	01 95 74 ff ff
	ff		 add	 DWORD PTR _iResultY$209535[ebp], edx
  001ea	01 8d 78 ff ff
	ff		 add	 DWORD PTR _iResultX$209534[ebp], ecx
  001f0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv293[ebp]
  001f6	03 c0		 add	 eax, eax
  001f8	47		 inc	 edi
  001f9	83 c4 08	 add	 esp, 8
  001fc	83 c3 02	 add	 ebx, 2
  001ff	3b be 84 01 00
	00		 cmp	 edi, DWORD PTR [esi+388]
  00205	7c 89		 jl	 SHORT $LL16@FindPathTo

; 135  : 
; 136  : 		for(int n=1;n<lpObj->PathCount;n++)

  00207	8b 9d 6c ff ff
	ff		 mov	 ebx, DWORD PTR tv297[ebp]
$LN17@FindPathTo:

; 146  : 		}
; 147  : 
; 148  : 		lpObj->MTX = iResultX;
; 149  : 		lpObj->MTY = iResultY;
; 150  : 		lpObj->TX = iResultX;
; 151  : 		lpObj->TY = iResultY;
; 152  : 
; 153  : 		if ( lpObj->PathCount > 0 )

  0020d	83 be 84 01 00
	00 00		 cmp	 DWORD PTR [esi+388], 0
  00214	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _iResultX$209534[ebp]
  0021a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iResultY$209535[ebp]
  00220	66 89 86 80 01
	00 00		 mov	 WORD PTR [esi+384], ax
  00227	66 89 8e 82 01
	00 00		 mov	 WORD PTR [esi+386], cx
  0022e	66 89 86 7c 01
	00 00		 mov	 WORD PTR [esi+380], ax
  00235	66 89 8e 7e 01
	00 00		 mov	 WORD PTR [esi+382], cx
  0023c	7e 5c		 jle	 SHORT $LN1@FindPathTo

; 154  : 		{
; 155  : 			MapC[lpObj->MapNumber].ClearStandAttr(iStartX, iStartY);

  0023e	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00245	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0024b	52		 push	 edx
  0024c	53		 push	 ebx
  0024d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00253	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 156  : 			MapC[lpObj->MapNumber].SetStandAttr(iResultX, iResultY);

  00258	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _iResultY$209535[ebp]
  0025e	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _iResultX$209534[ebp]
  00264	50		 push	 eax
  00265	51		 push	 ecx
  00266	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  0026d	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00273	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00279	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 157  : 			lpObj->m_OldX = iStartX;

  0027e	66 8b 95 6c ff
	ff ff		 mov	 dx, WORD PTR tv297[ebp]

; 158  : 			lpObj->m_OldY = iStartY;

  00285	66 8b 85 70 ff
	ff ff		 mov	 ax, WORD PTR tv293[ebp]
  0028c	66 89 96 78 01
	00 00		 mov	 WORD PTR [esi+376], dx
  00293	66 89 86 7a 01
	00 00		 mov	 WORD PTR [esi+378], ax
$LN1@FindPathTo:

; 159  : 		}
; 160  : 
; 161  : 		this->SendMonsterMoveMsg(lpObj);

  0029a	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002a0	56		 push	 esi
  002a1	e8 00 00 00 00	 call	 ?SendMonsterMoveMsg@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@@Z ; TMonsterAIUtil::SendMonsterMoveMsg
  002a6	5f		 pop	 edi
  002a7	5b		 pop	 ebx

; 162  : 		return TRUE;

  002a8	b8 01 00 00 00	 mov	 eax, 1
  002ad	5e		 pop	 esi

; 163  : 	}
; 164  : 
; 165  : 	return FALSE;
; 166  : }

  002ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b1	33 cd		 xor	 ecx, ebp
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c2 14 00	 ret	 20			; 00000014H
$LN6@FindPathTo:
  002be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c1	33 cd		 xor	 ecx, ebp
  002c3	33 c0		 xor	 eax, eax
  002c5	5e		 pop	 esi
  002c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cb	8b e5		 mov	 esp, ebp
  002cd	5d		 pop	 ebp
  002ce	c2 14 00	 ret	 20			; 00000014H
?FindPathToMoveMonster@TMonsterAIUtil@@QAEHPAUOBJECTSTRUCT@@HHHH@Z ENDP ; TMonsterAIUtil::FindPathToMoveMonster
_TEXT	ENDS
END
