; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\TMonsterSkillManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_bDataLoad@TMonsterSkillManager@@2HA		; TMonsterSkillManager::s_bDataLoad
_BSS	SEGMENT
?s_bDataLoad@TMonsterSkillManager@@2HA DD 01H DUP (?)	; TMonsterSkillManager::s_bDataLoad
_BSS	ENDS
PUBLIC	?Reset@TMonsterSkillInfo@@QAEXXZ		; TMonsterSkillInfo::Reset
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterskillinfo.h
;	COMDAT ?Reset@TMonsterSkillInfo@@QAEXXZ
_TEXT	SEGMENT
?Reset@TMonsterSkillInfo@@QAEXXZ PROC			; TMonsterSkillInfo::Reset, COMDAT
; _this$ = ecx

; 26   : 		this->m_iMonsterIndex = -1;

  00000	83 ca ff	 or	 edx, -1
  00003	89 11		 mov	 DWORD PTR [ecx], edx

; 27   : 		this->m_iSkillUnitCount = 0;

  00005	33 c0		 xor	 eax, eax
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 28   : 
; 29   : 		for ( int i=0;i<10;i++)
; 30   : 		{
; 31   : 			this->m_iSkillUnitTypeArray[i] = -1;

  0000a	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 32   : 			this->m_lpSkillUnitArray[i] = NULL;

  0000d	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00010	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00013	89 41 34	 mov	 DWORD PTR [ecx+52], eax
  00016	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00019	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0001c	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  0001f	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  00022	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  00025	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  00028	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  0002b	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  0002e	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00031	89 41 48	 mov	 DWORD PTR [ecx+72], eax
  00034	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00037	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  0003a	89 51 28	 mov	 DWORD PTR [ecx+40], edx
  0003d	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00040	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00043	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 33   : 		}
; 34   : 	}

  00046	c3		 ret	 0
?Reset@TMonsterSkillInfo@@QAEXXZ ENDP			; TMonsterSkillInfo::Reset
_TEXT	ENDS
PUBLIC	?IsValid@TMonsterSkillInfo@@QAEHXZ		; TMonsterSkillInfo::IsValid
; Function compile flags: /Ogtp
;	COMDAT ?IsValid@TMonsterSkillInfo@@QAEHXZ
_TEXT	SEGMENT
?IsValid@TMonsterSkillInfo@@QAEHXZ PROC			; TMonsterSkillInfo::IsValid, COMDAT
; _this$ = ecx

; 38   : 		if ( this->m_iMonsterIndex == -1 || this->m_iSkillUnitCount == 0 )

  00000	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00003	74 0c		 je	 SHORT $LN1@IsValid
  00005	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00009	74 06		 je	 SHORT $LN1@IsValid

; 40   : 
; 41   : 		return TRUE;

  0000b	b8 01 00 00 00	 mov	 eax, 1

; 42   : 	}

  00010	c3		 ret	 0
$LN1@IsValid:

; 39   : 			return FALSE;

  00011	33 c0		 xor	 eax, eax

; 42   : 	}

  00013	c3		 ret	 0
?IsValid@TMonsterSkillInfo@@QAEHXZ ENDP			; TMonsterSkillInfo::IsValid
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ	; _ST_MONSTER_SKILL_DELAYTIME_INFO::RESET
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterskillmanager.h
;	COMDAT ?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ
_TEXT	SEGMENT
?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ PROC	; _ST_MONSTER_SKILL_DELAYTIME_INFO::RESET, COMDAT
; _this$ = ecx

; 15   : 		this->iIndex = -1;

  00000	83 c8 ff	 or	 eax, -1
  00003	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 16   : 		this->iTargetIndex = -1;

  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 17   : 		this->dwDelayTime = 0;

  00009	33 c0		 xor	 eax, eax
  0000b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 18   : 		this->bIsUsed = FALSE;

  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 19   : 		this->lpMonsterSkillUnit = NULL;

  00010	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 20   : 	}

  00013	c3		 ret	 0
?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ ENDP	; _ST_MONSTER_SKILL_DELAYTIME_INFO::RESET
_TEXT	ENDS
PUBLIC	?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ ; _ST_MONSTER_SKILL_DELAYTIME_INFO::IsValid
; Function compile flags: /Ogtp
;	COMDAT ?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ
_TEXT	SEGMENT
?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ PROC	; _ST_MONSTER_SKILL_DELAYTIME_INFO::IsValid, COMDAT
; _this$ = ecx

; 25   : 		if ( !OBJMAX_RANGE(this->iIndex) || !OBJMAX_RANGE(this->iTargetIndex) )

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	78 30		 js	 SHORT $LN2@IsValid@2
  00007	33 d2		 xor	 edx, edx
  00009	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  0000e	0f 9e c2	 setle	 dl
  00011	8b c2		 mov	 eax, edx
  00013	85 c0		 test	 eax, eax
  00015	74 20		 je	 SHORT $LN2@IsValid@2
  00017	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001a	85 c0		 test	 eax, eax
  0001c	78 19		 js	 SHORT $LN2@IsValid@2
  0001e	33 d2		 xor	 edx, edx
  00020	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00025	0f 9e c2	 setle	 dl
  00028	8b c2		 mov	 eax, edx
  0002a	85 c0		 test	 eax, eax
  0002c	74 09		 je	 SHORT $LN2@IsValid@2

; 27   : 
; 28   : 		if ( this->lpMonsterSkillUnit == NULL )

  0002e	33 c0		 xor	 eax, eax
  00030	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00033	0f 95 c0	 setne	 al

; 29   : 			return FALSE;
; 30   : 
; 31   : 		return TRUE;
; 32   : 	}

  00036	c3		 ret	 0
$LN2@IsValid@2:

; 26   : 			return FALSE;

  00037	33 c0		 xor	 eax, eax

; 29   : 			return FALSE;
; 30   : 
; 31   : 		return TRUE;
; 32   : 	}

  00039	c3		 ret	 0
?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ ENDP	; _ST_MONSTER_SKILL_DELAYTIME_INFO::IsValid
_TEXT	ENDS
PUBLIC	??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ	; _ST_MONSTER_SKILL_DELAYTIME_INFO::_ST_MONSTER_SKILL_DELAYTIME_INFO
; Function compile flags: /Ogtp
;	COMDAT ??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ
_TEXT	SEGMENT
??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ PROC	; _ST_MONSTER_SKILL_DELAYTIME_INFO::_ST_MONSTER_SKILL_DELAYTIME_INFO, COMDAT
; _this$ = ecx

; 34   : 	_ST_MONSTER_SKILL_DELAYTIME_INFO()

  00000	8b c1		 mov	 eax, ecx

; 35   : 	{
; 36   : 		this->RESET();

  00002	83 c9 ff	 or	 ecx, -1
  00005	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00008	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000b	33 c9		 xor	 ecx, ecx
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00010	89 08		 mov	 DWORD PTR [eax], ecx
  00012	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 37   : 	}

  00015	c3		 ret	 0
??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ ENDP	; _ST_MONSTER_SKILL_DELAYTIME_INFO::_ST_MONSTER_SKILL_DELAYTIME_INFO
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??0TMonsterSkillManager@@QAE@XZ			; TMonsterSkillManager::TMonsterSkillManager
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterskillmanager.cpp
;	COMDAT ??0TMonsterSkillManager@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterSkillManager@@QAE@XZ PROC			; TMonsterSkillManager::TMonsterSkillManager, COMDAT
; _this$ = ecx

; 17   : {

  00000	8b c1		 mov	 eax, ecx

; 18   : 	return;
; 19   : }

  00002	c3		 ret	 0
??0TMonsterSkillManager@@QAE@XZ ENDP			; TMonsterSkillManager::TMonsterSkillManager
_TEXT	ENDS
PUBLIC	??1TMonsterSkillManager@@QAE@XZ			; TMonsterSkillManager::~TMonsterSkillManager
; Function compile flags: /Ogtp
;	COMDAT ??1TMonsterSkillManager@@QAE@XZ
_TEXT	SEGMENT
??1TMonsterSkillManager@@QAE@XZ PROC			; TMonsterSkillManager::~TMonsterSkillManager, COMDAT
; _this$ = ecx

; 23   : 	return;
; 24   : }

  00000	c3		 ret	 0
??1TMonsterSkillManager@@QAE@XZ ENDP			; TMonsterSkillManager::~TMonsterSkillManager
_TEXT	ENDS
PUBLIC	?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ ; TMonsterSkillManager::DelAllSkillManagerInfo
; Function compile flags: /Ogtp
;	COMDAT ?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ
_TEXT	SEGMENT
?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ PROC ; TMonsterSkillManager::DelAllSkillManagerInfo, COMDAT

; 152  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 153  : 	for ( int i=0;i<MAX_MONSTER_SKILL_INFO_ARRAY;i++)

  00002	83 ce ff	 or	 esi, -1
  00005	ba 30 00 00 00	 mov	 edx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A+48
  0000a	33 ff		 xor	 edi, edi
  0000c	8d 64 24 00	 npad	 4
$LL6@DelAllSkil:

; 154  : 	{
; 155  : 		TMonsterSkillManager::s_MonsterSkillInfoArray[i].Reset();

  00010	89 72 d0	 mov	 DWORD PTR [edx-48], esi
  00013	89 7a d4	 mov	 DWORD PTR [edx-44], edi
  00016	8b c2		 mov	 eax, edx
  00018	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0001d	8d 49 00	 npad	 3
$LL11@DelAllSkil:
  00020	89 70 d8	 mov	 DWORD PTR [eax-40], esi
  00023	89 38		 mov	 DWORD PTR [eax], edi
  00025	83 c0 04	 add	 eax, 4
  00028	49		 dec	 ecx
  00029	75 f5		 jne	 SHORT $LL11@DelAllSkil

; 153  : 	for ( int i=0;i<MAX_MONSTER_SKILL_INFO_ARRAY;i++)

  0002b	83 c2 58	 add	 edx, 88			; 00000058H
  0002e	81 fa d0 f0 00
	00		 cmp	 edx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A+61648
  00034	7c da		 jl	 SHORT $LL6@DelAllSkil

; 156  : 	}
; 157  : 
; 158  : 	for ( int j=0;j<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;j++)

  00036	b8 08 00 00 00	 mov	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+8
  0003b	eb 03 8d 49 00	 npad	 5
$LL3@DelAllSkil:

; 159  : 	{
; 160  : 		TMonsterSkillManager::s_MonsterSkillDelayInfoArray[j].RESET();

  00040	89 70 fc	 mov	 DWORD PTR [eax-4], esi
  00043	89 30		 mov	 DWORD PTR [eax], esi
  00045	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00048	89 78 f8	 mov	 DWORD PTR [eax-8], edi
  0004b	89 78 08	 mov	 DWORD PTR [eax+8], edi
  0004e	83 c0 14	 add	 eax, 20			; 00000014H
  00051	3d 68 ea 00 00	 cmp	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+60008
  00056	7c e8		 jl	 SHORT $LL3@DelAllSkil

; 161  : 	}
; 162  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	c3		 ret	 0
?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ ENDP ; TMonsterSkillManager::DelAllSkillManagerInfo
_TEXT	ENDS
PUBLIC	?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z	; TMonsterSkillManager::CheckMonsterSkill
; Function compile flags: /Ogtp
;	COMDAT ?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z
_TEXT	SEGMENT
_iMonsterClass$ = 8					; size = 4
?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z PROC	; TMonsterSkillManager::CheckMonsterSkill, COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	if ( iMonsterClass < 0 || iMonsterClass > MAX_MONSTER_SKILL_INFO_ARRAY )	// #error Change to MAX_MONSTER_SKILL_INFO_ARRAY-1

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMonsterClass$[ebp]
  00006	3d bc 02 00 00	 cmp	 eax, 700		; 000002bcH
  0000b	77 1a		 ja	 SHORT $LN2@CheckMonst

; 168  : 
; 169  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[iMonsterClass];

  0000d	6b c0 58	 imul	 eax, 88			; 00000058H
  00010	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray

; 170  : 
; 171  : 	if ( lpMonsterSkillInfo->IsValid() == FALSE )

  00015	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00018	74 0d		 je	 SHORT $LN2@CheckMonst
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0

; 172  : 		return FALSE;

  0001e	74 07		 je	 SHORT $LN2@CheckMonst

; 173  : 
; 174  : 	return TRUE;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 175  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@CheckMonst:

; 167  : 		return FALSE;

  00027	33 c0		 xor	 eax, eax

; 175  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z ENDP	; TMonsterSkillManager::CheckMonsterSkill
_TEXT	ENDS
PUBLIC	??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@ ; `string'
PUBLIC	?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z ; TMonsterSkillManager::AddMonsterSkillDelayInfo
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@
CONST	SEGMENT
??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@ DB '[M'
	DB	'onster Skill Manager] - (MonsterSkillDelayInfo) Slot Full!! ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iTargetIndex$ = 12					; size = 4
_iDelayTime$ = 16					; size = 4
_lpMonsterSkillUnit$ = 20				; size = 4
?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z PROC ; TMonsterSkillManager::AddMonsterSkillDelayInfo, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  : 	for ( int i=0;i<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;i++)

  00003	33 c9		 xor	 ecx, ecx
  00005	b8 00 00 00 00	 mov	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@AddMonster:

; 181  : 	{
; 182  : 		if ( TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].bIsUsed == FALSE )

  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 1f		 je	 SHORT $LN8@AddMonster

; 180  : 	for ( int i=0;i<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;i++)

  00015	83 c0 14	 add	 eax, 20			; 00000014H
  00018	41		 inc	 ecx
  00019	3d 60 ea 00 00	 cmp	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+60000
  0001e	7c f0		 jl	 SHORT $LL4@AddMonster

; 191  : 		}
; 192  : 	}
; 193  : 
; 194  : 	LogAddC(2, "[Monster Skill Manager] - (MonsterSkillDelayInfo) Slot Full!! ");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@
  00025	6a 02		 push	 2
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002d	83 c4 08	 add	 esp, 8

; 195  : 	return FALSE;

  00030	33 c0		 xor	 eax, eax

; 196  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN8@AddMonster:

; 183  : 		{
; 184  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].iIndex = iIndex;

  00034	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00037	56		 push	 esi
  00038	8d 34 89	 lea	 esi, DWORD PTR [ecx+ecx*4]

; 185  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].iTargetIndex = iTargetIndex;

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _iTargetIndex$[ebp]
  0003e	03 f6		 add	 esi, esi
  00040	03 f6		 add	 esi, esi
  00042	89 86 04 00 00
	00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi+4], eax
  00048	89 8e 08 00 00
	00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi+8], ecx

; 186  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].dwDelayTime = GetTickCount() + iDelayTime;

  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00054	03 45 10	 add	 eax, DWORD PTR _iDelayTime$[ebp]

; 187  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].lpMonsterSkillUnit = lpMonsterSkillUnit;

  00057	8b 55 14	 mov	 edx, DWORD PTR _lpMonsterSkillUnit$[ebp]
  0005a	89 86 0c 00 00
	00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi+12], eax
  00060	89 96 10 00 00
	00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi+16], edx

; 188  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].bIsUsed = TRUE;

  00066	c7 86 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi], 1

; 189  : 
; 190  : 			return TRUE;

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	5e		 pop	 esi

; 196  : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z ENDP ; TMonsterSkillManager::AddMonsterSkillDelayInfo
_TEXT	ENDS
PUBLIC	?MonsterSkillProc@TMonsterSkillManager@@SAXXZ	; TMonsterSkillManager::MonsterSkillProc
EXTRN	?RunSkill@TMonsterSkillUnit@@QAEXHH@Z:PROC	; TMonsterSkillUnit::RunSkill
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?MonsterSkillProc@TMonsterSkillManager@@SAXXZ
_TEXT	SEGMENT
_lpTargetObj$203065 = -8				; size = 4
_dwCurrentTick$ = -4					; size = 4
?MonsterSkillProc@TMonsterSkillManager@@SAXXZ PROC	; TMonsterSkillManager::MonsterSkillProc, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 202  : 	DWORD dwCurrentTick = GetTickCount();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	89 45 fc	 mov	 DWORD PTR _dwCurrentTick$[ebp], eax
  00012	be 08 00 00 00	 mov	 esi, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+8
  00017	33 db		 xor	 ebx, ebx
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL33@MonsterSki:

; 205  : 	{
; 206  : 		if ( TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].bIsUsed == TRUE )

  00020	83 7e f8 01	 cmp	 DWORD PTR [esi-8], 1
  00024	0f 85 a8 00 00
	00		 jne	 $LN8@MonsterSki

; 207  : 		{
; 208  : 			if ( dwCurrentTick < TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].dwDelayTime )

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _dwCurrentTick$[ebp]
  0002d	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00030	0f 83 9c 00 00
	00		 jae	 $LN8@MonsterSki

; 209  : 			{
; 210  : 				_ST_MONSTER_SKILL_DELAYTIME_INFO & stInfo = TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i];
; 211  : 
; 212  : 				if ( !stInfo.IsValid() )

  00036	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00039	3b cb		 cmp	 ecx, ebx
  0003b	7c 7f		 jl	 SHORT $LN2@MonsterSki
  0003d	33 c0		 xor	 eax, eax
  0003f	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00045	0f 9e c0	 setle	 al
  00048	3b c3		 cmp	 eax, ebx
  0004a	74 70		 je	 SHORT $LN2@MonsterSki
  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	3b c3		 cmp	 eax, ebx
  00050	7c 6a		 jl	 SHORT $LN2@MonsterSki
  00052	33 d2		 xor	 edx, edx
  00054	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00059	0f 9e c2	 setle	 dl
  0005c	3b d3		 cmp	 edx, ebx
  0005e	74 5c		 je	 SHORT $LN2@MonsterSki
  00060	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx

; 213  : 				{
; 214  : 					TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();
; 215  : 					continue;

  00063	74 57		 je	 SHORT $LN2@MonsterSki

; 216  : 				}
; 217  : 
; 218  : 				LPOBJ lpObj = &gObj[stInfo.iIndex];

  00065	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H

; 219  : 				LPOBJ lpTargetObj = &gObj[stInfo.iTargetIndex];

  0006b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00071	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00077	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007d	8b f9		 mov	 edi, ecx
  0007f	89 45 f8	 mov	 DWORD PTR _lpTargetObj$203065[ebp], eax

; 220  : 
; 221  : 				if ( !lpObj->Live || !lpTargetObj->Live )

  00082	38 5f 6a	 cmp	 BYTE PTR [edi+106], bl
  00085	74 35		 je	 SHORT $LN2@MonsterSki
  00087	38 58 6a	 cmp	 BYTE PTR [eax+106], bl
  0008a	74 30		 je	 SHORT $LN2@MonsterSki

; 224  : 					continue;
; 225  : 				}
; 226  : 
; 227  : 				if ( !gObjIsConnected(lpTargetObj))

  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00092	83 c4 04	 add	 esp, 4
  00095	85 c0		 test	 eax, eax

; 228  : 				{
; 229  : 					TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();
; 230  : 					continue;

  00097	74 23		 je	 SHORT $LN2@MonsterSki

; 231  : 				}
; 232  : 
; 233  : 				gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0,0,0);

  00099	8b 4d f8	 mov	 ecx, DWORD PTR _lpTargetObj$203065[ebp]
  0009c	53		 push	 ebx
  0009d	53		 push	 ebx
  0009e	53		 push	 ebx
  0009f	53		 push	 ebx
  000a0	53		 push	 ebx
  000a1	53		 push	 ebx
  000a2	53		 push	 ebx
  000a3	51		 push	 ecx
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack

; 234  : 				stInfo.lpMonsterSkillUnit->RunSkill(stInfo.iIndex, stInfo.iTargetIndex);

  000aa	8b 16		 mov	 edx, DWORD PTR [esi]
  000ac	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  000af	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b2	83 c4 24	 add	 esp, 36			; 00000024H
  000b5	52		 push	 edx
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?RunSkill@TMonsterSkillUnit@@QAEXHH@Z ; TMonsterSkillUnit::RunSkill
$LN2@MonsterSki:

; 222  : 				{
; 223  : 					TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();

  000bc	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  000bf	89 5e f8	 mov	 DWORD PTR [esi-8], ebx
  000c2	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  000c5	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
  000cb	c7 46 fc ff ff
	ff ff		 mov	 DWORD PTR [esi-4], -1
$LN8@MonsterSki:

; 203  : 
; 204  : 	for ( int i=0;i<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;i++)

  000d2	83 c6 14	 add	 esi, 20			; 00000014H
  000d5	81 fe 68 ea 00
	00		 cmp	 esi, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+60008
  000db	0f 8c 3f ff ff
	ff		 jl	 $LL33@MonsterSki
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 235  : 				TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();
; 236  : 			}
; 237  : 		}
; 238  : 	}
; 239  : }

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?MonsterSkillProc@TMonsterSkillManager@@SAXXZ ENDP	; TMonsterSkillManager::MonsterSkillProc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z ; TMonsterSkillManager::FindMonsterSkillUnit
EXTRN	_rand:PROC
; Function compile flags: /Ogtp
;	COMDAT ?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z
_TEXT	SEGMENT
_iFoundSkillArray$ = -44				; size = 40
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iMonsterSkillUnitType$ = 12				; size = 4
?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z PROC ; TMonsterSkillManager::FindMonsterSkillUnit, COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 244  : 	LPOBJ lpObj = &gObj[iIndex];

  00010	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]

; 245  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[lpObj->Class];

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0001f	57		 push	 edi
  00020	0f b7 bc 08 b8
	00 00 00	 movzx	 edi, WORD PTR [eax+ecx+184]
  00028	6b ff 58	 imul	 edi, 88			; 00000058H
  0002b	81 c7 00 00 00
	00		 add	 edi, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray

; 246  : 
; 247  : 	if ( lpMonsterSkillInfo->IsValid() == FALSE )

  00031	83 3f ff	 cmp	 DWORD PTR [edi], -1
  00034	74 06		 je	 SHORT $LN10@FindMonste
  00036	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003a	75 11		 jne	 SHORT $LN7@FindMonste
$LN10@FindMonste:

; 248  : 		return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	5f		 pop	 edi

; 272  : 	}
; 273  : 	
; 274  : 	return NULL;
; 275  : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN7@FindMonste:

; 249  : 
; 250  : 	int iFoundSkillArray[10] = {-1};

  0004d	33 c0		 xor	 eax, eax
  0004f	89 45 d8	 mov	 DWORD PTR _iFoundSkillArray$[ebp+4], eax
  00052	89 45 dc	 mov	 DWORD PTR _iFoundSkillArray$[ebp+8], eax
  00055	89 45 e0	 mov	 DWORD PTR _iFoundSkillArray$[ebp+12], eax
  00058	89 45 e4	 mov	 DWORD PTR _iFoundSkillArray$[ebp+16], eax
  0005b	89 45 e8	 mov	 DWORD PTR _iFoundSkillArray$[ebp+20], eax
  0005e	89 45 ec	 mov	 DWORD PTR _iFoundSkillArray$[ebp+24], eax
  00061	89 45 f0	 mov	 DWORD PTR _iFoundSkillArray$[ebp+28], eax
  00064	89 45 f4	 mov	 DWORD PTR _iFoundSkillArray$[ebp+32], eax
  00067	89 45 f8	 mov	 DWORD PTR _iFoundSkillArray$[ebp+36], eax

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  0006a	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterSkillUnitType$[ebp]
  0006d	56		 push	 esi
  0006e	33 f6		 xor	 esi, esi
  00070	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _iFoundSkillArray$[ebp], -1
  00077	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0007a	75 08		 jne	 SHORT $LN5@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  0007c	89 75 d4	 mov	 DWORD PTR _iFoundSkillArray$[ebp], esi

; 258  : 			iFoundSkillCount++;

  0007f	be 01 00 00 00	 mov	 esi, 1
$LN5@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  00084	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00087	75 09		 jne	 SHORT $LN20@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  00089	c7 44 b5 d4 01
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 1

; 258  : 			iFoundSkillCount++;

  00091	46		 inc	 esi
$LN20@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  00092	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00095	75 09		 jne	 SHORT $LN22@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  00097	c7 44 b5 d4 02
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 2

; 258  : 			iFoundSkillCount++;

  0009f	46		 inc	 esi
$LN22@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000a0	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  000a3	75 09		 jne	 SHORT $LN24@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000a5	c7 44 b5 d4 03
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 3

; 258  : 			iFoundSkillCount++;

  000ad	46		 inc	 esi
$LN24@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000ae	3b 47 18	 cmp	 eax, DWORD PTR [edi+24]
  000b1	75 09		 jne	 SHORT $LN26@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000b3	c7 44 b5 d4 04
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 4

; 258  : 			iFoundSkillCount++;

  000bb	46		 inc	 esi
$LN26@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000bc	3b 47 1c	 cmp	 eax, DWORD PTR [edi+28]
  000bf	75 09		 jne	 SHORT $LN28@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000c1	c7 44 b5 d4 05
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 5

; 258  : 			iFoundSkillCount++;

  000c9	46		 inc	 esi
$LN28@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000ca	3b 47 20	 cmp	 eax, DWORD PTR [edi+32]
  000cd	75 09		 jne	 SHORT $LN30@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000cf	c7 44 b5 d4 06
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 6

; 258  : 			iFoundSkillCount++;

  000d7	46		 inc	 esi
$LN30@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000d8	3b 47 24	 cmp	 eax, DWORD PTR [edi+36]
  000db	75 09		 jne	 SHORT $LN32@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000dd	c7 44 b5 d4 07
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 7

; 258  : 			iFoundSkillCount++;

  000e5	46		 inc	 esi
$LN32@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000e6	3b 47 28	 cmp	 eax, DWORD PTR [edi+40]
  000e9	75 09		 jne	 SHORT $LN34@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000eb	c7 44 b5 d4 08
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 8

; 258  : 			iFoundSkillCount++;

  000f3	46		 inc	 esi
$LN34@FindMonste:

; 251  : 	int iFoundSkillCount = 0;
; 252  : 
; 253  : 	for(int i=0;i<10;i++)
; 254  : 	{
; 255  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000f4	3b 47 2c	 cmp	 eax, DWORD PTR [edi+44]
  000f7	75 09		 jne	 SHORT $LN36@FindMonste

; 256  : 		{
; 257  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000f9	c7 44 b5 d4 09
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 9

; 258  : 			iFoundSkillCount++;

  00101	46		 inc	 esi
$LN36@FindMonste:

; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	if ( iFoundSkillCount > 0 )

  00102	85 f6		 test	 esi, esi
  00104	7e 25		 jle	 SHORT $LN2@FindMonste

; 263  : 	{
; 264  : 		int iSlot = iFoundSkillArray[rand() % iFoundSkillCount];

  00106	e8 00 00 00 00	 call	 _rand
  0010b	99		 cdq
  0010c	f7 fe		 idiv	 esi
  0010e	8b 54 95 d4	 mov	 edx, DWORD PTR _iFoundSkillArray$[ebp+edx*4]

; 265  : 
; 266  : 		if ( iSlot == -1 )

  00112	83 fa ff	 cmp	 edx, -1

; 267  : 			return NULL;

  00115	74 14		 je	 SHORT $LN2@FindMonste

; 268  : 
; 269  : 		TMonsterSkillUnit * lpMonsterSkillUnit = lpMonsterSkillInfo->m_lpSkillUnitArray[iSlot];
; 270  : 		
; 271  : 		return lpMonsterSkillUnit;

  00117	8b 44 97 30	 mov	 eax, DWORD PTR [edi+edx*4+48]
  0011b	5e		 pop	 esi
  0011c	5f		 pop	 edi

; 272  : 	}
; 273  : 	
; 274  : 	return NULL;
; 275  : }

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00120	33 cd		 xor	 ecx, ebp
  00122	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
$LN2@FindMonste:
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	5e		 pop	 esi
  0012f	33 cd		 xor	 ecx, ebp
  00131	33 c0		 xor	 eax, eax
  00133	5f		 pop	 edi
  00134	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z ENDP ; TMonsterSkillManager::FindMonsterSkillUnit
_TEXT	ENDS
PUBLIC	??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ ; `string'
PUBLIC	??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ ; `string'
PUBLIC	??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@ ; `string'
PUBLIC	?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z ; TMonsterSkillManager::UseMonsterSkill
EXTRN	?HitCheck@CSkillHitBox@@QAEHHHHHH@Z:PROC	; CSkillHitBox::HitCheck
EXTRN	?SkillElectricSparkHitBox@@3VCSkillHitBox@@A:BYTE ; SkillElectricSparkHitBox
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?GetAngle@CObjUseSkill@@QAEHHHHH@Z:PROC		; CObjUseSkill::GetAngle
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z:PROC ; GCUseMonsterSkillSend
;	COMDAT ??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
; File e:\work\tranet_version\gs\gameserver\tmonsterskillinfo.h
CONST	SEGMENT
??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ DB '[TMonst'
	DB	'erSkillManager][UserMonsterSkill] error: iIndex(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
CONST	SEGMENT
??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ DB '[TMonst'
	DB	'erSkillManager][UserMonsterSkill] error: iTargetIndex(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@
CONST	SEGMENT
??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@ DB '[Monste'
	DB	'r Skill Manager] SkillUnit is NULL : ObjIndex[%d], SkillUnitT'
	DB	'ype[%d] ', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterskillmanager.cpp
CONST	ENDS
;	COMDAT ?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_iAngle$203121 = -16					; size = 4
tv202 = -12						; size = 4
tv589 = -8						; size = 4
_lpMonsterSkillUnit$ = -4				; size = 4
_iIndex$ = 8						; size = 4
_iTargetIndex$ = 12					; size = 4
_iMonsterSkillUnitType$ = 16				; size = 4
_iMonsterSkillUnit$ = 20				; size = 4
_lpMagic$ = 24						; size = 4
?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z PROC ; TMonsterSkillManager::UseMonsterSkill, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 281  : 	if (iIndex >= OBJ_MAXMONSTER || iIndex < 0)

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	81 fe c7 32 00
	00		 cmp	 esi, 12999		; 000032c7H
  00010	0f 87 b1 02 00
	00		 ja	 $LN39@UseMonster

; 284  : 		return;
; 285  : 	}
; 286  : 
; 287  : 	if (iTargetIndex >= OBJMAX || iTargetIndex < 0)

  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _iTargetIndex$[ebp]
  0001a	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00020	0f 87 8a 02 00
	00		 ja	 $LN37@UseMonster

; 290  : 		return;
; 291  : 	}
; 292  : 
; 293  : 	LPOBJ lpObj = &gObj[iIndex]; //loc1

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H

; 294  : 	LPOBJ lpTargetObj = &gObj[iTargetIndex]; //loc2

  00031	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00037	03 f0		 add	 esi, eax
  00039	03 f8		 add	 edi, eax

; 295  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[lpObj->Class]; //loc3

  0003b	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00042	6b c0 58	 imul	 eax, 88			; 00000058H
  00045	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray

; 296  : 
; 297  : 	if ( lpMonsterSkillInfo->IsValid() == FALSE )

  0004a	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0004d	74 42		 je	 SHORT $LN57@UseMonster
  0004f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00053	74 3c		 je	 SHORT $LN57@UseMonster

; 298  : 		return;
; 299  : 	
; 300  : 	TMonsterSkillUnit * lpMonsterSkillUnit = NULL; //loc4
; 301  : 
; 302  : 	if ( iMonsterSkillUnit > -1) //arg4

  00055	8b 4d 14	 mov	 ecx, DWORD PTR _iMonsterSkillUnit$[ebp]
  00058	53		 push	 ebx
  00059	8b 5d 10	 mov	 ebx, DWORD PTR _iMonsterSkillUnitType$[ebp]
  0005c	83 f9 ff	 cmp	 ecx, -1
  0005f	7e 06		 jle	 SHORT $LN35@UseMonster

; 303  : 	{
; 304  : 		int iMonsterSkill = iMonsterSkillUnit; //loc5
; 305  : 
; 306  : 		lpMonsterSkillUnit = lpMonsterSkillInfo->m_lpSkillUnitArray[iMonsterSkill];

  00061	8b 44 88 30	 mov	 eax, DWORD PTR [eax+ecx*4+48]

; 307  : 	}
; 308  : 	else

  00065	eb 0d		 jmp	 SHORT $LN59@UseMonster
$LN35@UseMonster:

; 309  : 	{
; 310  : 		lpMonsterSkillUnit = TMonsterSkillManager::FindMonsterSkillUnit(iIndex, iMonsterSkillUnitType);

  00067	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0006a	53		 push	 ebx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z ; TMonsterSkillManager::FindMonsterSkillUnit
  00071	83 c4 08	 add	 esp, 8
$LN59@UseMonster:
  00074	89 45 fc	 mov	 DWORD PTR _lpMonsterSkillUnit$[ebp], eax

; 311  : 	}
; 312  : 
; 313  : 	if ( lpMonsterSkillUnit == NULL )

  00077	85 c0		 test	 eax, eax
  00079	75 1c		 jne	 SHORT $LN33@UseMonster

; 314  : 	{
; 315  : 		LogAddC(2, "[Monster Skill Manager] SkillUnit is NULL : ObjIndex[%d], SkillUnitType[%d] ",iIndex,iMonsterSkillUnitType);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0007e	53		 push	 ebx
  0007f	51		 push	 ecx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@
  00085	6a 02		 push	 2
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0008d	83 c4 10	 add	 esp, 16			; 00000010H
  00090	5b		 pop	 ebx
$LN57@UseMonster:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi

; 444  : 				break;
; 445  : 		}
; 446  : 	}
; 447  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$LN33@UseMonster:

; 316  : 		return;
; 317  : 	}
; 318  : 
; 319  : 	GCUseMonsterSkillSend(lpObj, lpTargetObj, lpMonsterSkillUnit->m_iUnitNumber);

  00097	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0009a	52		 push	 edx
  0009b	57		 push	 edi
  0009c	56		 push	 esi
  0009d	e8 00 00 00 00	 call	 ?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ; GCUseMonsterSkillSend

; 320  : 
; 321  : 	//TEST
; 322  : 	//char szTemp[256];
; 323  : 	//wsprintf(szTemp, "[USEMONSTERSKILL] %d", lpMonsterSkillUnit->m_iUnitNumber);
; 324  : 	//GCServerMsgStringSend(szTemp, lpTargetObj->m_Index, 1);
; 325  : 
; 326  : 	if ( lpMonsterSkillUnit->m_iUnitScopeType == -1 )

  000a2	8b 5d fc	 mov	 ebx, DWORD PTR _lpMonsterSkillUnit$[ebp]
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	83 7b 20 ff	 cmp	 DWORD PTR [ebx+32], -1
  000ac	0f 85 82 00 00
	00		 jne	 $LN32@UseMonster

; 327  : 	{
; 328  : 		if ( lpObj->MapNumber == MAP_INDEX_RAKLION )

  000b2	80 be 49 01 00
	00 39		 cmp	 BYTE PTR [esi+329], 57	; 00000039H
  000b9	75 18		 jne	 SHORT $LN54@UseMonster

; 329  : 		{
; 330  : 			gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);

  000bb	6a 00		 push	 0
  000bd	6a 00		 push	 0
  000bf	6a 00		 push	 0
  000c1	6a 00		 push	 0
  000c3	6a 00		 push	 0
  000c5	6a 00		 push	 0
  000c7	6a 00		 push	 0
  000c9	57		 push	 edi
  000ca	56		 push	 esi
  000cb	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  000d0	83 c4 24	 add	 esp, 36			; 00000024H
$LN54@UseMonster:

; 331  : 		}
; 332  :         if ( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )

  000d3	80 be 49 01 00
	00 3a		 cmp	 BYTE PTR [esi+329], 58	; 0000003aH
  000da	75 42		 jne	 SHORT $LN25@UseMonster

; 333  :         {
; 334  : 			if ( lpObj->Class == 459 )

  000dc	b8 cb 01 00 00	 mov	 eax, 459		; 000001cbH
  000e1	66 39 86 b8 00
	00 00		 cmp	 WORD PTR [esi+184], ax
  000e8	75 1c		 jne	 SHORT $LN29@UseMonster

; 335  : 			{
; 336  :                 if ( lpMonsterSkillUnit->m_iUnitNumber == 40 )

  000ea	83 7b 18 28	 cmp	 DWORD PTR [ebx+24], 40	; 00000028H

; 337  :                 {
; 338  : 					gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);
; 339  :                 }
; 340  : 				else

  000ee	74 16		 je	 SHORT $LN29@UseMonster

; 341  :                 {
; 342  : 					if ( lpMagic )

  000f0	8b 45 18	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000f3	85 c0		 test	 eax, eax
  000f5	74 27		 je	 SHORT $LN25@UseMonster

; 343  : 					{
; 344  : 						gObjAttack(lpObj, lpTargetObj,lpMagic, 0, 0, 0, 0,0,0);

  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	6a 00		 push	 0
  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	50		 push	 eax

; 345  : 					}
; 346  :                 }
; 347  :             }
; 348  :             else

  00104	eb 0e		 jmp	 SHORT $LN60@UseMonster
$LN29@UseMonster:

; 349  :             {
; 350  :                 gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0,0,0);

  00106	6a 00		 push	 0
  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	6a 00		 push	 0
  00112	6a 00		 push	 0
$LN60@UseMonster:
  00114	57		 push	 edi
  00115	56		 push	 esi
  00116	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0011b	83 c4 24	 add	 esp, 36			; 00000024H
$LN25@UseMonster:

; 351  :             }
; 352  :         }
; 353  : 
; 354  : 		lpMonsterSkillUnit->RunSkill(iIndex, iTargetIndex);

  0011e	8b 4d 0c	 mov	 ecx, DWORD PTR _iTargetIndex$[ebp]
  00121	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00124	51		 push	 ecx
  00125	52		 push	 edx
  00126	8b cb		 mov	 ecx, ebx
  00128	e8 00 00 00 00	 call	 ?RunSkill@TMonsterSkillUnit@@QAEXHH@Z ; TMonsterSkillUnit::RunSkill
  0012d	5b		 pop	 ebx
  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi

; 444  : 				break;
; 445  : 		}
; 446  : 	}
; 447  : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
$LN32@UseMonster:

; 355  : 	}
; 356  : 	else
; 357  : 	{
; 358  : 		int iCount = 0;
; 359  : 		int iRangeTargetIndex = -1;
; 360  : 		int iAngle = gObjUseSkill.GetAngle(lpObj->X, lpObj->Y, lpTargetObj->X, lpTargetObj->Y);

  00134	0f bf 87 46 01
	00 00		 movsx	 eax, WORD PTR [edi+326]
  0013b	0f bf 8f 44 01
	00 00		 movsx	 ecx, WORD PTR [edi+324]
  00142	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  00149	50		 push	 eax
  0014a	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  00151	51		 push	 ecx
  00152	52		 push	 edx
  00153	50		 push	 eax
  00154	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00159	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  0015e	89 45 f0	 mov	 DWORD PTR _iAngle$203121[ebp], eax
  00161	8d 86 ae 08 00
	00		 lea	 eax, DWORD PTR [esi+2222]
  00167	89 45 f8	 mov	 DWORD PTR tv589[ebp], eax
  0016a	c7 45 f4 4b 00
	00 00		 mov	 DWORD PTR tv202[ebp], 75 ; 0000004bH
$LL23@UseMonster:

; 361  : 
; 362  : 		while ( true )
; 363  : 		{
; 364  : 			if ( lpObj->VpPlayer2[iCount].state )

  00171	80 78 fe 00	 cmp	 BYTE PTR [eax-2], 0
  00175	0f 84 1c 01 00
	00		 je	 $LN53@UseMonster

; 365  : 			{
; 366  : 				iRangeTargetIndex = lpObj->VpPlayer2[iCount].number;

  0017b	0f bf 18	 movsx	 ebx, WORD PTR [eax]

; 367  : 
; 368  : 				if ( OBJMAX_RANGE(iRangeTargetIndex))

  0017e	85 db		 test	 ebx, ebx
  00180	0f 88 11 01 00
	00		 js	 $LN53@UseMonster
  00186	33 c0		 xor	 eax, eax
  00188	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0018e	0f 9e c0	 setle	 al
  00191	85 c0		 test	 eax, eax
  00193	0f 84 fe 00 00
	00		 je	 $LN53@UseMonster

; 369  : 				{
; 370  : 					if ( gObj[iRangeTargetIndex].Type == OBJ_USER )

  00199	8b c3		 mov	 eax, ebx
  0019b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  001a1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a7	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  001ac	0f 85 e5 00 00
	00		 jne	 $LN53@UseMonster

; 371  : 					{
; 372  : 						BOOL bTargetOK = FALSE;
; 373  : 
; 374  : 						if ( lpMonsterSkillUnit->m_iUnitScopeType == 0 )

  001b2	8b 4d fc	 mov	 ecx, DWORD PTR _lpMonsterSkillUnit$[ebp]
  001b5	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001b8	85 c9		 test	 ecx, ecx
  001ba	75 18		 jne	 SHORT $LN18@UseMonster

; 375  : 						{
; 376  : 							if ( gObjCalDistance(lpObj, &gObj[iRangeTargetIndex]) < lpMonsterSkillUnit->m_iUnitScopeValue )

  001bc	50		 push	 eax
  001bd	56		 push	 esi
  001be	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001c3	8b 55 fc	 mov	 edx, DWORD PTR _lpMonsterSkillUnit$[ebp]
  001c6	83 c4 08	 add	 esp, 8
  001c9	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  001cc	0f 8d c5 00 00
	00		 jge	 $LN53@UseMonster

; 377  : 							{
; 378  : 								bTargetOK = TRUE;
; 379  : 							}
; 380  : 						}

  001d2	eb 47		 jmp	 SHORT $LN52@UseMonster
$LN18@UseMonster:

; 381  : 						else  if ( lpMonsterSkillUnit->m_iUnitScopeType == 1 )

  001d4	83 f9 01	 cmp	 ecx, 1
  001d7	75 38		 jne	 SHORT $LN15@UseMonster

; 382  : 						{
; 383  : 							if ( SkillElectricSparkHitBox.HitCheck(iAngle, lpObj->X, lpObj->Y,
; 384  : 								gObj[iRangeTargetIndex].X, gObj[iRangeTargetIndex].Y) )

  001d9	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  001e0	0f bf 90 44 01
	00 00		 movsx	 edx, WORD PTR [eax+324]
  001e7	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  001ee	51		 push	 ecx
  001ef	0f bf 8e 44 01
	00 00		 movsx	 ecx, WORD PTR [esi+324]
  001f6	52		 push	 edx
  001f7	8b 55 f0	 mov	 edx, DWORD PTR _iAngle$203121[ebp]
  001fa	50		 push	 eax
  001fb	51		 push	 ecx
  001fc	52		 push	 edx
  001fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillElectricSparkHitBox@@3VCSkillHitBox@@A ; SkillElectricSparkHitBox
  00202	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00207	85 c0		 test	 eax, eax
  00209	0f 84 88 00 00
	00		 je	 $LN53@UseMonster

; 385  : 							{
; 386  : 								bTargetOK = TRUE;
; 387  : 							}
; 388  : 						}

  0020f	eb 0a		 jmp	 SHORT $LN52@UseMonster
$LN15@UseMonster:

; 389  : 						else if ( lpMonsterSkillUnit->m_iUnitScopeType == 2 )

  00211	83 f9 02	 cmp	 ecx, 2

; 390  : 						{
; 391  : 							bTargetOK = TRUE;

  00214	74 05		 je	 SHORT $LN52@UseMonster

; 392  : 						}
; 393  : 						else if ( lpMonsterSkillUnit->m_iUnitScopeType == 3 )

  00216	83 f9 03	 cmp	 ecx, 3
  00219	75 7c		 jne	 SHORT $LN53@UseMonster
$LN52@UseMonster:

; 394  : 						{
; 395  : 							bTargetOK = TRUE;
; 396  : 						}
; 397  : 
; 398  : 						if ( bTargetOK )
; 399  : 						{
; 400  : 							if ( lpObj->MapNumber == MAP_INDEX_RAKLION )

  0021b	80 be 49 01 00
	00 39		 cmp	 BYTE PTR [esi+329], 57	; 00000039H
  00222	75 18		 jne	 SHORT $LN8@UseMonster

; 401  : 							{
; 402  : 								gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);

  00224	6a 00		 push	 0
  00226	6a 00		 push	 0
  00228	6a 00		 push	 0
  0022a	6a 00		 push	 0
  0022c	6a 00		 push	 0
  0022e	6a 00		 push	 0
  00230	6a 00		 push	 0
  00232	57		 push	 edi
  00233	56		 push	 esi
  00234	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00239	83 c4 24	 add	 esp, 36			; 00000024H
$LN8@UseMonster:

; 403  : 							}
; 404  : 							if ( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )

  0023c	80 be 49 01 00
	00 3a		 cmp	 BYTE PTR [esi+329], 58	; 0000003aH
  00243	75 45		 jne	 SHORT $LN2@UseMonster

; 405  : 							{
; 406  : 								if ( lpObj->Class == 459 )

  00245	b8 cb 01 00 00	 mov	 eax, 459		; 000001cbH
  0024a	66 39 86 b8 00
	00 00		 cmp	 WORD PTR [esi+184], ax
  00251	75 1f		 jne	 SHORT $LN6@UseMonster

; 407  : 								{
; 408  : 									if ( lpMonsterSkillUnit->m_iUnitNumber == 40 )

  00253	8b 4d fc	 mov	 ecx, DWORD PTR _lpMonsterSkillUnit$[ebp]
  00256	83 79 18 28	 cmp	 DWORD PTR [ecx+24], 40	; 00000028H

; 409  : 									{
; 410  : 										gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);
; 411  : 									}
; 412  : 									else

  0025a	74 16		 je	 SHORT $LN6@UseMonster

; 413  : 									{
; 414  : 										if ( lpMagic )

  0025c	8b 45 18	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0025f	85 c0		 test	 eax, eax
  00261	74 27		 je	 SHORT $LN2@UseMonster

; 415  : 										{
; 416  : 											gObjAttack(lpObj, lpTargetObj,lpMagic, 0, 0, 0, 0,0,0);

  00263	6a 00		 push	 0
  00265	6a 00		 push	 0
  00267	6a 00		 push	 0
  00269	6a 00		 push	 0
  0026b	6a 00		 push	 0
  0026d	6a 00		 push	 0
  0026f	50		 push	 eax

; 417  : 										}
; 418  : 									}
; 419  : 								}
; 420  : 								else

  00270	eb 0e		 jmp	 SHORT $LN61@UseMonster
$LN6@UseMonster:

; 421  : 								{
; 422  : 									gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0,0,0);

  00272	6a 00		 push	 0
  00274	6a 00		 push	 0
  00276	6a 00		 push	 0
  00278	6a 00		 push	 0
  0027a	6a 00		 push	 0
  0027c	6a 00		 push	 0
  0027e	6a 00		 push	 0
$LN61@UseMonster:
  00280	57		 push	 edi
  00281	56		 push	 esi
  00282	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00287	83 c4 24	 add	 esp, 36			; 00000024H
$LN2@UseMonster:

; 423  : 								}
; 424  : 							}
; 425  : 
; 426  : #ifdef IMPERIAL_CONFLICT_NEW
; 427  : 							if ( lpObj->Class >= 504 && lpObj->Class <= 521)
; 428  : 							{
; 429  : 								if ( lpMagic )
; 430  : 									gObjAttack(lpObj, lpTargetObj, lpMagic, 0, 0, 0, 0, 0, 0);
; 431  : 								else
; 432  : 									gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0, 0, 0);
; 433  : 							}
; 434  : #endif
; 435  : 							lpMonsterSkillUnit->RunSkill(iIndex, iRangeTargetIndex);

  0028a	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0028d	8b 4d fc	 mov	 ecx, DWORD PTR _lpMonsterSkillUnit$[ebp]
  00290	53		 push	 ebx
  00291	52		 push	 edx
  00292	e8 00 00 00 00	 call	 ?RunSkill@TMonsterSkillUnit@@QAEXHH@Z ; TMonsterSkillUnit::RunSkill
$LN53@UseMonster:

; 436  : 						}
; 437  : 					}
; 438  : 				}
; 439  : 			}
; 440  : 
; 441  : 			iCount++;

  00297	8b 45 f8	 mov	 eax, DWORD PTR tv589[ebp]
  0029a	83 c0 0c	 add	 eax, 12			; 0000000cH

; 442  : 
; 443  : 			if ( iCount > MAX_VIEWPORT_MONSTER-1)

  0029d	ff 4d f4	 dec	 DWORD PTR tv202[ebp]
  002a0	89 45 f8	 mov	 DWORD PTR tv589[ebp], eax
  002a3	0f 85 c8 fe ff
	ff		 jne	 $LL23@UseMonster
  002a9	5b		 pop	 ebx
  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi

; 444  : 				break;
; 445  : 		}
; 446  : 	}
; 447  : }

  002ac	8b e5		 mov	 esp, ebp
  002ae	5d		 pop	 ebp
  002af	c3		 ret	 0
$LN37@UseMonster:

; 288  : 	{
; 289  : 		LogAddC(2,"[TMonsterSkillManager][UserMonsterSkill] error: iTargetIndex(%d)",iTargetIndex);

  002b0	57		 push	 edi
  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
  002b6	6a 02		 push	 2
  002b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002be	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c1	5f		 pop	 edi
  002c2	5e		 pop	 esi

; 444  : 				break;
; 445  : 		}
; 446  : 	}
; 447  : }

  002c3	8b e5		 mov	 esp, ebp
  002c5	5d		 pop	 ebp
  002c6	c3		 ret	 0
$LN39@UseMonster:

; 282  : 	{
; 283  : 		LogAddC(2,"[TMonsterSkillManager][UserMonsterSkill] error: iIndex(%d)",iIndex);

  002c7	56		 push	 esi
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
  002cd	6a 02		 push	 2
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d8	5e		 pop	 esi

; 444  : 				break;
; 445  : 		}
; 446  : 	}
; 447  : }

  002d9	8b e5		 mov	 esp, ebp
  002db	5d		 pop	 ebp
  002dc	c3		 ret	 0
?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z ENDP ; TMonsterSkillManager::UseMonsterSkill
_TEXT	ENDS
PUBLIC	??0TMonsterSkillInfo@@QAE@XZ			; TMonsterSkillInfo::TMonsterSkillInfo
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterskillinfo.h
;	COMDAT ??0TMonsterSkillInfo@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterSkillInfo@@QAE@XZ PROC			; TMonsterSkillInfo::TMonsterSkillInfo, COMDAT
; _this$ = ecx

; 19   : 	TMonsterSkillInfo()

  00000	8b c1		 mov	 eax, ecx

; 20   : 	{
; 21   : 		this->Reset();

  00002	83 ca ff	 or	 edx, -1
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	33 c9		 xor	 ecx, ecx
  00009	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000c	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0000f	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00018	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0001b	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0001e	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00021	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00024	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00027	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  0002a	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  0002d	89 48 44	 mov	 DWORD PTR [eax+68], ecx
  00030	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00033	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00036	89 50 24	 mov	 DWORD PTR [eax+36], edx
  00039	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  0003c	89 50 28	 mov	 DWORD PTR [eax+40], edx
  0003f	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00042	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  00045	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 22   : 	}

  00048	c3		 ret	 0
??0TMonsterSkillInfo@@QAE@XZ ENDP			; TMonsterSkillInfo::TMonsterSkillInfo
_TEXT	ENDS
PUBLIC	??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@ ; `string'
PUBLIC	??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@ ; `string'
PUBLIC	??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@ ; `string'
PUBLIC	??_C@_0DG@MDEFFMNA@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@ ; `string'
PUBLIC	??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@ ; `string'
PUBLIC	??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_lpszFileName$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?LoadData@TMonsterSkillManager@@SAHPAD@Z	; TMonsterSkillManager::LoadData
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	?FindSkillUnit@TMonsterSkillUnit@@SAPAV1@H@Z:PROC ; TMonsterSkillUnit::FindSkillUnit
EXTRN	_fclose:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@
CONST	SEGMENT
??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@ DB '[Mon'
	DB	'ster Skill Manager] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@
CONST	SEGMENT
??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@ DB '[Mons'
	DB	'ter Skill Manager] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@
CONST	SEGMENT
??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@ DB 0a1H
	DB	0dbH, 'Index:%d,Name:%s,Count:%d,Type0:%d,Unit0:%d,Type1:%d,Un'
	DB	'it1:%d,Type2:%d,Unit2:%d,Type3:%d,Unit3:%d,Type4:%d,Unit4:%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MDEFFMNA@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@
CONST	SEGMENT
??_C@_0DG@MDEFFMNA@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@ DB '[Mons'
	DB	'ter Manager] - Invalid SkillInfo : MIndex(%s/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@
CONST	SEGMENT
??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@ DB '[Monst'
	DB	'er Manager] - MonsterIndex(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@
CONST	SEGMENT
??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@ DB '['
	DB	'Monster Skill Manager] - %s file is Loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@ DB '[Mo'
	DB	'nster Skill Manager] - Can''t Open %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterSkillManager@@SAHPAD@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterSkillManager@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterSkillManager@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterSkillManager@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterSkillManager@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterSkillManager@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterSkillManager@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterSkillManager@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tmonsterskillmanager.cpp
xdata$x	ENDS
;	COMDAT ?LoadData@TMonsterSkillManager@@SAHPAD@Z
_TEXT	SEGMENT
_iType$202988 = -340					; size = 4
_bVerified$202998 = -336				; size = 4
_lpszFileName$GSCopy$ = -332				; size = 4
_MonsterSkillInfo$203000 = -328				; size = 88
_szMsg$203019 = -240					; size = 200
_szMonsterName$202999 = -40				; size = 20
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterSkillManager@@SAHPAD@Z PROC		; TMonsterSkillManager::LoadData, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterSkillManager@@SAHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 5d 08	 mov	 ebx, DWORD PTR _lpszFileName$[ebp]

; 28   : 	TMonsterSkillManager::s_bDataLoad = FALSE;

  00034	33 ff		 xor	 edi, edi
  00036	89 9d b4 fe ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$[ebp], ebx
  0003c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?s_bDataLoad@TMonsterSkillManager@@2HA, edi ; TMonsterSkillManager::s_bDataLoad

; 29   : 
; 30   : 	if ( !lpszFileName || !strcmp(lpszFileName, ""))

  00042	3b df		 cmp	 ebx, edi
  00044	0f 84 ea 02 00
	00		 je	 $LN18@LoadData
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0004f	8b c3		 mov	 eax, ebx
$LL39@LoadData:
  00051	8a 10		 mov	 dl, BYTE PTR [eax]
  00053	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00055	75 1d		 jne	 SHORT $LN40@LoadData
  00057	84 d2		 test	 dl, dl
  00059	74 12		 je	 SHORT $LN41@LoadData
  0005b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0005e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00061	75 11		 jne	 SHORT $LN40@LoadData
  00063	83 c0 02	 add	 eax, 2
  00066	83 c1 02	 add	 ecx, 2
  00069	84 d2		 test	 dl, dl
  0006b	75 e4		 jne	 SHORT $LL39@LoadData
$LN41@LoadData:
  0006d	33 c0		 xor	 eax, eax
  0006f	83 ce ff	 or	 esi, -1
  00072	eb 09		 jmp	 SHORT $LN42@LoadData
$LN40@LoadData:
  00074	1b c0		 sbb	 eax, eax
  00076	be ff ff ff ff	 mov	 esi, -1
  0007b	1b c6		 sbb	 eax, esi
$LN42@LoadData:
  0007d	3b c7		 cmp	 eax, edi
  0007f	0f 84 af 02 00
	00		 je	 $LN18@LoadData

; 34   : 	}
; 35   : 
; 36   : 	try
; 37   : 	{
; 38   : 		SMDToken Token;
; 39   : 		SMDFile = fopen(lpszFileName, "r");

  00085	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0008a	53		 push	 ebx
  0008b	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  0008e	e8 00 00 00 00	 call	 _fopen
  00093	83 c4 08	 add	 esp, 8
  00096	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 40   : 
; 41   : 		if ( SMDFile == NULL )

  0009b	3b c7		 cmp	 eax, edi
  0009d	75 13		 jne	 SHORT $LN16@LoadData

; 42   : 		{
; 43   : 			MsgBox("[Monster Skill Manager] - Can't Open %s ", lpszFileName);

  0009f	53		 push	 ebx
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@
  000a5	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000aa	83 c4 08	 add	 esp, 8

; 44   : 			return FALSE;

  000ad	e9 8f 02 00 00	 jmp	 $LN50@LoadData
$LN16@LoadData:

; 45   : 		}
; 46   : 
; 47   : 		TMonsterSkillManager::DelAllSkillManagerInfo();

  000b2	e8 00 00 00 00	 call	 ?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ ; TMonsterSkillManager::DelAllSkillManagerInfo
$LL15@LoadData:

; 48   : 		int iType = -1;
; 49   : 
; 50   : 		while ( true )
; 51   : 		{
; 52   : 			Token = GetToken();

  000b7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 53   : 
; 54   : 			if ( Token == END )

  000bc	83 f8 02	 cmp	 eax, 2
  000bf	75 2b		 jne	 SHORT $LN13@LoadData

; 133  : 		}
; 134  : 
; 135  : 		fclose(SMDFile);

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _fclose

; 136  : 
; 137  : 		LogAddC(2, "[Monster Skill Manager] - %s file is Loaded", lpszFileName);

  000cc	53		 push	 ebx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@
  000d2	6a 02		 push	 2
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000da	83 c4 10	 add	 esp, 16			; 00000010H

; 138  : 
; 139  : 		TMonsterSkillManager::s_bDataLoad = TRUE;

  000dd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterSkillManager@@2HA, 1 ; TMonsterSkillManager::s_bDataLoad
  000e7	e9 55 02 00 00	 jmp	 $LN50@LoadData
$LN13@LoadData:

; 55   : 				break;
; 56   : 
; 57   : 			iType = (int)TokenNumber;

  000ec	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000f2	e8 00 00 00 00	 call	 __ftol2_sse
  000f7	89 85 ac fe ff
	ff		 mov	 DWORD PTR _iType$202988[ebp], eax
  000fd	8d 49 00	 npad	 3
$LL12@LoadData:

; 58   : 
; 59   : 			while ( true )
; 60   : 			{
; 61   : 				if ( iType == 0 )

  00100	39 bd ac fe ff
	ff		 cmp	 DWORD PTR _iType$202988[ebp], edi
  00106	75 f8		 jne	 SHORT $LL12@LoadData

; 62   : 				{
; 63   : 					BOOL bVerified = TRUE;
; 64   : 					char szMonsterName[20]={0};

  00108	33 c0		 xor	 eax, eax
  0010a	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bVerified$202998[ebp], 1
  00114	c6 45 d8 00	 mov	 BYTE PTR _szMonsterName$202999[ebp], 0
  00118	89 45 d9	 mov	 DWORD PTR _szMonsterName$202999[ebp+1], eax
  0011b	89 45 dd	 mov	 DWORD PTR _szMonsterName$202999[ebp+5], eax
  0011e	89 45 e1	 mov	 DWORD PTR _szMonsterName$202999[ebp+9], eax
  00121	89 45 e5	 mov	 DWORD PTR _szMonsterName$202999[ebp+13], eax
  00124	66 89 45 e9	 mov	 WORD PTR _szMonsterName$202999[ebp+17], ax
  00128	88 45 eb	 mov	 BYTE PTR _szMonsterName$202999[ebp+19], al

; 65   : 					TMonsterSkillInfo MonsterSkillInfo;

  0012b	89 b5 b8 fe ff
	ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp], esi
  00131	89 bd bc fe ff
	ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp+4], edi
$LL30@LoadData:
  00137	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0013a	7d 11		 jge	 SHORT $LN28@LoadData
  0013c	89 b4 85 c0 fe
	ff ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp+eax*4+8], esi
  00143	89 bc 85 e8 fe
	ff ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp+eax*4+48], edi
  0014a	40		 inc	 eax
  0014b	eb ea		 jmp	 SHORT $LL30@LoadData
$LN28@LoadData:

; 66   : 
; 67   : 					Token = GetToken();

  0014d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 68   : 
; 69   : 					if ( !strcmp("end", TokenString))

  00152	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00157	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0015c	8d 64 24 00	 npad	 4
$LL43@LoadData:
  00160	8a 10		 mov	 dl, BYTE PTR [eax]
  00162	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00164	75 1a		 jne	 SHORT $LN44@LoadData
  00166	84 d2		 test	 dl, dl
  00168	74 12		 je	 SHORT $LN45@LoadData
  0016a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0016d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00170	75 0e		 jne	 SHORT $LN44@LoadData
  00172	83 c0 02	 add	 eax, 2
  00175	83 c1 02	 add	 ecx, 2
  00178	84 d2		 test	 dl, dl
  0017a	75 e4		 jne	 SHORT $LL43@LoadData
$LN45@LoadData:
  0017c	33 c0		 xor	 eax, eax
  0017e	eb 04		 jmp	 SHORT $LN46@LoadData
$LN44@LoadData:
  00180	1b c0		 sbb	 eax, eax
  00182	1b c6		 sbb	 eax, esi
$LN46@LoadData:
  00184	3b c7		 cmp	 eax, edi
  00186	0f 84 9d 01 00
	00		 je	 $LN47@LoadData

; 70   : 						break;
; 71   : 
; 72   : 					MonsterSkillInfo.m_iMonsterIndex = (int)TokenNumber;

  0018c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00192	e8 00 00 00 00	 call	 __ftol2_sse
  00197	8b d8		 mov	 ebx, eax
  00199	89 9d b8 fe ff
	ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp], ebx

; 73   : 
; 74   : 					Token = GetToken();

  0019f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 75   : 					memcpy(szMonsterName, TokenString, 20);

  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _TokenString
  001aa	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _TokenString+4
  001b0	a1 08 00 00 00	 mov	 eax, DWORD PTR _TokenString+8
  001b5	89 4d d8	 mov	 DWORD PTR _szMonsterName$202999[ebp], ecx
  001b8	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _TokenString+12
  001be	89 55 dc	 mov	 DWORD PTR _szMonsterName$202999[ebp+4], edx
  001c1	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR _TokenString+16
  001c7	89 45 e0	 mov	 DWORD PTR _szMonsterName$202999[ebp+8], eax
  001ca	89 4d e4	 mov	 DWORD PTR _szMonsterName$202999[ebp+12], ecx
  001cd	89 55 e8	 mov	 DWORD PTR _szMonsterName$202999[ebp+16], edx

; 76   : 
; 77   : 					for ( int i = 0;i < 10;i++)//Season 4.5 changed from 5 to 10

  001d0	33 f6		 xor	 esi, esi
$LL8@LoadData:
  001d2	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  001d5	7d 5e		 jge	 SHORT $LN6@LoadData

; 78   : 					{
; 79   : 						int iSkillUnitNumber = -1;
; 80   : 						Token = GetToken();

  001d7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 81   : 						MonsterSkillInfo.m_iSkillUnitTypeArray[i] = (int)TokenNumber;

  001dc	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e2	e8 00 00 00 00	 call	 __ftol2_sse
  001e7	89 84 b5 c0 fe
	ff ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp+esi*4+8], eax

; 82   : 
; 83   : 						Token = GetToken();

  001ee	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 84   : 						iSkillUnitNumber = (int)TokenNumber;

  001f3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001f9	e8 00 00 00 00	 call	 __ftol2_sse

; 85   : 
; 86   : 						if ( iSkillUnitNumber == -1 )

  001fe	83 f8 ff	 cmp	 eax, -1
  00201	74 29		 je	 SHORT $LN7@LoadData

; 87   : 							continue;
; 88   : 
; 89   : 						TMonsterSkillUnit * lpSkillUnit = TMonsterSkillUnit::FindSkillUnit(iSkillUnitNumber);

  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?FindSkillUnit@TMonsterSkillUnit@@SAPAV1@H@Z ; TMonsterSkillUnit::FindSkillUnit
  00209	83 c4 04	 add	 esp, 4

; 90   : 						
; 91   : 						if ( lpSkillUnit == NULL )

  0020c	3b c7		 cmp	 eax, edi
  0020e	75 0f		 jne	 SHORT $LN4@LoadData

; 92   : 						{
; 93   : 							bVerified = FALSE;

  00210	8b 9d b8 fe ff
	ff		 mov	 ebx, DWORD PTR _MonsterSkillInfo$203000[ebp]
  00216	89 bd b0 fe ff
	ff		 mov	 DWORD PTR _bVerified$202998[ebp], edi
  0021c	46		 inc	 esi
  0021d	eb b3		 jmp	 SHORT $LL8@LoadData
$LN4@LoadData:

; 94   : 							continue;
; 95   : 						}
; 96   : 
; 97   : 						MonsterSkillInfo.m_lpSkillUnitArray[i] = lpSkillUnit;

  0021f	89 84 b5 e8 fe
	ff ff		 mov	 DWORD PTR _MonsterSkillInfo$203000[ebp+esi*4+48], eax

; 98   : 						MonsterSkillInfo.m_iSkillUnitCount++;

  00226	ff 85 bc fe ff
	ff		 inc	 DWORD PTR _MonsterSkillInfo$203000[ebp+4]
$LN7@LoadData:

; 76   : 
; 77   : 					for ( int i = 0;i < 10;i++)//Season 4.5 changed from 5 to 10

  0022c	8b 9d b8 fe ff
	ff		 mov	 ebx, DWORD PTR _MonsterSkillInfo$203000[ebp]
  00232	46		 inc	 esi
  00233	eb 9d		 jmp	 SHORT $LL8@LoadData
$LN6@LoadData:

; 99   : 					}
; 100  : 
; 101  : 
; 102  : 
; 103  : 					if ( false || MonsterSkillInfo.m_iMonsterIndex >= MAX_MONSTER_SKILL_INFO_ARRAY )

  00235	81 fb bc 02 00
	00		 cmp	 ebx, 700		; 000002bcH
  0023b	7c 1d		 jl	 SHORT $LN3@LoadData

; 104  : 					{
; 105  : 						MsgBox("[Monster Manager] - MonsterIndex(%d) Error (%s) File. ", 
; 106  : 							MonsterSkillInfo.m_iMonsterIndex, lpszFileName);

  0023d	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _lpszFileName$GSCopy$[ebp]
  00243	50		 push	 eax
  00244	53		 push	 ebx
  00245	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@
  0024a	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0024f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 107  : 						continue;

  00252	83 ce ff	 or	 esi, -1
  00255	e9 a6 fe ff ff	 jmp	 $LL12@LoadData
$LN3@LoadData:

; 108  : 					}
; 109  : 
; 110  : 					if ( bVerified ==FALSE )

  0025a	39 bd b0 fe ff
	ff		 cmp	 DWORD PTR _bVerified$202998[ebp], edi
  00260	75 1c		 jne	 SHORT $LN1@LoadData

; 111  : 					{
; 112  : 						LogAddC(2, "[Monster Manager] - Invalid SkillInfo : MIndex(%s/%d)",
; 113  : 							szMonsterName, MonsterSkillInfo.m_iMonsterIndex,lpszFileName);

  00262	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpszFileName$GSCopy$[ebp]
  00268	51		 push	 ecx
  00269	53		 push	 ebx
  0026a	8d 55 d8	 lea	 edx, DWORD PTR _szMonsterName$202999[ebp]
  0026d	52		 push	 edx
  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MDEFFMNA@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@
  00273	6a 02		 push	 2
  00275	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0027b	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@LoadData:

; 114  : 					}
; 115  : 
; 116  : 					memcpy(&TMonsterSkillManager::s_MonsterSkillInfoArray[MonsterSkillInfo.m_iMonsterIndex],
; 117  : 						&MonsterSkillInfo, sizeof(MonsterSkillInfo));

  0027e	6b db 58	 imul	 ebx, 88			; 00000058H
  00281	8d 9b 00 00 00
	00		 lea	 ebx, DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[ebx]
  00287	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0028c	8d b5 b8 fe ff
	ff		 lea	 esi, DWORD PTR _MonsterSkillInfo$203000[ebp]
  00292	8b fb		 mov	 edi, ebx

; 118  : 
; 119  : 					char szMsg[200] = {0};

  00294	68 c7 00 00 00	 push	 199			; 000000c7H
  00299	f3 a5		 rep movsd
  0029b	8d 8d 11 ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$203019[ebp+1]
  002a1	6a 00		 push	 0
  002a3	51		 push	 ecx
  002a4	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR _szMsg$203019[ebp], 0
  002ab	e8 00 00 00 00	 call	 _memset

; 120  : 					TMonsterSkillInfo * pMonSInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[MonsterSkillInfo.m_iMonsterIndex];
; 121  : 
; 122  : 					wsprintf(szMsg, "Index:%d,Name:%s,Count:%d,Type0:%d,Unit0:%d,Type1:%d,Unit1:%d,Type2:%d,Unit2:%d,Type3:%d,Unit3:%d,Type4:%d,Unit4:%d\n",
; 123  : 						pMonSInfo->m_iMonsterIndex, szMonsterName, pMonSInfo->m_iSkillUnitCount,
; 124  : 						pMonSInfo->m_iSkillUnitTypeArray[0], pMonSInfo->m_lpSkillUnitArray[0],
; 125  : 						pMonSInfo->m_iSkillUnitTypeArray[1], pMonSInfo->m_lpSkillUnitArray[1],
; 126  : 						pMonSInfo->m_iSkillUnitTypeArray[2], pMonSInfo->m_lpSkillUnitArray[2],
; 127  : 						pMonSInfo->m_iSkillUnitTypeArray[3], pMonSInfo->m_lpSkillUnitArray[3],
; 128  : 						pMonSInfo->m_iSkillUnitTypeArray[4], pMonSInfo->m_lpSkillUnitArray[4]);

  002b0	8b 53 40	 mov	 edx, DWORD PTR [ebx+64]
  002b3	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  002b6	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  002b9	52		 push	 edx
  002ba	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  002bd	50		 push	 eax
  002be	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  002c1	51		 push	 ecx
  002c2	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  002c5	52		 push	 edx
  002c6	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  002c9	50		 push	 eax
  002ca	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  002cd	51		 push	 ecx
  002ce	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  002d1	52		 push	 edx
  002d2	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  002d5	50		 push	 eax
  002d6	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002d9	51		 push	 ecx
  002da	52		 push	 edx
  002db	8b 13		 mov	 edx, DWORD PTR [ebx]
  002dd	50		 push	 eax
  002de	8d 4d d8	 lea	 ecx, DWORD PTR _szMonsterName$202999[ebp]
  002e1	51		 push	 ecx
  002e2	52		 push	 edx
  002e3	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$203019[ebp]
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@
  002ee	50		 push	 eax
  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  002f5	83 c4 48	 add	 esp, 72			; 00000048H

; 129  : 
; 130  : 					OutputDebugString(szMsg);

  002f8	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$203019[ebp]
  002fe	51		 push	 ecx
  002ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 131  : 				}
; 132  : 			}

  00305	33 ff		 xor	 edi, edi
  00307	83 ce ff	 or	 esi, -1
  0030a	e9 f1 fd ff ff	 jmp	 $LL12@LoadData
__catch$?LoadData@TMonsterSkillManager@@SAHPAD@Z$0:

; 140  : 	}
; 141  : 	catch(...)
; 142  : 	{
; 143  : 		MsgBox("[Monster Skill Manager] - Loading Exception Error (%s) File. ", lpszFileName);

  0030f	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _lpszFileName$GSCopy$[ebp]
  00315	50		 push	 eax
  00316	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@
  0031b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00320	83 c4 08	 add	 esp, 8

; 144  : 	}

  00323	b8 00 00 00 00	 mov	 eax, $LN50@LoadData
  00328	c3		 ret	 0
$LN47@LoadData:

; 131  : 				}
; 132  : 			}

  00329	8b 9d b4 fe ff
	ff		 mov	 ebx, DWORD PTR _lpszFileName$GSCopy$[ebp]
  0032f	e9 83 fd ff ff	 jmp	 $LL15@LoadData
$LN18@LoadData:

; 31   : 	{
; 32   : 		MsgBox("[Monster Skill Manager] - File load error : File Name Error");

  00334	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@
  00339	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0033e	83 c4 04	 add	 esp, 4
$LN50@LoadData:

; 33   : 		return FALSE;

  00341	33 c0		 xor	 eax, eax

; 145  : 
; 146  : 	return FALSE;
; 147  : }

  00343	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00346	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0034d	59		 pop	 ecx
  0034e	5f		 pop	 edi
  0034f	5e		 pop	 esi
  00350	5b		 pop	 ebx
  00351	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00354	33 cd		 xor	 ecx, ebp
  00356	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035b	8b e5		 mov	 esp, ebp
  0035d	5d		 pop	 ebp
  0035e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterSkillManager@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-344]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterSkillManager@@SAHPAD@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterSkillManager@@SAHPAD@Z ENDP		; TMonsterSkillManager::LoadData
; Function compile flags: /Ogtp
;	COMDAT ??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ
text$yc	SEGMENT
??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillInfoArray'', COMDAT

; 11   : TMonsterSkillInfo TMonsterSkillManager::s_MonsterSkillInfoArray[MAX_MONSTER_SKILL_INFO_ARRAY];

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	bb bb 02 00 00	 mov	 ebx, 699		; 000002bbH
  00007	ba 30 00 00 00	 mov	 edx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A+48
  0000c	83 ce ff	 or	 esi, -1
  0000f	90		 npad	 1
$LL4@s_MonsterS:
  00010	89 72 d0	 mov	 DWORD PTR [edx-48], esi
  00013	c7 42 d4 00 00
	00 00		 mov	 DWORD PTR [edx-44], 0
  0001a	8b c2		 mov	 eax, edx
  0001c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
$LL11@s_MonsterS:
  00021	89 70 d8	 mov	 DWORD PTR [eax-40], esi
  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002a	83 c0 04	 add	 eax, 4
  0002d	49		 dec	 ecx
  0002e	75 f1		 jne	 SHORT $LL11@s_MonsterS
  00030	83 c2 58	 add	 edx, 88			; 00000058H
  00033	4b		 dec	 ebx
  00034	79 da		 jns	 SHORT $LL4@s_MonsterS
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	c3		 ret	 0
??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillInfoArray''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ
text$yc	SEGMENT
??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillDelayInfoArray'', COMDAT

; 12   : _ST_MONSTER_SKILL_DELAYTIME_INFO TMonsterSkillManager::s_MonsterSkillDelayInfoArray[MAX_MONSTER_SKILL_DELAY_INFO_ARRAY];

  00000	ba b7 0b 00 00	 mov	 edx, 2999		; 00000bb7H
  00005	b8 08 00 00 00	 mov	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+8
  0000a	33 c9		 xor	 ecx, ecx
  0000c	8d 64 24 00	 npad	 4
$LL4@s_MonsterS@2:
  00010	c7 40 fc ff ff
	ff ff		 mov	 DWORD PTR [eax-4], -1
  00017	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00020	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  00023	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00026	83 c0 14	 add	 eax, 20			; 00000014H
  00029	4a		 dec	 edx
  0002a	79 e4		 jns	 SHORT $LL4@s_MonsterS@2
  0002c	c3		 ret	 0
??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillDelayInfoArray''
text$yc	ENDS
EXTRN	_atexit:PROC
EXTRN	??0TSync@@QAE@XZ:PROC				; TSync::TSync
; Function compile flags: /Ogtp
;	COMDAT ??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ
text$yc	SEGMENT
??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterSkillManager::s_Sync'', COMDAT

; 13   : TSync TMonsterSkillManager::s_Sync;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_Sync@TMonsterSkillManager@@2VTSync@@A ; TMonsterSkillManager::s_Sync
  00005	e8 00 00 00 00	 call	 ??0TSync@@QAE@XZ	; TSync::TSync
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ; `dynamic atexit destructor for 'TMonsterSkillManager::s_Sync''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterSkillManager::s_Sync''
text$yc	ENDS
EXTRN	??1TSync@@QAE@XZ:PROC				; TSync::~TSync
; Function compile flags: /Ogtp
;	COMDAT ??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ
text$yd	SEGMENT
??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'TMonsterSkillManager::s_Sync'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_Sync@TMonsterSkillManager@@2VTSync@@A ; TMonsterSkillManager::s_Sync
  00005	e9 00 00 00 00	 jmp	 ??1TSync@@QAE@XZ	; TSync::~TSync
??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'TMonsterSkillManager::s_Sync''
text$yd	ENDS
PUBLIC	?s_Sync@TMonsterSkillManager@@2VTSync@@A	; TMonsterSkillManager::s_Sync
PUBLIC	?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray
PUBLIC	?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray
_BSS	SEGMENT
?s_Sync@TMonsterSkillManager@@2VTSync@@A DB 01cH DUP (?) ; TMonsterSkillManager::s_Sync
?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A DB 0ea60H DUP (?) ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray
?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A DB 0f0a0H DUP (?) ; TMonsterSkillManager::s_MonsterSkillInfoArray
_BSS	ENDS
CRT$XCU	SEGMENT
?s_MonsterSkillInfoArray$initializer$@TMonsterSkillManager@@2P6AXXZA DD FLAT:??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ ; TMonsterSkillManager::s_MonsterSkillInfoArray$initializer$
?s_MonsterSkillDelayInfoArray$initializer$@TMonsterSkillManager@@2P6AXXZA DD FLAT:??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray$initializer$
?s_Sync$initializer$@TMonsterSkillManager@@2P6AXXZA DD FLAT:??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ; TMonsterSkillManager::s_Sync$initializer$
CRT$XCU	ENDS
END
