; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\WzQueue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0WZQueue@@QAE@I@Z				; WZQueue::WZQueue
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\wzqueue.cpp
;	COMDAT ??0WZQueue@@QAE@I@Z
_TEXT	SEGMENT
_nMaxNode$ = 8						; size = 4
??0WZQueue@@QAE@I@Z PROC				; WZQueue::WZQueue, COMDAT
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6    : 	this->m_Max_Node = nMaxNode;

  00003	8b 45 08	 mov	 eax, DWORD PTR _nMaxNode$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 7    : 	this->m_pTail = 0;

  0000d	33 c0		 xor	 eax, eax

; 8    : 	this->m_pHead = 0;
; 9    : 	this->m_Count = 0;
; 10   : 	BOOL bSuccess;
; 11   : 	bSuccess=InitializeCriticalSectionAndSpinCount(&this->m_CriticalSection , 4000);

  0000f	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  00014	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00017	57		 push	 edi
  00018	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 12   : 	if (bSuccess == 0 )

  00026	85 c0		 test	 eax, eax
  00028	75 14		 jne	 SHORT $LN6@WZQueue

; 13   : 	{
; 14   : 		if ( GetLastError() == STATUS_NO_MEMORY )	

  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00030	3d 17 00 00 c0	 cmp	 eax, -1073741801	; c0000017H
  00035	75 07		 jne	 SHORT $LN6@WZQueue

; 15   : 		{
; 16   : 			InitializeCriticalSection(&this->m_CriticalSection );

  00037	57		 push	 edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
$LN6@WZQueue:

; 17   : 		}
; 18   : 	}
; 19   : }

  0003e	5f		 pop	 edi
  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??0WZQueue@@QAE@I@Z ENDP				; WZQueue::WZQueue
_TEXT	ENDS
PUBLIC	?Init@WZQueue@@QAEXXZ				; WZQueue::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@WZQueue@@QAEXXZ
_TEXT	SEGMENT
?Init@WZQueue@@QAEXXZ PROC				; WZQueue::Init, COMDAT
; _this$ = ecx

; 23   : 	return;	// Empty
; 24   : }

  00000	c3		 ret	 0
?Init@WZQueue@@QAEXXZ ENDP				; WZQueue::Init
_TEXT	ENDS
PUBLIC	?Free@WZQueue@@QAEXXZ				; WZQueue::Free
; Function compile flags: /Ogtp
;	COMDAT ?Free@WZQueue@@QAEXXZ
_TEXT	SEGMENT
?Free@WZQueue@@QAEXXZ PROC				; WZQueue::Free, COMDAT
; _this$ = ecx

; 28   : 	return;	// Empty
; 29   : }

  00000	c3		 ret	 0
?Free@WZQueue@@QAEXXZ ENDP				; WZQueue::Free
_TEXT	ENDS
PUBLIC	?GetCount@WZQueue@@QAEIXZ			; WZQueue::GetCount
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GetCount@WZQueue@@QAEIXZ
_TEXT	SEGMENT
?GetCount@WZQueue@@QAEIXZ PROC				; WZQueue::GetCount, COMDAT
; _this$ = ecx

; 38   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 39   : 	int nNum;
; 40   : 	EnterCriticalSection(&this->m_CriticalSection);

  00004	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 41   : 	nNum=this->m_Count;

  0000e	8b 36		 mov	 esi, DWORD PTR [esi]

; 42   : 	LeaveCriticalSection(&this->m_CriticalSection);

  00010	57		 push	 edi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00017	5f		 pop	 edi

; 43   : 	return nNum;

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi

; 44   : }

  0001b	c3		 ret	 0
?GetCount@WZQueue@@QAEIXZ ENDP				; WZQueue::GetCount
_TEXT	ENDS
PUBLIC	?AddTail@WZQueue@@AAEHPAU_ListNode@@@Z		; WZQueue::AddTail
; Function compile flags: /Ogtp
;	COMDAT ?AddTail@WZQueue@@AAEHPAU_ListNode@@@Z
_TEXT	SEGMENT
_pNewNode$ = 8						; size = 4
?AddTail@WZQueue@@AAEHPAU_ListNode@@@Z PROC		; WZQueue::AddTail, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 48   : 	BOOL bRet;
; 49   : 	EnterCriticalSection(&this->m_CriticalSection);

  00008	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  0000b	57		 push	 edi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 50   : 	bRet=1;
; 51   : 
; 52   : 	if( this->m_Count < 1280 )

  00012	81 3e 00 05 00
	00		 cmp	 DWORD PTR [esi], 1280	; 00000500H
  00018	bb 01 00 00 00	 mov	 ebx, 1
  0001d	73 48		 jae	 SHORT $LN4@AddTail

; 53   : 	{
; 54   : 		pNewNode->lpNodePre  = this->m_pTail  ;

  0001f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00022	8b 45 08	 mov	 eax, DWORD PTR _pNewNode$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 55   : 		pNewNode->lpNodeNext = 0;

  00027	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 56   : 
; 57   : 		if ( this->m_pHead  ==0 )

  0002e	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00032	75 18		 jne	 SHORT $LN3@AddTail

; 64   : 		}
; 65   : 
; 66   : 		this->m_pTail = pNewNode;
; 67   : 		this->m_Count++;

  00034	ff 06		 inc	 DWORD PTR [esi]

; 68   : 	}
; 69   : 	else
; 70   : 	{
; 71   : 		bRet=0;
; 72   : 	}
; 73   : 
; 74   : 	LeaveCriticalSection(&this->m_CriticalSection);

  00036	57		 push	 edi
  00037	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 75   : 	return bRet;

  00045	8b c3		 mov	 eax, ebx
  00047	5b		 pop	 ebx

; 76   : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN3@AddTail:

; 58   : 		{
; 59   : 			this->m_pHead = pNewNode;
; 60   : 		}
; 61   : 		else
; 62   : 		{
; 63   : 			this->m_pTail->lpNodeNext = pNewNode;

  0004c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0004f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 64   : 		}
; 65   : 
; 66   : 		this->m_pTail = pNewNode;
; 67   : 		this->m_Count++;

  00052	ff 06		 inc	 DWORD PTR [esi]

; 68   : 	}
; 69   : 	else
; 70   : 	{
; 71   : 		bRet=0;
; 72   : 	}
; 73   : 
; 74   : 	LeaveCriticalSection(&this->m_CriticalSection);

  00054	57		 push	 edi
  00055	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 75   : 	return bRet;

  00060	8b c3		 mov	 eax, ebx
  00062	5b		 pop	 ebx

; 76   : }

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
$LN4@AddTail:

; 68   : 	}
; 69   : 	else
; 70   : 	{
; 71   : 		bRet=0;
; 72   : 	}
; 73   : 
; 74   : 	LeaveCriticalSection(&this->m_CriticalSection);

  00067	57		 push	 edi
  00068	33 db		 xor	 ebx, ebx
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 75   : 	return bRet;

  00072	8b c3		 mov	 eax, ebx
  00074	5b		 pop	 ebx

; 76   : }

  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
?AddTail@WZQueue@@AAEHPAU_ListNode@@@Z ENDP		; WZQueue::AddTail
_TEXT	ENDS
PUBLIC	?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ	; WZQueue::GetHeadNode
; Function compile flags: /Ogtp
;	COMDAT ?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ
_TEXT	SEGMENT
?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ PROC		; WZQueue::GetHeadNode, COMDAT
; _this$ = ecx

; 80   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	57		 push	 edi

; 81   : 	LPLISTNODE pNode;
; 82   : 	EnterCriticalSection(&this->m_CriticalSection);

  00005	8d 5e 14	 lea	 ebx, DWORD PTR [esi+20]
  00008	53		 push	 ebx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 83   : 
; 84   : 	pNode=0;
; 85   : 
; 86   : 	if (this->m_pHead != 0)

  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	33 c9		 xor	 ecx, ecx
  00014	33 ff		 xor	 edi, edi
  00016	3b c1		 cmp	 eax, ecx
  00018	74 2b		 je	 SHORT $LN3@GetHeadNod

; 87   : 	{
; 88   : 		pNode=this->m_pHead;

  0001a	8b f8		 mov	 edi, eax

; 89   : 
; 90   : 		if ( this->m_pHead->lpNodeNext   != 0)

  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	3b c1		 cmp	 eax, ecx
  00021	74 1a		 je	 SHORT $LN2@GetHeadNod

; 91   : 		{
; 92   : 			this->m_pHead->lpNodeNext->lpNodePre   = 0; 

  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 93   : 			this->m_pHead = this->m_pHead->lpNodeNext ;

  00025	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 94   : 		}
; 95   : 		else
; 96   : 		{
; 97   : 			this->m_pTail = 0;
; 98   : 			this->m_pHead = 0;
; 99   : 		}
; 100  : 
; 101  : 		this->m_Count --;

  0002b	ff 0e		 dec	 DWORD PTR [esi]

; 102  : 		
; 103  : 	}
; 104  : 
; 105  : 	LeaveCriticalSection(&this->m_CriticalSection );

  0002d	53		 push	 ebx
  0002e	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 106  : 	
; 107  : 	return pNode; 

  00037	8b c7		 mov	 eax, edi
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 108  : }

  0003c	c3		 ret	 0
$LN2@GetHeadNod:

; 94   : 		}
; 95   : 		else
; 96   : 		{
; 97   : 			this->m_pTail = 0;
; 98   : 			this->m_pHead = 0;
; 99   : 		}
; 100  : 
; 101  : 		this->m_Count --;

  0003d	ff 0e		 dec	 DWORD PTR [esi]
  0003f	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00042	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
$LN3@GetHeadNod:

; 102  : 		
; 103  : 	}
; 104  : 
; 105  : 	LeaveCriticalSection(&this->m_CriticalSection );

  00045	53		 push	 ebx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 106  : 	
; 107  : 	return pNode; 

  0004c	8b c7		 mov	 eax, edi
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 108  : }

  00051	c3		 ret	 0
?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ ENDP		; WZQueue::GetHeadNode
_TEXT	ENDS
PUBLIC	?AddToQueue@WZQueue@@QAEHQAEIEH@Z		; WZQueue::AddToQueue
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?AddToQueue@WZQueue@@QAEHQAEIEH@Z
_TEXT	SEGMENT
tv160 = -12						; size = 4
_this$ = -8						; size = 4
_bRet$ = -4						; size = 4
_pObject$ = 8						; size = 4
_nSize$ = 12						; size = 4
_headcode$ = 16						; size = 1
_uindex$ = 20						; size = 4
?AddToQueue@WZQueue@@QAEHQAEIEH@Z PROC			; WZQueue::AddToQueue, COMDAT
; _this$ = ecx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 113  : 	BOOL bRet=0;
; 114  : 	LPLISTNODE pNewNode;
; 115  : 
; 116  : 	EnterCriticalSection(&this->m_CriticalSection );

  00006	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00009	50		 push	 eax
  0000a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0
  00014	89 45 f4	 mov	 DWORD PTR tv160[ebp], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 117  : 
; 118  : 	if (nSize < 1 || nSize > 65536 )

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _nSize$[ebp]
  00020	48		 dec	 eax
  00021	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00026	0f 87 ac 00 00
	00		 ja	 $LN6@AddToQueue

; 121  : 	}
; 122  : 
; 123  : 	pNewNode=(LPLISTNODE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LISTNODE));

  0002c	53		 push	 ebx
  0002d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetProcessHeap@0
  00033	56		 push	 esi
  00034	57		 push	 edi
  00035	6a 20		 push	 32			; 00000020H
  00037	6a 08		 push	 8
  00039	ff d3		 call	 ebx
  0003b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__HeapAlloc@12
  00041	50		 push	 eax
  00042	ff d7		 call	 edi
  00044	8b f0		 mov	 esi, eax

; 124  : 
; 125  : 	if (pNewNode != 0)

  00046	85 f6		 test	 esi, esi
  00048	74 6b		 je	 SHORT $LN5@AddToQueue

; 126  : 	{
; 127  : 		char* p;
; 128  : 		p=(char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nSize);

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0004d	51		 push	 ecx
  0004e	6a 08		 push	 8
  00050	ff d3		 call	 ebx
  00052	50		 push	 eax
  00053	ff d7		 call	 edi
  00055	8b f8		 mov	 edi, eax

; 129  : 
; 130  : 		if (p != 0)

  00057	85 ff		 test	 edi, edi
  00059	74 41		 je	 SHORT $LN4@AddToQueue

; 131  : 		{
; 132  : 			memcpy(p, pObject, nSize);

  0005b	8b 5d 0c	 mov	 ebx, DWORD PTR _nSize$[ebp]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pObject$[ebp]
  00061	53		 push	 ebx
  00062	52		 push	 edx
  00063	57		 push	 edi
  00064	e8 00 00 00 00	 call	 _memcpy

; 133  : 
; 134  : 			pNewNode->pHeapMemory = p;
; 135  : 			pNewNode->nSize = nSize;
; 136  : 			pNewNode->Headcode = headcode;

  00069	8a 45 10	 mov	 al, BYTE PTR _headcode$[ebp]

; 137  : 			pNewNode->uIndex = uindex;

  0006c	8b 4d 14	 mov	 ecx, DWORD PTR _uindex$[ebp]
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	88 46 18	 mov	 BYTE PTR [esi+24], al

; 138  : 			pNewNode->bIsDataSending = 0;

  00075	33 c0		 xor	 eax, eax
  00077	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 139  : 			pNewNode->iBytesSended  = 0;
; 140  : 
; 141  : 			if (this->AddTail(pNewNode) != 0)

  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	56		 push	 esi
  0007e	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00081	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00084	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00087	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0008a	e8 00 00 00 00	 call	 ?AddTail@WZQueue@@AAEHPAU_ListNode@@@Z ; WZQueue::AddTail
  0008f	85 c0		 test	 eax, eax
  00091	74 2f		 je	 SHORT $LN10@AddToQueue

; 142  : 			{
; 143  : 				bRet=1;

  00093	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1

; 144  : 			}
; 145  : 		}
; 146  : 		else

  0009a	eb 26		 jmp	 SHORT $LN10@AddToQueue
$LN4@AddToQueue:

; 147  : 		{
; 148  : 			HeapFree(GetProcessHeap(), 0, p);

  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	ff d3		 call	 ebx
  000a2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__HeapFree@12
  000a8	50		 push	 eax
  000a9	ff d7		 call	 edi

; 149  : 			HeapFree(GetProcessHeap(), 0, pNewNode);

  000ab	56		 push	 esi
  000ac	6a 00		 push	 0
  000ae	ff d3		 call	 ebx
  000b0	50		 push	 eax
  000b1	ff d7		 call	 edi

; 150  : 		}
; 151  : 	}
; 152  : 	else

  000b3	eb 0d		 jmp	 SHORT $LN10@AddToQueue
$LN5@AddToQueue:

; 153  : 	{
; 154  : 		HeapFree(GetProcessHeap(), 0, pNewNode);

  000b5	6a 00		 push	 0
  000b7	6a 00		 push	 0
  000b9	ff d3		 call	 ebx
  000bb	50		 push	 eax
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
$LN10@AddToQueue:

; 155  : 	}
; 156  : 
; 157  : 	LeaveCriticalSection(&this->m_CriticalSection);

  000c2	8b 55 f4	 mov	 edx, DWORD PTR tv160[ebp]
  000c5	52		 push	 edx
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 158  : 	return bRet;

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _bRet$[ebp]
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx

; 159  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c2 10 00	 ret	 16			; 00000010H
$LN6@AddToQueue:

; 119  : 	{
; 120  : 		return FALSE;

  000d8	33 c0		 xor	 eax, eax

; 159  : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 10 00	 ret	 16			; 00000010H
?AddToQueue@WZQueue@@QAEHQAEIEH@Z ENDP			; WZQueue::AddToQueue
_TEXT	ENDS
PUBLIC	?AddToQueueList@WZQueue@@QAEPAU_ListNode@@PAEIEH@Z ; WZQueue::AddToQueueList
; Function compile flags: /Ogtp
;	COMDAT ?AddToQueueList@WZQueue@@QAEPAU_ListNode@@PAEIEH@Z
_TEXT	SEGMENT
tv162 = -8						; size = 4
_this$ = -4						; size = 4
_pObject$ = 8						; size = 4
_nSize$ = 12						; size = 4
_headcode$ = 16						; size = 1
_uindex$ = 20						; size = 4
?AddToQueueList@WZQueue@@QAEPAU_ListNode@@PAEIEH@Z PROC	; WZQueue::AddToQueueList, COMDAT
; _this$ = ecx

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 164  : 	BOOL bRet=0;
; 165  : 	LPLISTNODE pNewNode;
; 166  : 
; 167  : 	if (nSize < 1 || nSize > 65536 )

  00006	8b 45 0c	 mov	 eax, DWORD PTR _nSize$[ebp]
  00009	48		 dec	 eax
  0000a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00012	0f 87 d7 00 00
	00		 ja	 $LN6@AddToQueue@2

; 170  : 	}
; 171  : 
; 172  : 	EnterCriticalSection(&this->m_CriticalSection );

  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  0001d	57		 push	 edi
  0001e	50		 push	 eax
  0001f	89 45 f8	 mov	 DWORD PTR tv162[ebp], eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 173  : 
; 174  : 	pNewNode=(LPLISTNODE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LISTNODE));

  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetProcessHeap@0
  0002e	6a 20		 push	 32			; 00000020H
  00030	6a 08		 push	 8
  00032	ff d7		 call	 edi
  00034	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__HeapAlloc@12
  0003a	50		 push	 eax
  0003b	ff d3		 call	 ebx
  0003d	8b f0		 mov	 esi, eax

; 175  : 
; 176  : 	if (pNewNode != 0)

  0003f	85 f6		 test	 esi, esi
  00041	0f 84 86 00 00
	00		 je	 $LN5@AddToQueue@2

; 177  : 	{
; 178  : 		char* p;
; 179  : 		p=(char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nSize);

  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0004a	51		 push	 ecx
  0004b	6a 08		 push	 8
  0004d	ff d7		 call	 edi
  0004f	50		 push	 eax
  00050	ff d3		 call	 ebx
  00052	8b d8		 mov	 ebx, eax

; 180  : 
; 181  : 		if (p != 0)

  00054	85 db		 test	 ebx, ebx
  00056	74 49		 je	 SHORT $LN4@AddToQueue@2

; 182  : 		{
; 183  : 			memcpy(p, pObject, nSize);

  00058	8b 7d 0c	 mov	 edi, DWORD PTR _nSize$[ebp]
  0005b	8b 55 08	 mov	 edx, DWORD PTR _pObject$[ebp]
  0005e	57		 push	 edi
  0005f	52		 push	 edx
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memcpy

; 184  : 
; 185  : 			pNewNode->pHeapMemory = p;
; 186  : 			pNewNode->nSize = nSize;
; 187  : 			pNewNode->Headcode = headcode;

  00066	8a 45 10	 mov	 al, BYTE PTR _headcode$[ebp]

; 188  : 			pNewNode->uIndex = uindex;

  00069	8b 4d 14	 mov	 ecx, DWORD PTR _uindex$[ebp]
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	88 46 18	 mov	 BYTE PTR [esi+24], al

; 189  : 			pNewNode->bIsDataSending = 0;

  00072	33 c0		 xor	 eax, eax
  00074	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 190  : 			pNewNode->iBytesSended  = 0;
; 191  : 
; 192  : 			if (this->AddTail(pNewNode) != 0)

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	56		 push	 esi
  0007b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0007e	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00081	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00084	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00087	e8 00 00 00 00	 call	 ?AddTail@WZQueue@@AAEHPAU_ListNode@@@Z ; WZQueue::AddTail

; 206  : 	}
; 207  : 
; 208  : 	LeaveCriticalSection(&this->m_CriticalSection);

  0008c	8b 55 f8	 mov	 edx, DWORD PTR tv162[ebp]
  0008f	52		 push	 edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00096	5f		 pop	 edi

; 209  : 	return pNewNode;

  00097	8b c6		 mov	 eax, esi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 210  : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 10 00	 ret	 16			; 00000010H
$LN4@AddToQueue@2:

; 193  : 			{
; 194  : 				bRet=1;
; 195  : 			}
; 196  : 		}
; 197  : 		else
; 198  : 		{
; 199  : 			HeapFree(GetProcessHeap(), 0, p);

  000a1	6a 00		 push	 0
  000a3	6a 00		 push	 0
  000a5	ff d7		 call	 edi
  000a7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__HeapFree@12
  000ad	50		 push	 eax
  000ae	ff d3		 call	 ebx

; 200  : 			HeapFree(GetProcessHeap(), 0, pNewNode);

  000b0	56		 push	 esi
  000b1	6a 00		 push	 0
  000b3	ff d7		 call	 edi
  000b5	50		 push	 eax
  000b6	ff d3		 call	 ebx

; 206  : 	}
; 207  : 
; 208  : 	LeaveCriticalSection(&this->m_CriticalSection);

  000b8	8b 55 f8	 mov	 edx, DWORD PTR tv162[ebp]
  000bb	52		 push	 edx
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000c2	5f		 pop	 edi

; 209  : 	return pNewNode;

  000c3	8b c6		 mov	 eax, esi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx

; 210  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 10 00	 ret	 16			; 00000010H
$LN5@AddToQueue@2:

; 201  : 		}
; 202  : 	}
; 203  : 	else
; 204  : 	{
; 205  : 		HeapFree(GetProcessHeap(), 0, pNewNode);

  000cd	6a 00		 push	 0
  000cf	6a 00		 push	 0
  000d1	ff d7		 call	 edi
  000d3	50		 push	 eax
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 206  : 	}
; 207  : 
; 208  : 	LeaveCriticalSection(&this->m_CriticalSection);

  000da	8b 55 f8	 mov	 edx, DWORD PTR tv162[ebp]
  000dd	52		 push	 edx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000e4	5f		 pop	 edi

; 209  : 	return pNewNode;

  000e5	8b c6		 mov	 eax, esi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx

; 210  : }

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 10 00	 ret	 16			; 00000010H
$LN6@AddToQueue@2:

; 168  : 	{
; 169  : 		return FALSE;

  000ef	33 c0		 xor	 eax, eax

; 210  : }

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 10 00	 ret	 16			; 00000010H
?AddToQueueList@WZQueue@@QAEPAU_ListNode@@PAEIEH@Z ENDP	; WZQueue::AddToQueueList
_TEXT	ENDS
PUBLIC	?GetFromQueue@WZQueue@@QAEHPAEPAI0PAH@Z		; WZQueue::GetFromQueue
; Function compile flags: /Ogtp
;	COMDAT ?GetFromQueue@WZQueue@@QAEHPAEPAI0PAH@Z
_TEXT	SEGMENT
_pObject$ = 8						; size = 4
_pSize$ = 12						; size = 4
_headcode$ = 16						; size = 4
_uindex$ = 20						; size = 4
?GetFromQueue@WZQueue@@QAEHPAEPAI0PAH@Z PROC		; WZQueue::GetFromQueue, COMDAT
; _this$ = ecx

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 215  : 	LPLISTNODE pNode=0;
; 216  : 
; 217  : 	pNode = this->GetHeadNode();

  00007	e8 00 00 00 00	 call	 ?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ ; WZQueue::GetHeadNode
  0000c	8b f0		 mov	 esi, eax

; 218  : 
; 219  : 	if ( pNode != 0 )

  0000e	85 f6		 test	 esi, esi
  00010	74 6b		 je	 SHORT $LN1@GetFromQue

; 220  : 	{
; 221  : 		EnterCriticalSection(&this->m_CriticalSection);

  00012	53		 push	 ebx
  00013	83 c7 14	 add	 edi, 20			; 00000014H
  00016	57		 push	 edi
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 222  : 
; 223  : 		memcpy(pObject, pNode->pHeapMemory , pNode->nSize);

  0001d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00020	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00023	8b 55 08	 mov	 edx, DWORD PTR _pObject$[ebp]
  00026	50		 push	 eax
  00027	51		 push	 ecx
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 _memcpy

; 224  : 
; 225  : 		*pSize = pNode->nSize;

  0002e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _pSize$[ebp]

; 226  : 		*headcode = pNode->Headcode;
; 227  : 		*uindex = pNode->uIndex;
; 228  : 
; 229  : 		HeapFree(GetProcessHeap(), 0, pNode->pHeapMemory);

  00034	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetProcessHeap@0
  0003a	89 01		 mov	 DWORD PTR [ecx], eax
  0003c	8a 56 18	 mov	 dl, BYTE PTR [esi+24]
  0003f	8b 45 10	 mov	 eax, DWORD PTR _headcode$[ebp]
  00042	88 10		 mov	 BYTE PTR [eax], dl
  00044	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00047	8b 55 14	 mov	 edx, DWORD PTR _uindex$[ebp]
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	89 0a		 mov	 DWORD PTR [edx], ecx
  0004f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	ff d3		 call	 ebx
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 230  : 		HeapFree(GetProcessHeap(), 0, pNode);

  0005e	56		 push	 esi
  0005f	6a 00		 push	 0
  00061	ff d3		 call	 ebx
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 231  : 
; 232  : 		LeaveCriticalSection(&this->m_CriticalSection);

  0006a	57		 push	 edi
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00071	5b		 pop	 ebx
  00072	5f		 pop	 edi

; 233  : 		return TRUE;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	5e		 pop	 esi

; 236  : }

  00079	5d		 pop	 ebp
  0007a	c2 10 00	 ret	 16			; 00000010H
$LN1@GetFromQue:
  0007d	5f		 pop	 edi

; 234  : 	}
; 235  : 	return FALSE;

  0007e	33 c0		 xor	 eax, eax
  00080	5e		 pop	 esi

; 236  : }

  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?GetFromQueue@WZQueue@@QAEHPAEPAI0PAH@Z ENDP		; WZQueue::GetFromQueue
_TEXT	ENDS
PUBLIC	?DeleteAllNodes@WZQueue@@AAEXXZ			; WZQueue::DeleteAllNodes
; Function compile flags: /Ogtp
;	COMDAT ?DeleteAllNodes@WZQueue@@AAEXXZ
_TEXT	SEGMENT
tv128 = -4						; size = 4
?DeleteAllNodes@WZQueue@@AAEXXZ PROC			; WZQueue::DeleteAllNodes, COMDAT
; _this$ = ecx

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 241  : 	LPLISTNODE pNode=0;
; 242  : 
; 243  : 	EnterCriticalSection(&this->m_CriticalSection);

  00008	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  0000b	57		 push	 edi
  0000c	89 7d fc	 mov	 DWORD PTR tv128[ebp], edi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 244  : 
; 245  : 	while ( (pNode=this->GetHeadNode() ) != 0 )

  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 ?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ ; WZQueue::GetHeadNode
  0001c	85 c0		 test	 eax, eax
  0001e	74 27		 je	 SHORT $LN1@DeleteAllN
  00020	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__HeapFree@12
  00026	53		 push	 ebx
  00027	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetProcessHeap@0
  0002d	8d 49 00	 npad	 3
$LL2@DeleteAllN:

; 246  : 	{
; 247  : 		HeapFree(GetProcessHeap(), 0, pNode);

  00030	50		 push	 eax
  00031	6a 00		 push	 0
  00033	ff d3		 call	 ebx
  00035	50		 push	 eax
  00036	ff d7		 call	 edi
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ?GetHeadNode@WZQueue@@AAEPAU_ListNode@@XZ ; WZQueue::GetHeadNode
  0003f	85 c0		 test	 eax, eax
  00041	75 ed		 jne	 SHORT $LL2@DeleteAllN

; 244  : 
; 245  : 	while ( (pNode=this->GetHeadNode() ) != 0 )

  00043	8b 7d fc	 mov	 edi, DWORD PTR tv128[ebp]
  00046	5b		 pop	 ebx
$LN1@DeleteAllN:

; 248  : 	}
; 249  : 
; 250  : 	LeaveCriticalSection(&this->m_CriticalSection);

  00047	57		 push	 edi
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi

; 251  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?DeleteAllNodes@WZQueue@@AAEXXZ ENDP			; WZQueue::DeleteAllNodes
_TEXT	ENDS
PUBLIC	?StartQ@WZQueue@@QAEHXZ				; WZQueue::StartQ
; Function compile flags: /Ogtp
;	COMDAT ?StartQ@WZQueue@@QAEHXZ
_TEXT	SEGMENT
?StartQ@WZQueue@@QAEHXZ PROC				; WZQueue::StartQ, COMDAT
; _this$ = ecx

; 255  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 256  : 	if ( this->m_pHead != 0 )

  00003	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00007	74 20		 je	 SHORT $LN1@StartQ

; 257  : 	{
; 258  : 		EnterCriticalSection(&this->m_CriticalSection); 

  00009	57		 push	 edi
  0000a	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  0000d	57		 push	 edi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 259  : 		this->m_pCur = this->m_pHead;

  00014	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 260  : 		LeaveCriticalSection(&this->m_CriticalSection);

  00017	57		 push	 edi
  00018	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00021	5f		 pop	 edi

; 261  : 		return TRUE;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	5e		 pop	 esi

; 264  : }

  00028	c3		 ret	 0
$LN1@StartQ:

; 262  : 	}
; 263  : 	return FALSE;

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 264  : }

  0002c	c3		 ret	 0
?StartQ@WZQueue@@QAEHXZ ENDP				; WZQueue::StartQ
_TEXT	ENDS
PUBLIC	?NextQ@WZQueue@@QAEHXZ				; WZQueue::NextQ
; Function compile flags: /Ogtp
;	COMDAT ?NextQ@WZQueue@@QAEHXZ
_TEXT	SEGMENT
?NextQ@WZQueue@@QAEHXZ PROC				; WZQueue::NextQ, COMDAT
; _this$ = ecx

; 267  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 268  : 	if ( this->m_pCur  != 0 )

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	74 29		 je	 SHORT $LN1@NextQ

; 269  : 	{
; 270  : 		if ( this->m_pCur->lpNodeNext  != 0 )

  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 23		 je	 SHORT $LN1@NextQ

; 271  : 		{
; 272  : 			EnterCriticalSection(&this->m_CriticalSection); 

  00010	57		 push	 edi
  00011	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00014	57		 push	 edi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 273  : 			this->m_pCur = this->m_pCur->lpNodeNext ;

  0001b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 274  : 			LeaveCriticalSection(&this->m_CriticalSection);

  00021	57		 push	 edi
  00022	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0002b	5f		 pop	 edi

; 275  : 			return TRUE;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	5e		 pop	 esi

; 279  : }

  00032	c3		 ret	 0
$LN1@NextQ:

; 276  : 		}
; 277  : 	}
; 278  : 	return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 279  : }

  00036	c3		 ret	 0
?NextQ@WZQueue@@QAEHXZ ENDP				; WZQueue::NextQ
_TEXT	ENDS
PUBLIC	?GetCurData@WZQueue@@QAEPAU_ListNode@@PAEPAI0PAH@Z ; WZQueue::GetCurData
; Function compile flags: /Ogtp
;	COMDAT ?GetCurData@WZQueue@@QAEPAU_ListNode@@PAEPAI0PAH@Z
_TEXT	SEGMENT
_pObject$ = 8						; size = 4
_pSize$ = 12						; size = 4
_headcode$ = 16						; size = 4
_uindex$ = 20						; size = 4
?GetCurData@WZQueue@@QAEPAU_ListNode@@PAEPAI0PAH@Z PROC	; WZQueue::GetCurData, COMDAT
; _this$ = ecx

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 283  : 	if ( this->m_pCur != 0 )

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	85 c0		 test	 eax, eax
  0000b	74 43		 je	 SHORT $LN2@GetCurData

; 284  : 	{
; 285  : 		if ( this->m_pCur->bIsDataSending == 1 )

  0000d	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1

; 286  : 		{
; 287  : 			return NULL;

  00011	74 3d		 je	 SHORT $LN2@GetCurData

; 288  : 		}
; 289  : 
; 290  : 		memcpy(pObject, this->m_pCur->pHeapMemory , this->m_pCur->nSize); 

  00013	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00016	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00019	8b 45 08	 mov	 eax, DWORD PTR _pObject$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _memcpy

; 291  : 
; 292  : 		*pSize = this->m_pCur->nSize;

  00024	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00027	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _pSize$[ebp]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 293  : 		*headcode = this->m_pCur->Headcode;

  0002f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00032	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  00035	8b 45 10	 mov	 eax, DWORD PTR _headcode$[ebp]
  00038	88 10		 mov	 BYTE PTR [eax], dl

; 294  : 		*uindex = this->m_pCur->uIndex;

  0003a	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003d	8b 45 14	 mov	 eax, DWORD PTR _uindex$[ebp]
  00040	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 10		 mov	 DWORD PTR [eax], edx

; 295  : 
; 296  : 		return this->m_pCur;

  00048	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0004b	5e		 pop	 esi

; 300  : }

  0004c	5d		 pop	 ebp
  0004d	c2 10 00	 ret	 16			; 00000010H
$LN2@GetCurData:

; 297  : 	}
; 298  : 
; 299  : 	return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	5e		 pop	 esi

; 300  : }

  00053	5d		 pop	 ebp
  00054	c2 10 00	 ret	 16			; 00000010H
?GetCurData@WZQueue@@QAEPAU_ListNode@@PAEPAI0PAH@Z ENDP	; WZQueue::GetCurData
_TEXT	ENDS
PUBLIC	?Pop@WZQueue@@QAEHPAU_ListNode@@PAEHPAH2@Z	; WZQueue::Pop
EXTRN	___security_cookie:DWORD
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?Pop@WZQueue@@QAEHPAU_ListNode@@PAEHPAH2@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffd0H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN7@Pop
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?Pop@WZQueue@@QAEHPAU_ListNode@@PAEHPAH2@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_bRet$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pCur$ = 8						; size = 4
_pObject$ = 12						; size = 4
_nOfs$ = 16						; size = 4
_nSize$ = 20						; size = 4
_sendbytes$ = 24					; size = 4
?Pop@WZQueue@@QAEHPAU_ListNode@@PAEHPAH2@Z PROC		; WZQueue::Pop, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?Pop@WZQueue@@QAEHPAU_ListNode@@PAEHPAH2@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 10	 sub	 esp, 16			; 00000010H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	8b f9		 mov	 edi, ecx
  00032	89 7d e0	 mov	 DWORD PTR _this$[ebp], edi

; 304  : 	BOOL bRet=FALSE;

  00035	33 c0		 xor	 eax, eax
  00037	89 45 e4	 mov	 DWORD PTR _bRet$[ebp], eax

; 305  : 
; 306  : 	if ( pCur != 0 )

  0003a	8b 75 08	 mov	 esi, DWORD PTR _pCur$[ebp]
  0003d	3b f0		 cmp	 esi, eax
  0003f	74 5a		 je	 SHORT $LN10@Pop

; 307  : 	{
; 308  : 		__try

  00041	89 45 fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], eax

; 309  : 		{
; 310  : 			EnterCriticalSection(&this->m_CriticalSection);

  00044	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 311  : 			pCur->iBytesSended  = pCur->iBytesSended  + nOfs;

  0004e	8b 55 10	 mov	 edx, DWORD PTR _nOfs$[ebp]
  00051	01 56 14	 add	 DWORD PTR [esi+20], edx
  00054	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 312  : 
; 313  : 			if ( (pCur->nSize-nOfs) != 0 )

  00057	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0005a	8b d8		 mov	 ebx, eax
  0005c	2b da		 sub	 ebx, edx
  0005e	74 2f		 je	 SHORT $LN1@Pop

; 314  : 			{
; 315  : 				memcpy(pObject, &pCur->pHeapMemory[pCur->iBytesSended ], pCur->nSize - pCur->iBytesSended );

  00060	2b c1		 sub	 eax, ecx
  00062	50		 push	 eax
  00063	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00066	03 d1		 add	 edx, ecx
  00068	52		 push	 edx
  00069	8b 45 0c	 mov	 eax, DWORD PTR _pObject$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _memcpy
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  : 				*nSize = pCur->nSize - pCur->iBytesSended ;

  00075	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00078	2b 4e 14	 sub	 ecx, DWORD PTR [esi+20]
  0007b	8b 55 14	 mov	 edx, DWORD PTR _nSize$[ebp]
  0007e	89 0a		 mov	 DWORD PTR [edx], ecx

; 317  : 				*sendbytes = pCur->iBytesSended ;

  00080	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00083	8b 4d 18	 mov	 ecx, DWORD PTR _sendbytes$[ebp]
  00086	89 01		 mov	 DWORD PTR [ecx], eax

; 318  : 				bRet=TRUE;

  00088	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN1@Pop:

; 319  : 			}
; 320  : 		}
; 321  : 
; 322  : 		__finally

  0008f	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00096	e8 1a 00 00 00	 call	 $LN9@Pop
$LN10@Pop:

; 325  : 		}
; 326  : 	}
; 327  : 
; 328  : 	return bRet;

  0009b	8b 45 e4	 mov	 eax, DWORD PTR _bRet$[ebp]

; 329  : }

  0009e	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 14 00	 ret	 20			; 00000014H
$LN7@Pop:
$LN13@Pop:

; 319  : 			}
; 320  : 		}
; 321  : 
; 322  : 		__finally

  000b2	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
$LN9@Pop:

; 323  : 		{
; 324  : 			LeaveCriticalSection(&this->m_CriticalSection);

  000b5	83 c7 14	 add	 edi, 20			; 00000014H
  000b8	57		 push	 edi
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN8@Pop:
$LN12@Pop:
  000bf	c3		 ret	 0
?Pop@WZQueue@@QAEHPAU_ListNode@@PAEHPAH2@Z ENDP		; WZQueue::Pop
_TEXT	ENDS
PUBLIC	?SetCurDataSending@WZQueue@@QAEXPAU_ListNode@@@Z ; WZQueue::SetCurDataSending
; Function compile flags: /Ogtp
;	COMDAT ?SetCurDataSending@WZQueue@@QAEXPAU_ListNode@@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?SetCurDataSending@WZQueue@@QAEXPAU_ListNode@@@Z PROC	; WZQueue::SetCurDataSending, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 334  : 	if ( pNode != NULL )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _pNode$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 1a		 je	 SHORT $LN1@SetCurData

; 335  : 	{
; 336  : 		EnterCriticalSection(&this->m_CriticalSection);

  0000b	56		 push	 esi
  0000c	8d 71 14	 lea	 esi, DWORD PTR [ecx+20]
  0000f	56		 push	 esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 337  : 		pNode->bIsDataSending = TRUE;
; 338  : 		LeaveCriticalSection(&this->m_CriticalSection);

  00016	56		 push	 esi
  00017	c7 47 10 01 00
	00 00		 mov	 DWORD PTR [edi+16], 1
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00024	5e		 pop	 esi
$LN1@SetCurData:
  00025	5f		 pop	 edi

; 339  : 	}
; 340  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?SetCurDataSending@WZQueue@@QAEXPAU_ListNode@@@Z ENDP	; WZQueue::SetCurDataSending
_TEXT	ENDS
PUBLIC	?DeleteNode@WZQueue@@QAEXPAU_ListNode@@@Z	; WZQueue::DeleteNode
; Function compile flags: /Ogtp
;	COMDAT ?DeleteNode@WZQueue@@QAEXPAU_ListNode@@@Z
_TEXT	SEGMENT
tv192 = -4						; size = 4
_pCur$ = 8						; size = 4
?DeleteNode@WZQueue@@QAEXPAU_ListNode@@@Z PROC		; WZQueue::DeleteNode, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx

; 344  : 	LPLISTNODE pNode=0;
; 345  : 	LPLISTNODE pPre=0;
; 346  : 	LPLISTNODE pNext=0;
; 347  : 
; 348  : 	EnterCriticalSection(&this->m_CriticalSection);

  00008	8d 73 14	 lea	 esi, DWORD PTR [ebx+20]
  0000b	56		 push	 esi
  0000c	89 75 fc	 mov	 DWORD PTR tv192[ebp], esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 349  : 
; 350  : 	if ( pCur != NULL )

  00015	8b 45 08	 mov	 eax, DWORD PTR _pCur$[ebp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	3b c1		 cmp	 eax, ecx
  0001c	0f 84 83 00 00
	00		 je	 $LN13@DeleteNode

; 351  : 	{
; 352  : 		pNode = pCur;
; 353  : 		pPre = pCur->lpNodePre;

  00022	8b 30		 mov	 esi, DWORD PTR [eax]
  00024	57		 push	 edi

; 354  : 		pNext= pCur->lpNodeNext;

  00025	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 355  : 
; 356  : 		if ( pPre == 0 && pNext == 0 )

  00028	3b f1		 cmp	 esi, ecx
  0002a	75 10		 jne	 SHORT $LN16@DeleteNode
  0002c	3b f9		 cmp	 edi, ecx
  0002e	75 05		 jne	 SHORT $LN18@DeleteNode

; 357  : 		{
; 358  : 			this->m_pHead = pCur;

  00030	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00033	eb 35		 jmp	 SHORT $LN2@DeleteNode
$LN18@DeleteNode:

; 359  : 		}
; 360  : 		else if ( pPre == 0 && pNext != 0 )
; 361  : 		{
; 362  : 			pNext->lpNodePre = 0;

  00035	89 0f		 mov	 DWORD PTR [edi], ecx

; 363  : 			pCur = pNext;
; 364  : 			this->m_pHead=pCur;

  00037	89 7b 08	 mov	 DWORD PTR [ebx+8], edi

; 365  : 
; 366  : 			if ( pNext->lpNodeNext == 0 )
; 367  : 			{
; 368  : 				this->m_pTail=pNext;
; 369  : 				this->m_pTail->lpNodeNext =0;
; 370  : 			}
; 371  : 		}

  0003a	eb 23		 jmp	 SHORT $LN3@DeleteNode
$LN16@DeleteNode:

; 372  : 		else if ( pPre != 0 && pNext == 0 )

  0003c	3b f9		 cmp	 edi, ecx
  0003e	75 11		 jne	 SHORT $LN7@DeleteNode

; 373  : 		{
; 374  : 			pPre->lpNodeNext = 0;

  00040	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 375  : 			pCur = pPre;
; 376  : 			this->m_pTail = pCur;

  00043	89 73 0c	 mov	 DWORD PTR [ebx+12], esi

; 377  : 
; 378  : 			if ( pPre->lpNodePre == 0 )

  00046	39 0e		 cmp	 DWORD PTR [esi], ecx
  00048	75 20		 jne	 SHORT $LN2@DeleteNode

; 379  : 			{
; 380  : 				this->m_pHead = pPre;

  0004a	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 381  : 				this->m_pHead->lpNodePre = 0;

  0004d	89 0e		 mov	 DWORD PTR [esi], ecx

; 382  : 			}
; 383  : 		}

  0004f	eb 19		 jmp	 SHORT $LN2@DeleteNode
$LN7@DeleteNode:

; 384  : 		else if ( pPre != 0 && pNext != 0 )
; 385  : 		{
; 386  : 			pPre->lpNodeNext = pNext;

  00051	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 387  : 			pNext->lpNodePre = pPre;

  00054	89 37		 mov	 DWORD PTR [edi], esi

; 388  : 
; 389  : 			if ( pPre->lpNodePre == 0 )

  00056	39 0e		 cmp	 DWORD PTR [esi], ecx
  00058	75 05		 jne	 SHORT $LN3@DeleteNode

; 390  : 			{
; 391  : 				this->m_pHead = pPre;

  0005a	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 392  : 				this->m_pHead->lpNodePre = NULL;

  0005d	89 0e		 mov	 DWORD PTR [esi], ecx
$LN3@DeleteNode:

; 393  : 			}
; 394  : 
; 395  : 			if ( pNext->lpNodeNext == NULL )

  0005f	39 4f 04	 cmp	 DWORD PTR [edi+4], ecx
  00062	75 06		 jne	 SHORT $LN2@DeleteNode

; 396  : 			{
; 397  : 				this->m_pTail = pNext;

  00064	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi

; 398  : 				this->m_pTail->lpNodeNext = NULL;

  00067	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN2@DeleteNode:

; 399  : 			}
; 400  : 		}
; 401  : 
; 402  : 		HeapFree( GetProcessHeap(), 0, pNode->pHeapMemory  );

  0006a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006d	50		 push	 eax
  0006e	51		 push	 ecx
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 403  : 		HeapFree( GetProcessHeap(), 0, pNode);

  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _pCur$[ebp]
  0007f	51		 push	 ecx
  00080	6a 00		 push	 0
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00088	50		 push	 eax
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 404  : 
; 405  : 		if ( pPre == NULL && pNext == NULL )

  0008f	33 c0		 xor	 eax, eax
  00091	3b f0		 cmp	 esi, eax
  00093	75 0a		 jne	 SHORT $LN1@DeleteNode
  00095	3b f8		 cmp	 edi, eax
  00097	75 06		 jne	 SHORT $LN1@DeleteNode

; 406  : 		{
; 407  : 			this->m_pHead = NULL;

  00099	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 408  : 			pCur = NULL;
; 409  : 			this->m_pTail = NULL;

  0009c	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
$LN1@DeleteNode:

; 410  : 		}
; 411  : 		
; 412  : 		this->m_Count --;

  0009f	ff 0b		 dec	 DWORD PTR [ebx]
  000a1	8b 75 fc	 mov	 esi, DWORD PTR tv192[ebp]
  000a4	5f		 pop	 edi
$LN13@DeleteNode:

; 413  : 		
; 414  : 	}
; 415  : 
; 416  : 	LeaveCriticalSection(&this->m_CriticalSection);

  000a5	56		 push	 esi
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 417  : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
?DeleteNode@WZQueue@@QAEXPAU_ListNode@@@Z ENDP		; WZQueue::DeleteNode
_TEXT	ENDS
PUBLIC	??1WZQueue@@QAE@XZ				; WZQueue::~WZQueue
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ??1WZQueue@@QAE@XZ
_TEXT	SEGMENT
??1WZQueue@@QAE@XZ PROC					; WZQueue::~WZQueue, COMDAT
; _this$ = ecx

; 32   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 33   : 	this->DeleteAllNodes();

  00003	e8 00 00 00 00	 call	 ?DeleteAllNodes@WZQueue@@AAEXXZ ; WZQueue::DeleteAllNodes

; 34   : 	DeleteCriticalSection(&this->m_CriticalSection );

  00008	83 c6 14	 add	 esi, 20			; 00000014H
  0000b	56		 push	 esi
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00012	5e		 pop	 esi

; 35   : }

  00013	c3		 ret	 0
??1WZQueue@@QAE@XZ ENDP					; WZQueue::~WZQueue
_TEXT	ENDS
END
