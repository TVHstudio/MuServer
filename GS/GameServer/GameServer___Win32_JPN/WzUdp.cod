; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\WzUdp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
PUBLIC	?Init@WzUdp@@QAEHXZ				; WzUdp::Init
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\wzudp.cpp
;	COMDAT ?Init@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_wsd$ = -404						; size = 400
__$ArrayPad$ = -4					; size = 4
?Init@WzUdp@@QAEHXZ PROC				; WzUdp::Init, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 29   : 	WSADATA			wsd;
; 30   : 
; 31   : 	if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)

  00014	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _wsd$[ebp]
  0001a	50		 push	 eax
  0001b	68 02 02 00 00	 push	 514			; 00000202H
  00020	8b f1		 mov	 esi, ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  00028	85 c0		 test	 eax, eax
  0002a	74 11		 je	 SHORT $LN1@Init

; 32   :     {        
; 33   :         return FALSE;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 34   :     }
; 35   : 	m_Socket = -1;//Season 4.5 changed
; 36   : 	m_dwLength  = DEFAULT_BUFFER_LENGTH;
; 37   : 	m_dwRecvOfs = 0;
; 38   : 	m_ThreadHandle = NULL;
; 39   : 	ProtocolCore   = NULL;
; 40   : 	return TRUE;
; 41   : }

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN1@Init:
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 c0		 xor	 eax, eax
  00042	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00045	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00048	89 86 5c 08 00
	00		 mov	 DWORD PTR [esi+2140], eax
  0004e	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
  00055	c7 46 1c 00 10
	00 00		 mov	 DWORD PTR [esi+28], 4096 ; 00001000H
  0005c	33 cd		 xor	 ecx, ebp
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?Init@WzUdp@@QAEHXZ ENDP				; WzUdp::Init
_TEXT	ENDS
PUBLIC	?Close@WzUdp@@QAEHXZ				; WzUdp::Close
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__TerminateThread@8:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Close@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?Close@WzUdp@@QAEHXZ PROC				; WzUdp::Close, COMDAT
; _this$ = ecx

; 44   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 45   : 	TerminateThread(m_ThreadHandle, 0);

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	6a 00		 push	 0
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 46   : 	if( m_ThreadHandle != NULL )

  0000f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00012	85 c0		 test	 eax, eax
  00014	74 1a		 je	 SHORT $LN1@Close

; 47   : 	{
; 48   : 		WaitForSingleObject( m_ThreadHandle, INFINITE );

  00016	6a ff		 push	 -1
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 49   : 		CloseHandle(m_ThreadHandle);

  0001f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00022	51		 push	 ecx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 50   : 		m_ThreadHandle = NULL;

  00029	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Close:

; 51   : 	}
; 52   : 	HeapFree(GetProcessHeap(), 0, m_Recvbuf);

  00030	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00033	52		 push	 edx
  00034	6a 00		 push	 0
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 53   : 	return TRUE;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	5e		 pop	 esi

; 54   : }	

  00049	c3		 ret	 0
?Close@WzUdp@@QAEHXZ ENDP				; WzUdp::Close
_TEXT	ENDS
PUBLIC	?CreateSocket@WzUdp@@QAEHXZ			; WzUdp::CreateSocket
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	__imp__closesocket@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CreateSocket@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?CreateSocket@WzUdp@@QAEHXZ PROC			; WzUdp::CreateSocket, COMDAT
; _this$ = ecx

; 57   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 58   : 	if( m_Socket != INVALID_SOCKET)//Season 4.5 addon

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 0e		 je	 SHORT $LN2@CreateSock

; 59   : 	{
; 60   : 		closesocket(m_Socket);

  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 61   : 		m_Socket = -1;

  00012	c7 46 10 ff ff
	ff ff		 mov	 DWORD PTR [esi+16], -1
$LN2@CreateSock:

; 62   : 	}
; 63   : 
; 64   : 	m_Socket = WSASocket(AF_INET, SOCK_DGRAM, 0, NULL, 0, NULL);

  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	6a 00		 push	 0
  00021	6a 02		 push	 2
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24

; 65   :     
; 66   : 	if( m_Socket == INVALID_SOCKET )

  0002b	33 c9		 xor	 ecx, ecx
  0002d	83 f8 ff	 cmp	 eax, -1
  00030	0f 95 c1	 setne	 cl
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	5e		 pop	 esi
  00037	8b c1		 mov	 eax, ecx

; 67   :     {        
; 68   :         return FALSE;
; 69   :     }
; 70   : 	return TRUE;
; 71   : }

  00039	c3		 ret	 0
?CreateSocket@WzUdp@@QAEHXZ ENDP			; WzUdp::CreateSocket
_TEXT	ENDS
PUBLIC	?SendSet@WzUdp@@QAEHPADH@Z			; WzUdp::SendSet
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendSet@WzUdp@@QAEHPADH@Z
_TEXT	SEGMENT
_ip$ = 8						; size = 4
_port$ = 12						; size = 4
?SendSet@WzUdp@@QAEHPADH@Z PROC				; WzUdp::SendSet, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	m_Port					= port;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _port$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 76   :     m_SockAddr.sin_family	= AF_INET;

  0000a	b9 02 00 00 00	 mov	 ecx, 2

; 77   :     m_SockAddr.sin_port		= htons(port);

  0000f	50		 push	 eax
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00013	66 89 8e 4c 08
	00 00		 mov	 WORD PTR [esi+2124], cx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 78   : 	if( (m_SockAddr.sin_addr.s_addr	= inet_addr(ip)) == INADDR_NONE )

  00020	8b 7d 08	 mov	 edi, DWORD PTR _ip$[ebp]
  00023	57		 push	 edi
  00024	66 89 86 4e 08
	00 00		 mov	 WORD PTR [esi+2126], ax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00031	81 c6 50 08 00
	00		 add	 esi, 2128		; 00000850H
  00037	89 06		 mov	 DWORD PTR [esi], eax
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	75 1f		 jne	 SHORT $LN1@SendSet

; 79   : 	{
; 80   : 		struct hostent *host=NULL;
; 81   : 		host = gethostbyname(ip);

  0003e	57		 push	 edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 82   : 		if( host )

  00045	85 c0		 test	 eax, eax
  00047	74 1f		 je	 SHORT $LN2@SendSet

; 83   : 		{
; 84   : 			CopyMemory(&m_SockAddr.sin_addr, host->h_addr_list[0], host->h_length);

  00049	0f bf 50 0a	 movsx	 edx, WORD PTR [eax+10]
  0004d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	52		 push	 edx
  00053	51		 push	 ecx
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 _memcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SendSet:

; 89   : 		}
; 90   : 	}
; 91   : 	return TRUE;

  0005d	5f		 pop	 edi
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	5e		 pop	 esi

; 92   : }

  00064	5d		 pop	 ebp
  00065	c2 08 00	 ret	 8
$LN2@SendSet:
  00068	5f		 pop	 edi

; 85   : 		}
; 86   : 		else
; 87   : 		{		
; 88   : 			return FALSE;

  00069	33 c0		 xor	 eax, eax
  0006b	5e		 pop	 esi

; 92   : }

  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?SendSet@WzUdp@@QAEHPADH@Z ENDP				; WzUdp::SendSet
_TEXT	ENDS
PUBLIC	?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z	; WzUdp::SetProtocolCore
; Function compile flags: /Ogtp
;	COMDAT ?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z
_TEXT	SEGMENT
_pc$ = 8						; size = 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z PROC		; WzUdp::SetProtocolCore, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 	ProtocolCore = pc;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pc$[ebp]
  00006	89 81 5c 08 00
	00		 mov	 DWORD PTR [ecx+2140], eax

; 97   : 	return TRUE;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 98   : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z ENDP		; WzUdp::SetProtocolCore
_TEXT	ENDS
PUBLIC	?RecvSet@WzUdp@@QAEHH@Z				; WzUdp::RecvSet
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__htonl@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?RecvSet@WzUdp@@QAEHH@Z
_TEXT	SEGMENT
_port$ = 8						; size = 4
?RecvSet@WzUdp@@QAEHH@Z PROC				; WzUdp::RecvSet, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 	m_Port						= port;

  00003	8b 45 08	 mov	 eax, DWORD PTR _port$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 104  :     m_SockAddr.sin_port			= htons(port);

  0000a	50		 push	 eax
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00014	66 89 86 4e 08
	00 00		 mov	 WORD PTR [esi+2126], ax

; 105  : 	m_SockAddr.sin_family		= AF_INET;

  0001b	b8 02 00 00 00	 mov	 eax, 2
  00020	8d be 4c 08 00
	00		 lea	 edi, DWORD PTR [esi+2124]

; 106  :     m_SockAddr.sin_addr.s_addr	= htonl(INADDR_ANY);

  00026	6a 00		 push	 0
  00028	66 89 07	 mov	 WORD PTR [edi], ax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 107  : 	
; 108  : 	if( bind(m_Socket, (SOCKADDR *)&m_SockAddr, sizeof(m_SockAddr)) == SOCKET_ERROR )

  00031	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00034	6a 10		 push	 16			; 00000010H
  00036	57		 push	 edi
  00037	51		 push	 ecx
  00038	89 86 50 08 00
	00		 mov	 DWORD PTR [esi+2128], eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  00044	83 f8 ff	 cmp	 eax, -1
  00047	75 08		 jne	 SHORT $LN2@RecvSet

; 109  :     {		
; 110  : 		return FALSE;

  00049	5f		 pop	 edi
  0004a	33 c0		 xor	 eax, eax
  0004c	5e		 pop	 esi

; 115  :     {        
; 116  :         return FALSE;
; 117  :     }
; 118  : 	return TRUE;
; 119  : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN2@RecvSet:

; 111  :     }
; 112  : 	
; 113  : 	m_Recvbuf = (LPBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwLength);

  00051	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00054	52		 push	 edx
  00055	6a 08		 push	 8
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12

; 114  :     if (!m_Recvbuf)

  00064	33 c9		 xor	 ecx, ecx
  00066	85 c0		 test	 eax, eax
  00068	0f 95 c1	 setne	 cl
  0006b	89 46 14	 mov	 DWORD PTR [esi+20], eax
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	8b c1		 mov	 eax, ecx

; 115  :     {        
; 116  :         return FALSE;
; 117  :     }
; 118  : 	return TRUE;
; 119  : }

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?RecvSet@WzUdp@@QAEHH@Z ENDP				; WzUdp::RecvSet
_TEXT	ENDS
PUBLIC	?SendData@WzUdp@@QAEHPAEK@Z			; WzUdp::SendData
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASendTo@36:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendData@WzUdp@@QAEHPAEK@Z
_TEXT	SEGMENT
_SendData$ = 8						; size = 4
_nSendDataLen$ = 12					; size = 4
?SendData@WzUdp@@QAEHPAEK@Z PROC			; WzUdp::SendData, COMDAT
; _this$ = ecx

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 125  : 	DWORD Ret;
; 126  : 
; 127  : 	ZeroMemory(&(m_PerIoSendData.Overlapped), sizeof(OVERLAPPED));

  00005	33 c0		 xor	 eax, eax
  00007	8b f1		 mov	 esi, ecx

; 128  : 	
; 129  : 	memcpy(m_PerIoSendData.Buffer, SendData, nSendDataLen);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _SendData$[ebp]
  0000c	57		 push	 edi
  0000d	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
  00010	89 07		 mov	 DWORD PTR [edi], eax
  00012	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00015	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00018	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _nSendDataLen$[ebp]
  00021	50		 push	 eax
  00022	51		 push	 ecx
  00023	8d 5e 44	 lea	 ebx, DWORD PTR [esi+68]
  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 _memcpy

; 130  : 	
; 131  : 	m_PerIoSendData.lOfs		= nSendDataLen;

  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _nSendDataLen$[ebp]
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 132  : 	m_PerIoSendData.DataBuf.buf = m_PerIoSendData.Buffer;
; 133  : 	m_PerIoSendData.DataBuf.len = m_PerIoSendData.lOfs;
; 134  : 		
; 135  : 	Ret = WSASendTo(m_Socket, &(m_PerIoSendData.DataBuf), 1, &nSendDataLen, 
; 136  : 		0, (SOCKADDR*)&m_SockAddr, sizeof(m_SockAddr), &(m_PerIoSendData.Overlapped), NULL);

  00032	6a 00		 push	 0
  00034	57		 push	 edi
  00035	6a 10		 push	 16			; 00000010H
  00037	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  0003a	8d 96 4c 08 00
	00		 lea	 edx, DWORD PTR [esi+2124]
  00040	52		 push	 edx
  00041	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00044	6a 00		 push	 0
  00046	89 8e 48 08 00
	00		 mov	 DWORD PTR [esi+2120], ecx
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
  0004e	8d 4d 0c	 lea	 ecx, DWORD PTR _nSendDataLen$[ebp]
  00051	51		 push	 ecx
  00052	6a 01		 push	 1
  00054	50		 push	 eax
  00055	52		 push	 edx
  00056	89 5e 40	 mov	 DWORD PTR [esi+64], ebx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASendTo@36
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 137  : 	if( Ret == SOCKET_ERROR )

  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 14		 jne	 SHORT $LN1@SendData

; 138  : 	{
; 139  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0006d	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00072	74 07		 je	 SHORT $LN1@SendData

; 140  : 		{
; 141  : 			//printf("WSASend() failed with error %d\n", WSAGetLastError());
; 142  : 			return -1;

  00074	83 c8 ff	 or	 eax, -1

; 146  : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
$LN1@SendData:

; 143  : 		}
; 144  : 	}
; 145  : 	return TRUE;

  0007b	b8 01 00 00 00	 mov	 eax, 1

; 146  : }

  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?SendData@WzUdp@@QAEHPAEK@Z ENDP			; WzUdp::SendData
_TEXT	ENDS
PUBLIC	?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z		; WzUdp::MuProtocolParse
; Function compile flags: /Ogtp
;	COMDAT ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z
_TEXT	SEGMENT
_headcode$ = -4						; size = 1
_RecvData$ = 8						; size = 4
_nRecvDataLen$ = 12					; size = 4
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z PROC		; WzUdp::MuProtocolParse, COMDAT
; _this$ = ecx

; 149  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi
  00006	8b d9		 mov	 ebx, ecx

; 150  : 	int		lOfs = 0;

  00008	33 ff		 xor	 edi, edi

; 151  : 	int		size = 0;
; 152  : 	BYTE	headcode;
; 153  : 
; 154  : 	if( ProtocolCore == NULL ) return FALSE;

  0000a	39 bb 5c 08 00
	00		 cmp	 DWORD PTR [ebx+2140], edi
  00010	75 0a		 jne	 SHORT $LN22@MuProtocol
  00012	5f		 pop	 edi
  00013	33 c0		 xor	 eax, eax
  00015	5b		 pop	 ebx

; 198  : 				}
; 199  : 			}
; 200  : 			break;
; 201  : 		}
; 202  : 	}
; 203  : 	return TRUE;
; 204  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN22@MuProtocol:
  0001c	56		 push	 esi
  0001d	8d 49 00	 npad	 3
$LL14@MuProtocol:

; 155  : 
; 156  : 	while( TRUE )
; 157  : 	{
; 158  : 		if( RecvData[lOfs] == 0xC1 )

  00020	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00023	8a 0c 07	 mov	 cl, BYTE PTR [edi+eax]
  00026	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00029	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  0002c	75 0b		 jne	 SHORT $LN12@MuProtocol

; 159  : 		{
; 160  : 			size		= *(RecvData+lOfs+1);

  0002e	0f b6 74 07 01	 movzx	 esi, BYTE PTR [edi+eax+1]

; 161  : 			headcode	= *(RecvData+lOfs+2);

  00033	8a 4c 07 02	 mov	 cl, BYTE PTR [edi+eax+2]
  00037	eb 18		 jmp	 SHORT $LN24@MuProtocol
$LN12@MuProtocol:

; 162  : 		}
; 163  : 		else if( RecvData[lOfs] == 0xC2 )

  00039	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  0003c	75 72		 jne	 SHORT $LN10@MuProtocol

; 164  : 		{
; 165  : 			size		 = (WORD)(*(RecvData+lOfs+1));
; 166  : 			size	   <<= 8;
; 167  : 			size		|= (WORD)(*(RecvData+lOfs+2));

  0003e	0f b6 74 07 01	 movzx	 esi, BYTE PTR [edi+eax+1]
  00043	0f b6 4c 07 02	 movzx	 ecx, BYTE PTR [edi+eax+2]
  00048	c1 e6 08	 shl	 esi, 8
  0004b	0b f1		 or	 esi, ecx

; 168  : 			headcode	 = *(RecvData+lOfs+3);

  0004d	8a 4c 07 03	 mov	 cl, BYTE PTR [edi+eax+3]
$LN24@MuProtocol:
  00051	88 4d fc	 mov	 BYTE PTR _headcode$[ebp], cl

; 174  : 		}
; 175  : 		if( size <= 0 )	// size 가 0일때는 에러..

  00054	85 f6		 test	 esi, esi
  00056	7e 5f		 jle	 SHORT $LN19@MuProtocol

; 176  : 		{
; 177  : 			return FALSE;
; 178  : 		}		
; 179  : 		else if( size <= nRecvDataLen )	// 하나의 패킷이 완전하다면..

  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _nRecvDataLen$[ebp]
  0005b	3b 31		 cmp	 esi, DWORD PTR [ecx]
  0005d	7f 2a		 jg	 SHORT $LN6@MuProtocol

; 180  : 		{
; 181  : 			(*ProtocolCore)(headcode, RecvData+lOfs, size);

  0005f	8b 83 5c 08 00
	00		 mov	 eax, DWORD PTR [ebx+2140]
  00065	56		 push	 esi
  00066	52		 push	 edx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _headcode$[ebp]
  0006a	52		 push	 edx
  0006b	ff d0		 call	 eax

; 182  : 			lOfs		 += size;
; 183  : 			m_dwRecvOfs  -= size;

  0006d	29 73 20	 sub	 DWORD PTR [ebx+32], esi
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	03 fe		 add	 edi, esi

; 184  : 			if( m_dwRecvOfs <= 0 ) break;

  00075	83 7b 20 00	 cmp	 DWORD PTR [ebx+32], 0
  00079	7f a5		 jg	 SHORT $LL14@MuProtocol

; 197  : 					return TRUE;

  0007b	5e		 pop	 esi
  0007c	5f		 pop	 edi
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	5b		 pop	 ebx

; 198  : 				}
; 199  : 			}
; 200  : 			break;
; 201  : 		}
; 202  : 	}
; 203  : 	return TRUE;
; 204  : }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
$LN6@MuProtocol:

; 185  : 		}		
; 186  : 		else												// 데이터가 더 남았다면
; 187  : 		{	
; 188  : 			if( lOfs > 0 )									// 하나이상 데이터를 처리한 후 라면..

  00089	85 ff		 test	 edi, edi
  0008b	7e 15		 jle	 SHORT $LN1@MuProtocol

; 189  : 			{
; 190  : 				if( m_dwRecvOfs < 1 )

  0008d	8b 5b 20	 mov	 ebx, DWORD PTR [ebx+32]
  00090	83 fb 01	 cmp	 ebx, 1

; 191  : 				{
; 192  : 					return FALSE;

  00093	7c 22		 jl	 SHORT $LN19@MuProtocol

; 193  : 				}
; 194  : 				else 
; 195  : 				{
; 196  : 					memcpy(RecvData, (RecvData+lOfs), m_dwRecvOfs); // 남은만큼 복사한다.

  00095	53		 push	 ebx
  00096	03 f8		 add	 edi, eax
  00098	57		 push	 edi
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _memcpy
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@MuProtocol:

; 197  : 					return TRUE;

  000a2	5e		 pop	 esi
  000a3	5f		 pop	 edi
  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	5b		 pop	 ebx

; 198  : 				}
; 199  : 			}
; 200  : 			break;
; 201  : 		}
; 202  : 	}
; 203  : 	return TRUE;
; 204  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN10@MuProtocol:

; 169  : 		}
; 170  : 		else  // 헤더가 맞지 않다면..
; 171  : 		{
; 172  : 			m_dwRecvOfs = 0;

  000b0	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0
$LN19@MuProtocol:
  000b7	5e		 pop	 esi
  000b8	5f		 pop	 edi

; 173  : 			return FALSE;

  000b9	33 c0		 xor	 eax, eax
  000bb	5b		 pop	 ebx

; 198  : 				}
; 199  : 			}
; 200  : 			break;
; 201  : 		}
; 202  : 	}
; 203  : 	return TRUE;
; 204  : }

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 08 00	 ret	 8
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ENDP		; WzUdp::MuProtocolParse
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?RecvThread@WzUdp@@QAEHXZ			; WzUdp::RecvThread
EXTRN	__imp__recvfrom@24:PROC
; Function compile flags: /Ogtp
;	COMDAT ?RecvThread@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_dwSenderSize$ = -24					; size = 4
_sender$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?RecvThread@WzUdp@@QAEHXZ PROC				; WzUdp::RecvThread, COMDAT
; _this$ = ecx

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 218  : 	int			ret;
; 219  :     DWORD		dwSenderSize;
; 220  :     SOCKADDR_IN	sender;	
; 221  : 	
; 222  : 	dwSenderSize = sizeof(sender);

  00012	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__recvfrom@24
  00018	8b f1		 mov	 esi, ecx
  0001a	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _dwSenderSize$[ebp], 16 ; 00000010H
$LL6@RecvThread:

; 223  : 	while(1)
; 224  : 	{		
; 225  : 		ret = recvfrom(m_Socket, (char*)m_Recvbuf+m_dwRecvOfs,
; 226  : 			DEFAULT_BUFFER_LENGTH-m_dwRecvOfs, 0, (SOCKADDR *)&sender, (int*)&dwSenderSize);

  00021	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00024	8d 4d e8	 lea	 ecx, DWORD PTR _dwSenderSize$[ebp]
  00027	51		 push	 ecx
  00028	8d 55 ec	 lea	 edx, DWORD PTR _sender$[ebp]
  0002b	52		 push	 edx
  0002c	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002f	6a 00		 push	 0
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	2b c8		 sub	 ecx, eax
  00038	51		 push	 ecx
  00039	03 d0		 add	 edx, eax
  0003b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	ff d7		 call	 edi

; 227  : 
; 228  : 		if (ret == SOCKET_ERROR)

  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 da		 je	 SHORT $LL6@RecvThread

; 229  : 		{
; 230  : 			//printf("recvfrom() failed; %d\n", WSAGetLastError());
; 231  : 		}
; 232  : 		else if (ret == 0)

  00047	85 c0		 test	 eax, eax
  00049	74 d6		 je	 SHORT $LL6@RecvThread

; 233  : 		{
; 234  : 		}
; 235  : 		else
; 236  : 		{
; 237  : 			m_dwLength  = ret;
; 238  : 			m_dwRecvOfs += ret;

  0004b	01 46 20	 add	 DWORD PTR [esi+32], eax
  0004e	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]

; 239  : 			MuProtocolParse(m_Recvbuf, m_dwLength);

  00051	51		 push	 ecx
  00052	89 01		 mov	 DWORD PTR [ecx], eax
  00054	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00057	51		 push	 ecx
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ; WzUdp::MuProtocolParse

; 240  : 		}
; 241  : 	}

  0005f	eb c0		 jmp	 SHORT $LL6@RecvThread
?RecvThread@WzUdp@@QAEHXZ ENDP				; WzUdp::RecvThread
_TEXT	ENDS
PUBLIC	?WzUdpRecvThread@@YGKPAVWzUdp@@@Z		; WzUdpRecvThread
; Function compile flags: /Ogtp
;	COMDAT ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z
_TEXT	SEGMENT
_lpWzUdp$ = 8						; size = 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z PROC			; WzUdpRecvThread, COMDAT

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 246  :     lpWzUdp->RecvThread();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpWzUdp$[ebp]
  00006	e8 00 00 00 00	 call	 ?RecvThread@WzUdp@@QAEHXZ ; WzUdp::RecvThread
$LN4@WzUdpRecvT:
$LN3@WzUdpRecvT:
  0000b	cc		 int	 3
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ENDP			; WzUdpRecvThread
_TEXT	ENDS
PUBLIC	??_7WzUdp@@6B@					; WzUdp::`vftable'
PUBLIC	??0WzUdp@@QAE@XZ				; WzUdp::WzUdp
PUBLIC	??_R4WzUdp@@6B@					; WzUdp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWzUdp@@@8				; WzUdp `RTTI Type Descriptor'
PUBLIC	??_R3WzUdp@@8					; WzUdp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2WzUdp@@8					; WzUdp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@WzUdp@@8				; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EWzUdp@@UAEPAXI@Z:PROC			; WzUdp::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@WzUdp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WzUdp@@8 DD FLAT:??_R0?AVWzUdp@@@8	; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R2WzUdp@@8
rdata$r	SEGMENT
??_R2WzUdp@@8 DD FLAT:??_R1A@?0A@EA@WzUdp@@8		; WzUdp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3WzUdp@@8
rdata$r	SEGMENT
??_R3WzUdp@@8 DD 00H					; WzUdp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWzUdp@@@8
_DATA	SEGMENT
??_R0?AVWzUdp@@@8 DD FLAT:??_7type_info@@6B@		; WzUdp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWzUdp@@', 00H
_DATA	ENDS
;	COMDAT ??_R4WzUdp@@6B@
rdata$r	SEGMENT
??_R4WzUdp@@6B@ DD 00H					; WzUdp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWzUdp@@@8
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_7WzUdp@@6B@
CONST	SEGMENT
??_7WzUdp@@6B@ DD FLAT:??_R4WzUdp@@6B@			; WzUdp::`vftable'
	DD	FLAT:??_EWzUdp@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0WzUdp@@QAE@XZ
_TEXT	SEGMENT
??0WzUdp@@QAE@XZ PROC					; WzUdp::WzUdp, COMDAT
; _this$ = ecx

; 18   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7WzUdp@@6B@

; 19   : 	Init();

  00009	e8 00 00 00 00	 call	 ?Init@WzUdp@@QAEHXZ	; WzUdp::Init

; 20   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0WzUdp@@QAE@XZ ENDP					; WzUdp::WzUdp
_TEXT	ENDS
PUBLIC	??1WzUdp@@UAE@XZ				; WzUdp::~WzUdp
; Function compile flags: /Ogtp
;	COMDAT ??1WzUdp@@UAE@XZ
_TEXT	SEGMENT
??1WzUdp@@UAE@XZ PROC					; WzUdp::~WzUdp, COMDAT
; _this$ = ecx

; 23   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7WzUdp@@6B@

; 24   : 	Close();

  00006	e9 00 00 00 00	 jmp	 ?Close@WzUdp@@QAEHXZ	; WzUdp::Close
??1WzUdp@@UAE@XZ ENDP					; WzUdp::~WzUdp
_TEXT	ENDS
PUBLIC	?Run@WzUdp@@QAEHXZ				; WzUdp::Run
EXTRN	__imp__CreateThread@24:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Run@WzUdp@@QAEHXZ
_TEXT	SEGMENT
?Run@WzUdp@@QAEHXZ PROC					; WzUdp::Run, COMDAT
; _this$ = ecx

; 208  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 209  : 	if( (m_ThreadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WzUdpRecvThread, (void*)this, 0, &m_ThreadID) ) == NULL)

  00003	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	68 00 00 00 00	 push	 OFFSET ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ; WzUdpRecvThread
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00019	33 c9		 xor	 ecx, ecx
  0001b	85 c0		 test	 eax, eax
  0001d	0f 95 c1	 setne	 cl
  00020	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00023	5e		 pop	 esi
  00024	8b c1		 mov	 eax, ecx

; 210  : 	{		
; 211  : 		return FALSE;
; 212  : 	}
; 213  : 	return TRUE;
; 214  : }

  00026	c3		 ret	 0
?Run@WzUdp@@QAEHXZ ENDP					; WzUdp::Run
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GWzUdp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWzUdp@@UAEPAXI@Z PROC				; WzUdp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1WzUdp@@UAE@XZ	; WzUdp::~WzUdp
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GWzUdp@@UAEPAXI@Z ENDP				; WzUdp::`scalar deleting destructor'
_TEXT	ENDS
END
