; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\XMasAttackEventData.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??0CEventTimer@@QAE@XZ				; CEventTimer::CEventTimer
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\xmasattackeventdata.cpp
;	COMDAT ??0CEventTimer@@QAE@XZ
_TEXT	SEGMENT
??0CEventTimer@@QAE@XZ PROC				; CEventTimer::CEventTimer, COMDAT
; _this$ = ecx

; 14   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 15   : 	this->m_iTIME_MSEC_REMAIN = GetTickCount();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 16   : }

  0000b	8b c6		 mov	 eax, esi
  0000d	5e		 pop	 esi
  0000e	c3		 ret	 0
??0CEventTimer@@QAE@XZ ENDP				; CEventTimer::CEventTimer
_TEXT	ENDS
PUBLIC	??1CEventTimer@@QAE@XZ				; CEventTimer::~CEventTimer
; Function compile flags: /Ogtp
;	COMDAT ??1CEventTimer@@QAE@XZ
_TEXT	SEGMENT
??1CEventTimer@@QAE@XZ PROC				; CEventTimer::~CEventTimer, COMDAT
; _this$ = ecx

; 20   : 
; 21   : }

  00000	c3		 ret	 0
??1CEventTimer@@QAE@XZ ENDP				; CEventTimer::~CEventTimer
_TEXT	ENDS
PUBLIC	?SetSeconds@CEventTimer@@QAEXH@Z		; CEventTimer::SetSeconds
; Function compile flags: /Ogtp
;	COMDAT ?SetSeconds@CEventTimer@@QAEXH@Z
_TEXT	SEGMENT
_Time$ = 8						; size = 4
?SetSeconds@CEventTimer@@QAEXH@Z PROC			; CEventTimer::SetSeconds, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 25   : 	this->m_iTIME_MSEC_REMAIN = GetTickCount() + (1000 * Time);

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _Time$[ebp]
  0000f	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  00015	03 c1		 add	 eax, ecx
  00017	89 06		 mov	 DWORD PTR [esi], eax
  00019	5e		 pop	 esi

; 26   : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetSeconds@CEventTimer@@QAEXH@Z ENDP			; CEventTimer::SetSeconds
_TEXT	ENDS
PUBLIC	?GetSeconds@CEventTimer@@QAEHXZ			; CEventTimer::GetSeconds
; Function compile flags: /Ogtp
;	COMDAT ?GetSeconds@CEventTimer@@QAEHXZ
_TEXT	SEGMENT
?GetSeconds@CEventTimer@@QAEHXZ PROC			; CEventTimer::GetSeconds, COMDAT
; _this$ = ecx

; 29   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 30   : 	int Time = GetTickCount(); //loc2

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 31   : 
; 32   : 	int loc3 = this->m_iTIME_MSEC_REMAIN - Time;

  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	2b c8		 sub	 ecx, eax

; 33   : 
; 34   : 	if( loc3 < 0 )

  0000d	79 06		 jns	 SHORT $LN1@GetSeconds

; 35   : 	{
; 36   : 		this->m_iTIME_MSEC_REMAIN = Time;

  0000f	89 06		 mov	 DWORD PTR [esi], eax

; 37   : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 41   : }

  00014	c3		 ret	 0
$LN1@GetSeconds:

; 38   : 	}
; 39   : 
; 40   : 	return ((loc3+999)/1000);

  00015	81 c1 e7 03 00
	00		 add	 ecx, 999		; 000003e7H
  0001b	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00020	f7 e9		 imul	 ecx
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b c2		 mov	 eax, edx
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	03 c2		 add	 eax, edx
  0002c	5e		 pop	 esi

; 41   : }

  0002d	c3		 ret	 0
?GetSeconds@CEventTimer@@QAEHXZ ENDP			; CEventTimer::GetSeconds
_TEXT	ENDS
PUBLIC	?SetMinutes@CEventTimer@@QAEXH@Z		; CEventTimer::SetMinutes
; Function compile flags: /Ogtp
;	COMDAT ?SetMinutes@CEventTimer@@QAEXH@Z
_TEXT	SEGMENT
_Time$ = 8						; size = 4
?SetMinutes@CEventTimer@@QAEXH@Z PROC			; CEventTimer::SetMinutes, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 45   : 	this->m_iTIME_MSEC_REMAIN = GetTickCount() + (60000 * Time);

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _Time$[ebp]
  0000f	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  00015	03 c1		 add	 eax, ecx
  00017	89 06		 mov	 DWORD PTR [esi], eax
  00019	5e		 pop	 esi

; 46   : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?SetMinutes@CEventTimer@@QAEXH@Z ENDP			; CEventTimer::SetMinutes
_TEXT	ENDS
PUBLIC	?GetMinutes@CEventTimer@@QAEHXZ			; CEventTimer::GetMinutes
; Function compile flags: /Ogtp
;	COMDAT ?GetMinutes@CEventTimer@@QAEHXZ
_TEXT	SEGMENT
?GetMinutes@CEventTimer@@QAEHXZ PROC			; CEventTimer::GetMinutes, COMDAT
; _this$ = ecx

; 49   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 50   : 	int Time = GetTickCount(); //loc2

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 51   : 
; 52   : 	int loc3 = this->m_iTIME_MSEC_REMAIN - Time;

  00009	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000b	2b c8		 sub	 ecx, eax

; 53   : 
; 54   : 	if( loc3 < 0 )

  0000d	79 06		 jns	 SHORT $LN1@GetMinutes

; 55   : 	{
; 56   : 		this->m_iTIME_MSEC_REMAIN = Time;

  0000f	89 06		 mov	 DWORD PTR [esi], eax

; 57   : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	5e		 pop	 esi

; 61   : }

  00014	c3		 ret	 0
$LN1@GetMinutes:

; 58   : 	}
; 59   : 
; 60   : 	return ((loc3+59999)/60000);

  00015	81 c1 5f ea 00
	00		 add	 ecx, 59999		; 0000ea5fH
  0001b	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00020	f7 e9		 imul	 ecx
  00022	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00025	8b c2		 mov	 eax, edx
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	03 c2		 add	 eax, edx
  0002c	5e		 pop	 esi

; 61   : }

  0002d	c3		 ret	 0
?GetMinutes@CEventTimer@@QAEHXZ ENDP			; CEventTimer::GetMinutes
_TEXT	ENDS
PUBLIC	?SetMiliSeconds@CEventTimer@@QAEXH@Z		; CEventTimer::SetMiliSeconds
; Function compile flags: /Ogtp
;	COMDAT ?SetMiliSeconds@CEventTimer@@QAEXH@Z
_TEXT	SEGMENT
_Time$ = 8						; size = 4
?SetMiliSeconds@CEventTimer@@QAEXH@Z PROC		; CEventTimer::SetMiliSeconds, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 65   : 	this->m_iTIME_MSEC_REMAIN = GetTickCount() + Time;

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000c	03 45 08	 add	 eax, DWORD PTR _Time$[ebp]
  0000f	89 06		 mov	 DWORD PTR [esi], eax
  00011	5e		 pop	 esi

; 66   : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetMiliSeconds@CEventTimer@@QAEXH@Z ENDP		; CEventTimer::SetMiliSeconds
_TEXT	ENDS
PUBLIC	?GetMiliSeconds@CEventTimer@@QAEHXZ		; CEventTimer::GetMiliSeconds
; Function compile flags: /Ogtp
;	COMDAT ?GetMiliSeconds@CEventTimer@@QAEHXZ
_TEXT	SEGMENT
?GetMiliSeconds@CEventTimer@@QAEHXZ PROC		; CEventTimer::GetMiliSeconds, COMDAT
; _this$ = ecx

; 69   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 70   : 	int Time = GetTickCount(); //loc2

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00009	8b c8		 mov	 ecx, eax

; 71   : 
; 72   : 	int loc3 = this->m_iTIME_MSEC_REMAIN - Time;

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	2b c1		 sub	 eax, ecx

; 73   : 
; 74   : 	if( loc3 < 0 )

  0000f	79 04		 jns	 SHORT $LN2@GetMiliSec

; 75   : 	{
; 76   : 		this->m_iTIME_MSEC_REMAIN = Time;

  00011	89 0e		 mov	 DWORD PTR [esi], ecx

; 77   : 		return 0;

  00013	33 c0		 xor	 eax, eax
$LN2@GetMiliSec:
  00015	5e		 pop	 esi

; 78   : 	}
; 79   : 
; 80   : 	return loc3;
; 81   : }

  00016	c3		 ret	 0
?GetMiliSeconds@CEventTimer@@QAEHXZ ENDP		; CEventTimer::GetMiliSeconds
_TEXT	ENDS
PUBLIC	?SetMenualStart@CXMasAttackEvent@@UAEXH@Z	; CXMasAttackEvent::SetMenualStart
; Function compile flags: /Ogtp
;	COMDAT ?SetMenualStart@CXMasAttackEvent@@UAEXH@Z
_TEXT	SEGMENT
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CXMasAttackEvent@@UAEXH@Z PROC		; CXMasAttackEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   : 	this->m_bMenualStart = bMenualStart;

  00003	8b 45 08	 mov	 eax, DWORD PTR _bMenualStart$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 92   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetMenualStart@CXMasAttackEvent@@UAEXH@Z ENDP		; CXMasAttackEvent::SetMenualStart
_TEXT	ENDS
PUBLIC	?Init@CXMasAttackEventData@@QAEHH@Z		; CXMasAttackEventData::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@CXMasAttackEventData@@QAEHH@Z
_TEXT	SEGMENT
_arg1$ = 8						; size = 4
?Init@CXMasAttackEventData@@QAEHH@Z PROC		; CXMasAttackEventData::Init, COMDAT
; _this$ = ecx

; 113  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 114  : }

  00002	c2 04 00	 ret	 4
?Init@CXMasAttackEventData@@QAEHH@Z ENDP		; CXMasAttackEventData::Init
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::~_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::~_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::~_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@XZ ; std::allocator<XMASMONSTER_EVENT_TIME>::allocator<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@XZ PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::allocator<XMASMONSTER_EVENT_TIME>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@XZ ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::allocator<XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::~_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::~_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::~_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@XZ	; std::allocator<XMASMONSTER_DATA>::allocator<XMASMONSTER_DATA>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@XZ PROC	; std::allocator<XMASMONSTER_DATA>::allocator<XMASMONSTER_DATA>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@XZ ENDP	; std::allocator<XMASMONSTER_DATA>::allocator<XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ ; std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::~_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::~_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::~_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@XZ ; std::allocator<CXMasMonsterHerd *>::allocator<CXMasMonsterHerd *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@XZ PROC	; std::allocator<CXMasMonsterHerd *>::allocator<CXMasMonsterHerd *>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@XZ ENDP	; std::allocator<CXMasMonsterHerd *>::allocator<CXMasMonsterHerd *>
_TEXT	ENDS
PUBLIC	??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::allocator<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::allocator<XMASMONSTER_EVENT_TIME>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::allocator<XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@ABV01@@Z ; std::allocator<XMASMONSTER_DATA>::allocator<XMASMONSTER_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@ABV01@@Z PROC ; std::allocator<XMASMONSTER_DATA>::allocator<XMASMONSTER_DATA>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UXMASMONSTER_DATA@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<XMASMONSTER_DATA>::allocator<XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z ; std::allocator<XMASMONSTER_DATA>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z PROC ; std::allocator<XMASMONSTER_DATA>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@I@Z ENDP ; std::allocator<XMASMONSTER_DATA>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@ABV01@@Z ; std::allocator<CXMasMonsterHerd *>::allocator<CXMasMonsterHerd *>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CXMasMonsterHerd *>::allocator<CXMasMonsterHerd *>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@PAVCXMasMonsterHerd@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CXMasMonsterHerd *>::allocator<CXMasMonsterHerd *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z ; std::allocator<CXMasMonsterHerd *>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z PROC ; std::allocator<CXMasMonsterHerd *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCXMasMonsterHerd@@@std@@QAEXPAPAVCXMasMonsterHerd@@I@Z ENDP ; std::allocator<CXMasMonsterHerd *>::deallocate
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Compat
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat
; Function compile flags: /Ogtp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Compat
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z PROC ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UXMASMONSTER_EVENT_TIME@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_EVENT_TIME@@0@Z ENDP ; std::_Ptr_cat<XMASMONSTER_EVENT_TIME,XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z PROC ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UXMASMONSTER_DATA@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUXMASMONSTER_DATA@@0@Z ENDP ; std::_Ptr_cat<XMASMONSTER_DATA,XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z PROC ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCXMasMonsterHerd@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCXMasMonsterHerd@@0@Z ENDP ; std::_Ptr_cat<CXMasMonsterHerd *,CXMasMonsterHerd *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??$move@AAUXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ; std::move<XMASMONSTER_EVENT_TIME &>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::move<XMASMONSTER_EVENT_TIME &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUXMASMONSTER_EVENT_TIME@@@std@@YA$$QAUXMASMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::move<XMASMONSTER_EVENT_TIME &>
_TEXT	ENDS
PUBLIC	??$move@AAUXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z ; std::move<XMASMONSTER_DATA &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAUXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z PROC ; std::move<XMASMONSTER_DATA &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUXMASMONSTER_DATA@@@std@@YA$$QAUXMASMONSTER_DATA@@AAU1@@Z ENDP ; std::move<XMASMONSTER_DATA &>
_TEXT	ENDS
PUBLIC	??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Destroy<XMASMONSTER_EVENT_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::_Destroy<XMASMONSTER_EVENT_TIME>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UXMASMONSTER_EVENT_TIME@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::_Destroy<XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z ; std::_Destroy<XMASMONSTER_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z PROC ; std::_Destroy<XMASMONSTER_DATA>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UXMASMONSTER_DATA@@@std@@YAXPAUXMASMONSTER_DATA@@@Z ENDP ; std::_Destroy<XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_EVENT_TIME@@@1@@Z ; std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_EVENT_TIME@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_EVENT_TIME@@@1@@Z PROC ; std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_EVENT_TIME@@@1@@Z ENDP ; std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_DATA@@@1@@Z ; std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_DATA@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_DATA@@@1@@Z PROC ; std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@V?$allocator@UXMASMONSTER_DATA@@@1@@Z ENDP ; std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@V?$allocator@PAVCXMasMonsterHerd@@@1@@Z ; std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@V?$allocator@PAVCXMasMonsterHerd@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@V?$allocator@PAVCXMasMonsterHerd@@@1@@Z PROC ; std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@V?$allocator@PAVCXMasMonsterHerd@@@1@@Z ENDP ; std::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Vector_val<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator==
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@YAXPAPAVCXMasMonsterHerd@@0AAV?$allocator@PAVCXMasMonsterHerd@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL3@Move
  00025	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<XMASMONSTER_DATA *,XMASMONSTER_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<XMASMONSTER_DATA *,XMASMONSTER_DATA *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 1c		 je	 SHORT $LN1@Move@2
  00010	56		 push	 esi
$LL3@Move@2:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0001e	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00021	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00024	83 c0 0c	 add	 eax, 12			; 0000000cH
  00027	3b ca		 cmp	 ecx, edx
  00029	75 e6		 jne	 SHORT $LL3@Move@2
  0002b	5e		 pop	 esi
$LN1@Move@2:

; 2515 : 	return (_Dest);
; 2516 : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<XMASMONSTER_DATA *,XMASMONSTER_DATA *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@QAEXPAUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::allocator<XMASMONSTER_EVENT_TIME>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z ; std::allocator<XMASMONSTER_DATA>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z PROC ; std::allocator<XMASMONSTER_DATA>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UXMASMONSTER_DATA@@@std@@QAEXPAUXMASMONSTER_DATA@@@Z ENDP ; std::allocator<XMASMONSTER_DATA>::destroy
_TEXT	ENDS
PUBLIC	??0?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??0?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAUXMASMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXPAPAVCXMasMonsterHerd@@0@Z ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00@Z PROC ; std::_Move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN5@Move@3
  00010	56		 push	 esi
$LL7@Move@3:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	83 c1 08	 add	 ecx, 8
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ca		 cmp	 ecx, edx
  00023	75 ec		 jne	 SHORT $LL7@Move@3
  00025	5e		 pop	 esi
$LN5@Move@3:

; 2536 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Move@PAUXMASMONSTER_EVENT_TIME@@PAU1@@std@@YAPAUXMASMONSTER_EVENT_TIME@@PAU1@00@Z ENDP ; std::_Move<XMASMONSTER_EVENT_TIME *,XMASMONSTER_EVENT_TIME *>
_TEXT	ENDS
PUBLIC	??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00@Z ; std::_Move<XMASMONSTER_DATA *,XMASMONSTER_DATA *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00@Z PROC ; std::_Move<XMASMONSTER_DATA *,XMASMONSTER_DATA *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 1c		 je	 SHORT $LN5@Move@4
  00010	56		 push	 esi
$LL7@Move@4:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0001e	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00021	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00024	83 c0 0c	 add	 eax, 12			; 0000000cH
  00027	3b ca		 cmp	 ecx, edx
  00029	75 e6		 jne	 SHORT $LL7@Move@4
  0002b	5e		 pop	 esi
$LN5@Move@4:

; 2536 : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Move@PAUXMASMONSTER_DATA@@PAU1@@std@@YAPAUXMASMONSTER_DATA@@PAU1@00@Z ENDP ; std::_Move<XMASMONSTER_DATA *,XMASMONSTER_DATA *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z PROC ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@UXMASMONSTER_EVENT_TIME@@@std@@YAXAAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@PAUXMASMONSTER_EVENT_TIME@@@Z ENDP ; std::_Dest_val<std::allocator<XMASMONSTER_EVENT_TIME>,XMASMONSTER_EVENT_TIME>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z PROC ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UXMASMONSTER_DATA@@@std@@UXMASMONSTER_DATA@@@std@@YAXAAV?$allocator@UXMASMONSTER_DATA@@@0@PAUXMASMONSTER_DATA@@@Z ENDP ; std::_Dest_val<std::allocator<XMASMONSTER_DATA>,XMASMONSTER_DATA>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin
; Function compile flags: /Ogtp
;	COMDAT ?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXXZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXXZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@IAEXXZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::~vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ PROC ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::~vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCXMasMonsterHerd@@V?$allocator@PAVCXMasMonsterHerd@@@std@@@std@@QAE@XZ ENDP ; std::vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >::~vector<CXMasMonsterHerd *,std::allocator<CXMasMonsterHerd *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@YAXPAUXMASMONSTER_EVENT_TIME@@0AAV?$allocator@UXMASMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@YAXPAUXMASMONSTER_DATA@@0AAV?$allocator@UXMASMONSTER_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXPAUXMASMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@2

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@2:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@IAEXXZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXPAUXMASMONSTER_DATA@@0@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXXZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXXZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy@3

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy@3:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@IAEXXZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::~vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::~vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@3
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@3:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::~vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 26		 je	 SHORT $LN1@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 1a		 je	 SHORT $LN30@erase
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00027	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002a	83 c2 08	 add	 edx, 8
  0002d	83 c6 08	 add	 esi, 8
  00030	3b d7		 cmp	 edx, edi
  00032	75 ec		 jne	 SHORT $LL32@erase
  00034	5b		 pop	 ebx
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00035	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00038	5f		 pop	 edi
$LN1@erase:
  00039	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_EVENT_TIME@@V?$allocator@UXMASMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<XMASMONSTER_EVENT_TIME,std::allocator<XMASMONSTER_EVENT_TIME> >::erase
_TEXT	ENDS
PUBLIC	??1?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::~vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::~vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@4
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@4:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::~vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@0@Z ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);
; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First_arg$[ebp]
  0000d	89 30		 mov	 DWORD PTR [eax], esi
  0000f	3b f2		 cmp	 esi, edx
  00011	74 2c		 je	 SHORT $LN1@erase@2

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	57		 push	 edi
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	3b d7		 cmp	 edx, edi
  00019	74 20		 je	 SHORT $LN30@erase@2
  0001b	53		 push	 ebx
  0001c	8d 64 24 00	 npad	 4
$LL32@erase@2:
  00020	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00022	89 1e		 mov	 DWORD PTR [esi], ebx
  00024	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00027	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002a	8b 5a 08	 mov	 ebx, DWORD PTR [edx+8]
  0002d	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00030	83 c2 0c	 add	 edx, 12			; 0000000cH
  00033	83 c6 0c	 add	 esi, 12			; 0000000cH
  00036	3b d7		 cmp	 edx, edi
  00038	75 e6		 jne	 SHORT $LL32@erase@2
  0003a	5b		 pop	 ebx
$LN30@erase@2:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  0003b	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0003e	5f		 pop	 edi
$LN1@erase@2:
  0003f	5e		 pop	 esi

; 1212 : 			}
; 1213 : 		return (_First);
; 1214 : 		}

  00040	5d		 pop	 ebp
  00041	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UXMASMONSTER_DATA@@V?$allocator@UXMASMONSTER_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<XMASMONSTER_DATA,std::allocator<XMASMONSTER_DATA> >::erase
_TEXT	ENDS
PUBLIC	??_7CXMasAttackEventData@@6B@			; CXMasAttackEventData::`vftable'
PUBLIC	??0CXMasAttackEventData@@QAE@XZ			; CXMasAttackEventData::CXMasAttackEventData
PUBLIC	??_R4CXMasAttackEventData@@6B@			; CXMasAttackEventData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCXMasAttackEventData@@@8		; CXMasAttackEventData `RTTI Type Descriptor'
PUBLIC	??_R3CXMasAttackEventData@@8			; CXMasAttackEventData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CXMasAttackEventData@@8			; CXMasAttackEventData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CXMasAttackEventData@@8		; CXMasAttackEventData::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECXMasAttackEventData@@UAEPAXI@Z:PROC	; CXMasAttackEventData::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CXMasAttackEventData@@8
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CXMasAttackEventData@@8 DD FLAT:??_R0?AVCXMasAttackEventData@@@8 ; CXMasAttackEventData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CXMasAttackEventData@@8
rdata$r	ENDS
;	COMDAT ??_R2CXMasAttackEventData@@8
rdata$r	SEGMENT
??_R2CXMasAttackEventData@@8 DD FLAT:??_R1A@?0A@EA@CXMasAttackEventData@@8 ; CXMasAttackEventData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CXMasAttackEventData@@8
rdata$r	SEGMENT
??_R3CXMasAttackEventData@@8 DD 00H			; CXMasAttackEventData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CXMasAttackEventData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCXMasAttackEventData@@@8
_DATA	SEGMENT
??_R0?AVCXMasAttackEventData@@@8 DD FLAT:??_7type_info@@6B@ ; CXMasAttackEventData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCXMasAttackEventData@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CXMasAttackEventData@@6B@
rdata$r	SEGMENT
??_R4CXMasAttackEventData@@6B@ DD 00H			; CXMasAttackEventData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCXMasAttackEventData@@@8
	DD	FLAT:??_R3CXMasAttackEventData@@8
rdata$r	ENDS
;	COMDAT ??_7CXMasAttackEventData@@6B@
CONST	SEGMENT
??_7CXMasAttackEventData@@6B@ DD FLAT:??_R4CXMasAttackEventData@@6B@ ; CXMasAttackEventData::`vftable'
	DD	FLAT:??_ECXMasAttackEventData@@UAEPAXI@Z
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\xmasattackeventdata.cpp
CONST	ENDS
;	COMDAT ??0CXMasAttackEventData@@QAE@XZ
_TEXT	SEGMENT
??0CXMasAttackEventData@@QAE@XZ PROC			; CXMasAttackEventData::CXMasAttackEventData, COMDAT
; _this$ = ecx

; 84   : {

  00000	33 c0		 xor	 eax, eax
  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx
  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CXMasAttackEventData@@6B@
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00011	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00014	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00017	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0001a	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0001d	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00020	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00023	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00026	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00029	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0002c	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0002f	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00032	e8 00 00 00 00	 call	 ??0CEventTimer@@QAE@XZ	; CEventTimer::CEventTimer

; 85   : 	InitializeCriticalSection(&this->m_critMonsterAddData);

  00037	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 86   : }

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
??0CXMasAttackEventData@@QAE@XZ ENDP			; CXMasAttackEventData::CXMasAttackEventData
_TEXT	ENDS
PUBLIC	??1CXMasAttackEventData@@UAE@XZ			; CXMasAttackEventData::~CXMasAttackEventData
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ??1CXMasAttackEventData@@UAE@XZ
_TEXT	SEGMENT
??1CXMasAttackEventData@@UAE@XZ PROC			; CXMasAttackEventData::~CXMasAttackEventData, COMDAT
; _this$ = ecx

; 95   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 96   : 	DeleteCriticalSection(&this->m_critMonsterAddData);

  00004	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00007	50		 push	 eax
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CXMasAttackEventData@@6B@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 97   : }

  00014	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  00017	33 ff		 xor	 edi, edi
  00019	3b c7		 cmp	 eax, edi
  0001b	74 09		 je	 SHORT $LN13@CXMasAttac
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 04	 add	 esp, 4
$LN13@CXMasAttac:
  00026	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  00029	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  0002c	89 7e 50	 mov	 DWORD PTR [esi+80], edi
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	3b c7		 cmp	 eax, edi
  00034	74 09		 je	 SHORT $LN24@CXMasAttac
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN24@CXMasAttac:
  0003f	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  00042	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  00045	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  00048	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0004b	3b c7		 cmp	 eax, edi
  0004d	74 09		 je	 SHORT $LN35@CXMasAttac
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
$LN35@CXMasAttac:
  00058	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0005b	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  0005e	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	c3		 ret	 0
??1CXMasAttackEventData@@UAE@XZ ENDP			; CXMasAttackEventData::~CXMasAttackEventData
_TEXT	ENDS
PUBLIC	?Clear@CXMasAttackEventData@@QAEXXZ		; CXMasAttackEventData::Clear
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CXMasAttackEventData@@QAEXXZ
_TEXT	SEGMENT
?Clear@CXMasAttackEventData@@QAEXXZ PROC		; CXMasAttackEventData::Clear, COMDAT
; _this$ = ecx

; 101  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f1		 mov	 esi, ecx

; 102  : 	EnterCriticalSection(&this->m_critMonsterAddData);

  00005	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00008	57		 push	 edi
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 103  : 	this->m_vtMonsterAddData.erase( this->m_vtMonsterAddData.begin(), this->m_vtMonsterAddData.end() );

  0000f	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00012	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00015	3b c8		 cmp	 ecx, eax
  00017	74 24		 je	 SHORT $LN19@Clear
  00019	8b d0		 mov	 edx, eax
  0001b	3b c2		 cmp	 eax, edx
  0001d	74 1b		 je	 SHORT $LN48@Clear
  0001f	90		 npad	 1
$LL50@Clear:
  00020	8b 18		 mov	 ebx, DWORD PTR [eax]
  00022	89 19		 mov	 DWORD PTR [ecx], ebx
  00024	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00027	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  0002a	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  0002d	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
  00030	83 c0 0c	 add	 eax, 12			; 0000000cH
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	3b c2		 cmp	 eax, edx
  00038	75 e6		 jne	 SHORT $LL50@Clear
$LN48@Clear:
  0003a	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx
$LN19@Clear:

; 104  : 	this->m_vtEventTime.erase( this->m_vtEventTime.begin(), this->m_vtEventTime.end() );

  0003d	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00040	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00043	3b c8		 cmp	 ecx, eax
  00045	74 20		 je	 SHORT $LN71@Clear
  00047	8b d0		 mov	 edx, eax
  00049	3b c2		 cmp	 eax, edx
  0004b	74 17		 je	 SHORT $LN100@Clear
  0004d	8d 49 00	 npad	 3
$LL102@Clear:
  00050	8b 18		 mov	 ebx, DWORD PTR [eax]
  00052	89 19		 mov	 DWORD PTR [ecx], ebx
  00054	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00057	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  0005a	83 c0 08	 add	 eax, 8
  0005d	83 c1 08	 add	 ecx, 8
  00060	3b c2		 cmp	 eax, edx
  00062	75 ec		 jne	 SHORT $LL102@Clear
$LN100@Clear:
  00064	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
$LN71@Clear:

; 105  : 	LeaveCriticalSection(&this->m_critMonsterAddData);

  00067	57		 push	 edi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0006e	5f		 pop	 edi

; 106  : 
; 107  : 	this->m_bHasData = FALSE;

  0006f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 108  : }

  00078	c3		 ret	 0
?Clear@CXMasAttackEventData@@QAEXXZ ENDP		; CXMasAttackEventData::Clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCXMasAttackEventData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCXMasAttackEventData@@UAEPAXI@Z PROC		; CXMasAttackEventData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CXMasAttackEventData@@UAE@XZ ; CXMasAttackEventData::~CXMasAttackEventData
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCXMasAttackEventData@@UAEPAXI@Z ENDP		; CXMasAttackEventData::`scalar deleting destructor'
_TEXT	ENDS
END
