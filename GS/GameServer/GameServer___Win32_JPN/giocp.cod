; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\giocp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A	; SOCKET_FLAG
PUBLIC	?g_CompletionPort@@3PAXA			; g_CompletionPort
PUBLIC	?g_dwThreadCount@@3KA				; g_dwThreadCount
PUBLIC	?criti@@3U_RTL_CRITICAL_SECTION@@A		; criti
PUBLIC	?g_ThreadHandles@@3PAPAXA			; g_ThreadHandles
PUBLIC	?g_ServerPort@@3HA				; g_ServerPort
PUBLIC	?g_IocpThreadHandle@@3PAXA			; g_IocpThreadHandle
PUBLIC	?ExSendBuf@@3PAEA				; ExSendBuf
PUBLIC	?g_Listen@@3IA					; g_Listen
PUBLIC	?dwDebugDataSendSize@@3KA			; dwDebugDataSendSize
_BSS	SEGMENT
?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A DD 01H DUP (?) ; SOCKET_FLAG
?g_CompletionPort@@3PAXA DD 01H DUP (?)			; g_CompletionPort
?g_dwThreadCount@@3KA DD 01H DUP (?)			; g_dwThreadCount
?criti@@3U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?)	; criti
?g_ThreadHandles@@3PAPAXA DD 064H DUP (?)		; g_ThreadHandles
?g_ServerPort@@3HA DD 01H DUP (?)			; g_ServerPort
?g_IocpThreadHandle@@3PAXA DD 01H DUP (?)		; g_IocpThreadHandle
?ExSendBuf@@3PAEA DD 01H DUP (?)			; ExSendBuf
?dwDebugDataSendSize@@3KA DD 01H DUP (?)		; dwDebugDataSendSize
_BSS	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
?g_Listen@@3IA DD 0ffffffffH				; g_Listen
_DATA	ENDS
PUBLIC	??_7CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`vftable'
PUBLIC	??1CStreamPacketEngine_Server@@UAE@XZ		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
PUBLIC	??_R4CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCStreamPacketEngine_Server@@@8		; CStreamPacketEngine_Server `RTTI Type Descriptor'
PUBLIC	??_R3CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CStreamPacketEngine_Server@@8	; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECStreamPacketEngine_Server@@UAEPAXI@Z:PROC	; CStreamPacketEngine_Server::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CStreamPacketEngine_Server@@8
; File e:\work\tranet_version\gs\gameserver\spe.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 DD FLAT:??_R0?AVCStreamPacketEngine_Server@@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R2CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R2CStreamPacketEngine_Server@@8 DD FLAT:??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R3CStreamPacketEngine_Server@@8 DD 00H		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStreamPacketEngine_Server@@@8
_DATA	SEGMENT
??_R0?AVCStreamPacketEngine_Server@@@8 DD FLAT:??_7type_info@@6B@ ; CStreamPacketEngine_Server `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStreamPacketEngine_Server@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CStreamPacketEngine_Server@@6B@
rdata$r	SEGMENT
??_R4CStreamPacketEngine_Server@@6B@ DD 00H		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCStreamPacketEngine_Server@@@8
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_7CStreamPacketEngine_Server@@6B@
CONST	SEGMENT
??_7CStreamPacketEngine_Server@@6B@ DD FLAT:??_R4CStreamPacketEngine_Server@@6B@ ; CStreamPacketEngine_Server::`vftable'
	DD	FLAT:??_ECStreamPacketEngine_Server@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??1CStreamPacketEngine_Server@@UAE@XZ
_TEXT	SEGMENT
??1CStreamPacketEngine_Server@@UAE@XZ PROC		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 21   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 22   : 		return;
; 23   : 	};

  00006	c3		 ret	 0
??1CStreamPacketEngine_Server@@UAE@XZ ENDP		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
_TEXT	ENDS
PUBLIC	?Clear@CStreamPacketEngine_Server@@QAEXXZ	; CStreamPacketEngine_Server::Clear
; Function compile flags: /Ogtp
;	COMDAT ?Clear@CStreamPacketEngine_Server@@QAEXXZ
_TEXT	SEGMENT
?Clear@CStreamPacketEngine_Server@@QAEXXZ PROC		; CStreamPacketEngine_Server::Clear, COMDAT
; _this$ = ecx

; 27   : 		this->m_wSize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 28   : 	};

  00006	c3		 ret	 0
?Clear@CStreamPacketEngine_Server@@QAEXXZ ENDP		; CStreamPacketEngine_Server::Clear
_TEXT	ENDS
PUBLIC	??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z	; CStreamPacketEngine_Server::XorData
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@
CONST	SEGMENT
??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@ DB 'CStreamPacketE'
	DB	'ngine XorData Error %d,%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z
_TEXT	SEGMENT
_byXorFilter$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_iStart$ = 8						; size = 4
_iEnd$ = 12						; size = 4
_iDir$ = 16						; size = 4
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z PROC	; CStreamPacketEngine_Server::XorData, COMDAT
; _this$ = ecx

; 33   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 34   : 		if ( iStart < iEnd  )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iStart$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _iEnd$[ebp]
  00017	8b d1		 mov	 edx, ecx
  00019	3b c6		 cmp	 eax, esi
  0001b	7d 23		 jge	 SHORT $LN4@XorData

; 35   : 		{
; 36   : 			LogAddC(2, "CStreamPacketEngine XorData Error %d,%d", iStart, iEnd);

  0001d	56		 push	 esi
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Erro@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5e		 pop	 esi

; 187  : 		}
; 188  : 	}

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
$LN4@XorData:

; 37   : 			return;
; 38   : 		}
; 39   : 
; 40   : 		BYTE byXorFilter[32];
; 41   : 
; 42   : 		//byXorFilter[0]	= 0xAB;
; 43   : 		//byXorFilter[1]	= 0x11; 
; 44   : 		//byXorFilter[2]	= 0xCD;
; 45   : 		//byXorFilter[3]	= 0xFE; 
; 46   : 		//byXorFilter[4]	= 0x18;
; 47   : 		//byXorFilter[5]	= 0x23;
; 48   : 		//byXorFilter[6]	= 0xC5;
; 49   : 		//byXorFilter[7]	= 0xA3;
; 50   : 		//byXorFilter[8]	= 0xCA; 
; 51   : 		//byXorFilter[9]	= 0x33;
; 52   : 		//byXorFilter[10]	= 0xC1; 
; 53   : 		//byXorFilter[11] = 0xCC; 
; 54   : 		//byXorFilter[12] = 0x66; 
; 55   : 		//byXorFilter[13] = 0x67; 
; 56   : 		//byXorFilter[14] = 0x21; 
; 57   : 		//byXorFilter[15] = 0xF3;
; 58   : 		//byXorFilter[16] = 0x32;
; 59   : 		//byXorFilter[17] = 0x12; 
; 60   : 		//byXorFilter[18] = 0x15; 
; 61   : 		//byXorFilter[19] = 0x35; 
; 62   : 		//byXorFilter[20] = 0x29; 
; 63   : 		//byXorFilter[21] = 0xFF;
; 64   : 		//byXorFilter[22] = 0xFE;
; 65   : 		//byXorFilter[23] = 0x1D;
; 66   : 		//byXorFilter[24] = 0x44; 
; 67   : 		//byXorFilter[25] = 0xEF; 
; 68   : 		//byXorFilter[26] = 0xCD; 
; 69   : 		//byXorFilter[27] = 0x41; 
; 70   : 		//byXorFilter[28] = 0x26; 
; 71   : 		//byXorFilter[29] = 0x3C; 
; 72   : 		//byXorFilter[30] = 0x4E; 
; 73   : 		//byXorFilter[31] = 0x4D;
; 74   : 
; 75   : 		#if(ENABLE_ENCDEC_EVOMU)
; 76   : 
; 77   : 		byXorFilter[0] = 0x54;
; 78   : 		byXorFilter[1] = 0xAD;
; 79   : 		byXorFilter[2] = 0x65;
; 80   : 		byXorFilter[3] = 0x0F;
; 81   : 		byXorFilter[4] = 0x33;
; 82   : 		byXorFilter[5] = 0xFE;
; 83   : 		byXorFilter[6] = 0x31;
; 84   : 		byXorFilter[7] = 0xBB;
; 85   : 		byXorFilter[8] = 0x9A;
; 86   : 		byXorFilter[9] = 0x13;
; 87   : 		byXorFilter[10] = 0x56;
; 88   : 		byXorFilter[11] = 0xAC;
; 89   : 		byXorFilter[12] = 0x71;
; 90   : 		byXorFilter[13] = 0x83;
; 91   : 		byXorFilter[14] = 0x60;
; 92   : 		byXorFilter[15] = 0x2B;
; 93   : 		byXorFilter[16] = 0x13;
; 94   : 		byXorFilter[17] = 0x47;
; 95   : 		byXorFilter[18] = 0xBF;
; 96   : 		byXorFilter[19] = 0x28;
; 97   : 		byXorFilter[20] = 0xE9;
; 98   : 		byXorFilter[21] = 0x00;
; 99   : 		byXorFilter[22] = 0x7F;
; 100  : 		byXorFilter[23] = 0x10;
; 101  : 		byXorFilter[24] = 0x6F;
; 102  : 		byXorFilter[25] = 0x32;
; 103  : 		byXorFilter[26] = 0x65;
; 104  : 		byXorFilter[27] = 0xF6;
; 105  : 		byXorFilter[28] = 0x92;
; 106  : 		byXorFilter[29] = 0x1D;
; 107  : 		byXorFilter[30] = 0xD3;
; 108  : 		byXorFilter[31] = 0xEF;
; 109  : 
; 110  : 		#else
; 111  : 
; 112  : 		//ZtTeam Packet
; 113  : 
; 114  : 		byXorFilter[0] = 0x54;

  00040	c7 45 dc 54 ad
	65 0f		 mov	 DWORD PTR _byXorFilter$[ebp], 258321748 ; 0f65ad54H

; 115  : 		byXorFilter[1] = 0xAD;
; 116  : 		byXorFilter[2] = 0x65;
; 117  : 		byXorFilter[3] = 0x0F;
; 118  : 		byXorFilter[4] = 0x33;

  00047	c7 45 e0 33 fe
	31 bb		 mov	 DWORD PTR _byXorFilter$[ebp+4], -1154351565 ; bb31fe33H

; 119  : 		byXorFilter[5] = 0xFE;
; 120  : 		byXorFilter[6] = 0x31;
; 121  : 		byXorFilter[7] = 0xBB;
; 122  : 		byXorFilter[8] = 0x9A;

  0004e	c7 45 e4 9a 13
	56 ac		 mov	 DWORD PTR _byXorFilter$[ebp+8], -1403645030 ; ac56139aH

; 123  : 		byXorFilter[9] = 0x13;
; 124  : 		byXorFilter[10] = 0x56;
; 125  : 		byXorFilter[11] = 0xAC;
; 126  : 		byXorFilter[12] = 0x71;

  00055	c7 45 e8 71 83
	60 2b		 mov	 DWORD PTR _byXorFilter$[ebp+12], 727745393 ; 2b608371H

; 127  : 		byXorFilter[13] = 0x83;
; 128  : 		byXorFilter[14] = 0x60;
; 129  : 		byXorFilter[15] = 0x2B;
; 130  : 		byXorFilter[16] = 0x13;

  0005c	c7 45 ec 13 47
	bf 28		 mov	 DWORD PTR _byXorFilter$[ebp+16], 683624211 ; 28bf4713H

; 131  : 		byXorFilter[17] = 0x47;
; 132  : 		byXorFilter[18] = 0xBF;
; 133  : 		byXorFilter[19] = 0x28;
; 134  : 		byXorFilter[20] = 0xE9;

  00063	c7 45 f0 e9 00
	7f 10		 mov	 DWORD PTR _byXorFilter$[ebp+20], 276758761 ; 107f00e9H

; 135  : 		byXorFilter[21] = 0x00;
; 136  : 		byXorFilter[22] = 0x7F;
; 137  : 		byXorFilter[23] = 0x10;
; 138  : 		byXorFilter[24] = 0x6F;

  0006a	c7 45 f4 6f 32
	65 f6		 mov	 DWORD PTR _byXorFilter$[ebp+24], -161140113 ; f665326fH

; 139  : 		byXorFilter[25] = 0x32;
; 140  : 		byXorFilter[26] = 0x65;
; 141  : 		byXorFilter[27] = 0xF6;
; 142  : 		byXorFilter[28] = 0x92;

  00071	c7 45 f8 92 1d
	d3 ef		 mov	 DWORD PTR _byXorFilter$[ebp+28], -271377006 ; efd31d92H

; 143  : 		byXorFilter[29] = 0x1D;
; 144  : 		byXorFilter[30] = 0xD3;
; 145  : 		byXorFilter[31] = 0xEF;
; 146  : 
; 147  : 		#endif
; 148  : 
; 149  : #if(ZTTEAM_GAMECLIENT_DEV)
; 150  : 		byXorFilter[0] = 0xE7;
; 151  : 		byXorFilter[1] = 0x6D;
; 152  : 		byXorFilter[2] = 0x3A;
; 153  : 		byXorFilter[3] = 0x89;
; 154  : 		byXorFilter[4] = 0xBC;
; 155  : 		byXorFilter[5] = 0xB2;
; 156  : 		byXorFilter[6] = 0x9F;
; 157  : 		byXorFilter[7] = 0x73;
; 158  : 		byXorFilter[8] = 0x23;
; 159  : 		byXorFilter[9] = 0xA8;
; 160  : 		byXorFilter[10] = 0xFE;
; 161  : 		byXorFilter[11] = 0xB6;
; 162  : 		byXorFilter[12] = 0x49;
; 163  : 		byXorFilter[13] = 0x5D;
; 164  : 		byXorFilter[14] = 0x39;
; 165  : 		byXorFilter[15] = 0x5D;
; 166  : 		byXorFilter[16] = 0x8A;
; 167  : 		byXorFilter[17] = 0xCB;
; 168  : 		byXorFilter[18] = 0x63;
; 169  : 		byXorFilter[19] = 0x8D;
; 170  : 		byXorFilter[20] = 0xEA;
; 171  : 		byXorFilter[21] = 0x7D;
; 172  : 		byXorFilter[22] = 0x2B;
; 173  : 		byXorFilter[23] = 0x5F;
; 174  : 		byXorFilter[24] = 0xC3;
; 175  : 		byXorFilter[25] = 0xB1;
; 176  : 		byXorFilter[26] = 0xE9;
; 177  : 		byXorFilter[27] = 0x83;
; 178  : 		byXorFilter[28] = 0x29;
; 179  : 		byXorFilter[29] = 0x51;
; 180  : 		byXorFilter[30] = 0xE8;
; 181  : 		byXorFilter[31] = 0x56;	
; 182  : #endif
; 183  : 
; 184  : 		for ( int i = iStart ; i != iEnd ; i+=iDir )

  00078	3b c6		 cmp	 eax, esi
  0007a	74 37		 je	 SHORT $LN1@XorData
  0007c	b9 fa ff ff ff	 mov	 ecx, -6			; fffffffaH
  00081	57		 push	 edi
  00082	8b 7d 10	 mov	 edi, DWORD PTR _iDir$[ebp]
  00085	8d 44 02 06	 lea	 eax, DWORD PTR [edx+eax+6]
  00089	2b ca		 sub	 ecx, edx
  0008b	eb 03 8d 49 00	 npad	 5
$LL3@XorData:

; 185  : 		{
; 186  : 			this->m_byBuffer[i] ^= this->m_byBuffer[i-1] ^ byXorFilter[ i%32 ];

  00090	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  00093	81 e2 1f 00 00
	80		 and	 edx, -2147483617	; 8000001fH
  00099	79 05		 jns	 SHORT $LN9@XorData
  0009b	4a		 dec	 edx
  0009c	83 ca e0	 or	 edx, -32		; ffffffe0H
  0009f	42		 inc	 edx
$LN9@XorData:
  000a0	8a 54 15 dc	 mov	 dl, BYTE PTR _byXorFilter$[ebp+edx]
  000a4	32 50 ff	 xor	 dl, BYTE PTR [eax-1]
  000a7	30 10		 xor	 BYTE PTR [eax], dl
  000a9	03 c7		 add	 eax, edi
  000ab	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  000ae	3b d6		 cmp	 edx, esi
  000b0	75 de		 jne	 SHORT $LL3@XorData
  000b2	5f		 pop	 edi
$LN1@XorData:

; 187  : 		}
; 188  : 	}

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5e		 pop	 esi
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 0c 00	 ret	 12			; 0000000cH
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ENDP	; CStreamPacketEngine_Server::XorData
_TEXT	ENDS
PUBLIC	??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@ ; `string'
PUBLIC	?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z	; CStreamPacketEngine_Server::AddData
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
CONST	SEGMENT
??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@ DB 'CStreamPacketEn'
	DB	'gine Adding Buffer Size Error %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_wSize$ = 12						; size = 2
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z PROC	; CStreamPacketEngine_Server::AddData, COMDAT
; _this$ = ecx

; 193  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 194  : 		if ( ((this->m_wSize + wSize) >=  2048) ||  (wSize == 0) )

  00005	66 8b 7d 0c	 mov	 di, WORD PTR _wSize$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  0000f	0f b7 cf	 movzx	 ecx, di
  00012	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  00015	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  0001b	7d 26		 jge	 SHORT $LN1@AddData
  0001d	66 85 ff	 test	 di, di
  00020	74 21		 je	 SHORT $LN1@AddData

; 199  : 		}
; 200  : 
; 201  : 		memcpy((void*)&this->m_byBuffer[this->m_wSize], pSrc, wSize);

  00022	51		 push	 ecx
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00026	51		 push	 ecx
  00027	8d 54 30 06	 lea	 edx, DWORD PTR [eax+esi+6]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _memcpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 		this->m_wSize += wSize;

  00034	66 01 7e 04	 add	 WORD PTR [esi+4], di
  00038	5f		 pop	 edi

; 203  : 		return TRUE;

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	5e		 pop	 esi

; 204  : 	}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
$LN1@AddData:

; 195  : 		{
; 196  : 			LogAddC(2,"CStreamPacketEngine Adding Buffer Size Error %d", this->m_wSize + wSize);

  00043	52		 push	 edx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  00049	6a 02		 push	 2
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	5f		 pop	 edi

; 197  : 			int iSize = 2048;
; 198  : 			return FALSE;

  00055	33 c0		 xor	 eax, eax
  00057	5e		 pop	 esi

; 204  : 	}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ENDP	; CStreamPacketEngine_Server::AddData
_TEXT	ENDS
PUBLIC	_pTar$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
; Function compile flags: /Ogtp
;	COMDAT ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z
_TEXT	SEGMENT
_wSize$ = -2060						; size = 2
tv293 = -2056						; size = 4
_pTar$GSCopy$ = -2056					; size = 4
_byTemp$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pTar$ = 8						; size = 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z PROC ; CStreamPacketEngine_Server::ExtractPacket, COMDAT
; _this$ = ecx

; 207  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 08 00
	00		 sub	 esp, 2060		; 0000080cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pTar$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 208  : 		WORD wSize;
; 209  : 		BYTE byXorFilter[32];
; 210  : 
; 211  : 		BYTE byTemp[2048];
; 212  : 
; 213  : 		
; 214  : 
; 215  : 		switch ( this->m_byBuffer[0] )

  0001a	8d 5e 06	 lea	 ebx, DWORD PTR [esi+6]

; 239  : 		}
; 240  : 
; 241  : //#if(ENABLE_INDEV_NETWORK)
; 242  : 		byXorFilter[0] = 0x54;
; 243  : 		byXorFilter[1] = 0xAD;
; 244  : 		byXorFilter[2] = 0x65;
; 245  : 		byXorFilter[3] = 0x0F;
; 246  : 		byXorFilter[4] = 0x33;
; 247  : 		byXorFilter[5] = 0xFE;
; 248  : 		byXorFilter[6] = 0x31;
; 249  : 		byXorFilter[7] = 0xBB;
; 250  : 		byXorFilter[8] = 0x9A;
; 251  : 		byXorFilter[9] = 0x13;
; 252  : 		byXorFilter[10] = 0x56;
; 253  : 		byXorFilter[11] = 0xAC;
; 254  : 		byXorFilter[12] = 0x71;
; 255  : 		byXorFilter[13] = 0x83;
; 256  : 		byXorFilter[14] = 0x60;
; 257  : 		byXorFilter[15] = 0x2B;
; 258  : 		byXorFilter[16] = 0x13;
; 259  : 		byXorFilter[17] = 0x47;
; 260  : 		byXorFilter[18] = 0xBF;
; 261  : 		byXorFilter[19] = 0x28;
; 262  : 		byXorFilter[20] = 0xE9;
; 263  : 		byXorFilter[21] = 0x00;
; 264  : 		byXorFilter[22] = 0x7F;
; 265  : 		byXorFilter[23] = 0x10;
; 266  : 		byXorFilter[24] = 0x6F;
; 267  : 		byXorFilter[25] = 0x32;
; 268  : 		byXorFilter[26] = 0x65;
; 269  : 		byXorFilter[27] = 0xF6;
; 270  : 		byXorFilter[28] = 0x92;
; 271  : 		byXorFilter[29] = 0x1D;
; 272  : 		byXorFilter[30] = 0xD3;
; 273  : 		byXorFilter[31] = 0xEF;
; 274  : //#else
; 275  : //
; 276  : //		byXorFilter[0] = 0xE7;
; 277  : //		byXorFilter[1] = 0x6D;
; 278  : //		byXorFilter[2] = 0x3A;
; 279  : //		byXorFilter[3] = 0x89;
; 280  : //		byXorFilter[4] = 0xBC;
; 281  : //		byXorFilter[5] = 0xB2;
; 282  : //		byXorFilter[6] = 0x9F;
; 283  : //		byXorFilter[7] = 0x73;
; 284  : //		byXorFilter[8] = 0x23;
; 285  : //		byXorFilter[9] = 0xA8;
; 286  : //		byXorFilter[10] = 0xFE;
; 287  : //		byXorFilter[11] = 0xB6;
; 288  : //		byXorFilter[12] = 0x49;
; 289  : //		byXorFilter[13] = 0x5D;
; 290  : //		byXorFilter[14] = 0x39;
; 291  : //		byXorFilter[15] = 0x5D;
; 292  : //		byXorFilter[16] = 0x8A;
; 293  : //		byXorFilter[17] = 0xCB;
; 294  : //		byXorFilter[18] = 0x63;
; 295  : //		byXorFilter[19] = 0x8D;
; 296  : //		byXorFilter[20] = 0xEA;
; 297  : //		byXorFilter[21] = 0x7D;
; 298  : //		byXorFilter[22] = 0x2B;
; 299  : //		byXorFilter[23] = 0x5F;
; 300  : //		byXorFilter[24] = 0xC3;
; 301  : //		byXorFilter[25] = 0xB1;
; 302  : //		byXorFilter[26] = 0xE9;
; 303  : //		byXorFilter[27] = 0x83;
; 304  : //		byXorFilter[28] = 0x29;
; 305  : //		byXorFilter[29] = 0x51;
; 306  : //		byXorFilter[30] = 0xE8;
; 307  : //		byXorFilter[31] = 0x56;	
; 308  : //
; 309  : //#endif
; 310  : 
; 311  : 		#if(ENABLE_INDEV_NETWORK)
; 312  : 		if(this->m_byBuffer[0] == 0xC1 || this->m_byBuffer[0] == 0xC3)
; 313  : 		{
; 314  : 			this->XorData(wSize-1, 2, -1);
; 315  : 			//if(!this->XorData(wSize-1, 2, -1))
; 316  : 			{
; 317  : 			//	return true;
; 318  : 			}
; 319  : 		}
; 320  : 		else if(this->m_byBuffer[0] == 0xC2 || this->m_byBuffer[0] == 0xC4)
; 321  : 		{
; 322  : 			this->XorData(wSize-1, 3, -1);
; 323  : 			//if(!this->XorData(wSize-1, 3, -1))
; 324  : 			{
; 325  : 			//	return true;
; 326  : 			}
; 327  : 		}
; 328  : 		#else
; 329  : 		this->XorData(wSize-1, (this->m_byBuffer[0] == 0xC1 ? 2 : 3), -1);

  0001d	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _pTar$GSCopy$[ebp], eax
  00023	8a 03		 mov	 al, BYTE PTR [ebx]
  00025	0f b6 c8	 movzx	 ecx, al
  00028	81 e9 c1 00 00
	00		 sub	 ecx, 193		; 000000c1H
  0002e	74 39		 je	 SHORT $LN4@ExtractPac

; 208  : 		WORD wSize;
; 209  : 		BYTE byXorFilter[32];
; 210  : 
; 211  : 		BYTE byTemp[2048];
; 212  : 
; 213  : 		
; 214  : 
; 215  : 		switch ( this->m_byBuffer[0] )

  00030	49		 dec	 ecx
  00031	74 17		 je	 SHORT $LN3@ExtractPac

; 230  : 
; 231  : 			default:
; 232  : 				return true;

  00033	5e		 pop	 esi
  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	5b		 pop	 ebx

; 336  : 		return false;
; 337  : 	}

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN3@ExtractPac:

; 222  : 				break;
; 223  : 
; 224  : 			case 0xC2:
; 225  : 			#if(ENABLE_INDEV_NETWORK)
; 226  : 			case 0xC4:
; 227  : 			#endif
; 228  : 				wSize = this->m_byBuffer[1] * 256 + this->m_byBuffer[2];

  0004a	0f b6 4e 07	 movzx	 ecx, BYTE PTR [esi+7]
  0004e	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00053	66 0f af ca	 imul	 cx, dx
  00057	0f b6 56 08	 movzx	 edx, BYTE PTR [esi+8]
  0005b	66 03 ca	 add	 cx, dx
  0005e	0f b7 c9	 movzx	 ecx, cx
  00061	89 8d f4 f7 ff
	ff		 mov	 DWORD PTR _wSize$[ebp], ecx

; 229  : 				break;

  00067	eb 0c		 jmp	 SHORT $LN5@ExtractPac
$LN4@ExtractPac:

; 216  : 		{
; 217  : 			case 0xC1:
; 218  : 			#if(ENABLE_INDEV_NETWORK)
; 219  : 			case 0xC3:
; 220  : 			#endif
; 221  : 				wSize = this->m_byBuffer[1];

  00069	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  0006d	89 95 f4 f7 ff
	ff		 mov	 DWORD PTR _wSize$[ebp], edx
  00073	8b ca		 mov	 ecx, edx
$LN5@ExtractPac:

; 233  : 				break;
; 234  : 		}
; 235  : 
; 236  : 		if ( this->m_wSize < wSize )

  00075	66 39 4e 04	 cmp	 WORD PTR [esi+4], cx
  00079	73 17		 jae	 SHORT $LN1@ExtractPac

; 237  : 		{
; 238  : 			return 2;

  0007b	5e		 pop	 esi
  0007c	b8 02 00 00 00	 mov	 eax, 2
  00081	5b		 pop	 ebx

; 336  : 		return false;
; 337  : 	}

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
$LN1@ExtractPac:
  00092	57		 push	 edi

; 239  : 		}
; 240  : 
; 241  : //#if(ENABLE_INDEV_NETWORK)
; 242  : 		byXorFilter[0] = 0x54;
; 243  : 		byXorFilter[1] = 0xAD;
; 244  : 		byXorFilter[2] = 0x65;
; 245  : 		byXorFilter[3] = 0x0F;
; 246  : 		byXorFilter[4] = 0x33;
; 247  : 		byXorFilter[5] = 0xFE;
; 248  : 		byXorFilter[6] = 0x31;
; 249  : 		byXorFilter[7] = 0xBB;
; 250  : 		byXorFilter[8] = 0x9A;
; 251  : 		byXorFilter[9] = 0x13;
; 252  : 		byXorFilter[10] = 0x56;
; 253  : 		byXorFilter[11] = 0xAC;
; 254  : 		byXorFilter[12] = 0x71;
; 255  : 		byXorFilter[13] = 0x83;
; 256  : 		byXorFilter[14] = 0x60;
; 257  : 		byXorFilter[15] = 0x2B;
; 258  : 		byXorFilter[16] = 0x13;
; 259  : 		byXorFilter[17] = 0x47;
; 260  : 		byXorFilter[18] = 0xBF;
; 261  : 		byXorFilter[19] = 0x28;
; 262  : 		byXorFilter[20] = 0xE9;
; 263  : 		byXorFilter[21] = 0x00;
; 264  : 		byXorFilter[22] = 0x7F;
; 265  : 		byXorFilter[23] = 0x10;
; 266  : 		byXorFilter[24] = 0x6F;
; 267  : 		byXorFilter[25] = 0x32;
; 268  : 		byXorFilter[26] = 0x65;
; 269  : 		byXorFilter[27] = 0xF6;
; 270  : 		byXorFilter[28] = 0x92;
; 271  : 		byXorFilter[29] = 0x1D;
; 272  : 		byXorFilter[30] = 0xD3;
; 273  : 		byXorFilter[31] = 0xEF;
; 274  : //#else
; 275  : //
; 276  : //		byXorFilter[0] = 0xE7;
; 277  : //		byXorFilter[1] = 0x6D;
; 278  : //		byXorFilter[2] = 0x3A;
; 279  : //		byXorFilter[3] = 0x89;
; 280  : //		byXorFilter[4] = 0xBC;
; 281  : //		byXorFilter[5] = 0xB2;
; 282  : //		byXorFilter[6] = 0x9F;
; 283  : //		byXorFilter[7] = 0x73;
; 284  : //		byXorFilter[8] = 0x23;
; 285  : //		byXorFilter[9] = 0xA8;
; 286  : //		byXorFilter[10] = 0xFE;
; 287  : //		byXorFilter[11] = 0xB6;
; 288  : //		byXorFilter[12] = 0x49;
; 289  : //		byXorFilter[13] = 0x5D;
; 290  : //		byXorFilter[14] = 0x39;
; 291  : //		byXorFilter[15] = 0x5D;
; 292  : //		byXorFilter[16] = 0x8A;
; 293  : //		byXorFilter[17] = 0xCB;
; 294  : //		byXorFilter[18] = 0x63;
; 295  : //		byXorFilter[19] = 0x8D;
; 296  : //		byXorFilter[20] = 0xEA;
; 297  : //		byXorFilter[21] = 0x7D;
; 298  : //		byXorFilter[22] = 0x2B;
; 299  : //		byXorFilter[23] = 0x5F;
; 300  : //		byXorFilter[24] = 0xC3;
; 301  : //		byXorFilter[25] = 0xB1;
; 302  : //		byXorFilter[26] = 0xE9;
; 303  : //		byXorFilter[27] = 0x83;
; 304  : //		byXorFilter[28] = 0x29;
; 305  : //		byXorFilter[29] = 0x51;
; 306  : //		byXorFilter[30] = 0xE8;
; 307  : //		byXorFilter[31] = 0x56;	
; 308  : //
; 309  : //#endif
; 310  : 
; 311  : 		#if(ENABLE_INDEV_NETWORK)
; 312  : 		if(this->m_byBuffer[0] == 0xC1 || this->m_byBuffer[0] == 0xC3)
; 313  : 		{
; 314  : 			this->XorData(wSize-1, 2, -1);
; 315  : 			//if(!this->XorData(wSize-1, 2, -1))
; 316  : 			{
; 317  : 			//	return true;
; 318  : 			}
; 319  : 		}
; 320  : 		else if(this->m_byBuffer[0] == 0xC2 || this->m_byBuffer[0] == 0xC4)
; 321  : 		{
; 322  : 			this->XorData(wSize-1, 3, -1);
; 323  : 			//if(!this->XorData(wSize-1, 3, -1))
; 324  : 			{
; 325  : 			//	return true;
; 326  : 			}
; 327  : 		}
; 328  : 		#else
; 329  : 		this->XorData(wSize-1, (this->m_byBuffer[0] == 0xC1 ? 2 : 3), -1);

  00093	0f b7 f9	 movzx	 edi, cx
  00096	33 c9		 xor	 ecx, ecx
  00098	3c c1		 cmp	 al, 193			; 000000c1H
  0009a	0f 95 c1	 setne	 cl
  0009d	6a ff		 push	 -1
  0009f	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  000a2	83 c1 02	 add	 ecx, 2
  000a5	51		 push	 ecx
  000a6	52		 push	 edx
  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ; CStreamPacketEngine_Server::XorData

; 330  : 		#endif
; 331  : 
; 332  : 		memcpy(pTar, this->m_byBuffer, wSize);

  000ae	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _pTar$GSCopy$[ebp]
  000b4	57		 push	 edi
  000b5	53		 push	 ebx
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 _memcpy

; 333  : 		this->m_wSize-=wSize;

  000bc	66 8b 8d f4 f7
	ff ff		 mov	 cx, WORD PTR _wSize$[ebp]
  000c3	66 29 4e 04	 sub	 WORD PTR [esi+4], cx

; 334  : 		memcpy(byTemp, &this->m_byBuffer[wSize], this->m_wSize);

  000c7	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  000cb	50		 push	 eax
  000cc	8d 54 37 06	 lea	 edx, DWORD PTR [edi+esi+6]
  000d0	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR tv293[ebp], eax
  000d6	52		 push	 edx
  000d7	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _byTemp$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _memcpy

; 335  : 		memcpy(this->m_byBuffer, byTemp, this->m_wSize);

  000e3	8b 8d f8 f7 ff
	ff		 mov	 ecx, DWORD PTR tv293[ebp]
  000e9	51		 push	 ecx
  000ea	8d 95 fc f7 ff
	ff		 lea	 edx, DWORD PTR _byTemp$[ebp]
  000f0	52		 push	 edx
  000f1	53		 push	 ebx
  000f2	e8 00 00 00 00	 call	 _memcpy

; 336  : 		return false;
; 337  : 	}

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	83 c4 24	 add	 esp, 36			; 00000024H
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	33 cd		 xor	 ecx, ebp
  00101	33 c0		 xor	 eax, eax
  00103	5b		 pop	 ebx
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ENDP ; CStreamPacketEngine_Server::ExtractPacket
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCStreamPacketEngine_Server@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z PROC		; CStreamPacketEngine_Server::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CStreamPacketEngine_Server@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z ENDP		; CStreamPacketEngine_Server::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GiocpInit@@YAXXZ				; GiocpInit
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\giocp.cpp
;	COMDAT ?GiocpInit@@YAXXZ
_TEXT	SEGMENT
?GiocpInit@@YAXXZ PROC					; GiocpInit, COMDAT

; 71   : 	ExSendBuf=new BYTE[MAX_EXSENDBUF_SIZE];

  00000	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00005	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0000a	83 c4 04	 add	 esp, 4
  0000d	a3 00 00 00 00	 mov	 DWORD PTR ?ExSendBuf@@3PAEA, eax ; ExSendBuf

; 72   : }

  00012	c3		 ret	 0
?GiocpInit@@YAXXZ ENDP					; GiocpInit
_TEXT	ENDS
PUBLIC	?GiocpDelete@@YAXXZ				; GiocpDelete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtp
;	COMDAT ?GiocpDelete@@YAXXZ
_TEXT	SEGMENT
?GiocpDelete@@YAXXZ PROC				; GiocpDelete, COMDAT

; 76   : 	delete[] ExSendBuf;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000b	59		 pop	 ecx

; 77   : }

  0000c	c3		 ret	 0
?GiocpDelete@@YAXXZ ENDP				; GiocpDelete
_TEXT	ENDS
PUBLIC	??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second?5@ ; `string'
PUBLIC	??_C@_09ELJFIOPP@giocp?4cpp?$AA@		; `string'
PUBLIC	?HackToolCheck@@YAHEHHE@Z			; HackToolCheck
EXTRN	?IncreasePacketCount@CHackToolPacket@@QAEXEK@Z:PROC ; CHackToolPacket::IncreasePacketCount
EXTRN	?CheckPacketCount@CHackToolPacket@@QAEHXZ:PROC	; CHackToolPacket::CheckPacketCount
EXTRN	?GetState@CHackToolPacket@@QAEXPAHPAK1@Z:PROC	; CHackToolPacket::GetState
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second?5@
CONST	SEGMENT
??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second?5@ DB '[HAC'
	DB	'KTOOL] : Packets Per Second = %dip = %s account:%s name:%s HE'
	DB	'AD:%x (%s,%d) State:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
CONST	SEGMENT
??_C@_09ELJFIOPP@giocp?4cpp?$AA@ DB 'giocp.cpp', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?HackToolCheck@@YAHEHHE@Z
_TEXT	SEGMENT
_loc2$ = -8						; size = 4
_loc3$ = -4						; size = 4
_headcode$ = 8						; size = 1
_size$ = 12						; size = 4
_PacketCount$ = 16					; size = 4
_uIndex$ = 16						; size = 4
_xcode$ = 20						; size = 1
?HackToolCheck@@YAHEHHE@Z PROC				; HackToolCheck, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 81   : 	int PacketCount;
; 82   : 	DWORD loc2, loc3;
; 83   : 
; 84   : 	if(OBJMAX_RANGE(uIndex) != FALSE)

  00007	8b 75 10	 mov	 esi, DWORD PTR _uIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 c9 00 00
	00		 js	 $LN4@HackToolCh
  00012	33 c0		 xor	 eax, eax
  00014	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 b6 00 00
	00		 je	 $LN4@HackToolCh

; 85   : 	{
; 86   : 		gObj[uIndex].m_HackToolCheck.GetState(&PacketCount, &loc2, &loc3);

  00025	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002b	8d 45 fc	 lea	 eax, DWORD PTR _loc3$[ebp]
  0002e	50		 push	 eax
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	8d 4d f8	 lea	 ecx, DWORD PTR _loc2$[ebp]
  00037	51		 push	 ecx
  00038	8d 55 10	 lea	 edx, DWORD PTR _PacketCount$[ebp]
  0003b	52		 push	 edx
  0003c	8d 8c 06 98 21
	00 00		 lea	 ecx, DWORD PTR [esi+eax+8600]
  00043	e8 00 00 00 00	 call	 ?GetState@CHackToolPacket@@QAEXPAHPAK1@Z ; CHackToolPacket::GetState

; 87   : 		gObj[uIndex].m_HackToolCheck.CheckPacketCount();

  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004e	8d 8c 0e 98 21
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+8600]
  00055	e8 00 00 00 00	 call	 ?CheckPacketCount@CHackToolPacket@@QAEHXZ ; CHackToolPacket::CheckPacketCount

; 88   : 
; 89   : 		if(PacketCount > MAX_PACKET_SERVER)

  0005a	8b 4d 10	 mov	 ecx, DWORD PTR _PacketCount$[ebp]
  0005d	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00063	7e 40		 jle	 SHORT $LN3@HackToolCh

; 90   : 		{
; 91   : 			LogAddC(2,"[HACKTOOL] : Packets Per Second = %dip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 92   : 				PacketCount, gObj[uIndex].Ip_addr, gObj[uIndex].AccountID, gObj[uIndex].Name, headcode, __FILE__, __LINE__, 
; 93   : 				gObj[uIndex].Connected);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	8b 54 06 04	 mov	 edx, DWORD PTR [esi+eax+4]
  0006e	52		 push	 edx
  0006f	0f b6 55 08	 movzx	 edx, BYTE PTR _headcode$[ebp]
  00073	6a 5c		 push	 92			; 0000005cH
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0007a	52		 push	 edx
  0007b	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0007f	52		 push	 edx
  00080	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00084	52		 push	 edx
  00085	8d 44 06 18	 lea	 eax, DWORD PTR [esi+eax+24]
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second?5@
  00090	6a 02		 push	 2
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00098	83 c4 28	 add	 esp, 40			; 00000028H

; 94   : 			return TRUE;

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	5e		 pop	 esi

; 106  : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
$LN3@HackToolCh:

; 95   : 		}
; 96   : 		
; 97   : 		if(headcode == 0xC3 || headcode == 0xC8)

  000a5	8a 45 08	 mov	 al, BYTE PTR _headcode$[ebp]
  000a8	3c c3		 cmp	 al, 195			; 000000c3H
  000aa	74 2f		 je	 SHORT $LN4@HackToolCh
  000ac	3c c8		 cmp	 al, 200			; 000000c8H
  000ae	74 2b		 je	 SHORT $LN4@HackToolCh

; 98   : 		{
; 99   : 			return FALSE;
; 100  : 		}
; 101  : 
; 102  : 		gObj[uIndex].m_HackToolCheck.IncreasePacketCount(((xcode != 0xC3 && xcode != 0xC4)?(BYTE)(0x00):(BYTE)(0x01)), size);

  000b0	8a 45 14	 mov	 al, BYTE PTR _xcode$[ebp]
  000b3	3c c3		 cmp	 al, 195			; 000000c3H
  000b5	74 08		 je	 SHORT $LN9@HackToolCh
  000b7	3c c4		 cmp	 al, 196			; 000000c4H
  000b9	74 04		 je	 SHORT $LN9@HackToolCh
  000bb	32 c0		 xor	 al, al
  000bd	eb 05		 jmp	 SHORT $LN10@HackToolCh
$LN9@HackToolCh:
  000bf	b8 01 00 00 00	 mov	 eax, 1
$LN10@HackToolCh:
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  000c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cd	51		 push	 ecx
  000ce	50		 push	 eax
  000cf	8d 8c 16 98 21
	00 00		 lea	 ecx, DWORD PTR [esi+edx+8600]
  000d6	e8 00 00 00 00	 call	 ?IncreasePacketCount@CHackToolPacket@@QAEXEK@Z ; CHackToolPacket::IncreasePacketCount
$LN4@HackToolCh:

; 103  : 	}
; 104  : 
; 105  : 	return FALSE;

  000db	33 c0		 xor	 eax, eax
  000dd	5e		 pop	 esi

; 106  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
?HackToolCheck@@YAHEHHE@Z ENDP				; HackToolCheck
_TEXT	ENDS
PUBLIC	??_C@_09HNKOADHB@Error?9L10?$AA@		; `string'
PUBLIC	?DestroyGIocp@@YAXXZ				; DestroyGIocp
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_09HNKOADHB@Error?9L10?$AA@
CONST	SEGMENT
??_C@_09HNKOADHB@Error?9L10?$AA@ DB 'Error-L10', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DestroyGIocp@@YAXXZ
_TEXT	SEGMENT
?DestroyGIocp@@YAXXZ PROC				; DestroyGIocp, COMDAT

; 192  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 193  : 	LogAddTD("Error-L10");

  00002	68 00 00 00 00	 push	 OFFSET ??_C@_09HNKOADHB@Error?9L10?$AA@
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 194  : 
; 195  : 	closesocket(g_Listen);

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 196  : 
; 197  : 	for (DWORD dwCPU=0; dwCPU < g_dwThreadCount;dwCPU++ )

  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__TerminateThread@8
  00022	33 f6		 xor	 esi, esi
  00024	39 35 00 00 00
	00		 cmp	 DWORD PTR ?g_dwThreadCount@@3KA, esi ; g_dwThreadCount
  0002a	76 19		 jbe	 SHORT $LN2@DestroyGIo
  0002c	8d 64 24 00	 npad	 4
$LL4@DestroyGIo:

; 198  : 	{
; 199  : 		TerminateThread( g_ThreadHandles[dwCPU] , 0);

  00030	8b 0c b5 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_ThreadHandles@@3PAPAXA[esi*4]
  00037	6a 00		 push	 0
  00039	51		 push	 ecx
  0003a	ff d7		 call	 edi
  0003c	46		 inc	 esi
  0003d	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  00043	72 eb		 jb	 SHORT $LL4@DestroyGIo
$LN2@DestroyGIo:

; 200  : 	}
; 201  : 
; 202  : 	TerminateThread(g_IocpThreadHandle, 0);

  00045	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_IocpThreadHandle@@3PAXA ; g_IocpThreadHandle
  0004b	6a 00		 push	 0
  0004d	52		 push	 edx
  0004e	ff d7		 call	 edi

; 203  : 
; 204  : 	if ( g_CompletionPort != NULL )

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	85 c0		 test	 eax, eax
  00059	74 11		 je	 SHORT $LN1@DestroyGIo

; 205  : 	{
; 206  : 		CloseHandle(g_CompletionPort);

  0005b	50		 push	 eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 207  : 		g_CompletionPort=NULL;

  00062	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN1@DestroyGIo:

; 208  : 	} 
; 209  : 	
; 210  : }

  0006c	c3		 ret	 0
?DestroyGIocp@@YAXXZ ENDP				; DestroyGIocp
_TEXT	ENDS
PUBLIC	??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CreateListenSocket@@YAHXZ			; CreateListenSocket
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASocketA@24:PROC
;	COMDAT ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ DB 'li'
	DB	'sten() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSA'
	DB	'Socket() failed with error %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CreateListenSocket@@YAHXZ
_TEXT	SEGMENT
_InternetAddr$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
?CreateListenSocket@@YAHXZ PROC				; CreateListenSocket, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 214  : 	sockaddr_in InternetAddr;
; 215  : 	int nRet;
; 216  : 
; 217  : 	g_Listen=WSASocket(AF_INET, SOCK_STREAM, IPPROTO_IP, NULL, 0, WSA_FLAG_OVERLAPPED);

  00010	6a 01		 push	 1
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 01		 push	 1
  0001a	6a 02		 push	 2
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  00022	a3 00 00 00 00	 mov	 DWORD PTR ?g_Listen@@3IA, eax ; g_Listen

; 218  : 
; 219  : 	if ( g_Listen == -1 )

  00027	83 f8 ff	 cmp	 eax, -1
  0002a	75 25		 jne	 SHORT $LN6@CreateList

; 220  : 	{
; 221  : 		LogAdd("WSASocket() failed with error %d", WSAGetLastError() );

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CFd@
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003e	83 c4 08	 add	 esp, 8

; 222  : 		return 0;

  00041	33 c0		 xor	 eax, eax

; 244  : 			}
; 245  : 			else
; 246  : 			{
; 247  : 				return 1;
; 248  : 			}
; 249  : 		}
; 250  : 	} 
; 251  : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN6@CreateList:

; 223  : 	}
; 224  : 	else
; 225  : 	{
; 226  : 		InternetAddr.sin_family=AF_INET;

  00051	b8 02 00 00 00	 mov	 eax, 2

; 227  : 		InternetAddr.sin_addr.S_un.S_addr=htonl(0);

  00056	6a 00		 push	 0
  00058	66 89 45 ec	 mov	 WORD PTR _InternetAddr$[ebp], ax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 228  : 		InternetAddr.sin_port=htons(g_ServerPort);

  00062	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?g_ServerPort@@3HA
  00069	51		 push	 ecx
  0006a	89 45 f0	 mov	 DWORD PTR _InternetAddr$[ebp+4], eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 229  : 		nRet=bind(g_Listen, (sockaddr*)&InternetAddr, 16);

  00073	6a 10		 push	 16			; 00000010H
  00075	8d 55 ec	 lea	 edx, DWORD PTR _InternetAddr$[ebp]
  00078	66 89 45 ee	 mov	 WORD PTR _InternetAddr$[ebp+2], ax
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12

; 230  : 		
; 231  : 		if ( nRet == -1 )

  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 3b		 jne	 SHORT $LN4@CreateList

; 232  : 		{
; 233  : 			MsgBox(lMsg.Get(MSGGET(2, 55)));

  0008e	68 37 02 00 00	 push	 567			; 00000237H
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00098	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 234  : 			SendMessage(ghWnd, WM_CLOSE, 0,0);	// Kill aplication

  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000a9	83 c4 04	 add	 esp, 4
  000ac	6a 00		 push	 0
  000ae	6a 00		 push	 0
  000b0	6a 10		 push	 16			; 00000010H
  000b2	51		 push	 ecx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 235  : 			return 0 ;

  000b9	33 c0		 xor	 eax, eax

; 244  : 			}
; 245  : 			else
; 246  : 			{
; 247  : 				return 1;
; 248  : 			}
; 249  : 		}
; 250  : 	} 
; 251  : }

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
$LN4@CreateList:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			nRet=listen(g_Listen, 5);

  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_Listen@@3IA ; g_Listen
  000cf	6a 05		 push	 5
  000d1	52		 push	 edx
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__listen@8

; 240  : 			if (nRet == -1)

  000d8	83 f8 ff	 cmp	 eax, -1
  000db	75 25		 jne	 SHORT $LN2@CreateList

; 241  : 			{
; 242  : 				LogAdd("listen() failed with error %d", WSAGetLastError());

  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000e3	50		 push	 eax
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ef	83 c4 08	 add	 esp, 8

; 243  : 				return 0;

  000f2	33 c0		 xor	 eax, eax

; 244  : 			}
; 245  : 			else
; 246  : 			{
; 247  : 				return 1;
; 248  : 			}
; 249  : 		}
; 250  : 	} 
; 251  : }

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	33 cd		 xor	 ecx, ebp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
$LN2@CreateList:
  00102	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00105	33 cd		 xor	 ecx, ebp
  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
?CreateListenSocket@@YAHXZ ENDP				; CreateListenSocket
_TEXT	ENDS
PUBLIC	??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@ ; `string'
PUBLIC	?UpdateCompletionPort@@YAHIHH@Z			; UpdateCompletionPort
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateIoCompletionPort@16:PROC
;	COMDAT ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@ DB 'CreateIoCompl'
	DB	'etionPort: %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?UpdateCompletionPort@@YAHIHH@Z
_TEXT	SEGMENT
_sd$ = 8						; size = 4
_ClientIndex$ = 12					; size = 4
_bAddToList$ = 16					; size = 4
?UpdateCompletionPort@@YAHIHH@Z PROC			; UpdateCompletionPort, COMDAT

; 1350 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1351 : 	LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL;
; 1352 : 
; 1353 : 	HANDLE cp = CreateIoCompletionPort((HANDLE)sd, g_CompletionPort, (DWORD)ClientIndex, 0); 

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _sd$[ebp]
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _ClientIndex$[ebp]
  0000f	6a 00		 push	 0
  00011	56		 push	 esi
  00012	50		 push	 eax
  00013	51		 push	 ecx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16

; 1354 :     
; 1355 : 	if (cp == NULL)

  0001a	85 c0		 test	 eax, eax
  0001c	75 1a		 jne	 SHORT $LN1@UpdateComp

; 1356 : 	{
; 1357 : 		LogAdd("CreateIoCompletionPort: %d", GetLastError() );

  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00030	83 c4 08	 add	 esp, 8

; 1358 : 		return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 1367 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN1@UpdateComp:

; 1359 : 	}
; 1360 : 
; 1361 : 	#if(ENABLE_OPTIMIZATION)
; 1362 : 	g_Optimization.AddedMemoryObject(ClientIndex);
; 1363 : 	#endif
; 1364 : 
; 1365 : 	gObj[ClientIndex].PerSocketContext->dwIOCount = 0;

  00038	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00044	8b 44 16 10	 mov	 eax, DWORD PTR [esi+edx+16]
  00048	c7 80 68 00 04
	00 00 00 00 00	 mov	 DWORD PTR [eax+262248], 0

; 1366 : 	return TRUE;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5e		 pop	 esi

; 1367 : }

  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?UpdateCompletionPort@@YAHIHH@Z ENDP			; UpdateCompletionPort
_TEXT	ENDS
PUBLIC	?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z	; CloseClient
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?CheckOnlineUser@cOffTrade@@QAE_NH@Z:PROC	; cOffTrade::CheckOnlineUser
EXTRN	?gOffTrade@@3VcOffTrade@@A:BYTE			; gOffTrade
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
_TEXT	SEGMENT
_lpPerSocketContext$ = 8				; size = 4
_bGraceful$ = 12					; size = 4
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z PROC	; CloseClient, COMDAT

; 1371 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1372 : 	int index = -1;
; 1373 : 	index = lpPerSocketContext->nIndex ;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00006	53		 push	 ebx
  00007	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 1374 : 
; 1375 : 	if ( index >= OBJ_STARTUSERINDZT && index < OBJMAX )

  0000a	8d 8b 50 c9 ff
	ff		 lea	 ecx, DWORD PTR [ebx-14000]
  00010	81 f9 e7 03 00
	00		 cmp	 ecx, 999		; 000003e7H
  00016	0f 87 85 00 00
	00		 ja	 $LN7@CloseClien

; 1376 : 	{
; 1377 : 		LPOBJ lpObj = &gObj[index];

  0001c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	56		 push	 esi
  00023	8b f3		 mov	 esi, ebx
  00025	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002b	57		 push	 edi
  0002c	8d 3c 16	 lea	 edi, DWORD PTR [esi+edx]

; 1378 : 
; 1379 : #if(OFFLINE_MODE==TRUE)
; 1380 : 		if(lpObj->m_OfflineMode == true)

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	38 87 d4 28 00
	00		 cmp	 BYTE PTR [edi+10452], al

; 1381 : 		{
; 1382 : 			lpObj->CheckTick = GetTickCount();
; 1383 : 			return;

  0003a	74 08		 je	 SHORT $LN12@CloseClien

; 1384 : 		}
; 1385 : #endif
; 1386 : 
; 1387 : 		//OffExp
; 1388 : 		if(lpObj->OffExp == 1)

  0003c	39 87 98 22 00
	00		 cmp	 DWORD PTR [edi+8856], eax
  00042	75 0e		 jne	 SHORT $LN5@CloseClien
$LN12@CloseClien:

; 1389 : 		{
; 1390 : 			//LPOBJ lpObj = &gObj[index];
; 1391 : 			lpObj->CheckTick = GetTickCount();

  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004a	89 47 40	 mov	 DWORD PTR [edi+64], eax
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx

; 1413 : 	}
; 1414 : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN5@CloseClien:

; 1392 : 			return;
; 1393 : 		}
; 1394 : 
; 1395 : #ifdef _OFFTRADE_
; 1396 : 		if(gOffTrade.CheckOnlineUser(index))return;

  00052	53		 push	 ebx
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  00058	e8 00 00 00 00	 call	 ?CheckOnlineUser@cOffTrade@@QAE_NH@Z ; cOffTrade::CheckOnlineUser
  0005d	84 c0		 test	 al, al
  0005f	75 3e		 jne	 SHORT $LN10@CloseClien

; 1397 : #endif
; 1398 : 
; 1399 : 		if ( gObj[index].m_socket != INVALID_SOCKET )

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	8b 44 06 14	 mov	 eax, DWORD PTR [esi+eax+20]
  0006a	83 f8 ff	 cmp	 eax, -1
  0006d	74 27		 je	 SHORT $LN3@CloseClien

; 1400 : 		{
; 1401 : 			if (closesocket(gObj[index].m_socket) == -1 )

  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00076	83 f8 ff	 cmp	 eax, -1
  00079	75 0d		 jne	 SHORT $LN1@CloseClien

; 1402 : 			{
; 1403 : 				if ( WSAGetLastError() != 10038 )

  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00081	3d 36 27 00 00	 cmp	 eax, 10038		; 00002736H
  00086	75 17		 jne	 SHORT $LN10@CloseClien
$LN1@CloseClien:

; 1404 : 				{
; 1405 : 					return;
; 1406 : 				}
; 1407 : 			}
; 1408 : 
; 1409 : 			gObj[index].m_socket = INVALID_SOCKET;

  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	c7 44 0e 14 ff
	ff ff ff	 mov	 DWORD PTR [esi+ecx+20], -1
$LN3@CloseClien:

; 1410 : 		}
; 1411 : 
; 1412 : 		gObjDel(index);

  00096	53		 push	 ebx
  00097	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0009c	83 c4 04	 add	 esp, 4
$LN10@CloseClien:
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
$LN7@CloseClien:
  000a1	5b		 pop	 ebx

; 1413 : 	}
; 1414 : }

  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ENDP	; CloseClient
_TEXT	ENDS
PUBLIC	??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@ ; `string'
PUBLIC	??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@ ; `string'
PUBLIC	??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@ ; `string'
PUBLIC	?CloseClient@@YAXH@Z				; CloseClient
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@
CONST	SEGMENT
??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@ DB 'error-L1 :'
	DB	' CloseClient index error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@
CONST	SEGMENT
??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@ DB 'error-L1 : '
	DB	'CloseClient INVALID_SOCKET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@
CONST	SEGMENT
??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@ DB 'error-L1 :'
	DB	' CloseClient connect error', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CloseClient@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?CloseClient@@YAXH@Z PROC				; CloseClient, COMDAT

; 1419 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1420 : 	if ( index < 0 || index > OBJMAX-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00006	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  0000b	0f 87 b7 00 00
	00		 ja	 $LN7@CloseClien@2

; 1423 : 		return;
; 1424 : 	}
; 1425 : 
; 1426 : 	if ( gObj[index].Connected == PLAYER_EMPTY )

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00017	56		 push	 esi
  00018	8b f0		 mov	 esi, eax
  0001a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00020	83 7c 0e 04 00	 cmp	 DWORD PTR [esi+ecx+4], 0
  00025	57		 push	 edi
  00026	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00029	75 12		 jne	 SHORT $LN6@CloseClien@2

; 1427 : 	{
; 1428 : 		LogAdd("error-L1 : CloseClient connect error");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00036	83 c4 04	 add	 esp, 4
$LN11@CloseClien@2:
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 1466 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN6@CloseClien@2:

; 1429 : 		return;
; 1430 : 	}
; 1431 : 
; 1432 : 	LPOBJ lpObj = &gObj[index];
; 1433 : 
; 1434 : #if(OFFLINE_MODE==TRUE)
; 1435 : 	if(lpObj->m_OfflineMode == true)

  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	38 8f d4 28 00
	00		 cmp	 BYTE PTR [edi+10452], cl

; 1436 : 	{
; 1437 : 		lpObj->CheckTick = GetTickCount();
; 1438 : 		return;

  00048	74 08		 je	 SHORT $LN13@CloseClien@2

; 1439 : 	}
; 1440 : #endif
; 1441 : 
; 1442 : 	//	OffExp
; 1443 : 	if(lpObj->OffExp == 1)

  0004a	39 8f 98 22 00
	00		 cmp	 DWORD PTR [edi+8856], ecx
  00050	75 0d		 jne	 SHORT $LN4@CloseClien@2
$LN13@CloseClien@2:

; 1444 : 	{
; 1445 : 		lpObj->CheckTick = GetTickCount();

  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00058	89 47 40	 mov	 DWORD PTR [edi+64], eax
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 1466 : }

  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN4@CloseClien@2:

; 1446 : 		return;
; 1447 : 	}
; 1448 : 
; 1449 : #ifdef _OFFTRADE_
; 1450 : 		if(gOffTrade.CheckOnlineUser(index))return;

  0005f	50		 push	 eax
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  00065	e8 00 00 00 00	 call	 ?CheckOnlineUser@cOffTrade@@QAE_NH@Z ; cOffTrade::CheckOnlineUser
  0006a	84 c0		 test	 al, al
  0006c	75 cb		 jne	 SHORT $LN11@CloseClien@2

; 1451 : #endif
; 1452 : 
; 1453 : 	EnterCriticalSection(&criti);

  0006e	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1454 : 
; 1455 : 	if ( gObj[index].m_socket != INVALID_SOCKET )

  00079	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	8b 44 16 14	 mov	 eax, DWORD PTR [esi+edx+20]
  00083	83 f8 ff	 cmp	 eax, -1
  00086	74 23		 je	 SHORT $LN2@CloseClien@2

; 1456 : 	{
; 1457 : 		closesocket(gObj[index].m_socket );

  00088	50		 push	 eax
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1458 : 		gObj[index].m_socket = INVALID_SOCKET;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1463 : 	}
; 1464 : 
; 1465 : 	LeaveCriticalSection(&criti);

  00094	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00099	c7 44 06 14 ff
	ff ff ff	 mov	 DWORD PTR [esi+eax+20], -1
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi

; 1466 : }

  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN2@CloseClien@2:

; 1459 : 	}
; 1460 : 	else
; 1461 : 	{
; 1462 : 		LogAdd("error-L1 : CloseClient INVALID_SOCKET");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b6	83 c4 04	 add	 esp, 4

; 1463 : 	}
; 1464 : 
; 1465 : 	LeaveCriticalSection(&criti);

  000b9	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi

; 1466 : }

  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN7@CloseClien@2:

; 1421 : 	{
; 1422 : 		LogAdd("error-L1 : CloseClient index error");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d3	83 c4 04	 add	 esp, 4

; 1466 : }

  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?CloseClient@@YAXH@Z ENDP				; CloseClient
_TEXT	ENDS
PUBLIC	?ResponErrorCloseClient@@YAXH@Z			; ResponErrorCloseClient
; Function compile flags: /Ogtp
;	COMDAT ?ResponErrorCloseClient@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?ResponErrorCloseClient@@YAXH@Z PROC			; ResponErrorCloseClient, COMDAT

; 1469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1470 : 	if ( index < 0 || index > OBJMAX-1 )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _index$[ebp]
  00007	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0000d	0f 87 ba 00 00
	00		 ja	 $LN6@ResponErro

; 1473 : 		return;
; 1474 : 	}
; 1475 : 
; 1476 : 	if ( gObj[index].Connected == PLAYER_EMPTY )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	8b f3		 mov	 esi, ebx
  0001b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00021	83 7c 06 04 00	 cmp	 DWORD PTR [esi+eax+4], 0
  00026	57		 push	 edi
  00027	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  0002a	75 13		 jne	 SHORT $LN5@ResponErro

; 1477 : 	{
; 1478 : 		LogAdd("error-L1 : CloseClient connect error");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5e@
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00037	83 c4 04	 add	 esp, 4
$LN10@ResponErro:
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 1515 : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN5@ResponErro:

; 1479 : 		return;
; 1480 : 	}
; 1481 : 
; 1482 : 	LPOBJ lpObj = &gObj[index];
; 1483 : 
; 1484 : #if(OFFLINE_MODE==TRUE)
; 1485 : 	if(lpObj->m_OfflineMode == true)

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	38 87 d4 28 00
	00		 cmp	 BYTE PTR [edi+10452], al

; 1486 : 	{
; 1487 : 		lpObj->CheckTick = GetTickCount();
; 1488 : 		return;

  0004a	74 08		 je	 SHORT $LN12@ResponErro

; 1489 : 	}
; 1490 : #endif
; 1491 : 
; 1492 : 	//	OffExp
; 1493 : 	if(lpObj->OffExp == 1)

  0004c	39 87 98 22 00
	00		 cmp	 DWORD PTR [edi+8856], eax
  00052	75 0e		 jne	 SHORT $LN3@ResponErro
$LN12@ResponErro:

; 1494 : 	{
; 1495 : 		
; 1496 : 		lpObj->CheckTick = GetTickCount();

  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005a	89 47 40	 mov	 DWORD PTR [edi+64], eax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 1515 : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN3@ResponErro:

; 1497 : 		return;
; 1498 : 	}
; 1499 : 
; 1500 : #ifdef _OFFTRADE_
; 1501 : 		if(gOffTrade.CheckOnlineUser(index))return;

  00062	53		 push	 ebx
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  00068	e8 00 00 00 00	 call	 ?CheckOnlineUser@cOffTrade@@QAE_NH@Z ; cOffTrade::CheckOnlineUser
  0006d	84 c0		 test	 al, al
  0006f	75 c9		 jne	 SHORT $LN10@ResponErro

; 1502 : #endif
; 1503 : 
; 1504 : 	EnterCriticalSection(&criti);

  00071	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1505 : 	closesocket(gObj[index].m_socket);

  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00082	8b 54 0e 14	 mov	 edx, DWORD PTR [esi+ecx+20]
  00086	52		 push	 edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1506 : 	gObj[index].m_socket = INVALID_SOCKET;

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	83 c8 ff	 or	 eax, -1
  00096	89 44 0e 14	 mov	 DWORD PTR [esi+ecx+20], eax

; 1507 : 
; 1508 : 	if ( gObj[index].m_socket == INVALID_SOCKET )

  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	39 44 16 14	 cmp	 DWORD PTR [esi+edx+20], eax
  000a4	75 0e		 jne	 SHORT $LN1@ResponErro

; 1509 : 	{
; 1510 : 		LogAdd("error-L1 : CloseClient INVALID_SOCKET");

  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_S@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b1	83 c4 04	 add	 esp, 4
$LN1@ResponErro:

; 1511 : 	}
; 1512 : 
; 1513 : 	gObjDel(index);

  000b4	53		 push	 ebx
  000b5	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  000ba	83 c4 04	 add	 esp, 4

; 1514 : 	LeaveCriticalSection(&criti);

  000bd	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx

; 1515 : }

  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN6@ResponErro:

; 1471 : 	{
; 1472 : 		LogAdd("error-L1 : CloseClient index error");

  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5err@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d8	83 c4 04	 add	 esp, 4
  000db	5b		 pop	 ebx

; 1515 : }

  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?ResponErrorCloseClient@@YAXH@Z ENDP			; ResponErrorCloseClient
_TEXT	ENDS
PUBLIC	??0CStreamPacketEngine_Server@@QAE@XZ		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\spe.h
;	COMDAT ??0CStreamPacketEngine_Server@@QAE@XZ
_TEXT	SEGMENT
??0CStreamPacketEngine_Server@@QAE@XZ PROC		; CStreamPacketEngine_Server::CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 15   : 	CStreamPacketEngine_Server()

  00000	8b c1		 mov	 eax, ecx

; 16   : 	{
; 17   : 		this->Clear();

  00002	33 c9		 xor	 ecx, ecx
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CStreamPacketEngine_Server@@6B@
  0000a	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 18   : 	};

  0000e	c3		 ret	 0
??0CStreamPacketEngine_Server@@QAE@XZ ENDP		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
_TEXT	ENDS
PUBLIC	??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@ ; `string'
PUBLIC	??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@ ; `string'
PUBLIC	??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@ ; `string'
PUBLIC	??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@ ; `string'
PUBLIC	_uIndex$GSCopy$
PUBLIC	_lpIOContext$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z	; RecvDataParse
EXTRN	?ProtocolCore@@YAXEPAEHHHH@Z:PROC		; ProtocolCore
EXTRN	?Decrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Decrypt
EXTRN	?g_SimpleModulusCS@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulusCS
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@ DB 'Message copy %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@ DB 'er'
	DB	'ror-L1 : recvbuflen 1 %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
CONST	SEGMENT
??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@ DB 'error-L1 : '
	DB	'CStreamPacketEngine ExtractPacket Error : ip = %s account:%s '
	DB	'name:%s HEAD:%x (%s,%d) State:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@ DB 'error-L1 : size %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@
CONST	SEGMENT
??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@ DB 'e'
	DB	'rror-L1 : Header error (%s %d)lOfs:%d, size:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@
CONST	SEGMENT
??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@ DB 'error-L1 : '
	DB	'CStreamPacketEngine Adding Error : ip = %s account:%s name:%s'
	DB	' HEAD:%x (%s,%d) State:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@ DB 0beH
	DB	0cfH, 0c8H, 0a3H, 0c6H, 0d0H, 0c5H, 0b6H, ' : [0x%x]', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$2
__ehfuncinfo$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\giocp.cpp
xdata$x	ENDS
;	COMDAT ?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
_TEXT	SEGMENT
_xcode$ = -34864					; size = 1
_lpIOContext$GSCopy$ = -34860				; size = 4
_lOfs$ = -34856						; size = 4
_uIndex$GSCopy$ = -34852				; size = 4
_subhead$212356 = -34845				; size = 1
_subhead$212337 = -34845				; size = 1
_headcode$ = -34844					; size = 1
_ps$212373 = -34840					; size = 2056
_PacketStream$212364 = -34840				; size = 2056
_PacketStream$212339 = -34840				; size = 2056
_byDec$ = -32784					; size = 32767
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpIOContext$ = 8					; size = 4
_uIndex$ = 12						; size = 4
?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z PROC		; RecvDataParse, COMDAT

; 529  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 24 88 00 00	 mov	 eax, 34852		; 00008824H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 5d 08	 mov	 ebx, DWORD PTR _lpIOContext$[ebp]

; 530  : 	if ( lpIOContext->nSentBytes < 3 )

  00035	83 bb 24 00 02
	00 03		 cmp	 DWORD PTR [ebx+131108], 3

; 564  : 			headcode			= lphead->headcode;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _uIndex$[ebp]

; 667  : 					{
; 668  : 						return FALSE;
; 669  : 					}
; 670  : 
; 671  : #if(ENABLE_PROTOCOL_QUEUE)
; 672  : 
; 673  : 					QueueInfo.index = uIndex;
; 674  : 					QueueInfo.head = headcode;
; 675  : 					memcpy(QueueInfo.buff, byDec, size);
; 676  : 					QueueInfo.size = iSize;
; 677  : 					QueueInfo.encrypt = 1;
; 678  : 					QueueInfo.serial = subhead;
; 679  : 
; 680  : 					if(g_ServerQueue.AddToQueue(&QueueInfo) != 0)
; 681  : 					{
; 682  : 						ReleaseSemaphore(g_ServerQueueSemaphore, 1, 0);
; 683  : 					}
; 684  : 
; 685  : #else
; 686  : 
; 687  : 					//ProtocolCore(headcode, byDec+1, iSize, uIndex, 1, byDec[0]);
; 688  : 					ProtocolCore(headcode, byDec, iSize, uIndex, 1, subhead);

  0003f	89 9d d4 77 ff
	ff		 mov	 DWORD PTR _lpIOContext$GSCopy$[ebp], ebx
  00045	89 85 dc 77 ff
	ff		 mov	 DWORD PTR _uIndex$GSCopy$[ebp], eax
  0004b	0f 8c 76 05 00
	00		 jl	 $LN2@RecvDataPa

; 531  : 	{
; 532  : 		return TRUE;
; 533  : 	}
; 534  : 
; 535  : 	LPBYTE recvbuf;
; 536  : 	int lOfs = 0;

  00051	33 d2		 xor	 edx, edx
  00053	89 95 d8 77 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], edx
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL35@RecvDataPa:

; 537  : 	int size = 0;
; 538  : 	BYTE headcode;
; 539  : 	BYTE xcode = 0;
; 540  : 	BYTE byDec[MAX_EXSENDBUF_SIZE];	//[7024];
; 541  : 
; 542  : #if(ENABLE_PROTOCOL_QUEUE)
; 543  : 	static QUEUE_INFO QueueInfo;
; 544  : #endif
; 545  : 
; 546  : 	recvbuf = (LPBYTE)lpIOContext->Buffer;
; 547  : 
; 548  : 	while ( 1 )
; 549  : 	{
; 550  : 		if( recvbuf[lOfs] == 0xC1 || 
; 551  : 			recvbuf[lOfs] == 0xC3 ) 

  00060	8d 7b 1c	 lea	 edi, DWORD PTR [ebx+28]
  00063	8a 0c 17	 mov	 cl, BYTE PTR [edi+edx]
  00066	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00069	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  0006c	74 25		 je	 SHORT $LN32@RecvDataPa
  0006e	80 f9 c3	 cmp	 cl, 195			; 000000c3H
  00071	74 20		 je	 SHORT $LN32@RecvDataPa

; 557  : 		}
; 558  : 		else if( recvbuf[lOfs] == 0xC2 || 
; 559  : 				 recvbuf[lOfs] == 0xC4 ) //

  00073	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  00076	74 09		 je	 SHORT $LN29@RecvDataPa
  00078	80 f9 c4	 cmp	 cl, 196			; 000000c4H
  0007b	0f 85 f9 03 00
	00		 jne	 $LN30@RecvDataPa
$LN29@RecvDataPa:

; 560  : 		{
; 561  : 			PWMSG_HEAD* lphead	= (PWMSG_HEAD*)(recvbuf+lOfs);
; 562  : 			size				= ((WORD)(lphead->sizeH)<<8);
; 563  : 			size			   |= (WORD)(lphead->sizeL);

  00081	0f b6 70 01	 movzx	 esi, BYTE PTR [eax+1]
  00085	0f b6 50 02	 movzx	 edx, BYTE PTR [eax+2]
  00089	c1 e6 08	 shl	 esi, 8
  0008c	0b f2		 or	 esi, edx

; 564  : 			headcode			= lphead->headcode;

  0008e	8a 50 03	 mov	 dl, BYTE PTR [eax+3]

; 565  : 			xcode				= recvbuf[lOfs];
; 566  : 		}
; 567  : 		else  //   ..

  00091	eb 07		 jmp	 SHORT $LN115@RecvDataPa
$LN32@RecvDataPa:

; 552  : 		{
; 553  : 			PBMSG_HEAD* lphead = (PBMSG_HEAD*)(recvbuf+lOfs);
; 554  : 			size				= lphead->size;

  00093	0f b6 70 01	 movzx	 esi, BYTE PTR [eax+1]

; 555  : 			headcode			= lphead->headcode;

  00097	8a 50 02	 mov	 dl, BYTE PTR [eax+2]
$LN115@RecvDataPa:

; 556  : 			xcode				= recvbuf[lOfs];

  0009a	88 8d d0 77 ff
	ff		 mov	 BYTE PTR _xcode$[ebp], cl
  000a0	88 95 e4 77 ff
	ff		 mov	 BYTE PTR _headcode$[ebp], dl

; 574  : 		}
; 575  : 		if ( size <= 0 )

  000a6	85 f6		 test	 esi, esi
  000a8	0f 8e fd 03 00
	00		 jle	 $LN97@RecvDataPa

; 579  : 		}
; 580  : 
; 581  : 		if ( size <= lpIOContext->nSentBytes )

  000ae	3b b3 24 00 02
	00		 cmp	 esi, DWORD PTR [ebx+131108]
  000b4	0f 8f b7 04 00
	00		 jg	 $LN26@RecvDataPa

; 582  : 		{
; 583  : 
; 584  : 			#if(ENABLE_INDEV_NETWORK)
; 585  : 			//LogAddC(2, "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", recvbuf[0], recvbuf[1], recvbuf[2], recvbuf[3], recvbuf[4]);
; 586  : 			#endif
; 587  : 
; 588  : 			if ( xcode == 0xC3 )

  000ba	80 f9 c3	 cmp	 cl, 195			; 000000c3H
  000bd	0f 85 54 01 00
	00		 jne	 $LN25@RecvDataPa

; 589  : 			{
; 590  : #if(ENABLE_INDEV_NETWORK)
; 591  : 				int iSize = g_PacketEncrypt.Decrypt( byDec+2,(recvbuf+lOfs+2), size-2);
; 592  : 				//int iSize = g_PacketEncrypt.Decrypt(&byDec[2], &recvbuf[lOfs + 2], size - 2);
; 593  : 				//memcpy( &byDec[2], &recvbuf[lOfs + 2], size - 2);
; 594  : 
; 595  : #else
; 596  : 				int iSize = g_SimpleModulusCS.Decrypt( byDec+2,(recvbuf+lOfs+2), size-2);

  000c3	8b 8d d8 77 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  000c9	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  000cc	50		 push	 eax
  000cd	8d 54 0f 02	 lea	 edx, DWORD PTR [edi+ecx+2]
  000d1	52		 push	 edx
  000d2	8d 85 f2 7f ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+2]
  000d8	50		 push	 eax
  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusCS@@3VCSimpleModulus@@A ; g_SimpleModulusCS
  000de	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  000e3	8b d8		 mov	 ebx, eax

; 597  : #endif
; 598  : 
; 599  : 
; 600  : 
; 601  : 				if ( iSize < 0 )

  000e5	85 db		 test	 ebx, ebx
  000e7	0f 88 00 01 00
	00		 js	 $LN112@RecvDataPa

; 602  : 				{
; 603  : 
; 604  : 				}
; 605  : 				else
; 606  : 				{
; 607  : #if(ENABLE_INDEV_NETWORK)
; 608  : 					PBMSG_HEAD* lphead = (PBMSG_HEAD*)(byDec);
; 609  : 					headcode		= lphead->headcode;
; 610  : 					BYTE subhead	= byDec[2];
; 611  : 					byDec[0]		= 0xC1;
; 612  : 					byDec[1]		= ((BYTE)iSize)+2;
; 613  : 
; 614  : #else
; 615  : 					PBMSG_HEAD* lphead = (PBMSG_HEAD*)(byDec+1);
; 616  : 					headcode		= lphead->headcode;
; 617  : 					BYTE subhead	= byDec[2];

  000ed	8a 95 f2 7f ff
	ff		 mov	 dl, BYTE PTR _byDec$[ebp+2]
  000f3	8a 8d f3 7f ff
	ff		 mov	 cl, BYTE PTR _byDec$[ebp+3]

; 618  : 					byDec[1]		= 0xC1;
; 619  : 					byDec[2]		= ((BYTE)iSize)+2;

  000f9	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  000fc	88 8d e4 77 ff
	ff		 mov	 BYTE PTR _headcode$[ebp], cl
  00102	88 95 e3 77 ff
	ff		 mov	 BYTE PTR _subhead$212337[ebp], dl
  00108	c6 85 f1 7f ff
	ff c1		 mov	 BYTE PTR _byDec$[ebp+1], 193 ; 000000c1H
  0010f	88 85 f2 7f ff
	ff		 mov	 BYTE PTR _byDec$[ebp+2], al

; 620  : #endif
; 621  : 
; 622  : 
; 623  : 
; 624  : 				#if(ENABLE_INDEV_NETWORK)
; 625  : 				LogAddC(3, "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X",
; 626  : 					byDec[0], byDec[1], byDec[2], byDec[3], byDec[4], byDec[5]);
; 627  : 				#endif
; 628  : 
; 629  : 					CStreamPacketEngine_Server PacketStream;

  00115	c7 85 e8 77 ff
	ff 00 00 00 00	 mov	 DWORD PTR _PacketStream$212339[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 630  : 
; 631  : 					PacketStream.Clear();
; 632  : 
; 633  : #if(ENABLE_INDEV_NETWORK)
; 634  : 					if ( PacketStream.AddData(byDec, iSize+2) == 0 )
; 635  : #else
; 636  : 					if ( PacketStream.AddData(byDec+1, iSize+2) == 0 )

  0011f	8d 53 02	 lea	 edx, DWORD PTR [ebx+2]
  00122	0f b7 fa	 movzx	 edi, dx
  00125	33 c9		 xor	 ecx, ecx
  00127	8b c7		 mov	 eax, edi
  00129	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00130	66 89 8d ec 77
	ff ff		 mov	 WORD PTR _PacketStream$212339[ebp+4], cx
  00137	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0013c	0f 8d 77 02 00
	00		 jge	 $LN48@RecvDataPa
  00142	66 85 ff	 test	 di, di
  00145	0f 84 6e 02 00
	00		 je	 $LN48@RecvDataPa
  0014b	50		 push	 eax
  0014c	8d 85 f1 7f ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+1]
  00152	50		 push	 eax
  00153	8d 8d ee 77 ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$212339[ebp+6]
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 _memcpy
  0015f	66 01 bd ec 77
	ff ff		 add	 WORD PTR _PacketStream$212339[ebp+4], di
  00166	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 					}
; 648  : 
; 649  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  00169	8d 95 f0 7f ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  0016f	52		 push	 edx
  00170	8d 8d e8 77 ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$212339[ebp]
  00176	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  0017b	85 c0		 test	 eax, eax
  0017d	0f 85 3e 03 00
	00		 jne	 $LN99@RecvDataPa

; 659  : 					}
; 660  : 
; 661  : 					if ( xcode == 0xC3 && headcode == 0xC5 )

  00183	80 bd e4 77 ff
	ff c5		 cmp	 BYTE PTR _headcode$[ebp], 197 ; 000000c5H
  0018a	75 13		 jne	 SHORT $LN20@RecvDataPa

; 662  : 					{
; 663  : 						LogAdd(" : [0x%x]" , headcode);

  0018c	68 c5 00 00 00	 push	 197			; 000000c5H
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0019c	83 c4 08	 add	 esp, 8
$LN20@RecvDataPa:

; 664  : 					}
; 665  : 
; 666  : 					if(HackToolCheck(headcode, size, uIndex, xcode) == TRUE)

  0019f	68 c3 00 00 00	 push	 195			; 000000c3H
$LN120@RecvDataPa:
  001a4	8b bd dc 77 ff
	ff		 mov	 edi, DWORD PTR _uIndex$GSCopy$[ebp]
  001aa	8b 85 e4 77 ff
	ff		 mov	 eax, DWORD PTR _headcode$[ebp]
  001b0	57		 push	 edi
  001b1	56		 push	 esi
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?HackToolCheck@@YAHEHHE@Z ; HackToolCheck
  001b8	83 c4 10	 add	 esp, 16			; 00000010H
  001bb	83 f8 01	 cmp	 eax, 1
  001be	0f 84 e0 02 00
	00		 je	 $LN100@RecvDataPa

; 667  : 					{
; 668  : 						return FALSE;
; 669  : 					}
; 670  : 
; 671  : #if(ENABLE_PROTOCOL_QUEUE)
; 672  : 
; 673  : 					QueueInfo.index = uIndex;
; 674  : 					QueueInfo.head = headcode;
; 675  : 					memcpy(QueueInfo.buff, byDec, size);
; 676  : 					QueueInfo.size = iSize;
; 677  : 					QueueInfo.encrypt = 1;
; 678  : 					QueueInfo.serial = subhead;
; 679  : 
; 680  : 					if(g_ServerQueue.AddToQueue(&QueueInfo) != 0)
; 681  : 					{
; 682  : 						ReleaseSemaphore(g_ServerQueueSemaphore, 1, 0);
; 683  : 					}
; 684  : 
; 685  : #else
; 686  : 
; 687  : 					//ProtocolCore(headcode, byDec+1, iSize, uIndex, 1, byDec[0]);
; 688  : 					ProtocolCore(headcode, byDec, iSize, uIndex, 1, subhead);

  001c4	0f b6 8d e3 77
	ff ff		 movzx	 ecx, BYTE PTR _subhead$212337[ebp]
  001cb	8b 85 e4 77 ff
	ff		 mov	 eax, DWORD PTR _headcode$[ebp]
  001d1	51		 push	 ecx
  001d2	6a 01		 push	 1
  001d4	57		 push	 edi
  001d5	53		 push	 ebx
  001d6	8d 95 f0 7f ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  001dc	52		 push	 edx
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  001e3	83 c4 18	 add	 esp, 24			; 00000018H

; 689  : 
; 690  : #endif
; 691  : 				}

  001e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN112@RecvDataPa:

; 769  : 					{
; 770  : 						return FALSE;
; 771  : 					}
; 772  : 	
; 773  : #if(ENABLE_PROTOCOL_QUEUE)
; 774  : 
; 775  : 					QueueInfo.index = uIndex;
; 776  : 					QueueInfo.head = headcode;
; 777  : 					memcpy(QueueInfo.buff, byDec, size);
; 778  : 					QueueInfo.size = iSize;
; 779  : 					QueueInfo.encrypt = 1;
; 780  : 					QueueInfo.serial = subhead;
; 781  : 
; 782  : 					if(g_ServerQueue.AddToQueue(&QueueInfo) != 0)
; 783  : 					{
; 784  : 						ReleaseSemaphore(g_ServerQueueSemaphore, 1, 0);
; 785  : 					}
; 786  : 
; 787  : #else
; 788  : 
; 789  : 					ProtocolCore(headcode, byDec, iSize, uIndex, 1, subhead);
; 790  : 
; 791  : #endif
; 792  : 				}
; 793  : 			}
; 794  : 			else

  001ed	8b 9d d4 77 ff
	ff		 mov	 ebx, DWORD PTR _lpIOContext$GSCopy$[ebp]

; 847  : 
; 848  : #endif
; 849  : 
; 850  : 			}

$LN94@RecvDataPa:

; 851  : 
; 852  : 			lOfs += size;

  001f3	01 b5 d8 77 ff
	ff		 add	 DWORD PTR _lOfs$[ebp], esi

; 853  : 			lpIOContext->nSentBytes  -= size;

  001f9	29 b3 24 00 02
	00		 sub	 DWORD PTR [ebx+131108], esi

; 854  : 
; 855  : 			if ( lpIOContext->nSentBytes <= 0 )

  001ff	83 bb 24 00 02
	00 00		 cmp	 DWORD PTR [ebx+131108], 0
  00206	0f 8e bb 03 00
	00		 jle	 $LN2@RecvDataPa

; 872  : 				//break;
; 873  : 			}
; 874  : 			break;
; 875  : 		
; 876  : 		}
; 877  : 		else
; 878  : 		{
; 879  : 			break;
; 880  : 		}
; 881  : 		
; 882  : 	}

  0020c	8b 95 d8 77 ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  00212	e9 49 fe ff ff	 jmp	 $LL35@RecvDataPa
$LN25@RecvDataPa:

; 692  : 			}
; 693  : 
; 694  : 			else if ( xcode == 0xC4 )

  00217	80 f9 c4	 cmp	 cl, 196			; 000000c4H
  0021a	0f 85 e6 00 00
	00		 jne	 $LN17@RecvDataPa

; 695  : 			{
; 696  : #if(ENABLE_INDEV_NETWORK)
; 697  : 				int iSize = g_PacketEncrypt.Decrypt( byDec+3, (recvbuf+lOfs+3), size-3);
; 698  : 				//int iSize = g_PacketEncrypt.Decrypt(&byDec[3], &recvbuf[lOfs + 3], size - 3);
; 699  : #else
; 700  : 				int iSize = g_SimpleModulusCS.Decrypt( byDec+3, (recvbuf+lOfs+3), size-3);

  00220	8b 95 d8 77 ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  00226	8d 4e fd	 lea	 ecx, DWORD PTR [esi-3]
  00229	51		 push	 ecx
  0022a	8d 44 17 03	 lea	 eax, DWORD PTR [edi+edx+3]
  0022e	50		 push	 eax
  0022f	8d 8d f3 7f ff
	ff		 lea	 ecx, DWORD PTR _byDec$[ebp+3]
  00235	51		 push	 ecx
  00236	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusCS@@3VCSimpleModulus@@A ; g_SimpleModulusCS
  0023b	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  00240	8b d8		 mov	 ebx, eax

; 701  : #endif
; 702  : 				if ( iSize < 0 )

  00242	85 db		 test	 ebx, ebx
  00244	78 a7		 js	 SHORT $LN112@RecvDataPa

; 703  : 				{
; 704  : 
; 705  : 				}
; 706  : 				else
; 707  : 				{
; 708  : #if(ENABLE_INDEV_NETWORK)
; 709  : 					BYTE* pDecBuf = byDec+1;
; 710  : 					BYTE subhead	= byDec[3];
; 711  : 					byDec[0]		= 0xC2;
; 712  : 					WORD wsize		= ((WORD)iSize)+3;
; 713  : 					byDec[1]		= SET_NUMBERH(wsize);
; 714  : 					byDec[2]		= SET_NUMBERL(wsize);
; 715  : 
; 716  : #else
; 717  : 					BYTE* pDecBuf = byDec+1;
; 718  : 					BYTE subhead	= byDec[3];

  00246	8a 95 f3 7f ff
	ff		 mov	 dl, BYTE PTR _byDec$[ebp+3]

; 719  : 					byDec[1]		= 0xC2;
; 720  : 					WORD wsize		= ((WORD)iSize)+3;

  0024c	8d 7b 03	 lea	 edi, DWORD PTR [ebx+3]
  0024f	0f b7 c7	 movzx	 eax, di

; 721  : 					byDec[2]		= SET_NUMBERH(wsize);

  00252	8b c8		 mov	 ecx, eax
  00254	c1 e9 08	 shr	 ecx, 8
  00257	88 95 e3 77 ff
	ff		 mov	 BYTE PTR _subhead$212356[ebp], dl
  0025d	c6 85 f1 7f ff
	ff c2		 mov	 BYTE PTR _byDec$[ebp+1], 194 ; 000000c2H
  00264	88 8d f2 7f ff
	ff		 mov	 BYTE PTR _byDec$[ebp+2], cl

; 722  : 					byDec[3]		= SET_NUMBERL(wsize);

  0026a	88 85 f3 7f ff
	ff		 mov	 BYTE PTR _byDec$[ebp+3], al

; 723  : #endif
; 724  : 
; 725  : 
; 726  : 					CStreamPacketEngine_Server PacketStream;

  00270	c7 85 e8 77 ff
	ff 00 00 00 00	 mov	 DWORD PTR _PacketStream$212364[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 727  : 
; 728  : 					PacketStream.Clear();
; 729  : 
; 730  : 
; 731  : #if(ENABLE_INDEV_NETWORK)
; 732  : 					if ( PacketStream.AddData(byDec, iSize+3) == 0 )
; 733  : #else
; 734  : 					if ( PacketStream.AddData(byDec+1, iSize+3) == 0 )

  0027a	0f b7 c7	 movzx	 eax, di
  0027d	33 d2		 xor	 edx, edx
  0027f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00286	66 89 95 ec 77
	ff ff		 mov	 WORD PTR _PacketStream$212364[ebp+4], dx
  0028d	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00292	0f 8d 7d 01 00
	00		 jge	 $LN66@RecvDataPa
  00298	66 85 ff	 test	 di, di
  0029b	0f 84 74 01 00
	00		 je	 $LN66@RecvDataPa
  002a1	50		 push	 eax
  002a2	8d 85 f1 7f ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp+1]
  002a8	50		 push	 eax
  002a9	8d 8d ee 77 ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$212364[ebp+6]
  002af	51		 push	 ecx
  002b0	e8 00 00 00 00	 call	 _memcpy
  002b5	66 01 bd ec 77
	ff ff		 add	 WORD PTR _PacketStream$212364[ebp+4], di
  002bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 746  : 					}
; 747  : 
; 748  : 					if ( PacketStream.ExtractPacket(byDec) != 0 )

  002bf	8d 95 f0 7f ff
	ff		 lea	 edx, DWORD PTR _byDec$[ebp]
  002c5	52		 push	 edx
  002c6	8d 8d e8 77 ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$212364[ebp]
  002cc	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  002d1	85 c0		 test	 eax, eax
  002d3	0f 85 33 02 00
	00		 jne	 $LN102@RecvDataPa

; 758  : 						return FALSE;
; 759  : 					}
; 760  : 
; 761  : 					headcode = pDecBuf[2];

  002d9	8a 85 f3 7f ff
	ff		 mov	 al, BYTE PTR _byDec$[ebp+3]
  002df	88 85 e4 77 ff
	ff		 mov	 BYTE PTR _headcode$[ebp], al

; 762  : 
; 763  : 					if ( xcode == 0xC4 && headcode == 0xC5 )

  002e5	3c c5		 cmp	 al, 197			; 000000c5H
  002e7	75 13		 jne	 SHORT $LN12@RecvDataPa

; 764  : 					{
; 765  : 						LogAdd(" : [0x%x]" , headcode);

  002e9	68 c5 00 00 00	 push	 197			; 000000c5H
  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN?$AA@
  002f3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002f9	83 c4 08	 add	 esp, 8
$LN12@RecvDataPa:

; 766  : 					}
; 767  : 
; 768  : 					if(HackToolCheck(headcode, size, uIndex, xcode) == TRUE)

  002fc	68 c4 00 00 00	 push	 196			; 000000c4H

; 769  : 					{
; 770  : 						return FALSE;
; 771  : 					}
; 772  : 	
; 773  : #if(ENABLE_PROTOCOL_QUEUE)
; 774  : 
; 775  : 					QueueInfo.index = uIndex;
; 776  : 					QueueInfo.head = headcode;
; 777  : 					memcpy(QueueInfo.buff, byDec, size);
; 778  : 					QueueInfo.size = iSize;
; 779  : 					QueueInfo.encrypt = 1;
; 780  : 					QueueInfo.serial = subhead;
; 781  : 
; 782  : 					if(g_ServerQueue.AddToQueue(&QueueInfo) != 0)
; 783  : 					{
; 784  : 						ReleaseSemaphore(g_ServerQueueSemaphore, 1, 0);
; 785  : 					}
; 786  : 
; 787  : #else
; 788  : 
; 789  : 					ProtocolCore(headcode, byDec, iSize, uIndex, 1, subhead);
; 790  : 
; 791  : #endif
; 792  : 				}
; 793  : 			}
; 794  : 			else

  00301	e9 9e fe ff ff	 jmp	 $LN120@RecvDataPa
$LN17@RecvDataPa:

; 795  : 			{
; 796  : 				CStreamPacketEngine_Server ps;

  00306	c7 85 e8 77 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ps$212373[ebp], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 797  : 				ps.Clear();

  00310	33 c9		 xor	 ecx, ecx
  00312	66 89 8d ec 77
	ff ff		 mov	 WORD PTR _ps$212373[ebp+4], cx

; 798  : 				
; 799  : 				if ( ps.AddData(recvbuf+lOfs, size) == 0 )

  00319	0f b7 ce	 movzx	 ecx, si
  0031c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00323	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  00329	0f 8d 17 01 00
	00		 jge	 $LN84@RecvDataPa
  0032f	66 85 f6	 test	 si, si
  00332	0f 84 0e 01 00
	00		 je	 $LN84@RecvDataPa
  00338	51		 push	 ecx
  00339	50		 push	 eax
  0033a	8d 95 ee 77 ff
	ff		 lea	 edx, DWORD PTR _ps$212373[ebp+6]
  00340	52		 push	 edx
  00341	e8 00 00 00 00	 call	 _memcpy
  00346	66 01 b5 ec 77
	ff ff		 add	 WORD PTR _ps$212373[ebp+4], si
  0034d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 809  : 				}
; 810  : 
; 811  : 
; 812  : 
; 813  : 				if ( ps.ExtractPacket(byDec) != 0 )

  00350	8d 85 f0 7f ff
	ff		 lea	 eax, DWORD PTR _byDec$[ebp]
  00356	50		 push	 eax
  00357	8d 8d e8 77 ff
	ff		 lea	 ecx, DWORD PTR _ps$212373[ebp]
  0035d	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  00362	85 c0		 test	 eax, eax
  00364	0f 85 ea 01 00
	00		 jne	 $LN105@RecvDataPa

; 823  : 				}
; 824  : 
; 825  : 				if(HackToolCheck(headcode, size, uIndex, xcode) == TRUE)

  0036a	8b 8d d0 77 ff
	ff		 mov	 ecx, DWORD PTR _xcode$[ebp]
  00370	8b 95 dc 77 ff
	ff		 mov	 edx, DWORD PTR _uIndex$GSCopy$[ebp]
  00376	8b bd e4 77 ff
	ff		 mov	 edi, DWORD PTR _headcode$[ebp]
  0037c	51		 push	 ecx
  0037d	52		 push	 edx
  0037e	56		 push	 esi
  0037f	57		 push	 edi
  00380	e8 00 00 00 00	 call	 ?HackToolCheck@@YAHEHHE@Z ; HackToolCheck
  00385	83 c4 10	 add	 esp, 16			; 00000010H
  00388	83 f8 01	 cmp	 eax, 1
  0038b	0f 84 13 01 00
	00		 je	 $LN100@RecvDataPa

; 826  : 				{
; 827  : 					return FALSE;
; 828  : 				}
; 829  : 
; 830  : #if(ENABLE_PROTOCOL_QUEUE)
; 831  : 
; 832  : 				QueueInfo.index = uIndex;
; 833  : 				QueueInfo.head = headcode;
; 834  : 				memcpy(QueueInfo.buff, byDec, size);
; 835  : 				QueueInfo.size = size;
; 836  : 				QueueInfo.encrypt = 0;
; 837  : 				QueueInfo.serial = -1;
; 838  : 
; 839  : 				if(g_ServerQueue.AddToQueue(&QueueInfo) != 0)
; 840  : 				{
; 841  : 					ReleaseSemaphore(g_ServerQueueSemaphore, 1, 0);
; 842  : 				}
; 843  : 				
; 844  : #else
; 845  : 
; 846  : 				ProtocolCore(headcode, byDec, size, uIndex, 0, -1);

  00391	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  00397	6a ff		 push	 -1
  00399	6a 00		 push	 0
  0039b	50		 push	 eax
  0039c	56		 push	 esi
  0039d	8d 8d f0 7f ff
	ff		 lea	 ecx, DWORD PTR _byDec$[ebp]
  003a3	51		 push	 ecx
  003a4	57		 push	 edi
  003a5	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  003aa	83 c4 18	 add	 esp, 24			; 00000018H

; 847  : 
; 848  : #endif
; 849  : 
; 850  : 			}

  003ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003b4	e9 3a fe ff ff	 jmp	 $LN94@RecvDataPa

; 630  : 
; 631  : 					PacketStream.Clear();
; 632  : 
; 633  : #if(ENABLE_INDEV_NETWORK)
; 634  : 					if ( PacketStream.AddData(byDec, iSize+2) == 0 )
; 635  : #else
; 636  : 					if ( PacketStream.AddData(byDec+1, iSize+2) == 0 )

$LN48@RecvDataPa:
  003b9	57		 push	 edi
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  003bf	6a 02		 push	 2
  003c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 637  : #endif
; 638  : 					{
; 639  : 						LogAddC(2, "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 640  : 							gObj[uIndex].Ip_addr, 
; 641  : 							gObj[uIndex].AccountID, 
; 642  : 							gObj[uIndex].Name, 
; 643  : 							headcode, 
; 644  : 							__FILE__, __LINE__, 
; 645  : 							gObj[uIndex].Connected);

  003c7	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  003cd	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003d6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003dc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003df	52		 push	 edx
  003e0	68 84 02 00 00	 push	 644			; 00000284H
$LN117@RecvDataPa:
  003e5	0f b6 8d e4 77
	ff ff		 movzx	 ecx, BYTE PTR _headcode$[ebp]
  003ec	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  003f1	51		 push	 ecx
  003f2	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  003f5	52		 push	 edx
  003f6	8d 48 6c	 lea	 ecx, DWORD PTR [eax+108]
  003f9	51		 push	 ecx
  003fa	83 c0 18	 add	 eax, 24			; 00000018H
  003fd	50		 push	 eax
  003fe	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5A@
  00403	6a 02		 push	 2
  00405	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0040b	83 c4 24	 add	 esp, 36			; 00000024H

; 646  : 						return FALSE;

  0040e	33 c0		 xor	 eax, eax
  00410	e9 b7 01 00 00	 jmp	 $LN37@RecvDataPa

; 727  : 
; 728  : 					PacketStream.Clear();
; 729  : 
; 730  : 
; 731  : #if(ENABLE_INDEV_NETWORK)
; 732  : 					if ( PacketStream.AddData(byDec, iSize+3) == 0 )
; 733  : #else
; 734  : 					if ( PacketStream.AddData(byDec+1, iSize+3) == 0 )

$LN66@RecvDataPa:
  00415	0f b7 c7	 movzx	 eax, di
  00418	50		 push	 eax
  00419	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  0041e	6a 02		 push	 2
  00420	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 735  : #endif			
; 736  : 					{
; 737  : 						LogAddC(2, "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d",	
; 738  : 							gObj[uIndex].Ip_addr, 
; 739  : 							gObj[uIndex].AccountID, 
; 740  : 							gObj[uIndex].Name, 
; 741  : 							headcode, 
; 742  : 							__FILE__, 
; 743  : 							__LINE__, 
; 744  : 							gObj[uIndex].Connected);

  00426	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  0042c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00432	83 c4 0c	 add	 esp, 12			; 0000000cH
  00435	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0043e	52		 push	 edx
  0043f	68 e7 02 00 00	 push	 743			; 000002e7H

; 745  : 						return FALSE;

  00444	eb 9f		 jmp	 SHORT $LN117@RecvDataPa

; 798  : 				
; 799  : 				if ( ps.AddData(recvbuf+lOfs, size) == 0 )

$LN84@RecvDataPa:
  00446	0f b7 ce	 movzx	 ecx, si
  00449	51		 push	 ecx
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buffe@
  0044f	6a 02		 push	 2
  00451	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 800  : 				{
; 801  : 					LogAddC(2, "error-L1 : CStreamPacketEngine Adding Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 802  : 						gObj[uIndex].Ip_addr, 
; 803  : 						gObj[uIndex].AccountID, 
; 804  : 						gObj[uIndex].Name, 
; 805  : 						headcode, 
; 806  : 						__FILE__, __LINE__, 
; 807  : 						gObj[uIndex].Connected);

  00457	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  0045d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00463	83 c4 0c	 add	 esp, 12			; 0000000cH
  00466	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0046f	52		 push	 edx
  00470	68 26 03 00 00	 push	 806			; 00000326H

; 808  : 					return FALSE;

  00475	e9 6b ff ff ff	 jmp	 $LN117@RecvDataPa
$LN30@RecvDataPa:

; 568  : 		{
; 569  : 			LogAdd("error-L1 : Header error (%s %d)lOfs:%d, size:%d",
; 570  : 				__FILE__, __LINE__, lOfs, 
; 571  : 				lpIOContext->nSentBytes);

  0047a	8b 83 24 00 02
	00		 mov	 eax, DWORD PTR [ebx+131108]
  00480	50		 push	 eax
  00481	52		 push	 edx
  00482	68 3a 02 00 00	 push	 570			; 0000023aH
  00487	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  0048c	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJl@
  00491	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00497	83 c4 14	 add	 esp, 20			; 00000014H

; 572  : 			lpIOContext->nSentBytes = 0;

  0049a	c7 83 24 00 02
	00 00 00 00 00	 mov	 DWORD PTR [ebx+131108], 0
$LN100@RecvDataPa:

; 573  : 			return FALSE;

  004a4	33 c0		 xor	 eax, eax
  004a6	e9 21 01 00 00	 jmp	 $LN37@RecvDataPa
$LN97@RecvDataPa:

; 576  : 		{
; 577  : 			LogAdd("error-L1 : size %d",size);

  004ab	56		 push	 esi
  004ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd?$AA@
  004b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004b7	83 c4 08	 add	 esp, 8

; 578  : 			return FALSE;

  004ba	33 c0		 xor	 eax, eax
  004bc	e9 0b 01 00 00	 jmp	 $LN37@RecvDataPa
$LN99@RecvDataPa:

; 650  : 					{
; 651  : 						LogAddC(2, "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 652  : 							gObj[uIndex].Ip_addr, 
; 653  : 							gObj[uIndex].AccountID, 
; 654  : 							gObj[uIndex].Name, 
; 655  : 							headcode, 
; 656  : 							__FILE__, __LINE__, 
; 657  : 							gObj[uIndex].Connected);

  004c1	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  004c7	0f b6 95 e4 77
	ff ff		 movzx	 edx, BYTE PTR _headcode$[ebp]
  004ce	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  004d4	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004dd	51		 push	 ecx
  004de	68 90 02 00 00	 push	 656			; 00000290H
  004e3	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  004e8	52		 push	 edx
  004e9	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  004ec	51		 push	 ecx
  004ed	8d 50 6c	 lea	 edx, DWORD PTR [eax+108]
  004f0	52		 push	 edx
  004f1	83 c0 18	 add	 eax, 24			; 00000018H
  004f4	50		 push	 eax
  004f5	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
  004fa	6a 02		 push	 2
  004fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00502	83 c4 24	 add	 esp, 36			; 00000024H

; 658  : 						return FALSE;

  00505	33 c0		 xor	 eax, eax
  00507	e9 c0 00 00 00	 jmp	 $LN37@RecvDataPa
$LN102@RecvDataPa:

; 749  : 					{
; 750  : 						LogAddC(2, "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 751  : 							gObj[uIndex].Ip_addr, 
; 752  : 							gObj[uIndex].AccountID, 
; 753  : 							gObj[uIndex].Name, 
; 754  : 							headcode, 
; 755  : 							__FILE__, 
; 756  : 							__LINE__, 
; 757  : 							gObj[uIndex].Connected);

  0050c	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  00512	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00518	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0051e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00521	51		 push	 ecx
  00522	68 f4 02 00 00	 push	 756			; 000002f4H
$LN121@RecvDataPa:
  00527	0f b6 95 e4 77
	ff ff		 movzx	 edx, BYTE PTR _headcode$[ebp]
  0052e	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00533	52		 push	 edx
  00534	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00537	51		 push	 ecx
  00538	8d 50 6c	 lea	 edx, DWORD PTR [eax+108]
  0053b	52		 push	 edx
  0053c	83 c0 18	 add	 eax, 24			; 00000018H
  0053f	50		 push	 eax
  00540	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5E@
  00545	6a 02		 push	 2
  00547	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0054d	83 c4 24	 add	 esp, 36			; 00000024H
  00550	33 c0		 xor	 eax, eax
  00552	eb 78		 jmp	 SHORT $LN37@RecvDataPa
$LN105@RecvDataPa:

; 814  : 				{
; 815  : 					LogAddC(2, "error-L1 : CStreamPacketEngine ExtractPacket Error : ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 816  : 						gObj[uIndex].Ip_addr, 
; 817  : 						gObj[uIndex].AccountID, 
; 818  : 						gObj[uIndex].Name, 
; 819  : 						headcode, 
; 820  : 						__FILE__, __LINE__, 
; 821  : 						gObj[uIndex].Connected);

  00554	8b 85 dc 77 ff
	ff		 mov	 eax, DWORD PTR _uIndex$GSCopy$[ebp]
  0055a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00560	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00566	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00569	51		 push	 ecx
  0056a	68 34 03 00 00	 push	 820			; 00000334H

; 822  : 					return FALSE;

  0056f	eb b6		 jmp	 SHORT $LN121@RecvDataPa
$LN26@RecvDataPa:

; 856  : 			{
; 857  : 				break;
; 858  : 			}
; 859  : 		}
; 860  : 		else if ( lOfs > 0 )

  00571	8b 8d d8 77 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00577	85 c9		 test	 ecx, ecx
  00579	7e 4c		 jle	 SHORT $LN2@RecvDataPa

; 861  : 		{
; 862  : 			if ( lpIOContext->nSentBytes < 1 )

  0057b	8b 83 24 00 02
	00		 mov	 eax, DWORD PTR [ebx+131108]
  00581	83 f8 01	 cmp	 eax, 1
  00584	7d 1a		 jge	 SHORT $LN3@RecvDataPa

; 863  : 			{
; 864  : 				LogAdd("error-L1 : recvbuflen 1 %s %d", __FILE__, __LINE__);

  00586	68 60 03 00 00	 push	 864			; 00000360H
  0058b	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00590	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd?$AA@
  00595	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0059b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 865  : 				break;

  0059e	eb 27		 jmp	 SHORT $LN2@RecvDataPa
$LN3@RecvDataPa:

; 866  : 			}
; 867  : 
; 868  : 			if ( lpIOContext->nSentBytes < MAX_IO_BUFFER_SIZE ) 

  005a0	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  005a5	7d 20		 jge	 SHORT $LN2@RecvDataPa

; 869  : 			{
; 870  : 				memcpy(recvbuf, &recvbuf[lOfs], lpIOContext->nSentBytes);

  005a7	50		 push	 eax
  005a8	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  005ab	50		 push	 eax
  005ac	57		 push	 edi
  005ad	e8 00 00 00 00	 call	 _memcpy

; 871  : 				LogAdd("Message copy %d", lpIOContext->nSentBytes);

  005b2	8b 8b 24 00 02
	00		 mov	 ecx, DWORD PTR [ebx+131108]
  005b8	51		 push	 ecx
  005b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OIIBACED@Message?5copy?5?$CFd?$AA@
  005be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005c4	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@RecvDataPa:

; 883  : 
; 884  : 	return true;

  005c7	b8 01 00 00 00	 mov	 eax, 1
$LN37@RecvDataPa:

; 885  : }

  005cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005d6	59		 pop	 ecx
  005d7	5f		 pop	 edi
  005d8	5e		 pop	 esi
  005d9	5b		 pop	 ebx
  005da	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005dd	33 cd		 xor	 ecx, ebp
  005df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e4	8b e5		 mov	 esp, ebp
  005e6	5d		 pop	 ebp
  005e7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$0:
  00000	8d 8d e8 77 ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$212339[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$1:
  0000b	8d 8d e8 77 ff
	ff		 lea	 ecx, DWORD PTR _PacketStream$212364[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$2:
  00016	8d 8d e8 77 ff
	ff		 lea	 ecx, DWORD PTR _ps$212373[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__ehhandler$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a cc 77 ff
	ff		 mov	 ecx, DWORD PTR [edx-34868]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z ENDP		; RecvDataParse
PUBLIC	??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@ ; `string'
PUBLIC	??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@ ; `string'
PUBLIC	?DataSend@@YAHHPAEK@Z				; DataSend
EXTRN	__imp__WSASend@28:PROC
EXTRN	?Encrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Encrypt
EXTRN	?g_SimpleModulusSC@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulusSC
EXTRN	?GetSendSerial@NSerialCheck@@QAEEXZ:PROC	; NSerialCheck::GetSendSerial
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
;	COMDAT ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@
CONST	SEGMENT
??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@ DB '('
	DB	'%d)WSASend(%d) failed with error [%x][%x] %d %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
CONST	SEGMENT
??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
CONST	SEGMENT
??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@ DB 'E'
	DB	'rror : Max msg(%d) %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@
CONST	SEGMENT
??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@ DB 'e'
	DB	'rror-L2 : Index(%d) %x %x %x ', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataSend@@YAHHPAEK@Z
_TEXT	SEGMENT
_SendBytes$ = -12					; size = 4
_SendBuf$ = -8						; size = 4
tv417 = -4						; size = 4
_lpPerSocketContext$ = 8				; size = 4
_aIndex$ = 8						; size = 4
_btsize$212404 = 11					; size = 1
_lpMsg$ = 12						; size = 4
_dwSize$ = 16						; size = 4
?DataSend@@YAHHPAEK@Z PROC				; DataSend, COMDAT

; 1072 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1073 : 	DWORD SendBytes;
; 1074 : 	LPPER_SOCKET_CONTEXT lpPerSocketContext;
; 1075 : 	LPBYTE SendBuf;
; 1076 : 	
; 1077 : 
; 1078 : 	if ( aIndex < OBJ_STARTUSERINDZT )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	81 fb b0 36 00
	00		 cmp	 ebx, 14000		; 000036b0H
  00010	7d 0a		 jge	 SHORT $LN20@DataSend

; 1079 : 	{
; 1080 : 		return true;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	5b		 pop	 ebx

; 1249 : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
$LN20@DataSend:

; 1081 : 	}
; 1082 : 
; 1083 : #if(OFFLINE_MODE == TRUE)
; 1084 : 	if( gObj[aIndex].m_OfflineMode )

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	56		 push	 esi
  00022	8b f3		 mov	 esi, ebx
  00024	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002a	80 bc 06 d4 28
	00 00 00	 cmp	 BYTE PTR [esi+eax+10452], 0
  00032	89 75 fc	 mov	 DWORD PTR tv417[ebp], esi

; 1085 : 	{
; 1086 : 		return false;

  00035	75 4c		 jne	 SHORT $LN34@DataSend

; 1087 : 	}
; 1088 : #endif
; 1089 : 
; 1090 : 	EnterCriticalSection(&criti);

  00037	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1091 : 
; 1092 : 	if ( ((aIndex < 0)? FALSE : (aIndex > OBJMAX-1)? FALSE : TRUE )  == FALSE )

  00042	85 db		 test	 ebx, ebx
  00044	78 0f		 js	 SHORT $LN25@DataSend
  00046	33 c0		 xor	 eax, eax
  00048	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0004e	0f 9e c0	 setle	 al
  00051	85 c0		 test	 eax, eax
  00053	75 36		 jne	 SHORT $LN18@DataSend
$LN25@DataSend:

; 1093 : 	{
; 1094 : 		LogAdd("error-L2 : Index(%d) %x %x %x ", dwSize, lpMsg[0], lpMsg[1], lpMsg[2]);

  00055	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00058	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0005c	0f b6 50 01	 movzx	 edx, BYTE PTR [eax+1]
  00060	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00063	51		 push	 ecx
  00064	8b 4d 10	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5?$AA@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00075	83 c4 14	 add	 esp, 20			; 00000014H

; 1095 : 		LeaveCriticalSection(&criti);

  00078	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN34@DataSend:

; 1096 : 		return false;

  00083	5e		 pop	 esi
  00084	33 c0		 xor	 eax, eax
  00086	5b		 pop	 ebx

; 1249 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN18@DataSend:

; 1097 : 	}
; 1098 : 
; 1099 : 	if ( lpMsg[0] == 0xC3 || lpMsg[0] == 0xC4 )

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008e	8a 08		 mov	 cl, BYTE PTR [eax]
  00090	57		 push	 edi
  00091	80 f9 c3	 cmp	 cl, 195			; 000000c3H
  00094	74 0d		 je	 SHORT $LN26@DataSend
  00096	80 f9 c4	 cmp	 cl, 196			; 000000c4H
  00099	74 66		 je	 SHORT $LN15@DataSend

; 1138 : 		}
; 1139 : 	}
; 1140 : 	else
; 1141 : 	{
; 1142 : 		SendBuf = lpMsg;

  0009b	8b 7d 10	 mov	 edi, DWORD PTR _dwSize$[ebp]
  0009e	e9 c2 00 00 00	 jmp	 $LN30@DataSend
$LN26@DataSend:

; 1100 : 	{
; 1101 : 		int ret;
; 1102 : 		BYTE btsize;
; 1103 : 
; 1104 : 		if ( lpMsg[0] == 0xC3 )
; 1105 : 		{
; 1106 : 			btsize = lpMsg[1];

  000a3	0f b6 50 01	 movzx	 edx, BYTE PTR [eax+1]
  000a7	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1107 : #if(ENABLE_INDEV_NETWORK)	
; 1108 : 			//lpMsg[1]=gNSerialCheck[aIndex].GetSendSerial();
; 1109 : 			ret = g_PacketEncrypt.Encrypt(&ExSendBuf[2], &lpMsg[1], dwSize-1);
; 1110 : #else
; 1111 : 			lpMsg[1]=gNSerialCheck[aIndex].GetSendSerial();

  000aa	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ebx*8]
  000b1	88 55 0b	 mov	 BYTE PTR _btsize$212404[ebp], dl
  000b4	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial
  000b9	88 06		 mov	 BYTE PTR [esi], al

; 1112 : 			ret = g_SimpleModulusSC.Encrypt(&ExSendBuf[2], &lpMsg[1], dwSize-1);

  000bb	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000c4	48		 dec	 eax
  000c5	50		 push	 eax
  000c6	83 c1 02	 add	 ecx, 2
  000c9	56		 push	 esi
  000ca	51		 push	 ecx
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusSC@@3VCSimpleModulus@@A ; g_SimpleModulusSC
  000d0	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt

; 1113 : #endif
; 1114 : 			
; 1115 : 			ExSendBuf[0] = 0xC3;

  000d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000db	c6 02 c3	 mov	 BYTE PTR [edx], 195	; 000000c3H

; 1116 : 			ExSendBuf[1] = ret + 2;

  000de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000e4	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  000e7	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 1117 : 			SendBuf = ExSendBuf;
; 1118 : 			dwSize = ret + 2;
; 1119 : 			lpMsg[1] = btsize;

  000ea	0f b6 55 0b	 movzx	 edx, BYTE PTR _btsize$212404[ebp]
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  000f4	88 16		 mov	 BYTE PTR [esi], dl

; 1120 : 		}
; 1121 : 		else

  000f6	8b 75 fc	 mov	 esi, DWORD PTR tv417[ebp]
  000f9	89 4d f8	 mov	 DWORD PTR _SendBuf$[ebp], ecx
  000fc	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
  000ff	eb 67		 jmp	 SHORT $LN14@DataSend
$LN15@DataSend:

; 1122 : 		{
; 1123 : 			btsize = lpMsg[2];

  00101	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  00104	8a 06		 mov	 al, BYTE PTR [esi]

; 1124 : #if(ENABLE_INDEV_NETWORK)
; 1125 : 			//lpMsg[2] = gNSerialCheck[aIndex].GetSendSerial();
; 1126 : 			ret = g_PacketEncrypt.Encrypt(&ExSendBuf[3], &lpMsg[2], dwSize-2);
; 1127 : #else
; 1128 : 			lpMsg[2] = gNSerialCheck[aIndex].GetSendSerial();

  00106	8d 0c dd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ebx*8]
  0010d	88 45 0b	 mov	 BYTE PTR _btsize$212404[ebp], al
  00110	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial

; 1129 : 			ret = g_SimpleModulusSC.Encrypt(&ExSendBuf[3], &lpMsg[2], dwSize-2);

  00115	8b 4d 10	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00118	83 c1 fe	 add	 ecx, -2			; fffffffeH
  0011b	51		 push	 ecx
  0011c	88 06		 mov	 BYTE PTR [esi], al
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00124	56		 push	 esi
  00125	83 c2 03	 add	 edx, 3
  00128	52		 push	 edx
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusSC@@3VCSimpleModulus@@A ; g_SimpleModulusSC
  0012e	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt

; 1130 : #endif
; 1131 : 			
; 1132 : 			ExSendBuf[0] = 0xC4;

  00133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00139	c6 01 c4	 mov	 BYTE PTR [ecx], 196	; 000000c4H

; 1133 : 			ExSendBuf[1] = SET_NUMBERH(ret +3 );

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00142	8d 78 03	 lea	 edi, DWORD PTR [eax+3]
  00145	8b d7		 mov	 edx, edi
  00147	c1 ea 08	 shr	 edx, 8
  0014a	88 51 01	 mov	 BYTE PTR [ecx+1], dl

; 1134 : 			ExSendBuf[2] = SET_NUMBERL(ret+3);

  0014d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf

; 1136 : 			dwSize = ret + 3;
; 1137 : 			lpMsg[2] = btsize;

  00153	8a 4d 0b	 mov	 cl, BYTE PTR _btsize$212404[ebp]
  00156	04 03		 add	 al, 3
  00158	88 42 02	 mov	 BYTE PTR [edx+2], al
  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00160	88 0e		 mov	 BYTE PTR [esi], cl
  00162	8b 75 fc	 mov	 esi, DWORD PTR tv417[ebp]
$LN30@DataSend:

; 1135 : 			SendBuf = ExSendBuf;

  00165	89 45 f8	 mov	 DWORD PTR _SendBuf$[ebp], eax
$LN14@DataSend:

; 1143 : 	}
; 1144 : 
; 1145 : 	if ( gObj[aIndex].Connected < PLAYER_CONNECTED )

  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016d	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1

; 1146 : 	{
; 1147 : 		LeaveCriticalSection(&criti);
; 1148 : 		return FALSE;

  00172	0f 8c 4c 02 00
	00		 jl	 $LN33@DataSend

; 1149 : 	}
; 1150 : 
; 1151 : 	lpPerSocketContext= gObj[aIndex].PerSocketContext;

  00178	8b 74 06 10	 mov	 esi, DWORD PTR [esi+eax+16]
  0017c	89 75 08	 mov	 DWORD PTR _lpPerSocketContext$[ebp], esi

; 1152 : 
; 1153 : 	if ( dwSize > sizeof(lpPerSocketContext->IOContext[0].Buffer))

  0017f	81 ff ff ff 00
	00		 cmp	 edi, 65535		; 0000ffffH
  00185	76 33		 jbe	 SHORT $LN11@DataSend

; 1154 : 	{
; 1155 : 		LogAdd("Error : Max msg(%d) %s %d", dwSize, __FILE__, __LINE__);

  00187	68 83 04 00 00	 push	 1155			; 00000483H
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_09ELJFIOPP@giocp?4cpp?$AA@
  00191	57		 push	 edi
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd?$AA@
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1156 : 		CloseClient(aIndex);

  0019d	53		 push	 ebx
  0019e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  001a3	83 c4 14	 add	 esp, 20			; 00000014H

; 1157 : 		LeaveCriticalSection(&criti);

  001a6	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  001b1	5f		 pop	 edi
  001b2	5e		 pop	 esi

; 1158 : 		return false;

  001b3	33 c0		 xor	 eax, eax
  001b5	5b		 pop	 ebx

; 1249 : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
$LN11@DataSend:

; 1159 : 	}
; 1160 : 
; 1161 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];

  001ba	81 c6 38 00 02
	00		 add	 esi, 131128		; 00020038H

; 1162 : 
; 1163 : 	if ( lpIoCtxt->nWaitIO > 0 )

  001c0	83 be 2c 00 02
	00 00		 cmp	 DWORD PTR [esi+131116], 0
  001c7	7e 6e		 jle	 SHORT $LN10@DataSend

; 1164 : 	{
; 1165 : 		if ( ( lpIoCtxt->nSecondOfs + dwSize ) > MAX_IO_BUFFER_SIZE-1 )

  001c9	8b 8e 1c 00 02
	00		 mov	 ecx, DWORD PTR [esi+131100]
  001cf	8d 14 39	 lea	 edx, DWORD PTR [ecx+edi]
  001d2	81 fa fe ff 00
	00		 cmp	 edx, 65534		; 0000fffeH
  001d8	76 3d		 jbe	 SHORT $LN9@DataSend

; 1166 : 		{
; 1167 : 			LogAdd("(%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]", 
; 1168 : 				aIndex, lpIoCtxt->nTotalBytes, lpIoCtxt->nSecondOfs, 
; 1169 : 				dwSize, gObj[aIndex].AccountID, gObj[aIndex].Name);

  001da	8b 55 fc	 mov	 edx, DWORD PTR tv417[ebp]
  001dd	8d 54 02 77	 lea	 edx, DWORD PTR [edx+eax+119]
  001e1	52		 push	 edx
  001e2	8b 55 fc	 mov	 edx, DWORD PTR tv417[ebp]
  001e5	8d 44 02 6c	 lea	 eax, DWORD PTR [edx+eax+108]
  001e9	50		 push	 eax
  001ea	57		 push	 edi
  001eb	51		 push	 ecx
  001ec	8b 8e 20 00 02
	00		 mov	 ecx, DWORD PTR [esi+131104]
  001f2	51		 push	 ecx
  001f3	53		 push	 ebx
  001f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1170 : 
; 1171 : 			lpIoCtxt->nWaitIO = 0;
; 1172 : 
; 1173 : 			CloseClient(aIndex);

  001ff	53		 push	 ebx
  00200	c7 86 2c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131116], 0
  0020a	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0020f	83 c4 20	 add	 esp, 32			; 00000020H

; 1174 : 
; 1175 : 			LeaveCriticalSection(&criti);
; 1176 : 			return true;

  00212	e9 d4 01 00 00	 jmp	 $LN31@DataSend
$LN9@DataSend:

; 1177 : 		}
; 1178 : 
; 1179 : 		memcpy( &lpIoCtxt->BufferSecond[lpIoCtxt->nSecondOfs], SendBuf, dwSize);

  00217	8b 55 f8	 mov	 edx, DWORD PTR _SendBuf$[ebp]
  0021a	57		 push	 edi
  0021b	52		 push	 edx
  0021c	8d 84 31 1b 00
	01 00		 lea	 eax, DWORD PTR [ecx+esi+65563]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 _memcpy
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1180 : 		lpIoCtxt->nSecondOfs += dwSize;

  0022c	01 be 1c 00 02
	00		 add	 DWORD PTR [esi+131100], edi

; 1181 : 		LeaveCriticalSection(&criti);
; 1182 : 		return true;

  00232	e9 b4 01 00 00	 jmp	 $LN31@DataSend
$LN10@DataSend:

; 1183 : 	}
; 1184 : 
; 1185 : 	lpIoCtxt->nTotalBytes = 0;
; 1186 : 	
; 1187 : 	if ( lpIoCtxt->nSecondOfs > 0 )

  00237	8b 86 1c 00 02
	00		 mov	 eax, DWORD PTR [esi+131100]
  0023d	c7 86 20 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131104], 0
  00247	85 c0		 test	 eax, eax
  00249	7e 2a		 jle	 SHORT $LN8@DataSend

; 1188 : 	{
; 1189 : 		memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  0024b	50		 push	 eax
  0024c	8d 8e 1b 00 01
	00		 lea	 ecx, DWORD PTR [esi+65563]
  00252	51		 push	 ecx
  00253	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00256	52		 push	 edx
  00257	e8 00 00 00 00	 call	 _memcpy

; 1190 : 		lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  0025c	8b 86 1c 00 02
	00		 mov	 eax, DWORD PTR [esi+131100]
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH
  00265	89 86 20 00 02
	00		 mov	 DWORD PTR [esi+131104], eax

; 1191 : 		lpIoCtxt->nSecondOfs = 0;

  0026b	c7 86 1c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131100], 0
$LN8@DataSend:

; 1192 : 	}
; 1193 : 
; 1194 : 	if ( (lpIoCtxt->nTotalBytes+dwSize) > MAX_IO_BUFFER_SIZE-1 )

  00275	8b 86 20 00 02
	00		 mov	 eax, DWORD PTR [esi+131104]
  0027b	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  0027e	81 f9 fe ff 00
	00		 cmp	 ecx, 65534		; 0000fffeH
  00284	76 4b		 jbe	 SHORT $LN7@DataSend

; 1195 : 	{
; 1196 : 		LogAdd("(%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]", 
; 1197 : 			aIndex, lpIoCtxt->nTotalBytes, dwSize, 
; 1198 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  00286	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028c	8b 55 fc	 mov	 edx, DWORD PTR tv417[ebp]
  0028f	8d 54 0a 77	 lea	 edx, DWORD PTR [edx+ecx+119]
  00293	52		 push	 edx
  00294	8b 55 fc	 mov	 edx, DWORD PTR tv417[ebp]
  00297	8d 4c 0a 6c	 lea	 ecx, DWORD PTR [edx+ecx+108]
  0029b	51		 push	 ecx
  0029c	57		 push	 edi
  0029d	50		 push	 eax
  0029e	53		 push	 ebx
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd?5@
  002a4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1199 : 
; 1200 : 		lpIoCtxt->nWaitIO = 0;
; 1201 : 		
; 1202 : 		CloseClient(aIndex);

  002aa	53		 push	 ebx
  002ab	c7 86 2c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131116], 0
  002b5	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002ba	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1203 : 		
; 1204 : 		LeaveCriticalSection(&criti);

  002bd	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  002c8	5f		 pop	 edi
  002c9	5e		 pop	 esi

; 1205 : 		return FALSE;

  002ca	33 c0		 xor	 eax, eax
  002cc	5b		 pop	 ebx

; 1249 : }

  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c3		 ret	 0
$LN7@DataSend:

; 1206 : 	}
; 1207 : 
; 1208 : 	memcpy( &lpIoCtxt->Buffer[lpIoCtxt->nTotalBytes], SendBuf, dwSize);

  002d1	8b 55 f8	 mov	 edx, DWORD PTR _SendBuf$[ebp]
  002d4	57		 push	 edi
  002d5	52		 push	 edx
  002d6	8d 44 30 1c	 lea	 eax, DWORD PTR [eax+esi+28]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 _memcpy

; 1209 : 	lpIoCtxt->nTotalBytes += dwSize;

  002e0	01 be 20 00 02
	00		 add	 DWORD PTR [esi+131104], edi
  002e6	8b 8e 20 00 02
	00		 mov	 ecx, DWORD PTR [esi+131104]

; 1210 : 	lpIoCtxt->wsabuf.buf = (char*)&lpIoCtxt->Buffer;
; 1211 : 	lpIoCtxt->wsabuf.len = lpIoCtxt->nTotalBytes;
; 1212 : 	lpIoCtxt->nSentBytes = 0;
; 1213 : 	lpIoCtxt->IOOperation = SEND_IO;
; 1214 : 
; 1215 : 	if ( WSASend( gObj[aIndex].m_socket, &lpIoCtxt->wsabuf , 1, &SendBytes, 0, &lpIoCtxt->Overlapped, NULL) == -1 )

  002ec	8b 7d fc	 mov	 edi, DWORD PTR tv417[ebp]
  002ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f2	6a 00		 push	 0
  002f4	56		 push	 esi
  002f5	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  002f8	89 08		 mov	 DWORD PTR [eax], ecx
  002fa	6a 00		 push	 0
  002fc	8d 4d f4	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  002ff	51		 push	 ecx
  00300	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00303	89 56 18	 mov	 DWORD PTR [esi+24], edx
  00306	c7 86 24 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131108], 0
  00310	c7 86 28 00 02
	00 01 00 00 00	 mov	 DWORD PTR [esi+131112], 1
  0031a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00320	6a 01		 push	 1
  00322	50		 push	 eax
  00323	8b 44 17 14	 mov	 eax, DWORD PTR [edi+edx+20]
  00327	50		 push	 eax
  00328	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  0032e	83 f8 ff	 cmp	 eax, -1
  00331	0f 85 a1 00 00
	00		 jne	 $LN6@DataSend

; 1216 : 	{
; 1217 : 
; 1218 : 		if ( WSAGetLastError() != WSA_IO_PENDING )	

  00337	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0033d	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00342	0f 84 99 00 00
	00		 je	 $LN27@DataSend

; 1219 : 		{
; 1220 : 			lpIoCtxt->nWaitIO = 0;
; 1221 : 			
; 1222 : 
; 1223 : 			if ( lpIoCtxt->wsabuf.buf[0] == 0xC1 )

  00348	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0034b	c7 86 2c 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131116], 0
  00355	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  00358	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  0035d	75 25		 jne	 SHORT $LN4@DataSend

; 1224 : 			{
; 1225 : 				LogAdd("(%d)WSASend(%d) failed with error [%x][%x] %d %s ", 
; 1226 : 					__LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0],
; 1227 : 					(BYTE)lpIoCtxt->wsabuf.buf[2], WSAGetLastError(), gObj[aIndex].Ip_addr);

  0035f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00365	8d 44 17 18	 lea	 eax, DWORD PTR [edi+edx+24]
  00369	50		 push	 eax
  0036a	8b f1		 mov	 esi, ecx
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00372	0f b6 4e 02	 movzx	 ecx, BYTE PTR [esi+2]
  00376	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00379	50		 push	 eax
  0037a	51		 push	 ecx
  0037b	52		 push	 edx
  0037c	53		 push	 ebx
  0037d	68 ca 04 00 00	 push	 1226			; 000004caH
  00382	eb 29		 jmp	 SHORT $LN32@DataSend
$LN4@DataSend:

; 1228 : 			}
; 1229 : 			else if ( lpIoCtxt->wsabuf.buf[0] == 0xC2 )

  00384	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  00389	75 30		 jne	 SHORT $LN2@DataSend

; 1230 : 			{
; 1231 : 				LogAdd("(%d)WSASend(%d) failed with error [%x][%x] %d %s ", 
; 1232 : 					__LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0],
; 1233 : 					(BYTE)lpIoCtxt->wsabuf.buf[3], WSAGetLastError(), gObj[aIndex].Ip_addr);

  0038b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00390	8b f1		 mov	 esi, ecx
  00392	8d 4c 07 18	 lea	 ecx, DWORD PTR [edi+eax+24]
  00396	51		 push	 ecx
  00397	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0039d	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  003a1	50		 push	 eax
  003a2	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  003a5	52		 push	 edx
  003a6	50		 push	 eax
  003a7	53		 push	 ebx
  003a8	68 d0 04 00 00	 push	 1232			; 000004d0H
$LN32@DataSend:
  003ad	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5erro@
  003b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003b8	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@DataSend:

; 1234 : 			}
; 1235 : 			CloseClient(aIndex);

  003bb	53		 push	 ebx
  003bc	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  003c1	83 c4 04	 add	 esp, 4
$LN33@DataSend:

; 1236 : 			LeaveCriticalSection(&criti);

  003c4	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  003cf	5f		 pop	 edi
  003d0	5e		 pop	 esi

; 1237 : 			return false;

  003d1	33 c0		 xor	 eax, eax
  003d3	5b		 pop	 ebx

; 1249 : }

  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c3		 ret	 0
$LN6@DataSend:

; 1238 : 		}
; 1239 : 	}
; 1240 : 	else
; 1241 : 	{
; 1242 : 		lpPerSocketContext->dwIOCount ++;

  003d8	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  003db	ff 80 68 00 04
	00		 inc	 DWORD PTR [eax+262248]
$LN27@DataSend:

; 1243 : 	}
; 1244 : 	
; 1245 : 	
; 1246 : 	lpIoCtxt->nWaitIO = 1;

  003e1	c7 86 2c 00 02
	00 01 00 00 00	 mov	 DWORD PTR [esi+131116], 1
$LN31@DataSend:

; 1247 : 	LeaveCriticalSection(&criti);

  003eb	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  003f6	5f		 pop	 edi
  003f7	5e		 pop	 esi

; 1248 : 	return true;

  003f8	b8 01 00 00 00	 mov	 eax, 1
  003fd	5b		 pop	 ebx

; 1249 : }

  003fe	8b e5		 mov	 esp, ebp
  00400	5d		 pop	 ebp
  00401	c3		 ret	 0
?DataSend@@YAHHPAEK@Z ENDP				; DataSend
_TEXT	ENDS
PUBLIC	??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoSendSecond
;	COMDAT ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@ DB 'W'
	DB	'SASend(%d) failed with error %d %s ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_SendBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC	; IoSendSecond, COMDAT

; 1255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1256 : 	DWORD SendBytes;
; 1257 : 	int aIndex;
; 1258 : 	EnterCriticalSection(&criti);

  00006	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1259 : 	aIndex = lpPerSocketContext->nIndex;

  00011	8b 75 08	 mov	 esi, DWORD PTR _lpPerSocketContext$[ebp]
  00014	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 1260 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];

  00017	81 c6 38 00 02
	00		 add	 esi, 131128		; 00020038H

; 1261 : 
; 1262 : 	if ( lpIoCtxt->nWaitIO > 0 )

  0001d	83 be 2c 00 02
	00 00		 cmp	 DWORD PTR [esi+131116], 0
  00024	7e 13		 jle	 SHORT $LN6@IoSendSeco
$LN5@IoSendSeco:

; 1263 : 	{
; 1264 : 		LeaveCriticalSection(&criti);

  00026	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00031	5e		 pop	 esi

; 1265 : 		return false;

  00032	33 c0		 xor	 eax, eax
  00034	5b		 pop	 ebx

; 1305 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN6@IoSendSeco:

; 1266 : 	}
; 1267 : 
; 1268 : 	lpIoCtxt->nTotalBytes = 0;
; 1269 : 	if ( lpIoCtxt->nSecondOfs > 0 )

  00039	8b 86 1c 00 02
	00		 mov	 eax, DWORD PTR [esi+131100]
  0003f	c7 86 20 00 02
	00 00 00 00 00	 mov	 DWORD PTR [esi+131104], 0
  00049	85 c0		 test	 eax, eax
  0004b	7e d9		 jle	 SHORT $LN5@IoSendSeco

; 1270 : 	{
; 1271 : 		memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  0004d	57		 push	 edi
  0004e	50		 push	 eax
  0004f	8d 86 1b 00 01
	00		 lea	 eax, DWORD PTR [esi+65563]
  00055	50		 push	 eax
  00056	8d 7e 1c	 lea	 edi, DWORD PTR [esi+28]
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 _memcpy

; 1272 : 		lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  0005f	8b 8e 1c 00 02
	00		 mov	 ecx, DWORD PTR [esi+131100]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 8e 20 00 02
	00		 mov	 DWORD PTR [esi+131104], ecx

; 1273 : 		lpIoCtxt->nSecondOfs = 0;
; 1274 : 	}
; 1275 : 	else
; 1276 : 	{
; 1277 : 		LeaveCriticalSection(&criti);
; 1278 : 		return false;
; 1279 : 	}
; 1280 : 
; 1281 : 	lpIoCtxt->wsabuf.buf = (char*)&lpIoCtxt->Buffer;
; 1282 : 	lpIoCtxt->wsabuf.len = lpIoCtxt->nTotalBytes;

  0006e	8b 96 20 00 02
	00		 mov	 edx, DWORD PTR [esi+131104]
  00074	33 c9		 xor	 ecx, ecx

; 1283 : 	lpIoCtxt->nSentBytes = 0;
; 1284 : 	lpIoCtxt->IOOperation = SEND_IO;
; 1285 : 
; 1286 : 	if ( WSASend(gObj[aIndex].m_socket, &lpIoCtxt->wsabuf, 1, &SendBytes, 0, &lpIoCtxt->Overlapped, NULL) == -1 )

  00076	51		 push	 ecx
  00077	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0007a	56		 push	 esi
  0007b	8b fb		 mov	 edi, ebx
  0007d	51		 push	 ecx
  0007e	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00084	89 8e 1c 00 02
	00		 mov	 DWORD PTR [esi+131100], ecx
  0008a	89 8e 24 00 02
	00		 mov	 DWORD PTR [esi+131108], ecx
  00090	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  00093	51		 push	 ecx
  00094	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00097	89 10		 mov	 DWORD PTR [eax], edx
  00099	c7 86 28 00 02
	00 01 00 00 00	 mov	 DWORD PTR [esi+131112], 1
  000a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a9	6a 01		 push	 1
  000ab	50		 push	 eax
  000ac	8b 44 17 14	 mov	 eax, DWORD PTR [edi+edx+20]
  000b0	50		 push	 eax
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000b7	83 f8 ff	 cmp	 eax, -1
  000ba	75 4c		 jne	 SHORT $LN3@IoSendSeco

; 1287 : 	{
; 1288 : 		if ( WSAGetLastError() != WSA_IO_PENDING )

  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000c2	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000c7	74 48		 je	 SHORT $LN9@IoSendSeco

; 1289 : 		{
; 1290 : 			LogAdd("WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	8d 54 0f 18	 lea	 edx, DWORD PTR [edi+ecx+24]
  000d3	52		 push	 edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000da	50		 push	 eax
  000db	68 0a 05 00 00	 push	 1290			; 0000050aH
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1291 : 			CloseClient(aIndex);

  000eb	53		 push	 ebx
  000ec	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000f1	83 c4 14	 add	 esp, 20			; 00000014H

; 1292 : 			LeaveCriticalSection(&criti);

  000f4	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi

; 1293 : 			return false;

  00101	33 c0		 xor	 eax, eax
  00103	5b		 pop	 ebx

; 1305 : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN3@IoSendSeco:

; 1294 : 		}
; 1295 : 	}
; 1296 : 	else
; 1297 : 	{
; 1298 : 		lpPerSocketContext->dwIOCount ++;

  00108	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0010b	ff 80 68 00 04
	00		 inc	 DWORD PTR [eax+262248]
$LN9@IoSendSeco:

; 1299 : 	}
; 1300 : 	
; 1301 : 	lpIoCtxt->nWaitIO = 1;
; 1302 : 	LeaveCriticalSection(&criti);

  00111	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00116	c7 86 2c 00 02
	00 01 00 00 00	 mov	 DWORD PTR [esi+131116], 1
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi

; 1303 : 	
; 1304 : 	return true;

  00128	b8 01 00 00 00	 mov	 eax, 1
  0012d	5b		 pop	 ebx

; 1305 : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP	; IoSendSecond
_TEXT	ENDS
PUBLIC	?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoMoreSend
; Function compile flags: /Ogtp
;	COMDAT ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_SendBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC		; IoMoreSend, COMDAT

; 1309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1310 : 	DWORD SendBytes;
; 1311 : 	int aIndex;
; 1312 : 	
; 1313 : 	EnterCriticalSection(&criti);

  00006	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1314 : 	aIndex = lpPerSocketContext->nIndex;

  00011	8b 75 08	 mov	 esi, DWORD PTR _lpPerSocketContext$[ebp]
  00014	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]

; 1315 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];
; 1316 : 
; 1317 : 	if ( (lpIoCtxt->nTotalBytes - lpIoCtxt->nSentBytes) < 0 )

  00017	8b 86 5c 00 04
	00		 mov	 eax, DWORD PTR [esi+262236]
  0001d	8b 8e 58 00 04
	00		 mov	 ecx, DWORD PTR [esi+262232]
  00023	81 c6 38 00 02
	00		 add	 esi, 131128		; 00020038H
  00029	2b c8		 sub	 ecx, eax
  0002b	79 13		 jns	 SHORT $LN4@IoMoreSend

; 1318 : 	{
; 1319 : 		LeaveCriticalSection(&criti);

  0002d	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00038	5e		 pop	 esi

; 1320 : 		return false;

  00039	33 c0		 xor	 eax, eax
  0003b	5b		 pop	 ebx

; 1346 : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN4@IoMoreSend:
  00040	57		 push	 edi

; 1321 : 	}
; 1322 : 
; 1323 : 	lpIoCtxt->wsabuf.buf = (char*)&lpIoCtxt->Buffer[lpIoCtxt->nSentBytes];
; 1324 : 	lpIoCtxt->wsabuf.len = lpIoCtxt->nTotalBytes - lpIoCtxt->nSentBytes;
; 1325 : 	lpIoCtxt->IOOperation = SEND_IO;
; 1326 : 
; 1327 : 	if ( WSASend(gObj[aIndex].m_socket, &lpIoCtxt->wsabuf, 1, &SendBytes, 0, &lpIoCtxt->Overlapped, NULL) == -1 )

  00041	6a 00		 push	 0
  00043	8d 44 30 1c	 lea	 eax, DWORD PTR [eax+esi+28]
  00047	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0004a	56		 push	 esi
  0004b	8b fb		 mov	 edi, ebx
  0004d	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00050	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00056	89 08		 mov	 DWORD PTR [eax], ecx
  00058	6a 00		 push	 0
  0005a	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  0005d	51		 push	 ecx
  0005e	c7 86 28 00 02
	00 01 00 00 00	 mov	 DWORD PTR [esi+131112], 1
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	6a 01		 push	 1
  00070	50		 push	 eax
  00071	8b 44 17 14	 mov	 eax, DWORD PTR [edi+edx+20]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  0007c	83 f8 ff	 cmp	 eax, -1
  0007f	75 4c		 jne	 SHORT $LN3@IoMoreSend

; 1328 : 	{
; 1329 : 		if ( WSAGetLastError() != WSA_IO_PENDING )

  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00087	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0008c	74 48		 je	 SHORT $LN7@IoMoreSend

; 1330 : 		{
; 1331 : 			LogAdd("WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  0008e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00094	8d 54 0f 18	 lea	 edx, DWORD PTR [edi+ecx+24]
  00098	52		 push	 edx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0009f	50		 push	 eax
  000a0	68 33 05 00 00	 push	 1331			; 00000533H
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CFd@
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1332 : 			CloseClient(aIndex);

  000b0	53		 push	 ebx
  000b1	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000b6	83 c4 14	 add	 esp, 20			; 00000014H

; 1333 : 			LeaveCriticalSection(&criti);

  000b9	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi

; 1334 : 			return false;

  000c6	33 c0		 xor	 eax, eax
  000c8	5b		 pop	 ebx

; 1346 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN3@IoMoreSend:

; 1335 : 		}
; 1336 : 	}
; 1337 : 	else
; 1338 : 	{
; 1339 : 		lpPerSocketContext->dwIOCount ++;

  000cd	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  000d0	ff 80 68 00 04
	00		 inc	 DWORD PTR [eax+262248]
$LN7@IoMoreSend:

; 1340 : 	}
; 1341 : 	
; 1342 : 	
; 1343 : 	lpIoCtxt->nWaitIO = 1;
; 1344 : 	LeaveCriticalSection(&criti);

  000d6	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000db	c7 86 2c 00 02
	00 01 00 00 00	 mov	 DWORD PTR [esi+131116], 1
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi

; 1345 : 	return true;

  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	5b		 pop	 ebx

; 1346 : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP		; IoMoreSend
_TEXT	ENDS
PUBLIC	??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@ ; `string'
PUBLIC	??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@ ; `string'
PUBLIC	??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@ ; `string'
PUBLIC	?ServerWorkerThread@@YGKPAX@Z			; ServerWorkerThread
EXTRN	__imp__WSARecv@28:PROC
EXTRN	__imp__GetQueuedCompletionStatus@20:PROC
;	COMDAT ??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@
CONST	SEGMENT
??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@ DB 'Error Thread'
	DB	' : GetQueueCompletionStatus( %d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@ DB 'W'
	DB	'SARecv() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@
CONST	SEGMENT
??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@ DB 'error-'
	DB	'L1 : Socket Header error %d, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@ DB 'Conne'
	DB	'ction Closed, dwIoSize == 0 (Index:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ServerWorkerThread@@YGKPAX@Z
_TEXT	SEGMENT
_RecvBytes$ = -24					; size = 4
_Flags$ = -20						; size = 4
tv306 = -16						; size = 4
_dwIoSize$ = -12					; size = 4
_ClientIndex$ = -8					; size = 4
_lpOverlapped$ = -4					; size = 4
_CompletionPortID$ = 8					; size = 4
?ServerWorkerThread@@YGKPAX@Z PROC			; ServerWorkerThread, COMDAT

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 408  : 	HANDLE	CompletionPort = (HANDLE) CompletionPortID;
; 409  : 	DWORD	dwIoSize;
; 410  : 	DWORD	RecvBytes;
; 411  : 	DWORD	Flags;
; 412  : 	DWORD	dwSendNumBytes = 0;
; 413  : 	BOOL	bSuccess = FALSE; 
; 414  : 	int		nRet;
; 415  : 	int     ClientIndex;
; 416  : 
; 417  : 	LPPER_SOCKET_CONTEXT	lpPerSocketContext = NULL;
; 418  : 	LPOVERLAPPED			lpOverlapped = NULL; 

  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpOverlapped$[ebp], 0
  0000f	57		 push	 edi
$LL15@ServerWork:

; 419  : 	LPPER_IO_CONTEXT		lpIOContext = NULL;
; 420  : 	
; 421  : 	while(TRUE)
; 422  : 	{
; 423  : 		bSuccess = GetQueuedCompletionStatus(
; 424  : 			CompletionPort,
; 425  : 			&dwIoSize,
; 426  : 			(LPDWORD)&ClientIndex,
; 427  : 			&lpOverlapped,
; 428  : 			INFINITE
; 429  : 		);

  00010	6a ff		 push	 -1
  00012	8d 45 fc	 lea	 eax, DWORD PTR _lpOverlapped$[ebp]
  00015	50		 push	 eax
  00016	8b 45 08	 mov	 eax, DWORD PTR _CompletionPortID$[ebp]
  00019	8d 4d f8	 lea	 ecx, DWORD PTR _ClientIndex$[ebp]
  0001c	51		 push	 ecx
  0001d	8d 55 f4	 lea	 edx, DWORD PTR _dwIoSize$[ebp]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueuedCompletionStatus@20

; 430  : 
; 431  : 		if( !bSuccess )

  00028	85 c0		 test	 eax, eax
  0002a	75 29		 jne	 SHORT $LN26@ServerWork

; 432  : 		{
; 433  : 			if( lpOverlapped != NULL )

  0002c	39 45 fc	 cmp	 DWORD PTR _lpOverlapped$[ebp], eax
  0002f	74 24		 je	 SHORT $LN26@ServerWork

; 434  : 			{
; 435  : 				int aError = GetLastError();

  00031	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  00037	ff d6		 call	 esi

; 436  : 				if ( (aError != ERROR_SEM_TIMEOUT)		  && (aError != ERROR_NETNAME_DELETED) && 
; 437  : 					 (aError != ERROR_CONNECTION_ABORTED) && (aError != ERROR_OPERATION_ABORTED) )

  00039	83 f8 79	 cmp	 eax, 121		; 00000079H
  0003c	74 17		 je	 SHORT $LN26@ServerWork
  0003e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00041	74 12		 je	 SHORT $LN26@ServerWork
  00043	3d d4 04 00 00	 cmp	 eax, 1236		; 000004d4H
  00048	74 0b		 je	 SHORT $LN26@ServerWork
  0004a	3d e3 03 00 00	 cmp	 eax, 995		; 000003e3H
  0004f	0f 85 c9 01 00
	00		 jne	 $LN24@ServerWork
$LN26@ServerWork:

; 443  : 				}
; 444  : 			}
; 445  : 		}
; 446  : 
; 447  : 		EnterCriticalSection(&criti);

  00055	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 448  : 		lpPerSocketContext = gObj[ClientIndex].PerSocketContext;

  00060	8b 4d f8	 mov	 ecx, DWORD PTR _ClientIndex$[ebp]
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0006f	8b 7c 11 10	 mov	 edi, DWORD PTR [ecx+edx+16]

; 449  : 		
; 450  : 		lpPerSocketContext->dwIOCount--;

  00073	ff 8f 68 00 04
	00		 dec	 DWORD PTR [edi+262248]

; 451  : 		if( dwIoSize == 0 )

  00079	8b 4d f4	 mov	 ecx, DWORD PTR _dwIoSize$[ebp]
  0007c	33 db		 xor	 ebx, ebx
  0007e	3b cb		 cmp	 ecx, ebx
  00080	75 29		 jne	 SHORT $LN10@ServerWork

; 452  : 		{
; 453  : 			LogAdd("Connection Closed, dwIoSize == 0 (Index:%d)", lpPerSocketContext->nIndex);

  00082	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00085	50		 push	 eax
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?50@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 454  : 			CloseClient(lpPerSocketContext, 0);

  00091	53		 push	 ebx
  00092	57		 push	 edi
  00093	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 455  : 			LeaveCriticalSection(&criti);

  0009b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 456  : 			continue;

  000a6	e9 65 ff ff ff	 jmp	 $LL15@ServerWork
$LN10@ServerWork:

; 457  : 		}
; 458  : 
; 459  : 		lpIOContext = (LPPER_IO_CONTEXT)lpOverlapped;

  000ab	8b 75 fc	 mov	 esi, DWORD PTR _lpOverlapped$[ebp]

; 460  : 
; 461  : 		if( lpIOContext == NULL ) continue;

  000ae	3b f3		 cmp	 esi, ebx
  000b0	0f 84 5a ff ff
	ff		 je	 $LL15@ServerWork

; 462  : 
; 463  : 		if( lpIOContext->IOOperation == SEND_IO )

  000b6	8d 86 28 00 02
	00		 lea	 eax, DWORD PTR [esi+131112]
  000bc	89 45 f0	 mov	 DWORD PTR tv306[ebp], eax
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	83 f8 01	 cmp	 eax, 1
  000c4	75 58		 jne	 SHORT $LN8@ServerWork

; 464  : 		{
; 465  : 			#if(!FIX_SOCKET_MAXBUFFER)
; 466  : 			lpIOContext->nSentBytes += dwIoSize;

  000c6	01 8e 24 00 02
	00		 add	 DWORD PTR [esi+131108], ecx

; 467  : 
; 468  : 			if( lpIOContext->nSentBytes >= lpIOContext->nTotalBytes )

  000cc	8b 8e 24 00 02
	00		 mov	 ecx, DWORD PTR [esi+131108]
  000d2	3b 8e 20 00 02
	00		 cmp	 ecx, DWORD PTR [esi+131104]
  000d8	7c 2b		 jl	 SHORT $LN7@ServerWork

; 469  : 			{
; 470  : 				lpIOContext->nWaitIO = 0;

  000da	89 9e 2c 00 02
	00		 mov	 DWORD PTR [esi+131116], ebx

; 471  : 				if( lpIOContext->nSecondOfs > 0 )

  000e0	39 9e 1c 00 02
	00		 cmp	 DWORD PTR [esi+131100], ebx
  000e6	0f 8e 22 01 00
	00		 jle	 $LN3@ServerWork

; 472  : 				{
; 473  : 					IoSendSecond(lpPerSocketContext);

  000ec	57		 push	 edi
  000ed	e8 00 00 00 00	 call	 ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoSendSecond
  000f2	83 c4 04	 add	 esp, 4

; 521  : 			//#endif
; 522  : 		}
; 523  : 		LeaveCriticalSection(&criti);

  000f5	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 524  : 	}

  00100	e9 0b ff ff ff	 jmp	 $LL15@ServerWork
$LN7@ServerWork:

; 474  : 				}
; 475  : 			}
; 476  : 			else
; 477  : 			{
; 478  : 				IoMoreSend(lpPerSocketContext);

  00105	57		 push	 edi
  00106	e8 00 00 00 00	 call	 ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoMoreSend
  0010b	83 c4 04	 add	 esp, 4

; 521  : 			//#endif
; 522  : 		}
; 523  : 		LeaveCriticalSection(&criti);

  0010e	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 524  : 	}

  00119	e9 f2 fe ff ff	 jmp	 $LL15@ServerWork
$LN8@ServerWork:

; 479  : 			}
; 480  : 			#endif
; 481  : 		}
; 482  : 		else if( lpIOContext->IOOperation == RECV_IO )

  0011e	3b c3		 cmp	 eax, ebx
  00120	0f 85 e8 00 00
	00		 jne	 $LN3@ServerWork

; 483  : 		{
; 484  : 			RecvBytes = 0;

  00126	89 5d e8	 mov	 DWORD PTR _RecvBytes$[ebp], ebx

; 485  : 
; 486  : 			lpIOContext->nSentBytes += dwIoSize;

  00129	01 8e 24 00 02
	00		 add	 DWORD PTR [esi+131108], ecx

; 487  : 			
; 488  : 			if( RecvDataParse(lpIOContext, lpPerSocketContext->nIndex) == FALSE )

  0012f	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00132	52		 push	 edx
  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 ?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z ; RecvDataParse
  00139	83 c4 08	 add	 esp, 8
  0013c	85 c0		 test	 eax, eax
  0013e	75 31		 jne	 SHORT $LN2@ServerWork

; 489  : 			{
; 490  : 				LogAdd("error-L1 : Socket Header error %d, %d", WSAGetLastError(), lpPerSocketContext->nIndex);

  00140	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0014a	50		 push	 eax
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5?$CF@
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 491  : 				CloseClient(lpPerSocketContext, 0);

  00156	6a 00		 push	 0
  00158	57		 push	 edi
  00159	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0015e	83 c4 14	 add	 esp, 20			; 00000014H

; 492  : 				LeaveCriticalSection(&criti);

  00161	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 493  : 				continue;

  0016c	e9 9f fe ff ff	 jmp	 $LL15@ServerWork
$LN2@ServerWork:

; 494  : 			}
; 495  : 			
; 496  : 			//#if(!FIX_SOCKET_MAXBUFFER)
; 497  : 			lpIOContext->nWaitIO = 0;
; 498  : 			//#endif
; 499  : 			Flags = 0;
; 500  : 			ZeroMemory(&(lpIOContext->Overlapped), sizeof(OVERLAPPED));

  00171	33 c0		 xor	 eax, eax
  00173	33 d2		 xor	 edx, edx
  00175	89 96 2c 00 02
	00		 mov	 DWORD PTR [esi+131116], edx
  0017b	89 55 ec	 mov	 DWORD PTR _Flags$[ebp], edx
  0017e	89 06		 mov	 DWORD PTR [esi], eax
  00180	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00183	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00186	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00189	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 501  : 				
; 502  : 			lpIOContext->wsabuf.len		= MAX_IO_BUFFER_SIZE-lpIOContext->nSentBytes;

  0018c	8b 86 24 00 02
	00		 mov	 eax, DWORD PTR [esi+131108]
  00192	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH
  00197	2b d8		 sub	 ebx, eax

; 503  : 			lpIOContext->wsabuf.buf		= lpIOContext->Buffer+lpIOContext->nSentBytes;

  00199	8d 44 30 1c	 lea	 eax, DWORD PTR [eax+esi+28]

; 504  : 			lpIOContext->IOOperation	= RECV_IO;
; 505  : 				
; 506  : 			nRet = WSARecv(lpPerSocketContext->m_socket, &(lpIOContext->wsabuf), 1, &RecvBytes, &Flags,
; 507  : 				&(lpIOContext->Overlapped), NULL);

  0019d	52		 push	 edx
  0019e	89 46 18	 mov	 DWORD PTR [esi+24], eax
  001a1	8b 45 f0	 mov	 eax, DWORD PTR tv306[ebp]
  001a4	56		 push	 esi
  001a5	89 10		 mov	 DWORD PTR [eax], edx
  001a7	8d 55 ec	 lea	 edx, DWORD PTR _Flags$[ebp]
  001aa	52		 push	 edx
  001ab	8d 45 e8	 lea	 eax, DWORD PTR _RecvBytes$[ebp]
  001ae	50		 push	 eax
  001af	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  001b2	6a 01		 push	 1
  001b4	51		 push	 ecx
  001b5	89 19		 mov	 DWORD PTR [ecx], ebx
  001b7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001b9	51		 push	 ecx
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28

; 508  : 			
; 509  : 			if( nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING) )

  001c0	83 f8 ff	 cmp	 eax, -1
  001c3	75 38		 jne	 SHORT $LN25@ServerWork
  001c5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WSAGetLastError@0
  001cb	ff d3		 call	 ebx
  001cd	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  001d2	74 29		 je	 SHORT $LN25@ServerWork

; 510  : 			{
; 511  : 				LogAdd("WSARecv() failed with error %d", WSAGetLastError());

  001d4	ff d3		 call	 ebx
  001d6	50		 push	 eax
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd?$AA@
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 512  : 				//lpIOContext->nWaitIO = 2;
; 513  : 				CloseClient( lpPerSocketContext, FALSE);

  001e2	6a 00		 push	 0
  001e4	57		 push	 edi
  001e5	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  001ea	83 c4 10	 add	 esp, 16			; 00000010H

; 514  : 				LeaveCriticalSection(&criti);

  001ed	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 515  : 				continue;

  001f8	e9 13 fe ff ff	 jmp	 $LL15@ServerWork
$LN25@ServerWork:

; 516  : 			}
; 517  : 				
; 518  : 			lpPerSocketContext->dwIOCount++;

  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	01 87 68 00 04
	00		 add	 DWORD PTR [edi+262248], eax

; 519  : 			//#if(!FIX_SOCKET_MAXBUFFER)
; 520  : 			lpIOContext->nWaitIO = 1;

  00208	89 86 2c 00 02
	00		 mov	 DWORD PTR [esi+131116], eax
$LN3@ServerWork:

; 521  : 			//#endif
; 522  : 		}
; 523  : 		LeaveCriticalSection(&criti);

  0020e	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 524  : 	}

  00219	e9 f2 fd ff ff	 jmp	 $LL15@ServerWork
$LN24@ServerWork:

; 438  : 				{
; 439  : 					EnterCriticalSection(&criti);

  0021e	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 440  : 					LogAdd("Error Thread : GetQueueCompletionStatus( %d )", GetLastError());

  00229	ff d6		 call	 esi
  0022b	50		 push	 eax
  0022c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompletio@
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00237	83 c4 08	 add	 esp, 8

; 441  : 					LeaveCriticalSection(&criti);

  0023a	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00245	5f		 pop	 edi
  00246	5e		 pop	 esi

; 442  : 					return 0;

  00247	33 c0		 xor	 eax, eax
  00249	5b		 pop	 ebx

; 525  : 	return TRUE;
; 526  : }

  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c2 04 00	 ret	 4
?ServerWorkerThread@@YGKPAX@Z ENDP			; ServerWorkerThread
_TEXT	ENDS
PUBLIC	??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@ ; `string'
PUBLIC	??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@ ; `string'
PUBLIC	??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@ ; `string'
PUBLIC	??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@ ; `string'
PUBLIC	??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?IocpServerWorker@@YGKPAX@Z			; IocpServerWorker
EXTRN	__imp__PostQueuedCompletionStatus@16:PROC
EXTRN	?SCPJoinResultSend@@YAXHE@Z:PROC		; SCPJoinResultSend
EXTRN	?gObjAdd@@YAFIPADH@Z:PROC			; gObjAdd
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?gObjAddSearch@@YAFIPAD@Z:PROC			; gObjAddSearch
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__WSAAccept@20:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__except_handler4:PROC
;	COMDAT ??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@
CONST	SEGMENT
??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@ DB 'erro'
	DB	'r-L1 : WSARecv() failed with error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@
CONST	SEGMENT
??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@ DB 'e'
	DB	'rror-L1 : %d %d gObjAdd() failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@
CONST	SEGMENT
??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@ DB 'erro'
	DB	'r-L1 : %d %d CreateIoCompletionPort failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@
CONST	SEGMENT
??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@ DB 'error-L2'
	DB	' : ClientIndex = -1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSA'
	DB	'Accept() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
CONST	SEGMENT
??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@ DB 'CreateT'
	DB	'hread() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@
CONST	SEGMENT
??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@ DB 'CreateIoComple'
	DB	'tionPort failed with error: %d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?IocpServerWorker@@YGKPAX@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffff8cH
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN24@IocpServer
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?IocpServerWorker@@YGKPAX@Z
_TEXT	SEGMENT
_SystemInfo$ = -100					; size = 36
_RecvBytes$ = -64					; size = 4
_ThreadID$ = -60					; size = 4
_dwCPU$212229 = -56					; size = 4
_Flags$ = -52						; size = 4
_cAddrlen$ = -48					; size = 4
_cAddr$ = -44						; size = 16
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_p$ = 8							; size = 4
?IocpServerWorker@@YGKPAX@Z PROC			; IocpServerWorker, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?IocpServerWorker@@YGKPAX@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 54	 sub	 esp, 84			; 00000054H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 255  : 	SYSTEM_INFO SystemInfo;
; 256  : 	DWORD ThreadID;
; 257  : 	SOCKET Accept;
; 258  : 	int nRet;
; 259  : 	int ClientIndex;
; 260  : 	SOCKADDR_IN cAddr;
; 261  : 	IN_ADDR		cInAddr;
; 262  : 	int			cAddrlen = sizeof( cAddr );

  00033	c7 45 d0 10 00
	00 00		 mov	 DWORD PTR _cAddrlen$[ebp], 16 ; 00000010H

; 263  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL; 
; 264  : 	DWORD RecvBytes;
; 265  : 	DWORD Flags=0;

  0003a	33 db		 xor	 ebx, ebx
  0003c	89 5d cc	 mov	 DWORD PTR _Flags$[ebp], ebx

; 266  : 	
; 267  : 	InitializeCriticalSection(&criti);

  0003f	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 268  : 	GetSystemInfo(&SystemInfo);

  0004a	8d 45 9c	 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 269  : 
; 270  : 	g_dwThreadCount = SystemInfo.dwNumberOfProcessors * 2;

  00054	8b 4d b0	 mov	 ecx, DWORD PTR _SystemInfo$[ebp+20]
  00057	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  0005a	89 15 00 00 00
	00		 mov	 DWORD PTR ?g_dwThreadCount@@3KA, edx ; g_dwThreadCount

; 271  : 	__try

  00060	89 5d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], ebx

; 272  : 	{
; 273  : 
; 274  : 		g_CompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

  00063	53		 push	 ebx
  00064	53		 push	 ebx
  00065	53		 push	 ebx
  00066	6a ff		 push	 -1
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  0006e	a3 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, eax ; g_CompletionPort

; 275  : 		if ( g_CompletionPort == NULL)

  00073	3b c3		 cmp	 eax, ebx
  00075	75 17		 jne	 SHORT $LN19@IocpServer

; 276  : 		{
; 277  : 			LogAdd("CreateIoCompletionPort failed with error: %d", GetLastError());

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5wi@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00089	83 c4 08	 add	 esp, 8

; 278  : 			__leave;

  0008c	eb 5c		 jmp	 SHORT $LN12@IocpServer
$LN19@IocpServer:

; 279  : 		}
; 280  : 		
; 281  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  0008e	33 f6		 xor	 esi, esi
  00090	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateThread@24
$LN36@IocpServer:
  00096	89 75 c8	 mov	 DWORD PTR _dwCPU$212229[ebp], esi
  00099	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  0009f	73 40		 jae	 SHORT $LN16@IocpServer

; 282  : 		{
; 283  : 			HANDLE ThreadHandle;
; 284  : 			// Create a server worker thread and pass the completion port to the thread.
; 285  : 			
; 286  : 			ThreadHandle = CreateThread(NULL, 0, ServerWorkerThread, g_CompletionPort, 0, &ThreadID);

  000a1	8d 4d c4	 lea	 ecx, DWORD PTR _ThreadID$[ebp]
  000a4	51		 push	 ecx
  000a5	53		 push	 ebx
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ?ServerWorkerThread@@YGKPAX@Z ; ServerWorkerThread
  000ac	53		 push	 ebx
  000ad	53		 push	 ebx
  000ae	ff d7		 call	 edi

; 287  : 			if ( ThreadHandle == NULL)

  000b0	3b c3		 cmp	 eax, ebx
  000b2	75 17		 jne	 SHORT $LN15@IocpServer

; 288  : 			{
; 289  : 				LogAdd("CreateThread() failed with error %d", GetLastError());

  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c6	83 c4 08	 add	 esp, 8

; 290  : 				__leave;

  000c9	eb 1f		 jmp	 SHORT $LN12@IocpServer
$LN15@IocpServer:

; 291  : 			}
; 292  : 			g_ThreadHandles[dwCPU] = ThreadHandle;

  000cb	89 04 b5 00 00
	00 00		 mov	 DWORD PTR ?g_ThreadHandles@@3PAPAXA[esi*4], eax

; 293  : 			CloseHandle(ThreadHandle);

  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 279  : 		}
; 280  : 		
; 281  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  000d9	46		 inc	 esi
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  000df	eb b5		 jmp	 SHORT $LN36@IocpServer
$LN16@IocpServer:

; 294  : 
; 295  : 		}
; 296  : 
; 297  : 		if (!CreateListenSocket() )

  000e1	e8 00 00 00 00	 call	 ?CreateListenSocket@@YAHXZ ; CreateListenSocket
  000e6	85 c0		 test	 eax, eax
  000e8	75 3a		 jne	 SHORT $LL13@IocpServer
$LN12@IocpServer:

; 384  : 	}
; 385  : 	__finally  

  000ea	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000f1	e8 08 03 00 00	 call	 $LN26@IocpServer
$LN27@IocpServer:

; 401  : 		} 
; 402  : 	}
; 403  : 	return TRUE;

  000f6	b8 01 00 00 00	 mov	 eax, 1

; 404  : }

  000fb	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000fe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00105	59		 pop	 ecx
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010c	33 cd		 xor	 ecx, ebp
  0010e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
$LN38@IocpServer:

; 321  : 				LeaveCriticalSection(&criti);

  00119	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LL13@IocpServer:

; 298  : 			__leave;
; 299  : 
; 300  : 		
; 301  : 		while(TRUE)		
; 302  : 		{
; 303  : 			Accept = WSAAccept(g_Listen, (LPSOCKADDR)&cAddr, &cAddrlen, NULL, 0);

  00124	6a 00		 push	 0
  00126	6a 00		 push	 0
  00128	8d 55 d0	 lea	 edx, DWORD PTR _cAddrlen$[ebp]
  0012b	52		 push	 edx
  0012c	8d 45 d4	 lea	 eax, DWORD PTR _cAddr$[ebp]
  0012f	50		 push	 eax
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00136	51		 push	 ecx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAAccept@20
  0013d	8b f8		 mov	 edi, eax

; 305  : 			{
; 306  : 				EnterCriticalSection(&criti);

  0013f	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 304  : 			if (Accept==SOCKET_ERROR)

  0014a	83 ff ff	 cmp	 edi, -1
  0014d	75 17		 jne	 SHORT $LN11@IocpServer

; 307  : 				LogAdd("WSAAccept() failed with error %d", WSAGetLastError());

  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00155	50		 push	 eax
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CFd@
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00161	83 c4 08	 add	 esp, 8

; 308  : 				LeaveCriticalSection(&criti);
; 309  : 				continue;

  00164	eb b3		 jmp	 SHORT $LN38@IocpServer
$LN11@IocpServer:

; 310  : 			}
; 311  : 			EnterCriticalSection(&criti);
; 312  : 
; 313  : 			memcpy( &cInAddr, &cAddr.sin_addr.s_addr, 4 );

  00166	8b 45 d8	 mov	 eax, DWORD PTR _cAddr$[ebp+4]
  00169	8b f0		 mov	 esi, eax

; 314  : 
; 315  : 			ClientIndex = gObjAddSearch(Accept, inet_ntoa(cInAddr) );

  0016b	50		 push	 eax
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00172	50		 push	 eax
  00173	57		 push	 edi
  00174	e8 00 00 00 00	 call	 ?gObjAddSearch@@YAFIPAD@Z ; gObjAddSearch
  00179	83 c4 08	 add	 esp, 8
  0017c	0f bf d8	 movsx	 ebx, ax

; 316  : 			
; 317  : 			if ( ClientIndex == -1 )

  0017f	83 fb ff	 cmp	 ebx, -1
  00182	75 1a		 jne	 SHORT $LN10@IocpServer

; 318  : 			{
; 319  : 				LogAddL("error-L2 : ClientIndex = -1");

  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91?$AA@
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  0018f	83 c4 04	 add	 esp, 4
$LN37@IocpServer:

; 320  : 				closesocket(Accept);

  00192	57		 push	 edi
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 322  : 				continue;

  00199	e9 7b ff ff ff	 jmp	 $LN38@IocpServer
$LN10@IocpServer:

; 323  : 			}
; 324  : 
; 325  : 			if (UpdateCompletionPort(Accept, ClientIndex, 1) == 0 )

  0019e	6a 01		 push	 1
  001a0	53		 push	 ebx
  001a1	57		 push	 edi
  001a2	e8 00 00 00 00	 call	 ?UpdateCompletionPort@@YAHIHH@Z ; UpdateCompletionPort
  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001aa	85 c0		 test	 eax, eax
  001ac	75 19		 jne	 SHORT $LN9@IocpServer

; 326  : 			{
; 327  : 				LogAddL("error-L1 : %d %d CreateIoCompletionPort failed with error %d", Accept, ClientIndex, GetLastError() );

  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001b4	50		 push	 eax
  001b5	53		 push	 ebx
  001b6	57		 push	 edi
  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComplet@
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  001c2	83 c4 10	 add	 esp, 16			; 00000010H

; 328  : 				closesocket(Accept);
; 329  : 				LeaveCriticalSection(&criti);
; 330  : 				continue;

  001c5	eb cb		 jmp	 SHORT $LN37@IocpServer
$LN9@IocpServer:

; 331  : 			}
; 332  : 
; 333  : 			if (gObjAdd(Accept, inet_ntoa(cInAddr), ClientIndex) == -1 )

  001c7	53		 push	 ebx
  001c8	56		 push	 esi
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  001cf	50		 push	 eax
  001d0	57		 push	 edi
  001d1	e8 00 00 00 00	 call	 ?gObjAdd@@YAFIPADH@Z	; gObjAdd
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d9	66 83 f8 ff	 cmp	 ax, -1
  001dd	75 2e		 jne	 SHORT $LN8@IocpServer

; 334  : 			{
; 335  : 				LogAddL("error-L1 : %d %d gObjAdd() failed with error %d", Accept, ClientIndex, GetLastError() );

  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001e5	50		 push	 eax
  001e6	53		 push	 ebx
  001e7	57		 push	 edi
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5faile@
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  001f3	83 c4 10	 add	 esp, 16			; 00000010H

; 336  : 				LeaveCriticalSection(&criti);

  001f6	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 337  : 				closesocket(Accept);

  00201	57		 push	 edi
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 338  : 				continue;

  00208	e9 17 ff ff ff	 jmp	 $LL13@IocpServer
$LN8@IocpServer:

; 339  : 			}
; 340  : 				
; 341  : 			memset(&gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped, 0, sizeof(OVERLAPPED));

  0020d	8b f3		 mov	 esi, ebx
  0020f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00215	33 c9		 xor	 ecx, ecx
  00217	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021d	8b 44 16 10	 mov	 eax, DWORD PTR [esi+edx+16]
  00221	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00224	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00227	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0022a	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0022d	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 342  : 			memset(&gObj[ClientIndex].PerSocketContext->IOContext[1].Overlapped, 0, sizeof(OVERLAPPED));

  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00235	8b 44 06 10	 mov	 eax, DWORD PTR [esi+eax+16]
  00239	89 88 38 00 02
	00		 mov	 DWORD PTR [eax+131128], ecx
  0023f	89 88 3c 00 02
	00		 mov	 DWORD PTR [eax+131132], ecx
  00245	89 88 40 00 02
	00		 mov	 DWORD PTR [eax+131136], ecx
  0024b	89 88 44 00 02
	00		 mov	 DWORD PTR [eax+131140], ecx
  00251	89 88 48 00 02
	00		 mov	 DWORD PTR [eax+131144], ecx

; 343  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  00257	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025d	8b 44 16 10	 mov	 eax, DWORD PTR [esi+edx+16]
  00261	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  00264	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 344  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.len = MAX_IO_BUFFER_SIZE;

  00267	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026c	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  00270	c7 42 1c ff ff
	00 00		 mov	 DWORD PTR [edx+28], 65535 ; 0000ffffH

; 345  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nTotalBytes = 0;

  00277	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0027c	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  00280	89 8a 28 00 02
	00		 mov	 DWORD PTR [edx+131112], ecx

; 346  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSentBytes = 0;

  00286	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028b	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0028f	89 8a 2c 00 02
	00		 mov	 DWORD PTR [edx+131116], ecx

; 347  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO    = 0;

  00295	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029a	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0029e	89 8a 34 00 02
	00		 mov	 DWORD PTR [edx+131124], ecx

; 348  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSecondOfs = 0;

  002a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a9	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  002ad	89 8a 24 00 02
	00		 mov	 DWORD PTR [edx+131108], ecx

; 349  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].IOOperation = RECV_IO;

  002b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b8	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  002bc	89 8a 30 00 02
	00		 mov	 DWORD PTR [edx+131120], ecx

; 350  : 			
; 351  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  002c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c7	8b 44 06 10	 mov	 eax, DWORD PTR [esi+eax+16]
  002cb	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  002ce	89 90 50 00 02
	00		 mov	 DWORD PTR [eax+131152], edx

; 352  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.len = MAX_IO_BUFFER_SIZE;

  002d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d9	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  002dd	c7 82 4c 00 02
	00 ff ff 00 00	 mov	 DWORD PTR [edx+131148], 65535 ; 0000ffffH

; 353  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nTotalBytes= 0;

  002e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ec	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  002f0	89 8a 58 00 04
	00		 mov	 DWORD PTR [edx+262232], ecx

; 354  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSentBytes = 0;

  002f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fb	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  002ff	89 8a 5c 00 04
	00		 mov	 DWORD PTR [edx+262236], ecx

; 355  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nWaitIO    = 0;

  00305	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0030a	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0030e	89 8a 64 00 04
	00		 mov	 DWORD PTR [edx+262244], ecx

; 356  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSecondOfs = 0;

  00314	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00319	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0031d	89 8a 54 00 04
	00		 mov	 DWORD PTR [edx+262228], ecx

; 357  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].IOOperation = SEND_IO;

  00323	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00328	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0032c	c7 82 60 00 04
	00 01 00 00 00	 mov	 DWORD PTR [edx+262240], 1

; 358  : 			gObj[ClientIndex].PerSocketContext->m_socket = Accept;

  00336	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033b	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0033f	89 3a		 mov	 DWORD PTR [edx], edi

; 359  : 			gObj[ClientIndex].PerSocketContext->nIndex   = ClientIndex;

  00341	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00346	8b 54 06 10	 mov	 edx, DWORD PTR [esi+eax+16]
  0034a	89 5a 04	 mov	 DWORD PTR [edx+4], ebx

; 360  : 
; 361  : 			nRet = WSARecv(Accept, &(gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf), 1, &RecvBytes, &Flags,
; 362  : 				&(gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped), NULL);

  0034d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00352	8b 44 06 10	 mov	 eax, DWORD PTR [esi+eax+16]
  00356	51		 push	 ecx
  00357	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0035a	51		 push	 ecx
  0035b	8d 55 cc	 lea	 edx, DWORD PTR _Flags$[ebp]
  0035e	52		 push	 edx
  0035f	8d 4d c0	 lea	 ecx, DWORD PTR _RecvBytes$[ebp]
  00362	51		 push	 ecx
  00363	6a 01		 push	 1
  00365	83 c0 1c	 add	 eax, 28			; 0000001cH
  00368	50		 push	 eax
  00369	57		 push	 edi
  0036a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28

; 363  : 
; 364  : 			if( nRet == SOCKET_ERROR && WSAGetLastError() != ERROR_IO_PENDING )

  00370	83 f8 ff	 cmp	 eax, -1
  00373	75 4b		 jne	 SHORT $LN7@IocpServer
  00375	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WSAGetLastError@0
  0037b	ff d7		 call	 edi
  0037d	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00382	74 3c		 je	 SHORT $LN7@IocpServer

; 365  : 			{
; 366  : 				LogAdd("error-L1 : WSARecv() failed with error %d", WSAGetLastError());

  00384	ff d7		 call	 edi
  00386	50		 push	 eax
  00387	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5with@
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 367  : 				//#if(!FIX_SOCKET_MAXBUFFER)
; 368  : 				gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 4;

  00392	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00398	8b 44 16 10	 mov	 eax, DWORD PTR [esi+edx+16]
  0039c	c7 80 34 00 02
	00 04 00 00 00	 mov	 DWORD PTR [eax+131124], 4

; 369  : 				//#endif
; 370  : 				CloseClient(gObj[ClientIndex].PerSocketContext, FALSE);

  003a6	6a 00		 push	 0
  003a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ae	8b 54 0e 10	 mov	 edx, DWORD PTR [esi+ecx+16]
  003b2	52		 push	 edx
  003b3	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  003b8	83 c4 10	 add	 esp, 16			; 00000010H

; 371  : 				LeaveCriticalSection(&criti);
; 372  : 				continue;

  003bb	e9 59 fd ff ff	 jmp	 $LN38@IocpServer
$LN7@IocpServer:

; 373  : 			}
; 374  : 
; 375  : 			//#if(!FIX_SOCKET_MAXBUFFER)
; 376  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 1;

  003c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c5	8b 4c 06 10	 mov	 ecx, DWORD PTR [esi+eax+16]
  003c9	bf 01 00 00 00	 mov	 edi, 1
  003ce	89 b9 34 00 02
	00		 mov	 DWORD PTR [ecx+131124], edi

; 377  : 			//#endif
; 378  : 			gObj[ClientIndex].PerSocketContext->dwIOCount++;

  003d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003da	8b 74 16 10	 mov	 esi, DWORD PTR [esi+edx+16]
  003de	01 be 68 00 04
	00		 add	 DWORD PTR [esi+262248], edi

; 379  : 
; 380  : 			LeaveCriticalSection(&criti);

  003e4	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 381  : 			SCPJoinResultSend(ClientIndex, 1);

  003ef	57		 push	 edi
  003f0	53		 push	 ebx
  003f1	e8 00 00 00 00	 call	 ?SCPJoinResultSend@@YAXHE@Z ; SCPJoinResultSend
  003f6	83 c4 08	 add	 esp, 8

; 382  : 
; 383  : 		}

  003f9	e9 26 fd ff ff	 jmp	 $LL13@IocpServer
$LN24@IocpServer:
$LN40@IocpServer:
$LN26@IocpServer:

; 386  : 	{
; 387  : 		if( g_CompletionPort )

  003fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00403	85 c0		 test	 eax, eax
  00405	74 3c		 je	 SHORT $LN2@IocpServer

; 388  : 		{
; 389  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  00407	33 f6		 xor	 esi, esi
  00409	39 35 00 00 00
	00		 cmp	 DWORD PTR ?g_dwThreadCount@@3KA, esi ; g_dwThreadCount
  0040f	76 1d		 jbe	 SHORT $LN3@IocpServer
  00411	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PostQueuedCompletionStatus@16
$LL34@IocpServer:

; 390  : 					PostQueuedCompletionStatus(g_CompletionPort, 0, 0, NULL); 

  00417	6a 00		 push	 0
  00419	6a 00		 push	 0
  0041b	6a 00		 push	 0
  0041d	50		 push	 eax
  0041e	ff d7		 call	 edi

; 388  : 		{
; 389  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  00420	46		 inc	 esi
  00421	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00426	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  0042c	72 e9		 jb	 SHORT $LL34@IocpServer
$LN3@IocpServer:

; 391  : 		}
; 392  : 		if( g_CompletionPort )

  0042e	85 c0		 test	 eax, eax
  00430	74 11		 je	 SHORT $LN2@IocpServer

; 393  : 		{
; 394  : 			CloseHandle(g_CompletionPort);

  00432	50		 push	 eax
  00433	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 395  : 			g_CompletionPort = NULL;

  00439	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN2@IocpServer:

; 396  : 		}
; 397  : 		if (g_Listen != INVALID_SOCKET)  

  00443	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00448	83 f8 ff	 cmp	 eax, -1
  0044b	74 11		 je	 SHORT $LN25@IocpServer

; 398  : 		{ 
; 399  :             closesocket(g_Listen);  

  0044d	50		 push	 eax
  0044e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 400  :             g_Listen = INVALID_SOCKET; 

  00454	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_Listen@@3IA, -1 ; g_Listen
$LN25@IocpServer:
$LN35@IocpServer:
  0045e	c3		 ret	 0
?IocpServerWorker@@YGKPAX@Z ENDP			; IocpServerWorker
_TEXT	ENDS
PUBLIC	?CreateGIocp@@YAHH@Z				; CreateGIocp
; Function compile flags: /Ogtp
;	COMDAT ?CreateGIocp@@YAHH@Z
_TEXT	SEGMENT
_ThreadID$ = 8						; size = 4
_server_port$ = 8					; size = 4
?CreateGIocp@@YAHH@Z PROC				; CreateGIocp, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	DWORD	ThreadID;
; 172  : 	
; 173  : 	g_ServerPort = server_port;

  00003	8b 45 08	 mov	 eax, DWORD PTR _server_port$[ebp]

; 174  : 	if ((g_IocpThreadHandle = CreateThread(NULL, 0, IocpServerWorker, (LPVOID)NULL,
; 175  : 			0, &ThreadID)) == NULL)

  00006	8d 4d 08	 lea	 ecx, DWORD PTR _ThreadID$[ebp]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET ?IocpServerWorker@@YGKPAX@Z ; IocpServerWorker
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	a3 00 00 00 00	 mov	 DWORD PTR ?g_ServerPort@@3HA, eax ; g_ServerPort
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00022	a3 00 00 00 00	 mov	 DWORD PTR ?g_IocpThreadHandle@@3PAXA, eax ; g_IocpThreadHandle
  00027	85 c0		 test	 eax, eax
  00029	75 19		 jne	 SHORT $LN1@CreateGIoc

; 176  : 	{
; 177  : 		LogAdd("CreateThread() failed with error %d", GetLastError());

  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5error@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003d	83 c4 08	 add	 esp, 8

; 178  : 		return FALSE;

  00040	33 c0		 xor	 eax, eax

; 189  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN1@CreateGIoc:

; 179  : 	}
; 180  : 
; 181  : #if(ENABLE_PROTOCOL_QUEUE)
; 182  : 	if(CreateServerQueue() == 0)
; 183  : 	{
; 184  : 		return 0;
; 185  : 	}
; 186  : #endif
; 187  : 
; 188  : 	return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1

; 189  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?CreateGIocp@@YAHH@Z ENDP				; CreateGIocp
_TEXT	ENDS
END
