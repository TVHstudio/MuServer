; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\protocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ltesttime@@3HA					; ltesttime
PUBLIC	?logincounttest@@3HA				; logincounttest
PUBLIC	?tempindex@@3HA					; tempindex
PUBLIC	?iCount@@3HA					; iCount
_BSS	SEGMENT
?ltesttime@@3HA DD 01H DUP (?)				; ltesttime
?logincounttest@@3HA DD 01H DUP (?)			; logincounttest
?tempindex@@3HA DD 01H DUP (?)				; tempindex
?iCount@@3HA DD	01H DUP (?)				; iCount
_BSS	ENDS
_DATA	SEGMENT
_g_iNpcUpDfLevel_CGATE DD 01H
	DD	02H
	DD	02dc6c0H
	DD	02H
	DD	03H
	DD	02dc6c0H
	DD	03H
	DD	04H
	DD	02dc6c0H
_g_iNpcUpDfLevel_CSTATUE DD 01H
	DD	03H
	DD	02dc6c0H
	DD	02H
	DD	05H
	DD	02dc6c0H
	DD	03H
	DD	07H
	DD	02dc6c0H
_g_iNpcUpMaxHP_CGATE DD 02625a0H
	DD	02H
	DD	0f4240H
	DD	03567e0H
	DD	03H
	DD	0f4240H
	DD	04f5880H
	DD	04H
	DD	0f4240H
_g_iNpcUpMaxHP_CSTATUE DD 02191c0H
	DD	03H
	DD	0f4240H
	DD	033e140H
	DD	05H
	DD	0f4240H
	DD	04c4b40H
	DD	07H
	DD	0f4240H
_g_iNpcUpRgLevel_CSTATUE DD 01H
	DD	03H
	DD	04c4b40H
	DD	02H
	DD	05H
	DD	04c4b40H
	DD	03H
	DD	07H
	DD	04c4b40H
_g_iCsUserReSpawnArea DD 023H
	DD	011H
	DD	090H
	DD	030H
	DD	04aH
	DD	090H
	DD	073H
	DD	09aH
	DD	023H
	DD	011H
	DD	090H
	DD	030H
_g_iNpcDefense_CGATE DD 064H
	DD	0b4H
	DD	012cH
	DD	0208H
_g_iNpcDefense_CSTATUE DD 050H
	DD	0b4H
	DD	0154H
	DD	0226H
_g_iCastleWallStepAxisY DD 071H
	DD	0a0H
	DD	0cbH
_g_sttKALIMAGATE_LEVEL DD 028H
	DD	082H
	DD	014H
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	015dH
	DD	0137H
	DD	015dH
	DD	015eH
	DD	03e8H
	DD	015eH
	DD	03e8H
_g_iKalimaGateGateIndex DD 058H
	DD	059H
	DD	05aH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	074H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	070H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
	DD	010eH
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	03e8H
	DD	0137H
	DD	03e8H
	DD	0fH
	DD	04afH
	DD	0aH
	DD	04afH
_g_sttCHAOSCASTLE_LEVEL DD 0fH
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	03e8H
	DD	0118H
	DD	03e8H
	DD	03e8H
	DD	04afH
	DD	03e8H
	DD	04afH
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	04H
_g_iChaosCastle_MonsterItemsNewServer DD 00H
	DD	00H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	02H
	DD	01c0eH
	DD	03H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 80   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 82   : 		lpBuf[1] = size;

  00006	8a 4d 10	 mov	 cl, BYTE PTR _size$[ebp]

; 83   : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  0000f	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00012	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 84   : 	};	// line : 22

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
PUBLIC	?set@PBMSG_HEAD2@@QAEXPAEEEE@Z			; PBMSG_HEAD2::set
; Function compile flags: /Ogtp
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 104  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 105  : 		lpBuf[0] = 0xC1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 106  : 		lpBuf[1] = size;

  00006	8a 4d 14	 mov	 cl, BYTE PTR _size$[ebp]

; 107  : 		lpBuf[2] = head;

  00009	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  0000c	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 108  : 		lpBuf[3] = sub;

  0000f	8a 4d 10	 mov	 cl, BYTE PTR _sub$[ebp]
  00012	c6 00 c1	 mov	 BYTE PTR [eax], 193	; 000000c1H
  00015	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00018	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 109  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
PUBLIC	?set@PWMSG_HEAD@@QAEXPAEEH@Z			; PWMSG_HEAD::set
; Function compile flags: /Ogtp
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 122  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 		lpBuf[0] = 0xC2;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpBuf$[ebp]

; 124  : 		lpBuf[1] = SET_NUMBERH(size);

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00009	8b d1		 mov	 edx, ecx

; 125  : 		lpBuf[2] = SET_NUMBERL(size);

  0000b	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 126  : 		lpBuf[3] = head;

  0000e	8a 4d 0c	 mov	 cl, BYTE PTR _head$[ebp]
  00011	c1 ea 08	 shr	 edx, 8
  00014	c6 00 c2	 mov	 BYTE PTR [eax], 194	; 000000c2H
  00017	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0001a	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 127  : 	};

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
PUBLIC	?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tdurmagickeychecker.h
;	COMDAT ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::IsValidDurationTime, COMDAT
; _this$ = ecx

; 16   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 17   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00004	8a 5d 08	 mov	 bl, BYTE PTR _btMagicKey$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0000d	3c 3b		 cmp	 al, 59			; 0000003bH
  0000f	77 1e		 ja	 SHORT $LN1@IsValidDur

; 18   : 		{
; 19   : 			if ( (GetTickCount() - this->m_dwDurationTime[btMagicKey]) < 15000 )

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00017	0f b6 cb	 movzx	 ecx, bl
  0001a	2b 04 8e	 sub	 eax, DWORD PTR [esi+ecx*4]
  0001d	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00022	73 0b		 jae	 SHORT $LN1@IsValidDur

; 20   : 			{
; 21   : 				return TRUE;

  00024	5e		 pop	 esi
  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	5b		 pop	 ebx

; 26   : 
; 27   : 	};	// line : 25

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN1@IsValidDur:
  0002f	5e		 pop	 esi

; 22   : 			}
; 23   : 		}
; 24   : 
; 25   : 		return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 26   : 
; 27   : 	};	// line : 25

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::IsValidDurationTime
_TEXT	ENDS
PUBLIC	?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::IsValidCount
; Function compile flags: /Ogtp
;	COMDAT ?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC		; TDurMagicKeyChecker::IsValidCount, COMDAT
; _this$ = ecx

; 31   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00007	fe c8		 dec	 al
  00009	b1 3b		 mov	 cl, 59			; 0000003bH
  0000b	3a c8		 cmp	 cl, al
  0000d	1b c0		 sbb	 eax, eax
  0000f	40		 inc	 eax

; 33   : 		{
; 34   : 			if ( this->m_btValidCount[btMagicKey] >= 0 )
; 35   : 			{
; 36   : 				return TRUE;
; 37   : 			}
; 38   : 		}
; 39   : 		return FALSE;
; 40   : 	};	// line : 38

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP		; TDurMagicKeyChecker::IsValidCount
_TEXT	ENDS
PUBLIC	?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z	; TDurMagicKeyChecker::SetDurationTime
; Function compile flags: /Ogtp
;	COMDAT ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
_dwCurrentTickCount$ = 12				; size = 4
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z PROC	; TDurMagicKeyChecker::SetDurationTime, COMDAT
; _this$ = ecx

; 43   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00009	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0000c	77 11		 ja	 SHORT $LN1@SetDuratio

; 45   : 		{
; 46   : 			this->m_dwDurationTime[btMagicKey] = dwCurrentTickCount;

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _dwCurrentTickCount$[ebp]
  00011	0f b6 c0	 movzx	 eax, al
  00014	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 47   : 			this->m_btValidCount[btMagicKey] = 7;

  00017	c6 84 08 f0 00
	00 00 07	 mov	 BYTE PTR [eax+ecx+240], 7
$LN1@SetDuratio:

; 48   : 		}
; 49   : 	};	// line : 47

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ENDP	; TDurMagicKeyChecker::SetDurationTime
_TEXT	ENDS
PUBLIC	?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
; Function compile flags: /Ogtp
;	COMDAT ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidDurationTime, COMDAT
; _this$ = ecx

; 52   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00009	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0000c	77 0a		 ja	 SHORT $LN1@GetValidDu

; 54   : 		{
; 55   : 			return this->m_dwDurationTime[btMagicKey];

  0000e	0f b6 c0	 movzx	 eax, al
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 59   : 	};	// line : 70

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN1@GetValidDu:

; 56   : 		}
; 57   : 
; 58   : 		return -77;

  00018	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H

; 59   : 	};	// line : 70

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidDurationTime
_TEXT	ENDS
PUBLIC	?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::GetValidCount
; Function compile flags: /Ogtp
;	COMDAT ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidCount, COMDAT
; _this$ = ecx

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00009	80 fa 3b	 cmp	 dl, 59			; 0000003bH
  0000c	77 0f		 ja	 SHORT $LN1@GetValidCo

; 64   : 		{		
; 65   : 			return this->m_btValidCount[btMagicKey];

  0000e	0f b6 c0	 movzx	 eax, al
  00011	0f b6 84 08 f0
	00 00 00	 movzx	 eax, BYTE PTR [eax+ecx+240]

; 69   : 	};	// line : 80

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN1@GetValidCo:

; 66   : 		}
; 67   : 
; 68   : 		return -77;

  0001d	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H

; 69   : 	};	// line : 80

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidCount
_TEXT	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
EXTRN	_strchr:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 215  : 	{ return (char*)strchr((const char*)_Str, _Ch); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 _strchr
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetQeustCount@CQuestInfo@@QAEHXZ		; CQuestInfo::GetQeustCount
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\questinfo.h
;	COMDAT ?GetQeustCount@CQuestInfo@@QAEHXZ
_TEXT	SEGMENT
?GetQeustCount@CQuestInfo@@QAEHXZ PROC			; CQuestInfo::GetQeustCount, COMDAT
; _this$ = ecx

; 102  : 	int GetQeustCount(){return m_QuestCount;}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetQeustCount@CQuestInfo@@QAEHXZ ENDP			; CQuestInfo::GetQeustCount
_TEXT	ENDS
PUBLIC	?GetCastleState@CCastleSiege@@QAEHXZ		; CCastleSiege::GetCastleState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
;	COMDAT ?GetCastleState@CCastleSiege@@QAEHXZ
_TEXT	SEGMENT
?GetCastleState@CCastleSiege@@QAEHXZ PROC		; CCastleSiege::GetCastleState, COMDAT
; _this$ = ecx

; 314  : 	int GetCastleState(){return m_iCastleSiegeState;}

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00003	c3		 ret	 0
?GetCastleState@CCastleSiege@@QAEHXZ ENDP		; CCastleSiege::GetCastleState
_TEXT	ENDS
PUBLIC	?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ ; CCastleSiege::GetCastleLeftSiegeDate
; Function compile flags: /Ogtp
;	COMDAT ?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ PROC ; CCastleSiege::GetCastleLeftSiegeDate, COMDAT
; _this$ = ecx

; 315  : 	SYSTEMTIME GetCastleLeftSiegeDate() {return m_tmLeftCastleSiegeDate;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  0000c	89 10		 mov	 DWORD PTR [eax], edx
  0000e	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  0001d	8b 89 8c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+140]
  00023	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00026	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ ENDP ; CCastleSiege::GetCastleLeftSiegeDate
_TEXT	ENDS
PUBLIC	?GetCastleOwnerGuild@CCastleSiege@@QAEPADXZ	; CCastleSiege::GetCastleOwnerGuild
; Function compile flags: /Ogtp
;	COMDAT ?GetCastleOwnerGuild@CCastleSiege@@QAEPADXZ
_TEXT	SEGMENT
?GetCastleOwnerGuild@CCastleSiege@@QAEPADXZ PROC	; CCastleSiege::GetCastleOwnerGuild, COMDAT
; _this$ = ecx

; 364  : 	char * GetCastleOwnerGuild(){return m_szCastleOwnerGuild;}

  00000	8d 81 d7 00 00
	00		 lea	 eax, DWORD PTR [ecx+215]
  00006	c3		 ret	 0
?GetCastleOwnerGuild@CCastleSiege@@QAEPADXZ ENDP	; CCastleSiege::GetCastleOwnerGuild
_TEXT	ENDS
PUBLIC	?GetHuntZoneEnter@CCastleSiege@@QAEHXZ		; CCastleSiege::GetHuntZoneEnter
; Function compile flags: /Ogtp
;	COMDAT ?GetHuntZoneEnter@CCastleSiege@@QAEHXZ
_TEXT	SEGMENT
?GetHuntZoneEnter@CCastleSiege@@QAEHXZ PROC		; CCastleSiege::GetHuntZoneEnter, COMDAT
; _this$ = ecx

; 365  : 	BOOL GetHuntZoneEnter(){return m_bEnterHuntZone;}

  00000	8b 81 fc 00 00
	00		 mov	 eax, DWORD PTR [ecx+252]
  00006	c3		 ret	 0
?GetHuntZoneEnter@CCastleSiege@@QAEHXZ ENDP		; CCastleSiege::GetHuntZoneEnter
_TEXT	ENDS
PUBLIC	?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z		; CCastleSiege::SetHuntZoneEnter
; Function compile flags: /Ogtp
;	COMDAT ?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z
_TEXT	SEGMENT
_bEnterHuntZone$ = 8					; size = 4
?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z PROC		; CCastleSiege::SetHuntZoneEnter, COMDAT
; _this$ = ecx

; 366  : 	void SetHuntZoneEnter(BOOL bEnterHuntZone){m_bEnterHuntZone = bEnterHuntZone;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _bEnterHuntZone$[ebp]
  00006	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z ENDP		; CCastleSiege::SetHuntZoneEnter
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?GetCrownAccessTickCount@CCastleSiege@@QAEKXZ	; CCastleSiege::GetCrownAccessTickCount
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
;	COMDAT ?GetCrownAccessTickCount@CCastleSiege@@QAEKXZ
_TEXT	SEGMENT
?GetCrownAccessTickCount@CCastleSiege@@QAEKXZ PROC	; CCastleSiege::GetCrownAccessTickCount, COMDAT
; _this$ = ecx

; 425  : 	DWORD GetCrownAccessTickCount(){return m_dwCrownAccessTime;}

  00000	8b 81 00 02 00
	00		 mov	 eax, DWORD PTR [ecx+512]
  00006	c3		 ret	 0
?GetCrownAccessTickCount@CCastleSiege@@QAEKXZ ENDP	; CCastleSiege::GetCrownAccessTickCount
_TEXT	ENDS
PUBLIC	?GetCrywolfState@CCrywolf@@QAEHXZ		; CCrywolf::GetCrywolfState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\crywolf.h
;	COMDAT ?GetCrywolfState@CCrywolf@@QAEHXZ
_TEXT	SEGMENT
?GetCrywolfState@CCrywolf@@QAEHXZ PROC			; CCrywolf::GetCrywolfState, COMDAT
; _this$ = ecx

; 91   : 	int GetCrywolfState(){return this->m_iCrywolfState;}

  00000	8b 81 ec b7 0f
	00		 mov	 eax, DWORD PTR [ecx+1030124]
  00006	c3		 ret	 0
?GetCrywolfState@CCrywolf@@QAEHXZ ENDP			; CCrywolf::GetCrywolfState
_TEXT	ENDS
PUBLIC	?GetOccupationState@CCrywolf@@QAEHXZ		; CCrywolf::GetOccupationState
; Function compile flags: /Ogtp
;	COMDAT ?GetOccupationState@CCrywolf@@QAEHXZ
_TEXT	SEGMENT
?GetOccupationState@CCrywolf@@QAEHXZ PROC		; CCrywolf::GetOccupationState, COMDAT
; _this$ = ecx

; 92   : 	int GetOccupationState(){return this->m_iOccupationState;}

  00000	8b 81 f0 b7 0f
	00		 mov	 eax, DWORD PTR [ecx+1030128]
  00006	c3		 ret	 0
?GetOccupationState@CCrywolf@@QAEHXZ ENDP		; CCrywolf::GetOccupationState
_TEXT	ENDS
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\tnotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 9    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00007	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  0000b	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0000f	c1 e0 08	 shl	 eax, 8
  00012	03 c1		 add	 eax, ecx
  00014	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00018	c1 e0 08	 shl	 eax, 8
  0001b	03 c2		 add	 eax, edx
  0001d	c1 e0 08	 shl	 eax, 8
  00020	03 c1		 add	 eax, ecx
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
PUBLIC	?GetCastleState@CCastleSiegeSync@@QAEHXZ	; CCastleSiegeSync::GetCastleState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\castlesiegesync.h
;	COMDAT ?GetCastleState@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
?GetCastleState@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetCastleState, COMDAT
; _this$ = ecx

; 34   : 	int  GetCastleState(){return this->m_iCurCastleState;};	// line : 70

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetCastleState@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetCastleState
_TEXT	ENDS
PUBLIC	?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ	; CCastleSiegeSync::GetCastleOwnerGuild
; Function compile flags: /Ogtp
;	COMDAT ?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ
_TEXT	SEGMENT
?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ PROC	; CCastleSiegeSync::GetCastleOwnerGuild, COMDAT
; _this$ = ecx

; 36   : 	LPSTR GetCastleOwnerGuild(){return this->m_szCastleOwnerGuild;};	// line : 85

  00000	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ ENDP	; CCastleSiegeSync::GetCastleOwnerGuild
_TEXT	ENDS
PUBLIC	??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ ; `string'
PUBLIC	?TalkRefDel@CQeustNpcTeleport@@QAEXXZ		; CQeustNpcTeleport::TalkRefDel
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	__imp__EnterCriticalSection@4:PROC
;	COMDAT ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\gobjmonster.h
CONST	SEGMENT
??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ DB 'QeustNpc R'
	DB	'efCount Dec= %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ
_TEXT	SEGMENT
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ PROC		; CQeustNpcTeleport::TalkRefDel, COMDAT
; _this$ = ecx

; 70   : 	{

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 71   : 		EnterCriticalSection(&this->CsRef);

  00004	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 72   : 		this->RefCount--;

  0000e	ff 0e		 dec	 DWORD PTR [esi]

; 73   : 
; 74   : 		if ( this->RefCount < 0 )

  00010	79 06		 jns	 SHORT $LN1@TalkRefDel

; 75   : 		{
; 76   : 			this->RefCount = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@TalkRefDel:

; 77   : 		}
; 78   : 		
; 79   : 		LogAdd("QeustNpc RefCount Dec= %d", this->RefCount);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00026	83 c4 08	 add	 esp, 8

; 80   : 		LeaveCriticalSection(&this->CsRef);

  00029	57		 push	 edi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 81   : 	};

  00032	c3		 ret	 0
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ENDP		; CQeustNpcTeleport::TalkRefDel
_TEXT	ENDS
PUBLIC	?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ; CDevilSquare::GetState
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\devilsquare.h
;	COMDAT ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ
_TEXT	SEGMENT
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ PROC ; CDevilSquare::GetState, COMDAT
; _this$ = ecx

; 44   : 	enum eDevilSquareState GetState(){return this->m_eState;};

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ENDP ; CDevilSquare::GetState
_TEXT	ENDS
PUBLIC	?GetRemainTime@CDevilSquare@@QAEHXZ		; CDevilSquare::GetRemainTime
; Function compile flags: /Ogtp
;	COMDAT ?GetRemainTime@CDevilSquare@@QAEHXZ
_TEXT	SEGMENT
?GetRemainTime@CDevilSquare@@QAEHXZ PROC		; CDevilSquare::GetRemainTime, COMDAT
; _this$ = ecx

; 47   : 	int GetRemainTime(){return this->m_iRemainTime;}

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetRemainTime@CDevilSquare@@QAEHXZ ENDP		; CDevilSquare::GetRemainTime
_TEXT	ENDS
PUBLIC	?GetMapSvrGroup@CMapServerManager@@QAEHXZ	; CMapServerManager::GetMapSvrGroup
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
;	COMDAT ?GetMapSvrGroup@CMapServerManager@@QAEHXZ
_TEXT	SEGMENT
?GetMapSvrGroup@CMapServerManager@@QAEHXZ PROC		; CMapServerManager::GetMapSvrGroup, COMDAT
; _this$ = ecx

; 50   : 		if ( this->m_lpThisMapSvrData != NULL )

  00000	8b 81 c0 32 01
	00		 mov	 eax, DWORD PTR [ecx+78528]
  00006	85 c0		 test	 eax, eax
  00008	74 05		 je	 SHORT $LN1@GetMapSvrG

; 51   : 		{
; 52   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]

; 55   : 	}

  0000e	c3		 ret	 0
$LN1@GetMapSvrG:

; 53   : 		}
; 54   : 		return -1;

  0000f	83 c8 ff	 or	 eax, -1

; 55   : 	}

  00012	c3		 ret	 0
?GetMapSvrGroup@CMapServerManager@@QAEHXZ ENDP		; CMapServerManager::GetMapSvrGroup
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SCFPostItemSend@@YAXHPAUPMSG_POSTITEM@@@Z	; SCFPostItemSend
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
;	COMDAT ?SCFPostItemSend@@YAXHPAUPMSG_POSTITEM@@@Z
_TEXT	SEGMENT
_pResult$ = -188					; size = 184
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_PostItem$ = 12						; size = 4
?SCFPostItemSend@@YAXHPAUPMSG_POSTITEM@@@Z PROC		; SCFPostItemSend, COMDAT

; 203  : void SCFPostItemSend ( int aIndex, PMSG_POSTITEM* PostItem ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _PostItem$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 204  :     SDHP_POSTITEMINFO pResult = { 0 };

  00019	68 b7 00 00 00	 push	 183			; 000000b7H
  0001e	8d 85 45 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp+1]
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _memset

; 205  :     memcpy ( &pResult.Name[0], &PostItem->chatid[0], 10 );

  0002c	8b 4b 03	 mov	 ecx, DWORD PTR [ebx+3]
  0002f	8b 53 07	 mov	 edx, DWORD PTR [ebx+7]
  00032	66 8b 43 0b	 mov	 ax, WORD PTR [ebx+11]
  00036	89 8d 4a ff ff
	ff		 mov	 DWORD PTR _pResult$[ebp+6], ecx
  0003c	89 95 4e ff ff
	ff		 mov	 DWORD PTR _pResult$[ebp+10], edx
  00042	66 89 85 52 ff
	ff ff		 mov	 WORD PTR _pResult$[ebp+14], ax

; 206  :     memcpy ( &pResult.Chat[0], &PostItem->chatmsg[0], 90 );

  00049	8d 73 0d	 lea	 esi, DWORD PTR [ebx+13]
  0004c	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00051	8d bd 55 ff ff
	ff		 lea	 edi, DWORD PTR _pResult$[ebp+17]
  00057	f3 a5		 rep movsd

; 207  :     memcpy ( &pResult.ItemData[0], &PostItem->item_data[0], 107 );
; 208  :     pResult.ServerCode = gGameServerCode;
; 209  :     pResult.h.set ( ( LPBYTE ) &pResult, 0x78, sizeof ( pResult ) );
; 210  : 	DataSend (aIndex, (LPBYTE) &pResult, pResult.h.size );

  00059	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005c	66 a5		 movsw
  0005e	8d 73 67	 lea	 esi, DWORD PTR [ebx+103]
  00061	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00066	8d 7d 91	 lea	 edi, DWORD PTR _pResult$[ebp+77]
  00069	f3 a5		 rep movsd
  0006b	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00072	66 a5		 movsw
  00074	68 b8 00 00 00	 push	 184			; 000000b8H
  00079	8d 95 44 ff ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0007f	a4		 movsb
  00080	52		 push	 edx
  00081	50		 push	 eax
  00082	66 89 8d 48 ff
	ff ff		 mov	 WORD PTR _pResult$[ebp+4], cx
  00089	66 c7 85 44 ff
	ff ff c1 b8	 mov	 WORD PTR _pResult$[ebp], 47297 ; 0000b8c1H
  00092	c6 85 46 ff ff
	ff 78		 mov	 BYTE PTR _pResult$[ebp+2], 120 ; 00000078H
  00099	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 211  : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	83 c4 18	 add	 esp, 24			; 00000018H
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5b		 pop	 ebx
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?SCFPostItemSend@@YAXHPAUPMSG_POSTITEM@@@Z ENDP		; SCFPostItemSend
_TEXT	ENDS
PUBLIC	?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z	; PacketCheckTime
; Function compile flags: /Ogtp
;	COMDAT ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z PROC		; PacketCheckTime, COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 232  : 	//LogAddC(2, "[DEBUG][1] PACKET TIME: %u", ( GetTickCount() - lpObj->m_PacketCheckTime ));
; 233  : 
; 234  : 	if ( ( GetTickCount() - lpObj->m_PacketCheckTime ) < 300 )	//300

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	57		 push	 edi
  00008	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  0000e	ff d7		 call	 edi
  00010	2b 86 8c 03 00
	00		 sub	 eax, DWORD PTR [esi+908]
  00016	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  0001b	73 06		 jae	 SHORT $LN1@PacketChec

; 235  : 	{
; 236  : 		return FALSE;

  0001d	5f		 pop	 edi
  0001e	33 c0		 xor	 eax, eax
  00020	5e		 pop	 esi

; 241  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN1@PacketChec:

; 237  : 	}
; 238  : 
; 239  : 	lpObj->m_PacketCheckTime = GetTickCount();

  00023	ff d7		 call	 edi
  00025	89 86 8c 03 00
	00		 mov	 DWORD PTR [esi+908], eax
  0002b	5f		 pop	 edi

; 240  : 	return TRUE;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	5e		 pop	 esi

; 241  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; PacketCheckTime
_TEXT	ENDS
PUBLIC	??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?DataEncryptCheck@@YAHHEH@Z			; DataEncryptCheck
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
;	COMDAT ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@ DB 'Err'
	DB	'or-L1 : Not Encrypt %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DataEncryptCheck@@YAHHEH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_protoNum$ = 12						; size = 1
_Encrypt$ = 16						; size = 4
?DataEncryptCheck@@YAHHEH@Z PROC			; DataEncryptCheck, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  : #ifdef _FIX_
; 246  : 	switch (protoNum)

  00003	0f b6 45 0c	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00007	8d 48 e7	 lea	 ecx, DWORD PTR [eax-25]
  0000a	81 f9 d8 00 00
	00		 cmp	 ecx, 216		; 000000d8H
  00010	77 0e		 ja	 SHORT $LN3@DataEncryp
  00012	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN7@DataEncryp[ecx]
  00019	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN8@DataEncryp[ecx*4]
$LN3@DataEncryp:

; 247  : 	{
; 248  : 	case 0x1E:
; 249  : 	case 0x19:
; 250  : 	case 0x22:
; 251  : 	case 0xF1:
; 252  : 	case 0x30:
; 253  : 	case 0x32:
; 254  : 	case 0x40:
; 255  : 	case 0x41:
; 256  : 	case 0x33:
; 257  : 		return TRUE;
; 258  : 		break;
; 259  : 	}
; 260  : #endif
; 261  : 	if ( Encrypt == FALSE )

  00020	83 7d 10 00	 cmp	 DWORD PTR _Encrypt$[ebp], 0
  00024	75 30		 jne	 SHORT $LN1@DataEncryp

; 262  : 	{
; 263  : 		LogAdd("Error-L1 : Not Encrypt %s %d", gObj[aIndex].AccountID, protoNum);

  00026	56		 push	 esi
  00027	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0002a	8b d6		 mov	 edx, esi
  0002c	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00032	50		 push	 eax
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	8d 4c 02 6c	 lea	 ecx, DWORD PTR [edx+eax+108]
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 264  : 		CloseClient(aIndex);

  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 265  : 		return FALSE;

  00051	33 c0		 xor	 eax, eax
  00053	5e		 pop	 esi

; 269  : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN1@DataEncryp:

; 266  : 	}
; 267  : 
; 268  : 	return TRUE;

  00056	b8 01 00 00 00	 mov	 eax, 1

; 269  : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
  0005d	8d 49 00	 npad	 3
$LN8@DataEncryp:
  00060	00 00 00 00	 DD	 $LN1@DataEncryp
  00064	00 00 00 00	 DD	 $LN3@DataEncryp
$LN7@DataEncryp:
  00068	00		 DB	 0
  00069	01		 DB	 1
  0006a	01		 DB	 1
  0006b	01		 DB	 1
  0006c	01		 DB	 1
  0006d	00		 DB	 0
  0006e	01		 DB	 1
  0006f	01		 DB	 1
  00070	01		 DB	 1
  00071	00		 DB	 0
  00072	01		 DB	 1
  00073	01		 DB	 1
  00074	01		 DB	 1
  00075	01		 DB	 1
  00076	01		 DB	 1
  00077	01		 DB	 1
  00078	01		 DB	 1
  00079	01		 DB	 1
  0007a	01		 DB	 1
  0007b	01		 DB	 1
  0007c	01		 DB	 1
  0007d	01		 DB	 1
  0007e	01		 DB	 1
  0007f	00		 DB	 0
  00080	01		 DB	 1
  00081	00		 DB	 0
  00082	00		 DB	 0
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	01		 DB	 1
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	00		 DB	 0
  00090	00		 DB	 0
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	01		 DB	 1
  00098	01		 DB	 1
  00099	01		 DB	 1
  0009a	01		 DB	 1
  0009b	01		 DB	 1
  0009c	01		 DB	 1
  0009d	01		 DB	 1
  0009e	01		 DB	 1
  0009f	01		 DB	 1
  000a0	01		 DB	 1
  000a1	01		 DB	 1
  000a2	01		 DB	 1
  000a3	01		 DB	 1
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	01		 DB	 1
  000a7	01		 DB	 1
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	01		 DB	 1
  000ad	01		 DB	 1
  000ae	01		 DB	 1
  000af	01		 DB	 1
  000b0	01		 DB	 1
  000b1	01		 DB	 1
  000b2	01		 DB	 1
  000b3	01		 DB	 1
  000b4	01		 DB	 1
  000b5	01		 DB	 1
  000b6	01		 DB	 1
  000b7	01		 DB	 1
  000b8	01		 DB	 1
  000b9	01		 DB	 1
  000ba	01		 DB	 1
  000bb	01		 DB	 1
  000bc	01		 DB	 1
  000bd	01		 DB	 1
  000be	01		 DB	 1
  000bf	01		 DB	 1
  000c0	01		 DB	 1
  000c1	01		 DB	 1
  000c2	01		 DB	 1
  000c3	01		 DB	 1
  000c4	01		 DB	 1
  000c5	01		 DB	 1
  000c6	01		 DB	 1
  000c7	01		 DB	 1
  000c8	01		 DB	 1
  000c9	01		 DB	 1
  000ca	01		 DB	 1
  000cb	01		 DB	 1
  000cc	01		 DB	 1
  000cd	01		 DB	 1
  000ce	01		 DB	 1
  000cf	01		 DB	 1
  000d0	01		 DB	 1
  000d1	01		 DB	 1
  000d2	01		 DB	 1
  000d3	01		 DB	 1
  000d4	01		 DB	 1
  000d5	01		 DB	 1
  000d6	01		 DB	 1
  000d7	01		 DB	 1
  000d8	01		 DB	 1
  000d9	01		 DB	 1
  000da	01		 DB	 1
  000db	01		 DB	 1
  000dc	01		 DB	 1
  000dd	01		 DB	 1
  000de	01		 DB	 1
  000df	01		 DB	 1
  000e0	01		 DB	 1
  000e1	01		 DB	 1
  000e2	01		 DB	 1
  000e3	01		 DB	 1
  000e4	01		 DB	 1
  000e5	01		 DB	 1
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	01		 DB	 1
  000eb	01		 DB	 1
  000ec	01		 DB	 1
  000ed	01		 DB	 1
  000ee	01		 DB	 1
  000ef	01		 DB	 1
  000f0	01		 DB	 1
  000f1	01		 DB	 1
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	01		 DB	 1
  000ff	01		 DB	 1
  00100	01		 DB	 1
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	01		 DB	 1
  00106	01		 DB	 1
  00107	01		 DB	 1
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	01		 DB	 1
  00131	01		 DB	 1
  00132	01		 DB	 1
  00133	01		 DB	 1
  00134	01		 DB	 1
  00135	01		 DB	 1
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	00		 DB	 0
?DataEncryptCheck@@YAHHEH@Z ENDP			; DataEncryptCheck
_TEXT	ENDS
PUBLIC	??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?TestSend@@YAXXZ				; TestSend
;	COMDAT ??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@
CONST	SEGMENT
??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@ DB 'TEST Data Send', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TestSend@@YAXXZ
_TEXT	SEGMENT
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestSend@@YAXXZ PROC					; TestSend, COMDAT

; 1675 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 07 00
	00		 sub	 esp, 2008		; 000007d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1676 : 	PMSG_TEST pMsg;
; 1677 : 	int size = sizeof(pMsg);
; 1678 : 	pMsg.h.c = 0xC2;
; 1679 : 	pMsg.h.headcode = 0xFF;
; 1680 : 	pMsg.h.sizeH = SET_NUMBERH(size);
; 1681 : 	pMsg.h.sizeL = SET_NUMBERL(size);
; 1682 : 	DataSend( tempindex, (LPBYTE)&pMsg, size);

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?tempindex@@3HA ; tempindex
  00019	68 d4 07 00 00	 push	 2004			; 000007d4H
  0001e	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	c7 85 28 f8 ff
	ff c2 07 d4 ff	 mov	 DWORD PTR _pMsg$[ebp], -2881598 ; ffd407c2H
  00030	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1683 : 	DataSend( tempindex, (LPBYTE)&pMsg, size);

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tempindex@@3HA ; tempindex
  0003a	68 d4 07 00 00	 push	 2004			; 000007d4H
  0003f	8d 95 28 f8 ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1684 : 	LogAdd("TEST Data Send");

  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1685 : }

  00057	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?TestSend@@YAXXZ ENDP					; TestSend
_TEXT	ENDS
PUBLIC	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z		; MsgSendV2
; Function compile flags: /Ogtp
;	COMDAT ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Msg$ = 12						; size = 4
_size$ = 16						; size = 4
?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z PROC		; MsgSendV2, COMDAT

; 1688 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1689 : 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	57		 push	 edi
  0000c	81 c6 ac 08 00
	00		 add	 esi, 2220		; 000008acH
  00012	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
$LL5@MsgSendV2:

; 1690 : 	{
; 1691 : 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00017	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  0001b	75 17		 jne	 SHORT $LN4@MsgSendV2

; 1692 : 		{
; 1693 : 			if ( lpObj->VpPlayer2[n].state != 0 )

  0001d	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00020	74 12		 je	 SHORT $LN4@MsgSendV2

; 1694 : 			{
; 1695 : 				DataSend(lpObj->VpPlayer2[n].number, Msg, size);

  00022	8b 45 0c	 mov	 eax, DWORD PTR _Msg$[ebp]
  00025	0f bf 4e 02	 movsx	 ecx, WORD PTR [esi+2]
  00029	53		 push	 ebx
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@MsgSendV2:

; 1689 : 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00034	83 c6 0c	 add	 esi, 12			; 0000000cH
  00037	4f		 dec	 edi
  00038	75 dd		 jne	 SHORT $LL5@MsgSendV2
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx

; 1696 : 			}
; 1697 : 		}
; 1698 : 	}
; 1699 : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ENDP		; MsgSendV2
_TEXT	ENDS
PUBLIC	?EncryptCheckSumKey@@YAGG@Z			; EncryptCheckSumKey
EXTRN	_rand:PROC
; Function compile flags: /Ogtp
;	COMDAT ?EncryptCheckSumKey@@YAGG@Z
_TEXT	SEGMENT
_wSource$ = 8						; size = 2
?EncryptCheckSumKey@@YAGG@Z PROC			; EncryptCheckSumKey, COMDAT

; 1810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1811 : 	WORD wRandom = rand() % 64;

  00003	e8 00 00 00 00	 call	 _rand
  00008	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0000d	79 05		 jns	 SHORT $LN3@EncryptChe
  0000f	48		 dec	 eax
  00010	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00013	40		 inc	 eax
$LN3@EncryptChe:

; 1812 : 	WORD wAcc = ((wSource & 0x3F0) * 64) | (wRandom *16) | (wSource & 0x0F);

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _wSource$[ebp]
  00017	8b d1		 mov	 edx, ecx
  00019	81 e2 f0 03 00
	00		 and	 edx, 1008		; 000003f0H
  0001f	c1 e0 04	 shl	 eax, 4
  00022	c1 e2 06	 shl	 edx, 6
  00025	0b c2		 or	 eax, edx
  00027	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0002a	0b c1		 or	 eax, ecx

; 1813 : 	return wAcc ^ 0xB479;

  0002c	35 79 b4 00 00	 xor	 eax, 46201		; 0000b479H

; 1814 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?EncryptCheckSumKey@@YAGG@Z ENDP			; EncryptCheckSumKey
_TEXT	ENDS
PUBLIC	??_C@_0BO@GADPEFGJ@Welcome?5?$FLuser?3?5?$CFs?5Lv?$CFd?$FN?5to?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Exe@ ; `string'
PUBLIC	??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41?$AA@		; `string'
PUBLIC	?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
EXTRN	?UserConnect@Brotherhood@@QAEXH@Z:PROC		; Brotherhood::UserConnect
EXTRN	?gBrotherhood@@3VBrotherhood@@A:BYTE		; gBrotherhood
EXTRN	?UserStart@cBloodHound@@QAEXH@Z:PROC		; cBloodHound::UserStart
EXTRN	?BloodHound@@3VcBloodHound@@A:BYTE		; BloodHound
EXTRN	?g_ZtLicense@@3VCZtLicense@@A:BYTE		; g_ZtLicense
EXTRN	?MsgNormal@@YAXHPADZZ:PROC			; MsgNormal
EXTRN	?ztMapName@@YAPADH@Z:PROC			; ztMapName
EXTRN	?ConnectInfo@PremiumSystem@@QAEXH@Z:PROC	; PremiumSystem::ConnectInfo
EXTRN	?Premium@@3VPremiumSystem@@A:BYTE		; Premium
EXTRN	?ExPlayerConnectSystem@@YAXH@Z:PROC		; ExPlayerConnectSystem
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?dwgCheckSum@@3PAKA:BYTE			; dwgCheckSum
EXTRN	?ZtConfig@@3VcZtConfigs@@A:BYTE			; ZtConfig
;	COMDAT ??_C@_0BO@GADPEFGJ@Welcome?5?$FLuser?3?5?$CFs?5Lv?$CFd?$FN?5to?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BO@GADPEFGJ@Welcome?5?$FLuser?3?5?$CFs?5Lv?$CFd?$FN?5to?5?$CFs?$AA@ DB 'W'
	DB	'elcome [user: %s Lv%d] to %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Exe@
CONST	SEGMENT
??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Exe@ DB 'e'
	DB	'rror-L1 : [%s][%s] CheckSum-Exe error ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CFd@
CONST	SEGMENT
??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CFd@ DB 'error-'
	DB	'L1 : CheckSum-Exe error %d %d %d [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41?$AA@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41?$AA@ DB '127.0.0.1', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z PROC ; CGCheckMainRecv, COMDAT

; 1817 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1818 : #if(REMOVE_CHECKSUM == 1)
; 1819 : 	gObj[aIndex].CheckSumTime = 0;
; 1820 : 		gObj[aIndex].m_InWebzen = true;
; 1821 : 		return;
; 1822 : #endif
; 1823 : 	//int EnableCheckSum = GetPrivateProfileInt("Common","CheckSum",0,"..\\Data\\ZtData\\CommonServer.ini");
; 1824 : 	if(ZtConfig.CommonServer.EnableCheckSum)

  00003	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+40, 0
  0000a	53		 push	 ebx

; 1825 : 	{
; 1826 : 		if ( strcmp(gObj[aIndex].Ip_addr, "127.0.0.1") == 0 )

  0000b	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00016	0f 84 ca 00 00
	00		 je	 $LN22@CGCheckMai
  0001c	8b c3		 mov	 eax, ebx
  0001e	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00024	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_09PFCHIMEP@127?40?40?41?$AA@
  00029	8d 4c 38 18	 lea	 ecx, DWORD PTR [eax+edi+24]
  0002d	8d 49 00	 npad	 3
$LL17@CGCheckMai:
  00030	8a 11		 mov	 dl, BYTE PTR [ecx]
  00032	3a 16		 cmp	 dl, BYTE PTR [esi]
  00034	75 1a		 jne	 SHORT $LN18@CGCheckMai
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN19@CGCheckMai
  0003a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0003d	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  00040	75 0e		 jne	 SHORT $LN18@CGCheckMai
  00042	83 c1 02	 add	 ecx, 2
  00045	83 c6 02	 add	 esi, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL17@CGCheckMai
$LN19@CGCheckMai:
  0004c	33 c9		 xor	 ecx, ecx
  0004e	eb 05		 jmp	 SHORT $LN20@CGCheckMai
$LN18@CGCheckMai:
  00050	1b c9		 sbb	 ecx, ecx
  00052	83 d9 ff	 sbb	 ecx, -1
$LN20@CGCheckMai:
  00055	85 c9		 test	 ecx, ecx
  00057	75 17		 jne	 SHORT $LN11@CGCheckMai

; 1827 : 		{
; 1828 : 			gObj[aIndex].CheckSumTime = 0;

  00059	89 4c 38 64	 mov	 DWORD PTR [eax+edi+100], ecx

; 1829 : 			gObj[aIndex].m_InWebzen = true;

  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	c6 84 08 e5 10
	00 00 01	 mov	 BYTE PTR [eax+ecx+4325], 1
  0006d	5b		 pop	 ebx

; 1882 : #endif
; 1883 : }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN11@CGCheckMai:

; 1830 : 			return;
; 1831 : 		}
; 1832 : 
; 1833 : 		if ( gObj[aIndex].CheckSumTableNum < 0 || gObj[aIndex].CheckSumTableNum > MAX_CHECKSUM_KEY-1 )

  00070	0f b7 4c 38 60	 movzx	 ecx, WORD PTR [eax+edi+96]
  00075	66 85 c9	 test	 cx, cx
  00078	78 49		 js	 SHORT $LN9@CGCheckMai
  0007a	ba ff 03 00 00	 mov	 edx, 1023		; 000003ffH
  0007f	66 3b ca	 cmp	 cx, dx
  00082	7f 3f		 jg	 SHORT $LN9@CGCheckMai

; 1837 : 			return;
; 1838 : 		}
; 1839 : 
; 1840 : 		if ( dwgCheckSum[gObj[aIndex].CheckSumTableNum] != lpMsg->m_dwKey)

  00084	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00087	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0008a	0f bf c9	 movsx	 ecx, cx
  0008d	39 14 8d 00 00
	00 00		 cmp	 DWORD PTR ?dwgCheckSum@@3PAKA[ecx*4], edx
  00094	74 50		 je	 SHORT $LN22@CGCheckMai

; 1841 : 		{
; 1842 : 			LogAddTD("error-L1 : CheckSum-Exe error %d %d %d [%s]", dwgCheckSum[gObj[aIndex].CheckSumTableNum],
; 1843 : 				lpMsg->m_dwKey, gObj[aIndex].CheckSumTableNum, gObj[aIndex].AccountID);

  00096	0f bf 4c 38 60	 movsx	 ecx, WORD PTR [eax+edi+96]
  0009b	8d 44 38 6c	 lea	 eax, DWORD PTR [eax+edi+108]
  0009f	50		 push	 eax
  000a0	51		 push	 ecx
  000a1	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?dwgCheckSum@@3PAKA[ecx*4]
  000a8	52		 push	 edx
  000a9	51		 push	 ecx
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CFd@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1844 : 			CloseClient(aIndex);

  000b5	53		 push	 ebx
  000b6	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000bb	83 c4 18	 add	 esp, 24			; 00000018H
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx

; 1882 : #endif
; 1883 : }

  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN9@CGCheckMai:

; 1834 : 		{
; 1835 : 			LogAdd("error-L1 : [%s][%s] CheckSum-Exe error ", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000c3	8d 54 38 77	 lea	 edx, DWORD PTR [eax+edi+119]
  000c7	52		 push	 edx
  000c8	8d 44 38 6c	 lea	 eax, DWORD PTR [eax+edi+108]
  000cc	50		 push	 eax
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Exe@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1836 : 			CloseClient(aIndex);

  000d8	53		 push	 ebx
  000d9	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000de	83 c4 10	 add	 esp, 16			; 00000010H
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 1882 : #endif
; 1883 : }

  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN22@CGCheckMai:

; 1845 : 			return;
; 1846 : 		}
; 1847 : 	}
; 1848 : 
; 1849 : 	gObj[aIndex].CheckSumTime = 0;

  000e6	8b c3		 mov	 eax, ebx
  000e8	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000ee	c7 44 38 64 00
	00 00 00	 mov	 DWORD PTR [eax+edi+100], 0

; 1850 : 	//Connect Game
; 1851 : 	LPOBJ lpObj = &gObj[aIndex];

  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1852 : 	ExPlayerConnectSystem(aIndex);

  000fc	53		 push	 ebx
  000fd	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00100	e8 00 00 00 00	 call	 ?ExPlayerConnectSystem@@YAXH@Z ; ExPlayerConnectSystem
  00105	83 c4 04	 add	 esp, 4

; 1853 : 	Premium.ConnectInfo(aIndex);

  00108	53		 push	 ebx
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?Premium@@3VPremiumSystem@@A ; Premium
  0010e	e8 00 00 00 00	 call	 ?ConnectInfo@PremiumSystem@@QAEXH@Z ; PremiumSystem::ConnectInfo

; 1854 : 
; 1855 : #if(LICENSE_UKRAINE)
; 1856 : 	if(lpObj->Level == 1)

  00113	66 83 bf be 00
	00 00 01	 cmp	 WORD PTR [edi+190], 1
  0011b	75 61		 jne	 SHORT $LN4@CGCheckMai

; 1857 : 	{
; 1858 : 		for ( int n = OBJ_STARTUSERINDZT ; n < OBJMAX ; n++)

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	bb b0 36 00 00	 mov	 ebx, 14000		; 000036b0H
  00127	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  0012c	8d 64 24 00	 npad	 4
$LL6@CGCheckMai:

; 1859 : 		{
; 1860 : 			if ( gObj[n].Type == OBJ_USER && gObj[n].Connected == PLAYER_PLAYING )

  00130	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00136	75 34		 jne	 SHORT $LN5@CGCheckMai
  00138	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0013d	75 2d		 jne	 SHORT $LN5@CGCheckMai

; 1861 : 			{
; 1862 : 				MsgNormal(n, "Welcome [user: %s Lv%d] to %s", lpObj->Name, lpObj->Level, ztMapName(lpObj->MapNumber));	

  0013f	0f b6 97 49 01
	00 00		 movzx	 edx, BYTE PTR [edi+329]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ?ztMapName@@YAPADH@Z	; ztMapName
  0014c	50		 push	 eax
  0014d	0f bf 87 be 00
	00 00		 movsx	 eax, WORD PTR [edi+190]
  00154	50		 push	 eax
  00155	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  00158	51		 push	 ecx
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GADPEFGJ@Welcome?5?$FLuser?3?5?$CFs?5Lv?$CFd?$FN?5to?5?$CFs?$AA@
  0015e	53		 push	 ebx
  0015f	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00169	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@CGCheckMai:

; 1857 : 	{
; 1858 : 		for ( int n = OBJ_STARTUSERINDZT ; n < OBJMAX ; n++)

  0016c	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00172	43		 inc	 ebx
  00173	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00179	7c b5		 jl	 SHORT $LL6@CGCheckMai
  0017b	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
$LN4@CGCheckMai:

; 1863 : 			}
; 1864 : 		}
; 1865 : 	}
; 1866 : #endif
; 1867 : 
; 1868 : 	//gRanking.SendUser(aIndex);
; 1869 : 
; 1870 : 	if(g_ZtLicense.user.BloodHound)

  0017e	80 3d cf 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+207, 0
  00185	74 0b		 je	 SHORT $LN2@CGCheckMai

; 1871 : 	{
; 1872 : 		BloodHound.UserStart(aIndex);

  00187	53		 push	 ebx
  00188	b9 00 00 00 00	 mov	 ecx, OFFSET ?BloodHound@@3VcBloodHound@@A ; BloodHound
  0018d	e8 00 00 00 00	 call	 ?UserStart@cBloodHound@@QAEXH@Z ; cBloodHound::UserStart
$LN2@CGCheckMai:

; 1873 : 	}
; 1874 : //#ifdef PRIVATE_MODULE
; 1875 : 	if(g_ZtLicense.user.MonsterQuest)
; 1876 : 	{
; 1877 : 		//gMonsterQuest.GCConnectUser(aIndex);
; 1878 : 	}
; 1879 : //#endif
; 1880 : #if(SYSTEMOF_BROTHER==TRUE)
; 1881 : 	gBrotherhood.UserConnect(aIndex);

  00192	53		 push	 ebx
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBrotherhood@@3VBrotherhood@@A ; gBrotherhood
  00198	e8 00 00 00 00	 call	 ?UserConnect@Brotherhood@@QAEXH@Z ; Brotherhood::UserConnect
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx

; 1882 : #endif
; 1883 : }

  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ENDP ; CGCheckMainRecv
_TEXT	ENDS
PUBLIC	?PEchoProc@@YAXPAEHF@Z				; PEchoProc
; Function compile flags: /Ogtp
;	COMDAT ?PEchoProc@@YAXPAEHF@Z
_TEXT	SEGMENT
_aMsg$ = 8						; size = 4
_aLen$ = 12						; size = 4
_aIndex$ = 16						; size = 2
?PEchoProc@@YAXPAEHF@Z PROC				; PEchoProc, COMDAT

; 1886 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1887 : 	for ( int n = 0 ; n< OBJMAX ; n++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aLen$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	33 f6		 xor	 esi, esi
  0000d	8d 49 00	 npad	 3
$LL4@PEchoProc:

; 1888 : 	{
; 1889 : 		if ( gObj[n].Connected >= PLAYER_CONNECTED )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  0001a	7c 0e		 jl	 SHORT $LN3@PEchoProc

; 1890 : 		{
; 1891 : 			DataSend(n, aMsg, aLen);

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _aMsg$[ebp]
  0001f	53		 push	 ebx
  00020	51		 push	 ecx
  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@PEchoProc:

; 1887 : 	for ( int n = 0 ; n< OBJMAX ; n++)

  0002a	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00030	47		 inc	 edi
  00031	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00037	7c d7		 jl	 SHORT $LL4@PEchoProc
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 1892 : 		}
; 1893 : 	}
; 1894 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?PEchoProc@@YAXPAEHF@Z ENDP				; PEchoProc
_TEXT	ENDS
PUBLIC	?GCResultSend@@YAXHEE@Z				; GCResultSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
; Function compile flags: /Ogtp
;	COMDAT ?GCResultSend@@YAXHEE@Z
_TEXT	SEGMENT
_pResult$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_headcode$ = 12						; size = 1
_result$ = 16						; size = 1
?GCResultSend@@YAXHEE@Z PROC				; GCResultSend, COMDAT

; 1897 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1898 : 	PMSG_DEFRESULT pResult;
; 1899 : 
; 1900 : 	PHeadSetB((LPBYTE)&pResult, headcode, sizeof(pResult));

  00004	8b 45 0c	 mov	 eax, DWORD PTR _headcode$[ebp]
  00007	6a 04		 push	 4
  00009	50		 push	 eax
  0000a	8d 4d fc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1901 : 	pResult.result = result;
; 1902 : 	
; 1903 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00013	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00017	8a 55 10	 mov	 dl, BYTE PTR _result$[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0001e	88 55 ff	 mov	 BYTE PTR _pResult$[ebp+3], dl
  00021	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00024	51		 push	 ecx
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 1904 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?GCResultSend@@YAXHEE@Z ENDP				; GCResultSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z		; ChatSend
; Function compile flags: /Ogtp
;	COMDAT ?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_pMsg$ = -100						; size = 94
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z PROC		; ChatSend, COMDAT

; 1907 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _szChat$[ebp]

; 1908 : 	int len = strlen(szChat);

  00014	8b c6		 mov	 eax, esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001d	8d 49 00	 npad	 3
$LL7@ChatSend:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL7@ChatSend
  00027	2b c2		 sub	 eax, edx

; 1909 : 
; 1910 : 	if ( len < 1 )

  00029	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0002c	83 f9 57	 cmp	 ecx, 87			; 00000057H
  0002f	77 48		 ja	 SHORT $LN3@ChatSend

; 1911 : 		return;
; 1912 : 
; 1913 : 	if ( len > MAX_CHAT_LEN-1 )
; 1914 : 		return;
; 1915 : 
; 1916 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1917 : 
; 1918 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00031	83 c0 06	 add	 eax, 6
  00034	50		 push	 eax
  00035	8d 55 9c	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00038	6a 01		 push	 1
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1919 : 	strcpy(pMsg.chatmsg, szChat);

  00040	8d 55 a1	 lea	 edx, DWORD PTR _pMsg$[ebp+5]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	8b c6		 mov	 eax, esi
  00048	2b d6		 sub	 edx, esi
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL5@ChatSend:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00055	40		 inc	 eax
  00056	84 c9		 test	 cl, cl
  00058	75 f6		 jne	 SHORT $LL5@ChatSend

; 1920 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0005a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1921 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 1922 : 
; 1923 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  0005c	0f b6 55 9d	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00060	8a 0f		 mov	 cl, BYTE PTR [edi]
  00062	c1 e8 08	 shr	 eax, 8
  00065	88 45 9f	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00068	52		 push	 edx
  00069	8d 45 9c	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006c	50		 push	 eax
  0006d	57		 push	 edi
  0006e	88 4d a0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00071	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@ChatSend:

; 1924 : }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	5f		 pop	 edi
  0007d	33 cd		 xor	 ecx, ebp
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z ENDP		; ChatSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ		; vChatSend
EXTRN	_vsprintf:PROC
; Function compile flags: /Ogtp
;	COMDAT ?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ
_TEXT	SEGMENT
_pMsg$ = -356						; size = 94
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ PROC		; vChatSend, COMDAT

; 1927 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 1928 : 	char szBuffer[256] = "";

  00017	68 ff 00 00 00	 push	 255			; 000000ffH
  0001c	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR _szBuffer$[ebp], 0
  0002c	e8 00 00 00 00	 call	 _memset

; 1929 : 	va_list pArguments;
; 1930 : 
; 1931 : 	va_start(pArguments, szChat);
; 1932 : 	vsprintf(szBuffer, szChat, pArguments);

  00031	8b 55 0c	 mov	 edx, DWORD PTR _szChat$[ebp]
  00034	8d 4d 10	 lea	 ecx, DWORD PTR _szChat$[ebp+4]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _vsprintf

; 1933 : 	va_end(pArguments);
; 1934 : 
; 1935 : 	int len = strlen(szBuffer);

  00045	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0004b	83 c4 18	 add	 esp, 24			; 00000018H
  0004e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL7@vChatSend:
  00051	8a 08		 mov	 cl, BYTE PTR [eax]
  00053	40		 inc	 eax
  00054	84 c9		 test	 cl, cl
  00056	75 f9		 jne	 SHORT $LL7@vChatSend
  00058	2b c2		 sub	 eax, edx

; 1936 : 
; 1937 : 	if ( len < 1 )

  0005a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0005d	83 f9 57	 cmp	 ecx, 87			; 00000057H
  00060	77 5c		 ja	 SHORT $LN3@vChatSend

; 1938 : 		return;
; 1939 : 
; 1940 : 	if ( len > MAX_CHAT_LEN-1 )
; 1941 : 		return;
; 1942 : 
; 1943 : 
; 1944 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1945 : 
; 1946 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00062	83 c0 06	 add	 eax, 6
  00065	50		 push	 eax
  00066	8d 95 9c fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  0006c	6a 01		 push	 1
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1947 : 	strcpy(pMsg.chatmsg, szBuffer);

  00077	33 c0		 xor	 eax, eax
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL5@vChatSend:
  00080	8a 8c 05 fc fe
	ff ff		 mov	 cl, BYTE PTR _szBuffer$[ebp+eax]
  00087	88 8c 05 a1 fe
	ff ff		 mov	 BYTE PTR _pMsg$[ebp+eax+5], cl
  0008e	40		 inc	 eax
  0008f	84 c9		 test	 cl, cl
  00091	75 ed		 jne	 SHORT $LL5@vChatSend

; 1948 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00093	8b 06		 mov	 eax, DWORD PTR [esi]

; 1949 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 1950 : 
; 1951 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00095	0f b6 95 9d fe
	ff ff		 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0009c	8a 0e		 mov	 cl, BYTE PTR [esi]
  0009e	c1 e8 08	 shr	 eax, 8
  000a1	88 85 9f fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], al
  000a7	52		 push	 edx
  000a8	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	88 8d a0 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl
  000b6	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@vChatSend:

; 1952 : }

  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5e		 pop	 esi
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ ENDP		; vChatSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?AllSendServerMsg@@YAXPAD@Z			; AllSendServerMsg
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
; Function compile flags: /Ogtp
;	COMDAT ?AllSendServerMsg@@YAXPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_chatmsg$ = 8						; size = 4
?AllSendServerMsg@@YAXPAD@Z PROC			; AllSendServerMsg, COMDAT

; 1955 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _chatmsg$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 1956 : #if(ENABLE_TEXTCHANGE)
; 1957 : 	if(g_ZtLicense.CheckUser(eZtUB::masonX) || g_ZtLicense.CheckUser(eZtUB::Local))
; 1958 : 	{
; 1959 : 		chatmsg = g_Text.Change(chatmsg);
; 1960 : 	}
; 1961 : #endif
; 1962 : 
; 1963 : 	PMSG_NOTICE pNotice;
; 1964 : 	
; 1965 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, 0x00,  chatmsg);

  00018	50		 push	 eax
  00019	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 1968 : 	{
; 1969 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00034	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL5@AllSendSer:
  00040	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00045	75 25		 jne	 SHORT $LN4@AllSendSer

; 1970 : 		{
; 1971 : 			if ( gObj[n].Type == OBJ_USER )

  00047	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  0004d	75 1d		 jne	 SHORT $LN4@AllSendSer

; 1972 : 			{
; 1973 : 				DataSend(n, (LPBYTE)&pNotice , pNotice.h.size );

  0004f	0f b6 8d ed fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$[ebp+1]
  00056	51		 push	 ecx
  00057	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  0005d	52		 push	 edx
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@AllSendSer:

; 1966 : 
; 1967 : 	for ( int n = OBJ_STARTUSERINDZT ; n < OBJMAX ; n++)

  0006c	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00072	47		 inc	 edi
  00073	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00079	7c c5		 jl	 SHORT $LL5@AllSendSer

; 1974 : 			}
; 1975 : 		}
; 1976 : 	}
; 1977 : }

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	5f		 pop	 edi
  0007f	33 cd		 xor	 ecx, ebp
  00081	5e		 pop	 esi
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?AllSendServerMsg@@YAXPAD@Z ENDP			; AllSendServerMsg
_TEXT	ENDS
PUBLIC	?DataSendAll@@YAXPAEH@Z				; DataSendAll
; Function compile flags: /Ogtp
;	COMDAT ?DataSendAll@@YAXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iMsgSize$ = 12						; size = 4
?DataSendAll@@YAXPAEH@Z PROC				; DataSendAll, COMDAT

; 1980 : {			

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1981 : 	for ( int n = OBJ_STARTUSERINDZT ; n < OBJMAX ; n++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _iMsgSize$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00013	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL5@DataSendAl:

; 1982 : 	{
; 1983 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 1b		 jne	 SHORT $LN4@DataSendAl

; 1984 : 		{
; 1985 : 			if ( gObj[n].Type == OBJ_USER )

  0001f	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00025	75 13		 jne	 SHORT $LN4@DataSendAl

; 1986 : 			{
; 1987 : 				DataSend(n, (LPBYTE)lpMsg , iMsgSize );

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002a	53		 push	 ebx
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@DataSendAl:

; 1981 : 	for ( int n = OBJ_STARTUSERINDZT ; n < OBJMAX ; n++)

  0003a	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00040	47		 inc	 edi
  00041	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00047	7c cf		 jl	 SHORT $LL5@DataSendAl
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1988 : 			}
; 1989 : 		}
; 1990 : 	}
; 1991 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?DataSendAll@@YAXPAEH@Z ENDP				; DataSendAll
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z	; ChatTargetSend
; Function compile flags: /Ogtp
;	COMDAT ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z
_TEXT	SEGMENT
_pMsg$ = -100						; size = 94
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
_senduser$ = 16						; size = 4
?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z PROC	; ChatTargetSend, COMDAT

; 1994 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _szChat$[ebp]

; 1995 : 	int len = strlen(szChat);

  00018	8b c6		 mov	 eax, esi
  0001a	57		 push	 edi
  0001b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001e	8b ff		 npad	 2
$LL7@ChatTarget:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL7@ChatTarget
  00027	2b c2		 sub	 eax, edx
  00029	8b f8		 mov	 edi, eax

; 1996 : 
; 1997 : 	if ( len < 1 || len > MAX_CHAT_LEN-1)

  0002b	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0002e	83 f8 57	 cmp	 eax, 87			; 00000057H
  00031	77 4e		 ja	 SHORT $LN1@ChatTarget

; 1998 : 		return;
; 1999 : 
; 2000 : 
; 2001 : 	PMSG_CHATDATA_NUMBER pMsg;
; 2002 : 
; 2003 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00033	8d 4f 06	 lea	 ecx, DWORD PTR [edi+6]
  00036	51		 push	 ecx
  00037	8d 55 9c	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0003a	6a 01		 push	 1
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2004 : 	strcpy(pMsg.chatmsg, szChat);

  00042	8d 55 a1	 lea	 edx, DWORD PTR _pMsg$[ebp+5]
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	8b c6		 mov	 eax, esi
  0004a	2b d6		 sub	 edx, esi
  0004c	8d 64 24 00	 npad	 4
$LL5@ChatTarget:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00055	40		 inc	 eax
  00056	84 c9		 test	 cl, cl
  00058	75 f6		 jne	 SHORT $LL5@ChatTarget

; 2005 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0005a	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2006 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  0005c	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0005e	c1 e8 08	 shr	 eax, 8
  00061	88 45 9f	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00064	88 4d a0	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 2007 : 	pMsg.chatmsg[len+1] = 0;
; 2008 : 
; 2009 : 	DataSend(senduser, (LPBYTE)&pMsg, pMsg.h.size);

  00067	8b 4d 10	 mov	 ecx, DWORD PTR _senduser$[ebp]
  0006a	c6 44 3d a2 00	 mov	 BYTE PTR _pMsg$[ebp+edi+6], 0
  0006f	0f b6 55 9d	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00073	52		 push	 edx
  00074	8d 45 9c	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00077	50		 push	 eax
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ChatTarget:

; 2010 : }

  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	33 cd		 xor	 ecx, ebp
  00088	5b		 pop	 ebx
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ENDP	; ChatTargetSend
_TEXT	ENDS
PUBLIC	?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z	; CGChatRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z PROC	; CGChatRecv, COMDAT

; 2595 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2596 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00010	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2597 : 
; 2598 : 	if ( PacketCheckTime(lpObj) == FALSE )

  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	74 20		 je	 SHORT $LN2@CGChatRecv

; 2599 : 	{
; 2600 : 		return;
; 2601 : 	}
; 2602 : 
; 2603 : 	DataSend(aIndex, (LPBYTE)lpMsg, lpMsg->h.size);

  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00027	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	53		 push	 ebx
  0002e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2604 : 	MsgSendV2(lpObj, (LPBYTE)lpMsg, lpMsg->h.size);

  00033	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  00037	51		 push	 ecx
  00038	57		 push	 edi
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0003f	83 c4 18	 add	 esp, 24			; 00000018H
  00042	5f		 pop	 edi
$LN2@CGChatRecv:
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2605 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ENDP	; CGChatRecv
_TEXT	ENDS
PUBLIC	?GCServerMsgSend@@YAXEH@Z			; GCServerMsgSend
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgSend@@YAXEH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_msg$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCServerMsgSend@@YAXEH@Z PROC				; GCServerMsgSend, COMDAT

; 2608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2609 : 	PMSG_SERVERMSG pMsg;
; 2610 : 
; 2611 : 	PHeadSetB((LPBYTE)&pMsg, 0x0C, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2612 : 	pMsg.MsgNumber = msg;
; 2613 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 08	 mov	 cl, BYTE PTR _msg$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 2614 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCServerMsgSend@@YAXEH@Z ENDP				; GCServerMsgSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCServerMsgStringSend@@YAXPADHE@Z		; GCServerMsgStringSend
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgStringSend@@YAXPADHE@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_szMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSend@@YAXPADHE@Z PROC			; GCServerMsgStringSend, COMDAT

; 2617 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _szMsg$[ebp]

; 2618 : #if(ENABLE_CHANGE)
; 2619 : 	szMsg = g_Text.Change(szMsg);
; 2620 : #endif
; 2621 : 
; 2622 : 	PMSG_NOTICE pNotice;
; 2623 : 	
; 2624 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, type, szMsg);

  00016	50		 push	 eax
  00017	8b 45 10	 mov	 eax, DWORD PTR _type$[ebp]
  0001a	50		 push	 eax
  0001b	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 2625 : 	DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00027	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _pNotice$[ebp+1]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00031	52		 push	 edx
  00032	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00038	50		 push	 eax
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2626 : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GCServerMsgStringSend@@YAXPADHE@Z ENDP			; GCServerMsgStringSend
_TEXT	ENDS
PUBLIC	?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z
_TEXT	SEGMENT
_lpNode$ = 8						; size = 4
_szMsg$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z PROC ; GCServerMsgStringSendGuild, COMDAT

; 2629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2630 : 	if ( lpNode == NULL )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpNode$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	74 3b		 je	 SHORT $LN2@GCServerMs

; 2631 : 	{
; 2632 : 		return;
; 2633 : 	}
; 2634 : 
; 2635 : 	for ( int n = 0; n<MAX_USER_GUILD ; n++)

  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	8d bb a0 03 00
	00		 lea	 edi, DWORD PTR [ebx+928]
$LL10@GCServerMs:

; 2636 : 	{
; 2637 : 		if (lpNode->Use[n] > 0 && lpNode->Index[n] >= 0 )

  00015	80 bc 33 40 04
	00 00 00	 cmp	 BYTE PTR [ebx+esi+1088], 0
  0001d	76 1c		 jbe	 SHORT $LN3@GCServerMs
  0001f	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00022	66 85 c0	 test	 ax, ax
  00025	78 14		 js	 SHORT $LN3@GCServerMs

; 2638 : 		{
; 2639 : 			GCServerMsgStringSend((char*)szMsg, lpNode->Index[n], type);

  00027	8b 4d 10	 mov	 ecx, DWORD PTR _type$[ebp]
  0002a	0f bf d0	 movsx	 edx, ax
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _szMsg$[ebp]
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCServerMs:

; 2631 : 	{
; 2632 : 		return;
; 2633 : 	}
; 2634 : 
; 2635 : 	for ( int n = 0; n<MAX_USER_GUILD ; n++)

  0003b	46		 inc	 esi
  0003c	83 c7 02	 add	 edi, 2
  0003f	83 fe 50	 cmp	 esi, 80			; 00000050H
  00042	7c d1		 jl	 SHORT $LL10@GCServerMs
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
$LN2@GCServerMs:
  00046	5b		 pop	 ebx

; 2640 : 		}
; 2641 : 	}
; 2642 : }

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ENDP ; GCServerMsgStringSendGuild
_TEXT	ENDS
PUBLIC	?GCEventStateSend@@YAXHEE@Z			; GCEventStateSend
; Function compile flags: /Ogtp
;	COMDAT ?GCEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCEventStateSend@@YAXHEE@Z PROC			; GCEventStateSend, COMDAT

; 2645 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2646 : 	PMSG_EVENT pMsg;
; 2647 : 
; 2648 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 0b		 push	 11			; 0000000bH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2649 : 	pMsg.Event = event;
; 2650 : 	pMsg.State = state;
; 2651 : 
; 2652 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00013	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00017	8a 4d 10	 mov	 cl, BYTE PTR _event$[ebp]
  0001a	8a 55 0c	 mov	 dl, BYTE PTR _state$[ebp]
  0001d	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00020	50		 push	 eax
  00021	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00024	88 55 fb	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  00027	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 18	 add	 esp, 24			; 00000018H

; 2653 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?GCEventStateSend@@YAXHEE@Z ENDP			; GCEventStateSend
_TEXT	ENDS
PUBLIC	?GCMapEventStateSend@@YAXHEE@Z			; GCMapEventStateSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMapEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_map$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCMapEventStateSend@@YAXHEE@Z PROC			; GCMapEventStateSend, COMDAT

; 2656 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 2657 : 	PMSG_EVENT pMsg;
; 2658 : 
; 2659 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof(pMsg));

  00008	6a 05		 push	 5
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 0b		 push	 11			; 0000000bH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2660 : 	pMsg.Event = event;

  00015	8a 4d 10	 mov	 cl, BYTE PTR _event$[ebp]

; 2661 : 	pMsg.State = state;

  00018	8a 55 0c	 mov	 dl, BYTE PTR _state$[ebp]
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2662 : 
; 2663 : 	for ( int n=0; n<OBJMAX ; n++ )

  00023	33 ff		 xor	 edi, edi
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	88 55 fb	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  0002b	33 f6		 xor	 esi, esi
  0002d	8d 49 00	 npad	 3
$LL4@GCMapEvent:

; 2664 : 	{
; 2665 : 		if ( gObj[n].Connected == PLAYER_PLAYING && gObj[n].Type == OBJ_USER && map == gObj[n].MapNumber )

  00030	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00035	75 2c		 jne	 SHORT $LN3@GCMapEvent
  00037	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  0003d	75 24		 jne	 SHORT $LN3@GCMapEvent
  0003f	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00047	39 4d 08	 cmp	 DWORD PTR _map$[ebp], ecx
  0004a	75 17		 jne	 SHORT $LN3@GCMapEvent

; 2666 : 		{
; 2667 : 			DataSend(n, (LPBYTE)&pMsg, pMsg.h.size);

  0004c	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00050	52		 push	 edx
  00051	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00054	50		 push	 eax
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCMapEvent:

; 2662 : 
; 2663 : 	for ( int n=0; n<OBJMAX ; n++ )

  00063	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00069	47		 inc	 edi
  0006a	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00070	7c be		 jl	 SHORT $LL4@GCMapEvent
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 2668 : 		}
; 2669 : 	}
; 2670 : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?GCMapEventStateSend@@YAXHEE@Z ENDP			; GCMapEventStateSend
_TEXT	ENDS
PUBLIC	??_C@_0BL@NBANGCOJ@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?9?$DO?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BB@PAAPNLIE@?$FLBanChat?$FN?5?$CFd?5Sec?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	?gWriteChatLog@@3HA:DWORD			; gWriteChatLog
EXTRN	?MessageSendEx@@YAXHHPAD0ZZ:PROC		; MessageSendEx
EXTRN	?AddCash@CWhisperCash@@QAEHPAD@Z:PROC		; CWhisperCash::AddCash
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?CheckSyntax@CChatFilter@@QAEXHPAD@Z:PROC	; CChatFilter::CheckSyntax
EXTRN	?g_ChatFilter@@3VCChatFilter@@A:BYTE		; g_ChatFilter
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
;	COMDAT ??_C@_0BL@NBANGCOJ@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?9?$DO?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?3?5?$CFs?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0BL@NBANGCOJ@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?9?$DO?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?3?5?$CFs?$AA@ DB '['
	DB	'%s] [%s] -> [%s] [%s]: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PAAPNLIE@?$FLBanChat?$FN?5?$CFd?5Sec?$AA@
CONST	SEGMENT
??_C@_0BB@PAAPNLIE@?$FLBanChat?$FN?5?$CFd?5Sec?$AA@ DB '[BanChat] %d Sec', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z
_TEXT	SEGMENT
tv224 = -132						; size = 4
_index$ = -128						; size = 4
tv234 = -124						; size = 4
_pWhisper$ = -120					; size = 102
_tid$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z PROC ; CGChatWhisperRecv, COMDAT

; 2673 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 2674 : 	char tid[11];
; 2675 : 	PMSG_CHATDATA_WHISPER pWhisper;
; 2676 : 	int len;
; 2677 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b de		 mov	 ebx, esi
  0001a	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00020	89 9d 7c ff ff
	ff		 mov	 DWORD PTR tv224[ebp], ebx
  00026	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	57		 push	 edi
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 2678 : 	int index;
; 2679 : 
; 2680 : 	if ( PacketCheckTime(lpObj) == FALSE )

  00030	53		 push	 ebx
  00031	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00036	83 c4 04	 add	 esp, 4
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 a0 01 00
	00		 je	 $LN1@CGChatWhis

; 2681 : 	{
; 2682 : 		return;
; 2683 : 	}
; 2684 : 
; 2685 : 	if ( lpObj->ChatLitmitTime > 0 )

  00041	0f b7 83 1c 01
	00 00		 movzx	 eax, WORD PTR [ebx+284]
  00048	66 85 c0	 test	 ax, ax
  0004b	74 2d		 je	 SHORT $LN6@CGChatWhis

; 2686 : 	{
; 2687 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(4, 223)), lpObj->ChatLitmitTime);

  0004d	50		 push	 eax
  0004e	68 df 04 00 00	 push	 1247			; 000004dfH
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00058	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0005d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0005f	50		 push	 eax
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx

; 2735 : 		}
; 2736 : #endif
; 2737 : 
; 2738 : 		CHAT_LOG_DATA pChatMsg;
; 2739 : 		int szTargetNameCount = 0;
; 2740 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2741 : 		if ( gWriteChatLog != FALSE )
; 2742 : 		{
; 2743 : 			pChatMsg.h.c = 0xC1;
; 2744 : 			pChatMsg.h.headcode = 0x02;
; 2745 : 			memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 2746 : 			memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_ACCOUNT_LEN);
; 2747 : 			pChatMsg.AccountID[MAX_ACCOUNT_LEN] = 0;
; 2748 : 			pChatMsg.Name[MAX_ACCOUNT_LEN] = 0;
; 2749 : 			pChatMsg.wServer = gGameServerCode;
; 2750 : 			memcpy(pChatMsg.szChatMsg, lpMsg->chatmsg, MAX_CHAT_LEN);
; 2751 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2752 : 			pChatMsg.btType = 5;
; 2753 : 			strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[index].Name);
; 2754 : 			szTargetNameCount++;
; 2755 : 
; 2756 : 			if ( szTargetNameCount != 0 )
; 2757 : 			{
; 2758 : 				pChatMsg.btType |= szTargetNameCount << 4;
; 2759 : 			}
; 2760 : 
; 2761 : 			pChatMsg.h.size = sizeof(pChatMsg);
; 2762 : 		
; 2763 : 			gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2764 : 		}
; 2765 : #endif
; 2766 : 	}
; 2767 : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
$LN6@CGChatWhis:

; 2688 : 		return;
; 2689 : 	}
; 2690 : #if(CUSTOM_CHATFILTER)
; 2691 : 	g_ChatFilter.CheckSyntax(aIndex, lpMsg->chatmsg);

  0007a	8d 47 0d	 lea	 eax, DWORD PTR [edi+13]
  0007d	50		 push	 eax
  0007e	56		 push	 esi
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChatFilter@@3VCChatFilter@@A ; g_ChatFilter
  00084	89 45 84	 mov	 DWORD PTR tv234[ebp], eax
  00087	e8 00 00 00 00	 call	 ?CheckSyntax@CChatFilter@@QAEXHPAD@Z ; CChatFilter::CheckSyntax

; 2692 : #endif
; 2693 : #if(_BAN_SYSTEM_)
; 2694 : 	if ( lpObj->BanChat > time(NULL) )

  0008c	6a 00		 push	 0
  0008e	e8 00 00 00 00	 call	 __time64
  00093	33 c9		 xor	 ecx, ecx
  00095	83 c4 04	 add	 esp, 4
  00098	3b ca		 cmp	 ecx, edx
  0009a	7c 40		 jl	 SHORT $LN5@CGChatWhis
  0009c	7f 08		 jg	 SHORT $LN16@CGChatWhis
  0009e	39 83 b4 27 00
	00		 cmp	 DWORD PTR [ebx+10164], eax
  000a4	76 36		 jbe	 SHORT $LN5@CGChatWhis
$LN16@CGChatWhis:

; 2695 : 	{
; 2696 : 		MsgOutput(lpObj->m_Index, "[BanChat] %d Sec", (lpObj->BanChat-time(NULL)));

  000a6	6a 00		 push	 0
  000a8	e8 00 00 00 00	 call	 __time64
  000ad	8b 8b b4 27 00
	00		 mov	 ecx, DWORD PTR [ebx+10164]
  000b3	33 f6		 xor	 esi, esi
  000b5	2b c8		 sub	 ecx, eax
  000b7	1b f2		 sbb	 esi, edx
  000b9	8b 13		 mov	 edx, DWORD PTR [ebx]
  000bb	56		 push	 esi
  000bc	51		 push	 ecx
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PAAPNLIE@?$FLBanChat?$FN?5?$CFd?5Sec?$AA@
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000c8	83 c4 14	 add	 esp, 20			; 00000014H
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx

; 2735 : 		}
; 2736 : #endif
; 2737 : 
; 2738 : 		CHAT_LOG_DATA pChatMsg;
; 2739 : 		int szTargetNameCount = 0;
; 2740 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2741 : 		if ( gWriteChatLog != FALSE )
; 2742 : 		{
; 2743 : 			pChatMsg.h.c = 0xC1;
; 2744 : 			pChatMsg.h.headcode = 0x02;
; 2745 : 			memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 2746 : 			memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_ACCOUNT_LEN);
; 2747 : 			pChatMsg.AccountID[MAX_ACCOUNT_LEN] = 0;
; 2748 : 			pChatMsg.Name[MAX_ACCOUNT_LEN] = 0;
; 2749 : 			pChatMsg.wServer = gGameServerCode;
; 2750 : 			memcpy(pChatMsg.szChatMsg, lpMsg->chatmsg, MAX_CHAT_LEN);
; 2751 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2752 : 			pChatMsg.btType = 5;
; 2753 : 			strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[index].Name);
; 2754 : 			szTargetNameCount++;
; 2755 : 
; 2756 : 			if ( szTargetNameCount != 0 )
; 2757 : 			{
; 2758 : 				pChatMsg.btType |= szTargetNameCount << 4;
; 2759 : 			}
; 2760 : 
; 2761 : 			pChatMsg.h.size = sizeof(pChatMsg);
; 2762 : 		
; 2763 : 			gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2764 : 		}
; 2765 : #endif
; 2766 : 	}
; 2767 : }

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d1	33 cd		 xor	 ecx, ebp
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN5@CGChatWhis:

; 2697 : 		return;
; 2698 : 	}
; 2699 : #endif
; 2700 : 
; 2701 : 	if ( (lpObj->Penalty & 2) == 2 )

  000dc	f6 83 10 02 00
	00 02		 test	 BYTE PTR [ebx+528], 2
  000e3	0f 85 f8 00 00
	00		 jne	 $LN1@CGChatWhis

; 2702 : 	{
; 2703 : 		return;
; 2704 : 	}
; 2705 : 
; 2706 : 	tid[10]=0;
; 2707 : 	memcpy(tid, lpMsg->id, sizeof(lpMsg->id));

  000e9	8b 47 03	 mov	 eax, DWORD PTR [edi+3]
  000ec	66 8b 57 0b	 mov	 dx, WORD PTR [edi+11]
  000f0	88 4d fa	 mov	 BYTE PTR _tid$[ebp+10], cl
  000f3	8b 4f 07	 mov	 ecx, DWORD PTR [edi+7]
  000f6	89 45 f0	 mov	 DWORD PTR _tid$[ebp], eax

; 2708 : 	index = WhisperCash.AddCash(tid);

  000f9	8d 45 f0	 lea	 eax, DWORD PTR _tid$[ebp]
  000fc	89 4d f4	 mov	 DWORD PTR _tid$[ebp+4], ecx
  000ff	50		 push	 eax
  00100	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  00105	66 89 55 f8	 mov	 WORD PTR _tid$[ebp+8], dx
  00109	e8 00 00 00 00	 call	 ?AddCash@CWhisperCash@@QAEHPAD@Z ; CWhisperCash::AddCash
  0010e	89 45 80	 mov	 DWORD PTR _index$[ebp], eax

; 2709 : 
; 2710 : 	if ( index < 0 )

  00111	85 c0		 test	 eax, eax
  00113	79 1c		 jns	 SHORT $LN3@CGChatWhis

; 2711 : 	{
; 2712 : 		GCServerMsgSend(0, aIndex);

  00115	56		 push	 esi
  00116	6a 00		 push	 0
  00118	e8 00 00 00 00	 call	 ?GCServerMsgSend@@YAXEH@Z ; GCServerMsgSend
  0011d	83 c4 08	 add	 esp, 8
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx

; 2735 : 		}
; 2736 : #endif
; 2737 : 
; 2738 : 		CHAT_LOG_DATA pChatMsg;
; 2739 : 		int szTargetNameCount = 0;
; 2740 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2741 : 		if ( gWriteChatLog != FALSE )
; 2742 : 		{
; 2743 : 			pChatMsg.h.c = 0xC1;
; 2744 : 			pChatMsg.h.headcode = 0x02;
; 2745 : 			memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 2746 : 			memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_ACCOUNT_LEN);
; 2747 : 			pChatMsg.AccountID[MAX_ACCOUNT_LEN] = 0;
; 2748 : 			pChatMsg.Name[MAX_ACCOUNT_LEN] = 0;
; 2749 : 			pChatMsg.wServer = gGameServerCode;
; 2750 : 			memcpy(pChatMsg.szChatMsg, lpMsg->chatmsg, MAX_CHAT_LEN);
; 2751 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2752 : 			pChatMsg.btType = 5;
; 2753 : 			strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[index].Name);
; 2754 : 			szTargetNameCount++;
; 2755 : 
; 2756 : 			if ( szTargetNameCount != 0 )
; 2757 : 			{
; 2758 : 				pChatMsg.btType |= szTargetNameCount << 4;
; 2759 : 			}
; 2760 : 
; 2761 : 			pChatMsg.h.size = sizeof(pChatMsg);
; 2762 : 		
; 2763 : 			gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2764 : 		}
; 2765 : #endif
; 2766 : 	}
; 2767 : }

  00123	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	33 cd		 xor	 ecx, ebp
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
$LN3@CGChatWhis:

; 2713 : 		return;
; 2714 : 	}
; 2715 : 
; 2716 : 	PHeadSetB((LPBYTE)&pWhisper, 0x02, sizeof(pWhisper));

  00131	6a 66		 push	 102			; 00000066H
  00133	8d 4d 88	 lea	 ecx, DWORD PTR _pWhisper$[ebp]
  00136	6a 02		 push	 2
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2717 : 	strcpy(pWhisper.id, gObj[aIndex].Name);

  0013e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00144	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv224[ebp]
  0014a	8d 44 10 77	 lea	 eax, DWORD PTR [eax+edx+119]
  0014e	8d 55 8b	 lea	 edx, DWORD PTR _pWhisper$[ebp+3]
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	2b d0		 sub	 edx, eax
$LL10@CGChatWhis:
  00156	8a 08		 mov	 cl, BYTE PTR [eax]
  00158	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0015b	40		 inc	 eax
  0015c	84 c9		 test	 cl, cl
  0015e	75 f6		 jne	 SHORT $LL10@CGChatWhis

; 2718 : 	memcpy(pWhisper.chatmsg, lpMsg->chatmsg, sizeof(lpMsg->chatmsg));

  00160	8b 75 84	 mov	 esi, DWORD PTR tv234[ebp]
  00163	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00168	8d 7d 95	 lea	 edi, DWORD PTR _pWhisper$[ebp+13]
  0016b	f3 a5		 rep movsd

; 2719 : 	len = strlen(pWhisper.chatmsg);

  0016d	8d 45 95	 lea	 eax, DWORD PTR _pWhisper$[ebp+13]
  00170	a4		 movsb
  00171	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL17@CGChatWhis:
  00174	8a 08		 mov	 cl, BYTE PTR [eax]
  00176	40		 inc	 eax
  00177	84 c9		 test	 cl, cl
  00179	75 f9		 jne	 SHORT $LL17@CGChatWhis
  0017b	2b c2		 sub	 eax, edx

; 2720 : 
; 2721 : 	if ( len > 0 )

  0017d	85 c0		 test	 eax, eax
  0017f	7e 60		 jle	 SHORT $LN1@CGChatWhis

; 2722 : 	{
; 2723 : 		pWhisper.h.size -= sizeof(pWhisper.chatmsg);
; 2724 : 		pWhisper.h.size += len + 1;
; 2725 : #ifdef _NEW_CHAT_FIX_
; 2726 : 		MessageSendEx(index, 2, pWhisper.id, pWhisper.chatmsg);

  00181	8b 75 80	 mov	 esi, DWORD PTR _index$[ebp]
  00184	8d 4d 95	 lea	 ecx, DWORD PTR _pWhisper$[ebp+13]
  00187	51		 push	 ecx
  00188	8d 55 8b	 lea	 edx, DWORD PTR _pWhisper$[ebp+3]
  0018b	52		 push	 edx
  0018c	2c 58		 sub	 al, 88			; 00000058H
  0018e	00 45 89	 add	 BYTE PTR _pWhisper$[ebp+1], al
  00191	6a 02		 push	 2
  00193	56		 push	 esi
  00194	e8 00 00 00 00	 call	 ?MessageSendEx@@YAXHHPAD0ZZ ; MessageSendEx
  00199	83 c4 10	 add	 esp, 16			; 00000010H

; 2727 : #else
; 2728 : 		DataSend(index, (LPBYTE)&pWhisper, pWhisper.h.size);
; 2729 : #endif
; 2730 : 
; 2731 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2732 : 		if( gWriteChatLog && g_ZtLicense.user.ChatLog )

  0019c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  001a3	74 3c		 je	 SHORT $LN1@CGChatWhis
  001a5	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  001ac	74 33		 je	 SHORT $LN1@CGChatWhis

; 2733 : 		{
; 2734 : 			g_PrivateChatLog.Output("[%s] [%s] -> [%s] [%s]: %s", lpObj->AccountID, lpObj->Name, gObj[index].AccountID, gObj[index].Name, lpMsg->chatmsg);

  001ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b3	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  001b9	8b 4d 84	 mov	 ecx, DWORD PTR tv234[ebp]
  001bc	51		 push	 ecx
  001bd	03 c6		 add	 eax, esi
  001bf	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  001c2	52		 push	 edx
  001c3	83 c0 6c	 add	 eax, 108		; 0000006cH
  001c6	50		 push	 eax
  001c7	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  001ca	50		 push	 eax
  001cb	83 c3 6c	 add	 ebx, 108		; 0000006cH
  001ce	53		 push	 ebx
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NBANGCOJ@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?9?$DO?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?3?5?$CFs?$AA@
  001d4	68 00 00 00 00	 push	 OFFSET ?g_PrivateChatLog@@3VCLogToFile@@A ; g_PrivateChatLog
  001d9	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001de	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@CGChatWhis:

; 2735 : 		}
; 2736 : #endif
; 2737 : 
; 2738 : 		CHAT_LOG_DATA pChatMsg;
; 2739 : 		int szTargetNameCount = 0;
; 2740 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2741 : 		if ( gWriteChatLog != FALSE )
; 2742 : 		{
; 2743 : 			pChatMsg.h.c = 0xC1;
; 2744 : 			pChatMsg.h.headcode = 0x02;
; 2745 : 			memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 2746 : 			memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_ACCOUNT_LEN);
; 2747 : 			pChatMsg.AccountID[MAX_ACCOUNT_LEN] = 0;
; 2748 : 			pChatMsg.Name[MAX_ACCOUNT_LEN] = 0;
; 2749 : 			pChatMsg.wServer = gGameServerCode;
; 2750 : 			memcpy(pChatMsg.szChatMsg, lpMsg->chatmsg, MAX_CHAT_LEN);
; 2751 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2752 : 			pChatMsg.btType = 5;
; 2753 : 			strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[index].Name);
; 2754 : 			szTargetNameCount++;
; 2755 : 
; 2756 : 			if ( szTargetNameCount != 0 )
; 2757 : 			{
; 2758 : 				pChatMsg.btType |= szTargetNameCount << 4;
; 2759 : 			}
; 2760 : 
; 2761 : 			pChatMsg.h.size = sizeof(pChatMsg);
; 2762 : 		
; 2763 : 			gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2764 : 		}
; 2765 : #endif
; 2766 : 	}
; 2767 : }

  001e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e4	5f		 pop	 edi
  001e5	5e		 pop	 esi
  001e6	33 cd		 xor	 ecx, ebp
  001e8	5b		 pop	 ebx
  001e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ee	8b e5		 mov	 esp, ebp
  001f0	5d		 pop	 ebp
  001f1	c3		 ret	 0
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ENDP ; CGChatWhisperRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SCPJoinResultSend@@YAXHE@Z			; SCPJoinResultSend
EXTRN	?szClientVersion@@3PADA:QWORD			; szClientVersion
; Function compile flags: /Ogtp
;	COMDAT ?SCPJoinResultSend@@YAXHE@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?SCPJoinResultSend@@YAXHE@Z PROC			; SCPJoinResultSend, COMDAT

; 2770 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2771 : 	PMSG_JOINRESULT pResult;
; 2772 : 
; 2773 : 	memset(&pResult, 0, sizeof(pResult));
; 2774 : 
; 2775 : 	pResult.h.size = sizeof(pResult);
; 2776 : 	pResult.h.c = 0xC1;
; 2777 : 	pResult.h.headcode = 0xF1;
; 2778 : 	pResult.scode = 0x00;
; 2779 : 	pResult.result = result;
; 2780 : 	pResult.NumberH = SET_NUMBERH(aIndex);
; 2781 : 	pResult.NumberL = SET_NUMBERL(aIndex);
; 2782 : 	pResult.CliVersion[0] = szClientVersion[0];

  00010	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?szClientVersion@@3PADA
  00017	33 c0		 xor	 eax, eax
  00019	89 45 f4	 mov	 DWORD PTR _pResult$[ebp+4], eax
  0001c	89 45 f8	 mov	 DWORD PTR _pResult$[ebp+8], eax
  0001f	53		 push	 ebx
  00020	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR _pResult$[ebp], eax
  00026	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00029	8b cb		 mov	 ecx, ebx
  0002b	c1 e9 08	 shr	 ecx, 8
  0002e	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al

; 2783 : 	pResult.CliVersion[1] = szClientVersion[1];

  00031	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00038	88 4d f5	 mov	 BYTE PTR _pResult$[ebp+5], cl

; 2784 : 	pResult.CliVersion[2] = szClientVersion[2];

  0003b	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ?szClientVersion@@3PADA+2
  00041	88 4d f9	 mov	 BYTE PTR _pResult$[ebp+9], cl
  00044	88 55 f7	 mov	 BYTE PTR _pResult$[ebp+7], dl

; 2785 : 	pResult.CliVersion[3] = szClientVersion[3];

  00047	0f b6 15 03 00
	00 00		 movzx	 edx, BYTE PTR ?szClientVersion@@3PADA+3
  0004e	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+8], al

; 2786 : 	pResult.CliVersion[4] = szClientVersion[4];

  00051	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+4

; 2787 : 
; 2788 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00058	6a 0c		 push	 12			; 0000000cH
  0005a	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0005d	51		 push	 ecx
  0005e	53		 push	 ebx
  0005f	c7 45 f0 c1 0c
	f1 00		 mov	 DWORD PTR _pResult$[ebp], 15797441 ; 00f10cc1H
  00066	88 5d f6	 mov	 BYTE PTR _pResult$[ebp+6], bl
  00069	88 55 fa	 mov	 BYTE PTR _pResult$[ebp+10], dl
  0006c	88 45 fb	 mov	 BYTE PTR _pResult$[ebp+11], al
  0006f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2789 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0007d	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00083	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2790 : }

  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	89 44 13 3c	 mov	 DWORD PTR [ebx+edx+60], eax
  00090	33 cd		 xor	 ecx, ebp
  00092	5b		 pop	 ebx
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?SCPJoinResultSend@@YAXHE@Z ENDP			; SCPJoinResultSend
_TEXT	ENDS
PUBLIC	??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_04FLFDNKBN@m321?$AA@			; `string'
PUBLIC	??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequestTEST
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?wsJServerCli@@3VwsJoinServerCli@@A:BYTE	; wsJServerCli
EXTRN	?BuxConvert@@YAXPADH@Z:PROC			; BuxConvert
EXTRN	__imp__wsprintfA:PROC
;	COMDAT ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@ DB 'login send : %s'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLFDNKBN@m321?$AA@
CONST	SEGMENT
??_C@_04FLFDNKBN@m321?$AA@ DB 'm321', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@
CONST	SEGMENT
??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@ DB 0bdH, 0b8H, 0b5H, 0b9H
	DB	0c0H, 0ccH, '%d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
_spMsg$ = -72						; size = 44
_szId$ = -28						; size = 11
_szPass$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequestTEST, COMDAT

; 2988 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 2989 : 	char szId[11];
; 2990 : 	char szPass[11];
; 2991 : 	LPOBJ lpObj = &gObj[aIndex];
; 2992 : 	SDHP_IDPASS spMsg;
; 2993 : 
; 2994 : 	PHeadSetB((LPBYTE)&spMsg, 0x11, sizeof(spMsg));

  00014	6a 2c		 push	 44			; 0000002cH
  00016	8d 45 b8	 lea	 eax, DWORD PTR _spMsg$[ebp]
  00019	6a 11		 push	 17			; 00000011H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2995 : 	spMsg.Number = aIndex;
; 2996 : 
; 2997 : 	wsprintf(szId, "%d", logincounttest);

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?logincounttest@@3HA ; logincounttest
  00027	51		 push	 ecx
  00028	8d 55 e4	 lea	 edx, DWORD PTR _szId$[ebp]
  0002b	66 89 75 d0	 mov	 WORD PTR _spMsg$[ebp+24], si
  0002f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@
  0003a	52		 push	 edx
  0003b	ff d6		 call	 esi

; 2998 : 	wsprintf(szPass, "m321", rand()%9);

  0003d	e8 00 00 00 00	 call	 _rand
  00042	99		 cdq
  00043	b9 09 00 00 00	 mov	 ecx, 9
  00048	f7 f9		 idiv	 ecx
  0004a	52		 push	 edx
  0004b	8d 55 f0	 lea	 edx, DWORD PTR _szPass$[ebp]
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_04FLFDNKBN@m321?$AA@
  00053	52		 push	 edx
  00054	ff d6		 call	 esi

; 2999 : 	LogAdd("login send : %s %s", szId, szPass);

  00056	8d 45 f0	 lea	 eax, DWORD PTR _szPass$[ebp]
  00059	50		 push	 eax
  0005a	8d 4d e4	 lea	 ecx, DWORD PTR _szId$[ebp]
  0005d	51		 push	 ecx
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3000 : 	
; 3001 : 	BuxConvert(szId, MAX_ACCOUNT_LEN);

  00069	8d 55 e4	 lea	 edx, DWORD PTR _szId$[ebp]
  0006c	6a 0a		 push	 10			; 0000000aH
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 3002 : 	BuxConvert(szPass, MAX_ACCOUNT_LEN);

  00074	8d 45 f0	 lea	 eax, DWORD PTR _szPass$[ebp]
  00077	6a 0a		 push	 10			; 0000000aH
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 3003 : 	memcpy(spMsg.Id, szId, MAX_ACCOUNT_LEN);

  0007f	0f b7 45 ec	 movzx	 eax, WORD PTR _szId$[ebp+8]
  00083	8b 4d e4	 mov	 ecx, DWORD PTR _szId$[ebp]
  00086	8b 55 e8	 mov	 edx, DWORD PTR _szId$[ebp+4]

; 3004 : 	memcpy(spMsg.Pass, szPass, MAX_ACCOUNT_LEN);
; 3005 : 	logincounttest++;
; 3006 : 	
; 3007 : 	if ( (GetTickCount()-ltesttime) > 1000 )

  00089	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0008f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?logincounttest@@3HA ; logincounttest
  00095	66 89 45 c3	 mov	 WORD PTR _spMsg$[ebp+11], ax
  00099	0f b7 45 f8	 movzx	 eax, WORD PTR _szPass$[ebp+8]
  0009d	89 4d bb	 mov	 DWORD PTR _spMsg$[ebp+3], ecx
  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _szPass$[ebp]
  000a3	89 55 bf	 mov	 DWORD PTR _spMsg$[ebp+7], edx
  000a6	8b 55 f4	 mov	 edx, DWORD PTR _szPass$[ebp+4]
  000a9	83 c4 40	 add	 esp, 64			; 00000040H
  000ac	89 4d c5	 mov	 DWORD PTR _spMsg$[ebp+13], ecx
  000af	89 55 c9	 mov	 DWORD PTR _spMsg$[ebp+17], edx
  000b2	66 89 45 cd	 mov	 WORD PTR _spMsg$[ebp+21], ax
  000b6	ff d6		 call	 esi
  000b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ltesttime@@3HA ; ltesttime
  000be	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000c3	76 11		 jbe	 SHORT $LN1@CSPJoinIdP

; 3008 : 	{
; 3009 : 		ltesttime = GetTickCount();

  000c5	ff d6		 call	 esi
  000c7	a3 00 00 00 00	 mov	 DWORD PTR ?ltesttime@@3HA, eax ; ltesttime

; 3010 : 		logincounttest=0;

  000cc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?logincounttest@@3HA, 0 ; logincounttest
$LN1@CSPJoinIdP:

; 3011 : 	}
; 3012 : 
; 3013 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000d6	0f b6 4d b9	 movzx	 ecx, BYTE PTR _spMsg$[ebp+1]
  000da	51		 push	 ecx
  000db	8d 55 b8	 lea	 edx, DWORD PTR _spMsg$[ebp]
  000de	52		 push	 edx
  000df	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  000e4	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3014 : 	spMsg.h.headcode = 0x01;
; 3015 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000e9	0f b6 45 b9	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  000ed	50		 push	 eax
  000ee	8d 4d b8	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  000f1	51		 push	 ecx
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  000f7	c6 45 ba 01	 mov	 BYTE PTR _spMsg$[ebp+2], 1
  000fb	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3016 : }

  00100	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	5e		 pop	 esi
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequestTEST
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCJoinBillCheckSend@@YAXPADH@Z			; GCJoinBillCheckSend
; Function compile flags: /Ogtp
;	COMDAT ?GCJoinBillCheckSend@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_AccountId$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCJoinBillCheckSend@@YAXPADH@Z PROC			; GCJoinBillCheckSend, COMDAT

; 3019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _AccountId$[ebp]

; 3020 : 	SDHP_BILLSEARCH pMsg;
; 3021 : 
; 3022 : 	PHeadSetB((LPBYTE)&pMsg, 0x06, sizeof(pMsg));

  00014	6a 10		 push	 16			; 00000010H
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 06		 push	 6
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3023 : 	memcpy(pMsg.Id, AccountId, sizeof(pMsg.Id));

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00026	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  0002a	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx

; 3024 : 	pMsg.Number = aIndex;
; 3025 : 
; 3026 : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  0002d	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  00037	66 8b 4d 0c	 mov	 cx, WORD PTR _aIndex$[ebp]
  0003b	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  0003f	52		 push	 edx
  00040	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00043	66 89 4d fa	 mov	 WORD PTR _pMsg$[ebp+14], cx
  00047	50		 push	 eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  0004d	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3027 : }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	5e		 pop	 esi
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCJoinBillCheckSend@@YAXPADH@Z ENDP			; GCJoinBillCheckSend
_TEXT	ENDS
PUBLIC	?GCJoinResult@@YAXEH@Z				; GCJoinResult
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?GCJoinResult@@YAXEH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCJoinResult@@YAXEH@Z PROC				; GCJoinResult, COMDAT

; 3030 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3031 : 	PMSG_RESULT  pResult;
; 3032 : 
; 3033 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF1, 0x01, sizeof(pResult));

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3034 : 	pResult.result = result;
; 3035 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0001c	8a 4d 08	 mov	 cl, BYTE PTR _result$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00023	88 4d fc	 mov	 BYTE PTR _pResult$[ebp+4], cl
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3036 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCJoinResult@@YAXEH@Z ENDP				; GCJoinResult
_TEXT	ENDS
PUBLIC	?GCJoinSocketResult@@YAXEI@Z			; GCJoinSocketResult
EXTRN	?DataSocketSend@CwsGameServer@@QAEHIPADH@Z:PROC	; CwsGameServer::DataSocketSend
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
; Function compile flags: /Ogtp
;	COMDAT ?GCJoinSocketResult@@YAXEI@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_Socket$ = 12						; size = 4
?GCJoinSocketResult@@YAXEI@Z PROC			; GCJoinSocketResult, COMDAT

; 3039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3040 : 	PMSG_RESULT pResult;
; 3041 : 
; 3042 : 	PHeadSubSetB((LPBYTE)&pResult , 0xF1, 0x01, sizeof(pResult) );

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3043 : 	pResult.result= result;
; 3044 : 
; 3045 : 	wsGServer.DataSocketSend(Socket, (char*)&pResult, pResult.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0001c	8a 4d 08	 mov	 cl, BYTE PTR _result$[ebp]
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	52		 push	 edx
  00023	88 4d fc	 mov	 BYTE PTR _pResult$[ebp+4], cl
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _Socket$[ebp]
  00029	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsGServer@@3VCwsGameServer@@A ; wsGServer
  00033	e8 00 00 00 00	 call	 ?DataSocketSend@CwsGameServer@@QAEHIPADH@Z ; CwsGameServer::DataSocketSend

; 3046 : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?GCJoinSocketResult@@YAXEI@Z ENDP			; GCJoinSocketResult
_TEXT	ENDS
PUBLIC	??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@ ; `string'
PUBLIC	?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z	; CGClientCloseMsg
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
;	COMDAT ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@ DB '['
	DB	'UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@ DB '['
	DB	'UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z PROC	; CGClientCloseMsg, COMDAT

; 3049 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3050 : 	switch ( lpMsg->Flag )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000a	83 e8 00	 sub	 eax, 0
  0000d	56		 push	 esi
  0000e	0f 84 c0 00 00
	00		 je	 $LN9@CGClientCl
  00014	48		 dec	 eax
  00015	74 62		 je	 SHORT $LN3@CGClientCl
  00017	48		 dec	 eax
  00018	0f 85 09 01 00
	00		 jne	 $LN7@CGClientCl

; 3063 : 			break;
; 3064 : 
; 3065 : 		case 2:	// ServerList
; 3066 : 			gObjCloseSet(aIndex, 2);

  0001e	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00021	6a 02		 push	 2
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00029	83 c4 08	 add	 esp, 8

; 3067 : 
; 3068 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  0002c	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00032	0f 87 ef 00 00
	00		 ja	 $LN7@CGClientCl

; 3069 : 			{
; 3070 : 				return;
; 3071 : 			}
; 3072 : 
; 3073 : 			LogAddTD("[UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]",
; 3074 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3075 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00044	0f bf 94 0e 46
	01 00 00	 movsx	 edx, WORD PTR [esi+ecx+326]
  0004c	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0004f	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  00056	52		 push	 edx
  00057	0f b6 90 49 01
	00 00		 movzx	 edx, BYTE PTR [eax+329]
  0005e	51		 push	 ecx
  0005f	52		 push	 edx
  00060	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00063	51		 push	 ecx
  00064	83 c0 6c	 add	 eax, 108		; 0000006cH
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	5e		 pop	 esi

; 3089 : 			break;
; 3090 : 	}
; 3091 : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN3@CGClientCl:

; 3076 : 			break;
; 3077 : 
; 3078 : 		case 1:	// Select Character
; 3079 : 			gObjCloseSet(aIndex, 1);

  00079	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0007c	6a 01		 push	 1
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00084	83 c4 08	 add	 esp, 8

; 3080 : 
; 3081 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  00087	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0008d	0f 87 94 00 00
	00		 ja	 $LN7@CGClientCl

; 3082 : 			{
; 3083 : 				return;
; 3084 : 			}
; 3085 : 
; 3086 : 			LogAddTD("[UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]",
; 3087 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3088 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);

  00093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00099	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0009f	0f bf 8c 16 46
	01 00 00	 movsx	 ecx, WORD PTR [esi+edx+326]
  000a7	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000aa	0f bf 90 44 01
	00 00		 movsx	 edx, WORD PTR [eax+324]
  000b1	51		 push	 ecx
  000b2	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  000b9	52		 push	 edx
  000ba	51		 push	 ecx
  000bb	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  000be	52		 push	 edx
  000bf	83 c0 6c	 add	 eax, 108		; 0000006cH
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ce	83 c4 18	 add	 esp, 24			; 00000018H
  000d1	5e		 pop	 esi

; 3089 : 			break;
; 3090 : 	}
; 3091 : }

  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN9@CGClientCl:

; 3051 : 	{
; 3052 : 		case 0:	// Close Game
; 3053 : 			gObjCloseSet(aIndex, 0);

  000d4	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  000d7	6a 00		 push	 0
  000d9	56		 push	 esi
  000da	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  000df	83 c4 08	 add	 esp, 8

; 3054 : 
; 3055 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  000e2	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  000e8	77 3d		 ja	 SHORT $LN7@CGClientCl

; 3056 : 			{
; 3057 : 				return;
; 3058 : 			}
; 3059 : 
; 3060 : 			LogAddTD("[UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]",
; 3061 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3062 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);

  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ef	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000f5	0f bf 8c 30 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+esi+326]
  000fd	0f bf 94 30 44
	01 00 00	 movsx	 edx, WORD PTR [eax+esi+324]
  00105	03 c6		 add	 eax, esi
  00107	51		 push	 ecx
  00108	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  0010f	52		 push	 edx
  00110	51		 push	 ecx
  00111	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  00114	52		 push	 edx
  00115	83 c0 6c	 add	 eax, 108		; 0000006cH
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00124	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@CGClientCl:
  00127	5e		 pop	 esi

; 3089 : 			break;
; 3090 : 	}
; 3091 : }

  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ENDP	; CGClientCloseMsg
_TEXT	ENDS
PUBLIC	?GCCloseMsgSend@@YAXHE@Z			; GCCloseMsgSend
EXTRN	?PHeadSubSetBE@@YAXPAEEEH@Z:PROC		; PHeadSubSetBE
; Function compile flags: /Ogtp
;	COMDAT ?GCCloseMsgSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?GCCloseMsgSend@@YAXHE@Z PROC				; GCCloseMsgSend, COMDAT

; 3094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3095 : 	PMSG_RESULT pMsg;
; 3096 : 
; 3097 : 	PHeadSubSetBE((LPBYTE)&pMsg, 0xF1, 0x02, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 02		 push	 2
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetBE@@YAXPAEEEH@Z ; PHeadSubSetBE

; 3098 : 	pMsg.result = result;
; 3099 : 	
; 3100 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00023	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3101 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCCloseMsgSend@@YAXHE@Z ENDP				; GCCloseMsgSend
_TEXT	ENDS
PUBLIC	??_C@_0BE@FHEKOAFO@Client?5HackCheck?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z		; CGClientMsg
EXTRN	?Send@CSendHackLog@@QAEXHEPAD@Z:PROC		; CSendHackLog::Send
EXTRN	?gSendHackLog@@3VCSendHackLog@@A:BYTE		; gSendHackLog
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
;	COMDAT ??_C@_0BE@FHEKOAFO@Client?5HackCheck?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@FHEKOAFO@Client?5HackCheck?5?$CFd?$AA@ DB 'Client HackCheck %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
CONST	SEGMENT
??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@ DB 'e'
	DB	'rror-L1 : HackCheck [%s][%s] 0x%x 0x%x', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z
_TEXT	SEGMENT
_msg$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z PROC		; CGClientMsg, COMDAT

; 3104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 3105 : 	if ( lpMsg->Flag )

  0001b	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  0001e	84 c9		 test	 cl, cl
  00020	74 31		 je	 SHORT $LN4@CGClientMs

; 3106 : 	{
; 3107 : 		LogAddC(2,"error-L1 : HackCheck [%s][%s] 0x%x 0x%x",
; 3108 : 			gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3109 : 			lpMsg->Flag, lpMsg->subFlag);

  00022	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00026	8b c3		 mov	 eax, ebx
  00028	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	52		 push	 edx
  00035	0f b6 c9	 movzx	 ecx, cl
  00038	51		 push	 ecx
  00039	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  0003c	52		 push	 edx
  0003d	83 c0 6c	 add	 eax, 108		; 0000006cH
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
  00046	6a 02		 push	 2
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0004e	83 c4 18	 add	 esp, 24			; 00000018H

; 3110 : 	}
; 3111 : 	else 

  00051	eb 5d		 jmp	 SHORT $LN1@CGClientMs
$LN4@CGClientMs:

; 3112 : 	{
; 3113 : 		if ( gObj[aIndex].m_ClientHackLogCount < 100 )

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	56		 push	 esi
  00059	8b f3		 mov	 esi, ebx
  0005b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00061	80 bc 06 e7 10
	00 00 64	 cmp	 BYTE PTR [esi+eax+4327], 100 ; 00000064H
  00069	73 26		 jae	 SHORT $LN2@CGClientMs

; 3114 : 		{
; 3115 : 			LogAddC(2, "error-L1 : HackCheck [%s][%s] 0x%x 0x%x",
; 3116 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3117 : 				lpMsg->Flag, lpMsg->subFlag);

  0006b	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0006f	51		 push	 ecx
  00070	6a 00		 push	 0
  00072	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00076	52		 push	 edx
  00077	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
  00081	6a 02		 push	 2
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@CGClientMs:

; 3118 : 		}
; 3119 : 
; 3120 : 		gObj[aIndex].m_ClientHackLogCount++;

  00091	fe 84 06 e7 10
	00 00		 inc	 BYTE PTR [esi+eax+4327]

; 3121 : 
; 3122 : 		if ( gObj[aIndex].m_ClientHackLogCount >= 100 )

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009d	80 bc 06 e7 10
	00 00 64	 cmp	 BYTE PTR [esi+eax+4327], 100 ; 00000064H
  000a5	72 08		 jb	 SHORT $LN7@CGClientMs

; 3123 : 			gObj[aIndex].m_ClientHackLogCount = 100;

  000a7	c6 84 06 e7 10
	00 00 64	 mov	 BYTE PTR [esi+eax+4327], 100 ; 00000064H
$LN7@CGClientMs:
  000af	5e		 pop	 esi
$LN1@CGClientMs:

; 3124 : 	}
; 3125 : 
; 3126 : 	char msg[255];
; 3127 : 
; 3128 : 	wsprintf(msg, "Client HackCheck %d", lpMsg->Flag);

  000b0	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  000b4	51		 push	 ecx
  000b5	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FHEKOAFO@Client?5HackCheck?5?$CFd?$AA@
  000c0	52		 push	 edx
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3129 : 	gSendHackLog.Send(aIndex, 0, msg);

  000ca	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000d0	50		 push	 eax
  000d1	6a 00		 push	 0
  000d3	53		 push	 ebx
  000d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSendHackLog@@3VCSendHackLog@@A ; gSendHackLog
  000d9	e8 00 00 00 00	 call	 ?Send@CSendHackLog@@QAEXHEPAD@Z ; CSendHackLog::Send

; 3130 : }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	5f		 pop	 edi
  000e2	33 cd		 xor	 ecx, ebp
  000e4	5b		 pop	 ebx
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ENDP		; CGClientMsg
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CD@KELNHOGA@Simbol?5Character?5create?5error?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@ ; `string'
PUBLIC	??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@ ; `string'
PUBLIC	??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK?G@ ; `string'
PUBLIC	??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z	; CGPCharacterCreate
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?ztCheckSimbol@@YA_NPADH@Z:PROC			; ztCheckSimbol
EXTRN	?CheckUser@CZtLicense@@QAE_NH@Z:PROC		; CZtLicense::CheckUser
EXTRN	?gCreateCharacter@@3HA:DWORD			; gCreateCharacter
EXTRN	?JGCharacterCreateFailSend@@YAXHPAD@Z:PROC	; JGCharacterCreateFailSend
;	COMDAT ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@ DB 'Character'
	DB	' create : %s,%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KELNHOGA@Simbol?5Character?5create?5error?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@KELNHOGA@Simbol?5Character?5create?5error?5?$FL?$CF@ DB 'Simbol'
	DB	' Character create error [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@
CONST	SEGMENT
??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@ DB 'error-L1: D'
	DB	'arklord Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@
CONST	SEGMENT
??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@ DB 'error-L1: M'
	DB	'agumsa Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK?G@
CONST	SEGMENT
??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK?G@ DB 0bcH
	DB	0adH, 0b9H, 0f6H, 0baH, 0d0H, 0c7H, 0d2H, ' ', 0b1H, 0e2H, 0b0H
	DB	0a3H, 0bfH, 0a1H, 0b4H, 0c2H, ' ', 0c4H, 0b3H, 0b8H, 0afH, 0c5H
	DB	0cdH, 0b8H, 0a6H, ' ', 0bbH, 0fdH, 0bcH, 0baH, 0c7H, 0d2H, 0bcH
	DB	0f6H, ' ', 0beH, 0f8H, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@
CONST	SEGMENT
??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@ DB '[A'
	DB	'nti-HACK][CGPCharacterCreate] Attempted Character Create duri'
	DB	'ng GamePlay. [%s][%s]', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z
_TEXT	SEGMENT
tv323 = -88						; size = 4
tv374 = -84						; size = 4
_sCreate$ = -80						; size = 36
_szTemp2$ = -44						; size = 20
_szTemp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z PROC	; CGPCharacterCreate, COMDAT

; 3133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3134 : 	#if(ENABLE_MULTI_CHAR)
; 3135 : 
; 3136 : 	if(OBJMAX_RANGE(aIndex))
; 3137 : 	{
; 3138 : 		if(gObj[aIndex].m_CharPage > 0)
; 3139 : 		{
; 3140 : 			CGPCharacterCreate_Multi((PMSG_CHARCREATE *) lpMsg, aIndex);
; 3141 : 
; 3142 : 			return;
; 3143 : 		}
; 3144 : 	}
; 3145 : 
; 3146 : 	#endif
; 3147 : 
; 3148 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0001d	57		 push	 edi
  0001e	8b fb		 mov	 edi, ebx
  00020	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00026	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	75 1e		 jne	 SHORT $LN15@CGPCharact
$LN21@CGPCharact:

; 3149 : 	{
; 3150 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00036	83 c6 04	 add	 esi, 4
  00039	56		 push	 esi
  0003a	53		 push	 ebx
  0003b	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00040	83 c4 08	 add	 esp, 8
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx

; 3266 : }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN15@CGPCharact:

; 3151 : 		return;
; 3152 : 	}
; 3153 : 
; 3154 : 	if ( gObj[aIndex].Connected < PLAYER_LOGGED )

  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	8b 44 0f 04	 mov	 eax, DWORD PTR [edi+ecx+4]
  0005e	83 f8 02	 cmp	 eax, 2
  00061	7d 36		 jge	 SHORT $LN14@CGPCharact

; 3155 : 	{
; 3156 : 		LogAdd(lMsg.Get(MSGGET(1, 220)), aIndex, gObj[aIndex].Ip_addr);

  00063	8d 54 0f 18	 lea	 edx, DWORD PTR [edi+ecx+24]
  00067	52		 push	 edx
  00068	53		 push	 ebx
  00069	68 dc 01 00 00	 push	 476			; 000001dcH
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00073	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3157 : 		CloseClient(aIndex);

  0007f	53		 push	 ebx
  00080	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 3266 : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN14@CGPCharact:

; 3158 : 
; 3159 : 		return;
; 3160 : 	}
; 3161 : 
; 3162 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00099	83 f8 03	 cmp	 eax, 3
  0009c	75 2f		 jne	 SHORT $LN13@CGPCharact

; 3163 : 	{
; 3164 : 		LogAddTD("[Anti-HACK][CGPCharacterCreate] Attempted Character Create during GamePlay. [%s][%s]",
; 3165 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  0009e	8d 44 0f 77	 lea	 eax, DWORD PTR [edi+ecx+119]
  000a2	50		 push	 eax
  000a3	8d 4c 0f 6c	 lea	 ecx, DWORD PTR [edi+ecx+108]
  000a7	51		 push	 ecx
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3166 : 		CloseClient(aIndex);

  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000b9	83 c4 10	 add	 esp, 16			; 00000010H
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx

; 3266 : }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	33 cd		 xor	 ecx, ebp
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
$LN13@CGPCharact:

; 3167 : 
; 3168 : 		return;
; 3169 : 	}
; 3170 : 
; 3171 : 
; 3172 : 	if ( !gCreateCharacter )

  000cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCreateCharacter@@3HA, 0 ; gCreateCharacter
  000d4	75 2b		 jne	 SHORT $LN12@CGPCharact

; 3173 : 	{
; 3174 : 		GCServerMsgStringSend("    ", aIndex, 1);

  000d6	6a 01		 push	 1
  000d8	53		 push	 ebx
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK?G@
  000de	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3175 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  000e3	83 c6 04	 add	 esi, 4
  000e6	56		 push	 esi
  000e7	53		 push	 ebx
  000e8	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  000ed	83 c4 14	 add	 esp, 20			; 00000014H
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 3266 : }

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6	33 cd		 xor	 ecx, ebp
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN12@CGPCharact:

; 3176 : 
; 3177 : 		return;
; 3178 : 	}
; 3179 : 
; 3180 : 	if ( lpMsg->ClassSkin != 0
; 3181 : 		&& lpMsg->ClassSkin != 16
; 3182 : 		&& lpMsg->ClassSkin != 32
; 3183 : 		&& lpMsg->ClassSkin != 48
; 3184 : 		&& lpMsg->ClassSkin != 64
; 3185 : 		&& lpMsg->ClassSkin != 80
; 3186 : 		&& lpMsg->ClassSkin != 96 )

  00101	8a 46 0e	 mov	 al, BYTE PTR [esi+14]
  00104	84 c0		 test	 al, al
  00106	74 1c		 je	 SHORT $LN11@CGPCharact
  00108	3c 10		 cmp	 al, 16			; 00000010H
  0010a	74 18		 je	 SHORT $LN11@CGPCharact
  0010c	3c 20		 cmp	 al, 32			; 00000020H
  0010e	74 14		 je	 SHORT $LN11@CGPCharact
  00110	3c 30		 cmp	 al, 48			; 00000030H
  00112	74 10		 je	 SHORT $LN11@CGPCharact
  00114	3c 40		 cmp	 al, 64			; 00000040H
  00116	74 0c		 je	 SHORT $LN11@CGPCharact
  00118	3c 50		 cmp	 al, 80			; 00000050H
  0011a	74 0c		 je	 SHORT $LN20@CGPCharact
  0011c	3c 60		 cmp	 al, 96			; 00000060H

; 3187 : 	{
; 3188 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 3189 : 		return;

  0011e	0f 85 12 ff ff
	ff		 jne	 $LN21@CGPCharact
$LN11@CGPCharact:

; 3190 : 	}
; 3191 : 
; 3192 : 	if ( lpMsg->ClassSkin == 0x50 ) // season4 add-on Summoner fix antihack

  00124	3c 50		 cmp	 al, 80			; 00000050H
  00126	75 0e		 jne	 SHORT $LN9@CGPCharact
$LN20@CGPCharact:

; 3193 : 	{
; 3194 : 		if ( gObj[aIndex].Summoner != 1 )

  00128	80 bc 0f 84 20
	00 00 01	 cmp	 BYTE PTR [edi+ecx+8324], 1

; 3195 : 		{
; 3196 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 3197 : 			return;

  00130	0f 85 00 ff ff
	ff		 jne	 $LN21@CGPCharact
$LN9@CGPCharact:

; 3198 : 		}
; 3199 : 	}
; 3200 : 
; 3201 : 	if ( lpMsg->ClassSkin == 0x30 ) // MG

  00136	3c 30		 cmp	 al, 48			; 00000030H
  00138	75 37		 jne	 SHORT $LN7@CGPCharact

; 3202 : 	{
; 3203 : 		if ( gObj[aIndex].Magumsa == 0 )

  0013a	80 7c 0f 34 00	 cmp	 BYTE PTR [edi+ecx+52], 0
  0013f	75 30		 jne	 SHORT $LN7@CGPCharact

; 3204 : 		{
; 3205 : 			LogAddC(2, "error-L1: Magumsa Character create error [%s]", gObj[aIndex].AccountID);

  00141	8d 54 0f 6c	 lea	 edx, DWORD PTR [edi+ecx+108]
  00145	52		 push	 edx
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@
$LN22@CGPCharact:
  0014b	6a 02		 push	 2
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 3206 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00153	83 c6 04	 add	 esi, 4
  00156	56		 push	 esi
$LN23@CGPCharact:
  00157	53		 push	 ebx
  00158	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  0015d	83 c4 14	 add	 esp, 20			; 00000014H
  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx

; 3266 : }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN7@CGPCharact:

; 3207 : 			return;
; 3208 : 		}
; 3209 : 	}
; 3210 : 
; 3211 : 	if ( lpMsg->ClassSkin == 0x40 ) // DL

  00171	3c 40		 cmp	 al, 64			; 00000040H
  00173	75 13		 jne	 SHORT $LN5@CGPCharact

; 3212 : 	{
; 3213 : 		if ( gObj[aIndex].Magumsa != 2 )

  00175	80 7c 0f 34 02	 cmp	 BYTE PTR [edi+ecx+52], 2
  0017a	74 0c		 je	 SHORT $LN5@CGPCharact

; 3214 : 		{
; 3215 : 			LogAddC(2, "error-L1: Darklord Character create error [%s]", gObj[aIndex].AccountID);

  0017c	8d 44 0f 6c	 lea	 eax, DWORD PTR [edi+ecx+108]
  00180	50		 push	 eax
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@

; 3216 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 3217 : 			return;

  00186	eb c3		 jmp	 SHORT $LN22@CGPCharact
$LN5@CGPCharact:

; 3218 : 		}
; 3219 : 	}
; 3220 : #ifdef SNAKER_CHN_LANG
; 3221 : 	if(g_ZtLicense.CheckUser(eZtUB::snaker) || 
; 3222 : 		g_ZtLicense.CheckUser(eZtUB::Local) || 
; 3223 : 		g_ZtLicense.CheckUser(eZtUB::masonX) ||
; 3224 : 		g_ZtLicense.CheckUser(eZtUB::AlterMU)
; 3225 : 		)

  00188	6a 1e		 push	 30			; 0000001eH
  0018a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0018f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00194	84 c0		 test	 al, al
  00196	75 77		 jne	 SHORT $LN3@CGPCharact
  00198	6a 00		 push	 0
  0019a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0019f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001a4	84 c0		 test	 al, al
  001a6	75 67		 jne	 SHORT $LN3@CGPCharact
  001a8	6a 3c		 push	 60			; 0000003cH
  001aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001af	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001b4	84 c0		 test	 al, al
  001b6	75 57		 jne	 SHORT $LN3@CGPCharact
  001b8	6a 3e		 push	 62			; 0000003eH
  001ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001bf	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001c4	84 c0		 test	 al, al
  001c6	75 47		 jne	 SHORT $LN3@CGPCharact

; 3226 : 	{
; 3227 : 
; 3228 : 	}
; 3229 : 	else
; 3230 : 	{
; 3231 : 			if(!ztCheckSimbol(lpMsg->Name, strlen(lpMsg->Name)))

  001c8	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  001cb	8b c2		 mov	 eax, edx
  001cd	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  001d0	89 55 a8	 mov	 DWORD PTR tv323[ebp], edx
  001d3	89 4d ac	 mov	 DWORD PTR tv374[ebp], ecx
$LL18@CGPCharact:
  001d6	8a 08		 mov	 cl, BYTE PTR [eax]
  001d8	40		 inc	 eax
  001d9	84 c9		 test	 cl, cl
  001db	75 f9		 jne	 SHORT $LL18@CGPCharact
  001dd	2b 45 ac	 sub	 eax, DWORD PTR tv374[ebp]
  001e0	50		 push	 eax
  001e1	52		 push	 edx
  001e2	e8 00 00 00 00	 call	 ?ztCheckSimbol@@YA_NPADH@Z ; ztCheckSimbol
  001e7	83 c4 08	 add	 esp, 8
  001ea	84 c0		 test	 al, al
  001ec	75 21		 jne	 SHORT $LN3@CGPCharact

; 3232 : 			{
; 3233 : 				LogAddC(2, "Simbol Character create error [%s]", gObj[aIndex].AccountID);

  001ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f4	8d 44 17 6c	 lea	 eax, DWORD PTR [edi+edx+108]
  001f8	50		 push	 eax
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KELNHOGA@Simbol?5Character?5create?5error?5?$FL?$CF@
  001fe	6a 02		 push	 2
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 3234 : 				JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00206	8b 4d a8	 mov	 ecx, DWORD PTR tv323[ebp]
  00209	51		 push	 ecx

; 3235 : 				return;

  0020a	e9 48 ff ff ff	 jmp	 $LN23@CGPCharact
$LN3@CGPCharact:

; 3236 : 			}
; 3237 : 	}
; 3238 : #else
; 3239 : 
; 3240 : 	if(!ztCheckSimbol(lpMsg->Name, strlen(lpMsg->Name)))
; 3241 : 	{
; 3242 : 		LogAddC(2, "Simbol Character create error [%s]", gObj[aIndex].AccountID);
; 3243 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 3244 : 		return;
; 3245 : 	}
; 3246 : #endif
; 3247 : 
; 3248 : 	SDHP_CREATECHAR sCreate;
; 3249 : 
; 3250 : 	memset(&sCreate, 0, sizeof(sCreate));

  0020f	33 c0		 xor	 eax, eax

; 3251 : 	PHeadSetB((LPBYTE)&sCreate, 0x04, sizeof(sCreate));

  00211	6a 24		 push	 36			; 00000024H
  00213	8d 55 b0	 lea	 edx, DWORD PTR _sCreate$[ebp]
  00216	6a 04		 push	 4
  00218	52		 push	 edx
  00219	89 45 b0	 mov	 DWORD PTR _sCreate$[ebp], eax
  0021c	89 45 b4	 mov	 DWORD PTR _sCreate$[ebp+4], eax
  0021f	89 45 b8	 mov	 DWORD PTR _sCreate$[ebp+8], eax
  00222	89 45 bc	 mov	 DWORD PTR _sCreate$[ebp+12], eax
  00225	89 45 c0	 mov	 DWORD PTR _sCreate$[ebp+16], eax
  00228	89 45 c4	 mov	 DWORD PTR _sCreate$[ebp+20], eax
  0022b	89 45 c8	 mov	 DWORD PTR _sCreate$[ebp+24], eax
  0022e	89 45 cc	 mov	 DWORD PTR _sCreate$[ebp+28], eax
  00231	89 45 d0	 mov	 DWORD PTR _sCreate$[ebp+32], eax
  00234	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3252 : 	sCreate.ClassSkin = lpMsg->ClassSkin;

  00239	8a 46 0e	 mov	 al, BYTE PTR [esi+14]
  0023c	88 45 d2	 mov	 BYTE PTR _sCreate$[ebp+34], al

; 3253 : 	sCreate.Number = aIndex;
; 3254 : 	memcpy(sCreate.AccountId, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  0023f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00244	66 89 5d bc	 mov	 WORD PTR _sCreate$[ebp+12], bx
  00248	8b 4c 07 6c	 mov	 ecx, DWORD PTR [edi+eax+108]
  0024c	89 4d be	 mov	 DWORD PTR _sCreate$[ebp+14], ecx
  0024f	8b 54 07 70	 mov	 edx, DWORD PTR [edi+eax+112]
  00253	89 55 c2	 mov	 DWORD PTR _sCreate$[ebp+18], edx
  00256	66 8b 44 07 74	 mov	 ax, WORD PTR [edi+eax+116]

; 3255 : 	memcpy(sCreate.Name, lpMsg->Name, MAX_ACCOUNT_LEN);

  0025b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0025e	89 7d c8	 mov	 DWORD PTR _sCreate$[ebp+24], edi
  00261	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00264	89 7d cc	 mov	 DWORD PTR _sCreate$[ebp+28], edi
  00267	66 8b 7e 0c	 mov	 di, WORD PTR [esi+12]
  0026b	66 89 7d d0	 mov	 WORD PTR _sCreate$[ebp+32], di

; 3256 : 	char szTemp[20];
; 3257 : 	char szTemp2[20];
; 3258 : 	szTemp[10]=0;
; 3259 : 	szTemp2[10]=0;
; 3260 : 	memcpy(szTemp, sCreate.Name, MAX_ACCOUNT_LEN);

  0026f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 3261 : 	memcpy(szTemp2, sCreate.AccountId, MAX_ACCOUNT_LEN);

  00272	89 4d d4	 mov	 DWORD PTR _szTemp2$[ebp], ecx

; 3262 : 
; 3263 : 	LogAddTD("Character create : %s,%s", szTemp2, szTemp);

  00275	8d 4d e8	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00278	89 55 d8	 mov	 DWORD PTR _szTemp2$[ebp+4], edx
  0027b	51		 push	 ecx
  0027c	8d 55 d4	 lea	 edx, DWORD PTR _szTemp2$[ebp]
  0027f	89 7d e8	 mov	 DWORD PTR _szTemp$[ebp], edi
  00282	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00285	66 8b 76 0c	 mov	 si, WORD PTR [esi+12]
  00289	52		 push	 edx
  0028a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@
  0028f	66 89 45 c6	 mov	 WORD PTR _sCreate$[ebp+22], ax
  00293	c6 45 f2 00	 mov	 BYTE PTR _szTemp$[ebp+10], 0
  00297	c6 45 de 00	 mov	 BYTE PTR _szTemp2$[ebp+10], 0
  0029b	89 7d ec	 mov	 DWORD PTR _szTemp$[ebp+4], edi
  0029e	66 89 75 f0	 mov	 WORD PTR _szTemp$[ebp+8], si
  002a2	66 89 45 dc	 mov	 WORD PTR _szTemp2$[ebp+8], ax
  002a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3264 : 
; 3265 : 	cDBSMng.Send((char*)&sCreate, sCreate.h.size);

  002ac	0f b6 45 b1	 movzx	 eax, BYTE PTR _sCreate$[ebp+1]
  002b0	83 c4 18	 add	 esp, 24			; 00000018H
  002b3	50		 push	 eax
  002b4	8d 4d b0	 lea	 ecx, DWORD PTR _sCreate$[ebp]
  002b7	51		 push	 ecx
  002b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002bd	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3266 : }

  002c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c5	5f		 pop	 edi
  002c6	5e		 pop	 esi
  002c7	33 cd		 xor	 ecx, ebp
  002c9	5b		 pop	 ebx
  002ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cf	8b e5		 mov	 esp, ebp
  002d1	5d		 pop	 ebp
  002d2	c3		 ret	 0
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ENDP	; CGPCharacterCreate
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ ; `string'
PUBLIC	??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z		; CGPCharDel
EXTRN	?GDReqPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemDelete
EXTRN	?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A:BYTE ; g_CashItemPeriodSystem
EXTRN	?gObjJoominCheck@@YA_NHPAD@Z:PROC		; gObjJoominCheck
EXTRN	?GetActivePC@CAccountSecurity@@QAE_NH@Z:PROC	; CAccountSecurity::GetActivePC
EXTRN	?g_AccountSecurity@@3VCAccountSecurity@@A:BYTE	; g_AccountSecurity
EXTRN	?gGuildDestroy@@3HA:DWORD			; gGuildDestroy
;	COMDAT ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@ DB 'Character'
	DB	' delete : %s,%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
CONST	SEGMENT
??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ DB '[A'
	DB	'nti-HACK][CGPCharDel] Attempted Character Delete during Preve'
	DB	'nted Time. [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
CONST	SEGMENT
??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ DB '[An'
	DB	'ti-HACK][CGPCharDel] Attempted Character Delete during GamePl'
	DB	'ay. [%s][%s]', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z
_TEXT	SEGMENT
_pResult$ = -100					; size = 5
_pCDel$ = -92						; size = 36
_szTemp2$ = -56						; size = 20
_szTemp$ = -36						; size = 20
_szJoomin$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z PROC		; CGPCharDel, COMDAT

; 3394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3395 : 	#if(ENABLE_MULTI_CHAR)
; 3396 : 
; 3397 : 	if(OBJMAX_RANGE(aIndex))
; 3398 : 	{
; 3399 : 		if(gObj[aIndex].m_CharPage > 0)
; 3400 : 		{
; 3401 : 			CGPCharDel_Multi((PMSG_CHARDELETE *) lpMsg, aIndex);
; 3402 : 
; 3403 : 			return;
; 3404 : 		}
; 3405 : 	}
; 3406 : 
; 3407 : 	#endif
; 3408 : 
; 3409 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001d	57		 push	 edi
  0001e	8b fe		 mov	 edi, esi
  00020	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00026	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	0f 84 9c 02 00
	00		 je	 $LN12@CGPCharDel

; 3410 : 	{
; 3411 : 		return;
; 3412 : 	}
; 3413 : 
; 3414 : 	if ( gObj[aIndex].Connected < PLAYER_LOGGED )

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  00043	83 f9 02	 cmp	 ecx, 2
  00046	7d 1a		 jge	 SHORT $LN10@CGPCharDel

; 3415 : 	{
; 3416 : 		CloseClient(aIndex);

  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004e	83 c4 04	 add	 esp, 4
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx

; 3509 : }

  00054	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00057	33 cd		 xor	 ecx, ebp
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN10@CGPCharDel:

; 3417 : 		return;
; 3418 : 	}
; 3419 : 
; 3420 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00062	83 f9 03	 cmp	 ecx, 3
  00065	75 2f		 jne	 SHORT $LN9@CGPCharDel

; 3421 : 	{
; 3422 : 		LogAddTD("[Anti-HACK][CGPCharDel] Attempted Character Delete during GamePlay. [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00067	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  0006b	52		 push	 edx
  0006c	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  00070	50		 push	 eax
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3423 : 		CloseClient(aIndex);

  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00082	83 c4 10	 add	 esp, 16			; 00000010H
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 3509 : }

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN9@CGPCharDel:

; 3424 : 		return;
; 3425 : 	}
; 3426 : 
; 3427 : 	if ( gObj[aIndex].bEnableDelCharacter == FALSE )

  00096	83 7c 07 0c 00	 cmp	 DWORD PTR [edi+eax+12], 0
  0009b	75 2f		 jne	 SHORT $LN8@CGPCharDel

; 3428 : 	{
; 3429 : 		LogAddTD("[Anti-HACK][CGPCharDel] Attempted Character Delete during Prevented Time. [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0009d	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  000a1	51		 push	 ecx
  000a2	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  000a6	52		 push	 edx
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3430 : 		CloseClient(aIndex);

  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000b8	83 c4 10	 add	 esp, 16			; 00000010H
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx

; 3509 : }

  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN8@CGPCharDel:

; 3431 : 		return;
; 3432 : 	}
; 3433 : 
; 3434 : 	SDHP_CHARDELETE pCDel;
; 3435 : 	PMSG_RESULT pResult;
; 3436 : 
; 3437 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF3, 0x02, sizeof(pResult));

  000cc	6a 05		 push	 5
  000ce	6a 02		 push	 2
  000d0	8d 45 9c	 lea	 eax, DWORD PTR _pResult$[ebp]
  000d3	68 f3 00 00 00	 push	 243			; 000000f3H
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3438 : 	pResult.result = 0;
; 3439 : 
; 3440 : 	if ( gObj[aIndex].m_cAccountItemBlock )

  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e4	83 c4 10	 add	 esp, 16			; 00000010H
  000e7	c6 45 a0 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  000eb	80 bc 0f 14 02
	00 00 00	 cmp	 BYTE PTR [edi+ecx+532], 0
  000f3	74 27		 je	 SHORT $LN7@CGPCharDel

; 3441 : 	{
; 3442 : 		pResult.result = 3;
; 3443 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000f5	0f b6 55 9d	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  000f9	52		 push	 edx
  000fa	8d 45 9c	 lea	 eax, DWORD PTR _pResult$[ebp]
  000fd	50		 push	 eax
  000fe	56		 push	 esi
  000ff	c6 45 a0 03	 mov	 BYTE PTR _pResult$[ebp+4], 3
  00103	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 3509 : }

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN7@CGPCharDel:

; 3444 : 		return;
; 3445 : 	}
; 3446 : 
; 3447 : 	if ( !gGuildDestroy )

  0011c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  00123	75 27		 jne	 SHORT $LN6@CGPCharDel

; 3448 : 	{
; 3449 : 		pResult.result = 0;
; 3450 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00125	0f b6 4d 9d	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00129	51		 push	 ecx
  0012a	8d 55 9c	 lea	 edx, DWORD PTR _pResult$[ebp]
  0012d	52		 push	 edx
  0012e	56		 push	 esi
  0012f	c6 45 a0 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  00133	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 3509 : }

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	33 cd		 xor	 ecx, ebp
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
$LN6@CGPCharDel:

; 3451 : 		return;
; 3452 : 	}
; 3453 : 
; 3454 : #if(CUSTOM_ACCOUNT_SECURITY)
; 3455 : 
; 3456 : 	if(g_AccountSecurity.GetActivePC(aIndex))

  0014c	56		 push	 esi
  0014d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  00152	e8 00 00 00 00	 call	 ?GetActivePC@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::GetActivePC
  00157	84 c0		 test	 al, al
  00159	74 27		 je	 SHORT $LN5@CGPCharDel

; 3457 : 	{
; 3458 : 		pResult.result = 0;

  0015b	c6 45 a0 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
$LN18@CGPCharDel:

; 3459 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0015f	0f b6 45 9d	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00163	50		 push	 eax
  00164	8d 4d 9c	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00167	51		 push	 ecx
  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx

; 3509 : }

  00174	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00177	33 cd		 xor	 ecx, ebp
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
$LN5@CGPCharDel:

; 3460 : 		return;
; 3461 : 	}
; 3462 : 
; 3463 : #endif
; 3464 : 
; 3465 : 	char szJoomin[11];
; 3466 : 	char szTemp[20];
; 3467 : 	char szTemp2[20];
; 3468 : 
; 3469 : 	memset(szJoomin, 0, sizeof(szJoomin));
; 3470 : 	memcpy(szJoomin, lpMsg->LastJoominNumber, 10);

  00182	8b 53 0e	 mov	 edx, DWORD PTR [ebx+14]
  00185	66 8b 4b 16	 mov	 cx, WORD PTR [ebx+22]
  00189	33 c0		 xor	 eax, eax
  0018b	89 45 f0	 mov	 DWORD PTR _szJoomin$[ebp], eax
  0018e	89 55 f0	 mov	 DWORD PTR _szJoomin$[ebp], edx

; 3471 : 
; 3472 : 	if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00191	8d 55 f0	 lea	 edx, DWORD PTR _szJoomin$[ebp]
  00194	89 45 f4	 mov	 DWORD PTR _szJoomin$[ebp+4], eax
  00197	66 89 45 f8	 mov	 WORD PTR _szJoomin$[ebp+8], ax
  0019b	88 45 fa	 mov	 BYTE PTR _szJoomin$[ebp+10], al
  0019e	8b 43 12	 mov	 eax, DWORD PTR [ebx+18]
  001a1	52		 push	 edx
  001a2	56		 push	 esi
  001a3	89 45 f4	 mov	 DWORD PTR _szJoomin$[ebp+4], eax
  001a6	66 89 4d f8	 mov	 WORD PTR _szJoomin$[ebp+8], cx
  001aa	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YA_NHPAD@Z ; gObjJoominCheck
  001af	83 c4 08	 add	 esp, 8
  001b2	84 c0		 test	 al, al
  001b4	75 06		 jne	 SHORT $LN4@CGPCharDel

; 3473 : 	{
; 3474 : 		pResult.result = 2;

  001b6	c6 45 a0 02	 mov	 BYTE PTR _pResult$[ebp+4], 2

; 3475 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3476 : 		return;

  001ba	eb a3		 jmp	 SHORT $LN18@CGPCharDel
$LN4@CGPCharDel:

; 3477 : 	}
; 3478 : 
; 3479 : 	PHeadSetB((LPBYTE)&pCDel, 0x05, sizeof(pCDel));

  001bc	6a 24		 push	 36			; 00000024H
  001be	8d 55 a4	 lea	 edx, DWORD PTR _pCDel$[ebp]
  001c1	6a 05		 push	 5
  001c3	52		 push	 edx
  001c4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3480 : 	pCDel.Number = aIndex;
; 3481 : 	memcpy(pCDel.AccountID, gObj[aIndex].AccountID, sizeof(pCDel.AccountID));

  001c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ce	03 c7		 add	 eax, edi
  001d0	66 89 75 a8	 mov	 WORD PTR _pCDel$[ebp+4], si
  001d4	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  001d7	89 4d aa	 mov	 DWORD PTR _pCDel$[ebp+6], ecx
  001da	8b 50 70	 mov	 edx, DWORD PTR [eax+112]

; 3482 : 	memcpy(pCDel.Name, lpMsg->Name, sizeof(pCDel.Name));

  001dd	83 c3 04	 add	 ebx, 4
  001e0	89 55 ae	 mov	 DWORD PTR _pCDel$[ebp+10], edx
  001e3	66 8b 48 74	 mov	 cx, WORD PTR [eax+116]
  001e7	8b 13		 mov	 edx, DWORD PTR [ebx]
  001e9	66 89 4d b2	 mov	 WORD PTR _pCDel$[ebp+14], cx
  001ed	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001f0	89 55 b4	 mov	 DWORD PTR _pCDel$[ebp+16], edx
  001f3	66 8b 53 08	 mov	 dx, WORD PTR [ebx+8]
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fa	89 4d b8	 mov	 DWORD PTR _pCDel$[ebp+20], ecx
  001fd	66 89 55 bc	 mov	 WORD PTR _pCDel$[ebp+24], dx

; 3483 : 	pCDel.Guild = 0;

  00201	c6 45 be 00	 mov	 BYTE PTR _pCDel$[ebp+26], 0

; 3484 : 
; 3485 : 	if ( gObj[aIndex].GuildNumber > 0 && gObj[aIndex].lpGuild != NULL)

  00205	83 b8 34 04 00
	00 00		 cmp	 DWORD PTR [eax+1076], 0
  0020c	7e 53		 jle	 SHORT $LN3@CGPCharDel
  0020e	8b b0 38 04 00
	00		 mov	 esi, DWORD PTR [eax+1080]
  00214	85 f6		 test	 esi, esi
  00216	74 49		 je	 SHORT $LN3@CGPCharDel

; 3486 : 	{
; 3487 : 		if ( !strcmp(gObj[aIndex].Name, gObj[aIndex].lpGuild->Names[0] ))

  00218	83 c6 2f	 add	 esi, 47			; 0000002fH
  0021b	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  0021e	8b ff		 npad	 2
$LL14@CGPCharDel:
  00220	8a 11		 mov	 dl, BYTE PTR [ecx]
  00222	3a 16		 cmp	 dl, BYTE PTR [esi]
  00224	75 1a		 jne	 SHORT $LN15@CGPCharDel
  00226	84 d2		 test	 dl, dl
  00228	74 12		 je	 SHORT $LN16@CGPCharDel
  0022a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0022d	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  00230	75 0e		 jne	 SHORT $LN15@CGPCharDel
  00232	83 c1 02	 add	 ecx, 2
  00235	83 c6 02	 add	 esi, 2
  00238	84 d2		 test	 dl, dl
  0023a	75 e4		 jne	 SHORT $LL14@CGPCharDel
$LN16@CGPCharDel:
  0023c	33 c9		 xor	 ecx, ecx
  0023e	eb 05		 jmp	 SHORT $LN17@CGPCharDel
$LN15@CGPCharDel:
  00240	1b c9		 sbb	 ecx, ecx
  00242	83 d9 ff	 sbb	 ecx, -1
$LN17@CGPCharDel:
  00245	85 c9		 test	 ecx, ecx
  00247	0f 95 c1	 setne	 cl
  0024a	fe c1		 inc	 cl
  0024c	88 4d be	 mov	 BYTE PTR _pCDel$[ebp+26], cl

; 3488 : 		{
; 3489 : 			pCDel.Guild = 1;	// Master
; 3490 : 		}
; 3491 : 		else
; 3492 : 		{
; 3493 : 			pCDel.Guild = 2;	// Member
; 3494 : 		}
; 3495 : 
; 3496 : 		memcpy(pCDel.GuildName, gObj[aIndex].lpGuild->Name, MAX_GUILD_LEN);

  0024f	8b 88 38 04 00
	00		 mov	 ecx, DWORD PTR [eax+1080]
  00255	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00258	89 55 bf	 mov	 DWORD PTR _pCDel$[ebp+27], edx
  0025b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0025e	89 4d c3	 mov	 DWORD PTR _pCDel$[ebp+31], ecx
$LN3@CGPCharDel:

; 3497 : 	}
; 3498 : 
; 3499 : 	g_CashItemPeriodSystem.GDReqPeriodItemDelete(&gObj[aIndex], lpMsg->Name);

  00261	53		 push	 ebx
  00262	50		 push	 eax
  00263	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00268	e8 00 00 00 00	 call	 ?GDReqPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CCashItemPeriodSystem::GDReqPeriodItemDelete

; 3500 : 	szTemp[10]=0;
; 3501 : 	szTemp2[10]=0;
; 3502 : 	memcpy(szTemp, pCDel.Name, MAX_ACCOUNT_LEN);

  0026d	8b 55 b4	 mov	 edx, DWORD PTR _pCDel$[ebp+16]
  00270	8b 45 b8	 mov	 eax, DWORD PTR _pCDel$[ebp+20]
  00273	0f b7 4d bc	 movzx	 ecx, WORD PTR _pCDel$[ebp+24]
  00277	89 55 dc	 mov	 DWORD PTR _szTemp$[ebp], edx

; 3503 : 	memcpy(szTemp2, pCDel.AccountID, MAX_ACCOUNT_LEN);

  0027a	8b 55 aa	 mov	 edx, DWORD PTR _pCDel$[ebp+6]
  0027d	89 45 e0	 mov	 DWORD PTR _szTemp$[ebp+4], eax
  00280	8b 45 ae	 mov	 eax, DWORD PTR _pCDel$[ebp+10]
  00283	89 55 c8	 mov	 DWORD PTR _szTemp2$[ebp], edx

; 3504 : 
; 3505 : 	LogAddTD("Character delete : %s,%s", szTemp2, szTemp);

  00286	8d 55 dc	 lea	 edx, DWORD PTR _szTemp$[ebp]
  00289	89 45 cc	 mov	 DWORD PTR _szTemp2$[ebp+4], eax
  0028c	52		 push	 edx
  0028d	66 89 4d e4	 mov	 WORD PTR _szTemp$[ebp+8], cx
  00291	0f b7 4d b2	 movzx	 ecx, WORD PTR _pCDel$[ebp+14]
  00295	8d 45 c8	 lea	 eax, DWORD PTR _szTemp2$[ebp]
  00298	50		 push	 eax
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@
  0029e	c6 45 e6 00	 mov	 BYTE PTR _szTemp$[ebp+10], 0
  002a2	c6 45 d2 00	 mov	 BYTE PTR _szTemp2$[ebp+10], 0
  002a6	66 89 4d d0	 mov	 WORD PTR _szTemp2$[ebp+8], cx
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3506 : 
; 3507 : 	cDBSMng.Send((char*)&pCDel, pCDel.h.size);

  002b0	0f b6 4d a5	 movzx	 ecx, BYTE PTR _pCDel$[ebp+1]
  002b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b7	51		 push	 ecx
  002b8	8d 55 a4	 lea	 edx, DWORD PTR _pCDel$[ebp]
  002bb	52		 push	 edx
  002bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002c1	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3508 : 	gObj[aIndex].Level = 0;

  002c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cc	33 c0		 xor	 eax, eax
  002ce	66 89 84 0f be
	00 00 00	 mov	 WORD PTR [edi+ecx+190], ax
$LN12@CGPCharDel:

; 3509 : }

  002d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d9	5f		 pop	 edi
  002da	5e		 pop	 esi
  002db	33 cd		 xor	 ecx, ebp
  002dd	5b		 pop	 ebx
  002de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ENDP		; CGPCharDel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
EXTRN	?gGensSystem@@3VGensSystem@@A:BYTE		; gGensSystem
EXTRN	?gGENS@@3HA:DWORD				; gGENS
EXTRN	?SelectCharacter@CAccountSecurity@@QAE_NH@Z:PROC ; CAccountSecurity::SelectCharacter
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
; Function compile flags: /Ogtp
;	COMDAT ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z
_TEXT	SEGMENT
_pCRequest$ = -72					; size = 28
_Result$245415 = -44					; size = 25
__name$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z PROC ; CGPCharacterMapJoinRequest, COMDAT

; 3630 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3631 : 
; 3632 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi
  0001a	8b f3		 mov	 esi, ebx
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	57		 push	 edi
  00023	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00026	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	0f 84 41 01 00
	00		 je	 $LN7@CGPCharact@2

; 3633 : 	{
; 3634 : 		return;
; 3635 : 	}
; 3636 : 
; 3637 : 	if ( !gObjIsAccontConnect(aIndex, gObj[aIndex].AccountID))

  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	8d 44 16 6c	 lea	 eax, DWORD PTR [esi+edx+108]
  00044	50		 push	 eax
  00045	53		 push	 ebx
  00046	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0004b	83 c4 08	 add	 esp, 8
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 25 01 00
	00		 je	 $LN7@CGPCharact@2

; 3638 : 	{
; 3639 : 		return;
; 3640 : 	}
; 3641 : 
; 3642 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005c	83 7c 0e 04 03	 cmp	 DWORD PTR [esi+ecx+4], 3
  00061	0f 84 14 01 00
	00		 je	 $LN7@CGPCharact@2

; 3643 : 	{
; 3644 : 		return;
; 3645 : 	}
; 3646 : 
; 3647 : #if(CUSTOM_ACCOUNT_SECURITY)
; 3648 : 	if(!g_AccountSecurity.SelectCharacter(aIndex))

  00067	53		 push	 ebx
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  0006d	e8 00 00 00 00	 call	 ?SelectCharacter@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::SelectCharacter
  00072	84 c0		 test	 al, al
  00074	0f 84 01 01 00
	00		 je	 $LN7@CGPCharact@2

; 3649 : 	{
; 3650 : 		return;
; 3651 : 	}
; 3652 : #endif
; 3653 : 
; 3654 : 	gObj[aIndex].bEnableDelCharacter = FALSE;

  0007a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3655 : 
; 3656 : 	char _name[MAX_ACCOUNT_LEN+1];
; 3657 : 	SDHP_DBCHARINFOREQUEST pCRequest;
; 3658 : 
; 3659 : 	PHeadSetB((LPBYTE)&pCRequest, 0x06, sizeof(pCRequest));

  00080	6a 1c		 push	 28			; 0000001cH
  00082	8d 45 b8	 lea	 eax, DWORD PTR _pCRequest$[ebp]
  00085	6a 06		 push	 6
  00087	50		 push	 eax
  00088	c7 44 16 0c 00
	00 00 00	 mov	 DWORD PTR [esi+edx+12], 0
  00090	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3660 : 	memset(_name, 0, MAX_ACCOUNT_LEN);
; 3661 : 	memcpy(_name, lpMsg->Name, MAX_ACCOUNT_LEN);

  00095	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00098	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0009b	33 c0		 xor	 eax, eax
  0009d	89 45 f0	 mov	 DWORD PTR __name$[ebp], eax
  000a0	89 45 f4	 mov	 DWORD PTR __name$[ebp+4], eax
  000a3	66 89 45 f8	 mov	 WORD PTR __name$[ebp+8], ax
  000a7	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  000ab	89 4d f0	 mov	 DWORD PTR __name$[ebp], ecx

; 3662 : 	BuxConvert(_name, MAX_ACCOUNT_LEN);

  000ae	8d 4d f0	 lea	 ecx, DWORD PTR __name$[ebp]
  000b1	6a 0a		 push	 10			; 0000000aH
  000b3	51		 push	 ecx
  000b4	89 55 f4	 mov	 DWORD PTR __name$[ebp+4], edx
  000b7	66 89 45 f8	 mov	 WORD PTR __name$[ebp+8], ax
  000bb	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 3663 : 	memcpy(pCRequest.Name, _name, MAX_ACCOUNT_LEN);

  000c0	8b 55 f0	 mov	 edx, DWORD PTR __name$[ebp]
  000c3	8b 45 f4	 mov	 eax, DWORD PTR __name$[ebp+4]
  000c6	66 8b 4d f8	 mov	 cx, WORD PTR __name$[ebp+8]
  000ca	89 55 c6	 mov	 DWORD PTR _pCRequest$[ebp+14], edx

; 3664 : 	strcpy(pCRequest.AccountID, gObj[aIndex].AccountID);

  000cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	89 45 ca	 mov	 DWORD PTR _pCRequest$[ebp+18], eax
  000d6	8d 44 16 6c	 lea	 eax, DWORD PTR [esi+edx+108]
  000da	8d 55 bb	 lea	 edx, DWORD PTR _pCRequest$[ebp+3]
  000dd	83 c4 14	 add	 esp, 20			; 00000014H
  000e0	66 89 4d ce	 mov	 WORD PTR _pCRequest$[ebp+22], cx
  000e4	2b d0		 sub	 edx, eax
$LL14@CGPCharact@2:
  000e6	8a 08		 mov	 cl, BYTE PTR [eax]
  000e8	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000eb	40		 inc	 eax
  000ec	84 c9		 test	 cl, cl
  000ee	75 f6		 jne	 SHORT $LL14@CGPCharact@2

; 3665 : 	pCRequest.Number = aIndex;
; 3666 : 
; 3667 : 	cDBSMng.Send((char*)&pCRequest, pCRequest.h.size);

  000f0	0f b6 45 b9	 movzx	 eax, BYTE PTR _pCRequest$[ebp+1]
  000f4	50		 push	 eax
  000f5	8d 4d b8	 lea	 ecx, DWORD PTR _pCRequest$[ebp]
  000f8	51		 push	 ecx
  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000fe	66 89 5d d2	 mov	 WORD PTR _pCRequest$[ebp+26], bx
  00102	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3668 : 
; 3669 : 	if(gGENS)

  00107	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  0010e	74 6b		 je	 SHORT $LN7@CGPCharact@2

; 3670 : 	{
; 3671 : 		PMSG_BATTLE_LIST Result;
; 3672 : 		// ----
; 3673 : 		PHeadSetB((LPBYTE)&Result, 0xFC, sizeof(Result));

  00110	6a 19		 push	 25			; 00000019H
  00112	8d 55 d4	 lea	 edx, DWORD PTR _Result$245415[ebp]
  00115	68 fc 00 00 00	 push	 252			; 000000fcH
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3674 : 		// ----
; 3675 : 		for(int i = 0; i < MAX_BATTLE_ZONE; i++ )
; 3676 : 		{
; 3677 : 			Result.BattleMapList[i]		= gGensSystem.BattleMapList[i];

  00120	a1 0f 00 00 00	 mov	 eax, DWORD PTR ?gGensSystem@@3VGensSystem@@A+15
  00125	66 8b 15 17 00
	00 00		 mov	 dx, WORD PTR ?gGensSystem@@3VGensSystem@@A+23
  0012c	8b 0d 13 00 00
	00		 mov	 ecx, DWORD PTR ?gGensSystem@@3VGensSystem@@A+19
  00132	89 45 d7	 mov	 DWORD PTR _Result$245415[ebp+3], eax
  00135	a0 19 00 00 00	 mov	 al, BYTE PTR ?gGensSystem@@3VGensSystem@@A+25
  0013a	66 89 55 df	 mov	 WORD PTR _Result$245415[ebp+11], dx

; 3678 : 		}
; 3679 : 		// ----
; 3680 : 		for(int i = 0; i < MAX_BATTLE_ZONE; i++ )
; 3681 : 		{
; 3682 : 			Result.BattleZoneList[i]	= gGensSystem.BattleZoneList[i];

  0013e	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?gGensSystem@@3VGensSystem@@A+8
  00144	88 45 e1	 mov	 BYTE PTR _Result$245415[ebp+13], al
  00147	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?gGensSystem@@3VGensSystem@@A+12
  0014d	89 55 e6	 mov	 DWORD PTR _Result$245415[ebp+18], edx

; 3683 : 		}
; 3684 : 		// ----
; 3685 : 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  00150	0f b6 55 d5	 movzx	 edx, BYTE PTR _Result$245415[ebp+1]
  00154	89 4d db	 mov	 DWORD PTR _Result$245415[ebp+7], ecx
  00157	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?gGensSystem@@3VGensSystem@@A+4
  0015d	66 89 45 ea	 mov	 WORD PTR _Result$245415[ebp+22], ax
  00161	52		 push	 edx
  00162	8d 45 d4	 lea	 eax, DWORD PTR _Result$245415[ebp]
  00165	89 4d e2	 mov	 DWORD PTR _Result$245415[ebp+14], ecx
  00168	8a 0d 0e 00 00
	00		 mov	 cl, BYTE PTR ?gGensSystem@@3VGensSystem@@A+14
  0016e	50		 push	 eax
  0016f	53		 push	 ebx
  00170	88 4d ec	 mov	 BYTE PTR _Result$245415[ebp+24], cl
  00173	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00178	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@CGPCharact@2:

; 3686 : 	}
; 3687 : }

  0017b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	33 cd		 xor	 ecx, ebp
  00182	5b		 pop	 ebx
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ENDP ; CGPCharacterMapJoinRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z	; CGLevelUpPointAdd
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?DestroyGIocp@@YAXXZ:PROC			; DestroyGIocp
EXTRN	?szAuthKey@@3PADA:BYTE				; szAuthKey
EXTRN	?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z:PROC ; gObjLevelUpPointAdd
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z
_TEXT	SEGMENT
tv262 = -24						; size = 4
tv260 = -24						; size = 4
tv254 = -24						; size = 4
tv252 = -24						; size = 4
tv265 = -18						; size = 2
tv257 = -18						; size = 2
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z PROC	; CGLevelUpPointAdd, COMDAT

; 3732 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 3733 : 	if ( !gObjIsConnected(aIndex))

  00018	53		 push	 ebx
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 19		 jne	 SHORT $LN7@CGLevelUpP

; 3734 : 	{
; 3735 : 		CloseClient(aIndex);

  00025	53		 push	 ebx
  00026	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0002b	83 c4 04	 add	 esp, 4
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx

; 3771 : 
; 3772 : }

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN7@CGLevelUpP:
  0003e	56		 push	 esi

; 3736 : 		return;
; 3737 : 	}
; 3738 : 
; 3739 : 	PMSG_LVPOINTADDRESULT pMsg;
; 3740 : 
; 3741 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x06, sizeof(pMsg));

  0003f	6a 0c		 push	 12			; 0000000cH
  00041	6a 06		 push	 6
  00043	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	68 f3 00 00 00	 push	 243			; 000000f3H
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3742 : 	pMsg.ResultType = 0;
; 3743 : 	
; 3744 : 	if (::gObjLevelUpPointAdd(lpMsg->Type, &gObj[aIndex]) == TRUE )

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0005b	8b f3		 mov	 esi, ebx
  0005d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00063	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	c6 45 f4 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0006c	e8 00 00 00 00	 call	 ?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z ; gObjLevelUpPointAdd
  00071	83 c4 18	 add	 esp, 24			; 00000018H
  00074	83 f8 01	 cmp	 eax, 1
  00077	0f 85 c2 00 00
	00		 jne	 $LN6@CGLevelUpP

; 3745 : 	{
; 3746 : 		pMsg.ResultType = 0x10;
; 3747 : 		pMsg.ResultType += lpMsg->Type;

  0007d	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00080	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]

; 3748 : 
; 3749 : 		switch ( lpMsg->Type )

  00083	0f b6 c0	 movzx	 eax, al
  00086	83 e8 02	 sub	 eax, 2
  00089	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00092	74 33		 je	 SHORT $LN3@CGLevelUpP
  00094	48		 dec	 eax
  00095	75 5e		 jne	 SHORT $LN4@CGLevelUpP

; 3753 : 				break;
; 3754 : 
; 3755 : 			case 3:	// Energy
; 3756 : 				pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana);

  00097	db 84 0e 50 01
	00 00		 fild	 DWORD PTR [esi+ecx+336]
  0009e	d9 7d ee	 fnstcw	 WORD PTR tv265[ebp]
  000a1	0f b7 45 ee	 movzx	 eax, WORD PTR tv265[ebp]
  000a5	d8 84 0e 14 01
	00 00		 fadd	 DWORD PTR [esi+ecx+276]
  000ac	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000b1	89 45 e8	 mov	 DWORD PTR tv262[ebp], eax
  000b4	d9 6d e8	 fldcw	 WORD PTR tv262[ebp]
  000b7	db 5d e8	 fistp	 DWORD PTR tv260[ebp]
  000ba	66 8b 55 e8	 mov	 dx, WORD PTR tv260[ebp]
  000be	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  000c2	d9 6d ee	 fldcw	 WORD PTR tv265[ebp]

; 3757 : 				break;

  000c5	eb 2e		 jmp	 SHORT $LN4@CGLevelUpP
$LN3@CGLevelUpP:

; 3750 : 		{
; 3751 : 			case 2:	// Vit
; 3752 : 				pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife);

  000c7	db 84 0e 4c 01
	00 00		 fild	 DWORD PTR [esi+ecx+332]
  000ce	d9 7d ee	 fnstcw	 WORD PTR tv257[ebp]
  000d1	0f b7 45 ee	 movzx	 eax, WORD PTR tv257[ebp]
  000d5	d8 84 0e 00 01
	00 00		 fadd	 DWORD PTR [esi+ecx+256]
  000dc	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000e1	89 45 e8	 mov	 DWORD PTR tv254[ebp], eax
  000e4	d9 6d e8	 fldcw	 WORD PTR tv254[ebp]
  000e7	db 5d e8	 fistp	 DWORD PTR tv252[ebp]
  000ea	66 8b 45 e8	 mov	 ax, WORD PTR tv252[ebp]
  000ee	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+6], ax
  000f2	d9 6d ee	 fldcw	 WORD PTR tv257[ebp]
$LN4@CGLevelUpP:

; 3758 : 		}
; 3759 : 
; 3760 : 		if ( szAuthKey[9] != AUTHKEY9 )

  000f5	80 3d 09 00 00
	00 90		 cmp	 BYTE PTR ?szAuthKey@@3PADA+9, -112 ; ffffff90H
  000fc	74 0b		 je	 SHORT $LN1@CGLevelUpP

; 3761 : 		{
; 3762 : 			DestroyGIocp();

  000fe	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN1@CGLevelUpP:

; 3763 : 		}
; 3764 : 
; 3765 : 		pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00109	66 8b 94 0e 5c
	01 00 00	 mov	 dx, WORD PTR [esi+ecx+348]
  00111	66 03 94 0e 58
	01 00 00	 add	 dx, WORD PTR [esi+ecx+344]

; 3766 : 		gObjSetBP(aIndex);

  00119	53		 push	 ebx
  0011a	66 89 55 f8	 mov	 WORD PTR _pMsg$[ebp+8], dx
  0011e	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 3767 : 		pMsg.MaxBP = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;

  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00128	66 8b 8c 06 30
	01 00 00	 mov	 cx, WORD PTR [esi+eax+304]
  00130	83 c4 04	 add	 esp, 4
  00133	66 03 8c 06 2c
	01 00 00	 add	 cx, WORD PTR [esi+eax+300]
  0013b	66 89 4d fa	 mov	 WORD PTR _pMsg$[ebp+10], cx
$LN6@CGLevelUpP:

; 3768 : 	}
; 3769 : 
; 3770 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0013f	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00143	52		 push	 edx
  00144	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00147	50		 push	 eax
  00148	53		 push	 ebx
  00149	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3771 : 
; 3772 : }

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	5e		 pop	 esi
  00155	5f		 pop	 edi
  00156	33 cd		 xor	 ecx, ebp
  00158	5b		 pop	 ebx
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ENDP	; CGLevelUpPointAdd
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCInventoryItemOneSend@@YAXHH@Z		; GCInventoryItemOneSend
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?GCInventoryItemOneSend@@YAXHH@Z
_TEXT	SEGMENT
_pos$GSCopy$ = -28					; size = 4
_pMsg$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCInventoryItemOneSend@@YAXHH@Z PROC			; GCInventoryItemOneSend, COMDAT

; 3775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3776 : 	if ( !gObj[aIndex].pInventory[pos].IsItem())

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _pos$[ebp]
  0001e	8b f3		 mov	 esi, ebx
  00020	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00026	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]

; 3777 : 	{
; 3778 : 		return;
; 3779 : 	}
; 3780 : 
; 3781 : 	PMSG_INVENTORYITEMMODIFY pMsg;
; 3782 : 
; 3783 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x14, sizeof(pMsg));

  0002d	89 7d e4	 mov	 DWORD PTR _pos$GSCopy$[ebp], edi
  00030	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00036	03 cf		 add	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003d	85 c0		 test	 eax, eax
  0003f	74 53		 je	 SHORT $LN2@GCInventor
  00041	6a 11		 push	 17			; 00000011H
  00043	6a 14		 push	 20			; 00000014H
  00045	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00048	68 f3 00 00 00	 push	 243			; 000000f3H
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3784 : 	pMsg.Pos = pos;

  00053	8a 55 e4	 mov	 dl, BYTE PTR _pos$GSCopy$[ebp]

; 3785 : 	ItemByteConvert(pMsg.ItemInfo, gObj[aIndex].pInventory[pos]);

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  0005e	8b b4 06 24 0e
	00 00		 mov	 esi, DWORD PTR [esi+eax+3620]
  00065	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  0006b	03 f7		 add	 esi, edi
  0006d	8b fc		 mov	 edi, esp
  0006f	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00074	f3 a5		 rep movsd
  00076	8d 4d ed	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 3786 : 
; 3787 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007f	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00083	52		 push	 edx
  00084	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00087	50		 push	 eax
  00088	53		 push	 ebx
  00089	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
$LN2@GCInventor:

; 3788 : }

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	33 cd		 xor	 ecx, ebp
  0009b	5b		 pop	 ebx
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?GCInventoryItemOneSend@@YAXHH@Z ENDP			; GCInventoryItemOneSend
_TEXT	ENDS
PUBLIC	?GCPkLevelSend@@YAXHE@Z				; GCPkLevelSend
; Function compile flags: /Ogtp
;	COMDAT ?GCPkLevelSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_pklevel$ = 12						; size = 1
?GCPkLevelSend@@YAXHE@Z PROC				; GCPkLevelSend, COMDAT

; 3791 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 3792 : 	PMSG_PKLEVEL pMsg;
; 3793 : 
; 3794 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x08, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	6a 08		 push	 8
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	68 f3 00 00 00	 push	 243			; 000000f3H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3795 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00019	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 3796 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 3797 : 	pMsg.PkLevel = pklevel;
; 3798 : 
; 3799 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00020	8a 55 0c	 mov	 dl, BYTE PTR _pklevel$[ebp]
  00023	8b cb		 mov	 ecx, ebx
  00025	c1 e9 08	 shr	 ecx, 8
  00028	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002b	50		 push	 eax
  0002c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002f	51		 push	 ecx
  00030	53		 push	 ebx
  00031	88 5d fd	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00034	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3800 : 	MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  0003c	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00042	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00046	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	52		 push	 edx
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00050	50		 push	 eax
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00057	83 c4 28	 add	 esp, 40			; 00000028H
  0005a	5b		 pop	 ebx

; 3801 : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GCPkLevelSend@@YAXHE@Z ENDP				; GCPkLevelSend
_TEXT	ENDS
PUBLIC	?CheckAuthorityCondition@@YA_NHPAUOBJECTSTRUCT@@@Z ; CheckAuthorityCondition
; Function compile flags: /Ogtp
;	COMDAT ?CheckAuthorityCondition@@YA_NHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_AuthorityCode$ = 8					; size = 4
_lpObj$ = 12						; size = 4
?CheckAuthorityCondition@@YA_NHPAUOBJECTSTRUCT@@@Z PROC	; CheckAuthorityCondition, COMDAT

; 3804 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3805 : 	return ((lpObj->Authority&AuthorityCode) == lpObj->Authority)?true:false;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 80 0c 02 00
	00		 mov	 eax, DWORD PTR [eax+524]
  0000c	8b c8		 mov	 ecx, eax
  0000e	23 4d 08	 and	 ecx, DWORD PTR _AuthorityCode$[ebp]
  00011	3b c8		 cmp	 ecx, eax
  00013	0f 94 c0	 sete	 al

; 3806 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?CheckAuthorityCondition@@YA_NHPAUOBJECTSTRUCT@@@Z ENDP	; CheckAuthorityCondition
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicListOneSend@@YAXHDGEGE@Z		; GCMagicListOneSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicListOneSend@@YAXHDGEGE@Z
_TEXT	SEGMENT
_pList$ = -1016						; size = 4
_pCount$ = -1012					; size = 6
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 2
_level$ = 20						; size = 1
_skill$ = 24						; size = 2
_btListType$ = 28					; size = 1
?GCMagicListOneSend@@YAXHDGEGE@Z PROC			; GCMagicListOneSend, COMDAT

; 3809 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3810 : 	PMSG_MAGICLISTCOUNT pCount;
; 3811 : 	PMSG_MAGICLIST pList;
; 3812 : 
; 3813 : 	BYTE sendbuf[1000];
; 3814 : 	int lOfs = sizeof(pCount);
; 3815 : 	
; 3816 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00013	6a 00		 push	 0
  00015	6a 11		 push	 17			; 00000011H
  00017	8d 85 0c fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0001d	68 f3 00 00 00	 push	 243			; 000000f3H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3817 : 	pCount.Count = 0xFE;
; 3818 : 	pCount.btListType = btListType;
; 3819 : 
; 3820 : 	pList.Pos = Pos;

  00028	8a 55 0c	 mov	 dl, BYTE PTR _Pos$[ebp]
  0002b	8a 4d 1c	 mov	 cl, BYTE PTR _btListType$[ebp]

; 3821 : 
; 3822 : #ifdef S3E1
; 3823 : 	pList.MagicInfo[DBM_TYPE] = type;
; 3824 : 	pList.MagicInfo[DBM_LEVEL] = level<<3;
; 3825 : 	pList.MagicInfo[DBM_LEVEL] |= skill & 0x07;
; 3826 : #else
; 3827 : 	pList.Type = type;

  0002e	66 8b 45 10	 mov	 ax, WORD PTR _type$[ebp]
  00032	88 95 08 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], dl

; 3828 : 	pList.MagicInfo[0] = level<<3;

  00038	8a 55 14	 mov	 dl, BYTE PTR _level$[ebp]
  0003b	88 8d 11 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], cl

; 3829 : 	pList.MagicInfo[0] |= (BYTE)skill & 0x07;

  00041	8a 4d 18	 mov	 cl, BYTE PTR _skill$[ebp]
  00044	02 d2		 add	 dl, dl
  00046	02 d2		 add	 dl, dl
  00048	80 e1 07	 and	 cl, 7
  0004b	02 d2		 add	 dl, dl
  0004d	0a ca		 or	 cl, dl
  0004f	88 8d 0b fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl
  00055	66 89 85 09 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 3830 : #endif
; 3831 : 
; 3832 : 
; 3833 : 	memcpy(&sendbuf[lOfs], &pList, sizeof(pList)); //size 4

  0005c	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]

; 3834 : 	lOfs+= sizeof(pList); //size 4
; 3835 : 
; 3836 : 	pCount.h.size = lOfs;

  00062	c6 85 0d fc ff
	ff 0a		 mov	 BYTE PTR _pCount$[ebp+1], 10 ; 0000000aH

; 3837 : 	memcpy(sendbuf, &pCount, sizeof(pCount)); //size 6

  00069	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]
  0006f	89 85 1a fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+6], eax

; 3838 : 
; 3839 : 	DataSend(aIndex, sendbuf, lOfs);

  00075	6a 0a		 push	 10			; 0000000aH
  00077	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0007d	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], ecx
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00086	c6 85 10 fc ff
	ff fe		 mov	 BYTE PTR _pCount$[ebp+4], 254 ; 000000feH
  0008d	66 8b 95 10 fc
	ff ff		 mov	 dx, WORD PTR _pCount$[ebp+4]
  00094	50		 push	 eax
  00095	51		 push	 ecx
  00096	66 89 95 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], dx
  0009d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3840 : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GCMagicListOneSend@@YAXHDGEGE@Z ENDP			; GCMagicListOneSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicListOneDelSend@@YAXHDGEEE@Z		; GCMagicListOneDelSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicListOneDelSend@@YAXHDGEEE@Z
_TEXT	SEGMENT
_pList$ = -1016						; size = 4
_pCount$ = -1012					; size = 6
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 2
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
_btListType$ = 28					; size = 1
?GCMagicListOneDelSend@@YAXHDGEEE@Z PROC		; GCMagicListOneDelSend, COMDAT

; 3843 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3844 : 	PMSG_MAGICLISTCOUNT pCount;
; 3845 : 	PMSG_MAGICLIST pList;
; 3846 : 	BYTE sendbuf[1000];
; 3847 : 	int lOfs = sizeof(pCount);
; 3848 : 
; 3849 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00013	6a 00		 push	 0
  00015	6a 11		 push	 17			; 00000011H
  00017	8d 85 0c fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0001d	68 f3 00 00 00	 push	 243			; 000000f3H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3850 : 	pCount.h.size = 0;
; 3851 : 	pCount.Count = 0xFF;
; 3852 : 	pCount.btListType = btListType;

  00028	8a 4d 1c	 mov	 cl, BYTE PTR _btListType$[ebp]

; 3853 : 	pList.Pos = Pos;

  0002b	8a 55 0c	 mov	 dl, BYTE PTR _Pos$[ebp]

; 3854 : 
; 3855 : #ifdef S3E1
; 3856 : 	pList.MagicInfo[DBM_TYPE] = type;
; 3857 : 	pList.MagicInfo[DBM_LEVEL] = level<<3;
; 3858 : 	pList.MagicInfo[DBM_LEVEL] |= skill & 0x07;
; 3859 : #else
; 3860 : 	pList.Type = type;

  0002e	66 8b 45 10	 mov	 ax, WORD PTR _type$[ebp]
  00032	88 8d 11 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], cl

; 3861 : 	pList.MagicInfo[0] = level<<3;

  00038	8a 4d 14	 mov	 cl, BYTE PTR _level$[ebp]
  0003b	02 c9		 add	 cl, cl
  0003d	88 95 08 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], dl

; 3862 : 	pList.MagicInfo[0] |= skill & 0x07;

  00043	8a 55 18	 mov	 dl, BYTE PTR _skill$[ebp]
  00046	02 c9		 add	 cl, cl
  00048	02 c9		 add	 cl, cl
  0004a	80 e2 07	 and	 dl, 7
  0004d	0a ca		 or	 cl, dl
  0004f	88 8d 0b fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl
  00055	66 89 85 09 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 3863 : #endif
; 3864 : 
; 3865 : 	memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  0005c	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]

; 3866 : 	lOfs+= sizeof(pList);
; 3867 : 	pCount.h.size = lOfs;

  00062	c6 85 0d fc ff
	ff 0a		 mov	 BYTE PTR _pCount$[ebp+1], 10 ; 0000000aH

; 3868 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00069	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]
  0006f	89 85 1a fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+6], eax

; 3869 : 
; 3870 : 	DataSend(aIndex, sendbuf, lOfs);

  00075	6a 0a		 push	 10			; 0000000aH
  00077	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0007d	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], ecx
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00086	c6 85 10 fc ff
	ff ff		 mov	 BYTE PTR _pCount$[ebp+4], 255 ; 000000ffH
  0008d	66 8b 95 10 fc
	ff ff		 mov	 dx, WORD PTR _pCount$[ebp+4]
  00094	50		 push	 eax
  00095	51		 push	 ecx
  00096	66 89 95 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], dx
  0009d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3871 : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GCMagicListOneDelSend@@YAXHDGEEE@Z ENDP		; GCMagicListOneDelSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z	; GCMagicListMultiSend
EXTRN	?CheckPrimarySkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMasterLevelSkillTreeSystem::CheckPrimarySkill
EXTRN	?GetWeaponMagicSearch@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMasterLevelSkillTreeSystem::GetWeaponMagicSearch
EXTRN	?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A:BYTE ; g_MasterSkillSystem
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_Count$ = -1024						; size = 4
_pList$ = -1020						; size = 4
_pCount$ = -1016					; size = 6
_lOfs$ = -1008						; size = 4
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_btListType$ = 12					; size = 1
?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z PROC	; GCMagicListMultiSend, COMDAT

; 3874 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3875 : 	PMSG_MAGICLISTCOUNT pCount;
; 3876 : 	PMSG_MAGICLIST pList;
; 3877 : 	BYTE sendbuf[1000];
; 3878 : 	int lOfs = sizeof(pCount);
; 3879 : 	int Count = 0;
; 3880 : 	pCount.btListType = btListType;

  00013	8a 45 0c	 mov	 al, BYTE PTR _btListType$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001c	33 db		 xor	 ebx, ebx

; 3881 : 
; 3882 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  0001e	53		 push	 ebx
  0001f	6a 11		 push	 17			; 00000011H
  00021	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _pCount$[ebp]
  00027	68 f3 00 00 00	 push	 243			; 000000f3H
  0002c	51		 push	 ecx
  0002d	c7 85 10 fc ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 6
  00037	89 9d 00 fc ff
	ff		 mov	 DWORD PTR _Count$[ebp], ebx
  0003d	88 85 0d fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al
  00043	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 3908 : 			lOfs+= sizeof(pList);

  0004b	33 f6		 xor	 esi, esi
  0004d	8d 49 00	 npad	 3
$LL7@GCMagicLis:

; 3885 : 	{
; 3886 : 		if ( lpObj->Magic[n].IsMagic() == TRUE )

  00050	8b 8f c8 04 00
	00		 mov	 ecx, DWORD PTR [edi+1224]
  00056	03 ce		 add	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 85 82 00 00
	00		 jne	 $LN6@GCMagicLis

; 3887 : 		{
; 3888 : 			if(g_MasterSkillSystem.GetWeaponMagicSearch(lpObj, n) == FALSE) //season4 add-on

  00066	53		 push	 ebx
  00067	57		 push	 edi
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0006d	e8 00 00 00 00	 call	 ?GetWeaponMagicSearch@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMasterLevelSkillTreeSystem::GetWeaponMagicSearch
  00072	85 c0		 test	 eax, eax
  00074	74 72		 je	 SHORT $LN6@GCMagicLis

; 3889 : 			{
; 3890 : 				continue;
; 3891 : 			}
; 3892 : 			if( g_MasterSkillSystem.CheckPrimarySkill(lpObj, lpObj->Magic[n].m_Skill) )

  00076	8b 97 c8 04 00
	00		 mov	 edx, DWORD PTR [edi+1224]
  0007c	8b 44 32 08	 mov	 eax, DWORD PTR [edx+esi+8]
  00080	50		 push	 eax
  00081	57		 push	 edi
  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00087	e8 00 00 00 00	 call	 ?CheckPrimarySkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMasterLevelSkillTreeSystem::CheckPrimarySkill
  0008c	85 c0		 test	 eax, eax
  0008e	75 58		 jne	 SHORT $LN6@GCMagicLis

; 3893 : 			{
; 3894 : 				continue;
; 3895 : 			}
; 3896 : 			// ----
; 3897 : 			if( lpObj->Magic[n].m_bPass == true )

  00090	8b 8f c8 04 00
	00		 mov	 ecx, DWORD PTR [edi+1224]
  00096	80 7c 31 14 01	 cmp	 BYTE PTR [ecx+esi+20], 1
  0009b	74 4b		 je	 SHORT $LN6@GCMagicLis

; 3898 : 			{
; 3899 : 				continue;
; 3900 : 			}
; 3901 : 
; 3902 : 			pList.Pos = n;
; 3903 : 
; 3904 : 			pList.Type = (WORD)lpObj->Magic[n].m_Skill;

  0009d	8b c1		 mov	 eax, ecx

; 3905 : 			pList.MagicInfo[0] = lpObj->Magic[n].m_Level<<3;

  0009f	8a 54 30 04	 mov	 dl, BYTE PTR [eax+esi+4]
  000a3	66 8b 4c 30 08	 mov	 cx, WORD PTR [eax+esi+8]

; 3906 : 			pList.MagicInfo[0] |= lpObj->Magic[n].m_Skill & 0x07;
; 3907 : 			memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  000a8	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000ae	02 d2		 add	 dl, dl
  000b0	02 d2		 add	 dl, dl
  000b2	66 89 8d 05 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], cx
  000b9	80 e1 07	 and	 cl, 7
  000bc	02 d2		 add	 dl, dl
  000be	0a d1		 or	 dl, cl
  000c0	88 9d 04 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], bl
  000c6	88 95 07 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], dl
  000cc	8b 8d 04 fc ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp]
  000d2	89 8c 05 14 fc
	ff ff		 mov	 DWORD PTR _sendbuf$[ebp+eax], ecx

; 3908 : 			lOfs+= sizeof(pList);

  000d9	83 c0 04	 add	 eax, 4

; 3909 : 			Count++;

  000dc	ff 85 00 fc ff
	ff		 inc	 DWORD PTR _Count$[ebp]
  000e2	89 85 10 fc ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
$LN6@GCMagicLis:

; 3883 : 
; 3884 : 	for ( int n=0;n<MAX_MAGIC;n++)

  000e8	83 c6 18	 add	 esi, 24			; 00000018H
  000eb	43		 inc	 ebx
  000ec	81 fe 10 0e 00
	00		 cmp	 esi, 3600		; 00000e10H
  000f2	0f 8c 58 ff ff
	ff		 jl	 $LL7@GCMagicLis

; 3910 : 		}
; 3911 : 	}
; 3912 : 
; 3913 : 	pCount.Count = Count;
; 3914 : 	pCount.h.size = lOfs;

  000f8	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000fe	8a 95 00 fc ff
	ff		 mov	 dl, BYTE PTR _Count$[ebp]
  00104	88 85 09 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al

; 3915 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  0010a	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]

; 3916 : 
; 3917 : 	DataSend(lpObj->m_Index, sendbuf, lOfs);

  00110	50		 push	 eax
  00111	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00117	89 8d 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], ecx
  0011d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0011f	88 95 0c fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], dl
  00125	66 8b 95 0c fc
	ff ff		 mov	 dx, WORD PTR _pCount$[ebp+4]
  0012c	50		 push	 eax
  0012d	51		 push	 ecx
  0012e	66 89 95 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], dx
  00135	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3918 : }

  0013a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	33 cd		 xor	 ecx, ebp
  00144	5b		 pop	 ebx
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z ENDP	; GCMagicListMultiSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCEquipmentSend@@YAXH@Z			; GCEquipmentSend
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
; Function compile flags: /Ogtp
;	COMDAT ?GCEquipmentSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCEquipmentSend@@YAXH@Z PROC				; GCEquipmentSend, COMDAT

; 3921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 3922 : 	PMSG_EQUIPMENTLIST pMsg;
; 3923 : 
; 3924 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x13, sizeof(pMsg));

  00014	6a 18		 push	 24			; 00000018H
  00016	6a 13		 push	 19			; 00000013H
  00018	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	68 f3 00 00 00	 push	 243			; 000000f3H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3925 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00026	8b cb		 mov	 ecx, ebx
  00028	c1 e9 08	 shr	 ecx, 8

; 3926 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 3927 : 	gObjMakePreviewCharSet(aIndex);

  0002b	53		 push	 ebx
  0002c	88 4d e8	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002f	88 5d e9	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00032	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 3928 : 	LPOBJ lpObj = &gObj[aIndex];

  00037	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  0003d	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3929 : 	memcpy(pMsg.Equipment, lpObj->CharSet, sizeof(lpObj->CharSet));

  00043	8b 93 e6 04 00
	00		 mov	 edx, DWORD PTR [ebx+1254]
  00049	89 55 ea	 mov	 DWORD PTR _pMsg$[ebp+6], edx
  0004c	8b 83 ea 04 00
	00		 mov	 eax, DWORD PTR [ebx+1258]
  00052	89 45 ee	 mov	 DWORD PTR _pMsg$[ebp+10], eax
  00055	8b 8b ee 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1262]
  0005b	89 4d f2	 mov	 DWORD PTR _pMsg$[ebp+14], ecx
  0005e	8b 93 f2 04 00
	00		 mov	 edx, DWORD PTR [ebx+1266]

; 3930 : 
; 3931 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00064	0f b6 4d e5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00068	89 55 f6	 mov	 DWORD PTR _pMsg$[ebp+18], edx
  0006b	66 8b 83 f6 04
	00 00		 mov	 ax, WORD PTR [ebx+1270]
  00072	51		 push	 ecx
  00073	8d 55 e4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00076	52		 push	 edx
  00077	53		 push	 ebx
  00078	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+22], ax
  0007c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 3932 : }

  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	83 c4 20	 add	 esp, 32			; 00000020H
  00087	33 cd		 xor	 ecx, ebp
  00089	5b		 pop	 ebx
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?GCEquipmentSend@@YAXH@Z ENDP				; GCEquipmentSend
_TEXT	ENDS
PUBLIC	?GCRecallMonLife@@YAXHHH@Z			; GCRecallMonLife
; Function compile flags: /Ogtp
;	COMDAT ?GCRecallMonLife@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_maxlife$ = 12						; size = 4
_life$ = 16						; size = 4
?GCRecallMonLife@@YAXHHH@Z PROC				; GCRecallMonLife, COMDAT

; 3935 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3936 : 	if ( maxlife <= 0 )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _maxlife$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	7e 33		 jle	 SHORT $LN2@GCRecallMo

; 3937 : 	{
; 3938 : 		return;
; 3939 : 	}
; 3940 : 	
; 3941 : 	PMSG_RECALLMONLIFE pMsg;
; 3942 : 	BYTE per = life * 100 / maxlife;
; 3943 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x20, sizeof(pMsg));

  0000e	6a 05		 push	 5
  00010	6a 20		 push	 32			; 00000020H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 f3 00 00 00	 push	 243			; 000000f3H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00020	8b 45 10	 mov	 eax, DWORD PTR _life$[ebp]
  00023	6b c0 64	 imul	 eax, 100		; 00000064H
  00026	99		 cdq
  00027	f7 fe		 idiv	 esi

; 3944 : 	pMsg.Life = per;
; 3945 : 
; 3946 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00029	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0002d	51		 push	 ecx
  0002e	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00031	52		 push	 edx
  00032	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00035	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@GCRecallMo:
  00041	5e		 pop	 esi

; 3947 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?GCRecallMonLife@@YAXHHH@Z ENDP				; GCRecallMonLife
_TEXT	ENDS
PUBLIC	?GCTimeViewSend@@YAXHH@Z			; GCTimeViewSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTimeViewSend@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_second$ = 12						; size = 4
?GCTimeViewSend@@YAXHH@Z PROC				; GCTimeViewSend, COMDAT

; 3950 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3951 : 	PMSG_TIMEVIEW pMsg;
; 3952 : 
; 3953 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x22, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 22		 push	 34			; 00000022H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3954 : 	pMsg.Second = second;
; 3955 : 
; 3956 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	66 8b 4d 0c	 mov	 cx, WORD PTR _second$[ebp]
  00020	52		 push	 edx
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	66 89 4d fc	 mov	 WORD PTR _pMsg$[ebp+4], cx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3957 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?GCTimeViewSend@@YAXHH@Z ENDP				; GCTimeViewSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGoalSend@@YAXHPADE0E@Z			; GCGoalSend
; Function compile flags: /Ogtp
;	COMDAT ?GCGoalSend@@YAXHPADE0E@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Name1$ = 12						; size = 4
_score1$ = 16						; size = 1
_Name2$ = 20						; size = 4
_score2$ = 24						; size = 1
?GCGoalSend@@YAXHPADE0E@Z PROC				; GCGoalSend, COMDAT

; 3960 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _Name1$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 14	 mov	 edi, DWORD PTR _Name2$[ebp]

; 3961 : 	PMSG_GOALSEND pMsg;
; 3962 : 
; 3963 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x23, sizeof(pMsg));

  00018	6a 16		 push	 22			; 00000016H
  0001a	6a 23		 push	 35			; 00000023H
  0001c	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	68 f3 00 00 00	 push	 243			; 000000f3H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3964 : 	memcpy(pMsg.RedTeamName, Name1, sizeof(pMsg.RedTeamName));

  0002a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 3965 : 	pMsg.RedTeamScore = score1;

  0002f	8a 45 10	 mov	 al, BYTE PTR _score1$[ebp]
  00032	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 3966 : 	memcpy(pMsg.BlueTeamName, Name2, sizeof(pMsg.BlueTeamName));

  00035	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00037	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  0003a	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0003d	89 4d f1	 mov	 DWORD PTR _pMsg$[ebp+13], ecx

; 3967 : 	pMsg.BlueTeamScore = score2;
; 3968 : 
; 3969 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00040	0f b6 4d e5	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00044	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+12], al
  00047	8a 45 18	 mov	 al, BYTE PTR _score2$[ebp]
  0004a	89 55 f5	 mov	 DWORD PTR _pMsg$[ebp+17], edx
  0004d	51		 push	 ecx
  0004e	8d 55 e4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00051	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+21], al
  00054	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3970 : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	83 c4 1c	 add	 esp, 28			; 0000001cH
  00064	5f		 pop	 edi
  00065	33 cd		 xor	 ecx, ebp
  00067	5e		 pop	 esi
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?GCGoalSend@@YAXHPADE0E@Z ENDP				; GCGoalSend
_TEXT	ENDS
PUBLIC	??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z	; GCSkillKeyRecv
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?DGOptionDataSend@@YAXHPADPAEEEEEEEH@Z:PROC	; DGOptionDataSend
EXTRN	__imp__ntohl@4:PROC
EXTRN	?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsGamePlaing
;	COMDAT ??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'O'
	DB	'ption Recv %d %d %d %d %d %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z
_TEXT	SEGMENT
_RKey$ = -4						; size = 1
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z PROC		; GCSkillKeyRecv, COMDAT

; 3973 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3974 : 	if ( !gObjIsGamePlaing(&gObj[aIndex]))

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00013	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsGamePlaing
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 a9 00 00
	00		 je	 $LN5@GCSkillKey

; 3975 : 	{
; 3976 : 		return;
; 3977 : 	}
; 3978 : 
; 3979 : 	if(gObj[aIndex].m_bSkillKeyRecv == 1) //season 2.5 add-on

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	b9 01 00 00 00	 mov	 ecx, 1
  00031	39 8c 07 7c 20
	00 00		 cmp	 DWORD PTR [edi+eax+8316], ecx
  00038	0f 84 92 00 00
	00		 je	 $LN5@GCSkillKey

; 3980 : 	{
; 3981 : 		return;
; 3982 : 	}
; 3983 : 
; 3984 : 	gObj[aIndex].m_bSkillKeyRecv = 1; //season 2.5 add-on
; 3985 : 
; 3986 : 	BYTE RKey = 0;
; 3987 : 
; 3988 : 	if(lpMsg->h.size == sizeof(PMSG_SKILLKEY)) // OMG :|

  0003e	53		 push	 ebx
  0003f	56		 push	 esi
  00040	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00043	89 8c 07 7c 20
	00 00		 mov	 DWORD PTR [edi+eax+8316], ecx
  0004a	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  0004d	32 db		 xor	 bl, bl
  0004f	88 5d fc	 mov	 BYTE PTR _RKey$[ebp], bl
  00052	80 f9 22	 cmp	 cl, 34			; 00000022H
  00055	75 06		 jne	 SHORT $LN2@GCSkillKey

; 3989 : 	{
; 3990 : 		RKey = lpMsg->RkeyDefine;

  00057	8a 5e 1d	 mov	 bl, BYTE PTR [esi+29]
  0005a	88 5d fc	 mov	 BYTE PTR _RKey$[ebp], bl
$LN2@GCSkillKey:

; 3991 : 	}
; 3992 : 
; 3993 : 	int QWERLevel = 0;

  0005d	33 c0		 xor	 eax, eax

; 3994 : 
; 3995 : 	if(lpMsg->h.size == sizeof(PMSG_SKILLKEY)) // OMG :|

  0005f	80 f9 22	 cmp	 cl, 34			; 00000022H
  00062	75 0a		 jne	 SHORT $LN1@GCSkillKey

; 3996 : 	{
; 3997 : 		QWERLevel = ntohl(lpMsg->QWERLevel);

  00064	8b 56 1e	 mov	 edx, DWORD PTR [esi+30]
  00067	52		 push	 edx
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ntohl@4
$LN1@GCSkillKey:

; 3998 : 	}
; 3999 : 
; 4000 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name,	lpMsg->SKillKey, lpMsg->GameOption,	lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, RKey, QWERLevel);

  0006e	0f b6 4e 1c	 movzx	 ecx, BYTE PTR [esi+28]
  00072	0f b6 56 1b	 movzx	 edx, BYTE PTR [esi+27]
  00076	50		 push	 eax
  00077	8b 45 fc	 mov	 eax, DWORD PTR _RKey$[ebp]
  0007a	50		 push	 eax
  0007b	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  0007f	51		 push	 ecx
  00080	0f b6 4e 19	 movzx	 ecx, BYTE PTR [esi+25]
  00084	52		 push	 edx
  00085	0f b6 56 18	 movzx	 edx, BYTE PTR [esi+24]
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00091	52		 push	 edx
  00092	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00095	50		 push	 eax
  00096	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00099	8d 54 0f 77	 lea	 edx, DWORD PTR [edi+ecx+119]
  0009d	52		 push	 edx
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?DGOptionDataSend@@YAXHPADPAEEEEEEEH@Z ; DGOptionDataSend

; 4001 : 
; 4002 : 	LogAddL("Option Recv %d %d %d %d %d %d", lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, RKey, lpMsg->QWERLevel); //fix me WZ noob

  000a4	8b 4e 1e	 mov	 ecx, DWORD PTR [esi+30]
  000a7	0f b6 46 1b	 movzx	 eax, BYTE PTR [esi+27]
  000ab	51		 push	 ecx
  000ac	0f b6 4e 1a	 movzx	 ecx, BYTE PTR [esi+26]
  000b0	0f b6 d3	 movzx	 edx, bl
  000b3	52		 push	 edx
  000b4	0f b6 56 19	 movzx	 edx, BYTE PTR [esi+25]
  000b8	50		 push	 eax
  000b9	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  000bd	51		 push	 ecx
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  000cb	83 c4 44	 add	 esp, 68			; 00000044H
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
$LN5@GCSkillKey:
  000d0	5f		 pop	 edi

; 4003 : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ENDP		; GCSkillKeyRecv
_TEXT	ENDS
PUBLIC	??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCSkillKeySend@@YAXHPAEEEEEEEH@Z		; GCSkillKeySend
;	COMDAT ??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'O'
	DB	'ption Send %d %d %d %d %d %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCSkillKeySend@@YAXHPAEEEEEEEH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 34
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_keybuffer$ = 12					; size = 4
_GO$ = 16						; size = 1
_Qk$ = 20						; size = 1
_Wk$ = 24						; size = 1
_Ek$ = 28						; size = 1
_ChatWnd$ = 32						; size = 1
_Rk$ = 36						; size = 1
_QWERLevel$ = 40					; size = 4
?GCSkillKeySend@@YAXHPAEEEEEEEH@Z PROC			; GCSkillKeySend, COMDAT

; 4006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _keybuffer$[ebp]

; 4007 : 	PMSG_SKILLKEY pMsg;
; 4008 : 
; 4009 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x30, sizeof(pMsg));

  00015	6a 22		 push	 34			; 00000022H
  00017	6a 30		 push	 48			; 00000030H
  00019	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	68 f3 00 00 00	 push	 243			; 000000f3H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 4010 : 
; 4011 : 	memcpy(pMsg.SKillKey, keybuffer, sizeof(pMsg.SKillKey));

  00027	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 4012 : 	pMsg.GameOption = GO;

  0002f	8a 5d 10	 mov	 bl, BYTE PTR _GO$[ebp]
  00032	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00035	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00038	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  0003b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]

; 4013 : 	pMsg.QkeyDefine = Qk;
; 4014 : 	pMsg.WkeyDefine = Wk;
; 4015 : 	pMsg.EkeyDefine = Ek;
; 4016 : 	pMsg.ChatWindow = ChatWnd;
; 4017 : 
; 4018 : 	pMsg.RkeyDefine = Rk;
; 4019 : 	pMsg.QWERLevel = QWERLevel;

  0003e	8b 75 28	 mov	 esi, DWORD PTR _QWERLevel$[ebp]
  00041	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00044	8a 45 14	 mov	 al, BYTE PTR _Qk$[ebp]
  00047	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+20], edx
  0004a	8a 55 1c	 mov	 dl, BYTE PTR _Ek$[ebp]
  0004d	89 4d e8	 mov	 DWORD PTR _pMsg$[ebp+16], ecx
  00050	8a 4d 18	 mov	 cl, BYTE PTR _Wk$[ebp]
  00053	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+25], al
  00056	8a 45 20	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  00059	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+27], dl

; 4020 : 
; 4021 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0005c	0f b6 55 d9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00060	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+26], cl
  00063	8a 4d 24	 mov	 cl, BYTE PTR _Rk$[ebp]
  00066	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+28], al
  00069	52		 push	 edx
  0006a	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006d	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+29], cl
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	88 5d f0	 mov	 BYTE PTR _pMsg$[ebp+24], bl
  00078	89 75 f6	 mov	 DWORD PTR _pMsg$[ebp+30], esi
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4022 : 	LogAddL("Option Send %d %d %d %d %d %d", GO, Qk, Wk, Ek, Rk, QWERLevel);

  00080	0f b6 55 24	 movzx	 edx, BYTE PTR _Rk$[ebp]
  00084	0f b6 45 1c	 movzx	 eax, BYTE PTR _Ek$[ebp]
  00088	0f b6 4d 18	 movzx	 ecx, BYTE PTR _Wk$[ebp]
  0008c	56		 push	 esi
  0008d	52		 push	 edx
  0008e	0f b6 55 14	 movzx	 edx, BYTE PTR _Qk$[ebp]
  00092	50		 push	 eax
  00093	51		 push	 ecx
  00094	0f b6 c3	 movzx	 eax, bl
  00097	52		 push	 edx
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 4023 : }

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	83 c4 38	 add	 esp, 56			; 00000038H
  000aa	5e		 pop	 esi
  000ab	33 cd		 xor	 ecx, ebp
  000ad	5b		 pop	 ebx
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?GCSkillKeySend@@YAXHPAEEEEEEEH@Z ENDP			; GCSkillKeySend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMoneySend@@YAXHK@Z				; GCMoneySend
; Function compile flags: /Ogtp
;	COMDAT ?GCMoneySend@@YAXHK@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCMoneySend@@YAXHK@Z PROC				; GCMoneySend, COMDAT

; 4026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4027 : 	PMSG_ITEMGETRESULT pMsg;
; 4028 : 
; 4029 : 	pMsg.h.c = 0xC3;
; 4030 : 	pMsg.h.headcode = 0x22;
; 4031 : 	pMsg.h.size = sizeof(pMsg);
; 4032 : 	pMsg.result = 0xFE;
; 4033 : 
; 4034 : 	WORD hiWord = SET_NUMBERHW(money);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _money$[ebp]
  00013	8b c1		 mov	 eax, ecx
  00015	c1 e8 10	 shr	 eax, 16			; 00000010H

; 4035 : 	WORD loWord = SET_NUMBERLW(money);
; 4036 : 	pMsg.Data[0] = SET_NUMBERH(hiWord);

  00018	8b d0		 mov	 edx, eax

; 4037 : 	pMsg.Data[1] = SET_NUMBERL(hiWord);

  0001a	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0001d	c1 ea 08	 shr	 edx, 8

; 4038 : 	pMsg.Data[2] = SET_NUMBERH(loWord);

  00020	8b c1		 mov	 eax, ecx

; 4039 : 	pMsg.Data[3] = SET_NUMBERL(loWord);

  00022	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 4040 : 
; 4041 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00025	6a 10		 push	 16			; 00000010H
  00027	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002a	88 55 f0	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  0002d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00030	51		 push	 ecx
  00031	c1 e8 08	 shr	 eax, 8
  00034	52		 push	 edx
  00035	c6 45 ec c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  00039	66 c7 45 ed 10
	22		 mov	 WORD PTR _pMsg$[ebp+1], 8720 ; 00002210H
  0003f	c6 45 ef fe	 mov	 BYTE PTR _pMsg$[ebp+3], 254 ; 000000feH
  00043	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00046	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4042 : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?GCMoneySend@@YAXHK@Z ENDP				; GCMoneySend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCItemInventoryPutSend@@YAXHEEE@Z		; GCItemInventoryPutSend
; Function compile flags: /Ogtp
;	COMDAT ?GCItemInventoryPutSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pResult$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_iteminfo1$ = 16					; size = 1
_iteminfo2$ = 20					; size = 1
?GCItemInventoryPutSend@@YAXHEEE@Z PROC			; GCItemInventoryPutSend, COMDAT

; 4045 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4046 : 	PMSG_ITEMGETRESULT pResult;
; 4047 : 
; 4048 : 	pResult.h.c = 0xC3;
; 4049 : 	pResult.h.headcode = 0x22;
; 4050 : 	pResult.h.size = sizeof(pResult);
; 4051 : 	pResult.result = result;

  00010	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]

; 4052 : 	pResult.Data[0] = iteminfo1;

  00013	8a 4d 10	 mov	 cl, BYTE PTR _iteminfo1$[ebp]

; 4053 : 	pResult.Data[1] = iteminfo2;

  00016	8a 55 14	 mov	 dl, BYTE PTR _iteminfo2$[ebp]
  00019	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al

; 4054 : 	pResult.h.size -= 2;
; 4055 : 
; 4056 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0001c	6a 0e		 push	 14			; 0000000eH
  0001e	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00021	88 4d f0	 mov	 BYTE PTR _pResult$[ebp+4], cl
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	c6 45 ec c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H
  0002d	88 55 f1	 mov	 BYTE PTR _pResult$[ebp+5], dl
  00030	66 c7 45 ed 0e
	22		 mov	 WORD PTR _pResult$[ebp+1], 8718 ; 0000220eH
  00036	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4057 : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GCItemInventoryPutSend@@YAXHEEE@Z ENDP			; GCItemInventoryPutSend
_TEXT	ENDS
PUBLIC	??_C@_0BC@IGBLPOFO@Move?5Amulet?5Block?$AA@	; `string'
PUBLIC	??_C@_0GB@CHPAOI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@ ; `string'
PUBLIC	??_C@_0FO@IOOCGPFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@ ; `string'
PUBLIC	??_C@_0GA@ICGPKMLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@ ; `string'
PUBLIC	??_C@_0GA@NDJPCCCA@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5IronJewel@ ; `string'
PUBLIC	??_C@_0GD@BOMFHKPI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5RefinedJe@ ; `string'
PUBLIC	??_C@_0GB@BODDPAFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5ShineJewe@ ; `string'
PUBLIC	??_C@_0FJ@HLIOIHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Silver?5Bo@ ; `string'
PUBLIC	??_C@_0FJ@BJKBOFGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Golden?5Bo@ ; `string'
PUBLIC	??_C@_0GC@KFKJFPHK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@ ; `string'
PUBLIC	??_C@_0FP@IOJDMAHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@ ; `string'
PUBLIC	??_C@_0GB@FACENDHB@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@ ; `string'
PUBLIC	??_C@_0FI@JFAFAJLO@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5GM?5Presen@ ; `string'
PUBLIC	??_C@_0EK@JOOALNAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@ ; `string'
PUBLIC	??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EM@OMBINMCG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EK@NLJNLJHL@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0ED@KAHFPFOH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0FC@DNBGEKCH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0FI@LBKHCBMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5CherryBox@ ; `string'
PUBLIC	??_C@_0FJ@FJFDABFJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5FireCrake@ ; `string'
PUBLIC	??_C@_0FI@KNMNAMHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@ ; `string'
PUBLIC	??_C@_0FJ@EEKOGNLH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Pumpkin?5o@ ; `string'
PUBLIC	??_C@_0FL@JACADLKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5WhiteDay?5@ ; `string'
PUBLIC	??_C@_0GG@OJDMPPPF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Valentine@ ; `string'
PUBLIC	??_C@_0FN@OKEEHLGI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@ ; `string'
PUBLIC	??_C@_0CF@NAOHIDPP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Used?5box?5of?5luck?5?$CIlevel@ ; `string'
PUBLIC	??_C@_0FO@OLBBBANK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Da@ ; `string'
PUBLIC	??_C@_0GA@JAPNPGBL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ ; `string'
PUBLIC	??_C@_0GA@CKKIPCAM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ ; `string'
PUBLIC	??_C@_0FP@EFLIOIJH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ ; `string'
PUBLIC	??_C@_0FO@EPDIFFOG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ ; `string'
PUBLIC	??_C@_0FO@CGPEKJOL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ ; `string'
PUBLIC	??_C@_0FK@EEPLJEBI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Ev@ ; `string'
PUBLIC	??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Si@ ; `string'
PUBLIC	??_C@_0FK@HNNMBKPL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Go@ ; `string'
PUBLIC	??_C@_0FM@PDLPCBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5He@ ; `string'
PUBLIC	??_C@_0FM@LBGLIJMP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Fi@ ; `string'
PUBLIC	??_C@_0FL@MNOGBEOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5St@ ; `string'
PUBLIC	??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@ ; `string'
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	??_C@_0BA@IPIHHLPL@Block?5Drop?5Item?$AA@	; `string'
PUBLIC	??_C@_0CK@CEMEJBFL@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Drop@ ; `string'
PUBLIC	??_C@_0DB@FEBFLDKF@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@ ; `string'
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ ; `string'
PUBLIC	??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@		; `string'
PUBLIC	??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z	; CGItemDropRequest
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEQAEE@Z:PROC ; MapClass::ItemDrop
EXTRN	?BoxOfPurpleColorItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; BoxOfPurpleColorItemBagOpen
EXTRN	?BoxOfRedColorItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; BoxOfRedColorItemBagOpen
EXTRN	?BoxOfGreenColorItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; BoxOfGreenColorItemBagOpen
EXTRN	?OldJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; OldJewelleryCaseItemBagOpen
EXTRN	?IronJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; IronJewelleryCaseItemBagOpen
EXTRN	?RefinedJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; RefinedJewelleryCaseItemBagOpen
EXTRN	?ShineJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; ShineJewelleryCaseItemBagOpen
EXTRN	?SilverBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; SilverBoxItemBagOpen
EXTRN	?GoldenBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; GoldenBoxItemBagOpen
EXTRN	?PCBangPurpleChaosBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; PCBangPurpleChaosBoxItemBagOpen
EXTRN	?PCBangRedChaosBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; PCBangRedChaosBoxItemBagOpen
EXTRN	?PCBangGreenChaosBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; PCBangGreenChaosBoxItemBagOpen
EXTRN	?GMPresentBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; GMPresentBoxItemBagOpen
EXTRN	?CreateLifeStone@CLifeStone@@QAEHH@Z:PROC	; CLifeStone::CreateLifeStone
EXTRN	?g_CsNPC_LifeStone@@3VCLifeStone@@A:DWORD	; g_CsNPC_LifeStone
EXTRN	?CreateGuardian@CGuardian@@QAEHH@Z:PROC		; CGuardian::CreateGuardian
EXTRN	?g_CsNPC_Guardian@@3VCGuardian@@A:DWORD		; g_CsNPC_Guardian
EXTRN	?CreateMercenary@CMercenary@@QAEHHHEE@Z:PROC	; CMercenary::CreateMercenary
EXTRN	?g_CsNPC_Mercenary@@3VCMercenary@@A:QWORD	; g_CsNPC_Mercenary
EXTRN	?Japan1StAnivBoxOpen@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; Japan1StAnivBoxOpen
EXTRN	?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z:PROC	; CKalimaGate::CreateKalimaGate
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?FriendShipItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; FriendShipItemBoxOpen
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?RingOfHeroBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; RingOfHeroBoxOpen
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?EGReqRegHTOfflineGift@@YAXH@Z:PROC		; EGReqRegHTOfflineGift
EXTRN	?g_iHiddenTreasureBoxOfflineRate@@3HA:DWORD	; g_iHiddenTreasureBoxOfflineRate
EXTRN	?HiddenTreasureBoxItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; HiddenTreasureBoxItemBoxOpen
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?ChristmasFireCrackDrop@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; ChristmasFireCrackDrop
EXTRN	?CherryBlossomEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; CherryBlossomEventItemBoxOpen
EXTRN	?ChristmasStarDrop@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; ChristmasStarDrop
EXTRN	?HallowinDayEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; HallowinDayEventItemBoxOpen
EXTRN	?DeepBlueCandyBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; DeepBlueCandyBoxOpen
EXTRN	?VermilionCandyBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; VermilionCandyBoxOpen
EXTRN	?LightPurpleCandyBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; LightPurpleCandyBoxOpen
EXTRN	?BlueChocolateBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; BlueChocolateBoxOpen
EXTRN	?RedChocolateBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; RedChocolateBoxOpen
EXTRN	?PinkChocolateBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; PinkChocolateBoxOpen
EXTRN	?BlueRibbonBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; BlueRibbonBoxOpen
EXTRN	?GreenRibbonBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; GreenRibbonBoxOpen
EXTRN	?RedRibbonBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; RedRibbonBoxOpen
EXTRN	?LuckyBoxOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; LuckyBoxOpenEven
EXTRN	?DarkLordHeartItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; DarkLordHeartItemBoxOpen
EXTRN	?EledoradoBoxOpenEven@@YAXPAUOBJECTSTRUCT@@HHH@Z:PROC ; EledoradoBoxOpenEven
EXTRN	?EventChipOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; EventChipOpenEven
EXTRN	?SilverMedalOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; SilverMedalOpenEven
EXTRN	?GoldMedalOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; GoldMedalOpenEven
EXTRN	?HeartOfLoveOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; HeartOfLoveOpenEven
EXTRN	?FireCrackerOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; FireCrackerOpenEven
EXTRN	?StarOfXMasOpenEven@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; StarOfXMasOpenEven
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?OnRequestPeriodItemList@CPeriodItemZt@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CPeriodItemZt::OnRequestPeriodItemList
EXTRN	?g_PeriodItemZt@@3VCPeriodItemZt@@A:BYTE	; g_PeriodItemZt
EXTRN	?GCItemListSend@@YAXH@Z:PROC			; GCItemListSend
EXTRN	?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z:PROC ; gObjInventorySearchSerialNumber
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z:PROC	; gObjCheckSerial0ItemList
EXTRN	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
EXTRN	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
EXTRN	?GetActiveSocketOption@CSocketOption@@QAEXPAVCItem@@PAEAAE@Z:PROC ; CSocketOption::GetActiveSocketOption
EXTRN	?g_SocketOption@@3VCSocketOption@@A:BYTE	; g_SocketOption
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?GetItemDrop@CAchievements@@QAE_NHH@Z:PROC	; CAchievements::GetItemDrop
EXTRN	?g_Achievements@@3VCAchievements@@A:BYTE	; g_Achievements
EXTRN	?CheckInventory@CAccountSecurity@@QAE_NH@Z:PROC	; CAccountSecurity::CheckInventory
EXTRN	?Move@cBlockMoveItem@@QAE_NHH@Z:PROC		; cBlockMoveItem::Move
EXTRN	?gBlockMoveIteml@@3VcBlockMoveItem@@A:BYTE	; gBlockMoveIteml
EXTRN	?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
EXTRN	?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
EXTRN	?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
EXTRN	?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?IsPeriodItem@CItem@@QAE_NXZ:PROC		; CItem::IsPeriodItem
EXTRN	?IsLuckyItemTicket@LuckyItemManager@@QAEHH@Z:PROC ; LuckyItemManager::IsLuckyItemTicket
EXTRN	?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z:PROC ; LuckyItemManager::IsLuckyItemEquipment
EXTRN	?g_LuckyItemManager@@3ULuckyItemManager@@A:BYTE	; g_LuckyItemManager
EXTRN	?CheckDrop@CItemMove@@QAE_NH@Z:PROC		; CItemMove::CheckDrop
EXTRN	?g_ItemMove@@3VCItemMove@@A:BYTE		; g_ItemMove
EXTRN	?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; gObjCanItemTouch
EXTRN	?gObjFixInventoryPointer@@YA_NH@Z:PROC		; gObjFixInventoryPointer
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BC@IGBLPOFO@Move?5Amulet?5Block?$AA@
; File e:\work\tranet_version\gs\gameserver\tnotice.h
CONST	SEGMENT
??_C@_0BC@IGBLPOFO@Move?5Amulet?5Block?$AA@ DB 'Move Amulet Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@CHPAOI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@
CONST	SEGMENT
??_C@_0GB@CHPAOI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@ DB '['
	DB	'%s][%s][%d]%d/%d Used Box Of PurpleColor Item Serial:%u (%s:%'
	DB	'd/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@IOOCGPFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@
CONST	SEGMENT
??_C@_0FO@IOOCGPFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@ DB '['
	DB	'%s][%s][%d]%d/%d Used Box Of RedColor Item Serial:%u (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@ICGPKMLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@
CONST	SEGMENT
??_C@_0GA@ICGPKMLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@ DB '['
	DB	'%s][%s][%d]%d/%d Used Box Of GreenColor Item Serial:%u (%s:%d'
	DB	'/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@NDJPCCCA@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5IronJewel@
CONST	SEGMENT
??_C@_0GA@NDJPCCCA@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5IronJewel@ DB '['
	DB	'%s][%s][%d]%d/%d Used IronJewelleryCase Item Serial:%u (%s:%d'
	DB	'/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@BOMFHKPI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5RefinedJe@
CONST	SEGMENT
??_C@_0GD@BOMFHKPI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5RefinedJe@ DB '['
	DB	'%s][%s][%d]%d/%d Used RefinedJewelleryCase Item Serial:%u (%s'
	DB	':%d/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@BODDPAFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5ShineJewe@
CONST	SEGMENT
??_C@_0GB@BODDPAFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5ShineJewe@ DB '['
	DB	'%s][%s][%d]%d/%d Used ShineJewelleryCase Item Serial:%u (%s:%'
	DB	'd/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@HLIOIHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Silver?5Bo@
CONST	SEGMENT
??_C@_0FJ@HLIOIHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Silver?5Bo@ DB '['
	DB	'%s][%s][%d]%d/%d Used Silver Box Item Serial:%u (%s:%d/level:'
	DB	'%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@BJKBOFGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Golden?5Bo@
CONST	SEGMENT
??_C@_0FJ@BJKBOFGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Golden?5Bo@ DB '['
	DB	'%s][%s][%d]%d/%d Used Golden Box Item Serial:%u (%s:%d/level:'
	DB	'%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@KFKJFPHK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@
CONST	SEGMENT
??_C@_0GC@KFKJFPHK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@ DB '['
	DB	'%s][%s][%d]%d/%d Used Box Of Purple Chaos Item Serial:%u (%s:'
	DB	'%d/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@IOJDMAHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@
CONST	SEGMENT
??_C@_0FP@IOJDMAHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@ DB '['
	DB	'%s][%s][%d]%d/%d Used Box Of Red Chaos Item Serial:%u (%s:%d/'
	DB	'level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@FACENDHB@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@
CONST	SEGMENT
??_C@_0GB@FACENDHB@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@ DB '['
	DB	'%s][%s][%d]%d/%d Used Box Of Green Chaos Item Serial:%u (%s:%'
	DB	'd/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@JFAFAJLO@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5GM?5Presen@
CONST	SEGMENT
??_C@_0FI@JFAFAJLO@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5GM?5Presen@ DB '['
	DB	'%s][%s][%d]%d/%d Used GM Present Box Serial:%u (%s:%d/level:%'
	DB	'd/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@JOOALNAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@
CONST	SEGMENT
??_C@_0EK@JOOALNAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@ DB '['
	DB	'Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map'
	DB	' Serial:%u)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)('
	DB	'%d/%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OMBINMCG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EM@OMBINMCG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Bo'
	DB	'x - serial:%u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@NLJNLJHL@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EK@NLJNLJHL@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Hidden Treasure Box '
	DB	'- serial:%u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KAHFPFOH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0ED@KAHFPFOH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - seria'
	DB	'l:%u', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DNBGEKCH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0FC@DNBGEKCH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Dr'
	DB	'op (%d) - serial:%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@LBKHCBMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5CherryBox@
CONST	SEGMENT
??_C@_0FI@LBKHCBMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5CherryBox@ DB '['
	DB	'%s][%s][%d]%d/%d Used CherryBox Item Serial:%u (%s:%d/level:%'
	DB	'd/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@FJFDABFJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5FireCrake@
CONST	SEGMENT
??_C@_0FJ@FJFDABFJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5FireCrake@ DB '['
	DB	'%s][%s][%d]%d/%d Used FireCraker Item Serial:%u (%s:%d/level:'
	DB	'%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@KNMNAMHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@
CONST	SEGMENT
??_C@_0FI@KNMNAMHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@ DB '['
	DB	'%s][%s][%d]%d/%d Used Christmas-Star Serial:%u (%s:%d/level:%'
	DB	'd/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@EEKOGNLH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Pumpkin?5o@
CONST	SEGMENT
??_C@_0FJ@EEKOGNLH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Pumpkin?5o@ DB '['
	DB	'%s][%s][%d]%d/%d Used Pumpkin of Luck Serial:%u (%s:%d/level:'
	DB	'%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@JACADLKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5WhiteDay?5@
CONST	SEGMENT
??_C@_0FL@JACADLKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5WhiteDay?5@ DB '['
	DB	'%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/leve'
	DB	'l:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@OJDMPPPF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Valentine@
CONST	SEGMENT
??_C@_0GG@OJDMPPPF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Valentine@ DB '['
	DB	'%s][%s][%d]%d/%d Used Valentine''s Day ChocolateBox Serial:%u'
	DB	' (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@OKEEHLGI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@
CONST	SEGMENT
??_C@_0FN@OKEEHLGI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@ DB '['
	DB	'%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/le'
	DB	'vel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NAOHIDPP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Used?5box?5of?5luck?5?$CIlevel@
CONST	SEGMENT
??_C@_0CF@NAOHIDPP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Used?5box?5of?5luck?5?$CIlevel@ DB '['
	DB	'%s][%s] Used box of luck (level:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@OLBBBANK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Da@
CONST	SEGMENT
??_C@_0FO@OLBBBANK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Da@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of DarkLordHeart Serial:%u (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JAPNPGBL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
CONST	SEGMENT
??_C@_0GA@JAPNPGBL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox1-12 Serial:%u (%s:%d'
	DB	'/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CKKIPCAM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
CONST	SEGMENT
??_C@_0GA@CKKIPCAM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox1-11 Serial:%u (%s:%d'
	DB	'/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@EFLIOIJH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
CONST	SEGMENT
??_C@_0FP@EFLIOIJH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox-10 Serial:%u (%s:%d/'
	DB	'level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@EPDIFFOG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
CONST	SEGMENT
??_C@_0FO@EPDIFFOG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox-9 Serial:%u (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@CGPEKJOL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
CONST	SEGMENT
??_C@_0FO@CGPEKJOL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox-8 Serial:%u (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@EEPLJEBI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Ev@
CONST	SEGMENT
??_C@_0FK@EEPLJEBI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Ev@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of EventChip Serial:%u (%s:%d/level'
	DB	':%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Si@
CONST	SEGMENT
??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Si@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of SilverMedal Serial:%d (%s:%d/lev'
	DB	'el:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@HNNMBKPL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Go@
CONST	SEGMENT
??_C@_0FK@HNNMBKPL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Go@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of GoldMedal Serial:%u (%s:%d/level'
	DB	':%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@PDLPCBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5He@
CONST	SEGMENT
??_C@_0FM@PDLPCBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5He@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of HeartOfLove Serial:%u (%s:%d/lev'
	DB	'el:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@LBGLIJMP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Fi@
CONST	SEGMENT
??_C@_0FM@LBGLIJMP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Fi@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of FireCracker Serial:%u (%s:%d/lev'
	DB	'el:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@MNOGBEOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5St@
CONST	SEGMENT
??_C@_0FL@MNOGBEOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5St@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of StarOfXMas Serial:%u (%s:%d/leve'
	DB	'l:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@
CONST	SEGMENT
??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IPIHHLPL@Block?5Drop?5Item?$AA@
CONST	SEGMENT
??_C@_0BA@IPIHHLPL@Block?5Drop?5Item?$AA@ DB 'Block Drop Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CEMEJBFL@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Drop@
CONST	SEGMENT
??_C@_0CK@CEMEJBFL@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Drop@ DB '['
	DB	'WARNING][All Item] Item NO Drop All Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FEBFLDKF@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0DB@FEBFLDKF@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ DB '['
	DB	'WARNING][Serial -1 Item] Item NO Drop SERI (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@ DB 'error:%s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ DB '['
	DB	'Fix Inv.Ptr] False Location - %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
CONST	SEGMENT
??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@ DB 'protocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@
CONST	SEGMENT
??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@ DB '['
	DB	'ANTI-HACK][Item Duplication] - Item Drop during MapServer Mov'
	DB	'e [%s][%s]', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z
_TEXT	SEGMENT
tv3590 = -460						; size = 4
_PetLevel$246028 = -456					; size = 4
_NOption$246026 = -452					; size = 1
_PetExp$246029 = -448					; size = 4
_SocketIndex$246033 = -444				; size = 1
_bIsItem$246022 = -440					; size = 4
_serial2$246034 = -436					; size = 4
_SOption$246030 = -432					; size = 1
_btItemEffectEx$246031 = -428				; size = 1
_CopyItem$ = -424					; size = 4
_dur$246021 = -420					; size = 4
_lpMsg$GSCopy$ = -416					; size = 4
_ServerCmd$246138 = -412				; size = 7
_map$246018 = -412					; size = 4
_Level$246128 = -404					; size = 4
_type$246019 = -404					; size = 4
_JOHOption$246037 = -398				; size = 1
_JOHOptionLevel$246038 = -397				; size = 1
_level$246020 = -396					; size = 4
_Option1$246023 = -392					; size = 1
_Option3$246025 = -388					; size = 1
_Option2$246024 = -384					; size = 1
tv3552 = -380						; size = 4
_pResult$ = -376					; size = 5
_aIndex$GSCopy$ = -368					; size = 4
_pNotice$246164 = -364					; size = 272
_pNotice$246155 = -364					; size = 272
_pChange$246253 = -92					; size = 17
_SocketOption$246032 = -72				; size = 5
_szItemName$246035 = -64				; size = 50
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_drop_type$ = 16					; size = 4
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z PROC	; CGItemDropRequest, COMDAT

; 4854 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4855 : 	BOOL CopyItem = FALSE;
; 4856 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 4857 : 
; 4858 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001c	56		 push	 esi
  0001d	8b f3		 mov	 esi, ebx
  0001f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00025	57		 push	 edi
  00026	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00029	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002c	51		 push	 ecx

; 4953 : 		{
; 4954 : 			GCServerMsgStringSend("Move Amulet Block",lpObj->m_Index,1);

  0002d	89 bd 60 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  00033	89 9d 90 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00039	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _CopyItem$[ebp], 0
  00043	89 b5 84 fe ff
	ff		 mov	 DWORD PTR tv3552[ebp], esi
  00049	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004e	83 c4 04	 add	 esp, 4
  00051	85 c0		 test	 eax, eax
  00053	0f 84 da 00 00
	00		 je	 $LN228@CGItemDrop

; 4859 : 	{
; 4860 : 		return FALSE;
; 4861 : 	}
; 4862 : 
; 4863 : 	PMSG_ITEMTHROW_RESULT pResult;
; 4864 : 
; 4865 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  00059	6a 05		 push	 5
  0005b	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00061	6a 23		 push	 35			; 00000023H
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 4866 : 	pResult.Result = true;
; 4867 : 	pResult.Ipos = lpMsg->Ipos;

  00069	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0006c	88 85 8c fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], al

; 4868 : 
; 4869 : 	if ( gObj[aIndex].m_IfState.use != 0 )

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00077	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
  0007e	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	f6 c1 03	 test	 cl, 3
  0008b	74 12		 je	 SHORT $LN190@CGItemDrop

; 4870 : 	{
; 4871 : 		if ( gObj[aIndex].m_IfState.type != 3 )

  0008d	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00093	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H

; 4872 : 		{
; 4873 : 			pResult.Result = false;
; 4874 : 			return FALSE;

  00099	0f 85 94 00 00
	00		 jne	 $LN228@CGItemDrop
$LN190@CGItemDrop:

; 4875 : 		}
; 4876 : 	}
; 4877 : 
; 4878 : 	if ( gObj[aIndex].CloseType != -1 )

  0009f	80 7c 06 0b ff	 cmp	 BYTE PTR [esi+eax+11], -1
  000a4	74 07		 je	 SHORT $LN189@CGItemDrop

; 4879 : 	{
; 4880 : 		pResult.Result = false;

  000a6	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN189@CGItemDrop:

; 4881 : 	}
; 4882 : 
; 4883 : 	if ( gObj[aIndex].m_bMapSvrMoveQuit == true )

  000ad	80 bc 06 e4 1b
	00 00 01	 cmp	 BYTE PTR [esi+eax+7140], 1
  000b5	75 1f		 jne	 SHORT $LN188@CGItemDrop

; 4884 : 	{
; 4885 : 		LogAddTD("[ANTI-HACK][Item Duplication] - Item Drop during MapServer Move [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000b7	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000bb	51		 push	 ecx
  000bc	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000c0	52		 push	 edx
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4886 : 		pResult.Result = false;

  000cf	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN188@CGItemDrop:

; 4887 : 	}
; 4888 : 
; 4889 : 	if ( !::gObjFixInventoryPointer(aIndex))

  000d6	53		 push	 ebx
  000d7	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000dc	83 c4 04	 add	 esp, 4
  000df	84 c0		 test	 al, al
  000e1	75 18		 jne	 SHORT $LN187@CGItemDrop

; 4890 : 	{
; 4891 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000e3	68 1b 13 00 00	 push	 4891			; 0000131bH
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@CGItemDrop:

; 4892 : 	}
; 4893 : 
; 4894 : 	if ( gObj[aIndex].pTransaction == 1 )

  000fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00100	80 bc 06 30 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3632], 1
  00108	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  0010b	75 39		 jne	 SHORT $LN186@CGItemDrop

; 4895 : 	{
; 4896 : 		LogAddTD("[%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYPE : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  0010d	8b 8b 1c 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3612]
  00113	c1 e9 06	 shr	 ecx, 6
  00116	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0011c	51		 push	 ecx
  0011d	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  00120	52		 push	 edx
  00121	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00124	53		 push	 ebx
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00130	83 c4 10	 add	 esp, 16			; 00000010H
$LN228@CGItemDrop:

; 4897 : 		pResult.Result = false;
; 4898 : 		return false;

  00133	33 c0		 xor	 eax, eax

; 5728 : }

  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx
  00138	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013b	33 cd		 xor	 ecx, ebp
  0013d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
$LN186@CGItemDrop:

; 4899 : 	}
; 4900 : 
; 4901 : 	LPOBJ lpObj = &gObj[aIndex];
; 4902 : 
; 4903 : 	if ( lpMsg->Ipos == 0xFF )

  00146	80 7f 05 ff	 cmp	 BYTE PTR [edi+5], 255	; 000000ffH
  0014a	75 1f		 jne	 SHORT $LN185@CGItemDrop

; 4904 : 	{
; 4905 : 		LogAdd("error:%s %d", __FILE__, __LINE__);

  0014c	68 29 13 00 00	 push	 4905			; 00001329H
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4906 : 		pResult.Result = false;

  00164	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN185@CGItemDrop:

; 4907 : 	}
; 4908 : 
; 4909 : 	if ( lpMsg->Ipos < 0 || lpMsg->Ipos > MAIN_INVENTORY_SIZE-1)

  0016b	80 7f 05 cb	 cmp	 BYTE PTR [edi+5], 203	; 000000cbH
  0016f	76 07		 jbe	 SHORT $LN184@CGItemDrop

; 4910 : 	{
; 4911 : 		pResult.Result = false;

  00171	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN184@CGItemDrop:

; 4912 : 	}
; 4913 : 
; 4914 : 	if (!::gObjCanItemTouch(lpObj, 0))

  00178	6a 00		 push	 0
  0017a	53		 push	 ebx
  0017b	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00180	83 c4 08	 add	 esp, 8
  00183	85 c0		 test	 eax, eax
  00185	75 06		 jne	 SHORT $LN182@CGItemDrop

; 4915 : 	{
; 4916 : 		pResult.Result = false;

  00187	88 85 8b fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
$LN182@CGItemDrop:

; 4917 : 	}
; 4918 : #if(Negative_Number)
; 4919 : 	CItem* BCheckItem = &lpObj->pInventory[lpMsg->Ipos];

  0018d	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00191	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00197	03 83 24 0e 00
	00		 add	 eax, DWORD PTR [ebx+3620]

; 4920 : 	//LogAddC(1, "CGItemDropRequest Item %s (%d)", BCheckItem->GetName(), BCheckItem->m_Number);
; 4921 : 	//==Check Seri -1
; 4922 : 	if (ZtConfig.CommonServer.MembItemLimit && (int)BCheckItem->m_Number < 0)

  0019d	83 3d 50 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+336, 0
  001a4	74 1d		 je	 SHORT $LN181@CGItemDrop
  001a6	8b 00		 mov	 eax, DWORD PTR [eax]
  001a8	85 c0		 test	 eax, eax
  001aa	79 17		 jns	 SHORT $LN181@CGItemDrop

; 4923 : 	{
; 4924 : 		//LogAddTD("[WARNING][Serial -1 Item] Item NO SELL SERI (%d)", BCheckItem->m_Number);
; 4925 : 		MsgOutput(aIndex, "[WARNING][Serial -1 Item] Item NO Drop SERI (%d)", BCheckItem->m_Number);

  001ac	50		 push	 eax
  001ad	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@FEBFLDKF@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 4926 : 		return -1;

  001be	e9 44 28 00 00	 jmp	 $LN223@CGItemDrop
$LN181@CGItemDrop:

; 4927 : 	}
; 4928 : 	//==Check Item Drop
; 4929 : 	if (ZtConfig.CommonServer.NorItemLimit)

  001c3	83 3d 5c 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+348, 0
  001ca	74 28		 je	 SHORT $LN180@CGItemDrop

; 4930 : 	{
; 4931 : 		//LogAddTD("[WARNING][Max Level Sell] Item NO SELL Level >= (%d)", ZtConfig.CommonServer.NorItemLevel);
; 4932 : 		MsgOutput(aIndex, "[WARNING][All Item] Item NO Drop All Item");

  001cc	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CEMEJBFL@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Drop@
  001d7	51		 push	 ecx
  001d8	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  001dd	83 c4 08	 add	 esp, 8

; 4955 : 			return -1;

  001e0	83 c8 ff	 or	 eax, -1

; 5728 : }

  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
  001e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e9	33 cd		 xor	 ecx, ebp
  001eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
$LN180@CGItemDrop:

; 4933 : 		return -1;
; 4934 : 	}
; 4935 : 
; 4936 : #endif
; 4937 : 
; 4938 : 
; 4939 : #ifdef ZTCLUSIVE_AMYLET
; 4940 : 	if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  001f4	6a 17		 push	 23			; 00000017H
  001f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001fb	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00200	84 c0		 test	 al, al
  00202	75 34		 jne	 SHORT $LN178@CGItemDrop
  00204	6a 1c		 push	 28			; 0000001cH
  00206	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0020b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00210	84 c0		 test	 al, al
  00212	75 24		 jne	 SHORT $LN178@CGItemDrop
  00214	6a 00		 push	 0
  00216	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0021b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00220	84 c0		 test	 al, al
  00222	75 14		 jne	 SHORT $LN178@CGItemDrop
  00224	6a 24		 push	 36			; 00000024H
  00226	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0022b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00230	84 c0		 test	 al, al
  00232	0f 84 a1 00 00
	00		 je	 $LN177@CGItemDrop
$LN178@CGItemDrop:

; 4941 : 	{
; 4942 : 		if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,147) ||
; 4943 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,148) ||
; 4944 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,149) ||
; 4945 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,150) ||
; 4946 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,151) ||
; 4947 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,152) ||
; 4948 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,153) ||
; 4949 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,154) ||
; 4950 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,155) ||
; 4951 : 			lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,156)
; 4952 : 			)

  00238	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  0023c	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  00242	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00248	0f b7 44 02 06	 movzx	 eax, WORD PTR [edx+eax+6]
  0024d	b9 93 1a 00 00	 mov	 ecx, 6803		; 00001a93H
  00252	66 3b c1	 cmp	 ax, cx
  00255	0f 84 9d 27 00
	00		 je	 $LN176@CGItemDrop
  0025b	ba 94 1a 00 00	 mov	 edx, 6804		; 00001a94H
  00260	66 3b c2	 cmp	 ax, dx
  00263	0f 84 8f 27 00
	00		 je	 $LN176@CGItemDrop
  00269	b9 95 1a 00 00	 mov	 ecx, 6805		; 00001a95H
  0026e	66 3b c1	 cmp	 ax, cx
  00271	0f 84 81 27 00
	00		 je	 $LN176@CGItemDrop
  00277	ba 96 1a 00 00	 mov	 edx, 6806		; 00001a96H
  0027c	66 3b c2	 cmp	 ax, dx
  0027f	0f 84 73 27 00
	00		 je	 $LN176@CGItemDrop
  00285	b9 97 1a 00 00	 mov	 ecx, 6807		; 00001a97H
  0028a	66 3b c1	 cmp	 ax, cx
  0028d	0f 84 65 27 00
	00		 je	 $LN176@CGItemDrop
  00293	ba 98 1a 00 00	 mov	 edx, 6808		; 00001a98H
  00298	66 3b c2	 cmp	 ax, dx
  0029b	0f 84 57 27 00
	00		 je	 $LN176@CGItemDrop
  002a1	b9 99 1a 00 00	 mov	 ecx, 6809		; 00001a99H
  002a6	66 3b c1	 cmp	 ax, cx
  002a9	0f 84 49 27 00
	00		 je	 $LN176@CGItemDrop
  002af	ba 9a 1a 00 00	 mov	 edx, 6810		; 00001a9aH
  002b4	66 3b c2	 cmp	 ax, dx
  002b7	0f 84 3b 27 00
	00		 je	 $LN176@CGItemDrop
  002bd	b9 9b 1a 00 00	 mov	 ecx, 6811		; 00001a9bH
  002c2	66 3b c1	 cmp	 ax, cx
  002c5	0f 84 2d 27 00
	00		 je	 $LN176@CGItemDrop
  002cb	ba 9c 1a 00 00	 mov	 edx, 6812		; 00001a9cH
  002d0	66 3b c2	 cmp	 ax, dx
  002d3	0f 84 1f 27 00
	00		 je	 $LN176@CGItemDrop
$LN177@CGItemDrop:

; 4956 : 		}
; 4957 : 	}
; 4958 : #endif
; 4959 : 
; 4960 : #if(CUSTOM_ITEM_MOVE)
; 4961 : 	if(g_ItemMove.CheckDrop(lpObj->pInventory[lpMsg->Ipos].m_Type))

  002d9	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  002dd	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  002e3	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  002e9	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  002ee	52		 push	 edx
  002ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMove@@3VCItemMove@@A ; g_ItemMove
  002f4	e8 00 00 00 00	 call	 ?CheckDrop@CItemMove@@QAE_NH@Z ; CItemMove::CheckDrop
  002f9	84 c0		 test	 al, al
  002fb	74 0f		 je	 SHORT $LN175@CGItemDrop

; 4962 : 	{
; 4963 : 		GCServerMsgStringSend("Block Drop Item",lpObj->m_Index,1);

  002fd	8b 03		 mov	 eax, DWORD PTR [ebx]
  002ff	6a 01		 push	 1
  00301	50		 push	 eax
  00302	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IPIHHLPL@Block?5Drop?5Item?$AA@

; 4964 : 		return -1;

  00307	e9 f6 26 00 00	 jmp	 $LN225@CGItemDrop
$LN175@CGItemDrop:

; 4965 : 	}
; 4966 : #endif
; 4967 : 
; 4968 : #ifdef LUCKYITEM
; 4969 : 	if( g_LuckyItemManager.IsLuckyItemEquipment(lpObj->pInventory[lpMsg->Ipos].m_Type) 
; 4970 : 		|| g_LuckyItemManager.IsLuckyItemTicket(lpObj->pInventory[lpMsg->Ipos].m_Type) )

  0030c	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00310	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  00316	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0031c	0f bf 44 11 06	 movsx	 eax, WORD PTR [ecx+edx+6]
  00321	50		 push	 eax
  00322	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  00327	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  0032c	85 c0		 test	 eax, eax
  0032e	75 24		 jne	 SHORT $LN173@CGItemDrop
  00330	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00334	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  0033a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00340	0f bf 44 11 06	 movsx	 eax, WORD PTR [ecx+edx+6]
  00345	50		 push	 eax
  00346	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  0034b	e8 00 00 00 00	 call	 ?IsLuckyItemTicket@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemTicket
  00350	85 c0		 test	 eax, eax
  00352	74 07		 je	 SHORT $LN174@CGItemDrop
$LN173@CGItemDrop:

; 4971 : 	{
; 4972 : 		pResult.Result = false;

  00354	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN174@CGItemDrop:

; 4973 : 	}
; 4974 : #endif
; 4975 : 	if ( gObj[aIndex].MapNumber == MAP_INDEX_ICARUS)

  0035b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00361	80 bc 0e 49 01
	00 00 0a	 cmp	 BYTE PTR [esi+ecx+329], 10 ; 0000000aH
  00369	75 4b		 jne	 SHORT $LN166@CGItemDrop

; 4976 : 	{
; 4977 : 		if ( lpMsg->Ipos == 8 )

  0036b	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0036e	3c 08		 cmp	 al, 8
  00370	75 25		 jne	 SHORT $LN171@CGItemDrop

; 4978 : 		{
; 4979 : 			if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,3) )

  00372	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  00378	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  0037d	66 39 90 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], dx
  00384	75 30		 jne	 SHORT $LN166@CGItemDrop

; 4980 : 			{
; 4981 : 				if( lpObj->pInventory[7].IsItem() == FALSE )

  00386	8d 88 cc 05 00
	00		 lea	 ecx, DWORD PTR [eax+1484]
  0038c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00391	85 c0		 test	 eax, eax
  00393	75 21		 jne	 SHORT $LN166@CGItemDrop

; 4982 : 				{
; 4983 : 					pResult.Result = false;
; 4984 : 				}
; 4985 : 			}
; 4986 : 		}

  00395	eb 18		 jmp	 SHORT $LN226@CGItemDrop
$LN171@CGItemDrop:

; 4987 : 		else if ( lpMsg->Ipos == 7 )

  00397	3c 07		 cmp	 al, 7
  00399	75 1b		 jne	 SHORT $LN166@CGItemDrop

; 4988 : 		{
; 4989 : 			if ( lpObj->pInventory[8].m_Type != ITEMGET(13,3) )

  0039b	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  003a1	b9 03 1a 00 00	 mov	 ecx, 6659		; 00001a03H
  003a6	66 39 88 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], cx
  003ad	74 07		 je	 SHORT $LN166@CGItemDrop
$LN226@CGItemDrop:

; 4990 : 			{
; 4991 : 				pResult.Result = false;

  003af	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN166@CGItemDrop:

; 4992 : 			}
; 4993 : 		}
; 4994 : 	}
; 4995 : 
; 4996 : #ifdef PERIOD
; 4997 : 	if( lpObj->pInventory[lpMsg->Ipos].IsPeriodItem() )

  003b6	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  003ba	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003c0	03 8b 24 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3620]
  003c6	e8 00 00 00 00	 call	 ?IsPeriodItem@CItem@@QAE_NXZ ; CItem::IsPeriodItem
  003cb	84 c0		 test	 al, al
  003cd	74 07		 je	 SHORT $LN165@CGItemDrop

; 4998 : 	{
; 4999 : 		pResult.Result = false;

  003cf	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN165@CGItemDrop:

; 5000 : 	}
; 5001 : #endif
; 5002 : 
; 5003 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,30) ||
; 5004 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,31) ||
; 5005 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,36) ||
; 5006 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,37) )

  003d6	0f b6 77 05	 movzx	 esi, BYTE PTR [edi+5]
  003da	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  003e0	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  003e6	0f b7 44 32 06	 movzx	 eax, WORD PTR [edx+esi+6]
  003eb	b9 1e 18 00 00	 mov	 ecx, 6174		; 0000181eH
  003f0	66 3b c1	 cmp	 ax, cx
  003f3	74 1e		 je	 SHORT $LN163@CGItemDrop
  003f5	ba 1f 18 00 00	 mov	 edx, 6175		; 0000181fH
  003fa	66 3b c2	 cmp	 ax, dx
  003fd	74 14		 je	 SHORT $LN163@CGItemDrop
  003ff	b9 24 1a 00 00	 mov	 ecx, 6692		; 00001a24H
  00404	66 3b c1	 cmp	 ax, cx
  00407	74 0a		 je	 SHORT $LN163@CGItemDrop
  00409	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  0040e	66 3b c2	 cmp	 ax, dx
  00411	75 07		 jne	 SHORT $LN164@CGItemDrop
$LN163@CGItemDrop:

; 5007 : 	{
; 5008 : 		pResult.Result = false;

  00413	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN164@CGItemDrop:

; 5009 : 	}
; 5010 : 
; 5011 : 	if( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,42) ) //Season 2.5 add-on

  0041a	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  00420	b9 2a 1a 00 00	 mov	 ecx, 6698		; 00001a2aH
  00425	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  0042a	75 07		 jne	 SHORT $LN162@CGItemDrop

; 5012 : 	{
; 5013 : 		pResult.Result = false;

  0042c	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN162@CGItemDrop:

; 5014 : 	}
; 5015 : 
; 5016 : 	if(IT_MAP_RANGE(lpObj->MapNumber) != FALSE) //Season 2.5 add-on

  00433	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  0043a	3c 2d		 cmp	 al, 45			; 0000002dH
  0043c	72 22		 jb	 SHORT $LN221@CGItemDrop
  0043e	b2 32		 mov	 dl, 50			; 00000032H
  00440	3a d0		 cmp	 dl, al
  00442	1b c0		 sbb	 eax, eax
  00444	40		 inc	 eax
  00445	74 19		 je	 SHORT $LN221@CGItemDrop

; 5017 : 	{
; 5018 : 		if( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,51) )

  00447	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  0044d	b9 33 1a 00 00	 mov	 ecx, 6707		; 00001a33H
  00452	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00457	75 07		 jne	 SHORT $LN221@CGItemDrop

; 5019 : 		{
; 5020 : 			pResult.Result = false;

  00459	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN221@CGItemDrop:

; 5021 : 		}
; 5022 : 	}
; 5023 : 
; 5024 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,64) )

  00460	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  00466	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  0046b	66 39 44 32 06	 cmp	 WORD PTR [edx+esi+6], ax
  00470	75 07		 jne	 SHORT $LN159@CGItemDrop

; 5025 : 	{
; 5026 : 		pResult.Result = false;

  00472	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN159@CGItemDrop:

; 5027 : 	}
; 5028 : 
; 5029 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,52) || //Season 2.5 add-on
; 5030 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,53) )

  00479	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  0047f	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  00484	ba 34 1a 00 00	 mov	 edx, 6708		; 00001a34H
  00489	66 3b c2	 cmp	 ax, dx
  0048c	74 0a		 je	 SHORT $LN157@CGItemDrop
  0048e	b9 35 1a 00 00	 mov	 ecx, 6709		; 00001a35H
  00493	66 3b c1	 cmp	 ax, cx
  00496	75 07		 jne	 SHORT $LN158@CGItemDrop
$LN157@CGItemDrop:

; 5031 : 	{
; 5032 : 		pResult.Result = false;

  00498	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN158@CGItemDrop:

; 5033 : 	}
; 5034 : 
; 5035 : 
; 5036 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,13) ||
; 5037 : 		lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,14) ||
; 5038 : 		lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,16) ||
; 5039 : 		(lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,0)
; 5040 : 		&& lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,6)) 
; 5041 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,15) 
; 5042 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Level >= 7 //season 2.5 changed 
; 5043 : 		&& lpObj->pInventory[lpMsg->Ipos].m_Type < ITEMGET(12,0)) 
; 5044 : 		||  lpObj->pInventory[lpMsg->Ipos].IsSetItem() != FALSE 
; 5045 : 		||  lpObj->pInventory[lpMsg->Ipos].IsExtItem() != FALSE 
; 5046 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,14) //season 2.5 add-on
; 5047 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,19)
; 5048 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,15)
; 5049 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,34)
; 5050 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,31)
; 5051 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,41)
; 5052 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,42)
; 5053 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,43)
; 5054 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,44)
; 5055 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,41) //season 3 add-on
; 5056 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,42)
; 5057 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,43)
; 5058 : #ifdef NEWWINGS_2_5
; 5059 : 		|| IS_NEWWINGS_2_5(lpObj->pInventory[lpMsg->Ipos].m_Type)
; 5060 : #endif
; 5061 : #ifdef NEWWINGS_4
; 5062 : 		|| IS_NEWWINGS_4(lpObj->pInventory[lpMsg->Ipos].m_Type)
; 5063 : #endif
; 5064 : #ifdef NEWWINGS_5
; 5065 : 		|| IS_NEWWINGS_5(lpObj->pInventory[lpMsg->Ipos].m_Type)
; 5066 : #endif
; 5067 : #ifdef NEWWINGS_6
; 5068 : 		|| IS_NEWWINGS_6(lpObj->pInventory[lpMsg->Ipos].m_Type)
; 5069 : #endif
; 5070 : 		)

  0049f	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  004a5	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  004aa	03 ce		 add	 ecx, esi
  004ac	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  004b1	66 3b c2	 cmp	 ax, dx
  004b4	0f 84 a6 01 00
	00		 je	 $LN222@CGItemDrop
  004ba	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  004bf	66 3b c2	 cmp	 ax, dx
  004c2	0f 84 98 01 00
	00		 je	 $LN222@CGItemDrop
  004c8	ba 10 1c 00 00	 mov	 edx, 7184		; 00001c10H
  004cd	66 3b c2	 cmp	 ax, dx
  004d0	0f 84 8a 01 00
	00		 je	 $LN222@CGItemDrop
  004d6	ba 00 18 00 00	 mov	 edx, 6144		; 00001800H
  004db	66 3b c2	 cmp	 ax, dx
  004de	7c 0e		 jl	 SHORT $LN154@CGItemDrop
  004e0	ba 06 18 00 00	 mov	 edx, 6150		; 00001806H
  004e5	66 3b c2	 cmp	 ax, dx
  004e8	0f 8e 72 01 00
	00		 jle	 $LN222@CGItemDrop
$LN154@CGItemDrop:
  004ee	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  004f3	66 3b c2	 cmp	 ax, dx
  004f6	0f 84 64 01 00
	00		 je	 $LN222@CGItemDrop
  004fc	66 83 79 08 07	 cmp	 WORD PTR [ecx+8], 7
  00501	7c 0e		 jl	 SHORT $LN153@CGItemDrop
  00503	ba 00 18 00 00	 mov	 edx, 6144		; 00001800H
  00508	66 3b c2	 cmp	 ax, dx
  0050b	0f 8c 4f 01 00
	00		 jl	 $LN222@CGItemDrop
$LN153@CGItemDrop:
  00511	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00516	85 c0		 test	 eax, eax
  00518	0f 85 42 01 00
	00		 jne	 $LN222@CGItemDrop
  0051e	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00522	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00528	03 8b 24 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3620]
  0052e	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00533	85 c0		 test	 eax, eax
  00535	0f 85 25 01 00
	00		 jne	 $LN222@CGItemDrop
  0053b	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0053f	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00545	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0054b	0f b7 44 08 06	 movzx	 eax, WORD PTR [eax+ecx+6]
  00550	ba 0e 1a 00 00	 mov	 edx, 6670		; 00001a0eH
  00555	66 3b c2	 cmp	 ax, dx
  00558	0f 84 02 01 00
	00		 je	 $LN222@CGItemDrop
  0055e	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  00563	66 3b c1	 cmp	 ax, cx
  00566	0f 84 f4 00 00
	00		 je	 $LN222@CGItemDrop
  0056c	ba 0f 1a 00 00	 mov	 edx, 6671		; 00001a0fH
  00571	66 3b c2	 cmp	 ax, dx
  00574	0f 84 e6 00 00
	00		 je	 $LN222@CGItemDrop
  0057a	b9 22 1a 00 00	 mov	 ecx, 6690		; 00001a22H
  0057f	66 3b c1	 cmp	 ax, cx
  00582	0f 84 d8 00 00
	00		 je	 $LN222@CGItemDrop
  00588	ba 1f 1c 00 00	 mov	 edx, 7199		; 00001c1fH
  0058d	66 3b c2	 cmp	 ax, dx
  00590	0f 84 ca 00 00
	00		 je	 $LN222@CGItemDrop
  00596	b9 29 1c 00 00	 mov	 ecx, 7209		; 00001c29H
  0059b	66 3b c1	 cmp	 ax, cx
  0059e	0f 84 bc 00 00
	00		 je	 $LN222@CGItemDrop
  005a4	ba 2a 1c 00 00	 mov	 edx, 7210		; 00001c2aH
  005a9	66 3b c2	 cmp	 ax, dx
  005ac	0f 84 ae 00 00
	00		 je	 $LN222@CGItemDrop
  005b2	b9 2b 1c 00 00	 mov	 ecx, 7211		; 00001c2bH
  005b7	66 3b c1	 cmp	 ax, cx
  005ba	0f 84 a0 00 00
	00		 je	 $LN222@CGItemDrop
  005c0	ba 2c 1c 00 00	 mov	 edx, 7212		; 00001c2cH
  005c5	66 3b c2	 cmp	 ax, dx
  005c8	0f 84 92 00 00
	00		 je	 $LN222@CGItemDrop
  005ce	b9 29 18 00 00	 mov	 ecx, 6185		; 00001829H
  005d3	66 3b c1	 cmp	 ax, cx
  005d6	0f 84 84 00 00
	00		 je	 $LN222@CGItemDrop
  005dc	ba 2a 18 00 00	 mov	 edx, 6186		; 0000182aH
  005e1	66 3b c2	 cmp	 ax, dx
  005e4	74 7a		 je	 SHORT $LN222@CGItemDrop
  005e6	b9 2b 18 00 00	 mov	 ecx, 6187		; 0000182bH
  005eb	66 3b c1	 cmp	 ax, cx
  005ee	74 70		 je	 SHORT $LN222@CGItemDrop
  005f0	ba ba 18 00 00	 mov	 edx, 6330		; 000018baH
  005f5	66 3b c2	 cmp	 ax, dx
  005f8	7c 13		 jl	 SHORT $LN213@CGItemDrop
  005fa	33 d2		 xor	 edx, edx
  005fc	b9 bc 18 00 00	 mov	 ecx, 6332		; 000018bcH
  00601	66 3b c1	 cmp	 ax, cx
  00604	0f 9e c2	 setle	 dl
  00607	8b ca		 mov	 ecx, edx
  00609	85 c9		 test	 ecx, ecx
  0060b	75 53		 jne	 SHORT $LN222@CGItemDrop
$LN213@CGItemDrop:
  0060d	b9 b4 18 00 00	 mov	 ecx, 6324		; 000018b4H
  00612	66 3b c1	 cmp	 ax, cx
  00615	7c 11		 jl	 SHORT $LN214@CGItemDrop
  00617	33 c9		 xor	 ecx, ecx
  00619	ba b9 18 00 00	 mov	 edx, 6329		; 000018b9H
  0061e	66 3b c2	 cmp	 ax, dx
  00621	0f 9e c1	 setle	 cl
  00624	85 c9		 test	 ecx, ecx
  00626	75 38		 jne	 SHORT $LN222@CGItemDrop
$LN214@CGItemDrop:
  00628	b9 bd 18 00 00	 mov	 ecx, 6333		; 000018bdH
  0062d	66 3b c1	 cmp	 ax, cx
  00630	7c 11		 jl	 SHORT $LN215@CGItemDrop
  00632	33 c9		 xor	 ecx, ecx
  00634	ba c2 18 00 00	 mov	 edx, 6338		; 000018c2H
  00639	66 3b c2	 cmp	 ax, dx
  0063c	0f 9e c1	 setle	 cl
  0063f	85 c9		 test	 ecx, ecx
  00641	75 1d		 jne	 SHORT $LN222@CGItemDrop
$LN215@CGItemDrop:
  00643	b9 c3 18 00 00	 mov	 ecx, 6339		; 000018c3H
  00648	66 3b c1	 cmp	 ax, cx
  0064b	7c 23		 jl	 SHORT $LN152@CGItemDrop
  0064d	33 c9		 xor	 ecx, ecx
  0064f	ba dc 18 00 00	 mov	 edx, 6364		; 000018dcH
  00654	66 3b c2	 cmp	 ax, dx
  00657	0f 9e c1	 setle	 cl
  0065a	8b c1		 mov	 eax, ecx
  0065c	85 c0		 test	 eax, eax
  0065e	74 10		 je	 SHORT $LN152@CGItemDrop
$LN222@CGItemDrop:

; 5071 : 	{
; 5072 : 		if ( gPkLimitFree == FALSE )

  00660	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00667	75 07		 jne	 SHORT $LN152@CGItemDrop

; 5073 : 		{
; 5074 : 			pResult.Result = false;

  00669	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN152@CGItemDrop:

; 5075 : 		}
; 5076 : 	}
; 5077 : 
; 5078 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(&lpObj->pInventory[lpMsg->Ipos]) == TRUE )

  00670	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00674	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0067a	03 93 24 0e 00
	00		 add	 edx, DWORD PTR [ebx+3620]
  00680	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00685	52		 push	 edx
  00686	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  0068b	83 f8 01	 cmp	 eax, 1
  0068e	75 23		 jne	 SHORT $LN151@CGItemDrop

; 5079 : 	{
; 5080 : 		pResult.Result = false;
; 5081 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 43)), lpObj->m_Index, 1);

  00690	50		 push	 eax
  00691	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  00698	8b 03		 mov	 eax, DWORD PTR [ebx]
  0069a	50		 push	 eax
  0069b	68 2b 0d 00 00	 push	 3371			; 00000d2bH
  006a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  006a5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  006aa	50		 push	 eax
  006ab	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006b0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN151@CGItemDrop:

; 5082 : 	}
; 5083 : 
; 5084 : 	if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyOriginal(lpObj->pInventory[lpMsg->Ipos].m_Type) ||
; 5085 : 		 g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(lpObj->pInventory[lpMsg->Ipos].m_Type)   ||
; 5086 : 		 g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(lpObj->pInventory[lpMsg->Ipos].m_Type) )

  006b3	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  006b7	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  006bd	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  006c3	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  006c8	50		 push	 eax
  006c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  006ce	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
  006d3	85 c0		 test	 eax, eax
  006d5	75 48		 jne	 SHORT $LN149@CGItemDrop
  006d7	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  006db	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  006e1	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  006e7	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  006ec	50		 push	 eax
  006ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  006f2	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
  006f7	85 c0		 test	 eax, eax
  006f9	75 24		 jne	 SHORT $LN149@CGItemDrop
  006fb	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  006ff	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  00705	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0070b	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  00710	50		 push	 eax
  00711	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00716	e8 00 00 00 00	 call	 ?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
  0071b	85 c0		 test	 eax, eax
  0071d	74 07		 je	 SHORT $LN150@CGItemDrop
$LN149@CGItemDrop:

; 5087 : 	{
; 5088 : 		pResult.Result = false;

  0071f	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN150@CGItemDrop:

; 5089 : 	}
; 5090 : 
; 5091 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,39) )

  00726	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0072a	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  00730	8b c1		 mov	 eax, ecx
  00732	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00738	be 27 1a 00 00	 mov	 esi, 6695		; 00001a27H
  0073d	66 39 74 02 06	 cmp	 WORD PTR [edx+eax+6], si
  00742	75 07		 jne	 SHORT $LN148@CGItemDrop

; 5092 : 	{
; 5093 : 		pResult.Result = false;

  00744	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN148@CGItemDrop:

; 5094 : 	}
; 5095 : #ifdef OLDCASHSHOP
; 5096 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Ipos].m_Type) == TRUE )
; 5097 : 	{
; 5098 : 		pResult.Result = false;
; 5099 : 	}
; 5100 : 
; 5101 : 	if ( CanItemTouchCash(lpObj->pInventory[lpMsg->Ipos].m_Type) == TRUE ) //season 4.5 add-on
; 5102 : 	{
; 5103 : 		pResult.Result = false;
; 5104 : 	}
; 5105 : #endif
; 5106 : 
; 5107 : 	if( lpObj->pInventory[lpMsg->Ipos].m_QuestItem) //season 2.5 add-on

  0074b	8b 93 24 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3620]
  00751	80 bc 02 ad 00
	00 00 00	 cmp	 BYTE PTR [edx+eax+173], 0
  00759	74 16		 je	 SHORT $LN147@CGItemDrop

; 5108 : 	{
; 5109 : 		return 0xFF;

  0075b	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 5728 : }

  00760	5f		 pop	 edi
  00761	5e		 pop	 esi
  00762	5b		 pop	 ebx
  00763	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00766	33 cd		 xor	 ecx, ebp
  00768	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0076d	8b e5		 mov	 esp, ebp
  0076f	5d		 pop	 ebp
  00770	c3		 ret	 0
$LN147@CGItemDrop:

; 5110 : 	}
; 5111 : 
; 5112 : #ifdef BLOCK_MOVE_DROP_FIX
; 5113 : 	if(gBlockMoveIteml.Move(lpObj->m_Index,lpMsg->Ipos) == false)

  00771	8b 03		 mov	 eax, DWORD PTR [ebx]
  00773	51		 push	 ecx
  00774	50		 push	 eax
  00775	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBlockMoveIteml@@3VcBlockMoveItem@@A ; gBlockMoveIteml
  0077a	e8 00 00 00 00	 call	 ?Move@cBlockMoveItem@@QAE_NHH@Z ; cBlockMoveItem::Move
  0077f	84 c0		 test	 al, al
  00781	75 06		 jne	 SHORT $LN146@CGItemDrop

; 5114 : 	{
; 5115 : 		//GCServerMsgStringSend("Move Item Block",lpObj->m_Index,1);
; 5116 : 		pResult.Result = false;

  00783	88 85 8b fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
$LN146@CGItemDrop:

; 5117 : 	}
; 5118 : #endif
; 5119 : 
; 5120 : #if(CUSTOM_ACCOUNT_SECURITY)
; 5121 : 	if(g_AccountSecurity.CheckInventory(lpObj->m_Index) == false)

  00789	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0078b	51		 push	 ecx
  0078c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  00791	e8 00 00 00 00	 call	 ?CheckInventory@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckInventory
  00796	84 c0		 test	 al, al

; 5122 : 	{
; 5123 : 		pResult.Result = false;
; 5124 : 	}
; 5125 : #endif
; 5126 : 
; 5127 : #if(SYSTEM_ACHIEVEMENTS)
; 5128 : 	if(pResult.Result)

  00798	0f 84 66 02 00
	00		 je	 $LN227@CGItemDrop
  0079e	8a 85 8b fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+3]
  007a4	84 c0		 test	 al, al
  007a6	74 29		 je	 SHORT $LN144@CGItemDrop

; 5129 : 	{
; 5130 : 		pResult.Result = g_Achievements.GetItemDrop(lpObj->m_Index, lpObj->pInventory[lpMsg->Ipos].m_Type);

  007a8	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  007ac	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  007b2	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  007b8	0f bf 4c 02 06	 movsx	 ecx, WORD PTR [edx+eax+6]
  007bd	8b 13		 mov	 edx, DWORD PTR [ebx]
  007bf	51		 push	 ecx
  007c0	52		 push	 edx
  007c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  007c6	e8 00 00 00 00	 call	 ?GetItemDrop@CAchievements@@QAE_NHH@Z ; CAchievements::GetItemDrop
  007cb	88 85 8b fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
$LN144@CGItemDrop:

; 5131 : 	}
; 5132 : #endif
; 5133 : 
; 5134 : 	if ( pResult.Result == 1 )

  007d1	3c 01		 cmp	 al, 1
  007d3	0f 85 32 02 00
	00		 jne	 $LN6@CGItemDrop

; 5135 : 	{
; 5136 : 		::ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Ipos]);

  007d9	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  007dd	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  007e3	03 83 24 0e 00
	00		 add	 eax, DWORD PTR [ebx+3620]
  007e9	8d 4d f4	 lea	 ecx, DWORD PTR _NewOption$[ebp]
  007ec	50		 push	 eax
  007ed	51		 push	 ecx
  007ee	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 5137 : 
; 5138 : 		int map = lpObj->MapNumber;
; 5139 : 		int type = lpObj->pInventory[lpMsg->Ipos].m_Type;

  007f3	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  007f7	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  007fe	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00804	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  0080a	03 c8		 add	 ecx, eax

; 5140 : 		int level = lpObj->pInventory[lpMsg->Ipos].m_Level;

  0080c	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]

; 5141 : 		float dur = lpObj->pInventory[lpMsg->Ipos].m_Durability;

  00810	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00813	89 95 64 fe ff
	ff		 mov	 DWORD PTR _map$246018[ebp], edx
  00819	d9 9d 5c fe ff
	ff		 fstp	 DWORD PTR _dur$246021[ebp]
  0081f	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00823	83 c4 08	 add	 esp, 8
  00826	89 95 6c fe ff
	ff		 mov	 DWORD PTR _type$246019[ebp], edx
  0082c	89 85 74 fe ff
	ff		 mov	 DWORD PTR _level$246020[ebp], eax

; 5142 : 		BOOL bIsItem = lpObj->pInventory[lpMsg->Ipos].IsItem();

  00832	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00837	89 85 48 fe ff
	ff		 mov	 DWORD PTR _bIsItem$246022[ebp], eax

; 5143 : 		BYTE Option1 = lpObj->pInventory[lpMsg->Ipos].m_Option1;

  0083d	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00841	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00847	03 83 24 0e 00
	00		 add	 eax, DWORD PTR [ebx+3620]
  0084d	0f b6 88 94 00
	00 00		 movzx	 ecx, BYTE PTR [eax+148]

; 5144 : 		BYTE Option2 = lpObj->pInventory[lpMsg->Ipos].m_Option2;

  00854	0f b6 90 95 00
	00 00		 movzx	 edx, BYTE PTR [eax+149]

; 5145 : 		BYTE Option3 = lpObj->pInventory[lpMsg->Ipos].m_Option3;
; 5146 : 		BYTE NOption = lpObj->pInventory[lpMsg->Ipos].m_NewOption;
; 5147 : 		DWORD serial = lpObj->pInventory[lpMsg->Ipos].m_Number;

  0085b	8b 30		 mov	 esi, DWORD PTR [eax]
  0085d	88 8d 78 fe ff
	ff		 mov	 BYTE PTR _Option1$246023[ebp], cl
  00863	0f b6 88 96 00
	00 00		 movzx	 ecx, BYTE PTR [eax+150]
  0086a	88 95 80 fe ff
	ff		 mov	 BYTE PTR _Option2$246024[ebp], dl
  00870	0f b6 90 97 00
	00 00		 movzx	 edx, BYTE PTR [eax+151]
  00877	88 8d 7c fe ff
	ff		 mov	 BYTE PTR _Option3$246025[ebp], cl

; 5148 : 		int PetLevel = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Level;

  0087d	8b 88 bc 00 00
	00		 mov	 ecx, DWORD PTR [eax+188]
  00883	88 95 3c fe ff
	ff		 mov	 BYTE PTR _NOption$246026[ebp], dl

; 5149 : 		int PetExp = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Exp;

  00889	8b 90 c0 00 00
	00		 mov	 edx, DWORD PTR [eax+192]
  0088f	89 8d 38 fe ff
	ff		 mov	 DWORD PTR _PetLevel$246028[ebp], ecx

; 5150 : 		BYTE SOption = lpObj->pInventory[lpMsg->Ipos].m_SetOption;

  00895	0f b6 88 ae 00
	00 00		 movzx	 ecx, BYTE PTR [eax+174]
  0089c	89 95 40 fe ff
	ff		 mov	 DWORD PTR _PetExp$246029[ebp], edx

; 5151 : 		BYTE btItemEffectEx = lpObj->pInventory[lpMsg->Ipos].m_ItemOptionEx;

  008a2	0f b6 90 ca 00
	00 00		 movzx	 edx, BYTE PTR [eax+202]
  008a9	88 8d 50 fe ff
	ff		 mov	 BYTE PTR _SOption$246030[ebp], cl

; 5152 : 
; 5153 : 		//Season 4 add-on
; 5154 : 		BYTE SocketOption[5]; //
; 5155 : 		BYTE SocketIndex; //
; 5156 : 		g_SocketOption.GetActiveSocketOption(&lpObj->pInventory[lpMsg->Ipos],SocketOption,SocketIndex);

  008af	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR _SocketIndex$246033[ebp]
  008b5	51		 push	 ecx
  008b6	88 95 54 fe ff
	ff		 mov	 BYTE PTR _btItemEffectEx$246031[ebp], dl
  008bc	8d 55 b8	 lea	 edx, DWORD PTR _SocketOption$246032[ebp]
  008bf	52		 push	 edx
  008c0	50		 push	 eax
  008c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  008c6	e8 00 00 00 00	 call	 ?GetActiveSocketOption@CSocketOption@@QAEXPAVCItem@@PAEAAE@Z ; CSocketOption::GetActiveSocketOption

; 5157 : 
; 5158 : 		int serial2 = lpObj->pInventory[lpMsg->Ipos].m_Number;

  008cb	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]

; 5159 : 		char szItemName[50] = "Item";

  008cf	0f b6 0d 04 00
	00 00		 movzx	 ecx, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  008d6	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  008dc	03 83 24 0e 00
	00		 add	 eax, DWORD PTR [ebx+3620]
  008e2	6a 2d		 push	 45			; 0000002dH
  008e4	8b 10		 mov	 edx, DWORD PTR [eax]
  008e6	89 95 4c fe ff
	ff		 mov	 DWORD PTR _serial2$246034[ebp], edx
  008ec	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv3590[ebp], eax
  008f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  008f7	8d 55 c5	 lea	 edx, DWORD PTR _szItemName$246035[ebp+5]
  008fa	6a 00		 push	 0
  008fc	52		 push	 edx
  008fd	89 45 c0	 mov	 DWORD PTR _szItemName$246035[ebp], eax
  00900	88 4d c4	 mov	 BYTE PTR _szItemName$246035[ebp+4], cl
  00903	e8 00 00 00 00	 call	 _memset

; 5160 : 		BYTE JOHOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(&lpObj->pInventory[lpMsg->Ipos]);

  00908	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv3590[ebp]
  0090e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00911	50		 push	 eax
  00912	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00917	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption

; 5161 : 		BYTE JOHOptionLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel(&lpObj->pInventory[lpMsg->Ipos]);

  0091c	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00920	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00926	03 8b 24 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3620]
  0092c	88 85 72 fe ff
	ff		 mov	 BYTE PTR _JOHOption$246037[ebp], al
  00932	51		 push	 ecx
  00933	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00938	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel

; 5162 : 
; 5163 : 		if ( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Ipos]) != FALSE )

  0093d	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00941	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00947	03 93 24 0e 00
	00		 add	 edx, DWORD PTR [ebx+3620]
  0094d	88 85 73 fe ff
	ff		 mov	 BYTE PTR _JOHOptionLevel$246038[ebp], al
  00953	52		 push	 edx
  00954	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00959	83 c4 04	 add	 esp, 4
  0095c	85 c0		 test	 eax, eax
  0095e	74 63		 je	 SHORT $LN142@CGItemDrop

; 5164 : 		{
; 5165 : 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  00960	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00965	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0096a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0096f	50		 push	 eax
  00970	8b 03		 mov	 eax, DWORD PTR [ebx]
  00972	50		 push	 eax
  00973	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5166 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d)", lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Ipos].GetName(), lpMsg->Ipos);

  00978	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0097c	83 c4 08	 add	 esp, 8
  0097f	51		 push	 ecx
  00980	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00986	03 8b 24 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3620]
  0098c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00991	50		 push	 eax
  00992	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00995	51		 push	 ecx
  00996	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00999	52		 push	 edx
  0099a	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@
  0099f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  009a5	83 c4 14	 add	 esp, 20			; 00000014H

; 5167 : 
; 5168 : 			CopyItem = TRUE;

  009a8	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _CopyItem$[ebp], 1

; 5169 : 			pResult.Result = false;

  009b2	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5170 : 			bIsItem = FALSE;

  009b9	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bIsItem$246022[ebp], 0
$LN142@CGItemDrop:

; 5171 : 		}
; 5172 : 
; 5173 : 		if ( !::gObjInventorySearchSerialNumber(lpObj, serial2))

  009c3	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR _serial2$246034[ebp]
  009c9	50		 push	 eax
  009ca	53		 push	 ebx
  009cb	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  009d0	83 c4 08	 add	 esp, 8
  009d3	85 c0		 test	 eax, eax
  009d5	0f 85 71 01 00
	00		 jne	 $LN141@CGItemDrop

; 5174 : 		{
; 5175 : 			CopyItem = TRUE;

  009db	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _CopyItem$[ebp], 1

; 5176 : 			pResult.Result = false;

  009e5	88 85 8b fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
$LN140@CGItemDrop:

; 5680 : 				{
; 5681 : 					pResult.Result = false;
; 5682 : 				}
; 5683 : 			}
; 5684 : 		}
; 5685 : 		else
; 5686 : 		{
; 5687 : 			LogAdd(lMsg.Get(MSGGET(1, 225)));

  009eb	68 e1 01 00 00	 push	 481			; 000001e1H
  009f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  009f5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  009fa	50		 push	 eax
  009fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00a01	83 c4 04	 add	 esp, 4
$LN227@CGItemDrop:

; 5688 : 			pResult.Result = false;

  00a04	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN6@CGItemDrop:

; 5689 : 		}
; 5690 : 	}
; 5691 : 
; 5692 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00a0b	0f b6 85 89 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00a12	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00a18	50		 push	 eax
  00a19	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00a1f	51		 push	 ecx
  00a20	52		 push	 edx
  00a21	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00a26	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5693 : 
; 5694 : 	if ( CopyItem != FALSE )

  00a29	83 bd 58 fe ff
	ff 00		 cmp	 DWORD PTR _CopyItem$[ebp], 0
  00a30	74 26		 je	 SHORT $LN5@CGItemDrop

; 5695 : 	{
; 5696 : 		::GCItemListSend(aIndex);

  00a32	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00a38	50		 push	 eax
  00a39	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend

; 5697 : #ifdef PERIOD
; 5698 : 		g_PeriodItemZt.OnRequestPeriodItemList(&gObj[aIndex]);

  00a3e	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  00a44	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a4a	83 c4 04	 add	 esp, 4
  00a4d	52		 push	 edx
  00a4e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemZt@@3VCPeriodItemZt@@A ; g_PeriodItemZt
  00a53	e8 00 00 00 00	 call	 ?OnRequestPeriodItemList@CPeriodItemZt@@QAEXPAUOBJECTSTRUCT@@@Z ; CPeriodItemZt::OnRequestPeriodItemList
$LN5@CGItemDrop:

; 5699 : #endif
; 5700 : 	}
; 5701 : 
; 5702 : 	if ( pResult.Result == 1 )

  00a58	80 bd 8b fe ff
	ff 01		 cmp	 BYTE PTR _pResult$[ebp+3], 1
  00a5f	0f 85 cf 00 00
	00		 jne	 $LN3@CGItemDrop

; 5703 : 	{
; 5704 : 		if ( lpMsg->Ipos < 12 )

  00a65	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  00a68	3c 0c		 cmp	 al, 12			; 0000000cH
  00a6a	0f 83 c4 00 00
	00		 jae	 $LN3@CGItemDrop

; 5705 : 		{
; 5706 : 			if ( lpMsg->Ipos == 10 || lpMsg->Ipos == 11 )

  00a70	3c 0a		 cmp	 al, 10			; 0000000aH
  00a72	74 04		 je	 SHORT $LN1@CGItemDrop
  00a74	3c 0b		 cmp	 al, 11			; 0000000bH
  00a76	75 11		 jne	 SHORT $LN2@CGItemDrop
$LN1@CGItemDrop:

; 5707 : 			{
; 5708 : 				gObjUseSkill.SkillChangeUse(aIndex);

  00a78	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00a7e	50		 push	 eax
  00a7f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00a84	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN2@CGItemDrop:

; 5709 : 			}
; 5710 : 
; 5711 : 			::gObjMakePreviewCharSet(aIndex);

  00a89	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00a8f	51		 push	 ecx
  00a90	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 5712 : 
; 5713 : 			PMSG_USEREQUIPMENTCHANGED pChange;
; 5714 : 
; 5715 : 			PHeadSetB((LPBYTE)&pChange, 0x25, sizeof(pChange));

  00a95	6a 11		 push	 17			; 00000011H
  00a97	8d 55 a4	 lea	 edx, DWORD PTR _pChange$246253[ebp]
  00a9a	6a 25		 push	 37			; 00000025H
  00a9c	52		 push	 edx
  00a9d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 5716 : 			pChange.NumberH = SET_NUMBERH(aIndex);
; 5717 : 			pChange.NumberL = SET_NUMBERL(aIndex);
; 5718 : 			ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[lpMsg->Ipos]);

  00aa2	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00aa8	0f b6 72 05	 movzx	 esi, BYTE PTR [edx+5]
  00aac	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00ab2	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00ab8	03 b3 24 0e 00
	00		 add	 esi, DWORD PTR [ebx+3620]
  00abe	8b c8		 mov	 ecx, eax
  00ac0	c1 e9 08	 shr	 ecx, 8
  00ac3	88 45 a8	 mov	 BYTE PTR _pChange$246253[ebp+4], al
  00ac6	88 4d a7	 mov	 BYTE PTR _pChange$246253[ebp+3], cl
  00ac9	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00acf	8d 45 a9	 lea	 eax, DWORD PTR _pChange$246253[ebp+5]
  00ad2	8b fc		 mov	 edi, esp
  00ad4	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00ad9	50		 push	 eax
  00ada	f3 a5		 rep movsd
  00adc	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5719 : 			pChange.ItemInfo[1] = lpMsg->Ipos <<  4;

  00ae1	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00ae7	8a 41 05	 mov	 al, BYTE PTR [ecx+5]

; 5720 : 			pChange.ItemInfo[1] |= LevelSmallConvert(aIndex, lpMsg->Ipos) & 0x0F;

  00aea	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00af0	8a d0		 mov	 dl, al
  00af2	0f b6 c0	 movzx	 eax, al
  00af5	50		 push	 eax
  00af6	c0 e2 04	 shl	 dl, 4
  00af9	51		 push	 ecx
  00afa	88 55 aa	 mov	 BYTE PTR _pChange$246253[ebp+6], dl
  00afd	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert

; 5721 : 
; 5722 : 			DataSend(aIndex, (LPBYTE)&pChange, pChange.h.size);

  00b02	0f b6 55 a5	 movzx	 edx, BYTE PTR _pChange$246253[ebp+1]
  00b06	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00b0c	24 0f		 and	 al, 15			; 0000000fH
  00b0e	08 45 aa	 or	 BYTE PTR _pChange$246253[ebp+6], al
  00b11	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00b17	52		 push	 edx
  00b18	8d 45 a4	 lea	 eax, DWORD PTR _pChange$246253[ebp]
  00b1b	50		 push	 eax
  00b1c	51		 push	 ecx
  00b1d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5723 : 			MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  00b22	0f b6 55 a5	 movzx	 edx, BYTE PTR _pChange$246253[ebp+1]
  00b26	52		 push	 edx
  00b27	8d 45 a4	 lea	 eax, DWORD PTR _pChange$246253[ebp]
  00b2a	50		 push	 eax
  00b2b	53		 push	 ebx
  00b2c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00b31	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@CGItemDrop:

; 5724 : 		}
; 5725 : 	}
; 5726 : 	
; 5727 : 	return pResult.Result;

  00b34	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+3]

; 5728 : }

  00b3b	5f		 pop	 edi
  00b3c	5e		 pop	 esi
  00b3d	5b		 pop	 ebx
  00b3e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b41	33 cd		 xor	 ecx, ebp
  00b43	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b48	8b e5		 mov	 esp, ebp
  00b4a	5d		 pop	 ebp
  00b4b	c3		 ret	 0
$LN141@CGItemDrop:

; 5177 : 			bIsItem = FALSE;
; 5178 : 		}
; 5179 : 
; 5180 : 		if ( bIsItem == TRUE )

  00b4c	83 bd 48 fe ff
	ff 01		 cmp	 DWORD PTR _bIsItem$246022[ebp], 1
  00b53	0f 85 92 fe ff
	ff		 jne	 $LN140@CGItemDrop

; 5181 : 		{
; 5182 : 			strcpy(szItemName, lpObj->pInventory[lpMsg->Ipos].GetName());

  00b59	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00b5d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00b63	03 8b 24 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3620]
  00b69	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00b6e	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  00b71	2b d0		 sub	 edx, eax
$LL205@CGItemDrop:
  00b73	8a 08		 mov	 cl, BYTE PTR [eax]
  00b75	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00b78	40		 inc	 eax
  00b79	84 c9		 test	 cl, cl
  00b7b	75 f6		 jne	 SHORT $LL205@CGItemDrop

; 5183 : 
; 5184 : 			if ( type == ITEMGET(14,11))

  00b7d	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR _type$246019[ebp]
  00b83	3d 0b 1c 00 00	 cmp	 eax, 7179		; 00001c0bH
  00b88	0f 85 49 06 00
	00		 jne	 $LN139@CGItemDrop

; 5185 : 			{
; 5186 : 				::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00b8e	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00b92	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00b98	51		 push	 ecx
  00b99	52		 push	 edx
  00b9a	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00b9f	83 c4 08	 add	 esp, 8

; 5187 : 				pResult.Result = true;
; 5188 : 
; 5189 : 				if ( level == 1 )

  00ba2	83 bd 74 fe ff
	ff 01		 cmp	 DWORD PTR _level$246020[ebp], 1
  00ba9	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
  00bb0	75 69		 jne	 SHORT $LN138@CGItemDrop

; 5190 : 				{
; 5191 : 					::StarOfXMasOpenEven(&gObj[aIndex]);

  00bb2	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00bb8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bbe	51		 push	 ecx
  00bbf	e8 00 00 00 00	 call	 ?StarOfXMasOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; StarOfXMasOpenEven

; 5192 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of StarOfXMas Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00bc4	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00bcb	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00bd2	52		 push	 edx
  00bd3	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00bda	51		 push	 ecx
  00bdb	52		 push	 edx
  00bdc	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00be3	6a 01		 push	 1
  00be5	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00bea	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00bed	51		 push	 ecx
  00bee	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00bf5	56		 push	 esi
  00bf6	52		 push	 edx
  00bf7	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00bfe	51		 push	 ecx
  00bff	52		 push	 edx
  00c00	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00c03	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00c06	57		 push	 edi
  00c07	50		 push	 eax
  00c08	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@MNOGBEOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5St@
  00c0d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c13	83 c4 38	 add	 esp, 56			; 00000038H
  00c16	e9 5f 05 00 00	 jmp	 $LN113@CGItemDrop
$LN138@CGItemDrop:

; 5193 : 				}
; 5194 : 				else if ( level == 2 )

  00c1b	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  00c21	83 f8 02	 cmp	 eax, 2
  00c24	75 69		 jne	 SHORT $LN136@CGItemDrop

; 5195 : 				{
; 5196 : 					::FireCrackerOpenEven(&gObj[aIndex]);

  00c26	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00c2c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c32	51		 push	 ecx
  00c33	e8 00 00 00 00	 call	 ?FireCrackerOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; FireCrackerOpenEven

; 5197 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of FireCracker Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00c38	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00c3f	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00c46	52		 push	 edx
  00c47	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00c4e	51		 push	 ecx
  00c4f	52		 push	 edx
  00c50	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00c57	6a 02		 push	 2
  00c59	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00c5e	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00c61	51		 push	 ecx
  00c62	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00c69	56		 push	 esi
  00c6a	52		 push	 edx
  00c6b	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00c72	51		 push	 ecx
  00c73	52		 push	 edx
  00c74	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00c77	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00c7a	57		 push	 edi
  00c7b	50		 push	 eax
  00c7c	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@LBGLIJMP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Fi@
  00c81	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c87	83 c4 38	 add	 esp, 56			; 00000038H
  00c8a	e9 eb 04 00 00	 jmp	 $LN113@CGItemDrop
$LN136@CGItemDrop:

; 5198 : 				}
; 5199 : 				else if ( level == 3 )

  00c8f	83 f8 03	 cmp	 eax, 3
  00c92	75 69		 jne	 SHORT $LN134@CGItemDrop

; 5200 : 				{
; 5201 : 					::HeartOfLoveOpenEven(&gObj[aIndex]);

  00c94	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00c9a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ca0	51		 push	 ecx
  00ca1	e8 00 00 00 00	 call	 ?HeartOfLoveOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; HeartOfLoveOpenEven

; 5202 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of HeartOfLove Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00ca6	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00cad	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00cb4	52		 push	 edx
  00cb5	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00cbc	51		 push	 ecx
  00cbd	52		 push	 edx
  00cbe	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00cc5	6a 03		 push	 3
  00cc7	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00ccc	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00ccf	51		 push	 ecx
  00cd0	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00cd7	56		 push	 esi
  00cd8	52		 push	 edx
  00cd9	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00ce0	51		 push	 ecx
  00ce1	52		 push	 edx
  00ce2	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00ce5	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00ce8	57		 push	 edi
  00ce9	50		 push	 eax
  00cea	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@PDLPCBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5He@
  00cef	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00cf5	83 c4 38	 add	 esp, 56			; 00000038H
  00cf8	e9 7d 04 00 00	 jmp	 $LN113@CGItemDrop
$LN134@CGItemDrop:

; 5203 : 				}
; 5204 : 				else if ( level == 6 )

  00cfd	83 f8 06	 cmp	 eax, 6
  00d00	75 69		 jne	 SHORT $LN132@CGItemDrop

; 5205 : 				{
; 5206 : 					::GoldMedalOpenEven(&gObj[aIndex]);

  00d02	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00d08	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d0e	51		 push	 ecx
  00d0f	e8 00 00 00 00	 call	 ?GoldMedalOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; GoldMedalOpenEven

; 5207 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of GoldMedal Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00d14	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00d1b	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00d22	52		 push	 edx
  00d23	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00d2a	51		 push	 ecx
  00d2b	52		 push	 edx
  00d2c	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00d33	6a 06		 push	 6
  00d35	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00d3a	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00d3d	51		 push	 ecx
  00d3e	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00d45	56		 push	 esi
  00d46	52		 push	 edx
  00d47	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00d4e	51		 push	 ecx
  00d4f	52		 push	 edx
  00d50	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00d53	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00d56	57		 push	 edi
  00d57	50		 push	 eax
  00d58	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@HNNMBKPL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Go@
  00d5d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d63	83 c4 38	 add	 esp, 56			; 00000038H
  00d66	e9 0f 04 00 00	 jmp	 $LN113@CGItemDrop
$LN132@CGItemDrop:

; 5208 : 				}
; 5209 : 				else if ( level == 5 )

  00d6b	83 f8 05	 cmp	 eax, 5
  00d6e	75 69		 jne	 SHORT $LN130@CGItemDrop

; 5210 : 				{
; 5211 : 					::SilverMedalOpenEven(&gObj[aIndex]);

  00d70	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00d76	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d7c	51		 push	 ecx
  00d7d	e8 00 00 00 00	 call	 ?SilverMedalOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; SilverMedalOpenEven

; 5212 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of SilverMedal Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00d82	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00d89	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00d90	52		 push	 edx
  00d91	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00d98	51		 push	 ecx
  00d99	52		 push	 edx
  00d9a	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00da1	6a 05		 push	 5
  00da3	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00da8	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00dab	51		 push	 ecx
  00dac	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00db3	56		 push	 esi
  00db4	52		 push	 edx
  00db5	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00dbc	51		 push	 ecx
  00dbd	52		 push	 edx
  00dbe	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00dc1	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00dc4	57		 push	 edi
  00dc5	50		 push	 eax
  00dc6	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Si@
  00dcb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00dd1	83 c4 38	 add	 esp, 56			; 00000038H
  00dd4	e9 a1 03 00 00	 jmp	 $LN113@CGItemDrop
$LN130@CGItemDrop:

; 5213 : 				}
; 5214 : 				else if ( level == 7 )

  00dd9	83 f8 07	 cmp	 eax, 7
  00ddc	75 69		 jne	 SHORT $LN128@CGItemDrop

; 5215 : 				{
; 5216 : 					::EventChipOpenEven(&gObj[aIndex]);

  00dde	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00de4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dea	51		 push	 ecx
  00deb	e8 00 00 00 00	 call	 ?EventChipOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; EventChipOpenEven

; 5217 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of EventChip Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00df0	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00df7	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00dfe	52		 push	 edx
  00dff	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00e06	51		 push	 ecx
  00e07	52		 push	 edx
  00e08	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00e0f	6a 07		 push	 7
  00e11	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00e16	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00e19	51		 push	 ecx
  00e1a	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00e21	56		 push	 esi
  00e22	52		 push	 edx
  00e23	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00e2a	51		 push	 ecx
  00e2b	52		 push	 edx
  00e2c	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00e2f	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00e32	57		 push	 edi
  00e33	50		 push	 eax
  00e34	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@EEPLJEBI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Ev@
  00e39	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00e3f	83 c4 38	 add	 esp, 56			; 00000038H
  00e42	e9 33 03 00 00	 jmp	 $LN113@CGItemDrop
$LN128@CGItemDrop:

; 5218 : 				}
; 5219 : 				else if ( level == 8 )

  00e47	83 f8 08	 cmp	 eax, 8
  00e4a	75 71		 jne	 SHORT $LN126@CGItemDrop

; 5220 : 				{
; 5221 : 					::EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 50000);

  00e4c	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00e52	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e58	68 50 c3 00 00	 push	 50000			; 0000c350H
  00e5d	6a 02		 push	 2
  00e5f	50		 push	 eax
  00e60	51		 push	 ecx
  00e61	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAUOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven

; 5222 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-8 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00e66	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00e6d	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00e74	52		 push	 edx
  00e75	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00e7c	51		 push	 ecx
  00e7d	52		 push	 edx
  00e7e	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00e85	6a 08		 push	 8
  00e87	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00e8c	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00e8f	51		 push	 ecx
  00e90	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00e97	56		 push	 esi
  00e98	52		 push	 edx
  00e99	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00ea0	51		 push	 ecx
  00ea1	52		 push	 edx
  00ea2	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00ea5	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00ea8	57		 push	 edi
  00ea9	50		 push	 eax
  00eaa	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@CGPEKJOL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
  00eaf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00eb5	83 c4 44	 add	 esp, 68			; 00000044H
  00eb8	e9 bd 02 00 00	 jmp	 $LN113@CGItemDrop
$LN126@CGItemDrop:

; 5223 : 				}
; 5224 : 				else if ( level == 9 )

  00ebd	83 f8 09	 cmp	 eax, 9
  00ec0	75 71		 jne	 SHORT $LN124@CGItemDrop

; 5225 : 				{
; 5226 : 					::EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 100000);

  00ec2	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00ec8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ece	68 a0 86 01 00	 push	 100000			; 000186a0H
  00ed3	6a 02		 push	 2
  00ed5	50		 push	 eax
  00ed6	51		 push	 ecx
  00ed7	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAUOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven

; 5227 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-9 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00edc	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00ee3	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00eea	52		 push	 edx
  00eeb	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00ef2	51		 push	 ecx
  00ef3	52		 push	 edx
  00ef4	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00efb	6a 09		 push	 9
  00efd	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00f02	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00f05	51		 push	 ecx
  00f06	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00f0d	56		 push	 esi
  00f0e	52		 push	 edx
  00f0f	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00f16	51		 push	 ecx
  00f17	52		 push	 edx
  00f18	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00f1b	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00f1e	57		 push	 edi
  00f1f	50		 push	 eax
  00f20	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@EPDIFFOG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
  00f25	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00f2b	83 c4 44	 add	 esp, 68			; 00000044H
  00f2e	e9 47 02 00 00	 jmp	 $LN113@CGItemDrop
$LN124@CGItemDrop:

; 5228 : 				}
; 5229 : 				else if ( level == 10 )

  00f33	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00f36	75 71		 jne	 SHORT $LN122@CGItemDrop

; 5230 : 				{
; 5231 : 					::EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 150000);

  00f38	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00f3e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f44	68 f0 49 02 00	 push	 150000			; 000249f0H
  00f49	6a 02		 push	 2
  00f4b	50		 push	 eax
  00f4c	51		 push	 ecx
  00f4d	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAUOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven

; 5232 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-10 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00f52	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00f59	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00f60	52		 push	 edx
  00f61	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00f68	51		 push	 ecx
  00f69	52		 push	 edx
  00f6a	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00f71	6a 0a		 push	 10			; 0000000aH
  00f73	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00f78	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00f7b	51		 push	 ecx
  00f7c	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00f83	56		 push	 esi
  00f84	52		 push	 edx
  00f85	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  00f8c	51		 push	 ecx
  00f8d	52		 push	 edx
  00f8e	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  00f91	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00f94	57		 push	 edi
  00f95	50		 push	 eax
  00f96	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@EFLIOIJH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
  00f9b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00fa1	83 c4 44	 add	 esp, 68			; 00000044H
  00fa4	e9 d1 01 00 00	 jmp	 $LN113@CGItemDrop
$LN122@CGItemDrop:

; 5233 : 				}
; 5234 : 				else if ( level == 11 )

  00fa9	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00fac	75 71		 jne	 SHORT $LN120@CGItemDrop

; 5235 : 				{
; 5236 : 					::EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 200000);

  00fae	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  00fb4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fba	68 40 0d 03 00	 push	 200000			; 00030d40H
  00fbf	6a 02		 push	 2
  00fc1	50		 push	 eax
  00fc2	51		 push	 ecx
  00fc3	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAUOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven

; 5237 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox1-11 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  00fc8	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  00fcf	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  00fd6	52		 push	 edx
  00fd7	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  00fde	51		 push	 ecx
  00fdf	52		 push	 edx
  00fe0	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  00fe7	6a 0b		 push	 11			; 0000000bH
  00fe9	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  00fee	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  00ff1	51		 push	 ecx
  00ff2	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  00ff9	56		 push	 esi
  00ffa	52		 push	 edx
  00ffb	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  01002	51		 push	 ecx
  01003	52		 push	 edx
  01004	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  01007	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0100a	57		 push	 edi
  0100b	50		 push	 eax
  0100c	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CKKIPCAM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
  01011	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01017	83 c4 44	 add	 esp, 68			; 00000044H
  0101a	e9 5b 01 00 00	 jmp	 $LN113@CGItemDrop
$LN120@CGItemDrop:

; 5238 : 				}
; 5239 : 				else if ( level == 12 )

  0101f	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  01022	75 71		 jne	 SHORT $LN118@CGItemDrop

; 5240 : 				{
; 5241 : 					::EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 250000);

  01024	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  0102a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01030	68 90 d0 03 00	 push	 250000			; 0003d090H
  01035	6a 02		 push	 2
  01037	50		 push	 eax
  01038	51		 push	 ecx
  01039	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAUOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven

; 5242 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox1-12 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0103e	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  01045	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  0104c	52		 push	 edx
  0104d	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  01054	51		 push	 ecx
  01055	52		 push	 edx
  01056	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  0105d	6a 0c		 push	 12			; 0000000cH
  0105f	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  01064	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  01067	51		 push	 ecx
  01068	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  0106f	56		 push	 esi
  01070	52		 push	 edx
  01071	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  01078	51		 push	 ecx
  01079	52		 push	 edx
  0107a	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  0107d	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01080	57		 push	 edi
  01081	50		 push	 eax
  01082	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JAPNPGBL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5El@
  01087	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0108d	83 c4 44	 add	 esp, 68			; 00000044H
  01090	e9 e5 00 00 00	 jmp	 $LN113@CGItemDrop
$LN118@CGItemDrop:

; 5243 : 				}
; 5244 : 				else if ( level == 13 )

  01095	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  01098	75 66		 jne	 SHORT $LN116@CGItemDrop

; 5245 : 				{
; 5246 : 					::DarkLordHeartItemBoxOpen(&gObj[aIndex]);

  0109a	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  010a0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010a6	51		 push	 ecx
  010a7	e8 00 00 00 00	 call	 ?DarkLordHeartItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; DarkLordHeartItemBoxOpen

; 5247 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of DarkLordHeart Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  010ac	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  010b3	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  010ba	52		 push	 edx
  010bb	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  010c2	51		 push	 ecx
  010c3	52		 push	 edx
  010c4	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  010cb	6a 0d		 push	 13			; 0000000dH
  010cd	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  010d2	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  010d5	51		 push	 ecx
  010d6	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  010dd	56		 push	 esi
  010de	52		 push	 edx
  010df	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  010e6	51		 push	 ecx
  010e7	52		 push	 edx
  010e8	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  010eb	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  010ee	57		 push	 edi
  010ef	50		 push	 eax
  010f0	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@OLBBBANK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5Da@
  010f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  010fb	83 c4 38	 add	 esp, 56			; 00000038H
  010fe	eb 7a		 jmp	 SHORT $LN113@CGItemDrop
$LN116@CGItemDrop:

; 5248 : 				}
; 5249 : 				else if ( level == 0 )

  01100	85 c0		 test	 eax, eax
  01102	0f 85 97 00 00
	00		 jne	 $LN114@CGItemDrop

; 5250 : 				{
; 5251 : 					::LuckyBoxOpenEven(&gObj[aIndex]);

  01108	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  0110e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01114	51		 push	 ecx
  01115	e8 00 00 00 00	 call	 ?LuckyBoxOpenEven@@YAXPAUOBJECTSTRUCT@@@Z ; LuckyBoxOpenEven

; 5252 : 					LogAddTD(lMsg.Get(MSGGET(1, 222)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0111a	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  01121	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  01128	83 c4 04	 add	 esp, 4
  0112b	52		 push	 edx
  0112c	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  01133	51		 push	 ecx
  01134	52		 push	 edx
  01135	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  0113c	6a 00		 push	 0
  0113e	68 0b 1c 00 00	 push	 7179			; 00001c0bH
  01143	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  01146	51		 push	 ecx
  01147	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  0114e	56		 push	 esi
  0114f	52		 push	 edx
  01150	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  01157	51		 push	 ecx
  01158	52		 push	 edx
  01159	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  0115c	57		 push	 edi
  0115d	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01160	50		 push	 eax
  01161	68 de 01 00 00	 push	 478			; 000001deH
  01166	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0116b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01170	50		 push	 eax
  01171	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01177	83 c4 34	 add	 esp, 52			; 00000034H
$LN113@CGItemDrop:

; 5259 : 				}
; 5260 : 
; 5261 : 				LogAddTD("[%s][%s] Used box of luck (level:%d)", lpObj->AccountID, lpObj->Name, level);

  0117a	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  01180	50		 push	 eax
  01181	57		 push	 edi
  01182	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01185	50		 push	 eax
  01186	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NAOHIDPP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Used?5box?5of?5luck?5?$CIlevel@
  0118b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01191	8b bd 60 fe ff
	ff		 mov	 edi, DWORD PTR _lpMsg$GSCopy$[ebp]
  01197	83 c4 10	 add	 esp, 16			; 00000010H
  0119a	e9 6c f8 ff ff	 jmp	 $LN6@CGItemDrop
$LN114@CGItemDrop:

; 5253 : 				}
; 5254 : 				else
; 5255 : 				{
; 5256 : 					pResult.Result = false;
; 5257 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0119f	0f b6 8d 89 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  011a6	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  011ac	51		 push	 ecx
  011ad	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  011b3	52		 push	 edx
  011b4	50		 push	 eax
  011b5	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  011bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  011c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5258 : 					return FALSE;

  011c4	33 c0		 xor	 eax, eax

; 5728 : }

  011c6	5f		 pop	 edi
  011c7	5e		 pop	 esi
  011c8	5b		 pop	 ebx
  011c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011cc	33 cd		 xor	 ecx, ebp
  011ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011d3	8b e5		 mov	 esp, ebp
  011d5	5d		 pop	 ebp
  011d6	c3		 ret	 0
$LN139@CGItemDrop:

; 5262 : 			}
; 5263 : 			else if ( type == ITEMGET(12,32) )

  011d7	3d 20 18 00 00	 cmp	 eax, 6176		; 00001820H
  011dc	0f 85 7f 00 00
	00		 jne	 $LN111@CGItemDrop

; 5264 : 			{
; 5265 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  011e2	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  011e6	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  011ec	51		 push	 ecx
  011ed	52		 push	 edx
  011ee	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5266 : 				RedRibbonBoxOpen(&gObj[aIndex]);

  011f3	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  011f9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011ff	51		 push	 ecx
  01200	e8 00 00 00 00	 call	 ?RedRibbonBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; RedRibbonBoxOpen

; 5267 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  01205	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  0120c	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  01213	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  0121a	52		 push	 edx
  0121b	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _level$246020[ebp]
  01221	50		 push	 eax
  01222	51		 push	 ecx
  01223	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  0122a	52		 push	 edx
  0122b	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  01232	68 20 18 00 00	 push	 6176			; 00001820H
  01237	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  0123a	50		 push	 eax
  0123b	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  01242	56		 push	 esi
  01243	51		 push	 ecx
  01244	52		 push	 edx
  01245	50		 push	 eax
  01246	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  01249	51		 push	 ecx
  0124a	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  0124d	52		 push	 edx
  0124e	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@OKEEHLGI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@
  01253	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01259	83 c4 40	 add	 esp, 64			; 00000040H
  0125c	e9 aa f7 ff ff	 jmp	 $LN6@CGItemDrop
$LN111@CGItemDrop:

; 5268 : 			}
; 5269 : 			else if ( type == ITEMGET(12,33) )

  01261	3d 21 18 00 00	 cmp	 eax, 6177		; 00001821H
  01266	0f 85 7f 00 00
	00		 jne	 $LN109@CGItemDrop

; 5270 : 			{
; 5271 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0126c	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01270	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01276	50		 push	 eax
  01277	51		 push	 ecx
  01278	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5272 : 				GreenRibbonBoxOpen(&gObj[aIndex]);

  0127d	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  01283	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01289	50		 push	 eax
  0128a	e8 00 00 00 00	 call	 ?GreenRibbonBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; GreenRibbonBoxOpen

; 5273 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0128f	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  01296	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  0129d	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  012a4	51		 push	 ecx
  012a5	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  012ab	52		 push	 edx
  012ac	50		 push	 eax
  012ad	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  012b4	51		 push	 ecx
  012b5	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  012bc	68 21 18 00 00	 push	 6177			; 00001821H
  012c1	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  012c4	52		 push	 edx
  012c5	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  012cc	56		 push	 esi
  012cd	50		 push	 eax
  012ce	51		 push	 ecx
  012cf	52		 push	 edx
  012d0	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  012d3	50		 push	 eax
  012d4	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  012d7	51		 push	 ecx
  012d8	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@OKEEHLGI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@
  012dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  012e3	83 c4 40	 add	 esp, 64			; 00000040H
  012e6	e9 20 f7 ff ff	 jmp	 $LN6@CGItemDrop
$LN109@CGItemDrop:

; 5274 : 			}
; 5275 : 			else if ( type == ITEMGET(12,34) )

  012eb	3d 22 18 00 00	 cmp	 eax, 6178		; 00001822H
  012f0	0f 85 7f 00 00
	00		 jne	 $LN107@CGItemDrop

; 5276 : 			{
; 5277 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  012f6	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  012fa	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  01300	52		 push	 edx
  01301	50		 push	 eax
  01302	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5278 : 				BlueRibbonBoxOpen(&gObj[aIndex]);

  01307	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  0130d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01313	52		 push	 edx
  01314	e8 00 00 00 00	 call	 ?BlueRibbonBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; BlueRibbonBoxOpen

; 5279 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  01319	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  01320	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  01327	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  0132e	50		 push	 eax
  0132f	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  01335	51		 push	 ecx
  01336	52		 push	 edx
  01337	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  0133e	50		 push	 eax
  0133f	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  01346	68 22 18 00 00	 push	 6178			; 00001822H
  0134b	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  0134e	51		 push	 ecx
  0134f	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01356	56		 push	 esi
  01357	52		 push	 edx
  01358	50		 push	 eax
  01359	51		 push	 ecx
  0135a	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  0135d	52		 push	 edx
  0135e	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01361	50		 push	 eax
  01362	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@OKEEHLGI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@
  01367	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0136d	83 c4 40	 add	 esp, 64			; 00000040H
  01370	e9 96 f6 ff ff	 jmp	 $LN6@CGItemDrop
$LN107@CGItemDrop:

; 5280 : 			}
; 5281 : 			else if ( type == ITEMGET(14,32) && level == 0 )

  01375	3d 20 1c 00 00	 cmp	 eax, 7200		; 00001c20H
  0137a	0f 85 88 00 00
	00		 jne	 $LN105@CGItemDrop
  01380	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  01386	85 c9		 test	 ecx, ecx
  01388	0f 85 a0 01 00
	00		 jne	 $LN216@CGItemDrop

; 5282 : 			{
; 5283 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0138e	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  01392	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01398	51		 push	 ecx
  01399	52		 push	 edx
  0139a	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5284 : 				PinkChocolateBoxOpen(&gObj[aIndex]);

  0139f	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  013a5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  013ab	51		 push	 ecx
  013ac	e8 00 00 00 00	 call	 ?PinkChocolateBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; PinkChocolateBoxOpen

; 5285 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  013b1	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  013b8	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  013bf	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  013c6	52		 push	 edx
  013c7	50		 push	 eax
  013c8	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  013cf	51		 push	 ecx
  013d0	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  013d7	6a 00		 push	 0
  013d9	68 20 1c 00 00	 push	 7200			; 00001c20H
  013de	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  013e1	52		 push	 edx
  013e2	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  013e9	56		 push	 esi
  013ea	50		 push	 eax
  013eb	51		 push	 ecx
  013ec	52		 push	 edx
  013ed	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  013f0	50		 push	 eax
  013f1	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  013f4	51		 push	 ecx
  013f5	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@OJDMPPPF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Valentine@
  013fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01400	83 c4 40	 add	 esp, 64			; 00000040H
  01403	e9 03 f6 ff ff	 jmp	 $LN6@CGItemDrop
$LN105@CGItemDrop:

; 5286 : 			}
; 5287 : 			else if ( type == ITEMGET(14,33)  && level == 0 )

  01408	3d 21 1c 00 00	 cmp	 eax, 7201		; 00001c21H
  0140d	0f 85 88 00 00
	00		 jne	 $LN103@CGItemDrop
  01413	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  01419	85 c9		 test	 ecx, ecx
  0141b	0f 85 90 01 00
	00		 jne	 $LN217@CGItemDrop

; 5288 : 			{
; 5289 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01421	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  01425	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0142b	52		 push	 edx
  0142c	50		 push	 eax
  0142d	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5290 : 				RedChocolateBoxOpen(&gObj[aIndex]);

  01432	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  01438	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0143e	52		 push	 edx
  0143f	e8 00 00 00 00	 call	 ?RedChocolateBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; RedChocolateBoxOpen

; 5291 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  01444	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  0144b	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  01452	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  01459	50		 push	 eax
  0145a	51		 push	 ecx
  0145b	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  01462	52		 push	 edx
  01463	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  0146a	6a 00		 push	 0
  0146c	68 21 1c 00 00	 push	 7201			; 00001c21H
  01471	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  01474	50		 push	 eax
  01475	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  0147c	56		 push	 esi
  0147d	51		 push	 ecx
  0147e	52		 push	 edx
  0147f	50		 push	 eax
  01480	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  01483	51		 push	 ecx
  01484	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  01487	52		 push	 edx
  01488	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@OJDMPPPF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Valentine@
  0148d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01493	83 c4 40	 add	 esp, 64			; 00000040H
  01496	e9 70 f5 ff ff	 jmp	 $LN6@CGItemDrop
$LN103@CGItemDrop:

; 5292 : 
; 5293 : 			}
; 5294 : 			else if ( type == ITEMGET(14,34) && level == 0  )

  0149b	3d 22 1c 00 00	 cmp	 eax, 7202		; 00001c22H
  014a0	0f 85 11 02 00
	00		 jne	 $LN95@CGItemDrop
  014a6	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  014ac	85 c9		 test	 ecx, ecx
  014ae	0f 85 80 01 00
	00		 jne	 $LN218@CGItemDrop

; 5295 : 			{
; 5296 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  014b4	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  014b8	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  014be	50		 push	 eax
  014bf	51		 push	 ecx
  014c0	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5297 : 				BlueChocolateBoxOpen(&gObj[aIndex]);

  014c5	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  014cb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014d1	50		 push	 eax
  014d2	e8 00 00 00 00	 call	 ?BlueChocolateBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; BlueChocolateBoxOpen

; 5298 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  014d7	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  014de	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  014e5	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  014ec	51		 push	 ecx
  014ed	52		 push	 edx
  014ee	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  014f5	50		 push	 eax
  014f6	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  014fd	6a 00		 push	 0
  014ff	68 22 1c 00 00	 push	 7202			; 00001c22H
  01504	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  01507	51		 push	 ecx
  01508	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  0150f	56		 push	 esi
  01510	52		 push	 edx
  01511	50		 push	 eax
  01512	51		 push	 ecx
  01513	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  01516	52		 push	 edx
  01517	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0151a	50		 push	 eax
  0151b	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@OJDMPPPF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Valentine@
  01520	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01526	83 c4 40	 add	 esp, 64			; 00000040H
  01529	e9 dd f4 ff ff	 jmp	 $LN6@CGItemDrop
$LN216@CGItemDrop:

; 5299 : 			}
; 5300 : 			else if ( type == ITEMGET(14,32)  && level == 1 )

  0152e	83 f9 01	 cmp	 ecx, 1
  01531	0f 85 7a 12 00
	00		 jne	 $LN15@CGItemDrop

; 5301 : 			{
; 5302 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01537	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0153b	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01541	51		 push	 ecx
  01542	52		 push	 edx
  01543	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5303 : 				LightPurpleCandyBoxOpen(&gObj[aIndex]);

  01548	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  0154e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01554	51		 push	 ecx
  01555	e8 00 00 00 00	 call	 ?LightPurpleCandyBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; LightPurpleCandyBoxOpen

; 5304 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0155a	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  01561	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  01568	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  0156f	52		 push	 edx
  01570	50		 push	 eax
  01571	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  01578	51		 push	 ecx
  01579	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  01580	6a 01		 push	 1
  01582	68 20 1c 00 00	 push	 7200			; 00001c20H
  01587	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  0158a	52		 push	 edx
  0158b	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  01592	56		 push	 esi
  01593	50		 push	 eax
  01594	51		 push	 ecx
  01595	52		 push	 edx
  01596	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  01599	50		 push	 eax
  0159a	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  0159d	51		 push	 ecx
  0159e	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@JACADLKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5WhiteDay?5@
  015a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  015a9	83 c4 40	 add	 esp, 64			; 00000040H
  015ac	e9 5a f4 ff ff	 jmp	 $LN6@CGItemDrop
$LN217@CGItemDrop:

; 5305 : 			}
; 5306 : 			else if ( type == ITEMGET(14,33)  && level == 1  )

  015b1	83 f9 01	 cmp	 ecx, 1
  015b4	0f 85 f7 11 00
	00		 jne	 $LN15@CGItemDrop

; 5307 : 			{
; 5308 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  015ba	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  015be	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  015c4	52		 push	 edx
  015c5	50		 push	 eax
  015c6	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5309 : 				VermilionCandyBoxOpen(&gObj[aIndex]);

  015cb	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  015d1	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015d7	52		 push	 edx
  015d8	e8 00 00 00 00	 call	 ?VermilionCandyBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; VermilionCandyBoxOpen

; 5310 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  015dd	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  015e4	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  015eb	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  015f2	50		 push	 eax
  015f3	51		 push	 ecx
  015f4	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  015fb	52		 push	 edx
  015fc	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  01603	6a 01		 push	 1
  01605	68 21 1c 00 00	 push	 7201			; 00001c21H
  0160a	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  0160d	50		 push	 eax
  0160e	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  01615	56		 push	 esi
  01616	51		 push	 ecx
  01617	52		 push	 edx
  01618	50		 push	 eax
  01619	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0161c	51		 push	 ecx
  0161d	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  01620	52		 push	 edx
  01621	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@JACADLKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5WhiteDay?5@
  01626	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0162c	83 c4 40	 add	 esp, 64			; 00000040H
  0162f	e9 d7 f3 ff ff	 jmp	 $LN6@CGItemDrop
$LN218@CGItemDrop:

; 5311 : 			}
; 5312 : 			else if ( type == ITEMGET(14,34)  && level == 1 )

  01634	83 f9 01	 cmp	 ecx, 1
  01637	0f 85 74 11 00
	00		 jne	 $LN15@CGItemDrop

; 5313 : 			{
; 5314 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0163d	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01641	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01647	50		 push	 eax
  01648	51		 push	 ecx
  01649	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5315 : 				DeepBlueCandyBoxOpen(&gObj[aIndex]);

  0164e	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  01654	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0165a	50		 push	 eax
  0165b	e8 00 00 00 00	 call	 ?DeepBlueCandyBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; DeepBlueCandyBoxOpen

; 5316 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  01660	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  01667	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  0166e	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  01675	51		 push	 ecx
  01676	52		 push	 edx
  01677	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  0167e	50		 push	 eax
  0167f	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  01686	6a 01		 push	 1
  01688	68 22 1c 00 00	 push	 7202			; 00001c22H
  0168d	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  01690	51		 push	 ecx
  01691	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01698	56		 push	 esi
  01699	52		 push	 edx
  0169a	50		 push	 eax
  0169b	51		 push	 ecx
  0169c	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  0169f	52		 push	 edx
  016a0	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  016a3	50		 push	 eax
  016a4	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@JACADLKN@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5WhiteDay?5@
  016a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  016af	83 c4 40	 add	 esp, 64			; 00000040H
  016b2	e9 54 f3 ff ff	 jmp	 $LN6@CGItemDrop
$LN95@CGItemDrop:

; 5317 : 			}
; 5318 : 			else if ( type == ITEMGET(14,45) )

  016b7	3d 2d 1c 00 00	 cmp	 eax, 7213		; 00001c2dH
  016bc	75 73		 jne	 SHORT $LN93@CGItemDrop

; 5319 : 			{
; 5320 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  016be	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  016c2	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  016c8	51		 push	 ecx
  016c9	52		 push	 edx
  016ca	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5321 : 				HallowinDayEventItemBoxOpen(lpObj);

  016cf	53		 push	 ebx
  016d0	e8 00 00 00 00	 call	 ?HallowinDayEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; HallowinDayEventItemBoxOpen

; 5322 : 				LogAddTD("[%s][%s][%d]%d/%d Used Pumpkin of Luck Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  016d5	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  016dc	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  016e3	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  016ea	50		 push	 eax
  016eb	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  016f1	51		 push	 ecx
  016f2	52		 push	 edx
  016f3	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  016fa	50		 push	 eax
  016fb	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  01702	68 2d 1c 00 00	 push	 7213			; 00001c2dH
  01707	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  0170a	51		 push	 ecx
  0170b	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01712	56		 push	 esi
  01713	52		 push	 edx
  01714	50		 push	 eax
  01715	51		 push	 ecx
  01716	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  01719	52		 push	 edx
  0171a	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0171d	50		 push	 eax
  0171e	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@EEKOGNLH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Pumpkin?5o@
  01723	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01729	83 c4 40	 add	 esp, 64			; 00000040H
  0172c	e9 da f2 ff ff	 jmp	 $LN6@CGItemDrop
$LN93@CGItemDrop:

; 5323 : 			}
; 5324 : 			else if ( type == ITEMGET(14,51) ) //Season 2.5 add-on Christmas Star identical

  01731	3d 33 1c 00 00	 cmp	 eax, 7219		; 00001c33H
  01736	75 73		 jne	 SHORT $LN91@CGItemDrop

; 5325 : 			{
; 5326 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01738	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0173c	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01742	51		 push	 ecx
  01743	52		 push	 edx
  01744	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5327 : 				ChristmasStarDrop(lpObj);

  01749	53		 push	 ebx
  0174a	e8 00 00 00 00	 call	 ?ChristmasStarDrop@@YAXPAUOBJECTSTRUCT@@@Z ; ChristmasStarDrop

; 5328 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas-Star Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0174f	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  01756	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  0175d	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  01764	50		 push	 eax
  01765	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  0176b	51		 push	 ecx
  0176c	52		 push	 edx
  0176d	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  01774	50		 push	 eax
  01775	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  0177c	68 33 1c 00 00	 push	 7219			; 00001c33H
  01781	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  01784	51		 push	 ecx
  01785	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  0178c	56		 push	 esi
  0178d	52		 push	 edx
  0178e	50		 push	 eax
  0178f	51		 push	 ecx
  01790	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  01793	52		 push	 edx
  01794	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01797	50		 push	 eax
  01798	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@KNMNAMHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Christmas@
  0179d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  017a3	83 c4 40	 add	 esp, 64			; 00000040H
  017a6	e9 60 f2 ff ff	 jmp	 $LN6@CGItemDrop
$LN91@CGItemDrop:

; 5329 : 			}
; 5330 : 			else if ( type == ITEMGET(14,63) ) //Season 2.5 add-on FireCraker (from Natasha Seller) identical

  017ab	3d 3f 1c 00 00	 cmp	 eax, 7231		; 00001c3fH
  017b0	75 73		 jne	 SHORT $LN89@CGItemDrop

; 5331 : 			{
; 5332 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  017b2	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  017b6	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  017bc	51		 push	 ecx
  017bd	52		 push	 edx
  017be	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5333 : 				ChristmasStarDrop(lpObj);

  017c3	53		 push	 ebx
  017c4	e8 00 00 00 00	 call	 ?ChristmasStarDrop@@YAXPAUOBJECTSTRUCT@@@Z ; ChristmasStarDrop

; 5334 : 				LogAddTD("[%s][%s][%d]%d/%d Used FireCraker Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  017c9	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  017d0	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  017d7	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  017de	50		 push	 eax
  017df	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  017e5	51		 push	 ecx
  017e6	52		 push	 edx
  017e7	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  017ee	50		 push	 eax
  017ef	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  017f6	68 3f 1c 00 00	 push	 7231			; 00001c3fH
  017fb	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  017fe	51		 push	 ecx
  017ff	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01806	56		 push	 esi
  01807	52		 push	 edx
  01808	50		 push	 eax
  01809	51		 push	 ecx
  0180a	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  0180d	52		 push	 edx
  0180e	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01811	50		 push	 eax
  01812	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@FJFDABFJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5FireCrake@
  01817	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0181d	83 c4 40	 add	 esp, 64			; 00000040H
  01820	e9 e6 f1 ff ff	 jmp	 $LN6@CGItemDrop
$LN89@CGItemDrop:

; 5335 : 			}
; 5336 : 			else if( type == ITEMGET(14,84) ) //Season 3.0 add-on Cherry Blossom Play-Box

  01825	3d 54 1c 00 00	 cmp	 eax, 7252		; 00001c54H
  0182a	0f 85 97 00 00
	00		 jne	 $LN87@CGItemDrop

; 5337 : 			{
; 5338 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01830	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  01834	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0183a	51		 push	 ecx
  0183b	52		 push	 edx
  0183c	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5339 : 				CherryBlossomEventItemBoxOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  01841	0f b6 83 46 01
	00 00		 movzx	 eax, BYTE PTR [ebx+326]
  01848	0f b6 8b 44 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+324]
  0184f	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  01856	50		 push	 eax
  01857	51		 push	 ecx
  01858	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  0185e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01864	52		 push	 edx
  01865	51		 push	 ecx
  01866	e8 00 00 00 00	 call	 ?CherryBlossomEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; CherryBlossomEventItemBoxOpen

; 5340 : 				LogAddTD("[%s][%s][%d]%d/%d Used CherryBox Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0186b	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  01872	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  01879	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  01880	52		 push	 edx
  01881	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _level$246020[ebp]
  01887	50		 push	 eax
  01888	51		 push	 ecx
  01889	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  01890	52		 push	 edx
  01891	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  01898	68 54 1c 00 00	 push	 7252			; 00001c54H
  0189d	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  018a0	50		 push	 eax
  018a1	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  018a8	56		 push	 esi
  018a9	51		 push	 ecx
  018aa	52		 push	 edx
  018ab	50		 push	 eax
  018ac	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  018af	51		 push	 ecx
  018b0	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  018b3	52		 push	 edx
  018b4	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@LBKHCBMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5CherryBox@
  018b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  018bf	83 c4 4c	 add	 esp, 76			; 0000004cH
  018c2	e9 44 f1 ff ff	 jmp	 $LN6@CGItemDrop
$LN87@CGItemDrop:

; 5341 : 			}
; 5342 : 			else if( type == ITEMGET(14,99) ) //Season 4.0 add-on XMas FireCrack

  018c7	3d 63 1c 00 00	 cmp	 eax, 7267		; 00001c63H
  018cc	75 73		 jne	 SHORT $LN85@CGItemDrop

; 5343 : 			{
; 5344 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  018ce	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  018d2	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  018d8	50		 push	 eax
  018d9	51		 push	 ecx
  018da	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5345 : 				ChristmasFireCrackDrop(lpObj);

  018df	53		 push	 ebx
  018e0	e8 00 00 00 00	 call	 ?ChristmasFireCrackDrop@@YAXPAUOBJECTSTRUCT@@@Z ; ChristmasFireCrackDrop

; 5346 : 				LogAddTD("[%s][%s][%d]%d/%d Used FireCraker Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  018e5	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  018ec	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  018f3	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  018fa	52		 push	 edx
  018fb	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _level$246020[ebp]
  01901	50		 push	 eax
  01902	51		 push	 ecx
  01903	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  0190a	52		 push	 edx
  0190b	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  01912	68 63 1c 00 00	 push	 7267			; 00001c63H
  01917	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  0191a	50		 push	 eax
  0191b	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  01922	56		 push	 esi
  01923	51		 push	 ecx
  01924	52		 push	 edx
  01925	50		 push	 eax
  01926	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  01929	51		 push	 ecx
  0192a	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  0192d	52		 push	 edx
  0192e	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@FJFDABFJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5FireCrake@
  01933	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01939	83 c4 40	 add	 esp, 64			; 00000040H
  0193c	e9 ca f0 ff ff	 jmp	 $LN6@CGItemDrop
$LN85@CGItemDrop:

; 5347 : 			}
; 5348 : 			//Season 5 New Box
; 5349 : 			//else if( type == ITEMGET(14,141) )
; 5350 : 			//{
; 5351 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5352 : 			//	ShiningJewelryCaseItemBagOpen(lpObj,lpObj->MapNumber,lpObj->X,lpObj->Y);
; 5353 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5354 : 			//}
; 5355 : 			//else if( type == ITEMGET(14,142) )
; 5356 : 			//{
; 5357 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5358 : 			//	ElegantJewelryCaseItemBagOpen(lpObj,lpObj->MapNumber,lpObj->X,lpObj->Y);
; 5359 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5360 : 			//}
; 5361 : 			//else if( type == ITEMGET(14,143) )
; 5362 : 			//{
; 5363 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5364 : 			//	SteelJewelryCaseItemBagOpen(lpObj,lpObj->MapNumber,lpObj->X,lpObj->Y);
; 5365 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5366 : 			//}
; 5367 : 			//else if( type == ITEMGET(14,144) )
; 5368 : 			//{
; 5369 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5370 : 			//	OldJewelryCaseItemBagOpen(lpObj,lpObj->MapNumber,lpObj->X,lpObj->Y);
; 5371 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5372 : 			//}
; 5373 : 			//else if( type == ITEMGET(14,142) )
; 5374 : 			//{
; 5375 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5376 : 			//	ChristmasFireCrackDrop(lpObj);
; 5377 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5378 : 			//}
; 5379 : 			//else if( type == ITEMGET(14,143) )
; 5380 : 			//{
; 5381 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5382 : 			//	ChristmasFireCrackDrop(lpObj);
; 5383 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5384 : 			//}
; 5385 : 			//else if( type == ITEMGET(14,144) )
; 5386 : 			//{
; 5387 : 			//	gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5388 : 			//	ChristmasFireCrackDrop(lpObj);
; 5389 : 			//	LogAddTD("[%s][%s][%d]%d/%d Season 5 New Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)", lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5390 : 			//}
; 5391 : 			else if ( type == ITEMGET(12,26) )

  01941	3d 1a 18 00 00	 cmp	 eax, 6170		; 0000181aH
  01946	0f 85 52 02 00
	00		 jne	 $LN83@CGItemDrop

; 5392 : 			{
; 5393 : 				switch ( level )

  0194c	83 bd 74 fe ff
	ff 05		 cmp	 DWORD PTR _level$246020[ebp], 5
  01953	0f 87 b2 f0 ff
	ff		 ja	 $LN6@CGItemDrop
  01959	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  0195f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN229@CGItemDrop[eax*4]
$LN80@CGItemDrop:

; 5394 : 				{
; 5395 : 					case 0:
; 5396 : 						{
; 5397 : 							gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01966	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0196a	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01970	51		 push	 ecx
  01971	52		 push	 edx
  01972	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  01977	83 c4 08	 add	 esp, 8

; 5398 : 							pResult.Result = true;

  0197a	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1

; 5399 : 							int ltype = ITEMGET(12,26);
; 5400 : 							int randor = rand()%100;

  01981	e8 00 00 00 00	 call	 _rand
  01986	99		 cdq
  01987	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0198c	f7 f9		 idiv	 ecx

; 5401 : 							int Level;
; 5402 : 
; 5403 : 							if ( randor < 10 )

  0198e	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  01991	7d 0c		 jge	 SHORT $LN79@CGItemDrop

; 5404 : 							{
; 5405 : 								Level = 3;

  01993	c7 85 6c fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _Level$246128[ebp], 3
  0199d	eb 0f		 jmp	 SHORT $LN77@CGItemDrop
$LN79@CGItemDrop:

; 5406 : 							}
; 5407 : 							else if ( randor < 45 )

  0199f	33 c0		 xor	 eax, eax
  019a1	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  019a4	0f 9d c0	 setge	 al
  019a7	40		 inc	 eax
  019a8	89 85 6c fe ff
	ff		 mov	 DWORD PTR _Level$246128[ebp], eax
$LN77@CGItemDrop:

; 5408 : 							{
; 5409 : 								Level = 1;
; 5410 : 							}
; 5411 : 							else
; 5412 : 							{
; 5413 : 								Level = 2;
; 5414 : 							}
; 5415 : 
; 5416 : 							ItemSerialCreateSend(aIndex, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, ltype, (BYTE)Level, 1, 0, 0, 0, lpObj->m_Index, 0, 0);

  019ae	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  019b0	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR _Level$246128[ebp]
  019b6	0f b6 83 46 01
	00 00		 movzx	 eax, BYTE PTR [ebx+326]
  019bd	6a 00		 push	 0
  019bf	6a 00		 push	 0
  019c1	51		 push	 ecx
  019c2	0f b6 8b 44 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+324]
  019c9	6a 00		 push	 0
  019cb	6a 00		 push	 0
  019cd	6a 00		 push	 0
  019cf	6a 01		 push	 1
  019d1	52		 push	 edx
  019d2	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  019d9	68 1a 18 00 00	 push	 6170			; 0000181aH
  019de	50		 push	 eax
  019df	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  019e5	51		 push	 ecx
  019e6	52		 push	 edx
  019e7	50		 push	 eax
  019e8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 5417 : 							
; 5418 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Drop (%d) - serial:%u", lpObj->AccountID, lpObj->Name, Level, serial);

  019ed	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _Level$246128[ebp]
  019f3	56		 push	 esi
  019f4	51		 push	 ecx
  019f5	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  019f8	52		 push	 edx
  019f9	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  019fc	50		 push	 eax
  019fd	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DNBGEKCH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  01a02	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01a08	83 c4 48	 add	 esp, 72			; 00000048H

; 5419 : 						}
; 5420 : 						break;

  01a0b	e9 fb ef ff ff	 jmp	 $LN6@CGItemDrop
$LN75@CGItemDrop:

; 5421 : 					case 1: case 2: case 3:
; 5422 : 						{
; 5423 : 							gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01a10	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  01a14	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01a1a	51		 push	 ecx
  01a1b	52		 push	 edx
  01a1c	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5424 : 							pResult.Result = true;
; 5425 : 
; 5426 : 							PMSG_SERVERCMD ServerCmd;
; 5427 : 
; 5428 : 							PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  01a21	6a 07		 push	 7
  01a23	6a 40		 push	 64			; 00000040H
  01a25	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$246138[ebp]
  01a2b	68 f3 00 00 00	 push	 243			; 000000f3H
  01a30	50		 push	 eax
  01a31	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
  01a38	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 5429 : 							ServerCmd.CmdType = 0;
; 5430 : 							ServerCmd.X = lpObj->X;

  01a3d	8a 8b 44 01 00
	00		 mov	 cl, BYTE PTR [ebx+324]

; 5431 : 							ServerCmd.Y = lpObj->Y;

  01a43	8a 93 46 01 00
	00		 mov	 dl, BYTE PTR [ebx+326]

; 5432 : 
; 5433 : 							MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  01a49	6a 07		 push	 7
  01a4b	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$246138[ebp]
  01a51	50		 push	 eax
  01a52	53		 push	 ebx
  01a53	c6 85 68 fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$246138[ebp+4], 0
  01a5a	88 8d 69 fe ff
	ff		 mov	 BYTE PTR _ServerCmd$246138[ebp+5], cl
  01a60	88 95 6a fe ff
	ff		 mov	 BYTE PTR _ServerCmd$246138[ebp+6], dl
  01a66	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 5434 : 							DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  01a6b	8b 13		 mov	 edx, DWORD PTR [ebx]
  01a6d	6a 07		 push	 7
  01a6f	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _ServerCmd$246138[ebp]
  01a75	51		 push	 ecx
  01a76	52		 push	 edx
  01a77	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5435 : 													
; 5436 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - serial:%u", lpObj->AccountID, lpObj->Name, level, serial);

  01a7c	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  01a82	56		 push	 esi
  01a83	50		 push	 eax
  01a84	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  01a87	51		 push	 ecx
  01a88	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  01a8b	52		 push	 edx
  01a8c	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@KAHFPFOH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  01a91	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01a97	83 c4 44	 add	 esp, 68			; 00000044H

; 5437 : 						}
; 5438 : 						break;

  01a9a	e9 6c ef ff ff	 jmp	 $LN6@CGItemDrop
$LN74@CGItemDrop:

; 5439 : 					case 4:
; 5440 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Hidden Treasure Box - serial:%u", lpObj->AccountID, lpObj->Name,  serial);

  01a9f	56		 push	 esi
  01aa0	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  01aa3	50		 push	 eax
  01aa4	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  01aa7	51		 push	 ecx
  01aa8	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@NLJNLJHL@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  01aad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5441 : 
; 5442 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01ab3	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  01ab7	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  01abd	52		 push	 edx
  01abe	50		 push	 eax
  01abf	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5443 : 						pResult.Result = true;
; 5444 : 						HiddenTreasureBoxItemBoxOpen(&gObj[aIndex]);

  01ac4	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  01aca	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ad0	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
  01ad7	52		 push	 edx
  01ad8	e8 00 00 00 00	 call	 ?HiddenTreasureBoxItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; HiddenTreasureBoxItemBoxOpen
  01add	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5445 : 
; 5446 : 						break;

  01ae0	e9 26 ef ff ff	 jmp	 $LN6@CGItemDrop
$LN73@CGItemDrop:

; 5447 : 					case 5:
; 5448 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Box - serial:%u", lpObj->AccountID, lpObj->Name,  serial);

  01ae5	56		 push	 esi
  01ae6	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  01ae9	50		 push	 eax
  01aea	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  01aed	51		 push	 ecx
  01aee	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@OMBINMCG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  01af3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5449 : 
; 5450 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01af9	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01afd	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01b03	50		 push	 eax
  01b04	51		 push	 ecx
  01b05	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  01b0a	83 c4 18	 add	 esp, 24			; 00000018H

; 5451 : 						pResult.Result = true;

  01b0d	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1

; 5452 : 
; 5453 : 						if ( (rand()%10000) < g_iHiddenTreasureBoxOfflineRate )

  01b14	e8 00 00 00 00	 call	 _rand
  01b19	99		 cdq
  01b1a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  01b1f	f7 f9		 idiv	 ecx
  01b21	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iHiddenTreasureBoxOfflineRate@@3HA ; g_iHiddenTreasureBoxOfflineRate
  01b27	7d 10		 jge	 SHORT $LN72@CGItemDrop

; 5454 : 						{
; 5455 : 							EGReqRegHTOfflineGift(lpObj->m_Index);

  01b29	8b 13		 mov	 edx, DWORD PTR [ebx]
  01b2b	52		 push	 edx
  01b2c	e8 00 00 00 00	 call	 ?EGReqRegHTOfflineGift@@YAXH@Z ; EGReqRegHTOfflineGift
  01b31	83 c4 04	 add	 esp, 4

; 5456 : 						}
; 5457 : 						else

  01b34	e9 d2 ee ff ff	 jmp	 $LN6@CGItemDrop
$LN72@CGItemDrop:

; 5458 : 						{
; 5459 : 							int money = 1000000;
; 5460 : 							MapC[lpObj->MapNumber].MoneyItemDrop(money, lpObj->X, lpObj->Y);

  01b39	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  01b40	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  01b47	50		 push	 eax
  01b48	51		 push	 ecx
  01b49	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01b50	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  01b56	68 40 42 0f 00	 push	 1000000			; 000f4240H
  01b5b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  01b61	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 5461 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)(%d/%d)", lpObj->AccountID, lpObj->Name, money, lpObj->MapNumber, lpObj->X, lpObj->Y);

  01b66	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  01b6d	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  01b74	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01b7b	52		 push	 edx
  01b7c	50		 push	 eax
  01b7d	51		 push	 ecx
  01b7e	68 40 42 0f 00	 push	 1000000			; 000f4240H
  01b83	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  01b86	50		 push	 eax
  01b87	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  01b8a	50		 push	 eax
  01b8b	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  01b90	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01b96	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5462 : 						}
; 5463 : 						break;
; 5464 : 				}
; 5465 : 			}
; 5466 : 			else if ( type == ITEMGET(13,20) && level == 1 ) // Wizard Ring A

  01b99	e9 6d ee ff ff	 jmp	 $LN6@CGItemDrop
$LN83@CGItemDrop:
  01b9e	3d 14 1a 00 00	 cmp	 eax, 6676		; 00001a14H
  01ba3	0f 85 94 01 00
	00		 jne	 $LN65@CGItemDrop
  01ba9	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  01baf	83 f9 01	 cmp	 ecx, 1
  01bb2	0f 85 be 00 00
	00		 jne	 $LN219@CGItemDrop

; 5467 : 			{
; 5468 : 				if ( gObj[aIndex].Level >= 40 )

  01bb8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01bbe	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  01bc4	66 83 bc 10 be
	00 00 00 28	 cmp	 WORD PTR [eax+edx+190], 40 ; 00000028H
  01bcd	7c 2b		 jl	 SHORT $LN68@CGItemDrop

; 5469 : 				{
; 5470 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01bcf	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  01bd3	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01bd9	51		 push	 ecx
  01bda	52		 push	 edx
  01bdb	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5471 : 					::RingOfHeroBoxOpen(&gObj[aIndex]); //season2.5

  01be0	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  01be6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01bec	51		 push	 ecx
  01bed	e8 00 00 00 00	 call	 ?RingOfHeroBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; RingOfHeroBoxOpen
  01bf2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5483 : 				}

  01bf5	e9 11 ee ff ff	 jmp	 $LN6@CGItemDrop
$LN68@CGItemDrop:

; 5472 : 				}
; 5473 : 				else
; 5474 : 				{
; 5475 : 					PMSG_NOTICE pNotice;
; 5476 : 
; 5477 : 					TNotice::MakeNoticeMsg((TNotice *)&pNotice, 10, lMsg.Get(MSGGET(4, 187)));

  01bfa	68 bb 04 00 00	 push	 1211			; 000004bbH
  01bff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01c04	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01c09	50		 push	 eax
  01c0a	8d 95 94 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$246155[ebp]
  01c10	6a 0a		 push	 10			; 0000000aH
  01c12	52		 push	 edx
  01c13	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 5478 : 					TNotice::SetNoticeProperty((TNotice *)&pNotice, 10, _ARGB(255, 128, 149, 196), 1, 0, 20);

  01c18	6a 14		 push	 20			; 00000014H
  01c1a	6a 00		 push	 0
  01c1c	6a 01		 push	 1
  01c1e	68 80 95 c4 ff	 push	 -3893888		; ffc49580H
  01c23	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$246155[ebp]
  01c29	6a 0a		 push	 10			; 0000000aH
  01c2b	50		 push	 eax
  01c2c	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty

; 5479 : 					TNotice::SendNoticeToUser(aIndex, (TNotice *)&pNotice);

  01c31	8b b5 90 fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  01c37	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$246155[ebp]
  01c3d	51		 push	 ecx
  01c3e	56		 push	 esi
  01c3f	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser

; 5480 : 					pResult.Result = false;
; 5481 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01c44	0f b6 95 89 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  01c4b	52		 push	 edx
  01c4c	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  01c52	50		 push	 eax
  01c53	56		 push	 esi
  01c54	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  01c5b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01c60	83 c4 38	 add	 esp, 56			; 00000038H

; 5482 : 					return FALSE;

  01c63	33 c0		 xor	 eax, eax

; 5728 : }

  01c65	5f		 pop	 edi
  01c66	5e		 pop	 esi
  01c67	5b		 pop	 ebx
  01c68	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c6b	33 cd		 xor	 ecx, ebp
  01c6d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c72	8b e5		 mov	 esp, ebp
  01c74	5d		 pop	 ebp
  01c75	c3		 ret	 0
$LN219@CGItemDrop:

; 5484 : 			}
; 5485 : 			else if ( type == ITEMGET(13,20) && level == 2 ) // Wizard Ring B

  01c76	83 f9 02	 cmp	 ecx, 2
  01c79	0f 85 32 0b 00
	00		 jne	 $LN15@CGItemDrop

; 5486 : 			{
; 5487 : 				if ( gObj[aIndex].Level >= 80 )

  01c7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c85	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  01c8b	66 83 bc 0a be
	00 00 00 50	 cmp	 WORD PTR [edx+ecx+190], 80 ; 00000050H
  01c94	7c 2b		 jl	 SHORT $LN64@CGItemDrop

; 5488 : 				{
; 5489 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01c96	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01c9a	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01ca0	50		 push	 eax
  01ca1	51		 push	 ecx
  01ca2	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5490 : 					::FriendShipItemBoxOpen(&gObj[aIndex]);

  01ca7	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  01cad	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cb3	50		 push	 eax
  01cb4	e8 00 00 00 00	 call	 ?FriendShipItemBoxOpen@@YAXPAUOBJECTSTRUCT@@@Z ; FriendShipItemBoxOpen
  01cb9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5502 : 				}

  01cbc	e9 4a ed ff ff	 jmp	 $LN6@CGItemDrop
$LN64@CGItemDrop:

; 5491 : 				}
; 5492 : 				else
; 5493 : 				{
; 5494 : 					PMSG_NOTICE pNotice;
; 5495 : 
; 5496 : 					TNotice::MakeNoticeMsg((TNotice *)&pNotice, 10, lMsg.Get(MSGGET(4, 191)));

  01cc1	68 bf 04 00 00	 push	 1215			; 000004bfH
  01cc6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01ccb	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01cd0	50		 push	 eax
  01cd1	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$246164[ebp]
  01cd7	6a 0a		 push	 10			; 0000000aH
  01cd9	51		 push	 ecx
  01cda	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 5497 : 					TNotice::SetNoticeProperty((TNotice *)&pNotice, 10, _ARGB(255, 128, 149, 196), 1, 0, 20);

  01cdf	6a 14		 push	 20			; 00000014H
  01ce1	6a 00		 push	 0
  01ce3	6a 01		 push	 1
  01ce5	68 80 95 c4 ff	 push	 -3893888		; ffc49580H
  01cea	8d 95 94 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$246164[ebp]
  01cf0	6a 0a		 push	 10			; 0000000aH
  01cf2	52		 push	 edx
  01cf3	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty

; 5498 : 					TNotice::SendNoticeToUser(aIndex, (TNotice *)&pNotice);

  01cf8	8b b5 90 fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  01cfe	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$246164[ebp]
  01d04	50		 push	 eax
  01d05	56		 push	 esi
  01d06	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser

; 5499 : 					pResult.Result = false;
; 5500 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01d0b	0f b6 8d 89 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  01d12	51		 push	 ecx
  01d13	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  01d19	52		 push	 edx
  01d1a	56		 push	 esi
  01d1b	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  01d22	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01d27	83 c4 38	 add	 esp, 56			; 00000038H

; 5501 : 					return FALSE;

  01d2a	33 c0		 xor	 eax, eax

; 5728 : }

  01d2c	5f		 pop	 edi
  01d2d	5e		 pop	 esi
  01d2e	5b		 pop	 ebx
  01d2f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d32	33 cd		 xor	 ecx, ebp
  01d34	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d39	8b e5		 mov	 esp, ebp
  01d3b	5d		 pop	 ebp
  01d3c	c3		 ret	 0
$LN65@CGItemDrop:

; 5503 : 			}
; 5504 : 			else if ( type == ITEMGET(14,28) ) // Lost Map

  01d3d	3d 1c 1c 00 00	 cmp	 eax, 7196		; 00001c1cH
  01d42	0f 85 ac 00 00
	00		 jne	 $LN61@CGItemDrop

; 5505 : 			{
; 5506 : 				if ( g_KalimaGate.CreateKalimaGate(aIndex, level, lpMsg->px, lpMsg->py))

  01d48	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  01d4c	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  01d50	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _level$246020[ebp]
  01d56	50		 push	 eax
  01d57	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  01d5d	51		 push	 ecx
  01d5e	52		 push	 edx
  01d5f	50		 push	 eax
  01d60	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  01d65	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate
  01d6a	85 c0		 test	 eax, eax
  01d6c	74 4e		 je	 SHORT $LN60@CGItemDrop

; 5507 : 				{
; 5508 : 					LogAddTD("[Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map Serial:%u)", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);

  01d6e	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  01d72	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d77	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  01d7d	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  01d83	8b b4 01 24 0e
	00 00		 mov	 esi, DWORD PTR [ecx+eax+3620]
  01d8a	8b 14 32	 mov	 edx, DWORD PTR [edx+esi]
  01d8d	52		 push	 edx
  01d8e	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  01d92	52		 push	 edx
  01d93	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  01d97	50		 push	 eax
  01d98	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@JOOALNAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@
  01d9d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5509 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01da3	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  01da7	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01dad	51		 push	 ecx
  01dae	52		 push	 edx
  01daf	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  01db4	83 c4 18	 add	 esp, 24			; 00000018H

; 5516 : 				}

  01db7	e9 4f ec ff ff	 jmp	 $LN6@CGItemDrop
$LN60@CGItemDrop:

; 5510 : 				}
; 5511 : 				else
; 5512 : 				{
; 5513 : 					pResult.Result = false;
; 5514 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01dbc	0f b6 85 89 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01dc3	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01dc9	50		 push	 eax
  01dca	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  01dd0	51		 push	 ecx
  01dd1	52		 push	 edx
  01dd2	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  01dd9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01dde	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5515 : 					return FALSE;

  01de1	33 c0		 xor	 eax, eax

; 5728 : }

  01de3	5f		 pop	 edi
  01de4	5e		 pop	 esi
  01de5	5b		 pop	 ebx
  01de6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01de9	33 cd		 xor	 ecx, ebp
  01deb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01df0	8b e5		 mov	 esp, ebp
  01df2	5d		 pop	 ebp
  01df3	c3		 ret	 0
$LN61@CGItemDrop:

; 5517 : 			}
; 5518 : #ifdef INTERNATIONAL_JAPAN
; 5519 : 			else if ( type == ITEMGET(14,20) && ( ((level-1<0)?FALSE:(level-1>4)?FALSE:TRUE) != FALSE ) ) // Remedy Of Love

  01df4	3d 14 1c 00 00	 cmp	 eax, 7188		; 00001c14H
  01df9	75 51		 jne	 SHORT $LN57@CGItemDrop
  01dfb	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  01e01	49		 dec	 ecx
  01e02	0f 88 a9 09 00
	00		 js	 $LN15@CGItemDrop
  01e08	33 d2		 xor	 edx, edx
  01e0a	83 f9 04	 cmp	 ecx, 4
  01e0d	0f 9e c2	 setle	 dl
  01e10	8b ca		 mov	 ecx, edx
  01e12	85 c9		 test	 ecx, ecx
  01e14	0f 84 97 09 00
	00		 je	 $LN15@CGItemDrop

; 5520 : 			{
; 5521 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01e1a	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01e1e	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01e24	50		 push	 eax
  01e25	51		 push	 ecx
  01e26	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5522 : 				Japan1StAnivBoxOpen(&gObj[aIndex], level);

  01e2b	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _level$246020[ebp]
  01e31	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  01e37	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e3d	52		 push	 edx
  01e3e	51		 push	 ecx
  01e3f	e8 00 00 00 00	 call	 ?Japan1StAnivBoxOpen@@YAXPAUOBJECTSTRUCT@@H@Z ; Japan1StAnivBoxOpen
  01e44	83 c4 10	 add	 esp, 16			; 00000010H
  01e47	e9 bf eb ff ff	 jmp	 $LN6@CGItemDrop
$LN57@CGItemDrop:

; 5523 : 			}
; 5524 : #endif
; 5525 : 			else if ( type == ITEMGET(13,7) ) // Contract (Summon)

  01e4c	3d 07 1a 00 00	 cmp	 eax, 6663		; 00001a07H
  01e51	0f 85 88 00 00
	00		 jne	 $LN55@CGItemDrop

; 5526 : 			{
; 5527 : 				int iMonsterID = 0;
; 5528 : 
; 5529 : 				if ( level == 0 )

  01e57	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  01e5d	33 c0		 xor	 eax, eax
  01e5f	85 c9		 test	 ecx, ecx
  01e61	75 07		 jne	 SHORT $LN54@CGItemDrop

; 5530 : 				{
; 5531 : 					iMonsterID = 286;

  01e63	b8 1e 01 00 00	 mov	 eax, 286		; 0000011eH
  01e68	eb 0a		 jmp	 SHORT $LN52@CGItemDrop
$LN54@CGItemDrop:

; 5532 : 				}
; 5533 : 				else if ( level == 1 )

  01e6a	83 f9 01	 cmp	 ecx, 1
  01e6d	75 05		 jne	 SHORT $LN52@CGItemDrop

; 5534 : 				{
; 5535 : 					iMonsterID = 287;

  01e6f	b8 1f 01 00 00	 mov	 eax, 287		; 0000011fH
$LN52@CGItemDrop:

; 5536 : 				}
; 5537 : 
; 5538 : 				if ( g_CsNPC_Mercenary.CreateMercenary(aIndex, iMonsterID, lpMsg->px, lpMsg->py) )

  01e74	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  01e78	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  01e7c	52		 push	 edx
  01e7d	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01e83	51		 push	 ecx
  01e84	50		 push	 eax
  01e85	52		 push	 edx
  01e86	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  01e8b	e8 00 00 00 00	 call	 ?CreateMercenary@CMercenary@@QAEHHHEE@Z ; CMercenary::CreateMercenary

; 5539 : 				{
; 5540 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01e90	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01e96	85 c0		 test	 eax, eax
  01e98	74 13		 je	 SHORT $LN51@CGItemDrop
  01e9a	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01e9e	50		 push	 eax
  01e9f	51		 push	 ecx
  01ea0	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  01ea5	83 c4 08	 add	 esp, 8

; 5548 : 				}

  01ea8	e9 5e eb ff ff	 jmp	 $LN6@CGItemDrop
$LN51@CGItemDrop:

; 5541 : 				}
; 5542 : 				else
; 5543 : 				{
; 5544 : 					pResult.Result = false;
; 5545 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01ead	0f b6 95 89 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  01eb4	52		 push	 edx
  01eb5	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  01ebb	50		 push	 eax
  01ebc	51		 push	 ecx
  01ebd	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  01ec4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01ec9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5546 : 
; 5547 : 					return FALSE;

  01ecc	33 c0		 xor	 eax, eax

; 5728 : }

  01ece	5f		 pop	 edi
  01ecf	5e		 pop	 esi
  01ed0	5b		 pop	 ebx
  01ed1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ed4	33 cd		 xor	 ecx, ebp
  01ed6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01edb	8b e5		 mov	 esp, ebp
  01edd	5d		 pop	 ebp
  01ede	c3		 ret	 0
$LN55@CGItemDrop:

; 5549 : 			}
; 5550 : 			else if ( type == ITEMGET(13,11) ) // Guardian / LifeStone

  01edf	3d 0b 1a 00 00	 cmp	 eax, 6667		; 00001a0bH
  01ee4	75 59		 jne	 SHORT $LN48@CGItemDrop

; 5551 : 			{
; 5552 : 				BOOL bResult = FALSE;
; 5553 : 
; 5554 : 				if ( level == 0 )

  01ee6	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  01eec	85 c0		 test	 eax, eax
  01eee	75 13		 jne	 SHORT $LN47@CGItemDrop

; 5555 : 					bResult = g_CsNPC_Guardian.CreateGuardian(aIndex);

  01ef0	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01ef6	52		 push	 edx
  01ef7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Guardian@@3VCGuardian@@A ; g_CsNPC_Guardian
  01efc	e8 00 00 00 00	 call	 ?CreateGuardian@CGuardian@@QAEHH@Z ; CGuardian::CreateGuardian
  01f01	eb 1a		 jmp	 SHORT $LN45@CGItemDrop
$LN47@CGItemDrop:

; 5556 : //#if(GS_CASTLE==1)
; 5557 : 				else if ( level == 1 )

  01f03	83 f8 01	 cmp	 eax, 1
  01f06	0f 85 b0 fe ff
	ff		 jne	 $LN60@CGItemDrop

; 5558 : 					bResult = g_CsNPC_LifeStone.CreateLifeStone(aIndex);

  01f0c	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  01f12	50		 push	 eax
  01f13	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_LifeStone@@3VCLifeStone@@A ; g_CsNPC_LifeStone
  01f18	e8 00 00 00 00	 call	 ?CreateLifeStone@CLifeStone@@QAEHH@Z ; CLifeStone::CreateLifeStone
$LN45@CGItemDrop:

; 5559 : //#endif
; 5560 : 
; 5561 : 				if ( bResult == TRUE )

  01f1d	83 f8 01	 cmp	 eax, 1
  01f20	0f 85 96 fe ff
	ff		 jne	 $LN60@CGItemDrop

; 5562 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01f26	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  01f2a	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  01f30	51		 push	 ecx
  01f31	52		 push	 edx
  01f32	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  01f37	83 c4 08	 add	 esp, 8

; 5563 : 				else
; 5564 : 				{
; 5565 : 					pResult.Result = false;
; 5566 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5567 : 					return FALSE;
; 5568 : 				}

  01f3a	e9 cc ea ff ff	 jmp	 $LN6@CGItemDrop
$LN48@CGItemDrop:

; 5569 : 			}
; 5570 : 			else if ( type == ITEMGET(14,52) ) //Season 2.5 add-on GM Box identical

  01f3f	3d 34 1c 00 00	 cmp	 eax, 7220		; 00001c34H
  01f44	75 73		 jne	 SHORT $LN41@CGItemDrop

; 5571 : 			{
; 5572 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01f46	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01f4a	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01f50	50		 push	 eax
  01f51	51		 push	 ecx
  01f52	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5573 : 				GMPresentBoxItemBagOpen(lpObj); //season 3.0 changed arguments

  01f57	53		 push	 ebx
  01f58	e8 00 00 00 00	 call	 ?GMPresentBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@@Z ; GMPresentBoxItemBagOpen

; 5574 : 				LogAddTD("[%s][%s][%d]%d/%d Used GM Present Box Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  01f5d	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  01f64	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  01f6b	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  01f72	52		 push	 edx
  01f73	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _level$246020[ebp]
  01f79	50		 push	 eax
  01f7a	51		 push	 ecx
  01f7b	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  01f82	52		 push	 edx
  01f83	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  01f8a	68 34 1c 00 00	 push	 7220			; 00001c34H
  01f8f	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  01f92	50		 push	 eax
  01f93	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  01f9a	56		 push	 esi
  01f9b	51		 push	 ecx
  01f9c	52		 push	 edx
  01f9d	50		 push	 eax
  01f9e	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  01fa1	51		 push	 ecx
  01fa2	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  01fa5	52		 push	 edx
  01fa6	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@JFAFAJLO@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5GM?5Presen@
  01fab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01fb1	83 c4 40	 add	 esp, 64			; 00000040H
  01fb4	e9 52 ea ff ff	 jmp	 $LN6@CGItemDrop
$LN41@CGItemDrop:

; 5575 : 			}
; 5576 : 			else if ( type == ITEMGET(14,55) && level == 0 ) //Season 4.5 add-on PCBang Green Chaos Box identical

  01fb9	3d 37 1c 00 00	 cmp	 eax, 7223		; 00001c37H
  01fbe	0f 85 9f 00 00
	00		 jne	 $LN39@CGItemDrop
  01fc4	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  01fcb	0f 85 e0 07 00
	00		 jne	 $LN15@CGItemDrop

; 5577 : 			{
; 5578 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  01fd1	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  01fd5	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  01fdb	50		 push	 eax
  01fdc	51		 push	 ecx
  01fdd	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5579 : 				PCBangGreenChaosBoxItemBagOpen(&gObj[aIndex],lpObj->MapNumber,lpObj->X,lpObj->Y);

  01fe2	0f b6 93 46 01
	00 00		 movzx	 edx, BYTE PTR [ebx+326]
  01fe9	0f b6 83 44 01
	00 00		 movzx	 eax, BYTE PTR [ebx+324]
  01ff0	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  01ff7	52		 push	 edx
  01ff8	50		 push	 eax
  01ff9	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  01fff	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02005	51		 push	 ecx
  02006	50		 push	 eax
  02007	e8 00 00 00 00	 call	 ?PCBangGreenChaosBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; PCBangGreenChaosBoxItemBagOpen

; 5580 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Green Chaos Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0200c	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  02013	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  0201a	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  02021	51		 push	 ecx
  02022	52		 push	 edx
  02023	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  0202a	50		 push	 eax
  0202b	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  02032	6a 00		 push	 0
  02034	68 37 1c 00 00	 push	 7223			; 00001c37H
  02039	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  0203c	51		 push	 ecx
  0203d	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  02044	56		 push	 esi
  02045	52		 push	 edx
  02046	50		 push	 eax
  02047	51		 push	 ecx
  02048	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  0204b	52		 push	 edx
  0204c	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0204f	50		 push	 eax
  02050	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@FACENDHB@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@
  02055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0205b	83 c4 4c	 add	 esp, 76			; 0000004cH
  0205e	e9 a8 e9 ff ff	 jmp	 $LN6@CGItemDrop
$LN39@CGItemDrop:

; 5581 : 			}
; 5582 : 			else if ( type == ITEMGET(14,56) && level == 0 ) //Season 4.5 add-on PCBang Red Chaos Box identical

  02063	3d 38 1c 00 00	 cmp	 eax, 7224		; 00001c38H
  02068	0f 85 9f 00 00
	00		 jne	 $LN37@CGItemDrop
  0206e	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  02075	0f 85 36 07 00
	00		 jne	 $LN15@CGItemDrop

; 5583 : 			{
; 5584 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0207b	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0207f	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  02085	51		 push	 ecx
  02086	52		 push	 edx
  02087	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5585 : 				PCBangRedChaosBoxItemBagOpen(&gObj[aIndex],lpObj->MapNumber,lpObj->X,lpObj->Y);

  0208c	0f b6 83 46 01
	00 00		 movzx	 eax, BYTE PTR [ebx+326]
  02093	0f b6 8b 44 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+324]
  0209a	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  020a1	50		 push	 eax
  020a2	51		 push	 ecx
  020a3	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  020a9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020af	52		 push	 edx
  020b0	51		 push	 ecx
  020b1	e8 00 00 00 00	 call	 ?PCBangRedChaosBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; PCBangRedChaosBoxItemBagOpen

; 5586 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Red Chaos Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  020b6	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  020bd	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  020c4	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  020cb	52		 push	 edx
  020cc	50		 push	 eax
  020cd	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  020d4	51		 push	 ecx
  020d5	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  020dc	6a 00		 push	 0
  020de	68 38 1c 00 00	 push	 7224			; 00001c38H
  020e3	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  020e6	52		 push	 edx
  020e7	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  020ee	56		 push	 esi
  020ef	50		 push	 eax
  020f0	51		 push	 ecx
  020f1	52		 push	 edx
  020f2	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  020f5	50		 push	 eax
  020f6	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  020f9	51		 push	 ecx
  020fa	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@IOJDMAHH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@
  020ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02105	83 c4 4c	 add	 esp, 76			; 0000004cH
  02108	e9 fe e8 ff ff	 jmp	 $LN6@CGItemDrop
$LN37@CGItemDrop:

; 5587 : 			}
; 5588 : 			else if ( type == ITEMGET(14,57) && level == 0 ) //Season 4.5 add-on PCBang Purple Chaos Box identical

  0210d	3d 39 1c 00 00	 cmp	 eax, 7225		; 00001c39H
  02112	0f 85 9f 00 00
	00		 jne	 $LN35@CGItemDrop
  02118	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  0211f	0f 85 8c 06 00
	00		 jne	 $LN15@CGItemDrop

; 5589 : 			{
; 5590 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02125	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  02129	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0212f	52		 push	 edx
  02130	50		 push	 eax
  02131	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5591 : 				PCBangPurpleChaosBoxItemBagOpen(&gObj[aIndex],lpObj->MapNumber,lpObj->X,lpObj->Y);

  02136	0f b6 8b 46 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+326]
  0213d	0f b6 93 44 01
	00 00		 movzx	 edx, BYTE PTR [ebx+324]
  02144	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  0214b	51		 push	 ecx
  0214c	52		 push	 edx
  0214d	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  02153	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02159	50		 push	 eax
  0215a	52		 push	 edx
  0215b	e8 00 00 00 00	 call	 ?PCBangPurpleChaosBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; PCBangPurpleChaosBoxItemBagOpen

; 5592 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Purple Chaos Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  02160	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  02167	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  0216e	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  02175	50		 push	 eax
  02176	51		 push	 ecx
  02177	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  0217e	52		 push	 edx
  0217f	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  02186	6a 00		 push	 0
  02188	68 39 1c 00 00	 push	 7225			; 00001c39H
  0218d	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  02190	50		 push	 eax
  02191	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02198	56		 push	 esi
  02199	51		 push	 ecx
  0219a	52		 push	 edx
  0219b	50		 push	 eax
  0219c	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0219f	51		 push	 ecx
  021a0	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  021a3	52		 push	 edx
  021a4	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@KFKJFPHK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@
  021a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  021af	83 c4 4c	 add	 esp, 76			; 0000004cH
  021b2	e9 54 e8 ff ff	 jmp	 $LN6@CGItemDrop
$LN35@CGItemDrop:

; 5593 : 			}
; 5594 : 			else if( type == ITEMGET(14, 123) && level == 0 )

  021b7	3d 7b 1c 00 00	 cmp	 eax, 7291		; 00001c7bH
  021bc	0f 85 9f 00 00
	00		 jne	 $LN33@CGItemDrop
  021c2	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  021c9	0f 85 e2 05 00
	00		 jne	 $LN15@CGItemDrop

; 5595 : 			{
; 5596 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  021cf	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  021d3	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  021d9	50		 push	 eax
  021da	51		 push	 ecx
  021db	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5597 : 				GoldenBoxItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  021e0	0f b6 93 46 01
	00 00		 movzx	 edx, BYTE PTR [ebx+326]
  021e7	0f b6 83 44 01
	00 00		 movzx	 eax, BYTE PTR [ebx+324]
  021ee	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  021f5	52		 push	 edx
  021f6	50		 push	 eax
  021f7	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  021fd	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02203	51		 push	 ecx
  02204	50		 push	 eax
  02205	e8 00 00 00 00	 call	 ?GoldenBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; GoldenBoxItemBagOpen

; 5598 : 				LogAddTD("[%s][%s][%d]%d/%d Used Golden Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5599 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0220a	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  02211	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  02218	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  0221f	51		 push	 ecx
  02220	52		 push	 edx
  02221	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  02228	50		 push	 eax
  02229	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  02230	6a 00		 push	 0
  02232	68 7b 1c 00 00	 push	 7291			; 00001c7bH
  02237	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  0223a	51		 push	 ecx
  0223b	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  02242	56		 push	 esi
  02243	52		 push	 edx
  02244	50		 push	 eax
  02245	51		 push	 ecx
  02246	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  02249	52		 push	 edx
  0224a	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0224d	50		 push	 eax
  0224e	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@BJKBOFGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Golden?5Bo@
  02253	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02259	83 c4 4c	 add	 esp, 76			; 0000004cH
  0225c	e9 aa e7 ff ff	 jmp	 $LN6@CGItemDrop
$LN33@CGItemDrop:

; 5600 : 			}
; 5601 : 			else if( type == ITEMGET(14, 124) && level == 0 )

  02261	3d 7c 1c 00 00	 cmp	 eax, 7292		; 00001c7cH
  02266	0f 85 9f 00 00
	00		 jne	 $LN31@CGItemDrop
  0226c	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  02273	0f 85 38 05 00
	00		 jne	 $LN15@CGItemDrop

; 5602 : 			{
; 5603 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02279	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0227d	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  02283	51		 push	 ecx
  02284	52		 push	 edx
  02285	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5604 : 				SilverBoxItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  0228a	0f b6 83 46 01
	00 00		 movzx	 eax, BYTE PTR [ebx+326]
  02291	0f b6 8b 44 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+324]
  02298	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  0229f	50		 push	 eax
  022a0	51		 push	 ecx
  022a1	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  022a7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  022ad	52		 push	 edx
  022ae	51		 push	 ecx
  022af	e8 00 00 00 00	 call	 ?SilverBoxItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; SilverBoxItemBagOpen

; 5605 : 				LogAddTD("[%s][%s][%d]%d/%d Used Silver Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5606 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  022b4	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  022bb	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  022c2	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  022c9	52		 push	 edx
  022ca	50		 push	 eax
  022cb	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  022d2	51		 push	 ecx
  022d3	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  022da	6a 00		 push	 0
  022dc	68 7c 1c 00 00	 push	 7292			; 00001c7cH
  022e1	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  022e4	52		 push	 edx
  022e5	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  022ec	56		 push	 esi
  022ed	50		 push	 eax
  022ee	51		 push	 ecx
  022ef	52		 push	 edx
  022f0	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  022f3	50		 push	 eax
  022f4	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  022f7	51		 push	 ecx
  022f8	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@HLIOIHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Silver?5Bo@
  022fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02303	83 c4 4c	 add	 esp, 76			; 0000004cH
  02306	e9 00 e7 ff ff	 jmp	 $LN6@CGItemDrop
$LN31@CGItemDrop:

; 5607 : 			}
; 5608 : 			else if( type == ITEMGET(14, 141) && level == 0 )

  0230b	3d 8d 1c 00 00	 cmp	 eax, 7309		; 00001c8dH
  02310	0f 85 9f 00 00
	00		 jne	 $LN29@CGItemDrop
  02316	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  0231d	0f 85 8e 04 00
	00		 jne	 $LN15@CGItemDrop

; 5609 : 			{
; 5610 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02323	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  02327	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0232d	52		 push	 edx
  0232e	50		 push	 eax
  0232f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5611 : 				ShineJewelleryCaseItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  02334	0f b6 8b 46 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+326]
  0233b	0f b6 93 44 01
	00 00		 movzx	 edx, BYTE PTR [ebx+324]
  02342	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02349	51		 push	 ecx
  0234a	52		 push	 edx
  0234b	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  02351	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02357	50		 push	 eax
  02358	52		 push	 edx
  02359	e8 00 00 00 00	 call	 ?ShineJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; ShineJewelleryCaseItemBagOpen

; 5612 : 				LogAddTD("[%s][%s][%d]%d/%d Used ShineJewelleryCase Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0235e	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  02365	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  0236c	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  02373	50		 push	 eax
  02374	51		 push	 ecx
  02375	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  0237c	52		 push	 edx
  0237d	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  02384	6a 00		 push	 0
  02386	68 8d 1c 00 00	 push	 7309			; 00001c8dH
  0238b	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  0238e	50		 push	 eax
  0238f	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02396	56		 push	 esi
  02397	51		 push	 ecx
  02398	52		 push	 edx
  02399	50		 push	 eax
  0239a	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0239d	51		 push	 ecx
  0239e	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  023a1	52		 push	 edx
  023a2	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@BODDPAFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5ShineJewe@
  023a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  023ad	83 c4 4c	 add	 esp, 76			; 0000004cH
  023b0	e9 56 e6 ff ff	 jmp	 $LN6@CGItemDrop
$LN29@CGItemDrop:

; 5613 : 			}
; 5614 : 			else if( type == ITEMGET(14, 142) && level == 0 )

  023b5	3d 8e 1c 00 00	 cmp	 eax, 7310		; 00001c8eH
  023ba	0f 85 9f 00 00
	00		 jne	 $LN27@CGItemDrop
  023c0	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  023c7	0f 85 e4 03 00
	00		 jne	 $LN15@CGItemDrop

; 5615 : 			{
; 5616 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  023cd	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  023d1	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  023d7	50		 push	 eax
  023d8	51		 push	 ecx
  023d9	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5617 : 				RefinedJewelleryCaseItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  023de	0f b6 93 46 01
	00 00		 movzx	 edx, BYTE PTR [ebx+326]
  023e5	0f b6 83 44 01
	00 00		 movzx	 eax, BYTE PTR [ebx+324]
  023ec	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  023f3	52		 push	 edx
  023f4	50		 push	 eax
  023f5	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  023fb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02401	51		 push	 ecx
  02402	50		 push	 eax
  02403	e8 00 00 00 00	 call	 ?RefinedJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; RefinedJewelleryCaseItemBagOpen

; 5618 : 				LogAddTD("[%s][%s][%d]%d/%d Used RefinedJewelleryCase Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  02408	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  0240f	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  02416	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  0241d	51		 push	 ecx
  0241e	52		 push	 edx
  0241f	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  02426	50		 push	 eax
  02427	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  0242e	6a 00		 push	 0
  02430	68 8e 1c 00 00	 push	 7310			; 00001c8eH
  02435	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  02438	51		 push	 ecx
  02439	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  02440	56		 push	 esi
  02441	52		 push	 edx
  02442	50		 push	 eax
  02443	51		 push	 ecx
  02444	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  02447	52		 push	 edx
  02448	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0244b	50		 push	 eax
  0244c	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@BOMFHKPI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5RefinedJe@
  02451	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02457	83 c4 4c	 add	 esp, 76			; 0000004cH
  0245a	e9 ac e5 ff ff	 jmp	 $LN6@CGItemDrop
$LN27@CGItemDrop:

; 5619 : 			}
; 5620 : 			else if( type == ITEMGET(14, 143) && level == 0 )

  0245f	3d 8f 1c 00 00	 cmp	 eax, 7311		; 00001c8fH
  02464	0f 85 9f 00 00
	00		 jne	 $LN25@CGItemDrop
  0246a	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  02471	0f 85 3a 03 00
	00		 jne	 $LN15@CGItemDrop

; 5621 : 			{
; 5622 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02477	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  0247b	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  02481	51		 push	 ecx
  02482	52		 push	 edx
  02483	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5623 : 				IronJewelleryCaseItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  02488	0f b6 83 46 01
	00 00		 movzx	 eax, BYTE PTR [ebx+326]
  0248f	0f b6 8b 44 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+324]
  02496	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  0249d	50		 push	 eax
  0249e	51		 push	 ecx
  0249f	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  024a5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  024ab	52		 push	 edx
  024ac	51		 push	 ecx
  024ad	e8 00 00 00 00	 call	 ?IronJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; IronJewelleryCaseItemBagOpen

; 5624 : 				LogAddTD("[%s][%s][%d]%d/%d Used IronJewelleryCase Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  024b2	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  024b9	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  024c0	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  024c7	52		 push	 edx
  024c8	50		 push	 eax
  024c9	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  024d0	51		 push	 ecx
  024d1	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  024d8	6a 00		 push	 0
  024da	68 8f 1c 00 00	 push	 7311			; 00001c8fH
  024df	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  024e2	52		 push	 edx
  024e3	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  024ea	56		 push	 esi
  024eb	50		 push	 eax
  024ec	51		 push	 ecx
  024ed	52		 push	 edx
  024ee	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  024f1	50		 push	 eax
  024f2	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  024f5	51		 push	 ecx
  024f6	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@NDJPCCCA@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5IronJewel@
  024fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02501	83 c4 4c	 add	 esp, 76			; 0000004cH
  02504	e9 02 e5 ff ff	 jmp	 $LN6@CGItemDrop
$LN25@CGItemDrop:

; 5625 : 			}
; 5626 : 			else if( type == ITEMGET(14, 144) && level == 0 )

  02509	3d 90 1c 00 00	 cmp	 eax, 7312		; 00001c90H
  0250e	0f 85 9f 00 00
	00		 jne	 $LN23@CGItemDrop
  02514	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  0251b	0f 85 90 02 00
	00		 jne	 $LN15@CGItemDrop

; 5627 : 			{
; 5628 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02521	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  02525	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0252b	52		 push	 edx
  0252c	50		 push	 eax
  0252d	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5629 : 				OldJewelleryCaseItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  02532	0f b6 8b 46 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+326]
  02539	0f b6 93 44 01
	00 00		 movzx	 edx, BYTE PTR [ebx+324]
  02540	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02547	51		 push	 ecx
  02548	52		 push	 edx
  02549	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  0254f	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02555	50		 push	 eax
  02556	52		 push	 edx
  02557	e8 00 00 00 00	 call	 ?OldJewelleryCaseItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; OldJewelleryCaseItemBagOpen

; 5630 : 				LogAddTD("[%s][%s][%d]%d/%d Used Golden Box Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0255c	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  02563	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  0256a	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  02571	50		 push	 eax
  02572	51		 push	 ecx
  02573	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  0257a	52		 push	 edx
  0257b	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  02582	6a 00		 push	 0
  02584	68 90 1c 00 00	 push	 7312			; 00001c90H
  02589	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  0258c	50		 push	 eax
  0258d	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02594	56		 push	 esi
  02595	51		 push	 ecx
  02596	52		 push	 edx
  02597	50		 push	 eax
  02598	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0259b	51		 push	 ecx
  0259c	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  0259f	52		 push	 edx
  025a0	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@BJKBOFGK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Golden?5Bo@
  025a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  025ab	83 c4 4c	 add	 esp, 76			; 0000004cH
  025ae	e9 58 e4 ff ff	 jmp	 $LN6@CGItemDrop
$LN23@CGItemDrop:

; 5631 : 			}
; 5632 : 			else if( type == ITEMGET(14, 157) && level == 0 )

  025b3	3d 9d 1c 00 00	 cmp	 eax, 7325		; 00001c9dH
  025b8	0f 85 9f 00 00
	00		 jne	 $LN19@CGItemDrop
  025be	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  025c5	0f 85 e6 01 00
	00		 jne	 $LN15@CGItemDrop

; 5633 : 			{
; 5634 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  025cb	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  025cf	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  025d5	50		 push	 eax
  025d6	51		 push	 ecx
  025d7	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5635 : 				BoxOfGreenColorItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  025dc	0f b6 93 46 01
	00 00		 movzx	 edx, BYTE PTR [ebx+326]
  025e3	0f b6 83 44 01
	00 00		 movzx	 eax, BYTE PTR [ebx+324]
  025ea	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  025f1	52		 push	 edx
  025f2	50		 push	 eax
  025f3	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv3552[ebp]
  025f9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025ff	51		 push	 ecx
  02600	50		 push	 eax
  02601	e8 00 00 00 00	 call	 ?BoxOfGreenColorItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; BoxOfGreenColorItemBagOpen

; 5636 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of GreenColor Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  02606	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  0260d	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  02614	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  0261b	51		 push	 ecx
  0261c	52		 push	 edx
  0261d	0f bf 93 46 01
	00 00		 movsx	 edx, WORD PTR [ebx+326]
  02624	50		 push	 eax
  02625	0f bf 83 44 01
	00 00		 movsx	 eax, WORD PTR [ebx+324]
  0262c	6a 00		 push	 0
  0262e	68 9d 1c 00 00	 push	 7325			; 00001c9dH
  02633	8d 4d c0	 lea	 ecx, DWORD PTR _szItemName$246035[ebp]
  02636	51		 push	 ecx
  02637	0f b6 8b 49 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+329]
  0263e	56		 push	 esi
  0263f	52		 push	 edx
  02640	50		 push	 eax
  02641	51		 push	 ecx
  02642	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  02645	52		 push	 edx
  02646	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  02649	50		 push	 eax
  0264a	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@ICGPKMLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Gr@
  0264f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02655	83 c4 4c	 add	 esp, 76			; 0000004cH
  02658	e9 ae e3 ff ff	 jmp	 $LN6@CGItemDrop
$LN19@CGItemDrop:

; 5637 : 			}
; 5638 : 			else if( type == ITEMGET(14, 157) && level == 0 )
; 5639 : 			{
; 5640 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5641 : 				BoxOfGreenColorItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);
; 5642 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of GreenColor Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);
; 5643 : 			}
; 5644 : 			else if( type == ITEMGET(14, 158) && level == 0 )

  0265d	3d 9e 1c 00 00	 cmp	 eax, 7326		; 00001c9eH
  02662	0f 85 9f 00 00
	00		 jne	 $LN17@CGItemDrop
  02668	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  0266f	0f 85 3c 01 00
	00		 jne	 $LN15@CGItemDrop

; 5645 : 			{
; 5646 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02675	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  02679	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0267f	51		 push	 ecx
  02680	52		 push	 edx
  02681	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5647 : 				BoxOfRedColorItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  02686	0f b6 83 46 01
	00 00		 movzx	 eax, BYTE PTR [ebx+326]
  0268d	0f b6 8b 44 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+324]
  02694	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  0269b	50		 push	 eax
  0269c	51		 push	 ecx
  0269d	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv3552[ebp]
  026a3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026a9	52		 push	 edx
  026aa	51		 push	 ecx
  026ab	e8 00 00 00 00	 call	 ?BoxOfRedColorItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; BoxOfRedColorItemBagOpen

; 5648 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of RedColor Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  026b0	0f b6 95 7c fe
	ff ff		 movzx	 edx, BYTE PTR _Option3$246025[ebp]
  026b7	0f b6 85 80 fe
	ff ff		 movzx	 eax, BYTE PTR _Option2$246024[ebp]
  026be	0f b6 8d 78 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option1$246023[ebp]
  026c5	52		 push	 edx
  026c6	50		 push	 eax
  026c7	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  026ce	51		 push	 ecx
  026cf	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  026d6	6a 00		 push	 0
  026d8	68 9e 1c 00 00	 push	 7326			; 00001c9eH
  026dd	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  026e0	52		 push	 edx
  026e1	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  026e8	56		 push	 esi
  026e9	50		 push	 eax
  026ea	51		 push	 ecx
  026eb	52		 push	 edx
  026ec	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  026ef	50		 push	 eax
  026f0	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  026f3	51		 push	 ecx
  026f4	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@IOOCGPFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Re@
  026f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  026ff	83 c4 4c	 add	 esp, 76			; 0000004cH
  02702	e9 04 e3 ff ff	 jmp	 $LN6@CGItemDrop
$LN17@CGItemDrop:

; 5649 : 			}
; 5650 : 			else if( type == ITEMGET(14, 159) && level == 0 )

  02707	3d 9f 1c 00 00	 cmp	 eax, 7327		; 00001c9fH
  0270c	0f 85 9f 00 00
	00		 jne	 $LN15@CGItemDrop
  02712	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _level$246020[ebp], 0
  02719	0f 85 92 00 00
	00		 jne	 $LN15@CGItemDrop

; 5651 : 			{
; 5652 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0271f	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  02723	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  02729	52		 push	 edx
  0272a	50		 push	 eax
  0272b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5653 : 				BoxOfPurpleColorItemBagOpen(&gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y);

  02730	0f b6 8b 46 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+326]
  02737	0f b6 93 44 01
	00 00		 movzx	 edx, BYTE PTR [ebx+324]
  0273e	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02745	51		 push	 ecx
  02746	52		 push	 edx
  02747	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv3552[ebp]
  0274d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02753	50		 push	 eax
  02754	52		 push	 edx
  02755	e8 00 00 00 00	 call	 ?BoxOfPurpleColorItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; BoxOfPurpleColorItemBagOpen

; 5654 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of PurpleColor Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3);

  0275a	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  02761	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  02768	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  0276f	50		 push	 eax
  02770	51		 push	 ecx
  02771	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  02778	52		 push	 edx
  02779	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  02780	6a 00		 push	 0
  02782	68 9f 1c 00 00	 push	 7327			; 00001c9fH
  02787	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  0278a	50		 push	 eax
  0278b	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  02792	56		 push	 esi
  02793	51		 push	 ecx
  02794	52		 push	 edx
  02795	50		 push	 eax
  02796	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  02799	51		 push	 ecx
  0279a	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  0279d	52		 push	 edx
  0279e	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@CHPAOI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Box?5Of?5Pu@
  027a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  027a9	83 c4 4c	 add	 esp, 76			; 0000004cH

; 5655 : 			}
; 5656 : 			else

  027ac	e9 5a e2 ff ff	 jmp	 $LN6@CGItemDrop
$LN15@CGItemDrop:

; 5657 : 			{
; 5658 : 				int OwnerIndex = aIndex;

  027b1	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]

; 5659 : 
; 5660 : 				if ( (type >= ITEMGET(14,0) && type <= ITEMGET(14,10)) || (type == ITEMGET(4,7) ) || type ==ITEMGET(4,15) )

  027b7	3d 00 1c 00 00	 cmp	 eax, 7168		; 00001c00H
  027bc	7c 07		 jl	 SHORT $LN11@CGItemDrop
  027be	3d 0a 1c 00 00	 cmp	 eax, 7178		; 00001c0aH
  027c3	7e 0e		 jle	 SHORT $LN12@CGItemDrop
$LN11@CGItemDrop:
  027c5	3d 07 08 00 00	 cmp	 eax, 2055		; 00000807H
  027ca	74 07		 je	 SHORT $LN12@CGItemDrop
  027cc	3d 0f 08 00 00	 cmp	 eax, 2063		; 0000080fH
  027d1	75 03		 jne	 SHORT $LN13@CGItemDrop
$LN12@CGItemDrop:

; 5661 : 				{
; 5662 : 					OwnerIndex = -1;

  027d3	83 c9 ff	 or	 ecx, -1
$LN13@CGItemDrop:

; 5663 : 				}
; 5664 : 
; 5665 : 				if ( MapC[map].ItemDrop( type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3,	NOption, SOption, serial2, OwnerIndex, PetLevel, PetExp, btItemEffectEx, SocketOption, SocketIndex) == TRUE )

  027d6	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _SocketIndex$246033[ebp]
  027dc	d9 85 5c fe ff
	ff		 fld	 DWORD PTR _dur$246021[ebp]
  027e2	50		 push	 eax
  027e3	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _btItemEffectEx$246031[ebp]
  027e9	8d 55 b8	 lea	 edx, DWORD PTR _SocketOption$246032[ebp]
  027ec	52		 push	 edx
  027ed	8b 95 40 fe ff
	ff		 mov	 edx, DWORD PTR _PetExp$246029[ebp]
  027f3	50		 push	 eax
  027f4	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _PetLevel$246028[ebp]
  027fa	52		 push	 edx
  027fb	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR _SOption$246030[ebp]
  02801	50		 push	 eax
  02802	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR _NOption$246026[ebp]
  02808	51		 push	 ecx
  02809	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR _serial2$246034[ebp]
  0280f	51		 push	 ecx
  02810	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _Option3$246025[ebp]
  02816	52		 push	 edx
  02817	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR _Option2$246024[ebp]
  0281d	50		 push	 eax
  0281e	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _Option1$246023[ebp]
  02824	51		 push	 ecx
  02825	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  02829	52		 push	 edx
  0282a	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  0282e	50		 push	 eax
  0282f	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  02835	51		 push	 ecx
  02836	52		 push	 edx
  02837	51		 push	 ecx
  02838	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _type$246019[ebp]
  0283e	d9 1c 24	 fstp	 DWORD PTR [esp]
  02841	50		 push	 eax
  02842	51		 push	 ecx
  02843	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _map$246018[ebp]
  02849	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0284f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  02855	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEQAEE@Z ; MapClass::ItemDrop
  0285a	83 f8 01	 cmp	 eax, 1
  0285d	0f 85 a1 e1 ff
	ff		 jne	 $LN227@CGItemDrop

; 5666 : 				{
; 5667 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  02863	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  02867	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0286d	52		 push	 edx
  0286e	50		 push	 eax
  0286f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  02874	83 c4 08	 add	 esp, 8

; 5668 : 					pResult.Result = true;
; 5669 : 
; 5670 : 					if ( drop_type == FALSE )

  02877	83 7d 10 00	 cmp	 DWORD PTR _drop_type$[ebp], 0

; 5671 : 					{
; 5672 : 						LogAddTD(lMsg.Get(MSGGET(1, 223)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], SOption, btItemEffectEx>>7, JOHOption, JOHOptionLevel);

  0287b	d9 85 5c fe ff
	ff		 fld	 DWORD PTR _dur$246021[ebp]
  02881	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
  02888	0f 85 b5 00 00
	00		 jne	 $LN9@CGItemDrop
  0288e	0f b6 8d 73 fe
	ff ff		 movzx	 ecx, BYTE PTR _JOHOptionLevel$246038[ebp]
  02895	0f b6 95 72 fe
	ff ff		 movzx	 edx, BYTE PTR _JOHOption$246037[ebp]
  0289c	0f b6 85 54 fe
	ff ff		 movzx	 eax, BYTE PTR _btItemEffectEx$246031[ebp]
  028a3	51		 push	 ecx
  028a4	0f b6 8d 50 fe
	ff ff		 movzx	 ecx, BYTE PTR _SOption$246030[ebp]
  028ab	52		 push	 edx
  028ac	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$[ebp+6]
  028b0	c1 e8 07	 shr	 eax, 7
  028b3	50		 push	 eax
  028b4	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  028b8	51		 push	 ecx
  028b9	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$[ebp+4]
  028bd	52		 push	 edx
  028be	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$[ebp+3]
  028c2	50		 push	 eax
  028c3	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$[ebp+2]
  028c7	51		 push	 ecx
  028c8	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$[ebp+1]
  028cc	52		 push	 edx
  028cd	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$[ebp]
  028d1	50		 push	 eax
  028d2	51		 push	 ecx
  028d3	52		 push	 edx
  028d4	e8 00 00 00 00	 call	 __ftol2_sse
  028d9	0f b6 8d 80 fe
	ff ff		 movzx	 ecx, BYTE PTR _Option2$246024[ebp]
  028e0	0f b6 95 78 fe
	ff ff		 movzx	 edx, BYTE PTR _Option1$246023[ebp]
  028e7	50		 push	 eax
  028e8	0f b6 85 7c fe
	ff ff		 movzx	 eax, BYTE PTR _Option3$246025[ebp]
  028ef	50		 push	 eax
  028f0	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _level$246020[ebp]
  028f6	51		 push	 ecx
  028f7	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR _type$246019[ebp]
  028fd	52		 push	 edx
  028fe	50		 push	 eax
  028ff	0f bf 83 46 01
	00 00		 movsx	 eax, WORD PTR [ebx+326]
  02906	51		 push	 ecx
  02907	0f bf 8b 44 01
	00 00		 movsx	 ecx, WORD PTR [ebx+324]
  0290e	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$246035[ebp]
  02911	52		 push	 edx
  02912	0f b6 93 49 01
	00 00		 movzx	 edx, BYTE PTR [ebx+329]
  02919	56		 push	 esi
  0291a	50		 push	 eax
  0291b	51		 push	 ecx
  0291c	52		 push	 edx
  0291d	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  02920	50		 push	 eax
  02921	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  02924	51		 push	 ecx
  02925	68 df 01 00 00	 push	 479			; 000001dfH
  0292a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0292f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  02934	50		 push	 eax
  02935	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0293b	83 c4 64	 add	 esp, 100		; 00000064H

; 5673 : 					}
; 5674 : 					else

  0293e	e9 c8 e0 ff ff	 jmp	 $LN6@CGItemDrop
$LN9@CGItemDrop:

; 5675 : 					{
; 5676 : 						LogAddTD(lMsg.Get(MSGGET(1, 224)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2, Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], SOption, btItemEffectEx>>7, JOHOption, JOHOptionLevel); //season3.5 fixed

  02943	0f b6 95 73 fe
	ff ff		 movzx	 edx, BYTE PTR _JOHOptionLevel$246038[ebp]
  0294a	0f b6 85 72 fe
	ff ff		 movzx	 eax, BYTE PTR _JOHOption$246037[ebp]
  02951	0f b6 8d 54 fe
	ff ff		 movzx	 ecx, BYTE PTR _btItemEffectEx$246031[ebp]
  02958	52		 push	 edx
  02959	0f b6 95 50 fe
	ff ff		 movzx	 edx, BYTE PTR _SOption$246030[ebp]
  02960	50		 push	 eax
  02961	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$[ebp+6]
  02965	c1 e9 07	 shr	 ecx, 7
  02968	51		 push	 ecx
  02969	0f b6 4d f9	 movzx	 ecx, BYTE PTR _NewOption$[ebp+5]
  0296d	52		 push	 edx
  0296e	0f b6 55 f8	 movzx	 edx, BYTE PTR _NewOption$[ebp+4]
  02972	50		 push	 eax
  02973	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  02977	51		 push	 ecx
  02978	0f b6 4d f6	 movzx	 ecx, BYTE PTR _NewOption$[ebp+2]
  0297c	52		 push	 edx
  0297d	0f b6 55 f5	 movzx	 edx, BYTE PTR _NewOption$[ebp+1]
  02981	50		 push	 eax
  02982	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  02986	51		 push	 ecx
  02987	52		 push	 edx
  02988	50		 push	 eax
  02989	e8 00 00 00 00	 call	 __ftol2_sse
  0298e	0f b6 8d 7c fe
	ff ff		 movzx	 ecx, BYTE PTR _Option3$246025[ebp]
  02995	0f b6 95 80 fe
	ff ff		 movzx	 edx, BYTE PTR _Option2$246024[ebp]
  0299c	50		 push	 eax
  0299d	0f b6 85 78 fe
	ff ff		 movzx	 eax, BYTE PTR _Option1$246023[ebp]
  029a4	51		 push	 ecx
  029a5	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _level$246020[ebp]
  029ab	52		 push	 edx
  029ac	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR _type$246019[ebp]
  029b2	50		 push	 eax
  029b3	51		 push	 ecx
  029b4	0f bf 8b 46 01
	00 00		 movsx	 ecx, WORD PTR [ebx+326]
  029bb	52		 push	 edx
  029bc	0f bf 93 44 01
	00 00		 movsx	 edx, WORD PTR [ebx+324]
  029c3	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$246035[ebp]
  029c6	50		 push	 eax
  029c7	0f b6 83 49 01
	00 00		 movzx	 eax, BYTE PTR [ebx+329]
  029ce	56		 push	 esi
  029cf	51		 push	 ecx
  029d0	52		 push	 edx
  029d1	50		 push	 eax
  029d2	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  029d5	51		 push	 ecx
  029d6	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  029d9	52		 push	 edx
  029da	68 e0 01 00 00	 push	 480			; 000001e0H
  029df	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  029e4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  029e9	50		 push	 eax
  029ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  029f0	83 c4 64	 add	 esp, 100		; 00000064H

; 5677 : 					}
; 5678 : 				}
; 5679 : 				else

  029f3	e9 13 e0 ff ff	 jmp	 $LN6@CGItemDrop
$LN176@CGItemDrop:

; 4953 : 		{
; 4954 : 			GCServerMsgStringSend("Move Amulet Block",lpObj->m_Index,1);

  029f8	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  029fa	6a 01		 push	 1
  029fc	51		 push	 ecx
  029fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IGBLPOFO@Move?5Amulet?5Block?$AA@
$LN225@CGItemDrop:
  02a02	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
$LN223@CGItemDrop:

; 5728 : }

  02a07	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02a0a	83 c4 0c	 add	 esp, 12			; 0000000cH
  02a0d	5f		 pop	 edi
  02a0e	5e		 pop	 esi
  02a0f	33 cd		 xor	 ecx, ebp
  02a11	83 c8 ff	 or	 eax, -1
  02a14	5b		 pop	 ebx
  02a15	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02a1a	8b e5		 mov	 esp, ebp
  02a1c	5d		 pop	 ebp
  02a1d	c3		 ret	 0
  02a1e	8b ff		 npad	 2
$LN229@CGItemDrop:
  02a20	00 00 00 00	 DD	 $LN80@CGItemDrop
  02a24	00 00 00 00	 DD	 $LN75@CGItemDrop
  02a28	00 00 00 00	 DD	 $LN75@CGItemDrop
  02a2c	00 00 00 00	 DD	 $LN75@CGItemDrop
  02a30	00 00 00 00	 DD	 $LN74@CGItemDrop
  02a34	00 00 00 00	 DD	 $LN73@CGItemDrop
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ENDP	; CGItemDropRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCItemMoveResultSend@@YAXHEEQAE@Z		; GCItemMoveResultSend
EXTRN	?UpdatePSInventoryUser@PersonalShopZt@@QAEXH@Z:PROC ; PersonalShopZt::UpdatePSInventoryUser
EXTRN	?g_PersonalShopZt@@3VPersonalShopZt@@A:BYTE	; g_PersonalShopZt
; Function compile flags: /Ogtp
;	COMDAT ?GCItemMoveResultSend@@YAXHEEQAE@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_pos$ = 16						; size = 1
_ItemInfo$ = 20						; size = 4
?GCItemMoveResultSend@@YAXHEEQAE@Z PROC			; GCItemMoveResultSend, COMDAT

; 5739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 5740 : #if(CUSTOM_PERSONAL_SHOP==TRUE)
; 5741 : 	if(pos >= 204)

  00011	8a 5d 10	 mov	 bl, BYTE PTR _pos$[ebp]
  00014	56		 push	 esi
  00015	8b 75 14	 mov	 esi, DWORD PTR _ItemInfo$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001c	80 fb cc	 cmp	 bl, 204			; 000000ccH
  0001f	72 0b		 jb	 SHORT $LN1@GCItemMove

; 5742 : 	{
; 5743 : 		g_PersonalShopZt.UpdatePSInventoryUser(aIndex);

  00021	57		 push	 edi
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PersonalShopZt@@3VPersonalShopZt@@A ; g_PersonalShopZt
  00027	e8 00 00 00 00	 call	 ?UpdatePSInventoryUser@PersonalShopZt@@QAEXH@Z ; PersonalShopZt::UpdatePSInventoryUser
$LN1@GCItemMove:

; 5744 : 	}
; 5745 : #endif
; 5746 : 
; 5747 : 	PMSG_INVENTORYITEMMOVE_RESULT pMsg;
; 5748 : 
; 5749 : 	pMsg.h.c = 0xC3;
; 5750 : 	pMsg.h.headcode = 0x24;
; 5751 : 	pMsg.h.size = sizeof(pMsg);
; 5752 : 	pMsg.result = result;
; 5753 : 	pMsg.Pos = pos;
; 5754 : 	pMsg.ItemInfo[0] = ItemInfo[0];

  0002c	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  0002f	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]

; 5755 : 	pMsg.ItemInfo[1] = ItemInfo[1];

  00032	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  00036	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 5756 : 	pMsg.ItemInfo[2] = ItemInfo[2];
; 5757 : 	pMsg.ItemInfo[3] = ItemInfo[3];

  00039	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0003d	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00040	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00044	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 5758 : 	pMsg.ItemInfo[4] = ItemInfo[4];
; 5759 : 	pMsg.ItemInfo[5] = ItemInfo[5];
; 5760 : 	pMsg.ItemInfo[6] = ItemInfo[6];

  00047	0f b6 4e 06	 movzx	 ecx, BYTE PTR [esi+6]
  0004b	88 55 ee	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  0004e	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  00052	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+7], al
  00055	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00059	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 5761 : 
; 5762 : 	//season4 add-on
; 5763 : 	pMsg.ItemInfo[7] = ItemInfo[7];
; 5764 : 	pMsg.ItemInfo[8] = ItemInfo[8];
; 5765 : 	pMsg.ItemInfo[9] = ItemInfo[9];

  0005c	0f b6 4e 09	 movzx	 ecx, BYTE PTR [esi+9]
  00060	88 55 f1	 mov	 BYTE PTR _pMsg$[ebp+9], dl
  00063	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00067	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+10], al
  0006a	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  0006e	88 4d f6	 mov	 BYTE PTR _pMsg$[ebp+14], cl
  00071	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+12], dl

; 5766 : 	pMsg.ItemInfo[10] = ItemInfo[10];

  00074	0f b6 56 0a	 movzx	 edx, BYTE PTR [esi+10]
  00078	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 5767 : 	pMsg.ItemInfo[11] = ItemInfo[11];

  0007b	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]

; 5768 : 
; 5769 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007f	6a 11		 push	 17			; 00000011H
  00081	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00084	51		 push	 ecx
  00085	57		 push	 edi
  00086	c6 45 e8 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  0008a	66 c7 45 e9 11
	24		 mov	 WORD PTR _pMsg$[ebp+1], 9233 ; 00002411H
  00090	88 5d ec	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  00093	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+15], dl
  00096	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+16], al
  00099	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5770 : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5b		 pop	 ebx
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?GCItemMoveResultSend@@YAXHEEQAE@Z ENDP			; GCItemMoveResultSend
_TEXT	ENDS
PUBLIC	_pos$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCEquipmentChange@@YAXHH@Z			; GCEquipmentChange
; Function compile flags: /Ogtp
;	COMDAT ?GCEquipmentChange@@YAXHH@Z
_TEXT	SEGMENT
_pos$GSCopy$ = -32					; size = 4
_aIndex$GSCopy$ = -28					; size = 4
_pChange$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCEquipmentChange@@YAXHH@Z PROC			; GCEquipmentChange, COMDAT

; 6302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 6303 : 	PMSG_USEREQUIPMENTCHANGED pChange;
; 6304 : 	LPOBJ lpObj = &gObj[aIndex];

  00017	89 5d e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001a	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00020	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	56		 push	 esi
  00027	57		 push	 edi

; 6305 : 
; 6306 : 	PHeadSetB((LPBYTE)&pChange, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  00028	6a 11		 push	 17			; 00000011H
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR _pChange$[ebp]
  0002d	6a 25		 push	 37			; 00000025H
  0002f	51		 push	 ecx
  00030	89 45 e0	 mov	 DWORD PTR _pos$GSCopy$[ebp], eax
  00033	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6307 : 	pChange.NumberH = SET_NUMBERH(aIndex);

  00038	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 6308 : 	pChange.NumberL = SET_NUMBERL(aIndex);

  0003b	88 45 ec	 mov	 BYTE PTR _pChange$[ebp+4], al
  0003e	8b d0		 mov	 edx, eax

; 6309 : 	ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[pos]);

  00040	8b 45 e0	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  00043	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00049	c1 ea 08	 shr	 edx, 8
  0004c	88 55 eb	 mov	 BYTE PTR _pChange$[ebp+3], dl
  0004f	8b b3 24 0e 00
	00		 mov	 esi, DWORD PTR [ebx+3620]
  00055	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0005b	03 f0		 add	 esi, eax
  0005d	8b fc		 mov	 edi, esp
  0005f	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00064	f3 a5		 rep movsd
  00066	8d 4d ed	 lea	 ecx, DWORD PTR _pChange$[ebp+5]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 6310 : 	pChange.ItemInfo[1] = pos << 4;

  0006f	8b 45 e0	 mov	 eax, DWORD PTR _pos$GSCopy$[ebp]
  00072	8a d0		 mov	 dl, al

; 6311 : 	pChange.ItemInfo[1] |= LevelSmallConvert(aIndex, pos) & MAX_ITEM_LEVEL;

  00074	50		 push	 eax
  00075	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00078	c0 e2 04	 shl	 dl, 4
  0007b	50		 push	 eax
  0007c	88 55 ee	 mov	 BYTE PTR _pChange$[ebp+6], dl
  0007f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert

; 6312 : 
; 6313 : 	MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  00084	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pChange$[ebp+1]
  00088	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  0008e	51		 push	 ecx
  0008f	8d 55 e8	 lea	 edx, DWORD PTR _pChange$[ebp]
  00092	52		 push	 edx
  00093	24 0f		 and	 al, 15			; 0000000fH
  00095	08 45 ee	 or	 BYTE PTR _pChange$[ebp+6], al
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 6314 : }

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5b		 pop	 ebx
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?GCEquipmentChange@@YAXHH@Z ENDP			; GCEquipmentChange
_TEXT	ENDS
PUBLIC	?CheckBuyDonateItem@@YA_NPAUPMSG_BUYREQUEST@@H@Z ; CheckBuyDonateItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckBuyDonateItem@@YA_NPAUPMSG_BUYREQUEST@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_pMsg$ = 12						; size = 4
_aIndex$ = 12						; size = 4
?CheckBuyDonateItem@@YA_NPAUPMSG_BUYREQUEST@@H@Z PROC	; CheckBuyDonateItem, COMDAT

; 6705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6706 : 	if(!OBJMAX_RANGE(aIndex))

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 0f		 js	 SHORT $LN10@CheckBuyDo
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	75 04		 jne	 SHORT $LN3@CheckBuyDo
$LN10@CheckBuyDo:

; 6707 : 	{
; 6708 : 		return false;

  00019	32 c0		 xor	 al, al

; 6731 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN3@CheckBuyDo:

; 6709 : 	}
; 6710 : 
; 6711 : 	LPOBJ lpUser = &gObj[aIndex];

  0001d	8b c1		 mov	 eax, ecx
  0001f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00025	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6712 : 
; 6713 : 	if(lpUser->m_bCheckBuyDonateItem)

  0002b	80 b8 f8 29 00
	00 00		 cmp	 BYTE PTR [eax+10744], 0

; 6714 : 	{
; 6715 : 		return false;

  00032	75 e5		 jne	 SHORT $LN10@CheckBuyDo

; 6716 : 	}
; 6717 : 
; 6718 : 	if(lpUser->TargetShopNumber < DONAT_SHOP_START && DONAT_SHOP_END > lpUser->TargetShopNumber)

  00034	0f b7 90 5a 04
	00 00		 movzx	 edx, WORD PTR [eax+1114]
  0003b	66 83 fa 14	 cmp	 dx, 20			; 00000014H
  0003f	7d 0c		 jge	 SHORT $LN1@CheckBuyDo
  00041	56		 push	 esi
  00042	be 2d 00 00 00	 mov	 esi, 45			; 0000002dH
  00047	66 3b f2	 cmp	 si, dx
  0004a	5e		 pop	 esi

; 6719 : 	{
; 6720 : 		return false;

  0004b	7f cc		 jg	 SHORT $LN10@CheckBuyDo
$LN1@CheckBuyDo:

; 6721 : 	}
; 6722 : 
; 6723 : 	lpUser->m_bCheckBuyDonateItem = true;
; 6724 : 	lpUser->m_btCheckBuyDonatePos = lpMsg->Pos;

  0004d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00050	c6 80 f8 29 00
	00 01		 mov	 BYTE PTR [eax+10744], 1
  00057	8a 52 03	 mov	 dl, BYTE PTR [edx+3]
  0005a	88 90 f9 29 00
	00		 mov	 BYTE PTR [eax+10745], dl

; 6725 : 
; 6726 : 	PMSG_DONATE_CHECKBUY pMsg;
; 6727 : 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0x96, sizeof(pMsg));
; 6728 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00060	6a 04		 push	 4
  00062	8d 45 0c	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00065	50		 push	 eax
  00066	51		 push	 ecx
  00067	c7 45 0c c1 04
	fb 96		 mov	 DWORD PTR _pMsg$[ebp], -1761934143 ; 96fb04c1H
  0006e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6729 : 
; 6730 : 	return true;	

  00076	b0 01		 mov	 al, 1

; 6731 : }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?CheckBuyDonateItem@@YA_NPAUPMSG_BUYREQUEST@@H@Z ENDP	; CheckBuyDonateItem
_TEXT	ENDS
PUBLIC	??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	??_C@_0BH@JBOCIKJE@?$FLZen?5Coin?$FN?5Need?5?$CFd?5Zen?$AA@ ; `string'
PUBLIC	??_C@_0BF@ONNMFDNA@?$FLBuy?5Credit?$FN?5Need?5?$CFd?$AA@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z	; CGBuyRequestRecv
EXTRN	?BuyItemEx@CShop@@QAE_NHH@Z:PROC		; CShop::BuyItemEx
EXTRN	?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjShopBuyInventoryInsertItem
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z:PROC	; gObjSearchItem
EXTRN	?CheckBuyItemEx@CShop@@QAE_NHHAAH@Z:PROC	; CShop::CheckBuyItemEx
EXTRN	?BuyPriceItem@cPriceManager@@QAE_NHHAAHH@Z:PROC	; cPriceManager::BuyPriceItem
EXTRN	?PriceManager@@3VcPriceManager@@A:BYTE		; PriceManager
EXTRN	?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateStore
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?ShopC@@3PAVCShop@@A:BYTE			; ShopC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
;	COMDAT ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@ DB '['
	DB	'%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d'
	DB	'][%d][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBOCIKJE@?$FLZen?5Coin?$FN?5Need?5?$CFd?5Zen?$AA@
CONST	SEGMENT
??_C@_0BH@JBOCIKJE@?$FLZen?5Coin?$FN?5Need?5?$CFd?5Zen?$AA@ DB '[Zen Coin'
	DB	'] Need %d Zen', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ONNMFDNA@?$FLBuy?5Credit?$FN?5Need?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@ONNMFDNA@?$FLBuy?5Credit?$FN?5Need?5?$CFd?$AA@ DB '[Buy Credit]'
	DB	' Need %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z
_TEXT	SEGMENT
_tShop$ = -52						; size = 4
tv806 = -48						; size = 4
tv768 = -44						; size = 4
_iTaxRate$246738 = -44					; size = 4
_lpMsg$GSCopy$ = -40					; size = 4
_iStoreTaxMoney$246676 = -36				; size = 4
_StandartShop$246710 = -29				; size = 1
tv856 = -28						; size = 4
_iStoreTaxMoney2$246717 = -28				; size = 4
_MinusCred$246684 = -28					; size = 4
_aIndex$GSCopy$ = -24					; size = 4
_pResult$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z PROC	; CGBuyRequestRecv, COMDAT

; 6761 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6762 : #if(THINNAKORN_MAC)
; 6763 : 	if(CheckBuyDonateItem(lpMsg, aIndex) == true)
; 6764 : 	{
; 6765 : 		return;
; 6766 : 	}
; 6767 : #endif
; 6768 : 
; 6769 : 	LPOBJ lpObj = &gObj[aIndex];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 7012 : 					}
; 7013 : #else
; 7014 : 					lpObj->Money -= iStoreTaxMoney;
; 7015 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney2);
; 7016 : 
; 7017 : 					if ( lpObj->Money < 0 )
; 7018 : 					{
; 7019 : 						lpObj->Money = 0;
; 7020 : 					}
; 7021 : 
; 7022 : 					GCMoneySend(aIndex, lpObj->Money);
; 7023 : #endif
; 7024 : 					LogAddTD("[%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d][%d][%d]", lpObj->AccountID, lpObj->Name, tShop, lc64, iTaxRate, lc64+iStoreTaxMoney2, ShopC[tShop].m_item[lpMsg->Pos].GetName(), ShopC[tShop].m_item[lpMsg->Pos].m_Level, ShopC[tShop].m_item[lpMsg->Pos].m_Durability, ShopC[tShop].m_item[lpMsg->Pos].m_Option1, ShopC[tShop].m_item[lpMsg->Pos].m_Option2, ShopC[tShop].m_item[lpMsg->Pos].m_Option3);

  0001a	89 75 e8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00027	6a 10		 push	 16			; 00000010H
  00029	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0002c	6a 32		 push	 50			; 00000032H
  0002e	51		 push	 ecx
  0002f	89 7d d8	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  00032	89 75 d4	 mov	 DWORD PTR tv768[ebp], esi
  00035	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00038	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0003d	53		 push	 ebx
  0003e	c6 45 ef ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00042	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 d0 05 00
	00		 je	 $LN45@CGBuyReque

; 6770 : 	PMSG_BUYRESULT pResult;
; 6771 : 
; 6772 : 	PHeadSetB((LPBYTE)&pResult, 0x32, sizeof(pResult));
; 6773 : 	pResult.Result = -1;
; 6774 : 
; 6775 : 	if ( !PacketCheckTime(lpObj))
; 6776 : 	{
; 6777 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6778 : 		return;
; 6779 : 	}
; 6780 : 
; 6781 : 	if ( gObj[aIndex].CloseType != -1 )

  00052	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	80 7c 16 0b ff	 cmp	 BYTE PTR [esi+edx+11], -1
  0005d	74 12		 je	 SHORT $LN53@CGBuyReque

; 6782 : 	{
; 6783 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0005f	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00063	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00066	50		 push	 eax
  00067	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0006a	51		 push	 ecx
  0006b	52		 push	 edx

; 6784 : 		return;

  0006c	e9 be 05 00 00	 jmp	 $LN71@CGBuyReque
$LN53@CGBuyReque:

; 6785 : 	}
; 6786 : 
; 6787 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00071	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0007a	83 c4 04	 add	 esp, 4
  0007d	84 c0		 test	 al, al
  0007f	75 18		 jne	 SHORT $LN52@CGBuyReque

; 6788 : 	{
; 6789 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00081	68 85 1a 00 00	 push	 6789			; 00001a85H
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@CGBuyReque:

; 6790 : 	}
; 6791 : 
; 6792 : 	if ( gObj[aIndex].m_ShopTime == 0 )

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009e	80 bc 06 90 03
	00 00 00	 cmp	 BYTE PTR [esi+eax+912], 0
  000a6	75 0d		 jne	 SHORT $LN51@CGBuyReque

; 6793 : 	{
; 6794 : 		gObj[aIndex].m_ShopTime = 1;

  000a8	c6 84 06 90 03
	00 00 01	 mov	 BYTE PTR [esi+eax+912], 1
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN51@CGBuyReque:

; 6795 : 	}
; 6796 : 
; 6797 : 	if ( gObj[aIndex].m_ShopTime > 	60 )

  000b5	80 bc 06 90 03
	00 00 3c	 cmp	 BYTE PTR [esi+eax+912], 60 ; 0000003cH

; 6798 : 	{
; 6799 : 		if ( lpObj->m_IfState.use != 0 && lpObj->m_IfState.type == 3 )

  000bd	8b 83 1c 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3612]
  000c3	76 35		 jbe	 SHORT $LN50@CGBuyReque
  000c5	a8 03		 test	 al, 3
  000c7	0f 84 55 05 00
	00		 je	 $LN45@CGBuyReque
  000cd	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000d2	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000d7	0f 85 45 05 00
	00		 jne	 $LN45@CGBuyReque

; 6800 : 		{
; 6801 : 			pResult.Result = 0xFE; //season 3.0 add-on
; 6802 : 			lpObj->TargetShopNumber = -1;

  000dd	83 c9 ff	 or	 ecx, -1
  000e0	c6 45 ef fe	 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH

; 6803 : 			lpObj->m_IfState.use = 0;
; 6804 : 			lpObj->m_IfState.type = 0;

  000e4	81 a3 1c 0e 00
	00 3c 00 ff ff	 and	 DWORD PTR [ebx+3612], -65476 ; ffff003cH
  000ee	66 89 8b 5a 04
	00 00		 mov	 WORD PTR [ebx+1114], cx

; 6805 : 		}
; 6806 : 
; 6807 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6808 : 		return;

  000f5	e9 28 05 00 00	 jmp	 $LN45@CGBuyReque
$LN50@CGBuyReque:

; 6809 : 	}
; 6810 : 
; 6811 : 	if ( lpObj->m_IfState.use > 0 )

  000fa	a8 03		 test	 al, 3
  000fc	76 10		 jbe	 SHORT $LN47@CGBuyReque

; 6812 : 	{
; 6813 : 		if ( lpObj->m_IfState.type != 3 )

  000fe	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00103	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H

; 6814 : 		{
; 6815 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6816 : 			return;

  00108	0f 85 14 05 00
	00		 jne	 $LN45@CGBuyReque
$LN47@CGBuyReque:

; 6817 : 		}
; 6818 : 	}
; 6819 : 
; 6820 : 	int tShop = lpObj->TargetShopNumber;

  0010e	0f bf b3 5a 04
	00 00		 movsx	 esi, WORD PTR [ebx+1114]
  00115	89 75 cc	 mov	 DWORD PTR _tShop$[ebp], esi

; 6821 : 
; 6822 : 	if ( tShop < 0 || tShop > MAX_SHOP-1 )

  00118	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  0011b	0f 87 01 05 00
	00		 ja	 $LN45@CGBuyReque

; 6825 : 		return;
; 6826 : 	}
; 6827 : 
; 6828 : 	if ( lpMsg->Pos > MAX_ITEM_IN_SHOP-1 )

  00121	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00124	3c 77		 cmp	 al, 119			; 00000077H

; 6829 : 	{
; 6830 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6831 : 		return;

  00126	0f 87 f6 04 00
	00		 ja	 $LN45@CGBuyReque

; 6832 : 	}
; 6833 : 	
; 6834 : 	if ( ShopC[tShop].m_item[lpMsg->Pos].IsItem() == TRUE )

  0012c	0f b6 d0	 movzx	 edx, al
  0012f	69 f6 9c 6f 00
	00		 imul	 esi, 28572		; 00006f9cH
  00135	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0013b	8d 8c 32 80 00
	00 00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[edx+esi+128]
  00142	89 75 d0	 mov	 DWORD PTR tv806[ebp], esi
  00145	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0014a	83 f8 01	 cmp	 eax, 1
  0014d	0f 85 cf 04 00
	00		 jne	 $LN45@CGBuyReque

; 6835 : 	{
; 6836 : 		int iStoreTaxMoney = ShopC[tShop].m_item[lpMsg->Pos].m_BuyMoney + (int)((__int64)ShopC[tShop].m_item[lpMsg->Pos].m_BuyMoney * (__int64)g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index) / (__int64)100);

  00153	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00157	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00159	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0015f	8b bc 30 f0 00
	00 00		 mov	 edi, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+esi+240]
  00166	51		 push	 ecx
  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0016c	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  00171	6a 00		 push	 0
  00173	99		 cdq
  00174	57		 push	 edi
  00175	52		 push	 edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 __allmul
  0017c	6a 00		 push	 0
  0017e	6a 64		 push	 100			; 00000064H
  00180	52		 push	 edx
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 __alldiv
  00187	03 c7		 add	 eax, edi

; 6837 : 
; 6838 : 		int BuyItemLevel = ShopC[tShop].m_item[lpMsg->Pos].m_Level;

  00189	8b 7d d8	 mov	 edi, DWORD PTR _lpMsg$GSCopy$[ebp]
  0018c	89 45 dc	 mov	 DWORD PTR _iStoreTaxMoney$246676[ebp], eax
  0018f	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00193	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00199	0f bf 8c 30 88
	00 00 00	 movsx	 ecx, WORD PTR ?ShopC@@3PAVCShop@@A[eax+esi+136]

; 6839 : 
; 6840 : 		if(!PriceManager.BuyPriceItem(aIndex,ShopC[tShop].m_item[lpMsg->Pos].m_Type,iStoreTaxMoney,BuyItemLevel))

  001a1	0f bf 94 30 86
	00 00 00	 movsx	 edx, WORD PTR ?ShopC@@3PAVCShop@@A[eax+esi+134]
  001a9	03 c6		 add	 eax, esi
  001ab	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001ae	51		 push	 ecx
  001af	8d 4d dc	 lea	 ecx, DWORD PTR _iStoreTaxMoney$246676[ebp]
  001b2	51		 push	 ecx
  001b3	52		 push	 edx
  001b4	50		 push	 eax
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?PriceManager@@3VcPriceManager@@A ; PriceManager
  001ba	e8 00 00 00 00	 call	 ?BuyPriceItem@cPriceManager@@QAE_NHHAAHH@Z ; cPriceManager::BuyPriceItem
  001bf	84 c0		 test	 al, al
  001c1	75 12		 jne	 SHORT $LN42@CGBuyReque
$LN74@CGBuyReque:

; 6841 : 		{
; 6842 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001c3	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  001c7	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001ca	51		 push	 ecx
  001cb	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  001ce	52		 push	 edx
  001cf	50		 push	 eax

; 6843 : 			return;

  001d0	e9 5a 04 00 00	 jmp	 $LN71@CGBuyReque
$LN42@CGBuyReque:

; 6844 : 		}
; 6845 : 
; 6846 : #if(_CR_COIN_==1)
; 6847 : 		int MinusCred = 0;
; 6848 : 		if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,215))

  001d5	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  001d9	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  001df	0f b7 84 31 86
	00 00 00	 movzx	 eax, WORD PTR ?ShopC@@3PAVCShop@@A[ecx+esi+134]
  001e7	ba d7 1c 00 00	 mov	 edx, 7383		; 00001cd7H
  001ec	66 3b c2	 cmp	 ax, dx
  001ef	75 07		 jne	 SHORT $LN41@CGBuyReque

; 6849 : 		{
; 6850 : 			MinusCred++;

  001f1	b9 01 00 00 00	 mov	 ecx, 1
  001f6	eb 53		 jmp	 SHORT $LN72@CGBuyReque
$LN41@CGBuyReque:

; 6851 : 		}
; 6852 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,216))

  001f8	b9 d8 1c 00 00	 mov	 ecx, 7384		; 00001cd8H
  001fd	66 3b c1	 cmp	 ax, cx
  00200	75 07		 jne	 SHORT $LN39@CGBuyReque

; 6853 : 		{
; 6854 : 			MinusCred += 5;

  00202	b9 05 00 00 00	 mov	 ecx, 5
  00207	eb 42		 jmp	 SHORT $LN72@CGBuyReque
$LN39@CGBuyReque:

; 6855 : 		}
; 6856 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,217))

  00209	ba d9 1c 00 00	 mov	 edx, 7385		; 00001cd9H
  0020e	66 3b c2	 cmp	 ax, dx
  00211	75 07		 jne	 SHORT $LN37@CGBuyReque

; 6857 : 		{
; 6858 : 			MinusCred += 10;

  00213	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00218	eb 31		 jmp	 SHORT $LN72@CGBuyReque
$LN37@CGBuyReque:

; 6859 : 		}
; 6860 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,218))

  0021a	b9 da 1c 00 00	 mov	 ecx, 7386		; 00001cdaH
  0021f	66 3b c1	 cmp	 ax, cx
  00222	75 07		 jne	 SHORT $LN35@CGBuyReque

; 6861 : 		{
; 6862 : 			MinusCred += 20;

  00224	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00229	eb 20		 jmp	 SHORT $LN72@CGBuyReque
$LN35@CGBuyReque:

; 6863 : 		}
; 6864 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,219))

  0022b	ba db 1c 00 00	 mov	 edx, 7387		; 00001cdbH
  00230	66 3b c2	 cmp	 ax, dx
  00233	75 07		 jne	 SHORT $LN33@CGBuyReque

; 6865 : 		{
; 6866 : 			MinusCred += 50;

  00235	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  0023a	eb 0f		 jmp	 SHORT $LN72@CGBuyReque
$LN33@CGBuyReque:

; 6867 : 		}
; 6868 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,220))

  0023c	b9 dc 1c 00 00	 mov	 ecx, 7388		; 00001cdcH
  00241	66 3b c1	 cmp	 ax, cx
  00244	75 67		 jne	 SHORT $LN61@CGBuyReque

; 6869 : 		{
; 6870 : 			MinusCred += 100;

  00246	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
$LN72@CGBuyReque:
  0024b	89 4d e4	 mov	 DWORD PTR _MinusCred$246684[ebp], ecx

; 6871 : 		}
; 6872 : 		if(MinusCred>0)
; 6873 : 		{
; 6874 : 			if(MinusCred > lpObj->ZtCred)

  0024e	db 45 e4	 fild	 DWORD PTR _MinusCred$246684[ebp]
  00251	d9 5d e4	 fstp	 DWORD PTR tv856[ebp]
  00254	d9 45 e4	 fld	 DWORD PTR tv856[ebp]
  00257	d9 83 a8 22 00
	00		 fld	 DWORD PTR [ebx+8872]
  0025d	d8 d9		 fcomp	 ST(1)
  0025f	df e0		 fnstsw	 ax
  00261	f6 c4 05	 test	 ah, 5
  00264	7a 34		 jp	 SHORT $LN29@CGBuyReque

; 6875 : 			{
; 6876 : 				MsgNormal(aIndex,"[Buy Credit] Need %d",MinusCred);

  00266	8b 75 e8	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00269	dd d8		 fstp	 ST(0)
  0026b	51		 push	 ecx
  0026c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ONNMFDNA@?$FLBuy?5Credit?$FN?5Need?5?$CFd?$AA@
  00271	56		 push	 esi
  00272	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal

; 6877 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00277	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0027b	52		 push	 edx
  0027c	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  0027f	50		 push	 eax
  00280	56		 push	 esi
  00281	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00286	83 c4 18	 add	 esp, 24			; 00000018H

; 7025 : 				}
; 7026 : 			}
; 7027 : 		}
; 7028 : 	}
; 7029 : 
; 7030 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7031 : }

  00289	5f		 pop	 edi
  0028a	5e		 pop	 esi
  0028b	5b		 pop	 ebx
  0028c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028f	33 cd		 xor	 ecx, ebp
  00291	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00296	8b e5		 mov	 esp, ebp
  00298	5d		 pop	 ebp
  00299	c3		 ret	 0
$LN29@CGBuyReque:

; 6878 : 				return;
; 6879 : 			}
; 6880 : 			iStoreTaxMoney = 0;
; 6881 : 			lpObj->ZtCred -= MinusCred;

  0029a	d8 ab a8 22 00
	00		 fsubr	 DWORD PTR [ebx+8872]
  002a0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iStoreTaxMoney$246676[ebp], 0
  002a7	d9 9b a8 22 00
	00		 fstp	 DWORD PTR [ebx+8872]
$LN61@CGBuyReque:

; 6882 : 		}
; 6883 : #endif
; 6884 : #if(_ZEN_COIN_==1)
; 6885 : 		int MinusZen = 0;
; 6886 : 		if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,221))

  002ad	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  002b1	8b d1		 mov	 edx, ecx
  002b3	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  002b9	0f b7 84 32 86
	00 00 00	 movzx	 eax, WORD PTR ?ShopC@@3PAVCShop@@A[edx+esi+134]
  002c1	ba dd 1c 00 00	 mov	 edx, 7389		; 00001cddH
  002c6	66 3b c2	 cmp	 ax, dx
  002c9	75 07		 jne	 SHORT $LN28@CGBuyReque

; 6887 : 		{
; 6888 : 			MinusZen += 100000000;

  002cb	b8 00 e1 f5 05	 mov	 eax, 100000000		; 05f5e100H
  002d0	eb 20		 jmp	 SHORT $LN58@CGBuyReque
$LN28@CGBuyReque:

; 6889 : 		}
; 6890 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,222))

  002d2	ba de 1c 00 00	 mov	 edx, 7390		; 00001cdeH
  002d7	66 3b c2	 cmp	 ax, dx
  002da	75 07		 jne	 SHORT $LN26@CGBuyReque

; 6891 : 		{
; 6892 : 			MinusZen += 500000000;

  002dc	b8 00 65 cd 1d	 mov	 eax, 500000000		; 1dcd6500H
  002e1	eb 0f		 jmp	 SHORT $LN58@CGBuyReque
$LN26@CGBuyReque:

; 6893 : 		}
; 6894 : 		else if(ShopC[tShop].m_item[lpMsg->Pos].m_Type == ITEMGET(14,223))

  002e3	ba df 1c 00 00	 mov	 edx, 7391		; 00001cdfH
  002e8	66 3b c2	 cmp	 ax, dx
  002eb	75 42		 jne	 SHORT $LN67@CGBuyReque

; 6895 : 		{
; 6896 : 			MinusZen += 1000000000;

  002ed	b8 00 ca 9a 3b	 mov	 eax, 1000000000		; 3b9aca00H
$LN58@CGBuyReque:

; 6897 : 		}
; 6898 : 		if(MinusZen>0)
; 6899 : 		{
; 6900 : 			iStoreTaxMoney = MinusZen;

  002f2	89 45 dc	 mov	 DWORD PTR _iStoreTaxMoney$246676[ebp], eax

; 6901 : 			if ( lpObj->Money < iStoreTaxMoney )

  002f5	39 83 f0 00 00
	00		 cmp	 DWORD PTR [ebx+240], eax
  002fb	7d 32		 jge	 SHORT $LN67@CGBuyReque

; 6902 : 			{
; 6903 : 				MsgNormal(aIndex,"[Zen Coin] Need %d Zen",iStoreTaxMoney);

  002fd	8b 75 e8	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00300	50		 push	 eax
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JBOCIKJE@?$FLZen?5Coin?$FN?5Need?5?$CFd?5Zen?$AA@
  00306	56		 push	 esi
  00307	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal

; 6904 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0030c	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00310	50		 push	 eax
  00311	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00314	51		 push	 ecx
  00315	56		 push	 esi
  00316	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0031b	83 c4 18	 add	 esp, 24			; 00000018H

; 7025 : 				}
; 7026 : 			}
; 7027 : 		}
; 7028 : 	}
; 7029 : 
; 7030 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7031 : }

  0031e	5f		 pop	 edi
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx
  00321	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00324	33 cd		 xor	 ecx, ebp
  00326	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032b	8b e5		 mov	 esp, ebp
  0032d	5d		 pop	 ebp
  0032e	c3		 ret	 0
$LN67@CGBuyReque:

; 6905 : 				return;
; 6906 : 			}
; 6907 : 		}
; 6908 : #endif
; 6909 : 
; 6910 : #if(DONATE_SHOP==TRUE)
; 6911 : 		bool StandartShop = true;
; 6912 : 
; 6913 : 		if(tShop >= 0 && tShop < DONAT_SHOP_START)

  0032f	83 7d cc 14	 cmp	 DWORD PTR _tShop$[ebp], 20 ; 00000014H
  00333	7d 06		 jge	 SHORT $LN21@CGBuyReque

; 6914 : 		{
; 6915 : 			StandartShop = true;

  00335	c6 45 e3 01	 mov	 BYTE PTR _StandartShop$246710[ebp], 1

; 6916 : 		}
; 6917 : 		else

  00339	eb 20		 jmp	 SHORT $LN62@CGBuyReque
$LN21@CGBuyReque:

; 6918 : 		{
; 6919 : 			StandartShop = false;
; 6920 : 		}
; 6921 : 
; 6922 : 		if(StandartShop == false)
; 6923 : 		{
; 6924 : 			if(!ShopC[tShop].CheckBuyItemEx(aIndex,lpMsg->Pos, iStoreTaxMoney))

  0033b	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0033e	8d 55 dc	 lea	 edx, DWORD PTR _iStoreTaxMoney$246676[ebp]
  00341	52		 push	 edx
  00342	51		 push	 ecx
  00343	50		 push	 eax
  00344	8d 8e 00 00 00
	00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[esi]
  0034a	c6 45 e3 00	 mov	 BYTE PTR _StandartShop$246710[ebp], 0
  0034e	e8 00 00 00 00	 call	 ?CheckBuyItemEx@CShop@@QAE_NHHAAH@Z ; CShop::CheckBuyItemEx
  00353	84 c0		 test	 al, al

; 6925 : 			{
; 6926 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6927 : 				return;

  00355	0f 84 68 fe ff
	ff		 je	 $LN74@CGBuyReque
$LN62@CGBuyReque:

; 6928 : 			}
; 6929 : 		}
; 6930 : #endif
; 6931 : 
; 6932 : 		if ( iStoreTaxMoney < 0 )

  0035b	83 7d dc 00	 cmp	 DWORD PTR _iStoreTaxMoney$246676[ebp], 0
  0035f	7d 07		 jge	 SHORT $LN17@CGBuyReque

; 6933 : 		{
; 6934 : 			iStoreTaxMoney  = 0;

  00361	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iStoreTaxMoney$246676[ebp], 0
$LN17@CGBuyReque:

; 6935 : 		}
; 6936 : 
; 6937 : 		int iStoreTaxMoney2 = (int)((__int64)ShopC[tShop].m_item[lpMsg->Pos].m_BuyMoney * (__int64)g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index) / (__int64)100);

  00368	0f b6 7f 03	 movzx	 edi, BYTE PTR [edi+3]
  0036c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0036e	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00374	52		 push	 edx
  00375	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0037a	03 fe		 add	 edi, esi
  0037c	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  00381	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[edi+240]
  00387	6a 00		 push	 0
  00389	99		 cdq
  0038a	51		 push	 ecx
  0038b	52		 push	 edx
  0038c	50		 push	 eax
  0038d	e8 00 00 00 00	 call	 __allmul
  00392	6a 00		 push	 0
  00394	6a 64		 push	 100			; 00000064H
  00396	52		 push	 edx
  00397	50		 push	 eax
  00398	e8 00 00 00 00	 call	 __alldiv
  0039d	89 45 e4	 mov	 DWORD PTR _iStoreTaxMoney2$246717[ebp], eax

; 6938 : 
; 6939 : 		if ( iStoreTaxMoney2 < 0 )

  003a0	85 c0		 test	 eax, eax
  003a2	79 07		 jns	 SHORT $LN16@CGBuyReque

; 6940 : 		{
; 6941 : 			iStoreTaxMoney2  = 0;

  003a4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iStoreTaxMoney2$246717[ebp], 0
$LN16@CGBuyReque:

; 6942 : 		}
; 6943 : 
; 6944 : 		if ( lpObj->Money < iStoreTaxMoney )

  003ab	8b 93 f0 00 00
	00		 mov	 edx, DWORD PTR [ebx+240]
  003b1	3b 55 dc	 cmp	 edx, DWORD PTR _iStoreTaxMoney$246676[ebp]
  003b4	7d 09		 jge	 SHORT $LN15@CGBuyReque

; 6945 : 		{
; 6946 : 			pResult.Result = -1;

  003b6	c6 45 ef ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 6947 : 		}
; 6948 : 		else

  003ba	e9 63 02 00 00	 jmp	 $LN45@CGBuyReque
$LN15@CGBuyReque:

; 6949 : 		{
; 6950 : 			BOOL bNoItem = TRUE;
; 6951 : 
; 6952 : 			if ( (ShopC[tShop].m_item[lpMsg->Pos].m_Type >= ITEMGET(14,0) && ShopC[tShop].m_item[lpMsg->Pos].m_Type <= ITEMGET(14,8)) || (ShopC[tShop].m_item[lpMsg->Pos].m_Type >= ITEMGET(14,35) && ShopC[tShop].m_item[lpMsg->Pos].m_Type <= ITEMGET(14,40)))

  003bf	0f b7 87 86 00
	00 00		 movzx	 eax, WORD PTR ?ShopC@@3PAVCShop@@A[edi+134]
  003c6	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  003cb	66 3b c1	 cmp	 ax, cx
  003ce	7c 0a		 jl	 SHORT $LN11@CGBuyReque
  003d0	ba 08 1c 00 00	 mov	 edx, 7176		; 00001c08H
  003d5	66 3b c2	 cmp	 ax, dx
  003d8	7e 1c		 jle	 SHORT $LN12@CGBuyReque
$LN11@CGBuyReque:
  003da	b9 23 1c 00 00	 mov	 ecx, 7203		; 00001c23H
  003df	66 3b c1	 cmp	 ax, cx
  003e2	0f 8c 9c 00 00
	00		 jl	 $LN66@CGBuyReque
  003e8	ba 28 1c 00 00	 mov	 edx, 7208		; 00001c28H
  003ed	66 3b c2	 cmp	 ax, dx
  003f0	0f 8f 8e 00 00
	00		 jg	 $LN66@CGBuyReque
$LN12@CGBuyReque:

; 6953 : 			{
; 6954 : 				int dur = (int)(ShopC[tShop].m_item[lpMsg->Pos].m_Durability);

  003f6	d9 87 a4 00 00
	00		 fld	 DWORD PTR ?ShopC@@3PAVCShop@@A[edi+164]
  003fc	e8 00 00 00 00	 call	 __ftol2_sse

; 6955 : 
; 6956 : 				if ( dur == 0 )

  00401	85 c0		 test	 eax, eax
  00403	75 05		 jne	 SHORT $LN65@CGBuyReque

; 6957 : 				{
; 6958 : 					dur = 1;

  00405	b8 01 00 00 00	 mov	 eax, 1
$LN65@CGBuyReque:

; 6959 : 				}
; 6960 : 
; 6961 : 				if ( ::gObjSearchItem(&gObj[aIndex], ShopC[tShop].m_item[lpMsg->Pos].m_Type,dur, ShopC[tShop].m_item[lpMsg->Pos].m_Level) == TRUE )

  0040a	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0040d	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00411	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00417	0f bf 94 31 88
	00 00 00	 movsx	 edx, WORD PTR ?ShopC@@3PAVCShop@@A[ecx+esi+136]
  0041f	03 ce		 add	 ecx, esi
  00421	52		 push	 edx
  00422	8b 55 d4	 mov	 edx, DWORD PTR tv768[ebp]
  00425	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042b	50		 push	 eax
  0042c	0f bf 81 86 00
	00 00		 movsx	 eax, WORD PTR ?ShopC@@3PAVCShop@@A[ecx+134]
  00433	50		 push	 eax
  00434	52		 push	 edx
  00435	e8 00 00 00 00	 call	 ?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z ; gObjSearchItem
  0043a	83 c4 10	 add	 esp, 16			; 00000010H
  0043d	83 f8 01	 cmp	 eax, 1
  00440	75 42		 jne	 SHORT $LN66@CGBuyReque

; 6962 : 				{
; 6963 : 					bNoItem = FALSE;
; 6964 : 					lpObj->Money -= iStoreTaxMoney;
; 6965 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney2);

  00442	8b 4d e4	 mov	 ecx, DWORD PTR _iStoreTaxMoney2$246717[ebp]
  00445	8b 45 dc	 mov	 eax, DWORD PTR _iStoreTaxMoney$246676[ebp]
  00448	29 83 f0 00 00
	00		 sub	 DWORD PTR [ebx+240], eax
  0044e	51		 push	 ecx
  0044f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00454	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 6966 : 
; 6967 : 					if ( lpObj->Money < 0 )

  00459	83 bb f0 00 00
	00 00		 cmp	 DWORD PTR [ebx+240], 0
  00460	7d 0a		 jge	 SHORT $LN8@CGBuyReque

; 6968 : 					{
; 6969 : 						lpObj->Money = 0;

  00462	c7 83 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+240], 0
$LN8@CGBuyReque:

; 6970 : 					}
; 6971 : 		
; 6972 : 					::GCMoneySend(aIndex, lpObj->Money);

  0046c	8b 93 f0 00 00
	00		 mov	 edx, DWORD PTR [ebx+240]
  00472	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00475	52		 push	 edx
  00476	50		 push	 eax
  00477	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0047c	83 c4 08	 add	 esp, 8

; 6973 : 				}
; 6974 : 			}
; 6975 : 
; 6976 : 			if ( bNoItem != FALSE )

  0047f	e9 9e 01 00 00	 jmp	 $LN45@CGBuyReque
$LN66@CGBuyReque:

; 6977 : 			{
; 6978 : 				pResult.Result = gObjShopBuyInventoryInsertItem(aIndex, ShopC[tShop].m_item[lpMsg->Pos]);

  00484	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00487	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0048b	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0048e	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00494	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0049a	8d b4 32 80 00
	00 00		 lea	 esi, DWORD PTR ?ShopC@@3PAVCShop@@A[edx+esi+128]
  004a1	8b fc		 mov	 edi, esp
  004a3	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  004a8	50		 push	 eax
  004a9	f3 a5		 rep movsd
  004ab	e8 00 00 00 00	 call	 ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItem
  004b0	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  004b6	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al

; 6979 : 				
; 6980 : 				if ( pResult.Result != 0xFF )

  004b9	3c ff		 cmp	 al, 255			; 000000ffH
  004bb	0f 84 61 01 00
	00		 je	 $LN45@CGBuyReque

; 6981 : 				{
; 6982 : 					ItemByteConvert((LPBYTE)&pResult.ItemInfo, ShopC[tShop].m_item[lpMsg->Pos]);

  004c1	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  004c4	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  004c8	8b 45 d0	 mov	 eax, DWORD PTR tv806[ebp]
  004cb	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  004d1	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  004d7	8d b4 02 80 00
	00 00		 lea	 esi, DWORD PTR ?ShopC@@3PAVCShop@@A[edx+eax+128]
  004de	8b fc		 mov	 edi, esp
  004e0	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  004e5	f3 a5		 rep movsd
  004e7	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp+4]
  004ea	51		 push	 ecx
  004eb	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 6983 : 					int lc64 = ShopC[tShop].m_item[lpMsg->Pos].m_BuyMoney;

  004f0	8b 55 d8	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  004f3	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]

; 6984 : 					int iTaxRate = g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index);

  004f7	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004f9	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  004ff	8b 7d d0	 mov	 edi, DWORD PTR tv806[ebp]
  00502	8b b4 38 f0 00
	00 00		 mov	 esi, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+edi+240]
  00509	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0050f	51		 push	 ecx
  00510	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00515	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore

; 6985 : #if(DONATE_SHOP==TRUE)
; 6986 : 					if(StandartShop == false)

  0051a	80 7d e3 00	 cmp	 BYTE PTR _StandartShop$246710[ebp], 0
  0051e	89 45 d4	 mov	 DWORD PTR _iTaxRate$246738[ebp], eax
  00521	75 52		 jne	 SHORT $LN5@CGBuyReque

; 6987 : 					{
; 6988 : 						if(!ShopC[tShop].BuyItemEx(aIndex,lpMsg->Pos))

  00523	8b 55 d8	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00526	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  0052a	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0052d	50		 push	 eax
  0052e	51		 push	 ecx
  0052f	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[edi]
  00535	e8 00 00 00 00	 call	 ?BuyItemEx@CShop@@QAE_NHH@Z ; CShop::BuyItemEx
  0053a	84 c0		 test	 al, al
  0053c	75 74		 jne	 SHORT $LN63@CGBuyReque

; 6989 : 						{
; 6990 : 							lpObj->Money -= iStoreTaxMoney;
; 6991 : 							::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney2);

  0053e	8b 45 e4	 mov	 eax, DWORD PTR _iStoreTaxMoney2$246717[ebp]
  00541	8b 55 dc	 mov	 edx, DWORD PTR _iStoreTaxMoney$246676[ebp]
  00544	29 93 f0 00 00
	00		 sub	 DWORD PTR [ebx+240], edx
  0054a	50		 push	 eax
  0054b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00550	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 6992 : 
; 6993 : 							if ( lpObj->Money < 0 )

  00555	83 bb f0 00 00
	00 00		 cmp	 DWORD PTR [ebx+240], 0
  0055c	7d 0a		 jge	 SHORT $LN3@CGBuyReque

; 6994 : 							{
; 6995 : 								lpObj->Money = 0;

  0055e	c7 83 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+240], 0
$LN3@CGBuyReque:

; 6996 : 							}
; 6997 : 
; 6998 : 							GCMoneySend(aIndex, lpObj->Money);

  00568	8b 8b f0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+240]
  0056e	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00571	51		 push	 ecx
  00572	52		 push	 edx

; 6999 : 						}
; 7000 : 					}
; 7001 : 					else

  00573	eb 35		 jmp	 SHORT $LN73@CGBuyReque
$LN5@CGBuyReque:

; 7002 : 					{
; 7003 : 						lpObj->Money -= iStoreTaxMoney;
; 7004 : 						::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney2);

  00575	8b 4d e4	 mov	 ecx, DWORD PTR _iStoreTaxMoney2$246717[ebp]
  00578	8b 45 dc	 mov	 eax, DWORD PTR _iStoreTaxMoney$246676[ebp]
  0057b	29 83 f0 00 00
	00		 sub	 DWORD PTR [ebx+240], eax
  00581	51		 push	 ecx
  00582	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00587	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 7005 : 
; 7006 : 						if ( lpObj->Money < 0 )

  0058c	83 bb f0 00 00
	00 00		 cmp	 DWORD PTR [ebx+240], 0
  00593	7d 0a		 jge	 SHORT $LN1@CGBuyReque

; 7007 : 						{
; 7008 : 							lpObj->Money = 0;

  00595	c7 83 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+240], 0
$LN1@CGBuyReque:

; 7009 : 						}
; 7010 : 
; 7011 : 						GCMoneySend(aIndex, lpObj->Money);

  0059f	8b 93 f0 00 00
	00		 mov	 edx, DWORD PTR [ebx+240]
  005a5	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  005a8	52		 push	 edx
  005a9	50		 push	 eax
$LN73@CGBuyReque:
  005aa	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  005af	83 c4 08	 add	 esp, 8
$LN63@CGBuyReque:

; 7012 : 					}
; 7013 : #else
; 7014 : 					lpObj->Money -= iStoreTaxMoney;
; 7015 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney2);
; 7016 : 
; 7017 : 					if ( lpObj->Money < 0 )
; 7018 : 					{
; 7019 : 						lpObj->Money = 0;
; 7020 : 					}
; 7021 : 
; 7022 : 					GCMoneySend(aIndex, lpObj->Money);
; 7023 : #endif
; 7024 : 					LogAddTD("[%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d][%d][%d]", lpObj->AccountID, lpObj->Name, tShop, lc64, iTaxRate, lc64+iStoreTaxMoney2, ShopC[tShop].m_item[lpMsg->Pos].GetName(), ShopC[tShop].m_item[lpMsg->Pos].m_Level, ShopC[tShop].m_item[lpMsg->Pos].m_Durability, ShopC[tShop].m_item[lpMsg->Pos].m_Option1, ShopC[tShop].m_item[lpMsg->Pos].m_Option2, ShopC[tShop].m_item[lpMsg->Pos].m_Option3);

  005b2	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  005b5	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  005b9	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  005bf	d9 84 38 a4 00
	00 00		 fld	 DWORD PTR ?ShopC@@3PAVCShop@@A[eax+edi+164]
  005c6	0f b6 8c 38 16
	01 00 00	 movzx	 ecx, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+edi+278]
  005ce	0f b6 94 38 15
	01 00 00	 movzx	 edx, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+edi+277]
  005d6	03 c7		 add	 eax, edi
  005d8	51		 push	 ecx
  005d9	0f b6 88 14 01
	00 00		 movzx	 ecx, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+276]
  005e0	52		 push	 edx
  005e1	0f bf 90 88 00
	00 00		 movsx	 edx, WORD PTR ?ShopC@@3PAVCShop@@A[eax+136]
  005e8	51		 push	 ecx
  005e9	83 ec 08	 sub	 esp, 8
  005ec	8d 88 80 00 00
	00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+128]
  005f2	dd 1c 24	 fstp	 QWORD PTR [esp]
  005f5	52		 push	 edx
  005f6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005fb	8b 55 d4	 mov	 edx, DWORD PTR _iTaxRate$246738[ebp]
  005fe	50		 push	 eax
  005ff	8b 45 e4	 mov	 eax, DWORD PTR _iStoreTaxMoney2$246717[ebp]
  00602	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00605	8b 45 cc	 mov	 eax, DWORD PTR _tShop$[ebp]
  00608	51		 push	 ecx
  00609	52		 push	 edx
  0060a	56		 push	 esi
  0060b	50		 push	 eax
  0060c	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0060f	51		 push	 ecx
  00610	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00613	53		 push	 ebx
  00614	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@
  00619	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0061f	83 c4 38	 add	 esp, 56			; 00000038H
$LN45@CGBuyReque:

; 6823 : 	{
; 6824 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00622	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00626	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00629	52		 push	 edx
  0062a	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  0062d	50		 push	 eax
  0062e	51		 push	 ecx
$LN71@CGBuyReque:
  0062f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7025 : 				}
; 7026 : 			}
; 7027 : 		}
; 7028 : 	}
; 7029 : 
; 7030 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7031 : }

  00634	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00637	83 c4 0c	 add	 esp, 12			; 0000000cH
  0063a	5f		 pop	 edi
  0063b	5e		 pop	 esi
  0063c	33 cd		 xor	 ecx, ebp
  0063e	5b		 pop	 ebx
  0063f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00644	8b e5		 mov	 esp, ebp
  00646	5d		 pop	 ebp
  00647	c3		 ret	 0
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ENDP	; CGBuyRequestRecv
_TEXT	ENDS
PUBLIC	??_C@_0BA@EKAJJHMP@Move?5Item?5Block?$AA@	; `string'
PUBLIC	??_C@_0BA@KMKFDPIL@Block?5Sell?5Item?$AA@	; `string'
PUBLIC	??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0DB@MDNMOJNN@?$FLWARNING?$FN?$FLMax?5Ext?5Sell?$FN?5Item?5NO?5@ ; `string'
PUBLIC	??_C@_0DF@EDDECOID@?$FLWARNING?$FN?$FLMax?5Level?5Sell?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0DB@FKPKJBDK@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@ ; `string'
PUBLIC	??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z	; CGSellRequestRecv
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?SellPriceItem@cPriceManager@@QAEXHHAAH@Z:PROC	; cPriceManager::SellPriceItem
EXTRN	?Sell@cBlockMoveItem@@QAE_NHH@Z:PROC		; cBlockMoveItem::Sell
EXTRN	?Sell@cCreditDonate@@QAE_NHHAAH@Z:PROC		; cCreditDonate::Sell
EXTRN	?gCreditDonate@@3VcCreditDonate@@A:BYTE		; gCreditDonate
EXTRN	?PetValue@CItem@@QAEXXZ:PROC			; CItem::PetValue
EXTRN	?Value@CItem@@QAEXXZ:PROC			; CItem::Value
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?IsPeriodItemZtpire@CItem@@QAE_NXZ:PROC		; CItem::IsPeriodItemZtpire
EXTRN	?GetExcOptionCount@@YAEE@Z:PROC			; GetExcOptionCount
;	COMDAT ??_C@_0BA@EKAJJHMP@Move?5Item?5Block?$AA@
CONST	SEGMENT
??_C@_0BA@EKAJJHMP@Move?5Item?5Block?$AA@ DB 'Move Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMKFDPIL@Block?5Sell?5Item?$AA@
CONST	SEGMENT
??_C@_0BA@KMKFDPIL@Block?5Sell?5Item?$AA@ DB 'Block Sell Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@
CONST	SEGMENT
??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@ DB 'ID:%s CharID:%s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MDNMOJNN@?$FLWARNING?$FN?$FLMax?5Ext?5Sell?$FN?5Item?5NO?5@
CONST	SEGMENT
??_C@_0DB@MDNMOJNN@?$FLWARNING?$FN?$FLMax?5Ext?5Sell?$FN?5Item?5NO?5@ DB '['
	DB	'WARNING][Max Ext Sell] Item NO SELL Ext >= (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EDDECOID@?$FLWARNING?$FN?$FLMax?5Level?5Sell?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0DF@EDDECOID@?$FLWARNING?$FN?$FLMax?5Level?5Sell?$FN?5Item?5N@ DB '['
	DB	'WARNING][Max Level Sell] Item NO SELL Level >= (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FKPKJBDK@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0DB@FKPKJBDK@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ DB '['
	DB	'WARNING][Serial -1 Item] Item NO SELL SERI (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@
CONST	SEGMENT
??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z
_TEXT	SEGMENT
_tShop$ = -36						; size = 4
_PlusCred$246837 = -32					; size = 4
_iAddZen$246828 = -28					; size = 4
_aIndex$GSCopy$ = -24					; size = 4
_pResult$ = -20						; size = 8
_NewOption$246827 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z PROC	; CGSellRequestRecv, COMDAT

; 7041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 7042 : 	PMSG_SELLRESULT pResult;
; 7043 : 	LPOBJ lpObj = &gObj[aIndex];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 7363 : 		}
; 7364 : 
; 7365 : 		lpObj->Money += iAddZen;

  0001e	89 7d e8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  00021	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00027	6a 08		 push	 8
  00029	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0002c	6a 33		 push	 51			; 00000033H
  0002e	51		 push	 ecx
  0002f	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]
  00032	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	c6 45 ef 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00044	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  0004b	80 7c 17 0b ff	 cmp	 BYTE PTR [edi+edx+11], -1
  00050	0f 85 b4 08 00
	00		 jne	 $LN51@CGSellRequ

; 7044 : 
; 7045 : 	PHeadSetB((LPBYTE)&pResult, 0x33, sizeof(pResult));
; 7046 : 	pResult.Result = false;
; 7047 : 	pResult.Money = 0;
; 7048 : 
; 7049 : 	if ( gObj[aIndex].CloseType != -1 )
; 7050 : 	{
; 7051 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7052 : 		return;
; 7053 : 	}
; 7054 : 
; 7055 : 	if ( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type != 3 )

  00056	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0005c	a8 03		 test	 al, 3
  0005e	76 10		 jbe	 SHORT $LN56@CGSellRequ
  00060	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00065	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H

; 7056 : 	{
; 7057 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7058 : 		return;

  0006a	0f 85 9a 08 00
	00		 jne	 $LN51@CGSellRequ
$LN56@CGSellRequ:

; 7059 : 	}
; 7060 : 
; 7061 : 	if ( !PacketCheckTime(lpObj))

  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00076	83 c4 04	 add	 esp, 4
  00079	85 c0		 test	 eax, eax

; 7062 : 	{
; 7063 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7064 : 		return;

  0007b	0f 84 89 08 00
	00		 je	 $LN51@CGSellRequ

; 7065 : 	}
; 7066 : 
; 7067 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00081	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0008a	83 c4 04	 add	 esp, 4
  0008d	84 c0		 test	 al, al
  0008f	75 18		 jne	 SHORT $LN54@CGSellRequ

; 7068 : 	{
; 7069 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00091	68 9d 1b 00 00	 push	 7069			; 00001b9dH
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@CGSellRequ:

; 7070 : 	}
; 7071 : 
; 7072 : 	if ( gObj[aIndex].pTransaction == 1 )

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ae	80 bc 07 30 0e
	00 00 01	 cmp	 BYTE PTR [edi+eax+3632], 1
  000b6	75 3a		 jne	 SHORT $LN53@CGSellRequ

; 7073 : 	{
; 7074 : 		LogAddTD("[%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYPE : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  000b8	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  000bf	c1 e9 06	 shr	 ecx, 6
  000c2	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  000c8	51		 push	 ecx
  000c9	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  000cd	52		 push	 edx
  000ce	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  000d2	50		 push	 eax
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000de	83 c4 10	 add	 esp, 16			; 00000010H
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 7389 : 	}
; 7390 : 
; 7391 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7392 : }

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e7	33 cd		 xor	 ecx, ebp
  000e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
$LN53@CGSellRequ:

; 7075 : 		return;
; 7076 : 	}
; 7077 : 
; 7078 : 	int tShop = lpObj->TargetShopNumber;

  000f2	0f bf 86 5a 04
	00 00		 movsx	 eax, WORD PTR [esi+1114]
  000f9	89 45 dc	 mov	 DWORD PTR _tShop$[ebp], eax

; 7079 : 
; 7080 : 	if ( tShop < 0 || tShop > MAX_SHOP-1 )

  000fc	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000ff	0f 87 05 08 00
	00		 ja	 $LN51@CGSellRequ

; 7083 : 		return;
; 7084 : 	}
; 7085 : 
; 7086 : 	if ( !gObjCanItemTouch(lpObj, 3))

  00105	6a 03		 push	 3
  00107	56		 push	 esi
  00108	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  0010d	83 c4 08	 add	 esp, 8
  00110	85 c0		 test	 eax, eax
  00112	75 12		 jne	 SHORT $LN50@CGSellRequ
$LN69@CGSellRequ:

; 7087 : 	{
; 7088 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00114	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00118	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0011b	51		 push	 ecx
  0011c	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  0011f	52		 push	 edx
  00120	50		 push	 eax

; 7089 : 		return;

  00121	e9 f1 07 00 00	 jmp	 $LN67@CGSellRequ
$LN50@CGSellRequ:

; 7090 : 	}
; 7091 : 
; 7092 : 	if ( lpMsg->Pos > MAIN_INVENTORY_SIZE-1 )

  00126	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  00129	3c cb		 cmp	 al, 203			; 000000cbH
  0012b	76 44		 jbe	 SHORT $LN49@CGSellRequ

; 7093 : 	{
; 7094 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0012d	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00131	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00134	51		 push	 ecx
  00135	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp]
  00138	52		 push	 edx
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7095 : 		LogAdd(lMsg.Get(MSGGET(1, 227)), lpMsg->Pos);

  0013f	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH
  00146	51		 push	 ecx
  00147	68 e3 01 00 00	 push	 483			; 000001e3H
  0014c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00151	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0015d	83 c4 08	 add	 esp, 8
  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx

; 7389 : 	}
; 7390 : 
; 7391 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7392 : }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN49@CGSellRequ:

; 7096 : 		return;
; 7097 : 	}
; 7098 : 
; 7099 : 	if ( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Pos]) != FALSE )

  00171	0f b6 d0	 movzx	 edx, al
  00174	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0017a	03 96 24 0e 00
	00		 add	 edx, DWORD PTR [esi+3620]
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00186	83 c4 04	 add	 esp, 4
  00189	85 c0		 test	 eax, eax
  0018b	74 69		 je	 SHORT $LN48@CGSellRequ

; 7100 : 	{
; 7101 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  0018d	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00192	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00197	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0019c	8b 7d e8	 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  0019f	50		 push	 eax
  001a0	57		 push	 edi
  001a1	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 7102 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001a6	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001aa	50		 push	 eax
  001ab	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001ae	51		 push	 ecx
  001af	57		 push	 edi
  001b0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7103 : 
; 7104 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%d)", lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Pos].GetName(), lpMsg->Pos);

  001b5	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  001b9	83 c4 14	 add	 esp, 20			; 00000014H
  001bc	51		 push	 ecx
  001bd	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  001c3	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  001c9	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001ce	50		 push	 eax
  001cf	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  001d2	52		 push	 edx
  001d3	83 c6 6c	 add	 esi, 108		; 0000006cH
  001d6	56		 push	 esi
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e2	83 c4 14	 add	 esp, 20			; 00000014H
  001e5	5f		 pop	 edi
  001e6	5e		 pop	 esi
  001e7	5b		 pop	 ebx

; 7389 : 	}
; 7390 : 
; 7391 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7392 : }

  001e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001eb	33 cd		 xor	 ecx, ebp
  001ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f2	8b e5		 mov	 esp, ebp
  001f4	5d		 pop	 ebp
  001f5	c3		 ret	 0
$LN48@CGSellRequ:

; 7105 : 		return;
; 7106 : 	}
; 7107 : #if(Negative_Number)
; 7108 : 	CItem* BCheckItem = &lpObj->pInventory[lpMsg->Pos];

  001f6	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  001fa	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00200	03 86 24 0e 00
	00		 add	 eax, DWORD PTR [esi+3620]

; 7109 : 	//LogAddC(1, "CGSellRequestRecv Item %s (%d)", BCheckItem->GetName(), BCheckItem->m_Number);
; 7110 : 	//==Check Seri -1
; 7111 : 	if (ZtConfig.CommonServer.MembItemLimit && (int)BCheckItem->m_Number < 0)

  00206	83 3d 50 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+336, 0
  0020d	74 38		 je	 SHORT $LN47@CGSellRequ
  0020f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00211	85 c9		 test	 ecx, ecx
  00213	79 32		 jns	 SHORT $LN47@CGSellRequ

; 7112 : 	{
; 7113 : 		//LogAddTD("[WARNING][Serial -1 Item] Item NO SELL SERI (%d)", BCheckItem->m_Number);
; 7114 : 		MsgOutput(aIndex, "[WARNING][Serial -1 Item] Item NO SELL SERI (%d)", BCheckItem->m_Number);

  00215	51		 push	 ecx
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@FKPKJBDK@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
$LN70@CGSellRequ:
  0021b	8b 75 e8	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  0021e	56		 push	 esi
  0021f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 7115 : 		DataSend(aIndex, (LPBYTE)& pResult, pResult.h.size);

  00224	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00228	50		 push	 eax
  00229	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0022c	51		 push	 ecx
$LN71@CGSellRequ:
  0022d	56		 push	 esi
$LN73@CGSellRequ:
  0022e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00233	83 c4 18	 add	 esp, 24			; 00000018H
  00236	5f		 pop	 edi
  00237	5e		 pop	 esi
  00238	5b		 pop	 ebx

; 7389 : 	}
; 7390 : 
; 7391 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7392 : }

  00239	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023c	33 cd		 xor	 ecx, ebp
  0023e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c3		 ret	 0
$LN47@CGSellRequ:

; 7116 : 		return;
; 7117 : 	}
; 7118 : 	//==Check Item Level Max
; 7119 : 	if ((int)BCheckItem->m_Level >= ZtConfig.CommonServer.NorItemLevel)

  00247	0f bf 50 08	 movsx	 edx, WORD PTR [eax+8]
  0024b	8b 0d 60 01 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+352
  00251	3b d1		 cmp	 edx, ecx
  00253	7c 08		 jl	 SHORT $LN46@CGSellRequ

; 7120 : 	{
; 7121 : 		//LogAddTD("[WARNING][Max Level Sell] Item NO SELL Level >= (%d)", ZtConfig.CommonServer.NorItemLevel);
; 7122 : 		MsgOutput(aIndex, "[WARNING][Max Level Sell] Item NO SELL Level >= (%d)", ZtConfig.CommonServer.NorItemLevel);

  00255	51		 push	 ecx
  00256	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EDDECOID@?$FLWARNING?$FN?$FLMax?5Level?5Sell?$FN?5Item?5N@

; 7123 : 		DataSend(aIndex, (LPBYTE)& pResult, pResult.h.size);
; 7124 : 		return;

  0025b	eb be		 jmp	 SHORT $LN70@CGSellRequ
$LN46@CGSellRequ:

; 7125 : 	}
; 7126 : 	//==Check Item Count Exl
; 7127 : 	if (  GetExcOptionCount(BCheckItem->m_NewOption) >= ZtConfig.CommonServer.NorItemExt)

  0025d	0f b6 90 97 00
	00 00		 movzx	 edx, BYTE PTR [eax+151]
  00264	52		 push	 edx
  00265	e8 00 00 00 00	 call	 ?GetExcOptionCount@@YAEE@Z ; GetExcOptionCount
  0026a	0f b6 c0	 movzx	 eax, al
  0026d	83 c4 04	 add	 esp, 4
  00270	3b 05 64 01 00
	00		 cmp	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+356
  00276	7c 20		 jl	 SHORT $LN45@CGSellRequ

; 7128 : 	{
; 7129 : 		//LogAddTD("[WARNING][Max Ext Sell] Item NO SELL Ext >= (%d)", ZtConfig.CommonServer.NorItemLevel);
; 7130 : 		MsgOutput(aIndex, "[WARNING][Max Ext Sell] Item NO SELL Ext >= (%d)", ZtConfig.CommonServer.NorItemLevel);

  00278	8b 0d 60 01 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+352
  0027e	8b 75 e8	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00281	51		 push	 ecx
  00282	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MDNMOJNN@?$FLWARNING?$FN?$FLMax?5Ext?5Sell?$FN?5Item?5NO?5@
  00287	56		 push	 esi
  00288	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 7131 : 		DataSend(aIndex, (LPBYTE)& pResult, pResult.h.size);

  0028d	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00291	52		 push	 edx
  00292	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00295	50		 push	 eax

; 7132 : 		return;

  00296	eb 95		 jmp	 SHORT $LN71@CGSellRequ
$LN45@CGSellRequ:

; 7133 : 	}
; 7134 : #endif
; 7135 : 
; 7136 : 
; 7137 : #ifdef ZTCLUSIVE_AMYLET
; 7138 : 	if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  00298	6a 17		 push	 23			; 00000017H
  0029a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0029f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002a4	84 c0		 test	 al, al
  002a6	75 34		 jne	 SHORT $LN43@CGSellRequ
  002a8	6a 1c		 push	 28			; 0000001cH
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002af	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002b4	84 c0		 test	 al, al
  002b6	75 24		 jne	 SHORT $LN43@CGSellRequ
  002b8	6a 00		 push	 0
  002ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002bf	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002c4	84 c0		 test	 al, al
  002c6	75 14		 jne	 SHORT $LN43@CGSellRequ
  002c8	6a 24		 push	 36			; 00000024H
  002ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002cf	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002d4	84 c0		 test	 al, al
  002d6	0f 84 a1 00 00
	00		 je	 $LN42@CGSellRequ
$LN43@CGSellRequ:

; 7139 : 	{
; 7140 : 		if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,147) ||
; 7141 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,148) ||
; 7142 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,149) ||
; 7143 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,150) ||
; 7144 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,151) ||
; 7145 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,152) ||
; 7146 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,153) ||
; 7147 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,154) ||
; 7148 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,155) ||
; 7149 : 			lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,156)
; 7150 : 			)

  002dc	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  002e0	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  002e6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  002ec	0f b7 44 11 06	 movzx	 eax, WORD PTR [ecx+edx+6]
  002f1	b9 93 1a 00 00	 mov	 ecx, 6803		; 00001a93H
  002f6	66 3b c1	 cmp	 ax, cx
  002f9	0f 84 0b 06 00
	00		 je	 $LN51@CGSellRequ
  002ff	ba 94 1a 00 00	 mov	 edx, 6804		; 00001a94H
  00304	66 3b c2	 cmp	 ax, dx
  00307	0f 84 fd 05 00
	00		 je	 $LN51@CGSellRequ
  0030d	b9 95 1a 00 00	 mov	 ecx, 6805		; 00001a95H
  00312	66 3b c1	 cmp	 ax, cx
  00315	0f 84 ef 05 00
	00		 je	 $LN51@CGSellRequ
  0031b	ba 96 1a 00 00	 mov	 edx, 6806		; 00001a96H
  00320	66 3b c2	 cmp	 ax, dx
  00323	0f 84 e1 05 00
	00		 je	 $LN51@CGSellRequ
  00329	b9 97 1a 00 00	 mov	 ecx, 6807		; 00001a97H
  0032e	66 3b c1	 cmp	 ax, cx
  00331	0f 84 d3 05 00
	00		 je	 $LN51@CGSellRequ
  00337	ba 98 1a 00 00	 mov	 edx, 6808		; 00001a98H
  0033c	66 3b c2	 cmp	 ax, dx
  0033f	0f 84 c5 05 00
	00		 je	 $LN51@CGSellRequ
  00345	b9 99 1a 00 00	 mov	 ecx, 6809		; 00001a99H
  0034a	66 3b c1	 cmp	 ax, cx
  0034d	0f 84 b7 05 00
	00		 je	 $LN51@CGSellRequ
  00353	ba 9a 1a 00 00	 mov	 edx, 6810		; 00001a9aH
  00358	66 3b c2	 cmp	 ax, dx
  0035b	0f 84 a9 05 00
	00		 je	 $LN51@CGSellRequ
  00361	b9 9b 1a 00 00	 mov	 ecx, 6811		; 00001a9bH
  00366	66 3b c1	 cmp	 ax, cx
  00369	0f 84 9b 05 00
	00		 je	 $LN51@CGSellRequ
  0036f	ba 9c 1a 00 00	 mov	 edx, 6812		; 00001a9cH
  00374	66 3b c2	 cmp	 ax, dx
  00377	0f 84 8d 05 00
	00		 je	 $LN51@CGSellRequ
$LN42@CGSellRequ:

; 7151 : 		{
; 7152 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7153 : 			return;
; 7154 : 		}
; 7155 : 	}
; 7156 : #endif
; 7157 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,11) )

  0037d	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00381	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00387	03 86 24 0e 00
	00		 add	 eax, DWORD PTR [esi+3620]
  0038d	ba 0b 1c 00 00	 mov	 edx, 7179		; 00001c0bH
  00392	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00396	66 3b ca	 cmp	 cx, dx

; 7158 : 	{
; 7159 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7160 : 		return;

  00399	0f 84 6b 05 00
	00		 je	 $LN51@CGSellRequ

; 7161 : 	}
; 7162 : 	//if ( ItemMoveBlockExlOpt(lpObj->pInventory[lpMsg->Pos].m_NewOption) == FALSE )
; 7163 : 	//if(gBlockMoveIteml.Sell(aIndex, lpMsg->Pos) == false)
; 7164 : 	//{
; 7165 : 	//	GCServerMsgStringSend("Move Item Block",lpObj->m_Index,1);
; 7166 : 	//	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7167 : 	//	return;
; 7168 : 	//}
; 7169 : 
; 7170 : 	//season4 removed
; 7171 : 	/*if(lpMsg->Pos >= 0 && lpMsg->Pos < 12?TRUE:FALSE) //Season 3.5 add-on (Must unwear item first and later sell it)
; 7172 : 	{
; 7173 : 		pResult.Result = 0xFF;
; 7174 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7175 : 		return;
; 7176 : 	}*/
; 7177 : 
; 7178 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Pos].m_Level == 1)

  0039f	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  003a4	66 3b ca	 cmp	 cx, dx
  003a7	75 1b		 jne	 SHORT $LN38@CGSellRequ
  003a9	66 83 78 08 01	 cmp	 WORD PTR [eax+8], 1

; 7179 : 	{
; 7180 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7181 : 		return;

  003ae	0f 84 56 05 00
	00		 je	 $LN51@CGSellRequ

; 7182 : 	}
; 7183 : 
; 7184 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Pos].m_Level == 2)

  003b4	66 3b ca	 cmp	 cx, dx
  003b7	75 0b		 jne	 SHORT $LN38@CGSellRequ
  003b9	66 83 78 08 02	 cmp	 WORD PTR [eax+8], 2

; 7185 : 	{
; 7186 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7187 : 		return;

  003be	0f 84 46 05 00
	00		 je	 $LN51@CGSellRequ
$LN38@CGSellRequ:

; 7188 : 	}
; 7189 : 
; 7190 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(12,26) &&
; 7191 : 		(lpObj->pInventory[lpMsg->Pos].m_Level == 1 ||
; 7192 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 2 || 
; 7193 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 3 || 
; 7194 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 4 || 
; 7195 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 5 ))

  003c4	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  003c9	66 3b ca	 cmp	 cx, dx
  003cc	75 57		 jne	 SHORT $LN66@CGSellRequ
  003ce	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  003d2	66 83 f8 01	 cmp	 ax, 1
  003d6	74 18		 je	 SHORT $LN36@CGSellRequ
  003d8	66 83 f8 02	 cmp	 ax, 2
  003dc	74 12		 je	 SHORT $LN36@CGSellRequ
  003de	66 83 f8 03	 cmp	 ax, 3
  003e2	74 0c		 je	 SHORT $LN36@CGSellRequ
  003e4	66 83 f8 04	 cmp	 ax, 4
  003e8	74 06		 je	 SHORT $LN36@CGSellRequ
  003ea	66 83 f8 05	 cmp	 ax, 5
  003ee	75 35		 jne	 SHORT $LN66@CGSellRequ
$LN36@CGSellRequ:

; 7196 : 	{
; 7197 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003f0	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003f4	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  003f7	50		 push	 eax
  003f8	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  003fb	51		 push	 ecx
  003fc	52		 push	 edx
  003fd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7198 : 		GCServerMsgStringSend("Move Amulet Block",lpObj->m_Index,1);

  00402	8b 06		 mov	 eax, DWORD PTR [esi]
  00404	6a 01		 push	 1
  00406	50		 push	 eax
  00407	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IGBLPOFO@Move?5Amulet?5Block?$AA@
  0040c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00411	83 c4 18	 add	 esp, 24			; 00000018H
  00414	5f		 pop	 edi
  00415	5e		 pop	 esi
  00416	5b		 pop	 ebx

; 7389 : 	}
; 7390 : 
; 7391 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7392 : }

  00417	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041a	33 cd		 xor	 ecx, ebp
  0041c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00421	8b e5		 mov	 esp, ebp
  00423	5d		 pop	 ebp
  00424	c3		 ret	 0
$LN66@CGSellRequ:

; 7199 : 		return;
; 7200 : 	}
; 7201 : 
; 7202 : #ifdef LUCKYITEM
; 7203 : 	if( g_LuckyItemManager.IsLuckyItemTicket(lpObj->pInventory[lpMsg->Pos].m_Type) 
; 7204 : 		|| g_LuckyItemManager.IsLuckyItemEquipment(lpObj->pInventory[lpMsg->Pos].m_Type)
; 7205 : 		|| lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14, 160) || lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14, 161) )

  00425	0f bf c9	 movsx	 ecx, cx
  00428	51		 push	 ecx
  00429	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  0042e	e8 00 00 00 00	 call	 ?IsLuckyItemTicket@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemTicket
  00433	85 c0		 test	 eax, eax
  00435	0f 85 cf 04 00
	00		 jne	 $LN51@CGSellRequ
  0043b	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  0043f	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  00445	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0044b	0f bf 4c 02 06	 movsx	 ecx, WORD PTR [edx+eax+6]
  00450	51		 push	 ecx
  00451	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  00456	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  0045b	85 c0		 test	 eax, eax
  0045d	0f 85 a7 04 00
	00		 jne	 $LN51@CGSellRequ
  00463	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00467	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0046d	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  00473	ba a0 1c 00 00	 mov	 edx, 7328		; 00001ca0H
  00478	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0047c	66 3b c2	 cmp	 ax, dx
  0047f	0f 84 85 04 00
	00		 je	 $LN51@CGSellRequ
  00485	ba a1 1c 00 00	 mov	 edx, 7329		; 00001ca1H
  0048a	66 3b c2	 cmp	 ax, dx
  0048d	0f 84 77 04 00
	00		 je	 $LN51@CGSellRequ

; 7206 : 	{
; 7207 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7208 : 		return;
; 7209 : 	}
; 7210 : #endif
; 7211 : 
; 7212 : #ifdef PERIOD
; 7213 : 	if( lpObj->pInventory[lpMsg->Pos].IsPeriodItem() && !lpObj->pInventory[lpMsg->Pos].IsPeriodItemZtpire() )

  00493	e8 00 00 00 00	 call	 ?IsPeriodItem@CItem@@QAE_NXZ ; CItem::IsPeriodItem
  00498	84 c0		 test	 al, al
  0049a	74 1d		 je	 SHORT $LN33@CGSellRequ
  0049c	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  004a0	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  004a6	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  004ac	e8 00 00 00 00	 call	 ?IsPeriodItemZtpire@CItem@@QAE_NXZ ; CItem::IsPeriodItemZtpire
  004b1	84 c0		 test	 al, al

; 7214 : 	{
; 7215 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7216 : 		return;

  004b3	0f 84 51 04 00
	00		 je	 $LN51@CGSellRequ
$LN33@CGSellRequ:

; 7217 : 	}
; 7218 : #endif
; 7219 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(&lpObj->pInventory[lpMsg->Pos]) == TRUE )

  004b9	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  004bd	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  004c3	03 86 24 0e 00
	00		 add	 eax, DWORD PTR [esi+3620]
  004c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  004d4	83 f8 01	 cmp	 eax, 1
  004d7	75 2b		 jne	 SHORT $LN32@CGSellRequ

; 7220 : 	{
; 7221 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 37)), lpObj->m_Index, 1);

  004d9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  004db	50		 push	 eax
  004dc	51		 push	 ecx
  004dd	68 25 0d 00 00	 push	 3365			; 00000d25H
  004e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004e7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004ec	50		 push	 eax
$LN74@CGSellRequ:
  004ed	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7222 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  004f2	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  004f6	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  004f9	52		 push	 edx
  004fa	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  004fd	50		 push	 eax
  004fe	51		 push	 ecx

; 7223 : 		return;

  004ff	e9 2a fd ff ff	 jmp	 $LN73@CGSellRequ
$LN32@CGSellRequ:

; 7224 : 	}
; 7225 : #ifdef OLDCASHSHOP
; 7226 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Pos].m_Type) == TRUE )
; 7227 : 	{
; 7228 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7229 : 		return;
; 7230 : 	}
; 7231 : 
; 7232 : 	if ( CanItemTouchCash(lpObj->pInventory[lpMsg->Pos].m_Type) == TRUE ) //season4 add-on
; 7233 : 	{
; 7234 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7235 : 		return;
; 7236 : 	}
; 7237 : 
; 7238 : #endif
; 7239 : 
; 7240 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,12) && lpObj->pInventory[lpMsg->Pos].m_Level == 1) // Heart+1

  00504	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00508	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0050e	8b d0		 mov	 edx, eax
  00510	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00516	03 ca		 add	 ecx, edx
  00518	ba 0c 1c 00 00	 mov	 edx, 7180		; 00001c0cH
  0051d	66 39 51 06	 cmp	 WORD PTR [ecx+6], dx
  00521	75 4a		 jne	 SHORT $LN31@CGSellRequ
  00523	66 83 79 08 01	 cmp	 WORD PTR [ecx+8], 1
  00528	75 43		 jne	 SHORT $LN31@CGSellRequ

; 7241 : 	{
; 7242 : 		pResult.Result = true;
; 7243 : 		pResult.Money = lpObj->Money;
; 7244 : 		gObjInventoryItemSet(aIndex, lpMsg->Pos, -1);

  0052a	8b 7d e8	 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  0052d	68 ff 00 00 00	 push	 255			; 000000ffH
  00532	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00536	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  0053c	50		 push	 eax
  0053d	57		 push	 edi
  0053e	89 4d f0	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  00541	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 7245 : 		lpObj->pInventory[lpMsg->Pos].Clear();

  00546	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  0054a	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00550	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  00556	83 c4 0c	 add	 esp, 12			; 0000000cH
  00559	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7246 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0055e	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00562	52		 push	 edx
  00563	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00566	50		 push	 eax
  00567	57		 push	 edi

; 7247 : 		return;

  00568	e9 aa 03 00 00	 jmp	 $LN67@CGSellRequ
$LN31@CGSellRequ:

; 7248 : 	}
; 7249 : 
; 7250 : 	if ( lpObj->pInventory[lpMsg->Pos].IsItem() == FALSE )

  0056d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00572	85 c0		 test	 eax, eax
  00574	75 5f		 jne	 SHORT $LN30@CGSellRequ

; 7251 : 	{
; 7252 : 		pResult.Result = false;
; 7253 : 		pResult.Money = lpObj->Money;
; 7254 : 		LogAdd(lMsg.Get(MSGGET(1, 228)), __FILE__, __LINE__, lpObj->Name, lpMsg->Pos);

  00576	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  0057a	52		 push	 edx
  0057b	8d 7e 77	 lea	 edi, DWORD PTR [esi+119]
  0057e	57		 push	 edi
  0057f	68 56 1c 00 00	 push	 7254			; 00001c56H
  00584	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al
  00587	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  0058d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00592	89 4d f0	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  00595	68 e4 01 00 00	 push	 484			; 000001e4H
  0059a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0059f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  005a4	50		 push	 eax
  005a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 7255 : 		LogAdd("ID:%s CharID:%s ", lpObj->AccountID, lpObj->Name);

  005ab	57		 push	 edi
  005ac	83 c6 6c	 add	 esi, 108		; 0000006cH
  005af	56		 push	 esi
  005b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@
  005b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 7256 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005bb	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005bf	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  005c2	50		 push	 eax
  005c3	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  005c6	51		 push	 ecx
  005c7	52		 push	 edx
  005c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005cd	83 c4 2c	 add	 esp, 44			; 0000002cH

; 7257 : 
; 7258 : 	}
; 7259 : 	else

  005d0	e9 35 03 00 00	 jmp	 $LN51@CGSellRequ
$LN30@CGSellRequ:

; 7260 : 	{
; 7261 : #if(CUSTOM_ACCOUNT_SECURITY)
; 7262 : 		if(g_AccountSecurity.CheckInventory(lpObj->m_Index) == false)

  005d5	8b 06		 mov	 eax, DWORD PTR [esi]
  005d7	50		 push	 eax
  005d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  005dd	e8 00 00 00 00	 call	 ?CheckInventory@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckInventory
  005e2	84 c0		 test	 al, al

; 7263 : 		{
; 7264 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7265 : 			return;

  005e4	0f 84 2a fb ff
	ff		 je	 $LN69@CGSellRequ

; 7266 : 		}
; 7267 : #endif
; 7268 : 
; 7269 : #if(CUSTOM_ITEM_MOVE)
; 7270 : 	if(g_ItemMove.CheckDrop(lpObj->pInventory[lpMsg->Pos].m_Type))

  005ea	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  005ee	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  005f4	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  005fa	0f bf 44 11 06	 movsx	 eax, WORD PTR [ecx+edx+6]
  005ff	50		 push	 eax
  00600	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMove@@3VCItemMove@@A ; g_ItemMove
  00605	e8 00 00 00 00	 call	 ?CheckDrop@CItemMove@@QAE_NH@Z ; CItemMove::CheckDrop
  0060a	84 c0		 test	 al, al
  0060c	74 0f		 je	 SHORT $LN27@CGSellRequ

; 7271 : 	{
; 7272 : 		GCServerMsgStringSend("Block Sell Item",lpObj->m_Index,1);

  0060e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00610	6a 01		 push	 1
  00612	51		 push	 ecx
  00613	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KMKFDPIL@Block?5Sell?5Item?$AA@

; 7273 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7274 : 		return;

  00618	e9 d0 fe ff ff	 jmp	 $LN74@CGSellRequ
$LN27@CGSellRequ:

; 7275 : 	}
; 7276 : #endif
; 7277 : 
; 7278 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 7279 : 		int iAddZen = 0;
; 7280 : 		int type = lpObj->pInventory[lpMsg->Pos].m_Type;

  0061d	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00621	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00627	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  0062d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iAddZen$246828[ebp], 0
  00634	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]

; 7281 : 
; 7282 : 		if ( type == ITEMGET(13,4) || type == ITEMGET(13,5))

  00638	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  0063d	74 0e		 je	 SHORT $LN25@CGSellRequ
  0063f	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  00644	74 07		 je	 SHORT $LN25@CGSellRequ

; 7285 : 		}
; 7286 : 		else
; 7287 : 		{
; 7288 : 			lpObj->pInventory[lpMsg->Pos].Value();

  00646	e8 00 00 00 00	 call	 ?Value@CItem@@QAEXXZ	; CItem::Value
  0064b	eb 05		 jmp	 SHORT $LN24@CGSellRequ
$LN25@CGSellRequ:

; 7283 : 		{
; 7284 : 			lpObj->pInventory[lpMsg->Pos].PetValue();

  0064d	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue
$LN24@CGSellRequ:

; 7289 : 		}
; 7290 : 
; 7291 : 		iAddZen = lpObj->pInventory[lpMsg->Pos].m_SellMoney;

  00652	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00656	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]

; 7292 : 
; 7293 : 		if(!gCreditDonate.Sell(aIndex,lpMsg->Pos,iAddZen))

  0065c	8b 7d e8	 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  0065f	8b c8		 mov	 ecx, eax
  00661	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00667	8b 4c 11 6c	 mov	 ecx, DWORD PTR [ecx+edx+108]
  0066b	8d 55 e4	 lea	 edx, DWORD PTR _iAddZen$246828[ebp]
  0066e	52		 push	 edx
  0066f	50		 push	 eax
  00670	89 4d e4	 mov	 DWORD PTR _iAddZen$246828[ebp], ecx
  00673	57		 push	 edi
  00674	b9 00 00 00 00	 mov	 ecx, OFFSET ?gCreditDonate@@3VcCreditDonate@@A ; gCreditDonate
  00679	e8 00 00 00 00	 call	 ?Sell@cCreditDonate@@QAE_NHHAAH@Z ; cCreditDonate::Sell
  0067e	84 c0		 test	 al, al
  00680	75 32		 jne	 SHORT $LN22@CGSellRequ

; 7294 : 		{
; 7295 : 			if(gBlockMoveIteml.Sell(aIndex, lpMsg->Pos) == false)

  00682	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00686	50		 push	 eax
  00687	57		 push	 edi
  00688	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBlockMoveIteml@@3VcBlockMoveItem@@A ; gBlockMoveIteml
  0068d	e8 00 00 00 00	 call	 ?Sell@cBlockMoveItem@@QAE_NHH@Z ; cBlockMoveItem::Sell
  00692	84 c0		 test	 al, al
  00694	75 1e		 jne	 SHORT $LN22@CGSellRequ

; 7296 : 			{
; 7297 : 				GCServerMsgStringSend("Move Item Block",lpObj->m_Index,1);

  00696	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00698	6a 01		 push	 1
  0069a	51		 push	 ecx
  0069b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EKAJJHMP@Move?5Item?5Block?$AA@
  006a0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7298 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  006a5	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  006a9	52		 push	 edx
  006aa	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  006ad	50		 push	 eax
  006ae	57		 push	 edi

; 7299 : 				return;

  006af	e9 7a fb ff ff	 jmp	 $LN73@CGSellRequ
$LN22@CGSellRequ:

; 7300 : 			}
; 7301 : 		}
; 7302 : 
; 7303 : #ifdef _PRICE_MANAGER_
; 7304 : 		PriceManager.SellPriceItem(aIndex,lpMsg->Pos,iAddZen);

  006b4	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  006b8	8d 4d e4	 lea	 ecx, DWORD PTR _iAddZen$246828[ebp]
  006bb	51		 push	 ecx
  006bc	52		 push	 edx
  006bd	57		 push	 edi
  006be	b9 00 00 00 00	 mov	 ecx, OFFSET ?PriceManager@@3VcPriceManager@@A ; PriceManager
  006c3	e8 00 00 00 00	 call	 ?SellPriceItem@cPriceManager@@QAEXHHAAH@Z ; cPriceManager::SellPriceItem

; 7305 : #endif
; 7306 : 
; 7307 : #if(_CR_COIN_==1)
; 7308 : 		int PlusCred = 0;
; 7309 : 		if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,215))

  006c8	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  006cc	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  006d2	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  006d8	0f b7 44 08 06	 movzx	 eax, WORD PTR [eax+ecx+6]
  006dd	ba d7 1c 00 00	 mov	 edx, 7383		; 00001cd7H
  006e2	66 3b c2	 cmp	 ax, dx
  006e5	75 09		 jne	 SHORT $LN21@CGSellRequ

; 7310 : 		{
; 7311 : 			PlusCred++;

  006e7	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _PlusCred$246837[ebp], 1
  006ee	eb 5d		 jmp	 SHORT $LN60@CGSellRequ
$LN21@CGSellRequ:

; 7312 : 		}
; 7313 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,216))

  006f0	ba d8 1c 00 00	 mov	 edx, 7384		; 00001cd8H
  006f5	66 3b c2	 cmp	 ax, dx
  006f8	75 09		 jne	 SHORT $LN19@CGSellRequ

; 7314 : 		{
; 7315 : 			PlusCred += 5;

  006fa	c7 45 e0 05 00
	00 00		 mov	 DWORD PTR _PlusCred$246837[ebp], 5
  00701	eb 4a		 jmp	 SHORT $LN60@CGSellRequ
$LN19@CGSellRequ:

; 7316 : 		}
; 7317 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,217))

  00703	ba d9 1c 00 00	 mov	 edx, 7385		; 00001cd9H
  00708	66 3b c2	 cmp	 ax, dx
  0070b	75 09		 jne	 SHORT $LN17@CGSellRequ

; 7318 : 		{
; 7319 : 			PlusCred += 10;

  0070d	c7 45 e0 0a 00
	00 00		 mov	 DWORD PTR _PlusCred$246837[ebp], 10 ; 0000000aH
  00714	eb 37		 jmp	 SHORT $LN60@CGSellRequ
$LN17@CGSellRequ:

; 7320 : 		}
; 7321 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,218))

  00716	ba da 1c 00 00	 mov	 edx, 7386		; 00001cdaH
  0071b	66 3b c2	 cmp	 ax, dx
  0071e	75 09		 jne	 SHORT $LN15@CGSellRequ

; 7322 : 		{
; 7323 : 			PlusCred += 20;

  00720	c7 45 e0 14 00
	00 00		 mov	 DWORD PTR _PlusCred$246837[ebp], 20 ; 00000014H
  00727	eb 24		 jmp	 SHORT $LN60@CGSellRequ
$LN15@CGSellRequ:

; 7324 : 		}
; 7325 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,219))

  00729	ba db 1c 00 00	 mov	 edx, 7387		; 00001cdbH
  0072e	66 3b c2	 cmp	 ax, dx
  00731	75 09		 jne	 SHORT $LN13@CGSellRequ

; 7326 : 		{
; 7327 : 			PlusCred += 50;

  00733	c7 45 e0 32 00
	00 00		 mov	 DWORD PTR _PlusCred$246837[ebp], 50 ; 00000032H
  0073a	eb 11		 jmp	 SHORT $LN60@CGSellRequ
$LN13@CGSellRequ:

; 7328 : 		}
; 7329 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,220))

  0073c	ba dc 1c 00 00	 mov	 edx, 7388		; 00001cdcH
  00741	66 3b c2	 cmp	 ax, dx
  00744	75 1d		 jne	 SHORT $LN62@CGSellRequ

; 7330 : 		{
; 7331 : 			PlusCred += 100;

  00746	c7 45 e0 64 00
	00 00		 mov	 DWORD PTR _PlusCred$246837[ebp], 100 ; 00000064H
$LN60@CGSellRequ:

; 7332 : 		}
; 7333 : 		if(PlusCred>0)
; 7334 : 		{
; 7335 : 			iAddZen = 0;
; 7336 : 			lpObj->ZtCred += PlusCred;

  0074d	db 45 e0	 fild	 DWORD PTR _PlusCred$246837[ebp]
  00750	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iAddZen$246828[ebp], 0
  00757	d8 86 a8 22 00
	00		 fadd	 DWORD PTR [esi+8872]
  0075d	d9 9e a8 22 00
	00		 fstp	 DWORD PTR [esi+8872]
$LN62@CGSellRequ:

; 7337 : 		}
; 7338 : #endif
; 7339 : #if(_ZEN_COIN_==1)
; 7340 : 		int PlusZen = 0;
; 7341 : 		if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,221))

  00763	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00767	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0076d	0f b7 44 08 06	 movzx	 eax, WORD PTR [eax+ecx+6]
  00772	b9 dd 1c 00 00	 mov	 ecx, 7389		; 00001cddH
  00777	66 3b c1	 cmp	 ax, cx
  0077a	75 07		 jne	 SHORT $LN9@CGSellRequ

; 7342 : 		{
; 7343 : 			PlusZen += 100000000;

  0077c	b8 00 e1 f5 05	 mov	 eax, 100000000		; 05f5e100H
  00781	eb 20		 jmp	 SHORT $LN61@CGSellRequ
$LN9@CGSellRequ:

; 7344 : 		}
; 7345 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,222))

  00783	ba de 1c 00 00	 mov	 edx, 7390		; 00001cdeH
  00788	66 3b c2	 cmp	 ax, dx
  0078b	75 07		 jne	 SHORT $LN7@CGSellRequ

; 7346 : 		{
; 7347 : 			PlusZen += 500000000;

  0078d	b8 00 65 cd 1d	 mov	 eax, 500000000		; 1dcd6500H
  00792	eb 0f		 jmp	 SHORT $LN61@CGSellRequ
$LN7@CGSellRequ:

; 7348 : 		}
; 7349 : 		else if(lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,223))

  00794	b9 df 1c 00 00	 mov	 ecx, 7391		; 00001cdfH
  00799	66 3b c1	 cmp	 ax, cx
  0079c	75 08		 jne	 SHORT $LN65@CGSellRequ

; 7350 : 		{
; 7351 : 			PlusZen += 1000000000;

  0079e	b8 00 ca 9a 3b	 mov	 eax, 1000000000		; 3b9aca00H
$LN61@CGSellRequ:

; 7352 : 		}
; 7353 : 		if(PlusZen>0)
; 7354 : 		{
; 7355 : 			iAddZen = PlusZen;

  007a3	89 45 e4	 mov	 DWORD PTR _iAddZen$246828[ebp], eax
$LN65@CGSellRequ:

; 7356 : 		}
; 7357 : #endif
; 7358 : 
; 7359 : 		if ( gObjCheckMaxZen(aIndex, iAddZen) == FALSE )

  007a6	8b 55 e4	 mov	 edx, DWORD PTR _iAddZen$246828[ebp]
  007a9	52		 push	 edx
  007aa	57		 push	 edi
  007ab	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  007b0	83 c4 08	 add	 esp, 8
  007b3	85 c0		 test	 eax, eax
  007b5	75 0f		 jne	 SHORT $LN3@CGSellRequ

; 7360 : 		{
; 7361 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  007b7	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  007bb	50		 push	 eax
  007bc	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  007bf	51		 push	 ecx
  007c0	57		 push	 edi

; 7362 : 			return;

  007c1	e9 51 01 00 00	 jmp	 $LN67@CGSellRequ
$LN3@CGSellRequ:

; 7363 : 		}
; 7364 : 
; 7365 : 		lpObj->Money += iAddZen;

  007c6	8b 55 e4	 mov	 edx, DWORD PTR _iAddZen$246828[ebp]
  007c9	01 96 f0 00 00
	00		 add	 DWORD PTR [esi+240], edx

; 7366 : 		pResult.Result =true;
; 7367 : 		pResult.Money = lpObj->Money;
; 7368 : 
; 7369 : 		ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Pos]);

  007cf	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  007d3	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  007d9	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  007dd	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  007e3	89 45 f0	 mov	 DWORD PTR _pResult$[ebp+4], eax
  007e6	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  007ec	8d 55 f4	 lea	 edx, DWORD PTR _NewOption$246827[ebp]
  007ef	51		 push	 ecx
  007f0	52		 push	 edx
  007f1	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 7370 : 
; 7371 : 		LogAddTD(lMsg.Get(MSGGET(1, 229)), lpObj->AccountID, lpObj->Name, tShop,
; 7372 : 			iAddZen, lpObj->pInventory[lpMsg->Pos].GetName(), 
; 7373 : 			lpObj->pInventory[lpMsg->Pos].m_Level, lpObj->pInventory[lpMsg->Pos].m_Option1,
; 7374 : 			lpObj->pInventory[lpMsg->Pos].m_Option2, lpObj->pInventory[lpMsg->Pos].m_Option3,
; 7375 : 			lpObj->pInventory[lpMsg->Pos].m_Number, (int)lpObj->pInventory[lpMsg->Pos].m_Durability,
; 7376 : 			NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], 
; 7377 : 			lpObj->pInventory[lpMsg->Pos].m_SetOption, lpObj->pInventory[lpMsg->Pos].m_ItemOptionEx >> 7, //season 2.5 add-on
; 7378 : 			g_kJewelOfHarmonySystem.GetItemStrengthenOption(&lpObj->pInventory[lpMsg->Pos]),
; 7379 : 			g_kJewelOfHarmonySystem.GetItemOptionLevel(&lpObj->pInventory[lpMsg->Pos]));

  007f6	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  007fa	0f b6 7b 03	 movzx	 edi, BYTE PTR [ebx+3]
  007fe	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00804	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0080a	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00810	03 d1		 add	 edx, ecx
  00812	83 c4 08	 add	 esp, 8
  00815	03 f9		 add	 edi, ecx
  00817	52		 push	 edx
  00818	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0081d	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  00822	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00826	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0082c	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  00832	0f b6 c0	 movzx	 eax, al
  00835	50		 push	 eax
  00836	51		 push	 ecx
  00837	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0083c	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  00841	0f b6 8f ae 00
	00 00		 movzx	 ecx, BYTE PTR [edi+174]
  00848	d9 47 24	 fld	 DWORD PTR [edi+36]
  0084b	0f b6 d0	 movzx	 edx, al
  0084e	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  00855	52		 push	 edx
  00856	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$246827[ebp+6]
  0085a	c1 e8 07	 shr	 eax, 7
  0085d	50		 push	 eax
  0085e	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$246827[ebp+5]
  00862	51		 push	 ecx
  00863	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$246827[ebp+4]
  00867	52		 push	 edx
  00868	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$246827[ebp+3]
  0086c	50		 push	 eax
  0086d	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$246827[ebp+2]
  00871	51		 push	 ecx
  00872	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$246827[ebp+1]
  00876	52		 push	 edx
  00877	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$246827[ebp]
  0087b	50		 push	 eax
  0087c	51		 push	 ecx
  0087d	52		 push	 edx
  0087e	e8 00 00 00 00	 call	 __ftol2_sse
  00883	0f b6 8f 96 00
	00 00		 movzx	 ecx, BYTE PTR [edi+150]
  0088a	0f b6 97 95 00
	00 00		 movzx	 edx, BYTE PTR [edi+149]
  00891	50		 push	 eax
  00892	8b 07		 mov	 eax, DWORD PTR [edi]
  00894	50		 push	 eax
  00895	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  0089c	51		 push	 ecx
  0089d	0f bf 4f 08	 movsx	 ecx, WORD PTR [edi+8]
  008a1	52		 push	 edx
  008a2	50		 push	 eax
  008a3	51		 push	 ecx
  008a4	8b cf		 mov	 ecx, edi
  008a6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  008ab	8b 55 e4	 mov	 edx, DWORD PTR _iAddZen$246828[ebp]
  008ae	50		 push	 eax
  008af	8b 45 dc	 mov	 eax, DWORD PTR _tShop$[ebp]
  008b2	52		 push	 edx
  008b3	50		 push	 eax
  008b4	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  008b7	51		 push	 ecx
  008b8	83 c6 6c	 add	 esi, 108		; 0000006cH
  008bb	56		 push	 esi
  008bc	68 e5 01 00 00	 push	 485			; 000001e5H
  008c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  008c6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  008cb	50		 push	 eax
  008cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7380 : 
; 7381 : 		::gObjInventoryDeleteItem(aIndex, lpMsg->Pos);

  008d2	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  008d6	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  008d9	52		 push	 edx
  008da	50		 push	 eax
  008db	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 7382 : 
; 7383 : 		if ( lpMsg->Pos == 10 || lpMsg->Pos == 11 )

  008e0	8a 5b 03	 mov	 bl, BYTE PTR [ebx+3]
  008e3	83 c4 64	 add	 esp, 100		; 00000064H
  008e6	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  008e9	74 05		 je	 SHORT $LN1@CGSellRequ
  008eb	80 fb 0b	 cmp	 bl, 11			; 0000000bH
  008ee	75 0e		 jne	 SHORT $LN63@CGSellRequ
$LN1@CGSellRequ:

; 7384 : 		{
; 7385 : 			::gObjUseSkill.SkillChangeUse(aIndex);

  008f0	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  008f3	51		 push	 ecx
  008f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  008f9	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN63@CGSellRequ:

; 7386 : 		}
; 7387 : 
; 7388 : 		::gObjMakePreviewCharSet(aIndex);

  008fe	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00901	52		 push	 edx
  00902	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  00907	83 c4 04	 add	 esp, 4
$LN51@CGSellRequ:

; 7081 : 	{
; 7082 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0090a	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0090e	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00911	50		 push	 eax
  00912	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00915	51		 push	 ecx
  00916	52		 push	 edx
$LN67@CGSellRequ:
  00917	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 7389 : 	}
; 7390 : 
; 7391 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7392 : }

  0091c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00922	5f		 pop	 edi
  00923	5e		 pop	 esi
  00924	33 cd		 xor	 ecx, ebp
  00926	5b		 pop	 ebx
  00927	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0092c	8b e5		 mov	 esp, ebp
  0092e	5d		 pop	 ebp
  0092f	c3		 ret	 0
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ENDP	; CGSellRequestRecv
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z	; GetNeedMoneyItemDurRepaire
EXTRN	?GetAllRepairItemRate@@YAMH@Z:PROC		; GetAllRepairItemRate
EXTRN	?HasItemDurability@@YAHH@Z:PROC			; HasItemDurability
EXTRN	__CIsqrt:PROC
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z
_TEXT	SEGMENT
tv256 = -16						; size = 8
_lc6$246875 = -8					; size = 4
_ItemDurability$ = -4					; size = 4
tv234 = 8						; size = 4
tv231 = 8						; size = 4
tv228 = 8						; size = 4
tv225 = 8						; size = 4
_lc7$246876 = 8						; size = 4
_lc4$246872 = 8						; size = 4
_lc5$246873 = 8						; size = 4
_DurItem$ = 8						; size = 4
_RequestPos$ = 12					; size = 4
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z PROC	; GetNeedMoneyItemDurRepaire, COMDAT

; 7395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 7396 : 	int iMoney = 0;
; 7397 : 	int type = DurItem->m_Type;

  00007	8b 75 08	 mov	 esi, DWORD PTR _DurItem$[ebp]

; 7398 : 	float ItemDurability = DurItem->m_Durability;

  0000a	d9 46 24	 fld	 DWORD PTR [esi+36]
  0000d	57		 push	 edi
  0000e	0f bf 7e 06	 movsx	 edi, WORD PTR [esi+6]
  00012	d9 5d fc	 fstp	 DWORD PTR _ItemDurability$[ebp]

; 7399 : 
; 7400 : 	if ( type == ITEMGET(13,10) )

  00015	81 ff 0a 1a 00
	00		 cmp	 edi, 6666		; 00001a0aH

; 7401 : 	{
; 7402 : 		return 0;

  0001b	74 30		 je	 SHORT $LN28@GetNeedMon

; 7403 : 	}
; 7404 : 
; 7405 : 	if ( ::HasItemDurability(type ) != FALSE )

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?HasItemDurability@@YAHH@Z ; HasItemDurability
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	0f 84 74 01 00
	00		 je	 $LN18@GetNeedMon

; 7406 : 	{
; 7407 : 		float lc4;
; 7408 : 		float lc5 = 0;
; 7409 : 		lc4 = DurItem->m_BaseDurability;

  0002e	d9 46 2c	 fld	 DWORD PTR [esi+44]
  00031	d9 5d 08	 fstp	 DWORD PTR _lc4$246872[ebp]

; 7410 : 
; 7411 : 		if ( ItemDurability == lc4 )

  00034	d9 45 fc	 fld	 DWORD PTR _ItemDurability$[ebp]
  00037	d9 c0		 fld	 ST(0)
  00039	d9 45 08	 fld	 DWORD PTR _lc4$246872[ebp]
  0003c	d9 c0		 fld	 ST(0)
  0003e	dd ea		 fucomp	 ST(2)
  00040	df e0		 fnstsw	 ax
  00042	dd d9		 fstp	 ST(1)
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7a 0c		 jp	 SHORT $LN17@GetNeedMon
  00049	dd d9		 fstp	 ST(1)
  0004b	dd d8		 fstp	 ST(0)
$LN28@GetNeedMon:

; 7412 : 		{
; 7413 : 			return 0;

  0004d	5f		 pop	 edi
  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 7480 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN17@GetNeedMon:

; 7414 : 		}
; 7415 : 
; 7416 : 		float lc6 = 1.0f - ItemDurability / lc4;

  00055	de f9		 fdivp	 ST(1), ST(0)
  00057	d9 e8		 fld1
  00059	de e1		 fsubrp	 ST(1), ST(0)
  0005b	d9 5d f8	 fstp	 DWORD PTR _lc6$246875[ebp]

; 7417 : 		int lc7;
; 7418 : 
; 7419 : 		if ( type == ITEMGET(13,4)|| type ==ITEMGET(13,5) )

  0005e	81 ff 04 1a 00
	00		 cmp	 edi, 6660		; 00001a04H
  00064	74 14		 je	 SHORT $LN15@GetNeedMon
  00066	81 ff 05 1a 00
	00		 cmp	 edi, 6661		; 00001a05H
  0006c	74 0c		 je	 SHORT $LN15@GetNeedMon

; 7422 : 		}
; 7423 : 		else
; 7424 : 		{
; 7425 : 			lc7 = DurItem->m_BuyMoney/3;

  0006e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00073	f7 66 70	 mul	 DWORD PTR [esi+112]
  00076	d1 ea		 shr	 edx, 1
  00078	eb 03		 jmp	 SHORT $LN26@GetNeedMon
$LN15@GetNeedMon:

; 7420 : 		{
; 7421 : 			lc7 = DurItem->m_BuyMoney;

  0007a	8b 56 70	 mov	 edx, DWORD PTR [esi+112]
$LN26@GetNeedMon:
  0007d	89 55 08	 mov	 DWORD PTR _lc7$246876[ebp], edx

; 7426 : 		}
; 7427 : 
; 7428 : 		if ( lc7 > 400000000 ) lc7 = 400000000;

  00080	81 fa 00 84 d7
	17		 cmp	 edx, 400000000		; 17d78400H
  00086	7e 07		 jle	 SHORT $LN13@GetNeedMon
  00088	ba 00 84 d7 17	 mov	 edx, 400000000		; 17d78400H

; 7429 : 
; 7430 : 		if ( lc7 >= 1000 )

  0008d	eb 08		 jmp	 SHORT $LN22@GetNeedMon
$LN13@GetNeedMon:
  0008f	81 fa e8 03 00
	00		 cmp	 edx, 1000		; 000003e8H
  00095	7c 19		 jl	 SHORT $LN12@GetNeedMon
$LN22@GetNeedMon:

; 7431 : 		{
; 7432 : 			lc7 = lc7/100*100;

  00097	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0009c	f7 ea		 imul	 edx
  0009e	c1 fa 05	 sar	 edx, 5
  000a1	8b c2		 mov	 eax, edx
  000a3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000a6	03 c2		 add	 eax, edx
  000a8	6b c0 64	 imul	 eax, 100		; 00000064H
  000ab	89 45 08	 mov	 DWORD PTR _lc7$246876[ebp], eax
  000ae	eb 1e		 jmp	 SHORT $LN10@GetNeedMon
$LN12@GetNeedMon:

; 7433 : 		}
; 7434 : 		else if ( lc7 >= 100 )

  000b0	83 fa 64	 cmp	 edx, 100		; 00000064H
  000b3	7c 19		 jl	 SHORT $LN10@GetNeedMon

; 7435 : 		{
; 7436 : 			lc7 = lc7/10*10;

  000b5	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000ba	f7 ea		 imul	 edx
  000bc	c1 fa 02	 sar	 edx, 2
  000bf	8b c2		 mov	 eax, edx
  000c1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c4	03 c2		 add	 eax, edx
  000c6	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000c9	03 c9		 add	 ecx, ecx
  000cb	89 4d 08	 mov	 DWORD PTR _lc7$246876[ebp], ecx
$LN10@GetNeedMon:

; 7437 : 		}
; 7438 : 
; 7439 : 		float lc8 = sqrt((double)lc7);
; 7440 : 		float lc9 = sqrt(sqrt((double)lc7)); 

  000ce	db 45 08	 fild	 DWORD PTR _lc7$246876[ebp]
  000d1	e8 00 00 00 00	 call	 __CIsqrt
  000d6	dd 55 f0	 fst	 QWORD PTR tv256[ebp]
  000d9	e8 00 00 00 00	 call	 __CIsqrt

; 7441 : 		lc5 = 3.0f * lc8 * lc9;
; 7442 : 		lc5 *= lc6;
; 7443 : 		lc5 += 1.0f;

  000de	d9 5d 08	 fstp	 DWORD PTR tv234[ebp]
  000e1	d9 45 08	 fld	 DWORD PTR tv234[ebp]
  000e4	dd 45 f0	 fld	 QWORD PTR tv256[ebp]
  000e7	d9 5d 08	 fstp	 DWORD PTR tv231[ebp]
  000ea	d9 45 08	 fld	 DWORD PTR tv231[ebp]
  000ed	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4008000000000000
  000f3	de c9		 fmulp	 ST(1), ST(0)
  000f5	d9 5d 08	 fstp	 DWORD PTR tv228[ebp]
  000f8	d9 45 08	 fld	 DWORD PTR tv228[ebp]
  000fb	d8 4d f8	 fmul	 DWORD PTR _lc6$246875[ebp]
  000fe	d9 5d 08	 fstp	 DWORD PTR tv225[ebp]
  00101	d9 45 08	 fld	 DWORD PTR tv225[ebp]
  00104	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  0010a	d9 5d 08	 fstp	 DWORD PTR _lc5$246873[ebp]

; 7444 : 
; 7445 : 		if ( ItemDurability <= 0.0f )

  0010d	d9 ee		 fldz
  0010f	d8 5d fc	 fcomp	 DWORD PTR _ItemDurability$[ebp]
  00112	df e0		 fnstsw	 ax
  00114	f6 c4 01	 test	 ah, 1
  00117	75 26		 jne	 SHORT $LN6@GetNeedMon

; 7446 : 		{
; 7447 : 			if ( type == ITEMGET(13,4)|| type ==ITEMGET(13,5) )

  00119	81 ff 04 1a 00
	00		 cmp	 edi, 6660		; 00001a04H
  0011f	74 16		 je	 SHORT $LN7@GetNeedMon
  00121	81 ff 05 1a 00
	00		 cmp	 edi, 6661		; 00001a05H
  00127	74 0e		 je	 SHORT $LN7@GetNeedMon

; 7450 : 			}
; 7451 : 			else
; 7452 : 			{
; 7453 : 				lc5 *= ::GetAllRepairItemRate(type);

  00129	57		 push	 edi
  0012a	e8 00 00 00 00	 call	 ?GetAllRepairItemRate@@YAMH@Z ; GetAllRepairItemRate
  0012f	d8 4d 08	 fmul	 DWORD PTR _lc5$246873[ebp]
  00132	83 c4 04	 add	 esp, 4
  00135	eb 05		 jmp	 SHORT $LN27@GetNeedMon
$LN7@GetNeedMon:

; 7448 : 			{
; 7449 : 				lc5 *= 2;

  00137	d9 45 08	 fld	 DWORD PTR _lc5$246873[ebp]
  0013a	dc c0		 fadd	 ST(0), ST(0)
$LN27@GetNeedMon:
  0013c	d9 5d 08	 fstp	 DWORD PTR _lc5$246873[ebp]
$LN6@GetNeedMon:

; 7454 : 			}
; 7455 : 
; 7456 : 		}
; 7457 : 
; 7458 : 		if ( RequestPos == TRUE )

  0013f	83 7d 0c 01	 cmp	 DWORD PTR _RequestPos$[ebp], 1
  00143	75 0c		 jne	 SHORT $LN5@GetNeedMon

; 7459 : 		{
; 7460 : 			lc5 += lc5 * 2; //season4 changed

  00145	d9 45 08	 fld	 DWORD PTR _lc5$246873[ebp]
  00148	d9 c0		 fld	 ST(0)
  0014a	d8 c1		 fadd	 ST(0), ST(1)
  0014c	de c1		 faddp	 ST(1), ST(0)
  0014e	d9 5d 08	 fstp	 DWORD PTR _lc5$246873[ebp]
$LN5@GetNeedMon:

; 7461 : 		}
; 7462 : 
; 7463 : 		iMoney = (int)lc5;

  00151	d9 45 08	 fld	 DWORD PTR _lc5$246873[ebp]
  00154	e8 00 00 00 00	 call	 __ftol2_sse
  00159	8b c8		 mov	 ecx, eax

; 7464 : 
; 7465 : 		if ( iMoney >= 1000 )

  0015b	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00161	7c 1c		 jl	 SHORT $LN4@GetNeedMon

; 7466 : 		{
; 7467 : 			iMoney = iMoney/100*100;

  00163	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00168	f7 e9		 imul	 ecx
  0016a	c1 fa 05	 sar	 edx, 5
  0016d	8b ca		 mov	 ecx, edx
  0016f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00172	03 ca		 add	 ecx, edx
  00174	6b c9 64	 imul	 ecx, 100		; 00000064H
  00177	5f		 pop	 edi

; 7477 : 	}
; 7478 : 
; 7479 : 	return iMoney;

  00178	8b c1		 mov	 eax, ecx
  0017a	5e		 pop	 esi

; 7480 : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
$LN4@GetNeedMon:

; 7468 : 		}
; 7469 : 		else if ( iMoney > 10 )

  0017f	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00182	7e 21		 jle	 SHORT $LN1@GetNeedMon

; 7470 : 		{
; 7471 : 			iMoney = iMoney/10*10;

  00184	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00189	f7 e9		 imul	 ecx
  0018b	c1 fa 02	 sar	 edx, 2
  0018e	8b c2		 mov	 eax, edx
  00190	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00193	03 c2		 add	 eax, edx
  00195	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00198	03 c9		 add	 ecx, ecx
  0019a	5f		 pop	 edi

; 7477 : 	}
; 7478 : 
; 7479 : 	return iMoney;

  0019b	8b c1		 mov	 eax, ecx
  0019d	5e		 pop	 esi

; 7480 : }

  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
$LN18@GetNeedMon:

; 7472 : 		}		
; 7473 : 	}
; 7474 : 	else
; 7475 : 	{
; 7476 : 		iMoney = -1;

  001a2	83 c9 ff	 or	 ecx, -1
$LN1@GetNeedMon:
  001a5	5f		 pop	 edi

; 7477 : 	}
; 7478 : 
; 7479 : 	return iMoney;

  001a6	8b c1		 mov	 eax, ecx
  001a8	5e		 pop	 esi

; 7480 : }

  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c3		 ret	 0
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ENDP	; GetNeedMoneyItemDurRepaire
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCTradeResponseSend@@YAHEHPADGH@Z		; GCTradeResponseSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeResponseSend@@YAHEHPADGH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_response$ = 8						; size = 1
_aIndex$ = 12						; size = 4
_id$ = 16						; size = 4
_level$ = 20						; size = 2
_GuildNumber$ = 24					; size = 4
?GCTradeResponseSend@@YAHEHPADGH@Z PROC			; GCTradeResponseSend, COMDAT

; 8238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR _id$[ebp]

; 8239 : 	PMSG_TRADE_RESPONSE pMsg;
; 8240 : 
; 8241 : 	PHeadSetB((LPBYTE)&pMsg, 0x37, sizeof(pMsg));

  00014	6a 14		 push	 20			; 00000014H
  00016	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 37		 push	 55			; 00000037H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8242 : 	pMsg.Response = response;

  00021	8a 4d 08	 mov	 cl, BYTE PTR _response$[ebp]

; 8243 : 	pMsg.Level = level;

  00024	66 8b 55 14	 mov	 dx, WORD PTR _level$[ebp]

; 8244 : 	pMsg.GuildNumber = GuildNumber;

  00028	8b 45 18	 mov	 eax, DWORD PTR _GuildNumber$[ebp]
  0002b	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 8245 : 	memcpy(pMsg.Id, id, sizeof(pMsg.Id));

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+14], dx
  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 8246 : 
; 8247 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003a	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0003e	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00041	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  00045	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00048	51		 push	 ecx
  00049	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0004c	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax
  00050	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00053	52		 push	 edx
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8248 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	33 cd		 xor	 ecx, ebp
  00062	5e		 pop	 esi
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?GCTradeResponseSend@@YAHEHPADGH@Z ENDP			; GCTradeResponseSend
_TEXT	ENDS
PUBLIC	?GCTradeOtherDel@@YAHHE@Z			; GCTradeOtherDel
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeOtherDel@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
?GCTradeOtherDel@@YAHHE@Z PROC				; GCTradeOtherDel, COMDAT

; 8257 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8258 : 	PMSG_TRADE_OTHER_DEL pMsg;
; 8259 : 
; 8260 : 	PHeadSetB((LPBYTE)&pMsg, 0x38, sizeof(pMsg ));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 38		 push	 56			; 00000038H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8261 : 	pMsg.TradeItemIndex = tradeindex;
; 8262 : 
; 8263 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _tradeindex$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 8264 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCTradeOtherDel@@YAHHE@Z ENDP				; GCTradeOtherDel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCTradeOtherAdd@@YAHHEPAE@Z			; GCTradeOtherAdd
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeOtherAdd@@YAHHEPAE@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
_iteminfo$ = 16						; size = 4
?GCTradeOtherAdd@@YAHHEPAE@Z PROC			; GCTradeOtherAdd, COMDAT

; 8274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR _iteminfo$[ebp]

; 8275 : 	PMSG_TRADE_OTHER_MOVE pMsg;
; 8276 : 
; 8277 : 	PHeadSetB((LPBYTE)&pMsg, 0x39, sizeof(pMsg));

  00014	6a 10		 push	 16			; 00000010H
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 39		 push	 57			; 00000039H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8278 : 	pMsg.TradeItemIndex = tradeindex;
; 8279 : 	pMsg.ItemInfo[0] = iteminfo[0];

  00021	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00024	8a 4d 0c	 mov	 cl, BYTE PTR _tradeindex$[ebp]

; 8280 : 	pMsg.ItemInfo[1] = iteminfo[1];

  00027	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0002b	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 8281 : 	pMsg.ItemInfo[2] = iteminfo[2];

  0002e	0f b6 4e 02	 movzx	 ecx, BYTE PTR [esi+2]
  00032	88 55 f0	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 8282 : 	pMsg.ItemInfo[3] = iteminfo[3];

  00035	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00039	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 8283 : 	pMsg.ItemInfo[4] = iteminfo[4];

  0003c	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00040	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 8284 : 	pMsg.ItemInfo[5] = iteminfo[5];

  00043	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00047	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+7], dl

; 8285 : 	pMsg.ItemInfo[6] = iteminfo[6];

  0004a	0f b6 56 06	 movzx	 edx, BYTE PTR [esi+6]
  0004e	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 8286 : 
; 8287 : 	//season4 add-on
; 8288 : 	pMsg.ItemInfo[7] = iteminfo[7];

  00051	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  00055	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 8289 : 	pMsg.ItemInfo[8] = iteminfo[8];

  00058	0f b6 4e 08	 movzx	 ecx, BYTE PTR [esi+8]
  0005c	88 55 f6	 mov	 BYTE PTR _pMsg$[ebp+10], dl

; 8290 : 	pMsg.ItemInfo[9] = iteminfo[9];

  0005f	0f b6 56 09	 movzx	 edx, BYTE PTR [esi+9]
  00063	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 8291 : 	pMsg.ItemInfo[10] = iteminfo[10];

  00066	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  0006a	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+12], cl

; 8292 : 	pMsg.ItemInfo[11] = iteminfo[11];

  0006d	0f b6 4e 0b	 movzx	 ecx, BYTE PTR [esi+11]
  00071	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+13], dl

; 8293 : 	
; 8294 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00078	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+14], al
  0007b	52		 push	 edx
  0007c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+15], cl
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00085	50		 push	 eax
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8295 : }

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	83 c4 18	 add	 esp, 24			; 00000018H
  00092	33 cd		 xor	 ecx, ebp
  00094	5e		 pop	 esi
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
?GCTradeOtherAdd@@YAHHEPAE@Z ENDP			; GCTradeOtherAdd
_TEXT	ENDS
PUBLIC	?GCTradeMoneyOther@@YAHHK@Z			; GCTradeMoneyOther
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeMoneyOther@@YAHHK@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCTradeMoneyOther@@YAHHK@Z PROC			; GCTradeMoneyOther, COMDAT

; 8380 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8381 : 	PMSG_TRADE_OTHER_GOLD pMsg;
; 8382 : 
; 8383 : 	PHeadSetB((LPBYTE)&pMsg, 0x3B, sizeof(pMsg));

  00006	6a 08		 push	 8
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 3b		 push	 59			; 0000003bH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8384 : 	pMsg.Money = money;
; 8385 : 
; 8386 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);	

  00013	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _money$[ebp]
  0001a	52		 push	 edx
  0001b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	89 4d fc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 8387 : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?GCTradeMoneyOther@@YAHHK@Z ENDP			; GCTradeMoneyOther
_TEXT	ENDS
PUBLIC	?GCTradeOkButtonSend@@YAHHE@Z			; GCTradeOkButtonSend
; Function compile flags: /Ogtp
;	COMDAT ?GCTradeOkButtonSend@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_flag$ = 12						; size = 1
?GCTradeOkButtonSend@@YAHHE@Z PROC			; GCTradeOkButtonSend, COMDAT

; 8390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8391 : 	PMSG_TRADE_OKBUTTON pMsg;
; 8392 : 
; 8393 : 	PHeadSetB((LPBYTE)&pMsg, 0x3C, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 3c		 push	 60			; 0000003cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8394 : 	pMsg.Flag = flag;
; 8395 : 
; 8396 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _flag$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 8397 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCTradeOkButtonSend@@YAHHE@Z ENDP			; GCTradeOkButtonSend
_TEXT	ENDS
PUBLIC	??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@ ; `string'
PUBLIC	?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
EXTRN	?gObjTradeOkButton@@YAXH@Z:PROC			; gObjTradeOkButton
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
;	COMDAT ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@
CONST	SEGMENT
??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@ DB '[%s'
	DB	'][%s] Trade Accept', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z PROC ; CGTradeOkButtonRecv, COMDAT

; 8400 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8401 : 	int number = gObj[aIndex].TargetNumber;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00013	0f bf 9c 06 58
	04 00 00	 movsx	 ebx, WORD PTR [esi+eax+1112]

; 8402 : 
; 8403 : 	if ( number < 0 || number > OBJMAX-1 )

  0001b	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00021	0f 87 02 01 00
	00		 ja	 $LN8@CGTradeOkB

; 8404 : 	{
; 8405 : 		return;
; 8406 : 	}
; 8407 : 
; 8408 : 	if ( !gObjIsConnected(&gObj[number]))

  00027	57		 push	 edi
  00028	8b fb		 mov	 edi, ebx
  0002a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00030	03 c7		 add	 eax, edi
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 e5 00 00
	00		 je	 $LN17@CGTradeOkB

; 8409 : 	{
; 8410 : 		return;
; 8411 : 	}
; 8412 : 
; 8413 : 	if ( gObj[aIndex].m_IfState.use < 1 || gObj[aIndex].m_IfState.state != 1 )

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  0004f	8b d1		 mov	 edx, ecx
  00051	80 e2 03	 and	 dl, 3
  00054	80 fa 01	 cmp	 dl, 1
  00057	0f 82 cb 00 00
	00		 jb	 $LN17@CGTradeOkB
  0005d	80 e1 3c	 and	 cl, 60			; 0000003cH
  00060	80 f9 04	 cmp	 cl, 4
  00063	0f 85 bf 00 00
	00		 jne	 $LN17@CGTradeOkB

; 8414 : 	{
; 8415 : 		return;
; 8416 : 	}
; 8417 : 
; 8418 : 	if ( gObj[number].m_IfState.use < 1 || gObj[number].m_IfState.state != 1 )

  00069	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  00070	8b d1		 mov	 edx, ecx
  00072	80 e2 03	 and	 dl, 3
  00075	80 fa 01	 cmp	 dl, 1
  00078	0f 82 aa 00 00
	00		 jb	 $LN17@CGTradeOkB
  0007e	80 e1 3c	 and	 cl, 60			; 0000003cH
  00081	80 f9 04	 cmp	 cl, 4
  00084	0f 85 9e 00 00
	00		 jne	 $LN17@CGTradeOkB

; 8419 : 	{
; 8420 : 		return;
; 8421 : 	}
; 8422 : 
; 8423 : 	if ( gObj[aIndex].CloseType != -1 )

  0008a	80 c9 ff	 or	 cl, -1
  0008d	38 4c 06 0b	 cmp	 BYTE PTR [esi+eax+11], cl
  00091	0f 85 91 00 00
	00		 jne	 $LN17@CGTradeOkB

; 8424 : 	{
; 8425 : 		return;
; 8426 : 	}
; 8427 : 
; 8428 : 	if ( gObj[number].CloseType != -1 )

  00097	38 4c 07 0b	 cmp	 BYTE PTR [edi+eax+11], cl
  0009b	0f 85 87 00 00
	00		 jne	 $LN17@CGTradeOkB

; 8429 : 	{
; 8430 : 		return;
; 8431 : 	}
; 8432 : 	
; 8433 : 	if ( lpMsg->Flag == 1 )

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000a4	8a 49 03	 mov	 cl, BYTE PTR [ecx+3]
  000a7	80 f9 01	 cmp	 cl, 1
  000aa	75 49		 jne	 SHORT $LN5@CGTradeOkB

; 8434 : 	{
; 8435 : 		if ( gObj[aIndex].TradeOk == false )

  000ac	80 bc 06 58 0e
	00 00 00	 cmp	 BYTE PTR [esi+eax+3672], 0
  000b4	8d 84 06 58 0e
	00 00		 lea	 eax, DWORD PTR [esi+eax+3672]
  000bb	75 5f		 jne	 SHORT $LN1@CGTradeOkB

; 8436 : 		{
; 8437 : 			gObj[aIndex].TradeOk = true;

  000bd	88 08		 mov	 BYTE PTR [eax], cl

; 8438 : 			LogAddTD("[%s][%s] Trade Accept", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000c8	52		 push	 edx
  000c9	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  000cd	50		 push	 eax
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8439 : 			GCTradeOkButtonSend(number, 1);

  000d9	6a 01		 push	 1
  000db	53		 push	 ebx
  000dc	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 8448 : 		}
; 8449 : 	}
; 8450 : 
; 8451 : 	gObjTradeOkButton(aIndex);

  000e1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000e4	83 c4 14	 add	 esp, 20			; 00000014H
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  000ed	83 c4 04	 add	 esp, 4
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 8452 : }

  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN5@CGTradeOkB:

; 8440 : 		}
; 8441 : 	}
; 8442 : 	else if ( lpMsg->Flag == 0 )

  000f5	84 c9		 test	 cl, cl
  000f7	75 23		 jne	 SHORT $LN1@CGTradeOkB

; 8443 : 	{
; 8444 : 		if ( gObj[aIndex].TradeOk  == true )

  000f9	80 bc 06 58 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3672], 1
  00101	75 19		 jne	 SHORT $LN1@CGTradeOkB

; 8445 : 		{
; 8446 : 			GCTradeOkButtonSend(number, 0);

  00103	6a 00		 push	 0
  00105	53		 push	 ebx
  00106	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 8447 : 			gObj[aIndex].TradeOk = false;

  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	83 c4 08	 add	 esp, 8
  00114	c6 84 0e 58 0e
	00 00 00	 mov	 BYTE PTR [esi+ecx+3672], 0
$LN1@CGTradeOkB:

; 8448 : 		}
; 8449 : 	}
; 8450 : 
; 8451 : 	gObjTradeOkButton(aIndex);

  0011c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  00125	83 c4 04	 add	 esp, 4
$LN17@CGTradeOkB:
  00128	5f		 pop	 edi
$LN8@CGTradeOkB:
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx

; 8452 : }

  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ENDP ; CGTradeOkButtonRecv
_TEXT	ENDS
PUBLIC	?CGTradeResult@@YAXHE@Z				; CGTradeResult
; Function compile flags: /Ogtp
;	COMDAT ?CGTradeResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?CGTradeResult@@YAXHE@Z PROC				; CGTradeResult, COMDAT

; 8474 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8475 : 	PMSG_TRADE_RESULT pMsg;
; 8476 : 
; 8477 : 	PHeadSetB((LPBYTE)&pMsg, 0x3D, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 3d		 push	 61			; 0000003dH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8478 : 	pMsg.Result = result;
; 8479 : 
; 8480 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 8481 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?CGTradeResult@@YAXHE@Z ENDP				; CGTradeResult
_TEXT	ENDS
PUBLIC	?CGPShopAnsSetItemPrice@@YAXHEE@Z		; CGPShopAnsSetItemPrice
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsSetItemPrice@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btItemPos$ = 16					; size = 1
?CGPShopAnsSetItemPrice@@YAXHEE@Z PROC			; CGPShopAnsSetItemPrice, COMDAT

; 8712 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8713 : 	PMSG_ANS_PSHOP_SETITEMPRICE pMsg;
; 8714 : 
; 8715 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x01, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8716 : 	pMsg.btResult = btResult;
; 8717 : 	pMsg.btItemPos = btItemPos;
; 8718 : 
; 8719 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00015	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00019	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]
  0001c	8a 55 10	 mov	 dl, BYTE PTR _btItemPos$[ebp]
  0001f	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00022	50		 push	 eax
  00023	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00026	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00029	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH

; 8720 : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?CGPShopAnsSetItemPrice@@YAXHEE@Z ENDP			; CGPShopAnsSetItemPrice
_TEXT	ENDS
PUBLIC	?CGPShopAnsOpen@@YAXHE@Z			; CGPShopAnsOpen
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsOpen@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsOpen@@YAXHE@Z PROC				; CGPShopAnsOpen, COMDAT

; 8875 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8876 : 	PMSG_ANS_PSHOP_OPEN pMsg;
; 8877 : 
; 8878 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x02, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 02		 push	 2
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8879 : 	pMsg.btResult = btResult;
; 8880 : 
; 8881 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00015	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00018	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]
  0001b	6a 05		 push	 5
  0001d	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00025	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 8882 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?CGPShopAnsOpen@@YAXHE@Z ENDP				; CGPShopAnsOpen
_TEXT	ENDS
PUBLIC	??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@ ; `string'
PUBLIC	?CGPShopAnsClose@@YAXHE@Z			; CGPShopAnsClose
;	COMDAT ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@
CONST	SEGMENT
??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@ DB '['
	DB	'PShop] [%s][%s] Close PShop', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopAnsClose@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsClose@@YAXHE@Z PROC				; CGPShopAnsClose, COMDAT

; 8914 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8915 : 	LogAddTD("[PShop] [%s][%s] Close PShop",
; 8916 : 		gObj[aIndex].AccountID, gObj[aIndex].Name);

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000b	53		 push	 ebx
  0000c	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000f	56		 push	 esi
  00010	8b f3		 mov	 esi, ebx
  00012	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00018	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0001c	51		 push	 ecx
  0001d	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00021	52		 push	 edx
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8917 : 
; 8918 : 	PMSG_ANS_PSHOP_CLOSE pMsg;
; 8919 : 
; 8920 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x03, sizeof(pMsg));

  0002d	6a 07		 push	 7
  0002f	6a 03		 push	 3
  00031	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	6a 3f		 push	 63			; 0000003fH
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8921 : 	pMsg.btResult = btResult;

  0003c	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]

; 8922 : 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 8923 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 8924 : 
; 8925 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0003f	6a 07		 push	 7
  00041	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00044	8b d3		 mov	 edx, ebx
  00046	50		 push	 eax
  00047	c1 ea 08	 shr	 edx, 8
  0004a	53		 push	 ebx
  0004b	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0004e	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00051	88 5d fe	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 28	 add	 esp, 40			; 00000028H

; 8926 : 
; 8927 : 	if ( btResult == 1 )

  0005c	80 7d 0c 01	 cmp	 BYTE PTR _btResult$[ebp], 1
  00060	75 18		 jne	 SHORT $LN1@CGPShopAns

; 8928 : 	{
; 8929 : 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00062	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00066	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006c	51		 push	 ecx
  0006d	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00070	52		 push	 edx
  00071	56		 push	 esi
  00072	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPShopAns:
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx

; 8930 : 	}
; 8931 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?CGPShopAnsClose@@YAXHE@Z ENDP				; CGPShopAnsClose
_TEXT	ENDS
PUBLIC	??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd?$AA@	; `string'
PUBLIC	_aTargetIndex$GSCopy$
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopAnsBuyList@@YAXHHE_N@Z			; CGPShopAnsBuyList
EXTRN	?GetMoney@PersonalShopZt@@QAEHHH@Z:PROC		; PersonalShopZt::GetMoney
EXTRN	?UpdatePSInventoryTarget@PersonalShopZt@@QAEXHH@Z:PROC ; PersonalShopZt::UpdatePSInventoryTarget
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
;	COMDAT ??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd?$AA@ DB 'ITEM TYPE:%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopAnsBuyList@@YAXHHE_N@Z
_TEXT	SEGMENT
_aSourceIndex$GSCopy$ = -1128				; size = 4
_pMsgILC$ = -1124					; size = 55
_aTargetIndex$GSCopy$ = -1068				; size = 4
_iCount$247571 = -1064					; size = 4
_sOfs$ = -1060						; size = 4
_n$247572 = -1056					; size = 4
tv332 = -1052						; size = 4
_pMsgIL$ = -1048					; size = 20
_sendBuf$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_btResult$ = 16						; size = 1
_bResend$ = 20						; size = 1
?CGPShopAnsBuyList@@YAXHHE_N@Z PROC			; CGPShopAnsBuyList, COMDAT

; 9039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 04 00
	00		 sub	 esp, 1128		; 00000468H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9040 : 	if ( gDoPShopOpen == FALSE )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0001a	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0001d	53		 push	 ebx
  0001e	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi

; 9110 : 			}
; 9111 : 		}
; 9112 : 
; 9113 : 		pMsgILC.h.c = 0xC2;

  00023	89 95 98 fb ff
	ff		 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], edx
  00029	89 9d d4 fb ff
	ff		 mov	 DWORD PTR _aTargetIndex$GSCopy$[ebp], ebx
  0002f	0f 84 d0 02 00
	00		 je	 $LN9@CGPShopAns@2

; 9041 : 	{
; 9042 : 		return;
; 9043 : 	}
; 9044 : 	
; 9045 : 	PMSG_ANS_BUYLIST_FROM_PSHOP pMsgILC;
; 9046 : 	PMSG_BUYLIST_FROM_PSHOP pMsgIL;
; 9047 : 	BYTE sendBuf[1024];
; 9048 : 	int sOfs = sizeof(pMsgILC);

  00035	8a 45 10	 mov	 al, BYTE PTR _btResult$[ebp]
  00038	c7 85 dc fb ff
	ff 37 00 00 00	 mov	 DWORD PTR _sOfs$[ebp], 55 ; 00000037H

; 9049 : 	int pMsgILSize = sizeof(pMsgIL);
; 9050 : 
; 9051 : 	if ( btResult != 1 )

  00042	3c 01		 cmp	 al, 1
  00044	0f 84 a8 00 00
	00		 je	 $LN12@CGPShopAns@2

; 9052 : 	{
; 9053 : 		LPOBJ lpObj = &gObj[aSourceIndex];
; 9054 : 		
; 9055 : 		pMsgILC.h.c = 0xC2;
; 9056 : 		pMsgILC.h.headcode = 0x3F;
; 9057 : 
; 9058 : 		if ( bResend == false )

  0004a	8a 4d 14	 mov	 cl, BYTE PTR _bResend$[ebp]
  0004d	f6 d9		 neg	 cl
  0004f	1a c9		 sbb	 cl, cl

; 9059 : 		{
; 9060 : 			pMsgILC.h.subcode = 0x05;
; 9061 : 		}
; 9062 : 		else
; 9063 : 		{
; 9064 : 			pMsgILC.h.subcode = 0x13;
; 9065 : 		}
; 9066 : 
; 9067 : 		pMsgILC.h.sizeH = SET_NUMBERH(sOfs);
; 9068 : 		pMsgILC.h.sizeL = SET_NUMBERL(sOfs);
; 9069 : 		pMsgILC.btCount = 0;
; 9070 : 		pMsgILC.Result = btResult;

  00051	88 85 a1 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+5], al
  00057	80 e1 0e	 and	 cl, 14			; 0000000eH
  0005a	80 c1 05	 add	 cl, 5

; 9071 : 		pMsgILC.NumberH = SET_NUMBERH(aTargetIndex);

  0005d	8b c3		 mov	 eax, ebx
  0005f	c1 e8 08	 shr	 eax, 8
  00062	88 8d a0 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+4], cl
  00068	88 85 a2 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+6], al

; 9072 : 		pMsgILC.NumberL = SET_NUMBERL(aTargetIndex);
; 9073 : 		memset(pMsgILC.btName, 0, sizeof(pMsgILC.btName));

  0006e	33 c0		 xor	 eax, eax

; 9074 : 		memset(pMsgILC.szPShopText, 0, sizeof(pMsgILC.szPShopText));
; 9075 : 		memcpy(sendBuf, &pMsgILC, sizeof(pMsgILC));

  00070	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00075	8d b5 9c fb ff
	ff		 lea	 esi, DWORD PTR _pMsgILC$[ebp]
  0007b	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _sendBuf$[ebp]
  00081	c7 85 9c fb ff
	ff c2 00 37 3f	 mov	 DWORD PTR _pMsgILC$[ebp], 1060569282 ; 3f3700c2H
  0008b	c6 85 d2 fb ff
	ff 00		 mov	 BYTE PTR _pMsgILC$[ebp+54], 0
  00092	88 9d a3 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+7], bl
  00098	89 85 a4 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+8], eax
  0009e	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+12], eax
  000a4	66 89 85 ac fb
	ff ff		 mov	 WORD PTR _pMsgILC$[ebp+16], ax
  000ab	89 85 ae fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+18], eax
  000b1	89 85 b2 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+22], eax
  000b7	89 85 b6 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+26], eax
  000bd	89 85 ba fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+30], eax
  000c3	89 85 be fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+34], eax
  000c9	89 85 c2 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+38], eax
  000cf	89 85 c6 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+42], eax
  000d5	89 85 ca fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+46], eax
  000db	89 85 ce fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+50], eax
  000e1	f3 a5		 rep movsd

; 9076 : 
; 9077 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  000e3	6a 37		 push	 55			; 00000037H
  000e5	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  000eb	51		 push	 ecx
  000ec	52		 push	 edx

; 9078 : 	}
; 9079 : 	else

  000ed	e9 08 02 00 00	 jmp	 $LN18@CGPShopAns@2
$LN12@CGPShopAns@2:

; 9080 : 	{
; 9081 : #if(CUSTOM_PERSONAL_SHOP==TRUE)
; 9082 : 		g_PersonalShopZt.UpdatePSInventoryTarget(aSourceIndex, aTargetIndex);

  000f2	53		 push	 ebx
  000f3	52		 push	 edx
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PersonalShopZt@@3VPersonalShopZt@@A ; g_PersonalShopZt
  000f9	e8 00 00 00 00	 call	 ?UpdatePSInventoryTarget@PersonalShopZt@@QAEXHH@Z ; PersonalShopZt::UpdatePSInventoryTarget

; 9083 : #endif
; 9084 : 		LPOBJ lpObjSource = &gObj[aSourceIndex];
; 9085 : 		LPOBJ lpObjTarget = &gObj[aTargetIndex];

  000fe	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00104	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010a	bf f0 a8 00 00	 mov	 edi, 43248		; 0000a8f0H

; 9086 : 		int iCount = 0;

  0010f	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCount$247571[ebp], 0

; 9087 : 
; 9088 : 		for ( int n=MAIN_INVENTORY_SIZE;n<INVENTORY_SIZE;n++)

  00119	c7 85 e0 fb ff
	ff cc 00 00 00	 mov	 DWORD PTR _n$247572[ebp], 204 ; 000000ccH
  00123	89 bd e4 fb ff
	ff		 mov	 DWORD PTR tv332[ebp], edi
  00129	8d a4 24 00 00
	00 00		 npad	 7
$LL8@CGPShopAns@2:

; 9089 : 		{
; 9090 : 			if ( lpObjTarget->Inventory1[n].IsItem() == TRUE )

  00130	8b 8b 34 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3636]
  00136	03 cf		 add	 ecx, edi
  00138	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0013d	83 f8 01	 cmp	 eax, 1
  00140	0f 85 e4 00 00
	00		 jne	 $LN7@CGPShopAns@2

; 9091 : 			{
; 9092 : 				pMsgIL.Pos = n;

  00146	8a 95 e0 fb ff
	ff		 mov	 dl, BYTE PTR _n$247572[ebp]
  0014c	88 95 e8 fb ff
	ff		 mov	 BYTE PTR _pMsgIL$[ebp], dl

; 9093 : 				ItemByteConvert(pMsgIL.ItemInfo, lpObjTarget->Inventory1[n]);

  00152	8b b3 34 0e 00
	00		 mov	 esi, DWORD PTR [ebx+3636]
  00158	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0015e	03 f7		 add	 esi, edi
  00160	8d 85 e9 fb ff
	ff		 lea	 eax, DWORD PTR _pMsgIL$[ebp+1]
  00166	8b fc		 mov	 edi, esp
  00168	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0016d	50		 push	 eax
  0016e	f3 a5		 rep movsd
  00170	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00175	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 9094 : //#if(CUSTOM_PERSONAL_SHOP==TRUE)
; 9095 : 				if(g_PersonalShopZt.Enable)

  0017b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A, 0
  00182	74 1a		 je	 SHORT $LN4@CGPShopAns@2

; 9096 : 				{
; 9097 : 					pMsgIL.PShopItemValue = g_PersonalShopZt.GetMoney(aTargetIndex,n); //lpObjTarget->Inventory1[n].m_iPShopValue;

  00184	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _n$247572[ebp]
  0018a	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR _aTargetIndex$GSCopy$[ebp]
  00190	51		 push	 ecx
  00191	52		 push	 edx
  00192	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PersonalShopZt@@3VPersonalShopZt@@A ; g_PersonalShopZt
  00197	e8 00 00 00 00	 call	 ?GetMoney@PersonalShopZt@@QAEHHH@Z ; PersonalShopZt::GetMoney

; 9098 : 				}
; 9099 : 				else

  0019c	eb 10		 jmp	 SHORT $LN19@CGPShopAns@2
$LN4@CGPShopAns@2:

; 9100 : //#else
; 9101 : 				{
; 9102 : 					pMsgIL.PShopItemValue = lpObjTarget->Inventory1[n].m_iPShopValue;

  0019e	8b 83 34 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3636]
  001a4	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR tv332[ebp]
  001aa	8b 44 01 74	 mov	 eax, DWORD PTR [ecx+eax+116]
$LN19@CGPShopAns@2:

; 9103 : 				}
; 9104 : //#endif
; 9105 : 				memcpy(&sendBuf[sOfs], &pMsgIL, pMsgILSize);

  001ae	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _sOfs$[ebp]
  001b4	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR _pMsgIL$[ebp]
  001ba	89 94 0d fc fb
	ff ff		 mov	 DWORD PTR _sendBuf$[ebp+ecx], edx
  001c1	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _pMsgIL$[ebp+4]

; 9106 : 				iCount++;

  001c7	ff 85 d8 fb ff
	ff		 inc	 DWORD PTR _iCount$247571[ebp]
  001cd	89 94 0d 00 fc
	ff ff		 mov	 DWORD PTR _sendBuf$[ebp+ecx+4], edx
  001d4	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _pMsgIL$[ebp+8]
  001da	89 94 0d 04 fc
	ff ff		 mov	 DWORD PTR _sendBuf$[ebp+ecx+8], edx
  001e1	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _pMsgIL$[ebp+12]
  001e7	89 94 0d 08 fc
	ff ff		 mov	 DWORD PTR _sendBuf$[ebp+ecx+12], edx
  001ee	89 84 0d 0c fc
	ff ff		 mov	 DWORD PTR _sendBuf$[ebp+ecx+16], eax

; 9107 : 				sOfs += pMsgILSize;

  001f5	83 c1 14	 add	 ecx, 20			; 00000014H
  001f8	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _pMsgIL$[ebp+16], eax

; 9108 : 
; 9109 : 				LogAddTD("ITEM TYPE:%d", lpObjTarget->Inventory1[n].m_Type);

  001fe	8b 83 34 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3636]
  00204	89 8d dc fb ff
	ff		 mov	 DWORD PTR _sOfs$[ebp], ecx
  0020a	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR tv332[ebp]
  00210	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  00215	52		 push	 edx
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd?$AA@
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00221	8b bd e4 fb ff
	ff		 mov	 edi, DWORD PTR tv332[ebp]
  00227	83 c4 08	 add	 esp, 8
$LN7@CGPShopAns@2:

; 9087 : 
; 9088 : 		for ( int n=MAIN_INVENTORY_SIZE;n<INVENTORY_SIZE;n++)

  0022a	ff 85 e0 fb ff
	ff		 inc	 DWORD PTR _n$247572[ebp]
  00230	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00236	89 bd e4 fb ff
	ff		 mov	 DWORD PTR tv332[ebp], edi
  0023c	81 ff 70 c3 00
	00		 cmp	 edi, 50032		; 0000c370H
  00242	0f 8c e8 fe ff
	ff		 jl	 $LL8@CGPShopAns@2

; 9114 : 		pMsgILC.h.headcode = 0x3F;
; 9115 : 
; 9116 : 		if ( bResend == false )

  00248	8a 45 14	 mov	 al, BYTE PTR _bResend$[ebp]

; 9117 : 		{
; 9118 : 			pMsgILC.h.subcode = 0x05;
; 9119 : 		}
; 9120 : 		else
; 9121 : 		{
; 9122 : 			pMsgILC.h.subcode = 0x13;
; 9123 : 		}
; 9124 : 
; 9125 : 		pMsgILC.h.sizeH = SET_NUMBERH(sOfs);
; 9126 : 		pMsgILC.h.sizeL = SET_NUMBERL(sOfs);
; 9127 : 		pMsgILC.btCount = iCount;

  0024b	8a 95 d8 fb ff
	ff		 mov	 dl, BYTE PTR _iCount$247571[ebp]
  00251	f6 d8		 neg	 al
  00253	1a c0		 sbb	 al, al
  00255	24 0e		 and	 al, 14			; 0000000eH
  00257	04 05		 add	 al, 5
  00259	88 85 a0 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+4], al
  0025f	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  00265	8b c8		 mov	 ecx, eax
  00267	c1 e9 08	 shr	 ecx, 8
  0026a	88 8d 9d fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+1], cl

; 9128 : 		pMsgILC.Result = btResult;
; 9129 : 		pMsgILC.NumberH = SET_NUMBERH(aTargetIndex);

  00270	8b 8d d4 fb ff
	ff		 mov	 ecx, DWORD PTR _aTargetIndex$GSCopy$[ebp]
  00276	88 95 d2 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+54], dl
  0027c	8b d1		 mov	 edx, ecx

; 9130 : 		pMsgILC.NumberL = SET_NUMBERL(aTargetIndex);

  0027e	88 8d a3 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+7], cl

; 9131 : 		memcpy(pMsgILC.btName, lpObjTarget->Name, sizeof(pMsgILC.btName));

  00284	8b 4b 77	 mov	 ecx, DWORD PTR [ebx+119]
  00287	89 8d a4 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+8], ecx
  0028d	66 8b 4b 7f	 mov	 cx, WORD PTR [ebx+127]
  00291	c1 ea 08	 shr	 edx, 8
  00294	88 95 a2 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+6], dl
  0029a	8b 53 7b	 mov	 edx, DWORD PTR [ebx+123]
  0029d	66 89 8d ac fb
	ff ff		 mov	 WORD PTR _pMsgILC$[ebp+16], cx
  002a4	89 95 a8 fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+12], edx
  002aa	88 85 9e fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+2], al

; 9134 : 
; 9135 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  002b0	50		 push	 eax
  002b1	8b 85 98 fb ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  002b7	c6 85 9c fb ff
	ff c2		 mov	 BYTE PTR _pMsgILC$[ebp], 194 ; 000000c2H
  002be	c6 85 9f fb ff
	ff 3f		 mov	 BYTE PTR _pMsgILC$[ebp+3], 63 ; 0000003fH
  002c5	c6 85 a1 fb ff
	ff 01		 mov	 BYTE PTR _pMsgILC$[ebp+5], 1
  002cc	8d b3 c8 0e 00
	00		 lea	 esi, DWORD PTR [ebx+3784]
  002d2	b9 09 00 00 00	 mov	 ecx, 9
  002d7	8d bd ae fb ff
	ff		 lea	 edi, DWORD PTR _pMsgILC$[ebp+18]
  002dd	f3 a5		 rep movsd
  002df	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _sendBuf$[ebp]
  002e5	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  002ea	8d b5 9c fb ff
	ff		 lea	 esi, DWORD PTR _pMsgILC$[ebp]
  002f0	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _sendBuf$[ebp]
  002f6	52		 push	 edx
  002f7	f3 a5		 rep movsd
  002f9	50		 push	 eax
$LN18@CGPShopAns@2:

; 9132 : 		memcpy(pMsgILC.szPShopText, lpObjTarget->m_szPShopText, sizeof(pMsgILC.szPShopText));
; 9133 : 		memcpy(sendBuf, &pMsgILC, sizeof(pMsgILC));

  002fa	66 a5		 movsw
  002fc	a4		 movsb

; 9134 : 
; 9135 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  002fd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00302	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGPShopAns@2:

; 9136 : 	}
; 9137 : }

  00305	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00308	5f		 pop	 edi
  00309	5e		 pop	 esi
  0030a	33 cd		 xor	 ecx, ebp
  0030c	5b		 pop	 ebx
  0030d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00312	8b e5		 mov	 esp, ebp
  00314	5d		 pop	 ebp
  00315	c3		 ret	 0
?CGPShopAnsBuyList@@YAXHHE_N@Z ENDP			; CGPShopAnsBuyList
_TEXT	ENDS
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopAnsBuyItem@@YAXHHHE@Z			; CGPShopAnsBuyItem
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsBuyItem@@YAXHHHE@Z
_TEXT	SEGMENT
_aSourceIndex$GSCopy$ = -28				; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
_btResult$ = 20						; size = 1
?CGPShopAnsBuyItem@@YAXHHHE@Z PROC			; CGPShopAnsBuyItem, COMDAT

; 10199: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 10	 mov	 ebx, DWORD PTR _iItemPos$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  00018	57		 push	 edi

; 10200: 	PMSG_ANS_BUYITEM_FROM_PSHOP pMsg;
; 10201: 
; 10202: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x06, sizeof(pMsg));

  00019	6a 14		 push	 20			; 00000014H
  0001b	6a 06		 push	 6
  0001d	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00020	6a 3f		 push	 63			; 0000003fH
  00022	50		 push	 eax
  00023	89 75 e4	 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], esi
  00026	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 10203: 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);
; 10204: 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 10205: 	pMsg.btItemPos = iItemPos;
; 10206: 	pMsg.Result = btResult;
; 10207: 	ItemByteConvert(pMsg.cItemInfo, gObj[aSourceIndex].Inventory1[iItemPos]);

  0002b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00031	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00034	8a 55 14	 mov	 dl, BYTE PTR _btResult$[ebp]
  00037	88 5d fb	 mov	 BYTE PTR _pMsg$[ebp+19], bl
  0003a	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  00040	8b c8		 mov	 ecx, eax
  00042	c1 e9 08	 shr	 ecx, 8
  00045	88 45 ee	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  00050	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00053	8b b4 06 34 0e
	00 00		 mov	 esi, DWORD PTR [esi+eax+3636]
  0005a	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00060	8b fc		 mov	 edi, esp
  00062	03 f3		 add	 esi, ebx
  00064	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00069	f3 a5		 rep movsd
  0006b	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+7]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 10208: 
; 10209: 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00078	8b 4d e4	 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0007b	52		 push	 edx
  0007c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007f	50		 push	 eax
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10210: }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	33 cd		 xor	 ecx, ebp
  00093	5b		 pop	 ebx
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?CGPShopAnsBuyItem@@YAXHHHE@Z ENDP			; CGPShopAnsBuyItem
_TEXT	ENDS
PUBLIC	?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ; CGPShopReqCloseDeal
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z PROC ; CGPShopReqCloseDeal, COMDAT

; 10220: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 10221: 	if ( !gObjIsConnected(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 3e		 je	 SHORT $LN2@CGPShopReq

; 10222: 	{
; 10223: 		return;
; 10224: 	}
; 10225: 
; 10226: 	gObj[aIndex].m_bPShopWantDeal = false;

  00014	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00022	33 c9		 xor	 ecx, ecx
  00024	88 8c 10 ec 0e
	00 00		 mov	 BYTE PTR [eax+edx+3820], cl

; 10227: 	gObj[aIndex].m_iPShopDealerIndex =-1;

  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	c7 84 10 f0 0e
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+edx+3824], -1

; 10228: 	memset(gObj[aIndex].m_szPShopDealerName , 0, MAX_ACCOUNT_LEN);

  0003c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	8d 84 10 f4 0e
	00 00		 lea	 eax, DWORD PTR [eax+edx+3828]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004e	66 89 48 08	 mov	 WORD PTR [eax+8], cx
$LN2@CGPShopReq:
  00052	5e		 pop	 esi

; 10229: }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ENDP ; CGPShopReqCloseDeal
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopAnsSoldItem@@YAXHHH@Z			; CGPShopAnsSoldItem
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsSoldItem@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
?CGPShopAnsSoldItem@@YAXHHH@Z PROC			; CGPShopAnsSoldItem, COMDAT

; 10232: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]

; 10233: 	PMSG_ANS_SOLDITEM_FROM_PSHOP pMsg;
; 10234: 
; 10235: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x08, sizeof(pMsg));

  00014	6a 0f		 push	 15			; 0000000fH
  00016	6a 08		 push	 8
  00018	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001b	6a 3f		 push	 63			; 0000003fH
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 10236: 	pMsg.btItemPos = iItemPos;
; 10237: 	memcpy(pMsg.btName, gObj[aTargetIndex].Name, MAX_ACCOUNT_LEN);

  00023	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00029	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	8a 4d 10	 mov	 cl, BYTE PTR _iItemPos$[ebp]
  00032	8d 44 16 77	 lea	 eax, DWORD PTR [esi+edx+119]
  00036	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d f1	 mov	 DWORD PTR _pMsg$[ebp+5], ecx
  0003e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 10238: 
; 10239: 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00041	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00045	89 55 f5	 mov	 DWORD PTR _pMsg$[ebp+9], edx
  00048	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  0004c	51		 push	 ecx
  0004d	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00050	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax
  00054	8b 45 08	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10240: }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	83 c4 1c	 add	 esp, 28			; 0000001cH
  00064	33 cd		 xor	 ecx, ebp
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?CGPShopAnsSoldItem@@YAXHHH@Z ENDP			; CGPShopAnsSoldItem
_TEXT	ENDS
PUBLIC	?CGPShopAnsDealerClosedShop@@YAXHH@Z		; CGPShopAnsDealerClosedShop
; Function compile flags: /Ogtp
;	COMDAT ?CGPShopAnsDealerClosedShop@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
?CGPShopAnsDealerClosedShop@@YAXHH@Z PROC		; CGPShopAnsDealerClosedShop, COMDAT

; 10250: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 10251: 	PMSG_REQ_DEALER_CLOSED_SHOP pMsg;
; 10252: 
; 10253: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x12, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 12		 push	 18			; 00000012H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 10254: 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]

; 10255: 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 10256: 
; 10257: 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8b c8		 mov	 ecx, eax
  0001e	c1 e9 08	 shr	 ecx, 8
  00021	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00024	52		 push	 edx
  00025	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  0002e	50		 push	 eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00035	83 c4 1c	 add	 esp, 28			; 0000001cH

; 10258: }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?CGPShopAnsDealerClosedShop@@YAXHH@Z ENDP		; CGPShopAnsDealerClosedShop
_TEXT	ENDS
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5np@ ; `string'
PUBLIC	?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'P'
	DB	'arty result : %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5np@
CONST	SEGMENT
??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5np@ DB '[HACK'
	DB	'TOOL] : NPC-PartyRequest npc:%d ip:%s account:%s name:%s Stat'
	DB	'e:%d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_number$ = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z PROC	; CGPartyRequestRecv, COMDAT

; 10268: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 10269: 	int number =  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00011	66 c1 e1 08	 shl	 cx, 8
  00015	56		 push	 esi
  00016	0f b7 f1	 movzx	 esi, cx
  00019	0b f2		 or	 esi, edx
  0001b	89 75 08	 mov	 DWORD PTR _number$[ebp], esi

; 10270: 	PMSG_PARTYREQUESTSEND pMsg;
; 10271: 
; 10272: 	if ( number < 0 || number > OBJMAX-1)

  0001e	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00024	0f 87 e9 02 00
	00		 ja	 $LN15@CGPartyReq

; 10273: 	{
; 10274: 		return;
; 10275: 	}
; 10276: 
; 10277: 	if (!PacketCheckTime(&gObj[aIndex]))

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	53		 push	 ebx
  00030	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00033	57		 push	 edi
  00034	8b fb		 mov	 edi, ebx
  00036	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0003c	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 c1 02 00
	00		 je	 $LN26@CGPartyReq

; 10278: 	{
; 10279: 		return;
; 10280: 	}
; 10281: 
; 10282: 	if ( !gObjIsConnected(&gObj[number]))

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0005c	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00065	83 c4 04	 add	 esp, 4
  00068	85 c0		 test	 eax, eax
  0006a	75 14		 jne	 SHORT $LN13@CGPartyReq

; 10283: 	{
; 10284: 		::GCResultSend(aIndex, 0x41, 0x03);

  0006c	6a 03		 push	 3

; 10289: 	{
; 10290: 		::GCResultSend(aIndex, 0x41, 0x00);

  0006e	6a 41		 push	 65			; 00000041H
  00070	53		 push	 ebx
  00071	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	5f		 pop	 edi
  0007a	5b		 pop	 ebx
  0007b	5e		 pop	 esi

; 10392: }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN13@CGPartyReq:

; 10285: 		return;
; 10286: 	}
; 10287: 
; 10288: 	if ( gObj[aIndex].CloseCount >= 0 || gObj[number].CloseCount >= 0 )

  00080	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00085	80 7c 07 0a 00	 cmp	 BYTE PTR [edi+eax+10], 0
  0008a	0f 8d 74 02 00
	00		 jge	 $LN11@CGPartyReq
  00090	80 7c 06 0a 00	 cmp	 BYTE PTR [esi+eax+10], 0
  00095	0f 8d 69 02 00
	00		 jge	 $LN11@CGPartyReq

; 10291: 		return;
; 10292: 	} 
; 10293: 
; 10294: 	if( gObj[number].Type != OBJ_USER ) //season4 add-on

  0009b	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  000a1	74 3a		 je	 SHORT $LN10@CGPartyReq

; 10295: 	{
; 10296: 		LogAddC(2,"[HACKTOOL] : NPC-PartyRequest npc:%d ip:%s account:%s name:%s State:%d",
; 10297: 			gObj[number].Class,gObj[aIndex].Ip_addr,gObj[aIndex].AccountID,
; 10298: 			gObj[aIndex].Name,gObj[aIndex].Connected);

  000a3	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  000a7	51		 push	 ecx
  000a8	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  000ac	52		 push	 edx
  000ad	8d 4c 07 6c	 lea	 ecx, DWORD PTR [edi+eax+108]
  000b1	51		 push	 ecx
  000b2	8d 54 07 18	 lea	 edx, DWORD PTR [edi+eax+24]
  000b6	0f b7 84 06 b8
	00 00 00	 movzx	 eax, WORD PTR [esi+eax+184]
  000be	52		 push	 edx
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5np@
  000c5	6a 02		 push	 2
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 10299: 		CloseClient(aIndex);

  000cd	53		 push	 ebx
  000ce	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000d3	83 c4 20	 add	 esp, 32			; 00000020H
  000d6	5f		 pop	 edi
  000d7	5b		 pop	 ebx
  000d8	5e		 pop	 esi

; 10392: }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
$LN10@CGPartyReq:

; 10300: 		return;
; 10301: 	}
; 10302: 
; 10303: 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000dd	8a 8c 07 49 01
	00 00		 mov	 cl, BYTE PTR [edi+eax+329]
  000e4	80 f9 35	 cmp	 cl, 53			; 00000035H
  000e7	74 11		 je	 SHORT $LN25@CGPartyReq
  000e9	80 f9 12	 cmp	 cl, 18			; 00000012H
  000ec	72 2e		 jb	 SHORT $LN9@CGPartyReq
  000ee	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  000f3	3a d1		 cmp	 dl, cl
  000f5	1b d2		 sbb	 edx, edx
  000f7	42		 inc	 edx
  000f8	74 22		 je	 SHORT $LN9@CGPartyReq
$LN25@CGPartyReq:

; 10304: 	{
; 10305: 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), aIndex, 1);

  000fa	6a 01		 push	 1
  000fc	53		 push	 ebx
  000fd	68 c6 04 00 00	 push	 1222			; 000004c6H
$LN30@CGPartyReq:
  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00107	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
  00115	5f		 pop	 edi
  00116	5b		 pop	 ebx
  00117	5e		 pop	 esi

; 10392: }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN9@CGPartyReq:

; 10306: 		return;
; 10307: 	}
; 10308: 
; 10309: 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) ) //season 2.5 add-on

  0011c	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0011f	72 13		 jb	 SHORT $LN8@CGPartyReq
  00121	b2 32		 mov	 dl, 50			; 00000032H
  00123	3a d1		 cmp	 dl, cl
  00125	1b c9		 sbb	 ecx, ecx
  00127	41		 inc	 ecx
  00128	74 0a		 je	 SHORT $LN8@CGPartyReq

; 10310: 	{
; 10311: 		::GCServerMsgStringSend(lMsg.Get(3397), aIndex, 1);

  0012a	6a 01		 push	 1
  0012c	53		 push	 ebx
  0012d	68 45 0d 00 00	 push	 3397			; 00000d45H

; 10312: 		return;

  00132	eb ce		 jmp	 SHORT $LN30@CGPartyReq
$LN8@CGPartyReq:

; 10313: 	}
; 10314: 
; 10315: 	if ( szAuthKey[4] != AUTHKEY4 )

  00134	80 3d 04 00 00
	00 e1		 cmp	 BYTE PTR ?szAuthKey@@3PADA+4, -31 ; ffffffe1H
  0013b	74 0a		 je	 SHORT $LN7@CGPartyReq

; 10316: 	{
; 10317: 		DestroyGIocp();

  0013d	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN7@CGPartyReq:

; 10318: 	}
; 10319: 
; 10320: 	LogAddL("Party result : %d %d %d %d", gObj[aIndex].CloseCount, gObj[number].CloseCount, gObj[aIndex].Connected, gObj[number].Connected);

  00147	8b 4c 06 04	 mov	 ecx, DWORD PTR [esi+eax+4]
  0014b	8b 54 07 04	 mov	 edx, DWORD PTR [edi+eax+4]
  0014f	51		 push	 ecx
  00150	0f be 4c 06 0a	 movsx	 ecx, BYTE PTR [esi+eax+10]
  00155	52		 push	 edx
  00156	0f be 54 07 0a	 movsx	 edx, BYTE PTR [edi+eax+10]
  0015b	51		 push	 ecx
  0015c	52		 push	 edx
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 10321: 	LogAddL("%s %s", gObj[aIndex].Name, gObj[number].Name);

  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016d	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00171	51		 push	 ecx
  00172	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00176	52		 push	 edx
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 10322: 
; 10323: 	if ( gObj[aIndex].m_IfState.use > 0 )

  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00188	8d 84 0f 1c 0e
	00 00		 lea	 eax, DWORD PTR [edi+ecx+3612]
  0018f	83 c4 20	 add	 esp, 32			; 00000020H
  00192	f6 00 03	 test	 BYTE PTR [eax], 3

; 10324: 	{
; 10325: 		::GCResultSend(aIndex, 0x41, 0x00);
; 10326: 		return;

  00195	0f 87 69 01 00
	00		 ja	 $LN11@CGPartyReq

; 10327: 	}
; 10328: 		
; 10329: 	if ( gObj[number].m_IfState.use > 0 )

  0019b	f6 84 0e 1c 0e
	00 00 03	 test	 BYTE PTR [esi+ecx+3612], 3

; 10330: 	{
; 10331: 		::GCResultSend(aIndex, 0x41, 0x00);
; 10332: 		return;

  001a3	0f 87 5b 01 00
	00		 ja	 $LN11@CGPartyReq

; 10333: 	}
; 10334: 
; 10335: 	if ( (gObj[number].m_Option &1) != TRUE )

  001a9	f6 84 0e 8c 0e
	00 00 01	 test	 BYTE PTR [esi+ecx+3724], 1
  001b1	75 14		 jne	 SHORT $LN4@CGPartyReq

; 10336: 	{
; 10337: 		::GCResultSend(aIndex, 0x41, 0x01);

  001b3	6a 01		 push	 1
  001b5	6a 41		 push	 65			; 00000041H
  001b7	53		 push	 ebx
  001b8	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c0	5f		 pop	 edi
  001c1	5b		 pop	 ebx
  001c2	5e		 pop	 esi

; 10392: }

  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
$LN4@CGPartyReq:

; 10338: 		return;
; 10339: 	}
; 10340: #ifndef _NEW_PT_SYSTEM_
; 10341: 	if ( gObj[aIndex].PartyNumber >= 0 )
; 10342: 	{
; 10343: 		int iUserIndex;
; 10344: 		int iDbNumber;
; 10345: 		gParty.GetIndexUser(gObj[aIndex].PartyNumber, 0, iUserIndex, iDbNumber);
; 10346: 		
; 10347: 		if ( iUserIndex < 0 || ( iUserIndex != aIndex && gObj[aIndex].DBNumber != iDbNumber )  )
; 10348: 		{
; 10349: 			::GCResultSend(aIndex, 0x41, 0x00);
; 10350: 			return;
; 10351: 		}
; 10352: 	}
; 10353: #endif
; 10354: 
; 10355: 	if ( gObj[aIndex].PartyTargetUser >= 0 )

  001c7	83 bc 0f 30 04
	00 00 00	 cmp	 DWORD PTR [edi+ecx+1072], 0
  001cf	0f 8d 3c 01 00
	00		 jge	 $LN26@CGPartyReq

; 10356: 	{
; 10357: 		return;
; 10358: 	}
; 10359: 
; 10360: 	if ( gObj[number].PartyNumber >= 0 )

  001d5	83 bc 0e 2c 04
	00 00 00	 cmp	 DWORD PTR [esi+ecx+1068], 0
  001dd	7c 14		 jl	 SHORT $LN2@CGPartyReq

; 10361: 	{
; 10362: 		::GCResultSend(aIndex, 0x41, 0x04);

  001df	6a 04		 push	 4
  001e1	6a 41		 push	 65			; 00000041H
  001e3	53		 push	 ebx
  001e4	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ec	5f		 pop	 edi
  001ed	5b		 pop	 ebx
  001ee	5e		 pop	 esi

; 10392: }

  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
$LN2@CGPartyReq:

; 10363: 		return;
; 10364: 	}
; 10365: 
; 10366: 	if ( gObj[number].PartyTargetUser >= 0 )

  001f3	83 bc 0e 30 04
	00 00 00	 cmp	 DWORD PTR [esi+ecx+1072], 0

; 10367: 	{
; 10368: 		::GCResultSend(aIndex, 0x41, 0x00);
; 10369: 		return;

  001fb	0f 8d 03 01 00
	00		 jge	 $LN11@CGPartyReq

; 10370: 	}
; 10371: 
; 10372: 	int maxlevel = 0;
; 10373: 	int minlevel = 0;
; 10374: 
; 10375: 	gObj[aIndex].m_IfState.use = TRUE;

  00201	8b 08		 mov	 ecx, DWORD PTR [eax]
  00203	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00206	83 c9 01	 or	 ecx, 1
  00209	89 08		 mov	 DWORD PTR [eax], ecx

; 10376: 	gObj[aIndex].m_IfState.type = 2;

  0020b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00210	8b 94 07 1c 0e
	00 00		 mov	 edx, DWORD PTR [edi+eax+3612]
  00217	81 e2 bf 00 ff
	ff		 and	 edx, -65345		; ffff00bfH
  0021d	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00223	89 94 07 1c 0e
	00 00		 mov	 DWORD PTR [edi+eax+3612], edx

; 10377: 	gObj[aIndex].m_IfState.state = 0;

  0022a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022f	b9 c3 ff ff ff	 mov	 ecx, -61		; ffffffc3H
  00234	21 8c 07 1c 0e
	00 00		 and	 DWORD PTR [edi+eax+3612], ecx

; 10378: 	gObj[number].m_IfState.use = TRUE;

  0023b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00240	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00247	83 e2 fd	 and	 edx, -3			; fffffffdH
  0024a	83 ca 01	 or	 edx, 1
  0024d	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx

; 10379: 	gObj[number].m_IfState.type = 2;

  00254	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00259	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00260	81 e2 bf 00 ff
	ff		 and	 edx, -65345		; ffff00bfH
  00266	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0026c	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx

; 10380: 	gObj[number].m_IfState.state = 0;

  00273	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00278	21 8c 06 1c 0e
	00 00		 and	 DWORD PTR [esi+eax+3612], ecx

; 10381: 	gObj[aIndex].TargetNumber = number;

  0027f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00284	66 8b 4d 08	 mov	 cx, WORD PTR _number$[ebp]
  00288	66 89 8c 07 58
	04 00 00	 mov	 WORD PTR [edi+eax+1112], cx

; 10382: 	gObj[number].TargetNumber = aIndex;

  00290	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00296	66 89 9c 16 58
	04 00 00	 mov	 WORD PTR [esi+edx+1112], bx

; 10383: 	gObj[aIndex].m_InterfaceTime = GetTickCount();

  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002aa	89 84 0f 20 0e
	00 00		 mov	 DWORD PTR [edi+ecx+3616], eax

; 10384: 	gObj[number].m_InterfaceTime = GetTickCount();

  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bd	89 84 16 20 0e
	00 00		 mov	 DWORD PTR [esi+edx+3616], eax

; 10385: 	gObj[aIndex].PartyTargetUser = number;

  002c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c9	8b 75 08	 mov	 esi, DWORD PTR _number$[ebp]

; 10386: 	
; 10387: 	PHeadSetB((LPBYTE)&pMsg, 0x40, sizeof(pMsg));

  002cc	6a 05		 push	 5
  002ce	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  002d1	6a 40		 push	 64			; 00000040H
  002d3	51		 push	 ecx
  002d4	89 b4 07 30 04
	00 00		 mov	 DWORD PTR [edi+eax+1072], esi
  002db	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10388: 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 10389: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 10390: 
; 10391: 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  002e0	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002e4	50		 push	 eax
  002e5	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  002e8	8b d3		 mov	 edx, ebx
  002ea	51		 push	 ecx
  002eb	c1 ea 08	 shr	 edx, 8
  002ee	56		 push	 esi
  002ef	88 55 fb	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  002f2	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  002f5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002fa	83 c4 18	 add	 esp, 24			; 00000018H
  002fd	5f		 pop	 edi
  002fe	5b		 pop	 ebx
  002ff	5e		 pop	 esi

; 10392: }

  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c3		 ret	 0
$LN11@CGPartyReq:

; 10289: 	{
; 10290: 		::GCResultSend(aIndex, 0x41, 0x00);

  00304	6a 00		 push	 0
  00306	6a 41		 push	 65			; 00000041H
  00308	53		 push	 ebx
  00309	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0030e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@CGPartyReq:
  00311	5f		 pop	 edi
  00312	5b		 pop	 ebx
$LN15@CGPartyReq:
  00313	5e		 pop	 esi

; 10392: }

  00314	8b e5		 mov	 esp, ebp
  00316	5d		 pop	 ebp
  00317	c3		 ret	 0
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ENDP	; CGPartyRequestRecv
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPartyList@@YAXH@Z				; CGPartyList
EXTRN	?GCDisplayBuffeffectPartyMember@@YAXH@Z:PROC	; GCDisplayBuffeffectPartyMember
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; gObjIsConnected
EXTRN	?GetCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetCount
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
; Function compile flags: /Ogtp
;	COMDAT ?CGPartyList@@YAXH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -568					; size = 4
_number$ = -564						; size = 4
tv376 = -560						; size = 4
_pList$ = -556						; size = 24
_n$248061 = -532					; size = 4
_lOfs$ = -528						; size = 4
_pCount$ = -524						; size = 5
_sendbuf$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGPartyList@@YAXH@Z PROC				; CGPartyList, COMDAT

; 10566: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 02 00
	00		 sub	 esp, 568		; 00000238H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10567: 	PMSG_PARTYLISTCOUNT pCount;
; 10568: 	PMSG_PARTYLIST pList;
; 10569: 	BYTE sendbuf[512];
; 10570: 	int lOfs = 0;
; 10571: 
; 10572: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001d	8b f7		 mov	 esi, edi
  0001f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00025	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00028	51		 push	 ecx

; 10592: 	{
; 10593: 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00029	89 bd c8 fd ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  0002f	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00034	83 c4 04	 add	 esp, 4
  00037	85 c0		 test	 eax, eax
  00039	0f 84 ff 01 00
	00		 je	 $LN9@CGPartyLis

; 10573: 	{
; 10574: 		return;
; 10575: 	}
; 10576: 
; 10577: 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof(pCount));

  0003f	6a 05		 push	 5
  00041	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _pCount$[ebp]
  00047	6a 42		 push	 66			; 00000042H
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10578: 	pCount.Count = 0;
; 10579: 	pCount.Result = false;
; 10580: 
; 10581: 	int number;
; 10582: 	int pnumber = gObj[aIndex].PartyNumber ;

  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	66 c7 85 f7 fd
	ff ff 00 00	 mov	 WORD PTR _pCount$[ebp+3], 0
  0005e	8b b4 0e 2c 04
	00 00		 mov	 esi, DWORD PTR [esi+ecx+1068]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	32 c0		 xor	 al, al

; 10583: 
; 10584: 	if ( pnumber >= 0 )

  0006a	85 f6		 test	 esi, esi
  0006c	78 11		 js	 SHORT $LN7@CGPartyLis

; 10585: 	{
; 10586: 		pCount.Count = gParty.GetCount(pnumber);

  0006e	56		 push	 esi
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00074	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00079	88 85 f8 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], al
$LN7@CGPartyLis:

; 10587: 	}
; 10588: 
; 10589: 	lOfs += sizeof(pCount);

  0007f	b9 05 00 00 00	 mov	 ecx, 5
  00084	89 8d f0 fd ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], ecx

; 10590: 
; 10591: 	if ( pCount.Count != 0 )

  0008a	84 c0		 test	 al, al
  0008c	0f 84 83 01 00
	00		 je	 $LN6@CGPartyLis

; 10592: 	{
; 10593: 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00092	6b f6 68	 imul	 esi, 104		; 00000068H
  00095	81 c6 34 00 00
	00		 add	 esi, OFFSET ?gParty@@3VPartyClass@@A+52
  0009b	53		 push	 ebx
  0009c	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$248061[ebp], 0
  000a6	8d 9d 01 fe ff
	ff		 lea	 ebx, DWORD PTR _sendbuf$[ebp+5]
  000ac	8b fe		 mov	 edi, esi
  000ae	89 b5 d0 fd ff
	ff		 mov	 DWORD PTR tv376[ebp], esi
$LL5@CGPartyLis:

; 10594: 		{
; 10595: 			number = gParty.m_PartyS[pnumber].Number[n];

  000b4	8b 77 d8	 mov	 esi, DWORD PTR [edi-40]
  000b7	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _number$[ebp], esi

; 10596: 
; 10597: 			if ( number >= 0 )

  000bd	85 f6		 test	 esi, esi
  000bf	0f 88 17 01 00
	00		 js	 $LN4@CGPartyLis

; 10598: 			{
; 10599: 				if ( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE )

  000c5	8b 17		 mov	 edx, DWORD PTR [edi]
  000c7	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	52		 push	 edx
  000d3	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjIsConnected
  000dc	83 c4 08	 add	 esp, 8
  000df	83 f8 01	 cmp	 eax, 1
  000e2	0f 85 f4 00 00
	00		 jne	 $LN4@CGPartyLis

; 10600: 				{
; 10601: 					memset(&pList, 0, sizeof(pList));
; 10602: 					memcpy(pList.szId, gObj[number].Name, MAX_ACCOUNT_LEN);

  000e8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	8b 54 3e 77	 mov	 edx, DWORD PTR [esi+edi+119]

; 10603: 					pList.Number = n;
; 10604: 					pList.MapNumber = gObj[number].MapNumber;
; 10605: 					pList.X = gObj[number].X;
; 10606: 					pList.Y = gObj[number].Y;
; 10607: 					pList.Life = (int)gObj[number].Life;

  000f2	d9 84 3e fc 00
	00 00		 fld	 DWORD PTR [esi+edi+252]
  000f9	66 8b 4c 3e 7f	 mov	 cx, WORD PTR [esi+edi+127]
  000fe	33 c0		 xor	 eax, eax
  00100	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  00106	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], edx
  0010c	0f b6 95 ec fd
	ff ff		 movzx	 edx, BYTE PTR _n$248061[ebp]
  00113	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+8], eax
  00119	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+12], eax
  0011f	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  00125	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax
  0012b	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00131	8b 44 3e 7b	 mov	 eax, DWORD PTR [esi+edi+123]
  00135	88 95 de fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], dl
  0013b	0f b6 94 3e 46
	01 00 00	 movzx	 edx, BYTE PTR [esi+edi+326]
  00143	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  00149	8a 84 3e 49 01
	00 00		 mov	 al, BYTE PTR [esi+edi+329]
  00150	66 89 8d dc fd
	ff ff		 mov	 WORD PTR _pList$[ebp+8], cx
  00157	8a 8c 3e 44 01
	00 00		 mov	 cl, BYTE PTR [esi+edi+324]
  0015e	88 85 df fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al
  00164	88 8d e0 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], cl
  0016a	88 95 e1 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+13], dl
  00170	e8 00 00 00 00	 call	 __ftol2_sse
  00175	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax

; 10608: 					pList.MaxLife = (int)(gObj[number].MaxLife + gObj[number].AddLife);

  0017b	db 84 3e 4c 01
	00 00		 fild	 DWORD PTR [esi+edi+332]
  00182	d8 84 3e 00 01
	00 00		 fadd	 DWORD PTR [esi+edi+256]
  00189	e8 00 00 00 00	 call	 __ftol2_sse

; 10609: 
; 10610: 					memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  0018e	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp]
  00194	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _pList$[ebp+4]

; 10611: 					lOfs += sizeof(pList);

  0019a	83 85 f0 fd ff
	ff 18		 add	 DWORD PTR _lOfs$[ebp], 24 ; 00000018H
  001a1	89 0b		 mov	 DWORD PTR [ebx], ecx
  001a3	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp+8]
  001a9	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  001ac	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _pList$[ebp+12]
  001b2	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  001b5	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp+16]
  001bb	89 53 0c	 mov	 DWORD PTR [ebx+12], edx

; 10612: #ifdef _ZT_DEV_BUFF_PT_
; 10613: 					GCDisplayBuffeffectPartyMember(number);

  001be	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _number$[ebp]
  001c4	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx
  001c7	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  001ca	52		 push	 edx
  001cb	83 c3 18	 add	 ebx, 24			; 00000018H
  001ce	e8 00 00 00 00	 call	 ?GCDisplayBuffeffectPartyMember@@YAXH@Z ; GCDisplayBuffeffectPartyMember
  001d3	8b bd d0 fd ff
	ff		 mov	 edi, DWORD PTR tv376[ebp]
  001d9	83 c4 04	 add	 esp, 4
$LN4@CGPartyLis:

; 10592: 	{
; 10593: 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  001dc	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _n$248061[ebp]
  001e2	40		 inc	 eax
  001e3	83 c7 04	 add	 edi, 4
  001e6	89 85 ec fd ff
	ff		 mov	 DWORD PTR _n$248061[ebp], eax
  001ec	89 bd d0 fd ff
	ff		 mov	 DWORD PTR tv376[ebp], edi
  001f2	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001f5	0f 8c b9 fe ff
	ff		 jl	 $LL5@CGPartyLis

; 10614: #endif
; 10615: 				}
; 10616: 			}
; 10617: 		}
; 10618: 
; 10619: 		pCount.Result = true;

  001fb	8a 85 f8 fd ff
	ff		 mov	 al, BYTE PTR _pCount$[ebp+4]
  00201	8b bd c8 fd ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00207	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  0020d	c6 85 f7 fd ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1
  00214	5b		 pop	 ebx
$LN6@CGPartyLis:

; 10620: 	}
; 10621: 
; 10622: 	pCount.h.size = lOfs;
; 10623: 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00215	88 85 00 fe ff
	ff		 mov	 BYTE PTR _sendbuf$[ebp+4], al

; 10624: 	
; 10625: 	DataSend(aIndex, (LPBYTE)&sendbuf, lOfs);

  0021b	51		 push	 ecx
  0021c	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00222	88 8d f5 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], cl
  00228	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp]
  0022e	50		 push	 eax
  0022f	57		 push	 edi
  00230	89 95 fc fd ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], edx
  00236	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0023b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGPartyLis:

; 10626: }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	5f		 pop	 edi
  00242	33 cd		 xor	 ecx, ebp
  00244	5e		 pop	 esi
  00245	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
?CGPartyList@@YAXH@Z ENDP				; CGPartyList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGPartyListAll@@YAXH@Z				; CGPartyListAll
EXTRN	?IsParty@PartyClass@@QAEHH@Z:PROC		; PartyClass::IsParty
; Function compile flags: /Ogtp
;	COMDAT ?CGPartyListAll@@YAXH@Z
_TEXT	SEGMENT
tv398 = -564						; size = 4
tv380 = -560						; size = 4
_pList$ = -556						; size = 24
_n$248082 = -532					; size = 4
_lOfs$ = -528						; size = 4
_pCount$ = -524						; size = 5
_sendbuf$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGPartyListAll@@YAXH@Z PROC				; CGPartyListAll, COMDAT

; 10629: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 02 00
	00		 sub	 esp, 564		; 00000234H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pnumber$[ebp]

; 10630: 	PMSG_PARTYLISTCOUNT pCount;
; 10631: 	PMSG_PARTYLIST pList;
; 10632: 	BYTE sendbuf[512];
; 10633: 	int lOfs = 0;
; 10634: 	int number;
; 10635: 
; 10636: 	if ( pnumber < 0 )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 28 02 00
	00		 js	 $LN2@CGPartyLis@2

; 10637: 	{
; 10638: 		return;
; 10639: 	}
; 10640: 
; 10641: 	if ( gParty.IsParty(pnumber) == FALSE )

  0001f	56		 push	 esi
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00025	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 15 02 00
	00		 je	 $LN2@CGPartyLis@2

; 10642: 	{
; 10643: 		return;
; 10644: 	}
; 10645: 
; 10646: 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof(pCount));

  00032	6a 05		 push	 5
  00034	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0003a	6a 42		 push	 66			; 00000042H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10647: 	pCount.Result = false;
; 10648: 	pCount.Count = gParty.GetCount(pnumber);

  00045	56		 push	 esi
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0004b	c6 85 f7 fd ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+3], 0
  00052	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00057	88 85 f8 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], al

; 10649: 
; 10650: 	if ( pCount.Count == 0 )

  0005d	84 c0		 test	 al, al
  0005f	0f 84 e2 01 00
	00		 je	 $LN2@CGPartyLis@2

; 10651: 	{
; 10652: 		return;
; 10653: 	}
; 10654: 
; 10655: 	pCount.Result = true;

  00065	6b f6 68	 imul	 esi, 104		; 00000068H
  00068	53		 push	 ebx
  00069	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	8d 86 34 00 00
	00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[esi+52]
  00075	57		 push	 edi
  00076	c6 85 f7 fd ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1

; 10656: 	lOfs += sizeof(pCount);

  0007d	c7 85 f0 fd ff
	ff 05 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 5

; 10657: 
; 10658: 	for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00087	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$248082[ebp], 0
  00091	8d bd 01 fe ff
	ff		 lea	 edi, DWORD PTR _sendbuf$[ebp+5]
  00097	89 b5 cc fd ff
	ff		 mov	 DWORD PTR tv398[ebp], esi
  0009d	89 85 d0 fd ff
	ff		 mov	 DWORD PTR tv380[ebp], eax
$LL13@CGPartyLis@2:

; 10659: 	{
; 10660: 		number = gParty.m_PartyS[pnumber].Number[n];

  000a3	8b 70 d8	 mov	 esi, DWORD PTR [eax-40]

; 10661: 
; 10662: 		if ( number >= 0 )

  000a6	85 f6		 test	 esi, esi
  000a8	0f 88 f6 00 00
	00		 js	 $LN12@CGPartyLis@2

; 10663: 		{
; 10664: 			if ( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE )

  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000b6	51		 push	 ecx
  000b7	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjIsConnected

; 10665: 			{
; 10666: 				memset(&pList, 0, sizeof(pList));
; 10667: 				memcpy(pList.szId, gObj[number].Name, MAX_ACCOUNT_LEN);

  000c0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c6	83 c4 08	 add	 esp, 8
  000c9	83 f8 01	 cmp	 eax, 1
  000cc	0f 85 d2 00 00
	00		 jne	 $LN12@CGPartyLis@2
  000d2	8b 4c 1e 7b	 mov	 ecx, DWORD PTR [esi+ebx+123]

; 10668: 				pList.Number = n;
; 10669: 				pList.MapNumber = gObj[number].MapNumber;
; 10670: 				pList.X = gObj[number].X;
; 10671: 				pList.Y = gObj[number].Y;
; 10672: 				pList.Life = (int)gObj[number].Life;

  000d6	d9 84 1e fc 00
	00 00		 fld	 DWORD PTR [esi+ebx+252]
  000dd	66 8b 54 1e 7f	 mov	 dx, WORD PTR [esi+ebx+127]
  000e2	33 c0		 xor	 eax, eax
  000e4	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+8], eax
  000ea	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+12], eax
  000f0	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  000f6	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  000fc	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax
  00102	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00108	8b 44 1e 77	 mov	 eax, DWORD PTR [esi+ebx+119]
  0010c	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  00112	0f b6 85 ec fd
	ff ff		 movzx	 eax, BYTE PTR _n$248082[ebp]
  00119	88 85 de fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], al
  0011f	0f b6 84 1e 46
	01 00 00	 movzx	 eax, BYTE PTR [esi+ebx+326]
  00127	89 8d d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], ecx
  0012d	8a 8c 1e 49 01
	00 00		 mov	 cl, BYTE PTR [esi+ebx+329]
  00134	66 89 95 dc fd
	ff ff		 mov	 WORD PTR _pList$[ebp+8], dx
  0013b	8a 94 1e 44 01
	00 00		 mov	 dl, BYTE PTR [esi+ebx+324]
  00142	88 8d df fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], cl
  00148	88 95 e0 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], dl
  0014e	88 85 e1 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+13], al
  00154	e8 00 00 00 00	 call	 __ftol2_sse
  00159	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax

; 10673: 				pList.MaxLife =  (int)gObj[number].MaxLife;

  0015f	d9 84 1e 00 01
	00 00		 fld	 DWORD PTR [esi+ebx+256]
  00166	e8 00 00 00 00	 call	 __ftol2_sse

; 10674: 
; 10675: 				memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  0016b	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp]
  00171	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _pList$[ebp+4]

; 10676: 				lOfs += sizeof(pList);

  00177	83 85 f0 fd ff
	ff 18		 add	 DWORD PTR _lOfs$[ebp], 24 ; 00000018H
  0017e	89 0f		 mov	 DWORD PTR [edi], ecx
  00180	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp+8]
  00186	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00189	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _pList$[ebp+12]
  0018f	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00192	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pList$[ebp+16]
  00198	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  0019b	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0019e	89 47 14	 mov	 DWORD PTR [edi+20], eax
  001a1	83 c7 18	 add	 edi, 24			; 00000018H
$LN12@CGPartyLis@2:

; 10657: 
; 10658: 	for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  001a4	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _n$248082[ebp]
  001aa	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR tv380[ebp]
  001b0	41		 inc	 ecx
  001b1	83 c0 04	 add	 eax, 4
  001b4	89 8d ec fd ff
	ff		 mov	 DWORD PTR _n$248082[ebp], ecx
  001ba	89 85 d0 fd ff
	ff		 mov	 DWORD PTR tv380[ebp], eax
  001c0	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  001c3	0f 8c da fe ff
	ff		 jl	 $LL13@CGPartyLis@2

; 10677: 			}
; 10678: 		}
; 10679: 	}
; 10680: 
; 10681: 	pCount.h.size = lOfs;

  001c9	8a 95 f0 fd ff
	ff		 mov	 dl, BYTE PTR _lOfs$[ebp]
  001cf	8b 9d cc fd ff
	ff		 mov	 ebx, DWORD PTR tv398[ebp]

; 10682: 	memcpy(sendbuf, &pCount, sizeof(pCount));

  001d5	8a 8d f8 fd ff
	ff		 mov	 cl, BYTE PTR _pCount$[ebp+4]
  001db	88 95 f5 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], dl
  001e1	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  001e7	8d 9b 0c 00 00
	00		 lea	 ebx, DWORD PTR ?gParty@@3VPartyClass@@A[ebx+12]
  001ed	89 85 fc fd ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  001f3	88 8d 00 fe ff
	ff		 mov	 BYTE PTR _sendbuf$[ebp+4], cl
  001f9	8b f3		 mov	 esi, ebx
  001fb	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
$LL27@CGPartyLis@2:

; 10685: 	{
; 10686: 		number = gParty.m_PartyS[pnumber].Number[n];

  00200	8b 06		 mov	 eax, DWORD PTR [esi]

; 10687: 
; 10688: 		if ( number >= 0 )

  00202	85 c0		 test	 eax, eax
  00204	78 17		 js	 SHORT $LN7@CGPartyLis@2

; 10689: 		{
; 10690: 			DataSend(number, sendbuf, lOfs);

  00206	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  0020c	52		 push	 edx
  0020d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  00213	51		 push	 ecx
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0021a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGPartyLis@2:

; 10683: 
; 10684: 	for (int n=0;n<MAX_USER_IN_PARTY;n++)

  0021d	83 c6 04	 add	 esi, 4
  00220	4f		 dec	 edi
  00221	75 dd		 jne	 SHORT $LL27@CGPartyLis@2

; 10691: 		}
; 10692: 	}
; 10693: 
; 10694: #ifdef _ZT_DEV_BUFF_PT_
; 10695:     for (int nb = 0; nb < 5; ++nb )

  00223	8b f3		 mov	 esi, ebx
  00225	bf 05 00 00 00	 mov	 edi, 5
  0022a	8d 9b 00 00 00
	00		 npad	 6
$LL4@CGPartyLis@2:

; 10696:     {
; 10697:         number = gParty.m_PartyS[pnumber].Number[nb];

  00230	8b 06		 mov	 eax, DWORD PTR [esi]

; 10698:         if ( number >= 0 )

  00232	85 c0		 test	 eax, eax
  00234	78 09		 js	 SHORT $LN3@CGPartyLis@2

; 10699: 		{
; 10700: 			GCDisplayBuffeffectPartyMember(number);

  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 ?GCDisplayBuffeffectPartyMember@@YAXH@Z ; GCDisplayBuffeffectPartyMember
  0023c	83 c4 04	 add	 esp, 4
$LN3@CGPartyLis@2:

; 10691: 		}
; 10692: 	}
; 10693: 
; 10694: #ifdef _ZT_DEV_BUFF_PT_
; 10695:     for (int nb = 0; nb < 5; ++nb )

  0023f	83 c6 04	 add	 esi, 4
  00242	4f		 dec	 edi
  00243	75 eb		 jne	 SHORT $LL4@CGPartyLis@2
  00245	5f		 pop	 edi
  00246	5b		 pop	 ebx
$LN2@CGPartyLis@2:

; 10701: 		}
; 10702:     }
; 10703: #endif
; 10704: }

  00247	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024a	33 cd		 xor	 ecx, ebp
  0024c	5e		 pop	 esi
  0024d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00252	8b e5		 mov	 esp, ebp
  00254	5d		 pop	 ebp
  00255	c3		 ret	 0
?CGPartyListAll@@YAXH@Z ENDP				; CGPartyListAll
_TEXT	ENDS
PUBLIC	?GCPartyDelUserSend@@YAXH@Z			; GCPartyDelUserSend
; Function compile flags: /Ogtp
;	COMDAT ?GCPartyDelUserSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCPartyDelUserSend@@YAXH@Z PROC			; GCPartyDelUserSend, COMDAT

; 10969: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10970: 	PMSG_PARTYDELUSERSEND pMsg;
; 10971: 
; 10972: 	PHeadSetB((LPBYTE)&pMsg, 0x43, sizeof(pMsg));

  00004	6a 03		 push	 3
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 43		 push	 67			; 00000043H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10973: 
; 10974: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00015	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00018	51		 push	 ecx
  00019	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0001c	52		 push	 edx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00023	83 c4 18	 add	 esp, 24			; 00000018H

; 10975: }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?GCPartyDelUserSend@@YAXH@Z ENDP			; GCPartyDelUserSend
_TEXT	ENDS
PUBLIC	??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@ ; `string'
PUBLIC	??_C@_0FF@BDHDGNPM@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Guild@ ; `string'
PUBLIC	??_C@_0EI@MFMMLBKJ@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@ ; `string'
PUBLIC	??_C@_0DM@EGCNGFFB@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@ ; `string'
PUBLIC	??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5np@ ; `string'
PUBLIC	?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z	; CGGuildRequestRecv
EXTRN	?GetGensInfluenceName@GensSystem@@QAEPADPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::GetGensInfluenceName
EXTRN	?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; GensSystem::GetGensInfluence
;	COMDAT ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@
; File e:\work\tranet_version\gs\gameserver\castlesiegesync.h
CONST	SEGMENT
??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@ DB '['
	DB	'%s][%s] Guild Request - Join : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@BDHDGNPM@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Guild@
CONST	SEGMENT
??_C@_0FF@BDHDGNPM@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Guild@ DB '['
	DB	'GensSystem] [%s][%s] [%s] Guild Joining Failed to Gens be Dif'
	DB	'ferent : [%s][%s] [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@MFMMLBKJ@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@
CONST	SEGMENT
??_C@_0EI@MFMMLBKJ@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@ DB '['
	DB	'GensSystem] [%s][%s] Guild Joining Failed to Not Join Gens Gu'
	DB	'ildMaster', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EGCNGFFB@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@
CONST	SEGMENT
??_C@_0DM@EGCNGFFB@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@ DB '['
	DB	'GensSystem] [%s][%s] Guild Joining Failed to Not Join Gens', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5np@
CONST	SEGMENT
??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5np@ DB '[HACK'
	DB	'TOOL] : NPC-GuildRequest npc:%d ip:%s account:%s name:%s Stat'
	DB	'e:%d', 00H					; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
tv728 = -4						; size = 4
tv686 = 8						; size = 4
_number$ = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z PROC	; CGGuildRequestRecv, COMDAT

; 10985: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 10986: 	PMSG_GUILDQUESTSEND pMsg;
; 10987: 	int number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00011	66 c1 e1 08	 shl	 cx, 8
  00015	56		 push	 esi
  00016	0f b7 f1	 movzx	 esi, cx
  00019	0b f2		 or	 esi, edx
  0001b	89 75 08	 mov	 DWORD PTR _number$[ebp], esi

; 10988: 
; 10989: 	if ( number < 0 || number > OBJMAX-1 )

  0001e	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00024	0f 87 d4 06 00
	00		 ja	 $LN39@CGGuildReq

; 10990: 	{
; 10991: 		return;
; 10992: 	}
; 10993: 
; 10994: 	if ( !PacketCheckTime(&gObj[aIndex]))

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	53		 push	 ebx
  00030	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00033	57		 push	 edi
  00034	8b fb		 mov	 edi, ebx
  00036	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0003c	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 ac 06 00
	00		 je	 $LN60@CGGuildReq

; 10995: 	{
; 10996: 		return;
; 10997: 	}
; 10998: 
; 10999: //#if(GS_CASTLE==1)
; 11000: 	if(g_ZtLicense.CheckUser(eZtUB::PrideMu) || g_ZtLicense.CheckUser(eZtUB::PrideMuLocal) || g_ZtLicense.CheckUser(eZtUB::Local3))

  00050	6a 11		 push	 17			; 00000011H
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00057	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0005c	84 c0		 test	 al, al
  0005e	75 49		 jne	 SHORT $LN36@CGGuildReq
  00060	6a 1a		 push	 26			; 0000001aH
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00067	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0006c	84 c0		 test	 al, al
  0006e	75 39		 jne	 SHORT $LN36@CGGuildReq
  00070	6a 1c		 push	 28			; 0000001cH
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00077	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0007c	84 c0		 test	 al, al
  0007e	75 29		 jne	 SHORT $LN36@CGGuildReq

; 11001: 	{
; 11002: 		//Enter Guild to Castle Siege
; 11003: 	}
; 11004: 	else
; 11005: 	{
; 11006: 		if(g_CastleSiegeSync.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  00080	83 3d 04 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4, 7
  00087	75 20		 jne	 SHORT $LN36@CGGuildReq

; 11007: 		{
; 11008: 			MsgOutput(aIndex,(lMsg.Get(MSGGET(6, 194))));

  00089	68 c2 06 00 00	 push	 1730			; 000006c2H
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00093	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00098	50		 push	 eax
  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0009f	83 c4 08	 add	 esp, 8
  000a2	5f		 pop	 edi
  000a3	5b		 pop	 ebx
  000a4	5e		 pop	 esi

; 11209: }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN36@CGGuildReq:

; 11009: 			return;
; 11010: 		}
; 11011: 	}
; 11012: //#endif
; 11013: 
; 11014: 	if( IT_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE ) //season 2.5 add-on

  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000af	0f b6 84 0f 49
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+329]
  000b7	3c 2d		 cmp	 al, 45			; 0000002dH
  000b9	72 29		 jb	 SHORT $LN53@CGGuildReq
  000bb	b2 32		 mov	 dl, 50			; 00000032H
  000bd	3a d0		 cmp	 dl, al
  000bf	1b c0		 sbb	 eax, eax
  000c1	40		 inc	 eax
  000c2	74 20		 je	 SHORT $LN53@CGGuildReq

; 11015: 	{
; 11016: 		MsgOutput(aIndex,(lMsg.Get(3398)));

  000c4	68 46 0d 00 00	 push	 3398			; 00000d46H
  000c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ce	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000d3	50		 push	 eax
  000d4	53		 push	 ebx
  000d5	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000da	83 c4 08	 add	 esp, 8
  000dd	5f		 pop	 edi
  000de	5b		 pop	 ebx
  000df	5e		 pop	 esi

; 11209: }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN53@CGGuildReq:

; 11017: 		return;
; 11018: 	}
; 11019: 
; 11020: 	if ( !gObjIsConnected(&gObj[number]))

  000e4	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000ea	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000f3	83 c4 04	 add	 esp, 4
  000f6	85 c0		 test	 eax, eax
  000f8	75 14		 jne	 SHORT $LN32@CGGuildReq

; 11021: 	{
; 11022: 		GCResultSend(aIndex, 0x51, 0x03);

  000fa	6a 03		 push	 3

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  000fc	6a 51		 push	 81			; 00000051H
  000fe	53		 push	 ebx
  000ff	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
  00107	5f		 pop	 edi
  00108	5b		 pop	 ebx
  00109	5e		 pop	 esi

; 11209: }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN32@CGGuildReq:

; 11023: 		return;
; 11024: 	}
; 11025: 
; 11026: 
; 11027: 	if ( gObj[aIndex].m_IfState.use > 0 )

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00113	f6 84 07 1c 0e
	00 00 03	 test	 BYTE PTR [edi+eax+3612], 3
  0011b	76 14		 jbe	 SHORT $LN31@CGGuildReq
$LN64@CGGuildReq:

; 11028: 	{
; 11029: 		GCResultSend(aIndex, 0x51, 0x06);

  0011d	6a 06		 push	 6

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  0011f	6a 51		 push	 81			; 00000051H
  00121	53		 push	 ebx
  00122	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012a	5f		 pop	 edi
  0012b	5b		 pop	 ebx
  0012c	5e		 pop	 esi

; 11209: }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
$LN31@CGGuildReq:

; 11030: 		return;
; 11031: 	}
; 11032: 
; 11033: 	if ( gObj[aIndex].Level < 6 )

  00131	66 83 bc 07 be
	00 00 00 06	 cmp	 WORD PTR [edi+eax+190], 6
  0013a	7d 14		 jge	 SHORT $LN30@CGGuildReq

; 11034: 	{
; 11035: 		GCResultSend(aIndex, 0x51, 0x07);

  0013c	6a 07		 push	 7

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  0013e	6a 51		 push	 81			; 00000051H
  00140	53		 push	 ebx
  00141	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH
  00149	5f		 pop	 edi
  0014a	5b		 pop	 ebx
  0014b	5e		 pop	 esi

; 11209: }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
$LN30@CGGuildReq:

; 11036: 		return;
; 11037: 	}
; 11038: 
; 11039: 	if ( gObj[aIndex].GuildNumber > 0 )

  00150	83 bc 07 34 04
	00 00 00	 cmp	 DWORD PTR [edi+eax+1076], 0
  00158	7e 14		 jle	 SHORT $LN29@CGGuildReq

; 11040: 	{
; 11041: 		GCResultSend(aIndex, 0x51, 0x05);

  0015a	6a 05		 push	 5

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  0015c	6a 51		 push	 81			; 00000051H
  0015e	53		 push	 ebx
  0015f	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH
  00167	5f		 pop	 edi
  00168	5b		 pop	 ebx
  00169	5e		 pop	 esi

; 11209: }

  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
$LN29@CGGuildReq:

; 11042: 		return;
; 11043: 	}
; 11044: 
; 11045: 	if ( (gObj[number].m_Option&1 ) != 1 )

  0016e	f6 84 06 8c 0e
	00 00 01	 test	 BYTE PTR [esi+eax+3724], 1
  00176	75 14		 jne	 SHORT $LN28@CGGuildReq

; 11046: 	{
; 11047: 		GCResultSend(aIndex, 0x51, 0x00);

  00178	6a 00		 push	 0

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  0017a	6a 51		 push	 81			; 00000051H
  0017c	53		 push	 ebx
  0017d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	5f		 pop	 edi
  00186	5b		 pop	 ebx
  00187	5e		 pop	 esi

; 11209: }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
$LN28@CGGuildReq:

; 11048: 		return;
; 11049: 	}
; 11050: 
; 11051: 	if( gObj[number].Type != OBJ_USER ) //season4 add-on

  0018c	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00192	74 3a		 je	 SHORT $LN27@CGGuildReq

; 11052: 	{
; 11053: 		LogAddC(2,"[HACKTOOL] : NPC-GuildRequest npc:%d ip:%s account:%s name:%s State:%d",
; 11054: 			gObj[number].Class,gObj[aIndex].Ip_addr,gObj[aIndex].AccountID,
; 11055: 			gObj[aIndex].Name,gObj[aIndex].Connected);

  00194	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  00198	51		 push	 ecx
  00199	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  0019d	52		 push	 edx
  0019e	8d 4c 07 6c	 lea	 ecx, DWORD PTR [edi+eax+108]
  001a2	51		 push	 ecx
  001a3	8d 54 07 18	 lea	 edx, DWORD PTR [edi+eax+24]
  001a7	0f b7 84 06 b8
	00 00 00	 movzx	 eax, WORD PTR [esi+eax+184]
  001af	52		 push	 edx
  001b0	50		 push	 eax
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5np@
  001b6	6a 02		 push	 2
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 11056: 		CloseClient(aIndex);

  001be	53		 push	 ebx
  001bf	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  001c4	83 c4 20	 add	 esp, 32			; 00000020H
  001c7	5f		 pop	 edi
  001c8	5b		 pop	 ebx
  001c9	5e		 pop	 esi

; 11209: }

  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
$LN27@CGGuildReq:

; 11057: 		return;
; 11058: 	}
; 11059: 
; 11060: 	if(gObj[number].lpGuild->WareOpen)

  001ce	8b 8c 06 38 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1080]
  001d5	83 b9 44 07 00
	00 00		 cmp	 DWORD PTR [ecx+1860], 0

; 11061: 	{
; 11062: 		GCResultSend(aIndex, 0x51, 0x06);
; 11063: 		return;

  001dc	0f 85 3b ff ff
	ff		 jne	 $LN64@CGGuildReq

; 11064: 	}
; 11065: 
; 11066: 	if ( gObj[number].GuildNumber > 0 )

  001e2	83 bc 06 34 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1076], 0
  001ea	0f 8e ff 04 00
	00		 jle	 $LN25@CGGuildReq

; 11067: 	{
; 11068: #if(FIX_AGM_REQVALLIANCE || ENABLE_AGMASTER)
; 11069: 		if( g_ZtLicense.CheckUser(eZtUB::Gredy) || 
; 11070: 			g_ZtLicense.CheckUser(eZtUB::Gredy2) || 
; 11071: 			g_ZtLicense.CheckUser(eZtUB::GredyLocal) || 
; 11072: 			g_ZtLicense.CheckUser(eZtUB::mu4you) ||
; 11073: 			g_ZtLicense.CheckUser(eZtUB::NSGames) || 
; 11074: 			g_ZtLicense.CheckUser(eZtUB::MUDev))	

  001f0	6a 20		 push	 32			; 00000020H
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001f7	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001fc	84 c0		 test	 al, al
  001fe	0f 85 ae 00 00
	00		 jne	 $LN54@CGGuildReq
  00204	6a 22		 push	 34			; 00000022H
  00206	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0020b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00210	84 c0		 test	 al, al
  00212	0f 85 9a 00 00
	00		 jne	 $LN54@CGGuildReq
  00218	6a 21		 push	 33			; 00000021H
  0021a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0021f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00224	84 c0		 test	 al, al
  00226	0f 85 86 00 00
	00		 jne	 $LN54@CGGuildReq
  0022c	6a 4e		 push	 78			; 0000004eH
  0022e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00233	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00238	84 c0		 test	 al, al
  0023a	75 76		 jne	 SHORT $LN54@CGGuildReq
  0023c	6a 51		 push	 81			; 00000051H
  0023e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00243	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00248	84 c0		 test	 al, al
  0024a	75 66		 jne	 SHORT $LN54@CGGuildReq
  0024c	6a 53		 push	 83			; 00000053H
  0024e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00253	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00258	84 c0		 test	 al, al
  0025a	75 56		 jne	 SHORT $LN54@CGGuildReq

; 11079: 				return;
; 11080: 			}
; 11081: 		}
; 11082: 		else
; 11083: #endif
; 11084: 		{
; 11085: 			if ( strcmp(gObj[number].lpGuild->Names[0], gObj[number].Name))

  0025c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00262	8b 84 16 38 04
	00 00		 mov	 eax, DWORD PTR [esi+edx+1080]
  00269	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  0026c	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0026f	83 c0 2f	 add	 eax, 47			; 0000002fH
$LL47@CGGuildReq:
  00272	8a 10		 mov	 dl, BYTE PTR [eax]
  00274	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00276	75 1a		 jne	 SHORT $LN48@CGGuildReq
  00278	84 d2		 test	 dl, dl
  0027a	74 12		 je	 SHORT $LN49@CGGuildReq
  0027c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0027f	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00282	75 0e		 jne	 SHORT $LN48@CGGuildReq
  00284	83 c0 02	 add	 eax, 2
  00287	83 c1 02	 add	 ecx, 2
  0028a	84 d2		 test	 dl, dl
  0028c	75 e4		 jne	 SHORT $LL47@CGGuildReq
$LN49@CGGuildReq:
  0028e	33 c0		 xor	 eax, eax
  00290	eb 05		 jmp	 SHORT $LN50@CGGuildReq
$LN48@CGGuildReq:
  00292	1b c0		 sbb	 eax, eax
  00294	83 d8 ff	 sbb	 eax, -1
$LN50@CGGuildReq:
  00297	85 c0		 test	 eax, eax
  00299	74 4a		 je	 SHORT $LN22@CGGuildReq

; 11086: 			{
; 11087: 				GCResultSend(aIndex, 0x51, 0x04);

  0029b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0029e	6a 04		 push	 4
  002a0	6a 51		 push	 81			; 00000051H
  002a2	50		 push	 eax

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  002a3	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ab	5f		 pop	 edi
  002ac	5b		 pop	 ebx
  002ad	5e		 pop	 esi

; 11209: }

  002ae	8b e5		 mov	 esp, ebp
  002b0	5d		 pop	 ebp
  002b1	c3		 ret	 0
$LN54@CGGuildReq:

; 11075: 		{
; 11076: 			if( gObj[number].GuildStatus != G_MASTER && gObj[number].GuildStatus != G_SUB_MASTER )

  002b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b8	8b 84 0e 48 04
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1096]
  002bf	8d 1c 0e	 lea	 ebx, DWORD PTR [esi+ecx]
  002c2	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002c7	74 1c		 je	 SHORT $LN22@CGGuildReq
  002c9	83 f8 40	 cmp	 eax, 64			; 00000040H
  002cc	74 17		 je	 SHORT $LN22@CGGuildReq

; 11077: 			{
; 11078: 				GCResultSend(aIndex, 0x51, 0x04);

  002ce	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002d1	6a 04		 push	 4
  002d3	6a 51		 push	 81			; 00000051H
  002d5	52		 push	 edx

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  002d6	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002db	83 c4 0c	 add	 esp, 12			; 0000000cH
  002de	5f		 pop	 edi
  002df	5b		 pop	 ebx
  002e0	5e		 pop	 esi

; 11209: }

  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c3		 ret	 0
$LN22@CGGuildReq:

; 11088: 				return;
; 11089: 			}
; 11090: 		}
; 11091: 
; 11092: 		#if(DEV_GUILDBANK)
; 11093: 		if ( gObj[number].lpGuild->WarState )

  002e5	8b 83 38 04 00
	00		 mov	 eax, DWORD PTR [ebx+1080]
  002eb	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  002f2	74 17		 je	 SHORT $LN19@CGGuildReq
$LN65@CGGuildReq:

; 11094: 		{
; 11095: 			GCResultSend(aIndex, 0x51, 0x06);

  002f4	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002f7	6a 06		 push	 6
  002f9	6a 51		 push	 81			; 00000051H
  002fb	51		 push	 ecx

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  002fc	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00301	83 c4 0c	 add	 esp, 12			; 0000000cH
  00304	5f		 pop	 edi
  00305	5b		 pop	 ebx
  00306	5e		 pop	 esi

; 11209: }

  00307	8b e5		 mov	 esp, ebp
  00309	5d		 pop	 ebp
  0030a	c3		 ret	 0
$LN19@CGGuildReq:

; 11096: 			return;
; 11097: 		}
; 11098: 		#endif
; 11099: 
; 11100: #if(EVOMU_HOSTILITY_DEL)
; 11101: 	if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || g_ZtLicense.CheckUser(eZtUB::GredyLocal))	

  0030b	6a 20		 push	 32			; 00000020H
  0030d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00312	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00317	84 c0		 test	 al, al
  00319	75 20		 jne	 SHORT $LN57@CGGuildReq
  0031b	6a 22		 push	 34			; 00000022H
  0031d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00322	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00327	84 c0		 test	 al, al
  00329	75 10		 jne	 SHORT $LN57@CGGuildReq
  0032b	6a 21		 push	 33			; 00000021H
  0032d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00332	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00337	84 c0		 test	 al, al
  00339	74 16		 je	 SHORT $LN59@CGGuildReq
$LN57@CGGuildReq:

; 11102: 	{
; 11103: 		if(gObj[number].lpGuild->iGuildRival > 0)

  0033b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00341	8b 84 16 38 04
	00 00		 mov	 eax, DWORD PTR [esi+edx+1080]
  00348	83 b8 20 07 00
	00 00		 cmp	 DWORD PTR [eax+1824], 0

; 11104: 		{
; 11105: 			GCResultSend(aIndex, 0x51, 0x06);
; 11106: 			return;

  0034f	7f a3		 jg	 SHORT $LN65@CGGuildReq
$LN59@CGGuildReq:

; 11107: 		}
; 11108: 	}
; 11109: #endif	
; 11110: 
; 11111: #if(FIX_AGM_REQVALLIANCE || ENABLE_AGMASTER)
; 11112: 		if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || g_ZtLicense.CheckUser(eZtUB::GredyLocal))

  00351	6a 20		 push	 32			; 00000020H
  00353	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00358	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0035d	84 c0		 test	 al, al
  0035f	75 20		 jne	 SHORT $LN14@CGGuildReq
  00361	6a 22		 push	 34			; 00000022H
  00363	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00368	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0036d	84 c0		 test	 al, al
  0036f	75 10		 jne	 SHORT $LN14@CGGuildReq
  00371	6a 21		 push	 33			; 00000021H
  00373	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00378	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0037d	84 c0		 test	 al, al
  0037f	74 2a		 je	 SHORT $LN51@CGGuildReq
$LN14@CGGuildReq:

; 11113: 		{
; 11114: 			if ( gObj[number].lpGuild->TotalCount >= MAX_USER_GUILD )

  00381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00387	8b 94 0e 38 04
	00 00		 mov	 edx, DWORD PTR [esi+ecx+1080]
  0038e	80 7a 2e 50	 cmp	 BYTE PTR [edx+46], 80	; 00000050H
  00392	72 1d		 jb	 SHORT $LN13@CGGuildReq

; 11115: 			{
; 11116: 				GCResultSend(aIndex, 0x51, 0x02);

  00394	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00397	6a 02		 push	 2
  00399	6a 51		 push	 81			; 00000051H
  0039b	50		 push	 eax

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  0039c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  003a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a4	5f		 pop	 edi
  003a5	5b		 pop	 ebx
  003a6	5e		 pop	 esi

; 11209: }

  003a7	8b e5		 mov	 esp, ebp
  003a9	5d		 pop	 ebp
  003aa	c3		 ret	 0
$LN51@CGGuildReq:

; 11117: 				return;

  003ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN13@CGGuildReq:

; 11118: 			}
; 11119: 		}
; 11120: #endif
; 11121: 
; 11122: 		int MaxGuildMember = MAX_USER_GUILD;
; 11123: 
; 11124: 		if ( gObj[number].Class == CLASS_DARKLORD )

  003b1	66 83 bc 0e b8
	00 00 00 04	 cmp	 WORD PTR [esi+ecx+184], 4

; 11125: 		{
; 11126: 			MaxGuildMember = (gObj[number].Level+gObj[number].MLevel) / 10 + gObj[number].Leadership / 10;

  003ba	0f bf 94 0e d0
	00 00 00	 movsx	 edx, WORD PTR [esi+ecx+208]
  003c2	75 3e		 jne	 SHORT $LN12@CGGuildReq
  003c4	0f bf 84 0e be
	00 00 00	 movsx	 eax, WORD PTR [esi+ecx+190]
  003cc	03 d0		 add	 edx, eax
  003ce	0f b7 8c 0e 18
	01 00 00	 movzx	 ecx, WORD PTR [esi+ecx+280]
  003d6	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  003db	f7 ea		 imul	 edx
  003dd	c1 fa 02	 sar	 edx, 2
  003e0	8b c2		 mov	 eax, edx
  003e2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003e5	03 c2		 add	 eax, edx
  003e7	89 45 fc	 mov	 DWORD PTR tv728[ebp], eax
  003ea	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  003ef	f7 e9		 imul	 ecx
  003f1	8b 45 fc	 mov	 eax, DWORD PTR tv728[ebp]
  003f4	c1 fa 02	 sar	 edx, 2
  003f7	8b da		 mov	 ebx, edx
  003f9	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  003fc	03 c2		 add	 eax, edx
  003fe	03 d8		 add	 ebx, eax

; 11127: 		}
; 11128: 		else

  00400	eb 1b		 jmp	 SHORT $LN11@CGGuildReq
$LN12@CGGuildReq:

; 11129: 		{
; 11130: 			MaxGuildMember = (gObj[number].Level+gObj[number].MLevel) / 10;

  00402	0f bf 8c 0e be
	00 00 00	 movsx	 ecx, WORD PTR [esi+ecx+190]
  0040a	03 d1		 add	 edx, ecx
  0040c	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00411	f7 ea		 imul	 edx
  00413	c1 fa 02	 sar	 edx, 2
  00416	8b da		 mov	 ebx, edx
  00418	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0041b	03 da		 add	 ebx, edx
$LN11@CGGuildReq:

; 11131: 		}
; 11132: 
; 11133: 		if(g_ZtLicense.CheckUser(Gredy) || g_ZtLicense.CheckUser(Gredy2) || g_ZtLicense.CheckUser(GredyLocal))

  0041d	6a 20		 push	 32			; 00000020H
  0041f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00424	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00429	84 c0		 test	 al, al
  0042b	75 20		 jne	 SHORT $LN9@CGGuildReq
  0042d	6a 22		 push	 34			; 00000022H
  0042f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00434	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00439	84 c0		 test	 al, al
  0043b	75 10		 jne	 SHORT $LN9@CGGuildReq
  0043d	6a 21		 push	 33			; 00000021H
  0043f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00444	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00449	84 c0		 test	 al, al
  0044b	74 06		 je	 SHORT $LN10@CGGuildReq
$LN9@CGGuildReq:

; 11134: 		{
; 11135: 			MaxGuildMember = ZtConfig.m_iGuildMaxUser;

  0044d	8b 1d a4 0d 00
	00		 mov	 ebx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+3492
$LN10@CGGuildReq:

; 11136: 		}
; 11137: 
; 11138: 		if ( MaxGuildMember > MAX_USER_GUILD )

  00453	83 fb 50	 cmp	 ebx, 80			; 00000050H
  00456	7e 05		 jle	 SHORT $LN8@CGGuildReq

; 11139: 		{
; 11140: 			MaxGuildMember = MAX_USER_GUILD;

  00458	bb 50 00 00 00	 mov	 ebx, 80			; 00000050H
$LN8@CGGuildReq:

; 11141: 		}
; 11142: 
; 11143: 		if ( gObj[number].lpGuild->TotalCount >= MaxGuildMember )

  0045d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00462	8b 94 06 38 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1080]
  00469	0f b6 4a 2e	 movzx	 ecx, BYTE PTR [edx+46]
  0046d	3b cb		 cmp	 ecx, ebx
  0046f	7c 17		 jl	 SHORT $LN7@CGGuildReq

; 11144: 		{
; 11145: 			GCResultSend(aIndex, 0x51, 0x02);

  00471	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00474	6a 02		 push	 2
  00476	6a 51		 push	 81			; 00000051H
  00478	52		 push	 edx

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  00479	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0047e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00481	5f		 pop	 edi
  00482	5b		 pop	 ebx
  00483	5e		 pop	 esi

; 11209: }

  00484	8b e5		 mov	 esp, ebp
  00486	5d		 pop	 ebp
  00487	c3		 ret	 0
$LN7@CGGuildReq:

; 11146: 			return;
; 11147: 		}
; 11148: 
; 11149: 		if(gGENS)

  00488	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  0048f	0f 84 31 01 00
	00		 je	 $LN2@CGGuildReq

; 11150: 		{
; 11151: 			if( gGensSystem.CheckGuildEnter )

  00495	80 3d ad 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VGensSystem@@A+173, 0
  0049c	0f 84 24 01 00
	00		 je	 $LN2@CGGuildReq

; 11152: 			{
; 11153: 				if( !gGensSystem.GetGensInfluence(&gObj[aIndex]) )

  004a2	03 c7		 add	 eax, edi
  004a4	50		 push	 eax
  004a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  004aa	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  004af	85 c0		 test	 eax, eax
  004b1	75 34		 jne	 SHORT $LN4@CGGuildReq

; 11154: 				{
; 11155: 					LogAddTD("[GensSystem] [%s][%s] Guild Joining Failed to Not Join Gens", 
; 11156: 						gObj[aIndex].AccountID, gObj[aIndex].Name);

  004b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b8	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  004bc	51		 push	 ecx
  004bd	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  004c1	52		 push	 edx
  004c2	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EGCNGFFB@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11157: 					// ----
; 11158: 					GCResultSend(aIndex, 0x51, 0xA3);

  004cd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004d0	68 a3 00 00 00	 push	 163			; 000000a3H
  004d5	6a 51		 push	 81			; 00000051H
  004d7	50		 push	 eax
  004d8	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  004dd	83 c4 18	 add	 esp, 24			; 00000018H
  004e0	5f		 pop	 edi
  004e1	5b		 pop	 ebx
  004e2	5e		 pop	 esi

; 11209: }

  004e3	8b e5		 mov	 esp, ebp
  004e5	5d		 pop	 ebp
  004e6	c3		 ret	 0
$LN4@CGGuildReq:

; 11159: 					return;
; 11160: 				}
; 11161: 				// ----
; 11162: 				if( !gGensSystem.GetGensInfluence(&gObj[number]) )

  004e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ed	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  004f0	52		 push	 edx
  004f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  004f6	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  004fb	85 c0		 test	 eax, eax
  004fd	75 34		 jne	 SHORT $LN3@CGGuildReq

; 11163: 				{
; 11164: 					LogAddTD("[GensSystem] [%s][%s] Guild Joining Failed to Not Join Gens GuildMaster", 
; 11165: 						gObj[aIndex].AccountID, gObj[aIndex].Name);

  004ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00504	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  00508	51		 push	 ecx
  00509	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  0050d	52		 push	 edx
  0050e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@MFMMLBKJ@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Join@
  00513	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11166: 					// ----
; 11167: 					GCResultSend(aIndex, 0x51, 0xA1);

  00519	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0051c	68 a1 00 00 00	 push	 161			; 000000a1H
  00521	6a 51		 push	 81			; 00000051H
  00523	50		 push	 eax
  00524	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00529	83 c4 18	 add	 esp, 24			; 00000018H
  0052c	5f		 pop	 edi
  0052d	5b		 pop	 ebx
  0052e	5e		 pop	 esi

; 11209: }

  0052f	8b e5		 mov	 esp, ebp
  00531	5d		 pop	 ebp
  00532	c3		 ret	 0
$LN3@CGGuildReq:

; 11168: 					return;
; 11169: 				}
; 11170: 				// ----
; 11171: 				if( gGensSystem.GetGensInfluence(&gObj[number]) != gGensSystem.GetGensInfluence(&gObj[aIndex]) )

  00533	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00539	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0053c	52		 push	 edx
  0053d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00542	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  00547	8b d8		 mov	 ebx, eax
  00549	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0054e	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00551	51		 push	 ecx
  00552	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00557	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  0055c	3b d8		 cmp	 ebx, eax

; 11172: 				{
; 11173: 					LogAddTD("[GensSystem] [%s][%s] [%s] Guild Joining Failed to Gens be Different : [%s][%s] [%s]", 
; 11174: 						gObj[aIndex].AccountID, gObj[aIndex].Name, gGensSystem.GetGensInfluenceName(&gObj[aIndex]),
; 11175: 						gObj[number].AccountID, gObj[number].Name, gGensSystem.GetGensInfluenceName(&gObj[number]));

  0055e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00563	74 61		 je	 SHORT $LN2@CGGuildReq
  00565	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00568	03 f0		 add	 esi, eax
  0056a	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  0056d	56		 push	 esi
  0056e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00573	89 55 08	 mov	 DWORD PTR tv686[ebp], edx
  00576	e8 00 00 00 00	 call	 ?GetGensInfluenceName@GensSystem@@QAEPADPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluenceName
  0057b	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00581	50		 push	 eax
  00582	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  00585	50		 push	 eax
  00586	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00589	53		 push	 ebx
  0058a	57		 push	 edi
  0058b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00590	e8 00 00 00 00	 call	 ?GetGensInfluenceName@GensSystem@@QAEPADPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluenceName
  00595	50		 push	 eax
  00596	8b 45 08	 mov	 eax, DWORD PTR tv686[ebp]
  00599	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  0059c	52		 push	 edx
  0059d	83 c0 6c	 add	 eax, 108		; 0000006cH
  005a0	50		 push	 eax
  005a1	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@BDHDGNPM@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5Guild@
  005a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11176: 					// ----
; 11177: 					GCResultSend(aIndex, 0x51, 0xA2);

  005ac	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005af	68 a2 00 00 00	 push	 162			; 000000a2H
  005b4	6a 51		 push	 81			; 00000051H
  005b6	50		 push	 eax
  005b7	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  005bc	83 c4 28	 add	 esp, 40			; 00000028H
  005bf	5f		 pop	 edi
  005c0	5b		 pop	 ebx
  005c1	5e		 pop	 esi

; 11209: }

  005c2	8b e5		 mov	 esp, ebp
  005c4	5d		 pop	 ebp
  005c5	c3		 ret	 0
$LN2@CGGuildReq:

; 11186: 		return;
; 11187: 	}
; 11188: 
; 11189: 	gObj[aIndex].m_IfState.use = 1;

  005c6	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  005cd	83 e1 fd	 and	 ecx, -3			; fffffffdH
  005d0	83 c9 01	 or	 ecx, 1
  005d3	89 8c 07 1c 0e
	00 00		 mov	 DWORD PTR [edi+eax+3612], ecx

; 11190: 	gObj[aIndex].m_IfState.type = 4;

  005da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005df	8b 94 07 1c 0e
	00 00		 mov	 edx, DWORD PTR [edi+eax+3612]
  005e6	81 e2 3f 01 ff
	ff		 and	 edx, -65217		; ffff013fH
  005ec	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  005f2	89 94 07 1c 0e
	00 00		 mov	 DWORD PTR [edi+eax+3612], edx

; 11191: 	gObj[aIndex].m_IfState.state = 0;

  005f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11192: 
; 11193: 	gObj[number].m_IfState.use = 1;
; 11194: 	gObj[number].m_IfState.type = 4;
; 11195: 	gObj[number].m_IfState.state = 0;
; 11196: 
; 11197: 	gObj[aIndex].TargetNumber = number;
; 11198: 	gObj[number].TargetNumber = aIndex;

  005fe	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00601	b9 c3 ff ff ff	 mov	 ecx, -61		; ffffffc3H
  00606	21 8c 07 1c 0e
	00 00		 and	 DWORD PTR [edi+eax+3612], ecx
  0060d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00612	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00619	83 e2 fd	 and	 edx, -3			; fffffffdH
  0061c	83 ca 01	 or	 edx, 1
  0061f	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx
  00626	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0062b	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00632	81 e2 3f 01 ff
	ff		 and	 edx, -65217		; ffff013fH
  00638	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  0063e	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx
  00645	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0064a	21 8c 06 1c 0e
	00 00		 and	 DWORD PTR [esi+eax+3612], ecx
  00651	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00656	66 8b 4d 08	 mov	 cx, WORD PTR _number$[ebp]
  0065a	66 89 8c 07 58
	04 00 00	 mov	 WORD PTR [edi+eax+1112], cx
  00662	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00668	66 89 9c 16 58
	04 00 00	 mov	 WORD PTR [esi+edx+1112], bx

; 11199: 	gObj[aIndex].m_InterfaceTime = GetTickCount();

  00670	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00676	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0067c	89 84 0f 20 0e
	00 00		 mov	 DWORD PTR [edi+ecx+3616], eax

; 11200: 	gObj[number].m_InterfaceTime = GetTickCount();

  00683	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00689	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11201: 
; 11202: 	PHeadSetB((LPBYTE)&pMsg, 0x50, sizeof(pMsg));

  0068f	6a 05		 push	 5
  00691	89 84 16 20 0e
	00 00		 mov	 DWORD PTR [esi+edx+3616], eax
  00698	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0069b	6a 50		 push	 80			; 00000050H
  0069d	50		 push	 eax
  0069e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11203: 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 11204: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 11205: 
; 11206: 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  006a3	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  006a7	8b cb		 mov	 ecx, ebx
  006a9	c1 e9 08	 shr	 ecx, 8
  006ac	52		 push	 edx
  006ad	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  006b0	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  006b3	8b 4d 08	 mov	 ecx, DWORD PTR _number$[ebp]
  006b6	50		 push	 eax
  006b7	51		 push	 ecx
  006b8	88 5d f8	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  006bb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11207: 
; 11208: 	LogAddTD("[%s][%s] Guild Request - Join : %s", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].lpGuild->Name);

  006c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006c5	8b 94 06 38 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1080]
  006cc	83 c2 04	 add	 edx, 4
  006cf	52		 push	 edx
  006d0	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  006d4	51		 push	 ecx
  006d5	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  006d9	52		 push	 edx
  006da	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@
  006df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006e5	83 c4 28	 add	 esp, 40			; 00000028H
  006e8	5f		 pop	 edi
  006e9	5b		 pop	 ebx
  006ea	5e		 pop	 esi

; 11209: }

  006eb	8b e5		 mov	 esp, ebp
  006ed	5d		 pop	 ebp
  006ee	c3		 ret	 0
$LN25@CGGuildReq:

; 11178: 					return;
; 11179: 				}
; 11180: 			}
; 11181: 		}
; 11182: 	}
; 11183: 	else
; 11184: 	{
; 11185: 		GCResultSend(aIndex, 0x51, 0x04);

  006ef	6a 04		 push	 4
  006f1	6a 51		 push	 81			; 00000051H
  006f3	53		 push	 ebx
  006f4	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  006f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@CGGuildReq:
  006fc	5f		 pop	 edi
  006fd	5b		 pop	 ebx
$LN39@CGGuildReq:
  006fe	5e		 pop	 esi

; 11209: }

  006ff	8b e5		 mov	 esp, ebp
  00701	5d		 pop	 ebp
  00702	c3		 ret	 0
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ENDP	; CGGuildRequestRecv
_TEXT	ENDS
PUBLIC	??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIre@ ; `string'
PUBLIC	?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
EXTRN	?GDGuildMemberAdd@@YAXHPAD0@Z:PROC		; GDGuildMemberAdd
;	COMDAT ??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIre@
CONST	SEGMENT
??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIre@ DB '[HA'
	DB	'CKTOOL] : NPC-GuildRequest(result) npc:%d ip:%s account:%s na'
	DB	'me:%s State:%d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z
_TEXT	SEGMENT
_result$ = -1						; size = 1
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z PROC ; CGGuildRequestResultRecv, COMDAT

; 11212: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11213: 	int number;
; 11214: 	BYTE result=0;
; 11215: 	int pnumber=-1;
; 11216: 
; 11217: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00013	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00016	51		 push	 ecx
  00017	c6 45 ff 00	 mov	 BYTE PTR _result$[ebp], 0
  0001b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	0f 84 31 01 00
	00		 je	 $LN9@CGGuildReq@2

; 11218: 	{
; 11219: 		return;
; 11220: 	}
; 11221: 
; 11222: 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002e	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00032	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00036	66 c1 e2 08	 shl	 dx, 8
  0003a	53		 push	 ebx
  0003b	0f b7 da	 movzx	 ebx, dx
  0003e	0b d8		 or	 ebx, eax

; 11223: 
; 11224: 	if ( number < 0 || number > OBJMAX-1)

  00040	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00046	0f 87 0f 01 00
	00		 ja	 $LN14@CGGuildReq@2

; 11225: 	{
; 11226: 		return;
; 11227: 	}
; 11228: 
; 11229: 	if ( !gObjIsConnected(&gObj[number]))

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	57		 push	 edi
  00053	8b fb		 mov	 edi, ebx
  00055	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0005b	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00064	83 c4 04	 add	 esp, 4
  00067	85 c0		 test	 eax, eax
  00069	75 15		 jne	 SHORT $LN8@CGGuildReq@2

; 11230: 	{
; 11231: 		GCResultSend(aIndex, 0x51, 0x02);

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0006e	6a 02		 push	 2
  00070	6a 51		 push	 81			; 00000051H
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 11232: 	}
; 11233: 	else

  00078	8a 4d ff	 mov	 cl, BYTE PTR _result$[ebp]
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	eb 02		 jmp	 SHORT $LN7@CGGuildReq@2
$LN8@CGGuildReq@2:

; 11234: 	{
; 11235: 		result = 1;

  00080	b1 01		 mov	 cl, 1
$LN7@CGGuildReq@2:

; 11236: 	}
; 11237: 
; 11238: 	if( gObj[number].Type != OBJ_USER ) //season4 add-on

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	66 83 7c 07 68
	01		 cmp	 WORD PTR [edi+eax+104], 1
  0008d	74 3d		 je	 SHORT $LN6@CGGuildReq@2

; 11239: 	{
; 11240: 		LogAddC(2,"[HACKTOOL] : NPC-GuildRequest(result) npc:%d ip:%s account:%s name:%s State:%d",
; 11241: 			gObj[number].Class,gObj[aIndex].Ip_addr,gObj[aIndex].AccountID,
; 11242: 			gObj[aIndex].Name,gObj[aIndex].Connected);

  0008f	8b 4c 06 04	 mov	 ecx, DWORD PTR [esi+eax+4]
  00093	51		 push	 ecx
  00094	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00098	52		 push	 edx
  00099	8d 4c 06 6c	 lea	 ecx, DWORD PTR [esi+eax+108]
  0009d	51		 push	 ecx
  0009e	8d 54 06 18	 lea	 edx, DWORD PTR [esi+eax+24]
  000a2	0f b7 84 07 b8
	00 00 00	 movzx	 eax, WORD PTR [edi+eax+184]
  000aa	52		 push	 edx
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIre@
  000b1	6a 02		 push	 2
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 11243: 		CloseClient(aIndex);

  000b9	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000c2	83 c4 20	 add	 esp, 32			; 00000020H
  000c5	5f		 pop	 edi
  000c6	5b		 pop	 ebx
  000c7	5e		 pop	 esi

; 11269: 	}
; 11270: }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN6@CGGuildReq@2:

; 11244: 		return;
; 11245: 	}
; 11246: 
; 11247: 	if ( lpMsg->Result == 0 )

  000cc	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000cf	80 7a 03 00	 cmp	 BYTE PTR [edx+3], 0
  000d3	75 0c		 jne	 SHORT $LN5@CGGuildReq@2

; 11248: 	{
; 11249: 		result = 0;
; 11250: 		GCResultSend(number, 0x51, 0x00);

  000d5	6a 00		 push	 0
  000d7	6a 51		 push	 81			; 00000051H
  000d9	53		 push	 ebx
  000da	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 11251: 	}
; 11252: 
; 11253: 	if ( result == 1 )

  000df	eb 25		 jmp	 SHORT $LN16@CGGuildReq@2
$LN5@CGGuildReq@2:
  000e1	80 f9 01	 cmp	 cl, 1
  000e4	75 28		 jne	 SHORT $LN3@CGGuildReq@2

; 11254: 	{
; 11255: 		if ( gObj[aIndex].GuildNumber > 0 )

  000e6	83 bc 06 34 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1076], 0
  000ee	7e 1e		 jle	 SHORT $LN3@CGGuildReq@2

; 11256: 		{
; 11257: 			GDGuildMemberAdd(number, gObj[aIndex].lpGuild->Name, gObj[number].Name);

  000f0	8b 94 06 38 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1080]
  000f7	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  000fb	51		 push	 ecx
  000fc	83 c2 04	 add	 edx, 4
  000ff	52		 push	 edx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 ?GDGuildMemberAdd@@YAXHPAD0@Z ; GDGuildMemberAdd
$LN16@CGGuildReq@2:
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@CGGuildReq@2:

; 11258: 		}
; 11259: 	}
; 11260: 
; 11261: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 4)

  0010e	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00115	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  0011a	f6 c1 03	 test	 cl, 3
  0011d	74 1a		 je	 SHORT $LN2@CGGuildReq@2
  0011f	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00125	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  0012b	75 0c		 jne	 SHORT $LN2@CGGuildReq@2

; 11262: 	{
; 11263: 		gObj[aIndex].m_IfState.use = 0;

  0012d	21 94 06 1c 0e
	00 00		 and	 DWORD PTR [esi+eax+3612], edx
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@CGGuildReq@2:

; 11264: 	}
; 11265: 		
; 11266: 	if ( gObj[number].m_IfState.use && gObj[number].m_IfState.type == 4)

  00139	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  00140	f6 c1 03	 test	 cl, 3
  00143	74 15		 je	 SHORT $LN15@CGGuildReq@2
  00145	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0014b	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00151	75 07		 jne	 SHORT $LN15@CGGuildReq@2

; 11267: 	{
; 11268: 		gObj[number].m_IfState.use = 0;

  00153	21 94 07 1c 0e
	00 00		 and	 DWORD PTR [edi+eax+3612], edx
$LN15@CGGuildReq@2:
  0015a	5f		 pop	 edi
$LN14@CGGuildReq@2:
  0015b	5b		 pop	 ebx
$LN9@CGGuildReq@2:
  0015c	5e		 pop	 esi

; 11269: 	}
; 11270: }

  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ENDP ; CGGuildRequestResultRecv
_TEXT	ENDS
PUBLIC	_pnumber$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildListAll@@YAXH@Z				; CGGuildListAll
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildListAll@@YAXH@Z
_TEXT	SEGMENT
_pnumber$GSCopy$ = -1564				; size = 4
tv322 = -1560						; size = 4
_lOfs$ = -1556						; size = 4
_n$ = -1552						; size = 4
_pList$ = -1548						; size = 13
tv438 = -1532						; size = 4
_pCount$ = -1528					; size = 24
_sendbuf$ = -1504					; size = 1500
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGGuildListAll@@YAXH@Z PROC				; CGGuildListAll, COMDAT

; 11291: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 06 00
	00		 sub	 esp, 1564		; 0000061cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 11292: 	if ( gObj[pnumber].lpGuild == NULL )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _pnumber$[ebp]
  0001c	57		 push	 edi
  0001d	8b fe		 mov	 edi, esi
  0001f	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00025	83 bc 07 38 04
	00 00 00	 cmp	 DWORD PTR [edi+eax+1080], 0

; 11343: 		{
; 11344: 			memset(&pList, 0, sizeof(pList));

  0002d	89 b5 e4 f9 ff
	ff		 mov	 DWORD PTR _pnumber$GSCopy$[ebp], esi
  00033	0f 84 58 02 00
	00		 je	 $LN10@CGGuildLis

; 11293: 	{
; 11294: 		return;
; 11295: 	}
; 11296: 
; 11297: 	PMSG_GUILDLISTCOUNT pCount;
; 11298: 	PMSG_GUILDLIST pList;
; 11299: 	char sendbuf[1500];
; 11300: 	int lOfs = 0;
; 11301: 	int number;
; 11302: 	int n;
; 11303: 	int guildmaster = 0;
; 11304: 	
; 11305: 	PHeadSetW((LPBYTE)&pCount, 0x52, 0);

  00039	6a 00		 push	 0
  0003b	8d 8d 08 fa ff
	ff		 lea	 ecx, DWORD PTR _pCount$[ebp]
  00041	6a 52		 push	 82			; 00000052H
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 11306: 	pCount.Result = 0;
; 11307: 	pCount.Count = 0;
; 11308: 	lOfs += sizeof(pCount);
; 11309: 	pCount.h.sizeH = SET_NUMBERH(lOfs);
; 11310: 	pCount.h.sizeL = SET_NUMBERL(lOfs);
; 11311: 
; 11312: 	if ( gObj[pnumber].GuildNumber < 1 )

  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	66 c7 85 0c fa
	ff ff 00 00	 mov	 WORD PTR _pCount$[ebp+4], 0
  0005b	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00060	66 c7 85 09 fa
	ff ff 00 18	 mov	 WORD PTR _pCount$[ebp+1], 6144 ; 00001800H
  00069	83 bc 0f 34 04
	00 00 01	 cmp	 DWORD PTR [edi+ecx+1076], 1
  00071	89 85 ec f9 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
  00077	7d 21		 jge	 SHORT $LN8@CGGuildLis

; 11313: 	{
; 11314: 		DataSend(pnumber, (LPBYTE)&pCount, lOfs);

  00079	50		 push	 eax
  0007a	8d 95 08 fa ff
	ff		 lea	 edx, DWORD PTR _pCount$[ebp]
  00080	52		 push	 edx
  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 11366: }

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	33 cd		 xor	 ecx, ebp
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
$LN8@CGGuildLis:

; 11315: 		return;
; 11316: 	}
; 11317: 
; 11318: 	pCount.Count = gObj[pnumber].lpGuild->Count;

  0009a	8d bc 0f 38 04
	00 00		 lea	 edi, DWORD PTR [edi+ecx+1080]
  000a1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a3	8a 51 2d	 mov	 dl, BYTE PTR [ecx+45]
  000a6	88 95 0d fa ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], dl

; 11319: 	pCount.TotalScore = gObj[pnumber].lpGuild->TotalScore;

  000ac	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000ae	8b 89 98 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1432]
  000b4	89 8d 10 fa ff
	ff		 mov	 DWORD PTR _pCount$[ebp+8], ecx

; 11320: 	pCount.Score = gObj[pnumber].lpGuild->PlayScore;

  000ba	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000bc	8a 89 95 05 00
	00		 mov	 cl, BYTE PTR [ecx+1429]
  000c2	88 8d 14 fa ff
	ff		 mov	 BYTE PTR _pCount$[ebp+12], cl

; 11321: 	memset(pCount.szRivalGuild, 0, sizeof(pCount.szRivalGuild));

  000c8	33 c9		 xor	 ecx, ecx
  000ca	89 8d 15 fa ff
	ff		 mov	 DWORD PTR _pCount$[ebp+13], ecx
  000d0	89 8d 19 fa ff
	ff		 mov	 DWORD PTR _pCount$[ebp+17], ecx
  000d6	88 8d 1d fa ff
	ff		 mov	 BYTE PTR _pCount$[ebp+21], cl

; 11322: 
; 11323: 	if ( gObj[pnumber].lpGuild->iGuildRival )

  000dc	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000de	83 b9 20 07 00
	00 00		 cmp	 DWORD PTR [ecx+1824], 0
  000e5	89 bd e8 f9 ff
	ff		 mov	 DWORD PTR tv322[ebp], edi
  000eb	74 18		 je	 SHORT $LN7@CGGuildLis

; 11324: 	{
; 11325: 		memcpy(pCount.szRivalGuild, gObj[pnumber].lpGuild->szGuildRivalName, MAX_GUILD_LEN);

  000ed	8b b1 28 07 00
	00		 mov	 esi, DWORD PTR [ecx+1832]
  000f3	89 b5 15 fa ff
	ff		 mov	 DWORD PTR _pCount$[ebp+13], esi
  000f9	8b 89 2c 07 00
	00		 mov	 ecx, DWORD PTR [ecx+1836]
  000ff	89 8d 19 fa ff
	ff		 mov	 DWORD PTR _pCount$[ebp+17], ecx
$LN7@CGGuildLis:

; 11326: 	}
; 11327: 
; 11328: 	pCount.Result = 1;

  00105	c6 85 0c fa ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+4], 1

; 11329: 	guildmaster = 1;
; 11330: 
; 11331: 	if ( pCount.Count == 0 )

  0010c	84 d2		 test	 dl, dl
  0010e	0f 84 7d 01 00
	00		 je	 $LN10@CGGuildLis

; 11332: 	{
; 11333: 		return;
; 11334: 	}
; 11335: 
; 11336: 	pCount.Count = 0;
; 11337: 
; 11338: 	for ( n=0;n<MAX_USER_GUILD;n++)

  00114	53		 push	 ebx
  00115	33 db		 xor	 ebx, ebx
  00117	c6 85 0d fa ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+5], 0
  0011e	89 9d f0 f9 ff
	ff		 mov	 DWORD PTR _n$[ebp], ebx
  00124	8d 95 38 fa ff
	ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+24]
  0012a	33 f6		 xor	 esi, esi
  0012c	c7 85 04 fa ff
	ff d8 05 00 00	 mov	 DWORD PTR tv438[ebp], 1496 ; 000005d8H
  00136	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL5@CGGuildLis:

; 11339: 	{
; 11340: 		number = gObj[pnumber].lpGuild->Use[n];

  00140	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 11341: 
; 11342: 		if ( number > 0 )

  00142	80 bc 19 40 04
	00 00 00	 cmp	 BYTE PTR [ecx+ebx+1088], 0
  0014a	0f 86 ab 00 00
	00		 jbe	 $LN4@CGGuildLis

; 11343: 		{
; 11344: 			memset(&pList, 0, sizeof(pList));

  00150	33 c0		 xor	 eax, eax
  00152	89 85 fc f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp+8], eax
  00158	89 85 f4 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  0015e	89 85 f8 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  00164	88 85 00 fa ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], al

; 11345: 			memcpy(pList.Name, gObj[pnumber].lpGuild->Names[n], sizeof(pList.Name));

  0016a	8b 44 0e 2f	 mov	 eax, DWORD PTR [esi+ecx+47]
  0016e	89 85 f4 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp], eax
  00174	8b 44 0e 33	 mov	 eax, DWORD PTR [esi+ecx+51]
  00178	89 85 f8 f9 ff
	ff		 mov	 DWORD PTR _pList$[ebp+4], eax
  0017e	66 8b 44 0e 37	 mov	 ax, WORD PTR [esi+ecx+55]
  00183	66 89 85 fc f9
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax

; 11346: 			pList.Number = gObj[pnumber].lpGuild->pServer[n];

  0018a	8b c1		 mov	 eax, ecx
  0018c	8d bc 18 90 04
	00 00		 lea	 edi, DWORD PTR [eax+ebx+1168]
  00193	8a 07		 mov	 al, BYTE PTR [edi]

; 11347: 			pList.ConnectAServer = (short)gObj[pnumber].lpGuild->pServer[n] & 0x7F;

  00195	8a d8		 mov	 bl, al
  00197	88 85 fe f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], al
  0019d	24 7f		 and	 al, 127			; 0000007fH
  0019f	88 85 ff f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al

; 11348: 
; 11349: 			if ( gObj[pnumber].lpGuild->pServer[n] >= 0 )

  001a5	84 db		 test	 bl, bl
  001a7	78 08		 js	 SHORT $LN1@CGGuildLis

; 11350: 			{
; 11351: 				pList.ConnectAServer |= 0x80;

  001a9	0c 80		 or	 al, 128			; 00000080H
  001ab	88 85 ff f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al
$LN1@CGGuildLis:

; 11352: 			}
; 11353: 
; 11354: 			pList.btGuildStatus = gObj[pnumber].lpGuild->GuildStatus[n];

  001b1	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR tv438[ebp]
  001b7	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 11355: 			memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  001ba	8b 85 f4 f9 ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]

; 11356: 			lOfs+= sizeof(pList);
; 11357: 			pCount.Count++;

  001c0	8b bd e8 f9 ff
	ff		 mov	 edi, DWORD PTR tv322[ebp]
  001c6	8b 9d f0 f9 ff
	ff		 mov	 ebx, DWORD PTR _n$[ebp]
  001cc	89 02		 mov	 DWORD PTR [edx], eax
  001ce	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp+4]
  001d4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  001d7	8b 85 fc f9 ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp+8]
  001dd	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001e0	8b 85 ec f9 ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  001e6	83 c0 0d	 add	 eax, 13			; 0000000dH
  001e9	88 4a 0c	 mov	 BYTE PTR [edx+12], cl
  001ec	83 c2 0d	 add	 edx, 13			; 0000000dH
  001ef	fe 85 0d fa ff
	ff		 inc	 BYTE PTR _pCount$[ebp+5]
  001f5	89 85 ec f9 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
$LN4@CGGuildLis:

; 11332: 	{
; 11333: 		return;
; 11334: 	}
; 11335: 
; 11336: 	pCount.Count = 0;
; 11337: 
; 11338: 	for ( n=0;n<MAX_USER_GUILD;n++)

  001fb	8b 8d 04 fa ff
	ff		 mov	 ecx, DWORD PTR tv438[ebp]
  00201	83 c1 04	 add	 ecx, 4
  00204	43		 inc	 ebx
  00205	83 c6 0b	 add	 esi, 11			; 0000000bH
  00208	89 9d f0 f9 ff
	ff		 mov	 DWORD PTR _n$[ebp], ebx
  0020e	89 8d 04 fa ff
	ff		 mov	 DWORD PTR tv438[ebp], ecx
  00214	81 f9 18 07 00
	00		 cmp	 ecx, 1816		; 00000718H
  0021a	0f 8c 20 ff ff
	ff		 jl	 $LL5@CGGuildLis

; 11358: 		}
; 11359: 	}
; 11360: 
; 11361: 	pCount.h.sizeH = SET_NUMBERH(lOfs);

  00220	8b c8		 mov	 ecx, eax
  00222	c1 e9 08	 shr	 ecx, 8
  00225	88 8d 09 fa ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], cl

; 11362: 	pCount.h.sizeL = SET_NUMBERL(lOfs);
; 11363: 	memcpy(sendbuf, (LPBYTE)&pCount, sizeof(pCount));

  0022b	8b 8d 0c fa ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp+4]
  00231	88 85 0a fa ff
	ff		 mov	 BYTE PTR _pCount$[ebp+2], al
  00237	8b 95 08 fa ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp]
  0023d	89 95 20 fa ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], edx
  00243	8b 95 10 fa ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp+8]
  00249	89 95 28 fa ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+8], edx
  0024f	8b 95 18 fa ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp+16]
  00255	89 8d 24 fa ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+4], ecx
  0025b	8b 8d 14 fa ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp+12]

; 11364: 
; 11365: 	DataSend(pnumber, (LPBYTE)sendbuf, lOfs);

  00261	50		 push	 eax
  00262	8b 85 e4 f9 ff
	ff		 mov	 eax, DWORD PTR _pnumber$GSCopy$[ebp]
  00268	89 95 30 fa ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+16], edx
  0026e	8d 95 20 fa ff
	ff		 lea	 edx, DWORD PTR _sendbuf$[ebp]
  00274	89 8d 2c fa ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+12], ecx
  0027a	8b 8d 1c fa ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp+20]
  00280	52		 push	 edx
  00281	50		 push	 eax
  00282	89 8d 34 fa ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+20], ecx
  00288	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0028d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00290	5b		 pop	 ebx
$LN10@CGGuildLis:

; 11366: }

  00291	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00294	5f		 pop	 edi
  00295	33 cd		 xor	 ecx, ebp
  00297	5e		 pop	 esi
  00298	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029d	8b e5		 mov	 esp, ebp
  0029f	5d		 pop	 ebp
  002a0	c3		 ret	 0
?CGGuildListAll@@YAXH@Z ENDP				; CGGuildListAll
_TEXT	ENDS
PUBLIC	??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@ ; `string'
PUBLIC	??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z	; CGGuildDelUser
EXTRN	?GDGuildMemberDel@@YAXHPAD0@Z:PROC		; GDGuildMemberDel
EXTRN	?GDGuildDestroySend@@YAXHPAD0@Z:PROC		; GDGuildDestroySend
EXTRN	?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjGuildWarMasterClose
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_bCastleGuildDestoyLimit@@3HA:DWORD		; g_bCastleGuildDestoyLimit
EXTRN	?DeleteGuildUser@CDungeonSiege@@QAE_NH@Z:PROC	; CDungeonSiege::DeleteGuildUser
EXTRN	?g_DungeonSiege@@3VCDungeonSiege@@A:BYTE	; g_DungeonSiege
;	COMDAT ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@ DB '['
	DB	'%s][%s] Guild Request - Leave : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@
CONST	SEGMENT
??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@ DB '['
	DB	'%s][%s] Guild Request - Dismiss All : %s', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z
_TEXT	SEGMENT
tv352 = -56						; size = 4
_aIndex$GSCopy$ = -52					; size = 4
_pMsg$ = -48						; size = 4
_guildname$ = -44					; size = 11
_memberid$ = -32					; size = 11
_joomin$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z PROC	; CGGuildDelUser, COMDAT

; 11375: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 11376: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001e	8b f7		 mov	 esi, edi
  00020	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00026	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00029	51		 push	 ecx
  0002a	89 7d cc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  0002d	89 75 c8	 mov	 DWORD PTR tv352[ebp], esi
  00030	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00035	83 c4 04	 add	 esp, 4
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 dc 03 00
	00		 je	 $LN4@CGGuildDel

; 11377: 	{
; 11378: 		return;
; 11379: 	}
; 11380: 
; 11381: //#if(GS_CASTLE==1)
; 11382: 	if(g_CastleSiegeSync.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) //Good

  00040	83 3d 04 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4, 7
  00047	75 2a		 jne	 SHORT $LN19@CGGuildDel

; 11383: 	{
; 11384: 		MsgOutput(aIndex,(lMsg.Get(MSGGET(6, 195))));

  00049	68 c3 06 00 00	 push	 1731			; 000006c3H
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00053	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00058	50		 push	 eax
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0005f	83 c4 08	 add	 esp, 8
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx

; 11498: 	}
; 11499: }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN19@CGGuildDel:

; 11385: 		return;
; 11386: 	}
; 11387: //#endif
; 11388: 
; 11389: #if(EVENT_DUNGEON_SIEGE)
; 11390: 	if(!g_DungeonSiege.DeleteGuildUser(aIndex))

  00073	57		 push	 edi
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  00079	e8 00 00 00 00	 call	 ?DeleteGuildUser@CDungeonSiege@@QAE_NH@Z ; CDungeonSiege::DeleteGuildUser
  0007e	84 c0		 test	 al, al
  00080	0f 84 96 03 00
	00		 je	 $LN4@CGGuildDel

; 11391: 	{
; 11392: 		return;
; 11393: 	}
; 11394: #endif
; 11395: 
; 11396: 	if ( gObj[aIndex].GuildNumber < 1 )

  00086	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008c	83 bc 16 34 04
	00 00 01	 cmp	 DWORD PTR [esi+edx+1076], 1
  00094	0f 8c 82 03 00
	00		 jl	 $LN4@CGGuildDel

; 11397: 		return;
; 11398: 
; 11399: 
; 11400: 
; 11401: 	char joomin[14];
; 11402: 	char memberid[11];
; 11403: 	char guildname[11];
; 11404: 	PMSG_GUILDDELUSER_RESULT pMsg;
; 11405: 	
; 11406: 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof(pMsg));

  0009a	6a 04		 push	 4
  0009c	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009f	6a 53		 push	 83			; 00000053H
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11407: 	pMsg.Result = 3;
; 11408: 
; 11409: 	if ( !gGuildDestroy )

  000aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  000b1	c6 45 d3 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3
  000b5	75 23		 jne	 SHORT $LN16@CGGuildDel

; 11410: 	{
; 11411: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000b7	0f b6 4d d1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000bb	51		 push	 ecx
  000bc	8d 55 d0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000bf	52		 push	 edx
  000c0	57		 push	 edi
  000c1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx

; 11498: 	}
; 11499: }

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cf	33 cd		 xor	 ecx, ebp
  000d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
$LN16@CGGuildDel:

; 11412: 		return;
; 11413: 	}
; 11414: 
; 11415: #if(EVOMU_HOSTILITY_DEL)
; 11416: 	if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || g_ZtLicense.CheckUser(eZtUB::GredyLocal))	

  000da	6a 20		 push	 32			; 00000020H
  000dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000e1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000e6	84 c0		 test	 al, al
  000e8	75 20		 jne	 SHORT $LN14@CGGuildDel
  000ea	6a 22		 push	 34			; 00000022H
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000f1	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000f6	84 c0		 test	 al, al
  000f8	75 10		 jne	 SHORT $LN14@CGGuildDel
  000fa	6a 21		 push	 33			; 00000021H
  000fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00101	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00106	84 c0		 test	 al, al
  00108	74 48		 je	 SHORT $LN45@CGGuildDel
$LN14@CGGuildDel:

; 11417: 	{
; 11418: 		_GUILD_INFO_STRUCT * lpGuildUser = gObj[aIndex].lpGuild;

  0010a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00110	8b 84 3e 38 04
	00 00		 mov	 eax, DWORD PTR [esi+edi+1080]

; 11419: 
; 11420: 		if(!lpGuildUser)

  00117	85 c0		 test	 eax, eax
  00119	0f 84 fd 02 00
	00		 je	 $LN4@CGGuildDel

; 11421: 		{
; 11422: 			return;
; 11423: 		}
; 11424: 
; 11425: 		if(lpGuildUser->iGuildRival > 0)

  0011f	83 b8 20 07 00
	00 00		 cmp	 DWORD PTR [eax+1824], 0
  00126	7e 30		 jle	 SHORT $LN12@CGGuildDel

; 11426: 		{
; 11427: 			pMsg.Result = 0;
; 11428: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00128	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0012c	8b 55 cc	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0012f	50		 push	 eax
  00130	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00133	51		 push	 ecx
  00134	52		 push	 edx
  00135	c6 45 d3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00139	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx

; 11498: 	}
; 11499: }

  00144	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
$LN45@CGGuildDel:

; 11429: 			return;

  00152	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN12@CGGuildDel:

; 11430: 		}
; 11431: 	}
; 11432: #endif
; 11433: 
; 11434: 	memset(memberid, 0, sizeof(memberid));
; 11435: 	memset(guildname, 0, sizeof(guildname));
; 11436: 	memcpy(memberid, lpMsg->Name, MAX_ACCOUNT_LEN);

  00158	66 8b 53 0b	 mov	 dx, WORD PTR [ebx+11]
  0015c	8b 4b 07	 mov	 ecx, DWORD PTR [ebx+7]
  0015f	33 c0		 xor	 eax, eax
  00161	89 45 e0	 mov	 DWORD PTR _memberid$[ebp], eax
  00164	89 45 e4	 mov	 DWORD PTR _memberid$[ebp+4], eax
  00167	66 89 45 e8	 mov	 WORD PTR _memberid$[ebp+8], ax
  0016b	88 45 ea	 mov	 BYTE PTR _memberid$[ebp+10], al
  0016e	89 45 d4	 mov	 DWORD PTR _guildname$[ebp], eax
  00171	89 45 d8	 mov	 DWORD PTR _guildname$[ebp+4], eax
  00174	66 89 45 dc	 mov	 WORD PTR _guildname$[ebp+8], ax
  00178	88 45 de	 mov	 BYTE PTR _guildname$[ebp+10], al
  0017b	8b 43 03	 mov	 eax, DWORD PTR [ebx+3]
  0017e	89 45 e0	 mov	 DWORD PTR _memberid$[ebp], eax
  00181	66 89 55 e8	 mov	 WORD PTR _memberid$[ebp+8], dx

; 11437: 	strcpy(guildname, gObj[aIndex].lpGuild->Name);

  00185	8d b4 3e 38 04
	00 00		 lea	 esi, DWORD PTR [esi+edi+1080]
  0018c	89 4d e4	 mov	 DWORD PTR _memberid$[ebp+4], ecx
  0018f	8b 06		 mov	 eax, DWORD PTR [esi]
  00191	83 c0 04	 add	 eax, 4
  00194	8d 55 d4	 lea	 edx, DWORD PTR _guildname$[ebp]
$LL23@CGGuildDel:
  00197	8a 08		 mov	 cl, BYTE PTR [eax]
  00199	88 0a		 mov	 BYTE PTR [edx], cl
  0019b	40		 inc	 eax
  0019c	42		 inc	 edx
  0019d	84 c9		 test	 cl, cl
  0019f	75 f6		 jne	 SHORT $LL23@CGGuildDel

; 11438: 
; 11439: 	if ( !strcmp(gObj[aIndex].lpGuild->Names[0], gObj[aIndex].Name ))

  001a1	8b 45 c8	 mov	 eax, DWORD PTR tv352[ebp]
  001a4	8d 7c 38 77	 lea	 edi, DWORD PTR [eax+edi+119]
  001a8	8b 06		 mov	 eax, DWORD PTR [esi]
  001aa	8b cf		 mov	 ecx, edi
  001ac	83 c0 2f	 add	 eax, 47			; 0000002fH
  001af	90		 npad	 1
$LL29@CGGuildDel:
  001b0	8a 10		 mov	 dl, BYTE PTR [eax]
  001b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001b4	75 1a		 jne	 SHORT $LN30@CGGuildDel
  001b6	84 d2		 test	 dl, dl
  001b8	74 12		 je	 SHORT $LN31@CGGuildDel
  001ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001c0	75 0e		 jne	 SHORT $LN30@CGGuildDel
  001c2	83 c0 02	 add	 eax, 2
  001c5	83 c1 02	 add	 ecx, 2
  001c8	84 d2		 test	 dl, dl
  001ca	75 e4		 jne	 SHORT $LL29@CGGuildDel
$LN31@CGGuildDel:
  001cc	33 c0		 xor	 eax, eax
  001ce	eb 05		 jmp	 SHORT $LN32@CGGuildDel
$LN30@CGGuildDel:
  001d0	1b c0		 sbb	 eax, eax
  001d2	83 d8 ff	 sbb	 eax, -1
$LN32@CGGuildDel:
  001d5	85 c0		 test	 eax, eax
  001d7	0f 85 61 01 00
	00		 jne	 $LN11@CGGuildDel

; 11440: 	{
; 11441: 		memset(joomin, 0, sizeof(joomin));
; 11442: 		memcpy(joomin, lpMsg->JoominNumber, 10);

  001dd	8b 4b 0d	 mov	 ecx, DWORD PTR [ebx+13]
  001e0	8b 53 11	 mov	 edx, DWORD PTR [ebx+17]
  001e3	89 45 ec	 mov	 DWORD PTR _joomin$[ebp], eax
  001e6	89 45 f0	 mov	 DWORD PTR _joomin$[ebp+4], eax
  001e9	89 45 f4	 mov	 DWORD PTR _joomin$[ebp+8], eax
  001ec	89 4d ec	 mov	 DWORD PTR _joomin$[ebp], ecx
  001ef	66 89 45 f8	 mov	 WORD PTR _joomin$[ebp+12], ax
  001f3	66 8b 43 15	 mov	 ax, WORD PTR [ebx+21]

; 11443: 
; 11444: 		if ( gObjJoominCheck(aIndex, joomin) == TRUE )

  001f7	8b 5d cc	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  001fa	8d 4d ec	 lea	 ecx, DWORD PTR _joomin$[ebp]
  001fd	51		 push	 ecx
  001fe	53		 push	 ebx
  001ff	89 55 f0	 mov	 DWORD PTR _joomin$[ebp+4], edx
  00202	66 89 45 f4	 mov	 WORD PTR _joomin$[ebp+8], ax
  00206	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YA_NHPAD@Z ; gObjJoominCheck
  0020b	83 c4 08	 add	 esp, 8
  0020e	3c 01		 cmp	 al, 1
  00210	0f 85 01 01 00
	00		 jne	 $LN10@CGGuildDel

; 11445: 		{
; 11446: 			if ( !strcmp(memberid, gObj[aIndex].Name ))

  00216	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021c	8b 7d c8	 mov	 edi, DWORD PTR tv352[ebp]
  0021f	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  00222	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00225	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
$LL33@CGGuildDel:
  00228	8a 10		 mov	 dl, BYTE PTR [eax]
  0022a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0022c	75 1a		 jne	 SHORT $LN34@CGGuildDel
  0022e	84 d2		 test	 dl, dl
  00230	74 12		 je	 SHORT $LN35@CGGuildDel
  00232	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00235	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00238	75 0e		 jne	 SHORT $LN34@CGGuildDel
  0023a	83 c0 02	 add	 eax, 2
  0023d	83 c1 02	 add	 ecx, 2
  00240	84 d2		 test	 dl, dl
  00242	75 e4		 jne	 SHORT $LL33@CGGuildDel
$LN35@CGGuildDel:
  00244	33 c0		 xor	 eax, eax
  00246	eb 05		 jmp	 SHORT $LN36@CGGuildDel
$LN34@CGGuildDel:
  00248	1b c0		 sbb	 eax, eax
  0024a	83 d8 ff	 sbb	 eax, -1
$LN36@CGGuildDel:
  0024d	85 c0		 test	 eax, eax
  0024f	0f 85 94 00 00
	00		 jne	 $LN9@CGGuildDel

; 11447: 			{
; 11448: //#if(GS_CASTLE==1)
; 11449: 				if( g_bCastleGuildDestoyLimit != 0 )

  00255	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_bCastleGuildDestoyLimit@@3HA, eax ; g_bCastleGuildDestoyLimit
  0025b	74 66		 je	 SHORT $LN46@CGGuildDel

; 11450: 				{
; 11451: 					if( !strcmp(gObj[aIndex].lpGuild->Name,g_CastleSiege.GetCastleOwnerGuild()) )

  0025d	8b 86 38 04 00
	00		 mov	 eax, DWORD PTR [esi+1080]
  00263	b9 d7 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A+215
  00268	83 c0 04	 add	 eax, 4
  0026b	eb 03 8d 49 00	 npad	 5
$LL37@CGGuildDel:
  00270	8a 10		 mov	 dl, BYTE PTR [eax]
  00272	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00274	75 1a		 jne	 SHORT $LN38@CGGuildDel
  00276	84 d2		 test	 dl, dl
  00278	74 12		 je	 SHORT $LN39@CGGuildDel
  0027a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0027d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00280	75 0e		 jne	 SHORT $LN38@CGGuildDel
  00282	83 c0 02	 add	 eax, 2
  00285	83 c1 02	 add	 ecx, 2
  00288	84 d2		 test	 dl, dl
  0028a	75 e4		 jne	 SHORT $LL37@CGGuildDel
$LN39@CGGuildDel:
  0028c	33 c0		 xor	 eax, eax
  0028e	eb 05		 jmp	 SHORT $LN40@CGGuildDel
$LN38@CGGuildDel:
  00290	1b c0		 sbb	 eax, eax
  00292	83 d8 ff	 sbb	 eax, -1
$LN40@CGGuildDel:
  00295	85 c0		 test	 eax, eax
  00297	75 2a		 jne	 SHORT $LN46@CGGuildDel

; 11452: 					{
; 11453: 						MsgOutput(aIndex,lMsg.Get(0x6BD));

  00299	68 bd 06 00 00	 push	 1725			; 000006bdH
  0029e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002a3	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002a8	50		 push	 eax
  002a9	53		 push	 ebx
  002aa	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  002af	83 c4 08	 add	 esp, 8
  002b2	5f		 pop	 edi
  002b3	5e		 pop	 esi
  002b4	5b		 pop	 ebx

; 11498: 	}
; 11499: }

  002b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b8	33 cd		 xor	 ecx, ebp
  002ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
$LN46@CGGuildDel:

; 11454: 						return;
; 11455: 					}
; 11456: 				}
; 11457: //#endif
; 11458: 				gObjGuildWarMasterClose(&gObj[aIndex]);

  002c3	56		 push	 esi
  002c4	e8 00 00 00 00	 call	 ?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose

; 11459: 				GDGuildDestroySend(aIndex, gObj[aIndex].lpGuild->Name, gObj[aIndex].Name);

  002c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ce	8b 94 07 38 04
	00 00		 mov	 edx, DWORD PTR [edi+eax+1080]
  002d5	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  002d9	51		 push	 ecx
  002da	83 c2 04	 add	 edx, 4
  002dd	52		 push	 edx
  002de	53		 push	 ebx
  002df	e8 00 00 00 00	 call	 ?GDGuildDestroySend@@YAXHPAD0@Z ; GDGuildDestroySend
  002e4	83 c4 10	 add	 esp, 16			; 00000010H

; 11460: 			}
; 11461: 			else

  002e7	eb 11		 jmp	 SHORT $LN6@CGGuildDel
$LN9@CGGuildDel:

; 11462: 			{
; 11463: 				GDGuildMemberDel(aIndex, guildname, memberid);

  002e9	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  002ec	50		 push	 eax
  002ed	8d 4d d4	 lea	 ecx, DWORD PTR _guildname$[ebp]
  002f0	51		 push	 ecx
  002f1	53		 push	 ebx
  002f2	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
  002f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGGuildDel:

; 11464: 			}
; 11465: 
; 11466: 			LogAddTD("[%s][%s] Guild Request - Dismiss All : %s",
; 11467: 				gObj[aIndex].AccountID,gObj[aIndex].Name, guildname);

  002fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ff	8d 55 d4	 lea	 edx, DWORD PTR _guildname$[ebp]
  00302	52		 push	 edx
  00303	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  00307	51		 push	 ecx
  00308	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  0030c	52		 push	 edx
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@

; 11473: 			return;
; 11474: 		}
; 11475: 	}
; 11476: 	else

  00312	e9 fc 00 00 00	 jmp	 $LN47@CGGuildDel
$LN10@CGGuildDel:

; 11468: 		}
; 11469: 		else
; 11470: 		{
; 11471: 			pMsg.Result = 0;
; 11472: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00317	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0031b	50		 push	 eax
  0031c	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0031f	51		 push	 ecx
  00320	53		 push	 ebx
  00321	c6 45 d3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00325	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032d	5f		 pop	 edi
  0032e	5e		 pop	 esi
  0032f	5b		 pop	 ebx

; 11498: 	}
; 11499: }

  00330	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00333	33 cd		 xor	 ecx, ebp
  00335	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c3		 ret	 0
$LN11@CGGuildDel:

; 11477: 	{
; 11478: 		if ( strcmp(memberid, gObj[aIndex].Name) )

  0033e	8b cf		 mov	 ecx, edi
  00340	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
$LL41@CGGuildDel:
  00343	8a 10		 mov	 dl, BYTE PTR [eax]
  00345	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00347	75 1a		 jne	 SHORT $LN42@CGGuildDel
  00349	84 d2		 test	 dl, dl
  0034b	74 12		 je	 SHORT $LN43@CGGuildDel
  0034d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00350	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00353	75 0e		 jne	 SHORT $LN42@CGGuildDel
  00355	83 c0 02	 add	 eax, 2
  00358	83 c1 02	 add	 ecx, 2
  0035b	84 d2		 test	 dl, dl
  0035d	75 e4		 jne	 SHORT $LL41@CGGuildDel
$LN43@CGGuildDel:
  0035f	33 c0		 xor	 eax, eax
  00361	eb 05		 jmp	 SHORT $LN44@CGGuildDel
$LN42@CGGuildDel:
  00363	1b c0		 sbb	 eax, eax
  00365	83 d8 ff	 sbb	 eax, -1
$LN44@CGGuildDel:
  00368	85 c0		 test	 eax, eax
  0036a	74 2a		 je	 SHORT $LN3@CGGuildDel

; 11479: 		{
; 11480: 			pMsg.Result = 0;
; 11481: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0036c	0f b6 55 d1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00370	8b 4d cc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00373	52		 push	 edx
  00374	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00377	50		 push	 eax
  00378	51		 push	 ecx
  00379	c6 45 d3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  0037d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00382	83 c4 0c	 add	 esp, 12			; 0000000cH
  00385	5f		 pop	 edi
  00386	5e		 pop	 esi
  00387	5b		 pop	 ebx

; 11498: 	}
; 11499: }

  00388	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038b	33 cd		 xor	 ecx, ebp
  0038d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00392	8b e5		 mov	 esp, ebp
  00394	5d		 pop	 ebp
  00395	c3		 ret	 0
$LN3@CGGuildDel:

; 11482: 			return;
; 11483: 		}
; 11484: 
; 11485: 		memset(joomin, 0, sizeof(joomin));
; 11486: 		memcpy(joomin, lpMsg->JoominNumber, 10);

  00396	8b 53 0d	 mov	 edx, DWORD PTR [ebx+13]
  00399	66 8b 4b 15	 mov	 cx, WORD PTR [ebx+21]

; 11487: 
; 11488: 		if ( gObjJoominCheck(aIndex, joomin) == TRUE )

  0039d	8b 75 cc	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  003a0	33 c0		 xor	 eax, eax
  003a2	89 45 ec	 mov	 DWORD PTR _joomin$[ebp], eax
  003a5	89 55 ec	 mov	 DWORD PTR _joomin$[ebp], edx
  003a8	8d 55 ec	 lea	 edx, DWORD PTR _joomin$[ebp]
  003ab	89 45 f0	 mov	 DWORD PTR _joomin$[ebp+4], eax
  003ae	89 45 f4	 mov	 DWORD PTR _joomin$[ebp+8], eax
  003b1	66 89 45 f8	 mov	 WORD PTR _joomin$[ebp+12], ax
  003b5	8b 43 11	 mov	 eax, DWORD PTR [ebx+17]
  003b8	52		 push	 edx
  003b9	56		 push	 esi
  003ba	89 45 f0	 mov	 DWORD PTR _joomin$[ebp+4], eax
  003bd	66 89 4d f4	 mov	 WORD PTR _joomin$[ebp+8], cx
  003c1	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YA_NHPAD@Z ; gObjJoominCheck
  003c6	83 c4 08	 add	 esp, 8
  003c9	3c 01		 cmp	 al, 1
  003cb	75 10		 jne	 SHORT $LN2@CGGuildDel

; 11489: 		{
; 11490: 			GDGuildMemberDel(aIndex, guildname, memberid);

  003cd	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  003d0	50		 push	 eax
  003d1	8d 4d d4	 lea	 ecx, DWORD PTR _guildname$[ebp]
  003d4	51		 push	 ecx
  003d5	56		 push	 esi
  003d6	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel

; 11491: 		}
; 11492: 		else

  003db	eb 18		 jmp	 SHORT $LN48@CGGuildDel
$LN2@CGGuildDel:

; 11493: 		{
; 11494: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 108)), aIndex, 1);

  003dd	6a 01		 push	 1
  003df	56		 push	 esi
  003e0	68 6c 04 00 00	 push	 1132			; 0000046cH
  003e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003ea	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003ef	50		 push	 eax
  003f0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
$LN48@CGGuildDel:

; 11495: 		}
; 11496: 
; 11497: 		LogAddTD("[%s][%s] Guild Request - Leave : %s",	gObj[aIndex].AccountID, gObj[aIndex].Name, guildname);

  003f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003fa	8b 4d c8	 mov	 ecx, DWORD PTR tv352[ebp]
  003fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00400	8d 55 d4	 lea	 edx, DWORD PTR _guildname$[ebp]
  00403	52		 push	 edx
  00404	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00408	52		 push	 edx
  00409	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0040d	50		 push	 eax
  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@
$LN47@CGGuildDel:
  00413	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00419	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@CGGuildDel:

; 11498: 	}
; 11499: }

  0041c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041f	5f		 pop	 edi
  00420	5e		 pop	 esi
  00421	33 cd		 xor	 ecx, ebp
  00423	5b		 pop	 ebx
  00424	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00429	8b e5		 mov	 esp, ebp
  0042b	5d		 pop	 ebp
  0042c	c3		 ret	 0
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ENDP	; CGGuildDelUser
_TEXT	ENDS
PUBLIC	?GCGuildDelUserResult@@YAXHE@Z			; GCGuildDelUserResult
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildDelUserResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
?GCGuildDelUserResult@@YAXHE@Z PROC			; GCGuildDelUserResult, COMDAT

; 11502: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11503: 	PMSG_GUILDDELUSER_RESULT pMsg;
; 11504: 
; 11505: 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 53		 push	 83			; 00000053H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11506: 	pMsg.Result = Result;
; 11507: 
; 11508: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _Result$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 11509: }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCGuildDelUserResult@@YAXHE@Z ENDP			; GCGuildDelUserResult
_TEXT	ENDS
PUBLIC	?GCGuildMasterQuestionSend@@YAXH@Z		; GCGuildMasterQuestionSend
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildMasterQuestionSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterQuestionSend@@YAXH@Z PROC			; GCGuildMasterQuestionSend, COMDAT

; 11512: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11513: 	if ( gObj[aIndex].m_IfState.use > 0 )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	8b f7		 mov	 esi, edi
  0000f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00015	f6 84 06 1c 0e
	00 00 03	 test	 BYTE PTR [esi+eax+3612], 3
  0001d	77 64		 ja	 SHORT $LN2@GCGuildMas

; 11514: 	{
; 11515: 		return;
; 11516: 	}
; 11517: 
; 11518: 	PMSG_GUILDMASTERQUESTION pMsg;
; 11519: 
; 11520: 	PHeadSetB((LPBYTE)&pMsg, 0x54, sizeof(pMsg));

  0001f	6a 03		 push	 3
  00021	8d 4d 08	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00024	6a 54		 push	 84			; 00000054H
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11521: 	gObj[aIndex].m_IfState.use = 1;

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00038	83 e2 fd	 and	 edx, -3			; fffffffdH
  0003b	83 ca 01	 or	 edx, 1
  0003e	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx

; 11522: 	gObj[aIndex].m_IfState.type = 5;

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00051	81 e1 7f 01 ff
	ff		 and	 ecx, -65153		; ffff017fH
  00057	81 c9 40 01 00
	00		 or	 ecx, 320		; 00000140H
  0005d	89 8c 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], ecx

; 11523: 	gObj[aIndex].m_IfState.state = 0;

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	83 a4 06 1c 0e
	00 00 c3	 and	 DWORD PTR [esi+eax+3612], -61 ; ffffffc3H

; 11524: 
; 11525: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00071	0f b6 55 09	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00075	52		 push	 edx
  00076	8d 45 08	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00079	50		 push	 eax
  0007a	57		 push	 edi
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00080	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@GCGuildMas:
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 11526: }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?GCGuildMasterQuestionSend@@YAXH@Z ENDP			; GCGuildMasterQuestionSend
_TEXT	ENDS
PUBLIC	?GCGuildMasterManagerRun@@YAXH@Z		; GCGuildMasterManagerRun
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildMasterManagerRun@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterManagerRun@@YAXH@Z PROC			; GCGuildMasterManagerRun, COMDAT

; 11553: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11554: 	PMSG_GUILDMASTERMANAGER_RUN pMsg;
; 11555: 
; 11556: 	PHeadSetB((LPBYTE)&pMsg, 0x55, sizeof(pMsg));

  00004	6a 03		 push	 3
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 55		 push	 85			; 00000055H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11557: 
; 11558: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00015	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00018	51		 push	 ecx
  00019	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0001c	52		 push	 edx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00023	83 c4 18	 add	 esp, 24			; 00000018H

; 11559: }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?GCGuildMasterManagerRun@@YAXH@Z ENDP			; GCGuildMasterManagerRun
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
EXTRN	?GDGuildCreateSend@@YAXHPAD0PAEH@Z:PROC		; GDGuildCreateSend
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z
_TEXT	SEGMENT
_pMsg$248404 = -24					; size = 5
_pMsg$248397 = -24					; size = 5
_GuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z PROC ; CGGuildMasterInfoSave, COMDAT

; 11562: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMsg$[ebp]

; 11563: 	char GuildName[MAX_GUILD_LEN+1];
; 11564: 	GuildName[MAX_GUILD_LEN] ='\0';
; 11565: 	memcpy(GuildName, lpMsg->GuildName, MAX_GUILD_LEN);

  00014	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00017	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _GuildName$[ebp], eax

; 11566: 	int len = strlen(GuildName);

  00021	8d 45 f0	 lea	 eax, DWORD PTR _GuildName$[ebp]
  00024	57		 push	 edi
  00025	c6 45 f8 00	 mov	 BYTE PTR _GuildName$[ebp+8], 0
  00029	89 4d f4	 mov	 DWORD PTR _GuildName$[ebp+4], ecx
  0002c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0002f	90		 npad	 1
$LL13@CGGuildMas:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL13@CGGuildMas
  00037	2b c2		 sub	 eax, edx

; 11567: 
; 11568: 	if(g_ZtLicense.CheckUser(eZtUB::snaker) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::masonX))

  00039	6a 1e		 push	 30			; 0000001eH
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00040	8b f8		 mov	 edi, eax
  00042	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00047	84 c0		 test	 al, al
  00049	75 71		 jne	 SHORT $LN9@CGGuildMas
  0004b	6a 00		 push	 0
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00052	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00057	84 c0		 test	 al, al
  00059	75 61		 jne	 SHORT $LN9@CGGuildMas
  0005b	6a 3c		 push	 60			; 0000003cH
  0005d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00062	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00067	84 c0		 test	 al, al
  00069	75 51		 jne	 SHORT $LN9@CGGuildMas

; 11582: 			}
; 11583: 
; 11584: 			return;
; 11585: 		}
; 11586: 	}
; 11587: 	else
; 11588: 	{
; 11589: 		if ( len <= 2 || len > MAX_GUILD_LEN
; 11590: #ifdef FIX_CREATE_GUILD
; 11591: 			|| !ztCheckSimbol(GuildName, len)
; 11592: #endif
; 11593: 
; 11594: 			)

  0006b	8d 57 fd	 lea	 edx, DWORD PTR [edi-3]
  0006e	83 fa 05	 cmp	 edx, 5
  00071	77 11		 ja	 SHORT $LN3@CGGuildMas
  00073	8d 45 f0	 lea	 eax, DWORD PTR _GuildName$[ebp]
  00076	57		 push	 edi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?ztCheckSimbol@@YA_NPADH@Z ; ztCheckSimbol
  0007d	83 c4 08	 add	 esp, 8
  00080	84 c0		 test	 al, al
  00082	75 40		 jne	 SHORT $LN8@CGGuildMas
$LN3@CGGuildMas:

; 11595: 		{
; 11596: 			PMSG_GUILDCREATED_RESULT pMsg;
; 11597: 
; 11598: 			PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof(pMsg));

  00084	6a 05		 push	 5
  00086	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$248404[ebp]
  00089	6a 56		 push	 86			; 00000056H
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11599: 			pMsg.Result = 2;
; 11600: 		
; 11601: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00091	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$248404[ebp+1]
  00095	52		 push	 edx
  00096	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$248404[ebp]
  00099	50		 push	 eax
  0009a	56		 push	 esi
  0009b	c6 45 eb 02	 mov	 BYTE PTR _pMsg$248404[ebp+3], 2
  0009f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11602: 
; 11603: 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  000a4	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b0	8d 8c 0e 1c 0e
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+3612]

; 11604: 			{
; 11605: 				gObj[aIndex].m_IfState.use = 0;
; 11606: 			}
; 11607: 
; 11608: 			return;

  000b7	e9 98 00 00 00	 jmp	 $LN16@CGGuildMas
$LN9@CGGuildMas:

; 11569: 	{
; 11570: 		if ( len <= 2 || len > MAX_GUILD_LEN )

  000bc	83 c7 fd	 add	 edi, -3			; fffffffdH
  000bf	83 ff 05	 cmp	 edi, 5
  000c2	77 5e		 ja	 SHORT $LN7@CGGuildMas
$LN8@CGGuildMas:

; 11609: 		}
; 11610: 	}
; 11611: 
; 11612: 
; 11613: 
; 11614: 	GDGuildCreateSend(aIndex, GuildName, gObj[aIndex].Name, lpMsg->Mark, lpMsg->btGuildType);

  000c4	0f b6 53 03	 movzx	 edx, BYTE PTR [ebx+3]
  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cd	8b fe		 mov	 edi, esi
  000cf	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  000d5	52		 push	 edx
  000d6	83 c3 0c	 add	 ebx, 12			; 0000000cH
  000d9	53		 push	 ebx
  000da	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  000de	51		 push	 ecx
  000df	8d 55 f0	 lea	 edx, DWORD PTR _GuildName$[ebp]
  000e2	52		 push	 edx
  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?GDGuildCreateSend@@YAXHPAD0PAEH@Z ; GDGuildCreateSend

; 11615: 
; 11616: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ef	8b 84 0f 1c 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3612]
  000f6	83 c4 14	 add	 esp, 20			; 00000014H
  000f9	a8 03		 test	 al, 3
  000fb	74 6f		 je	 SHORT $LN6@CGGuildMas
  000fd	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00102	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00107	75 63		 jne	 SHORT $LN6@CGGuildMas

; 11617: 	{
; 11618: 		gObj[aIndex].m_IfState.use = 0;

  00109	83 a4 0f 1c 0e
	00 00 fc	 and	 DWORD PTR [edi+ecx+3612], -4 ; fffffffcH
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx

; 11619: 	}
; 11620: }

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN7@CGGuildMas:

; 11571: 		{
; 11572: 			PMSG_GUILDCREATED_RESULT pMsg;
; 11573: 
; 11574: 			PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof(pMsg));

  00122	6a 05		 push	 5
  00124	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$248397[ebp]
  00127	6a 56		 push	 86			; 00000056H
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11575: 			pMsg.Result = 2;
; 11576: 		
; 11577: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0012f	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pMsg$248397[ebp+1]
  00133	51		 push	 ecx
  00134	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$248397[ebp]
  00137	52		 push	 edx
  00138	56		 push	 esi
  00139	c6 45 eb 02	 mov	 BYTE PTR _pMsg$248397[ebp+3], 2
  0013d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11578: 
; 11579: 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  00142	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014d	8d 8c 06 1c 0e
	00 00		 lea	 ecx, DWORD PTR [esi+eax+3612]
$LN16@CGGuildMas:
  00154	8b 01		 mov	 eax, DWORD PTR [ecx]
  00156	83 c4 18	 add	 esp, 24			; 00000018H
  00159	a8 03		 test	 al, 3
  0015b	74 0f		 je	 SHORT $LN6@CGGuildMas
  0015d	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00162	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00167	75 03		 jne	 SHORT $LN6@CGGuildMas

; 11580: 			{
; 11581: 				gObj[aIndex].m_IfState.use = 0;

  00169	83 21 fc	 and	 DWORD PTR [ecx], -4	; fffffffcH
$LN6@CGGuildMas:

; 11619: 	}
; 11620: }

  0016c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	33 cd		 xor	 ecx, ebp
  00173	5b		 pop	 ebx
  00174	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ENDP ; CGGuildMasterInfoSave
_TEXT	ENDS
PUBLIC	?CGGuildMasterCreateCancel@@YAXH@Z		; CGGuildMasterCreateCancel
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildMasterCreateCancel@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGGuildMasterCreateCancel@@YAXH@Z PROC			; CGGuildMasterCreateCancel, COMDAT

; 11623: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11624: 	if ( gObj[aIndex].GuildNumber > 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0000c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	83 b8 34 04 00
	00 00		 cmp	 DWORD PTR [eax+1076], 0
  00019	7f 20		 jg	 SHORT $LN1@CGGuildMas@2

; 11625: 	{
; 11626: 		return;
; 11627: 	}
; 11628: 
; 11629: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0001b	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  00021	f6 c1 03	 test	 cl, 3
  00024	74 15		 je	 SHORT $LN1@CGGuildMas@2
  00026	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0002c	81 f9 40 01 00
	00		 cmp	 ecx, 320		; 00000140H
  00032	75 07		 jne	 SHORT $LN1@CGGuildMas@2

; 11630: 	{
; 11631: 		gObj[aIndex].m_IfState.use = 0;

  00034	83 a0 1c 0e 00
	00 fc		 and	 DWORD PTR [eax+3612], -4 ; fffffffcH
$LN1@CGGuildMas@2:

; 11632: 	}
; 11633: }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?CGGuildMasterCreateCancel@@YAXH@Z ENDP			; CGGuildMasterCreateCancel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildViewportNowPaint@@YAXHPADPAEH@Z		; GCGuildViewportNowPaint
EXTRN	?CheckCastleOwnerUnionMember@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckCastleOwnerUnionMember
EXTRN	?CheckCastleOwnerMember@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckCastleOwnerMember
EXTRN	?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z:PROC ; CGuildClass::SearchGuild
EXTRN	?Guild@@3VCGuildClass@@A:BYTE			; Guild
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildViewportNowPaint@@YAXHPADPAEH@Z
_TEXT	SEGMENT
_pGVCount$ = -280					; size = 5
_pMsg$ = -272						; size = 12
__GuildInfoBuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_guildname$ = 12					; size = 4
_mark$ = 16						; size = 4
_isGuildMaster$ = 20					; size = 4
?GCGuildViewportNowPaint@@YAXHPADPAEH@Z PROC		; GCGuildViewportNowPaint, COMDAT

; 11636: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _guildname$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 11637: 	_GUILD_INFO_STRUCT * lpGuild = Guild.SearchGuild(guildname);

  0001a	50		 push	 eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00020	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild

; 11638: 
; 11639: 	if ( lpGuild == NULL )

  00025	85 c0		 test	 eax, eax
  00027	0f 84 51 01 00
	00		 je	 $LN10@GCGuildVie

; 11640: 	{
; 11641: 		return;
; 11642: 	}
; 11643: 
; 11644: 	LPOBJ lpObj = &gObj[aIndex];

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	56		 push	 esi
  00033	8b f3		 mov	 esi, ebx
  00035	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0003b	57		 push	 edi

; 11645: 	BYTE _GuildInfoBuf[256] = {0};

  0003c	68 ff 00 00 00	 push	 255			; 000000ffH
  00041	8d 8d fd fe ff
	ff		 lea	 ecx, DWORD PTR __GuildInfoBuf$[ebp+1]
  00047	6a 00		 push	 0
  00049	51		 push	 ecx
  0004a	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  0004d	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR __GuildInfoBuf$[ebp], 0
  00054	e8 00 00 00 00	 call	 _memset

; 11646: 	int _GuildInfoOfs = 5;
; 11647: 
; 11648: 	if ( lpObj->lpGuild == NULL )

  00059	8b 87 38 04 00
	00		 mov	 eax, DWORD PTR [edi+1080]
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	85 c0		 test	 eax, eax
  00064	0f 84 12 01 00
	00		 je	 $LN18@GCGuildVie

; 11649: 	{
; 11650: 		return;
; 11651: 	}
; 11652: 
; 11653: 	PMSG_SIMPLE_GUILDVIEWPORT pMsg;
; 11654: 	pMsg.GuildNumber = lpObj->lpGuild->Number;

  0006a	8b 10		 mov	 edx, DWORD PTR [eax]

; 11655: 	pMsg.NumberH = SET_NUMBERH(aIndex)&0x7F;

  0006c	8b cb		 mov	 ecx, ebx
  0006e	c1 e9 08	 shr	 ecx, 8
  00071	80 e1 7f	 and	 cl, 127			; 0000007fH

; 11656: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 11657: 
; 11658: 	if ( isGuildMaster != FALSE )

  00074	83 7d 14 00	 cmp	 DWORD PTR _isGuildMaster$[ebp], 0
  00078	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp], edx
  0007e	88 8d f7 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+7], cl
  00084	88 9d f8 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+8], bl
  0008a	74 10		 je	 SHORT $LN6@GCGuildVie

; 11659: 	{
; 11660: 		pMsg.NumberH |= 0x80;

  0008c	b1 80		 mov	 cl, 128			; 00000080H
  0008e	08 8d f7 fe ff
	ff		 or	 BYTE PTR _pMsg$[ebp+7], cl

; 11661: 	}
; 11662: 
; 11663: 
; 11664: 	if ( isGuildMaster != FALSE )
; 11665: 	{
; 11666: 		pMsg.btGuildStatus = 0x80;

  00094	88 8d f4 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 11667: 	}
; 11668: 	else

  0009a	eb 0c		 jmp	 SHORT $LN5@GCGuildVie
$LN6@GCGuildVie:

; 11669: 	{
; 11670: 		pMsg.btGuildStatus = lpObj->GuildStatus;

  0009c	8a 97 48 04 00
	00		 mov	 dl, BYTE PTR [edi+1096]
  000a2	88 95 f4 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], dl
$LN5@GCGuildVie:

; 11671: 	}
; 11672: 
; 11673: 	pMsg.btGuildType = lpObj->lpGuild->btGuildType;
; 11674: 
; 11675: 	pMsg.btGuildRelationShip = 0;
; 11676: 
; 11677: 	lpObj->iGuildUnionTimeStamp = 0;
; 11678: 
; 11679: 	if( g_CastleSiegeSync.CheckCastleOwnerMember(lpObj->m_Index) == TRUE || //season 4 add-on
; 11680: 		g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE)

  000a8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000aa	8a 80 18 07 00
	00		 mov	 al, BYTE PTR [eax+1816]
  000b0	51		 push	 ecx
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000b6	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+5], al
  000bc	c6 85 f6 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+6], 0
  000c3	c7 87 4c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1100], 0
  000cd	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckCastleOwnerMember
  000d2	83 f8 01	 cmp	 eax, 1
  000d5	74 19		 je	 SHORT $LN3@GCGuildVie
  000d7	8b 17		 mov	 edx, DWORD PTR [edi]
  000d9	52		 push	 edx
  000da	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000df	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckCastleOwnerUnionMember

; 11683: 	}
; 11684: 	else
; 11685: 	{
; 11686: 		pMsg.btOwnerStatus = 0;

  000e4	c6 85 f9 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+9], 0
  000eb	83 f8 01	 cmp	 eax, 1
  000ee	75 07		 jne	 SHORT $LN2@GCGuildVie
$LN3@GCGuildVie:

; 11681: 	{
; 11682: 		pMsg.btOwnerStatus = 1;

  000f0	c6 85 f9 fe ff
	ff 01		 mov	 BYTE PTR _pMsg$[ebp+9], 1
$LN2@GCGuildVie:

; 11687: 	}
; 11688: 
; 11689: 	memcpy(&_GuildInfoBuf[_GuildInfoOfs], &pMsg, sizeof(pMsg));

  000f7	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp]
  000fd	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _pMsg$[ebp+4]
  00103	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _pMsg$[ebp+8]
  00109	89 85 01 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+5], eax
  0010f	89 8d 05 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+9], ecx
  00115	89 95 09 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+13], edx

; 11690: 	_GuildInfoOfs += sizeof(pMsg);
; 11691: 
; 11692: 	PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 11693: 
; 11694: 	pGVCount.h.c = 0xC2;
; 11695: 	pGVCount.h.headcode = 0x65;
; 11696: 	pGVCount.h.sizeH = SET_NUMBERH(_GuildInfoOfs);
; 11697: 	pGVCount.h.sizeL = SET_NUMBERL(_GuildInfoOfs);
; 11698: 	pGVCount.Count = 1;
; 11699: 	memcpy(_GuildInfoBuf, &pGVCount, sizeof(pGVCount));
; 11700: 
; 11701: 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  0011b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00121	c7 85 e8 fe ff
	ff c2 00 11 65	 mov	 DWORD PTR _pGVCount$[ebp], 1695613122 ; 651100c2H
  0012b	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _pGVCount$[ebp]
  00131	b0 01		 mov	 al, 1
  00133	89 8d fc fe ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp], ecx
  00139	88 85 00 ff ff
	ff		 mov	 BYTE PTR __GuildInfoBuf$[ebp+4], al
  0013f	0f b6 84 16 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+329]
  00147	3c 35		 cmp	 al, 53			; 00000035H
  00149	74 1f		 je	 SHORT $LN17@GCGuildVie
  0014b	3c 12		 cmp	 al, 18			; 00000012H
  0014d	72 09		 jb	 SHORT $LN16@GCGuildVie
  0014f	b1 17		 mov	 cl, 23			; 00000017H
  00151	3a c8		 cmp	 cl, al
  00153	1b c0		 sbb	 eax, eax
  00155	40		 inc	 eax
  00156	75 12		 jne	 SHORT $LN17@GCGuildVie
$LN16@GCGuildVie:

; 11702: 	{
; 11703: 		DataSend(aIndex, _GuildInfoBuf, _GuildInfoOfs);

  00158	6a 11		 push	 17			; 00000011H
  0015a	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR __GuildInfoBuf$[ebp]
  00160	52		 push	 edx
  00161	53		 push	 ebx
  00162	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00167	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@GCGuildVie:

; 11704: 	}
; 11705: 
; 11706: 	MsgSendV2(lpObj, _GuildInfoBuf, _GuildInfoOfs);

  0016a	6a 11		 push	 17			; 00000011H
  0016c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR __GuildInfoBuf$[ebp]
  00172	50		 push	 eax
  00173	57		 push	 edi
  00174	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@GCGuildVie:
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
$LN10@GCGuildVie:

; 11707: }

  0017e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00181	33 cd		 xor	 ecx, ebp
  00183	5b		 pop	 ebx
  00184	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
?GCGuildViewportNowPaint@@YAXHPADPAEH@Z ENDP		; GCGuildViewportNowPaint
_TEXT	ENDS
PUBLIC	?GCGuildViewportDelNow@@YAXHH@Z			; GCGuildViewportDelNow
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildViewportDelNow@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_isGuildMaster$ = 12					; size = 4
?GCGuildViewportDelNow@@YAXHH@Z PROC			; GCGuildViewportDelNow, COMDAT

; 11717: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 11718: 	PMSG_GUILDDEL_VIEWPORT_NOW pMsg;
; 11719: 
; 11720: 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f3		 mov	 esi, ebx
  0000d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11721: 
; 11722: 	PHeadSetB((LPBYTE)&pMsg, 0x5D, sizeof(pMsg));

  00019	6a 05		 push	 5
  0001b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	6a 5d		 push	 93			; 0000005dH
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11723: 	pMsg.NumberH = SET_NUMBERH(aIndex) & 0x7F;

  00026	8b cb		 mov	 ecx, ebx
  00028	c1 e9 08	 shr	 ecx, 8
  0002b	80 e1 7f	 and	 cl, 127			; 0000007fH
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11724: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 11725: 
; 11726: 	if ( isGuildMaster != FALSE )

  00031	83 7d 0c 00	 cmp	 DWORD PTR _isGuildMaster$[ebp], 0
  00035	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00038	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  0003b	74 04		 je	 SHORT $LN1@GCGuildVie@2

; 11727: 	{
; 11728: 		pMsg.NumberH |= 0x80;

  0003d	80 4d fb 80	 or	 BYTE PTR _pMsg$[ebp+3], 128 ; 00000080H
$LN1@GCGuildVie@2:

; 11729: 	}
; 11730: 
; 11731: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00041	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00045	52		 push	 edx
  00046	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00049	50		 push	 eax
  0004a	53		 push	 ebx
  0004b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11732: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00050	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00054	51		 push	 ecx
  00055	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00058	52		 push	 edx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 11733: }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GCGuildViewportDelNow@@YAXHH@Z ENDP			; GCGuildViewportDelNow
_TEXT	ENDS
PUBLIC	?GCManagerGuildWarEnd@@YAXPAD@Z			; GCManagerGuildWarEnd
EXTRN	?BattleInfoSend@CGMMng@@QAEXPADE0E@Z:PROC	; CGMMng::BattleInfoSend
EXTRN	?cManager@@3VCGMMng@@A:BYTE			; cManager
EXTRN	?GetBattleTeamName@@YAPADHH@Z:PROC		; GetBattleTeamName
EXTRN	?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z:PROC ; gObjGuildWarEnd
EXTRN	?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z:PROC ; gObjGuildWarEndSend
EXTRN	?gBattleGroundEnable@@YAXHH@Z:PROC		; gBattleGroundEnable
; Function compile flags: /Ogtp
;	COMDAT ?GCManagerGuildWarEnd@@YAXPAD@Z
_TEXT	SEGMENT
_Result1$248487 = -8					; size = 1
_Result2$248488 = -4					; size = 1
_GuildName$ = 8						; size = 4
?GCManagerGuildWarEnd@@YAXPAD@Z PROC			; GCManagerGuildWarEnd, COMDAT

; 11736: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11737: 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(GuildName);

  00003	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00010	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00015	8b f8		 mov	 edi, eax

; 11738: 
; 11739: 	if ( lpNode == NULL )

  00017	85 ff		 test	 edi, edi
  00019	0f 84 41 01 00
	00		 je	 $LN1@GCManagerG

; 11740: 	{
; 11741: 		return;
; 11742: 	}
; 11743: 
; 11744: 	int n=0;

  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	33 db		 xor	 ebx, ebx
  00029	83 c6 77	 add	 esi, 119		; 00000077H
  0002c	8d 64 24 00	 npad	 4
$LL15@GCManagerG:

; 11745: 	int warmaster = -1;
; 11746: 
; 11747: 	while ( true )
; 11748: 	{
; 11749: 		if ( gObj[n].Type == OBJ_USER )

  00030	66 83 7e f1 01	 cmp	 WORD PTR [esi-15], 1
  00035	75 42		 jne	 SHORT $LN10@GCManagerG

; 11750: 		{
; 11751: 			if ( gObj[n].Connected > PLAYER_LOGGED )

  00037	83 7e 8d 02	 cmp	 DWORD PTR [esi-115], 2
  0003b	7e 3c		 jle	 SHORT $LN10@GCManagerG

; 11752: 			{
; 11753: 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0003d	8a 16		 mov	 dl, BYTE PTR [esi]
  0003f	3a 57 2f	 cmp	 dl, BYTE PTR [edi+47]
  00042	8d 4f 2f	 lea	 ecx, DWORD PTR [edi+47]
  00045	75 32		 jne	 SHORT $LN10@GCManagerG

; 11754: 				{
; 11755: 					if ( strcmp(gObj[n].Name, lpNode->Names[0]) == 0 )

  00047	8b c6		 mov	 eax, esi
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL21@GCManagerG:
  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00054	75 1a		 jne	 SHORT $LN22@GCManagerG
  00056	84 d2		 test	 dl, dl
  00058	74 12		 je	 SHORT $LN23@GCManagerG
  0005a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0005d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00060	75 0e		 jne	 SHORT $LN22@GCManagerG
  00062	83 c0 02	 add	 eax, 2
  00065	83 c1 02	 add	 ecx, 2
  00068	84 d2		 test	 dl, dl
  0006a	75 e4		 jne	 SHORT $LL21@GCManagerG
$LN23@GCManagerG:
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN24@GCManagerG
$LN22@GCManagerG:
  00070	1b c0		 sbb	 eax, eax
  00072	83 d8 ff	 sbb	 eax, -1
$LN24@GCManagerG:
  00075	85 c0		 test	 eax, eax
  00077	74 15		 je	 SHORT $LN20@GCManagerG
$LN10@GCManagerG:

; 11756: 					{
; 11757: 						warmaster = n;
; 11758: 						break;
; 11759: 					}
; 11760: 				}
; 11761: 			}
; 11762: 		}
; 11763: 
; 11764: 		if ( n < OBJMAX-1 )

  00079	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0007f	0f 8d d9 00 00
	00		 jge	 $LN25@GCManagerG

; 11765: 		{
; 11766: 			n++;

  00085	43		 inc	 ebx
  00086	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H

; 11767: 		}
; 11768: 		else
; 11769: 		{
; 11770: 			break;
; 11771: 		}
; 11772: 	}

  0008c	eb a2		 jmp	 SHORT $LL15@GCManagerG
$LN20@GCManagerG:

; 11773: 
; 11774: 	if ( warmaster >= 1 )

  0008e	83 fb 01	 cmp	 ebx, 1
  00091	0f 8c c7 00 00
	00		 jl	 $LN25@GCManagerG

; 11775: 	{
; 11776: 		BYTE Result1 = 0;
; 11777: 		BYTE Result2 = 0;
; 11778: 
; 11779: 		if ( lpNode != NULL )
; 11780: 		{
; 11781: 			if ( lpNode->lpTargetGuildNode != NULL )

  00097	8b 87 8c 05 00
	00		 mov	 eax, DWORD PTR [edi+1420]
  0009d	c6 45 f8 00	 mov	 BYTE PTR _Result1$248487[ebp], 0
  000a1	c6 45 fc 00	 mov	 BYTE PTR _Result2$248488[ebp], 0
  000a5	85 c0		 test	 eax, eax
  000a7	74 24		 je	 SHORT $LN3@GCManagerG

; 11782: 			{
; 11783: 				if ( lpNode->PlayScore == 0 && lpNode->lpTargetGuildNode->PlayScore == 0 )

  000a9	80 bf 95 05 00
	00 00		 cmp	 BYTE PTR [edi+1429], 0
  000b0	75 13		 jne	 SHORT $LN4@GCManagerG
  000b2	80 b8 95 05 00
	00 00		 cmp	 BYTE PTR [eax+1429], 0
  000b9	75 0a		 jne	 SHORT $LN4@GCManagerG

; 11784: 				{
; 11785: 					Result1 = 6;

  000bb	b1 06		 mov	 cl, 6
  000bd	88 4d f8	 mov	 BYTE PTR _Result1$248487[ebp], cl

; 11786: 					Result2 = 6;

  000c0	88 4d fc	 mov	 BYTE PTR _Result2$248488[ebp], cl

; 11787: 				}
; 11788: 				else

  000c3	eb 08		 jmp	 SHORT $LN3@GCManagerG
$LN4@GCManagerG:

; 11789: 				{
; 11790: 					Result1 = 0;

  000c5	c6 45 f8 00	 mov	 BYTE PTR _Result1$248487[ebp], 0

; 11791: 					Result2 = 1;

  000c9	c6 45 fc 01	 mov	 BYTE PTR _Result2$248488[ebp], 1
$LN3@GCManagerG:

; 11792: 				}
; 11793: 			}
; 11794: 		}
; 11795: 
; 11796: 		if ( lpNode->WarType == 1 )

  000cd	80 bf 92 05 00
	00 01		 cmp	 BYTE PTR [edi+1426], 1
  000d4	75 69		 jne	 SHORT $LN2@GCManagerG

; 11797: 		{
; 11798: 			gBattleGroundEnable(lpNode->BattleGroundIndex, FALSE );

  000d6	0f b6 87 93 05
	00 00		 movzx	 eax, BYTE PTR [edi+1427]
  000dd	6a 00		 push	 0
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 11799: 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, Result1, Result2);

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _Result2$248488[ebp]
  000e8	8b 55 f8	 mov	 edx, DWORD PTR _Result1$248487[ebp]
  000eb	8b 87 8c 05 00
	00		 mov	 eax, DWORD PTR [edi+1420]
  000f1	51		 push	 ecx
  000f2	52		 push	 edx
  000f3	50		 push	 eax
  000f4	57		 push	 edi
  000f5	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 11800: 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  000fa	8b 8f 8c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1420]
  00100	51		 push	 ecx
  00101	57		 push	 edi
  00102	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  00107	83 c4 20	 add	 esp, 32			; 00000020H

; 11801: 
; 11802: 			cManager.BattleInfoSend(::GetBattleTeamName(0, 0), -1, ::GetBattleTeamName(0, 1), -1);

  0010a	68 ff 00 00 00	 push	 255			; 000000ffH
  0010f	6a 01		 push	 1
  00111	6a 00		 push	 0
  00113	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  00118	83 c4 08	 add	 esp, 8
  0011b	50		 push	 eax
  0011c	68 ff 00 00 00	 push	 255			; 000000ffH
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  0012a	83 c4 08	 add	 esp, 8
  0012d	50		 push	 eax
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00133	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	5f		 pop	 edi

; 11808: 		}
; 11809: 	}
; 11810: }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
$LN2@GCManagerG:

; 11803: 		}
; 11804: 		else
; 11805: 		{
; 11806: 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, Result1, Result2);

  0013f	8b 55 fc	 mov	 edx, DWORD PTR _Result2$248488[ebp]
  00142	8b 4d f8	 mov	 ecx, DWORD PTR _Result1$248487[ebp]
  00145	52		 push	 edx
  00146	51		 push	 ecx
  00147	50		 push	 eax
  00148	57		 push	 edi
  00149	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 11807: 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  0014e	8b 97 8c 05 00
	00		 mov	 edx, DWORD PTR [edi+1420]
  00154	52		 push	 edx
  00155	57		 push	 edi
  00156	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  0015b	83 c4 18	 add	 esp, 24			; 00000018H
$LN25@GCManagerG:
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
$LN1@GCManagerG:
  00160	5f		 pop	 edi

; 11808: 		}
; 11809: 	}
; 11810: }

  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
?GCManagerGuildWarEnd@@YAXPAD@Z ENDP			; GCManagerGuildWarEnd
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarRequestSend@@YAXPADHH@Z		; GCGuildWarRequestSend
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarRequestSend@@YAXPADHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestSend@@YAXPADHH@Z PROC			; GCGuildWarRequestSend, COMDAT

; 12023: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _GuildName$[ebp]

; 12024: 	PMSG_GUILDWARSEND pMsg;
; 12025: //#if(GS_CASTLE==0)
; 12026: 	PHeadSetB((LPBYTE)&pMsg, 0x61, sizeof(pMsg));

  00014	6a 0c		 push	 12			; 0000000cH
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 61		 push	 97			; 00000061H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12027: 	pMsg.Type = type;

  00021	8a 4d 10	 mov	 cl, BYTE PTR _type$[ebp]

; 12028: 	memcpy(pMsg.GuildName, GuildName, MAX_GUILD_LEN);

  00024	8b 16		 mov	 edx, DWORD PTR [esi]
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 12029: 
; 12030: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00030	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+3], edx
  00033	51		 push	 ecx
  00034	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00037	89 45 f7	 mov	 DWORD PTR _pMsg$[ebp+7], eax
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00044	83 c4 18	 add	 esp, 24			; 00000018H

; 12031: 	LogAddTD(lMsg.Get(MSGGET(1, 237)), GuildName);

  00047	56		 push	 esi
  00048	68 ed 01 00 00	 push	 493			; 000001edH
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00052	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12032: //#endif
; 12033: }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	83 c4 08	 add	 esp, 8
  00064	33 cd		 xor	 ecx, ebp
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GCGuildWarRequestSend@@YAXPADHH@Z ENDP			; GCGuildWarRequestSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarDeclare@@YAXHPAD@Z			; GCGuildWarDeclare
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarDeclare@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
__guildname$ = 12					; size = 4
?GCGuildWarDeclare@@YAXHPAD@Z PROC			; GCGuildWarDeclare, COMDAT

; 12299: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR __guildname$[ebp]

; 12300: 	PMSG_GUILDWAR_DECLARE pMsg;
; 12301: //#if(GS_CASTLE==0)
; 12302: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof(pMsg));

  00014	6a 0d		 push	 13			; 0000000dH
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 62		 push	 98			; 00000062H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12303: 	memcpy(pMsg.GuildName, _guildname, sizeof(pMsg.GuildName));

  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 12304: 
; 12305: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00023	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00027	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002a	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  0002d	50		 push	 eax
  0002e	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00031	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx
  00034	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12306: //#endif
; 12307: }

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	83 c4 18	 add	 esp, 24			; 00000018H
  00044	33 cd		 xor	 ecx, ebp
  00046	5e		 pop	 esi
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GCGuildWarDeclare@@YAXHPAD@Z ENDP			; GCGuildWarDeclare
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarEnd@@YAXHEPAD@Z			; GCGuildWarEnd
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarEnd@@YAXHEPAD@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
__guildname$ = 16					; size = 4
?GCGuildWarEnd@@YAXHEPAD@Z PROC				; GCGuildWarEnd, COMDAT

; 12317: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR __guildname$[ebp]

; 12318: 	PMSG_GUILDWAR_END pMsg;
; 12319: //#if(GS_CASTLE==0)
; 12320: 	PHeadSetB((LPBYTE)&pMsg, 0x63, sizeof(pMsg));

  00014	6a 0c		 push	 12			; 0000000cH
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 63		 push	 99			; 00000063H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12321: 	pMsg.Result = result;

  00021	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]

; 12322: 	memcpy(pMsg.GuildName, _guildname, sizeof(pMsg.GuildName));

  00024	8b 16		 mov	 edx, DWORD PTR [esi]
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 12323: 
; 12324: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00030	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+4], edx
  00033	51		 push	 ecx
  00034	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12325: //#endif
; 12326: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	83 c4 18	 add	 esp, 24			; 00000018H
  0004a	33 cd		 xor	 ecx, ebp
  0004c	5e		 pop	 esi
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?GCGuildWarEnd@@YAXHEPAD@Z ENDP				; GCGuildWarEnd
_TEXT	ENDS
PUBLIC	??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	?GCGuildWarScore@@YAXH@Z			; GCGuildWarScore
;	COMDAT ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@ DB 'Target Score %s %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@ DB 'Score %s %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGuildWarScore@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCGuildWarScore@@YAXH@Z PROC				; GCGuildWarScore, COMDAT

; 12337: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 12338: 	PMSG_GUILDSCORE pMsg;
; 12339: //#if(GS_CASTLE==0)
; 12340: 	if ( gObj[aIndex].GuildNumber < 1 )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00010	8b f7		 mov	 esi, edi
  00012	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00018	83 bc 06 34 04
	00 00 01	 cmp	 DWORD PTR [esi+eax+1076], 1
  00020	0f 8c b9 00 00
	00		 jl	 $LN4@GCGuildWar

; 12341: 	{
; 12342: 		return;
; 12343: 	}
; 12344: 
; 12345: 	PHeadSetB((LPBYTE)&pMsg, 0x64, sizeof(pMsg));

  00026	6a 06		 push	 6
  00028	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002b	6a 64		 push	 100			; 00000064H
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12346: 	pMsg.Score1 = 0;
; 12347: 	pMsg.Score2 = 0;
; 12348: 	pMsg.Type = 0;
; 12349: 
; 12350: 	if ( gObj[aIndex].lpGuild != NULL )

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	66 c7 45 fb 00
	00		 mov	 WORD PTR _pMsg$[ebp+3], 0
  00041	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00045	83 bc 06 38 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1080], 0
  0004d	74 37		 je	 SHORT $LN2@GCGuildWar

; 12351: 	{
; 12352: 		pMsg.Score1 = gObj[aIndex].lpGuild->PlayScore;

  0004f	8b 94 06 38 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1080]
  00056	8a 8a 95 05 00
	00		 mov	 cl, BYTE PTR [edx+1429]
  0005c	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 12353: 		LogAdd("Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->PlayScore);

  0005f	8b 94 06 38 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1080]
  00066	0f b6 8a 95 05
	00 00		 movzx	 ecx, BYTE PTR [edx+1429]
  0006d	51		 push	 ecx
  0006e	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00072	52		 push	 edx
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCGuildWar:

; 12354: 	}
; 12355: 
; 12356: 	if ( gObj[aIndex].lpGuild->lpTargetGuildNode != NULL )

  00086	8b 8c 06 38 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1080]
  0008d	83 b9 8c 05 00
	00 00		 cmp	 DWORD PTR [ecx+1420], 0
  00094	74 37		 je	 SHORT $LN1@GCGuildWar

; 12357: 	{
; 12358: 		pMsg.Score2 = gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore;

  00096	8b 89 8c 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1420]
  0009c	8a 91 95 05 00
	00		 mov	 dl, BYTE PTR [ecx+1429]
  000a2	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 12359: 		LogAdd("Target Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore);

  000a5	8b 8c 06 38 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1080]
  000ac	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  000b2	0f b6 8a 95 05
	00 00		 movzx	 ecx, BYTE PTR [edx+1429]
  000b9	51		 push	 ecx
  000ba	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000be	52		 push	 edx
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar:

; 12360: 	}
; 12361: 
; 12362: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000cd	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000d1	50		 push	 eax
  000d2	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000d5	51		 push	 ecx
  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCGuildWar:
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi

; 12363: //#endif
; 12364: }	

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?GCGuildWarScore@@YAXH@Z ENDP				; GCGuildWarScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCWarehouseInventoryMoneySend@@YAXHEHH@Z	; GCWarehouseInventoryMoneySend
; Function compile flags: /Ogtp
;	COMDAT ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_money$ = 16						; size = 4
_wmoney$ = 20						; size = 4
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z PROC		; GCWarehouseInventoryMoneySend, COMDAT

; 12510: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 12511: 	PMSG_MONEY pMsg;
; 12512: 
; 12513: 	PHeadSetB((LPBYTE)&pMsg, 0x81, sizeof(pMsg));

  00010	6a 0c		 push	 12			; 0000000cH
  00012	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 81 00 00 00	 push	 129			; 00000081H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12514: 	pMsg.Result = result;

  00020	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]

; 12515: 	pMsg.iMoney = money;

  00023	8b 55 10	 mov	 edx, DWORD PTR _money$[ebp]

; 12516: 	pMsg.wMoney = wmoney;

  00026	8b 45 14	 mov	 eax, DWORD PTR _wmoney$[ebp]
  00029	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 12517: 
; 12518: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00030	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00033	51		 push	 ecx
  00034	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00037	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12519: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ENDP		; GCWarehouseInventoryMoneySend
_TEXT	ENDS
PUBLIC	??_C@_0CC@DKBCOKH@error?5?$FLCGWarehouseUseEnd?$FN?$FL?$CFs?$FN?$FL?$CFd@ ; `string'
PUBLIC	??_C@_0BJ@KDJKIPKK@error?5WarehouseTickCount?$AA@ ; `string'
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	?CGWarehouseUseEnd@@YAXH@Z			; CGWarehouseUseEnd
EXTRN	?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; GDUserItemSave
EXTRN	?GDSetWarehouseList@@YAXH@Z:PROC		; GDSetWarehouseList
EXTRN	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?SendClose@ConnectZt@@QAEXHH@Z:PROC		; ConnectZt::SendClose
EXTRN	?g_ConnectZt@@3VConnectZt@@A:QWORD		; g_ConnectZt
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
;	COMDAT ??_C@_0CC@DKBCOKH@error?5?$FLCGWarehouseUseEnd?$FN?$FL?$CFs?$FN?$FL?$CFd@
CONST	SEGMENT
??_C@_0CC@DKBCOKH@error?5?$FLCGWarehouseUseEnd?$FN?$FL?$CFs?$FN?$FL?$CFd@ DB 'e'
	DB	'rror [CGWarehouseUseEnd][%s][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KDJKIPKK@error?5WarehouseTickCount?$AA@
CONST	SEGMENT
??_C@_0BJ@KDJKIPKK@error?5WarehouseTickCount?$AA@ DB 'error WarehouseTick'
	DB	'Count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGWarehouseUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$248781 = -4					; size = 3
_aIndex$ = 8						; size = 4
?CGWarehouseUseEnd@@YAXH@Z PROC				; CGWarehouseUseEnd, COMDAT

; 12555: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 12556: 	//CGWarehouseUseEndOLD(aIndex);
; 12557: 	//return;
; 12558: 
; 12559: 	if(!gObjIsConnectedGP(aIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN7@CGWarehous

; 12560: 	{
; 12561: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00015	68 11 31 00 00	 push	 12561			; 00003111H
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 12607: #else
; 12608: 		CloseClient(aIndex);
; 12609: #endif
; 12610: 	}
; 12611: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN7@CGWarehous:
  00034	56		 push	 esi

; 12562: 		return;
; 12563: 	}
; 12564: 
; 12565: 	LPOBJ lpObj = &gObj[aIndex];

  00035	8b f7		 mov	 esi, edi
  00037	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0003d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 12566: 
; 12567: 	DWORD dwDelay = GetTickCount() - lpObj->WarehouseTickCount;

  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00049	2b 86 74 0e 00
	00		 sub	 eax, DWORD PTR [esi+3700]

; 12568: 
; 12569: 	if(dwDelay < 100)

  0004f	83 f8 64	 cmp	 eax, 100		; 00000064H
  00052	73 23		 jae	 SHORT $LN6@CGWarehous

; 12570: 	{
; 12571: 		LogAddC(2, "error WarehouseTickCount");

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KDJKIPKK@error?5WarehouseTickCount?$AA@
  00059	6a 02		 push	 2
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00061	83 c4 08	 add	 esp, 8

; 12572: #ifdef _RECONNECT_				
; 12573: 		g_ConnectZt.SendClose(aIndex, NORM_DC);

  00064	6a 00		 push	 0
  00066	57		 push	 edi
  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  0006c	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
  00071	5e		 pop	 esi
  00072	5f		 pop	 edi

; 12607: #else
; 12608: 		CloseClient(aIndex);
; 12609: #endif
; 12610: 	}
; 12611: }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
$LN6@CGWarehous:

; 12574: #else
; 12575: 		CloseClient(aIndex);
; 12576: #endif
; 12577: 		return;
; 12578: 	}
; 12579: 
; 12580: 	if(lpObj->m_IfState.use > 0 && lpObj->m_IfState.type == 6 && lpObj->m_IfState.state == 1 && lpObj->WarehouseSave == 1)

  00077	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0007d	8b c8		 mov	 ecx, eax
  0007f	83 e1 03	 and	 ecx, 3
  00082	53		 push	 ebx
  00083	ba 01 00 00 00	 mov	 edx, 1
  00088	0f 86 8a 00 00
	00		 jbe	 $LN5@CGWarehous
  0008e	8b d8		 mov	 ebx, eax
  00090	81 e3 c0 ff 00
	00		 and	 ebx, 65472		; 0000ffc0H
  00096	81 fb 80 01 00
	00		 cmp	 ebx, 384		; 00000180H
  0009c	75 7a		 jne	 SHORT $LN5@CGWarehous
  0009e	8b d8		 mov	 ebx, eax
  000a0	80 e3 3c	 and	 bl, 60			; 0000003cH
  000a3	80 fb 04	 cmp	 bl, 4
  000a6	75 70		 jne	 SHORT $LN5@CGWarehous
  000a8	39 96 70 0e 00
	00		 cmp	 DWORD PTR [esi+3696], edx
  000ae	75 68		 jne	 SHORT $LN5@CGWarehous

; 12581: 	{
; 12582: 		PMSG_DEFAULT pMsg;
; 12583: 		PHeadSetB((LPBYTE)&pMsg, 0x82, sizeof(pMsg));

  000b0	6a 03		 push	 3
  000b2	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$248781[ebp]
  000b5	68 82 00 00 00	 push	 130			; 00000082H
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12584: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000c0	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$248781[ebp+1]
  000c4	51		 push	 ecx
  000c5	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$248781[ebp]
  000c8	52		 push	 edx
  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12585: 
; 12586: 		gObjItemTextSave(lpObj);

  000cf	56		 push	 esi
  000d0	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave

; 12587: 		GDSetWarehouseList(aIndex);

  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList

; 12588: 		GDUserItemSave(lpObj);

  000db	56		 push	 esi
  000dc	e8 00 00 00 00	 call	 ?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ; GDUserItemSave

; 12589: 
; 12590: 		if ( lpObj->m_IfState.use  && lpObj->m_IfState.type == 6 )

  000e1	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  000e7	83 c4 24	 add	 esp, 36			; 00000024H
  000ea	a8 03		 test	 al, 3
  000ec	74 6f		 je	 SHORT $LN11@CGWarehous
  000ee	8b c8		 mov	 ecx, eax
  000f0	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000f6	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  000fc	75 5f		 jne	 SHORT $LN11@CGWarehous

; 12591: 		{
; 12592: 			lpObj->m_IfState.use = 0;
; 12593: 			lpObj->m_IfState.state = 0;

  000fe	83 e0 c0	 and	 eax, -64		; ffffffc0H
  00101	5b		 pop	 ebx
  00102	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax

; 12594: 			lpObj->WarehouseSave = FALSE;

  00108	c7 86 70 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+3696], 0
  00112	5e		 pop	 esi
  00113	5f		 pop	 edi

; 12607: #else
; 12608: 		CloseClient(aIndex);
; 12609: #endif
; 12610: 	}
; 12611: }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN5@CGWarehous:

; 12595: 		}
; 12596: 	}
; 12597: 	else if(lpObj->WareChange == true && lpObj->m_IfState.use == 0)

  00118	38 96 e5 2a 00
	00		 cmp	 BYTE PTR [esi+10981], dl
  0011e	75 16		 jne	 SHORT $LN2@CGWarehous
  00120	85 c9		 test	 ecx, ecx
  00122	75 12		 jne	 SHORT $LN2@CGWarehous

; 12598: 	{
; 12599: 		lpObj->m_IfState.use = 1;

  00124	83 e0 fd	 and	 eax, -3			; fffffffdH
  00127	0b c2		 or	 eax, edx
  00129	5b		 pop	 ebx
  0012a	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax
  00130	5e		 pop	 esi
  00131	5f		 pop	 edi

; 12607: #else
; 12608: 		CloseClient(aIndex);
; 12609: #endif
; 12610: 	}
; 12611: }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
$LN2@CGWarehous:

; 12600: 	}
; 12601: 	else
; 12602: 	{
; 12603: 		LogAddC(2, "error [CGWarehouseUseEnd][%s][%d]", __FILE__, __LINE__);

  00136	68 3b 31 00 00	 push	 12603			; 0000313bH
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00140	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DKBCOKH@error?5?$FLCGWarehouseUseEnd?$FN?$FL?$CFs?$FN?$FL?$CFd@
  00145	6a 02		 push	 2
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0014d	83 c4 10	 add	 esp, 16			; 00000010H

; 12604: 
; 12605: #ifdef _RECONNECT_				
; 12606: 		g_ConnectZt.SendClose(aIndex, NORM_DC);

  00150	6a 00		 push	 0
  00152	57		 push	 edi
  00153	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00158	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
$LN11@CGWarehous:
  0015d	5b		 pop	 ebx
  0015e	5e		 pop	 esi
  0015f	5f		 pop	 edi

; 12607: #else
; 12608: 		CloseClient(aIndex);
; 12609: #endif
; 12610: 	}
; 12611: }

  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
?CGWarehouseUseEnd@@YAXH@Z ENDP				; CGWarehouseUseEnd
_TEXT	ENDS
PUBLIC	?GCWarehouseStateSend@@YAXHE@Z			; GCWarehouseStateSend
; Function compile flags: /Ogtp
;	COMDAT ?GCWarehouseStateSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
?GCWarehouseStateSend@@YAXHE@Z PROC			; GCWarehouseStateSend, COMDAT

; 12620: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 12621: 	PMSG_WAREHOUSESTATE pMsg;
; 12622: 
; 12623: 	PHeadSetB((LPBYTE)&pMsg, 0x83, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	68 83 00 00 00	 push	 131			; 00000083H
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12624: 	pMsg.State = state;
; 12625: 
; 12626: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00014	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00018	8a 4d 0c	 mov	 cl, BYTE PTR _state$[ebp]
  0001b	52		 push	 edx
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00025	50		 push	 eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 12627: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GCWarehouseStateSend@@YAXHE@Z ENDP			; GCWarehouseStateSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
EXTRN	?WarehousePassword@CGuildBank@@QAE_NH@Z:PROC	; CGuildBank::WarehousePassword
EXTRN	?g_GuildBank@@3VCGuildBank@@A:BYTE		; g_GuildBank
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
; Function compile flags: /Ogtp
;	COMDAT ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z
_TEXT	SEGMENT
_pw$ = -20						; size = 4
_szJoomin$248827 = -16					; size = 11
_szJoomin$248823 = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z PROC ; GCWarehouseRecivePassword, COMDAT

; 12630: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 12631: 	if ( bCanWarehouseLock == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 0 ; bCanWarehouseLock
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 0c	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f 84 fa 00 00
	00		 je	 $LN8@GCWarehous

; 12632: 	{
; 12633: 		return;
; 12634: 	}
; 12635: 
; 12636: #if(DEV_GUILDBANK)
; 12637: 	if(!g_GuildBank.WarehousePassword(aIndex))

  00025	56		 push	 esi
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  0002b	e8 00 00 00 00	 call	 ?WarehousePassword@CGuildBank@@QAE_NH@Z ; CGuildBank::WarehousePassword
  00030	84 c0		 test	 al, al
  00032	0f 84 e7 00 00
	00		 je	 $LN8@GCWarehous

; 12638: 	{
; 12639: 		return;
; 12640: 	}
; 12641: #endif
; 12642: 
; 12643: 
; 12644: 	int pw = lpMsg->Pass;
; 12645: 
; 12646: 	switch ( lpMsg->Type )

  00038	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0003c	83 e8 00	 sub	 eax, 0
  0003f	0f bf 4f 04	 movsx	 ecx, WORD PTR [edi+4]
  00043	89 4d ec	 mov	 DWORD PTR _pw$[ebp], ecx
  00046	0f 84 3e 01 00
	00		 je	 $LN11@GCWarehous
  0004c	48		 dec	 eax
  0004d	0f 84 a2 00 00
	00		 je	 $LN7@GCWarehous
  00053	48		 dec	 eax
  00054	0f 85 c5 00 00
	00		 jne	 $LN8@GCWarehous

; 12685: 		case 0x02:
; 12686: 			{
; 12687: 				char szJoomin[11];
; 12688: 
; 12689: 				memset(szJoomin, 0, sizeof(szJoomin));
; 12690: 				memcpy(szJoomin, lpMsg->LastJoominNumber, 10);

  0005a	8b 4f 0a	 mov	 ecx, DWORD PTR [edi+10]
  0005d	66 8b 57 0e	 mov	 dx, WORD PTR [edi+14]
  00061	89 45 f0	 mov	 DWORD PTR _szJoomin$248827[ebp], eax
  00064	89 45 f4	 mov	 DWORD PTR _szJoomin$248827[ebp+4], eax
  00067	66 89 45 f8	 mov	 WORD PTR _szJoomin$248827[ebp+8], ax
  0006b	88 45 fa	 mov	 BYTE PTR _szJoomin$248827[ebp+10], al
  0006e	8b 47 06	 mov	 eax, DWORD PTR [edi+6]
  00071	89 45 f0	 mov	 DWORD PTR _szJoomin$248827[ebp], eax

; 12691: 
; 12692: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00074	8d 45 f0	 lea	 eax, DWORD PTR _szJoomin$248827[ebp]
  00077	50		 push	 eax
  00078	56		 push	 esi
  00079	89 4d f4	 mov	 DWORD PTR _szJoomin$248827[ebp+4], ecx
  0007c	66 89 55 f8	 mov	 WORD PTR _szJoomin$248827[ebp+8], dx
  00080	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YA_NHPAD@Z ; gObjJoominCheck
  00085	83 c4 08	 add	 esp, 8
  00088	84 c0		 test	 al, al
  0008a	75 1b		 jne	 SHORT $LN1@GCWarehous

; 12693: 				{
; 12694: 					GCWarehouseStateSend(aIndex, 0x0D);

  0008c	6a 0d		 push	 13			; 0000000dH
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00094	83 c4 08	 add	 esp, 8
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi

; 12701: 			}
; 12702: 			break;
; 12703: 	}
; 12704: }	

  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	33 cd		 xor	 ecx, ebp
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN1@GCWarehous:

; 12695: 					return;
; 12696: 				}
; 12697: 
; 12698: 				gObj[aIndex].WarehouseLock = FALSE;

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ad	8b c6		 mov	 eax, esi
  000af	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000b5	c6 84 08 68 0e
	00 00 00	 mov	 BYTE PTR [eax+ecx+3688], 0

; 12699: 				gObj[aIndex].WarehousePW = 0;

  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	33 d2		 xor	 edx, edx
  000c5	66 89 94 08 66
	0e 00 00	 mov	 WORD PTR [eax+ecx+3686], dx

; 12700: 				GCWarehouseStateSend(aIndex, gObj[aIndex].WarehouseLock);

  000cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	0f b6 84 10 68
	0e 00 00	 movzx	 eax, BYTE PTR [eax+edx+3688]
  000db	50		 push	 eax
  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  000e2	83 c4 08	 add	 esp, 8
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi

; 12701: 			}
; 12702: 			break;
; 12703: 	}
; 12704: }	

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN7@GCWarehous:

; 12659: 				}
; 12660: 			}
; 12661: 			break;
; 12662: 		case 0x01:
; 12663: 			if ( !gObj[aIndex].WarehouseLock || gObj[aIndex].WarehouseLock == 0xFF )

  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fb	53		 push	 ebx
  000fc	8b de		 mov	 ebx, esi
  000fe	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00104	8a 84 0b 68 0e
	00 00		 mov	 al, BYTE PTR [ebx+ecx+3688]
  0010b	84 c0		 test	 al, al
  0010d	74 20		 je	 SHORT $LN5@GCWarehous
  0010f	3c ff		 cmp	 al, 255			; 000000ffH
  00111	74 1c		 je	 SHORT $LN5@GCWarehous

; 12679: 			}
; 12680: 			else
; 12681: 			{
; 12682: 				GCWarehouseStateSend(aIndex, 0x0B);

  00113	6a 0b		 push	 11			; 0000000bH
$LN19@GCWarehous:

; 12671: 				{
; 12672: 					GCWarehouseStateSend(aIndex, 0x0D);

  00115	56		 push	 esi
  00116	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  0011b	83 c4 08	 add	 esp, 8
  0011e	5b		 pop	 ebx
$LN8@GCWarehous:
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi

; 12701: 			}
; 12702: 			break;
; 12703: 	}
; 12704: }	

  00121	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
$LN5@GCWarehous:

; 12664: 			{
; 12665: 				char szJoomin[11];
; 12666: 
; 12667: 				memset(szJoomin, 0, sizeof(szJoomin));
; 12668: 				memcpy(szJoomin, lpMsg->LastJoominNumber, 10);

  0012f	8b 57 06	 mov	 edx, DWORD PTR [edi+6]
  00132	66 8b 4f 0e	 mov	 cx, WORD PTR [edi+14]
  00136	33 c0		 xor	 eax, eax
  00138	89 45 f0	 mov	 DWORD PTR _szJoomin$248823[ebp], eax
  0013b	89 55 f0	 mov	 DWORD PTR _szJoomin$248823[ebp], edx

; 12669: 
; 12670: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )

  0013e	8d 55 f0	 lea	 edx, DWORD PTR _szJoomin$248823[ebp]
  00141	89 45 f4	 mov	 DWORD PTR _szJoomin$248823[ebp+4], eax
  00144	66 89 45 f8	 mov	 WORD PTR _szJoomin$248823[ebp+8], ax
  00148	88 45 fa	 mov	 BYTE PTR _szJoomin$248823[ebp+10], al
  0014b	8b 47 0a	 mov	 eax, DWORD PTR [edi+10]
  0014e	52		 push	 edx
  0014f	56		 push	 esi
  00150	89 45 f4	 mov	 DWORD PTR _szJoomin$248823[ebp+4], eax
  00153	66 89 4d f8	 mov	 WORD PTR _szJoomin$248823[ebp+8], cx
  00157	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YA_NHPAD@Z ; gObjJoominCheck
  0015c	83 c4 08	 add	 esp, 8
  0015f	84 c0		 test	 al, al
  00161	75 04		 jne	 SHORT $LN4@GCWarehous

; 12671: 				{
; 12672: 					GCWarehouseStateSend(aIndex, 0x0D);

  00163	6a 0d		 push	 13			; 0000000dH

; 12673: 					return;

  00165	eb ae		 jmp	 SHORT $LN19@GCWarehous
$LN4@GCWarehous:

; 12674: 				}
; 12675: 
; 12676: 				gObj[aIndex].WarehousePW = pw;

  00167	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016c	66 8b 4d ec	 mov	 cx, WORD PTR _pw$[ebp]
  00170	66 89 8c 03 66
	0e 00 00	 mov	 WORD PTR [ebx+eax+3686], cx

; 12677: 				gObj[aIndex].WarehouseLock = FALSE;

  00178	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017e	c6 84 13 68 0e
	00 00 00	 mov	 BYTE PTR [ebx+edx+3688], 0

; 12678: 				GCWarehouseStateSend(aIndex, 0x0C);

  00186	6a 0c		 push	 12			; 0000000cH

; 12683: 			}
; 12684: 			break;

  00188	eb 8b		 jmp	 SHORT $LN19@GCWarehous
$LN11@GCWarehous:

; 12647: 	{
; 12648: 		case 0x00:
; 12649: 			if ( gObj[aIndex].WarehouseLock )

  0018a	8b c6		 mov	 eax, esi
  0018c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00192	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00198	80 b8 68 0e 00
	00 00		 cmp	 BYTE PTR [eax+3688], 0
  0019f	0f 84 7a ff ff
	ff		 je	 $LN8@GCWarehous

; 12650: 			{
; 12651: 				if ( gObj[aIndex].WarehousePW == pw )

  001a5	0f bf 90 66 0e
	00 00		 movsx	 edx, WORD PTR [eax+3686]
  001ac	3b d1		 cmp	 edx, ecx
  001ae	75 22		 jne	 SHORT $LN9@GCWarehous

; 12652: 				{
; 12653: 					gObj[aIndex].WarehouseLock = FALSE;
; 12654: 					GCWarehouseStateSend(aIndex, 0x0C);

  001b0	6a 0c		 push	 12			; 0000000cH
  001b2	56		 push	 esi
  001b3	c6 80 68 0e 00
	00 00		 mov	 BYTE PTR [eax+3688], 0
  001ba	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  001bf	83 c4 08	 add	 esp, 8
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi

; 12701: 			}
; 12702: 			break;
; 12703: 	}
; 12704: }	

  001c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c7	33 cd		 xor	 ecx, ebp
  001c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
$LN9@GCWarehous:

; 12655: 				}
; 12656: 				else
; 12657: 				{
; 12658: 					GCWarehouseStateSend(aIndex, 0x0A);

  001d2	6a 0a		 push	 10			; 0000000aH
  001d4	56		 push	 esi
  001d5	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend

; 12701: 			}
; 12702: 			break;
; 12703: 	}
; 12704: }	

  001da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001dd	83 c4 08	 add	 esp, 8
  001e0	5f		 pop	 edi
  001e1	33 cd		 xor	 ecx, ebp
  001e3	5e		 pop	 esi
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c3		 ret	 0
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ENDP ; GCWarehouseRecivePassword
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z	; GCUserChaosBoxSend
; Function compile flags: /Ogtp
;	COMDAT ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -2072					; size = 4
tv246 = -2068						; size = 4
_n$248845 = -2064					; size = 4
_pMsg$ = -2060						; size = 6
_SendByte$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iChaosBoxType$ = 12					; size = 4
?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GCUserChaosBoxSend, COMDAT

; 12707: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 08 00
	00		 sub	 esp, 2072		; 00000818H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 12708: 	if ( iChaosBoxType == 1  )
; 12709: 	{
; 12710: 		if ( lpObj->m_IfState.type != 13 )

  00018	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _iChaosBoxType$[ebp]

; 12757: 		}
; 12758: 	}
; 12759: 
; 12760: 	pMsg.h.sizeH = SET_NUMBERH(lOfs);

  00022	89 b5 e8 f7 ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], esi
  00028	83 ff 01	 cmp	 edi, 1
  0002b	75 10		 jne	 SHORT $LN12@GCUserChao

; 12708: 	if ( iChaosBoxType == 1  )
; 12709: 	{
; 12710: 		if ( lpObj->m_IfState.type != 13 )

  0002d	8b c8		 mov	 ecx, eax
  0002f	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00035	81 f9 40 03 00
	00		 cmp	 ecx, 832		; 00000340H

; 12711: 		{
; 12712: 			return;
; 12713: 		}
; 12714: 
; 12715: 		if ( lpObj->m_IfState.type == 13 && lpObj->m_IfState.state == 1 )
; 12716: 		{
; 12717: 			return;
; 12718: 		}
; 12719: 	}
; 12720: 	else 

  0003b	eb 0e		 jmp	 SHORT $LN18@GCUserChao
$LN12@GCUserChao:

; 12721: 	{
; 12722: 		if ( lpObj->m_IfState.type != 7 )

  0003d	8b d0		 mov	 edx, eax
  0003f	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00045	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
$LN18@GCUserChao:
  0004b	0f 85 05 01 00
	00		 jne	 $LN13@GCUserChao

; 12723: 		{
; 12724: 			return;
; 12725: 		}
; 12726: 
; 12727: 		if ( lpObj->m_IfState.type == 7 && lpObj->m_IfState.state == 1 )

  00051	24 3c		 and	 al, 60			; 0000003cH
  00053	3c 04		 cmp	 al, 4
  00055	0f 84 fb 00 00
	00		 je	 $LN13@GCUserChao

; 12728: 		{
; 12729: 			return;
; 12730: 		}
; 12731: 	}
; 12732: 
; 12733: 	PMSG_SHOPITEMCOUNT pMsg;
; 12734: 	BYTE SendByte[2048];
; 12735: 	int lOfs = sizeof(pMsg);
; 12736: 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  0005b	6a 00		 push	 0
  0005d	8d 85 f4 f7 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00063	6a 31		 push	 49			; 00000031H
  00065	50		 push	 eax
  00066	bb 06 00 00 00	 mov	 ebx, 6
  0006b	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12737: 	pMsg.count = 0;
; 12738: 
; 12739: 	if ( iChaosBoxType == 1 )

  00073	83 ff 01	 cmp	 edi, 1
  00076	0f 94 c1	 sete	 cl

; 12740: 	{
; 12741: 		pMsg.Type = 5;
; 12742: 	}
; 12743: 	else
; 12744: 	{
; 12745: 		pMsg.Type = 3;
; 12746: 	}
; 12747: 
; 12748: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00079	33 ff		 xor	 edi, edi
  0007b	c6 85 f9 f7 ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00082	89 bd f0 f7 ff
	ff		 mov	 DWORD PTR _n$248845[ebp], edi
  00088	89 bd ec f7 ff
	ff		 mov	 DWORD PTR tv246[ebp], edi
  0008e	8d 4c 09 03	 lea	 ecx, DWORD PTR [ecx+ecx+3]
  00092	88 8d f8 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00098	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL4@GCUserChao:

; 12749: 	{
; 12750: 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  000a0	8b 8e 78 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3704]
  000a6	03 cf		 add	 ecx, edi
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 4c		 jne	 SHORT $LN3@GCUserChao

; 12751: 		{
; 12752: 			SendByte[lOfs] = n;
; 12753: 			lOfs++;
; 12754: 			ItemByteConvert(&SendByte[lOfs], lpObj->pChaosBox[n] );

  000b2	8b b6 78 0e 00
	00		 mov	 esi, DWORD PTR [esi+3704]
  000b8	8a 95 f0 f7 ff
	ff		 mov	 dl, BYTE PTR _n$248845[ebp]
  000be	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  000c4	03 f7		 add	 esi, edi
  000c6	8d 84 1d fd f7
	ff ff		 lea	 eax, DWORD PTR _SendByte$[ebp+ebx+1]
  000cd	8b fc		 mov	 edi, esp
  000cf	88 94 1d fc f7
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+ebx], dl
  000d6	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000db	50		 push	 eax
  000dc	f3 a5		 rep movsd
  000de	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 12755: 			lOfs += MAX_ITEM_INFO;
; 12756: 			pMsg.count ++;

  000e3	8b bd ec f7 ff
	ff		 mov	 edi, DWORD PTR tv246[ebp]
  000e9	8b b5 e8 f7 ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$[ebp]
  000ef	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000f5	83 c3 0d	 add	 ebx, 13			; 0000000dH
  000f8	fe 85 f9 f7 ff
	ff		 inc	 BYTE PTR _pMsg$[ebp+5]
$LN3@GCUserChao:

; 12740: 	{
; 12741: 		pMsg.Type = 5;
; 12742: 	}
; 12743: 	else
; 12744: 	{
; 12745: 		pMsg.Type = 3;
; 12746: 	}
; 12747: 
; 12748: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  000fe	ff 85 f0 f7 ff
	ff		 inc	 DWORD PTR _n$248845[ebp]
  00104	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0010a	89 bd ec f7 ff
	ff		 mov	 DWORD PTR tv246[ebp], edi
  00110	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  00116	7c 88		 jl	 SHORT $LL4@GCUserChao

; 12761: 	pMsg.h.sizeL = SET_NUMBERL(lOfs);
; 12762: 	memcpy(SendByte, &pMsg, sizeof(pMsg));

  00118	66 8b 85 f8 f7
	ff ff		 mov	 ax, WORD PTR _pMsg$[ebp+4]
  0011f	8b cb		 mov	 ecx, ebx
  00121	c1 e9 08	 shr	 ecx, 8
  00124	88 8d f5 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], cl
  0012a	88 9d f6 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], bl
  00130	8b 95 f4 f7 ff
	ff		 mov	 edx, DWORD PTR _pMsg$[ebp]

; 12763: 
; 12764: 	DataSend(lpObj->m_Index, SendByte, lOfs);

  00136	53		 push	 ebx
  00137	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  0013d	89 95 fc f7 ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], edx
  00143	8b 16		 mov	 edx, DWORD PTR [esi]
  00145	51		 push	 ecx
  00146	52		 push	 edx
  00147	66 89 85 00 f8
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], ax
  0014e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@GCUserChao:

; 12765: }

  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	33 cd		 xor	 ecx, ebp
  0015d	5b		 pop	 ebx
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GCUserChaosBoxSend
_TEXT	ENDS
PUBLIC	??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@ ; `string'
PUBLIC	??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ ; `string'
PUBLIC	??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_aRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
EXTRN	?MixWings6rd@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::MixWings6rd
EXTRN	?MixGrandItem@cGrandHero@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; cGrandHero::MixGrandItem
EXTRN	?GrandHero@@3VcGrandHero@@A:BYTE		; GrandHero
EXTRN	?MixWings5rd@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::MixWings5rd
EXTRN	?MixWings4rd@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::MixWings4rd
EXTRN	?MixWings2_5@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::MixWings2_5
EXTRN	?LuckyItemSmelting@LuckyItemManager@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; LuckyItemManager::LuckyItemSmelting
EXTRN	?LuckyItemTicketExchange@LuckyItemManager@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; LuckyItemManager::LuckyItemTicketExchange
EXTRN	?GoldenNSilverBoxMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::GoldenNSilverBoxMix
EXTRN	?SecromiconMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::SecromiconMix
EXTRN	?SocketRemoveSeedSphere@CMixSystem@@QAEXPAUOBJECTSTRUCT@@E@Z:PROC ; CMixSystem::SocketRemoveSeedSphere
EXTRN	?SocketSetSeedSphere@CMixSystem@@QAEXPAUOBJECTSTRUCT@@E@Z:PROC ; CMixSystem::SocketSetSeedSphere
EXTRN	?SocketSeedSphereComposite@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::SocketSeedSphereComposite
EXTRN	?SocketSeedExtract@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::SocketSeedExtract
EXTRN	?CherryBlossomMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::CherryBlossomMix
EXTRN	?ThirdWingMix2@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ThirdWingMix2
EXTRN	?ThirdWingMix1@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ThirdWingMix1
EXTRN	?TicketChaosMix@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleEvent::TicketChaosMix
EXTRN	?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTempleEvent
EXTRN	?LotteryItemMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::LotteryItemMix
EXTRN	?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CItemSystemFor380::ChaosMix380ItemOption
EXTRN	?g_kItemSystemFor380@@3VCItemSystemFor380@@A:BYTE ; g_kItemSystemFor380
EXTRN	?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::RestoreStrengthenItem
EXTRN	?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
EXTRN	?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::PurityJewelOfHarmony
EXTRN	?ShieldPotionLv3_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ShieldPotionLv3_Mix
EXTRN	?ShieldPotionLv2_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ShieldPotionLv2_Mix
EXTRN	?ShieldPotionLv1_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ShieldPotionLv1_Mix
EXTRN	?Fenrir_04Upgrade_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::Fenrir_04Upgrade_Mix
EXTRN	?Fenrir_03Level_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::Fenrir_03Level_Mix
EXTRN	?Fenrir_02Level_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::Fenrir_02Level_Mix
EXTRN	?Fenrir_01Level_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::Fenrir_01Level_Mix
EXTRN	?HiddenTreasureBoxItemMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::HiddenTreasureBoxItemMix
EXTRN	?CastleSpecialItemMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::CastleSpecialItemMix
EXTRN	?LifeStoneChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::LifeStoneChaosMix
EXTRN	?SoulPotionChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::SoulPotionChaosMix
EXTRN	?BlessPotionChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::BlessPotionChaosMix
EXTRN	?DarkSpiritChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DarkSpiritChaosMix
EXTRN	?DarkHorseChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DarkHorseChaosMix
EXTRN	?DefaultChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DefaultChaosMix
EXTRN	?BloodCastleItemChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::BloodCastleItemChaosMix
EXTRN	?WingChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::WingChaosMix
EXTRN	?CircleChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::CircleChaosMix
EXTRN	?PegasiaChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::PegasiaChaosMix
EXTRN	?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMixSystem::PlusItemLevelChaosMix
EXTRN	?DevilSquareItemChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DevilSquareItemChaosMix
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?Main@cChaosMixManager@@QAE_NHH@Z:PROC		; cChaosMixManager::Main
EXTRN	?ChaosMixManager@@3VcChaosMixManager@@A:BYTE	; ChaosMixManager
EXTRN	?GetOption@MixOption@@QAEXPAUOBJECTSTRUCT@@H@Z:PROC ; MixOption::GetOption
EXTRN	?g_MixOption@@3VMixOption@@A:BYTE		; g_MixOption
EXTRN	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; CheckInventoryEmptySpace
EXTRN	?GetSize@CItem@@QAEHAAH0@Z:PROC			; CItem::GetSize
;	COMDAT ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@
CONST	SEGMENT
??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@ DB '['
	DB	'%s][%s] Undefine chaosmix type detect %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
CONST	SEGMENT
??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ DB '['
	DB	'%s][%s] is Already Opening PShop, ChaosBox Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
CONST	SEGMENT
??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ DB '['
	DB	'%s][%s] Already Used Chaos', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z
_TEXT	SEGMENT
_iItemWidth$248885 = -44				; size = 4
_iItemHeight$248886 = -40				; size = 4
_aRecv$GSCopy$ = -36					; size = 4
_aIndex$GSCopy$ = -32					; size = 4
tv614 = -28						; size = 4
_validitemcount$248870 = -24				; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z PROC ; CGChaosBoxItemMixButtonClick, COMDAT

; 12768: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 12769: 	if ( !gObjIsConnectedGP(aIndex))

  00018	53		 push	 ebx

; 12836: 		}
; 12837: 
; 12838: 		int iItemWidth = 0;

  00019	89 7d dc	 mov	 DWORD PTR _aRecv$GSCopy$[ebp], edi
  0001c	89 5d e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001f	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 2a		 jne	 SHORT $LN73@CGChaosBox

; 12770: 	{
; 12771: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0002b	68 e3 31 00 00	 push	 12771			; 000031e3H
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0003a	6a 02		 push	 2
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	5f		 pop	 edi
  00046	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN73@CGChaosBox:
  00055	56		 push	 esi

; 12772: 		return;
; 12773: 	}
; 12774: 
; 12775: 	LPOBJ lpObj = &gObj[aIndex];

  00056	8b f3		 mov	 esi, ebx
  00058	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0005e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 12776: 
; 12777: 	if ( lpObj->ChaosLock == TRUE )

  00064	83 be 88 0e 00
	00 01		 cmp	 DWORD PTR [esi+3720], 1
  0006b	75 44		 jne	 SHORT $LN72@CGChaosBox

; 12778: 	{
; 12779: 		LogAdd("[%s][%s] Already Used Chaos", lpObj->AccountID, lpObj->Name);

  0006d	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00070	50		 push	 eax
  00071	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00074	51		 push	 ecx
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 12780: 		GCServerMsgStringSend(lMsg.Get(MSGGET(2, 198)), lpObj->m_Index, 1);

  00080	8b 16		 mov	 edx, DWORD PTR [esi]
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	6a 01		 push	 1
  00087	52		 push	 edx
  00088	68 c6 02 00 00	 push	 710			; 000002c6H
$LN85@CGChaosBox:
  0008d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00092	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 12844: 		{
; 12845: 			
; 12846: 		}
; 12847: 		else
; 12848: 		{
; 12849: 			pMsg.Result = 0;
; 12850: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	5e		 pop	 esi
  000a1	5f		 pop	 edi
  000a2	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a6	33 cd		 xor	 ecx, ebp
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN72@CGChaosBox:

; 12781: 		return;
; 12782: 	}
; 12783: 
; 12784: 	if ( lpObj->m_bPShopOpen == true )

  000b1	80 be c4 0e 00
	00 01		 cmp	 BYTE PTR [esi+3780], 1
  000b8	75 22		 jne	 SHORT $LN71@CGChaosBox

; 12785: 	{
; 12786: 		LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed", lpObj->AccountID, lpObj->Name);

  000ba	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  000bd	50		 push	 eax
  000be	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  000c1	51		 push	 ecx
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 12787: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  000cd	8b 16		 mov	 edx, DWORD PTR [esi]
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d2	6a 01		 push	 1
  000d4	52		 push	 edx
  000d5	68 c2 04 00 00	 push	 1218			; 000004c2H

; 12788: 		return;

  000da	eb b1		 jmp	 SHORT $LN85@CGChaosBox
$LN71@CGChaosBox:

; 12789: 	}
; 12790: 
; 12791: 	//season4 add-on start
; 12792: 	PMSG_CHAOSMIXRESULT pMsg;
; 12793: 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  000dc	6a 10		 push	 16			; 00000010H
  000de	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000e1	68 86 00 00 00	 push	 134			; 00000086H
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12794: 	pMsg.Result = CB_ERROR;
; 12795: 
; 12796: 	if( aRecv->Type == 3 ||
; 12797: 		aRecv->Type == 4 ||
; 12798: 		aRecv->Type == 22 ||
; 12799: 		aRecv->Type == 23 )

  000ec	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  000f6	3c 03		 cmp	 al, 3
  000f8	74 10		 je	 SHORT $LN69@CGChaosBox
  000fa	3c 04		 cmp	 al, 4
  000fc	74 0c		 je	 SHORT $LN69@CGChaosBox
  000fe	3c 16		 cmp	 al, 22			; 00000016H
  00100	74 08		 je	 SHORT $LN69@CGChaosBox
  00102	3c 17		 cmp	 al, 23			; 00000017H
  00104	0f 85 c5 00 00
	00		 jne	 $LN55@CGChaosBox
$LN69@CGChaosBox:

; 12800: 	{
; 12801: 		int pos = 0;

  0010a	33 ff		 xor	 edi, edi
  0010c	33 db		 xor	 ebx, ebx

; 12802: 		int validitemcount = 0;

  0010e	89 7d e8	 mov	 DWORD PTR _validitemcount$248870[ebp], edi
  00111	89 7d e4	 mov	 DWORD PTR tv614[ebp], edi
  00114	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL79@CGChaosBox:

; 12805: 		{
; 12806: 			if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  00120	8b 8e 78 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3704]
  00126	03 4d e4	 add	 ecx, DWORD PTR tv614[ebp]
  00129	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0012e	b9 01 00 00 00	 mov	 ecx, 1
  00133	3b c1		 cmp	 eax, ecx
  00135	75 2b		 jne	 SHORT $LN67@CGChaosBox

; 12807: 			{
; 12808: 				if( lpObj->pChaosBox[n].m_Level == 9)

  00137	8b 96 78 0e 00
	00		 mov	 edx, DWORD PTR [esi+3704]
  0013d	8b 45 e4	 mov	 eax, DWORD PTR tv614[ebp]
  00140	0f b7 44 02 08	 movzx	 eax, WORD PTR [edx+eax+8]
  00145	66 83 f8 09	 cmp	 ax, 9

; 12809: 				{
; 12810: 					pos = n;
; 12811: 					validitemcount++;

  00149	74 12		 je	 SHORT $LN83@CGChaosBox

; 12812: 				}
; 12813: 				else if( lpObj->pChaosBox[n].m_Level == 10)

  0014b	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH

; 12814: 				{
; 12815: 					pos = n;
; 12816: 					validitemcount++;

  0014f	74 0c		 je	 SHORT $LN83@CGChaosBox

; 12817: 				}
; 12818: 				else if( lpObj->pChaosBox[n].m_Level == 11)

  00151	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH

; 12819: 				{
; 12820: 					pos = n;
; 12821: 					validitemcount++;

  00155	74 06		 je	 SHORT $LN83@CGChaosBox

; 12822: 				}
; 12823: 				else if( lpObj->pChaosBox[n].m_Level == 12)

  00157	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH
  0015b	75 05		 jne	 SHORT $LN67@CGChaosBox
$LN83@CGChaosBox:

; 12824: 				{
; 12825: 					pos = n;
; 12826: 					validitemcount++;

  0015d	01 4d e8	 add	 DWORD PTR _validitemcount$248870[ebp], ecx
  00160	8b df		 mov	 ebx, edi
$LN67@CGChaosBox:

; 12803: 
; 12804: 		for ( int n=0;n<CHAOS_BOX_SIZE;n++) //loc8

  00162	8b 45 e4	 mov	 eax, DWORD PTR tv614[ebp]
  00165	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0016a	03 f9		 add	 edi, ecx
  0016c	89 45 e4	 mov	 DWORD PTR tv614[ebp], eax
  0016f	3d 80 1a 00 00	 cmp	 eax, 6784		; 00001a80H
  00174	7c aa		 jl	 SHORT $LL79@CGChaosBox

; 12827: 				}
; 12828: 			}
; 12829: 		}
; 12830: 
; 12831: 		if(validitemcount != 1)

  00176	39 4d e8	 cmp	 DWORD PTR _validitemcount$248870[ebp], ecx
  00179	74 12		 je	 SHORT $LN57@CGChaosBox

; 12832: 		{
; 12833: 			pMsg.Result = 0;
; 12834: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0017b	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0017f	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00182	51		 push	 ecx
  00183	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00186	52		 push	 edx
  00187	50		 push	 eax

; 12835: 			return;

  00188	e9 c0 06 00 00	 jmp	 $LN84@CGChaosBox
$LN57@CGChaosBox:

; 12839: 		int iItemHeight = 0;
; 12840: 
; 12841: 		lpObj->pChaosBox[pos].GetSize(iItemWidth, iItemHeight);

  0018d	8d 4d d8	 lea	 ecx, DWORD PTR _iItemHeight$248886[ebp]
  00190	51		 push	 ecx
  00191	8b cb		 mov	 ecx, ebx
  00193	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00199	03 8e 78 0e 00
	00		 add	 ecx, DWORD PTR [esi+3704]
  0019f	33 c0		 xor	 eax, eax
  001a1	8d 55 d4	 lea	 edx, DWORD PTR _iItemWidth$248885[ebp]
  001a4	52		 push	 edx
  001a5	89 45 d4	 mov	 DWORD PTR _iItemWidth$248885[ebp], eax
  001a8	89 45 d8	 mov	 DWORD PTR _iItemHeight$248886[ebp], eax
  001ab	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 12842: 
; 12843: 		if(CheckInventoryEmptySpace(lpObj,iItemHeight,iItemWidth) != 0)

  001b0	8b 45 d4	 mov	 eax, DWORD PTR _iItemWidth$248885[ebp]
  001b3	8b 4d d8	 mov	 ecx, DWORD PTR _iItemHeight$248886[ebp]
  001b6	50		 push	 eax
  001b7	51		 push	 ecx
  001b8	56		 push	 esi
  001b9	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c1	85 c0		 test	 eax, eax
  001c3	0f 84 77 06 00
	00		 je	 $LN56@CGChaosBox
  001c9	8b 5d e0	 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  001cc	8b 7d dc	 mov	 edi, DWORD PTR _aRecv$GSCopy$[ebp]
$LN55@CGChaosBox:

; 12851: 			return;
; 12852: 		}
; 12853: 	}
; 12854: 	//season4 add-on end
; 12855: 
; 12856: 	lpObj->bIsChaosMixCompleted = true;

  001cf	c6 86 79 12 00
	00 01		 mov	 BYTE PTR [esi+4729], 1

; 12857: 	int iMixType = aRecv->Type;

  001d6	0f b6 7f 03	 movzx	 edi, BYTE PTR [edi+3]

; 12858: 
; 12859: 	g_MixOption.GetOption(lpObj, iMixType);

  001da	57		 push	 edi
  001db	56		 push	 esi
  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixOption@@3VMixOption@@A ; g_MixOption
  001e1	e8 00 00 00 00	 call	 ?GetOption@MixOption@@QAEXPAUOBJECTSTRUCT@@H@Z ; MixOption::GetOption

; 12860: 
; 12861: 	if(ChaosMixManager.Main(aIndex, iMixType)) return;

  001e6	57		 push	 edi
  001e7	53		 push	 ebx
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?ChaosMixManager@@3VcChaosMixManager@@A ; ChaosMixManager
  001ed	e8 00 00 00 00	 call	 ?Main@cChaosMixManager@@QAE_NHH@Z ; cChaosMixManager::Main
  001f2	84 c0		 test	 al, al
  001f4	0f 85 5f 06 00
	00		 jne	 $LN81@CGChaosBox

; 12862: 
; 12863: 	switch ( iMixType )

  001fa	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  001fd	83 f8 67	 cmp	 eax, 103		; 00000067H
  00200	0f 87 12 06 00
	00		 ja	 $LN1@CGChaosBox
  00206	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN78@CGChaosBox[eax]
  0020d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN86@CGChaosBox[edx*4]
$LN51@CGChaosBox:

; 12864: 	{
; 12865: 		case CHAOS_TYPE_DEVILSQUARE:
; 12866: 			g_MixSystem.DevilSquareItemChaosMix(lpObj);

  00214	56		 push	 esi
  00215	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0021a	e8 00 00 00 00	 call	 ?DevilSquareItemChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::DevilSquareItemChaosMix
  0021f	5e		 pop	 esi
  00220	5f		 pop	 edi
  00221	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00222	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00225	33 cd		 xor	 ecx, ebp
  00227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
$LN50@CGChaosBox:

; 12867: 			break;
; 12868: 		case CHAOS_TYPE_UPGRADE_10:
; 12869: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_10);

  00230	6a 03		 push	 3
  00232	56		 push	 esi
  00233	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00238	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix
  0023d	5e		 pop	 esi
  0023e	5f		 pop	 edi
  0023f	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00240	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00243	33 cd		 xor	 ecx, ebp
  00245	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
$LN49@CGChaosBox:

; 12870: 			break;
; 12871: 		case CHAOS_TYPE_UPGRADE_11:
; 12872: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_11);

  0024e	6a 04		 push	 4
  00250	56		 push	 esi
  00251	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00256	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix
  0025b	5e		 pop	 esi
  0025c	5f		 pop	 edi
  0025d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0025e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00261	33 cd		 xor	 ecx, ebp
  00263	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c3		 ret	 0
$LN48@CGChaosBox:

; 12873: 			break;
; 12874: 		case CHAOS_TYPE_UPGRADE_12:
; 12875: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_12);

  0026c	6a 16		 push	 22			; 00000016H
  0026e	56		 push	 esi
  0026f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00274	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix
  00279	5e		 pop	 esi
  0027a	5f		 pop	 edi
  0027b	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0027c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027f	33 cd		 xor	 ecx, ebp
  00281	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c3		 ret	 0
$LN47@CGChaosBox:

; 12876: 			break;
; 12877: 		case CHAOS_TYPE_UPGRADE_13:
; 12878: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_13);

  0028a	6a 17		 push	 23			; 00000017H
  0028c	56		 push	 esi
  0028d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00292	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix
  00297	5e		 pop	 esi
  00298	5f		 pop	 edi
  00299	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0029a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029d	33 cd		 xor	 ecx, ebp
  0029f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a4	8b e5		 mov	 esp, ebp
  002a6	5d		 pop	 ebp
  002a7	c3		 ret	 0
$LN46@CGChaosBox:

; 12879: 			break;
; 12880: 			//Season 5 +15 Item
; 12881: 		case CHAOS_TYPE_UPGRADE_14:
; 12882: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_14);

  002a8	6a 31		 push	 49			; 00000031H
  002aa	56		 push	 esi
  002ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  002b0	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix
  002b5	5e		 pop	 esi
  002b6	5f		 pop	 edi
  002b7	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  002b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bb	33 cd		 xor	 ecx, ebp
  002bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c3		 ret	 0
$LN45@CGChaosBox:

; 12883: 			break;
; 12884: 		case CHAOS_TYPE_UPGRADE_15:
; 12885: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_15);

  002c6	6a 32		 push	 50			; 00000032H
  002c8	56		 push	 esi
  002c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  002ce	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix
  002d3	5e		 pop	 esi
  002d4	5f		 pop	 edi
  002d5	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  002d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d9	33 cd		 xor	 ecx, ebp
  002db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c3		 ret	 0
$LN44@CGChaosBox:

; 12886: 			break;
; 12887: 		case CHAOS_TYPE_DINORANT:
; 12888: 			g_MixSystem.PegasiaChaosMix(lpObj);

  002e4	56		 push	 esi
  002e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  002ea	e8 00 00 00 00	 call	 ?PegasiaChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::PegasiaChaosMix
  002ef	5e		 pop	 esi
  002f0	5f		 pop	 edi
  002f1	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  002f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f5	33 cd		 xor	 ecx, ebp
  002f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fc	8b e5		 mov	 esp, ebp
  002fe	5d		 pop	 ebp
  002ff	c3		 ret	 0
$LN43@CGChaosBox:

; 12889: 			break;
; 12890: 		case CHAOS_TYPE_FRUIT:
; 12891: 			g_MixSystem.CircleChaosMix(lpObj);

  00300	56		 push	 esi
  00301	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00306	e8 00 00 00 00	 call	 ?CircleChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::CircleChaosMix
  0030b	5e		 pop	 esi
  0030c	5f		 pop	 edi
  0030d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0030e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00311	33 cd		 xor	 ecx, ebp
  00313	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00318	8b e5		 mov	 esp, ebp
  0031a	5d		 pop	 ebp
  0031b	c3		 ret	 0
$LN42@CGChaosBox:

; 12892: 			break;
; 12893: 		case CHAOS_TYPE_SECOND_WING:
; 12894: 		case CHAOS_TYPE_CLOAK:
; 12895: 			g_MixSystem.WingChaosMix(lpObj);

  0031c	56		 push	 esi
  0031d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00322	e8 00 00 00 00	 call	 ?WingChaosMix@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::WingChaosMix
  00327	5e		 pop	 esi
  00328	5f		 pop	 edi
  00329	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0032a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032d	33 cd		 xor	 ecx, ebp
  0032f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c3		 ret	 0
$LN41@CGChaosBox:

; 12896: 			break;
; 12897: 		case CHAOS_TYPE_BLOODCATLE:
; 12898: 			g_MixSystem.BloodCastleItemChaosMix(lpObj);

  00338	56		 push	 esi
  00339	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0033e	e8 00 00 00 00	 call	 ?BloodCastleItemChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::BloodCastleItemChaosMix
  00343	5e		 pop	 esi
  00344	5f		 pop	 edi
  00345	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00346	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00349	33 cd		 xor	 ecx, ebp
  0034b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00350	8b e5		 mov	 esp, ebp
  00352	5d		 pop	 ebp
  00353	c3		 ret	 0
$LN40@CGChaosBox:

; 12899: 			break;
; 12900: 		case CHAOS_TYPE_DEFAULT:
; 12901: 		case CHAOS_TYPE_FIRST_WING:
; 12902: 			g_MixSystem.DefaultChaosMix(lpObj);

  00354	56		 push	 esi
  00355	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0035a	e8 00 00 00 00	 call	 ?DefaultChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::DefaultChaosMix
  0035f	5e		 pop	 esi
  00360	5f		 pop	 edi
  00361	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00362	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00365	33 cd		 xor	 ecx, ebp
  00367	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036c	8b e5		 mov	 esp, ebp
  0036e	5d		 pop	 ebp
  0036f	c3		 ret	 0
$LN39@CGChaosBox:

; 12903: 			break;
; 12904: 		//case CHAOS_TYPE_SETITEM:
; 12905: 			//g_MixSystem.SetItemChaosMix(lpObj);
; 12906: 			//break;
; 12907: 		case CHAOS_TYPE_DARKHORSE:
; 12908: 			g_MixSystem.DarkHorseChaosMix(lpObj);

  00370	56		 push	 esi
  00371	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00376	e8 00 00 00 00	 call	 ?DarkHorseChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::DarkHorseChaosMix
  0037b	5e		 pop	 esi
  0037c	5f		 pop	 edi
  0037d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0037e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00381	33 cd		 xor	 ecx, ebp
  00383	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
$LN38@CGChaosBox:

; 12909: 			break;
; 12910: 		case CHAOS_TYPE_DARKSPIRIT:
; 12911: 			g_MixSystem.DarkSpiritChaosMix(lpObj);

  0038c	56		 push	 esi
  0038d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00392	e8 00 00 00 00	 call	 ?DarkSpiritChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::DarkSpiritChaosMix
  00397	5e		 pop	 esi
  00398	5f		 pop	 edi
  00399	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0039a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039d	33 cd		 xor	 ecx, ebp
  0039f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a4	8b e5		 mov	 esp, ebp
  003a6	5d		 pop	 ebp
  003a7	c3		 ret	 0
$LN37@CGChaosBox:

; 12912: 			break;
; 12913: 		case CHAOS_TYPE_BLESS_POTION:
; 12914: 			g_MixSystem.BlessPotionChaosMix(lpObj);

  003a8	56		 push	 esi
  003a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  003ae	e8 00 00 00 00	 call	 ?BlessPotionChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::BlessPotionChaosMix
  003b3	5e		 pop	 esi
  003b4	5f		 pop	 edi
  003b5	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  003b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b9	33 cd		 xor	 ecx, ebp
  003bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c0	8b e5		 mov	 esp, ebp
  003c2	5d		 pop	 ebp
  003c3	c3		 ret	 0
$LN36@CGChaosBox:

; 12915: 			break;
; 12916: 		case CHAOS_TYPE_SOUL_POTION:
; 12917: 			g_MixSystem.SoulPotionChaosMix(lpObj);

  003c4	56		 push	 esi
  003c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  003ca	e8 00 00 00 00	 call	 ?SoulPotionChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::SoulPotionChaosMix
  003cf	5e		 pop	 esi
  003d0	5f		 pop	 edi
  003d1	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  003d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d5	33 cd		 xor	 ecx, ebp
  003d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003dc	8b e5		 mov	 esp, ebp
  003de	5d		 pop	 ebp
  003df	c3		 ret	 0
$LN35@CGChaosBox:

; 12918: 			break;
; 12919: 		case CHAOS_TYPE_LIFE_STONE:
; 12920: 			g_MixSystem.LifeStoneChaosMix(lpObj);

  003e0	56		 push	 esi
  003e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  003e6	e8 00 00 00 00	 call	 ?LifeStoneChaosMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::LifeStoneChaosMix
  003eb	5e		 pop	 esi
  003ec	5f		 pop	 edi
  003ed	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  003ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f1	33 cd		 xor	 ecx, ebp
  003f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f8	8b e5		 mov	 esp, ebp
  003fa	5d		 pop	 ebp
  003fb	c3		 ret	 0
$LN34@CGChaosBox:

; 12921: 			break;
; 12922: //#if(GS_CASTLE==1)
; 12923: 		case CHAOS_TYPE_CASTLE_ITEM:
; 12924: 			g_MixSystem.CastleSpecialItemMix(lpObj);

  003fc	56		 push	 esi
  003fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00402	e8 00 00 00 00	 call	 ?CastleSpecialItemMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::CastleSpecialItemMix
  00407	5e		 pop	 esi
  00408	5f		 pop	 edi
  00409	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0040a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040d	33 cd		 xor	 ecx, ebp
  0040f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00414	8b e5		 mov	 esp, ebp
  00416	5d		 pop	 ebp
  00417	c3		 ret	 0
$LN33@CGChaosBox:

; 12925: 			break;
; 12926: //#endif
; 12927: 		case CHAOS_TYPE_HT_BOX:
; 12928: 			g_MixSystem.HiddenTreasureBoxItemMix(lpObj);

  00418	56		 push	 esi
  00419	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0041e	e8 00 00 00 00	 call	 ?HiddenTreasureBoxItemMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::HiddenTreasureBoxItemMix
  00423	5e		 pop	 esi
  00424	5f		 pop	 edi
  00425	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00426	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00429	33 cd		 xor	 ecx, ebp
  0042b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00430	8b e5		 mov	 esp, ebp
  00432	5d		 pop	 ebp
  00433	c3		 ret	 0
$LN32@CGChaosBox:

; 12929: 			break;
; 12930: 		case CHAOS_TYPE_FENRIR_01:
; 12931: 			g_MixSystem.Fenrir_01Level_Mix(lpObj);

  00434	56		 push	 esi
  00435	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0043a	e8 00 00 00 00	 call	 ?Fenrir_01Level_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::Fenrir_01Level_Mix
  0043f	5e		 pop	 esi
  00440	5f		 pop	 edi
  00441	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00442	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00445	33 cd		 xor	 ecx, ebp
  00447	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0044c	8b e5		 mov	 esp, ebp
  0044e	5d		 pop	 ebp
  0044f	c3		 ret	 0
$LN31@CGChaosBox:

; 12932: 			break;
; 12933: 		case CHAOS_TYPE_FENRIR_02:
; 12934: 			g_MixSystem.Fenrir_02Level_Mix(lpObj);

  00450	56		 push	 esi
  00451	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00456	e8 00 00 00 00	 call	 ?Fenrir_02Level_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::Fenrir_02Level_Mix
  0045b	5e		 pop	 esi
  0045c	5f		 pop	 edi
  0045d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0045e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00461	33 cd		 xor	 ecx, ebp
  00463	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00468	8b e5		 mov	 esp, ebp
  0046a	5d		 pop	 ebp
  0046b	c3		 ret	 0
$LN30@CGChaosBox:

; 12935: 			break;
; 12936: 		case CHAOS_TYPE_FENRIR_03:
; 12937: 			g_MixSystem.Fenrir_03Level_Mix(lpObj);

  0046c	56		 push	 esi
  0046d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00472	e8 00 00 00 00	 call	 ?Fenrir_03Level_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::Fenrir_03Level_Mix
  00477	5e		 pop	 esi
  00478	5f		 pop	 edi
  00479	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0047a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047d	33 cd		 xor	 ecx, ebp
  0047f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00484	8b e5		 mov	 esp, ebp
  00486	5d		 pop	 ebp
  00487	c3		 ret	 0
$LN29@CGChaosBox:

; 12938: 			break;
; 12939: 		case CHAOS_TYPE_FENRIR_04:
; 12940: 			g_MixSystem.Fenrir_04Upgrade_Mix(lpObj);

  00488	56		 push	 esi
  00489	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0048e	e8 00 00 00 00	 call	 ?Fenrir_04Upgrade_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::Fenrir_04Upgrade_Mix
  00493	5e		 pop	 esi
  00494	5f		 pop	 edi
  00495	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00496	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00499	33 cd		 xor	 ecx, ebp
  0049b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a0	8b e5		 mov	 esp, ebp
  004a2	5d		 pop	 ebp
  004a3	c3		 ret	 0
$LN28@CGChaosBox:

; 12941: 			break;
; 12942: 		case CHAOS_TYPE_COMPOUNDPOTION_LV1:
; 12943: 			g_MixSystem.ShieldPotionLv1_Mix(lpObj);

  004a4	56		 push	 esi
  004a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  004aa	e8 00 00 00 00	 call	 ?ShieldPotionLv1_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::ShieldPotionLv1_Mix
  004af	5e		 pop	 esi
  004b0	5f		 pop	 edi
  004b1	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  004b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b5	33 cd		 xor	 ecx, ebp
  004b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bc	8b e5		 mov	 esp, ebp
  004be	5d		 pop	 ebp
  004bf	c3		 ret	 0
$LN27@CGChaosBox:

; 12944: 			break;
; 12945: 		case CHAOS_TYPE_COMPOUNTPOTION_LV2:
; 12946: 			g_MixSystem.ShieldPotionLv2_Mix(lpObj);

  004c0	56		 push	 esi
  004c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  004c6	e8 00 00 00 00	 call	 ?ShieldPotionLv2_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::ShieldPotionLv2_Mix
  004cb	5e		 pop	 esi
  004cc	5f		 pop	 edi
  004cd	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  004ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d1	33 cd		 xor	 ecx, ebp
  004d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d8	8b e5		 mov	 esp, ebp
  004da	5d		 pop	 ebp
  004db	c3		 ret	 0
$LN26@CGChaosBox:

; 12947: 			break;
; 12948: 		case CHAOS_TYPE_COMPOUNTPOTION_LV3:
; 12949: 			g_MixSystem.ShieldPotionLv3_Mix(lpObj);

  004dc	56		 push	 esi
  004dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  004e2	e8 00 00 00 00	 call	 ?ShieldPotionLv3_Mix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::ShieldPotionLv3_Mix
  004e7	5e		 pop	 esi
  004e8	5f		 pop	 edi
  004e9	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  004ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ed	33 cd		 xor	 ecx, ebp
  004ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f4	8b e5		 mov	 esp, ebp
  004f6	5d		 pop	 ebp
  004f7	c3		 ret	 0
$LN25@CGChaosBox:

; 12950: 			break;
; 12951: 		case CHAOS_TYPE_JEWELOFHARMONY_PURITY:
; 12952: 			g_kJewelOfHarmonySystem.PurityJewelOfHarmony(lpObj);

  004f8	56		 push	 esi
  004f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  004fe	e8 00 00 00 00	 call	 ?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::PurityJewelOfHarmony
  00503	5e		 pop	 esi
  00504	5f		 pop	 edi
  00505	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00506	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00509	33 cd		 xor	 ecx, ebp
  0050b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00510	8b e5		 mov	 esp, ebp
  00512	5d		 pop	 ebp
  00513	c3		 ret	 0
$LN24@CGChaosBox:

; 12953: 			break;
; 12954: 		case CHAOS_TYPE_JEWELOFHARMONY_MIX_SMELTINGITEM:
; 12955: 			g_kJewelOfHarmonySystem.MakeSmeltingStoneItem(lpObj);

  00514	56		 push	 esi
  00515	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0051a	e8 00 00 00 00	 call	 ?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
  0051f	5e		 pop	 esi
  00520	5f		 pop	 edi
  00521	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00522	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00525	33 cd		 xor	 ecx, ebp
  00527	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0052c	8b e5		 mov	 esp, ebp
  0052e	5d		 pop	 ebp
  0052f	c3		 ret	 0
$LN23@CGChaosBox:

; 12956: 			break;
; 12957: 		case CHAOS_TYPE_JEWELOFHARMONY_RESTORE_ITEM:
; 12958: 			g_kJewelOfHarmonySystem.RestoreStrengthenItem(lpObj);

  00530	56		 push	 esi
  00531	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00536	e8 00 00 00 00	 call	 ?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::RestoreStrengthenItem
  0053b	5e		 pop	 esi
  0053c	5f		 pop	 edi
  0053d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0053e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00541	33 cd		 xor	 ecx, ebp
  00543	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00548	8b e5		 mov	 esp, ebp
  0054a	5d		 pop	 ebp
  0054b	c3		 ret	 0
$LN22@CGChaosBox:

; 12959: 			break;
; 12960: 		case CHAOS_TYPE_380_OPTIONITEM:
; 12961: 			g_kItemSystemFor380.ChaosMix380ItemOption(lpObj);

  0054c	56		 push	 esi
  0054d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  00552	e8 00 00 00 00	 call	 ?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ; CItemSystemFor380::ChaosMix380ItemOption
  00557	5e		 pop	 esi
  00558	5f		 pop	 edi
  00559	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0055a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055d	33 cd		 xor	 ecx, ebp
  0055f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00564	8b e5		 mov	 esp, ebp
  00566	5d		 pop	 ebp
  00567	c3		 ret	 0
$LN21@CGChaosBox:

; 12962: 			break;
; 12963: 		case CHAOS_TYPE_LOTTERY_MIX:
; 12964: 			g_MixSystem.LotteryItemMix(lpObj);

  00568	56		 push	 esi
  00569	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0056e	e8 00 00 00 00	 call	 ?LotteryItemMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::LotteryItemMix
  00573	5e		 pop	 esi
  00574	5f		 pop	 edi
  00575	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00576	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00579	33 cd		 xor	 ecx, ebp
  0057b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00580	8b e5		 mov	 esp, ebp
  00582	5d		 pop	 ebp
  00583	c3		 ret	 0
$LN20@CGChaosBox:

; 12965: 			break;
; 12966: 		case CHAOS_TYPE_BLOOD_SCROLL_MIX:
; 12967: 			g_IllusionTempleEvent.TicketChaosMix(lpObj);

  00584	56		 push	 esi
  00585	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  0058a	e8 00 00 00 00	 call	 ?TicketChaosMix@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::TicketChaosMix
  0058f	5e		 pop	 esi
  00590	5f		 pop	 edi
  00591	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00592	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00595	33 cd		 xor	 ecx, ebp
  00597	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0059c	8b e5		 mov	 esp, ebp
  0059e	5d		 pop	 ebp
  0059f	c3		 ret	 0
$LN19@CGChaosBox:

; 12968: 			break;
; 12969: 		case CHAOS_TYPE_CONDOR_FEATHER_MIX:
; 12970: 			g_MixSystem.ThirdWingMix1(lpObj);

  005a0	56		 push	 esi
  005a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  005a6	e8 00 00 00 00	 call	 ?ThirdWingMix1@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::ThirdWingMix1
  005ab	5e		 pop	 esi
  005ac	5f		 pop	 edi
  005ad	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  005ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b1	33 cd		 xor	 ecx, ebp
  005b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005b8	8b e5		 mov	 esp, ebp
  005ba	5d		 pop	 ebp
  005bb	c3		 ret	 0
$LN18@CGChaosBox:

; 12971: 			break;
; 12972: 		case CHAOS_TYPE_THIRD_WING_MIX:
; 12973: 			g_MixSystem.ThirdWingMix2(lpObj);

  005bc	56		 push	 esi
  005bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  005c2	e8 00 00 00 00	 call	 ?ThirdWingMix2@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::ThirdWingMix2
  005c7	5e		 pop	 esi
  005c8	5f		 pop	 edi
  005c9	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  005ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005cd	33 cd		 xor	 ecx, ebp
  005cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d4	8b e5		 mov	 esp, ebp
  005d6	5d		 pop	 ebp
  005d7	c3		 ret	 0
$LN17@CGChaosBox:

; 12974: 			break;
; 12975: 		case CHAOS_TYPE_CHERRYBLOSSOM_MIX:
; 12976: 			g_MixSystem.CherryBlossomMix(lpObj);

  005d8	56		 push	 esi
  005d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  005de	e8 00 00 00 00	 call	 ?CherryBlossomMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::CherryBlossomMix
  005e3	5e		 pop	 esi
  005e4	5f		 pop	 edi
  005e5	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  005e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e9	33 cd		 xor	 ecx, ebp
  005eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f0	8b e5		 mov	 esp, ebp
  005f2	5d		 pop	 ebp
  005f3	c3		 ret	 0
$LN16@CGChaosBox:

; 12977: 			break;
; 12978: 			//season4 add-on start
; 12979: 		case CHAOS_TYPE_SOCKET_SEED_EXTRACT_MIX:
; 12980: 			g_MixSystem.SocketSeedExtract(lpObj);

  005f4	56		 push	 esi
  005f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  005fa	e8 00 00 00 00	 call	 ?SocketSeedExtract@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::SocketSeedExtract
  005ff	5e		 pop	 esi
  00600	5f		 pop	 edi
  00601	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00602	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00605	33 cd		 xor	 ecx, ebp
  00607	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0060c	8b e5		 mov	 esp, ebp
  0060e	5d		 pop	 ebp
  0060f	c3		 ret	 0
$LN15@CGChaosBox:

; 12981: 			break;
; 12982: 		case CHAOS_TYPE_SOCKET_SPHERE_COMPOSITE_MIX:
; 12983: 			g_MixSystem.SocketSeedSphereComposite(lpObj);

  00610	56		 push	 esi
  00611	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00616	e8 00 00 00 00	 call	 ?SocketSeedSphereComposite@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::SocketSeedSphereComposite
  0061b	5e		 pop	 esi
  0061c	5f		 pop	 edi
  0061d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0061e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00621	33 cd		 xor	 ecx, ebp
  00623	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00628	8b e5		 mov	 esp, ebp
  0062a	5d		 pop	 ebp
  0062b	c3		 ret	 0
$LN14@CGChaosBox:

; 12984: 			break;
; 12985: 		case CHAOS_TYPE_SOCKET_SPHERE_SET_MIX:
; 12986: 			g_MixSystem.SocketSetSeedSphere(lpObj, aRecv->SocketSlot);

  0062c	8b 45 dc	 mov	 eax, DWORD PTR _aRecv$GSCopy$[ebp]
  0062f	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00633	51		 push	 ecx
  00634	56		 push	 esi
  00635	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0063a	e8 00 00 00 00	 call	 ?SocketSetSeedSphere@CMixSystem@@QAEXPAUOBJECTSTRUCT@@E@Z ; CMixSystem::SocketSetSeedSphere
  0063f	5e		 pop	 esi
  00640	5f		 pop	 edi
  00641	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00642	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00645	33 cd		 xor	 ecx, ebp
  00647	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0064c	8b e5		 mov	 esp, ebp
  0064e	5d		 pop	 ebp
  0064f	c3		 ret	 0
$LN13@CGChaosBox:

; 12987: 			break;
; 12988: 		case CHAOS_TYPE_SOCKET_SPHERE_REMOVE_MIX:
; 12989: 			g_MixSystem.SocketRemoveSeedSphere(lpObj, aRecv->SocketSlot);

  00650	8b 55 dc	 mov	 edx, DWORD PTR _aRecv$GSCopy$[ebp]
  00653	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00657	50		 push	 eax
  00658	56		 push	 esi
  00659	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0065e	e8 00 00 00 00	 call	 ?SocketRemoveSeedSphere@CMixSystem@@QAEXPAUOBJECTSTRUCT@@E@Z ; CMixSystem::SocketRemoveSeedSphere
  00663	5e		 pop	 esi
  00664	5f		 pop	 edi
  00665	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00666	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00669	33 cd		 xor	 ecx, ebp
  0066b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00670	8b e5		 mov	 esp, ebp
  00672	5d		 pop	 ebp
  00673	c3		 ret	 0
$LN12@CGChaosBox:

; 12990: 			break;
; 12991: 		case CHAOS_TYPE_SECROMICON:	//Season 5 ImperialFort
; 12992: 			g_MixSystem.SecromiconMix(lpObj);

  00674	56		 push	 esi
  00675	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0067a	e8 00 00 00 00	 call	 ?SecromiconMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::SecromiconMix
  0067f	5e		 pop	 esi
  00680	5f		 pop	 edi
  00681	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00682	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00685	33 cd		 xor	 ecx, ebp
  00687	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0068c	8b e5		 mov	 esp, ebp
  0068e	5d		 pop	 ebp
  0068f	c3		 ret	 0
$LN11@CGChaosBox:

; 12993: 			break;
; 12994: 		case 47:	//CHAOS_TYPE_GOLD_AND_SILBER_BOX
; 12995: 			g_MixSystem.GoldenNSilverBoxMix(lpObj);

  00690	56		 push	 esi
  00691	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00696	e8 00 00 00 00	 call	 ?GoldenNSilverBoxMix@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::GoldenNSilverBoxMix
  0069b	5e		 pop	 esi
  0069c	5f		 pop	 edi
  0069d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0069e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006a1	33 cd		 xor	 ecx, ebp
  006a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a8	8b e5		 mov	 esp, ebp
  006aa	5d		 pop	 ebp
  006ab	c3		 ret	 0
$LN10@CGChaosBox:

; 12996: 			break;
; 12997: #ifdef LUCKYITEM
; 12998: 		case 51:
; 12999: 			g_LuckyItemManager.LuckyItemTicketExchange(lpObj);

  006ac	56		 push	 esi
  006ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  006b2	e8 00 00 00 00	 call	 ?LuckyItemTicketExchange@LuckyItemManager@@QAEXPAUOBJECTSTRUCT@@@Z ; LuckyItemManager::LuckyItemTicketExchange
  006b7	5e		 pop	 esi
  006b8	5f		 pop	 edi
  006b9	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  006ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006bd	33 cd		 xor	 ecx, ebp
  006bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006c4	8b e5		 mov	 esp, ebp
  006c6	5d		 pop	 ebp
  006c7	c3		 ret	 0
$LN9@CGChaosBox:

; 13000: 			break;
; 13001: 		case 52:
; 13002: 			g_LuckyItemManager.LuckyItemSmelting(lpObj);

  006c8	56		 push	 esi
  006c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  006ce	e8 00 00 00 00	 call	 ?LuckyItemSmelting@LuckyItemManager@@QAEXPAUOBJECTSTRUCT@@@Z ; LuckyItemManager::LuckyItemSmelting
  006d3	5e		 pop	 esi
  006d4	5f		 pop	 edi
  006d5	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  006d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d9	33 cd		 xor	 ecx, ebp
  006db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e0	8b e5		 mov	 esp, ebp
  006e2	5d		 pop	 ebp
  006e3	c3		 ret	 0
$LN8@CGChaosBox:

; 13003: 			break;
; 13004: #endif
; 13005: 
; 13006: 		case 100:
; 13007: 			g_MixSystem.MixWings2_5(lpObj);

  006e4	56		 push	 esi
  006e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  006ea	e8 00 00 00 00	 call	 ?MixWings2_5@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::MixWings2_5
  006ef	5e		 pop	 esi
  006f0	5f		 pop	 edi
  006f1	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  006f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006f5	33 cd		 xor	 ecx, ebp
  006f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006fc	8b e5		 mov	 esp, ebp
  006fe	5d		 pop	 ebp
  006ff	c3		 ret	 0
$LN7@CGChaosBox:

; 13008: 			break;
; 13009: 		case 101:
; 13010: 			g_MixSystem.MixWings4rd(lpObj);

  00700	56		 push	 esi
  00701	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00706	e8 00 00 00 00	 call	 ?MixWings4rd@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::MixWings4rd
  0070b	5e		 pop	 esi
  0070c	5f		 pop	 edi
  0070d	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0070e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00711	33 cd		 xor	 ecx, ebp
  00713	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00718	8b e5		 mov	 esp, ebp
  0071a	5d		 pop	 ebp
  0071b	c3		 ret	 0
$LN6@CGChaosBox:

; 13011: 			break;
; 13012: 		case 102:
; 13013: 			g_MixSystem.MixWings5rd(lpObj);

  0071c	56		 push	 esi
  0071d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00722	e8 00 00 00 00	 call	 ?MixWings5rd@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::MixWings5rd
  00727	5e		 pop	 esi
  00728	5f		 pop	 edi
  00729	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0072a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0072d	33 cd		 xor	 ecx, ebp
  0072f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00734	8b e5		 mov	 esp, ebp
  00736	5d		 pop	 ebp
  00737	c3		 ret	 0
$LN5@CGChaosBox:

; 13014: 			break;
; 13015: 			//season4 add-on end
; 13016: #if(GRAND_HERO_DEV)
; 13017: 		case 103:
; 13018: 			GrandHero.MixGrandItem(lpObj);

  00738	56		 push	 esi
  00739	b9 00 00 00 00	 mov	 ecx, OFFSET ?GrandHero@@3VcGrandHero@@A ; GrandHero
  0073e	e8 00 00 00 00	 call	 ?MixGrandItem@cGrandHero@@QAEXPAUOBJECTSTRUCT@@@Z ; cGrandHero::MixGrandItem
  00743	5e		 pop	 esi
  00744	5f		 pop	 edi
  00745	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00746	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00749	33 cd		 xor	 ecx, ebp
  0074b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00750	8b e5		 mov	 esp, ebp
  00752	5d		 pop	 ebp
  00753	c3		 ret	 0
$LN4@CGChaosBox:

; 13019: 			break;
; 13020: #endif
; 13021: #ifdef NEWWINGS_6
; 13022: 		case 104:
; 13023: 			{
; 13024: 				if(g_ZtLicense.CheckUser(eZtUB::PrideMuLocal)	||
; 13025: 				   g_ZtLicense.CheckUser(eZtUB::PrideMu)		|| 
; 13026: 				   g_ZtLicense.CheckUser(eZtUB::Local3)			|| 
; 13027: 				   g_ZtLicense.CheckUser(eZtUB::Local)			||
; 13028: 				   g_ZtLicense.CheckUser(eZtUB::Artem)			||
; 13029: 				   g_ZtLicense.CheckUser(eZtUB::SILVER1)		||
; 13030: 				   g_ZtLicense.CheckUser(eZtUB::SILVER2)		||
; 13031: 				   g_ZtLicense.CheckUser(eZtUB::SILVER_Local)	||
; 13032: 				   g_ZtLicense.CheckUser(eZtUB::Artem2)			||
; 13033: 				   g_ZtLicense.CheckUser(eZtUB::eternalmu))

  00754	6a 1a		 push	 26			; 0000001aH
  00756	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0075b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00760	84 c0		 test	 al, al
  00762	0f 85 94 00 00
	00		 jne	 $LN2@CGChaosBox
  00768	6a 11		 push	 17			; 00000011H
  0076a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0076f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00774	84 c0		 test	 al, al
  00776	0f 85 80 00 00
	00		 jne	 $LN2@CGChaosBox
  0077c	6a 1c		 push	 28			; 0000001cH
  0077e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00783	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00788	84 c0		 test	 al, al
  0078a	75 70		 jne	 SHORT $LN2@CGChaosBox
  0078c	6a 00		 push	 0
  0078e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00793	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00798	84 c0		 test	 al, al
  0079a	75 60		 jne	 SHORT $LN2@CGChaosBox
  0079c	6a 30		 push	 48			; 00000030H
  0079e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007a3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007a8	84 c0		 test	 al, al
  007aa	75 50		 jne	 SHORT $LN2@CGChaosBox
  007ac	6a 07		 push	 7
  007ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007b3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007b8	84 c0		 test	 al, al
  007ba	75 40		 jne	 SHORT $LN2@CGChaosBox
  007bc	6a 08		 push	 8
  007be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007c3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007c8	84 c0		 test	 al, al
  007ca	75 30		 jne	 SHORT $LN2@CGChaosBox
  007cc	6a 2b		 push	 43			; 0000002bH
  007ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007d3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007d8	84 c0		 test	 al, al
  007da	75 20		 jne	 SHORT $LN2@CGChaosBox
  007dc	6a 31		 push	 49			; 00000031H
  007de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007e3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007e8	84 c0		 test	 al, al
  007ea	75 10		 jne	 SHORT $LN2@CGChaosBox
  007ec	6a 4f		 push	 79			; 0000004fH
  007ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  007f3	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  007f8	84 c0		 test	 al, al
  007fa	74 5d		 je	 SHORT $LN81@CGChaosBox
$LN2@CGChaosBox:

; 13034: 				{
; 13035: 					g_MixSystem.MixWings6rd(lpObj);

  007fc	56		 push	 esi
  007fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00802	e8 00 00 00 00	 call	 ?MixWings6rd@CMixSystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CMixSystem::MixWings6rd
  00807	5e		 pop	 esi
  00808	5f		 pop	 edi
  00809	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  0080a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0080d	33 cd		 xor	 ecx, ebp
  0080f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00814	8b e5		 mov	 esp, ebp
  00816	5d		 pop	 ebp
  00817	c3		 ret	 0
$LN1@CGChaosBox:

; 13036: 				}
; 13037: 			}
; 13038: 			break;
; 13039: #endif
; 13040: 		default:
; 13041: 			LogAddTD("[%s][%s] Undefine chaosmix type detect %d", lpObj->AccountID, lpObj->Name, iMixType);

  00818	57		 push	 edi
  00819	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0081c	51		 push	 ecx
  0081d	83 c6 6c	 add	 esi, 108		; 0000006cH
  00820	56		 push	 esi
  00821	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@
  00826	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0082c	83 c4 10	 add	 esp, 16			; 00000010H
  0082f	5e		 pop	 esi
  00830	5f		 pop	 edi
  00831	5b		 pop	 ebx

; 13042: 			break;
; 13043: 	}
; 13044: }

  00832	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00835	33 cd		 xor	 ecx, ebp
  00837	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0083c	8b e5		 mov	 esp, ebp
  0083e	5d		 pop	 ebp
  0083f	c3		 ret	 0
$LN56@CGChaosBox:

; 12844: 		{
; 12845: 			
; 12846: 		}
; 12847: 		else
; 12848: 		{
; 12849: 			pMsg.Result = 0;
; 12850: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00840	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00844	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00847	52		 push	 edx
  00848	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0084b	50		 push	 eax
  0084c	51		 push	 ecx
$LN84@CGChaosBox:
  0084d	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  00851	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00856	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN81@CGChaosBox:

; 13042: 			break;
; 13043: 	}
; 13044: }

  00859	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0085c	5e		 pop	 esi
  0085d	5f		 pop	 edi
  0085e	33 cd		 xor	 ecx, ebp
  00860	5b		 pop	 ebx
  00861	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00866	8b e5		 mov	 esp, ebp
  00868	5d		 pop	 ebp
  00869	c3		 ret	 0
  0086a	8b ff		 npad	 2
$LN86@CGChaosBox:
  0086c	00 00 00 00	 DD	 $LN40@CGChaosBox
  00870	00 00 00 00	 DD	 $LN51@CGChaosBox
  00874	00 00 00 00	 DD	 $LN50@CGChaosBox
  00878	00 00 00 00	 DD	 $LN49@CGChaosBox
  0087c	00 00 00 00	 DD	 $LN44@CGChaosBox
  00880	00 00 00 00	 DD	 $LN43@CGChaosBox
  00884	00 00 00 00	 DD	 $LN42@CGChaosBox
  00888	00 00 00 00	 DD	 $LN41@CGChaosBox
  0088c	00 00 00 00	 DD	 $LN39@CGChaosBox
  00890	00 00 00 00	 DD	 $LN38@CGChaosBox
  00894	00 00 00 00	 DD	 $LN37@CGChaosBox
  00898	00 00 00 00	 DD	 $LN36@CGChaosBox
  0089c	00 00 00 00	 DD	 $LN35@CGChaosBox
  008a0	00 00 00 00	 DD	 $LN34@CGChaosBox
  008a4	00 00 00 00	 DD	 $LN33@CGChaosBox
  008a8	00 00 00 00	 DD	 $LN48@CGChaosBox
  008ac	00 00 00 00	 DD	 $LN47@CGChaosBox
  008b0	00 00 00 00	 DD	 $LN32@CGChaosBox
  008b4	00 00 00 00	 DD	 $LN31@CGChaosBox
  008b8	00 00 00 00	 DD	 $LN30@CGChaosBox
  008bc	00 00 00 00	 DD	 $LN29@CGChaosBox
  008c0	00 00 00 00	 DD	 $LN28@CGChaosBox
  008c4	00 00 00 00	 DD	 $LN27@CGChaosBox
  008c8	00 00 00 00	 DD	 $LN26@CGChaosBox
  008cc	00 00 00 00	 DD	 $LN25@CGChaosBox
  008d0	00 00 00 00	 DD	 $LN24@CGChaosBox
  008d4	00 00 00 00	 DD	 $LN23@CGChaosBox
  008d8	00 00 00 00	 DD	 $LN22@CGChaosBox
  008dc	00 00 00 00	 DD	 $LN20@CGChaosBox
  008e0	00 00 00 00	 DD	 $LN19@CGChaosBox
  008e4	00 00 00 00	 DD	 $LN18@CGChaosBox
  008e8	00 00 00 00	 DD	 $LN21@CGChaosBox
  008ec	00 00 00 00	 DD	 $LN17@CGChaosBox
  008f0	00 00 00 00	 DD	 $LN16@CGChaosBox
  008f4	00 00 00 00	 DD	 $LN15@CGChaosBox
  008f8	00 00 00 00	 DD	 $LN14@CGChaosBox
  008fc	00 00 00 00	 DD	 $LN13@CGChaosBox
  00900	00 00 00 00	 DD	 $LN12@CGChaosBox
  00904	00 00 00 00	 DD	 $LN11@CGChaosBox
  00908	00 00 00 00	 DD	 $LN46@CGChaosBox
  0090c	00 00 00 00	 DD	 $LN45@CGChaosBox
  00910	00 00 00 00	 DD	 $LN10@CGChaosBox
  00914	00 00 00 00	 DD	 $LN9@CGChaosBox
  00918	00 00 00 00	 DD	 $LN8@CGChaosBox
  0091c	00 00 00 00	 DD	 $LN7@CGChaosBox
  00920	00 00 00 00	 DD	 $LN6@CGChaosBox
  00924	00 00 00 00	 DD	 $LN5@CGChaosBox
  00928	00 00 00 00	 DD	 $LN4@CGChaosBox
  0092c	00 00 00 00	 DD	 $LN1@CGChaosBox
$LN78@CGChaosBox:
  00930	00		 DB	 0
  00931	01		 DB	 1
  00932	02		 DB	 2
  00933	03		 DB	 3
  00934	04		 DB	 4
  00935	05		 DB	 5
  00936	06		 DB	 6
  00937	07		 DB	 7
  00938	30		 DB	 48			; 00000030H
  00939	30		 DB	 48			; 00000030H
  0093a	00		 DB	 0
  0093b	30		 DB	 48			; 00000030H
  0093c	08		 DB	 8
  0093d	09		 DB	 9
  0093e	0a		 DB	 10			; 0000000aH
  0093f	0b		 DB	 11			; 0000000bH
  00940	0c		 DB	 12			; 0000000cH
  00941	0d		 DB	 13			; 0000000dH
  00942	30		 DB	 48			; 00000030H
  00943	0e		 DB	 14			; 0000000eH
  00944	30		 DB	 48			; 00000030H
  00945	0f		 DB	 15			; 0000000fH
  00946	10		 DB	 16			; 00000010H
  00947	06		 DB	 6
  00948	11		 DB	 17			; 00000011H
  00949	12		 DB	 18			; 00000012H
  0094a	13		 DB	 19			; 00000013H
  0094b	14		 DB	 20			; 00000014H
  0094c	30		 DB	 48			; 00000030H
  0094d	15		 DB	 21			; 00000015H
  0094e	16		 DB	 22			; 00000016H
  0094f	17		 DB	 23			; 00000017H
  00950	18		 DB	 24			; 00000018H
  00951	19		 DB	 25			; 00000019H
  00952	1a		 DB	 26			; 0000001aH
  00953	1b		 DB	 27			; 0000001bH
  00954	1c		 DB	 28			; 0000001cH
  00955	1d		 DB	 29			; 0000001dH
  00956	1e		 DB	 30			; 0000001eH
  00957	1f		 DB	 31			; 0000001fH
  00958	20		 DB	 32			; 00000020H
  00959	21		 DB	 33			; 00000021H
  0095a	22		 DB	 34			; 00000022H
  0095b	23		 DB	 35			; 00000023H
  0095c	24		 DB	 36			; 00000024H
  0095d	25		 DB	 37			; 00000025H
  0095e	26		 DB	 38			; 00000026H
  0095f	30		 DB	 48			; 00000030H
  00960	27		 DB	 39			; 00000027H
  00961	28		 DB	 40			; 00000028H
  00962	29		 DB	 41			; 00000029H
  00963	2a		 DB	 42			; 0000002aH
  00964	30		 DB	 48			; 00000030H
  00965	30		 DB	 48			; 00000030H
  00966	30		 DB	 48			; 00000030H
  00967	30		 DB	 48			; 00000030H
  00968	30		 DB	 48			; 00000030H
  00969	30		 DB	 48			; 00000030H
  0096a	30		 DB	 48			; 00000030H
  0096b	30		 DB	 48			; 00000030H
  0096c	30		 DB	 48			; 00000030H
  0096d	30		 DB	 48			; 00000030H
  0096e	30		 DB	 48			; 00000030H
  0096f	30		 DB	 48			; 00000030H
  00970	30		 DB	 48			; 00000030H
  00971	30		 DB	 48			; 00000030H
  00972	30		 DB	 48			; 00000030H
  00973	30		 DB	 48			; 00000030H
  00974	30		 DB	 48			; 00000030H
  00975	30		 DB	 48			; 00000030H
  00976	30		 DB	 48			; 00000030H
  00977	30		 DB	 48			; 00000030H
  00978	30		 DB	 48			; 00000030H
  00979	30		 DB	 48			; 00000030H
  0097a	30		 DB	 48			; 00000030H
  0097b	30		 DB	 48			; 00000030H
  0097c	30		 DB	 48			; 00000030H
  0097d	30		 DB	 48			; 00000030H
  0097e	30		 DB	 48			; 00000030H
  0097f	30		 DB	 48			; 00000030H
  00980	30		 DB	 48			; 00000030H
  00981	30		 DB	 48			; 00000030H
  00982	30		 DB	 48			; 00000030H
  00983	30		 DB	 48			; 00000030H
  00984	30		 DB	 48			; 00000030H
  00985	30		 DB	 48			; 00000030H
  00986	30		 DB	 48			; 00000030H
  00987	30		 DB	 48			; 00000030H
  00988	30		 DB	 48			; 00000030H
  00989	30		 DB	 48			; 00000030H
  0098a	30		 DB	 48			; 00000030H
  0098b	30		 DB	 48			; 00000030H
  0098c	30		 DB	 48			; 00000030H
  0098d	30		 DB	 48			; 00000030H
  0098e	30		 DB	 48			; 00000030H
  0098f	30		 DB	 48			; 00000030H
  00990	30		 DB	 48			; 00000030H
  00991	30		 DB	 48			; 00000030H
  00992	30		 DB	 48			; 00000030H
  00993	2b		 DB	 43			; 0000002bH
  00994	2c		 DB	 44			; 0000002cH
  00995	2d		 DB	 45			; 0000002dH
  00996	2e		 DB	 46			; 0000002eH
  00997	2f		 DB	 47			; 0000002fH
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ENDP ; CGChaosBoxItemMixButtonClick
_TEXT	ENDS
PUBLIC	?CGChaosBoxUseEnd@@YAXH@Z			; CGChaosBoxUseEnd
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
; Function compile flags: /Ogtp
;	COMDAT ?CGChaosBoxUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?CGChaosBoxUseEnd@@YAXH@Z PROC				; CGChaosBoxUseEnd, COMDAT

; 13047: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 13048: 	if ( !gObjIsConnectedGP(aIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN2@CGChaosBox@2

; 13049: 	{
; 13050: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00015	68 fa 32 00 00	 push	 13050			; 000032faH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 13069: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@CGChaosBox@2:
  00034	56		 push	 esi

; 13051: 		return;
; 13052: 	}
; 13053: 
; 13054: 	LPOBJ lpObj = &gObj[aIndex];

  00035	8b f7		 mov	 esi, edi
  00037	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0003d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13055: 
; 13056: 	PMSG_DEFAULT pMsg;
; 13057: 	PHeadSetB((LPBYTE)&pMsg, 0x87, sizeof(pMsg));

  00043	6a 03		 push	 3
  00045	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00048	68 87 00 00 00	 push	 135			; 00000087H
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13058: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00053	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00057	51		 push	 ecx
  00058	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0005b	52		 push	 edx
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 13059: 
; 13060: 	if ( lpObj->m_IfState.use && lpObj->m_IfState.type == 7 )

  00062	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  00068	83 c4 18	 add	 esp, 24			; 00000018H
  0006b	a8 03		 test	 al, 3
  0006d	74 19		 je	 SHORT $LN1@CGChaosBox@2
  0006f	8b c8		 mov	 ecx, eax
  00071	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00077	81 f9 c0 01 00
	00		 cmp	 ecx, 448		; 000001c0H
  0007d	75 09		 jne	 SHORT $LN1@CGChaosBox@2

; 13061: 	{
; 13062: 		lpObj->m_IfState.use = 0;
; 13063: 		lpObj->m_IfState.state = 0;

  0007f	83 e0 c0	 and	 eax, -64		; ffffffc0H
  00082	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax
$LN1@CGChaosBox@2:

; 13064: 	}
; 13065: 
; 13066: 	g_MixSystem.ChaosBoxInit(lpObj);

  00088	56		 push	 esi
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0008e	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 13067: 	gObjInventoryCommit(lpObj->m_Index);

  00093	8b 16		 mov	 edx, DWORD PTR [esi]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0009b	83 c4 04	 add	 esp, 4

; 13068: 	lpObj->m_bIsCastleNPCUpgradeCompleted = false;

  0009e	c6 86 04 1c 00
	00 00		 mov	 BYTE PTR [esi+7172], 0
  000a5	5e		 pop	 esi
  000a6	5f		 pop	 edi

; 13069: }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
?CGChaosBoxUseEnd@@YAXH@Z ENDP				; CGChaosBoxUseEnd
_TEXT	ENDS
PUBLIC	??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@ ; `string'
PUBLIC	??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMove$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z		; PMoveProc
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjPositionCheck
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?CheckPlayStart@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckPlayStart
EXTRN	?GetCurrentState@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetCurrentState
EXTRN	?GetBridgeIndex@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeIndex
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A:BYTE	; gPandoraBoxEvent
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckXYMapTile
EXTRN	?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSearchActiveEffect
;	COMDAT ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@
CONST	SEGMENT
??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@ DB 'error'
	DB	'-L3 : Path Count error %d id:%s %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@
CONST	SEGMENT
??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@ DB 'error-L3 '
	DB	': move protocol index error %s %d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z
_TEXT	SEGMENT
_sx$ = -312						; size = 4
_sy$ = -308						; size = 4
tv963 = -304						; size = 4
_lpMove$GSCopy$ = -300					; size = 4
_i$249040 = -300					; size = 4
_pMove$ = -296						; size = 8
_n$ = -288						; size = 2
_ax$ = -284						; size = 2
_ay$ = -280						; size = 2
_aIndex$GSCopy$ = -276					; size = 4
_pActionResult$249088 = -272				; size = 9
_pActionResult$249079 = -272				; size = 9
_pActionResult$249052 = -272				; size = 9
_pActionResult$249016 = -272				; size = 9
_msg$248987 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMove$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z PROC			; PMoveProc, COMDAT

; 13083: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lpMove$[ebp]

; 13182: 		}
; 13183: 
; 13184: 		ax += RoadPathTable[pathtable*2];

  0001a	89 bd d4 fe ff
	ff		 mov	 DWORD PTR _lpMove$GSCopy$[ebp], edi
  00020	89 85 ec fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], eax
  00026	85 c0		 test	 eax, eax
  00028	78 0e		 js	 SHORT $LN88@PMoveProc

; 13084: 	if ( !OBJMAX_RANGE(aIndex))

  0002a	33 c9		 xor	 ecx, ecx
  0002c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00031	0f 9e c1	 setle	 cl
  00034	85 c9		 test	 ecx, ecx
  00036	75 27		 jne	 SHORT $LN65@PMoveProc
$LN88@PMoveProc:

; 13085: 	{
; 13086: 		LogAdd("error-L3 : move protocol index error %s %d", __FILE__, __LINE__);

  00038	68 1e 33 00 00	 push	 13086			; 0000331eH
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	5f		 pop	 edi

; 13500: }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN65@PMoveProc:

; 13087: 		return;
; 13088: 	}
; 13089: 
; 13090: 	PMSG_RECVMOVE pMove;
; 13091: 
; 13092: 	short n, pathtable;
; 13093: 	short ax, ay;
; 13094: 	int   sx, sy;
; 13095: 
; 13096: 	LPOBJ lpObj = &gObj[aIndex];

  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00065	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H

; 13097: 
; 13098: 	if ( lpObj->RegenOk > 0 )

  0006b	80 bc 08 a3 03
	00 00 00	 cmp	 BYTE PTR [eax+ecx+931], 0
  00073	56		 push	 esi
  00074	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00077	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv963[ebp], eax
  0007d	0f 8f d3 08 00
	00		 jg	 $LN106@PMoveProc

; 13099: 	{
; 13100: 		return;
; 13101: 	}
; 13102: 
; 13103: 
; 13104: 	if ( lpObj->SkillRecallParty_Time )

  00083	66 83 be 74 12
	00 00 00	 cmp	 WORD PTR [esi+4724], 0
  0008b	74 3a		 je	 SHORT $LN63@PMoveProc

; 13105: 	{
; 13106: 		lpObj->SkillRecallParty_Time = 0;

  0008d	33 d2		 xor	 edx, edx

; 13107: 		char msg[255];
; 13108: 		wsprintf(msg, lMsg.Get(MSGGET(4, 230)));

  0008f	68 e6 04 00 00	 push	 1254			; 000004e6H
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00099	66 89 96 74 12
	00 00		 mov	 WORD PTR [esi+4724], dx
  000a0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000a5	50		 push	 eax
  000a6	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$248987[ebp]
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 13109: 		GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  000b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b5	6a 01		 push	 1
  000b7	51		 push	 ecx
  000b8	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$248987[ebp]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c4	83 c4 14	 add	 esp, 20			; 00000014H
$LN63@PMoveProc:

; 13110: 	}
; 13111: 
; 13112: 	if ( (GetTickCount()-lpObj->m_LastMoveTime) < 100 )

  000c7	53		 push	 ebx
  000c8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  000ce	ff d3		 call	 ebx
  000d0	2b 86 68 03 00
	00		 sub	 eax, DWORD PTR [esi+872]
  000d6	83 f8 64	 cmp	 eax, 100		; 00000064H
  000d9	0f 82 76 08 00
	00		 jb	 $LN107@PMoveProc

; 13113: 	{
; 13114: 		return;
; 13115: 	}
; 13116: 
; 13117: 	if ( lpObj->Teleport )

  000df	80 be a0 03 00
	00 00		 cmp	 BYTE PTR [esi+928], 0
  000e6	0f 85 69 08 00
	00		 jne	 $LN107@PMoveProc

; 13118: 	{
; 13119: 		return;
; 13120: 	}
; 13121: 
; 13122: 	if(gObjSearchActiveEffect(lpObj, AT_ICE_ARROW) == 1 || gObjSearchActiveEffect(lpObj, AT_STUN) == 1 || gObjSearchActiveEffect(lpObj, AT_SLEEP) == 1) //Season 3.0 add-on

  000ec	6a 39		 push	 57			; 00000039H
  000ee	56		 push	 esi
  000ef	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  000f4	83 c4 08	 add	 esp, 8
  000f7	3c 01		 cmp	 al, 1
  000f9	0f 84 56 08 00
	00		 je	 $LN107@PMoveProc
  000ff	6a 3d		 push	 61			; 0000003dH
  00101	56		 push	 esi
  00102	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00107	83 c4 08	 add	 esp, 8
  0010a	3c 01		 cmp	 al, 1
  0010c	0f 84 43 08 00
	00		 je	 $LN107@PMoveProc
  00112	6a 48		 push	 72			; 00000048H
  00114	56		 push	 esi
  00115	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0011a	83 c4 08	 add	 esp, 8
  0011d	3c 01		 cmp	 al, 1
  0011f	0f 84 30 08 00
	00		 je	 $LN107@PMoveProc

; 13123: 	{
; 13124: 		return;
; 13125: 	}
; 13126: 
; 13127: 	lpObj->m_LastMoveTime = GetTickCount();

  00125	ff d3		 call	 ebx
  00127	89 86 68 03 00
	00		 mov	 DWORD PTR [esi+872], eax

; 13128: 
; 13129: 	lpObj->m_Rest = 0;

  0012d	c6 86 25 02 00
	00 00		 mov	 BYTE PTR [esi+549], 0

; 13130: 	lpObj->PathCur = 0;

  00134	c7 86 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+392], 0

; 13131: 
; 13132: 	lpObj->Dir = lpMove->Path[0] >> 4;

  0013e	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  00141	c0 e8 04	 shr	 al, 4
  00144	88 86 48 01 00
	00		 mov	 BYTE PTR [esi+328], al

; 13133: 	lpObj->PathCount = lpMove->Path[0] & 0x0F;

  0014a	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0014e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00151	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax

; 13134: 
; 13135: 	if ( lpObj->PathCount > 15 )

  00157	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0015a	7e 2e		 jle	 SHORT $LN58@PMoveProc

; 13136: 	{
; 13137: 		LogAdd("error-L3 : Path Count error %d id:%s %s %d", lpObj->PathCount, lpObj->AccountID, __FILE__, __LINE__);

  0015c	68 51 33 00 00	 push	 13137			; 00003351H
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00166	83 c6 6c	 add	 esi, 108		; 0000006cH
  00169	56		 push	 esi
  0016a	50		 push	 eax
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00176	83 c4 14	 add	 esp, 20			; 00000014H
  00179	5b		 pop	 ebx
  0017a	5e		 pop	 esi
  0017b	5f		 pop	 edi

; 13500: }

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017f	33 cd		 xor	 ecx, ebp
  00181	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
$LN58@PMoveProc:

; 13138: 		return;
; 13139: 	}
; 13140: 
; 13141: 	for ( n=0;n<15;n++)

  0018a	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0018f	8d 86 ca 01 00
	00		 lea	 eax, DWORD PTR [esi+458]
  00195	8d 59 f2	 lea	 ebx, DWORD PTR [ecx-14]
  00198	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL57@PMoveProc:

; 13142: 	{
; 13143: 		lpObj->PathX[n]=0;

  001a0	33 d2		 xor	 edx, edx
  001a2	66 89 50 e2	 mov	 WORD PTR [eax-30], dx

; 13144: 		lpObj->PathY[n]=0;

  001a6	66 89 10	 mov	 WORD PTR [eax], dx

; 13145: 		lpObj->PathOri[n]=0;

  001a9	66 89 50 c4	 mov	 WORD PTR [eax-60], dx
  001ad	83 c0 02	 add	 eax, 2
  001b0	2b cb		 sub	 ecx, ebx
  001b2	75 ec		 jne	 SHORT $LL57@PMoveProc

; 13146: 	}
; 13147: 
; 13148: 	sx = lpMove->X;

  001b4	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]

; 13149: 	sy = lpMove->Y;

  001b8	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]

; 13150: 
; 13151: 	if ( gObjCheckXYMapTile(lpObj, 1) == TRUE )

  001bc	53		 push	 ebx
  001bd	56		 push	 esi
  001be	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _sx$[ebp], eax
  001c4	89 8d cc fe ff
	ff		 mov	 DWORD PTR _sy$[ebp], ecx
  001ca	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  001cf	83 c4 08	 add	 esp, 8
  001d2	3b c3		 cmp	 eax, ebx
  001d4	75 40		 jne	 SHORT $LN54@PMoveProc

; 13152: 	{
; 13153: 		lpObj->PathCount = 0;
; 13154: 		lpObj->PathCur = 0;
; 13155: 		lpObj->PathStartEnd = 0;
; 13156: 		gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  001d6	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  001dd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001df	33 c0		 xor	 eax, eax
  001e1	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax
  001e7	89 86 88 01 00
	00		 mov	 DWORD PTR [esi+392], eax
  001ed	88 86 8c 01 00
	00		 mov	 BYTE PTR [esi+396], al
  001f3	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  001fa	52		 push	 edx
  001fb	50		 push	 eax
  001fc	51		 push	 ecx
  001fd	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  00202	83 c4 0c	 add	 esp, 12			; 0000000cH
  00205	5b		 pop	 ebx
  00206	5e		 pop	 esi
  00207	5f		 pop	 edi

; 13500: }

  00208	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020b	33 cd		 xor	 ecx, ebp
  0020d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
$LN54@PMoveProc:

; 13157: 		return;
; 13158: 	}
; 13159: 
; 13160: 	ax = lpObj->PathX[0] = lpMove->X;
; 13161: 	ay = lpObj->PathY[0] = lpMove->Y;
; 13162: 
; 13163: 	lpObj->PathDir[0] = lpObj->Dir;
; 13164: 
; 13165: 	lpObj->PathStartEnd = 1;
; 13166: 
; 13167: 	if ( lpObj->PathCount > 0 )

  00216	83 be 84 01 00
	00 00		 cmp	 DWORD PTR [esi+388], 0
  0021d	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00221	8a 8e 48 01 00
	00		 mov	 cl, BYTE PTR [esi+328]
  00227	8b d0		 mov	 edx, eax
  00229	66 89 86 ac 01
	00 00		 mov	 WORD PTR [esi+428], ax
  00230	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00234	89 95 e4 fe ff
	ff		 mov	 DWORD PTR _ax$[ebp], edx
  0023a	66 89 86 ca 01
	00 00		 mov	 WORD PTR [esi+458], ax
  00241	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _ay$[ebp], eax
  00247	88 8e e8 01 00
	00		 mov	 BYTE PTR [esi+488], cl
  0024d	88 9e 8c 01 00
	00		 mov	 BYTE PTR [esi+396], bl
  00253	7e 0c		 jle	 SHORT $LN53@PMoveProc

; 13168: 	{
; 13169: 		lpObj->PathCur = 1;
; 13170: 		lpObj->PathCount +=1;

  00255	01 9e 84 01 00
	00		 add	 DWORD PTR [esi+388], ebx
  0025b	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx
$LN53@PMoveProc:

; 13171: 	}
; 13172: 
; 13173: 	for (n=1;n<lpObj->PathCount;n++)

  00261	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], ebx
  00267	39 9e 84 01 00
	00		 cmp	 DWORD PTR [esi+388], ebx
  0026d	0f 8e ae 00 00
	00		 jle	 $LN94@PMoveProc
  00273	66 8b bd e4 fe
	ff ff		 mov	 di, WORD PTR _ax$[ebp]
  0027a	8b cb		 mov	 ecx, ebx
  0027c	66 8b 9d e8 fe
	ff ff		 mov	 bx, WORD PTR _ay$[ebp]
$LL91@PMoveProc:

; 13174: 	{
; 13175: 		if ( (n%2) == 1 )

  00283	8b d1		 mov	 edx, ecx
  00285	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  0028b	79 05		 jns	 SHORT $LN108@PMoveProc
  0028d	4a		 dec	 edx
  0028e	83 ca fe	 or	 edx, -2			; fffffffeH
  00291	42		 inc	 edx
$LN108@PMoveProc:

; 13176: 		{
; 13177: 			pathtable = lpMove->Path[(n+1) / 2] >> 4;

  00292	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00295	83 fa 01	 cmp	 edx, 1
  00298	99		 cdq
  00299	75 13		 jne	 SHORT $LN49@PMoveProc
  0029b	2b c2		 sub	 eax, edx
  0029d	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMove$GSCopy$[ebp]
  002a3	d1 f8		 sar	 eax, 1
  002a5	8a 44 10 05	 mov	 al, BYTE PTR [eax+edx+5]
  002a9	c0 e8 04	 shr	 al, 4

; 13178: 		}
; 13179: 		else

  002ac	eb 10		 jmp	 SHORT $LN109@PMoveProc
$LN49@PMoveProc:

; 13180: 		{
; 13181: 			pathtable = lpMove->Path[(n+1) / 2] & 0x0F;

  002ae	2b c2		 sub	 eax, edx
  002b0	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMove$GSCopy$[ebp]
  002b6	d1 f8		 sar	 eax, 1
  002b8	8a 44 10 05	 mov	 al, BYTE PTR [eax+edx+5]
  002bc	24 0f		 and	 al, 15			; 0000000fH
$LN109@PMoveProc:
  002be	0f b6 d0	 movzx	 edx, al

; 13182: 		}
; 13183: 
; 13184: 		ax += RoadPathTable[pathtable*2];

  002c1	0f bf c2	 movsx	 eax, dx
  002c4	03 c0		 add	 eax, eax
  002c6	66 03 bc 00 00
	00 00 00	 add	 di, WORD PTR ?RoadPathTable@@3PAFA[eax+eax]

; 13185: 		ay += RoadPathTable[pathtable*2+1];

  002ce	66 03 9c 00 02
	00 00 00	 add	 bx, WORD PTR ?RoadPathTable@@3PAFA[eax+eax+2]
  002d6	03 c0		 add	 eax, eax
  002d8	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]

; 13186: 		
; 13187: 		lpObj->PathOri[n-1] = pathtable;

  002de	66 89 94 4e 8c
	01 00 00	 mov	 WORD PTR [esi+ecx*2+396], dx

; 13188: 		lpObj->PathDir[n]= pathtable;

  002e6	88 94 31 e8 01
	00 00		 mov	 BYTE PTR [ecx+esi+488], dl
  002ed	40		 inc	 eax

; 13189: 		lpObj->PathX[n] = ax;

  002ee	66 89 bc 4e ac
	01 00 00	 mov	 WORD PTR [esi+ecx*2+428], di

; 13190: 		lpObj->PathY[n] = ay;

  002f6	66 89 9c 4e ca
	01 00 00	 mov	 WORD PTR [esi+ecx*2+458], bx
  002fe	0f bf c8	 movsx	 ecx, ax
  00301	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  00307	3b 8e 84 01 00
	00		 cmp	 ecx, DWORD PTR [esi+388]
  0030d	0f 8c 70 ff ff
	ff		 jl	 $LL91@PMoveProc

; 13182: 		}
; 13183: 
; 13184: 		ax += RoadPathTable[pathtable*2];

  00313	66 89 9d e8 fe
	ff ff		 mov	 WORD PTR _ay$[ebp], bx
  0031a	66 89 bd e4 fe
	ff ff		 mov	 WORD PTR _ax$[ebp], di
$LN94@PMoveProc:

; 13171: 	}
; 13172: 
; 13173: 	for (n=1;n<lpObj->PathCount;n++)

  00321	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  00327	33 ff		 xor	 edi, edi

; 13191: 	}
; 13192: 
; 13193: 	if ( lpObj->PathCount > 0 )

  00329	39 be 84 01 00
	00		 cmp	 DWORD PTR [esi+388], edi
  0032f	0f 8e 1c 01 00
	00		 jle	 $LN93@PMoveProc

; 13194: 	{
; 13195: 		int nextX;
; 13196: 		int nextY;
; 13197: 		BYTE mapnumber;
; 13198: 		BYTE attr;
; 13199: 		nextX = lpObj->PathX[1];
; 13200: 		nextY = lpObj->PathY[1];

  00335	0f bf 8e cc 01
	00 00		 movsx	 ecx, WORD PTR [esi+460]
  0033c	0f bf 86 ae 01
	00 00		 movsx	 eax, WORD PTR [esi+430]

; 13201: 		mapnumber = lpObj->MapNumber;
; 13202: 
; 13203: 		if ( lpObj->PathCount > 0 ) //HermeX Add-on for fixing registers
; 13204: 		{
; 13205: 			//logadd
; 13206: 		}
; 13207: 
; 13208: 		attr = MapC[mapnumber].GetAttr(nextX, nextY);

  00343	51		 push	 ecx
  00344	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  0034b	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00351	50		 push	 eax
  00352	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00358	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 13209: 
; 13210: #ifdef PANDORA_EVENT
; 13211: 		if (g_ZtLicense.user.PandoraEvent)

  0035d	80 3d d9 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+217, 0
  00364	0f 84 83 00 00
	00		 je	 $LN92@PMoveProc

; 13212: 		{
; 13213: 			if ( gObj[aIndex].Type == OBJ_USER )

  0036a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00370	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv963[ebp]
  00376	66 83 7c 0a 68
	01		 cmp	 WORD PTR [edx+ecx+104], 1
  0037c	75 6f		 jne	 SHORT $LN92@PMoveProc

; 13214: 			{
; 13215: 				if (( (attr&1) == 1 ) && (aIndex == gPandoraBoxEvent.ActivePlayer))

  0037e	a8 01		 test	 al, 1
  00380	74 6b		 je	 SHORT $LN92@PMoveProc
  00382	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?gPandoraBoxEvent@@3VcPandoraBoxEvent@@A
  00388	75 63		 jne	 SHORT $LN92@PMoveProc

; 13216: 				{
; 13217: 					for ( n=0 ; n<15 ; n++)

  0038a	8d 86 ca 01 00
	00		 lea	 eax, DWORD PTR [esi+458]
  00390	8d 4f 0f	 lea	 ecx, DWORD PTR [edi+15]
$LL42@PMoveProc:

; 13218: 					{
; 13219: 						lpObj->PathX[n] = 0;

  00393	33 d2		 xor	 edx, edx
  00395	66 89 50 e2	 mov	 WORD PTR [eax-30], dx

; 13220: 						lpObj->PathY[n] = 0;

  00399	66 89 10	 mov	 WORD PTR [eax], dx

; 13221: 						lpObj->PathOri[n] = 0;

  0039c	66 89 50 c4	 mov	 WORD PTR [eax-60], dx
  003a0	83 c0 02	 add	 eax, 2
  003a3	49		 dec	 ecx
  003a4	75 ed		 jne	 SHORT $LL42@PMoveProc

; 13222: 					}
; 13223: 
; 13224: 					lpObj->PathCount = 0;
; 13225: 					lpObj->PathCur = 0;
; 13226: 					lpObj->PathStartEnd = 0;
; 13227: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  003a6	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  003ad	0f bf 8e 44 01
	00 00		 movsx	 ecx, WORD PTR [esi+324]
  003b4	50		 push	 eax
  003b5	88 96 8c 01 00
	00		 mov	 BYTE PTR [esi+396], dl
  003bb	8b 16		 mov	 edx, DWORD PTR [esi]
  003bd	51		 push	 ecx
  003be	52		 push	 edx
  003bf	89 be 84 01 00
	00		 mov	 DWORD PTR [esi+388], edi
  003c5	89 be 88 01 00
	00		 mov	 DWORD PTR [esi+392], edi
  003cb	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 13228: 			
; 13229: 					PMSG_ACTIONRESULT pActionResult;
; 13230: 
; 13231: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  003d0	6a 09		 push	 9
  003d2	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$249016[ebp]
  003d8	6a 18		 push	 24			; 00000018H
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13232: 					pActionResult.NumberH = SET_NUMBERH(aIndex);

  003e0	8b cb		 mov	 ecx, ebx

; 13233: 					pActionResult.NumberL = SET_NUMBERL(aIndex);

  003e2	88 9d f4 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249016[ebp+4], bl

; 13234: 					pActionResult.ActionNumber = 0x7A;
; 13235: 					pActionResult.Dir = lpObj->Dir;
; 13236: 					pActionResult.TargetNumberH = 0;
; 13237: 					pActionResult.TargetNumberL = 0;
; 13238: 
; 13239: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 13240: 			
; 13241: 					return;

  003e8	e9 fb 02 00 00	 jmp	 $LN116@PMoveProc
$LN92@PMoveProc:

; 13242: 				}
; 13243: 			}
; 13244: 		}
; 13245: #endif
; 13246: 		if ( ((attr & (BYTE)4) == (BYTE)4) || ((attr & (BYTE)8) == (BYTE)8))

  003ed	a8 0c		 test	 al, 12			; 0000000cH
  003ef	74 60		 je	 SHORT $LN93@PMoveProc

; 13247: 		{
; 13248: 			for ( n=0 ; n<15 ; n++)

  003f1	8d 86 ca 01 00
	00		 lea	 eax, DWORD PTR [esi+458]
  003f7	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  003fc	8d 64 24 00	 npad	 4
$LL37@PMoveProc:

; 13249: 			{
; 13250: 				lpObj->PathX[n] = 0;

  00400	33 d2		 xor	 edx, edx
  00402	66 89 50 e2	 mov	 WORD PTR [eax-30], dx

; 13251: 				lpObj->PathY[n] = 0;

  00406	66 89 10	 mov	 WORD PTR [eax], dx

; 13252: 				lpObj->PathOri[n] = 0;

  00409	66 89 50 c4	 mov	 WORD PTR [eax-60], dx
  0040d	83 c0 02	 add	 eax, 2
  00410	49		 dec	 ecx
  00411	75 ed		 jne	 SHORT $LL37@PMoveProc

; 13253: 			}
; 13254: 
; 13255: 			lpObj->PathCount = 0;
; 13256: 			lpObj->PathCur = 0;
; 13257: 			lpObj->PathStartEnd = 0;
; 13258: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  00413	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  0041a	0f bf 8e 44 01
	00 00		 movsx	 ecx, WORD PTR [esi+324]
  00421	50		 push	 eax
  00422	88 96 8c 01 00
	00		 mov	 BYTE PTR [esi+396], dl
  00428	8b 16		 mov	 edx, DWORD PTR [esi]
  0042a	51		 push	 ecx
  0042b	52		 push	 edx
  0042c	89 be 84 01 00
	00		 mov	 DWORD PTR [esi+388], edi
  00432	89 be 88 01 00
	00		 mov	 DWORD PTR [esi+392], edi
  00438	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  0043d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00440	5b		 pop	 ebx
  00441	5e		 pop	 esi
  00442	5f		 pop	 edi

; 13500: }

  00443	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00446	33 cd		 xor	 ecx, ebp
  00448	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0044d	8b e5		 mov	 esp, ebp
  0044f	5d		 pop	 ebp
  00450	c3		 ret	 0
$LN93@PMoveProc:

; 13259: 			
; 13260: 			return;
; 13261: 		}
; 13262: 	}
; 13263: 
; 13264: 	lpObj->TX = (BYTE)ax;
; 13265: 	lpObj->TY = (BYTE)ay;
; 13266: 
; 13267: 	if( lpObj->Type == OBJ_USER && lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )

  00451	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00456	0f b6 85 e4 fe
	ff ff		 movzx	 eax, BYTE PTR _ax$[ebp]
  0045d	0f b6 8d e8 fe
	ff ff		 movzx	 ecx, BYTE PTR _ay$[ebp]
  00464	66 89 86 7c 01
	00 00		 mov	 WORD PTR [esi+380], ax
  0046b	66 89 8e 7e 01
	00 00		 mov	 WORD PTR [esi+382], cx
  00472	0f 85 92 00 00
	00		 jne	 $LN23@PMoveProc
  00478	80 be 49 01 00
	00 1e		 cmp	 BYTE PTR [esi+329], 30	; 0000001eH
  0047f	0f 85 85 00 00
	00		 jne	 $LN23@PMoveProc

; 13268: 	{
; 13269: 		int nextX = lpObj->X;

  00485	0f bf 9e 44 01
	00 00		 movsx	 ebx, WORD PTR [esi+324]

; 13270: 		int nextY = lpObj->Y;

  0048c	0f bf be 46 01
	00 00		 movsx	 edi, WORD PTR [esi+326]

; 13271: 		int iResult = 0; //should be BOOL
; 13272: 		WORD attr = 0;
; 13273: 		
; 13274: 		for(int i = 0; i < 256;i++)

  00493	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$249040[ebp], 0
  0049d	8d 49 00	 npad	 3
$LL33@PMoveProc:

; 13275: 		{	
; 13276: 			if(nextX > lpObj->TX)

  004a0	0f bf 86 7c 01
	00 00		 movsx	 eax, WORD PTR [esi+380]
  004a7	3b d8		 cmp	 ebx, eax
  004a9	7e 03		 jle	 SHORT $LN110@PMoveProc

; 13277: 			{
; 13278: 				nextX -= 1;

  004ab	4b		 dec	 ebx

; 13279: 			}
; 13280: 
; 13281: 			if(nextX < lpObj->TX)

  004ac	3b d8		 cmp	 ebx, eax
$LN110@PMoveProc:
  004ae	7d 01		 jge	 SHORT $LN104@PMoveProc

; 13282: 			{
; 13283: 				nextX += 1;

  004b0	43		 inc	 ebx
$LN104@PMoveProc:

; 13284: 			}
; 13285: 
; 13286: 			if(nextY > lpObj->TY)

  004b1	0f bf 86 7e 01
	00 00		 movsx	 eax, WORD PTR [esi+382]
  004b8	3b f8		 cmp	 edi, eax
  004ba	7e 03		 jle	 SHORT $LN111@PMoveProc

; 13287: 			{
; 13288: 				nextY -= 1;

  004bc	4f		 dec	 edi

; 13289: 			}
; 13290: 
; 13291: 			if(nextY < lpObj->TY)

  004bd	3b f8		 cmp	 edi, eax
$LN111@PMoveProc:
  004bf	7d 01		 jge	 SHORT $LN27@PMoveProc

; 13292: 			{
; 13293: 				nextY += 1;

  004c1	47		 inc	 edi
$LN27@PMoveProc:

; 13294: 			}
; 13295: 
; 13296: 			attr = MapC[lpObj->MapNumber].GetAttr(nextX,nextY);
; 13297: 
; 13298: 			if ((attr&16) == 16 )

  004c2	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  004c9	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  004cf	57		 push	 edi
  004d0	53		 push	 ebx
  004d1	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  004d7	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  004dc	a8 10		 test	 al, 16			; 00000010H
  004de	75 5b		 jne	 SHORT $LN80@PMoveProc

; 13299: 			{
; 13300: 				iResult = 1;
; 13301: 				break;
; 13302: 			}
; 13303: 
; 13304: 			if( nextX == lpObj->TX)

  004e0	0f bf 96 7c 01
	00 00		 movsx	 edx, WORD PTR [esi+380]
  004e7	3b da		 cmp	 ebx, edx
  004e9	75 0b		 jne	 SHORT $LN32@PMoveProc

; 13305: 			{
; 13306: 				if(nextY == lpObj->TY)

  004eb	0f bf 86 7e 01
	00 00		 movsx	 eax, WORD PTR [esi+382]
  004f2	3b f8		 cmp	 edi, eax
  004f4	74 14		 je	 SHORT $LN23@PMoveProc
$LN32@PMoveProc:

; 13271: 		int iResult = 0; //should be BOOL
; 13272: 		WORD attr = 0;
; 13273: 		
; 13274: 		for(int i = 0; i < 256;i++)

  004f6	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _i$249040[ebp]
  004fc	40		 inc	 eax
  004fd	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _i$249040[ebp], eax
  00503	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00508	7c 96		 jl	 SHORT $LL33@PMoveProc
$LN23@PMoveProc:

; 13334: 		}
; 13335: 	}
; 13336: 
; 13337: 	if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Type == OBJ_USER )

  0050a	8a 8e 49 01 00
	00		 mov	 cl, BYTE PTR [esi+329]
  00510	80 f9 34	 cmp	 cl, 52			; 00000034H
  00513	0f 84 99 00 00
	00		 je	 $LN96@PMoveProc
  00519	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0051c	0f 82 1e 02 00
	00		 jb	 $LN97@PMoveProc
  00522	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00527	3a c1		 cmp	 al, cl
  00529	1b c0		 sbb	 eax, eax
  0052b	40		 inc	 eax
  0052c	33 db		 xor	 ebx, ebx
  0052e	3b c3		 cmp	 eax, ebx
  00530	0f 84 0a 02 00
	00		 je	 $LN97@PMoveProc
  00536	e9 79 00 00 00	 jmp	 $LN90@PMoveProc
$LN80@PMoveProc:

; 13307: 				{
; 13308: 					break;
; 13309: 				}
; 13310: 			}
; 13311: 		}
; 13312: 
; 13313: 		if(iResult == 1)
; 13314: 		{
; 13315: 			lpObj->m_Rest = 1;
; 13316: 			lpObj->PathCur = 0;
; 13317: 			lpObj->PathCount = 0;
; 13318: 			lpObj->PathStartEnd = 0;
; 13319: 
; 13320: 			gObjSetPosition(lpObj->m_Index,lpObj->X,lpObj->Y);

  0053b	0f bf 8e 46 01
	00 00		 movsx	 ecx, WORD PTR [esi+326]
  00542	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  00549	33 c0		 xor	 eax, eax
  0054b	51		 push	 ecx
  0054c	89 86 88 01 00
	00		 mov	 DWORD PTR [esi+392], eax
  00552	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax
  00558	88 86 8c 01 00
	00		 mov	 BYTE PTR [esi+396], al
  0055e	8b 06		 mov	 eax, DWORD PTR [esi]
  00560	52		 push	 edx
  00561	50		 push	 eax
  00562	c6 86 25 02 00
	00 01		 mov	 BYTE PTR [esi+549], 1
  00569	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 13321: 			
; 13322: 			PMSG_ACTIONRESULT pActionResult;
; 13323: 
; 13324: 			PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  0056e	6a 09		 push	 9
  00570	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pActionResult$249052[ebp]
  00576	6a 18		 push	 24			; 00000018H
  00578	51		 push	 ecx
  00579	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13325: 			pActionResult.NumberH = SET_NUMBERH(aIndex);

  0057e	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00584	8b d0		 mov	 edx, eax
  00586	c1 ea 08	 shr	 edx, 8

; 13326: 			pActionResult.NumberL = SET_NUMBERL(aIndex);
; 13327: 			pActionResult.ActionNumber = 0x7A;
; 13328: 			pActionResult.Dir = lpObj->Dir;
; 13329: 			pActionResult.TargetNumberH = 0;
; 13330: 			pActionResult.TargetNumberL = 0;
; 13331: 
; 13332: 			DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));

  00589	6a 09		 push	 9
  0058b	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pActionResult$249052[ebp]
  00591	88 95 f3 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249052[ebp+3], dl
  00597	8b 16		 mov	 edx, DWORD PTR [esi]
  00599	88 85 f4 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249052[ebp+4], al
  0059f	8a 86 48 01 00
	00		 mov	 al, BYTE PTR [esi+328]
  005a5	51		 push	 ecx
  005a6	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249052[ebp+5], al
  005ac	52		 push	 edx

; 13333: 			return;	

  005ad	e9 57 01 00 00	 jmp	 $LN117@PMoveProc
$LN96@PMoveProc:

; 13334: 		}
; 13335: 	}
; 13336: 
; 13337: 	if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Type == OBJ_USER )

  005b2	33 db		 xor	 ebx, ebx
$LN90@PMoveProc:
  005b4	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  005b9	0f 85 81 01 00
	00		 jne	 $LN97@PMoveProc

; 13338: 	{
; 13339: 		int iBridgeIndex = g_BloodCastle.GetBridgeIndex(lpObj->MapNumber);

  005bf	0f b6 c9	 movzx	 ecx, cl
  005c2	51		 push	 ecx
  005c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  005c8	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  005cd	8b f8		 mov	 edi, eax

; 13340: 
; 13341: 		switch ( g_BloodCastle.GetCurrentState(iBridgeIndex) )

  005cf	57		 push	 edi
  005d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  005d5	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  005da	48		 dec	 eax
  005db	0f 84 51 01 00
	00		 je	 $LN19@PMoveProc
  005e1	48		 dec	 eax
  005e2	0f 85 58 01 00
	00		 jne	 $LN97@PMoveProc

; 13364: 				}
; 13365: 				break;
; 13366: 			case 0x02:
; 13367: 				if ( lpObj->Y > 17 && g_BloodCastle.CheckPlayStart(iBridgeIndex) == false)

  005e8	66 83 be 46 01
	00 00 11	 cmp	 WORD PTR [esi+326], 17	; 00000011H
  005f0	7e 2f		 jle	 SHORT $LN16@PMoveProc
  005f2	57		 push	 edi
  005f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  005f8	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  005fd	84 c0		 test	 al, al
  005ff	75 20		 jne	 SHORT $LN16@PMoveProc

; 13368: 				{
; 13369: 					gObjMoveGate(lpObj->m_Index, iBridgeIndex+66);

  00601	8b 16		 mov	 edx, DWORD PTR [esi]
  00603	83 c7 42	 add	 edi, 66			; 00000042H
  00606	57		 push	 edi
  00607	52		 push	 edx
  00608	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0060d	83 c4 08	 add	 esp, 8
  00610	5b		 pop	 ebx
  00611	5e		 pop	 esi
  00612	5f		 pop	 edi

; 13500: }

  00613	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00616	33 cd		 xor	 ecx, ebp
  00618	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061d	8b e5		 mov	 esp, ebp
  0061f	5d		 pop	 ebp
  00620	c3		 ret	 0
$LN16@PMoveProc:

; 13370: 					return;
; 13371: 				}
; 13372: 
; 13373: 				if ( lpObj->TY > 15 && g_BloodCastle.CheckPlayStart(iBridgeIndex) == false )

  00621	66 83 be 7e 01
	00 00 0f	 cmp	 WORD PTR [esi+382], 15	; 0000000fH
  00629	7e 4d		 jle	 SHORT $LN15@PMoveProc
  0062b	57		 push	 edi
  0062c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00631	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  00636	84 c0		 test	 al, al
  00638	75 3e		 jne	 SHORT $LN15@PMoveProc

; 13374: 				{
; 13375: 					lpObj->m_Rest = 1;
; 13376: 					lpObj->PathCur = 0;
; 13377: 					lpObj->PathCount = 0;
; 13378: 					lpObj->PathStartEnd = 0;
; 13379: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0063a	0f bf 8e 44 01
	00 00		 movsx	 ecx, WORD PTR [esi+324]
  00641	8b 16		 mov	 edx, DWORD PTR [esi]
  00643	88 86 8c 01 00
	00		 mov	 BYTE PTR [esi+396], al
  00649	0f bf 86 46 01
	00 00		 movsx	 eax, WORD PTR [esi+326]
  00650	50		 push	 eax
  00651	51		 push	 ecx
  00652	52		 push	 edx
  00653	c6 86 25 02 00
	00 01		 mov	 BYTE PTR [esi+549], 1
  0065a	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx
  00660	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx
  00666	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 13380: 
; 13381: 					PMSG_ACTIONRESULT pActionResult;
; 13382: 
; 13383: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  0066b	6a 09		 push	 9
  0066d	6a 18		 push	 24			; 00000018H
  0066f	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$249079[ebp]
  00675	50		 push	 eax

; 13384: 					pActionResult.NumberH = SET_NUMBERH(aIndex);
; 13385: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 13386: 					pActionResult.ActionNumber = 0x7A;
; 13387: 					pActionResult.Dir = lpObj->Dir;
; 13388: 					pActionResult.TargetNumberH = 0;
; 13389: 					pActionResult.TargetNumberL = 0;
; 13390: 
; 13391: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 13392: 					return;

  00676	eb 5d		 jmp	 SHORT $LN113@PMoveProc
$LN15@PMoveProc:

; 13393: 				}
; 13394: 
; 13395: 				if ( lpObj->TY > 76 &&  g_BloodCastle.m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE )

  00678	66 83 be 7e 01
	00 00 4c	 cmp	 WORD PTR [esi+382], 76	; 0000004cH
  00680	0f 8e ba 00 00
	00		 jle	 $LN97@PMoveProc
  00686	69 ff 60 04 00
	00		 imul	 edi, 1120		; 00000460H
  0068c	39 9f a4 03 00
	00		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edi+932], ebx
  00692	0f 84 a8 00 00
	00		 je	 $LN97@PMoveProc
$LN112@PMoveProc:

; 13396: 				{
; 13397: 					lpObj->m_Rest = 1;
; 13398: 					lpObj->PathCur = 0;
; 13399: 					lpObj->PathCount = 0;
; 13400: 					lpObj->PathStartEnd = 0;
; 13401: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  00698	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  0069f	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  006a6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006a8	52		 push	 edx
  006a9	50		 push	 eax
  006aa	51		 push	 ecx
  006ab	c6 86 25 02 00
	00 01		 mov	 BYTE PTR [esi+549], 1
  006b2	89 9e 88 01 00
	00		 mov	 DWORD PTR [esi+392], ebx
  006b8	89 9e 84 01 00
	00		 mov	 DWORD PTR [esi+388], ebx
  006be	c6 86 8c 01 00
	00 00		 mov	 BYTE PTR [esi+396], 0
  006c5	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 13402: 
; 13403: 					PMSG_ACTIONRESULT pActionResult;
; 13404: 
; 13405: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  006ca	6a 09		 push	 9
  006cc	6a 18		 push	 24			; 00000018H
  006ce	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _pActionResult$249088[ebp]
  006d4	52		 push	 edx
$LN113@PMoveProc:
  006d5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13406: 					pActionResult.NumberH = SET_NUMBERH(aIndex);

  006da	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  006e0	8b c8		 mov	 ecx, eax

; 13407: 					pActionResult.NumberL = SET_NUMBERL(aIndex);

  006e2	88 85 f4 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249088[ebp+4], al
$LN116@PMoveProc:

; 13409: 					pActionResult.Dir = lpObj->Dir;

  006e8	8a 96 48 01 00
	00		 mov	 dl, BYTE PTR [esi+328]
  006ee	c1 e9 08	 shr	 ecx, 8

; 13410: 					pActionResult.TargetNumberH = 0;
; 13411: 					pActionResult.TargetNumberL = 0;
; 13412: 
; 13413: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));

  006f1	6a 09		 push	 9
  006f3	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$249088[ebp]
  006f9	88 8d f3 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249088[ebp+3], cl
  006ff	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00701	50		 push	 eax
  00702	88 95 f5 fe ff
	ff		 mov	 BYTE PTR _pActionResult$249088[ebp+5], dl
  00708	51		 push	 ecx
$LN117@PMoveProc:

; 13408: 					pActionResult.ActionNumber = 0x7A;

  00709	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _pActionResult$249088[ebp+8], 0
  00710	66 c7 85 f6 fe
	ff ff 7a 00	 mov	 WORD PTR _pActionResult$249088[ebp+6], 122 ; 0000007aH

; 13410: 					pActionResult.TargetNumberH = 0;
; 13411: 					pActionResult.TargetNumberL = 0;
; 13412: 
; 13413: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));

  00719	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0071e	83 c4 24	 add	 esp, 36			; 00000024H
  00721	5b		 pop	 ebx
  00722	5e		 pop	 esi
  00723	5f		 pop	 edi

; 13500: }

  00724	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00727	33 cd		 xor	 ecx, ebp
  00729	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072e	8b e5		 mov	 esp, ebp
  00730	5d		 pop	 ebp
  00731	c3		 ret	 0
$LN19@PMoveProc:

; 13342: 		{
; 13343: 			case 0x01:
; 13344: 				if ( lpObj->TY > 15 )

  00732	66 83 be 7e 01
	00 00 0f	 cmp	 WORD PTR [esi+382], 15	; 0000000fH

; 13345: 				{
; 13346: 					lpObj->m_Rest = 1;
; 13347: 					lpObj->PathCur = 0;
; 13348: 					lpObj->PathCount = 0;
; 13349: 					lpObj->PathStartEnd = 0;
; 13350: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 13351: 
; 13352: 					PMSG_ACTIONRESULT pActionResult;
; 13353: 
; 13354: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 13355: 					pActionResult.NumberH = SET_NUMBERH(aIndex);
; 13356: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 13357: 					pActionResult.ActionNumber = 0x7A;
; 13358: 					pActionResult.Dir = lpObj->Dir;
; 13359: 					pActionResult.TargetNumberH = 0;
; 13360: 					pActionResult.TargetNumberL = 0;
; 13361: 
; 13362: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 13363: 					return;

  0073a	0f 8f 58 ff ff
	ff		 jg	 $LN112@PMoveProc
$LN97@PMoveProc:

; 13414: 					return;
; 13415: 				}
; 13416: 				break;
; 13417: 		}
; 13418: 	}
; 13419: 
; 13420: 	PHeadSetB((LPBYTE)&pMove, PROTOCOL_MOVE , sizeof(pMove));

  00740	6a 08		 push	 8
  00742	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _pMove$[ebp]
  00748	68 d4 00 00 00	 push	 212			; 000000d4H
  0074d	52		 push	 edx
  0074e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13421: 	pMove.NumberH = SET_NUMBERH(aIndex);

  00753	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]

; 13422: 	pMove.NumberL = SET_NUMBERL(aIndex);
; 13423: 	pMove.X				= (BYTE)ax;

  00759	8a 8d e4 fe ff
	ff		 mov	 cl, BYTE PTR _ax$[ebp]

; 13424: 	pMove.Y				= (BYTE)ay;

  0075f	8a 95 e8 fe ff
	ff		 mov	 dl, BYTE PTR _ay$[ebp]
  00765	8b c3		 mov	 eax, ebx
  00767	c1 e8 08	 shr	 eax, 8
  0076a	88 85 db fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+3], al
  00770	88 9d dc fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+4], bl
  00776	88 8d dd fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+5], cl
  0077c	88 95 de fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+6], dl

; 13425: 	pMove.Path = lpObj->Dir << 4;

  00782	8a 86 48 01 00
	00		 mov	 al, BYTE PTR [esi+328]
  00788	c0 e0 04	 shl	 al, 4
  0078b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0078e	88 85 df fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+7], al

; 13426: 
; 13427: 	if ( lpObj->Type == OBJ_USER )

  00794	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00799	0f 85 9a 00 00
	00		 jne	 $LN101@PMoveProc

; 13428: 	{
; 13429: 		if ( lpObj->m_IfState.use )

  0079f	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  007a5	a8 03		 test	 al, 3
  007a7	74 25		 je	 SHORT $LN11@PMoveProc

; 13430: 		{
; 13431: 			if ( lpObj->m_IfState.type == 3 )

  007a9	8b c8		 mov	 ecx, eax
  007ab	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  007b1	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  007b7	75 15		 jne	 SHORT $LN11@PMoveProc

; 13432: 			{
; 13433: 				lpObj->TargetShopNumber = -1;

  007b9	83 ca ff	 or	 edx, -1

; 13434: 				lpObj->m_IfState.type = 0;
; 13435: 				lpObj->m_IfState.use = 0;

  007bc	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  007c1	66 89 96 5a 04
	00 00		 mov	 WORD PTR [esi+1114], dx
  007c8	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax
$LN11@PMoveProc:

; 13436: 			}
; 13437: 		}
; 13438: 
; 13439: 		if ( !gObjPositionCheck(lpObj))

  007ce	56		 push	 esi
  007cf	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjPositionCheck
  007d4	83 c4 04	 add	 esp, 4
  007d7	85 c0		 test	 eax, eax
  007d9	75 46		 jne	 SHORT $LN100@PMoveProc

; 13440: 		{
; 13441: 			lpObj->PathCur = 0;
; 13442: 			lpObj->PathCount = 0;
; 13443: 			ax = lpObj->X;
; 13444: 			ay = lpObj->Y;

  007db	0f b7 8e 46 01
	00 00		 movzx	 ecx, WORD PTR [esi+326]
  007e2	89 86 88 01 00
	00		 mov	 DWORD PTR [esi+392], eax
  007e8	89 86 84 01 00
	00		 mov	 DWORD PTR [esi+388], eax
  007ee	0f b7 86 44 01
	00 00		 movzx	 eax, WORD PTR [esi+324]

; 13445: 			lpObj->TX = (BYTE)ax;

  007f5	0f b6 d0	 movzx	 edx, al
  007f8	66 89 96 7c 01
	00 00		 mov	 WORD PTR [esi+380], dx

; 13446: 			lpObj->TY = (BYTE)ay;

  007ff	0f b6 d1	 movzx	 edx, cl
  00802	66 89 96 7e 01
	00 00		 mov	 WORD PTR [esi+382], dx
  00809	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _ax$[ebp], eax
  0080f	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _ay$[ebp], ecx

; 13447: 			pMove.X			= (BYTE)ax;

  00815	88 85 dd fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+5], al

; 13448: 			pMove.Y	  		= (BYTE)ay;

  0081b	88 8d de fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+6], cl
$LN100@PMoveProc:

; 13449: 		}
; 13450: 
; 13451: 		#if(ENABLE_CAMERA_PARTY)
; 13452: 		//g_CameraParty.Move(aIndex);
; 13453: 		#endif
; 13454: 
; 13455: 		DataSend(aIndex, (LPBYTE)&pMove, pMove.h.size);

  00821	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00828	50		 push	 eax
  00829	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMove$[ebp]
  0082f	51		 push	 ecx
  00830	53		 push	 ebx
  00831	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00836	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN101@PMoveProc:

; 13456: 	}
; 13457: 
; 13458: 	int MVL = MAX_VIEWPORT;
; 13459: 
; 13460: 	if ( lpObj->Type == OBJ_MONSTER )
; 13461: 	{
; 13462: 		MVL = MAX_VIEWPORT_MONSTER;
; 13463: 	}
; 13464: 		
; 13465: 	for (n=0;n<MVL;n++)

  00839	33 c0		 xor	 eax, eax
  0083b	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LL8@PMoveProc:

; 13466: 	{
; 13467: 		if ( lpObj->VpPlayer2[n].state == TRUE )

  00841	8d 94 40 2b 02
	00 00		 lea	 edx, DWORD PTR [eax+eax*2+555]
  00848	80 3c 96 01	 cmp	 BYTE PTR [esi+edx*4], 1
  0084c	8d 3c 96	 lea	 edi, DWORD PTR [esi+edx*4]
  0084f	75 5e		 jne	 SHORT $LN7@PMoveProc

; 13468: 		{
; 13469: 			int number = lpObj->VpPlayer2[n].number;

  00851	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00854	8d 8c 86 ae 08
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+2222]
  0085b	0f bf 01	 movsx	 eax, WORD PTR [ecx]

; 13470: 			
; 13471: 			if ( number >= 0 )

  0085e	85 c0		 test	 eax, eax
  00860	78 4d		 js	 SHORT $LN7@PMoveProc

; 13472: 			{
; 13473: 				if ( gObj[number].Connected > PLAYER_CONNECTED && gObj[number].Live != false)

  00862	8b d0		 mov	 edx, eax
  00864	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0086a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00870	bb 01 00 00 00	 mov	 ebx, 1
  00875	39 5a 04	 cmp	 DWORD PTR [edx+4], ebx
  00878	7e 26		 jle	 SHORT $LN3@PMoveProc
  0087a	80 7a 6a 00	 cmp	 BYTE PTR [edx+106], 0
  0087e	74 20		 je	 SHORT $LN3@PMoveProc

; 13474: 				{
; 13475: 					if(gObj[number].Type == OBJ_USER)

  00880	66 39 5a 68	 cmp	 WORD PTR [edx+104], bx
  00884	75 29		 jne	 SHORT $LN7@PMoveProc

; 13476: 					{
; 13477: 						DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pMove, pMove.h.size);

  00886	0f b6 8d d9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pMove$[ebp+1]
  0088d	51		 push	 ecx
  0088e	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _pMove$[ebp]
  00894	52		 push	 edx
  00895	50		 push	 eax
  00896	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0089b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13478: 					}
; 13479: 				}
; 13480: 				else

  0089e	eb 0f		 jmp	 SHORT $LN7@PMoveProc
$LN3@PMoveProc:

; 13481: 				{
; 13482: 					lpObj->VpPlayer2[n].number= -1;

  008a0	83 c8 ff	 or	 eax, -1
  008a3	66 89 01	 mov	 WORD PTR [ecx], ax

; 13483: 					lpObj->VpPlayer2[n].state = 0;

  008a6	c6 07 00	 mov	 BYTE PTR [edi], 0

; 13484: 					lpObj->VPCount2--;

  008a9	ff 8e 34 0c 00
	00		 dec	 DWORD PTR [esi+3124]
$LN7@PMoveProc:

; 13456: 	}
; 13457: 
; 13458: 	int MVL = MAX_VIEWPORT;
; 13459: 
; 13460: 	if ( lpObj->Type == OBJ_MONSTER )
; 13461: 	{
; 13462: 		MVL = MAX_VIEWPORT_MONSTER;
; 13463: 	}
; 13464: 		
; 13465: 	for (n=0;n<MVL;n++)

  008af	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  008b5	40		 inc	 eax
  008b6	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
  008bc	98		 cwde
  008bd	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  008c0	0f 8c 7b ff ff
	ff		 jl	 $LL8@PMoveProc

; 13485: 				}
; 13486: 			}
; 13487: 		}
; 13488: 	}
; 13489: 
; 13490: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  008c6	0f bf 8e 7a 01
	00 00		 movsx	 ecx, WORD PTR [esi+378]
  008cd	0f bf 96 78 01
	00 00		 movsx	 edx, WORD PTR [esi+376]
  008d4	51		 push	 ecx
  008d5	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  008dc	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  008e2	52		 push	 edx
  008e3	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  008e9	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 13491: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  008ee	0f bf 86 7e 01
	00 00		 movsx	 eax, WORD PTR [esi+382]
  008f5	0f bf 8e 7c 01
	00 00		 movsx	 ecx, WORD PTR [esi+380]
  008fc	50		 push	 eax
  008fd	51		 push	 ecx
  008fe	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  00905	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0090b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00911	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 13492: 
; 13493: 	lpObj->m_OldX = lpObj->TX;

  00916	0f b7 96 7c 01
	00 00		 movzx	 edx, WORD PTR [esi+380]

; 13494: 	lpObj->m_OldY = lpObj->TY;

  0091d	66 8b 86 7e 01
	00 00		 mov	 ax, WORD PTR [esi+382]

; 13495: 
; 13496: 	lpObj->X = sx;

  00924	66 8b 8d c8 fe
	ff ff		 mov	 cx, WORD PTR _sx$[ebp]
  0092b	66 89 96 78 01
	00 00		 mov	 WORD PTR [esi+376], dx

; 13497: 	lpObj->Y = sy;

  00932	0f b7 95 cc fe
	ff ff		 movzx	 edx, WORD PTR _sy$[ebp]
  00939	66 89 86 7a 01
	00 00		 mov	 WORD PTR [esi+378], ax
  00940	66 89 8e 44 01
	00 00		 mov	 WORD PTR [esi+324], cx
  00947	66 89 96 46 01
	00 00		 mov	 WORD PTR [esi+326], dx

; 13498: 
; 13499: 	lpObj->m_ViewState = 0;

  0094e	c6 86 26 02 00
	00 00		 mov	 BYTE PTR [esi+550], 0
$LN107@PMoveProc:
  00955	5b		 pop	 ebx
$LN106@PMoveProc:

; 13500: }

  00956	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00959	5e		 pop	 esi
  0095a	33 cd		 xor	 ecx, ebp
  0095c	5f		 pop	 edi
  0095d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00962	8b e5		 mov	 esp, ebp
  00964	5d		 pop	 ebp
  00965	c3		 ret	 0
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ENDP			; PMoveProc
_TEXT	ENDS
PUBLIC	??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@ ; `string'
PUBLIC	?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
;	COMDAT ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
CONST	SEGMENT
??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@ DB 'error : mo'
	DB	've protocol index error %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 7
_lpMove$ = 8						; size = 4
_n$ = 12						; size = 2
_aIndex$ = 12						; size = 4
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z PROC ; RecvPositionSetProc, COMDAT

; 13503: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 13504: 	short n;
; 13505: 
; 13506: 	if (  OBJMAX_RANGE(aIndex) == FALSE)

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	78 0f		 js	 SHORT $LN27@RecvPositi
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 1d		 jne	 SHORT $LN16@RecvPositi
$LN27@RecvPositi:

; 13507: 	{
; 13508: 		LogAdd("error : move protocol index error %s %d", __FILE__, __LINE__);

  0001d	68 c4 34 00 00	 push	 13508			; 000034c4H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5b		 pop	 ebx

; 13600: 
; 13601: }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN16@RecvPositi:
  0003a	56		 push	 esi

; 13509: 		return;
; 13510: 	}
; 13511: 
; 13512: 	LPOBJ lpObj = &gObj[aIndex];

  0003b	8b f3		 mov	 esi, ebx
  0003d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00043	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13513: 
; 13514: 	if ( ::PacketCheckTime(lpObj) == FALSE )

  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004f	83 c4 04	 add	 esp, 4
  00052	85 c0		 test	 eax, eax
  00054	0f 84 da 01 00
	00		 je	 $LN31@RecvPositi

; 13515: 	{
; 13516: 		return;
; 13517: 	}
; 13518: 
; 13519: 	if ( lpObj->Teleport != 0 )

  0005a	80 be a0 03 00
	00 00		 cmp	 BYTE PTR [esi+928], 0
  00061	0f 85 cd 01 00
	00		 jne	 $LN31@RecvPositi

; 13520: 	{
; 13521: 		return;
; 13522: 	}
; 13523: 
; 13524: 	lpObj->X = lpMove->X;

  00067	57		 push	 edi
  00068	8b 7d 08	 mov	 edi, DWORD PTR _lpMove$[ebp]
  0006b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0006f	66 89 86 44 01
	00 00		 mov	 WORD PTR [esi+324], ax

; 13525: 	lpObj->Y = lpMove->Y;
; 13526: 
; 13527: 	if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00076	0f b6 86 49 01
	00 00		 movzx	 eax, BYTE PTR [esi+329]
  0007d	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00081	66 89 8e 46 01
	00 00		 mov	 WORD PTR [esi+326], cx
  00088	3c 35		 cmp	 al, 53			; 00000035H
  0008a	74 0d		 je	 SHORT $LN28@RecvPositi
  0008c	3c 12		 cmp	 al, 18			; 00000012H
  0008e	72 20		 jb	 SHORT $LN12@RecvPositi
  00090	b2 17		 mov	 dl, 23			; 00000017H
  00092	3a d0		 cmp	 dl, al
  00094	1b c0		 sbb	 eax, eax
  00096	40		 inc	 eax
  00097	74 17		 je	 SHORT $LN12@RecvPositi
$LN28@RecvPositi:

; 13528: 	{
; 13529: 		if ( (GetTickCount() - lpObj->m_iChaosCastleBlowTime ) < 1000 )

  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0009f	2b 86 a8 0e 00
	00		 sub	 eax, DWORD PTR [esi+3752]
  000a5	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000aa	0f 82 83 01 00
	00		 jb	 $LN32@RecvPositi
$LN12@RecvPositi:

; 13530: 		{
; 13531: 			return;
; 13532: 		}
; 13533: 	}
; 13534: 
; 13535: 	if ( gObjCheckXYMapTile(lpObj, 2) == TRUE)

  000b0	6a 02		 push	 2
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  000b8	83 c4 08	 add	 esp, 8
  000bb	83 f8 01	 cmp	 eax, 1
  000be	0f 84 6f 01 00
	00		 je	 $LN32@RecvPositi

; 13536: 	{
; 13537: 		return;
; 13538: 	}
; 13539: 
; 13540: 	PMSG_RECV_POSISTION_SET pMove;
; 13541: 
; 13542: 	PHeadSetB((LPBYTE)&pMove, PROTOCOL_POSITION, sizeof(pMove));

  000c4	6a 07		 push	 7
  000c6	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  000c9	6a 15		 push	 21			; 00000015H
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13543: 	pMove.NumberH = SET_NUMBERH(aIndex);
; 13544: 	pMove.NumberL = SET_NUMBERL(aIndex);
; 13545: 	pMove.X = lpMove->X;

  000d1	8a 47 03	 mov	 al, BYTE PTR [edi+3]

; 13546: 	pMove.Y = lpMove->Y;

  000d4	8a 57 04	 mov	 dl, BYTE PTR [edi+4]
  000d7	88 45 fd	 mov	 BYTE PTR _pMove$[ebp+5], al
  000da	8b cb		 mov	 ecx, ebx
  000dc	c1 e9 08	 shr	 ecx, 8

; 13547: 	lpObj->TX = lpMove->X;

  000df	0f b6 c0	 movzx	 eax, al
  000e2	88 4d fb	 mov	 BYTE PTR _pMove$[ebp+3], cl
  000e5	88 5d fc	 mov	 BYTE PTR _pMove$[ebp+4], bl
  000e8	88 55 fe	 mov	 BYTE PTR _pMove$[ebp+6], dl
  000eb	66 89 86 7c 01
	00 00		 mov	 WORD PTR [esi+380], ax

; 13548: 	lpObj->TY = lpMove->Y;

  000f2	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]

; 13549: 
; 13550: 	if ( ::gObjPositionCheck(lpObj) == FALSE )

  000f6	56		 push	 esi
  000f7	66 89 8e 7e 01
	00 00		 mov	 WORD PTR [esi+382], cx
  000fe	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjPositionCheck
  00103	83 c4 10	 add	 esp, 16			; 00000010H
  00106	85 c0		 test	 eax, eax
  00108	0f 84 25 01 00
	00		 je	 $LN32@RecvPositi

; 13551: 	{
; 13552: 		return;
; 13553: 	}
; 13554: 
; 13555: 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  0010e	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  00115	0f bf 86 44 01
	00 00		 movsx	 eax, WORD PTR [esi+324]
  0011c	53		 push	 ebx
  0011d	52		 push	 edx
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13556: 
; 13557: 	if ( lpObj->Type == OBJ_USER )

  00127	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  0012c	75 12		 jne	 SHORT $LN9@RecvPositi

; 13558: 	{
; 13559: 		#if(ENABLE_CAMERA_PARTY)
; 13560: 		//g_CameraParty.Move(aIndex);
; 13561: 		#endif
; 13562: 
; 13563: 		DataSend(aIndex, (LPBYTE)&pMove, pMove.h.size);

  0012e	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMove$[ebp+1]
  00132	51		 push	 ecx
  00133	8d 55 f8	 lea	 edx, DWORD PTR _pMove$[ebp]
  00136	52		 push	 edx
  00137	53		 push	 ebx
  00138	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@RecvPositi:

; 13564: 	}
; 13565: 
; 13566: 	int MVL = MAX_VIEWPORT;
; 13567: 
; 13568: 	if ( lpObj->Type == OBJ_MONSTER )
; 13569: 	{
; 13570: 		MVL = MAX_VIEWPORT_MONSTER;
; 13571: 	}
; 13572: 
; 13573: 	for ( n=0;n<MVL;n++)

  00140	33 c0		 xor	 eax, eax
  00142	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
  00145	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL7@RecvPositi:

; 13574: 	{
; 13575: 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00150	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00153	80 bc 8e b0 08
	00 00 01	 cmp	 BYTE PTR [esi+ecx*4+2224], 1
  0015b	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]
  0015e	75 5a		 jne	 SHORT $LN6@RecvPositi

; 13576: 		{
; 13577: 			if ( lpObj->VpPlayer2[n].state == 1 )

  00160	8d 94 40 2b 02
	00 00		 lea	 edx, DWORD PTR [eax+eax*2+555]
  00167	80 3c 96 01	 cmp	 BYTE PTR [esi+edx*4], 1
  0016b	8d 3c 96	 lea	 edi, DWORD PTR [esi+edx*4]
  0016e	75 4a		 jne	 SHORT $LN6@RecvPositi

; 13578: 			{
; 13579: 				int Index = lpObj->VpPlayer2[n].number;

  00170	0f bf 91 ae 08
	00 00		 movsx	 edx, WORD PTR [ecx+2222]

; 13580: 
; 13581: 				if ( gObj[Index].Connected > PLAYER_CONNECTED && gObj[Index].Live != FALSE)

  00177	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017d	8b c2		 mov	 eax, edx
  0017f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00185	83 7c 18 04 01	 cmp	 DWORD PTR [eax+ebx+4], 1
  0018a	7e 1b		 jle	 SHORT $LN29@RecvPositi
  0018c	80 7c 18 6a 00	 cmp	 BYTE PTR [eax+ebx+106], 0
  00191	74 14		 je	 SHORT $LN29@RecvPositi

; 13582: 				{
; 13583: 					DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pMove, pMove.h.size);

  00193	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMove$[ebp+1]
  00197	51		 push	 ecx
  00198	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  0019b	50		 push	 eax
  0019c	52		 push	 edx
  0019d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13584: 				}
; 13585: 				else

  001a5	eb 13		 jmp	 SHORT $LN6@RecvPositi
$LN29@RecvPositi:

; 13586: 				{
; 13587: 					lpObj->VpPlayer2[n].number = -1;

  001a7	83 ca ff	 or	 edx, -1
  001aa	66 89 91 ae 08
	00 00		 mov	 WORD PTR [ecx+2222], dx

; 13588: 					lpObj->VpPlayer2[n].state = FALSE;

  001b1	c6 07 00	 mov	 BYTE PTR [edi], 0

; 13589: 					lpObj->VPCount2--;

  001b4	ff 8e 34 0c 00
	00		 dec	 DWORD PTR [esi+3124]
$LN6@RecvPositi:

; 13564: 	}
; 13565: 
; 13566: 	int MVL = MAX_VIEWPORT;
; 13567: 
; 13568: 	if ( lpObj->Type == OBJ_MONSTER )
; 13569: 	{
; 13570: 		MVL = MAX_VIEWPORT_MONSTER;
; 13571: 	}
; 13572: 
; 13573: 	for ( n=0;n<MVL;n++)

  001ba	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  001bd	40		 inc	 eax
  001be	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
  001c1	98		 cwde
  001c2	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  001c5	7c 89		 jl	 SHORT $LL7@RecvPositi

; 13590: 				}
; 13591: 			}
; 13592: 		}
; 13593: 	}
; 13594: 
; 13595: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  001c7	0f bf 86 7a 01
	00 00		 movsx	 eax, WORD PTR [esi+378]
  001ce	0f bf 8e 78 01
	00 00		 movsx	 ecx, WORD PTR [esi+376]
  001d5	50		 push	 eax
  001d6	51		 push	 ecx
  001d7	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  001de	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  001e4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001ea	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 13596: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  001ef	0f b6 8e 49 01
	00 00		 movzx	 ecx, BYTE PTR [esi+329]
  001f6	0f bf 96 7e 01
	00 00		 movsx	 edx, WORD PTR [esi+382]
  001fd	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00203	0f bf 86 7c 01
	00 00		 movsx	 eax, WORD PTR [esi+380]
  0020a	52		 push	 edx
  0020b	50		 push	 eax
  0020c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00212	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 13597: 
; 13598: 	lpObj->m_OldX = lpObj->TX;

  00217	66 8b 8e 7c 01
	00 00		 mov	 cx, WORD PTR [esi+380]

; 13599: 	lpObj->m_OldY = lpObj->TY;

  0021e	66 8b 96 7e 01
	00 00		 mov	 dx, WORD PTR [esi+382]
  00225	66 89 8e 78 01
	00 00		 mov	 WORD PTR [esi+376], cx
  0022c	66 89 96 7a 01
	00 00		 mov	 WORD PTR [esi+378], dx
$LN32@RecvPositi:
  00233	5f		 pop	 edi
$LN31@RecvPositi:
  00234	5e		 pop	 esi
  00235	5b		 pop	 ebx

; 13600: 
; 13601: }

  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c3		 ret	 0
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ENDP ; RecvPositionSetProc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCDamageSend@@YAXHHHHHH@Z			; GCDamageSend
EXTRN	?DataSend@CGMMng@@QAEXPAEH@Z:PROC		; CGMMng::DataSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDamageSend@@YAXHHHHHH@Z
_TEXT	SEGMENT
tv310 = -52						; size = 8
tv302 = -52						; size = 8
tv312 = -48						; size = 4
tv304 = -48						; size = 4
tv315 = -42						; size = 2
tv307 = -42						; size = 2
_pResult$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
_MSBDamage$ = 24					; size = 4
_iShieldDamage$ = 28					; size = 4
?GCDamageSend@@YAXHHHHHH@Z PROC				; GCDamageSend, COMDAT

; 13688: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _TargetIndex$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 13689: 	PMSG_ATTACKRESULT pResult;
; 13690: 
; 13691: 	PHeadSetB((LPBYTE)&pResult, PROTOCOL_ATTACK, sizeof(pResult));

  00019	6a 24		 push	 36			; 00000024H
  0001b	8d 45 d8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0001e	6a 11		 push	 17			; 00000011H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13692: 	pResult.NumberH = SET_NUMBERH(TargetIndex);
; 13693: 	pResult.NumberL = SET_NUMBERL(TargetIndex);
; 13694: 	pResult.DamageH = SET_NUMBERH(AttackDamage);

  00026	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00029	8b cb		 mov	 ecx, ebx
  0002b	c1 e9 08	 shr	 ecx, 8

; 13695: 	pResult.DamageL = SET_NUMBERL(AttackDamage);
; 13696: 	pResult.btShieldDamageH = SET_NUMBERH(iShieldDamage);
; 13697: 	pResult.btShieldDamageL = SET_NUMBERL(iShieldDamage);
; 13698: 
; 13699: 	pResult.AttackDamage = AttackDamage;
; 13700: 	pResult.iShieldDamage = iShieldDamage;
; 13701: 
; 13702: 	if ( gObj[aIndex].Type == OBJ_USER && OBJMAX_RANGE(TargetIndex))

  0002e	8b f7		 mov	 esi, edi
  00030	88 4d db	 mov	 BYTE PTR _pResult$[ebp+3], cl
  00033	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00039	8b 4d 1c	 mov	 ecx, DWORD PTR _iShieldDamage$[ebp]
  0003c	8b d0		 mov	 edx, eax
  0003e	c1 ea 08	 shr	 edx, 8
  00041	88 55 dd	 mov	 BYTE PTR _pResult$[ebp+5], dl
  00044	8b d1		 mov	 edx, ecx
  00046	c1 ea 08	 shr	 edx, 8
  00049	88 55 e0	 mov	 BYTE PTR _pResult$[ebp+8], dl
  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	88 4d e1	 mov	 BYTE PTR _pResult$[ebp+9], cl
  00055	89 4d f0	 mov	 DWORD PTR _pResult$[ebp+24], ecx
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	88 5d dc	 mov	 BYTE PTR _pResult$[ebp+4], bl
  0005e	88 45 de	 mov	 BYTE PTR _pResult$[ebp+6], al
  00061	89 45 ec	 mov	 DWORD PTR _pResult$[ebp+20], eax
  00064	33 c9		 xor	 ecx, ecx
  00066	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  0006c	0f 85 8c 00 00
	00		 jne	 $LN15@GCDamageSe
  00072	3b d9		 cmp	 ebx, ecx
  00074	0f 8c 84 00 00
	00		 jl	 $LN15@GCDamageSe
  0007a	33 c0		 xor	 eax, eax
  0007c	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00082	0f 9e c0	 setle	 al
  00085	3b c1		 cmp	 eax, ecx
  00087	74 75		 je	 SHORT $LN15@GCDamageSe

; 13703: 	{
; 13704: 		pResult.Life	= (DWORD)(gObj[TargetIndex].Life);

  00089	8b cb		 mov	 ecx, ebx
  0008b	d9 7d d6	 fnstcw	 WORD PTR tv315[ebp]
  0008e	0f b7 45 d6	 movzx	 eax, WORD PTR tv315[ebp]
  00092	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00098	d9 84 11 fc 00
	00 00		 fld	 DWORD PTR [ecx+edx+252]
  0009f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000a4	89 45 d0	 mov	 DWORD PTR tv312[ebp], eax
  000a7	03 ca		 add	 ecx, edx
  000a9	d9 6d d0	 fldcw	 WORD PTR tv312[ebp]
  000ac	df 7d cc	 fistp	 QWORD PTR tv310[ebp]
  000af	8b 45 cc	 mov	 eax, DWORD PTR tv310[ebp]
  000b2	89 45 e4	 mov	 DWORD PTR _pResult$[ebp+12], eax
  000b5	d9 6d d6	 fldcw	 WORD PTR tv315[ebp]

; 13705: 		pResult.MaxLife = (DWORD)(gObj[TargetIndex].MaxLife + gObj[TargetIndex].AddLife);

  000b8	db 81 4c 01 00
	00		 fild	 DWORD PTR [ecx+332]
  000be	d9 7d d6	 fnstcw	 WORD PTR tv307[ebp]
  000c1	d8 81 00 01 00
	00		 fadd	 DWORD PTR [ecx+256]
  000c7	0f b7 45 d6	 movzx	 eax, WORD PTR tv307[ebp]
  000cb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000d0	89 45 d0	 mov	 DWORD PTR tv304[ebp], eax
  000d3	d9 6d d0	 fldcw	 WORD PTR tv304[ebp]
  000d6	df 7d cc	 fistp	 QWORD PTR tv302[ebp]
  000d9	8b 45 cc	 mov	 eax, DWORD PTR tv302[ebp]
  000dc	89 45 e8	 mov	 DWORD PTR _pResult$[ebp+16], eax

; 13706: 		pResult.SD	= (DWORD)(gObj[TargetIndex].iShield);

  000df	8b 81 54 01 00
	00		 mov	 eax, DWORD PTR [ecx+340]
  000e5	d9 6d d6	 fldcw	 WORD PTR tv307[ebp]
  000e8	89 45 f4	 mov	 DWORD PTR _pResult$[ebp+28], eax

; 13707: 		pResult.MaxSD = (DWORD)(gObj[TargetIndex].iMaxShield + gObj[TargetIndex].iAddShield);

  000eb	8b 81 5c 01 00
	00		 mov	 eax, DWORD PTR [ecx+348]
  000f1	03 81 58 01 00
	00		 add	 eax, DWORD PTR [ecx+344]

; 13708: 	}
; 13709: 	else

  000f7	33 c9		 xor	 ecx, ecx
  000f9	89 45 f8	 mov	 DWORD PTR _pResult$[ebp+32], eax
  000fc	eb 0c		 jmp	 SHORT $LN6@GCDamageSe
$LN15@GCDamageSe:

; 13710: 	{
; 13711: 		pResult.Life	= 0;

  000fe	89 4d e4	 mov	 DWORD PTR _pResult$[ebp+12], ecx

; 13712: 		pResult.MaxLife = 0;

  00101	89 4d e8	 mov	 DWORD PTR _pResult$[ebp+16], ecx

; 13713: 		pResult.SD	= 0;

  00104	89 4d f4	 mov	 DWORD PTR _pResult$[ebp+28], ecx

; 13714: 		pResult.MaxSD = 0;

  00107	89 4d f8	 mov	 DWORD PTR _pResult$[ebp+32], ecx
$LN6@GCDamageSe:

; 13715: 	}
; 13716: 
; 13717: 	if ( MSBFlag != FALSE )

  0010a	39 4d 14	 cmp	 DWORD PTR _MSBFlag$[ebp], ecx
  0010d	74 04		 je	 SHORT $LN5@GCDamageSe

; 13718: 	{
; 13719: 		pResult.NumberH &= 0x7F;
; 13720: 		pResult.NumberH |= 0x80;

  0010f	80 4d db 80	 or	 BYTE PTR _pResult$[ebp+3], 128 ; 00000080H
$LN5@GCDamageSe:

; 13721: 	}
; 13722: 
; 13723: 	pResult.DamageType = MSBDamage;

  00113	8a 45 18	 mov	 al, BYTE PTR _MSBDamage$[ebp]
  00116	88 45 df	 mov	 BYTE PTR _pResult$[ebp+7], al

; 13724: 
; 13725: 	if ( OBJMAX_RANGE(TargetIndex) && gObj[TargetIndex].Type == OBJ_USER )

  00119	3b d9		 cmp	 ebx, ecx
  0011b	7c 37		 jl	 SHORT $LN16@GCDamageSe
  0011d	33 c0		 xor	 eax, eax
  0011f	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00125	0f 9e c0	 setle	 al
  00128	3b c1		 cmp	 eax, ecx
  0012a	74 28		 je	 SHORT $LN16@GCDamageSe
  0012c	8b cb		 mov	 ecx, ebx
  0012e	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00134	66 83 7c 11 68
	01		 cmp	 WORD PTR [ecx+edx+104], 1
  0013a	75 18		 jne	 SHORT $LN16@GCDamageSe

; 13726: 	{
; 13727: 		DataSend(TargetIndex, (LPBYTE)&pResult, pResult.h.size);

  0013c	0f b6 55 d9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00140	52		 push	 edx
  00141	8d 45 d8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00144	50		 push	 eax
  00145	53		 push	 ebx
  00146	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@GCDamageSe:

; 13728: 	}
; 13729: 
; 13730: 	if ( cManager.WatchTargetIndex == TargetIndex || cManager.WatchTargetIndex == aIndex )

  00154	a1 e4 4c 00 00	 mov	 eax, DWORD PTR ?cManager@@3VCGMMng@@A+19684
  00159	3b c3		 cmp	 eax, ebx
  0015b	74 04		 je	 SHORT $LN2@GCDamageSe
  0015d	3b c7		 cmp	 eax, edi
  0015f	75 19		 jne	 SHORT $LN3@GCDamageSe
$LN2@GCDamageSe:

; 13731: 	{
; 13732: 		cManager.DataSend((LPBYTE)&pResult, pResult.h.size);

  00161	0f b6 4d d9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00165	51		 push	 ecx
  00166	8d 55 d8	 lea	 edx, DWORD PTR _pResult$[ebp]
  00169	52		 push	 edx
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  0016f	e8 00 00 00 00	 call	 ?DataSend@CGMMng@@QAEXPAEH@Z ; CGMMng::DataSend
  00174	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@GCDamageSe:

; 13733: 	}
; 13734: 
; 13735: 	if ( gObj[aIndex].Type == OBJ_USER )

  0017a	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  00180	75 12		 jne	 SHORT $LN1@GCDamageSe

; 13736: 	{
; 13737: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00182	0f b6 45 d9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00186	50		 push	 eax
  00187	8d 4d d8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0018a	51		 push	 ecx
  0018b	57		 push	 edi
  0018c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDamageSe:

; 13738: 	}
; 13739: 
; 13740: }

  00194	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	33 cd		 xor	 ecx, ebp
  0019b	5b		 pop	 ebx
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c3		 ret	 0
?GCDamageSend@@YAXHHHHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
PUBLIC	?GCDamageSend@@YAXHHH@Z				; GCDamageSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDamageSend@@YAXHHH@Z
_TEXT	SEGMENT
_pDamage$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_damage$ = 12						; size = 4
_iShieldDamage$ = 16					; size = 4
?GCDamageSend@@YAXHHH@Z PROC				; GCDamageSend, COMDAT

; 13753: {	if ( gObj[aIndex].Type != OBJ_USER )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	83 ec 08	 sub	 esp, 8
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00010	8b c6		 mov	 eax, esi
  00012	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00018	66 83 7c 08 68
	01		 cmp	 WORD PTR [eax+ecx+104], 1
  0001e	75 40		 jne	 SHORT $LN2@GCDamageSe@2

; 13754: 	{
; 13755: 		return;
; 13756: 	}
; 13757: 
; 13758: 	PMSG_DAMAGE pDamage;
; 13759: 
; 13760: 	PHeadSubSetB((LPBYTE)&pDamage, 0xF3, 0x07, sizeof(pDamage));

  00020	6a 08		 push	 8
  00022	6a 07		 push	 7
  00024	8d 55 f8	 lea	 edx, DWORD PTR _pDamage$[ebp]
  00027	68 f3 00 00 00	 push	 243			; 000000f3H
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 13761: 	pDamage.DamageH = SET_NUMBERH(damage);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]
  00035	8b c8		 mov	 ecx, eax

; 13762: 	pDamage.DamageL = SET_NUMBERL(damage);

  00037	88 45 fd	 mov	 BYTE PTR _pDamage$[ebp+5], al

; 13763: 	pDamage.btShieldDamageH = SET_NUMBERH(iShieldDamage);

  0003a	8b 45 10	 mov	 eax, DWORD PTR _iShieldDamage$[ebp]
  0003d	8b d0		 mov	 edx, eax

; 13764: 	pDamage.btShieldDamageL = SET_NUMBERL(iShieldDamage);

  0003f	88 45 ff	 mov	 BYTE PTR _pDamage$[ebp+7], al

; 13765: 
; 13766: 	DataSend(aIndex, (LPBYTE)&pDamage, pDamage.h.size);

  00042	0f b6 45 f9	 movzx	 eax, BYTE PTR _pDamage$[ebp+1]
  00046	c1 e9 08	 shr	 ecx, 8
  00049	88 4d fc	 mov	 BYTE PTR _pDamage$[ebp+4], cl
  0004c	50		 push	 eax
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR _pDamage$[ebp]
  00050	51		 push	 ecx
  00051	c1 ea 08	 shr	 edx, 8
  00054	56		 push	 esi
  00055	88 55 fe	 mov	 BYTE PTR _pDamage$[ebp+6], dl
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005d	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@GCDamageSe@2:
  00060	5e		 pop	 esi

; 13767: }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?GCDamageSend@@YAXHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCKillPlayerExtSend@@YAXHH_JHH@Z		; GCKillPlayerExtSend
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
; Function compile flags: /Ogtp
;	COMDAT ?GCKillPlayerExtSend@@YAXHH_JHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_exp$ = 16						; size = 8
_AttackDamage$ = 24					; size = 4
_MSBFlag$ = 28						; size = 4
?GCKillPlayerExtSend@@YAXHH_JHH@Z PROC			; GCKillPlayerExtSend, COMDAT

; 13819: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 13820: 	PMSG_KILLPLAYER_EXT pMsg;
; 13821: 
; 13822: 	PHeadSetBE((LPBYTE)&pMsg, 0x9C, sizeof(pMsg));

  00015	6a 10		 push	 16			; 00000010H
  00017	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	68 9c 00 00 00	 push	 156			; 0000009cH
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 13823: 	pMsg.NumberH = SET_NUMBERH(TargetIndex);

  00025	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]

; 13824: 	pMsg.NumberL = SET_NUMBERL(TargetIndex);
; 13825: 	pMsg.ExpH = SET_NUMBERHW(exp);
; 13826: 	pMsg.ExpL = SET_NUMBERLW(exp);
; 13827: 	pMsg.DamageH = SET_NUMBERH(AttackDamage);

  00028	8b 5d 18	 mov	 ebx, DWORD PTR _AttackDamage$[ebp]
  0002b	8b c8		 mov	 ecx, eax
  0002d	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00030	8b 45 10	 mov	 eax, DWORD PTR _exp$[ebp]
  00033	c1 e9 08	 shr	 ecx, 8
  00036	8b d0		 mov	 edx, eax
  00038	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 13828: 	pMsg.DamageL = SET_NUMBERL(AttackDamage);
; 13829: 
; 13830: 	pMsg.ExDamage = AttackDamage;
; 13831: 
; 13832: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003b	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0003f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00042	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00046	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+8], ax
  0004a	51		 push	 ecx
  0004b	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0004e	8b c3		 mov	 eax, ebx
  00050	52		 push	 edx
  00051	c1 e8 08	 shr	 eax, 8
  00054	56		 push	 esi
  00055	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+10], al
  00058	88 5d f7	 mov	 BYTE PTR _pMsg$[ebp+11], bl
  0005b	89 5d f8	 mov	 DWORD PTR _pMsg$[ebp+12], ebx
  0005e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00063	83 c4 18	 add	 esp, 24			; 00000018H

; 13833: 
; 13834: #if(FIX_FINAL_DMG_COLOR==TRUE)
; 13835: 	if(g_ZtLicense.CheckUser(Local) || g_ZtLicense.CheckUser(SILVER1) || g_ZtLicense.CheckUser(SILVER2))

  00066	6a 00		 push	 0
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0006d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00072	84 c0		 test	 al, al
  00074	75 20		 jne	 SHORT $LN1@GCKillPlay
  00076	6a 07		 push	 7
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0007d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00082	84 c0		 test	 al, al
  00084	75 10		 jne	 SHORT $LN1@GCKillPlay
  00086	6a 08		 push	 8
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0008d	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00092	84 c0		 test	 al, al
  00094	74 29		 je	 SHORT $LN2@GCKillPlay
$LN1@GCKillPlay:

; 13836: 	{
; 13837: 		GCDamageSend(aIndex, TargetIndex, AttackDamage, 0, gObj[aIndex].MSBDamage, 0);

  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009c	8b c6		 mov	 eax, esi
  0009e	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000a4	0f b6 94 08 cc
	28 00 00	 movzx	 edx, BYTE PTR [eax+ecx+10444]
  000ac	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  000af	6a 00		 push	 0
  000b1	52		 push	 edx
  000b2	6a 00		 push	 0
  000b4	53		 push	 ebx
  000b5	50		 push	 eax
  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHHH@Z ; GCDamageSend
  000bc	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@GCKillPlay:

; 13838: 	}
; 13839: #endif
; 13840: }

  000bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c2	5e		 pop	 esi
  000c3	33 cd		 xor	 ecx, ebp
  000c5	5b		 pop	 ebx
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?GCKillPlayerExtSend@@YAXHH_JHH@Z ENDP			; GCKillPlayerExtSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z	; GCDiePlayerSend
; Function compile flags: /Ogtp
;	COMDAT ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z
_TEXT	SEGMENT
_pDieMsg$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_skill$ = 16						; size = 1
_KillerIndex$ = 20					; size = 4
?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z PROC	; GCDiePlayerSend, COMDAT

; 13857: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00014	57		 push	 edi

; 13858: 	PMSG_DIEPLAYER pDieMsg;
; 13859: 
; 13860: 	PHeadSetB((LPBYTE)&pDieMsg, 0x17, sizeof(pDieMsg));

  00015	6a 09		 push	 9
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  0001a	6a 17		 push	 23			; 00000017H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13861: 	pDieMsg.NumberH = SET_NUMBERH(TargetIndex);

  00022	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]

; 13862: 	pDieMsg.NumberL = SET_NUMBERL(TargetIndex);
; 13863: 
; 13864: 	pDieMsg.SkillH = SET_NUMBERH(skill);
; 13865: 	pDieMsg.SkillL = SET_NUMBERL(skill);
; 13866: 
; 13867: 	pDieMsg.KillerNumberH = SET_NUMBERH(KillerIndex);
; 13868: 	pDieMsg.KillerNumberL = SET_NUMBERL(KillerIndex);
; 13869: 
; 13870: 	int iSize = pDieMsg.h.size;

  00025	0f b6 7d f1	 movzx	 edi, BYTE PTR _pDieMsg$[ebp+1]
  00029	8a 55 10	 mov	 dl, BYTE PTR _skill$[ebp]
  0002c	8b c8		 mov	 ecx, eax
  0002e	c1 e9 08	 shr	 ecx, 8
  00031	88 45 f4	 mov	 BYTE PTR _pDieMsg$[ebp+4], al
  00034	8b 45 14	 mov	 eax, DWORD PTR _KillerIndex$[ebp]
  00037	88 4d f3	 mov	 BYTE PTR _pDieMsg$[ebp+3], cl
  0003a	88 55 f6	 mov	 BYTE PTR _pDieMsg$[ebp+6], dl

; 13871: 
; 13872: 	MsgSendV2(lpObj, (LPBYTE)&pDieMsg, iSize);

  0003d	57		 push	 edi
  0003e	8d 55 f0	 lea	 edx, DWORD PTR _pDieMsg$[ebp]
  00041	8b c8		 mov	 ecx, eax
  00043	52		 push	 edx
  00044	c1 e9 08	 shr	 ecx, 8
  00047	56		 push	 esi
  00048	c6 45 f5 00	 mov	 BYTE PTR _pDieMsg$[ebp+5], 0
  0004c	88 4d f7	 mov	 BYTE PTR _pDieMsg$[ebp+7], cl
  0004f	88 45 f8	 mov	 BYTE PTR _pDieMsg$[ebp+8], al
  00052	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00057	83 c4 18	 add	 esp, 24			; 00000018H

; 13873: 
; 13874: 	if ( lpObj->Type == OBJ_USER )

  0005a	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  0005f	75 10		 jne	 SHORT $LN1@GCDiePlaye

; 13875: 	{
; 13876: 		DataSend(lpObj->m_Index, (LPBYTE)&pDieMsg, iSize);

  00061	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00063	57		 push	 edi
  00064	8d 45 f0	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDiePlaye:

; 13877: 	}
; 13878: }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	5f		 pop	 edi
  00075	33 cd		 xor	 ecx, ebp
  00077	5e		 pop	 esi
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HEH@Z ENDP	; GCDiePlayerSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z	; GCActionSend
; Function compile flags: /Ogtp
;	COMDAT ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z
_TEXT	SEGMENT
_pActionResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_ActionNumber$ = 12					; size = 1
_aIndex$ = 16						; size = 4
_aTargetIndex$ = 20					; size = 4
?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z PROC		; GCActionSend, COMDAT

; 13881: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 13882: 	PMSG_ACTIONRESULT pActionResult;
; 13883: 
; 13884: 	PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  00014	6a 09		 push	 9
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  00019	6a 18		 push	 24			; 00000018H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13885: 	pActionResult.NumberH = SET_NUMBERH(aIndex);

  00021	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 13886: 	pActionResult.NumberL = SET_NUMBERL(aIndex);
; 13887: 	pActionResult.ActionNumber = ActionNumber;

  00024	8a 55 0c	 mov	 dl, BYTE PTR _ActionNumber$[ebp]
  00027	8b c8		 mov	 ecx, eax
  00029	88 45 f4	 mov	 BYTE PTR _pActionResult$[ebp+4], al

; 13888: 	pActionResult.Dir = lpObj->Dir;

  0002c	8a 86 48 01 00
	00		 mov	 al, BYTE PTR [esi+328]
  00032	c1 e9 08	 shr	 ecx, 8
  00035	88 55 f6	 mov	 BYTE PTR _pActionResult$[ebp+6], dl

; 13889: 	pActionResult.TargetNumberH = SET_NUMBERH(aTargetIndex);
; 13890: 	pActionResult.TargetNumberL = SET_NUMBERL(aTargetIndex);
; 13891: 
; 13892: 	MsgSendV2(lpObj, (LPBYTE)&pActionResult, pActionResult.h.size);

  00038	0f b6 55 f1	 movzx	 edx, BYTE PTR _pActionResult$[ebp+1]
  0003c	88 45 f5	 mov	 BYTE PTR _pActionResult$[ebp+5], al
  0003f	8b 45 14	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00042	88 4d f3	 mov	 BYTE PTR _pActionResult$[ebp+3], cl
  00045	8b c8		 mov	 ecx, eax
  00047	88 45 f8	 mov	 BYTE PTR _pActionResult$[ebp+8], al
  0004a	52		 push	 edx
  0004b	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  0004e	50		 push	 eax
  0004f	c1 e9 08	 shr	 ecx, 8
  00052	56		 push	 esi
  00053	88 4d f7	 mov	 BYTE PTR _pActionResult$[ebp+7], cl
  00056	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 13893: }

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	83 c4 18	 add	 esp, 24			; 00000018H
  00061	33 cd		 xor	 ecx, ebp
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ENDP		; GCActionSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z		; CGActionRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z PROC		; CGActionRecv, COMDAT

; 13896: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 13897: 	if ( !OBJMAX_RANGE(aIndex))

  00018	85 db		 test	 ebx, ebx
  0001a	78 0f		 js	 SHORT $LN19@CGActionRe
  0001c	33 c0		 xor	 eax, eax
  0001e	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN12@CGActionRe
$LN19@CGActionRe:

; 13898: 	{
; 13899: 		LogAdd("error : move protocol index error %s %d", __FILE__, __LINE__);

  0002b	68 4b 36 00 00	 push	 13899			; 0000364bH
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx

; 13946: 			}
; 13947: 		}
; 13948: 	}
; 13949: }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN12@CGActionRe:
  00053	56		 push	 esi

; 13900: 		return;
; 13901: 	}
; 13902: 
; 13903: 	PMSG_ACTIONRESULT pResult;
; 13904: 	LPOBJ lpObj = &gObj[aIndex];

  00054	8b f3		 mov	 esi, ebx
  00056	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0005c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13905: 
; 13906: 	PHeadSetB((LPBYTE)&pResult, 0x18, sizeof(pResult));

  00062	6a 09		 push	 9
  00064	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  00067	6a 18		 push	 24			; 00000018H
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 13907: 	pResult.ActionNumber = lpMsg->ActionNumber;

  0006f	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00072	88 45 f6	 mov	 BYTE PTR _pResult$[ebp+6], al

; 13908: 	pResult.NumberH = SET_NUMBERH(aIndex);

  00075	8b cb		 mov	 ecx, ebx
  00077	c1 e9 08	 shr	 ecx, 8
  0007a	88 4d f3	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 13909: 	pResult.NumberL = SET_NUMBERL(aIndex);

  0007d	88 5d f4	 mov	 BYTE PTR _pResult$[ebp+4], bl

; 13910: 	lpObj->m_ActionNumber = lpMsg->ActionNumber;

  00080	88 86 1c 02 00
	00		 mov	 BYTE PTR [esi+540], al

; 13911: 	lpObj->Dir = lpMsg->Dir;

  00086	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00089	88 86 48 01 00
	00		 mov	 BYTE PTR [esi+328], al

; 13912: 	pResult.Dir = lpObj->Dir;
; 13913: 	pResult.TargetNumberH = lpMsg->iTargetIndexH;

  0008f	8a 57 05	 mov	 dl, BYTE PTR [edi+5]
  00092	88 45 f5	 mov	 BYTE PTR _pResult$[ebp+5], al

; 13914: 	pResult.TargetNumberL = lpMsg->iTargetIndexL;

  00095	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  00099	88 55 f7	 mov	 BYTE PTR _pResult$[ebp+7], dl
  0009c	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+8], al

; 13915: 
; 13916: 	if ( lpObj->m_ActionNumber == 0x80)

  0009f	8a 86 1c 02 00
	00		 mov	 al, BYTE PTR [esi+540]
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	3c 80		 cmp	 al, 128			; 00000080H
  000aa	75 0b		 jne	 SHORT $LN11@CGActionRe

; 13917: 	{
; 13918: 		lpObj->m_ViewState = 2;

  000ac	66 c7 86 25 02
	00 00 80 02	 mov	 WORD PTR [esi+549], 640	; 00000280H

; 13919: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  000b5	eb 1c		 jmp	 SHORT $LN7@CGActionRe
$LN11@CGActionRe:

; 13920: 	}
; 13921: 	else if ( lpObj->m_ActionNumber == 0x81 )

  000b7	3c 81		 cmp	 al, 129			; 00000081H
  000b9	75 0b		 jne	 SHORT $LN9@CGActionRe

; 13922: 	{
; 13923: 		lpObj->m_ViewState = 3;

  000bb	66 c7 86 25 02
	00 00 81 03	 mov	 WORD PTR [esi+549], 897	; 00000381H

; 13924: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  000c4	eb 0d		 jmp	 SHORT $LN7@CGActionRe
$LN9@CGActionRe:

; 13925: 	}
; 13926: 	else if ( lpObj->m_ActionNumber == 0x82 )

  000c6	3c 82		 cmp	 al, 130			; 00000082H
  000c8	75 09		 jne	 SHORT $LN7@CGActionRe

; 13927: 	{
; 13928: 		lpObj->m_ViewState = 4;

  000ca	66 c7 86 25 02
	00 00 82 04	 mov	 WORD PTR [esi+549], 1154 ; 00000482H
$LN7@CGActionRe:

; 13929: 		lpObj->m_Rest = lpObj->m_ActionNumber;
; 13930: 	}
; 13931: 	
; 13932: 	int MVL = MAX_VIEWPORT;
; 13933: 
; 13934: 	if ( lpObj->Type == OBJ_MONSTER )
; 13935: 	{
; 13936: 		MVL = MAX_VIEWPORT_MONSTER;
; 13937: 	}
; 13938: 
; 13939: 	for (int n=0;n<MVL;n++)

  000d3	81 c6 ac 08 00
	00		 add	 esi, 2220		; 000008acH
  000d9	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
  000de	bb 01 00 00 00	 mov	 ebx, 1
$LL5@CGActionRe:

; 13940: 	{
; 13941: 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  000e3	38 5e 04	 cmp	 BYTE PTR [esi+4], bl
  000e6	75 24		 jne	 SHORT $LN4@CGActionRe

; 13942: 		{
; 13943: 			if ( lpObj->VpPlayer2[n].state != 0 && lpObj->VpPlayer2[n].state != 0x10 && lpObj->VpPlayer2[n].state != 0x08)

  000e8	8a 06		 mov	 al, BYTE PTR [esi]
  000ea	84 c0		 test	 al, al
  000ec	74 1e		 je	 SHORT $LN4@CGActionRe
  000ee	3c 10		 cmp	 al, 16			; 00000010H
  000f0	74 1a		 je	 SHORT $LN4@CGActionRe
  000f2	3c 08		 cmp	 al, 8
  000f4	74 16		 je	 SHORT $LN4@CGActionRe

; 13944: 			{
; 13945: 				DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pResult, pResult.h.size);

  000f6	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  000fa	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  000fe	51		 push	 ecx
  000ff	8d 55 f0	 lea	 edx, DWORD PTR _pResult$[ebp]
  00102	52		 push	 edx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CGActionRe:

; 13929: 		lpObj->m_Rest = lpObj->m_ActionNumber;
; 13930: 	}
; 13931: 	
; 13932: 	int MVL = MAX_VIEWPORT;
; 13933: 
; 13934: 	if ( lpObj->Type == OBJ_MONSTER )
; 13935: 	{
; 13936: 		MVL = MAX_VIEWPORT_MONSTER;
; 13937: 	}
; 13938: 
; 13939: 	for (int n=0;n<MVL;n++)

  0010c	83 c6 0c	 add	 esi, 12			; 0000000cH
  0010f	2b fb		 sub	 edi, ebx
  00111	75 d0		 jne	 SHORT $LL5@CGActionRe

; 13946: 			}
; 13947: 		}
; 13948: 	}
; 13949: }

  00113	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	5e		 pop	 esi
  00117	5f		 pop	 edi
  00118	33 cd		 xor	 ecx, ebp
  0011a	5b		 pop	 ebx
  0011b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ENDP		; CGActionRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
EXTRN	?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
EXTRN	?CheckRequireStatus@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckRequireStatus
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z
_TEXT	SEGMENT
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 2
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 1
?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z PROC ; GCMagicAttackNumberSend, COMDAT

; 14102: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 14103: #if(DEV_SKILL)
; 14104: 	if(MagicNumber == 2)
; 14105: 	{
; 14106: 		MagicNumber = 618;
; 14107: 	}
; 14108: #endif
; 14109: 
; 14110: 	PMSG_MAGICATTACK_RESULT pAttack;
; 14111: 	
; 14112: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  00016	6a 09		 push	 9
  00018	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0001b	6a 19		 push	 25			; 00000019H
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 14113: 	pAttack.MagicNumberH = SET_NUMBERH(MagicNumber);

  00023	8b 5d 0c	 mov	 ebx, DWORD PTR _MagicNumber$[ebp]
  00026	8b cb		 mov	 ecx, ebx
  00028	c1 e9 08	 shr	 ecx, 8
  0002b	88 4d f3	 mov	 BYTE PTR _pAttack$[ebp+3], cl

; 14114: 	pAttack.MagicNumberL = SET_NUMBERL(MagicNumber);
; 14115: 	pAttack.SourceNumberH = SET_NUMBERH(lpObj->m_Index);

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	8b d1		 mov	 edx, ecx
  00032	c1 ea 08	 shr	 edx, 8

; 14116: 	pAttack.SourceNumberL = SET_NUMBERL(lpObj->m_Index);

  00035	8a c1		 mov	 al, cl
  00037	88 55 f5	 mov	 BYTE PTR _pAttack$[ebp+5], dl

; 14117: 	pAttack.TargetNumberH = SET_NUMBERH(usernumber);

  0003a	8b 55 10	 mov	 edx, DWORD PTR _usernumber$[ebp]
  0003d	88 45 f6	 mov	 BYTE PTR _pAttack$[ebp+6], al
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 08	 shr	 eax, 8

; 14118: 	pAttack.TargetNumberL = SET_NUMBERL(usernumber);
; 14119: 	pAttack.TargetNumberH &= 0x7F;

  00045	24 7f		 and	 al, 127			; 0000007fH
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14120: 
; 14121: 	if ( skillsuccess )

  0004a	80 7d 14 00	 cmp	 BYTE PTR _skillsuccess$[ebp], 0
  0004e	88 5d f4	 mov	 BYTE PTR _pAttack$[ebp+4], bl
  00051	88 55 f8	 mov	 BYTE PTR _pAttack$[ebp+8], dl
  00054	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
  00057	74 05		 je	 SHORT $LN11@GCMagicAtt

; 14122: 	{
; 14123: 		pAttack.TargetNumberH |= 0x80;

  00059	0c 80		 or	 al, 128			; 00000080H
  0005b	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
$LN11@GCMagicAtt:

; 14124: 	}
; 14125: 
; 14126: 	if ( lpObj->Type == OBJ_USER )

  0005e	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00063	75 12		 jne	 SHORT $LN10@GCMagicAtt

; 14127: 	{
; 14128: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00065	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$[ebp+1]
  00069	52		 push	 edx
  0006a	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0006d	50		 push	 eax
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@GCMagicAtt:

; 14129: 	}
; 14130: 
; 14131: 	if ( CC_MAP_RANGE(lpObj->MapNumber) )

  00077	0f b6 86 49 01
	00 00		 movzx	 eax, BYTE PTR [esi+329]
  0007e	3c 35		 cmp	 al, 53			; 00000035H
  00080	74 0d		 je	 SHORT $LN18@GCMagicAtt
  00082	3c 12		 cmp	 al, 18			; 00000012H
  00084	72 54		 jb	 SHORT $LN2@GCMagicAtt
  00086	b1 17		 mov	 cl, 23			; 00000017H
  00088	3a c8		 cmp	 cl, al
  0008a	1b c0		 sbb	 eax, eax
  0008c	40		 inc	 eax
  0008d	74 4b		 je	 SHORT $LN2@GCMagicAtt
$LN18@GCMagicAtt:

; 14132: 	{
; 14133: 		if(g_MasterSkillSystem.CheckRequireStatus(MagicNumber) != FALSE) //Season3 add-on

  0008f	0f b7 fb	 movzx	 edi, bx
  00092	57		 push	 edi
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00098	e8 00 00 00 00	 call	 ?CheckRequireStatus@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckRequireStatus
  0009d	85 c0		 test	 eax, eax
  0009f	74 23		 je	 SHORT $LN8@GCMagicAtt

; 14134: 		{
; 14135: 			int GetBaseMasterLevelSkill = g_MasterSkillSystem.GetBaseMasterLevelSkill(MagicNumber);

  000a1	57		 push	 edi
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  000a7	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 14136: 
; 14137: 			switch ( GetBaseMasterLevelSkill )

  000ac	05 4d fe ff ff	 add	 eax, -435		; fffffe4dH
  000b1	83 f8 32	 cmp	 eax, 50			; 00000032H
  000b4	77 24		 ja	 SHORT $LN2@GCMagicAtt
  000b6	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN19@GCMagicAtt[eax]
  000bd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN21@GCMagicAtt[edx*4]
$LN8@GCMagicAtt:

; 14138: 			{
; 14139: 				case 435:
; 14140: 				case 470:
; 14141: 				case 475:
; 14142: 				//Season4 add-on
; 14143: 				case 480:
; 14144: 				case 485:
; 14145: 					return;
; 14146: 			}
; 14147: 		}
; 14148: 		else
; 14149: 		{
; 14150: 			switch ( MagicNumber )

  000c4	8d 47 f0	 lea	 eax, DWORD PTR [edi-16]
  000c7	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ca	77 0e		 ja	 SHORT $LN2@GCMagicAtt
  000cc	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN20@GCMagicAtt[eax]
  000d3	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@GCMagicAtt[eax*4]
$LN2@GCMagicAtt:

; 14151: 			{
; 14152: 				case 16:
; 14153: 				case 26:
; 14154: 				case 27:
; 14155: 				case 28:
; 14156: 				case 48:
; 14157: 					return;
; 14158: 			}
; 14159: 		}
; 14160: 	}
; 14161: 	
; 14162: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  000da	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pAttack$[ebp+1]
  000de	51		 push	 ecx
  000df	8d 55 f0	 lea	 edx, DWORD PTR _pAttack$[ebp]
  000e2	52		 push	 edx
  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@GCMagicAtt:

; 14163: }

  000ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	33 cd		 xor	 ecx, ebp
  000f3	5b		 pop	 ebx
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
  000fd	8d 49 00	 npad	 3
$LN21@GCMagicAtt:
  00100	00 00 00 00	 DD	 $LN12@GCMagicAtt
  00104	00 00 00 00	 DD	 $LN2@GCMagicAtt
$LN19@GCMagicAtt:
  00108	00		 DB	 0
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	00		 DB	 0
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	00		 DB	 0
  00131	01		 DB	 1
  00132	01		 DB	 1
  00133	01		 DB	 1
  00134	01		 DB	 1
  00135	00		 DB	 0
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	00		 DB	 0
  0013b	90		 npad	 1
$LN22@GCMagicAtt:
  0013c	00 00 00 00	 DD	 $LN12@GCMagicAtt
  00140	00 00 00 00	 DD	 $LN2@GCMagicAtt
$LN20@GCMagicAtt:
  00144	00		 DB	 0
  00145	01		 DB	 1
  00146	01		 DB	 1
  00147	01		 DB	 1
  00148	01		 DB	 1
  00149	01		 DB	 1
  0014a	01		 DB	 1
  0014b	01		 DB	 1
  0014c	01		 DB	 1
  0014d	01		 DB	 1
  0014e	00		 DB	 0
  0014f	00		 DB	 0
  00150	00		 DB	 0
  00151	01		 DB	 1
  00152	01		 DB	 1
  00153	01		 DB	 1
  00154	01		 DB	 1
  00155	01		 DB	 1
  00156	01		 DB	 1
  00157	01		 DB	 1
  00158	01		 DB	 1
  00159	01		 DB	 1
  0015a	01		 DB	 1
  0015b	01		 DB	 1
  0015c	01		 DB	 1
  0015d	01		 DB	 1
  0015e	01		 DB	 1
  0015f	01		 DB	 1
  00160	01		 DB	 1
  00161	01		 DB	 1
  00162	01		 DB	 1
  00163	01		 DB	 1
  00164	00		 DB	 0
?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ENDP ; GCMagicAttackNumberSend
_TEXT	ENDS
PUBLIC	?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@G@Z	; GCMagicCancelSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@G@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 2
?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@G@Z PROC	; GCMagicCancelSend, COMDAT

; 14166: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 14167: 	PMSG_MAGICCANCEL pMsg;
; 14168: 
; 14169: 	PHeadSetB((LPBYTE)&pMsg, 0x1B, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000c	6a 1b		 push	 27			; 0000001bH
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14170: 	pMsg.MagicNumberH = SET_NUMBERH(MagicNumber);

  00014	8b 45 0c	 mov	 eax, DWORD PTR _MagicNumber$[ebp]

; 14171: 	pMsg.MagicNumberL = SET_NUMBERL(MagicNumber);
; 14172: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  00017	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001a	8b c8		 mov	 ecx, eax
  0001c	c1 e9 08	 shr	 ecx, 8
  0001f	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	8b d0		 mov	 edx, eax
  00026	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00029	c1 ea 08	 shr	 edx, 8
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14173: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 14174: 
; 14175: 	if ( lpObj->Type == OBJ_USER )

  0002f	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00034	8a c8		 mov	 cl, al
  00036	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00039	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  0003c	75 12		 jne	 SHORT $LN1@GCMagicCan

; 14176: 	{
; 14177: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0003e	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00042	52		 push	 edx
  00043	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00046	51		 push	 ecx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMagicCan:

; 14178: 	}
; 14179: 	
; 14180: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00050	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00054	52		 push	 edx
  00055	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	5e		 pop	 esi

; 14181: }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@G@Z ENDP	; GCMagicCancelSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCUseEffectItem@@YAXPAUOBJECTSTRUCT@@HHHH@Z	; GCUseEffectItem
; Function compile flags: /Ogtp
;	COMDAT ?GCUseEffectItem@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iEffectUseOption$ = 12					; size = 4
_iOptionType$ = 16					; size = 4
_iEffectType$ = 20					; size = 4
_iLeftTime$ = 24					; size = 4
?GCUseEffectItem@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC	; GCUseEffectItem, COMDAT

; 14184: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 14185: 	PMSG_USEEFFECTITEM pMsg;
; 14186: 
; 14187: 	PHeadSetB((LPBYTE)&pMsg, 0x2D, sizeof(pMsg));

  00014	6a 14		 push	 20			; 00000014H
  00016	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 2d		 push	 45			; 0000002dH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14188: 	pMsg.byEffectOption = iEffectUseOption;

  00021	8a 4d 0c	 mov	 cl, BYTE PTR _iEffectUseOption$[ebp]

; 14189: 	pMsg.wOptionType = iOptionType;

  00024	66 8b 55 10	 mov	 dx, WORD PTR _iOptionType$[ebp]

; 14190: 	pMsg.wEffectType = iEffectType;

  00028	66 8b 45 14	 mov	 ax, WORD PTR _iEffectType$[ebp]
  0002c	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 14191: 	pMsg.iLeftTime = iLeftTime;

  0002f	8b 4d 18	 mov	 ecx, DWORD PTR _iLeftTime$[ebp]
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14192: 	pMsg.flag = 0;
; 14193: 
; 14194: 	if ( lpObj->Type == OBJ_USER )

  00035	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  0003a	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+4], dx
  0003e	66 89 45 ee	 mov	 WORD PTR _pMsg$[ebp+6], ax
  00042	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+12], ecx
  00045	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0
  00049	75 14		 jne	 SHORT $LN1@GCUseEffec

; 14195: 	{
; 14196: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0004b	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0004f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00051	52		 push	 edx
  00052	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00055	50		 push	 eax
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUseEffec:

; 14197: 	}
; 14198: }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	5e		 pop	 esi
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?GCUseEffectItem@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP	; GCUseEffectItem
_TEXT	ENDS
PUBLIC	?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z	; CGMagicCancel
EXTRN	?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
; Function compile flags: /Ogtp
;	COMDAT ?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z PROC	; CGMagicCancel, COMDAT

; 14201: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 14202: 	if ( !OBJMAX_RANGE(aIndex))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 88 0c 01 00
	00		 js	 $LN1@CGMagicCan@2
  0000e	33 c9		 xor	 ecx, ecx
  00010	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx
  0001a	0f 84 fa 00 00
	00		 je	 $LN1@CGMagicCan@2

; 14203: 	{
; 14204: 		return;
; 14205: 	}
; 14206: 
; 14207: 	LPOBJ lpObj = &gObj[aIndex];

  00020	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00026	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	56		 push	 esi
  0002d	8b f0		 mov	 esi, eax

; 14208: 
; 14209: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00032	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00036	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0003a	66 c1 e1 08	 shl	 cx, 8
  0003e	66 0b ca	 or	 cx, dx
  00041	0f b7 c1	 movzx	 eax, cx

; 14210: 
; 14211: 	if ( MagicNumber == 77)

  00044	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00047	75 21		 jne	 SHORT $LN14@CGMagicCan@2

; 14212: 	{
; 14213: 		if ( gObjSearchActiveEffect(lpObj, AT_INFINITY_ARROW) == 1 ) //S3 Addition -> Infinity Arrow

  00049	6a 06		 push	 6
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00051	83 c4 08	 add	 esp, 8
  00054	3c 01		 cmp	 al, 1
  00056	0f 85 bd 00 00
	00		 jne	 $LN20@CGMagicCan@2

; 14214: 		{
; 14215: 			gObjRemoveBuffEffect(lpObj, AT_INFINITY_ARROW); //S3 Addition -> Infinity Arrow

  0005c	6a 06		 push	 6

; 14242: 		{
; 14243: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00064	83 c4 08	 add	 esp, 8
  00067	5e		 pop	 esi

; 14244: 		}
; 14245: 	}
; 14246: 
; 14247: }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN14@CGMagicCan@2:

; 14216: 		}
; 14217: 	}
; 14218: 	else if ( MagicNumber == 233 ) //season4 add-on

  0006a	b9 e9 00 00 00	 mov	 ecx, 233		; 000000e9H
  0006f	66 3b c1	 cmp	 ax, cx
  00072	75 21		 jne	 SHORT $LN11@CGMagicCan@2

; 14219: 	{
; 14220: 		if ( gObjSearchActiveEffect(lpObj, AT_EXPANSION_WIZARDRY) == 1 )

  00074	6a 52		 push	 82			; 00000052H
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0007c	83 c4 08	 add	 esp, 8
  0007f	3c 01		 cmp	 al, 1
  00081	0f 85 92 00 00
	00		 jne	 $LN20@CGMagicCan@2

; 14221: 		{
; 14222: 			gObjRemoveBuffEffect(lpObj, AT_EXPANSION_WIZARDRY);

  00087	6a 52		 push	 82			; 00000052H

; 14242: 		{
; 14243: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0008f	83 c4 08	 add	 esp, 8
  00092	5e		 pop	 esi

; 14244: 		}
; 14245: 	}
; 14246: 
; 14247: }

  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN11@CGMagicCan@2:

; 14223: 		}
; 14224: 	}
; 14225: 	else if( MagicNumber == AT_MSKILL_DW_EXPWIZARDRY1 )

  00095	ba 7c 01 00 00	 mov	 edx, 380		; 0000017cH
  0009a	66 3b c2	 cmp	 ax, dx
  0009d	75 23		 jne	 SHORT $LN8@CGMagicCan@2

; 14226: 	{
; 14227: 		if ( gObjSearchActiveEffect(lpObj,BUFF_EXP_WIZARDRY2) == TRUE )

  0009f	68 8a 00 00 00	 push	 138			; 0000008aH
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  000aa	83 c4 08	 add	 esp, 8
  000ad	3c 01		 cmp	 al, 1
  000af	75 68		 jne	 SHORT $LN20@CGMagicCan@2

; 14228: 		{
; 14229: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY2);

  000b1	68 8a 00 00 00	 push	 138			; 0000008aH

; 14242: 		{
; 14243: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  000bc	83 c4 08	 add	 esp, 8
  000bf	5e		 pop	 esi

; 14244: 		}
; 14245: 	}
; 14246: 
; 14247: }

  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
$LN8@CGMagicCan@2:

; 14230: 		}
; 14231: 	}
; 14232: 	else if( MagicNumber == AT_MSKILL_DW_EXPWIZARDRY2 )

  000c2	b9 7f 01 00 00	 mov	 ecx, 383		; 0000017fH
  000c7	66 3b c1	 cmp	 ax, cx
  000ca	75 23		 jne	 SHORT $LN5@CGMagicCan@2

; 14233: 	{
; 14234: 		if ( gObjSearchActiveEffect(lpObj,BUFF_EXP_WIZARDRY3) == TRUE )

  000cc	68 8b 00 00 00	 push	 139			; 0000008bH
  000d1	56		 push	 esi
  000d2	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  000d7	83 c4 08	 add	 esp, 8
  000da	3c 01		 cmp	 al, 1
  000dc	75 3b		 jne	 SHORT $LN20@CGMagicCan@2

; 14235: 		{
; 14236: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY3);

  000de	68 8b 00 00 00	 push	 139			; 0000008bH

; 14242: 		{
; 14243: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  000e9	83 c4 08	 add	 esp, 8
  000ec	5e		 pop	 esi

; 14244: 		}
; 14245: 	}
; 14246: 
; 14247: }

  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN5@CGMagicCan@2:

; 14237: 		}
; 14238: 	}
; 14239: 	else if( MagicNumber == AT_MSKILL_FE_INFINITY1 )

  000ef	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  000f4	66 3b c2	 cmp	 ax, dx
  000f7	75 20		 jne	 SHORT $LN20@CGMagicCan@2

; 14240: 	{
; 14241: 		if( gObjSearchActiveEffect(lpObj,BUFF_INFINITY_ARROW2) == TRUE )

  000f9	68 8f 00 00 00	 push	 143			; 0000008fH
  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00104	83 c4 08	 add	 esp, 8
  00107	3c 01		 cmp	 al, 1
  00109	75 0e		 jne	 SHORT $LN20@CGMagicCan@2

; 14242: 		{
; 14243: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  0010b	68 8f 00 00 00	 push	 143			; 0000008fH
  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00116	83 c4 08	 add	 esp, 8
$LN20@CGMagicCan@2:
  00119	5e		 pop	 esi
$LN1@CGMagicCan@2:

; 14244: 		}
; 14245: 	}
; 14246: 
; 14247: }

  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z ENDP	; CGMagicCancel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ; GCUseMonsterSkillSend
; Function compile flags: /Ogtp
;	COMDAT ?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_iSkillNumber$ = 16					; size = 4
?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z PROC	; GCUseMonsterSkillSend, COMDAT

; 14259: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]

; 14260: 	PMSG_USE_MONSTERSKILL pMsg;
; 14261: 
; 14262: 	PHeadSetB((LPBYTE)&pMsg, 0x69, sizeof(pMsg));

  00018	6a 0a		 push	 10			; 0000000aH
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	6a 69		 push	 105			; 00000069H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14263: 	pMsg.btMonsterSkillNumberH = SET_NUMBERH(iSkillNumber);

  00025	8b 45 10	 mov	 eax, DWORD PTR _iSkillNumber$[ebp]

; 14264: 	pMsg.btMonsterSkillNumberL = SET_NUMBERL(iSkillNumber);
; 14265: 	pMsg.wObjIndex = lpObj->m_Index;

  00028	66 8b 16	 mov	 dx, WORD PTR [esi]
  0002b	8b c8		 mov	 ecx, eax
  0002d	c1 e9 08	 shr	 ecx, 8
  00030	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 14266: 	pMsg.wTargetObjIndex = lpTargetObj->m_Index;

  00033	66 8b 07	 mov	 ax, WORD PTR [edi]
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14267: 
; 14268: 	if ( lpObj->Type == OBJ_USER )

  00039	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  0003e	88 4d f3	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00041	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00045	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  00049	75 14		 jne	 SHORT $LN1@GCUseMonst

; 14269: 	{
; 14270: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0004b	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	51		 push	 ecx
  00052	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00055	52		 push	 edx
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUseMonst:

; 14271: 	}
; 14272: 
; 14273: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  0005f	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00063	51		 push	 ecx
  00064	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00067	52		 push	 edx
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 14274: }

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	5f		 pop	 edi
  00075	33 cd		 xor	 ecx, ebp
  00077	5e		 pop	 esi
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ENDP	; GCUseMonsterSkillSend
_TEXT	ENDS
PUBLIC	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z	; GCStateInfoSend
; Function compile flags: /Ogtp
;	COMDAT ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_lpObj$ = 8						; size = 4
_state$ = 12						; size = 1
_btEffectIndex$ = 16					; size = 1
?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z PROC		; GCStateInfoSend, COMDAT

; 14286: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 14287: 	PMSG_VIEWSKILLSTATE pMsg;
; 14288: 
; 14289: 	BYTE loc3 = 0;
; 14290: 
; 14291: 	PHeadSetB((LPBYTE)&pMsg, 0x07, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000c	6a 07		 push	 7
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14292: 
; 14293: 	pMsg.State		= state;
; 14294: 
; 14295: 	pMsg.NumberH	= SET_NUMBERH(lpObj->m_Index);

  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8a 4d 0c	 mov	 cl, BYTE PTR _state$[ebp]
  0001c	8b d0		 mov	 edx, eax
  0001e	c1 ea 08	 shr	 edx, 8
  00021	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 14296: 	pMsg.NumberL	= SET_NUMBERL(lpObj->m_Index);

  00024	0f b6 c8	 movzx	 ecx, al
  00027	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 14297: 
; 14298: 	pMsg.BuffEffect = btEffectIndex;

  0002a	8a 55 10	 mov	 dl, BYTE PTR _btEffectIndex$[ebp]
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14299: 
; 14300: 	if( lpObj->Type == OBJ_USER )

  00030	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00035	88 4d fd	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  00038	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  0003b	75 12		 jne	 SHORT $LN2@GCStateInf

; 14301: 	{
; 14302: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0003d	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00041	51		 push	 ecx
  00042	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCStateInf:

; 14303: 	}
; 14304: 
; 14305: 	if( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  0004f	0f b6 86 49 01
	00 00		 movzx	 eax, BYTE PTR [esi+329]
  00056	3c 35		 cmp	 al, 53			; 00000035H
  00058	74 1f		 je	 SHORT $LN3@GCStateInf
  0005a	3c 12		 cmp	 al, 18			; 00000012H
  0005c	72 09		 jb	 SHORT $LN9@GCStateInf
  0005e	b1 17		 mov	 cl, 23			; 00000017H
  00060	3a c8		 cmp	 cl, al
  00062	1b c0		 sbb	 eax, eax
  00064	40		 inc	 eax
  00065	75 12		 jne	 SHORT $LN3@GCStateInf
$LN9@GCStateInf:

; 14306: 	{
; 14307: 		return;
; 14308: 	}
; 14309: 
; 14310: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00067	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0006b	52		 push	 edx
  0006c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006f	50		 push	 eax
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCStateInf:
  00079	5e		 pop	 esi

; 14311: }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ENDP		; GCStateInfoSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z	; GCTeleportSend
EXTRN	?TeleportMap@CMapQuest@@QAEXHH@Z:PROC		; CMapQuest::TeleportMap
EXTRN	?g_MapQuest@@3VCMapQuest@@A:BYTE		; g_MapQuest
; Function compile flags: /Ogtp
;	COMDAT ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MoveNumber$ = 12					; size = 4
_MapNumber$ = 16					; size = 1
_MapX$ = 20						; size = 1
_MapY$ = 24						; size = 1
_Dir$ = 28						; size = 1
?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z PROC	; GCTeleportSend, COMDAT

; 14628: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 14629: 	PMSG_TELEPORT_RESULT pMsg;
; 14630: 
; 14631: 	if ( lpObj->Type != OBJ_USER )

  00014	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00019	75 63		 jne	 SHORT $LN5@GCTeleport

; 14632: 	{
; 14633: 		return;
; 14634: 	}
; 14635: 
; 14636: 	if(MoveNumber > 0) //Season 2.5 add-on

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _MoveNumber$[ebp]
  0001e	85 c0		 test	 eax, eax
  00020	7e 05		 jle	 SHORT $LN3@GCTeleport

; 14637: 	{
; 14638: 		MoveNumber = 1;

  00022	b8 01 00 00 00	 mov	 eax, 1
$LN3@GCTeleport:

; 14639: 	}
; 14640: 
; 14641: 	pMsg.h.c = 0xC3;
; 14642: 	pMsg.h.size = sizeof(pMsg);
; 14643: 	pMsg.h.headcode = 0x1C;
; 14644: 	pMsg.MoveNumber = MoveNumber;
; 14645: 	pMsg.MapNumber = MapNumber;
; 14646: 	pMsg.MapX = MapX;

  00027	8a 4d 14	 mov	 cl, BYTE PTR _MapX$[ebp]

; 14647: 	pMsg.MapY = MapY;

  0002a	8a 55 18	 mov	 dl, BYTE PTR _MapY$[ebp]
  0002d	53		 push	 ebx
  0002e	8a 5d 10	 mov	 bl, BYTE PTR _MapNumber$[ebp]
  00031	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 14648: 	pMsg.Dir = Dir;

  00034	8a 4d 1c	 mov	 cl, BYTE PTR _Dir$[ebp]
  00037	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pMsg$[ebp], 2755 ; 00000ac3H
  0003d	c6 45 f2 1c	 mov	 BYTE PTR _pMsg$[ebp+2], 28 ; 0000001cH
  00041	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00045	88 5d f6	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  00048	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+8], dl
  0004b	88 4d f9	 mov	 BYTE PTR _pMsg$[ebp+9], cl

; 14649: 
; 14650: 	if ( MoveNumber == 0 )
; 14651: 	{
; 14652: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0004e	6a 0a		 push	 10			; 0000000aH
  00050	85 c0		 test	 eax, eax
  00052	75 09		 jne	 SHORT $LN2@GCTeleport
  00054	8b 06		 mov	 eax, DWORD PTR [esi]
  00056	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00059	52		 push	 edx
  0005a	50		 push	 eax

; 14653: 	}
; 14654: 	else

  0005b	eb 07		 jmp	 SHORT $LN7@GCTeleport
$LN2@GCTeleport:

; 14655: 	{
; 14656: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0005d	8b 16		 mov	 edx, DWORD PTR [esi]
  0005f	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00062	51		 push	 ecx
  00063	52		 push	 edx
$LN7@GCTeleport:
  00064	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14657: 	}
; 14658: 
; 14659: #if(CUSTOM_MAPQUEST)
; 14660: 	g_MapQuest.TeleportMap(lpObj->m_Index, MapNumber);

  00069	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006b	0f b6 c3	 movzx	 eax, bl
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	50		 push	 eax
  00072	51		 push	 ecx
  00073	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapQuest@@3VCMapQuest@@A ; g_MapQuest
  00078	e8 00 00 00 00	 call	 ?TeleportMap@CMapQuest@@QAEXHH@Z ; CMapQuest::TeleportMap
  0007d	5b		 pop	 ebx
$LN5@GCTeleport:

; 14661: #endif
; 14662: }

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	5e		 pop	 esi
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ENDP	; GCTeleportSend
_TEXT	ENDS
PUBLIC	??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@ ; `string'
PUBLIC	??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@ ; `string'
PUBLIC	??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@ ; `string'
PUBLIC	??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ ; `string'
PUBLIC	??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ ; `string'
PUBLIC	??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ ; `string'
PUBLIC	??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@ ; `string'
PUBLIC	??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGBeattackRecv@@YAXPAEHH@Z			; CGBeattackRecv
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?MLS_FireScream@CMasterLevelSkillTreeSystem@@QAEHHHPAVCMagicInf@@@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_FireScream
EXTRN	?MLS_MaGumSkillDefenseDown@CMasterLevelSkillTreeSystem@@QAEXHH@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDown
EXTRN	?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::SkillFireScream
EXTRN	?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z:PROC ; CObjUseSkill::MaGumSkillDefenseDown
EXTRN	?gWriteSkillLog@@3HA:DWORD			; gWriteSkillLog
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?bIsIgnorePacketSpeedHackDetect@@3HA:DWORD	; bIsIgnorePacketSpeedHackDetect
EXTRN	?gDetectedHackKickCount@@3HA:DWORD		; gDetectedHackKickCount
EXTRN	?gIsKickDetecHackCountLimit@@3HA:DWORD		; gIsKickDetecHackCountLimit
EXTRN	?gHackCheckCount@@3KA:DWORD			; gHackCheckCount
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z:PROC ; CMagicDamage::SkillGetRequireClass
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagic
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagicSearch
;	COMDAT ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@
; File e:\work\tranet_version\gs\gameserver\tdurmagickeychecker.h
CONST	SEGMENT
??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@ DB '['
	DB	'%s][%s] %s Detect Hack : Multi Attack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd?0@
CONST	SEGMENT
??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd?0@ DB 'M'
	DB	'agic Attack3 : %d, serial = %d, Tgt =  %d, cnt = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@
CONST	SEGMENT
??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid VailidCoun'
	DB	't = %d ( Count : %d) [%d][%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@
CONST	SEGMENT
??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid DurationTi'
	DB	'me Key = %d ( Time : %d) [%d][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
CONST	SEGMENT
??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ DB '['
	DB	'%s][%s] %s Apply Attack Speed Penalty (%d left)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
CONST	SEGMENT
??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
CONST	SEGMENT
??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ DB '['
	DB	'%s][%s] %s Kick DetecHackCountLimit Over User (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@
CONST	SEGMENT
??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@ DB 'Too long ti'
	DB	'me passed after casting magic. [%s][%s] (%d)(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 %s %d', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGBeattackRecv@@YAXPAEHH@Z
_TEXT	SEGMENT
tv1605 = -544						; size = 4
_n$249824 = -540					; size = 4
_aIndex$GSCopy$ = -536					; size = 4
tv2192 = -532						; size = 4
tv1289 = -528						; size = 4
_lpRecv$GSCopy$ = -524					; size = 4
_lpMagic$ = -520					; size = 4
_pTargetNumber$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_magic_send$ = 16					; size = 4
?CGBeattackRecv@@YAXPAEHH@Z PROC			; CGBeattackRecv, COMDAT

; 14665: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]

; 14666: 	PMSG_BEATTACK_COUNT * lpCount = (PMSG_BEATTACK_COUNT *)lpRecv;
; 14667: 
; 14668: 	if ( lpCount->h.headcode != PROTOCOL_BEATTACK )

  00016	80 79 02 db	 cmp	 BYTE PTR [ecx+2], 219	; 000000dbH
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 15089: 		{
; 15090: 			continue;
; 15091: 		}
; 15092: 
; 15093: 		#if(FIX_OBJECT_VIEWE)
; 15094: 		g_ObjectViewe.GCIndexLive(aIndex, tNumber, gObj[tNumber].Type, gObj[tNumber].Live);
; 15095: 		#endif
; 15096: 
; 15097: 		int DistanceCheck = gObjCalDistance(lpObj, &gObj[tNumber]);

  0001e	89 8d f4 fd ff
	ff		 mov	 DWORD PTR _lpRecv$GSCopy$[ebp], ecx
  00024	89 b5 e8 fd ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002a	74 27		 je	 SHORT $LN70@CGBeattack

; 14669: 	{
; 14670: 		LogAdd("error-L3 %s %d", 
; 14671: 			__FILE__, 
; 14672: 			__LINE__);

  0002c	68 50 39 00 00	 push	 14672			; 00003950H
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	5e		 pop	 esi

; 15192: 	}
; 15193: }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN70@CGBeattack:

; 14673: 		return;
; 14674: 	}
; 14675: 
; 14676: 	if ( lpCount->Count < 1 )

  00053	8a 41 08	 mov	 al, BYTE PTR [ecx+8]
  00056	53		 push	 ebx
  00057	bb 01 00 00 00	 mov	 ebx, 1
  0005c	3a c3		 cmp	 al, bl
  0005e	73 28		 jae	 SHORT $LN69@CGBeattack

; 14677: 	{
; 14678: 		LogAdd("error-L3 %s %d", 
; 14679: 			__FILE__, 
; 14680: 			__LINE__);

  00060	68 58 39 00 00	 push	 14680			; 00003958H
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	5b		 pop	 ebx
  00079	5e		 pop	 esi

; 15192: 	}
; 15193: }

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	33 cd		 xor	 ecx, ebp
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN69@CGBeattack:

; 14681: 		return;
; 14682: 	}
; 14683: 
; 14684: 	if ( lpCount->Count > 5 )

  00088	3c 05		 cmp	 al, 5
  0008a	76 04		 jbe	 SHORT $LN68@CGBeattack

; 14685: 	{
; 14686: 		lpCount->Count = 5;

  0008c	c6 41 08 05	 mov	 BYTE PTR [ecx+8], 5
$LN68@CGBeattack:

; 14687: 	}
; 14688: 
; 14689: 	int lOfs = sizeof(PMSG_BEATTACK_COUNT);
; 14690: 
; 14691: 	CMagicInf * lpMagic;
; 14692: 
; 14693: 	int tNumber;
; 14694: 
; 14695: 	PMSG_BEATTACK * lpMsg;
; 14696: 
; 14697: 	if ( gObj[aIndex].Type == OBJ_USER )

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00095	57		 push	 edi
  00096	8b fe		 mov	 edi, esi
  00098	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0009e	03 c7		 add	 eax, edi
  000a0	89 bd f0 fd ff
	ff		 mov	 DWORD PTR tv1289[ebp], edi
  000a6	66 39 58 68	 cmp	 WORD PTR [eax+104], bx
  000aa	0f 85 87 00 00
	00		 jne	 $LN67@CGBeattack

; 14698: 	{
; 14699: 		//season 4.5 add-on start
; 14700: 		BYTE attr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 14701: 
; 14702: 		if ( (attr&1) == 1 ) //safezone

  000b0	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  000b7	0f bf 90 44 01
	00 00		 movsx	 edx, WORD PTR [eax+324]
  000be	51		 push	 ecx
  000bf	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  000c6	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  000cc	52		 push	 edx
  000cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000d3	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000d8	a8 01		 test	 al, 1
  000da	74 31		 je	 SHORT $LN66@CGBeattack

; 14703: 		{
; 14704: 			gObjSetPosition(aIndex,gObj[aIndex].X, gObj[aIndex].Y);

  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e1	0f bf 8c 07 46
	01 00 00	 movsx	 ecx, WORD PTR [edi+eax+326]
  000e9	0f bf 94 07 44
	01 00 00	 movsx	 edx, WORD PTR [edi+eax+324]
  000f1	51		 push	 ecx
  000f2	52		 push	 edx
  000f3	56		 push	 esi
  000f4	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 14926: 		{
; 14927: 			LogAdd("error-L3 %s %d", 
; 14928: 				__FILE__, 
; 14929: 				__LINE__);

  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	5f		 pop	 edi
  000fd	5b		 pop	 ebx
  000fe	5e		 pop	 esi

; 15192: 	}
; 15193: }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN66@CGBeattack:

; 14705: 			return;
; 14706: 		}
; 14707: 		//season 4.5 add-on end
; 14708: 
; 14709: 		WORD MagicNumber = MAKE_NUMBERW(lpCount->MagicNumberH, lpCount->MagicNumberL);

  0010d	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
  00113	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00117	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0011b	66 c1 e1 08	 shl	 cx, 8
  0011f	66 0b ca	 or	 cx, dx
  00122	0f b7 c1	 movzx	 eax, cx

; 14710: 
; 14711: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], MagicNumber);

  00125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012b	50		 push	 eax
  0012c	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 14712: 	}
; 14713: 	else

  00135	eb 19		 jmp	 SHORT $LN104@CGBeattack
$LN67@CGBeattack:

; 14714: 	{
; 14715: 		//
; 14716: 		WORD MagicNumber = MAKE_NUMBERW(lpCount->MagicNumberH, lpCount->MagicNumberL);

  00137	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0013b	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  0013f	66 c1 e2 08	 shl	 dx, 8
  00143	66 0b d1	 or	 dx, cx
  00146	0f b7 d2	 movzx	 edx, dx

; 14717: 
; 14718: 		lpMagic = gObjGetMagic(&gObj[aIndex], MagicNumber);

  00149	52		 push	 edx
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
$LN104@CGBeattack:
  00150	83 c4 08	 add	 esp, 8
  00153	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _lpMagic$[ebp], eax

; 14719: 	}
; 14720: 
; 14721: 	if ( lpMagic == NULL )

  00159	85 c0		 test	 eax, eax
  0015b	0f 84 66 0e 00
	00		 je	 $LN103@CGBeattack

; 14722: 	{
; 14723: 		//LogAdd("error-L3 %s %d", 
; 14724: 		//	__FILE__, 
; 14725: 		//	__LINE__);
; 14726: 		return;
; 14727: 	}
; 14728: 
; 14729: 	if ( lpMagic->m_Skill == 42 || 
; 14730: 		lpMagic->m_Skill == 43 || 
; 14731: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 336 || //s4
; 14732: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 331 || //s4
; 14733: 		lpMagic->m_Skill == 41 || 
; 14734: 		lpMagic->m_Skill == 333 ||
; 14735: 		lpMagic->m_Skill == 332 ||
; 14736: 		lpMagic->m_Skill == 330 )	//1.01.00

  00161	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00164	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00167	0f 84 5a 0e 00
	00		 je	 $LN103@CGBeattack
  0016d	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00170	0f 84 51 0e 00
	00		 je	 $LN103@CGBeattack
  00176	50		 push	 eax
  00177	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0017c	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00181	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  00186	0f 84 3b 0e 00
	00		 je	 $LN103@CGBeattack
  0018c	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00192	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00195	51		 push	 ecx
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0019b	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  001a0	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  001a5	0f 84 1c 0e 00
	00		 je	 $LN103@CGBeattack
  001ab	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpMagic$[ebp]
  001b1	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  001b4	83 f9 29	 cmp	 ecx, 41			; 00000029H
  001b7	0f 84 0a 0e 00
	00		 je	 $LN103@CGBeattack
  001bd	81 f9 4d 01 00
	00		 cmp	 ecx, 333		; 0000014dH
  001c3	0f 84 fe 0d 00
	00		 je	 $LN103@CGBeattack
  001c9	81 f9 4c 01 00
	00		 cmp	 ecx, 332		; 0000014cH
  001cf	0f 84 f2 0d 00
	00		 je	 $LN103@CGBeattack
  001d5	81 f9 4a 01 00
	00		 cmp	 ecx, 330		; 0000014aH
  001db	0f 84 e6 0d 00
	00		 je	 $LN103@CGBeattack

; 14737: 	{
; 14738: 		return;
; 14739: 	}
; 14740: 
; 14741: 	if ( gObj[aIndex].Type == OBJ_USER )

  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e6	66 39 5c 07 68	 cmp	 WORD PTR [edi+eax+104], bx
  001eb	0f 85 e5 00 00
	00		 jne	 $LN98@CGBeattack

; 14742: 	{
; 14743: 		if ( MagicDamageC.SkillGetRequireClass(
; 14744: 			gObj[aIndex].Class, 
; 14745: 			gObj[aIndex].ChangeUP, 
; 14746: 			gObj[aIndex].ChangeUP3rd, 
; 14747: 			lpMagic->m_Skill) < 1 )

  001f1	0f b6 94 07 bb
	00 00 00	 movzx	 edx, BYTE PTR [edi+eax+187]
  001f9	51		 push	 ecx
  001fa	0f b6 8c 07 bc
	00 00 00	 movzx	 ecx, BYTE PTR [edi+eax+188]
  00202	0f b7 84 07 b8
	00 00 00	 movzx	 eax, WORD PTR [edi+eax+184]
  0020a	51		 push	 ecx
  0020b	52		 push	 edx
  0020c	50		 push	 eax
  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00212	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00217	3b c3		 cmp	 eax, ebx

; 14748: 		{
; 14749: 			LogAddC(2, lMsg.Get(MSGGET(1, 239)), 
; 14750: 				gObj[aIndex].AccountID, 
; 14751: 				gObj[aIndex].Name, 
; 14752: 				lpMagic->m_Skill);

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021e	7d 46		 jge	 SHORT $LN60@CGBeattack
  00220	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  00226	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00229	52		 push	 edx
  0022a	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  0022e	51		 push	 ecx
  0022f	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  00233	52		 push	 edx
  00234	68 ef 01 00 00	 push	 495			; 000001efH
  00239	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0023e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00243	50		 push	 eax
  00244	6a 02		 push	 2
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 14753: 			gObjUserKill(aIndex);

  0024c	56		 push	 esi
  0024d	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  00252	83 c4 18	 add	 esp, 24			; 00000018H
  00255	5f		 pop	 edi
  00256	5b		 pop	 ebx
  00257	5e		 pop	 esi

; 15192: 	}
; 15193: }

  00258	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025b	33 cd		 xor	 ecx, ebp
  0025d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c3		 ret	 0
$LN60@CGBeattack:

; 14754: 			return;
; 14755: 		}
; 14756: 
; 14757: 		if ( (GetTickCount()- gObj[aIndex].UseMagicTime) > 8000 )

  00266	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0026c	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]
  0026f	ff d3		 call	 ebx
  00271	2b 86 d0 04 00
	00		 sub	 eax, DWORD PTR [esi+1232]
  00277	3d 40 1f 00 00	 cmp	 eax, 8000		; 00001f40H
  0027c	76 45		 jbe	 SHORT $LN59@CGBeattack

; 14758: 		{
; 14759: 			LogAddC(2, "Too long time passed after casting magic. [%s][%s] (%d)(%d)", 
; 14760: 				gObj[aIndex].AccountID, 
; 14761: 				gObj[aIndex].Name, 
; 14762: 				lpMagic->m_Skill, 
; 14763: 				GetTickCount() - gObj[aIndex].UseMagicTime);

  0027e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00284	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]
  00287	ff d3		 call	 ebx
  00289	2b 86 d0 04 00
	00		 sub	 eax, DWORD PTR [esi+1232]
  0028f	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpMagic$[ebp]
  00295	50		 push	 eax
  00296	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00299	50		 push	 eax
  0029a	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0029d	51		 push	 ecx
  0029e	83 c6 6c	 add	 esi, 108		; 0000006cH
  002a1	56		 push	 esi
  002a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@
  002a7	6a 02		 push	 2
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002af	83 c4 18	 add	 esp, 24			; 00000018H
  002b2	5f		 pop	 edi
  002b3	5b		 pop	 ebx
  002b4	5e		 pop	 esi

; 15192: 	}
; 15193: }

  002b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b8	33 cd		 xor	 ecx, ebp
  002ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
$LN59@CGBeattack:

; 14764: 			return;
; 14765: 		}
; 14766: 
; 14767: 		if ( gObj[aIndex].UseMagicCount > 4 )

  002c3	80 be d4 04 00
	00 04		 cmp	 BYTE PTR [esi+1236], 4
  002ca	0f 8f f7 0c 00
	00		 jg	 $LN103@CGBeattack

; 14768: 		{
; 14769: 			return;
; 14770: 		}
; 14771: 
; 14772: 		gObj[aIndex].UseMagicCount++;

  002d0	fe 86 d4 04 00
	00		 inc	 BYTE PTR [esi+1236]
$LN98@CGBeattack:

; 14773: 	}
; 14774: 
; 14775: 	if(g_MasterSkillSystem.CheckRequireStatus(lpMagic->m_Skill) != FALSE) //Season3 add-on

  002d6	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR _lpMagic$[ebp]
  002dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  002df	52		 push	 edx
  002e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  002e5	e8 00 00 00 00	 call	 ?CheckRequireStatus@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckRequireStatus
  002ea	85 c0		 test	 eax, eax

; 14776: 	{
; 14777: 		int GetBaseMasterLevelSkill = g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill);

  002ec	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002ef	0f 84 66 05 00
	00		 je	 $LN57@CGBeattack
  002f5	50		 push	 eax
  002f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  002fb	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 14778: 
; 14779: 		if(	   GetBaseMasterLevelSkill != 403
; 14780: 			&& GetBaseMasterLevelSkill != 388
; 14781: 			&& GetBaseMasterLevelSkill != 330
; 14782: 			&& GetBaseMasterLevelSkill != 413
; 14783: 			&& GetBaseMasterLevelSkill != 414
; 14784: 			&& GetBaseMasterLevelSkill != 481
; 14785: 			&& GetBaseMasterLevelSkill != 356
; 14786: 			&& GetBaseMasterLevelSkill != 382
; 14787: 			&& GetBaseMasterLevelSkill != 512
; 14788: 			&& GetBaseMasterLevelSkill != 508
; 14789: 			&& GetBaseMasterLevelSkill != 385
; 14790: 			&& GetBaseMasterLevelSkill != 391
; 14791: 			&& GetBaseMasterLevelSkill != 336
; 14792: 			&& GetBaseMasterLevelSkill != 331
; 14793: 			&& GetBaseMasterLevelSkill != 417
; 14794: 			&& GetBaseMasterLevelSkill != 420
; 14795: 			&& GetBaseMasterLevelSkill != 490
; 14796: 			&& GetBaseMasterLevelSkill != 482
; 14797: 			&& GetBaseMasterLevelSkill != 518
; 14798: 			&& GetBaseMasterLevelSkill != 487
; 14799: 			&& GetBaseMasterLevelSkill != 326
; 14800: 			&& GetBaseMasterLevelSkill != 327
; 14801: 			&& GetBaseMasterLevelSkill != 328
; 14802: 			&& GetBaseMasterLevelSkill != 329
; 14803: 			&& GetBaseMasterLevelSkill != 332
; 14804: 			&& GetBaseMasterLevelSkill != 333
; 14805: 			&& GetBaseMasterLevelSkill != 337
; 14806: 			&& GetBaseMasterLevelSkill != 339
; 14807: 			&& GetBaseMasterLevelSkill != 340
; 14808: 			&& GetBaseMasterLevelSkill != 342
; 14809: 			&& GetBaseMasterLevelSkill != 343
; 14810: 			&& GetBaseMasterLevelSkill != 344
; 14811: 			&& GetBaseMasterLevelSkill != 346
; 14812: 			&& GetBaseMasterLevelSkill != 360
; 14813: 			&& GetBaseMasterLevelSkill != 363
; 14814: 			&& GetBaseMasterLevelSkill != 376
; 14815: 			&& GetBaseMasterLevelSkill != 378
; 14816: 			&& GetBaseMasterLevelSkill != 379
; 14817: 			&& GetBaseMasterLevelSkill != 380
; 14818: 			&& GetBaseMasterLevelSkill != 381
; 14819: 			&& GetBaseMasterLevelSkill != 383
; 14820: 			&& GetBaseMasterLevelSkill != 384
; 14821: 			&& GetBaseMasterLevelSkill != 386
; 14822: 			&& GetBaseMasterLevelSkill != 387
; 14823: 			&& GetBaseMasterLevelSkill != 389
; 14824: 			&& GetBaseMasterLevelSkill != 390
; 14825: 			&& GetBaseMasterLevelSkill != 392
; 14826: 			&& GetBaseMasterLevelSkill != 393
; 14827: 			&& GetBaseMasterLevelSkill != 394
; 14828: 			&& GetBaseMasterLevelSkill != 395
; 14829: 			&& GetBaseMasterLevelSkill != 396
; 14830: 			&& GetBaseMasterLevelSkill != 404
; 14831: 			&& GetBaseMasterLevelSkill != 406
; 14832: 			&& GetBaseMasterLevelSkill != 411
; 14833: 			&& GetBaseMasterLevelSkill != 415
; 14834: 			&& GetBaseMasterLevelSkill != 416
; 14835: 			&& GetBaseMasterLevelSkill != 418
; 14836: 			&& GetBaseMasterLevelSkill != 419
; 14837: 			&& GetBaseMasterLevelSkill != 425
; 14838: 			&& GetBaseMasterLevelSkill != 426
; 14839: 			&& GetBaseMasterLevelSkill != 427
; 14840: 			&& GetBaseMasterLevelSkill != 428
; 14841: 			&& GetBaseMasterLevelSkill != 429
; 14842: 			&& GetBaseMasterLevelSkill != 430
; 14843: 			&& GetBaseMasterLevelSkill != 431
; 14844: 			&& GetBaseMasterLevelSkill != 432
; 14845: 			&& GetBaseMasterLevelSkill != 433
; 14846: 			&& GetBaseMasterLevelSkill != 434
; 14847: 			&& GetBaseMasterLevelSkill != 441
; 14848: 			&& GetBaseMasterLevelSkill != 459
; 14849: 			&& GetBaseMasterLevelSkill != 460
; 14850: 			&& GetBaseMasterLevelSkill != 461
; 14851: 			&& GetBaseMasterLevelSkill != 462
; 14852: 			&& GetBaseMasterLevelSkill != 466
; 14853: 			&& GetBaseMasterLevelSkill != 468
; 14854: 			&& GetBaseMasterLevelSkill != 469
; 14855: 			&& GetBaseMasterLevelSkill != 470
; 14856: 			&& GetBaseMasterLevelSkill != 472
; 14857: 			&& GetBaseMasterLevelSkill != 477
; 14858: 			&& GetBaseMasterLevelSkill != 479
; 14859: 			&& GetBaseMasterLevelSkill != 480
; 14860: 			&& GetBaseMasterLevelSkill != 483
; 14861: 			&& GetBaseMasterLevelSkill != 484
; 14862: 			&& GetBaseMasterLevelSkill != 486
; 14863: 			&& GetBaseMasterLevelSkill != 488
; 14864: 			&& GetBaseMasterLevelSkill != 489
; 14865: 			&& GetBaseMasterLevelSkill != 491
; 14866: 			&& GetBaseMasterLevelSkill != 492
; 14867: 			&& GetBaseMasterLevelSkill != 493
; 14868: 			&& GetBaseMasterLevelSkill != 494
; 14869: 			&& GetBaseMasterLevelSkill != 495
; 14870: 			&& GetBaseMasterLevelSkill != 497
; 14871: 			&& GetBaseMasterLevelSkill != 498
; 14872: 			&& GetBaseMasterLevelSkill != 499
; 14873: 			&& GetBaseMasterLevelSkill != 500
; 14874: 			&& GetBaseMasterLevelSkill != 501
; 14875: 			&& GetBaseMasterLevelSkill != 502
; 14876: 			&& GetBaseMasterLevelSkill != 509
; 14877: 			&& GetBaseMasterLevelSkill != 510
; 14878: 			&& GetBaseMasterLevelSkill != 514
; 14879: 			&& GetBaseMasterLevelSkill != 515
; 14880: 			&& GetBaseMasterLevelSkill != 516
; 14881: 			&& GetBaseMasterLevelSkill != 519
; 14882: 			&& GetBaseMasterLevelSkill != 520
; 14883: 			&& GetBaseMasterLevelSkill != 521
; 14884: 			&& GetBaseMasterLevelSkill != 523
; 14885: 			&& GetBaseMasterLevelSkill != 539
; 14886: 			&& GetBaseMasterLevelSkill != 551
; 14887: 			&& GetBaseMasterLevelSkill != 552
; 14888: 			&& GetBaseMasterLevelSkill != 554
; 14889: 			&& GetBaseMasterLevelSkill != 555
; 14890: 			&& GetBaseMasterLevelSkill != 556
; 14891: 			&& GetBaseMasterLevelSkill != 558
; 14892: 			&& GetBaseMasterLevelSkill != 559
; 14893: 			&& GetBaseMasterLevelSkill != 560
; 14894: 			&& GetBaseMasterLevelSkill != 561
; 14895: 			&& GetBaseMasterLevelSkill != 562
; 14896: 			&& GetBaseMasterLevelSkill != 563
; 14897: 			&& GetBaseMasterLevelSkill != 564
; 14898: 			&& GetBaseMasterLevelSkill != 565
; 14899: 			&& GetBaseMasterLevelSkill != 566
; 14900: 			&& GetBaseMasterLevelSkill != 567
; 14901: 			&& GetBaseMasterLevelSkill != 575
; 14902: 			&& GetBaseMasterLevelSkill != 577 )

  00300	3d 93 01 00 00	 cmp	 eax, 403		; 00000193H
  00305	0f 84 c9 05 00
	00		 je	 $LN93@CGBeattack
  0030b	3d 84 01 00 00	 cmp	 eax, 388		; 00000184H
  00310	0f 84 be 05 00
	00		 je	 $LN93@CGBeattack
  00316	3d 4a 01 00 00	 cmp	 eax, 330		; 0000014aH
  0031b	0f 84 b3 05 00
	00		 je	 $LN93@CGBeattack
  00321	3d 9d 01 00 00	 cmp	 eax, 413		; 0000019dH
  00326	0f 84 a8 05 00
	00		 je	 $LN93@CGBeattack
  0032c	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  00331	0f 84 9d 05 00
	00		 je	 $LN93@CGBeattack
  00337	3d e1 01 00 00	 cmp	 eax, 481		; 000001e1H
  0033c	0f 84 92 05 00
	00		 je	 $LN93@CGBeattack
  00342	3d 64 01 00 00	 cmp	 eax, 356		; 00000164H
  00347	0f 84 87 05 00
	00		 je	 $LN93@CGBeattack
  0034d	3d 7e 01 00 00	 cmp	 eax, 382		; 0000017eH
  00352	0f 84 7c 05 00
	00		 je	 $LN93@CGBeattack
  00358	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0035d	0f 84 71 05 00
	00		 je	 $LN93@CGBeattack
  00363	3d fc 01 00 00	 cmp	 eax, 508		; 000001fcH
  00368	0f 84 66 05 00
	00		 je	 $LN93@CGBeattack
  0036e	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  00373	0f 84 5b 05 00
	00		 je	 $LN93@CGBeattack
  00379	3d 87 01 00 00	 cmp	 eax, 391		; 00000187H
  0037e	0f 84 50 05 00
	00		 je	 $LN93@CGBeattack
  00384	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  00389	0f 84 45 05 00
	00		 je	 $LN93@CGBeattack
  0038f	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  00394	0f 84 3a 05 00
	00		 je	 $LN93@CGBeattack
  0039a	3d a1 01 00 00	 cmp	 eax, 417		; 000001a1H
  0039f	0f 84 2f 05 00
	00		 je	 $LN93@CGBeattack
  003a5	3d a4 01 00 00	 cmp	 eax, 420		; 000001a4H
  003aa	0f 84 24 05 00
	00		 je	 $LN93@CGBeattack
  003b0	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  003b5	0f 84 19 05 00
	00		 je	 $LN93@CGBeattack
  003bb	3d e2 01 00 00	 cmp	 eax, 482		; 000001e2H
  003c0	0f 84 0e 05 00
	00		 je	 $LN93@CGBeattack
  003c6	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  003cb	0f 84 03 05 00
	00		 je	 $LN93@CGBeattack
  003d1	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  003d6	0f 84 f8 04 00
	00		 je	 $LN93@CGBeattack
  003dc	3d 46 01 00 00	 cmp	 eax, 326		; 00000146H
  003e1	0f 84 ed 04 00
	00		 je	 $LN93@CGBeattack
  003e7	3d 47 01 00 00	 cmp	 eax, 327		; 00000147H
  003ec	0f 84 e2 04 00
	00		 je	 $LN93@CGBeattack
  003f2	3d 48 01 00 00	 cmp	 eax, 328		; 00000148H
  003f7	0f 84 d7 04 00
	00		 je	 $LN93@CGBeattack
  003fd	3d 49 01 00 00	 cmp	 eax, 329		; 00000149H
  00402	0f 84 cc 04 00
	00		 je	 $LN93@CGBeattack
  00408	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  0040d	0f 84 c1 04 00
	00		 je	 $LN93@CGBeattack
  00413	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  00418	0f 84 b6 04 00
	00		 je	 $LN93@CGBeattack
  0041e	3d 51 01 00 00	 cmp	 eax, 337		; 00000151H
  00423	0f 84 ab 04 00
	00		 je	 $LN93@CGBeattack
  00429	3d 53 01 00 00	 cmp	 eax, 339		; 00000153H
  0042e	0f 84 a0 04 00
	00		 je	 $LN93@CGBeattack
  00434	3d 54 01 00 00	 cmp	 eax, 340		; 00000154H
  00439	0f 84 95 04 00
	00		 je	 $LN93@CGBeattack
  0043f	3d 56 01 00 00	 cmp	 eax, 342		; 00000156H
  00444	0f 84 8a 04 00
	00		 je	 $LN93@CGBeattack
  0044a	3d 57 01 00 00	 cmp	 eax, 343		; 00000157H
  0044f	0f 84 7f 04 00
	00		 je	 $LN93@CGBeattack
  00455	3d 58 01 00 00	 cmp	 eax, 344		; 00000158H
  0045a	0f 84 74 04 00
	00		 je	 $LN93@CGBeattack
  00460	3d 5a 01 00 00	 cmp	 eax, 346		; 0000015aH
  00465	0f 84 69 04 00
	00		 je	 $LN93@CGBeattack
  0046b	3d 68 01 00 00	 cmp	 eax, 360		; 00000168H
  00470	0f 84 5e 04 00
	00		 je	 $LN93@CGBeattack
  00476	3d 6b 01 00 00	 cmp	 eax, 363		; 0000016bH
  0047b	0f 84 53 04 00
	00		 je	 $LN93@CGBeattack
  00481	3d 78 01 00 00	 cmp	 eax, 376		; 00000178H
  00486	0f 84 48 04 00
	00		 je	 $LN93@CGBeattack
  0048c	3d 7a 01 00 00	 cmp	 eax, 378		; 0000017aH
  00491	0f 84 3d 04 00
	00		 je	 $LN93@CGBeattack
  00497	3d 7b 01 00 00	 cmp	 eax, 379		; 0000017bH
  0049c	0f 84 32 04 00
	00		 je	 $LN93@CGBeattack
  004a2	3d 7c 01 00 00	 cmp	 eax, 380		; 0000017cH
  004a7	0f 84 27 04 00
	00		 je	 $LN93@CGBeattack
  004ad	3d 7d 01 00 00	 cmp	 eax, 381		; 0000017dH
  004b2	0f 84 1c 04 00
	00		 je	 $LN93@CGBeattack
  004b8	3d 7f 01 00 00	 cmp	 eax, 383		; 0000017fH
  004bd	0f 84 11 04 00
	00		 je	 $LN93@CGBeattack
  004c3	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  004c8	0f 84 06 04 00
	00		 je	 $LN93@CGBeattack
  004ce	3d 82 01 00 00	 cmp	 eax, 386		; 00000182H
  004d3	0f 84 fb 03 00
	00		 je	 $LN93@CGBeattack
  004d9	3d 83 01 00 00	 cmp	 eax, 387		; 00000183H
  004de	0f 84 f0 03 00
	00		 je	 $LN93@CGBeattack
  004e4	3d 85 01 00 00	 cmp	 eax, 389		; 00000185H
  004e9	0f 84 e5 03 00
	00		 je	 $LN93@CGBeattack
  004ef	3d 86 01 00 00	 cmp	 eax, 390		; 00000186H
  004f4	0f 84 da 03 00
	00		 je	 $LN93@CGBeattack
  004fa	3d 88 01 00 00	 cmp	 eax, 392		; 00000188H
  004ff	0f 84 cf 03 00
	00		 je	 $LN93@CGBeattack
  00505	3d 89 01 00 00	 cmp	 eax, 393		; 00000189H
  0050a	0f 84 c4 03 00
	00		 je	 $LN93@CGBeattack
  00510	3d 8a 01 00 00	 cmp	 eax, 394		; 0000018aH
  00515	0f 84 b9 03 00
	00		 je	 $LN93@CGBeattack
  0051b	3d 8b 01 00 00	 cmp	 eax, 395		; 0000018bH
  00520	0f 84 ae 03 00
	00		 je	 $LN93@CGBeattack
  00526	3d 8c 01 00 00	 cmp	 eax, 396		; 0000018cH
  0052b	0f 84 a3 03 00
	00		 je	 $LN93@CGBeattack
  00531	3d 94 01 00 00	 cmp	 eax, 404		; 00000194H
  00536	0f 84 98 03 00
	00		 je	 $LN93@CGBeattack
  0053c	3d 96 01 00 00	 cmp	 eax, 406		; 00000196H
  00541	0f 84 8d 03 00
	00		 je	 $LN93@CGBeattack
  00547	3d 9b 01 00 00	 cmp	 eax, 411		; 0000019bH
  0054c	0f 84 82 03 00
	00		 je	 $LN93@CGBeattack
  00552	3d 9f 01 00 00	 cmp	 eax, 415		; 0000019fH
  00557	0f 84 77 03 00
	00		 je	 $LN93@CGBeattack
  0055d	3d a0 01 00 00	 cmp	 eax, 416		; 000001a0H
  00562	0f 84 6c 03 00
	00		 je	 $LN93@CGBeattack
  00568	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  0056d	0f 84 61 03 00
	00		 je	 $LN93@CGBeattack
  00573	3d a3 01 00 00	 cmp	 eax, 419		; 000001a3H
  00578	0f 84 56 03 00
	00		 je	 $LN93@CGBeattack
  0057e	3d a9 01 00 00	 cmp	 eax, 425		; 000001a9H
  00583	0f 84 4b 03 00
	00		 je	 $LN93@CGBeattack
  00589	3d aa 01 00 00	 cmp	 eax, 426		; 000001aaH
  0058e	0f 84 40 03 00
	00		 je	 $LN93@CGBeattack
  00594	3d ab 01 00 00	 cmp	 eax, 427		; 000001abH
  00599	0f 84 35 03 00
	00		 je	 $LN93@CGBeattack
  0059f	3d ac 01 00 00	 cmp	 eax, 428		; 000001acH
  005a4	0f 84 2a 03 00
	00		 je	 $LN93@CGBeattack
  005aa	3d ad 01 00 00	 cmp	 eax, 429		; 000001adH
  005af	0f 84 1f 03 00
	00		 je	 $LN93@CGBeattack
  005b5	3d ae 01 00 00	 cmp	 eax, 430		; 000001aeH
  005ba	0f 84 14 03 00
	00		 je	 $LN93@CGBeattack
  005c0	3d af 01 00 00	 cmp	 eax, 431		; 000001afH
  005c5	0f 84 09 03 00
	00		 je	 $LN93@CGBeattack
  005cb	3d b0 01 00 00	 cmp	 eax, 432		; 000001b0H
  005d0	0f 84 fe 02 00
	00		 je	 $LN93@CGBeattack
  005d6	3d b1 01 00 00	 cmp	 eax, 433		; 000001b1H
  005db	0f 84 f3 02 00
	00		 je	 $LN93@CGBeattack
  005e1	3d b2 01 00 00	 cmp	 eax, 434		; 000001b2H
  005e6	0f 84 e8 02 00
	00		 je	 $LN93@CGBeattack
  005ec	3d b9 01 00 00	 cmp	 eax, 441		; 000001b9H
  005f1	0f 84 dd 02 00
	00		 je	 $LN93@CGBeattack
  005f7	3d cb 01 00 00	 cmp	 eax, 459		; 000001cbH
  005fc	0f 84 d2 02 00
	00		 je	 $LN93@CGBeattack
  00602	3d cc 01 00 00	 cmp	 eax, 460		; 000001ccH
  00607	0f 84 c7 02 00
	00		 je	 $LN93@CGBeattack
  0060d	3d cd 01 00 00	 cmp	 eax, 461		; 000001cdH
  00612	0f 84 bc 02 00
	00		 je	 $LN93@CGBeattack
  00618	3d ce 01 00 00	 cmp	 eax, 462		; 000001ceH
  0061d	0f 84 b1 02 00
	00		 je	 $LN93@CGBeattack
  00623	3d d2 01 00 00	 cmp	 eax, 466		; 000001d2H
  00628	0f 84 a6 02 00
	00		 je	 $LN93@CGBeattack
  0062e	3d d4 01 00 00	 cmp	 eax, 468		; 000001d4H
  00633	0f 84 9b 02 00
	00		 je	 $LN93@CGBeattack
  00639	3d d5 01 00 00	 cmp	 eax, 469		; 000001d5H
  0063e	0f 84 90 02 00
	00		 je	 $LN93@CGBeattack
  00644	3d d6 01 00 00	 cmp	 eax, 470		; 000001d6H
  00649	0f 84 85 02 00
	00		 je	 $LN93@CGBeattack
  0064f	3d d8 01 00 00	 cmp	 eax, 472		; 000001d8H
  00654	0f 84 7a 02 00
	00		 je	 $LN93@CGBeattack
  0065a	3d dd 01 00 00	 cmp	 eax, 477		; 000001ddH
  0065f	0f 84 6f 02 00
	00		 je	 $LN93@CGBeattack
  00665	3d df 01 00 00	 cmp	 eax, 479		; 000001dfH
  0066a	0f 84 64 02 00
	00		 je	 $LN93@CGBeattack
  00670	3d e0 01 00 00	 cmp	 eax, 480		; 000001e0H
  00675	0f 84 59 02 00
	00		 je	 $LN93@CGBeattack
  0067b	3d e3 01 00 00	 cmp	 eax, 483		; 000001e3H
  00680	0f 84 4e 02 00
	00		 je	 $LN93@CGBeattack
  00686	3d e4 01 00 00	 cmp	 eax, 484		; 000001e4H
  0068b	0f 84 43 02 00
	00		 je	 $LN93@CGBeattack
  00691	3d e6 01 00 00	 cmp	 eax, 486		; 000001e6H
  00696	0f 84 38 02 00
	00		 je	 $LN93@CGBeattack
  0069c	3d e8 01 00 00	 cmp	 eax, 488		; 000001e8H
  006a1	0f 84 2d 02 00
	00		 je	 $LN93@CGBeattack
  006a7	3d e9 01 00 00	 cmp	 eax, 489		; 000001e9H
  006ac	0f 84 22 02 00
	00		 je	 $LN93@CGBeattack
  006b2	3d eb 01 00 00	 cmp	 eax, 491		; 000001ebH
  006b7	0f 84 17 02 00
	00		 je	 $LN93@CGBeattack
  006bd	3d ec 01 00 00	 cmp	 eax, 492		; 000001ecH
  006c2	0f 84 0c 02 00
	00		 je	 $LN93@CGBeattack
  006c8	3d ed 01 00 00	 cmp	 eax, 493		; 000001edH
  006cd	0f 84 01 02 00
	00		 je	 $LN93@CGBeattack
  006d3	3d ee 01 00 00	 cmp	 eax, 494		; 000001eeH
  006d8	0f 84 f6 01 00
	00		 je	 $LN93@CGBeattack
  006de	3d ef 01 00 00	 cmp	 eax, 495		; 000001efH
  006e3	0f 84 eb 01 00
	00		 je	 $LN93@CGBeattack
  006e9	3d f1 01 00 00	 cmp	 eax, 497		; 000001f1H
  006ee	0f 84 e0 01 00
	00		 je	 $LN93@CGBeattack
  006f4	3d f2 01 00 00	 cmp	 eax, 498		; 000001f2H
  006f9	0f 84 d5 01 00
	00		 je	 $LN93@CGBeattack
  006ff	3d f3 01 00 00	 cmp	 eax, 499		; 000001f3H
  00704	0f 84 ca 01 00
	00		 je	 $LN93@CGBeattack
  0070a	3d f4 01 00 00	 cmp	 eax, 500		; 000001f4H
  0070f	0f 84 bf 01 00
	00		 je	 $LN93@CGBeattack
  00715	3d f5 01 00 00	 cmp	 eax, 501		; 000001f5H
  0071a	0f 84 b4 01 00
	00		 je	 $LN93@CGBeattack
  00720	3d f6 01 00 00	 cmp	 eax, 502		; 000001f6H
  00725	0f 84 a9 01 00
	00		 je	 $LN93@CGBeattack
  0072b	3d fd 01 00 00	 cmp	 eax, 509		; 000001fdH
  00730	0f 84 9e 01 00
	00		 je	 $LN93@CGBeattack
  00736	3d fe 01 00 00	 cmp	 eax, 510		; 000001feH
  0073b	0f 84 93 01 00
	00		 je	 $LN93@CGBeattack
  00741	3d 02 02 00 00	 cmp	 eax, 514		; 00000202H
  00746	0f 84 88 01 00
	00		 je	 $LN93@CGBeattack
  0074c	3d 03 02 00 00	 cmp	 eax, 515		; 00000203H
  00751	0f 84 7d 01 00
	00		 je	 $LN93@CGBeattack
  00757	3d 04 02 00 00	 cmp	 eax, 516		; 00000204H
  0075c	0f 84 72 01 00
	00		 je	 $LN93@CGBeattack
  00762	3d 07 02 00 00	 cmp	 eax, 519		; 00000207H
  00767	0f 84 67 01 00
	00		 je	 $LN93@CGBeattack
  0076d	3d 08 02 00 00	 cmp	 eax, 520		; 00000208H
  00772	0f 84 5c 01 00
	00		 je	 $LN93@CGBeattack
  00778	3d 09 02 00 00	 cmp	 eax, 521		; 00000209H
  0077d	0f 84 51 01 00
	00		 je	 $LN93@CGBeattack
  00783	3d 0b 02 00 00	 cmp	 eax, 523		; 0000020bH
  00788	0f 84 46 01 00
	00		 je	 $LN93@CGBeattack
  0078e	3d 1b 02 00 00	 cmp	 eax, 539		; 0000021bH
  00793	0f 84 3b 01 00
	00		 je	 $LN93@CGBeattack
  00799	3d 27 02 00 00	 cmp	 eax, 551		; 00000227H
  0079e	0f 84 30 01 00
	00		 je	 $LN93@CGBeattack
  007a4	3d 28 02 00 00	 cmp	 eax, 552		; 00000228H
  007a9	0f 84 25 01 00
	00		 je	 $LN93@CGBeattack
  007af	3d 2a 02 00 00	 cmp	 eax, 554		; 0000022aH
  007b4	0f 84 1a 01 00
	00		 je	 $LN93@CGBeattack
  007ba	3d 2b 02 00 00	 cmp	 eax, 555		; 0000022bH
  007bf	0f 84 0f 01 00
	00		 je	 $LN93@CGBeattack
  007c5	3d 2c 02 00 00	 cmp	 eax, 556		; 0000022cH
  007ca	0f 84 04 01 00
	00		 je	 $LN93@CGBeattack
  007d0	3d 2e 02 00 00	 cmp	 eax, 558		; 0000022eH
  007d5	0f 84 f9 00 00
	00		 je	 $LN93@CGBeattack
  007db	3d 2f 02 00 00	 cmp	 eax, 559		; 0000022fH
  007e0	0f 84 ee 00 00
	00		 je	 $LN93@CGBeattack
  007e6	3d 30 02 00 00	 cmp	 eax, 560		; 00000230H
  007eb	0f 84 e3 00 00
	00		 je	 $LN93@CGBeattack
  007f1	3d 31 02 00 00	 cmp	 eax, 561		; 00000231H
  007f6	0f 84 d8 00 00
	00		 je	 $LN93@CGBeattack
  007fc	3d 32 02 00 00	 cmp	 eax, 562		; 00000232H
  00801	0f 84 cd 00 00
	00		 je	 $LN93@CGBeattack
  00807	3d 33 02 00 00	 cmp	 eax, 563		; 00000233H
  0080c	0f 84 c2 00 00
	00		 je	 $LN93@CGBeattack
  00812	3d 34 02 00 00	 cmp	 eax, 564		; 00000234H
  00817	0f 84 b7 00 00
	00		 je	 $LN93@CGBeattack
  0081d	3d 35 02 00 00	 cmp	 eax, 565		; 00000235H
  00822	0f 84 ac 00 00
	00		 je	 $LN93@CGBeattack
  00828	3d 36 02 00 00	 cmp	 eax, 566		; 00000236H
  0082d	0f 84 a1 00 00
	00		 je	 $LN93@CGBeattack
  00833	3d 37 02 00 00	 cmp	 eax, 567		; 00000237H
  00838	0f 84 96 00 00
	00		 je	 $LN93@CGBeattack
  0083e	3d 3f 02 00 00	 cmp	 eax, 575		; 0000023fH
  00843	0f 84 8b 00 00
	00		 je	 $LN93@CGBeattack
  00849	3d 41 02 00 00	 cmp	 eax, 577		; 00000241H
  0084e	0f 84 80 00 00
	00		 je	 $LN93@CGBeattack

; 14903: 		{
; 14904: 			LogAdd("error-L3 %s %d", 
; 14905: 				__FILE__, 
; 14906: 				__LINE__);

  00854	68 3a 3a 00 00	 push	 14906			; 00003a3aH

; 14907: 			return;

  00859	eb 55		 jmp	 SHORT $LN111@CGBeattack
$LN57@CGBeattack:

; 14908: 		}
; 14909: 	}
; 14910: 	else if (	 lpMagic->m_Skill != 8
; 14911: 			  && lpMagic->m_Skill != 9
; 14912: 			  && lpMagic->m_Skill != 10
; 14913: 			  && lpMagic->m_Skill != 13
; 14914: 			  && lpMagic->m_Skill != 14
; 14915: 			  && lpMagic->m_Skill != 5
; 14916: 			  && lpMagic->m_Skill != 24
; 14917: 			  && lpMagic->m_Skill != 50
; 14918: 			  && lpMagic->m_Skill != 12
; 14919: 			  && lpMagic->m_Skill != 41
; 14920: 			  && lpMagic->m_Skill != 47
; 14921: 			  && lpMagic->m_Skill != 43
; 14922: 			  && lpMagic->m_Skill != 42
; 14923: 			  && lpMagic->m_Skill != 52
; 14924: 			  && lpMagic->m_Skill != 55
; 14925: 			  && lpMagic->m_Skill != 78 )

  0085b	83 f8 08	 cmp	 eax, 8
  0085e	74 74		 je	 SHORT $LN93@CGBeattack
  00860	83 f8 09	 cmp	 eax, 9
  00863	74 6f		 je	 SHORT $LN93@CGBeattack
  00865	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00868	74 6a		 je	 SHORT $LN93@CGBeattack
  0086a	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0086d	74 65		 je	 SHORT $LN93@CGBeattack
  0086f	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00872	74 60		 je	 SHORT $LN93@CGBeattack
  00874	83 f8 05	 cmp	 eax, 5
  00877	74 5b		 je	 SHORT $LN93@CGBeattack
  00879	83 f8 18	 cmp	 eax, 24			; 00000018H
  0087c	74 56		 je	 SHORT $LN93@CGBeattack
  0087e	83 f8 32	 cmp	 eax, 50			; 00000032H
  00881	74 51		 je	 SHORT $LN93@CGBeattack
  00883	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00886	74 4c		 je	 SHORT $LN93@CGBeattack
  00888	83 f8 29	 cmp	 eax, 41			; 00000029H
  0088b	74 47		 je	 SHORT $LN93@CGBeattack
  0088d	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00890	74 42		 je	 SHORT $LN93@CGBeattack
  00892	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00895	74 3d		 je	 SHORT $LN93@CGBeattack
  00897	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0089a	74 38		 je	 SHORT $LN93@CGBeattack
  0089c	83 f8 34	 cmp	 eax, 52			; 00000034H
  0089f	74 33		 je	 SHORT $LN93@CGBeattack
  008a1	83 f8 37	 cmp	 eax, 55			; 00000037H
  008a4	74 2e		 je	 SHORT $LN93@CGBeattack
  008a6	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  008a9	74 29		 je	 SHORT $LN93@CGBeattack

; 14926: 		{
; 14927: 			LogAdd("error-L3 %s %d", 
; 14928: 				__FILE__, 
; 14929: 				__LINE__);

  008ab	68 51 3a 00 00	 push	 14929			; 00003a51H
$LN111@CGBeattack:
  008b0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  008b5	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  008ba	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  008c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c3	5f		 pop	 edi
  008c4	5b		 pop	 ebx
  008c5	5e		 pop	 esi

; 15192: 	}
; 15193: }

  008c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008c9	33 cd		 xor	 ecx, ebp
  008cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008d0	8b e5		 mov	 esp, ebp
  008d2	5d		 pop	 ebp
  008d3	c3		 ret	 0
$LN93@CGBeattack:

; 14930: 			return;
; 14931: 		}
; 14932: 
; 14933: 	if ( lpMagic->m_Skill == 24 || 
; 14934: 		lpMagic->m_Skill == 78 || 
; 14935: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 490 ||
; 14936: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 525)

  008d4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  008d7	83 f8 18	 cmp	 eax, 24			; 00000018H
  008da	74 30		 je	 SHORT $LN52@CGBeattack
  008dc	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  008df	74 2b		 je	 SHORT $LN52@CGBeattack
  008e1	50		 push	 eax
  008e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  008e7	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  008ec	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  008f1	74 19		 je	 SHORT $LN52@CGBeattack
  008f3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  008f6	51		 push	 ecx
  008f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  008fc	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00901	3d 0d 02 00 00	 cmp	 eax, 525		; 0000020dH
  00906	0f 85 76 01 00
	00		 jne	 $LN100@CGBeattack
$LN52@CGBeattack:

; 14937: 	{
; 14938: 		int NSAttackSerial = lpCount->Serial;

  0090c	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR _lpRecv$GSCopy$[ebp]

; 14939: 
; 14940: 		if ( gObj[aIndex].OSAttackSerial >= 255 && (gObj[aIndex].OSAttackSerial - lpCount->Serial) > 50 )

  00912	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00918	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  0091c	0f b7 94 0f d6
	04 00 00	 movzx	 edx, WORD PTR [edi+ecx+1238]
  00924	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00929	66 3b d3	 cmp	 dx, bx
  0092c	7c 1b		 jl	 SHORT $LN51@CGBeattack
  0092e	0f bf d2	 movsx	 edx, dx
  00931	2b d0		 sub	 edx, eax
  00933	83 fa 32	 cmp	 edx, 50			; 00000032H
  00936	7e 11		 jle	 SHORT $LN51@CGBeattack

; 14941: 		{
; 14942: 			gObj[aIndex].OSAttackSerial = -1;

  00938	83 ca ff	 or	 edx, -1
  0093b	66 89 94 0f d6
	04 00 00	 mov	 WORD PTR [edi+ecx+1238], dx
  00943	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN51@CGBeattack:

; 14943: 		}
; 14944: 	
; 14945: 		if ( NSAttackSerial > gObj[aIndex].OSAttackSerial )

  00949	0f bf 94 0f d6
	04 00 00	 movsx	 edx, WORD PTR [edi+ecx+1238]
  00951	3b c2		 cmp	 eax, edx
  00953	0f 8e 29 01 00
	00		 jle	 $LN100@CGBeattack

; 14946: 		{
; 14947: 			gObj[aIndex].OSAttackSerial = NSAttackSerial;

  00959	66 89 84 0f d6
	04 00 00	 mov	 WORD PTR [edi+ecx+1238], ax

; 14948: 			LPOBJ lpObj = &gObj[aIndex];

  00961	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00966	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]

; 14949: 			int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;

  00969	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0096f	2b 86 6c 03 00
	00		 sub	 eax, DWORD PTR [esi+876]

; 14950: 
; 14951: 			if ( iTimeCalc < lpObj->m_DetectSpeedHackTime && iTimeCalc )

  00975	8b 8e 74 03 00
	00		 mov	 ecx, DWORD PTR [esi+884]
  0097b	3b c1		 cmp	 eax, ecx
  0097d	0f 8d df 00 00
	00		 jge	 $LN99@CGBeattack
  00983	85 c0		 test	 eax, eax
  00985	0f 84 d7 00 00
	00		 je	 $LN99@CGBeattack

; 14952: 			{
; 14953: 				lpObj->m_DetectCount++;

  0098b	ff 86 7c 03 00
	00		 inc	 DWORD PTR [esi+892]
  00991	8b 9e 7c 03 00
	00		 mov	 ebx, DWORD PTR [esi+892]

; 14954: 				lpObj->m_SumLastAttackTime += iTimeCalc;

  00997	01 86 78 03 00
	00		 add	 DWORD PTR [esi+888], eax
  0099d	8b 86 78 03 00
	00		 mov	 eax, DWORD PTR [esi+888]

; 14955: 
; 14956: 				if ( lpObj->m_DetectCount > gHackCheckCount )

  009a3	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  009a9	0f 86 a5 00 00
	00		 jbe	 $LN48@CGBeattack

; 14957: 				{
; 14958: 					lpObj->m_DetectedHackKickCount++;

  009af	ff 86 80 03 00
	00		 inc	 DWORD PTR [esi+896]

; 14959: 
; 14960: 					if ( gIsKickDetecHackCountLimit )

  009b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  009bc	8b 96 80 03 00
	00		 mov	 edx, DWORD PTR [esi+896]
  009c2	74 55		 je	 SHORT $LN46@CGBeattack

; 14961: 					{
; 14962: 						if ( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  009c4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  009ca	7e 4d		 jle	 SHORT $LN46@CGBeattack

; 14963: 						{
; 14964: 							LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)", 
; 14965: 								lpObj->AccountID, 
; 14966: 								lpObj->Name, 
; 14967: 								lMsg.Get(MSGGET(7, 108)+lpObj->Class), 
; 14968: 								lpObj->m_DetectedHackKickCount);

  009cc	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  009d3	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  009d9	52		 push	 edx
  009da	51		 push	 ecx
  009db	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  009e0	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  009e5	50		 push	 eax
  009e6	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  009e9	52		 push	 edx
  009ea	83 c6 6c	 add	 esi, 108		; 0000006cH
  009ed	56		 push	 esi
  009ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
  009f3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14969: 							CloseClient(aIndex);

  009f9	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  009ff	50		 push	 eax
  00a00	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00a05	83 c4 18	 add	 esp, 24			; 00000018H
  00a08	5f		 pop	 edi
  00a09	5b		 pop	 ebx
  00a0a	5e		 pop	 esi

; 15192: 	}
; 15193: }

  00a0b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a0e	33 cd		 xor	 ecx, ebp
  00a10	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a15	8b e5		 mov	 esp, ebp
  00a17	5d		 pop	 ebp
  00a18	c3		 ret	 0
$LN46@CGBeattack:

; 14970: 							return;
; 14971: 						}
; 14972: 					}
; 14973: 
; 14974: 					LogAddTD("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d", 
; 14975: 						lpObj->AccountID, 
; 14976: 						lpObj->Name, 
; 14977: 						lMsg.Get(MSGGET(7, 108)+lpObj->Class), 
; 14978: 						lpObj->m_DetectSpeedHackTime,
; 14979: 						lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 14980: 						lpObj->m_SpeedHackPenalty);

  00a19	8b 96 84 03 00
	00		 mov	 edx, DWORD PTR [esi+900]
  00a1f	52		 push	 edx
  00a20	33 d2		 xor	 edx, edx
  00a22	f7 f3		 div	 ebx
  00a24	50		 push	 eax
  00a25	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00a2c	51		 push	 ecx
  00a2d	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00a32	50		 push	 eax
  00a33	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a38	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00a3d	50		 push	 eax
  00a3e	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00a41	51		 push	 ecx
  00a42	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  00a45	52		 push	 edx
  00a46	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
  00a4b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a51	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN48@CGBeattack:

; 14981: 				}
; 14982: 
; 14983: 				lpObj->m_LastAttackTime = GetTickCount();

  00a54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00a5a	89 86 6c 03 00
	00		 mov	 DWORD PTR [esi+876], eax

; 14984: 			}
; 14985: 			else

  00a60	eb 0e		 jmp	 SHORT $LN45@CGBeattack
$LN99@CGBeattack:

; 14986: 			{
; 14987: 				lpObj->m_SumLastAttackTime = 0;

  00a62	33 c0		 xor	 eax, eax
  00a64	89 86 78 03 00
	00		 mov	 DWORD PTR [esi+888], eax

; 14988: 				lpObj->m_DetectCount = 0;

  00a6a	89 86 7c 03 00
	00		 mov	 DWORD PTR [esi+892], eax
$LN45@CGBeattack:

; 14989: 			}
; 14990: 
; 14991: 			lpObj->m_LastAttackTime = GetTickCount();

  00a70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00a76	89 86 6c 03 00
	00		 mov	 DWORD PTR [esi+876], eax
  00a7c	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR _lpMagic$[ebp]
$LN100@CGBeattack:

; 14992: 		}
; 14993: 	}
; 14994: 
; 14995: 	//season4 add-on
; 14996: 
; 14997: 	if( lpMagic->m_Skill == 9 ||
; 14998: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 385 ||	//1.01.00
; 14999: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 487)

  00a82	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00a85	83 f8 09	 cmp	 eax, 9
  00a88	74 27		 je	 SHORT $LN43@CGBeattack
  00a8a	50		 push	 eax
  00a8b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00a90	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00a95	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  00a9a	74 15		 je	 SHORT $LN43@CGBeattack
  00a9c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00a9f	50		 push	 eax
  00aa0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00aa5	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00aaa	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  00aaf	75 79		 jne	 SHORT $LN87@CGBeattack
$LN43@CGBeattack:

; 15000: 	{
; 15001: 		#if(EVIL_SPIRIT_SUMMONER)
; 15002: 		if(g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || g_ZtLicense.CheckUser(eZtUB::GredyLocal))

  00ab1	6a 00		 push	 0
  00ab3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00ab8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00abd	84 c0		 test	 al, al
  00abf	75 48		 jne	 SHORT $LN41@CGBeattack
  00ac1	6a 20		 push	 32			; 00000020H
  00ac3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00ac8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00acd	84 c0		 test	 al, al
  00acf	75 38		 jne	 SHORT $LN41@CGBeattack
  00ad1	6a 22		 push	 34			; 00000022H
  00ad3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00ad8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00add	84 c0		 test	 al, al
  00adf	75 28		 jne	 SHORT $LN41@CGBeattack
  00ae1	6a 21		 push	 33			; 00000021H
  00ae3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00ae8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00aed	84 c0		 test	 al, al
  00aef	75 18		 jne	 SHORT $LN41@CGBeattack

; 15005: 			{
; 15006: 				return;
; 15007: 			}
; 15008: 		}
; 15009: 		else
; 15010: 		#endif
; 15011: 		{
; 15012: 			if(gObj[aIndex].Class != CLASS_WIZARD && gObj[aIndex].Class != CLASS_MAGUMSA)

  00af1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00af7	0f b7 84 0f b8
	00 00 00	 movzx	 eax, WORD PTR [edi+ecx+184]
  00aff	66 85 c0	 test	 ax, ax
  00b02	74 26		 je	 SHORT $LN87@CGBeattack
  00b04	83 f8 03	 cmp	 eax, 3

; 15013: 			{
; 15014: 				return;

  00b07	eb 1b		 jmp	 SHORT $LN105@CGBeattack
$LN41@CGBeattack:

; 15003: 		{
; 15004: 			if(gObj[aIndex].Class != CLASS_WIZARD && gObj[aIndex].Class != CLASS_MAGUMSA &&	gObj[aIndex].Class != CLASS_SUMMONER)

  00b09	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b0f	0f b7 84 17 b8
	00 00 00	 movzx	 eax, WORD PTR [edi+edx+184]
  00b17	66 85 c0	 test	 ax, ax
  00b1a	74 0e		 je	 SHORT $LN87@CGBeattack
  00b1c	83 f8 03	 cmp	 eax, 3
  00b1f	74 09		 je	 SHORT $LN87@CGBeattack
  00b21	83 f8 05	 cmp	 eax, 5
$LN105@CGBeattack:
  00b24	0f 85 9d 04 00
	00		 jne	 $LN103@CGBeattack
$LN87@CGBeattack:

; 15015: 			}
; 15016: 		}
; 15017: 	}
; 15018: 
; 15019: 	if ( bIsIgnorePacketSpeedHackDetect )

  00b2a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  00b31	74 5a		 je	 SHORT $LN36@CGBeattack

; 15020: 	{
; 15021: 		LPOBJ lpObj = &gObj[aIndex];

  00b33	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b38	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]

; 15022: 
; 15023: 		if ( lpObj->m_SpeedHackPenalty > 0 )

  00b3b	8b 86 84 03 00
	00		 mov	 eax, DWORD PTR [esi+900]
  00b41	85 c0		 test	 eax, eax
  00b43	7e 48		 jle	 SHORT $LN36@CGBeattack

; 15024: 		{
; 15025: 			lpObj->m_SpeedHackPenalty--;
; 15026: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left)", 
; 15027: 				lpObj->AccountID, 
; 15028: 				lpObj->Name, 
; 15029: 				lMsg.Get(MSGGET(7, 108)+lpObj->Class), 
; 15030: 				lpObj->m_SpeedHackPenalty);

  00b45	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  00b4c	48		 dec	 eax
  00b4d	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  00b53	50		 push	 eax
  00b54	51		 push	 ecx
  00b55	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00b5a	89 86 84 03 00
	00		 mov	 DWORD PTR [esi+900], eax
  00b60	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00b65	50		 push	 eax
  00b66	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00b69	52		 push	 edx
  00b6a	83 c6 6c	 add	 esi, 108		; 0000006cH
  00b6d	56		 push	 esi
  00b6e	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
  00b73	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 15142: 					CloseClient(gObj[aIndex].m_Index);

  00b79	83 c4 14	 add	 esp, 20			; 00000014H
  00b7c	5f		 pop	 edi
  00b7d	5b		 pop	 ebx
  00b7e	5e		 pop	 esi

; 15192: 	}
; 15193: }

  00b7f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b82	33 cd		 xor	 ecx, ebp
  00b84	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b89	8b e5		 mov	 esp, ebp
  00b8b	5d		 pop	 ebp
  00b8c	c3		 ret	 0
$LN36@CGBeattack:

; 15031: 			return;
; 15032: 		}
; 15033: 	}
; 15034: 	
; 15035: 	int lOfs2 = lOfs;
; 15036: 	int pTargetNumber[128];
; 15037: 	
; 15038: 	for (int i=0;i<lpCount->Count;i++)

  00b8d	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
  00b93	0f b6 70 08	 movzx	 esi, BYTE PTR [eax+8]
  00b97	33 c9		 xor	 ecx, ecx
  00b99	85 f6		 test	 esi, esi
  00b9b	7e 26		 jle	 SHORT $LN33@CGBeattack
  00b9d	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00ba1	83 c0 09	 add	 eax, 9
$LL35@CGBeattack:

; 15039: 	{
; 15040: 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs2];
; 15041: 		pTargetNumber[i] = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00ba4	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  00ba7	0f b6 58 01	 movzx	 ebx, BYTE PTR [eax+1]
  00bab	66 c1 e7 08	 shl	 di, 8
  00baf	0f b7 ff	 movzx	 edi, di
  00bb2	0b fb		 or	 edi, ebx
  00bb4	89 bc 8d fc fd
	ff ff		 mov	 DWORD PTR _pTargetNumber$[ebp+ecx*4], edi
  00bbb	41		 inc	 ecx

; 15042: 		lOfs2 += sizeof(PMSG_BEATTACK);

  00bbc	83 c0 03	 add	 eax, 3
  00bbf	3b ca		 cmp	 ecx, edx
  00bc1	7c e1		 jl	 SHORT $LL35@CGBeattack
$LN33@CGBeattack:

; 15043: 	}
; 15044: 
; 15045: 	for (int n=0;n<lpCount->Count;n++)

  00bc3	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$249824[ebp], 0
  00bcd	85 f6		 test	 esi, esi
  00bcf	0f 8e f2 03 00
	00		 jle	 $LN103@CGBeattack
  00bd5	8b bd f4 fd ff
	ff		 mov	 edi, DWORD PTR _lpRecv$GSCopy$[ebp]
  00bdb	83 c7 09	 add	 edi, 9
  00bde	89 bd ec fd ff
	ff		 mov	 DWORD PTR tv2192[ebp], edi
  00be4	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL95@CGBeattack:

; 15046: 	{
; 15047: 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs];
; 15048: 		tNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00bf0	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00bf3	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]

; 15049: 		LPOBJ lpObj = &gObj[aIndex];

  00bf7	8b 9d f0 fd ff
	ff		 mov	 ebx, DWORD PTR tv1289[ebp]
  00bfd	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c03	66 c1 e1 08	 shl	 cx, 8
  00c07	0f b7 f1	 movzx	 esi, cx
  00c0a	0b f2		 or	 esi, edx

; 15050: 
; 15051: 		//season4 add-on
; 15052: 		if ( lpMsg->MagicKey == 0 && (lpMagic->m_Skill == 9 ||
; 15053: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 445 ||
; 15054: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 530))

  00c0c	80 7f 02 00	 cmp	 BYTE PTR [edi+2], 0
  00c10	75 51		 jne	 SHORT $LN108@CGBeattack
  00c12	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpMagic$[ebp]
  00c18	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c1b	83 f8 09	 cmp	 eax, 9
  00c1e	0f 84 a3 03 00
	00		 je	 $LN103@CGBeattack
  00c24	50		 push	 eax
  00c25	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00c2a	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00c2f	3d bd 01 00 00	 cmp	 eax, 445		; 000001bdH
  00c34	0f 84 8d 03 00
	00		 je	 $LN103@CGBeattack
  00c3a	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00c40	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c43	51		 push	 ecx
  00c44	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00c49	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00c4e	3d 12 02 00 00	 cmp	 eax, 530		; 00000212H
  00c53	0f 84 6e 03 00
	00		 je	 $LN103@CGBeattack

; 15055: 		{
; 15056: 			return;
; 15057: 		}
; 15058: 
; 15059: 		if ( lpMsg->MagicKey != 0 && (lpMagic->m_Skill == 9 ||
; 15060: 			//season4 add-on
; 15061: 			g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 445 ||
; 15062: 		g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 530))

  00c59	80 7f 02 00	 cmp	 BYTE PTR [edi+2], 0
  00c5d	0f 84 c1 00 00
	00		 je	 $LN88@CGBeattack
$LN108@CGBeattack:
  00c63	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpMagic$[ebp]
  00c69	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c6c	83 f8 09	 cmp	 eax, 9
  00c6f	74 31		 je	 SHORT $LN26@CGBeattack
  00c71	50		 push	 eax
  00c72	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00c77	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00c7c	3d bd 01 00 00	 cmp	 eax, 445		; 000001bdH
  00c81	74 1f		 je	 SHORT $LN26@CGBeattack
  00c83	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00c89	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c8c	51		 push	 ecx
  00c8d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00c92	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00c97	3d 12 02 00 00	 cmp	 eax, 530		; 00000212H
  00c9c	0f 85 82 00 00
	00		 jne	 $LN88@CGBeattack
$LN26@CGBeattack:

; 15063: 		{
; 15064: 			if ( lpObj->DurMagicKeyChecker.IsValidDurationTime(lpMsg->MagicKey) == FALSE )

  00ca2	0f b6 57 02	 movzx	 edx, BYTE PTR [edi+2]
  00ca6	8d 8b 48 11 00
	00		 lea	 ecx, DWORD PTR [ebx+4424]
  00cac	52		 push	 edx
  00cad	89 8d e0 fd ff
	ff		 mov	 DWORD PTR tv1605[ebp], ecx
  00cb3	e8 00 00 00 00	 call	 ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
  00cb8	85 c0		 test	 eax, eax
  00cba	75 3c		 jne	 SHORT $LN25@CGBeattack

; 15065: 			{
; 15066: 				LogAddC(0, " InValid DurationTime Key = %d ( Time : %d) [%d][%d]", 
; 15067: 					lpMsg->MagicKey, 
; 15068: 					lpObj->DurMagicKeyChecker.GetValidDurationTime(lpMsg->MagicKey),
; 15069: 				lpObj->AccountID, 
; 15070: 				lpObj->Name); 

  00cbc	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00cc0	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00cc3	51		 push	 ecx
  00cc4	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1605[ebp]
  00cca	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00ccd	53		 push	 ebx
  00cce	50		 push	 eax
  00ccf	e8 00 00 00 00	 call	 ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
  00cd4	0f b6 57 02	 movzx	 edx, BYTE PTR [edi+2]
  00cd8	50		 push	 eax
  00cd9	52		 push	 edx
  00cda	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@
$LN110@CGBeattack:
  00cdf	6a 00		 push	 0
  00ce1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00ce7	83 c4 18	 add	 esp, 24			; 00000018H

; 15071: 				lOfs += sizeof(PMSG_BEATTACK);

  00cea	83 c7 03	 add	 edi, 3
  00ced	89 bd ec fd ff
	ff		 mov	 DWORD PTR tv2192[ebp], edi

; 15072: 				continue;

  00cf3	e9 53 02 00 00	 jmp	 $LN31@CGBeattack
$LN25@CGBeattack:

; 15073: 			}
; 15074: 			
; 15075: 			if ( lpObj->DurMagicKeyChecker.IsValidCount(lpMsg->MagicKey) == FALSE )

  00cf8	8a 47 02	 mov	 al, BYTE PTR [edi+2]
  00cfb	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00cfe	80 f9 3b	 cmp	 cl, 59			; 0000003bH
  00d01	76 21		 jbe	 SHORT $LN88@CGBeattack

; 15076: 			{
; 15077: 				LogAddC(0, " InValid VailidCount = %d ( Count : %d) [%d][%d]", 
; 15078: 					lpMsg->MagicKey, 
; 15079: 					lpObj->DurMagicKeyChecker.GetValidCount(lpMsg->MagicKey), 
; 15080: 					lpObj->AccountID, 
; 15081: 					lpObj->Name); 

  00d03	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1605[ebp]
  00d09	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  00d0c	52		 push	 edx
  00d0d	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00d10	53		 push	 ebx
  00d11	50		 push	 eax
  00d12	e8 00 00 00 00	 call	 ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidCount
  00d17	50		 push	 eax
  00d18	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00d1c	50		 push	 eax
  00d1d	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@

; 15082: 				lOfs += sizeof(PMSG_BEATTACK);
; 15083: 				continue;

  00d22	eb bb		 jmp	 SHORT $LN110@CGBeattack
$LN88@CGBeattack:

; 15084: 			}
; 15085: 		}
; 15086: 		
; 15087: 		 //season4 add-on start
; 15088: 		if(OBJMAX_RANGE(tNumber)==false)

  00d24	85 f6		 test	 esi, esi
  00d26	0f 88 1f 02 00
	00		 js	 $LN31@CGBeattack
  00d2c	33 c0		 xor	 eax, eax
  00d2e	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00d34	0f 9e c0	 setle	 al
  00d37	85 c0		 test	 eax, eax
  00d39	0f 84 0c 02 00
	00		 je	 $LN31@CGBeattack

; 15089: 		{
; 15090: 			continue;
; 15091: 		}
; 15092: 
; 15093: 		#if(FIX_OBJECT_VIEWE)
; 15094: 		g_ObjectViewe.GCIndexLive(aIndex, tNumber, gObj[tNumber].Type, gObj[tNumber].Live);
; 15095: 		#endif
; 15096: 
; 15097: 		int DistanceCheck = gObjCalDistance(lpObj, &gObj[tNumber]);

  00d3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d45	8b fe		 mov	 edi, esi
  00d47	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00d4d	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  00d50	52		 push	 edx
  00d51	53		 push	 ebx
  00d52	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00d57	83 c4 08	 add	 esp, 8

; 15098: 
; 15099: 		if(DistanceCheck > 13)

  00d5a	83 f8 0d	 cmp	 eax, 13			; 0000000dH

; 15100: 		{
; 15101: 			lOfs += 3;
; 15102: 			continue;

  00d5d	0f 8f db 01 00
	00		 jg	 $LN89@CGBeattack

; 15103: 		}
; 15104: 		//season4 add-on end
; 15105: 
; 15106: 		if ( gWriteSkillLog )

  00d63	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteSkillLog@@3HA, 0 ; gWriteSkillLog

; 15107: 		{
; 15108: 			LogAddTD("Magic Attack3 : %d, serial = %d, Tgt =  %d, cnt = %d", 
; 15109: 				lpMagic->m_Skill, 
; 15110: 				lpCount->Serial, 
; 15111: 				tNumber, 
; 15112: 				lpCount->Count);

  00d6a	8b 9d f8 fd ff
	ff		 mov	 ebx, DWORD PTR _lpMagic$[ebp]
  00d70	74 23		 je	 SHORT $LN90@CGBeattack
  00d72	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$[ebp]
  00d78	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00d7c	0f b6 50 07	 movzx	 edx, BYTE PTR [eax+7]
  00d80	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00d83	51		 push	 ecx
  00d84	56		 push	 esi
  00d85	52		 push	 edx
  00d86	50		 push	 eax
  00d87	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd?0@
  00d8c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d92	83 c4 14	 add	 esp, 20			; 00000014H
$LN90@CGBeattack:
  00d95	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$[ebp]

; 15113: 		}
; 15114: 
; 15115: 		if ( gEnableCheckPenetrationSkill )
; 15116: 		{
; 15117: 			/*
; 15118: 			if ( lpMagic->m_Skill == 78 )
; 15119: 			{
; 15120: 				if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) == FALSE )
; 15121: 				{
; 15122: 					return;
; 15123: 				}
; 15124: 			}
; 15125: 			else if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial)== FALSE )
; 15126: 			{
; 15127: 				return;
; 15128: 			}
; 15129: 			*/
; 15130: 		}
; 15131: 
; 15132: 		for (int i=0;i<lpCount->Count;i++)

  00d9b	33 c0		 xor	 eax, eax
  00d9d	38 41 08	 cmp	 BYTE PTR [ecx+8], al
  00da0	76 1e		 jbe	 SHORT $LN91@CGBeattack
$LL96@CGBeattack:

; 15133: 		{
; 15134: 			if ( n != i)

  00da2	39 85 e4 fd ff
	ff		 cmp	 DWORD PTR _n$249824[ebp], eax
  00da8	74 0d		 je	 SHORT $LN18@CGBeattack

; 15135: 			{
; 15136: 				if ( pTargetNumber[i] == tNumber )

  00daa	39 b4 85 fc fd
	ff ff		 cmp	 DWORD PTR _pTargetNumber$[ebp+eax*4], esi
  00db1	0f 84 c4 01 00
	00		 je	 $LN82@CGBeattack
$LN18@CGBeattack:

; 15113: 		}
; 15114: 
; 15115: 		if ( gEnableCheckPenetrationSkill )
; 15116: 		{
; 15117: 			/*
; 15118: 			if ( lpMagic->m_Skill == 78 )
; 15119: 			{
; 15120: 				if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) == FALSE )
; 15121: 				{
; 15122: 					return;
; 15123: 				}
; 15124: 			}
; 15125: 			else if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial)== FALSE )
; 15126: 			{
; 15127: 				return;
; 15128: 			}
; 15129: 			*/
; 15130: 		}
; 15131: 
; 15132: 		for (int i=0;i<lpCount->Count;i++)

  00db7	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00dbb	40		 inc	 eax
  00dbc	3b c2		 cmp	 eax, edx
  00dbe	7c e2		 jl	 SHORT $LL96@CGBeattack
$LN91@CGBeattack:

; 15143: 					return;
; 15144: 				}
; 15145: 			}
; 15146: 		}
; 15147: 
; 15148: 		if ( tNumber >= 0 && tNumber < OBJMAX-1 )

  00dc0	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00dc6	0f 8d 72 01 00
	00		 jge	 $LN89@CGBeattack

; 15149: 		{
; 15150: 			if ( lpMagic->m_Skill == 55 )

  00dcc	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00dcf	83 f8 37	 cmp	 eax, 55			; 00000037H
  00dd2	0f 85 a5 00 00
	00		 jne	 $LN13@CGBeattack

; 15151: 			{
; 15152: 				if(gObj[aIndex].Type == OBJ_USER) //season 3.5 add-on

  00dd8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ddd	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1289[ebp]
  00de3	66 83 7c 01 68
	01		 cmp	 WORD PTR [ecx+eax+104], 1
  00de9	75 58		 jne	 SHORT $LN12@CGBeattack

; 15153: 				{
; 15154: 					if(gObj[aIndex].Strength+gObj[aIndex].AddStrength >= 596)

  00deb	0f bf 94 01 20
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+288]
  00df3	0f b7 84 01 f4
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+244]
  00dfb	03 d0		 add	 edx, eax
  00dfd	81 fa 54 02 00
	00		 cmp	 edx, 596		; 00000254H
  00e03	0f 8c 35 01 00
	00		 jl	 $LN89@CGBeattack

; 15155: 					{
; 15156: 						gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic->m_Level);

  00e09	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00e0d	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00e13	51		 push	 ecx
  00e14	56		 push	 esi
  00e15	52		 push	 edx
  00e16	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00e1b	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 15157: 						gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00e20	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e25	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1289[ebp]
  00e2b	6a 00		 push	 0
  00e2d	6a 00		 push	 0
  00e2f	6a 00		 push	 0
  00e31	6a 00		 push	 0
  00e33	6a 01		 push	 1
  00e35	6a 01		 push	 1
  00e37	53		 push	 ebx
  00e38	03 f8		 add	 edi, eax
  00e3a	57		 push	 edi
  00e3b	03 c8		 add	 ecx, eax
  00e3d	51		 push	 ecx

; 15158: 					}
; 15159: 				}
; 15160: 				else

  00e3e	e9 f3 00 00 00	 jmp	 $LN109@CGBeattack
$LN12@CGBeattack:

; 15161: 				{
; 15162: 					gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic->m_Level);

  00e43	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  00e47	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00e4d	52		 push	 edx
  00e4e	56		 push	 esi
  00e4f	50		 push	 eax
  00e50	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00e55	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 15163: 					gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00e5a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e5f	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1289[ebp]
  00e65	6a 00		 push	 0
  00e67	6a 00		 push	 0
  00e69	6a 00		 push	 0
  00e6b	6a 00		 push	 0
  00e6d	6a 01		 push	 1
  00e6f	6a 01		 push	 1
  00e71	53		 push	 ebx
  00e72	03 f8		 add	 edi, eax
  00e74	57		 push	 edi
  00e75	03 c8		 add	 ecx, eax
  00e77	51		 push	 ecx

; 15164: 				}

  00e78	e9 b9 00 00 00	 jmp	 $LN109@CGBeattack
$LN13@CGBeattack:

; 15165: 			}
; 15166: 			else if ( lpMagic->m_Skill == 78 )

  00e7d	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00e80	75 18		 jne	 SHORT $LN8@CGBeattack

; 15167: 			{
; 15168: 				gObjUseSkill.SkillFireScream(aIndex, tNumber, lpMagic);

  00e82	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00e88	53		 push	 ebx
  00e89	56		 push	 esi
  00e8a	52		 push	 edx
  00e8b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00e90	e8 00 00 00 00	 call	 ?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireScream
  00e95	e9 a4 00 00 00	 jmp	 $LN89@CGBeattack
$LN8@CGBeattack:

; 15169: 			}
; 15170: 
; 15171: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 490 ) //season4 add-on

  00e9a	50		 push	 eax
  00e9b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00ea0	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 15172: 			{
; 15173: 				g_MasterSkillSystem.MLS_MaGumSkillDefenseDown(aIndex, tNumber);

  00ea5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00eaa	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  00eaf	75 2d		 jne	 SHORT $LN6@CGBeattack
  00eb1	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00eb7	56		 push	 esi
  00eb8	50		 push	 eax
  00eb9	e8 00 00 00 00	 call	 ?MLS_MaGumSkillDefenseDown@CMasterLevelSkillTreeSystem@@QAEXHH@Z ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDown

; 15174: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE, 0, 0);

  00ebe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ec3	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1289[ebp]
  00ec9	6a 00		 push	 0
  00ecb	6a 00		 push	 0
  00ecd	6a 00		 push	 0
  00ecf	6a 00		 push	 0
  00ed1	6a 01		 push	 1
  00ed3	6a 01		 push	 1
  00ed5	53		 push	 ebx
  00ed6	03 f8		 add	 edi, eax
  00ed8	57		 push	 edi
  00ed9	03 c8		 add	 ecx, eax
  00edb	51		 push	 ecx
  00edc	eb 58		 jmp	 SHORT $LN109@CGBeattack
$LN6@CGBeattack:

; 15175: 			}
; 15176: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == 518 ) //season4 add-on

  00ede	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00ee1	52		 push	 edx
  00ee2	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00ee7	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  00eec	75 15		 jne	 SHORT $LN4@CGBeattack

; 15177: 			{
; 15178: 				g_MasterSkillSystem.MLS_FireScream(aIndex, tNumber, lpMagic);

  00eee	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00ef4	53		 push	 ebx
  00ef5	56		 push	 esi
  00ef6	50		 push	 eax
  00ef7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00efc	e8 00 00 00 00	 call	 ?MLS_FireScream@CMasterLevelSkillTreeSystem@@QAEHHHPAVCMagicInf@@@Z ; CMasterLevelSkillTreeSystem::MLS_FireScream
  00f01	eb 3b		 jmp	 SHORT $LN89@CGBeattack
$LN4@CGBeattack:

; 15179: 			}
; 15180: 
; 15181: 			else if ( magic_send )
; 15182: 			{
; 15183: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00f03	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f08	6a 00		 push	 0
  00f0a	6a 00		 push	 0
  00f0c	6a 00		 push	 0
  00f0e	03 f8		 add	 edi, eax
  00f10	83 7d 10 00	 cmp	 DWORD PTR _magic_send$[ebp], 0
  00f14	6a 00		 push	 0
  00f16	6a 01		 push	 1
  00f18	74 0f		 je	 SHORT $LN2@CGBeattack
  00f1a	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv1289[ebp]
  00f20	6a 01		 push	 1
  00f22	53		 push	 ebx
  00f23	57		 push	 edi
  00f24	03 c8		 add	 ecx, eax
  00f26	51		 push	 ecx

; 15184: 			}
; 15185: 			else

  00f27	eb 0d		 jmp	 SHORT $LN109@CGBeattack
$LN2@CGBeattack:

; 15186: 			{
; 15187: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, FALSE, 1, 0, FALSE,0,0);

  00f29	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR tv1289[ebp]
  00f2f	6a 00		 push	 0
  00f31	53		 push	 ebx
  00f32	57		 push	 edi
  00f33	03 d0		 add	 edx, eax
  00f35	52		 push	 edx
$LN109@CGBeattack:
  00f36	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00f3b	83 c4 24	 add	 esp, 36			; 00000024H
$LN89@CGBeattack:

; 15188: 			}
; 15189: 		}
; 15190: 
; 15191: 		lOfs += sizeof(PMSG_BEATTACK);

  00f3e	83 85 ec fd ff
	ff 03		 add	 DWORD PTR tv2192[ebp], 3
  00f45	8b bd ec fd ff
	ff		 mov	 edi, DWORD PTR tv2192[ebp]
$LN31@CGBeattack:

; 15043: 	}
; 15044: 
; 15045: 	for (int n=0;n<lpCount->Count;n++)

  00f4b	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$[ebp]
  00f51	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _n$249824[ebp]
  00f57	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00f5b	40		 inc	 eax
  00f5c	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _n$249824[ebp], eax
  00f62	3b c2		 cmp	 eax, edx
  00f64	0f 8c 86 fc ff
	ff		 jl	 $LL95@CGBeattack
  00f6a	5f		 pop	 edi
  00f6b	5b		 pop	 ebx
  00f6c	5e		 pop	 esi

; 15192: 	}
; 15193: }

  00f6d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f70	33 cd		 xor	 ecx, ebp
  00f72	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f77	8b e5		 mov	 esp, ebp
  00f79	5d		 pop	 ebp
  00f7a	c3		 ret	 0
$LN82@CGBeattack:

; 15137: 				{
; 15138: 					LogAddTD("[%s][%s] %s Detect Hack : Multi Attack", 
; 15139: 						gObj[aIndex].AccountID, 
; 15140: 						gObj[aIndex].Name, 
; 15141: 						lMsg.Get(MSGGET(7, 108)+gObj[aIndex].Class));

  00f7b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f80	8b bd f0 fd ff
	ff		 mov	 edi, DWORD PTR tv1289[ebp]
  00f86	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]
  00f89	0f b7 84 07 b8
	00 00 00	 movzx	 eax, WORD PTR [edi+eax+184]
  00f91	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00f96	50		 push	 eax
  00f97	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00f9c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00fa1	50		 push	 eax
  00fa2	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00fa5	51		 push	 ecx
  00fa6	83 c6 6c	 add	 esi, 108		; 0000006cH
  00fa9	56		 push	 esi
  00faa	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@
  00faf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 15142: 					CloseClient(gObj[aIndex].m_Index);

  00fb5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fbb	8b 04 17	 mov	 eax, DWORD PTR [edi+edx]
  00fbe	50		 push	 eax
  00fbf	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00fc4	83 c4 14	 add	 esp, 20			; 00000014H
$LN103@CGBeattack:

; 15192: 	}
; 15193: }

  00fc7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fca	5f		 pop	 edi
  00fcb	5b		 pop	 ebx
  00fcc	33 cd		 xor	 ecx, ebp
  00fce	5e		 pop	 esi
  00fcf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fd4	8b e5		 mov	 esp, ebp
  00fd6	5d		 pop	 ebp
  00fd7	c3		 ret	 0
?CGBeattackRecv@@YAXPAEHH@Z ENDP			; CGBeattackRecv
_TEXT	ENDS
PUBLIC	??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ ; `string'
PUBLIC	??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ ; `string'
PUBLIC	?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
EXTRN	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?EnableSkill@CObjUseSkill@@QAEHKH@Z:PROC	; CObjUseSkill::EnableSkill
EXTRN	?SpeedHackCheck@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SpeedHackCheck
EXTRN	?CheckKillCount@CMagicDamage@@QAEHHH@Z:PROC	; CMagicDamage::CheckKillCount
EXTRN	?CheckStatus@CMagicDamage@@QAEHHH@Z:PROC	; CMagicDamage::CheckStatus
;	COMDAT ??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
CONST	SEGMENT
??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ DB '['
	DB	'0x1E] CGDurationMagicRecv() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
CONST	SEGMENT
??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ DB '['
	DB	'0x1E] CGDurationMagicRecv() - Invalid Status', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z PROC ; CGDurationMagicRecv, COMDAT

; 15196: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15197: 	CMagicInf * lpMagic;
; 15198: 	LPOBJ lpObj = &gObj[aIndex];

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000c	56		 push	 esi
  0000d	8b f3		 mov	 esi, ebx
  0000f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H

; 15199: 
; 15200: 	if ( lpObj->Teleport )

  00015	80 bc 06 a0 03
	00 00 00	 cmp	 BYTE PTR [esi+eax+928], 0
  0001d	57		 push	 edi
  0001e	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  00021	0f 85 94 01 00
	00		 jne	 $LN1@CGDuration

; 15201: 	{
; 15202: 		return;
; 15203: 	}
; 15204: 
; 15205: 	if ( gObj[aIndex].Type == OBJ_USER )

  00027	66 83 7f 68 01	 cmp	 WORD PTR [edi+104], 1
  0002c	75 6f		 jne	 SHORT $LN11@CGDuration

; 15206: 	{
; 15207: 		//season 4.5 add-on start
; 15208: 		BYTE attr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 15209: 
; 15210: 		if ( (attr&1) == 1 ) //safezone

  0002e	0f bf 8f 46 01
	00 00		 movsx	 ecx, WORD PTR [edi+326]
  00035	0f bf 97 44 01
	00 00		 movsx	 edx, WORD PTR [edi+324]
  0003c	51		 push	 ecx
  0003d	0f b6 8f 49 01
	00 00		 movzx	 ecx, BYTE PTR [edi+329]
  00044	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  0004a	52		 push	 edx
  0004b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00051	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00056	a8 01		 test	 al, 1
  00058	74 25		 je	 SHORT $LN10@CGDuration

; 15211: 		{
; 15212: 			gObjSetPosition(aIndex,gObj[aIndex].X, gObj[aIndex].Y);

  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005f	0f bf 8c 06 46
	01 00 00	 movsx	 ecx, WORD PTR [esi+eax+326]
  00067	0f bf 94 06 44
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+324]
  0006f	51		 push	 ecx
  00070	52		 push	 edx
  00071	53		 push	 ebx
  00072	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx

; 15282: 	}
; 15283: }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN10@CGDuration:

; 15213: 			return;
; 15214: 		}
; 15215: 		//season 4.5 add-on end
; 15216: 
; 15217: 		WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);

  0007f	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00082	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00086	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  0008a	66 c1 e0 08	 shl	 ax, 8
  0008e	66 0b c1	 or	 ax, cx
  00091	0f b7 d0	 movzx	 edx, ax

; 15218: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  00094	52		 push	 edx
  00095	57		 push	 edi
  00096	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 15219: 	}
; 15220: 	else

  0009b	eb 1c		 jmp	 SHORT $LN15@CGDuration
$LN11@CGDuration:

; 15221: 	{
; 15222: 		WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);

  0009d	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  000a0	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000a4	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  000a8	66 c1 e0 08	 shl	 ax, 8
  000ac	66 0b c1	 or	 ax, cx
  000af	0f b7 d0	 movzx	 edx, ax

; 15223: 		lpMagic = gObjGetMagic( lpObj, MagicNumber);

  000b2	52		 push	 edx
  000b3	57		 push	 edi
  000b4	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
$LN15@CGDuration:
  000b9	8b d8		 mov	 ebx, eax
  000bb	83 c4 08	 add	 esp, 8

; 15224: 	}
; 15225: 
; 15226: 	if ( lpMagic == NULL )

  000be	85 db		 test	 ebx, ebx
  000c0	0f 84 f5 00 00
	00		 je	 $LN1@CGDuration

; 15227: 	{
; 15228: 		return;
; 15229: 	}
; 15230: 
; 15231: 	if ( lpObj->Type == OBJ_USER )

  000c6	66 83 7f 68 01	 cmp	 WORD PTR [edi+104], 1
  000cb	75 5d		 jne	 SHORT $LN5@CGDuration

; 15232: 	{
; 15233: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == FALSE )

  000cd	8b 87 48 04 00
	00		 mov	 eax, DWORD PTR [edi+1096]
  000d3	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000d6	50		 push	 eax
  000d7	51		 push	 ecx
  000d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  000dd	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  000e2	85 c0		 test	 eax, eax
  000e4	75 15		 jne	 SHORT $LN6@CGDuration

; 15234: 		{
; 15235: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid Status");

  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
  000eb	6a 02		 push	 2
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000f3	83 c4 08	 add	 esp, 8
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 15282: 	}
; 15283: }

  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
$LN6@CGDuration:

; 15236: 			return;
; 15237: 		}
; 15238: 
; 15239: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  000fb	0f b6 97 0c 1c
	00 00		 movzx	 edx, BYTE PTR [edi+7180]
  00102	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00105	52		 push	 edx
  00106	50		 push	 eax
  00107	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0010c	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  00111	85 c0		 test	 eax, eax
  00113	79 15		 jns	 SHORT $LN5@CGDuration

; 15240: 		{
; 15241: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid KillCount");

  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
  0011a	6a 02		 push	 2
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00122	83 c4 08	 add	 esp, 8
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx

; 15282: 	}
; 15283: }

  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
$LN5@CGDuration:

; 15242: 			return;
; 15243: 		}
; 15244: 	}
; 15245: 
; 15246: 	lpObj->UseMagicNumber = 0;

  0012a	c6 87 cd 04 00
	00 00		 mov	 BYTE PTR [edi+1229], 0

; 15247: 
; 15248: 	if ( lpMagic->m_Skill != 24 && lpMagic->m_Skill != 490)

  00131	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00134	83 f8 18	 cmp	 eax, 24			; 00000018H
  00137	74 19		 je	 SHORT $LN3@CGDuration
  00139	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  0013e	74 12		 je	 SHORT $LN3@CGDuration

; 15249: 	{
; 15250: 		if ( !gObjUseSkill.SpeedHackCheck(aIndex))

  00140	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00143	51		 push	 ecx
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00149	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  0014e	85 c0		 test	 eax, eax
  00150	74 69		 je	 SHORT $LN1@CGDuration
$LN3@CGDuration:

; 15251: 		{
; 15252: 			return;
; 15253: 		}
; 15254: 	}
; 15255: 
; 15256: 	if ( !gObjUseSkill.EnableSkill(lpMagic->m_Skill, lpMagic->m_Level) )

  00152	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  00156	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00159	52		 push	 edx
  0015a	50		 push	 eax
  0015b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00160	e8 00 00 00 00	 call	 ?EnableSkill@CObjUseSkill@@QAEHKH@Z ; CObjUseSkill::EnableSkill
  00165	85 c0		 test	 eax, eax
  00167	74 52		 je	 SHORT $LN1@CGDuration

; 15257: 	{
; 15258: 		return;
; 15259: 	}
; 15260: 
; 15261: 	int aTargetIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 15262: 
; 15263: 	#if(FIX_OBJECT_VIEWE)
; 15264: 	if(OBJMAX_RANGE(aTargetIndex))
; 15265: 	{
; 15266: 		g_ObjectViewe.GCIndexLive(aIndex, aTargetIndex, gObj[aTargetIndex].Type, gObj[aTargetIndex].Live);
; 15267: 	}
; 15268: 	#endif
; 15269: 
; 15270: 	#if(PET_FENRIR_FIX)
; 15271: 	if(!OBJMAX_RANGE(aTargetIndex))
; 15272: 	{
; 15273: 
; 15274: 	}
; 15275: 	#endif
; 15276: 
; 15277: 	gObjUseSkill.UseSkill(aIndex, lpMagic,lpMsg->X, lpMsg->Y, lpMsg->Dir, lpMsg->TargetPos, aTargetIndex);

  00169	0f b6 4e 0a	 movzx	 ecx, BYTE PTR [esi+10]
  0016d	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  00171	66 c1 e1 08	 shl	 cx, 8
  00175	0f b7 d1	 movzx	 edx, cx
  00178	0f b6 4e 09	 movzx	 ecx, BYTE PTR [esi+9]
  0017c	0b d0		 or	 edx, eax
  0017e	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  00182	52		 push	 edx
  00183	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00187	51		 push	 ecx
  00188	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  0018c	52		 push	 edx
  0018d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00190	50		 push	 eax
  00191	51		 push	 ecx
  00192	53		 push	 ebx
  00193	52		 push	 edx
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00199	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 15278: 
; 15279: 	if ( lpMsg->MagicKey )

  0019e	80 7e 0c 00	 cmp	 BYTE PTR [esi+12], 0
  001a2	74 17		 je	 SHORT $LN1@CGDuration

; 15280: 	{
; 15281: 		lpObj->DurMagicKeyChecker.SetDurationTime(lpMsg->MagicKey, GetTickCount());

  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001aa	50		 push	 eax
  001ab	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  001af	50		 push	 eax
  001b0	8d 8f 48 11 00
	00		 lea	 ecx, DWORD PTR [edi+4424]
  001b6	e8 00 00 00 00	 call	 ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ; TDurMagicKeyChecker::SetDurationTime
$LN1@CGDuration:
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx

; 15282: 	}
; 15283: }

  001be	5d		 pop	 ebp
  001bf	c3		 ret	 0
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ENDP ; CGDurationMagicRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ObjectMapJoinPositionSend@@YAXF@Z		; ObjectMapJoinPositionSend
; Function compile flags: /Ogtp
;	COMDAT ?ObjectMapJoinPositionSend@@YAXF@Z
_TEXT	SEGMENT
_pObject$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?ObjectMapJoinPositionSend@@YAXF@Z PROC			; ObjectMapJoinPositionSend, COMDAT

; 15286: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	0f b7 5d 08	 movzx	 ebx, WORD PTR _aIndex$[ebp]

; 15287: 	PMSG_USERMAPJOIN pObject;
; 15288: 	
; 15289: 	PHeadSubSetB((LPBYTE)&pObject, 0xF3, 0x03, sizeof(pObject));

  00015	6a 0a		 push	 10			; 0000000aH
  00017	6a 03		 push	 3
  00019	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  0001c	68 f3 00 00 00	 push	 243			; 000000f3H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 15290: 	pObject.NumberH = SET_NUMBERH(aIndex);

  00027	0f bf cb	 movsx	 ecx, bx

; 15291: 	pObject.NumberL = SET_NUMBERL(aIndex);
; 15292: 	pObject.X = gObj[aIndex].X;

  0002a	8b c1		 mov	 eax, ecx
  0002c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00032	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	8b d1		 mov	 edx, ecx
  0003a	c1 ea 08	 shr	 edx, 8
  0003d	88 55 f4	 mov	 BYTE PTR _pObject$[ebp+4], dl
  00040	88 5d f5	 mov	 BYTE PTR _pObject$[ebp+5], bl
  00043	0f b6 90 44 01
	00 00		 movzx	 edx, BYTE PTR [eax+324]
  0004a	88 55 f6	 mov	 BYTE PTR _pObject$[ebp+6], dl

; 15293: 	pObject.Y = gObj[aIndex].Y;

  0004d	0f b6 90 46 01
	00 00		 movzx	 edx, BYTE PTR [eax+326]
  00054	88 55 f7	 mov	 BYTE PTR _pObject$[ebp+7], dl

; 15294: 	pObject.MapNumber = gObj[aIndex].MapNumber;

  00057	0f b6 90 49 01
	00 00		 movzx	 edx, BYTE PTR [eax+329]
  0005e	88 55 f8	 mov	 BYTE PTR _pObject$[ebp+8], dl

; 15295: 	pObject.Dir = gObj[aIndex].Dir;

  00061	8a 80 48 01 00
	00		 mov	 al, BYTE PTR [eax+328]

; 15296: 
; 15297: 	DataSend(aIndex, (LPBYTE)&pObject, pObject.h.size);

  00067	0f b6 55 f1	 movzx	 edx, BYTE PTR _pObject$[ebp+1]
  0006b	88 45 f9	 mov	 BYTE PTR _pObject$[ebp+9], al
  0006e	52		 push	 edx
  0006f	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15298: }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007f	33 cd		 xor	 ecx, ebp
  00081	5b		 pop	 ebx
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?ObjectMapJoinPositionSend@@YAXF@Z ENDP			; ObjectMapJoinPositionSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCReFillSend@@YAXHHEEH@Z			; GCReFillSend
; Function compile flags: /Ogtp
;	COMDAT ?GCReFillSend@@YAXHHEEH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Life$ = 12						; size = 4
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_wShield$ = 24						; size = 4
?GCReFillSend@@YAXHHEEH@Z PROC				; GCReFillSend, COMDAT

; 16551: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 16552: 	if(0>Life||0>wShield) return;

  00010	83 7d 0c 00	 cmp	 DWORD PTR _Life$[ebp], 0
  00014	7c 54		 jl	 SHORT $LN1@GCReFillSe
  00016	53		 push	 ebx
  00017	8b 5d 18	 mov	 ebx, DWORD PTR _wShield$[ebp]
  0001a	85 db		 test	 ebx, ebx
  0001c	78 4b		 js	 SHORT $LN5@GCReFillSe

; 16553: 
; 16554: 	PMSG_REFILL pMsg;
; 16555: 
; 16556: 	PHeadSetB((LPBYTE)&pMsg, 0x26, sizeof(pMsg));

  0001e	6a 14		 push	 20			; 00000014H
  00020	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00023	6a 26		 push	 38			; 00000026H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16557: 	pMsg.IPos = Ipos;
; 16558: 	pMsg.LifeH = SET_NUMBERH(Life);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _Life$[ebp]
  0002e	8a 4d 10	 mov	 cl, BYTE PTR _Ipos$[ebp]
  00031	8b d0		 mov	 edx, eax
  00033	c1 ea 08	 shr	 edx, 8
  00036	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00039	88 55 ec	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 16559: 	pMsg.LifeL = SET_NUMBERL(Life);
; 16560: 	pMsg.btShieldH = SET_NUMBERH(wShield);
; 16561: 	pMsg.btShieldL = SET_NUMBERL(wShield);
; 16562: 	pMsg.Flag = 0;
; 16563: 	pMsg.Life = Life;
; 16564: 	pMsg.Shield = wShield;
; 16565: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003c	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00040	8b cb		 mov	 ecx, ebx
  00042	c1 e9 08	 shr	 ecx, 8
  00045	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00048	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0004b	52		 push	 edx
  0004c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004f	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+7], cl
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00055	50		 push	 eax
  00056	51		 push	 ecx
  00057	88 5d f0	 mov	 BYTE PTR _pMsg$[ebp+8], bl
  0005a	c6 45 ee 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
  0005e	89 5d f8	 mov	 DWORD PTR _pMsg$[ebp+16], ebx
  00061	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00066	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@GCReFillSe:
  00069	5b		 pop	 ebx
$LN1@GCReFillSe:

; 16566: }

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?GCReFillSend@@YAXHHEEH@Z ENDP				; GCReFillSend
_TEXT	ENDS
PUBLIC	??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCManaSend@@YAXHHEEH@Z				; GCManaSend
;	COMDAT ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@ DB 'GCMa'
	DB	'naSend() return %s %d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCManaSend@@YAXHHEEH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Mana$ = 12						; size = 4
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_BP$ = 24						; size = 4
?GCManaSend@@YAXHHEEH@Z PROC				; GCManaSend, COMDAT

; 16569: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 16570: 
; 16571: 	if ( aIndex < 0 || aIndex > OBJMAX-1)

  00014	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0001a	0f 87 8b 00 00
	00		 ja	 $LN5@GCManaSend

; 16574: 		return;
; 16575: 	}
; 16576: 
; 16577: 	if ( gObj[aIndex].Type != OBJ_USER )

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	8b c7		 mov	 eax, edi
  00028	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002e	66 83 7c 08 68
	01		 cmp	 WORD PTR [eax+ecx+104], 1
  00034	75 66		 jne	 SHORT $LN7@GCManaSend

; 16578: 	{
; 16579: 		return;
; 16580: 	}
; 16581: 
; 16582: #ifdef DEBUG_CODE
; 16583: 	LogAddC(2,"Mana: %d | BP: %d",Mana,BP);
; 16584: 
; 16585: #endif
; 16586: 
; 16587: 	int NewMana = Mana;

  00036	53		 push	 ebx
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR _Mana$[ebp]
  0003a	56		 push	 esi
  0003b	8b f3		 mov	 esi, ebx

; 16588: 
; 16589: 	if(Mana > 65535)

  0003d	81 fb ff ff 00
	00		 cmp	 ebx, 65535		; 0000ffffH
  00043	7e 07		 jle	 SHORT $LN3@GCManaSend

; 16590: 	{
; 16591: 		Mana = 65535;

  00045	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH

; 16592: 	}
; 16593: 
; 16594: 	if(0>Mana||0>BP) return;

  0004a	eb 04		 jmp	 SHORT $LN9@GCManaSend
$LN3@GCManaSend:
  0004c	85 db		 test	 ebx, ebx
  0004e	78 4a		 js	 SHORT $LN10@GCManaSend
$LN9@GCManaSend:
  00050	83 7d 18 00	 cmp	 DWORD PTR _BP$[ebp], 0
  00054	7c 44		 jl	 SHORT $LN10@GCManaSend

; 16595: 
; 16596: 	PMSG_MANASEND pMsg;
; 16597: 
; 16598: 	PHeadSetB((LPBYTE)&pMsg, 0x27, sizeof(pMsg));

  00056	6a 10		 push	 16			; 00000010H
  00058	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0005b	6a 27		 push	 39			; 00000027H
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16599: 	pMsg.IPos = Ipos;

  00063	8a 45 10	 mov	 al, BYTE PTR _Ipos$[ebp]
  00066	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 16600: 	pMsg.ManaH = SET_NUMBERH(Mana);
; 16601: 	pMsg.ManaL = SET_NUMBERL(Mana);
; 16602: 	pMsg.BPH = SET_NUMBERH(BP);

  00069	8b 45 18	 mov	 eax, DWORD PTR _BP$[ebp]
  0006c	8b d0		 mov	 edx, eax

; 16603: 	pMsg.BPL = SET_NUMBERL(BP);

  0006e	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 16604: 	pMsg.Mana = NewMana;
; 16605: 	pMsg.BP = BP;

  00071	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 16606: 
; 16607: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00078	8b cb		 mov	 ecx, ebx
  0007a	c1 e9 08	 shr	 ecx, 8
  0007d	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00080	50		 push	 eax
  00081	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00084	51		 push	 ecx
  00085	c1 ea 08	 shr	 edx, 8
  00088	57		 push	 edi
  00089	88 5d f1	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  0008c	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  0008f	89 75 f4	 mov	 DWORD PTR _pMsg$[ebp+8], esi
  00092	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00097	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@GCManaSend:
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
$LN7@GCManaSend:
  0009c	5f		 pop	 edi

; 16608: }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	33 cd		 xor	 ecx, ebp
  000a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN5@GCManaSend:

; 16572: 	{
; 16573: 		LogAdd("GCManaSend() return %s %d", __FILE__, __LINE__);

  000ab	68 bd 40 00 00	 push	 16573			; 000040bdH
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 16608: }

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	33 cd		 xor	 ecx, ebp
  000c8	5f		 pop	 edi
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?GCManaSend@@YAXHHEEH@Z ENDP				; GCManaSend
_TEXT	ENDS
PUBLIC	?GCInventoryItemDeleteSend@@YAXHEE@Z		; GCInventoryItemDeleteSend
; Function compile flags: /Ogtp
;	COMDAT ?GCInventoryItemDeleteSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_flag$ = 16						; size = 1
?GCInventoryItemDeleteSend@@YAXHEE@Z PROC		; GCInventoryItemDeleteSend, COMDAT

; 16611: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16612: 	PMSG_INVENTORYDELETE pMsg;
; 16613: 	
; 16614: 	PHeadSetB((LPBYTE)&pMsg, 0x28, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 28		 push	 40			; 00000028H
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16615: 	pMsg.IPos = pos;
; 16616: 	pMsg.Flag = flag;
; 16617: 
; 16618: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00013	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00017	8a 4d 0c	 mov	 cl, BYTE PTR _pos$[ebp]
  0001a	8a 55 10	 mov	 dl, BYTE PTR _flag$[ebp]
  0001d	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00020	50		 push	 eax
  00021	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00024	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00027	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 18	 add	 esp, 24			; 00000018H

; 16619: }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?GCInventoryItemDeleteSend@@YAXHEE@Z ENDP		; GCInventoryItemDeleteSend
_TEXT	ENDS
PUBLIC	?GCItemUseSpecialTimeSend@@YAXHEH@Z		; GCItemUseSpecialTimeSend
; Function compile flags: /Ogtp
;	COMDAT ?GCItemUseSpecialTimeSend@@YAXHEH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_number$ = 12						; size = 1
_time$ = 16						; size = 4
?GCItemUseSpecialTimeSend@@YAXHEH@Z PROC		; GCItemUseSpecialTimeSend, COMDAT

; 16622: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 16623: 	if ( time > 65535 )

  00007	8b 75 10	 mov	 esi, DWORD PTR _time$[ebp]
  0000a	81 fe ff ff 00
	00		 cmp	 esi, 65535		; 0000ffffH
  00010	7e 05		 jle	 SHORT $LN1@GCItemUseS

; 16624: 	{
; 16625: 		time = 65535;

  00012	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
$LN1@GCItemUseS:

; 16626: 	}
; 16627: 
; 16628: 	PMSG_ITEMUSESPECIALTIME pMsg;
; 16629: 
; 16630: 	PHeadSetBE((LPBYTE)&pMsg, 0x29, sizeof(pMsg));

  00017	6a 06		 push	 6
  00019	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	6a 29		 push	 41			; 00000029H
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 16631: 	pMsg.Number = number;
; 16632: 	pMsg.Time = time;
; 16633: 
; 16634: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00024	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00028	8a 4d 0c	 mov	 cl, BYTE PTR _number$[ebp]
  0002b	52		 push	 edx
  0002c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	66 89 75 fc	 mov	 WORD PTR _pMsg$[ebp+4], si
  0003b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00040	83 c4 18	 add	 esp, 24			; 00000018H
  00043	5e		 pop	 esi

; 16635: }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?GCItemUseSpecialTimeSend@@YAXHEH@Z ENDP		; GCItemUseSpecialTimeSend
_TEXT	ENDS
PUBLIC	?GCItemDurSend@@YAXHEEE@Z			; GCItemDurSend
; Function compile flags: /Ogtp
;	COMDAT ?GCItemDurSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend@@YAXHEEE@Z PROC				; GCItemDurSend, COMDAT

; 16638: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16639: 	PMSG_ITEMDUR pMsg;
; 16640: 
; 16641: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16642: 	pMsg.IPos = pos;

  00013	8a 4d 0c	 mov	 cl, BYTE PTR _pos$[ebp]

; 16643: 	pMsg.Dur = dur;

  00016	8a 55 10	 mov	 dl, BYTE PTR _dur$[ebp]

; 16644: 	pMsg.Flag = flag;

  00019	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  0001c	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 16645: 
; 16646: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00023	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00026	51		 push	 ecx
  00027	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0002a	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0002d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00030	52		 push	 edx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 16647: }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?GCItemDurSend@@YAXHEEE@Z ENDP				; GCItemDurSend
_TEXT	ENDS
PUBLIC	?GCItemDurSend2@@YAXHEEE@Z			; GCItemDurSend2
; Function compile flags: /Ogtp
;	COMDAT ?GCItemDurSend2@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend2@@YAXHEEE@Z PROC				; GCItemDurSend2, COMDAT

; 16650: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16651: 	PMSG_ITEMDUR pMsg;
; 16652: 
; 16653: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16654: 	pMsg.IPos = pos;

  00013	8a 4d 0c	 mov	 cl, BYTE PTR _pos$[ebp]

; 16655: 	pMsg.Dur = dur;

  00016	8a 55 10	 mov	 dl, BYTE PTR _dur$[ebp]

; 16656: 	pMsg.Flag = flag;

  00019	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  0001c	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 16657: 
; 16658: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00023	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00026	51		 push	 ecx
  00027	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0002a	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0002d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00030	52		 push	 edx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 16659: }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?GCItemDurSend2@@YAXHEEE@Z ENDP				; GCItemDurSend2
_TEXT	ENDS
PUBLIC	?CGWeatherSend@@YAXHE@Z				; CGWeatherSend
; Function compile flags: /Ogtp
;	COMDAT ?CGWeatherSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_weather$ = 12						; size = 1
?CGWeatherSend@@YAXHE@Z PROC				; CGWeatherSend, COMDAT

; 16662: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 16663: 	PMSG_WEATHER pMsg;
; 16664: 
; 16665: 	PHeadSetB((LPBYTE)&pMsg, 0x0F, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16666: 	pMsg.Weather = weather;
; 16667: 
; 16668: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _weather$[ebp]
  00018	52		 push	 edx
  00019	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 16669: }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?CGWeatherSend@@YAXHE@Z ENDP				; CGWeatherSend
_TEXT	ENDS
PUBLIC	?GCServerCmd@@YAXHEEE@Z				; GCServerCmd
; Function compile flags: /Ogtp
;	COMDAT ?GCServerCmd@@YAXHEEE@Z
_TEXT	SEGMENT
_ServerCmd$ = -8					; size = 7
_aIndex$ = 8						; size = 4
_type$ = 12						; size = 1
_Cmd1$ = 16						; size = 1
_Cmd2$ = 20						; size = 1
?GCServerCmd@@YAXHEEE@Z PROC				; GCServerCmd, COMDAT

; 16672: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 16673: 	PMSG_SERVERCMD ServerCmd;
; 16674: 
; 16675: 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00006	6a 07		 push	 7
  00008	6a 40		 push	 64			; 00000040H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 16676: 	ServerCmd.CmdType = type;

  00018	8a 4d 0c	 mov	 cl, BYTE PTR _type$[ebp]

; 16677: 	ServerCmd.X = Cmd1;

  0001b	8a 55 10	 mov	 dl, BYTE PTR _Cmd1$[ebp]

; 16678: 	ServerCmd.Y = Cmd2;

  0001e	8a 45 14	 mov	 al, BYTE PTR _Cmd2$[ebp]
  00021	88 4d fc	 mov	 BYTE PTR _ServerCmd$[ebp+4], cl

; 16679: 
; 16680: 	DataSend(aIndex, (LPBYTE)&ServerCmd, ServerCmd.h.size);

  00024	0f b6 4d f9	 movzx	 ecx, BYTE PTR _ServerCmd$[ebp+1]
  00028	88 55 fd	 mov	 BYTE PTR _ServerCmd$[ebp+5], dl
  0002b	51		 push	 ecx
  0002c	8d 55 f8	 lea	 edx, DWORD PTR _ServerCmd$[ebp]
  0002f	88 45 fe	 mov	 BYTE PTR _ServerCmd$[ebp+6], al
  00032	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00035	52		 push	 edx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 16681: }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GCServerCmd@@YAXHEEE@Z ENDP				; GCServerCmd
_TEXT	ENDS
PUBLIC	??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	__real@3f800000
PUBLIC	??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@ ; `string'
PUBLIC	??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0CB@KHNDAMDC@You?5have?5reached?5the?5daily?5limit@ ; `string'
PUBLIC	??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@ ; `string'
PUBLIC	?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
EXTRN	?IncObjCount@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::IncObjCount
EXTRN	?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z:PROC	; CDevilSquare::GetDevilSquareIndex
EXTRN	?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z:PROC ; CDevilSquare::GetUserLevelToEnter
EXTRN	?GetObjCount@CDevilSquareGround@@QAEJXZ:PROC	; CDevilSquareGround::GetObjCount
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
EXTRN	?ExAccData@@3PAUEX_ACC_DATA@@A:BYTE		; ExAccData
EXTRN	?AccountDataAdd@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; AccountDataAdd
EXTRN	?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; AccountDataGet
EXTRN	?GetPkLevel@PartyClass@@QAEDH@Z:PROC		; PartyClass::GetPkLevel
;	COMDAT ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\devilsquare.h
CONST	SEGMENT
??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@ DB 'return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] Remov'
	DB	'eItem[%s][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError '
	DB	'[%d][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@
CONST	SEGMENT
??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@ DB '['
	DB	'DevilSquare] [%s][%s] GetUserLevelToEnter() failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KHNDAMDC@You?5have?5reached?5the?5daily?5limit@
CONST	SEGMENT
??_C@_0CB@KHNDAMDC@You?5have?5reached?5the?5daily?5limit@ DB 'You have re'
	DB	'ached the daily limit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@
CONST	SEGMENT
??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@ DB '['
	DB	'DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z
_TEXT	SEGMENT
tv669 = -40						; size = 4
tv667 = -40						; size = 4
_sitem$ = -40						; size = 4
tv639 = -36						; size = 4
tv638 = -32						; size = 4
_movegateindex$ = -28					; size = 4
_cInvitationItemPos$ = -24				; size = 1
tv595 = -20						; size = 4
_ItemLevel$ = -16					; size = 4
_bPlayerKiller$ = -16					; size = 4
tv596 = -12						; size = 4
_pResult$ = -8						; size = 4
_cSquareNumber$ = -1					; size = 1
_lpMsg$ = 8						; size = 4
tv675 = 12						; size = 4
_aIndex$ = 12						; size = 4
tv672 = 14						; size = 2
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z PROC ; GCReqmoveDevilSquare, COMDAT

; 16684: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 16685: 	if ( aIndex < 0 || aIndex > OBJMAX-1 )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00010	0f 87 f9 04 00
	00		 ja	 $LN37@GCReqmoveD

; 16688: 		return;
; 16689: 	}
; 16690: 
; 16691: 	BYTE cSquareNumber = lpMsg->SquareNumber;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 16692: 	BYTE cInvitationItemPos = lpMsg->InvitationItemPos - INVENTORY_BAG_START;
; 16693: 
; 16694: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type != 12 )

  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	53		 push	 ebx
  00020	8a 58 03	 mov	 bl, BYTE PTR [eax+3]
  00023	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00026	2c 0c		 sub	 al, 12			; 0000000cH
  00028	88 45 e8	 mov	 BYTE PTR _cInvitationItemPos$[ebp], al
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	8b 84 06 1c 0e
	00 00		 mov	 eax, DWORD PTR [esi+eax+3612]
  00037	88 5d ff	 mov	 BYTE PTR _cSquareNumber$[ebp], bl
  0003a	a8 03		 test	 al, 3
  0003c	74 10		 je	 SHORT $LN36@GCReqmoveD
  0003e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00043	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  00048	0f 85 11 01 00
	00		 jne	 $LN60@GCReqmoveD
$LN36@GCReqmoveD:
  0004e	57		 push	 edi

; 16695: 	{
; 16696: 		return;
; 16697: 	}
; 16698: 
; 16699: 	PMSG_RESULT_MOVEDEVILSQUARE pResult;
; 16700: 
; 16701: 	PHeadSetB((LPBYTE)&pResult, 0x90, sizeof(pResult));

  0004f	6a 04		 push	 4
  00051	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00054	68 90 00 00 00	 push	 144			; 00000090H
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16702: 	pResult.Result = 0;
; 16703: 
; 16704: 	LPOBJ lpObj = &gObj[aIndex];

  0005f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16705: 
; 16706: 	LogAddTD("[DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);

  00065	0f b6 c3	 movzx	 eax, bl
  00068	89 45 ec	 mov	 DWORD PTR tv595[ebp], eax
  0006b	40		 inc	 eax
  0006c	50		 push	 eax
  0006d	c6 45 fb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00071	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  00078	89 45 f4	 mov	 DWORD PTR tv596[ebp], eax
  0007b	0f bf 86 be 00
	00 00		 movsx	 eax, WORD PTR [esi+190]
  00082	50		 push	 eax
  00083	51		 push	 ecx
  00084	8d 7e 77	 lea	 edi, DWORD PTR [esi+119]
  00087	57		 push	 edi
  00088	8d 5e 6c	 lea	 ebx, DWORD PTR [esi+108]
  0008b	53		 push	 ebx
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00097	83 c4 24	 add	 esp, 36			; 00000024H

; 16707: 
; 16708: 	BOOL bPlayerKiller = FALSE; //Season 2.5 add-on
; 16709: 
; 16710: 	if(ZtConfig.PvP.ZtPkPartySystem && lpObj->PartyNumber >= 0) //Season 2.5 add-on

  0009a	83 3d 38 09 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2360, 0
  000a1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bPlayerKiller$[ebp], 0
  000a8	74 20		 je	 SHORT $LN53@GCReqmoveD
  000aa	8b 86 2c 04 00
	00		 mov	 eax, DWORD PTR [esi+1068]
  000b0	85 c0		 test	 eax, eax
  000b2	78 16		 js	 SHORT $LN53@GCReqmoveD

; 16711: 	{
; 16712: 		if(gParty.GetPkLevel(lpObj->PartyNumber) >= 5)

  000b4	50		 push	 eax
  000b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000ba	e8 00 00 00 00	 call	 ?GetPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPkLevel
  000bf	3c 05		 cmp	 al, 5
  000c1	7c 07		 jl	 SHORT $LN53@GCReqmoveD

; 16713: 		{
; 16714: 			bPlayerKiller = TRUE;

  000c3	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bPlayerKiller$[ebp], 1
$LN53@GCReqmoveD:

; 16715: 		}
; 16716: 	}
; 16717: 
; 16718: 	if(!ZtConfig.Event.DSAllowPKPlayer)

  000ca	83 3d 8c 08 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2188, 0
  000d1	75 10		 jne	 SHORT $LN32@GCReqmoveD

; 16719: 	{
; 16720: 		if(lpObj->m_PK_Level >= 4)

  000d3	80 be 3d 01 00
	00 04		 cmp	 BYTE PTR [esi+317], 4
  000da	7c 07		 jl	 SHORT $LN32@GCReqmoveD

; 16721: 		{
; 16722: 			bPlayerKiller = TRUE;

  000dc	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bPlayerKiller$[ebp], 1
$LN32@GCReqmoveD:

; 16723: 		}
; 16724: 	}
; 16725: 
; 16726: #if(WAITENI_CUSTOM)
; 16727: 
; 16728: 	if(ZtConfig.CommonServer.DevilSqueryCount)

  000e3	83 3d 48 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+328, 0
  000ea	74 4f		 je	 SHORT $LN55@GCReqmoveD

; 16729: 	{
; 16730: 		if(AccountDataGet(lpObj) == -1)

  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 ?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z ; AccountDataGet
  000f2	83 c4 04	 add	 esp, 4
  000f5	83 f8 ff	 cmp	 eax, -1
  000f8	75 09		 jne	 SHORT $LN30@GCReqmoveD

; 16731: 		{
; 16732: 			AccountDataAdd(lpObj);	

  000fa	56		 push	 esi
  000fb	e8 00 00 00 00	 call	 ?AccountDataAdd@@YAXPAUOBJECTSTRUCT@@@Z ; AccountDataAdd
  00100	83 c4 04	 add	 esp, 4
$LN30@GCReqmoveD:

; 16733: 		}
; 16734: 
; 16735: 		int iAccInx = AccountDataGet(lpObj);

  00103	56		 push	 esi
  00104	e8 00 00 00 00	 call	 ?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z ; AccountDataGet
  00109	83 c4 04	 add	 esp, 4

; 16736: 
; 16737: 		if(iAccInx != -1)

  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	74 2a		 je	 SHORT $LN55@GCReqmoveD

; 16738: 		{
; 16739: 
; 16740: 			//MsgNormal(aIndex, "DS %d / %d", ExAccData[iAccInx].DevilSqueryCount, ZtConfig.CommonServer.DevilSqueryCount);
; 16741: 
; 16742: 			if(ExAccData[iAccInx].DevilSqueryCount >= ZtConfig.CommonServer.DevilSqueryCount)

  00111	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00114	8b 04 95 10 00
	00 00		 mov	 eax, DWORD PTR ?ExAccData@@3PAUEX_ACC_DATA@@A[edx*4+16]
  0011b	3b 05 48 01 00
	00		 cmp	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+328
  00121	7c 18		 jl	 SHORT $LN55@GCReqmoveD

; 16743: 			{
; 16744: 				MsgNormal(aIndex, "You have reached the daily limit");

  00123	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KHNDAMDC@You?5have?5reached?5the?5daily?5limit@
  0012b	51		 push	 ecx
  0012c	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00131	83 c4 08	 add	 esp, 8
  00134	5f		 pop	 edi
  00135	5b		 pop	 ebx
  00136	5e		 pop	 esi

; 16926: }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
$LN55@GCReqmoveD:

; 16745: 				
; 16746: 				//pResult.Result = 6;
; 16747: 				//DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 16748: 				return;
; 16749: 			}
; 16750: 
; 16751: 			//ExAccData[iAccInx].DevilSqueryCount++;
; 16752: 		}
; 16753: 	}
; 16754: 
; 16755: #endif
; 16756: 
; 16757: 	if ( bPlayerKiller == TRUE )

  0013b	b9 01 00 00 00	 mov	 ecx, 1
  00140	39 4d f0	 cmp	 DWORD PTR _bPlayerKiller$[ebp], ecx
  00143	75 20		 jne	 SHORT $LN27@GCReqmoveD

; 16758: 	{
; 16759: 		pResult.Result = 6;
; 16760: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00145	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00149	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0014c	52		 push	 edx
  0014d	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00150	50		 push	 eax
  00151	51		 push	 ecx
  00152	c6 45 fb 06	 mov	 BYTE PTR _pResult$[ebp+3], 6
  00156	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015e	5f		 pop	 edi
$LN60@GCReqmoveD:
  0015f	5b		 pop	 ebx
  00160	5e		 pop	 esi

; 16926: }

  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
$LN27@GCReqmoveD:

; 16761: 		return;
; 16762: 	}
; 16763: 
; 16764: 	if ( MAIN_INVENTORY_RANGE(cInvitationItemPos) == FALSE )

  00165	b2 cb		 mov	 dl, 203			; 000000cbH
  00167	3a 55 e8	 cmp	 dl, BYTE PTR _cInvitationItemPos$[ebp]
  0016a	1b c0		 sbb	 eax, eax
  0016c	40		 inc	 eax
  0016d	75 2e		 jne	 SHORT $LN26@GCReqmoveD

; 16765: 	{
; 16766: 		pResult.Result = 1;
; 16767: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0016f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00173	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00176	88 4d fb	 mov	 BYTE PTR _pResult$[ebp+3], cl
  00179	50		 push	 eax
  0017a	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0017d	51		 push	 ecx
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16768: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);

  00184	8b 45 f4	 mov	 eax, DWORD PTR tv596[ebp]
  00187	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  0018e	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR [esi+184]
  00195	50		 push	 eax
  00196	51		 push	 ecx
  00197	52		 push	 edx

; 16769: 		return;

  00198	e9 a9 00 00 00	 jmp	 $LN72@GCReqmoveD
$LN26@GCReqmoveD:

; 16770: 	}
; 16771: 
; 16772: 	if ( DS_LEVEL_RANGE(cSquareNumber) == FALSE )

  0019d	b8 06 00 00 00	 mov	 eax, 6
  001a2	3a 45 ff	 cmp	 al, BYTE PTR _cSquareNumber$[ebp]
  001a5	1b c0		 sbb	 eax, eax
  001a7	40		 inc	 eax
  001a8	75 05		 jne	 SHORT $LN25@GCReqmoveD

; 16773: 	{
; 16774: 		pResult.Result = 1;

  001aa	88 4d fb	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 16775: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 16776: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 16777: 		return;

  001ad	eb 71		 jmp	 SHORT $LN71@GCReqmoveD
$LN25@GCReqmoveD:

; 16778: 	}
; 16779: 
; 16780: 	if ( g_DevilSquare.GetState() != DevilSquare_OPEN )

  001af	39 0d 04 00 00
	00		 cmp	 DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+4, ecx
  001b5	74 06		 je	 SHORT $LN24@GCReqmoveD

; 16781: 	{
; 16782: 		pResult.Result = 2;

  001b7	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 16783: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 16784: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 16785: 		return;

  001bb	eb 63		 jmp	 SHORT $LN71@GCReqmoveD
$LN24@GCReqmoveD:

; 16786: 	}
; 16787: 
; 16788: 	if ( g_DevilSquare.m_DevilSquareGround[cSquareNumber].GetObjCount() >= MAX_DEVILSQUARE_USER )

  001bd	8b 4d ec	 mov	 ecx, DWORD PTR tv595[ebp]
  001c0	69 c9 a8 04 00
	00		 imul	 ecx, 1192		; 000004a8H
  001c6	81 c1 3c 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+60
  001cc	e8 00 00 00 00	 call	 ?GetObjCount@CDevilSquareGround@@QAEJXZ ; CDevilSquareGround::GetObjCount
  001d1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001d4	7c 06		 jl	 SHORT $LN23@GCReqmoveD

; 16789: 	{
; 16790: 		pResult.Result = 5;

  001d6	c6 45 fb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5

; 16791: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 16792: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 16793: 		return;

  001da	eb 44		 jmp	 SHORT $LN71@GCReqmoveD
$LN23@GCReqmoveD:

; 16794: 	}
; 16795: 
; 16796: 	CItem * sitem = &lpObj->pInventory[cInvitationItemPos];

  001dc	0f b6 45 e8	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  001e0	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  001e6	89 45 e0	 mov	 DWORD PTR tv638[ebp], eax
  001e9	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H

; 16797: 
; 16798: 	if ( sitem->m_Type != ITEMGET(14,19) && ( sitem->m_Type != ITEMGET(13,46) || sitem->m_Durability <= 0.0f ) )	// Devil's Invitation

  001ef	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  001f4	03 c8		 add	 ecx, eax
  001f6	89 45 dc	 mov	 DWORD PTR tv639[ebp], eax
  001f9	b8 13 1c 00 00	 mov	 eax, 7187		; 00001c13H
  001fe	89 4d d8	 mov	 DWORD PTR _sitem$[ebp], ecx
  00201	66 3b d0	 cmp	 dx, ax
  00204	74 57		 je	 SHORT $LN56@GCReqmoveD
  00206	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  0020b	66 3b d0	 cmp	 dx, ax
  0020e	75 0c		 jne	 SHORT $LN21@GCReqmoveD
  00210	d9 ee		 fldz
  00212	d8 59 24	 fcomp	 DWORD PTR [ecx+36]
  00215	df e0		 fnstsw	 ax
  00217	f6 c4 01	 test	 ah, 1
  0021a	75 41		 jne	 SHORT $LN56@GCReqmoveD
$LN21@GCReqmoveD:

; 16799: 	{
; 16800: 		pResult.Result = 1;

  0021c	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
$LN71@GCReqmoveD:

; 16801: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00220	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00224	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00227	51		 push	 ecx
  00228	8d 55 f8	 lea	 edx, DWORD PTR _pResult$[ebp]
  0022b	52		 push	 edx
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16802: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);

  00232	8b 4d f4	 mov	 ecx, DWORD PTR tv596[ebp]
  00235	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  0023c	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00243	51		 push	 ecx
  00244	52		 push	 edx
  00245	50		 push	 eax
$LN72@GCReqmoveD:
  00246	57		 push	 edi
  00247	53		 push	 ebx
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  0024d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00253	83 c4 24	 add	 esp, 36			; 00000024H
  00256	5f		 pop	 edi
  00257	5b		 pop	 ebx
  00258	5e		 pop	 esi

; 16926: }

  00259	8b e5		 mov	 esp, ebp
  0025b	5d		 pop	 ebp
  0025c	c3		 ret	 0
$LN56@GCReqmoveD:

; 16803: 		return;
; 16804: 	}
; 16805: 
; 16806: 	int ItemLevel = sitem->m_Level;

  0025d	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]

; 16807: 
; 16808: 	if ( sitem->m_Type == ITEMGET(13,46) )

  00261	b9 2e 1a 00 00	 mov	 ecx, 6702		; 00001a2eH
  00266	89 45 f0	 mov	 DWORD PTR _ItemLevel$[ebp], eax
  00269	66 3b d1	 cmp	 dx, cx
  0026c	75 47		 jne	 SHORT $LN20@GCReqmoveD

; 16809: 	{
; 16810: 		ItemLevel = 10;

  0026e	c7 45 f0 0a 00
	00 00		 mov	 DWORD PTR _ItemLevel$[ebp], 10 ; 0000000aH
$LN15@GCReqmoveD:

; 16833: 				return;
; 16834: 			}
; 16835: 		}
; 16836: 	}
; 16837: 
; 16838: 	BOOL bEnterCheck = FALSE;
; 16839: 	int movegateindex = 61;
; 16840: 
; 16841: 	int iENTER_LEVEL = g_DevilSquare.GetUserLevelToEnter(aIndex, movegateindex);

  00275	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00278	8d 45 e4	 lea	 eax, DWORD PTR _movegateindex$[ebp]
  0027b	50		 push	 eax
  0027c	51		 push	 ecx
  0027d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00282	c7 45 e4 3d 00
	00 00		 mov	 DWORD PTR _movegateindex$[ebp], 61 ; 0000003dH
  00289	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z ; CDevilSquare::GetUserLevelToEnter

; 16842: 
; 16843: 	if ( DS_LEVEL_RANGE(iENTER_LEVEL) == FALSE )

  0028e	85 c0		 test	 eax, eax
  00290	78 0c		 js	 SHORT $LN50@GCReqmoveD
  00292	33 c9		 xor	 ecx, ecx
  00294	83 f8 06	 cmp	 eax, 6
  00297	0f 9e c1	 setle	 cl
  0029a	85 c9		 test	 ecx, ecx
  0029c	75 6a		 jne	 SHORT $LN14@GCReqmoveD
$LN50@GCReqmoveD:

; 16844: 	{
; 16845: 		LogAddTD("[DevilSquare] [%s][%s] GetUserLevelToEnter() failed", lpObj->AccountID, lpObj->Name);

  0029e	57		 push	 edi
  0029f	53		 push	 ebx
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ae	5f		 pop	 edi
  002af	5b		 pop	 ebx
  002b0	5e		 pop	 esi

; 16926: }

  002b1	8b e5		 mov	 esp, ebp
  002b3	5d		 pop	 ebp
  002b4	c3		 ret	 0
$LN20@GCReqmoveD:

; 16811: 	}
; 16812: 
; 16813: 	int level = lpObj->Level;
; 16814: 
; 16815: 	if ( lpObj->Class == CLASS_DARKLORD 
; 16816: #ifdef MONK
; 16817: 		|| lpObj->Class == CLASS_MONK
; 16818: #endif
; 16819: 		|| lpObj->Class == CLASS_MAGUMSA )
; 16820: 	{
; 16821: 		level = (level+1)/2*3;
; 16822: 	}
; 16823: 
; 16824: 	if ( ItemLevel != 0 )

  002b5	85 c0		 test	 eax, eax
  002b7	74 bc		 je	 SHORT $LN15@GCReqmoveD

; 16825: 	{
; 16826: 		if ( ItemLevel != 10 )

  002b9	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002bc	74 b7		 je	 SHORT $LN15@GCReqmoveD

; 16827: 		{
; 16828: 			if ( ItemLevel != (cSquareNumber+1) )

  002be	3b 45 f4	 cmp	 eax, DWORD PTR tv596[ebp]
  002c1	74 b2		 je	 SHORT $LN15@GCReqmoveD

; 16829: 			{
; 16830: 				pResult.Result = 1;
; 16831: 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002c3	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  002c7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002ca	52		 push	 edx
  002cb	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  002ce	50		 push	 eax
  002cf	51		 push	 ecx
  002d0	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  002d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16832: 				LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError [%d][%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1, ItemLevel);

  002d9	8b 55 f0	 mov	 edx, DWORD PTR _ItemLevel$[ebp]
  002dc	8b 45 f4	 mov	 eax, DWORD PTR tv596[ebp]
  002df	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  002e6	52		 push	 edx
  002e7	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR [esi+184]
  002ee	50		 push	 eax
  002ef	51		 push	 ecx
  002f0	52		 push	 edx
  002f1	57		 push	 edi
  002f2	53		 push	 ebx
  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@

; 16878: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);

  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002fe	83 c4 28	 add	 esp, 40			; 00000028H
  00301	5f		 pop	 edi
  00302	5b		 pop	 ebx
  00303	5e		 pop	 esi

; 16926: }

  00304	8b e5		 mov	 esp, ebp
  00306	5d		 pop	 ebp
  00307	c3		 ret	 0
$LN14@GCReqmoveD:

; 16846: 		return;
; 16847: 	}
; 16848: 
; 16849: 	if ( ItemLevel == 10 )

  00308	83 7d f0 0a	 cmp	 DWORD PTR _ItemLevel$[ebp], 10 ; 0000000aH

; 16850: 	{
; 16851: 		cSquareNumber = iENTER_LEVEL;

  0030c	8a c8		 mov	 cl, al
  0030e	74 03		 je	 SHORT $LN13@GCReqmoveD
  00310	8a 4d ff	 mov	 cl, BYTE PTR _cSquareNumber$[ebp]
$LN13@GCReqmoveD:

; 16852: 	}
; 16853: 
; 16854: 	if ( cSquareNumber != iENTER_LEVEL )

  00313	0f b6 c9	 movzx	 ecx, cl
  00316	89 4d ec	 mov	 DWORD PTR tv595[ebp], ecx
  00319	3b c8		 cmp	 ecx, eax
  0031b	74 77		 je	 SHORT $LN8@GCReqmoveD

; 16855: 	{
; 16856: 		if ( cSquareNumber > iENTER_LEVEL )
; 16857: 		{
; 16858: 			bEnterCheck = 2;
; 16859: 		}
; 16860: 		else

  0031d	7f 30		 jg	 SHORT $LN51@GCReqmoveD

; 16861: 		{
; 16862: 			bEnterCheck = 1;
; 16863: 		}
; 16864: 	}
; 16865: 
; 16866: 	if ( bEnterCheck == 1 )
; 16867: 	{
; 16868: 		pResult.Result = 3;
; 16869: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0031f	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00323	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00326	52		 push	 edx
  00327	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0032a	50		 push	 eax
  0032b	51		 push	 ecx
  0032c	c6 45 fb 03	 mov	 BYTE PTR _pResult$[ebp+3], 3
  00330	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16870: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);

  00335	8b 55 f0	 mov	 edx, DWORD PTR _ItemLevel$[ebp]
  00338	8b 45 ec	 mov	 eax, DWORD PTR tv595[ebp]
  0033b	0f bf 8e be 00
	00 00		 movsx	 ecx, WORD PTR [esi+190]
  00342	52		 push	 edx
  00343	0f b7 96 b8 00
	00 00		 movzx	 edx, WORD PTR [esi+184]
  0034a	50		 push	 eax
  0034b	51		 push	 ecx
  0034c	52		 push	 edx

; 16871: 		return;

  0034d	eb 2e		 jmp	 SHORT $LN69@GCReqmoveD
$LN51@GCReqmoveD:

; 16872: 	}
; 16873: 
; 16874: 	if ( bEnterCheck == 2 )
; 16875: 	{
; 16876: 		pResult.Result = 4;
; 16877: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0034f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00353	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00356	50		 push	 eax
  00357	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0035a	51		 push	 ecx
  0035b	52		 push	 edx
  0035c	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4
  00360	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16878: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);

  00365	8b 45 f0	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00368	8b 4d ec	 mov	 ecx, DWORD PTR tv595[ebp]
  0036b	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  00372	50		 push	 eax
  00373	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  0037a	51		 push	 ecx
  0037b	52		 push	 edx
  0037c	50		 push	 eax
$LN69@GCReqmoveD:
  0037d	57		 push	 edi
  0037e	53		 push	 ebx
  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  00384	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0038a	83 c4 28	 add	 esp, 40			; 00000028H
  0038d	5f		 pop	 edi
  0038e	5b		 pop	 ebx
  0038f	5e		 pop	 esi

; 16926: }

  00390	8b e5		 mov	 esp, ebp
  00392	5d		 pop	 ebp
  00393	c3		 ret	 0
$LN8@GCReqmoveD:

; 16879: 		return;
; 16880: 	}
; 16881: 
; 16882: 	if ( szAuthKey[6] != AUTHKEY6 )

  00394	80 3d 06 00 00
	00 d6		 cmp	 BYTE PTR ?szAuthKey@@3PADA+6, -42 ; ffffffd6H
  0039b	74 05		 je	 SHORT $LN7@GCReqmoveD

; 16883: 	{
; 16884: 		DestroyGIocp();

  0039d	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN7@GCReqmoveD:

; 16885: 	}
; 16886: 
; 16887: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->Level, cSquareNumber, lpObj->pInventory[cInvitationItemPos].GetName(), cInvitationItemPos, ItemLevel, lpObj->pInventory[cInvitationItemPos].m_Number);

  003a2	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  003a8	03 4d dc	 add	 ecx, DWORD PTR tv639[ebp]
  003ab	8b 55 f0	 mov	 edx, DWORD PTR _ItemLevel$[ebp]
  003ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  003b0	50		 push	 eax
  003b1	8b 45 e0	 mov	 eax, DWORD PTR tv638[ebp]
  003b4	52		 push	 edx
  003b5	50		 push	 eax
  003b6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003bb	8b 4d ec	 mov	 ecx, DWORD PTR tv595[ebp]
  003be	0f bf 96 be 00
	00 00		 movsx	 edx, WORD PTR [esi+190]
  003c5	50		 push	 eax
  003c6	51		 push	 ecx
  003c7	52		 push	 edx
  003c8	57		 push	 edi
  003c9	53		 push	 ebx
  003ca	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  003cf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16888: 
; 16889: 	if ( sitem->m_Type == ITEMGET(14,19) || (sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability == 1.0f) )

  003d5	8b 55 d8	 mov	 edx, DWORD PTR _sitem$[ebp]
  003d8	0f b7 4a 06	 movzx	 ecx, WORD PTR [edx+6]
  003dc	b8 13 1c 00 00	 mov	 eax, 7187		; 00001c13H
  003e1	83 c4 24	 add	 esp, 36			; 00000024H
  003e4	66 3b c8	 cmp	 cx, ax
  003e7	74 74		 je	 SHORT $LN5@GCReqmoveD
  003e9	d9 e8		 fld1
  003eb	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  003f0	66 3b c8	 cmp	 cx, ax
  003f3	75 0e		 jne	 SHORT $LN6@GCReqmoveD
  003f5	d9 42 24	 fld	 DWORD PTR [edx+36]
  003f8	d9 c1		 fld	 ST(1)
  003fa	da e9		 fucompp
  003fc	df e0		 fnstsw	 ax
  003fe	f6 c4 44	 test	 ah, 68			; 00000044H
  00401	7b 58		 jnp	 SHORT $LN65@GCReqmoveD
$LN6@GCReqmoveD:

; 16894: 	}
; 16895: 	else if ( sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability > 1.0f )

  00403	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  00408	66 3b c8	 cmp	 cx, ax
  0040b	75 7d		 jne	 SHORT $LN67@GCReqmoveD
  0040d	d8 5a 24	 fcomp	 DWORD PTR [edx+36]
  00410	df e0		 fnstsw	 ax
  00412	f6 c4 05	 test	 ah, 5
  00415	7a 75		 jp	 SHORT $LN58@GCReqmoveD

; 16896: 	{
; 16897: 		sitem->m_Durability -= 1.0f;

  00417	d9 42 24	 fld	 DWORD PTR [edx+36]

; 16898: 		GCItemDurSend2(lpObj->m_Index, cInvitationItemPos, (BYTE)sitem->m_Durability, 0);

  0041a	6a 00		 push	 0
  0041c	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00422	d9 5d 0c	 fstp	 DWORD PTR tv675[ebp]
  00425	d9 45 0c	 fld	 DWORD PTR tv675[ebp]
  00428	d9 7d 0e	 fnstcw	 WORD PTR tv672[ebp]
  0042b	0f b7 45 0e	 movzx	 eax, WORD PTR tv672[ebp]
  0042f	d9 52 24	 fst	 DWORD PTR [edx+36]
  00432	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00437	89 45 d8	 mov	 DWORD PTR tv669[ebp], eax
  0043a	8b 45 e8	 mov	 eax, DWORD PTR _cInvitationItemPos$[ebp]
  0043d	d9 6d d8	 fldcw	 WORD PTR tv669[ebp]
  00440	db 5d d8	 fistp	 DWORD PTR tv667[ebp]
  00443	8a 4d d8	 mov	 cl, BYTE PTR tv667[ebp]
  00446	0f b6 d1	 movzx	 edx, cl
  00449	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0044b	d9 6d 0e	 fldcw	 WORD PTR tv672[ebp]
  0044e	52		 push	 edx
  0044f	50		 push	 eax
  00450	51		 push	 ecx
  00451	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00456	83 c4 10	 add	 esp, 16			; 00000010H
  00459	eb 31		 jmp	 SHORT $LN58@GCReqmoveD
$LN65@GCReqmoveD:

; 16888: 
; 16889: 	if ( sitem->m_Type == ITEMGET(14,19) || (sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability == 1.0f) )

  0045b	dd d8		 fstp	 ST(0)
$LN5@GCReqmoveD:

; 16890: 	{
; 16891: 		gObjInventoryDeleteItem(aIndex, cInvitationItemPos);

  0045d	8b 55 e0	 mov	 edx, DWORD PTR tv638[ebp]
  00460	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00463	52		 push	 edx
  00464	57		 push	 edi
  00465	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 16892: 		GCInventoryItemDeleteSend(aIndex, cInvitationItemPos, 1);

  0046a	8b 45 e8	 mov	 eax, DWORD PTR _cInvitationItemPos$[ebp]
  0046d	6a 01		 push	 1
  0046f	50		 push	 eax
  00470	57		 push	 edi
  00471	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16893: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00476	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0047a	51		 push	 ecx
  0047b	8d 55 f8	 lea	 edx, DWORD PTR _pResult$[ebp]
  0047e	52		 push	 edx
  0047f	57		 push	 edi
  00480	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00485	83 c4 20	 add	 esp, 32			; 00000020H
  00488	eb 02		 jmp	 SHORT $LN58@GCReqmoveD
$LN67@GCReqmoveD:
  0048a	dd d8		 fstp	 ST(0)
$LN58@GCReqmoveD:

; 16899: 	}
; 16900: 
; 16901: #if(WAITENI_CUSTOM)
; 16902: 
; 16903: 	if(ZtConfig.CommonServer.DevilSqueryCount)

  0048c	33 ff		 xor	 edi, edi
  0048e	39 3d 48 01 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+328, edi
  00494	74 18		 je	 SHORT $LN1@GCReqmoveD

; 16904: 	{
; 16905: 		int iAccInx = AccountDataGet(lpObj);

  00496	56		 push	 esi
  00497	e8 00 00 00 00	 call	 ?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z ; AccountDataGet
  0049c	83 c4 04	 add	 esp, 4

; 16906: 
; 16907: 		if(iAccInx != -1)

  0049f	83 f8 ff	 cmp	 eax, -1
  004a2	74 0a		 je	 SHORT $LN1@GCReqmoveD

; 16908: 		{
; 16909: 			ExAccData[iAccInx].DevilSqueryCount++;

  004a4	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  004a7	ff 04 85 10 00
	00 00		 inc	 DWORD PTR ?ExAccData@@3PAUEX_ACC_DATA@@A[eax*4+16]
$LN1@GCReqmoveD:

; 16910: 		}
; 16911: 	}
; 16912: 
; 16913: #endif
; 16914: 
; 16915: 	lpObj->m_nEventExp = 0;

  004ae	89 be 94 0e 00
	00		 mov	 DWORD PTR [esi+3732], edi

; 16916: 	lpObj->m_nEventScore = 0;

  004b4	89 be 90 0e 00
	00		 mov	 DWORD PTR [esi+3728], edi

; 16917: 	lpObj->m_nEventMoney = 0;

  004ba	89 be 98 0e 00
	00		 mov	 DWORD PTR [esi+3736], edi

; 16918: 	lpObj->m_bDevilSquareIndex = g_DevilSquare.GetDevilSquareIndex(movegateindex);

  004c0	8b 45 e4	 mov	 eax, DWORD PTR _movegateindex$[ebp]
  004c3	50		 push	 eax
  004c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  004c9	e8 00 00 00 00	 call	 ?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z ; CDevilSquare::GetDevilSquareIndex

; 16919: 	lpObj->m_bDevilSquareAuth = true;
; 16920: 	lpObj->m_IfState.state = 0;
; 16921: 	lpObj->m_IfState.type = 0;
; 16922: 	lpObj->m_IfState.use = 0;

  004ce	81 a6 1c 0e 00
	00 00 00 ff ff	 and	 DWORD PTR [esi+3612], -65536 ; ffff0000H

; 16923: 
; 16924: 	gObjMoveGate(lpObj->m_Index, movegateindex);

  004d8	8b 16		 mov	 edx, DWORD PTR [esi]
  004da	88 86 9c 0e 00
	00		 mov	 BYTE PTR [esi+3740], al
  004e0	c6 86 9d 0e 00
	00 01		 mov	 BYTE PTR [esi+3741], 1
  004e7	8b 4d e4	 mov	 ecx, DWORD PTR _movegateindex$[ebp]
  004ea	51		 push	 ecx
  004eb	52		 push	 edx
  004ec	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 16925: 	g_DevilSquare.m_DevilSquareGround[cSquareNumber].IncObjCount();

  004f1	8b 4d ec	 mov	 ecx, DWORD PTR tv595[ebp]
  004f4	69 c9 a8 04 00
	00		 imul	 ecx, 1192		; 000004a8H
  004fa	83 c4 08	 add	 esp, 8
  004fd	81 c1 3c 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+60
  00503	e8 00 00 00 00	 call	 ?IncObjCount@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::IncObjCount
  00508	5f		 pop	 edi
  00509	5b		 pop	 ebx
  0050a	5e		 pop	 esi

; 16926: }

  0050b	8b e5		 mov	 esp, ebp
  0050d	5d		 pop	 ebp
  0050e	c3		 ret	 0
$LN37@GCReqmoveD:

; 16686: 	{
; 16687: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0050f	68 2f 41 00 00	 push	 16687			; 0000412fH
  00514	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00519	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  0051e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00524	83 c4 0c	 add	 esp, 12			; 0000000cH
  00527	5e		 pop	 esi

; 16926: }

  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ENDP ; GCReqmoveDevilSquare
_TEXT	ENDS
PUBLIC	??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
EXTRN	?GetRemainTime@CIllusionTempleEvent@@QAEEXZ:PROC ; CIllusionTempleEvent::GetRemainTime
EXTRN	?GetRemainTime@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetRemainTime
EXTRN	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurEnteredUser
EXTRN	?CheckCanEnter@CChaosCastle@@QAE_NH@Z:PROC	; CChaosCastle::CheckCanEnter
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetUserLevelToEnter
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?GetRemainTime@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetRemainTime
EXTRN	?CheckCanEnter@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckCanEnter
EXTRN	?CheckCloseTime@CDevilSquare@@QAEHXZ:PROC	; CDevilSquare::CheckCloseTime
;	COMDAT ??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
; File e:\work\tranet_version\gs\gameserver\devilsquare.h
CONST	SEGMENT
??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][ChaosCastle] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 7
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z PROC ; GCReqDevilSquareRemainTime, COMDAT

; 16929: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16930: 	PMSG_RESULT_DEVILSQUARE_REMAINTIME pResult;
; 16931: 
; 16932: 	PHeadSetB((LPBYTE)&pResult, 0x91, sizeof(pResult));

  00009	6a 07		 push	 7
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000e	68 91 00 00 00	 push	 145			; 00000091H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16933: 	pResult.RemainTime = 0;
; 16934: 	int inutil = 0;
; 16935: 
; 16936: 	switch ( lpMsg->hEventType )

  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001c	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00020	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00023	48		 dec	 eax
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  0002b	83 f8 04	 cmp	 eax, 4
  0002e	0f 87 26 02 00
	00		 ja	 $LN21@GCReqDevil
  00034	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@GCReqDevil[eax*4]
$LN20@GCReqDevil:

; 16937: 	{
; 16938: 		case 1:
; 16939: 			if ( gObj[aIndex].m_PK_Level >= 4 )

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00041	8b f3		 mov	 esi, ebx
  00043	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00049	80 bc 0e 3d 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+317], 4
  00051	7c 39		 jl	 SHORT $LN19@GCReqDevil

; 16940: 			{
; 16941: 				GCServerCmd(aIndex, 0x37, 0, 0);

  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	6a 37		 push	 55			; 00000037H
  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 16942: 				LogAddTD("[PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	0f be 94 06 3d
	01 00 00	 movsx	 edx, BYTE PTR [esi+eax+317]
  0006c	52		 push	 edx
  0006d	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00071	51		 push	 ecx
  00072	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00076	52		 push	 edx
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00082	83 c4 20	 add	 esp, 32			; 00000020H
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 17044: }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN19@GCReqDevil:

; 16943: 				return;
; 16944: 			}
; 16945: 
; 16946: 			pResult.hEventType = 1;
; 16947: 
; 16948: 			if ( g_DevilSquare.GetState() == DevilSquare_CLOSE )

  0008c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+4
  00091	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00095	85 c0		 test	 eax, eax
  00097	75 0a		 jne	 SHORT $LN18@GCReqDevil

; 16949: 			{
; 16950: 				pResult.RemainTime = g_DevilSquare.GetRemainTime();

  00099	a0 0c 00 00 00	 mov	 al, BYTE PTR ?g_DevilSquare@@3VCDevilSquare@@A+12
  0009e	e9 b4 01 00 00	 jmp	 $LN31@GCReqDevil
$LN18@GCReqDevil:

; 16951: 			}
; 16952: 			else if ( g_DevilSquare.GetState() == DevilSquare_OPEN )

  000a3	83 f8 01	 cmp	 eax, 1
  000a6	75 09		 jne	 SHORT $LN16@GCReqDevil
$LN34@GCReqDevil:

; 16953: 			{
; 16954: 				pResult.RemainTime = 0;

  000a8	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 16955: 			}
; 16956: 			else

  000ac	e9 a9 01 00 00	 jmp	 $LN21@GCReqDevil
$LN16@GCReqDevil:

; 16957: 			{
; 16958: 				pResult.RemainTime = g_DevilSquare.CheckCloseTime();

  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000b6	e8 00 00 00 00	 call	 ?CheckCloseTime@CDevilSquare@@QAEHXZ ; CDevilSquare::CheckCloseTime

; 16959: 			}
; 16960: 			break;

  000bb	e9 97 01 00 00	 jmp	 $LN31@GCReqDevil
$LN14@GCReqDevil:

; 16961: 
; 16962: 		case 2:
; 16963: 			if ( gObj[aIndex].m_PK_Level >= 4 )

  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c6	8b f3		 mov	 esi, ebx
  000c8	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000ce	80 bc 0e 3d 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+317], 4
  000d6	7c 39		 jl	 SHORT $LN13@GCReqDevil

; 16964: 			{
; 16965: 				GCServerCmd(aIndex, 0x38, 0, 0);

  000d8	6a 00		 push	 0
  000da	6a 00		 push	 0
  000dc	6a 38		 push	 56			; 00000038H
  000de	53		 push	 ebx
  000df	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 16966: 
; 16967: 				LogAddTD("[PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e9	0f be 94 06 3d
	01 00 00	 movsx	 edx, BYTE PTR [esi+eax+317]
  000f1	52		 push	 edx
  000f2	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000f6	51		 push	 ecx
  000f7	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000fb	52		 push	 edx
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00107	83 c4 20	 add	 esp, 32			; 00000020H
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx

; 17044: }

  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN13@GCReqDevil:

; 16968: 
; 16969: 				return;
; 16970: 			}
; 16971: 
; 16972: 			pResult.hEventType = 2;
; 16973: 
; 16974: 			if ( g_BloodCastle.GetCurrentState(lpMsg->btItemLevel-1) == 1 )

  00111	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00115	48		 dec	 eax
  00116	50		 push	 eax
  00117	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0011c	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2
  00120	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00125	83 f8 01	 cmp	 eax, 1
  00128	75 2d		 jne	 SHORT $LN12@GCReqDevil

; 16975: 			{
; 16976: 				if ( g_BloodCastle.CheckCanEnter(lpMsg->btItemLevel-1) != false )

  0012a	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0012e	49		 dec	 ecx
  0012f	51		 push	 ecx
  00130	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00135	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  0013a	84 c0		 test	 al, al

; 16977: 				{
; 16978: 					pResult.RemainTime = 0;
; 16979: 				}
; 16980: 				else

  0013c	0f 85 66 ff ff
	ff		 jne	 $LN34@GCReqDevil

; 16981: 				{
; 16982: 					pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  00142	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00146	4a		 dec	 edx
  00147	52		 push	 edx
  00148	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0014d	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime

; 16983: 				}
; 16984: 			}
; 16985: 			else

  00152	e9 00 01 00 00	 jmp	 $LN31@GCReqDevil
$LN12@GCReqDevil:

; 16986: 			{
; 16987: 				pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  00157	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0015b	48		 dec	 eax
  0015c	50		 push	 eax
  0015d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00162	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime

; 16988: 			}
; 16989: 			break;

  00167	e9 eb 00 00 00	 jmp	 $LN31@GCReqDevil
$LN8@GCReqDevil:

; 16990: 		case 4:
; 16991: 			{
; 16992: 				if ( gObj[aIndex].m_PK_Level >= 4 )

  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00172	8b f3		 mov	 esi, ebx
  00174	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0017a	80 bc 0e 3d 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+317], 4
  00182	7c 39		 jl	 SHORT $LN7@GCReqDevil

; 16993: 				{
; 16994: 					GCServerCmd(aIndex, 0x39, 0, 0);

  00184	6a 00		 push	 0
  00186	6a 00		 push	 0
  00188	6a 39		 push	 57			; 00000039H
  0018a	53		 push	 ebx
  0018b	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 16995: 
; 16996: 					LogAddTD("[PK User][ChaosCastle] [%s][%s] Move Fail [PK Level:%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);

  00190	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00195	0f be 94 06 3d
	01 00 00	 movsx	 edx, BYTE PTR [esi+eax+317]
  0019d	52		 push	 edx
  0019e	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  001a2	51		 push	 ecx
  001a3	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  001a7	52		 push	 edx
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b3	83 c4 20	 add	 esp, 32			; 00000020H
  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	5b		 pop	 ebx

; 17044: }

  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN7@GCReqDevil:

; 16997: 
; 16998: 					return;
; 16999: 				}
; 17000: 
; 17001: 				int iENTER_LEVEL =  g_ChaosCastle.GetUserLevelToEnter(aIndex);

  001bd	53		 push	 ebx
  001be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001c3	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  001c8	8b f0		 mov	 esi, eax

; 17002: 
; 17003: 				if ( iENTER_LEVEL == -1 )

  001ca	83 fe ff	 cmp	 esi, -1
  001cd	0f 84 99 00 00
	00		 je	 $LN23@GCReqDevil

; 17004: 				{
; 17005: 					return;
; 17006: 				}
; 17007: 
; 17008: 				pResult.hEventType = 4;
; 17009: 
; 17010: 				if ( g_ChaosCastle.GetCurrentState(iENTER_LEVEL) == 1 )

  001d3	56		 push	 esi
  001d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001d9	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4
  001dd	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState

; 17011: 				{
; 17012: 					if ( g_ChaosCastle.CheckCanEnter(iENTER_LEVEL) != false )

  001e2	56		 push	 esi
  001e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001e8	83 f8 01	 cmp	 eax, 1
  001eb	75 33		 jne	 SHORT $LN5@GCReqDevil
  001ed	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter

; 17016: 						pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001f2	56		 push	 esi
  001f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001f8	84 c0		 test	 al, al
  001fa	74 12		 je	 SHORT $LN4@GCReqDevil

; 17013: 					{
; 17014: 						pResult.RemainTime = 0;
; 17015: 						pResult.RemainTime_LOW = 0;

  001fc	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  00200	c6 45 fe 00	 mov	 BYTE PTR _pResult$[ebp+6], 0

; 17030: 					pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 17031: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  00204	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  00209	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 17032: 				}
; 17033: 			}
; 17034: 			break;

  0020c	eb 4c		 jmp	 SHORT $LN21@GCReqDevil
$LN4@GCReqDevil:

; 17017: 					}
; 17018: 					else
; 17019: 					{
; 17020: 						WORD wREMAIN_TIME = g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  0020e	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  00213	0f b7 c0	 movzx	 eax, ax

; 17021: 						pResult.RemainTime = SET_NUMBERH(wREMAIN_TIME);

  00216	8b c8		 mov	 ecx, eax
  00218	c1 e9 08	 shr	 ecx, 8
  0021b	88 4d fc	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 17022: 						pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 17023: 						pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);
; 17024: 					}
; 17025: 				}
; 17026: 				else

  0021e	eb 10		 jmp	 SHORT $LN32@GCReqDevil
$LN5@GCReqDevil:

; 17027: 				{
; 17028: 					WORD wREMAIN_TIME = g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  00220	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  00225	0f b7 c0	 movzx	 eax, ax

; 17029: 					pResult.RemainTime = SET_NUMBERH(wREMAIN_TIME);

  00228	8b d0		 mov	 edx, eax
  0022a	c1 ea 08	 shr	 edx, 8
  0022d	88 55 fc	 mov	 BYTE PTR _pResult$[ebp+4], dl
$LN32@GCReqDevil:

; 17030: 					pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 17031: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  00230	56		 push	 esi
  00231	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00236	88 45 fe	 mov	 BYTE PTR _pResult$[ebp+6], al
  00239	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  0023e	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 17032: 				}
; 17033: 			}
; 17034: 			break;

  00241	eb 17		 jmp	 SHORT $LN21@GCReqDevil
$LN1@GCReqDevil:

; 17035: 		case 5:
; 17036: 			pResult.hEventType = 5;
; 17037: 			pResult.RemainTime = g_IllusionTempleEvent.GetRemainTime();

  00243	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00248	c6 45 fb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5
  0024c	e8 00 00 00 00	 call	 ?GetRemainTime@CIllusionTempleEvent@@QAEEXZ ; CIllusionTempleEvent::GetRemainTime

; 17038: 			pResult.EnteredUser = 0;

  00251	66 c7 45 fd 00
	00		 mov	 WORD PTR _pResult$[ebp+5], 0
$LN31@GCReqDevil:

; 17035: 		case 5:
; 17036: 			pResult.hEventType = 5;
; 17037: 			pResult.RemainTime = g_IllusionTempleEvent.GetRemainTime();

  00257	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
$LN21@GCReqDevil:

; 17039: 			pResult.RemainTime_LOW = 0;
; 17040: 			break;
; 17041: 	}
; 17042: 
; 17043: 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0025a	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0025e	50		 push	 eax
  0025f	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00262	51		 push	 ecx
  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@GCReqDevil:
  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi
  0026e	5b		 pop	 ebx

; 17044: }

  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	90		 npad	 1
$LN35@GCReqDevil:
  00274	00 00 00 00	 DD	 $LN20@GCReqDevil
  00278	00 00 00 00	 DD	 $LN14@GCReqDevil
  0027c	00 00 00 00	 DD	 $LN21@GCReqDevil
  00280	00 00 00 00	 DD	 $LN8@GCReqDevil
  00284	00 00 00 00	 DD	 $LN1@GCReqDevil
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ENDP ; GCReqDevilSquareRemainTime
_TEXT	ENDS
PUBLIC	?AllSendMsg@@YAXPAEH@Z				; AllSendMsg
; Function compile flags: /Ogtp
;	COMDAT ?AllSendMsg@@YAXPAEH@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
?AllSendMsg@@YAXPAEH@Z PROC				; AllSendMsg, COMDAT

; 17047: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17048: 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00013	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL5@AllSendMsg:

; 17049: 	{
; 17050: 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 1b		 jne	 SHORT $LN4@AllSendMsg

; 17051: 		{
; 17052: 			if ( gObj[n].Type == OBJ_USER )

  0001f	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00025	75 13		 jne	 SHORT $LN4@AllSendMsg

; 17053: 			{
; 17054: 				DataSend(n, Msg, size);

  00027	8b 45 08	 mov	 eax, DWORD PTR _Msg$[ebp]
  0002a	53		 push	 ebx
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@AllSendMsg:

; 17048: 	for ( int n=OBJ_STARTUSERINDZT;n<OBJMAX;n++)

  0003a	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00040	47		 inc	 edi
  00041	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00047	7c cf		 jl	 SHORT $LL5@AllSendMsg
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 17055: 			}
; 17056: 		}
; 17057: 	}
; 17058: }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?AllSendMsg@@YAXPAEH@Z ENDP				; AllSendMsg
_TEXT	ENDS
PUBLIC	?AllSendSameMapMsg@@YAXPAEHE@Z			; AllSendSameMapMsg
; Function compile flags: /Ogtp
;	COMDAT ?AllSendSameMapMsg@@YAXPAEHE@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
_mapnumber$ = 16					; size = 1
?AllSendSameMapMsg@@YAXPAEHE@Z PROC			; AllSendSameMapMsg, COMDAT

; 17061: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17062: 	for ( int n=0;n<OBJMAX;n++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 ff		 xor	 edi, edi
  00010	33 f6		 xor	 esi, esi
$LL6@AllSendSam:

; 17063: 	{
; 17064: 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00012	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  00017	75 27		 jne	 SHORT $LN5@AllSendSam

; 17065: 		{
; 17066: 			if ( gObj[n].Type == OBJ_USER )

  00019	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  0001f	75 1f		 jne	 SHORT $LN5@AllSendSam

; 17067: 			{
; 17068: 				if ( gObj[n].MapNumber == mapnumber )

  00021	8a 4d 10	 mov	 cl, BYTE PTR _mapnumber$[ebp]
  00024	38 8c 06 49 01
	00 00		 cmp	 BYTE PTR [esi+eax+329], cl
  0002b	75 13		 jne	 SHORT $LN5@AllSendSam

; 17069: 				{
; 17070: 					DataSend(n, Msg, size);

  0002d	8b 55 08	 mov	 edx, DWORD PTR _Msg$[ebp]
  00030	53		 push	 ebx
  00031	52		 push	 edx
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AllSendSam:

; 17062: 	for ( int n=0;n<OBJMAX;n++)

  00040	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00046	47		 inc	 edi
  00047	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  0004d	7c c3		 jl	 SHORT $LL6@AllSendSam
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 17071: 				}
; 17072: 			}
; 17073: 		}
; 17074: 	}
; 17075: }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?AllSendSameMapMsg@@YAXPAEHE@Z ENDP			; AllSendSameMapMsg
_TEXT	ENDS
PUBLIC	?GCSendPing@@YAXH@Z				; GCSendPing
; Function compile flags: /Ogtp
;	COMDAT ?GCSendPing@@YAXH@Z
_TEXT	SEGMENT
_pMsgPing$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCSendPing@@YAXH@Z PROC				; GCSendPing, COMDAT

; 17078: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 17079: 	PMSG_PING pMsgPing;
; 17080: 
; 17081: 	PHeadSetB((LPBYTE)&pMsgPing, 0x71, sizeof(pMsgPing));

  00005	6a 03		 push	 3
  00007	8d 45 fc	 lea	 eax, DWORD PTR _pMsgPing$[ebp]
  0000a	6a 71		 push	 113			; 00000071H
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17082: 	gObj[aIndex].iPingTime = GetTickCount();

  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00024	8b d1		 mov	 edx, ecx
  00026	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0002c	89 44 32 54	 mov	 DWORD PTR [edx+esi+84], eax

; 17083: 
; 17084: 	DataSend(aIndex, (LPBYTE)&pMsgPing, pMsgPing.h.size);

  00030	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsgPing$[ebp+1]
  00034	50		 push	 eax
  00035	8d 55 fc	 lea	 edx, DWORD PTR _pMsgPing$[ebp]
  00038	52		 push	 edx
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	5e		 pop	 esi

; 17085: }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GCSendPing@@YAXH@Z ENDP				; GCSendPing
_TEXT	ENDS
PUBLIC	??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms?$AA@ ; `string'
PUBLIC	?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z	; GCPingSendRecv
;	COMDAT ??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms?$AA@
CONST	SEGMENT
??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms?$AA@ DB '['
	DB	'%s][%s] Ping = %d ms', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z PROC	; GCPingSendRecv, COMDAT

; 17088: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 17089: 	int PingTime = GetTickCount() - gObj[aIndex].iPingTime;

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0000d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00019	2b 46 54	 sub	 eax, DWORD PTR [esi+84]

; 17090: 
; 17091: 	LogAdd("[%s][%s] Ping = %d ms", gObj[aIndex].AccountID, gObj[aIndex].Name, PingTime);

  0001c	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	83 c6 6c	 add	 esi, 108		; 0000006cH
  00024	56		 push	 esi
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms?$AA@
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	5e		 pop	 esi

; 17092: }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z ENDP	; GCPingSendRecv
_TEXT	ENDS
PUBLIC	??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Event@ ; `string'
PUBLIC	??_C@_0DK@BJLEJBLB@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone?5@ ; `string'
PUBLIC	??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ ; `string'
PUBLIC	??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
;	COMDAT ??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #3 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Event@
CONST	SEGMENT
??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Event@ DB '['
	DB	'Stone] [%s][%s] Not Found EventChip (Stone Pos: %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BJLEJBLB@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone?5@
CONST	SEGMENT
??_C@_0DK@BJLEJBLB@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone?5@ DB '['
	DB	'Stone] [%s][%s] Register Stone (Stone Pos:%d, Serial:%u)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
CONST	SEGMENT
??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
CONST	SEGMENT
??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using Trade Window', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z
_TEXT	SEGMENT
_sitem$ = -36						; size = 4
_Result$250607 = -32					; size = 8
_Result$250596 = -32					; size = 8
_Result$250582 = -32					; size = 8
_Result$250575 = -32					; size = 8
_Pos$ = -28						; size = 4
_pMsg$250602 = -24					; size = 20
_pMsg$250592 = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z PROC	; GCRegEventChipRecv, COMDAT

; 17095: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 17096: 	if ( !EVENCHIP_TYPE_RANGE(lpMsg->Type) )

  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	3a 47 03	 cmp	 al, BYTE PTR [edi+3]
  00020	1b c0		 sbb	 eax, eax
  00022	40		 inc	 eax
  00023	0f 84 c0 02 00
	00		 je	 $LN5@GCRegEvent

; 17097: 	{
; 17098: 		return;
; 17099: 	}
; 17100: 
; 17101: 	LPOBJ lpObj = &gObj[aIndex];

  00029	56		 push	 esi
  0002a	8b f3		 mov	 esi, ebx
  0002c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00032	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17102: 
; 17103: 	if ( lpObj->m_IfState.type == 1 )

  00038	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0003e	c1 e8 06	 shr	 eax, 6
  00041	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00046	83 f8 01	 cmp	 eax, 1
  00049	75 27		 jne	 SHORT $LN13@GCRegEvent

; 17104: 	{
; 17105: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using Trade Window", lpObj->AccountID, lpObj->Name);

  0004b	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0004e	51		 push	 ecx
  0004f	83 c6 6c	 add	 esi, 108		; 0000006cH
  00052	56		 push	 esi
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	5e		 pop	 esi
  00062	5f		 pop	 edi
  00063	5b		 pop	 ebx

; 17204: 			break;
; 17205: 	}
; 17206: }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN13@GCRegEvent:

; 17106: 		return;
; 17107: 	}
; 17108: 
; 17109: 	if ( lpObj->m_IfState.type == 7 )

  00072	83 f8 07	 cmp	 eax, 7
  00075	75 27		 jne	 SHORT $LN12@GCRegEvent

; 17110: 	{
; 17111: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window", lpObj->AccountID, lpObj->Name);

  00077	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  0007a	52		 push	 edx
  0007b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0007e	56		 push	 esi
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	5e		 pop	 esi
  0008e	5f		 pop	 edi
  0008f	5b		 pop	 ebx

; 17204: 			break;
; 17205: 	}
; 17206: }

  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$LN12@GCRegEvent:

; 17112: 		return;
; 17113: 	}
; 17114: 
; 17115: 	if ( lpObj->UseEventServer != FALSE )

  0009e	83 be 50 10 00
	00 00		 cmp	 DWORD PTR [esi+4176], 0
  000a5	74 58		 je	 SHORT $LN11@GCRegEvent

; 17116: 	{
; 17117: 		PMSG_REGEVENTCHIP_RESULT Result;
; 17118: 
; 17119: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  000a7	6a 08		 push	 8
  000a9	8d 45 e0	 lea	 eax, DWORD PTR _Result$250575[ebp]
  000ac	68 95 00 00 00	 push	 149			; 00000095H
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17122: 
; 17123: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d", lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  000b7	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  000bb	52		 push	 edx
  000bc	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  000bf	50		 push	 eax
  000c0	83 c6 6c	 add	 esi, 108		; 0000006cH
  000c3	56		 push	 esi
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
$LN27@GCRegEvent:

; 17120: 		Result.ChipCount = -1;
; 17121: 		Result.Type = lpMsg->Type;

  000c9	8a 4f 03	 mov	 cl, BYTE PTR [edi+3]
  000cc	88 4d e3	 mov	 BYTE PTR _Result$250575[ebp+3], cl
  000cf	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _Result$250575[ebp+4], -1

; 17122: 
; 17123: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d", lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 17124: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000dc	0f b6 4d e1	 movzx	 ecx, BYTE PTR _Result$250575[ebp+1]
  000e0	51		 push	 ecx
  000e1	8d 55 e0	 lea	 edx, DWORD PTR _Result$250575[ebp]
  000e4	52		 push	 edx
  000e5	53		 push	 ebx
  000e6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17169: 
; 17170: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000eb	83 c4 28	 add	 esp, 40			; 00000028H
  000ee	5e		 pop	 esi
  000ef	5f		 pop	 edi
  000f0	5b		 pop	 ebx

; 17204: 			break;
; 17205: 	}
; 17206: }

  000f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	33 cd		 xor	 ecx, ebp
  000f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
$LN11@GCRegEvent:

; 17125: 		return;
; 17126: 	}
; 17127: 
; 17128: 	int Pos = lpMsg->ChipPos + INVENTORY_BAG_START;

  000ff	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	89 4d e4	 mov	 DWORD PTR _Pos$[ebp], ecx

; 17129: 	CItem * sitem = &lpObj->pInventory[Pos];

  00109	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0010f	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  00115	89 4d dc	 mov	 DWORD PTR _sitem$[ebp], ecx

; 17130: 
; 17131: 	if ( !sitem->IsItem() )

  00118	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0011d	85 c0		 test	 eax, eax
  0011f	75 24		 jne	 SHORT $LN10@GCRegEvent

; 17132: 	{
; 17133: 		PMSG_REGEVENTCHIP_RESULT Result;
; 17134: 
; 17135: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00121	6a 08		 push	 8
  00123	8d 45 e0	 lea	 eax, DWORD PTR _Result$250582[ebp]
  00126	68 95 00 00 00	 push	 149			; 00000095H
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17136: 		Result.ChipCount = -1;
; 17137: 		Result.Type = lpMsg->Type;
; 17138: 
; 17139: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d", lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  00131	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00135	52		 push	 edx
  00136	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00139	50		 push	 eax
  0013a	83 c6 6c	 add	 esi, 108		; 0000006cH
  0013d	56		 push	 esi
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@

; 17140: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);
; 17141: 		return;

  00143	eb 84		 jmp	 SHORT $LN27@GCRegEvent
$LN10@GCRegEvent:

; 17142: 	}
; 17143: 
; 17144: 	lpObj->UseEventServer = TRUE;

  00145	b9 01 00 00 00	 mov	 ecx, 1
  0014a	89 8e 50 10 00
	00		 mov	 DWORD PTR [esi+4176], ecx

; 17145: 
; 17146: 	switch ( lpMsg->Type )

  00150	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00154	83 e8 00	 sub	 eax, 0
  00157	0f 84 db 00 00
	00		 je	 $LN7@GCRegEvent
  0015d	2b c1		 sub	 eax, ecx
  0015f	74 1b		 je	 SHORT $LN4@GCRegEvent

; 17202: 		default:
; 17203: 			lpObj->UseEventServer = FALSE;

  00161	c7 86 50 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4176], 0
  0016b	5e		 pop	 esi
  0016c	5f		 pop	 edi
  0016d	5b		 pop	 ebx

; 17204: 			break;
; 17205: 	}
; 17206: }

  0016e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00171	33 cd		 xor	 ecx, ebp
  00173	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
$LN4@GCRegEvent:

; 17172: 			}
; 17173: 			break;
; 17174: 		case 0x01:
; 17175: 			if ( sitem->m_Type == ITEMGET(14,21) && sitem->m_Level == 1 )

  0017c	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  0017f	ba 15 1c 00 00	 mov	 edx, 7189		; 00001c15H
  00184	66 39 50 06	 cmp	 WORD PTR [eax+6], dx
  00188	75 6d		 jne	 SHORT $LN3@GCRegEvent
  0018a	66 39 48 08	 cmp	 WORD PTR [eax+8], cx
  0018e	75 67		 jne	 SHORT $LN3@GCRegEvent

; 17176: 			{
; 17177: 				PMSG_REQ_REGISTER_STONES pMsg;
; 17178: 
; 17179: 				PHeadSetB((LPBYTE)&pMsg, 0x06, sizeof(pMsg));

  00190	6a 14		 push	 20			; 00000014H
  00192	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$250602[ebp]
  00195	6a 06		 push	 6
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17180: 				pMsg.iINDEX = aIndex;
; 17181: 				pMsg.iPosition = Pos;

  0019d	8a 4d e4	 mov	 cl, BYTE PTR _Pos$[ebp]
  001a0	89 5d ec	 mov	 DWORD PTR _pMsg$250602[ebp+4], ebx

; 17182: 				strcpy(pMsg.szUID, lpObj->AccountID);

  001a3	8d 5e 6c	 lea	 ebx, DWORD PTR [esi+108]
  001a6	8d 55 f1	 lea	 edx, DWORD PTR _pMsg$250602[ebp+9]
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ac	88 4d f0	 mov	 BYTE PTR _pMsg$250602[ebp+8], cl
  001af	8b c3		 mov	 eax, ebx
  001b1	2b d3		 sub	 edx, ebx
$LL20@GCRegEvent:
  001b3	8a 08		 mov	 cl, BYTE PTR [eax]
  001b5	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  001b8	40		 inc	 eax
  001b9	84 c9		 test	 cl, cl
  001bb	75 f6		 jne	 SHORT $LL20@GCRegEvent

; 17183: 
; 17184: 				DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  001bd	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$250602[ebp]
  001c0	6a 14		 push	 20			; 00000014H
  001c2	52		 push	 edx
  001c3	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 17185: 
; 17186: 				LogAddTD("[Stone] [%s][%s] Register Stone (Stone Pos:%d, Serial:%u)", lpObj->AccountID, lpObj->Name, lpMsg->ChipPos, sitem->m_Number);

  001c8	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  001cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cd	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  001d1	51		 push	 ecx
  001d2	52		 push	 edx
  001d3	83 c6 77	 add	 esi, 119		; 00000077H
  001d6	56		 push	 esi
  001d7	53		 push	 ebx
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@BJLEJBLB@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone?5@
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e3	83 c4 1c	 add	 esp, 28			; 0000001cH
  001e6	5e		 pop	 esi
  001e7	5f		 pop	 edi
  001e8	5b		 pop	 ebx

; 17204: 			break;
; 17205: 	}
; 17206: }

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
$LN3@GCRegEvent:

; 17187: 			}
; 17188: 			else
; 17189: 			{
; 17190: 				PMSG_REGEVENTCHIP_RESULT Result;
; 17191: 
; 17192: 				PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  001f7	6a 08		 push	 8
  001f9	8d 45 e0	 lea	 eax, DWORD PTR _Result$250607[ebp]
  001fc	68 95 00 00 00	 push	 149			; 00000095H
  00201	50		 push	 eax
  00202	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17193: 				Result.ChipCount = -1;
; 17194: 				Result.Type = 0x01;
; 17195: 
; 17196: 				LogAddTD("[Stone] [%s][%s] Not Found EventChip (Stone Pos: %d)", lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  00207	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0020b	51		 push	 ecx
  0020c	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  0020f	52		 push	 edx
  00210	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  00213	50		 push	 eax
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Event@
  00219	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _Result$250607[ebp+4], -1
  00220	c6 45 e3 01	 mov	 BYTE PTR _Result$250607[ebp+3], 1
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 17197: 
; 17198: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0022a	0f b6 4d e1	 movzx	 ecx, BYTE PTR _Result$250607[ebp+1]
  0022e	51		 push	 ecx
  0022f	8d 55 e0	 lea	 edx, DWORD PTR _Result$250607[ebp]
  00232	52		 push	 edx

; 17199: 				lpObj->UseEventServer = FALSE;
; 17200: 			}
; 17201: 			break;

  00233	e9 9d 00 00 00	 jmp	 $LN25@GCRegEvent
$LN7@GCRegEvent:

; 17147: 	{
; 17148: 		case 0x00:
; 17149: 			if ( sitem->m_Type == ITEMGET(14,21) && sitem->m_Level == 0 )

  00238	8b 45 dc	 mov	 eax, DWORD PTR _sitem$[ebp]
  0023b	b9 15 1c 00 00	 mov	 ecx, 7189		; 00001c15H
  00240	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  00244	75 53		 jne	 SHORT $LN6@GCRegEvent
  00246	66 83 78 08 00	 cmp	 WORD PTR [eax+8], 0
  0024b	75 4c		 jne	 SHORT $LN6@GCRegEvent

; 17150: 			{
; 17151: 				PMSG_REQ_REGISTER_EVENTCHIP pMsg;
; 17152: 
; 17153: 				PHeadSetB((LPBYTE)&pMsg, 0x02, sizeof(pMsg));

  0024d	6a 14		 push	 20			; 00000014H
  0024f	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$250592[ebp]
  00252	6a 02		 push	 2
  00254	52		 push	 edx
  00255	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17154: 				pMsg.iINDEX = aIndex;
; 17155: 				pMsg.Pos = Pos;

  0025a	8a 45 e4	 mov	 al, BYTE PTR _Pos$[ebp]
  0025d	88 45 f0	 mov	 BYTE PTR _pMsg$250592[ebp+8], al

; 17156: 				strcpy(pMsg.szUID, lpObj->AccountID);

  00260	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  00263	8d 55 f1	 lea	 edx, DWORD PTR _pMsg$250592[ebp+9]
  00266	83 c4 0c	 add	 esp, 12			; 0000000cH
  00269	89 5d ec	 mov	 DWORD PTR _pMsg$250592[ebp+4], ebx
  0026c	2b d0		 sub	 edx, eax
  0026e	8b ff		 npad	 2
$LL19@GCRegEvent:
  00270	8a 08		 mov	 cl, BYTE PTR [eax]
  00272	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00275	40		 inc	 eax
  00276	84 c9		 test	 cl, cl
  00278	75 f6		 jne	 SHORT $LL19@GCRegEvent

; 17157: 
; 17158: 				DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  0027a	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$250592[ebp]
  0027d	6a 14		 push	 20			; 00000014H
  0027f	51		 push	 ecx
  00280	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00285	83 c4 08	 add	 esp, 8
  00288	5e		 pop	 esi
  00289	5f		 pop	 edi
  0028a	5b		 pop	 ebx

; 17204: 			break;
; 17205: 	}
; 17206: }

  0028b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028e	33 cd		 xor	 ecx, ebp
  00290	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00295	8b e5		 mov	 esp, ebp
  00297	5d		 pop	 ebp
  00298	c3		 ret	 0
$LN6@GCRegEvent:

; 17159: 			}
; 17160: 			else
; 17161: 			{
; 17162: 				PMSG_REGEVENTCHIP_RESULT Result;
; 17163: 
; 17164: 				PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00299	6a 08		 push	 8
  0029b	8d 55 e0	 lea	 edx, DWORD PTR _Result$250596[ebp]
  0029e	68 95 00 00 00	 push	 149			; 00000095H
  002a3	52		 push	 edx
  002a4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17165: 				Result.ChipCount = -1;
; 17166: 				Result.Type = 0x00;
; 17167: 
; 17168: 				LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #3 %d", lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);

  002a9	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  002ad	50		 push	 eax
  002ae	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  002b1	51		 push	 ecx
  002b2	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  002b5	52		 push	 edx
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
  002bb	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _Result$250596[ebp+4], -1
  002c2	c6 45 e3 00	 mov	 BYTE PTR _Result$250596[ebp+3], 0
  002c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 17169: 
; 17170: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  002cc	0f b6 45 e1	 movzx	 eax, BYTE PTR _Result$250596[ebp+1]
  002d0	50		 push	 eax
  002d1	8d 4d e0	 lea	 ecx, DWORD PTR _Result$250596[ebp]
  002d4	51		 push	 ecx
$LN25@GCRegEvent:
  002d5	53		 push	 ebx
  002d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002db	83 c4 28	 add	 esp, 40			; 00000028H

; 17171: 				lpObj->UseEventServer = FALSE;

  002de	c7 86 50 10 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4176], 0
  002e8	5e		 pop	 esi
$LN5@GCRegEvent:

; 17204: 			break;
; 17205: 	}
; 17206: }

  002e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ec	5f		 pop	 edi
  002ed	33 cd		 xor	 ecx, ebp
  002ef	5b		 pop	 ebx
  002f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f5	8b e5		 mov	 esp, ebp
  002f7	5d		 pop	 ebp
  002f8	c3		 ret	 0
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ENDP	; GCRegEventChipRecv
_TEXT	ENDS
PUBLIC	??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@ ; `string'
PUBLIC	??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
EXTRN	?gObjFind10EventChip@@YAHH@Z:PROC		; gObjFind10EventChip
;	COMDAT ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@
CONST	SEGMENT
??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@ DB '['
	DB	'EventChip] [%s][%s] Request MutoNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@
CONST	SEGMENT
??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@ DB 0c0H
	DB	0ccH, 0b9H, 0ccH, ' ', 0b7H, 0e7H, 0b0H, 0a1H, 0b5H, 0e5H, 0c0H
	DB	0c7H, ' ', 0bcH, 0fdH, 0c0H, 0daH, 0b0H, 0a1H, ' ', 0c0H, 0d6H
	DB	0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -292						; size = 20
_Result$250621 = -272					; size = 10
_msg$250617 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z PROC	; GCGetMutoNumRecv, COMDAT

; 17209: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17210: 	if ( gObj[aIndex].MutoNumber != 0 )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001d	8b f7		 mov	 esi, edi
  0001f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00025	83 bc 06 4c 10
	00 00 00	 cmp	 DWORD PTR [esi+eax+4172], 0
  0002d	74 34		 je	 SHORT $LN3@GCGetMutoN

; 17211: 	{
; 17212: 		char msg[255];
; 17213: 		wsprintf(msg, "   ");

  0002f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$250617[ebp]
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 17214: 		GCServerMsgStringSend(msg, aIndex, 1);

  00041	6a 01		 push	 1
  00043	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$250617[ebp]
  00049	57		 push	 edi
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 17247: 
; 17248: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00050	83 c4 14	 add	 esp, 20			; 00000014H
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 17249: }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN3@GCGetMutoN:

; 17215: 		return;
; 17216: 	}
; 17217: 
; 17218: 	if ( gObj[aIndex].UseEventServer != FALSE )

  00063	83 bc 06 50 10
	00 00 00	 cmp	 DWORD PTR [esi+eax+4176], 0
  0006b	8d 84 06 50 10
	00 00		 lea	 eax, DWORD PTR [esi+eax+4176]
  00072	0f 85 d1 00 00
	00		 jne	 $LN4@GCGetMutoN

; 17219: 	{
; 17220: 		return;
; 17221: 	}
; 17222: 
; 17223: 	gObj[aIndex].UseEventServer = TRUE;
; 17224: 
; 17225: 	if ( !gObjFind10EventChip(aIndex) )

  00078	57		 push	 edi
  00079	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  0007f	e8 00 00 00 00	 call	 ?gObjFind10EventChip@@YAHH@Z ; gObjFind10EventChip
  00084	83 c4 04	 add	 esp, 4
  00087	85 c0		 test	 eax, eax
  00089	75 5e		 jne	 SHORT $LN1@GCGetMutoN

; 17226: 	{
; 17227: 		PMSG_GETMUTONUMBER_RESULT Result;
; 17228: 
; 17229: 		PHeadSetB((LPBYTE)&Result, 0x96, sizeof(Result));

  0008b	6a 0a		 push	 10			; 0000000aH
  0008d	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _Result$250621[ebp]
  00093	68 96 00 00 00	 push	 150			; 00000096H
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17230: 		Result.MutoNum[0] = -1;

  0009e	83 c8 ff	 or	 eax, -1
  000a1	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _Result$250621[ebp+4], ax

; 17231: 		Result.MutoNum[1] = 0;
; 17232: 		Result.MutoNum[2] = 0;
; 17233: 
; 17234: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000a8	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _Result$250621[ebp+1]
  000af	33 c9		 xor	 ecx, ecx
  000b1	89 8d f6 fe ff
	ff		 mov	 DWORD PTR _Result$250621[ebp+6], ecx
  000b7	50		 push	 eax
  000b8	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Result$250621[ebp]
  000be	51		 push	 ecx
  000bf	57		 push	 edi
  000c0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17235: 		gObj[aIndex].UseEventServer = FALSE;

  000c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	5f		 pop	 edi
  000cf	c7 84 16 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+4176], 0
  000da	5e		 pop	 esi

; 17249: }

  000db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	33 cd		 xor	 ecx, ebp
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN1@GCGetMutoN:

; 17236: 
; 17237: 		return;
; 17238: 	}
; 17239: 
; 17240: 	PMSG_REQ_REGISTER_MUTONUM pMsg;
; 17241: 
; 17242: 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  000e9	6a 14		 push	 20			; 00000014H
  000eb	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000f1	6a 03		 push	 3
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17243: 	pMsg.iINDEX = aIndex;
; 17244: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	8d 44 0e 6c	 lea	 eax, DWORD PTR [esi+ecx+108]
  00103	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010c	89 bd e0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+4], edi
  00112	2b d0		 sub	 edx, eax
$LL6@GCGetMutoN:
  00114	8a 08		 mov	 cl, BYTE PTR [eax]
  00116	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00119	40		 inc	 eax
  0011a	84 c9		 test	 cl, cl
  0011c	75 f6		 jne	 SHORT $LL6@GCGetMutoN

; 17245: 
; 17246: 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  0011e	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00124	6a 14		 push	 20			; 00000014H
  00126	52		 push	 edx
  00127	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 17247: 
; 17248: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0012c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00135	51		 push	 ecx
  00136	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0013a	52		 push	 edx
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00146	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@GCGetMutoN:

; 17249: }

  00149	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014c	5f		 pop	 edi
  0014d	33 cd		 xor	 ecx, ebp
  0014f	5e		 pop	 esi
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ENDP	; GCGetMutoNumRecv
_TEXT	ENDS
PUBLIC	?GCUseEndEventChipRescv@@YAXH@Z			; GCUseEndEventChipRescv
; Function compile flags: /Ogtp
;	COMDAT ?GCUseEndEventChipRescv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCUseEndEventChipRescv@@YAXH@Z PROC			; GCUseEndEventChipRescv, COMDAT

; 17252: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 17253: 	if ( !gObjIsConnectedGP(aIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 1d		 jne	 SHORT $LN2@GCUseEndEv

; 17254: 	{
; 17255: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00014	68 67 43 00 00	 push	 17255			; 00004367H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	5e		 pop	 esi

; 17264: 	}
; 17265: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@GCUseEndEv:

; 17256: 		return;
; 17257: 	}
; 17258: 
; 17259: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 9 )

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	8b c6		 mov	 eax, esi
  00039	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0003f	8b 94 08 1c 0e
	00 00		 mov	 edx, DWORD PTR [eax+ecx+3612]
  00046	f6 c2 03	 test	 dl, 3
  00049	74 35		 je	 SHORT $LN1@GCUseEndEv
  0004b	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00051	81 fa 40 02 00
	00		 cmp	 edx, 576		; 00000240H
  00057	75 27		 jne	 SHORT $LN1@GCUseEndEv

; 17260: 	{
; 17261: 		gObj[aIndex].m_IfState.state = 0;

  00059	83 a4 08 1c 0e
	00 00 c3	 and	 DWORD PTR [eax+ecx+3612], -61 ; ffffffc3H

; 17262: 		gObj[aIndex].m_IfState.type = 0;

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00067	81 a4 08 1c 0e
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [eax+ecx+3612], -65473 ; ffff003fH

; 17263: 		gObj[aIndex].m_IfState.use = 0;

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00078	83 a4 08 1c 0e
	00 00 fc	 and	 DWORD PTR [eax+ecx+3612], -4 ; fffffffcH
$LN1@GCUseEndEv:
  00080	5e		 pop	 esi

; 17264: 	}
; 17265: }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?GCUseEndEventChipRescv@@YAXH@Z ENDP			; GCUseEndEventChipRescv
_TEXT	ENDS
PUBLIC	??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ ; `string'
PUBLIC	??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
;	COMDAT ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
CONST	SEGMENT
??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ DB '['
	DB	'EventChip] [%s][%s] Request Change Rena', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
CONST	SEGMENT
??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ DB '['
	DB	'EventChip] [%s][%s] Request Change Stones', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z PROC ; GCUseRenaChangeZenRecv, COMDAT

; 17268: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17269: 	if ( gObj[aIndex].UseEventServer )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001a	8b f7		 mov	 esi, edi
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	83 bc 06 50 10
	00 00 00	 cmp	 DWORD PTR [esi+eax+4176], 0
  0002a	0f 85 85 00 00
	00		 jne	 $LN1@GCUseRenaC

; 17270: 	{
; 17271: 		return;
; 17272: 	}
; 17273: 
; 17274: 	gObj[aIndex].UseEventServer = TRUE;

  00030	c7 84 06 50 10
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+4176], 1

; 17275: 
; 17276: 	PMSG_REQ_RESET_EVENTCHIP pMsg;
; 17277: 
; 17278: 	if ( lpMsg->btType == 1 )

  0003b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0003e	80 78 03 01	 cmp	 BYTE PTR [eax+3], 1

; 17279: 	{
; 17280: 		PHeadSetB((LPBYTE)&pMsg, 0x09, sizeof(pMsg));

  00042	6a 14		 push	 20			; 00000014H
  00044	75 08		 jne	 SHORT $LN4@GCUseRenaC
  00046	6a 09		 push	 9
  00048	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004b	51		 push	 ecx

; 17281: 	}
; 17282: 	else

  0004c	eb 06		 jmp	 SHORT $LN10@GCUseRenaC
$LN4@GCUseRenaC:

; 17283: 	{
; 17284: 		PHeadSetB((LPBYTE)&pMsg, 0x04, sizeof(pMsg));

  0004e	6a 04		 push	 4
  00050	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00053	52		 push	 edx
$LN10@GCUseRenaC:
  00054	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17285: 	}
; 17286: 
; 17287: 	pMsg.iINDEX = aIndex;
; 17288: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00062	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	89 7d ec	 mov	 DWORD PTR _pMsg$[ebp+4], edi
  0006b	2b d0		 sub	 edx, eax
  0006d	8d 49 00	 npad	 3
$LL8@GCUseRenaC:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00075	40		 inc	 eax
  00076	84 c9		 test	 cl, cl
  00078	75 f6		 jne	 SHORT $LL8@GCUseRenaC

; 17289: 
; 17290: 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  0007a	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007d	6a 14		 push	 20			; 00000014H
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 17291: 
; 17292: 	if ( lpMsg->btType == 0x01 )
; 17293: 	{
; 17294: 		LogAddTD("[EventChip] [%s][%s] Request Change Stones", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0008d	83 c4 08	 add	 esp, 8
  00090	80 7a 03 01	 cmp	 BYTE PTR [edx+3], 1
  00094	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00098	51		 push	 ecx
  00099	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0009d	52		 push	 edx
  0009e	75 07		 jne	 SHORT $LN2@GCUseRenaC
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@

; 17295: 	}
; 17296: 	else

  000a5	eb 05		 jmp	 SHORT $LN11@GCUseRenaC
$LN2@GCUseRenaC:

; 17297: 	{
; 17298: 		LogAddTD("[EventChip] [%s][%s] Request Change Rena", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
$LN11@GCUseRenaC:
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUseRenaC:

; 17299: 	}
; 17300: }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	5f		 pop	 edi
  000b9	33 cd		 xor	 ecx, ebp
  000bb	5e		 pop	 esi
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ENDP ; GCUseRenaChangeZenRecv
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestQuestInfo@@YAXH@Z			; CGRequestQuestInfo
EXTRN	?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z:PROC ; CQuestInfo::GetQuestInfo
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestQuestInfo@@YAXH@Z
_TEXT	SEGMENT
_questcount$ = -76					; size = 4
_lpObj$ = -72						; size = 4
_aIndex$GSCopy$ = -68					; size = 4
_foundquest$ = -64					; size = 4
_pMsg$ = -60						; size = 54
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGRequestQuestInfo@@YAXH@Z PROC			; CGRequestQuestInfo, COMDAT

; 17303: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 17304: 	LPOBJ lpObj = &gObj[aIndex];

  00013	89 45 bc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], eax
  00016	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0001c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00022	53		 push	 ebx

; 17305: 
; 17306: 	if ( lpObj->m_SendQuestInfo != 0 )

  00023	33 db		 xor	 ebx, ebx
  00025	89 45 b8	 mov	 DWORD PTR _lpObj$[ebp], eax
  00028	38 98 be 10 00
	00		 cmp	 BYTE PTR [eax+4286], bl
  0002e	0f 85 90 00 00
	00		 jne	 $LN1@CGRequestQ

; 17307: 	{
; 17308: 		return;
; 17309: 	}
; 17310: 
; 17311: 	int questcount = g_QuestInfo.GetQeustCount();

  00034	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?g_QuestInfo@@3VCQuestInfo@@A+4
  0003a	56		 push	 esi
  0003b	57		 push	 edi
  0003c	89 4d b4	 mov	 DWORD PTR _questcount$[ebp], ecx

; 17312: 	int foundquest = 0;
; 17313: 
; 17314: 	PMSG_SEND_QEUSTINFO pMsg;
; 17315: 	LPQUEST_INFO lpQuestInfo;
; 17316: 
; 17317: 	memcpy(pMsg.State, lpObj->m_Quest, sizeof(pMsg.State));

  0003f	8d b0 8c 10 00
	00		 lea	 esi, DWORD PTR [eax+4236]
  00045	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0004a	8d 7d c8	 lea	 edi, DWORD PTR _pMsg$[ebp+4]
  0004d	f3 a5		 rep movsd
  0004f	89 5d c0	 mov	 DWORD PTR _foundquest$[ebp], ebx
  00052	66 a5		 movsw
$LL6@CGRequestQ:

; 17320: 	{
; 17321: 		lpQuestInfo = g_QuestInfo.GetQuestInfo(i);

  00054	53		 push	 ebx
  00055	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0005a	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo

; 17322: 
; 17323: 		if ( lpQuestInfo )

  0005f	85 c0		 test	 eax, eax
  00061	74 0c		 je	 SHORT $LN5@CGRequestQ

; 17324: 		{
; 17325: 			foundquest++;

  00063	8b 45 c0	 mov	 eax, DWORD PTR _foundquest$[ebp]
  00066	40		 inc	 eax
  00067	89 45 c0	 mov	 DWORD PTR _foundquest$[ebp], eax

; 17326: 
; 17327: 			if ( foundquest == questcount )

  0006a	3b 45 b4	 cmp	 eax, DWORD PTR _questcount$[ebp]
  0006d	74 09		 je	 SHORT $LN13@CGRequestQ
$LN5@CGRequestQ:

; 17318: 	int i=0;
; 17319: 	for (i=0;i<MAX_QUEST_INFO;i++)

  0006f	43		 inc	 ebx
  00070	81 fb c8 00 00
	00		 cmp	 ebx, 200		; 000000c8H
  00076	7c dc		 jl	 SHORT $LL6@CGRequestQ
$LN13@CGRequestQ:

; 17328: 			{
; 17329: 				break;
; 17330: 			}
; 17331: 		}
; 17332: 	}
; 17333: 
; 17334: 	int iSize = i/4+5;

  00078	8b c3		 mov	 eax, ebx
  0007a	99		 cdq
  0007b	83 e2 03	 and	 edx, 3
  0007e	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00081	c1 fe 02	 sar	 esi, 2
  00084	83 c6 05	 add	 esi, 5

; 17335: 
; 17336: 	PHeadSetB((LPBYTE)&pMsg, 0xA0, iSize);

  00087	56		 push	 esi
  00088	8d 55 c4	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0008b	68 a0 00 00 00	 push	 160			; 000000a0H
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17337: 	pMsg.Count = i;
; 17338: 	DataSend(aIndex, (LPBYTE)&pMsg, iSize);

  00096	8b 4d bc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00099	56		 push	 esi
  0009a	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009d	50		 push	 eax
  0009e	51		 push	 ecx
  0009f	88 5d c7	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  000a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17339: 	lpObj->m_SendQuestInfo = true;

  000a7	8b 55 b8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000aa	83 c4 18	 add	 esp, 24			; 00000018H
  000ad	c6 82 be 10 00
	00 01		 mov	 BYTE PTR [edx+4286], 1

; 17340: 
; 17341: 	if ( szAuthKey[8] != AUTHKEY8 )

  000b4	80 3d 08 00 00
	00 52		 cmp	 BYTE PTR ?szAuthKey@@3PADA+8, 82 ; 00000052H
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	74 05		 je	 SHORT $LN1@CGRequestQ

; 17342: 	{
; 17343: 		DestroyGIocp();

  000bf	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN1@CGRequestQ:

; 17344: 	}
; 17345: }

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c7	33 cd		 xor	 ecx, ebp
  000c9	5b		 pop	 ebx
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?CGRequestQuestInfo@@YAXH@Z ENDP			; CGRequestQuestInfo
_TEXT	ENDS
PUBLIC	?GCSendQuestInfo@@YAXHH@Z			; GCSendQuestInfo
EXTRN	?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestStateBYTE
; Function compile flags: /Ogtp
;	COMDAT ?GCSendQuestInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?GCSendQuestInfo@@YAXHH@Z PROC				; GCSendQuestInfo, COMDAT

; 17348: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 17349: 	CGRequestQuestInfo(aIndex);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo

; 17350: 	LPOBJ lpObj = &gObj[aIndex];

  00011	8b f7		 mov	 esi, edi
  00013	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00019	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17351: 	PMSG_SETQUEST pMsg;
; 17352: 
; 17353: 	PHeadSetB((LPBYTE)&pMsg, 0xA1, sizeof(pMsg));

  0001f	6a 05		 push	 5
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	68 a1 00 00 00	 push	 161			; 000000a1H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17354: 	pMsg.QuestIndex = QuestIndex;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 17355: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, QuestIndex);

  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0003c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0003f	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
  00044	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 17356: 
; 17357: 
; 17358: 	if ( pMsg.State != 0 )

  00047	84 c0		 test	 al, al
  00049	74 0f		 je	 SHORT $LN1@GCSendQues

; 17359: 	{
; 17360: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0004b	6a 05		 push	 5
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00050	51		 push	 ecx
  00051	57		 push	 edi
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendQues:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 17361: 	}
; 17362: }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GCSendQuestInfo@@YAXHH@Z ENDP				; GCSendQuestInfo
_TEXT	ENDS
PUBLIC	?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z	; CGSetQuestState
EXTRN	?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z:PROC ; CQuestInfo::SetQuestState
; Function compile flags: /Ogtp
;	COMDAT ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z PROC		; CGSetQuestState, COMDAT

; 17365: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 17366: 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f3		 mov	 esi, ebx
  0000d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00013	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	57		 push	 edi

; 17367: 	PMSG_SETQUEST_RESULT pMsg;
; 17368: 
; 17369: 	PHeadSetB((LPBYTE)&pMsg, 0xA2, sizeof(pMsg));

  0001a	6a 06		 push	 6
  0001c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	68 a2 00 00 00	 push	 162			; 000000a2H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17370: 	pMsg.QuestIndex = lpMsg->QuestIndex;

  0002a	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002d	8a 47 03	 mov	 al, BYTE PTR [edi+3]

; 17371: 	pMsg.Result = g_QuestInfo.SetQuestState(lpObj, lpMsg->QuestIndex, lpMsg->State);

  00030	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	51		 push	 ecx
  00038	0f b6 d0	 movzx	 edx, al
  0003b	52		 push	 edx
  0003c	56		 push	 esi
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00042	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00045	e8 00 00 00 00	 call	 ?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z ; CQuestInfo::SetQuestState
  0004a	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 17372: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, lpMsg->QuestIndex);

  0004d	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00051	50		 push	 eax
  00052	56		 push	 esi
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00058	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE

; 17373: 
; 17374: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0005d	6a 06		 push	 6
  0005f	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00062	51		 push	 ecx
  00063	53		 push	 ebx
  00064	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 17375: }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ENDP		; CGSetQuestState
_TEXT	ENDS
PUBLIC	?GCSendQuestPrize@@YAXHEE@Z			; GCSendQuestPrize
EXTRN	?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; ResetSystemGC_CharUpdate
; Function compile flags: /Ogtp
;	COMDAT ?GCSendQuestPrize@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 1
_Count$ = 16						; size = 1
?GCSendQuestPrize@@YAXHEE@Z PROC			; GCSendQuestPrize, COMDAT

; 17378: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 17379: 	CGRequestQuestInfo(aIndex);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo

; 17380: 	LPOBJ lpObj = &gObj[aIndex];

  00011	8b f7		 mov	 esi, edi
  00013	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00019	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17381: 
; 17382: 	PMSG_SETQUEST_PRIZE pMsg;
; 17383: 
; 17384: 	PHeadSetB((LPBYTE)&pMsg, 0xA3, sizeof(pMsg));

  0001f	6a 07		 push	 7
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	68 a3 00 00 00	 push	 163			; 000000a3H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17385: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 17386: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 17387: 	pMsg.Type = Type;

  00031	8a 45 0c	 mov	 al, BYTE PTR _Type$[ebp]
  00034	c1 e9 08	 shr	 ecx, 8
  00037	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003a	8a 16		 mov	 dl, BYTE PTR [esi]

; 17388: 	pMsg.Count = Count;

  0003c	8a 4d 10	 mov	 cl, BYTE PTR _Count$[ebp]
  0003f	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 17389: 
; 17390: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00042	6a 07		 push	 7
  00044	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00047	52		 push	 edx
  00048	57		 push	 edi
  00049	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0004c	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  0004f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17391: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, sizeof(pMsg));

  00054	6a 07		 push	 7
  00056	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	50		 push	 eax
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 17392: 
; 17393: #if(ENABLE_FIX)
; 17394: 	ResetSystemGC_CharUpdate(lpObj);

  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?ResetSystemGC_CharUpdate@@YAXPAUOBJECTSTRUCT@@@Z ; ResetSystemGC_CharUpdate
  00066	83 c4 2c	 add	 esp, 44			; 0000002cH
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 17395: #endif
; 17396: }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GCSendQuestPrize@@YAXHEE@Z ENDP			; GCSendQuestPrize
_TEXT	ENDS
PUBLIC	??_C@_0FL@LDGANMDE@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?EnterUserBridge@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::EnterUserBridge
EXTRN	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::CheckEnterLevel
;	COMDAT ??_C@_0FL@LDGANMDE@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FL@LDGANMDE@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle'
	DB	' (Invisible Cloak Serial:%u)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z
_TEXT	SEGMENT
tv667 = -292						; size = 4
_iBC_INDEX$ = -288					; size = 4
_btInvisibleCourtItemPos$ = -284			; size = 1
tv698 = -280						; size = 4
tv696 = -280						; size = 4
tv628 = -280						; size = 4
tv660 = -276						; size = 4
tv632 = -276						; size = 4
_dwITEM_SERIAL$ = -276					; size = 4
_iITEM_LEVEL$ = -272					; size = 4
_i$250749 = -268					; size = 4
_bPlayerKiller$ = -268					; size = 4
tv701 = -266						; size = 2
_pResult$ = -264					; size = 4
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z PROC ; CGRequestEnterBloodCastle, COMDAT

; 17465: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 17466: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	85 ff		 test	 edi, edi
  0001c	78 0f		 js	 SHORT $LN61@CGRequestE
  0001e	33 c9		 xor	 ecx, ecx
  00020	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	75 27		 jne	 SHORT $LN49@CGRequestE
$LN61@CGRequestE:

; 17467: 	{
; 17468: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0002d	68 3c 44 00 00	 push	 17468			; 0000443cH
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 17715: }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN49@CGRequestE:
  00054	53		 push	 ebx

; 17469: 		return;
; 17470: 	}
; 17471: 	
; 17472: 	BYTE btBridgeNumber = lpMsg->iBridgeNumber - 1;

  00055	8a 58 03	 mov	 bl, BYTE PTR [eax+3]

; 17473: 	BYTE btInvisibleCourtItemPos = lpMsg->iItemPos;

  00058	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0005b	56		 push	 esi

; 17474: 
; 17475: 	int iITEM_LEVEL = 0;
; 17476: 	DWORD dwITEM_SERIAL = 0;
; 17477: 
; 17478: 	PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 17479: 
; 17480: 	PHeadSetB((LPBYTE)&pResult, 0x9A, sizeof(pResult));

  0005c	6a 04		 push	 4
  0005e	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00064	68 9a 00 00 00	 push	 154			; 0000009aH
  00069	51		 push	 ecx
  0006a	fe cb		 dec	 bl
  0006c	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _btInvisibleCourtItemPos$[ebp], al
  00072	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  0007c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17481: 	pResult.Result = 0;
; 17482: 
; 17483: 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	8b f7		 mov	 esi, edi
  00088	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  00098	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  0009e	0f 85 bd 05 00
	00		 jne	 $LN70@CGRequestE
  000a4	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  000a9	0f 8e b2 05 00
	00		 jle	 $LN70@CGRequestE

; 17484: 	{
; 17485: 		return;
; 17486: 	}
; 17487: 
; 17488: 	if ( gObj[iIndex].m_IfState.use && gObj[iIndex].m_IfState.type != 12 )

  000af	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  000b6	f6 c1 03	 test	 cl, 3
  000b9	74 12		 je	 SHORT $LN46@CGRequestE
  000bb	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000c1	81 f9 00 03 00
	00		 cmp	 ecx, 768		; 00000300H
  000c7	0f 85 94 05 00
	00		 jne	 $LN70@CGRequestE
$LN46@CGRequestE:

; 17489: 	{
; 17490: 		return;
; 17491: 	}
; 17492: 
; 17493: 	BOOL bPlayerKiller = FALSE; //Season 2.5 add-on
; 17494: 
; 17495: 	if(ZtConfig.PvP.ZtPkPartySystem && gObj[iIndex].PartyNumber >= 0) //Season 2.5 add-on

  000cd	83 3d 38 09 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2360, 0
  000d4	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bPlayerKiller$[ebp], 0
  000de	74 29		 je	 SHORT $LN44@CGRequestE
  000e0	8b 8c 06 2c 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1068]
  000e7	85 c9		 test	 ecx, ecx
  000e9	78 1e		 js	 SHORT $LN44@CGRequestE

; 17496: 	{
; 17497: 		if(gParty.GetPkLevel(gObj[iIndex].PartyNumber) >= 5)

  000eb	51		 push	 ecx
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000f1	e8 00 00 00 00	 call	 ?GetPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPkLevel
  000f6	3c 05		 cmp	 al, 5

; 17498: 		{
; 17499: 			bPlayerKiller = TRUE;

  000f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fd	7c 0a		 jl	 SHORT $LN44@CGRequestE
  000ff	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bPlayerKiller$[ebp], 1
$LN44@CGRequestE:

; 17500: 		}
; 17501: 	}
; 17502: 
; 17503: 	if(!ZtConfig.Event.BCAllowPKPlayer)

  00109	83 3d 38 07 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1848, 0
  00110	75 14		 jne	 SHORT $LN42@CGRequestE

; 17504: 	{
; 17505: 		if(gObj[iIndex].m_PK_Level >= 4)

  00112	80 bc 06 3d 01
	00 00 04	 cmp	 BYTE PTR [esi+eax+317], 4
  0011a	7c 0a		 jl	 SHORT $LN42@CGRequestE

; 17506: 		{
; 17507: 			bPlayerKiller = TRUE;

  0011c	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bPlayerKiller$[ebp], 1
$LN42@CGRequestE:

; 17508: 		}
; 17509: 	}
; 17510: 
; 17511: #if(WAITENI_CUSTOM)
; 17512: 
; 17513: 	if(ZtConfig.CommonServer.BloodCastleCount)

  00126	83 3d 44 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+324, 0
  0012d	74 6a		 je	 SHORT $LN69@CGRequestE

; 17514: 	{
; 17515: 		if(AccountDataGet(&gObj[iIndex]) == -1)

  0012f	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 ?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z ; AccountDataGet
  00138	83 c4 04	 add	 esp, 4
  0013b	83 f8 ff	 cmp	 eax, -1
  0013e	75 11		 jne	 SHORT $LN40@CGRequestE

; 17516: 		{
; 17517: 			AccountDataAdd(&gObj[iIndex]);	

  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00145	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00148	51		 push	 ecx
  00149	e8 00 00 00 00	 call	 ?AccountDataAdd@@YAXPAUOBJECTSTRUCT@@@Z ; AccountDataAdd
  0014e	83 c4 04	 add	 esp, 4
$LN40@CGRequestE:

; 17518: 		}
; 17519: 
; 17520: 		int iAccInx = AccountDataGet(&gObj[iIndex]);

  00151	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00157	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z ; AccountDataGet
  00160	83 c4 04	 add	 esp, 4

; 17521: 
; 17522: 		if(iAccInx != -1)

  00163	83 f8 ff	 cmp	 eax, -1
  00166	74 31		 je	 SHORT $LN69@CGRequestE

; 17523: 		{
; 17524: 			//MsgNormal(iIndex, "BC %d / %d", ExAccData[iAccInx].BloodCastleCount, ZtConfig.CommonServer.BloodCastleCount);
; 17525: 
; 17526: 			if(ExAccData[iAccInx].BloodCastleCount >= ZtConfig.CommonServer.BloodCastleCount)

  00168	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0016b	8b 14 8d 0c 00
	00 00		 mov	 edx, DWORD PTR ?ExAccData@@3PAUEX_ACC_DATA@@A[ecx*4+12]
  00172	3b 15 44 01 00
	00		 cmp	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+324
  00178	7c 1f		 jl	 SHORT $LN69@CGRequestE

; 17527: 			{
; 17528: 				MsgNormal(iIndex, "You have reached the daily limit");

  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KHNDAMDC@You?5have?5reached?5the?5daily?5limit@
  0017f	57		 push	 edi
  00180	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00185	83 c4 08	 add	 esp, 8
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	5f		 pop	 edi

; 17715: }

  0018b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018e	33 cd		 xor	 ecx, ebp
  00190	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
$LN69@CGRequestE:

; 17529: 
; 17530: 				//pResult.Result = 7;
; 17531: 				//DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 17532: 				return;
; 17533: 			}
; 17534: 		}
; 17535: 
; 17536: 		//ExAccData[iAccInx].BloodCastleCount++;
; 17537: 	}
; 17538: 
; 17539: #endif
; 17540: 
; 17541: 	if ( bPlayerKiller == TRUE )

  00199	83 bd f4 fe ff
	ff 01		 cmp	 DWORD PTR _bPlayerKiller$[ebp], 1
  001a0	75 1b		 jne	 SHORT $LN37@CGRequestE

; 17542: 	{
; 17543: 		pResult.Result = 7;
; 17544: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  001a2	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001a9	50		 push	 eax
  001aa	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  001b0	c6 85 fb fe ff
	ff 07		 mov	 BYTE PTR _pResult$[ebp+3], 7
  001b7	51		 push	 ecx

; 17545: 		return;

  001b8	e9 9b 04 00 00	 jmp	 $LN79@CGRequestE
$LN37@CGRequestE:

; 17546: 	}
; 17547: 
; 17548: 	if ( g_BloodCastle.CheckCanEnter(btBridgeNumber) == false )

  001bd	0f b6 d3	 movzx	 edx, bl
  001c0	52		 push	 edx
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001c6	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  001cb	84 c0		 test	 al, al
  001cd	75 1b		 jne	 SHORT $LN36@CGRequestE

; 17549: 	{
; 17550: 		pResult.Result = 2;
; 17551: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  001cf	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001d6	50		 push	 eax
  001d7	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  001dd	c6 85 fb fe ff
	ff 02		 mov	 BYTE PTR _pResult$[ebp+3], 2
  001e4	51		 push	 ecx

; 17552: 		return;

  001e5	e9 6e 04 00 00	 jmp	 $LN79@CGRequestE
$LN36@CGRequestE:

; 17553: 	}
; 17554: 
; 17555: 	if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].IsItem() == TRUE )

  001ea	0f b6 9d e4 fe
	ff ff		 movzx	 ebx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  001f1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f7	8b 8c 16 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+edx+3620]
  001fe	89 9d e8 fe ff
	ff		 mov	 DWORD PTR tv628[ebp], ebx
  00204	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  0020a	03 cb		 add	 ecx, ebx
  0020c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00211	83 f8 01	 cmp	 eax, 1
  00214	0f 85 28 04 00
	00		 jne	 $LN35@CGRequestE

; 17556: 	{
; 17557: 		if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) )

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021f	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  00226	8d 84 06 24 0e
	00 00		 lea	 eax, DWORD PTR [esi+eax+3620]
  0022d	03 cb		 add	 ecx, ebx
  0022f	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv632[ebp], ecx
  00235	0f b7 49 06	 movzx	 ecx, WORD PTR [ecx+6]
  00239	ba 12 1a 00 00	 mov	 edx, 6674		; 00001a12H
  0023e	66 3b ca	 cmp	 cx, dx
  00241	75 3e		 jne	 SHORT $LN34@CGRequestE

; 17558: 		{
; 17559: 			iITEM_LEVEL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Level;

  00243	8b 00		 mov	 eax, DWORD PTR [eax]
  00245	0f bf 4c 18 08	 movsx	 ecx, WORD PTR [eax+ebx+8]

; 17560: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;

  0024a	8b 14 18	 mov	 edx, DWORD PTR [eax+ebx]
  0024d	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx
  00253	89 95 ec fe ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], edx

; 17561: 			
; 17562: 			if ( BC_CLOACK_LEVEL_RANGE(iITEM_LEVEL)==FALSE)

  00259	85 c9		 test	 ecx, ecx
  0025b	78 10		 js	 SHORT $LN62@CGRequestE
  0025d	33 c0		 xor	 eax, eax
  0025f	83 f9 08	 cmp	 ecx, 8
  00262	0f 9e c0	 setle	 al
  00265	85 c0		 test	 eax, eax
  00267	0f 85 e7 00 00
	00		 jne	 $LN24@CGRequestE
$LN62@CGRequestE:

; 17563: 			{
; 17564: 				pResult.Result = 1;
; 17565: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0026d	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00274	50		 push	 eax
  00275	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0027b	51		 push	 ecx

; 17566: 				return;

  0027c	e9 d0 03 00 00	 jmp	 $LN80@CGRequestE
$LN34@CGRequestE:

; 17567: 			}
; 17568: 		}
; 17569: 		else if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 0.0f )

  00281	ba 2f 1a 00 00	 mov	 edx, 6703		; 00001a2fH
  00286	66 3b ca	 cmp	 cx, dx
  00289	0f 85 ab 00 00
	00		 jne	 $LN63@CGRequestE
  0028f	d9 ee		 fldz
  00291	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv632[ebp]
  00297	d8 58 24	 fcomp	 DWORD PTR [eax+36]
  0029a	df e0		 fnstsw	 ax
  0029c	f6 c4 05	 test	 ah, 5
  0029f	0f 8a 95 00 00
	00		 jp	 $LN63@CGRequestE

; 17570: 		{
; 17571: 			//if(g_MasterLevelSystem.CheckIsMasterLevelCharacter(&gObj[iIndex]) != FALSE)
; 17572: 			if(gObj[iIndex].ChangeUP3rd == 1)

  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ab	80 bc 0e bc 00
	00 00 01	 cmp	 BYTE PTR [esi+ecx+188], 1
  002b3	75 0c		 jne	 SHORT $LN30@CGRequestE

; 17573: 			{
; 17574: 				iITEM_LEVEL = 8;

  002b5	c7 85 f0 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 8

; 17575: 			}
; 17576: 			else

  002bf	eb 4c		 jmp	 SHORT $LN26@CGRequestE
$LN30@CGRequestE:

; 17577: 			{
; 17578: 				for ( int i=0;i<MAX_CLOACK_LEVEL;i++)

  002c1	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$250749[ebp], 0
  002cb	eb 03 8d 49 00	 npad	 5
$LL66@CGRequestE:

; 17579: 				{
; 17580: 					if ( g_BloodCastle.CheckEnterLevel(iIndex, i+1) == 0 )

  002d0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$250749[ebp]
  002d6	40		 inc	 eax
  002d7	50		 push	 eax
  002d8	57		 push	 edi
  002d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002de	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv660[ebp], eax
  002e4	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel
  002e9	85 c0		 test	 eax, eax
  002eb	74 13		 je	 SHORT $LN59@CGRequestE

; 17577: 			{
; 17578: 				for ( int i=0;i<MAX_CLOACK_LEVEL;i++)

  002ed	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv660[ebp]
  002f3	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _i$250749[ebp], eax
  002f9	83 f8 09	 cmp	 eax, 9
  002fc	7c d2		 jl	 SHORT $LL66@CGRequestE

; 17579: 				{
; 17580: 					if ( g_BloodCastle.CheckEnterLevel(iIndex, i+1) == 0 )

  002fe	eb 0d		 jmp	 SHORT $LN26@CGRequestE
$LN59@CGRequestE:

; 17581: 					{
; 17582: 						iITEM_LEVEL = i+1;

  00300	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _i$250749[ebp]
  00306	42		 inc	 edx
  00307	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], edx
$LN26@CGRequestE:

; 17583: 						break;
; 17584: 					}
; 17585: 				}
; 17586: 			}
; 17587: 
; 17588: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;

  0030d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00312	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]

; 17589: 
; 17590: 			if ( BC_CLOACK_LEVEL_RANGE(iITEM_LEVEL) == FALSE )

  00319	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  0031f	8b 14 0b	 mov	 edx, DWORD PTR [ebx+ecx]
  00322	89 95 ec fe ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], edx
  00328	85 c0		 test	 eax, eax
  0032a	78 0e		 js	 SHORT $LN63@CGRequestE
  0032c	33 c9		 xor	 ecx, ecx
  0032e	83 f8 08	 cmp	 eax, 8
  00331	0f 9e c1	 setle	 cl
  00334	8b c1		 mov	 eax, ecx
  00336	85 c0		 test	 eax, eax
  00338	75 14		 jne	 SHORT $LN67@CGRequestE
$LN63@CGRequestE:

; 17591: 			{
; 17592: 				pResult.Result = 1;
; 17593: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0033a	0f b6 95 f9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00341	52		 push	 edx
  00342	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00348	50		 push	 eax

; 17594: 				return;

  00349	e9 03 03 00 00	 jmp	 $LN80@CGRequestE
$LN67@CGRequestE:
  0034e	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LEVEL$[ebp]
$LN24@CGRequestE:

; 17608: 		return;
; 17609: 	}
; 17610: 	
; 17611: 	int iRESULT = g_BloodCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);

  00354	51		 push	 ecx
  00355	57		 push	 edi
  00356	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0035b	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel

; 17612: 
; 17613: 	if ( iRESULT== 0 )

  00360	85 c0		 test	 eax, eax
  00362	0f 85 a0 02 00
	00		 jne	 $LN21@CGRequestE

; 17614: 	{
; 17615: 		pResult.Result = 0;
; 17616: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00368	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0036f	51		 push	 ecx
  00370	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00376	52		 push	 edx
  00377	57		 push	 edi
  00378	88 85 fb fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
  0037e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17632: 		}
; 17633: 
; 17634: 		return;
; 17635: 	}
; 17636: 		
; 17637: 	int iBC_INDEX = g_BloodCastle.EnterUserBridge(iITEM_LEVEL-1, iIndex);

  00383	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  00389	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038c	48		 dec	 eax
  0038d	57		 push	 edi
  0038e	50		 push	 eax
  0038f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00394	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv667[ebp], eax
  0039a	e8 00 00 00 00	 call	 ?EnterUserBridge@CBloodCastle@@QAEHHH@Z ; CBloodCastle::EnterUserBridge
  0039f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iBC_INDEX$[ebp], eax

; 17638: 
; 17639: 	if ( iBC_INDEX == -1 )

  003a5	83 f8 ff	 cmp	 eax, -1
  003a8	75 1b		 jne	 SHORT $LN17@CGRequestE

; 17640: 	{
; 17641: 		pResult.Result = 5;
; 17642: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  003aa	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003b1	50		 push	 eax
  003b2	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  003b8	c6 85 fb fe ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+3], 5
  003bf	51		 push	 ecx

; 17643: 		return;

  003c0	e9 93 02 00 00	 jmp	 $LN79@CGRequestE
$LN17@CGRequestE:

; 17644: 	}
; 17645: 
; 17646: 	if ( (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) || (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47)) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1.0f ))

  003c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003cb	8b 94 16 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+edx+3620]
  003d2	0f b7 4c 1a 06	 movzx	 ecx, WORD PTR [edx+ebx+6]
  003d7	b8 12 1a 00 00	 mov	 eax, 6674		; 00001a12H
  003dc	66 3b c8	 cmp	 cx, ax
  003df	0f 84 b3 00 00
	00		 je	 $LN15@CGRequestE
  003e5	d9 e8		 fld1
  003e7	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  003ec	66 3b c8	 cmp	 cx, ax
  003ef	75 13		 jne	 SHORT $LN16@CGRequestE
  003f1	d9 44 1a 24	 fld	 DWORD PTR [edx+ebx+36]
  003f5	d9 c1		 fld	 ST(1)
  003f7	da e9		 fucompp
  003f9	df e0		 fnstsw	 ax
  003fb	f6 c4 44	 test	 ah, 68			; 00000044H
  003fe	0f 8b 92 00 00
	00		 jnp	 $LN75@CGRequestE
$LN16@CGRequestE:

; 17651: 	}
; 17652: 	else if (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 1.0f )

  00404	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  00409	66 3b c8	 cmp	 cx, ax
  0040c	0f 85 bc 00 00
	00		 jne	 $LN77@CGRequestE
  00412	d8 5c 1a 24	 fcomp	 DWORD PTR [edx+ebx+36]
  00416	df e0		 fnstsw	 ax
  00418	f6 c4 05	 test	 ah, 5
  0041b	0f 8a af 00 00
	00		 jp	 $LN68@CGRequestE

; 17653: 	{
; 17654: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability -= 1.0f;

  00421	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17655: 		GCItemDurSend2(iIndex, btInvisibleCourtItemPos, (BYTE)gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability, 0);

  00427	d9 bd f6 fe ff
	ff		 fnstcw	 WORD PTR tv701[ebp]
  0042d	8b 94 0e 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+ecx+3620]
  00434	d9 44 1a 24	 fld	 DWORD PTR [edx+ebx+36]
  00438	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  0043e	8d 44 1a 24	 lea	 eax, DWORD PTR [edx+ebx+36]
  00442	6a 00		 push	 0
  00444	d9 18		 fstp	 DWORD PTR [eax]
  00446	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0044b	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  00452	0f b7 85 f6 fe
	ff ff		 movzx	 eax, WORD PTR tv701[ebp]
  00459	d9 44 19 24	 fld	 DWORD PTR [ecx+ebx+36]
  0045d	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _btInvisibleCourtItemPos$[ebp]
  00463	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00468	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv698[ebp], eax
  0046e	d9 ad e8 fe ff
	ff		 fldcw	 WORD PTR tv698[ebp]
  00474	db 9d e8 fe ff
	ff		 fistp	 DWORD PTR tv696[ebp]
  0047a	8a 95 e8 fe ff
	ff		 mov	 dl, BYTE PTR tv696[ebp]
  00480	0f b6 c2	 movzx	 eax, dl
  00483	50		 push	 eax
  00484	d9 ad f6 fe ff
	ff		 fldcw	 WORD PTR tv701[ebp]
  0048a	51		 push	 ecx
  0048b	57		 push	 edi
  0048c	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00491	83 c4 10	 add	 esp, 16			; 00000010H
  00494	eb 3a		 jmp	 SHORT $LN68@CGRequestE
$LN75@CGRequestE:

; 17644: 	}
; 17645: 
; 17646: 	if ( (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) || (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47)) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1.0f ))

  00496	dd d8		 fstp	 ST(0)
$LN15@CGRequestE:

; 17647: 	{
; 17648: 		gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);

  00498	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv628[ebp]
  0049e	52		 push	 edx
  0049f	57		 push	 edi
  004a0	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 17649: 		GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);

  004a5	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _btInvisibleCourtItemPos$[ebp]
  004ab	6a 01		 push	 1
  004ad	50		 push	 eax
  004ae	57		 push	 edi
  004af	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 17650: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  004b4	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  004bb	51		 push	 ecx
  004bc	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  004c2	52		 push	 edx
  004c3	57		 push	 edi
  004c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004c9	83 c4 20	 add	 esp, 32			; 00000020H
  004cc	eb 02		 jmp	 SHORT $LN68@CGRequestE
$LN77@CGRequestE:
  004ce	dd d8		 fstp	 ST(0)
$LN68@CGRequestE:

; 17656: 	}
; 17657: 
; 17658: #if(WAITENI_CUSTOM)
; 17659: 
; 17660: 	if(ZtConfig.CommonServer.BloodCastleCount)

  004d0	83 3d 44 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+324, 0
  004d7	74 20		 je	 SHORT $LN65@CGRequestE

; 17661: 	{
; 17662: 		int iAccInx = AccountDataGet(&gObj[iIndex]);

  004d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004de	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  004e1	51		 push	 ecx
  004e2	e8 00 00 00 00	 call	 ?AccountDataGet@@YAHPAUOBJECTSTRUCT@@@Z ; AccountDataGet
  004e7	83 c4 04	 add	 esp, 4

; 17663: 
; 17664: 		if(iAccInx != -1)

  004ea	83 f8 ff	 cmp	 eax, -1
  004ed	74 0a		 je	 SHORT $LN65@CGRequestE

; 17665: 		{
; 17666: 			ExAccData[iAccInx].BloodCastleCount++;

  004ef	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  004f2	ff 04 85 0c 00
	00 00		 inc	 DWORD PTR ?ExAccData@@3PAUEX_ACC_DATA@@A[eax*4+12]
$LN65@CGRequestE:

; 17667: 		}	
; 17668: 	}
; 17669: 
; 17670: #endif
; 17671: 
; 17672: 	gObj[iIndex].m_cBloodCastleIndex = iITEM_LEVEL-1;

  004f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004fe	8b 9d f0 fe ff
	ff		 mov	 ebx, DWORD PTR _iITEM_LEVEL$[ebp]
  00504	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00507	88 94 06 9e 0e
	00 00		 mov	 BYTE PTR [esi+eax+3742], dl

; 17673: 	gObj[iIndex].m_cBloodCastleSubIndex = iBC_INDEX;

  0050e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00514	8a 95 e0 fe ff
	ff		 mov	 dl, BYTE PTR _iBC_INDEX$[ebp]
  0051a	88 94 0e 9f 0e
	00 00		 mov	 BYTE PTR [esi+ecx+3743], dl

; 17674: 	gObj[iIndex].m_iBloodCastleEXP = 0;

  00521	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00526	c7 84 06 a0 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+3744], 0

; 17675: 	gObj[iIndex].m_IfState.state = 0;

  00531	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00536	83 a4 06 1c 0e
	00 00 c3	 and	 DWORD PTR [esi+eax+3612], -61 ; ffffffc3H

; 17676: 	gObj[iIndex].m_IfState.type = 0;

  0053e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00543	81 a4 06 1c 0e
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+3612], -65473 ; ffff003fH

; 17677: 	gObj[iIndex].m_IfState.use = 0;

  0054e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00553	83 a4 06 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+eax+3612], -4 ; fffffffcH

; 17678: 
; 17679: 	g_BloodCastle.SearchUserDeleteQuestItem(iIndex);

  0055b	57		 push	 edi
  0055c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00561	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 17680: 
; 17681: 	char szTemp[256];
; 17682: 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 147)), iITEM_LEVEL);

  00566	53		 push	 ebx
  00567	68 93 04 00 00	 push	 1171			; 00000493H
  0056c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00571	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00576	50		 push	 eax
  00577	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0057d	51		 push	 ecx
  0057e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 17683: 
; 17684: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  00584	6a 01		 push	 1
  00586	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0058c	57		 push	 edi
  0058d	52		 push	 edx
  0058e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 17685: 
; 17686: 	switch ( iITEM_LEVEL )

  00593	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv667[ebp]
  00599	83 c4 18	 add	 esp, 24			; 00000018H
  0059c	83 f8 07	 cmp	 eax, 7
  0059f	77 31		 ja	 SHORT $LN9@CGRequestE
  005a1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN82@CGRequestE[eax*4]
$LN8@CGRequestE:

; 17687: 	{
; 17688: 		case 1:
; 17689: 			gObjMoveGate(iIndex, 66);

  005a8	6a 42		 push	 66			; 00000042H

; 17690: 			break;

  005aa	eb 1d		 jmp	 SHORT $LN81@CGRequestE
$LN7@CGRequestE:

; 17691: 		case 2:
; 17692: 			gObjMoveGate(iIndex, 67);

  005ac	6a 43		 push	 67			; 00000043H

; 17693: 			break;

  005ae	eb 19		 jmp	 SHORT $LN81@CGRequestE
$LN6@CGRequestE:

; 17694: 		case 3:
; 17695: 			gObjMoveGate(iIndex, 68);

  005b0	6a 44		 push	 68			; 00000044H

; 17696: 			break;

  005b2	eb 15		 jmp	 SHORT $LN81@CGRequestE
$LN5@CGRequestE:

; 17697: 		case 4:
; 17698: 			gObjMoveGate(iIndex, 69);

  005b4	6a 45		 push	 69			; 00000045H

; 17699: 			break;

  005b6	eb 11		 jmp	 SHORT $LN81@CGRequestE
$LN4@CGRequestE:

; 17700: 		case 5:
; 17701: 			gObjMoveGate(iIndex, 70);

  005b8	6a 46		 push	 70			; 00000046H

; 17702: 			break;

  005ba	eb 0d		 jmp	 SHORT $LN81@CGRequestE
$LN3@CGRequestE:

; 17703: 		case 6:
; 17704: 			gObjMoveGate(iIndex, 71);

  005bc	6a 47		 push	 71			; 00000047H

; 17705: 			break;

  005be	eb 09		 jmp	 SHORT $LN81@CGRequestE
$LN2@CGRequestE:

; 17706: 		case 7:
; 17707: 			gObjMoveGate(iIndex, 80);

  005c0	6a 50		 push	 80			; 00000050H

; 17708: 			break;

  005c2	eb 05		 jmp	 SHORT $LN81@CGRequestE
$LN1@CGRequestE:

; 17709: 		case 8:
; 17710: 			gObjMoveGate(iIndex, 271);

  005c4	68 0f 01 00 00	 push	 271			; 0000010fH
$LN81@CGRequestE:
  005c9	57		 push	 edi
  005ca	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  005cf	83 c4 08	 add	 esp, 8
$LN9@CGRequestE:

; 17711: 			break;
; 17712: 	}
; 17713: 
; 17714: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u)", iITEM_LEVEL, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);

  005d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005d7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dwITEM_SERIAL$[ebp]
  005dd	51		 push	 ecx
  005de	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  005e2	52		 push	 edx
  005e3	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  005e7	50		 push	 eax
  005e8	53		 push	 ebx
  005e9	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@LDGANMDE@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  005ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005f4	83 c4 14	 add	 esp, 20			; 00000014H
  005f7	5e		 pop	 esi
  005f8	5b		 pop	 ebx
  005f9	5f		 pop	 edi

; 17715: }

  005fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005fd	33 cd		 xor	 ecx, ebp
  005ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00604	8b e5		 mov	 esp, ebp
  00606	5d		 pop	 ebp
  00607	c3		 ret	 0
$LN21@CGRequestE:

; 17617: 	}
; 17618: 	else 
; 17619: 	{
; 17620: 		if ( iRESULT == -1 )

  00608	83 f8 ff	 cmp	 eax, -1
  0060b	75 18		 jne	 SHORT $LN19@CGRequestE

; 17621: 		{
; 17622: 			pResult.Result = 4;
; 17623: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0060d	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00614	51		 push	 ecx
  00615	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0061b	c6 85 fb fe ff
	ff 04		 mov	 BYTE PTR _pResult$[ebp+3], 4
  00622	52		 push	 edx

; 17624: 			return;

  00623	eb 33		 jmp	 SHORT $LN79@CGRequestE
$LN19@CGRequestE:

; 17625: 		}
; 17626: 
; 17627: 		if ( iRESULT == 1 )

  00625	83 f8 01	 cmp	 eax, 1
  00628	75 37		 jne	 SHORT $LN70@CGRequestE

; 17628: 		{
; 17629: 			pResult.Result = 3;
; 17630: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0062a	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00631	50		 push	 eax
  00632	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00638	c6 85 fb fe ff
	ff 03		 mov	 BYTE PTR _pResult$[ebp+3], 3
  0063f	51		 push	 ecx

; 17631: 			return;

  00640	eb 16		 jmp	 SHORT $LN79@CGRequestE
$LN35@CGRequestE:

; 17607: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00642	0f b6 8d f9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00649	51		 push	 ecx
  0064a	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00650	52		 push	 edx
$LN80@CGRequestE:

; 17595: 			}
; 17596: 		}
; 17597: 		else
; 17598: 		{
; 17599: 			pResult.Result = 1;
; 17600: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 17601: 			return;
; 17602: 		}
; 17603: 	}
; 17604: 	else
; 17605: 	{
; 17606: 		pResult.Result = 1;

  00651	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
$LN79@CGRequestE:

; 17607: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00658	57		 push	 edi
  00659	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0065e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@CGRequestE:

; 17715: }

  00661	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00664	5e		 pop	 esi
  00665	5b		 pop	 ebx
  00666	33 cd		 xor	 ecx, ebp
  00668	5f		 pop	 edi
  00669	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066e	8b e5		 mov	 esp, ebp
  00670	5d		 pop	 ebp
  00671	c3		 ret	 0
  00672	8b ff		 npad	 2
$LN82@CGRequestE:
  00674	00 00 00 00	 DD	 $LN8@CGRequestE
  00678	00 00 00 00	 DD	 $LN7@CGRequestE
  0067c	00 00 00 00	 DD	 $LN6@CGRequestE
  00680	00 00 00 00	 DD	 $LN5@CGRequestE
  00684	00 00 00 00	 DD	 $LN4@CGRequestE
  00688	00 00 00 00	 DD	 $LN3@CGRequestE
  0068c	00 00 00 00	 DD	 $LN2@CGRequestE
  00690	00 00 00 00	 DD	 $LN1@CGRequestE
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ENDP ; CGRequestEnterBloodCastle
_TEXT	ENDS
PUBLIC	?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
EXTRN	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z:PROC	; CChaosCastle::ObjSetPosition
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z PROC ; CGRequestRepositionUserInChaosCastle, COMDAT

; 17977: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 17978: 	if ( !gObjIsConnected(aIndex) )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 5e		 je	 SHORT $LN1@CGRequestR

; 17979: 	{
; 17980: 		return;
; 17981: 	}
; 17982: 
; 17983: 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	56		 push	 esi
  0001b	8b f7		 mov	 esi, edi
  0001d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00023	0f b6 84 0e 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+329]
  0002b	3c 35		 cmp	 al, 53			; 00000035H
  0002d	74 0d		 je	 SHORT $LN10@CGRequestR
  0002f	3c 12		 cmp	 al, 18			; 00000012H
  00031	72 3e		 jb	 SHORT $LN11@CGRequestR
  00033	b2 17		 mov	 dl, 23			; 00000017H
  00035	3a d0		 cmp	 dl, al
  00037	1b c0		 sbb	 eax, eax
  00039	40		 inc	 eax
  0003a	74 35		 je	 SHORT $LN11@CGRequestR
$LN10@CGRequestR:

; 17984: 	{
; 17985: 		return;
; 17986: 	}
; 17987: 
; 17988: 	if ( g_ChaosCastle.ObjSetPosition(aIndex, gObj[aIndex].X, gObj[aIndex].Y) == TRUE )

  0003c	0f bf 84 0e 46
	01 00 00	 movsx	 eax, WORD PTR [esi+ecx+326]
  00044	0f bf 8c 0e 44
	01 00 00	 movsx	 ecx, WORD PTR [esi+ecx+324]
  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	57		 push	 edi
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00054	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  00059	83 f8 01	 cmp	 eax, 1
  0005c	75 13		 jne	 SHORT $LN11@CGRequestR

; 17989: 	{
; 17990: 		gObj[aIndex].m_iChaosCastleBlowTime = GetTickCount();

  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	89 84 16 a8 0e
	00 00		 mov	 DWORD PTR [esi+edx+3752], eax
$LN11@CGRequestR:
  00071	5e		 pop	 esi
$LN1@CGRequestR:
  00072	5f		 pop	 edi

; 17991: 	}
; 17992: }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ENDP ; CGRequestRepositionUserInChaosCastle
_TEXT	ENDS
PUBLIC	?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
EXTRN	?EGReqBloodCastleEnterCount@@YAXH@Z:PROC	; EGReqBloodCastleEnterCount
EXTRN	?EGReqIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXH@Z:PROC ; CIllusionTempleEvent::EGReqIllusionTempleEnterCount
; Function compile flags: /Ogtp
;	COMDAT ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z PROC ; CGRequestEventEnterCount, COMDAT

; 17995: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17996: 	if ( !lpMsg )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 28		 je	 SHORT $LN3@CGRequestE@2

; 17997: 	{
; 17998: 		return;
; 17999: 	}
; 18000: 
; 18001: 	switch ( lpMsg->btEventType )

  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0000e	83 e8 02	 sub	 eax, 2
  00011	74 13		 je	 SHORT $LN2@CGRequestE@2
  00013	48		 dec	 eax
  00014	75 1c		 jne	 SHORT $LN3@CGRequestE@2

; 18005: 			break;
; 18006: 		case 0x03: //Illusion Temple
; 18007: 			g_IllusionTempleEvent.EGReqIllusionTempleEnterCount(aIndex);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00019	50		 push	 eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  0001f	e8 00 00 00 00	 call	 ?EGReqIllusionTempleEnterCount@CIllusionTempleEvent@@QAEXH@Z ; CIllusionTempleEvent::EGReqIllusionTempleEnterCount

; 18008: 			break;
; 18009: 	}
; 18010: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN2@CGRequestE@2:

; 18002: 	{
; 18003: 		case 0x02:
; 18004: 			EGReqBloodCastleEnterCount(aIndex);

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?EGReqBloodCastleEnterCount@@YAXH@Z ; EGReqBloodCastleEnterCount
  0002f	83 c4 04	 add	 esp, 4
$LN3@CGRequestE@2:

; 18008: 			break;
; 18009: 	}
; 18010: }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ENDP ; CGRequestEventEnterCount
_TEXT	ENDS
PUBLIC	??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
;	COMDAT ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@
CONST	SEGMENT
??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@ DB '['
	DB	'Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-'
	DB	'%s)', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z PROC ; CGRequestLottoRegister, COMDAT

; 18013: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 18014: 	PMSG_REQ_2ANIV_SERIAL pMsg;
; 18015: 	PHeadSetB((LPBYTE)&pMsg, 0x08, sizeof(pMsg));

  00019	6a 28		 push	 40			; 00000028H
  0001b	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	6a 08		 push	 8
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 18016: 
; 18017: 	if ( gObj[aIndex].UseEventServer )

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	8b f3		 mov	 esi, ebx
  0002d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00033	33 c9		 xor	 ecx, ecx
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	39 8c 06 50 10
	00 00		 cmp	 DWORD PTR [esi+eax+4176], ecx
  0003f	0f 85 83 00 00
	00		 jne	 $LN2@CGRequestL

; 18018: 	{
; 18019: 		return;
; 18020: 	}
; 18021: 
; 18022: 	gObj[aIndex].UseEventServer = TRUE;

  00045	c7 84 06 50 10
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+4176], 1

; 18023: 	pMsg.iINDEX = aIndex;
; 18024: 	pMsg.iMEMB_GUID = gObj[aIndex].DBNumber;

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	89 5d d8	 mov	 DWORD PTR _pMsg$[ebp+4], ebx
  00058	8b 54 06 2c	 mov	 edx, DWORD PTR [esi+eax+44]

; 18025: 	memcpy(pMsg.szUID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  0005c	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00060	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+36], edx
  00063	8b 10		 mov	 edx, DWORD PTR [eax]
  00065	89 55 dc	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00068	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006b	89 55 e0	 mov	 DWORD PTR _pMsg$[ebp+12], edx
  0006e	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]

; 18026: 	pMsg.szUID[MAX_ACCOUNT_LEN] = 0;
; 18027: 	memcpy(pMsg.SERIAL1, lpMsg->SERIAL1, 4);

  00072	8b 57 03	 mov	 edx, DWORD PTR [edi+3]
  00075	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 18028: 	pMsg.SERIAL1[4] = 0;
; 18029: 	memcpy(pMsg.SERIAL2, lpMsg->SERIAL2, 4);

  00079	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007c	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0007f	89 55 e7	 mov	 DWORD PTR _pMsg$[ebp+19], edx

; 18030: 	pMsg.SERIAL2[4] = 0;
; 18031: 	memcpy(pMsg.SERIAL3, lpMsg->SERIAL3, 4);

  00082	8b 57 0d	 mov	 edx, DWORD PTR [edi+13]

; 18032: 	pMsg.SERIAL3[4] = 0;
; 18033: 
; 18034: 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00085	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00088	6a 28		 push	 40			; 00000028H
  0008a	50		 push	 eax
  0008b	88 4d e6	 mov	 BYTE PTR _pMsg$[ebp+18], cl
  0008e	88 4d eb	 mov	 BYTE PTR _pMsg$[ebp+23], cl
  00091	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+28], cl
  00094	89 55 f1	 mov	 DWORD PTR _pMsg$[ebp+29], edx
  00097	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+33], cl
  0009a	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 18035: 
; 18036: 	LogAddTD("[Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-%s)", gObj[aIndex].AccountID, gObj[aIndex].Name, pMsg.SERIAL1, pMsg.SERIAL2, pMsg.SERIAL3);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	8d 4d f1	 lea	 ecx, DWORD PTR _pMsg$[ebp+29]
  000a7	51		 push	 ecx
  000a8	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp+24]
  000ab	52		 push	 edx
  000ac	8d 4d e7	 lea	 ecx, DWORD PTR _pMsg$[ebp+19]
  000af	51		 push	 ecx
  000b0	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000b4	52		 push	 edx
  000b5	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c5	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@CGRequestL:

; 18037: }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	33 cd		 xor	 ecx, ebp
  000cf	5b		 pop	 ebx
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ENDP ; CGRequestLottoRegister
_TEXT	ENDS
PUBLIC	??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@ ; `string'
PUBLIC	??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ ; `string'
PUBLIC	??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ; CGReqMoveOtherServer
EXTRN	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; GJSetCharacterInfo
EXTRN	?gEnableServerDivision@@3HA:DWORD		; gEnableServerDivision
;	COMDAT ??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@
CONST	SEGMENT
??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@ DB '[CharTr'
	DB	'asfer] Request Character Trasfer [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
CONST	SEGMENT
??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ DB 0b9H
	DB	0aeH, 0c1H, 0a6H, ' ', 0b9H, 0dfH, 0bbH, 0fdH, 0bdH, 0c3H, ' c'
	DB	'hange@webzen.co.kr', 0b7H, 0ceH, ' ', 0b9H, 0aeH, 0c0H, 0c7H, 0c7H
	DB	0d8H, ' ', 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H, 0b9H, 0d9H, 0b6H
	DB	0f8H, 0b4H, 0cfH, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@
CONST	SEGMENT
??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@ DB '[Char'
	DB	'Trasfer] Fail (JoominNumber) [%s][%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z
_TEXT	SEGMENT
_pResult$ = -24						; size = 4
_pCharTransfer$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z PROC ; CGReqMoveOtherServer, COMDAT

; 18044: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18045: 	if ( !gEnableServerDivision)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEnableServerDivision@@3HA, 0 ; gEnableServerDivision
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001f	0f 84 27 01 00
	00		 je	 $LN5@CGReqMoveO

; 18046: 	{
; 18047: 		return;
; 18048: 	}
; 18049: 
; 18050: 	if ( !gObjIsConnectedGP(aIndex))

  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 2a		 jne	 SHORT $LN3@CGReqMoveO

; 18051: 	{
; 18052: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00032	68 84 46 00 00	 push	 18052			; 00004684H
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00041	6a 02		 push	 2
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	5f		 pop	 edi
  0004d	5b		 pop	 ebx

; 18089: }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN3@CGReqMoveO:
  0005c	56		 push	 esi

; 18053: 		return;
; 18054: 	}
; 18055: 
; 18056: 	LPOBJ lpObj = &gObj[aIndex];

  0005d	8b f7		 mov	 esi, edi
  0005f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00065	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18057: 
; 18058: 	if ( lpObj->m_MoveOtherServer )

  0006b	80 be d8 10 00
	00 00		 cmp	 BYTE PTR [esi+4312], 0
  00072	0f 85 d3 00 00
	00		 jne	 $LN7@CGReqMoveO

; 18059: 	{
; 18060: 		return;
; 18061: 	}
; 18062: 
; 18063: 	lpObj->m_MoveOtherServer = true;
; 18064: 
; 18065: 	PMSG_DEFRESULT pResult;
; 18066: 	PHeadSetB((LPBYTE)&pResult, 0x99, sizeof(pResult));

  00078	6a 04		 push	 4
  0007a	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0007d	68 99 00 00 00	 push	 153			; 00000099H
  00082	50		 push	 eax
  00083	c6 86 d8 10 00
	00 01		 mov	 BYTE PTR [esi+4312], 1
  0008a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 18067: 	
; 18068: 	if ( !gObjJoominCheck(aIndex, lpMsg->LastJoominNumber))

  0008f	83 c3 03	 add	 ebx, 3
  00092	53		 push	 ebx
  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YA_NHPAD@Z ; gObjJoominCheck
  00099	83 c4 14	 add	 esp, 20			; 00000014H
  0009c	84 c0		 test	 al, al
  0009e	75 4f		 jne	 SHORT $LN1@CGReqMoveO

; 18069: 	{
; 18070: 		pResult.result = 0;
; 18071: 
; 18072: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000a0	0f b6 4d e9	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  000a4	51		 push	 ecx
  000a5	8d 55 e8	 lea	 edx, DWORD PTR _pResult$[ebp]
  000a8	52		 push	 edx
  000a9	57		 push	 edi
  000aa	88 45 eb	 mov	 BYTE PTR _pResult$[ebp+3], al
  000ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18073: 		lpObj->m_MoveOtherServer = false;
; 18074: 
; 18075: 		LogAddTD("[CharTrasfer] Fail (JoominNumber) [%s][%s]", lpObj->AccountID, lpObj->Name);

  000b2	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  000b5	50		 push	 eax
  000b6	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  000b9	51		 push	 ecx
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@
  000bf	c6 86 d8 10 00
	00 00		 mov	 BYTE PTR [esi+4312], 0
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 18076: 		GCServerMsgStringSend("  change@webzen.co.kr  ", lpObj->m_Index, 1);

  000cc	8b 16		 mov	 edx, DWORD PTR [esi]
  000ce	6a 01		 push	 1
  000d0	52		 push	 edx
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
  000d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000db	83 c4 24	 add	 esp, 36			; 00000024H
  000de	5e		 pop	 esi
  000df	5f		 pop	 edi
  000e0	5b		 pop	 ebx

; 18089: }

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	33 cd		 xor	 ecx, ebp
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN1@CGReqMoveO:

; 18077: 		return;
; 18078: 	}
; 18079: 
; 18080: 	SDHP_CHARACTER_TRANSFER pCharTransfer;
; 18081: 
; 18082: 	GJSetCharacterInfo(lpObj, lpObj->m_Index, FALSE);

  000ef	8b 06		 mov	 eax, DWORD PTR [esi]
  000f1	6a 00		 push	 0
  000f3	50		 push	 eax
  000f4	56		 push	 esi
  000f5	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo

; 18083: 	PHeadSetB((LPBYTE)&pCharTransfer, 0xCF, sizeof(pCharTransfer));

  000fa	6a 10		 push	 16			; 00000010H
  000fc	8d 4d ec	 lea	 ecx, DWORD PTR _pCharTransfer$[ebp]
  000ff	68 cf 00 00 00	 push	 207			; 000000cfH
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 18084: 	pCharTransfer.Number = aIndex;

  0010a	66 89 7d fa	 mov	 WORD PTR _pCharTransfer$[ebp+14], di

; 18085: 	memcpy(pCharTransfer.Account, lpObj->AccountID, sizeof(pCharTransfer.Account));

  0010e	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00111	8d 7e 6c	 lea	 edi, DWORD PTR [esi+108]
  00114	89 55 ef	 mov	 DWORD PTR _pCharTransfer$[ebp+3], edx
  00117	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0011a	83 c4 18	 add	 esp, 24			; 00000018H
  0011d	89 45 f3	 mov	 DWORD PTR _pCharTransfer$[ebp+7], eax
  00120	66 8b 4f 08	 mov	 cx, WORD PTR [edi+8]

; 18086: 
; 18087: 	cDBSMng.Send((char*)&pCharTransfer, sizeof(pCharTransfer));

  00124	6a 10		 push	 16			; 00000010H
  00126	8d 55 ec	 lea	 edx, DWORD PTR _pCharTransfer$[ebp]
  00129	66 89 4d f7	 mov	 WORD PTR _pCharTransfer$[ebp+11], cx
  0012d	52		 push	 edx
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00133	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 18088: 	LogAddTD("[CharTrasfer] Request Character Trasfer [%s][%s]", lpObj->AccountID, lpObj->Name);

  00138	83 c6 77	 add	 esi, 119		; 00000077H
  0013b	56		 push	 esi
  0013c	57		 push	 edi
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGReqMoveO:
  0014b	5e		 pop	 esi
$LN5@CGReqMoveO:

; 18089: }

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014f	5f		 pop	 edi
  00150	33 cd		 xor	 ecx, ebp
  00152	5b		 pop	 ebx
  00153	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ENDP ; CGReqMoveOtherServer
_TEXT	ENDS
PUBLIC	?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
EXTRN	?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z:PROC	; CPacketCheckSum::AddCheckSum
EXTRN	?gPacketCheckSum@@3VCPacketCheckSum@@A:BYTE	; gPacketCheckSum
; Function compile flags: /Ogtp
;	COMDAT ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z PROC ; GCPacketCheckSumRecv, COMDAT

; 18092: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18093: 	gPacketCheckSum.AddCheckSum(aIndex, aRecv->funcindex, aRecv->CheckSum);

  00003	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPacketCheckSum@@3VCPacketCheckSum@@A ; gPacketCheckSum
  00018	e8 00 00 00 00	 call	 ?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z ; CPacketCheckSum::AddCheckSum

; 18094: }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ENDP ; GCPacketCheckSumRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z	; GCNPggSendCheckSum
; Function compile flags: /Ogtp
;	COMDAT ?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pggAuthData$ = 12					; size = 4
?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z PROC	; GCNPggSendCheckSum, COMDAT

; 18097: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _pggAuthData$[ebp]

; 18098: 	PMSG_NPROTECTGGCHECKSUM pMsg;
; 18099: 
; 18100: 	PHeadSetBE((LPBYTE)&pMsg, 0x73, sizeof(pMsg));

  00014	6a 14		 push	 20			; 00000014H
  00016	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 73		 push	 115			; 00000073H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 18101: 	memcpy(&pMsg.m_ggadCheckSum, pggAuthData, sizeof(pMsg.m_ggadCheckSum));

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 18102: 
; 18103: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0002c	6a 14		 push	 20			; 00000014H
  0002e	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00031	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00034	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00037	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  0003a	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0003d	52		 push	 edx
  0003e	50		 push	 eax
  0003f	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+16], ecx
  00042	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18104: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5e		 pop	 esi
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z ENDP	; GCNPggSendCheckSum
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ; CGDuelStartRequestRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z PROC ; CGDuelStartRequestRecv, COMDAT

; 18139: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18140: //#if(GS_CASTLE == 1)
; 18141: 	return;
; 18142: //#endif
; 18143: 	int iDuelIndex = -1;
; 18144: 	char szTempText[256];
; 18145: 
; 18146: 	if ( gObj[aIndex].CloseType != -1 )
; 18147: 		return;
; 18148: 	
; 18149: 	if ( gNonPK )
; 18150: 	{
; 18151: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 174)), aIndex, 1);
; 18152: 		return;
; 18153: 	}
; 18154: 
; 18155: 	if ( !gPkLimitFree )
; 18156: 	{
; 18157: 		BOOL bPlayerKiller = FALSE; //Season 2.5 add-on
; 18158: 
; 18159: 		if(ZtConfig.PvP.ZtPkPartySystem && gObj[aIndex].PartyNumber >= 0) //Season 2.5 add-on
; 18160: 		{
; 18161: 			if(gParty.GetPkLevel(gObj[aIndex].PartyNumber) >= 6)
; 18162: 			{
; 18163: 				bPlayerKiller = TRUE;
; 18164: 			}
; 18165: 		}
; 18166: 
; 18167: 		if(gObj[aIndex].m_PK_Level >= 6)
; 18168: 		{
; 18169: 			bPlayerKiller = TRUE;
; 18170: 		}
; 18171: 
; 18172: 		if ( bPlayerKiller == TRUE ) //? gObj[aIndex].m_PK_Level >= 6
; 18173: 		{
; 18174: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 175)), aIndex, 1);
; 18175: 			return;
; 18176: 		}
; 18177: 	}
; 18178: 
; 18179: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )
; 18180: 	{
; 18181: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 159)), aIndex, 1);
; 18182: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 18183: 		return;
; 18184: 	}
; 18185: 
; 18186: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser ) )
; 18187: 	{
; 18188: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), aIndex, 1);
; 18189: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 18190: 		return;
; 18191: 	}
; 18192: 
; 18193: 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )
; 18194: 	{
; 18195: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), aIndex, 1);
; 18196: 		return;
; 18197: 	}
; 18198: 
; 18199: 	LPOBJ lpObj = &gObj[aIndex];
; 18200: 
; 18201: 	if ( !PacketCheckTime(lpObj ) )
; 18202: 	{
; 18203: 		return;
; 18204: 	}
; 18205: 
; 18206: 	iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 18207: 
; 18208: 	if ( !OBJMAX_RANGE(iDuelIndex) )
; 18209: 	{
; 18210: 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);
; 18211: 		return;
; 18212: 	}
; 18213: 
; 18214: 	if ( iDuelIndex == aIndex  )
; 18215: 	{
; 18216: 		return;
; 18217: 	}
; 18218: 
; 18219: 	if ( !gPkLimitFree )
; 18220: 	{
; 18221: 		BOOL bPlayerKiller = FALSE; //Season 2.5 add-on
; 18222: 
; 18223: 		if(ZtConfig.PvP.ZtPkPartySystem && gObj[aIndex].PartyNumber >= 0) //Season 2.5 add-on
; 18224: 		{
; 18225: 			if(gParty.GetPkLevel(gObj[aIndex].PartyNumber) >= 6)
; 18226: 			{
; 18227: 				bPlayerKiller = TRUE;
; 18228: 			}
; 18229: 		}
; 18230: 
; 18231: 		if(gObj[aIndex].m_PK_Level >= 6)
; 18232: 		{
; 18233: 			bPlayerKiller = TRUE;
; 18234: 		}
; 18235: 
; 18236: 		if ( bPlayerKiller == TRUE )
; 18237: 		{
; 18238: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 176)), aIndex, 1);
; 18239: 			return;
; 18240: 		}
; 18241: 	}
; 18242: 
; 18243: 	char szDuelName[MAX_ACCOUNT_LEN+1]={0};
; 18244: 	char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 18245: 	memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);
; 18246: 	szDuelName[MAX_ACCOUNT_LEN] = 0;
; 18247: 	memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);
; 18248: 	szDuelName2[MAX_ACCOUNT_LEN] = 0;
; 18249: 
; 18250: 	if ( strcmp(szDuelName, szDuelName2) )
; 18251: 	{
; 18252: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 162)), aIndex, 1);
; 18253: 		return;
; 18254: 	}
; 18255: 
; 18256: 	if ( IsDuelEnable(iDuelIndex) == FALSE )
; 18257: 	{
; 18258: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 163)), aIndex, 1);
; 18259: 		return;
; 18260: 	}
; 18261: 
; 18262: 	if ( lpObj->lpGuild && lpObj->lpGuild->WarState == 1 )
; 18263: 	{
; 18264: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 164)), aIndex, 1);
; 18265: 		return;
; 18266: 	}
; 18267: 
; 18268: 	if ( gObj[iDuelIndex].lpGuild && gObj[iDuelIndex].lpGuild->WarState == 1 )
; 18269: 	{
; 18270: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 165)), aIndex, 1);
; 18271: 		return;
; 18272: 	}
; 18273: 
; 18274: 	if ( gObjIsConnected(iDuelIndex) == FALSE )
; 18275: 	{
; 18276: 		return;
; 18277: 	}
; 18278: 
; 18279: 	if ( gObj[iDuelIndex].Type == OBJ_MONSTER )
; 18280: 	{
; 18281: 		return;
; 18282: 	}
; 18283: 
; 18284: 	if ( gObj[iDuelIndex].CloseCount >= 0 )
; 18285: 	{
; 18286: 		return;
; 18287: 	}
; 18288: 
; 18289: 	BOOL bRetVal = FALSE;
; 18290: 
; 18291: 	for (int n=0;n<MAX_SELF_DEFENSE;n++)
; 18292: 	{
; 18293: 		if ( lpObj->SelfDefense[n] >= 0 )
; 18294: 		{
; 18295: 			bRetVal = TRUE;
; 18296: 			break;
; 18297: 		}
; 18298: 	}
; 18299: 
; 18300: 	if ( bRetVal )
; 18301: 	{
; 18302: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), aIndex, 1);
; 18303: 		return;
; 18304: 	}
; 18305: 
; 18306: 	for (int n=0;n<MAX_SELF_DEFENSE;n++)
; 18307: 	{
; 18308: 		if ( gObj[iDuelIndex].SelfDefense[n] >= 0 )
; 18309: 		{
; 18310: 			bRetVal = TRUE;
; 18311: 			break;
; 18312: 		}
; 18313: 	}
; 18314: 
; 18315: 	if ( bRetVal )
; 18316: 	{
; 18317: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), aIndex, 1);
; 18318: 		return;
; 18319: 	}
; 18320: 
; 18321: 	if ( DS_MAP_RANGE(gObj[iDuelIndex].MapNumber ) )
; 18322: 	{
; 18323: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 180)), aIndex, 1);
; 18324: 		return;
; 18325: 	}
; 18326: 
; 18327: 	if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) )
; 18328: 	{
; 18329: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 166)), aIndex, 1);
; 18330: 		return;
; 18331: 	}
; 18332: 
; 18333: 	if ( lpObj->m_IfState.use > 0 )
; 18334: 	{
; 18335: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 167)), aIndex, 1);
; 18336: 		return;
; 18337: 	}
; 18338: 
; 18339: 	if ( gObj[iDuelIndex].m_IfState.use > 0 )
; 18340: 	{
; 18341: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 168)), gObj[iDuelIndex].Name);
; 18342: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 18343: 		return;
; 18344: 	}
; 18345: 
; 18346: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserRequested) )
; 18347: 	{
; 18348: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 169)), gObj[iDuelIndex].Name);
; 18349: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 18350: 		return;
; 18351: 	}
; 18352: 
; 18353: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserReserved) )
; 18354: 	{
; 18355: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 170)), gObj[iDuelIndex].Name);
; 18356: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 18357: 		return;
; 18358: 	}
; 18359: 
; 18360: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )
; 18361: 	{
; 18362: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 171)), gObj[iDuelIndex].Name);
; 18363: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 18364: 		return;
; 18365: 	}
; 18366: 
; 18367: 	lpObj->m_iDuelUserReserved = iDuelIndex;
; 18368: 	lpObj->m_iDuelUser = -1;
; 18369: 	gObj[iDuelIndex].m_iDuelUserRequested = aIndex;
; 18370: 
; 18371: 	PMSG_REQ_DUEL_OK pMsg;
; 18372: 
; 18373: 	pMsg.h.c = 0xC1;
; 18374: 	pMsg.h.headcode = 0xAC;
; 18375: 	pMsg.h.size = sizeof(pMsg);
; 18376: 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 18377: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 18378: 	memcpy(pMsg.szName, gObj[aIndex].Name, sizeof(pMsg.szName));
; 18379: 
; 18380: 	DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 18381: 
; 18382: 	wsprintf(szTempText, lMsg.Get(MSGGET(4, 172)), gObj[iDuelIndex].Name);
; 18383: 	GCServerMsgStringSend(szTempText, aIndex, 1);
; 18384: 
; 18385: 	LogAddTD("[Duel] [%s][%s] Requested to Start Duel to [%s][%s]", lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 18386: }

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00011	33 cd		 xor	 ecx, ebp
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ENDP ; CGDuelStartRequestRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ; CGDuelEndRequestRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z PROC ; CGDuelEndRequestRecv, COMDAT

; 18389: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18390: //#if(GS_CASTLE==1)
; 18391: 	return;
; 18392: //#endif
; 18393: 	int iDuelIndex = -1;
; 18394: 
; 18395: 	if ( gObj[aIndex].CloseType != -1 )
; 18396: 	{
; 18397: 		return;
; 18398: 	}
; 18399: 
; 18400: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )
; 18401: 	{
; 18402: 		gObj[aIndex].m_iDuelUserReserved = -1;
; 18403: 	}
; 18404: 
; 18405: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser) )
; 18406: 	{
; 18407: 		iDuelIndex = gObj[aIndex].m_iDuelUser;
; 18408: 		gObj[aIndex].m_iDuelUser = -1;
; 18409: 
; 18410: 		PMSG_ANS_END_DUEL pMsg;
; 18411: 
; 18412: 		pMsg.h.c = 0xC1;
; 18413: 		pMsg.h.headcode = 0xAB;
; 18414: 		pMsg.h.size = sizeof(pMsg);
; 18415: 		pMsg.NumberH = SET_NUMBERH(iDuelIndex);
; 18416: 		pMsg.NumberL = SET_NUMBERL(iDuelIndex);
; 18417: 		memcpy(pMsg.szName, gObj[iDuelIndex].Name, sizeof(pMsg.szName));
; 18418: 
; 18419: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 18420: 
; 18421: 		if ( iDuelIndex == aIndex )
; 18422: 		{
; 18423: 			return;
; 18424: 		}
; 18425: 	}
; 18426: 	else
; 18427: 	{
; 18428: 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);
; 18429: 		return;
; 18430: 	}
; 18431: 
; 18432: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )
; 18433: 	{
; 18434: 		if ( gObj[iDuelIndex].m_iDuelUser == aIndex )
; 18435: 		{
; 18436: 			gObj[iDuelIndex].m_iDuelUser = -1;
; 18437: 
; 18438: 			PMSG_ANS_END_DUEL pMsg;
; 18439: 
; 18440: 			pMsg.h.c = 0xC1;
; 18441: 			pMsg.h.headcode = 0xAB;
; 18442: 			pMsg.h.size = sizeof(pMsg);
; 18443: 			pMsg.NumberH = SET_NUMBERH(aIndex);
; 18444: 			pMsg.NumberL = SET_NUMBERL(aIndex);
; 18445: 			memcpy(pMsg.szName, gObj[aIndex].Name, sizeof(pMsg.szName));
; 18446: 
; 18447: 			DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 18448: 
; 18449: 			LogAddTD("[Duel] [%s][%s] Duel Ended [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 18450: 		}
; 18451: 	}
; 18452: }

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00011	33 cd		 xor	 ecx, ebp
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ENDP ; CGDuelEndRequestRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendDuelScore@@YAXHH@Z			; GCSendDuelScore
; Function compile flags: /Ogtp
;	COMDAT ?GCSendDuelScore@@YAXHH@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_aIndex1$ = 8						; size = 4
_aIndex2$ = 12						; size = 4
?GCSendDuelScore@@YAXHH@Z PROC				; GCSendDuelScore, COMDAT

; 18596: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18597: //#if(GS_CASTLE==1)
; 18598: 	return;
; 18599: //#endif
; 18600: 	PMSG_ANS_DUEL_SCORE pMsg;
; 18601: 
; 18602: 	if ( !OBJMAX_RANGE(aIndex1) || !OBJMAX_RANGE(aIndex2))
; 18603: 	{
; 18604: 		return;
; 18605: 	}
; 18606: 
; 18607: 	if ( !gObjIsConnected(aIndex1) || !gObjIsConnected(aIndex2) )
; 18608: 	{
; 18609: 		return;
; 18610: 	}
; 18611: 
; 18612: 	if ( gObj[aIndex1].Type == OBJ_MONSTER || gObj[aIndex2].Type == OBJ_MONSTER )
; 18613: 	{
; 18614: 		return;
; 18615: 	}
; 18616: 	
; 18617: 	if ( gObj[aIndex1].CloseCount >= 0 || gObj[aIndex2].CloseCount >= 0 )
; 18618: 	{
; 18619: 		return;
; 18620: 	}
; 18621: 
; 18622: 	pMsg.h.c = 0xC1;
; 18623: 	pMsg.h.headcode = 0xAD;
; 18624: 	pMsg.h.size = sizeof(pMsg);
; 18625: 	pMsg.NumberH1 = SET_NUMBERH(aIndex1);
; 18626: 	pMsg.NumberL1 = SET_NUMBERL(aIndex1);
; 18627: 	pMsg.NumberH2 = SET_NUMBERH(aIndex2);
; 18628: 	pMsg.NumberL2 = SET_NUMBERL(aIndex2);
; 18629: 	pMsg.btDuelScore1 = gObj[aIndex1].m_btDuelScore;
; 18630: 	pMsg.btDuelScore2 = gObj[aIndex2].m_btDuelScore;
; 18631: 
; 18632: 	DataSend(aIndex1, (LPBYTE)&pMsg, pMsg.h.size);
; 18633: 	DataSend(aIndex2, (LPBYTE)&pMsg, pMsg.h.size);
; 18634: }

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00011	33 cd		 xor	 ecx, ebp
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GCSendDuelScore@@YAXHH@Z ENDP				; GCSendDuelScore
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z	; GCSendGetItemInfoForParty
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z:PROC ; CItemSystemFor380::Is380OptionItem
; Function compile flags: /Ogtp
;	COMDAT ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z
_TEXT	SEGMENT
_pMsg$251108 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpItem$ = 12						; size = 4
?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z PROC	; GCSendGetItemInfoForParty, COMDAT

; 18639: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _lpItem$[ebp]
  00017	57		 push	 edi

; 18640: 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b f8		 mov	 edi, eax
  0001a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00020	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18641: 
; 18642: 	if ( lpObj->PartyNumber >= 0)

  00026	83 bf 2c 04 00
	00 00		 cmp	 DWORD PTR [edi+1068], 0
  0002d	0f 8c db 00 00
	00		 jl	 $LN2@GCSendGetI

; 18643: 	{
; 18644: 		PMSG_GETITEMINFO_FOR_PARTY pMsg;
; 18645: 
; 18646: 		pMsg.h.c = 0xC1;
; 18647: 		pMsg.h.headcode = 0x47;
; 18648: 		pMsg.h.size = sizeof(pMsg);
; 18649: 		pMsg.NumberH = SET_NUMBERH(aIndex);

  00033	8b c8		 mov	 ecx, eax

; 18650: 		pMsg.NumberL = SET_NUMBERL(aIndex);

  00035	88 45 f0	 mov	 BYTE PTR _pMsg$251108[ebp+4], al

; 18651: 		pMsg.ItemInfo = lpItem->m_Type & (ITEMGET(MAX_TYPE_ITEMS-1, MAX_SUBTYPE_ITEMS-1));

  00038	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  0003c	c1 e9 08	 shr	 ecx, 8
  0003f	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH

; 18652: 
; 18653: 		if ( lpItem->m_Option1 )

  00044	80 be 98 00 00
	00 00		 cmp	 BYTE PTR [esi+152], 0
  0004b	c6 45 ec c1	 mov	 BYTE PTR _pMsg$251108[ebp], 193 ; 000000c1H
  0004f	66 c7 45 ed 10
	47		 mov	 WORD PTR _pMsg$251108[ebp+1], 18192 ; 00004710H
  00055	88 4d ef	 mov	 BYTE PTR _pMsg$251108[ebp+3], cl
  00058	89 45 f4	 mov	 DWORD PTR _pMsg$251108[ebp+8], eax
  0005b	74 08		 je	 SHORT $LN11@GCSendGetI

; 18654: 		{
; 18655: 			pMsg.ItemInfo |= 0x2000;

  0005d	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  00062	89 45 f4	 mov	 DWORD PTR _pMsg$251108[ebp+8], eax
$LN11@GCSendGetI:

; 18656: 		}
; 18657: 
; 18658: 		if ( lpItem->m_Option2 )

  00065	80 be 99 00 00
	00 00		 cmp	 BYTE PTR [esi+153], 0
  0006c	74 08		 je	 SHORT $LN10@GCSendGetI

; 18659: 		{
; 18660: 			pMsg.ItemInfo |= 0x4000;

  0006e	0d 00 40 00 00	 or	 eax, 16384		; 00004000H
  00073	89 45 f4	 mov	 DWORD PTR _pMsg$251108[ebp+8], eax
$LN10@GCSendGetI:

; 18661: 		}
; 18662: 
; 18663: 		if ( lpItem->m_Option3 )

  00076	80 be 9a 00 00
	00 00		 cmp	 BYTE PTR [esi+154], 0
  0007d	74 08		 je	 SHORT $LN9@GCSendGetI

; 18664: 		{
; 18665: 			pMsg.ItemInfo |= 0x8000;

  0007f	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00084	89 45 f4	 mov	 DWORD PTR _pMsg$251108[ebp+8], eax
$LN9@GCSendGetI:

; 18666: 		}
; 18667: 
; 18668: 		if ( lpItem->m_NewOption )

  00087	80 be 9b 00 00
	00 00		 cmp	 BYTE PTR [esi+155], 0
  0008e	74 08		 je	 SHORT $LN8@GCSendGetI

; 18669: 		{
; 18670: 			pMsg.ItemInfo |= 0x10000;

  00090	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  00095	89 45 f4	 mov	 DWORD PTR _pMsg$251108[ebp+8], eax
$LN8@GCSendGetI:

; 18671: 		}
; 18672: 
; 18673: 		if ( lpItem->m_SetOption )

  00098	80 be b2 00 00
	00 00		 cmp	 BYTE PTR [esi+178], 0
  0009f	74 08		 je	 SHORT $LN7@GCSendGetI

; 18674: 		{
; 18675: 			pMsg.ItemInfo |= 0x20000;

  000a1	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  000a6	89 45 f4	 mov	 DWORD PTR _pMsg$251108[ebp+8], eax
$LN7@GCSendGetI:

; 18676: 		}
; 18677: 
; 18678: 		if ( g_kItemSystemFor380.Is380OptionItem( (lpItem != NULL)?((CItem *)&lpItem->m_Number):NULL) == TRUE )

  000a9	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  000ac	52		 push	 edx
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  000b2	e8 00 00 00 00	 call	 ?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380OptionItem
  000b7	83 f8 01	 cmp	 eax, 1
  000ba	75 07		 jne	 SHORT $LN6@GCSendGetI

; 18679: 		{
; 18680: 			pMsg.ItemInfo |= 0x40000;

  000bc	81 4d f4 00 00
	04 00		 or	 DWORD PTR _pMsg$251108[ebp+8], 262144 ; 00040000H
$LN6@GCSendGetI:

; 18681: 		}
; 18682: 
; 18683: 		pMsg.Level = lpItem->m_Level;
; 18684: 		
; 18685: 		int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  000c3	8b 8f 2c 04 00
	00		 mov	 ecx, DWORD PTR [edi+1068]
  000c9	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  000cc	51		 push	 ecx
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000d2	88 45 f8	 mov	 BYTE PTR _pMsg$251108[ebp+12], al
  000d5	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 18686: 
; 18687: 		if ( partycount >= 0 )

  000da	85 c0		 test	 eax, eax
  000dc	78 30		 js	 SHORT $LN2@GCSendGetI

; 18688: 		{
; 18689: 			for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  000de	33 f6		 xor	 esi, esi
$LL4@GCSendGetI:

; 18690: 			{
; 18691: 				int number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  000e0	8b 97 2c 04 00
	00		 mov	 edx, DWORD PTR [edi+1068]
  000e6	6b d2 1a	 imul	 edx, 26			; 0000001aH
  000e9	03 d6		 add	 edx, esi
  000eb	8b 04 95 0c 00
	00 00		 mov	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[edx*4+12]

; 18692: 
; 18693: 				if ( number >= 0 )

  000f2	85 c0		 test	 eax, eax
  000f4	78 12		 js	 SHORT $LN3@GCSendGetI

; 18694: 				{
; 18695: 					DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  000f6	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$251108[ebp+1]
  000fa	51		 push	 ecx
  000fb	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$251108[ebp]
  000fe	52		 push	 edx
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCSendGetI:

; 18688: 		{
; 18689: 			for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00108	46		 inc	 esi
  00109	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  0010c	7c d2		 jl	 SHORT $LL4@GCSendGetI
$LN2@GCSendGetI:

; 18696: 				}
; 18697: 			}
; 18698: 		}
; 18699: 	}
; 18700: }

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	5f		 pop	 edi
  00112	33 cd		 xor	 ecx, ebp
  00114	5e		 pop	 esi
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ENDP	; GCSendGetItemInfoForParty
_TEXT	ENDS
PUBLIC	?GCSendEffectInfo@@YAXHE@Z			; GCSendEffectInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCSendEffectInfo@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btType$ = 12						; size = 1
?GCSendEffectInfo@@YAXHE@Z PROC				; GCSendEffectInfo, COMDAT

; 18703: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18704: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 5f		 js	 SHORT $LN3@GCSendEffe
  0000d	33 c9		 xor	 ecx, ecx
  0000f	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00014	0f 9e c1	 setle	 cl
  00017	85 c9		 test	 ecx, ecx
  00019	74 51		 je	 SHORT $LN3@GCSendEffe

; 18705: 	{
; 18706: 		return;
; 18707: 	}
; 18708: 
; 18709: 	LPOBJ lpObj = &gObj[aIndex];

  0001b	56		 push	 esi
  0001c	8b f0		 mov	 esi, eax
  0001e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00024	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 18710: 	PMSG_EFFECTINFO pMsg;
; 18711: 
; 18712: 	pMsg.h.c = 0xC1;
; 18713: 	pMsg.h.headcode = 0x48;
; 18714: 	pMsg.h.size = sizeof(pMsg);
; 18715: 	pMsg.NumberH = SET_NUMBERH(aIndex);

  0002a	8b c8		 mov	 ecx, eax
  0002c	c1 e9 08	 shr	 ecx, 8
  0002f	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 18716: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 18717: 	pMsg.btType = btType;

  00032	8a 4d 0c	 mov	 cl, BYTE PTR _btType$[ebp]
  00035	c6 45 f8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H
  00039	66 c7 45 f9 06
	48		 mov	 WORD PTR _pMsg$[ebp+1], 18438 ; 00004806H
  0003f	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00042	88 4d fd	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 18718: 
; 18719: 	if ( btType == 17 )

  00045	80 f9 11	 cmp	 cl, 17			; 00000011H
  00048	75 0f		 jne	 SHORT $LN1@GCSendEffe

; 18720: 	{
; 18721: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0004a	6a 06		 push	 6
  0004c	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0004f	52		 push	 edx
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendEffe:

; 18722: 	}
; 18723: 
; 18724: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00059	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005d	50		 push	 eax
  0005e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00061	51		 push	 ecx
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	5e		 pop	 esi
$LN3@GCSendEffe:

; 18725: }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GCSendEffectInfo@@YAXHE@Z ENDP				; GCSendEffectInfo
_TEXT	ENDS
PUBLIC	??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
EXTRN	?ChangeCommand@CDarkSpirit@@QAEXHH@Z:PROC	; CDarkSpirit::ChangeCommand
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
;	COMDAT ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@ DB 'error-L2 :'
	DB	' Index %s %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z PROC ; CGRequestPetItemCommand, COMDAT

; 18728: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 18729: 	if ( !gObjIsConnectedGP(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 1b		 jne	 SHORT $LN3@CGRequestP

; 18730: 	{
; 18731: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00014	68 2b 49 00 00	 push	 18731			; 0000492bH
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	5e		 pop	 esi

; 18749: }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN3@CGRequestP:

; 18732: 		return;
; 18733: 	}
; 18734: 
; 18735: 	if ( !OBJMAX_RANGE(aIndex))

  0002f	85 f6		 test	 esi, esi
  00031	78 3e		 js	 SHORT $LN4@CGRequestP
  00033	33 c0		 xor	 eax, eax
  00035	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0003b	0f 9e c0	 setle	 al
  0003e	85 c0		 test	 eax, eax
  00040	74 2f		 je	 SHORT $LN4@CGRequestP

; 18736: 	{
; 18737: 		return;
; 18738: 	}
; 18739: 
; 18740: 	LPOBJ lpObj = &gObj[aIndex];
; 18741: 
; 18742: 	if ( lpMsg->PetType )

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00045	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  00049	75 26		 jne	 SHORT $LN4@CGRequestP

; 18743: 	{
; 18744: 		return;
; 18745: 	}
; 18746: 
; 18747: 	int iTargetIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 18748: 	gDarkSpirit[aIndex].ChangeCommand(lpMsg->Command, iTargetIndex);

  0004b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0004f	66 c1 e1 08	 shl	 cx, 8
  00053	0f b7 d1	 movzx	 edx, cx
  00056	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0005a	0b d1		 or	 edx, ecx
  0005c	52		 push	 edx
  0005d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00061	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00064	52		 push	 edx
  00065	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gDarkSpirit@@3PAVCDarkSpirit@@A[ecx*8]
  0006c	e8 00 00 00 00	 call	 ?ChangeCommand@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::ChangeCommand
$LN4@CGRequestP:
  00071	5e		 pop	 esi

; 18749: }

  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ENDP ; CGRequestPetItemCommand
_TEXT	ENDS
PUBLIC	??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
;	COMDAT ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z
_TEXT	SEGMENT
tv760 = -32						; size = 4
tv758 = -32						; size = 4
tv747 = -32						; size = 4
tv744 = -32						; size = 4
tv723 = -32						; size = 4
tv721 = -32						; size = 4
tv806 = -28						; size = 4
tv804 = -28						; size = 4
tv793 = -28						; size = 4
tv791 = -28						; size = 4
tv778 = -28						; size = 4
tv776 = -28						; size = 4
_aIndex$GSCopy$ = -28					; size = 4
tv810 = -22						; size = 2
tv796 = -22						; size = 2
tv781 = -22						; size = 2
tv764 = -22						; size = 2
tv750 = -22						; size = 2
tv726 = -22						; size = 2
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z PROC ; CGRequestPetItemInfo, COMDAT

; 18752: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 18753: 	if ( !gObjIsConnectedGP(aIndex))

  00018	57		 push	 edi

; 18901: 				{
; 18902: 					pMsg.Exp = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Exp;

  00019	89 7d e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN37@CGRequestP@2

; 18754: 	{
; 18755: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00028	68 43 49 00 00	 push	 18755			; 00004943H
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	5f		 pop	 edi
  00041	5b		 pop	 ebx

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN37@CGRequestP@2:

; 18756: 		return;
; 18757: 	}
; 18758: 
; 18759: 	if ( !OBJMAX_RANGE(aIndex))

  00050	85 ff		 test	 edi, edi
  00052	0f 88 94 05 00
	00		 js	 $LN1@CGRequestP@2
  00058	33 c0		 xor	 eax, eax
  0005a	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00060	0f 9e c0	 setle	 al
  00063	85 c0		 test	 eax, eax
  00065	0f 84 81 05 00
	00		 je	 $LN1@CGRequestP@2

; 18760: 	{
; 18761: 		return;
; 18762: 	}
; 18763: 
; 18764: 	LPOBJ lpObj = &gObj[aIndex];

  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00071	8b c7		 mov	 eax, edi
  00073	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00079	56		 push	 esi
  0007a	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 18765: 
; 18766: 	if ( lpMsg->PetType != 0 && lpMsg->PetType != 1 )

  0007d	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  00080	84 c0		 test	 al, al
  00082	74 08		 je	 SHORT $LN35@CGRequestP@2
  00084	3c 01		 cmp	 al, 1
  00086	0f 85 5f 05 00
	00		 jne	 $LN60@CGRequestP@2
$LN35@CGRequestP@2:

; 18767: 	{
; 18768: 		return;
; 18769: 	}
; 18770: 	
; 18771: 	PMSG_SEND_PET_ITEMINFO pMsg;
; 18772: 
; 18773: 	pMsg.h.set((LPBYTE)&pMsg, 0xA9, sizeof(pMsg));
; 18774: 	pMsg.PetType = lpMsg->PetType;
; 18775: 	pMsg.InvenType = lpMsg->InvenType;

  0008c	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00090	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18776: 	pMsg.nPos = lpMsg->nPos;

  00093	8a 43 05	 mov	 al, BYTE PTR [ebx+5]
  00096	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H
  0009c	c6 45 ee a9	 mov	 BYTE PTR _pMsg$[ebp+2], 169 ; 000000a9H
  000a0	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  000a3	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 18777: 
; 18778: 	if ( lpMsg->InvenType == 0 )	// Inventory

  000a6	84 c9		 test	 cl, cl
  000a8	0f 85 87 00 00
	00		 jne	 $LN34@CGRequestP@2

; 18779: 	{
; 18780: 		if ( !INVENTORY_RANGE(lpMsg->nPos))

  000ae	b2 eb		 mov	 dl, 235			; 000000ebH
  000b0	3a d0		 cmp	 dl, al
  000b2	1b c9		 sbb	 ecx, ecx
  000b4	41		 inc	 ecx

; 18781: 		{
; 18782: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d", lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 18783: 			return;

  000b5	0f 84 21 04 00
	00		 je	 $LN64@CGRequestP@2

; 18784: 		}
; 18785: 
; 18786: 		if ( lpObj->pInventory[lpMsg->nPos].IsItem() )

  000bb	0f b6 c8	 movzx	 ecx, al
  000be	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  000c4	03 8e 24 0e 00
	00		 add	 ecx, DWORD PTR [esi+3620]
  000ca	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 14 05 00
	00		 je	 $LN60@CGRequestP@2

; 18787: 		{
; 18788: 			pMsg.Exp = lpObj->pInventory[lpMsg->nPos].m_PetItem_Exp;

  000d7	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 18789: 			pMsg.Level = lpObj->pInventory[lpMsg->nPos].m_PetItem_Level;
; 18790: 			pMsg.Life = (BYTE)lpObj->pInventory[lpMsg->nPos].m_Durability;

  000db	d9 7d ea	 fnstcw	 WORD PTR tv810[ebp]
  000de	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  000e4	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000ea	8b 8c 10 c0 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+192]
  000f1	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  000f4	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  000fa	8a 8c 10 bc 00
	00 00		 mov	 cl, BYTE PTR [eax+edx+188]
  00101	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  00104	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]

; 18791: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0010a	6a 10		 push	 16			; 00000010H
  0010c	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0010f	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00113	0f b7 45 ea	 movzx	 eax, WORD PTR tv810[ebp]
  00117	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0011c	89 45 e4	 mov	 DWORD PTR tv806[ebp], eax
  0011f	51		 push	 ecx
  00120	57		 push	 edi
  00121	d9 6d e4	 fldcw	 WORD PTR tv806[ebp]
  00124	db 5d e4	 fistp	 DWORD PTR tv804[ebp]
  00127	8a 45 e4	 mov	 al, BYTE PTR tv804[ebp]
  0012a	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  0012d	d9 6d ea	 fldcw	 WORD PTR tv810[ebp]

; 18792: 		}
; 18793: 	}

  00130	e9 ae 04 00 00	 jmp	 $LN61@CGRequestP@2
$LN34@CGRequestP@2:

; 18794: 	else if ( lpMsg->InvenType == 1 )	// Warehouse

  00135	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00139	80 f9 01	 cmp	 cl, 1
  0013c	0f 85 bb 00 00
	00		 jne	 $LN30@CGRequestP@2

; 18795: 	{
; 18796: 		if ( lpObj->LoadWareHouseInfo != false )

  00142	80 be 54 10 00
	00 00		 cmp	 BYTE PTR [esi+4180], 0
  00149	0f 84 9c 04 00
	00		 je	 $LN60@CGRequestP@2

; 18797: 		{
; 18798: 			if ( !WAREHOUSE_RANGE(lpMsg->nPos))

  0014f	b2 ef		 mov	 dl, 239			; 000000efH
  00151	3a d0		 cmp	 dl, al
  00153	1b c9		 sbb	 ecx, ecx
  00155	41		 inc	 ecx
  00156	75 2b		 jne	 SHORT $LN28@CGRequestP@2

; 18799: 			{
; 18800: 				LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d",	lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00158	0f b6 c0	 movzx	 eax, al
  0015b	50		 push	 eax
  0015c	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0015f	51		 push	 ecx
  00160	83 c6 6c	 add	 esi, 108		; 0000006cH
  00163	56		 push	 esi
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016f	83 c4 10	 add	 esp, 16			; 00000010H
  00172	5e		 pop	 esi
  00173	5f		 pop	 edi
  00174	5b		 pop	 ebx

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  00175	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
$LN28@CGRequestP@2:

; 18801: 				return;
; 18802: 			}
; 18803: 
; 18804: 			if ( lpObj->pWarehouse[lpMsg->nPos].IsItem() )

  00183	0f b6 c8	 movzx	 ecx, al
  00186	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0018c	03 8e 5c 0e 00
	00		 add	 ecx, DWORD PTR [esi+3676]
  00192	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00197	85 c0		 test	 eax, eax
  00199	0f 84 4c 04 00
	00		 je	 $LN60@CGRequestP@2

; 18805: 			{
; 18806: 				pMsg.Exp = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Exp;

  0019f	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 18807: 				pMsg.Level = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Level;
; 18808: 				pMsg.Life = (BYTE)lpObj->pWarehouse[lpMsg->nPos].m_Durability;

  001a3	d9 7d ea	 fnstcw	 WORD PTR tv796[ebp]
  001a6	8b 96 5c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3676]
  001ac	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  001b2	8b 8c 10 c0 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+192]
  001b9	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  001bc	8b 96 5c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3676]
  001c2	8a 8c 10 bc 00
	00 00		 mov	 cl, BYTE PTR [eax+edx+188]
  001c9	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  001cc	8b 96 5c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3676]

; 18809: 				DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  001d2	6a 10		 push	 16			; 00000010H
  001d4	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001d7	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  001db	0f b7 45 ea	 movzx	 eax, WORD PTR tv796[ebp]
  001df	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001e4	89 45 e4	 mov	 DWORD PTR tv793[ebp], eax
  001e7	51		 push	 ecx
  001e8	57		 push	 edi
  001e9	d9 6d e4	 fldcw	 WORD PTR tv793[ebp]
  001ec	db 5d e4	 fistp	 DWORD PTR tv791[ebp]
  001ef	8a 45 e4	 mov	 al, BYTE PTR tv791[ebp]
  001f2	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  001f5	d9 6d ea	 fldcw	 WORD PTR tv796[ebp]

; 18810: 			}
; 18811: 		}
; 18812: 	}

  001f8	e9 e6 03 00 00	 jmp	 $LN61@CGRequestP@2
$LN30@CGRequestP@2:

; 18813: 	else if ( lpMsg->InvenType == 2 )	// Trade

  001fd	80 f9 02	 cmp	 cl, 2
  00200	0f 85 d3 00 00
	00		 jne	 $LN25@CGRequestP@2

; 18814: 	{
; 18815: 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  00206	8b 8e 1c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3612]
  0020c	8b d1		 mov	 edx, ecx
  0020e	80 e2 03	 and	 dl, 3
  00211	80 fa 01	 cmp	 dl, 1
  00214	0f 82 d1 03 00
	00		 jb	 $LN60@CGRequestP@2
  0021a	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00220	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00223	0f 85 c2 03 00
	00		 jne	 $LN60@CGRequestP@2

; 18816: 		{
; 18817: 			return;
; 18818: 		}
; 18819: 
; 18820: 		if ( !TRADE_BOX_RANGE(lpMsg->nPos))

  00229	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0022e	3a c8		 cmp	 cl, al
  00230	1b c9		 sbb	 ecx, ecx
  00232	41		 inc	 ecx
  00233	75 2b		 jne	 SHORT $LN22@CGRequestP@2

; 18821: 		{
; 18822: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d",	lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00235	0f b6 d0	 movzx	 edx, al
  00238	52		 push	 edx
  00239	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0023c	50		 push	 eax
  0023d	83 c6 6c	 add	 esi, 108		; 0000006cH
  00240	56		 push	 esi
  00241	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0024c	83 c4 10	 add	 esp, 16			; 00000010H
  0024f	5e		 pop	 esi
  00250	5f		 pop	 edi
  00251	5b		 pop	 ebx

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  00252	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00255	33 cd		 xor	 ecx, ebp
  00257	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025c	8b e5		 mov	 esp, ebp
  0025e	5d		 pop	 ebp
  0025f	c3		 ret	 0
$LN22@CGRequestP@2:

; 18823: 			return;
; 18824: 		}
; 18825: 
; 18826: 		if ( lpObj->Trade[lpMsg->nPos].IsItem() )

  00260	0f b6 c8	 movzx	 ecx, al
  00263	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00269	03 8e 4c 0e 00
	00		 add	 ecx, DWORD PTR [esi+3660]
  0026f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00274	85 c0		 test	 eax, eax
  00276	0f 84 6f 03 00
	00		 je	 $LN60@CGRequestP@2

; 18827: 		{
; 18828: 			pMsg.Exp = lpObj->Trade[lpMsg->nPos].m_PetItem_Exp;

  0027c	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 18829: 			pMsg.Level = lpObj->Trade[lpMsg->nPos].m_PetItem_Level;
; 18830: 			pMsg.Life = (BYTE)lpObj->Trade[lpMsg->nPos].m_Durability;

  00280	d9 7d ea	 fnstcw	 WORD PTR tv781[ebp]
  00283	8b 8e 4c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3660]
  00289	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0028f	8b 94 08 c0 00
	00 00		 mov	 edx, DWORD PTR [eax+ecx+192]
  00296	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00299	8b 8e 4c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3660]
  0029f	0f b6 94 08 bc
	00 00 00	 movzx	 edx, BYTE PTR [eax+ecx+188]
  002a7	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  002aa	8b 8e 4c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3660]

; 18831: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002b0	6a 10		 push	 16			; 00000010H
  002b2	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  002b6	0f b7 45 ea	 movzx	 eax, WORD PTR tv781[ebp]
  002ba	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002bf	89 45 e4	 mov	 DWORD PTR tv778[ebp], eax
  002c2	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002c5	50		 push	 eax
  002c6	d9 6d e4	 fldcw	 WORD PTR tv778[ebp]
  002c9	57		 push	 edi
  002ca	db 5d e4	 fistp	 DWORD PTR tv776[ebp]
  002cd	0f b6 55 e4	 movzx	 edx, BYTE PTR tv776[ebp]
  002d1	d9 6d ea	 fldcw	 WORD PTR tv781[ebp]

; 18832: 		}
; 18833: 	}

  002d4	e9 07 03 00 00	 jmp	 $LN62@CGRequestP@2
$LN25@CGRequestP@2:

; 18834: 	else if ( lpMsg->InvenType == 3 )	// Target Trade

  002d9	80 f9 03	 cmp	 cl, 3
  002dc	0f 85 31 01 00
	00		 jne	 $LN19@CGRequestP@2

; 18835: 	{
; 18836: 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  002e2	8b 8e 1c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3612]
  002e8	8b d1		 mov	 edx, ecx
  002ea	80 e2 03	 and	 dl, 3
  002ed	80 fa 01	 cmp	 dl, 1
  002f0	0f 82 f5 02 00
	00		 jb	 $LN60@CGRequestP@2
  002f6	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  002fc	83 f9 40	 cmp	 ecx, 64			; 00000040H
  002ff	0f 85 e6 02 00
	00		 jne	 $LN60@CGRequestP@2

; 18837: 		{
; 18838: 			return;
; 18839: 		}
; 18840: 
; 18841: 		int iTargetIndex = gObj[aIndex].TargetNumber;

  00305	0f bf be 58 04
	00 00		 movsx	 edi, WORD PTR [esi+1112]

; 18842: 
; 18843: 		if ( iTargetIndex < 0 )

  0030c	85 ff		 test	 edi, edi
  0030e	0f 88 d7 02 00
	00		 js	 $LN60@CGRequestP@2

; 18844: 		{
; 18845: 			return;
; 18846: 		}
; 18847: 
; 18848: 		if ( !OBJMAX_RANGE(iTargetIndex) )

  00314	33 c9		 xor	 ecx, ecx
  00316	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0031c	0f 9e c1	 setle	 cl
  0031f	85 c9		 test	 ecx, ecx
  00321	0f 84 c4 02 00
	00		 je	 $LN60@CGRequestP@2

; 18849: 		{
; 18850: 			return;
; 18851: 		}
; 18852: 
; 18853: 		if ( gObj[iTargetIndex].m_IfState.use < 1 || gObj[iTargetIndex].m_IfState.type != 1 )

  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0032d	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00333	8b 8c 0f 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+3612]
  0033a	8b d1		 mov	 edx, ecx
  0033c	80 e2 03	 and	 dl, 3
  0033f	80 fa 01	 cmp	 dl, 1
  00342	0f 82 a3 02 00
	00		 jb	 $LN60@CGRequestP@2
  00348	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0034e	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00351	0f 85 94 02 00
	00		 jne	 $LN60@CGRequestP@2

; 18854: 		{
; 18855: 			return;
; 18856: 		}
; 18857: 
; 18858: 		if ( !TRADE_BOX_RANGE(lpMsg->nPos))

  00357	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0035c	3a c8		 cmp	 cl, al
  0035e	1b c9		 sbb	 ecx, ecx
  00360	41		 inc	 ecx
  00361	75 2b		 jne	 SHORT $LN12@CGRequestP@2

; 18859: 		{
; 18860: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d", lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00363	0f b6 d0	 movzx	 edx, al
  00366	52		 push	 edx
  00367	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0036a	50		 push	 eax
  0036b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0036e	56		 push	 esi
  0036f	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00374	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0037a	83 c4 10	 add	 esp, 16			; 00000010H
  0037d	5e		 pop	 esi
  0037e	5f		 pop	 edi
  0037f	5b		 pop	 ebx

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  00380	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00383	33 cd		 xor	 ecx, ebp
  00385	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038a	8b e5		 mov	 esp, ebp
  0038c	5d		 pop	 ebp
  0038d	c3		 ret	 0
$LN12@CGRequestP@2:

; 18861: 			return;
; 18862: 		}
; 18863: 
; 18864: 		if ( gObj[iTargetIndex].Trade[lpMsg->nPos].IsItem() )

  0038e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00394	0f b6 c8	 movzx	 ecx, al
  00397	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0039d	03 8c 17 4c 0e
	00 00		 add	 ecx, DWORD PTR [edi+edx+3660]
  003a4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003a9	85 c0		 test	 eax, eax
  003ab	0f 84 3a 02 00
	00		 je	 $LN60@CGRequestP@2

; 18865: 		{
; 18866: 			pMsg.Exp = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Exp;

  003b1	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 18867: 			pMsg.Level = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Level;
; 18868: 			pMsg.Life = (BYTE)gObj[iTargetIndex].Trade[lpMsg->nPos].m_Durability;

  003b5	d9 7d ea	 fnstcw	 WORD PTR tv764[ebp]
  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003be	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  003c4	8b 94 0f 4c 0e
	00 00		 mov	 edx, DWORD PTR [edi+ecx+3660]
  003cb	8b 94 10 c0 00
	00 00		 mov	 edx, DWORD PTR [eax+edx+192]
  003d2	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  003d5	8b 94 0f 4c 0e
	00 00		 mov	 edx, DWORD PTR [edi+ecx+3660]
  003dc	0f b6 94 10 bc
	00 00 00	 movzx	 edx, BYTE PTR [eax+edx+188]
  003e4	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  003e7	8b 8c 0f 4c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+3660]
  003ee	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  003f2	0f b7 45 ea	 movzx	 eax, WORD PTR tv764[ebp]

; 18869: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  003f6	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003f9	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  003fe	89 45 e0	 mov	 DWORD PTR tv760[ebp], eax
  00401	d9 6d e0	 fldcw	 WORD PTR tv760[ebp]
  00404	db 5d e0	 fistp	 DWORD PTR tv758[ebp]
  00407	0f b6 55 e0	 movzx	 edx, BYTE PTR tv758[ebp]
  0040b	d9 6d ea	 fldcw	 WORD PTR tv764[ebp]

; 18870: 		}
; 18871: 	}

  0040e	e9 c6 01 00 00	 jmp	 $LN63@CGRequestP@2
$LN19@CGRequestP@2:

; 18872: 	else if ( lpMsg->InvenType == 4 )	// Chaos

  00413	80 f9 04	 cmp	 cl, 4
  00416	0f 85 ae 00 00
	00		 jne	 $LN9@CGRequestP@2

; 18873: 	{
; 18874: 		if ( !CHAOS_BOX_RANGE(lpMsg->nPos) )

  0041c	b2 1f		 mov	 dl, 31			; 0000001fH
  0041e	3a d0		 cmp	 dl, al
  00420	1b c9		 sbb	 ecx, ecx
  00422	41		 inc	 ecx
  00423	75 2b		 jne	 SHORT $LN8@CGRequestP@2

; 18875: 		{
; 18876: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d",	lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  00425	0f b6 c0	 movzx	 eax, al
  00428	50		 push	 eax
  00429	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0042c	51		 push	 ecx
  0042d	83 c6 6c	 add	 esi, 108		; 0000006cH
  00430	56		 push	 esi
  00431	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00436	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0043c	83 c4 10	 add	 esp, 16			; 00000010H
  0043f	5e		 pop	 esi
  00440	5f		 pop	 edi
  00441	5b		 pop	 ebx

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  00442	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00445	33 cd		 xor	 ecx, ebp
  00447	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0044c	8b e5		 mov	 esp, ebp
  0044e	5d		 pop	 ebp
  0044f	c3		 ret	 0
$LN8@CGRequestP@2:

; 18877: 			return;
; 18878: 		}
; 18879: 
; 18880: 		if ( lpObj->pChaosBox[lpMsg->nPos].IsItem() )

  00450	0f b6 c8	 movzx	 ecx, al
  00453	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00459	03 8e 78 0e 00
	00		 add	 ecx, DWORD PTR [esi+3704]
  0045f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00464	85 c0		 test	 eax, eax
  00466	0f 84 7f 01 00
	00		 je	 $LN60@CGRequestP@2

; 18881: 		{
; 18882: 			pMsg.Exp = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Exp;

  0046c	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]

; 18883: 			pMsg.Level = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Level;
; 18884: 			pMsg.Life = (BYTE)lpObj->pChaosBox[lpMsg->nPos].m_Durability;

  00470	d9 7d ea	 fnstcw	 WORD PTR tv750[ebp]
  00473	8b 96 78 0e 00
	00		 mov	 edx, DWORD PTR [esi+3704]
  00479	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0047f	8b 8c 10 c0 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+192]
  00486	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00489	8b 96 78 0e 00
	00		 mov	 edx, DWORD PTR [esi+3704]
  0048f	8a 8c 10 bc 00
	00 00		 mov	 cl, BYTE PTR [eax+edx+188]
  00496	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  00499	8b 96 78 0e 00
	00		 mov	 edx, DWORD PTR [esi+3704]

; 18885: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0049f	6a 10		 push	 16			; 00000010H
  004a1	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  004a4	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  004a8	0f b7 45 ea	 movzx	 eax, WORD PTR tv750[ebp]
  004ac	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004b1	89 45 e0	 mov	 DWORD PTR tv747[ebp], eax
  004b4	51		 push	 ecx
  004b5	57		 push	 edi
  004b6	d9 6d e0	 fldcw	 WORD PTR tv747[ebp]
  004b9	db 5d e0	 fistp	 DWORD PTR tv744[ebp]
  004bc	8a 45 e0	 mov	 al, BYTE PTR tv744[ebp]
  004bf	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  004c2	d9 6d ea	 fldcw	 WORD PTR tv750[ebp]

; 18886: 		}
; 18887: 	}

  004c5	e9 19 01 00 00	 jmp	 $LN61@CGRequestP@2
$LN9@CGRequestP@2:

; 18888: 	else if ( lpMsg->InvenType == 5 )	// Personal Shop

  004ca	80 f9 05	 cmp	 cl, 5
  004cd	0f 85 18 01 00
	00		 jne	 $LN60@CGRequestP@2

; 18889: 	{
; 18890: 		if ( !INVENTORY_RANGE(lpMsg->nPos) )

  004d3	b2 eb		 mov	 dl, 235			; 000000ebH
  004d5	3a d0		 cmp	 dl, al
  004d7	1b c9		 sbb	 ecx, ecx
  004d9	41		 inc	 ecx
  004da	75 2b		 jne	 SHORT $LN4@CGRequestP@2
$LN64@CGRequestP@2:

; 18891: 		{
; 18892: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d", lpObj->AccountID, lpObj->Name, lpMsg->nPos);

  004dc	0f b6 c0	 movzx	 eax, al
  004df	50		 push	 eax
  004e0	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  004e3	51		 push	 ecx
  004e4	83 c6 6c	 add	 esi, 108		; 0000006cH
  004e7	56		 push	 esi
  004e8	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  004ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004f3	83 c4 10	 add	 esp, 16			; 00000010H
  004f6	5e		 pop	 esi
  004f7	5f		 pop	 edi
  004f8	5b		 pop	 ebx

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  004f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004fc	33 cd		 xor	 ecx, ebp
  004fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00503	8b e5		 mov	 esp, ebp
  00505	5d		 pop	 ebp
  00506	c3		 ret	 0
$LN4@CGRequestP@2:

; 18893: 			return;
; 18894: 		}
; 18895: 
; 18896: 		if ( lpObj->m_iPShopDealerIndex != -1 )

  00507	8b 96 f0 0e 00
	00		 mov	 edx, DWORD PTR [esi+3824]
  0050d	83 fa ff	 cmp	 edx, -1
  00510	0f 84 d5 00 00
	00		 je	 $LN60@CGRequestP@2

; 18897: 		{
; 18898: 			if ( OBJMAX_RANGE(lpObj->m_iPShopDealerIndex))

  00516	85 d2		 test	 edx, edx
  00518	0f 88 cd 00 00
	00		 js	 $LN60@CGRequestP@2
  0051e	33 c9		 xor	 ecx, ecx
  00520	81 fa 97 3a 00
	00		 cmp	 edx, 14999		; 00003a97H
  00526	0f 9e c1	 setle	 cl
  00529	85 c9		 test	 ecx, ecx
  0052b	0f 84 ba 00 00
	00		 je	 $LN60@CGRequestP@2

; 18899: 			{
; 18900: 				if ( gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].IsItem() )

  00531	0f b6 c8	 movzx	 ecx, al
  00534	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0053a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0053f	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00545	03 8c 02 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+eax+3620]
  0054c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00551	85 c0		 test	 eax, eax
  00553	0f 84 92 00 00
	00		 je	 $LN60@CGRequestP@2

; 18901: 				{
; 18902: 					pMsg.Exp = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Exp;

  00559	8b 96 f0 0e 00
	00		 mov	 edx, DWORD PTR [esi+3824]

; 18903: 					pMsg.Level = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Level;
; 18904: 					pMsg.Life = (BYTE)gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_Durability;

  0055f	d9 7d ea	 fnstcw	 WORD PTR tv726[ebp]
  00562	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00566	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0056c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00572	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00578	8b 94 0a 24 0e
	00 00		 mov	 edx, DWORD PTR [edx+ecx+3620]
  0057f	8b 94 02 c0 00
	00 00		 mov	 edx, DWORD PTR [edx+eax+192]
  00586	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00589	8b 96 f0 0e 00
	00		 mov	 edx, DWORD PTR [esi+3824]
  0058f	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00595	8b 94 0a 24 0e
	00 00		 mov	 edx, DWORD PTR [edx+ecx+3620]
  0059c	0f b6 94 02 bc
	00 00 00	 movzx	 edx, BYTE PTR [edx+eax+188]
  005a4	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  005a7	8b 96 f0 0e 00
	00		 mov	 edx, DWORD PTR [esi+3824]
  005ad	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  005b3	8b 8c 0a 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+3620]
  005ba	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  005be	0f b7 45 ea	 movzx	 eax, WORD PTR tv726[ebp]
  005c2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  005c7	89 45 e0	 mov	 DWORD PTR tv723[ebp], eax

; 18905: 					DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  005ca	8b cf		 mov	 ecx, edi
  005cc	d9 6d e0	 fldcw	 WORD PTR tv723[ebp]
  005cf	db 5d e0	 fistp	 DWORD PTR tv721[ebp]
  005d2	0f b6 55 e0	 movzx	 edx, BYTE PTR tv721[ebp]
  005d6	d9 6d ea	 fldcw	 WORD PTR tv726[ebp]
$LN63@CGRequestP@2:
  005d9	6a 10		 push	 16			; 00000010H
  005db	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  005de	50		 push	 eax
  005df	51		 push	 ecx
$LN62@CGRequestP@2:

; 18903: 					pMsg.Level = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Level;
; 18904: 					pMsg.Life = (BYTE)gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_Durability;

  005e0	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+12], dl
$LN61@CGRequestP@2:

; 18905: 					DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  005e3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@CGRequestP@2:
  005eb	5e		 pop	 esi
$LN1@CGRequestP@2:

; 18906: 				}
; 18907: 			}
; 18908: 		}
; 18909: 	}	
; 18910: }

  005ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ef	5f		 pop	 edi
  005f0	33 cd		 xor	 ecx, ebp
  005f2	5b		 pop	 ebx
  005f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f8	8b e5		 mov	 esp, ebp
  005fa	5d		 pop	 ebp
  005fb	c3		 ret	 0
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ENDP ; CGRequestPetItemInfo
_TEXT	ENDS
PUBLIC	??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ; GCGuildViewportInfo
EXTRN	?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z:PROC	; TUnion::SearchUnion
EXTRN	?UnionManager@@3VTUnion@@A:BYTE			; UnionManager
EXTRN	?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z:PROC ; CGuildClass::SearchGuild_Number
;	COMDAT ??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@
CONST	SEGMENT
??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0d9H, ' ', 0b1H, 0e6H, 0b5H, 0e5H, ' ', 0c1H
	DB	0a4H, 0baH, 0b8H, ' ', 0c3H, 0a3H, 0c0H, 0bbH, 0bcH, 0f6H, ' ', 0beH
	DB	0f8H, 0c0H, 0bdH, '. ', 0c0H, 0ccH, 0b8H, 0a7H, ' : [%s] ', 0b9H
	DB	0f8H, 0c8H, 0a3H, ' : %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -68					; size = 4
_pMsg$251230 = -64					; size = 60
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z PROC ; GCGuildViewportInfo, COMDAT

; 18913: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 18914: 	if ( !gObjIsConnectedGP(aIndex))

  00018	56		 push	 esi

; 18954: 	}
; 18955: 	else
; 18956: 	{
; 18957: 		LogAddTD("    .  : [%s]  : %d", lpObj->Name, dwGuildNumber);

  00019	89 75 bc	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN6@GCGuildVie@3

; 18915: 	{
; 18916: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00028	68 e4 49 00 00	 push	 18916			; 000049e4H
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 18958: 	}
; 18959: }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN6@GCGuildVie@3:

; 18917: 		return;
; 18918: 	}
; 18919: 
; 18920: 	if ( !OBJMAX_RANGE(aIndex))

  00050	85 f6		 test	 esi, esi
  00052	0f 88 cd 00 00
	00		 js	 $LN1@GCGuildVie@3
  00058	33 c0		 xor	 eax, eax
  0005a	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00060	0f 9e c0	 setle	 al
  00063	85 c0		 test	 eax, eax
  00065	0f 84 ba 00 00
	00		 je	 $LN1@GCGuildVie@3

; 18921: 	{
; 18922: 		return;
; 18923: 	}
; 18924: 
; 18925: 	LPOBJ lpObj = &gObj[aIndex];

  0006b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00071	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00077	53		 push	 ebx

; 18926: 	DWORD dwGuildNumber = aRecv->GuildNumber;

  00078	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]

; 18927: 	_GUILD_INFO_STRUCT * lpGuildInfo = Guild.SearchGuild_Number(dwGuildNumber);

  0007b	53		 push	 ebx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00081	e8 00 00 00 00	 call	 ?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z ; CGuildClass::SearchGuild_Number
  00086	8b f8		 mov	 edi, eax

; 18928: 
; 18929: 	if ( lpGuildInfo )

  00088	85 ff		 test	 edi, edi
  0008a	0f 84 81 00 00
	00		 je	 $LN4@GCGuildVie@3

; 18930: 	{
; 18931: 		PMSG_ANS_GUILDVIEWPORT pMsg;
; 18932: 
; 18933: 		pMsg.h.c = 0xC1;
; 18934: 		pMsg.h.headcode = 0x66;
; 18935: 		pMsg.h.size = sizeof(pMsg);
; 18936: 		pMsg.GuildNumber = lpGuildInfo->Number;
; 18937: 		pMsg.btGuildType = lpGuildInfo->btGuildType;

  00090	8a 8f 18 07 00
	00		 mov	 cl, BYTE PTR [edi+1816]

; 18938: 
; 18939: 		TUnionInfo * pUnionInfo = UnionManager.SearchUnion(lpGuildInfo->iGuildUnion);

  00096	8b 97 1c 07 00
	00		 mov	 edx, DWORD PTR [edi+1820]
  0009c	8b 07		 mov	 eax, DWORD PTR [edi]
  0009e	88 4d c8	 mov	 BYTE PTR _pMsg$251230[ebp+8], cl
  000a1	52		 push	 edx
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  000a7	c6 45 c0 c1	 mov	 BYTE PTR _pMsg$251230[ebp], 193 ; 000000c1H
  000ab	66 c7 45 c1 3c
	66		 mov	 WORD PTR _pMsg$251230[ebp+1], 26172 ; 0000663cH
  000b1	89 45 c4	 mov	 DWORD PTR _pMsg$251230[ebp+4], eax
  000b4	e8 00 00 00 00	 call	 ?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z ; TUnion::SearchUnion

; 18940: 
; 18941: 		if ( pUnionInfo )

  000b9	85 c0		 test	 eax, eax
  000bb	74 0e		 je	 SHORT $LN3@GCGuildVie@3

; 18942: 		{
; 18943: 			memcpy(pMsg.UnionName, pUnionInfo->m_szMasterGuild, MAX_GUILD_LEN);

  000bd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c0	89 4d c9	 mov	 DWORD PTR _pMsg$251230[ebp+9], ecx
  000c3	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000c6	89 55 cd	 mov	 DWORD PTR _pMsg$251230[ebp+13], edx

; 18944: 		}
; 18945: 		else

  000c9	eb 04		 jmp	 SHORT $LN2@GCGuildVie@3
$LN3@GCGuildVie@3:

; 18946: 		{
; 18947: 			pMsg.UnionName[0] = '\0';

  000cb	c6 45 c9 00	 mov	 BYTE PTR _pMsg$251230[ebp+9], 0
$LN2@GCGuildVie@3:

; 18948: 		}
; 18949: 
; 18950: 		strcpy(pMsg.GuildName, lpGuildInfo->Name);

  000cf	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000d2	8d 55 d1	 lea	 edx, DWORD PTR _pMsg$251230[ebp+17]
  000d5	2b d0		 sub	 edx, eax
$LL11@GCGuildVie@3:
  000d7	8a 08		 mov	 cl, BYTE PTR [eax]
  000d9	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000dc	40		 inc	 eax
  000dd	84 c9		 test	 cl, cl
  000df	75 f6		 jne	 SHORT $LL11@GCGuildVie@3

; 18951: 		memcpy(pMsg.Mark, lpGuildInfo->Mark, sizeof(pMsg.Mark));

  000e1	8d 77 0d	 lea	 esi, DWORD PTR [edi+13]
  000e4	b9 08 00 00 00	 mov	 ecx, 8
  000e9	8d 7d d9	 lea	 edi, DWORD PTR _pMsg$251230[ebp+25]

; 18952: 
; 18953: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000ec	6a 3c		 push	 60			; 0000003cH
  000ee	8d 45 c0	 lea	 eax, DWORD PTR _pMsg$251230[ebp]
  000f1	f3 a5		 rep movsd
  000f3	8b 4d bc	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  000f6	50		 push	 eax
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18954: 	}
; 18955: 	else
; 18956: 	{
; 18957: 		LogAddTD("    .  : [%s]  : %d", lpObj->Name, dwGuildNumber);

  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	5b		 pop	 ebx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi

; 18958: 	}
; 18959: }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN4@GCGuildVie@3:

; 18954: 	}
; 18955: 	else
; 18956: 	{
; 18957: 		LogAddTD("    .  : [%s]  : %d", lpObj->Name, dwGuildNumber);

  00111	53		 push	 ebx
  00112	83 c6 77	 add	 esi, 119		; 00000077H
  00115	56		 push	 esi
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
  00124	5b		 pop	 ebx
$LN1@GCGuildVie@3:

; 18958: 	}
; 18959: }

  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	5f		 pop	 edi
  00129	33 cd		 xor	 ecx, ebp
  0012b	5e		 pop	 esi
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ENDP ; GCGuildViewportInfo
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	_aRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ; CGGuildAssignStatus
EXTRN	?GDGuildReqAssignStatus@@YAXHHPADH@Z:PROC	; GDGuildReqAssignStatus
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z
_TEXT	SEGMENT
tv389 = -52						; size = 4
_szTargetName$ = -48					; size = 11
_aRecv$GSCopy$ = -36					; size = 4
_aIndex$GSCopy$ = -32					; size = 4
_iSubMasterCount$251257 = -28				; size = 4
tv392 = -21						; size = 1
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z PROC ; CGGuildAssignStatus, COMDAT

; 18962: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 18963: 	if ( !gObjIsConnectedGP(aIndex))

  00018	53		 push	 ebx

; 19043: 		{
; 19044: 			if ( iBattleMasterCount < (((lpObj->Level+lpObj->MLevel) / 200 ) +1) )

  00019	89 7d dc	 mov	 DWORD PTR _aRecv$GSCopy$[ebp], edi
  0001c	89 5d e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001f	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN25@CGGuildAss

; 18964: 	{
; 18965: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  0002b	68 15 4a 00 00	 push	 18965			; 00004a15H
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx

; 19068: 	}
; 19069: }

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	33 cd		 xor	 ecx, ebp
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN25@CGGuildAss:

; 18966: 		return;
; 18967: 	}
; 18968: 
; 18969: 	if ( !OBJMAX_RANGE(aIndex))

  00053	85 db		 test	 ebx, ebx
  00055	0f 88 a4 02 00
	00		 js	 $LN1@CGGuildAss
  0005b	33 c0		 xor	 eax, eax
  0005d	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00063	0f 9e c0	 setle	 al
  00066	85 c0		 test	 eax, eax
  00068	0f 84 91 02 00
	00		 je	 $LN1@CGGuildAss

; 18970: 	{
; 18971: 		return;
; 18972: 	}
; 18973: 
; 18974: 	LPOBJ lpObj = &gObj[aIndex];
; 18975: 	PMSG_GUILD_ASSIGN_STATUS_RESULT pMsg={0};
; 18976: 	
; 18977: 	pMsg.h.set((LPBYTE)&pMsg, 0xE1, sizeof(pMsg));
; 18978: 	pMsg.btType = aRecv->btType;
; 18979: 	memcpy(pMsg.szTagetName, aRecv->szTagetName, sizeof(pMsg.szTagetName));

  0006e	8b 4f 09	 mov	 ecx, DWORD PTR [edi+9]
  00071	33 c0		 xor	 eax, eax
  00073	8b d3		 mov	 edx, ebx
  00075	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00078	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  0007e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00084	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  00087	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+9], eax
  0008a	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax
  0008e	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00091	83 c7 05	 add	 edi, 5
  00094	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00097	88 45 eb	 mov	 BYTE PTR tv392[ebp], al
  0009a	8b 07		 mov	 eax, DWORD PTR [edi]
  0009c	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  0009f	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  000a3	66 c7 45 ec c1
	0f		 mov	 WORD PTR _pMsg$[ebp], 4033 ; 00000fc1H
  000a9	c6 45 ee e1	 mov	 BYTE PTR _pMsg$[ebp+2], 225 ; 000000e1H
  000ad	89 4d f5	 mov	 DWORD PTR _pMsg$[ebp+9], ecx
  000b0	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax

; 18980: 
; 18981: 	if ( lpObj->GuildNumber <= 0 || lpObj->lpGuild == NULL )

  000b4	83 ba 34 04 00
	00 00		 cmp	 DWORD PTR [edx+1076], 0
  000bb	56		 push	 esi
  000bc	89 55 cc	 mov	 DWORD PTR tv389[ebp], edx
  000bf	0f 8e 26 02 00
	00		 jle	 $LN22@CGGuildAss
  000c5	8b b2 38 04 00
	00		 mov	 esi, DWORD PTR [edx+1080]
  000cb	85 f6		 test	 esi, esi
  000cd	0f 84 18 02 00
	00		 je	 $LN22@CGGuildAss

; 18985: 		return;
; 18986: 	}
; 18987: 
; 18988: 	if ( gObj[aIndex].GuildStatus != G_MASTER )

  000d3	81 ba 48 04 00
	00 80 00 00 00	 cmp	 DWORD PTR [edx+1096], 128 ; 00000080H
  000dd	74 0f		 je	 SHORT $LN21@CGGuildAss
$LN56@CGGuildAss:

; 18989: 	{
; 18990: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 18991: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000df	6a 0f		 push	 15			; 0000000fH
  000e1	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000e4	c6 45 f0 11	 mov	 BYTE PTR _pMsg$[ebp+4], 17 ; 00000011H
  000e8	51		 push	 ecx

; 18992: 		return;

  000e9	e9 07 02 00 00	 jmp	 $LN54@CGGuildAss
$LN21@CGGuildAss:

; 18993: 	}
; 18994: 
; 18995: 	char szTargetName[MAX_ACCOUNT_LEN+1]={0};

  000ee	33 c0		 xor	 eax, eax
  000f0	89 45 d1	 mov	 DWORD PTR _szTargetName$[ebp+1], eax
  000f3	89 45 d5	 mov	 DWORD PTR _szTargetName$[ebp+5], eax
  000f6	66 89 45 d9	 mov	 WORD PTR _szTargetName$[ebp+9], ax

; 18996: 	memcpy(szTargetName, aRecv->szTagetName, MAX_ACCOUNT_LEN);

  000fa	8b 07		 mov	 eax, DWORD PTR [edi]
  000fc	89 45 d0	 mov	 DWORD PTR _szTargetName$[ebp], eax
  000ff	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  00103	89 4d d4	 mov	 DWORD PTR _szTargetName$[ebp+4], ecx
  00106	66 89 45 d8	 mov	 WORD PTR _szTargetName$[ebp+8], ax

; 18997: 
; 18998: 	if ( !strcmp(gObj[aIndex].Name, szTargetName))

  0010a	8d 4d d0	 lea	 ecx, DWORD PTR _szTargetName$[ebp]
  0010d	8d 42 77	 lea	 eax, DWORD PTR [edx+119]
$LL43@CGGuildAss:
  00110	8a 10		 mov	 dl, BYTE PTR [eax]
  00112	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00114	75 1a		 jne	 SHORT $LN44@CGGuildAss
  00116	84 d2		 test	 dl, dl
  00118	74 12		 je	 SHORT $LN45@CGGuildAss
  0011a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0011d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00120	75 0e		 jne	 SHORT $LN44@CGGuildAss
  00122	83 c0 02	 add	 eax, 2
  00125	83 c1 02	 add	 ecx, 2
  00128	84 d2		 test	 dl, dl
  0012a	75 e4		 jne	 SHORT $LL43@CGGuildAss
$LN45@CGGuildAss:
  0012c	33 c0		 xor	 eax, eax
  0012e	eb 05		 jmp	 SHORT $LN46@CGGuildAss
$LN44@CGGuildAss:
  00130	1b c0		 sbb	 eax, eax
  00132	83 d8 ff	 sbb	 eax, -1
$LN46@CGGuildAss:
  00135	85 c0		 test	 eax, eax

; 18999: 	{
; 19000: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 19001: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 19002: 		return;

  00137	74 a6		 je	 SHORT $LN56@CGGuildAss

; 19003: 	}
; 19004: 
; 19005: 	if ( lpObj->lpGuild == NULL )
; 19006: 	{
; 19007: 		return;
; 19008: 	}
; 19009: 
; 19010: 	if ( aRecv->btType == 1 || aRecv->btType == 2 )

  00139	8a 45 eb	 mov	 al, BYTE PTR tv392[ebp]
  0013c	3c 01		 cmp	 al, 1
  0013e	74 31		 je	 SHORT $LN17@CGGuildAss
  00140	3c 02		 cmp	 al, 2
  00142	74 2d		 je	 SHORT $LN17@CGGuildAss

; 19057: 			return;
; 19058: 		}
; 19059: 		else
; 19060: 		{
; 19061: 			return;
; 19062: 		}
; 19063: 	}
; 19064: 	
; 19065: 	if ( aRecv->btType == 3 )

  00144	3c 03		 cmp	 al, 3
  00146	0f 85 b2 01 00
	00		 jne	 $LN53@CGGuildAss

; 19066: 	{
; 19067: 		GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  0014c	8b 55 dc	 mov	 edx, DWORD PTR _aRecv$GSCopy$[ebp]
  0014f	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00153	50		 push	 eax
  00154	57		 push	 edi
  00155	6a 03		 push	 3
  00157	53		 push	 ebx
  00158	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  0015d	83 c4 10	 add	 esp, 16			; 00000010H
  00160	5e		 pop	 esi
  00161	5f		 pop	 edi
  00162	5b		 pop	 ebx

; 19068: 	}
; 19069: }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN17@CGGuildAss:

; 19013: 		int iBattleMasterCount = 0;

  00171	33 db		 xor	 ebx, ebx
  00173	8d 96 41 04 00
	00		 lea	 edx, DWORD PTR [esi+1089]
  00179	8d 8e dc 05 00
	00		 lea	 ecx, DWORD PTR [esi+1500]
  0017f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iSubMasterCount$251257[ebp], 0
  00186	8d 73 10	 lea	 esi, DWORD PTR [ebx+16]
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL16@CGGuildAss:

; 19016: 		{
; 19017: 			if ( lpObj->lpGuild->Use[n] > 0 )

  00190	80 7a ff 00	 cmp	 BYTE PTR [edx-1], 0
  00194	76 13		 jbe	 SHORT $LN15@CGGuildAss

; 19018: 			{
; 19019: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  00196	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00199	83 f8 40	 cmp	 eax, 64			; 00000040H
  0019c	75 05		 jne	 SHORT $LN12@CGGuildAss

; 19020: 				{
; 19021: 					iSubMasterCount++;

  0019e	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$251257[ebp]
  001a1	eb 06		 jmp	 SHORT $LN15@CGGuildAss
$LN12@CGGuildAss:

; 19022: 				}
; 19023: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001a3	83 f8 20	 cmp	 eax, 32			; 00000020H
  001a6	75 01		 jne	 SHORT $LN15@CGGuildAss

; 19024: 				{
; 19025: 					iBattleMasterCount++;

  001a8	43		 inc	 ebx
$LN15@CGGuildAss:

; 19016: 		{
; 19017: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001a9	80 3a 00	 cmp	 BYTE PTR [edx], 0
  001ac	76 12		 jbe	 SHORT $LN49@CGGuildAss

; 19018: 			{
; 19019: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  001b3	75 05		 jne	 SHORT $LN35@CGGuildAss

; 19020: 				{
; 19021: 					iSubMasterCount++;

  001b5	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$251257[ebp]
  001b8	eb 06		 jmp	 SHORT $LN49@CGGuildAss
$LN35@CGGuildAss:

; 19022: 				}
; 19023: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001ba	83 f8 20	 cmp	 eax, 32			; 00000020H
  001bd	75 01		 jne	 SHORT $LN49@CGGuildAss

; 19024: 				{
; 19025: 					iBattleMasterCount++;

  001bf	43		 inc	 ebx
$LN49@CGGuildAss:

; 19016: 		{
; 19017: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001c0	80 7a 01 00	 cmp	 BYTE PTR [edx+1], 0
  001c4	76 13		 jbe	 SHORT $LN50@CGGuildAss

; 19018: 			{
; 19019: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001c6	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001c9	83 f8 40	 cmp	 eax, 64			; 00000040H
  001cc	75 05		 jne	 SHORT $LN37@CGGuildAss

; 19020: 				{
; 19021: 					iSubMasterCount++;

  001ce	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$251257[ebp]
  001d1	eb 06		 jmp	 SHORT $LN50@CGGuildAss
$LN37@CGGuildAss:

; 19022: 				}
; 19023: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001d3	83 f8 20	 cmp	 eax, 32			; 00000020H
  001d6	75 01		 jne	 SHORT $LN50@CGGuildAss

; 19024: 				{
; 19025: 					iBattleMasterCount++;

  001d8	43		 inc	 ebx
$LN50@CGGuildAss:

; 19016: 		{
; 19017: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001d9	80 7a 02 00	 cmp	 BYTE PTR [edx+2], 0
  001dd	76 13		 jbe	 SHORT $LN51@CGGuildAss

; 19018: 			{
; 19019: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001e2	83 f8 40	 cmp	 eax, 64			; 00000040H
  001e5	75 05		 jne	 SHORT $LN39@CGGuildAss

; 19020: 				{
; 19021: 					iSubMasterCount++;

  001e7	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$251257[ebp]
  001ea	eb 06		 jmp	 SHORT $LN51@CGGuildAss
$LN39@CGGuildAss:

; 19022: 				}
; 19023: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  001ec	83 f8 20	 cmp	 eax, 32			; 00000020H
  001ef	75 01		 jne	 SHORT $LN51@CGGuildAss

; 19024: 				{
; 19025: 					iBattleMasterCount++;

  001f1	43		 inc	 ebx
$LN51@CGGuildAss:

; 19016: 		{
; 19017: 			if ( lpObj->lpGuild->Use[n] > 0 )

  001f2	80 7a 03 00	 cmp	 BYTE PTR [edx+3], 0
  001f6	76 13		 jbe	 SHORT $LN52@CGGuildAss

; 19018: 			{
; 19019: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  001f8	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001fb	83 f8 40	 cmp	 eax, 64			; 00000040H
  001fe	75 05		 jne	 SHORT $LN41@CGGuildAss

; 19020: 				{
; 19021: 					iSubMasterCount++;

  00200	ff 45 e4	 inc	 DWORD PTR _iSubMasterCount$251257[ebp]
  00203	eb 06		 jmp	 SHORT $LN52@CGGuildAss
$LN41@CGGuildAss:

; 19022: 				}
; 19023: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  00205	83 f8 20	 cmp	 eax, 32			; 00000020H
  00208	75 01		 jne	 SHORT $LN52@CGGuildAss

; 19024: 				{
; 19025: 					iBattleMasterCount++;

  0020a	43		 inc	 ebx
$LN52@CGGuildAss:

; 19011: 	{
; 19012: 		int iSubMasterCount = 0;

  0020b	83 c1 14	 add	 ecx, 20			; 00000014H
  0020e	83 c2 05	 add	 edx, 5

; 19014: 
; 19015: 		for ( int n=0;n<MAX_USER_GUILD;n++)

  00211	4e		 dec	 esi
  00212	0f 85 78 ff ff
	ff		 jne	 $LL16@CGGuildAss

; 19026: 				}
; 19027: 			}
; 19028: 		}
; 19029: 
; 19030: 		if ( aRecv->btGuildStatus == G_SUB_MASTER )

  00218	8b 4d dc	 mov	 ecx, DWORD PTR _aRecv$GSCopy$[ebp]
  0021b	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0021e	3c 40		 cmp	 al, 64			; 00000040H
  00220	75 3d		 jne	 SHORT $LN9@CGGuildAss

; 19031: 		{
; 19032: 			if ( iSubMasterCount == 0 )

  00222	39 75 e4	 cmp	 DWORD PTR _iSubMasterCount$251257[ebp], esi
  00225	75 25		 jne	 SHORT $LN8@CGGuildAss

; 19033: 			{
; 19034: 				GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  00227	0f b6 55 eb	 movzx	 edx, BYTE PTR tv392[ebp]
  0022b	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0022e	6a 40		 push	 64			; 00000040H
  00230	57		 push	 edi
  00231	52		 push	 edx
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  00238	83 c4 10	 add	 esp, 16			; 00000010H
  0023b	5e		 pop	 esi
  0023c	5f		 pop	 edi
  0023d	5b		 pop	 ebx

; 19068: 	}
; 19069: }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	33 cd		 xor	 ecx, ebp
  00243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c3		 ret	 0
$LN8@CGGuildAss:

; 19035: 				return;
; 19036: 			}
; 19037: 
; 19038: 			pMsg.btResult = GUILD_ANS_NOTEXIST_EXTRA_STATUS;
; 19039: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0024c	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0024f	6a 0f		 push	 15			; 0000000fH
  00251	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00254	51		 push	 ecx
  00255	c6 45 f0 12	 mov	 BYTE PTR _pMsg$[ebp+4], 18 ; 00000012H
  00259	52		 push	 edx

; 19040: 			return;

  0025a	e9 97 00 00 00	 jmp	 $LN55@CGGuildAss
$LN9@CGGuildAss:

; 19041: 		}
; 19042: 		else if ( aRecv->btGuildStatus == G_BATTLE_MASTER )

  0025f	3c 20		 cmp	 al, 32			; 00000020H
  00261	75 5f		 jne	 SHORT $LN6@CGGuildAss

; 19043: 		{
; 19044: 			if ( iBattleMasterCount < (((lpObj->Level+lpObj->MLevel) / 200 ) +1) )

  00263	8b 45 cc	 mov	 eax, DWORD PTR tv389[ebp]
  00266	0f bf 88 d0 00
	00 00		 movsx	 ecx, WORD PTR [eax+208]
  0026d	0f bf 80 be 00
	00 00		 movsx	 eax, WORD PTR [eax+190]
  00274	03 c8		 add	 ecx, eax
  00276	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0027b	f7 e9		 imul	 ecx
  0027d	c1 fa 06	 sar	 edx, 6
  00280	8b ca		 mov	 ecx, edx
  00282	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00285	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  00289	3b da		 cmp	 ebx, edx
  0028b	7d 25		 jge	 SHORT $LN5@CGGuildAss

; 19045: 			{
; 19046: 				GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  0028d	0f b6 45 eb	 movzx	 eax, BYTE PTR tv392[ebp]
  00291	8b 4d e0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00294	6a 20		 push	 32			; 00000020H
  00296	57		 push	 edi
  00297	50		 push	 eax
  00298	51		 push	 ecx
  00299	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  0029e	83 c4 10	 add	 esp, 16			; 00000010H
  002a1	5e		 pop	 esi
  002a2	5f		 pop	 edi
  002a3	5b		 pop	 ebx

; 19068: 	}
; 19069: }

  002a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a7	33 cd		 xor	 ecx, ebp
  002a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ae	8b e5		 mov	 esp, ebp
  002b0	5d		 pop	 ebp
  002b1	c3		 ret	 0
$LN5@CGGuildAss:

; 19047: 				return;
; 19048: 			}
; 19049: 
; 19050: 			pMsg.btResult = GUILD_ANS_NOTEXIST_EXTRA_STATUS;
; 19051: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002b2	8b 45 e0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  002b5	6a 0f		 push	 15			; 0000000fH
  002b7	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002ba	52		 push	 edx
  002bb	c6 45 f0 12	 mov	 BYTE PTR _pMsg$[ebp+4], 18 ; 00000012H
  002bf	50		 push	 eax

; 19052: 			return;

  002c0	eb 34		 jmp	 SHORT $LN55@CGGuildAss
$LN6@CGGuildAss:

; 19053: 		}
; 19054: 		else if ( aRecv->btGuildStatus == G_PERSON )

  002c2	84 c0		 test	 al, al
  002c4	75 38		 jne	 SHORT $LN53@CGGuildAss

; 19055: 		{
; 19056: 			GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  002c6	0f b6 4d eb	 movzx	 ecx, BYTE PTR tv392[ebp]
  002ca	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002cd	6a 00		 push	 0
  002cf	57		 push	 edi
  002d0	51		 push	 ecx
  002d1	52		 push	 edx
  002d2	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  002d7	83 c4 10	 add	 esp, 16			; 00000010H
  002da	5e		 pop	 esi
  002db	5f		 pop	 edi
  002dc	5b		 pop	 ebx

; 19068: 	}
; 19069: }

  002dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e0	33 cd		 xor	 ecx, ebp
  002e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e7	8b e5		 mov	 esp, ebp
  002e9	5d		 pop	 ebp
  002ea	c3		 ret	 0
$LN22@CGGuildAss:

; 18982: 	{
; 18983: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 18984: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002eb	6a 0f		 push	 15			; 0000000fH
  002ed	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002f0	c6 45 f0 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H
  002f4	50		 push	 eax
$LN54@CGGuildAss:
  002f5	53		 push	 ebx
$LN55@CGGuildAss:
  002f6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002fb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN53@CGGuildAss:
  002fe	5e		 pop	 esi
$LN1@CGGuildAss:

; 19068: 	}
; 19069: }

  002ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00302	5f		 pop	 edi
  00303	33 cd		 xor	 ecx, ebp
  00305	5b		 pop	 ebx
  00306	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030b	8b e5		 mov	 esp, ebp
  0030d	5d		 pop	 ebp
  0030e	c3		 ret	 0
?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ENDP ; CGGuildAssignStatus
_TEXT	ENDS
PUBLIC	?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ; CGGuildAssignType
EXTRN	?GDGuildReqAssignType@@YAXHH@Z:PROC		; GDGuildReqAssignType
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z PROC ; CGGuildAssignType, COMDAT

; 19072: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 19073: 	if ( !gObjIsConnectedGP(aIndex))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	75 1d		 jne	 SHORT $LN5@CGGuildAss@2

; 19074: 	{
; 19075: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00017	68 83 4a 00 00	 push	 19075			; 00004a83H
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 19091: 	{
; 19092: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 19093: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	5e		 pop	 esi

; 19105: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN5@CGGuildAss@2:

; 19076: 		return;
; 19077: 	}
; 19078: 
; 19079: 	if ( !OBJMAX_RANGE(aIndex))

  00034	85 f6		 test	 esi, esi
  00036	0f 88 98 00 00
	00		 js	 $LN6@CGGuildAss@2
  0003c	33 c0		 xor	 eax, eax
  0003e	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00044	0f 9e c0	 setle	 al
  00047	85 c0		 test	 eax, eax
  00049	0f 84 85 00 00
	00		 je	 $LN6@CGGuildAss@2

; 19080: 	{
; 19081: 		return;
; 19082: 	}
; 19083: 
; 19084: 	LPOBJ lpObj = &gObj[aIndex];

  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19085: 	PMSG_GUILD_ASSIGN_TYPE_RESULT pMsg={0};
; 19086: 	
; 19087: 	pMsg.h.set((LPBYTE)&pMsg, 0xE2, sizeof(pMsg));
; 19088: 	pMsg.btGuildType = aRecv->btGuildType;

  00055	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00058	8b c6		 mov	 eax, esi
  0005a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00060	03 c1		 add	 eax, ecx
  00062	8a 4a 03	 mov	 cl, BYTE PTR [edx+3]
  00065	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  0006c	66 c7 45 f8 c1
	05		 mov	 WORD PTR _pMsg$[ebp], 1473 ; 000005c1H
  00072	c6 45 fa e2	 mov	 BYTE PTR _pMsg$[ebp+2], 226 ; 000000e2H
  00076	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 19089: 	
; 19090: 	if ( lpObj->GuildNumber <= 0 || lpObj->lpGuild == NULL )

  00079	83 b8 34 04 00
	00 00		 cmp	 DWORD PTR [eax+1076], 0
  00080	7e 3f		 jle	 SHORT $LN2@CGGuildAss@2
  00082	83 b8 38 04 00
	00 00		 cmp	 DWORD PTR [eax+1080], 0
  00089	74 36		 je	 SHORT $LN2@CGGuildAss@2

; 19094: 		return;
; 19095: 	}
; 19096: 
; 19097: 	if ( gObj[aIndex].GuildStatus != G_MASTER )

  0008b	81 b8 48 04 00
	00 80 00 00 00	 cmp	 DWORD PTR [eax+1096], 128 ; 00000080H
  00095	74 18		 je	 SHORT $LN1@CGGuildAss@2

; 19098: 	{
; 19099: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 19100: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00097	6a 05		 push	 5
  00099	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009c	50		 push	 eax
  0009d	56		 push	 esi
  0009e	c6 45 fc 11	 mov	 BYTE PTR _pMsg$[ebp+4], 17 ; 00000011H
  000a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	5e		 pop	 esi

; 19105: }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN1@CGGuildAss@2:

; 19101: 		return;
; 19102: 	}
; 19103: 	
; 19104: 	GDGuildReqAssignType(aIndex, aRecv->btGuildType);

  000af	0f b6 c9	 movzx	 ecx, cl
  000b2	51		 push	 ecx
  000b3	56		 push	 esi
  000b4	e8 00 00 00 00	 call	 ?GDGuildReqAssignType@@YAXHH@Z ; GDGuildReqAssignType
  000b9	83 c4 08	 add	 esp, 8
  000bc	5e		 pop	 esi

; 19105: }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN2@CGGuildAss@2:

; 19091: 	{
; 19092: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 19093: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000c1	6a 05		 push	 5
  000c3	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000c6	52		 push	 edx
  000c7	56		 push	 esi
  000c8	c6 45 fc 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H
  000cc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGGuildAss@2:
  000d4	5e		 pop	 esi

; 19105: }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ENDP ; CGGuildAssignType
_TEXT	ENDS
PUBLIC	??_C@_0FM@KKODDGLK@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@ ; `string'
PUBLIC	??_C@_0FP@NEGBFKID@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@ ; `string'
PUBLIC	??_C@_0EH@IIMOLMPO@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@ ; `string'
PUBLIC	?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ; CGRelationShipReqJoinBreakOff
EXTRN	?GDUnionBreakOff@@YAXHH@Z:PROC			; GDUnionBreakOff
EXTRN	?GetGuildRelationShipCount@TUnion@@QAEHHH@Z:PROC ; TUnion::GetGuildRelationShipCount
EXTRN	?AllianceMinPlayers@@3HA:DWORD			; AllianceMinPlayers
EXTRN	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjGetRelationShip
;	COMDAT ??_C@_0FM@KKODDGLK@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@
; File e:\work\tranet_version\gs\gameserver\castlesiegesync.h
CONST	SEGMENT
??_C@_0FM@KKODDGLK@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@ DB '['
	DB	'GensSystem] [%s][%s] Union Joining Failed to Gens be Differen'
	DB	't : UnionMaster [%s][%s] [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@NEGBFKID@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@
CONST	SEGMENT
??_C@_0FP@NEGBFKID@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@ DB '['
	DB	'GensSystem] [%s][%s] Union Joining Failed to Not Join Gens Gu'
	DB	'ildMaster : UnionMaster [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@IIMOLMPO@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@
CONST	SEGMENT
??_C@_0EH@IIMOLMPO@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@ DB '['
	DB	'GensSystem] [%s][%s] Union Joining Failed to Not Join Gens Gu'
	DB	'ildMaste', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z
_TEXT	SEGMENT
_szCastleOwnerGuildName$251338 = -40			; size = 9
_ErrMsg$ = -28						; size = 8
_pMsg$ = -20						; size = 7
_iTargetUserIndex$ = -12				; size = 4
_lpGuildInfo$ = -8					; size = 4
_btRelationShip$ = -1					; size = 1
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z PROC ; CGRelationShipReqJoinBreakOff, COMDAT

; 19108: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19109: 	if ( g_CastleSiegeSync.GetCastleState() >= 5 && g_CastleSiegeSync.GetCastleState() <= 7 )

  00003	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4
  00008	83 c0 fb	 add	 eax, -5			; fffffffbH
  0000b	83 ec 28	 sub	 esp, 40			; 00000028H
  0000e	83 f8 02	 cmp	 eax, 2
  00011	77 20		 ja	 SHORT $LN53@CGRelation

; 19110: 	{
; 19111: 		MsgOutput(aIndex, lMsg.Get(MSGGET(6, 196)));

  00013	68 c4 06 00 00	 push	 1732			; 000006c4H
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0001d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00025	50		 push	 eax
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0002c	83 c4 08	 add	 esp, 8

; 19382: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN53@CGRelation:

; 19112: 		return;
; 19113: 	}
; 19114: 
; 19115: 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE ) //season 2.5 add-on

  00033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	53		 push	 ebx
  0003a	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0003d	56		 push	 esi
  0003e	8b f3		 mov	 esi, ebx
  00040	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00046	0f b6 84 16 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+edx+329]
  0004e	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  00051	3c 2d		 cmp	 al, 45			; 0000002dH
  00053	72 28		 jb	 SHORT $LN73@CGRelation
  00055	b2 32		 mov	 dl, 50			; 00000032H
  00057	3a d0		 cmp	 dl, al
  00059	1b c0		 sbb	 eax, eax
  0005b	40		 inc	 eax
  0005c	74 1f		 je	 SHORT $LN73@CGRelation

; 19116: 	{
; 19117: 		MsgOutput(aIndex, lMsg.Get(3399));

  0005e	68 47 0d 00 00	 push	 3399			; 00000d47H
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00068	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0006d	50		 push	 eax
  0006e	53		 push	 ebx
  0006f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00074	83 c4 08	 add	 esp, 8
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx

; 19382: }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN73@CGRelation:

; 19118: 		return;
; 19119: 	}
; 19120: 
; 19121: 	int iTargetUserIndex = MAKE_NUMBERW(aRecv->btTargetUserIndexH, aRecv->btTargetUserIndexL);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00080	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00084	0f b6 40 06	 movzx	 eax, BYTE PTR [eax+6]
  00088	66 c1 e2 08	 shl	 dx, 8
  0008c	57		 push	 edi
  0008d	0f b7 fa	 movzx	 edi, dx
  00090	0b f8		 or	 edi, eax
  00092	89 7d f4	 mov	 DWORD PTR _iTargetUserIndex$[ebp], edi

; 19122: 
; 19123: 	if ( !OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(iTargetUserIndex))

  00095	85 db		 test	 ebx, ebx
  00097	0f 88 47 06 00
	00		 js	 $LN80@CGRelation
  0009d	33 c0		 xor	 eax, eax
  0009f	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  000a5	0f 9e c0	 setle	 al
  000a8	85 c0		 test	 eax, eax
  000aa	0f 84 34 06 00
	00		 je	 $LN80@CGRelation
  000b0	85 ff		 test	 edi, edi
  000b2	0f 88 2c 06 00
	00		 js	 $LN80@CGRelation
  000b8	33 c0		 xor	 eax, eax
  000ba	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  000c0	0f 9e c0	 setle	 al
  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 19 06 00
	00		 je	 $LN80@CGRelation

; 19124: 	{
; 19125: 		return;
; 19126: 	}
; 19127: 
; 19128: 	if ( !PacketCheckTime(&gObj[aIndex]))

  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 08 06 00
	00		 je	 $LN80@CGRelation

; 19129: 	{
; 19130: 		return;
; 19131: 	}
; 19132: 
; 19133: 	if ( gObjIsConnected(&gObj[iTargetUserIndex]) == FALSE )

  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  000e8	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000f1	83 c4 04	 add	 esp, 4
  000f4	85 c0		 test	 eax, eax
  000f6	75 14		 jne	 SHORT $LN48@CGRelation

; 19134: 	{
; 19135: 		GCResultSend(aIndex, 0x51, 3);

  000f8	6a 03		 push	 3

; 19145: 	{
; 19146: 		GCResultSend(aIndex, 0x51, 5);

  000fa	6a 51		 push	 81			; 00000051H
  000fc	53		 push	 ebx
  000fd	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx

; 19382: }

  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN48@CGRelation:

; 19136: 		return;
; 19137: 	}
; 19138: 
; 19139: 	if((gObj[iTargetUserIndex].m_Option&1) != 1) //season 3.0 add-on

  0010c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	f6 84 07 8c 0e
	00 00 01	 test	 BYTE PTR [edi+eax+3724], 1
  00119	0f 84 c5 05 00
	00		 je	 $LN80@CGRelation

; 19140: 	{
; 19141: 		return;
; 19142: 	}
; 19143: 
; 19144: 	if ( !gObj[aIndex].lpGuild || !gObj[iTargetUserIndex].lpGuild )

  0011f	83 bc 06 38 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1080], 0
  00127	0f 84 aa 05 00
	00		 je	 $LN45@CGRelation
  0012d	83 bc 07 38 04
	00 00 00	 cmp	 DWORD PTR [edi+eax+1080], 0
  00135	0f 84 9c 05 00
	00		 je	 $LN45@CGRelation

; 19147: 		return;
; 19148: 	}
; 19149: 
; 19150: 	if ( gObj[aIndex].GuildStatus != G_MASTER && gObj[iTargetUserIndex].GuildStatus != G_MASTER)

  0013b	bb 80 00 00 00	 mov	 ebx, 128		; 00000080H
  00140	39 9c 06 48 04
	00 00		 cmp	 DWORD PTR [esi+eax+1096], ebx
  00147	74 20		 je	 SHORT $LN44@CGRelation
  00149	39 9c 07 48 04
	00 00		 cmp	 DWORD PTR [edi+eax+1096], ebx
  00150	74 17		 je	 SHORT $LN44@CGRelation

; 19151: 	{
; 19152: 		GCResultSend(aIndex, 0x51, 4);

  00152	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00155	6a 04		 push	 4
  00157	6a 51		 push	 81			; 00000051H
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 19382: }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
$LN44@CGRelation:

; 19153: 		return;
; 19154: 	}
; 19155: 
; 19156: 	if ( gObj[aIndex].m_IfState.use > 0 )

  00169	b1 03		 mov	 cl, 3
  0016b	84 8c 06 1c 0e
	00 00		 test	 BYTE PTR [esi+eax+3612], cl
  00172	76 17		 jbe	 SHORT $LN43@CGRelation

; 19157: 	{
; 19158: 		GCResultSend(aIndex, 0x51, 6);

  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00177	6a 06		 push	 6
  00179	6a 51		 push	 81			; 00000051H
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx

; 19382: }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
$LN43@CGRelation:

; 19159: 		return;
; 19160: 	}
; 19161: 
; 19162: 	if ( gObj[iTargetUserIndex].m_IfState.use > 0 )

  0018b	84 8c 07 1c 0e
	00 00		 test	 BYTE PTR [edi+eax+3612], cl
  00192	76 17		 jbe	 SHORT $LN42@CGRelation

; 19163: 	{
; 19164: 		GCResultSend(aIndex, 0x51, 6);

  00194	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00197	6a 06		 push	 6
  00199	6a 51		 push	 81			; 00000051H
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx

; 19382: }

  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c3		 ret	 0
$LN42@CGRelation:

; 19165: 		return;
; 19166: 	}
; 19167: 
; 19168: 
; 19169: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg={0};

  001ab	33 c0		 xor	 eax, eax

; 19170: 
; 19171: 	PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  001ad	6a 08		 push	 8
  001af	89 45 e5	 mov	 DWORD PTR _ErrMsg$[ebp+1], eax
  001b2	66 89 45 e9	 mov	 WORD PTR _ErrMsg$[ebp+5], ax
  001b6	88 45 eb	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  001b9	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  001bc	68 e6 00 00 00	 push	 230			; 000000e6H
  001c1	50		 push	 eax
  001c2	c6 45 e4 00	 mov	 BYTE PTR _ErrMsg$[ebp], 0
  001c6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 19172: 	ErrMsg.btResult = 0;
; 19173: 	ErrMsg.btRequestType = aRecv->btRequestType;

  001cb	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001ce	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]

; 19174: 	ErrMsg.btRelationShipType = aRecv->btRelationShipType;

  001d2	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  001d6	88 4d e8	 mov	 BYTE PTR _ErrMsg$[ebp+4], cl

; 19175: 	ErrMsg.btTargetUserIndexH = aRecv->btTargetUserIndexH;

  001d9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001dd	88 55 e7	 mov	 BYTE PTR _ErrMsg$[ebp+3], dl

; 19176: 	ErrMsg.btTargetUserIndexL = aRecv->btTargetUserIndexL;

  001e0	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]

; 19177: 
; 19178: 	LPOBJ lpObj = &gObj[aIndex];

  001e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e9	03 f0		 add	 esi, eax
  001eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ee	c6 45 e9 00	 mov	 BYTE PTR _ErrMsg$[ebp+5], 0
  001f2	88 4d ea	 mov	 BYTE PTR _ErrMsg$[ebp+6], cl
  001f5	88 55 eb	 mov	 BYTE PTR _ErrMsg$[ebp+7], dl

; 19179: 	LPOBJ lpTargetObj = &gObj[iTargetUserIndex];

  001f8	03 f8		 add	 edi, eax

; 19180: 
; 19181: 	if ( lpObj->GuildStatus != G_MASTER || lpTargetObj->GuildStatus != G_MASTER)

  001fa	39 9e 48 04 00
	00		 cmp	 DWORD PTR [esi+1096], ebx
  00200	0f 85 b1 04 00
	00		 jne	 $LN40@CGRelation
  00206	39 9f 48 04 00
	00		 cmp	 DWORD PTR [edi+1096], ebx
  0020c	0f 85 a5 04 00
	00		 jne	 $LN40@CGRelation

; 19185: 		return;
; 19186: 	}
; 19187: 
; 19188: 	_GUILD_INFO_STRUCT * lpGuildInfo = gObj[aIndex].lpGuild;

  00212	8b 86 38 04 00
	00		 mov	 eax, DWORD PTR [esi+1080]

; 19189: 	_GUILD_INFO_STRUCT * lpTargetGuildInfo = gObj[iTargetUserIndex].lpGuild;

  00218	8b 9f 38 04 00
	00		 mov	 ebx, DWORD PTR [edi+1080]

; 19190: 	BYTE btRelationShip = gObjGetRelationShip(lpObj, lpTargetObj);

  0021e	57		 push	 edi
  0021f	56		 push	 esi
  00220	89 45 f8	 mov	 DWORD PTR _lpGuildInfo$[ebp], eax
  00223	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  00228	83 c4 08	 add	 esp, 8

; 19191: 
; 19192: #if(EVOMU_HOSTILITY_DEL)
; 19193: 	if(g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::Gredy2) || g_ZtLicense.CheckUser(eZtUB::GredyLocal))	

  0022b	6a 20		 push	 32			; 00000020H
  0022d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00232	88 45 ff	 mov	 BYTE PTR _btRelationShip$[ebp], al
  00235	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0023a	84 c0		 test	 al, al
  0023c	75 20		 jne	 SHORT $LN38@CGRelation
  0023e	6a 22		 push	 34			; 00000022H
  00240	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00245	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0024a	84 c0		 test	 al, al
  0024c	75 10		 jne	 SHORT $LN38@CGRelation
  0024e	6a 21		 push	 33			; 00000021H
  00250	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00255	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0025a	84 c0		 test	 al, al
  0025c	74 1a		 je	 SHORT $LN74@CGRelation
$LN38@CGRelation:

; 19194: 	{
; 19195: 		if(!lpGuildInfo)

  0025e	8b 55 f8	 mov	 edx, DWORD PTR _lpGuildInfo$[ebp]
  00261	85 d2		 test	 edx, edx
  00263	0f 84 7b 04 00
	00		 je	 $LN80@CGRelation

; 19196: 		{
; 19197: 			return;
; 19198: 		}
; 19199: 
; 19200: 		if(lpGuildInfo->iGuildRival > 0)

  00269	83 ba 20 07 00
	00 00		 cmp	 DWORD PTR [edx+1824], 0
  00270	0f 8f 6e 04 00
	00		 jg	 $LN80@CGRelation
  00276	eb 03		 jmp	 SHORT $LN36@CGRelation
$LN74@CGRelation:
  00278	8b 55 f8	 mov	 edx, DWORD PTR _lpGuildInfo$[ebp]
$LN36@CGRelation:

; 19201: 		{
; 19202: 			return;
; 19203: 		}
; 19204: 	}
; 19205: #endif	
; 19206: 
; 19207: 	if ( aRecv->btRequestType == 1 )

  0027b	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0027e	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00281	3c 01		 cmp	 al, 1
  00283	0f 85 f2 02 00
	00		 jne	 $LN35@CGRelation

; 19208: 	{
; 19209: 		if ( aRecv->btRelationShipType == 1 )

  00289	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0028c	3c 01		 cmp	 al, 1
  0028e	0f 85 83 02 00
	00		 jne	 $LN34@CGRelation

; 19210: 		{
; 19211: 			if ( AllianceMinPlayers > lpTargetGuildInfo->Count )

  00294	0f b6 4b 2d	 movzx	 ecx, BYTE PTR [ebx+45]
  00298	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?AllianceMinPlayers@@3HA, ecx ; AllianceMinPlayers
  0029e	7e 20		 jle	 SHORT $LN33@CGRelation

; 19212: 			{
; 19213: 				ErrMsg.btResult = GUILD_ANS_CANNOT_BE_UNION_MASTER;

  002a0	c6 45 e9 1d	 mov	 BYTE PTR _ErrMsg$[ebp+5], 29 ; 0000001dH
$LN84@CGRelation:

; 19214: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  002a4	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  002a8	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002ab	52		 push	 edx
  002ac	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  002af	50		 push	 eax
  002b0	51		 push	 ecx
  002b1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b9	5f		 pop	 edi
  002ba	5e		 pop	 esi
  002bb	5b		 pop	 ebx

; 19382: }

  002bc	8b e5		 mov	 esp, ebp
  002be	5d		 pop	 ebp
  002bf	c3		 ret	 0
$LN33@CGRelation:

; 19215: 				return;
; 19216: 			}
; 19217: 
; 19218: 			if ( lpTargetGuildInfo->iGuildUnion != 0 && lpTargetGuildInfo->iGuildUnion == lpTargetGuildInfo->Number )

  002c0	8b 83 1c 07 00
	00		 mov	 eax, DWORD PTR [ebx+1820]
  002c6	85 c0		 test	 eax, eax
  002c8	0f 84 ae 00 00
	00		 je	 $LN29@CGRelation
  002ce	3b 03		 cmp	 eax, DWORD PTR [ebx]
  002d0	0f 85 a6 00 00
	00		 jne	 $LN29@CGRelation

; 19219: 			{
; 19220: 				if(g_ZtLicense.CheckUser(Gredy) || g_ZtLicense.CheckUser(Gredy2) || g_ZtLicense.CheckUser(GredyLocal))

  002d6	6a 20		 push	 32			; 00000020H
  002d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002dd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002e2	84 c0		 test	 al, al
  002e4	75 58		 jne	 SHORT $LN30@CGRelation
  002e6	6a 22		 push	 34			; 00000022H
  002e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002ed	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002f2	84 c0		 test	 al, al
  002f4	75 48		 jne	 SHORT $LN30@CGRelation
  002f6	6a 21		 push	 33			; 00000021H
  002f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002fd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00302	84 c0		 test	 al, al
  00304	75 38		 jne	 SHORT $LN30@CGRelation

; 19226: 						return;
; 19227: 					}
; 19228: 				}
; 19229: 				else
; 19230: 				{
; 19231: 					if ( UnionManager.GetGuildRelationShipCount(lpTargetGuildInfo->iGuildUnion, 1) >= MAX_UNION_MEMBER  )

  00306	8b 93 1c 07 00
	00		 mov	 edx, DWORD PTR [ebx+1820]
  0030c	6a 01		 push	 1
  0030e	52		 push	 edx
  0030f	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  00314	e8 00 00 00 00	 call	 ?GetGuildRelationShipCount@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShipCount
  00319	83 f8 05	 cmp	 eax, 5
  0031c	7c 5b		 jl	 SHORT $LN75@CGRelation

; 19232: 					{
; 19233: 						ErrMsg.btResult = GUILD_ANS_EXCEED_MAX_UNION_MEMBER;
; 19234: 						DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0031e	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00322	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00325	50		 push	 eax
  00326	8d 4d e4	 lea	 ecx, DWORD PTR _ErrMsg$[ebp]
  00329	51		 push	 ecx
  0032a	52		 push	 edx
  0032b	c6 45 e9 1e	 mov	 BYTE PTR _ErrMsg$[ebp+5], 30 ; 0000001eH
  0032f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00334	83 c4 0c	 add	 esp, 12			; 0000000cH
  00337	5f		 pop	 edi
  00338	5e		 pop	 esi
  00339	5b		 pop	 ebx

; 19382: }

  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c3		 ret	 0
$LN30@CGRelation:

; 19221: 				{
; 19222: 					if ( UnionManager.GetGuildRelationShipCount(lpTargetGuildInfo->iGuildUnion, 1) >= ZtConfig.m_iAllianceMaxGuild  )

  0033e	8b 83 1c 07 00
	00		 mov	 eax, DWORD PTR [ebx+1820]
  00344	6a 01		 push	 1
  00346	50		 push	 eax
  00347	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  0034c	e8 00 00 00 00	 call	 ?GetGuildRelationShipCount@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShipCount
  00351	3b 05 a8 0d 00
	00		 cmp	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+3496
  00357	7c 20		 jl	 SHORT $LN75@CGRelation

; 19223: 					{
; 19224: 						ErrMsg.btResult = GUILD_ANS_EXCEED_MAX_UNION_MEMBER;

  00359	c6 45 e9 1e	 mov	 BYTE PTR _ErrMsg$[ebp+5], 30 ; 0000001eH
$LN86@CGRelation:

; 19225: 						DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0035d	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  00361	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00364	51		 push	 ecx
  00365	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00368	52		 push	 edx
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0036f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00372	5f		 pop	 edi
  00373	5e		 pop	 esi
  00374	5b		 pop	 ebx

; 19382: }

  00375	8b e5		 mov	 esp, ebp
  00377	5d		 pop	 ebp
  00378	c3		 ret	 0
$LN75@CGRelation:

; 19221: 				{
; 19222: 					if ( UnionManager.GetGuildRelationShipCount(lpTargetGuildInfo->iGuildUnion, 1) >= ZtConfig.m_iAllianceMaxGuild  )

  00379	8b 55 f8	 mov	 edx, DWORD PTR _lpGuildInfo$[ebp]
$LN29@CGRelation:

; 19235: 						return;
; 19236: 					}
; 19237: 				}
; 19238: 			}
; 19239: 		
; 19240: 			char szCastleOwnerGuildName[MAX_GUILD_LEN+1]={0};
; 19241: 			memcpy(szCastleOwnerGuildName, g_CastleSiegeSync.GetCastleOwnerGuild(), MAX_GUILD_LEN);

  0037c	8b 0d 18 00 00
	00		 mov	 ecx, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+24
  00382	33 c0		 xor	 eax, eax
  00384	89 45 d9	 mov	 DWORD PTR _szCastleOwnerGuildName$251338[ebp+1], eax
  00387	89 45 dd	 mov	 DWORD PTR _szCastleOwnerGuildName$251338[ebp+5], eax
  0038a	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+28
  0038f	89 4d d8	 mov	 DWORD PTR _szCastleOwnerGuildName$251338[ebp], ecx
  00392	89 45 dc	 mov	 DWORD PTR _szCastleOwnerGuildName$251338[ebp+4], eax

; 19242: 
; 19243: 			if ( !strcmp(lpGuildInfo->Name, szCastleOwnerGuildName))

  00395	8d 4d d8	 lea	 ecx, DWORD PTR _szCastleOwnerGuildName$251338[ebp]
  00398	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0039b	eb 03 8d 49 00	 npad	 5
$LL68@CGRelation:
  003a0	8a 10		 mov	 dl, BYTE PTR [eax]
  003a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  003a4	75 1a		 jne	 SHORT $LN69@CGRelation
  003a6	84 d2		 test	 dl, dl
  003a8	74 12		 je	 SHORT $LN70@CGRelation
  003aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  003ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  003b0	75 0e		 jne	 SHORT $LN69@CGRelation
  003b2	83 c0 02	 add	 eax, 2
  003b5	83 c1 02	 add	 ecx, 2
  003b8	84 d2		 test	 dl, dl
  003ba	75 e4		 jne	 SHORT $LL68@CGRelation
$LN70@CGRelation:
  003bc	33 c0		 xor	 eax, eax
  003be	eb 05		 jmp	 SHORT $LN71@CGRelation
$LN69@CGRelation:
  003c0	1b c0		 sbb	 eax, eax
  003c2	83 d8 ff	 sbb	 eax, -1
$LN71@CGRelation:
  003c5	85 c0		 test	 eax, eax
  003c7	75 06		 jne	 SHORT $LN26@CGRelation

; 19244: 			{
; 19245: 				ErrMsg.btResult = GUILD_ANS_EXIST_UNION;

  003c9	c6 45 e9 17	 mov	 BYTE PTR _ErrMsg$[ebp+5], 23 ; 00000017H

; 19246: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 19247: 				return;

  003cd	eb 8e		 jmp	 SHORT $LN86@CGRelation
$LN26@CGRelation:

; 19248: 			}
; 19249: 
; 19250: 			if ( lpGuildInfo->iGuildUnion )

  003cf	8b 4d f8	 mov	 ecx, DWORD PTR _lpGuildInfo$[ebp]
  003d2	83 b9 1c 07 00
	00 00		 cmp	 DWORD PTR [ecx+1820], 0
  003d9	74 09		 je	 SHORT $LN25@CGRelation

; 19251: 			{
; 19252: 				ErrMsg.btResult = GUILD_ANS_EXIST_UNION;

  003db	c6 45 e9 17	 mov	 BYTE PTR _ErrMsg$[ebp+5], 23 ; 00000017H

; 19253: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 19254: 				return;

  003df	e9 c0 fe ff ff	 jmp	 $LN84@CGRelation
$LN25@CGRelation:

; 19255: 			}
; 19256: 
; 19257: 			if ( btRelationShip == 2 )

  003e4	80 7d ff 02	 cmp	 BYTE PTR _btRelationShip$[ebp], 2
  003e8	75 09		 jne	 SHORT $LN24@CGRelation

; 19258: 			{
; 19259: 				ErrMsg.btResult = GUILD_ANS_EXIST_RELATIONSHIP_RIVAL;

  003ea	c6 45 e9 16	 mov	 BYTE PTR _ErrMsg$[ebp+5], 22 ; 00000016H

; 19260: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 19261: 				return;

  003ee	e9 b1 fe ff ff	 jmp	 $LN84@CGRelation
$LN24@CGRelation:

; 19262: 			}
; 19263: 
; 19264: 			if ( lpTargetGuildInfo->iGuildUnion && lpTargetGuildInfo->Number != lpTargetGuildInfo->iGuildUnion )

  003f3	8b 83 1c 07 00
	00		 mov	 eax, DWORD PTR [ebx+1820]
  003f9	85 c0		 test	 eax, eax
  003fb	74 0d		 je	 SHORT $LN23@CGRelation
  003fd	39 03		 cmp	 DWORD PTR [ebx], eax
  003ff	74 09		 je	 SHORT $LN23@CGRelation

; 19265: 			{
; 19266: 				ErrMsg.btResult = GUIDL_ANS_NOT_UNION_MASTER;

  00401	c6 45 e9 1b	 mov	 BYTE PTR _ErrMsg$[ebp+5], 27 ; 0000001bH

; 19267: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 19268: 				return;

  00405	e9 9a fe ff ff	 jmp	 $LN84@CGRelation
$LN23@CGRelation:

; 19269: 			}
; 19270: 
; 19271: 			if(gGENS)

  0040a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  00411	0f 84 dd 01 00
	00		 je	 $LN76@CGRelation

; 19272: 			{
; 19273: 				if( gGensSystem.CheckAllianceEnter )

  00417	80 3d af 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VGensSystem@@A+175, 0
  0041e	0f 84 d0 01 00
	00		 je	 $LN76@CGRelation

; 19274: 				{
; 19275: 					if( !gGensSystem.GetGensInfluence(lpObj) )

  00424	56		 push	 esi
  00425	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  0042a	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  0042f	85 c0		 test	 eax, eax
  00431	75 33		 jne	 SHORT $LN20@CGRelation

; 19276: 					{
; 19277: 						LogAddTD("[GensSystem] [%s][%s] Union Joining Failed to Not Join Gens GuildMaste",
; 19278: 							lpObj->AccountID, lpObj->Name);

  00433	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00436	52		 push	 edx
  00437	83 c6 6c	 add	 esi, 108		; 0000006cH
  0043a	56		 push	 esi
  0043b	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@IIMOLMPO@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 19279: 						// ----
; 19280: 						ErrMsg.btResult = 0xA1;
; 19281: 						DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00446	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  0044a	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0044d	50		 push	 eax
  0044e	8d 4d e4	 lea	 ecx, DWORD PTR _ErrMsg$[ebp]
  00451	51		 push	 ecx
  00452	52		 push	 edx
  00453	c6 45 e9 a1	 mov	 BYTE PTR _ErrMsg$[ebp+5], 161 ; 000000a1H
  00457	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0045c	83 c4 18	 add	 esp, 24			; 00000018H
  0045f	5f		 pop	 edi
  00460	5e		 pop	 esi
  00461	5b		 pop	 ebx

; 19382: }

  00462	8b e5		 mov	 esp, ebp
  00464	5d		 pop	 ebp
  00465	c3		 ret	 0
$LN20@CGRelation:

; 19282: 						return;
; 19283: 					}
; 19284: 					// ----
; 19285: 					if( !gGensSystem.GetGensInfluence(lpTargetObj) )

  00466	57		 push	 edi
  00467	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  0046c	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  00471	85 c0		 test	 eax, eax
  00473	75 3b		 jne	 SHORT $LN19@CGRelation

; 19286: 					{
; 19287: 						LogAddTD("[GensSystem] [%s][%s] Union Joining Failed to Not Join Gens GuildMaster : UnionMaster [%s][%s]",
; 19288: 							lpObj->AccountID, lpObj->Name, lpTargetObj->AccountID, lpTargetObj->Name);

  00475	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  00478	50		 push	 eax
  00479	83 c7 6c	 add	 edi, 108		; 0000006cH
  0047c	57		 push	 edi
  0047d	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00480	51		 push	 ecx
  00481	83 c6 6c	 add	 esi, 108		; 0000006cH
  00484	56		 push	 esi
  00485	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@NEGBFKID@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@
  0048a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 19289: 						// ----
; 19290: 						ErrMsg.btResult = 0xA2;
; 19291: 						DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00490	0f b6 55 e5	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  00494	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00497	52		 push	 edx
  00498	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  0049b	50		 push	 eax
  0049c	51		 push	 ecx
  0049d	c6 45 e9 a2	 mov	 BYTE PTR _ErrMsg$[ebp+5], 162 ; 000000a2H
  004a1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004a6	83 c4 20	 add	 esp, 32			; 00000020H
  004a9	5f		 pop	 edi
  004aa	5e		 pop	 esi
  004ab	5b		 pop	 ebx

; 19382: }

  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c3		 ret	 0
$LN19@CGRelation:

; 19292: 						return;
; 19293: 					}
; 19294: 					// ----
; 19295: 					if( gGensSystem.GetGensInfluence(lpTargetObj) != gGensSystem.GetGensInfluence(lpObj) )

  004b0	57		 push	 edi
  004b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  004b6	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  004bb	56		 push	 esi
  004bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  004c1	8b d8		 mov	 ebx, eax
  004c3	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  004c8	3b d8		 cmp	 ebx, eax
  004ca	0f 84 1f 01 00
	00		 je	 $LN72@CGRelation

; 19296: 					{
; 19297: 						LogAddTD("[GensSystem] [%s][%s] Union Joining Failed to Gens be Different : UnionMaster [%s][%s] [%s]",
; 19298: 							lpObj->AccountID, lpObj->Name, lpTargetObj->AccountID, lpTargetObj->Name, 
; 19299: 							gGensSystem.GetGensInfluenceName(lpTargetObj));

  004d0	57		 push	 edi
  004d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  004d6	e8 00 00 00 00	 call	 ?GetGensInfluenceName@GensSystem@@QAEPADPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluenceName
  004db	50		 push	 eax
  004dc	8d 57 77	 lea	 edx, DWORD PTR [edi+119]
  004df	52		 push	 edx
  004e0	83 c7 6c	 add	 edi, 108		; 0000006cH
  004e3	57		 push	 edi
  004e4	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  004e7	50		 push	 eax
  004e8	83 c6 6c	 add	 esi, 108		; 0000006cH
  004eb	56		 push	 esi
  004ec	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@KKODDGLK@?$FLGensSystem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Union?5Join@
  004f1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 19300: 						// ----
; 19301: 						ErrMsg.btResult = 0xA3;
; 19302: 						DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  004f7	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  004fb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004fe	51		 push	 ecx
  004ff	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00502	52		 push	 edx
  00503	50		 push	 eax
  00504	c6 45 e9 a3	 mov	 BYTE PTR _ErrMsg$[ebp+5], 163 ; 000000a3H
  00508	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0050d	83 c4 24	 add	 esp, 36			; 00000024H
  00510	5f		 pop	 edi
  00511	5e		 pop	 esi
  00512	5b		 pop	 ebx

; 19382: }

  00513	8b e5		 mov	 esp, ebp
  00515	5d		 pop	 ebp
  00516	c3		 ret	 0
$LN34@CGRelation:

; 19303: 						return;
; 19304: 					}
; 19305: 				}
; 19306: 			}
; 19307: 		}
; 19308: 		else if ( aRecv->btRelationShipType == 2 )

  00517	3c 02		 cmp	 al, 2
  00519	0f 85 da 00 00
	00		 jne	 $LN4@CGRelation

; 19309: 		{
; 19310: 			if ( lpGuildInfo->iGuildRival || lpTargetGuildInfo->iGuildRival )

  0051f	83 ba 20 07 00
	00 00		 cmp	 DWORD PTR [edx+1824], 0
  00526	75 33		 jne	 SHORT $LN14@CGRelation
  00528	83 bb 20 07 00
	00 00		 cmp	 DWORD PTR [ebx+1824], 0
  0052f	75 2a		 jne	 SHORT $LN14@CGRelation

; 19314: 				return;
; 19315: 			}
; 19316: 
; 19317: 			if ( btRelationShip == 1 )

  00531	80 7d ff 01	 cmp	 BYTE PTR _btRelationShip$[ebp], 1
  00535	0f 85 be 00 00
	00		 jne	 $LN4@CGRelation

; 19318: 			{
; 19319: 				ErrMsg.btResult = GUILD_ANS_EXIST_RELATIONSHIP_UNION;
; 19320: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0053b	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  0053f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00542	51		 push	 ecx
  00543	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00546	52		 push	 edx
  00547	50		 push	 eax
  00548	c6 45 e9 15	 mov	 BYTE PTR _ErrMsg$[ebp+5], 21 ; 00000015H
  0054c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00551	83 c4 0c	 add	 esp, 12			; 0000000cH
  00554	5f		 pop	 edi
  00555	5e		 pop	 esi
  00556	5b		 pop	 ebx

; 19382: }

  00557	8b e5		 mov	 esp, ebp
  00559	5d		 pop	 ebp
  0055a	c3		 ret	 0
$LN14@CGRelation:

; 19311: 			{
; 19312: 				ErrMsg.btResult = GUILD_ANS_EXIST_RIVAL;
; 19313: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0055b	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  0055f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00562	51		 push	 ecx
  00563	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  00566	52		 push	 edx
  00567	50		 push	 eax
  00568	c6 45 e9 18	 mov	 BYTE PTR _ErrMsg$[ebp+5], 24 ; 00000018H
  0056c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00571	83 c4 0c	 add	 esp, 12			; 0000000cH
  00574	5f		 pop	 edi
  00575	5e		 pop	 esi
  00576	5b		 pop	 ebx

; 19382: }

  00577	8b e5		 mov	 esp, ebp
  00579	5d		 pop	 ebp
  0057a	c3		 ret	 0
$LN35@CGRelation:

; 19321: 				return;
; 19322: 			}
; 19323: 		}
; 19324: 	}
; 19325: 	else if ( aRecv->btRequestType == 2 )

  0057b	3c 02		 cmp	 al, 2
  0057d	75 7a		 jne	 SHORT $LN4@CGRelation

; 19326: 	{
; 19327: 		if ( aRecv->btRelationShipType == 1 )

  0057f	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00582	3c 01		 cmp	 al, 1
  00584	75 29		 jne	 SHORT $LN10@CGRelation

; 19328: 		{
; 19329: 			if ( lpGuildInfo->iGuildUnion == 0 )

  00586	83 ba 1c 07 00
	00 00		 cmp	 DWORD PTR [edx+1820], 0
  0058d	75 6a		 jne	 SHORT $LN4@CGRelation
$LN5@CGRelation:

; 19330: 			{
; 19331: 				ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 19332: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0058f	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  00593	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00596	51		 push	 ecx
  00597	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  0059a	52		 push	 edx
  0059b	50		 push	 eax
  0059c	c6 45 e9 19	 mov	 BYTE PTR _ErrMsg$[ebp+5], 25 ; 00000019H
  005a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  005a8	5f		 pop	 edi
  005a9	5e		 pop	 esi
  005aa	5b		 pop	 ebx

; 19382: }

  005ab	8b e5		 mov	 esp, ebp
  005ad	5d		 pop	 ebp
  005ae	c3		 ret	 0
$LN10@CGRelation:

; 19333: 				return;
; 19334: 			}
; 19335: 		}
; 19336: 		else if ( aRecv->btRelationShipType == 2 )

  005af	3c 02		 cmp	 al, 2
  005b1	75 46		 jne	 SHORT $LN4@CGRelation

; 19337: 		{
; 19338: 			if ( !lpGuildInfo->iGuildRival || !lpTargetGuildInfo->iGuildRival )

  005b3	8b 8a 20 07 00
	00		 mov	 ecx, DWORD PTR [edx+1824]
  005b9	85 c9		 test	 ecx, ecx
  005bb	74 d2		 je	 SHORT $LN5@CGRelation
  005bd	8b 83 20 07 00
	00		 mov	 eax, DWORD PTR [ebx+1824]
  005c3	85 c0		 test	 eax, eax
  005c5	74 c8		 je	 SHORT $LN5@CGRelation

; 19343: 			}
; 19344: 
; 19345: 			if ( lpGuildInfo->iGuildRival != lpTargetGuildInfo->Number || lpGuildInfo->Number != lpTargetGuildInfo->iGuildRival )

  005c7	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  005c9	75 04		 jne	 SHORT $LN3@CGRelation
  005cb	39 02		 cmp	 DWORD PTR [edx], eax
  005cd	74 27		 je	 SHORT $LN77@CGRelation
$LN3@CGRelation:

; 19346: 			{
; 19347: 				ErrMsg.btResult = GUILD_ANS_NOT_GUILD_RIVAL;
; 19348: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  005cf	0f b6 4d e5	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  005d3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005d6	51		 push	 ecx
  005d7	8d 55 e4	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  005da	52		 push	 edx
  005db	50		 push	 eax
  005dc	c6 45 e9 1c	 mov	 BYTE PTR _ErrMsg$[ebp+5], 28 ; 0000001cH
  005e0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  005e8	5f		 pop	 edi
  005e9	5e		 pop	 esi
  005ea	5b		 pop	 ebx

; 19382: }

  005eb	8b e5		 mov	 esp, ebp
  005ed	5d		 pop	 ebp
  005ee	c3		 ret	 0
$LN72@CGRelation:

; 19339: 			{
; 19340: 				ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 19341: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 19342: 				return;

  005ef	8b 55 f8	 mov	 edx, DWORD PTR _lpGuildInfo$[ebp]
  005f2	eb 02		 jmp	 SHORT $LN77@CGRelation
$LN76@CGRelation:
  005f4	8b d1		 mov	 edx, ecx
$LN77@CGRelation:
  005f6	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
$LN4@CGRelation:

; 19349: 				return;
; 19350: 			}
; 19351: 		}
; 19352: 	}		
; 19353: 	
; 19354: 	if ( aRecv->btRequestType == 2 )

  005f9	80 79 04 02	 cmp	 BYTE PTR [ecx+4], 2
  005fd	75 20		 jne	 SHORT $LN1@CGRelation

; 19355: 	{
; 19356: 		if ( aRecv->btRelationShipType == 1 )

  005ff	80 79 03 01	 cmp	 BYTE PTR [ecx+3], 1
  00603	75 1a		 jne	 SHORT $LN1@CGRelation

; 19357: 		{
; 19358: 			GDUnionBreakOff(aIndex, lpGuildInfo->iGuildUnion);

  00605	8b 8a 1c 07 00
	00		 mov	 ecx, DWORD PTR [edx+1820]
  0060b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0060e	51		 push	 ecx
  0060f	52		 push	 edx
  00610	e8 00 00 00 00	 call	 ?GDUnionBreakOff@@YAXHH@Z ; GDUnionBreakOff
  00615	83 c4 08	 add	 esp, 8
  00618	5f		 pop	 edi
  00619	5e		 pop	 esi
  0061a	5b		 pop	 ebx

; 19382: }

  0061b	8b e5		 mov	 esp, ebp
  0061d	5d		 pop	 ebp
  0061e	c3		 ret	 0
$LN1@CGRelation:

; 19359: 			return;
; 19360: 		}
; 19361: 	}
; 19362: 
; 19363: 	lpObj->m_IfState.use = 1;
; 19364: 	lpObj->m_IfState.type = 14;
; 19365: 	lpObj->m_IfState.state = 0;

  0061f	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]

; 19366: 	lpObj->m_InterfaceTime = GetTickCount();

  00625	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0062b	25 81 03 ff ff	 and	 eax, -64639		; ffff0381H
  00630	0d 81 03 00 00	 or	 eax, 897		; 00000381H
  00635	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax
  0063b	ff d3		 call	 ebx
  0063d	89 86 20 0e 00
	00		 mov	 DWORD PTR [esi+3616], eax

; 19367: 
; 19368: 	lpTargetObj->m_IfState.use = 1;
; 19369: 	lpTargetObj->m_IfState.type = 14;
; 19370: 	lpTargetObj->m_IfState.state = 0;

  00643	8b 8f 1c 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3612]
  00649	81 e1 81 03 ff
	ff		 and	 ecx, -64639		; ffff0381H
  0064f	81 c9 81 03 00
	00		 or	 ecx, 897		; 00000381H
  00655	89 8f 1c 0e 00
	00		 mov	 DWORD PTR [edi+3612], ecx

; 19371: 	lpTargetObj->m_InterfaceTime = GetTickCount();

  0065b	ff d3		 call	 ebx
  0065d	89 87 20 0e 00
	00		 mov	 DWORD PTR [edi+3616], eax

; 19372: 
; 19373: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ pMsg={0};
; 19374: 
; 19375: 	PHeadSetB((LPBYTE)&pMsg, 0xE5, sizeof(pMsg));

  00663	6a 07		 push	 7
  00665	33 c0		 xor	 eax, eax
  00667	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0066a	68 e5 00 00 00	 push	 229			; 000000e5H
  0066f	52		 push	 edx
  00670	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00674	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00677	66 89 45 f1	 mov	 WORD PTR _pMsg$[ebp+5], ax
  0067b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 19376: 	pMsg.btTargetUserIndexL = SET_NUMBERL(aIndex);

  00680	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00683	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 19377: 	pMsg.btTargetUserIndexH = SET_NUMBERH(aIndex);

  00686	c1 e8 08	 shr	 eax, 8
  00689	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 19378: 	pMsg.btRequestType = aRecv->btRequestType;

  0068c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0068f	8a 48 04	 mov	 cl, BYTE PTR [eax+4]

; 19379: 	pMsg.btRelationShipType = aRecv->btRelationShipType;

  00692	8a 50 03	 mov	 dl, BYTE PTR [eax+3]

; 19380: 	
; 19381: 	DataSend(iTargetUserIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00695	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00699	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0069c	50		 push	 eax
  0069d	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  006a0	88 55 ef	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  006a3	8b 55 f4	 mov	 edx, DWORD PTR _iTargetUserIndex$[ebp]
  006a6	51		 push	 ecx
  006a7	52		 push	 edx
  006a8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006ad	83 c4 18	 add	 esp, 24			; 00000018H
  006b0	5f		 pop	 edi
  006b1	5e		 pop	 esi
  006b2	5b		 pop	 ebx

; 19382: }

  006b3	8b e5		 mov	 esp, ebp
  006b5	5d		 pop	 ebp
  006b6	c3		 ret	 0
$LN40@CGRelation:

; 19182: 	{
; 19183: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 19184: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  006b7	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  006bb	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  006be	50		 push	 eax
  006bf	8d 4d e4	 lea	 ecx, DWORD PTR _ErrMsg$[ebp]
  006c2	51		 push	 ecx
  006c3	52		 push	 edx
  006c4	c6 45 e9 11	 mov	 BYTE PTR _ErrMsg$[ebp+5], 17 ; 00000011H

; 19214: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  006c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d0	5f		 pop	 edi
  006d1	5e		 pop	 esi
  006d2	5b		 pop	 ebx

; 19382: }

  006d3	8b e5		 mov	 esp, ebp
  006d5	5d		 pop	 ebp
  006d6	c3		 ret	 0
$LN45@CGRelation:

; 19145: 	{
; 19146: 		GCResultSend(aIndex, 0x51, 5);

  006d7	6a 05		 push	 5
  006d9	6a 51		 push	 81			; 00000051H
  006db	53		 push	 ebx
  006dc	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  006e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN80@CGRelation:
  006e4	5f		 pop	 edi
  006e5	5e		 pop	 esi
  006e6	5b		 pop	 ebx

; 19382: }

  006e7	8b e5		 mov	 esp, ebp
  006e9	5d		 pop	 ebp
  006ea	c3		 ret	 0
?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ENDP ; CGRelationShipReqJoinBreakOff
_TEXT	ENDS
PUBLIC	?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ; CGRelationShipAnsJoinBreakOff
EXTRN	?GDRelationShipReqBreakOff@@YAXHHH@Z:PROC	; GDRelationShipReqBreakOff
EXTRN	?GDRelationShipReqJoin@@YAXHHH@Z:PROC		; GDRelationShipReqJoin
; Function compile flags: /Ogtp
;	COMDAT ?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z
_TEXT	SEGMENT
_ErrMsg$251405 = -8					; size = 8
tv276 = 8						; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z PROC ; CGRelationShipAnsJoinBreakOff, COMDAT

; 19385: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 19386: 	int iTargetUserIndex = MAKE_NUMBERW(aRecv->btTargetUserIndexH, aRecv->btTargetUserIndexL);
; 19387: 
; 19388: 	if ( !OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(iTargetUserIndex))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  0000e	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  00012	0f b6 4e 07	 movzx	 ecx, BYTE PTR [esi+7]
  00016	66 c1 e0 08	 shl	 ax, 8
  0001a	57		 push	 edi
  0001b	0f b7 f8	 movzx	 edi, ax
  0001e	0b f9		 or	 edi, ecx
  00020	85 db		 test	 ebx, ebx
  00022	0f 88 5c 01 00
	00		 js	 $LN12@CGRelation@2
  00028	33 c0		 xor	 eax, eax
  0002a	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 49 01 00
	00		 je	 $LN12@CGRelation@2
  0003b	85 ff		 test	 edi, edi
  0003d	0f 88 41 01 00
	00		 js	 $LN12@CGRelation@2
  00043	33 c0		 xor	 eax, eax
  00045	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0004b	0f 9e c0	 setle	 al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 2e 01 00
	00		 je	 $LN12@CGRelation@2

; 19389: 	{
; 19390: 		return;
; 19391: 	}
; 19392: 
; 19393: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005c	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00062	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	0f 84 0e 01 00
	00		 je	 $LN12@CGRelation@2

; 19394: 	{
; 19395: 		return;
; 19396: 	}
; 19397: 
; 19398: 	if ( gObjIsConnected(&gObj[iTargetUserIndex]) == FALSE )

  00076	8b c7		 mov	 eax, edi
  00078	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0007e	89 45 08	 mov	 DWORD PTR tv276[ebp], eax
  00081	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0008d	83 c4 04	 add	 esp, 4
  00090	85 c0		 test	 eax, eax
  00092	75 17		 jne	 SHORT $LN10@CGRelation@2

; 19399: 	{
; 19400: 		GCResultSend(aIndex, 0x51, 3);

  00094	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00097	6a 03		 push	 3
  00099	6a 51		 push	 81			; 00000051H
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx

; 19443: 		}
; 19444: 	}
; 19445: }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN10@CGRelation@2:

; 19401: 		return;
; 19402: 	}
; 19403: 
; 19404: 	if ( aRecv->btResult == 1 )

  000ab	80 7e 05 01	 cmp	 BYTE PTR [esi+5], 1
  000af	75 33		 jne	 SHORT $LN9@CGRelation@2

; 19405: 	{
; 19406: 		if ( aRecv->btRequestType == 1 )

  000b1	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  000b4	3c 01		 cmp	 al, 1
  000b6	75 14		 jne	 SHORT $LN8@CGRelation@2

; 19407: 		{
; 19408: 			GDRelationShipReqJoin(iTargetUserIndex, aIndex, aRecv->btRelationShipType);

  000b8	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000bc	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000bf	50		 push	 eax
  000c0	51		 push	 ecx
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ?GDRelationShipReqJoin@@YAXHHH@Z ; GDRelationShipReqJoin
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	eb 68		 jmp	 SHORT $LN5@CGRelation@2
$LN8@CGRelation@2:

; 19409: 		}
; 19410: 		else if ( aRecv->btRequestType == 2 )

  000cc	3c 02		 cmp	 al, 2
  000ce	75 64		 jne	 SHORT $LN5@CGRelation@2

; 19411: 		{
; 19412: 			GDRelationShipReqBreakOff(aIndex, iTargetUserIndex, aRecv->btRelationShipType);

  000d0	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  000d4	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000d7	52		 push	 edx
  000d8	57		 push	 edi
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?GDRelationShipReqBreakOff@@YAXHHH@Z ; GDRelationShipReqBreakOff
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19413: 		}
; 19414: 	}
; 19415: 	else

  000e2	eb 50		 jmp	 SHORT $LN5@CGRelation@2
$LN9@CGRelation@2:

; 19416: 	{
; 19417: 		PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg ={0};
; 19418: 
; 19419: 		PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  000e4	6a 08		 push	 8
  000e6	33 c0		 xor	 eax, eax
  000e8	8d 4d f8	 lea	 ecx, DWORD PTR _ErrMsg$251405[ebp]
  000eb	68 e6 00 00 00	 push	 230			; 000000e6H
  000f0	51		 push	 ecx
  000f1	c6 45 f8 00	 mov	 BYTE PTR _ErrMsg$251405[ebp], 0
  000f5	89 45 f9	 mov	 DWORD PTR _ErrMsg$251405[ebp+1], eax
  000f8	66 89 45 fd	 mov	 WORD PTR _ErrMsg$251405[ebp+5], ax
  000fc	88 45 ff	 mov	 BYTE PTR _ErrMsg$251405[ebp+7], al
  000ff	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 19420: 		ErrMsg.btResult = 0;
; 19421: 		ErrMsg.btRequestType = aRecv->btRequestType;
; 19422: 		ErrMsg.btRelationShipType = aRecv->btRelationShipType;

  00104	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00107	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]

; 19423: 		ErrMsg.btTargetUserIndexH = aRecv->btTargetUserIndexH;

  0010b	8a 4e 06	 mov	 cl, BYTE PTR [esi+6]
  0010e	88 45 fb	 mov	 BYTE PTR _ErrMsg$251405[ebp+3], al

; 19424: 		ErrMsg.btTargetUserIndexL = aRecv->btTargetUserIndexL;
; 19425: 		ErrMsg.btResult = GUILD_ANS_CANCLE_REQUEST;
; 19426: 
; 19427: 		DataSend(iTargetUserIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00111	0f b6 45 f9	 movzx	 eax, BYTE PTR _ErrMsg$251405[ebp+1]
  00115	88 4d fe	 mov	 BYTE PTR _ErrMsg$251405[ebp+6], cl
  00118	50		 push	 eax
  00119	88 55 fc	 mov	 BYTE PTR _ErrMsg$251405[ebp+4], dl
  0011c	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  00120	8d 4d f8	 lea	 ecx, DWORD PTR _ErrMsg$251405[ebp]
  00123	51		 push	 ecx
  00124	57		 push	 edi
  00125	88 55 ff	 mov	 BYTE PTR _ErrMsg$251405[ebp+7], dl
  00128	c6 45 fd 20	 mov	 BYTE PTR _ErrMsg$251405[ebp+5], 32 ; 00000020H
  0012c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00131	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@CGRelation@2:

; 19428: 	}
; 19429: 
; 19430: 	if ( gObj[aIndex].m_IfState.use )

  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013a	8b 84 0b 1c 0e
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+3612]
  00141	be fc ff ff ff	 mov	 esi, -4			; fffffffcH
  00146	a8 03		 test	 al, 3
  00148	74 19		 je	 SHORT $LN3@CGRelation@2

; 19431: 	{
; 19432: 		if ( gObj[aIndex].m_IfState.type == 14 )

  0014a	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0014f	3d 80 03 00 00	 cmp	 eax, 896		; 00000380H
  00154	75 0d		 jne	 SHORT $LN3@CGRelation@2

; 19433: 		{
; 19434: 			gObj[aIndex].m_IfState.use = 0;

  00156	21 b4 0b 1c 0e
	00 00		 and	 DWORD PTR [ebx+ecx+3612], esi
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@CGRelation@2:

; 19435: 		}
; 19436: 	}
; 19437: 
; 19438: 	if ( gObj[iTargetUserIndex].m_IfState.use )

  00163	8b 55 08	 mov	 edx, DWORD PTR tv276[ebp]
  00166	8b 84 0a 1c 0e
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3612]
  0016d	a8 03		 test	 al, 3
  0016f	74 13		 je	 SHORT $LN12@CGRelation@2

; 19439: 	{
; 19440: 		if ( gObj[iTargetUserIndex].m_IfState.type == 14 )

  00171	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00176	3d 80 03 00 00	 cmp	 eax, 896		; 00000380H
  0017b	75 07		 jne	 SHORT $LN12@CGRelation@2

; 19441: 		{
; 19442: 			gObj[iTargetUserIndex].m_IfState.use = 0;

  0017d	21 b4 0a 1c 0e
	00 00		 and	 DWORD PTR [edx+ecx+3612], esi
$LN12@CGRelation@2:
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx

; 19443: 		}
; 19444: 	}
; 19445: }

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ENDP ; CGRelationShipAnsJoinBreakOff
_TEXT	ENDS
PUBLIC	?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z	; CGUnionList
EXTRN	?GDUnionListSend@@YAXHH@Z:PROC			; GDUnionListSend
; Function compile flags: /Ogtp
;	COMDAT ?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z PROC	; CGUnionList, COMDAT

; 19448: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 19449: 	if ( !OBJMAX_RANGE(aIndex))

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 72		 js	 SHORT $LN7@CGUnionLis
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 63		 je	 SHORT $LN7@CGUnionLis

; 19450: 	{
; 19451: 		return;
; 19452: 	}
; 19453: 
; 19454: 	if ( !PacketCheckTime(&gObj[aIndex]))

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	56		 push	 esi
  00020	8b f7		 mov	 esi, edi
  00022	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00028	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00031	83 c4 04	 add	 esp, 4
  00034	85 c0		 test	 eax, eax
  00036	74 44		 je	 SHORT $LN11@CGUnionLis

; 19455: 	{
; 19456: 		return;
; 19457: 	}
; 19458: 
; 19459: 	LPOBJ lpObj = &gObj[aIndex];

  00038	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19460: 
; 19461: 	if ( lpObj == NULL )

  0003e	74 3c		 je	 SHORT $LN11@CGUnionLis

; 19462: 	{
; 19463: 		return;
; 19464: 	}
; 19465: 
; 19466: 	if ( gObjIsConnected(&gObj[aIndex]) == FALSE )

  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00046	83 c4 04	 add	 esp, 4
  00049	85 c0		 test	 eax, eax

; 19467: 	{
; 19468: 		GCResultSend(aIndex, 0x51, 3);
; 19469: 		return;

  0004b	74 14		 je	 SHORT $LN12@CGUnionLis

; 19470: 	}
; 19471: 
; 19472: 	if ( lpObj->lpGuild == NULL )

  0004d	8b b6 38 04 00
	00		 mov	 esi, DWORD PTR [esi+1080]
  00053	85 f6		 test	 esi, esi

; 19473: 	{
; 19474: 		GCResultSend(aIndex, 0x51, 3);
; 19475: 		return;

  00055	74 0a		 je	 SHORT $LN12@CGUnionLis

; 19476: 	}
; 19477: 
; 19478: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  00057	8b b6 1c 07 00
	00		 mov	 esi, DWORD PTR [esi+1820]
  0005d	85 f6		 test	 esi, esi
  0005f	75 11		 jne	 SHORT $LN1@CGUnionLis
$LN12@CGUnionLis:

; 19479: 	{
; 19480: 		GCResultSend(aIndex, 0x51, 3);

  00061	6a 03		 push	 3
  00063	6a 51		 push	 81			; 00000051H
  00065	57		 push	 edi
  00066	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	5e		 pop	 esi
  0006f	5f		 pop	 edi

; 19485: 
; 19486: }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN1@CGUnionLis:

; 19481: 		return;
; 19482: 	}
; 19483: 
; 19484: 	GDUnionListSend(aIndex, lpObj->lpGuild->iGuildUnion);

  00072	56		 push	 esi
  00073	57		 push	 edi
  00074	e8 00 00 00 00	 call	 ?GDUnionListSend@@YAXHH@Z ; GDUnionListSend
  00079	83 c4 08	 add	 esp, 8
$LN11@CGUnionLis:
  0007c	5e		 pop	 esi
$LN7@CGUnionLis:
  0007d	5f		 pop	 edi

; 19485: 
; 19486: }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z ENDP	; CGUnionList
_TEXT	ENDS
PUBLIC	??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@ ; `string'
PUBLIC	??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ; CGRelationShipReqKickOutUnionMember
EXTRN	?GDRelationShipReqKickOutUnionMember@@YAXHPAD@Z:PROC ; GDRelationShipReqKickOutUnionMember
;	COMDAT ??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@
CONST	SEGMENT
??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@ DB 0a1H, 0d9H, ' Term'
	DB	'inated Guild.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@
CONST	SEGMENT
??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@ DB 0a1H, 0daH, ' Termi'
	DB	'nated User.', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -28					; size = 4
_ErrMsg$ = -24						; size = 8
_szUnionMemberGuildName$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z PROC ; CGRelationShipReqKickOutUnionMember, COMDAT

; 19489: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 19490: 	if ( !OBJMAX_RANGE(aIndex))

  00015	33 db		 xor	 ebx, ebx
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 19568: 
; 19569: 	if ( !strcmp(lpObj->lpGuild->Name, szUnionMemberGuildName))

  0001b	89 75 e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0001e	3b f3		 cmp	 esi, ebx
  00020	0f 8c b0 01 00
	00		 jl	 $LN10@CGRelation@3

; 19490: 	if ( !OBJMAX_RANGE(aIndex))

  00026	33 c0		 xor	 eax, eax
  00028	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0002e	0f 9e c0	 setle	 al
  00031	3b c3		 cmp	 eax, ebx
  00033	0f 84 9d 01 00
	00		 je	 $LN10@CGRelation@3

; 19491: 	{
; 19492: 		return;
; 19493: 	}
; 19494: 
; 19495: 	if ( ::PacketCheckTime(&gObj[aIndex]) == FALSE )

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00044	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004d	83 c4 04	 add	 esp, 4
  00050	85 c0		 test	 eax, eax
  00052	0f 84 7e 01 00
	00		 je	 $LN10@CGRelation@3

; 19496: 	{
; 19497: 		return;
; 19498: 	}
; 19499: 
; 19500: 	LPOBJ lpObj = &gObj[aIndex];

  00058	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19501: 
; 19502: 	if ( lpObj == NULL )

  0005e	3b f3		 cmp	 esi, ebx
  00060	0f 84 70 01 00
	00		 je	 $LN10@CGRelation@3

; 19503: 	{
; 19504: 		return;
; 19505: 	}
; 19506: 
; 19507: 	if ( gObjIsConnected(&gObj[aIndex]) == FALSE )

  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0006c	83 c4 04	 add	 esp, 4
  0006f	85 c0		 test	 eax, eax
  00071	75 2c		 jne	 SHORT $LN6@CGRelation@3

; 19508: 	{
; 19509: 		GCResultSend(aIndex, 0x51, 3);

  00073	8b 75 e4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00076	6a 03		 push	 3
  00078	6a 51		 push	 81			; 00000051H
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 19510: 		MsgOutput(aIndex, " Terminated User.");

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0008b	83 c4 14	 add	 esp, 20			; 00000014H
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 19577: }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN6@CGRelation@3:

; 19511: 		return;
; 19512: 	}
; 19513: 
; 19514: 	if ( lpObj->lpGuild == NULL )

  0009f	39 9e 38 04 00
	00		 cmp	 DWORD PTR [esi+1080], ebx
  000a5	75 2c		 jne	 SHORT $LN5@CGRelation@3

; 19515: 	{
; 19516: 		GCResultSend(aIndex, 0x51, 3);

  000a7	8b 75 e4	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  000aa	6a 03		 push	 3
  000ac	6a 51		 push	 81			; 00000051H
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 19517: 		MsgOutput(aIndex, " Terminated Guild.");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@
  000b9	56		 push	 esi
  000ba	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000bf	83 c4 14	 add	 esp, 20			; 00000014H
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx

; 19577: }

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
$LN5@CGRelation@3:

; 19518: 		return;
; 19519: 	}
; 19520: 
; 19521: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg = {0};

  000d3	33 c0		 xor	 eax, eax

; 19522: 
; 19523: 	PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  000d5	6a 08		 push	 8
  000d7	89 45 e9	 mov	 DWORD PTR _ErrMsg$[ebp+1], eax
  000da	66 89 45 ed	 mov	 WORD PTR _ErrMsg$[ebp+5], ax
  000de	88 45 ef	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  000e1	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  000e4	68 e6 00 00 00	 push	 230			; 000000e6H
  000e9	50		 push	 eax
  000ea	88 5d e8	 mov	 BYTE PTR _ErrMsg$[ebp], bl
  000ed	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 19524: 	ErrMsg.btResult = 0;
; 19525: 	ErrMsg.btRequestType = 2;
; 19526: 	ErrMsg.btRelationShipType = 1;

  000f2	c6 45 eb 01	 mov	 BYTE PTR _ErrMsg$[ebp+3], 1
  000f6	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _ErrMsg$[ebp+4], 2

; 19527: 	ErrMsg.btTargetUserIndexH = 0;
; 19528: 	ErrMsg.btTargetUserIndexL = 0;
; 19529: 
; 19530: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  000fd	8b 8e 38 04 00
	00		 mov	 ecx, DWORD PTR [esi+1080]
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH
  00106	39 99 1c 07 00
	00		 cmp	 DWORD PTR [ecx+1820], ebx
  0010c	75 16		 jne	 SHORT $LN4@CGRelation@3

; 19531: 	{
; 19532: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 19533: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0010e	0f b6 55 e9	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  00112	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00115	52		 push	 edx
  00116	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00119	50		 push	 eax
  0011a	c6 45 ed 19	 mov	 BYTE PTR _ErrMsg$[ebp+5], 25 ; 00000019H
  0011e	51		 push	 ecx

; 19534: 		return;

  0011f	e9 aa 00 00 00	 jmp	 $LN18@CGRelation@3
$LN4@CGRelation@3:

; 19535: 	}
; 19536: 
; 19537: 	#if(ENABLE_AGMASTER)	//Alli ckick
; 19538: 
; 19539: 	bool ResultStatus = false;
; 19540: 
; 19541: 	if(lpObj->GuildStatus == GUILD_MASTER || lpObj->GuildStatus == GUILD_ASSISTANT)
; 19542: 	{
; 19543: 		ResultStatus = true;
; 19544: 	}
; 19545: 
; 19546: 	if ( ResultStatus == false || lpObj->lpGuild->Number != lpObj->lpGuild->iGuildUnion)
; 19547: 	{
; 19548: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 19549: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 19550: 
; 19551: 		return;
; 19552: 	}	
; 19553: 
; 19554: 	#else
; 19555: 
; 19556: 	if ( lpObj->GuildStatus != GUILD_MASTER || lpObj->lpGuild->Number != lpObj->lpGuild->iGuildUnion)

  00124	81 be 48 04 00
	00 80 00 00 00	 cmp	 DWORD PTR [esi+1096], 128 ; 00000080H
  0012e	0f 85 89 00 00
	00		 jne	 $LN2@CGRelation@3
  00134	8b c1		 mov	 eax, ecx
  00136	8b 10		 mov	 edx, DWORD PTR [eax]
  00138	3b 90 1c 07 00
	00		 cmp	 edx, DWORD PTR [eax+1820]
  0013e	0f 85 79 00 00
	00		 jne	 $LN2@CGRelation@3

; 19560: 
; 19561: 		return;
; 19562: 	}
; 19563: 
; 19564: 	#endif
; 19565: 
; 19566: 	char szUnionMemberGuildName[MAX_GUILD_LEN+1] = {0};
; 19567: 	memcpy(szUnionMemberGuildName, aRecv->szTargetGuildName, MAX_GUILD_LEN);

  00144	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00147	33 c0		 xor	 eax, eax
  00149	89 45 f1	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+1], eax
  0014c	89 45 f5	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+5], eax
  0014f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00152	89 45 f0	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp], eax
  00155	89 4d f4	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+4], ecx

; 19568: 
; 19569: 	if ( !strcmp(lpObj->lpGuild->Name, szUnionMemberGuildName))

  00158	8b 86 38 04 00
	00		 mov	 eax, DWORD PTR [esi+1080]
  0015e	8d 4d f0	 lea	 ecx, DWORD PTR _szUnionMemberGuildName$[ebp]
  00161	83 c0 04	 add	 eax, 4
$LL14@CGRelation@3:
  00164	8a 10		 mov	 dl, BYTE PTR [eax]
  00166	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00168	75 1a		 jne	 SHORT $LN15@CGRelation@3
  0016a	3a d3		 cmp	 dl, bl
  0016c	74 12		 je	 SHORT $LN16@CGRelation@3
  0016e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00171	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00174	75 0e		 jne	 SHORT $LN15@CGRelation@3
  00176	83 c0 02	 add	 eax, 2
  00179	83 c1 02	 add	 ecx, 2
  0017c	3a d3		 cmp	 dl, bl
  0017e	75 e4		 jne	 SHORT $LL14@CGRelation@3
$LN16@CGRelation@3:
  00180	33 c0		 xor	 eax, eax
  00182	eb 05		 jmp	 SHORT $LN17@CGRelation@3
$LN15@CGRelation@3:
  00184	1b c0		 sbb	 eax, eax
  00186	83 d8 ff	 sbb	 eax, -1
$LN17@CGRelation@3:
  00189	3b c3		 cmp	 eax, ebx
  0018b	75 0f		 jne	 SHORT $LN1@CGRelation@3

; 19570: 	{
; 19571: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 19572: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0018d	0f b6 55 e9	 movzx	 edx, BYTE PTR _ErrMsg$[ebp+1]
  00191	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00194	52		 push	 edx
  00195	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00198	50		 push	 eax
  00199	51		 push	 ecx

; 19573: 		return;

  0019a	eb 2e		 jmp	 SHORT $LN19@CGRelation@3
$LN1@CGRelation@3:

; 19574: 	}
; 19575: 
; 19576: 	GDRelationShipReqKickOutUnionMember(aIndex, szUnionMemberGuildName);

  0019c	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0019f	8d 55 f0	 lea	 edx, DWORD PTR _szUnionMemberGuildName$[ebp]
  001a2	52		 push	 edx
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?GDRelationShipReqKickOutUnionMember@@YAXHPAD@Z ; GDRelationShipReqKickOutUnionMember
  001a9	83 c4 08	 add	 esp, 8
  001ac	5f		 pop	 edi
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx

; 19577: }

  001af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b2	33 cd		 xor	 ecx, ebp
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN2@CGRelation@3:

; 19559: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  001bd	0f b6 4d e9	 movzx	 ecx, BYTE PTR _ErrMsg$[ebp+1]
  001c1	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001c4	51		 push	 ecx
  001c5	8d 55 e8	 lea	 edx, DWORD PTR _ErrMsg$[ebp]
  001c8	52		 push	 edx
  001c9	50		 push	 eax
$LN19@CGRelation@3:

; 19557: 	{
; 19558: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;

  001ca	c6 45 ed 11	 mov	 BYTE PTR _ErrMsg$[ebp+5], 17 ; 00000011H
$LN18@CGRelation@3:

; 19559: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  001ce	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@CGRelation@3:

; 19577: }

  001d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	33 cd		 xor	 ecx, ebp
  001dd	5b		 pop	 ebx
  001de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ENDP ; CGRelationShipReqKickOutUnionMember
_TEXT	ENDS
PUBLIC	??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@ ; `string'
PUBLIC	?GCAnsMapSvrAuth@@YAXHH@Z			; GCAnsMapSvrAuth
;	COMDAT ??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@
CONST	SEGMENT
??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@ DB '[Ma'
	DB	'pServerMng] Packet Error JG [0x7B] - Index out of bound : %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCAnsMapSvrAuth@@YAXHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsMapSvrAuth@@YAXHH@Z PROC				; GCAnsMapSvrAuth, COMDAT

; 19668: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 19669: 	if ( !OBJMAX_RANGE(iIndex) )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 0f		 js	 SHORT $LN6@GCAnsMapSv
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	75 16		 jne	 SHORT $LN1@GCAnsMapSv
$LN6@GCAnsMapSv:

; 19670: 	{
; 19671: 		LogAddC(2,"[MapServerMng] Packet Error JG [0x7B] - Index out of bound : %d",iIndex);

  0001d	56		 push	 esi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	5e		 pop	 esi

; 19681: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@GCAnsMapSv:

; 19672: 		return;
; 19673: 	}
; 19674: 
; 19675: 	PMSG_ANS_MAPSERVERAUTH pMsgResult;
; 19676: 
; 19677: 	PHeadSubSetB((LPBYTE)&pMsgResult, 0xB1, 0x01, sizeof(pMsgResult));

  00033	6a 05		 push	 5
  00035	6a 01		 push	 1
  00037	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0003a	68 b1 00 00 00	 push	 177			; 000000b1H
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19678: 	pMsgResult.iResult = iResult;
; 19679: 
; 19680: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00045	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00049	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  0004c	52		 push	 edx
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00050	50		 push	 eax
  00051	56		 push	 esi
  00052	88 4d fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], cl
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005d	5e		 pop	 esi

; 19681: }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GCAnsMapSvrAuth@@YAXHH@Z ENDP				; GCAnsMapSvrAuth
_TEXT	ENDS
PUBLIC	?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ; CGReqCastleSiegeState
EXTRN	?GS_GDReqOwnerGuildMaster@@YAXHH@Z:PROC		; GS_GDReqOwnerGuildMaster
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z PROC ; CGReqCastleSiegeState, COMDAT

; 19684: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19685: //#if(GS_CASTLE==1)
; 19686: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(), iIndex);

  00003	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  00008	85 c0		 test	 eax, eax
  0000a	74 13		 je	 SHORT $LN3@CGReqCastl
  0000c	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00013	51		 push	 ecx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?GS_GDReqOwnerGuildMaster@@YAXHH@Z ; GS_GDReqOwnerGuildMaster
  0001a	83 c4 08	 add	 esp, 8

; 19687: //#endif
; 19688: }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0

; 19685: //#if(GS_CASTLE==1)
; 19686: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(), iIndex);

$LN3@CGReqCastl:
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00022	83 c8 ff	 or	 eax, -1
  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?GS_GDReqOwnerGuildMaster@@YAXHH@Z ; GS_GDReqOwnerGuildMaster
  0002c	83 c4 08	 add	 esp, 8

; 19687: //#endif
; 19688: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ENDP ; CGReqCastleSiegeState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCastleSiegeState@@YAXHHPAD0@Z		; GCAnsCastleSiegeState
EXTRN	?GetCurRemainSec@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCurRemainSec
EXTRN	?GetCastleStateTerm@CCastleSiege@@QAEHPAU_SYSTEMTIME@@0@Z:PROC ; CCastleSiege::GetCastleStateTerm
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCastleSiegeState@@YAXHHPAD0@Z
_TEXT	SEGMENT
_tmSiegeStartDate$ = -104				; size = 16
_iCastleState$ = -88					; size = 4
_tmStateStartDate$ = -84				; size = 16
_tmStateEndDate$ = -68					; size = 16
_pMsgResult$ = -52					; size = 46
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
_lpszGuildMaster$ = 20					; size = 4
?GCAnsCastleSiegeState@@YAXHHPAD0@Z PROC		; GCAnsCastleSiegeState, COMDAT

; 19691: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]
  00013	8b 45 14	 mov	 eax, DWORD PTR _lpszGuildMaster$[ebp]

; 19692: //#if (GS_CASTLE==1)
; 19693: 	if( (lpszGuildName == NULL) || (lpszGuildMaster == NULL) )

  00016	85 c9		 test	 ecx, ecx
  00018	0f 84 65 01 00
	00		 je	 $LN2@GCAnsCastl
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 5d 01 00
	00		 je	 $LN2@GCAnsCastl

; 19694: 	{
; 19695: 		return;
; 19696: 	}
; 19697: 
; 19698: 	PMSG_ANS_CASTLESIEGESTATE pMsgResult;
; 19699: 
; 19700: 
; 19701: 	pMsgResult.h.set((LPBYTE)&pMsgResult.h, 0xB2, 0x00, sizeof(pMsgResult));
; 19702: 
; 19703: 	pMsgResult.btResult = iResult;

  00026	8a 55 0c	 mov	 dl, BYTE PTR _iResult$[ebp]
  00029	88 55 d0	 mov	 BYTE PTR _pMsgResult$[ebp+4], dl

; 19704: 
; 19705: 	memcpy(pMsgResult.cOwnerGuild, lpszGuildName, sizeof(pMsgResult.cOwnerGuild));

  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00031	89 55 e4	 mov	 DWORD PTR _pMsgResult$[ebp+24], edx

; 19706: 	memcpy(pMsgResult.cOwnerGuildMaster, lpszGuildMaster, sizeof(pMsgResult.cOwnerGuildMaster));

  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 4d e8	 mov	 DWORD PTR _pMsgResult$[ebp+28], ecx
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 55 ec	 mov	 DWORD PTR _pMsgResult$[ebp+32], edx
  0003f	66 8b 50 08	 mov	 dx, WORD PTR [eax+8]

; 19707: 
; 19708: 	SYSTEMTIME tmStateStartDate = {0};

  00043	33 c0		 xor	 eax, eax
  00045	89 4d f0	 mov	 DWORD PTR _pMsgResult$[ebp+36], ecx

; 19709: 	SYSTEMTIME tmStateEndDate = {0};

  00048	33 c9		 xor	 ecx, ecx
  0004a	53		 push	 ebx
  0004b	66 89 45 ac	 mov	 WORD PTR _tmStateStartDate$[ebp], ax
  0004f	89 45 ae	 mov	 DWORD PTR _tmStateStartDate$[ebp+2], eax
  00052	89 45 b2	 mov	 DWORD PTR _tmStateStartDate$[ebp+6], eax
  00055	89 45 b6	 mov	 DWORD PTR _tmStateStartDate$[ebp+10], eax
  00058	66 89 45 ba	 mov	 WORD PTR _tmStateStartDate$[ebp+14], ax
  0005c	89 45 be	 mov	 DWORD PTR _tmStateEndDate$[ebp+2], eax
  0005f	89 45 c2	 mov	 DWORD PTR _tmStateEndDate$[ebp+6], eax
  00062	89 45 c6	 mov	 DWORD PTR _tmStateEndDate$[ebp+10], eax
  00065	66 89 45 ca	 mov	 WORD PTR _tmStateEndDate$[ebp+14], ax
  00069	66 89 4d bc	 mov	 WORD PTR _tmStateEndDate$[ebp], cx

; 19710: 	SYSTEMTIME tmSiegeStartDate = {0};
; 19711: 
; 19712: 	int iCastleState = g_CastleSiege.GetCastleState();
; 19713: 	int bRETVAL = g_CastleSiege.GetCastleStateTerm(&tmStateStartDate, &tmStateEndDate);

  0006d	8d 45 bc	 lea	 eax, DWORD PTR _tmStateEndDate$[ebp]
  00070	50		 push	 eax
  00071	8d 4d ac	 lea	 ecx, DWORD PTR _tmStateStartDate$[ebp]
  00074	66 89 55 f4	 mov	 WORD PTR _pMsgResult$[ebp+40], dx
  00078	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40
  0007e	51		 push	 ecx
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00084	c7 45 cc c1 2e
	b2 00		 mov	 DWORD PTR _pMsgResult$[ebp], 11677377 ; 00b22ec1H
  0008b	89 55 a8	 mov	 DWORD PTR _iCastleState$[ebp], edx
  0008e	e8 00 00 00 00	 call	 ?GetCastleStateTerm@CCastleSiege@@QAEHPAU_SYSTEMTIME@@0@Z ; CCastleSiege::GetCastleStateTerm

; 19714: 	tmSiegeStartDate = g_CastleSiege.GetCastleLeftSiegeDate();

  00093	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+132
  00099	8b 1d 80 00 00
	00		 mov	 ebx, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+128
  0009f	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+136
  000a5	89 55 9c	 mov	 DWORD PTR _tmSiegeStartDate$[ebp+4], edx
  000a8	8b 15 8c 00 00
	00		 mov	 edx, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+140
  000ae	89 5d 98	 mov	 DWORD PTR _tmSiegeStartDate$[ebp], ebx
  000b1	89 4d a0	 mov	 DWORD PTR _tmSiegeStartDate$[ebp+8], ecx
  000b4	89 55 a4	 mov	 DWORD PTR _tmSiegeStartDate$[ebp+12], edx

; 19715: 
; 19716: 	if( bRETVAL == FALSE )

  000b7	85 c0		 test	 eax, eax
  000b9	75 07		 jne	 SHORT $LN1@GCAnsCastl

; 19717: 	{
; 19718: 		iCastleState = -1;

  000bb	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR _iCastleState$[ebp], -1
$LN1@GCAnsCastl:

; 19719: 	}
; 19720: 
; 19721: 	int iStateLeftSec = g_CastleSiege.GetCurRemainSec();

  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000c7	e8 00 00 00 00	 call	 ?GetCurRemainSec@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCurRemainSec

; 19722: 
; 19723: 	// Create Packet
; 19724: 	pMsgResult.cCastleSiegeState = iCastleState;

  000cc	0f b6 4d a8	 movzx	 ecx, BYTE PTR _iCastleState$[ebp]

; 19725: 	// Start Date
; 19726: 	pMsgResult.btStartYearH = SET_NUMBERH(tmStateStartDate.wYear);

  000d0	8b 55 ac	 mov	 edx, DWORD PTR _tmStateStartDate$[ebp]
  000d3	88 4d d1	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl

; 19727: 	pMsgResult.btStartYearL = SET_NUMBERL(tmStateStartDate.wYear);

  000d6	0f b6 4d ac	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp]
  000da	c1 ea 08	 shr	 edx, 8
  000dd	88 55 d2	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl

; 19728: 	pMsgResult.btStartMonth = tmStateStartDate.wMonth;

  000e0	0f b6 55 ae	 movzx	 edx, BYTE PTR _tmStateStartDate$[ebp+2]
  000e4	88 4d d3	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl

; 19729: 	pMsgResult.btStartDay   = tmStateStartDate.wDay;

  000e7	0f b6 4d b2	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp+6]
  000eb	88 55 d4	 mov	 BYTE PTR _pMsgResult$[ebp+8], dl

; 19730: 	pMsgResult.btStartHour  = tmStateStartDate.wHour;

  000ee	0f b6 55 b4	 movzx	 edx, BYTE PTR _tmStateStartDate$[ebp+8]
  000f2	88 4d d5	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl

; 19731: 	pMsgResult.btStartMinute= tmStateStartDate.wMinute;

  000f5	0f b6 4d b6	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp+10]
  000f9	88 55 d6	 mov	 BYTE PTR _pMsgResult$[ebp+10], dl

; 19732: 	// End Date
; 19733: 	pMsgResult.btEndYearH = SET_NUMBERH(tmStateEndDate.wYear);

  000fc	8b 55 bc	 mov	 edx, DWORD PTR _tmStateEndDate$[ebp]
  000ff	88 4d d7	 mov	 BYTE PTR _pMsgResult$[ebp+11], cl

; 19734: 	pMsgResult.btEndYearL = SET_NUMBERL(tmStateEndDate.wYear);

  00102	0f b6 4d bc	 movzx	 ecx, BYTE PTR _tmStateEndDate$[ebp]
  00106	c1 ea 08	 shr	 edx, 8
  00109	88 55 d8	 mov	 BYTE PTR _pMsgResult$[ebp+12], dl

; 19735: 	pMsgResult.btEndMonth = tmStateEndDate.wMonth;

  0010c	0f b6 55 be	 movzx	 edx, BYTE PTR _tmStateEndDate$[ebp+2]
  00110	88 4d d9	 mov	 BYTE PTR _pMsgResult$[ebp+13], cl

; 19736: 	pMsgResult.btEndDay   = tmStateEndDate.wDay;

  00113	0f b6 4d c2	 movzx	 ecx, BYTE PTR _tmStateEndDate$[ebp+6]
  00117	88 55 da	 mov	 BYTE PTR _pMsgResult$[ebp+14], dl

; 19737: 	pMsgResult.btEndHour  = tmStateEndDate.wHour;

  0011a	0f b6 55 c4	 movzx	 edx, BYTE PTR _tmStateEndDate$[ebp+8]
  0011e	88 4d db	 mov	 BYTE PTR _pMsgResult$[ebp+15], cl

; 19738: 	pMsgResult.btEndMinute= tmStateEndDate.wMinute;

  00121	0f b6 4d c6	 movzx	 ecx, BYTE PTR _tmStateEndDate$[ebp+10]
  00125	88 55 dc	 mov	 BYTE PTR _pMsgResult$[ebp+16], dl
  00128	88 4d dd	 mov	 BYTE PTR _pMsgResult$[ebp+17], cl

; 19739: 	// Siege Start Date
; 19740: 	pMsgResult.btSiegeStartYearH = SET_NUMBERH(tmSiegeStartDate.wYear);
; 19741: 	pMsgResult.btSiegeStartYearL = SET_NUMBERL(tmSiegeStartDate.wYear);
; 19742: 	pMsgResult.btSiegeStartMonth = tmSiegeStartDate.wMonth;

  0012b	0f b6 4d 9a	 movzx	 ecx, BYTE PTR _tmSiegeStartDate$[ebp+2]
  0012f	88 4d e0	 mov	 BYTE PTR _pMsgResult$[ebp+20], cl

; 19743: 	pMsgResult.btSiegeStartDay   = tmSiegeStartDate.wDay;
; 19744: 	pMsgResult.btSiegeStartHour  = tmSiegeStartDate.wHour;

  00132	0f b6 4d a0	 movzx	 ecx, BYTE PTR _tmSiegeStartDate$[ebp+8]
  00136	8b d3		 mov	 edx, ebx
  00138	c1 ea 08	 shr	 edx, 8
  0013b	88 55 de	 mov	 BYTE PTR _pMsgResult$[ebp+18], dl
  0013e	0f b6 55 9e	 movzx	 edx, BYTE PTR _tmSiegeStartDate$[ebp+6]
  00142	88 55 e1	 mov	 BYTE PTR _pMsgResult$[ebp+21], dl

; 19745: 	pMsgResult.btSiegeStartMinute= tmSiegeStartDate.wMinute;

  00145	0f b6 55 a2	 movzx	 edx, BYTE PTR _tmSiegeStartDate$[ebp+10]
  00149	88 4d e2	 mov	 BYTE PTR _pMsgResult$[ebp+22], cl

; 19746: 	// Time Left
; 19747: 	pMsgResult.btStateLeftSec1 = SET_NUMBERH(SET_NUMBERHW(iStateLeftSec));

  0014c	8b c8		 mov	 ecx, eax
  0014e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00151	88 55 e3	 mov	 BYTE PTR _pMsgResult$[ebp+23], dl
  00154	8b d1		 mov	 edx, ecx
  00156	c1 ea 08	 shr	 edx, 8

; 19748: 	pMsgResult.btStateLeftSec2 = SET_NUMBERL(SET_NUMBERHW(iStateLeftSec));

  00159	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+43], cl
  0015c	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+42], dl

; 19749: 	pMsgResult.btStateLeftSec3 = SET_NUMBERH(SET_NUMBERLW(iStateLeftSec));
; 19750: 	pMsgResult.btStateLeftSec4 = SET_NUMBERL(SET_NUMBERLW(iStateLeftSec));
; 19751: 
; 19752: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0015f	0f b6 55 cd	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00163	8b c8		 mov	 ecx, eax
  00165	c1 e9 08	 shr	 ecx, 8
  00168	88 45 f9	 mov	 BYTE PTR _pMsgResult$[ebp+45], al
  0016b	52		 push	 edx
  0016c	8d 45 cc	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0016f	88 4d f8	 mov	 BYTE PTR _pMsgResult$[ebp+44], cl
  00172	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00175	50		 push	 eax
  00176	51		 push	 ecx
  00177	88 5d df	 mov	 BYTE PTR _pMsgResult$[ebp+19], bl
  0017a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	5b		 pop	 ebx
$LN2@GCAnsCastl:

; 19753: //#endif
; 19754: }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
?GCAnsCastleSiegeState@@YAXHHPAD0@Z ENDP		; GCAnsCastleSiegeState
_TEXT	ENDS
PUBLIC	??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsRegCastleSiege@@YAXHHPAD@Z		; GCAnsRegCastleSiege
;	COMDAT ??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@ DB '['
	DB	'CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Re'
	DB	'sult:%d', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?GCAnsRegCastleSiege@@YAXHHPAD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
?GCAnsRegCastleSiege@@YAXHHPAD@Z PROC			; GCAnsRegCastleSiege, COMDAT

; 19786: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 19787: //#if(GS_CASTLE==1)
; 19788: 	PMSG_ANS_REGCASTLESIEGE pMsgResult;
; 19789: 
; 19790: 	if( lpszGuildName == NULL )

  00017	85 c0		 test	 eax, eax
  00019	74 73		 je	 SHORT $LN1@GCAnsRegCa

; 19791: 	{
; 19792: 		return;
; 19793: 	}
; 19794: 
; 19795: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  0001b	85 f6		 test	 esi, esi
  0001d	78 6f		 js	 SHORT $LN1@GCAnsRegCa
  0001f	33 c9		 xor	 ecx, ecx
  00021	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00027	0f 9e c1	 setle	 cl
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 60		 je	 SHORT $LN1@GCAnsRegCa

; 19796: 	{
; 19797: 		return;
; 19798: 	}
; 19799: 
; 19800: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x01, sizeof(pMsgResult));
; 19801: 	pMsgResult.btResult = iResult;
; 19802: 	memcpy(&pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00033	53		 push	 ebx
  00034	8b 5d 0c	 mov	 ebx, DWORD PTR _iResult$[ebp]

; 19803: 
; 19804: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00037	6a 0d		 push	 13			; 0000000dH
  00039	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	c7 45 ec c1 0d
	b2 01		 mov	 DWORD PTR _pMsgResult$[ebp], 28446145 ; 01b20dc1H
  00045	88 5d f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl
  00048	89 4d f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], ecx
  0004b	89 55 f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], edx
  0004e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19805: 
; 19806: 	if( ::gObjIsConnected(iIndex) )

  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	85 c0		 test	 eax, eax
  0005e	74 2d		 je	 SHORT $LN10@GCAnsRegCa

; 19807: 	{
; 19808: 		::LogAddTD("[CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Result:%d",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, iResult);

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0006c	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0006f	53		 push	 ebx
  00070	8d 90 3c 04 00
	00		 lea	 edx, DWORD PTR [eax+1084]
  00076	52		 push	 edx
  00077	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  0007a	51		 push	 ecx
  0007b	83 c0 6c	 add	 eax, 108		; 0000006cH
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008a	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@GCAnsRegCa:
  0008d	5b		 pop	 ebx
$LN1@GCAnsRegCa:

; 19809: 	}
; 19810: //#endif
; 19811: }

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	5e		 pop	 esi
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?GCAnsRegCastleSiege@@YAXHHPAD@Z ENDP			; GCAnsRegCastleSiege
_TEXT	ENDS
PUBLIC	??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z		; GCAnsGiveUpCastleSiege
;	COMDAT ??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@ DB '['
	DB	'CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result'
	DB	':%d', 00H					; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_bGiveUp$ = 16						; size = 4
_iMarkCount$ = 20					; size = 4
_lpszGuildName$ = 24					; size = 4
?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z PROC		; GCAnsGiveUpCastleSiege, COMDAT

; 19838: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 18	 mov	 eax, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 19839: //#if(GS_CASTLE==1)
; 19840: 	PMSG_ANS_GIVEUPCASTLESIEGE pMsgResult;
; 19841: 
; 19842: 	if( lpszGuildName == NULL )

  00017	85 c0		 test	 eax, eax
  00019	0f 84 dd 00 00
	00		 je	 $LN1@GCAnsGiveU

; 19843: 	{
; 19844: 		return;
; 19845: 	}
; 19846: 
; 19847: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  0001f	85 f6		 test	 esi, esi
  00021	0f 88 d5 00 00
	00		 js	 $LN1@GCAnsGiveU
  00027	33 c9		 xor	 ecx, ecx
  00029	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0002f	0f 9e c1	 setle	 cl
  00032	85 c9		 test	 ecx, ecx
  00034	0f 84 c2 00 00
	00		 je	 $LN1@GCAnsGiveU

; 19848: 	{
; 19849: 		return;
; 19850: 	}
; 19851: 
; 19852: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x02, sizeof(pMsgResult));
; 19853: 	pMsgResult.btResult = iResult;
; 19854: 	pMsgResult.btIsGiveUp = bGiveUp;
; 19855: 
; 19856: 	memcpy(&pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

  0003a	8b 10		 mov	 edx, DWORD PTR [eax]
  0003c	8a 4d 10	 mov	 cl, BYTE PTR _bGiveUp$[ebp]
  0003f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00042	53		 push	 ebx
  00043	8b 5d 0c	 mov	 ebx, DWORD PTR _iResult$[ebp]
  00046	c7 45 ec c1 0e
	b2 02		 mov	 DWORD PTR _pMsgResult$[ebp], 45223617 ; 02b20ec1H
  0004d	88 5d f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl
  00050	88 4d f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00053	89 55 f2	 mov	 DWORD PTR _pMsgResult$[ebp+6], edx
  00056	89 45 f6	 mov	 DWORD PTR _pMsgResult$[ebp+10], eax

; 19857: 
; 19858: 	if( (pMsgResult.btResult == 1) && (iMarkCount > 0) )

  00059	80 fb 01	 cmp	 bl, 1
  0005c	75 54		 jne	 SHORT $LN3@GCAnsGiveU
  0005e	8b 4d 14	 mov	 ecx, DWORD PTR _iMarkCount$[ebp]
  00061	85 c9		 test	 ecx, ecx
  00063	7e 4d		 jle	 SHORT $LN3@GCAnsGiveU

; 19859: 	{
; 19860: 		gObj[iIndex].Money += (iMarkCount*3000);

  00065	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	69 c9 b8 0b 00
	00		 imul	 ecx, 3000		; 00000bb8H
  00071	8b c6		 mov	 eax, esi
  00073	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00079	01 8c 10 f0 00
	00 00		 add	 DWORD PTR [eax+edx+240], ecx

; 19861: 
; 19862: 		if( gObj[iIndex].Money > MAX_ZEN ) 

  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	ba 00 94 35 77	 mov	 edx, 2000000000		; 77359400H
  0008b	39 94 08 f0 00
	00 00		 cmp	 DWORD PTR [eax+ecx+240], edx
  00092	7e 0d		 jle	 SHORT $LN2@GCAnsGiveU

; 19863: 		{
; 19864: 			gObj[iIndex].Money = MAX_ZEN;

  00094	89 94 08 f0 00
	00 00		 mov	 DWORD PTR [eax+ecx+240], edx
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@GCAnsGiveU:

; 19865: 		}
; 19866: 		GCMoneySend(iIndex, gObj[iIndex].Money);

  000a1	8b 8c 08 f0 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+240]
  000a8	51		 push	 ecx
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000af	83 c4 08	 add	 esp, 8
$LN3@GCAnsGiveU:

; 19867: 	}
; 19868: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  000b2	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  000b6	52		 push	 edx
  000b7	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  000ba	50		 push	 eax
  000bb	56		 push	 esi
  000bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19869: 
; 19870: 	if( gObjIsConnected(iIndex) )

  000c1	56		 push	 esi
  000c2	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
  000ca	85 c0		 test	 eax, eax
  000cc	74 2d		 je	 SHORT $LN12@GCAnsGiveU

; 19871: 	{
; 19872: 		LogAddTD("[CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result:%d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, iResult);

  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000da	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  000dd	53		 push	 ebx
  000de	8d 90 3c 04 00
	00		 lea	 edx, DWORD PTR [eax+1084]
  000e4	52		 push	 edx
  000e5	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  000e8	51		 push	 ecx
  000e9	83 c0 6c	 add	 eax, 108		; 0000006cH
  000ec	50		 push	 eax
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f8	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@GCAnsGiveU:
  000fb	5b		 pop	 ebx
$LN1@GCAnsGiveU:

; 19873: 	}
; 19874: //#endif
; 19875: }

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	33 cd		 xor	 ecx, ebp
  00101	5e		 pop	 esi
  00102	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z ENDP		; GCAnsGiveUpCastleSiege
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ; CGReqGuildRegInfo
EXTRN	?GS_GDReqGuildMarkRegInfo@@YAXHH@Z:PROC		; GS_GDReqGuildMarkRegInfo
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z PROC ; CGReqGuildRegInfo, COMDAT

; 19881: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19882: //#if (GS_CASTLE==1)
; 19883: 	if( lpMsg == NULL )

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 6f		 je	 SHORT $LN3@CGReqGuild

; 19884: 	{
; 19885: 		return;
; 19886: 	}
; 19887: 
; 19888: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00013	8b c6		 mov	 eax, esi
  00015	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00020	8d 84 10 3c 04
	00 00		 lea	 eax, DWORD PTR [eax+edx+1084]
$LL8@CGReqGuild:
  00027	8a 10		 mov	 dl, BYTE PTR [eax]
  00029	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0002b	75 1a		 jne	 SHORT $LN9@CGReqGuild
  0002d	84 d2		 test	 dl, dl
  0002f	74 12		 je	 SHORT $LN10@CGReqGuild
  00031	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00034	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00037	75 0e		 jne	 SHORT $LN9@CGReqGuild
  00039	83 c0 02	 add	 eax, 2
  0003c	83 c1 02	 add	 ecx, 2
  0003f	84 d2		 test	 dl, dl
  00041	75 e4		 jne	 SHORT $LL8@CGReqGuild
$LN10@CGReqGuild:
  00043	33 c0		 xor	 eax, eax
  00045	eb 05		 jmp	 SHORT $LN11@CGReqGuild
$LN9@CGReqGuild:
  00047	1b c0		 sbb	 eax, eax
  00049	83 d8 ff	 sbb	 eax, -1
$LN11@CGReqGuild:
  0004c	85 c0		 test	 eax, eax
  0004e	74 27		 je	 SHORT $LN12@CGReqGuild

; 19889: 	{
; 19890: 		return;
; 19891: 	}
; 19892: 
; 19893: 	GS_GDReqGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(), iIndex);

  00050	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  00055	85 c0		 test	 eax, eax
  00057	74 11		 je	 SHORT $LN5@CGReqGuild
  00059	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0005d	56		 push	 esi
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqGuildMarkRegInfo
  00064	83 c4 08	 add	 esp, 8
  00067	5e		 pop	 esi

; 19894: //#endif
; 19895: }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0

; 19889: 	{
; 19890: 		return;
; 19891: 	}
; 19892: 
; 19893: 	GS_GDReqGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(), iIndex);

$LN5@CGReqGuild:
  0006a	83 c8 ff	 or	 eax, -1
  0006d	56		 push	 esi
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqGuildMarkRegInfo
  00074	83 c4 08	 add	 esp, 8
$LN12@CGReqGuild:
  00077	5e		 pop	 esi
$LN3@CGReqGuild:

; 19894: //#endif
; 19895: }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ENDP ; CGReqGuildRegInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ; GCAnsGuildRegInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z
_TEXT	SEGMENT
_pMsgResult$ = -24					; size = 19
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpMsgResult$ = 16					; size = 4
?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z PROC ; GCAnsGuildRegInfo, COMDAT

; 19900: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _lpMsgResult$[ebp]

; 19901: //#if (GS_CASTLE==1)
; 19902: 	PMSG_ANS_GUILDREGINFO pMsgResult;
; 19903: 
; 19904: 	if( lpMsgResult == NULL )

  00013	85 c0		 test	 eax, eax
  00015	74 6b		 je	 SHORT $LN3@GCAnsGuild

; 19905: 	{
; 19906: 		return;
; 19907: 	}
; 19908: 
; 19909: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	85 f6		 test	 esi, esi
  0001d	78 62		 js	 SHORT $LN9@GCAnsGuild
  0001f	33 c9		 xor	 ecx, ecx
  00021	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00027	0f 9e c1	 setle	 cl
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 53		 je	 SHORT $LN9@GCAnsGuild

; 19910: 	{
; 19911: 		return;
; 19912: 	}
; 19913: 
; 19914: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 3, sizeof(pMsgResult));
; 19915: 
; 19916: 	pMsgResult.btResult = iResult;

  0002e	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  00031	88 4d ec	 mov	 BYTE PTR _pMsgResult$[ebp+4], cl

; 19917: 	pMsgResult.btGuildMark1 = SET_NUMBERH(SET_NUMBERHW(lpMsgResult->iRegMarkCount));

  00034	0f b7 48 1a	 movzx	 ecx, WORD PTR [eax+26]
  00038	8b d1		 mov	 edx, ecx
  0003a	c1 ea 08	 shr	 edx, 8
  0003d	88 55 f5	 mov	 BYTE PTR _pMsgResult$[ebp+13], dl

; 19918: 	pMsgResult.btGuildMark2 = SET_NUMBERL(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
; 19919: 	pMsgResult.btGuildMark3 = SET_NUMBERH(SET_NUMBERLW(lpMsgResult->iRegMarkCount));
; 19920: 	pMsgResult.btGuildMark4 = SET_NUMBERL(SET_NUMBERLW(lpMsgResult->iRegMarkCount));

  00040	0f b6 50 18	 movzx	 edx, BYTE PTR [eax+24]
  00044	88 4d f6	 mov	 BYTE PTR _pMsgResult$[ebp+14], cl
  00047	0f b6 48 19	 movzx	 ecx, BYTE PTR [eax+25]
  0004b	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+15], cl

; 19921: 	pMsgResult.btRegRank = lpMsgResult->btRegRank;

  0004e	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  00052	88 55 f8	 mov	 BYTE PTR _pMsgResult$[ebp+16], dl

; 19922: 	pMsgResult.btIsGiveUp = lpMsgResult->bIsGiveUp;

  00055	0f b6 50 1c	 movzx	 edx, BYTE PTR [eax+28]
  00059	88 4d fa	 mov	 BYTE PTR _pMsgResult$[ebp+18], cl

; 19923: 	memcpy(&pMsgResult.szGuildName, lpMsgResult->szGuildName, sizeof(pMsgResult.szGuildName));

  0005c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005f	88 55 f9	 mov	 BYTE PTR _pMsgResult$[ebp+17], dl
  00062	8b 50 14	 mov	 edx, DWORD PTR [eax+20]

; 19924: 
; 19925: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00065	6a 13		 push	 19			; 00000013H
  00067	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0006a	50		 push	 eax
  0006b	56		 push	 esi
  0006c	c7 45 e8 c1 13
	b2 03		 mov	 DWORD PTR _pMsgResult$[ebp], 62002113 ; 03b213c1H
  00073	89 4d ed	 mov	 DWORD PTR _pMsgResult$[ebp+5], ecx
  00076	89 55 f1	 mov	 DWORD PTR _pMsgResult$[ebp+9], edx
  00079	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@GCAnsGuild:
  00081	5e		 pop	 esi
$LN3@GCAnsGuild:

; 19926: //#endif
; 19927: }

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ENDP ; GCAnsGuildRegInfo
_TEXT	ENDS
PUBLIC	_iIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ; CGReqRegGuildMark
EXTRN	?GS_GDReqRegGuildMark@@YAXHHH@Z:PROC		; GS_GDReqRegGuildMark
; Function compile flags: /Ogtp
;	COMDAT ?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -32					; size = 4
_iIndex$GSCopy$ = -28					; size = 4
_pMsgResult$251636 = -24				; size = 17
_pMsgResult$251630 = -24				; size = 17
_pMsgResult$251624 = -24				; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z PROC ; CGReqRegGuildMark, COMDAT

; 19930: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 19955: 	{
; 19956: 		gObj[iIndex].UseEventServer = FALSE;

  00017	89 45 e0	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax

; 19991: 			}
; 19992: 			else
; 19993: 			{
; 19994: 				GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(), iIndex, iItemPos);

  0001a	89 7d e4	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], edi
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 10 02 00
	00		 je	 $LN1@CGReqRegGu

; 19931: //#if (GS_CASTLE==1)
; 19932: 	if( lpMsg == NULL )
; 19933: 	{
; 19934: 		return;
; 19935: 	}
; 19936: 	
; 19937: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  00025	85 ff		 test	 edi, edi
  00027	0f 88 08 02 00
	00		 js	 $LN1@CGReqRegGu
  0002d	33 c0		 xor	 eax, eax
  0002f	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00035	0f 9e c0	 setle	 al
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 f5 01 00
	00		 je	 $LN1@CGReqRegGu

; 19938: 	{
; 19939: 		return;
; 19940: 	}
; 19941: 	
; 19942: 	if( gObj[iIndex].UseEventServer == TRUE )

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	56		 push	 esi
  00046	8b f7		 mov	 esi, edi
  00048	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	39 8c 06 50 10
	00 00		 cmp	 DWORD PTR [esi+eax+4176], ecx
  0005a	0f 84 d4 01 00
	00		 je	 $LN34@CGReqRegGu

; 19943: 	{
; 19944: 		return;
; 19945: 	}
; 19946: 
; 19947: 	gObj[iIndex].UseEventServer = TRUE;

  00060	89 8c 06 50 10
	00 00		 mov	 DWORD PTR [esi+eax+4176], ecx

; 19948: 
; 19949: 	if( g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGMARK )

  00067	83 3d 28 00 00
	00 03		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 3
  0006e	74 20		 je	 SHORT $LN9@CGReqRegGu

; 19950: 	{
; 19951: 		gObj[iIndex].UseEventServer = FALSE;

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	c7 84 06 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+4176], 0
  00080	5e		 pop	 esi
  00081	5f		 pop	 edi

; 19995: 			}
; 19996: 		}
; 19997: 	}
; 19998: //#endif
; 19999: }

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN9@CGReqRegGu:
  00090	53		 push	 ebx

; 19952: 		return;
; 19953: 	}
; 19954: 	if( strcmp( gObj[iIndex].GuildName, "") == 0)

  00091	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0009c	8d 84 1e 3c 04
	00 00		 lea	 eax, DWORD PTR [esi+ebx+1084]
$LL30@CGReqRegGu:
  000a3	8a 10		 mov	 dl, BYTE PTR [eax]
  000a5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000a7	75 1a		 jne	 SHORT $LN31@CGReqRegGu
  000a9	84 d2		 test	 dl, dl
  000ab	74 12		 je	 SHORT $LN32@CGReqRegGu
  000ad	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b3	75 0e		 jne	 SHORT $LN31@CGReqRegGu
  000b5	83 c0 02	 add	 eax, 2
  000b8	83 c1 02	 add	 ecx, 2
  000bb	84 d2		 test	 dl, dl
  000bd	75 e4		 jne	 SHORT $LL30@CGReqRegGu
$LN32@CGReqRegGu:
  000bf	33 c0		 xor	 eax, eax
  000c1	eb 05		 jmp	 SHORT $LN33@CGReqRegGu
$LN31@CGReqRegGu:
  000c3	1b c0		 sbb	 eax, eax
  000c5	83 d8 ff	 sbb	 eax, -1
$LN33@CGReqRegGu:
  000c8	85 c0		 test	 eax, eax
  000ca	75 18		 jne	 SHORT $LN8@CGReqRegGu

; 19955: 	{
; 19956: 		gObj[iIndex].UseEventServer = FALSE;

  000cc	89 84 1e 50 10
	00 00		 mov	 DWORD PTR [esi+ebx+4176], eax
  000d3	5b		 pop	 ebx
  000d4	5e		 pop	 esi
  000d5	5f		 pop	 edi

; 19995: 			}
; 19996: 		}
; 19997: 	}
; 19998: //#endif
; 19999: }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN8@CGReqRegGu:

; 19957: 		return;
; 19958: 	}
; 19959: 	
; 19960: 	if( CHECK_LIMIT(lpMsg->btItemPos, 64) == FALSE )

  000e4	8b 4d e0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  000e7	8a 49 04	 mov	 cl, BYTE PTR [ecx+4]
  000ea	b2 3f		 mov	 dl, 63			; 0000003fH
  000ec	3a d1		 cmp	 dl, cl
  000ee	1b c0		 sbb	 eax, eax
  000f0	40		 inc	 eax
  000f1	75 18		 jne	 SHORT $LN7@CGReqRegGu

; 19961: 	{
; 19962: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  000f3	89 45 e9	 mov	 DWORD PTR _pMsgResult$251624[ebp+1], eax
  000f6	89 45 ed	 mov	 DWORD PTR _pMsgResult$251624[ebp+5], eax
  000f9	89 45 f1	 mov	 DWORD PTR _pMsgResult$251624[ebp+9], eax
  000fc	89 45 f5	 mov	 DWORD PTR _pMsgResult$251624[ebp+13], eax

; 19963: 		pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x04, sizeof(pMsgResult));
; 19964: 		pMsgResult.btResult = 3;		
; 19965: 		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  000ff	6a 11		 push	 17			; 00000011H
  00101	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$251624[ebp]
  00104	50		 push	 eax
  00105	57		 push	 edi

; 19966: 		gObj[iIndex].UseEventServer = FALSE;
; 19967: 	}
; 19968: 	else

  00106	e9 04 01 00 00	 jmp	 $LN36@CGReqRegGu
$LN7@CGReqRegGu:

; 19969: 	{
; 19970: 		int iItemPos = (lpMsg->btItemPos + 12);
; 19971: 
; 19972: 		if( gObj[iIndex].pInventory[iItemPos].IsItem() == FALSE )

  0010b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	0f b6 d9	 movzx	 ebx, cl
  00114	8b 8c 16 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+edx+3620]
  0011b	83 c3 0c	 add	 ebx, 12			; 0000000cH
  0011e	8b fb		 mov	 edi, ebx
  00120	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  00126	03 cf		 add	 ecx, edi
  00128	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0012d	85 c0		 test	 eax, eax
  0012f	75 4b		 jne	 SHORT $LN5@CGReqRegGu

; 19973: 		{
; 19974: 			PMSG_ANS_REGGUILDMARK pMsgResult = {0};
; 19975: 			pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x04, sizeof(pMsgResult));
; 19976: 			pMsgResult.btResult = 3;		
; 19977: 			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00131	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  00134	89 45 e9	 mov	 DWORD PTR _pMsgResult$251630[ebp+1], eax
  00137	89 45 ed	 mov	 DWORD PTR _pMsgResult$251630[ebp+5], eax
  0013a	89 45 f1	 mov	 DWORD PTR _pMsgResult$251630[ebp+9], eax
  0013d	89 45 f5	 mov	 DWORD PTR _pMsgResult$251630[ebp+13], eax
  00140	6a 11		 push	 17			; 00000011H
  00142	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$251630[ebp]
  00145	50		 push	 eax
  00146	51		 push	 ecx
  00147	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$251630[ebp], 78778817 ; 04b211c1H
  0014e	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$251630[ebp+4], 3
  00152	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19978: 			gObj[iIndex].UseEventServer = FALSE;

  00157	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19989: 				DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	5b		 pop	 ebx
  00161	c7 84 16 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+4176], 0
  0016c	5e		 pop	 esi
  0016d	5f		 pop	 edi

; 19995: 			}
; 19996: 		}
; 19997: 	}
; 19998: //#endif
; 19999: }

  0016e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00171	33 cd		 xor	 ecx, ebp
  00173	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
$LN5@CGReqRegGu:

; 19979: 		}
; 19980: 		else
; 19981: 		{
; 19982: 			if( gObj[iIndex].pInventory[iItemPos].m_Type != ITEMGET(14,21) || 
; 19983: 				gObj[iIndex].pInventory[iItemPos].m_Level != 3 || 
; 19984: 				gObj[iIndex].pInventory[iItemPos].m_Durability <= 0.0f )

  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00181	8b 84 06 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+eax+3620]
  00188	ba 15 1c 00 00	 mov	 edx, 7189		; 00001c15H
  0018d	66 39 54 38 06	 cmp	 WORD PTR [eax+edi+6], dx
  00192	75 63		 jne	 SHORT $LN2@CGReqRegGu
  00194	66 83 7c 38 08
	03		 cmp	 WORD PTR [eax+edi+8], 3
  0019a	75 5b		 jne	 SHORT $LN2@CGReqRegGu
  0019c	d9 ee		 fldz
  0019e	d8 5c 38 24	 fcomp	 DWORD PTR [eax+edi+36]
  001a2	df e0		 fnstsw	 ax
  001a4	f6 c4 01	 test	 ah, 1
  001a7	74 4e		 je	 SHORT $LN2@CGReqRegGu

; 19991: 			}
; 19992: 			else
; 19993: 			{
; 19994: 				GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(), iIndex, iItemPos);

  001a9	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  001ae	85 c0		 test	 eax, eax
  001b0	74 23		 je	 SHORT $LN27@CGReqRegGu
  001b2	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  001b6	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  001b9	53		 push	 ebx
  001ba	51		 push	 ecx
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ?GS_GDReqRegGuildMark@@YAXHHH@Z ; GS_GDReqRegGuildMark
  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c4	5b		 pop	 ebx
  001c5	5e		 pop	 esi
  001c6	5f		 pop	 edi

; 19995: 			}
; 19996: 		}
; 19997: 	}
; 19998: //#endif
; 19999: }

  001c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ca	33 cd		 xor	 ecx, ebp
  001cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c3		 ret	 0

; 19991: 			}
; 19992: 			else
; 19993: 			{
; 19994: 				GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(), iIndex, iItemPos);

$LN27@CGReqRegGu:
  001d5	8b 4d e4	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  001d8	53		 push	 ebx
  001d9	83 c8 ff	 or	 eax, -1
  001dc	51		 push	 ecx
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ?GS_GDReqRegGuildMark@@YAXHHH@Z ; GS_GDReqRegGuildMark
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e6	5b		 pop	 ebx
  001e7	5e		 pop	 esi
  001e8	5f		 pop	 edi

; 19995: 			}
; 19996: 		}
; 19997: 	}
; 19998: //#endif
; 19999: }

  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
$LN2@CGReqRegGu:

; 19985: 			{
; 19986: 				PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  001f7	33 c0		 xor	 eax, eax

; 19989: 				DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  001f9	6a 11		 push	 17			; 00000011H
  001fb	8d 55 e8	 lea	 edx, DWORD PTR _pMsgResult$251636[ebp]
  001fe	89 45 e9	 mov	 DWORD PTR _pMsgResult$251636[ebp+1], eax
  00201	89 45 ed	 mov	 DWORD PTR _pMsgResult$251636[ebp+5], eax
  00204	89 45 f1	 mov	 DWORD PTR _pMsgResult$251636[ebp+9], eax
  00207	89 45 f5	 mov	 DWORD PTR _pMsgResult$251636[ebp+13], eax
  0020a	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  0020d	52		 push	 edx
  0020e	50		 push	 eax
$LN36@CGReqRegGu:

; 19987: 				pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x04, sizeof(pMsgResult));
; 19988: 				pMsgResult.btResult = 3;		

  0020f	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$251636[ebp], 78778817 ; 04b211c1H
  00216	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$251636[ebp+4], 3

; 19989: 				DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0021a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19990: 				gObj[iIndex].UseEventServer = FALSE;

  0021f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00225	83 c4 0c	 add	 esp, 12			; 0000000cH
  00228	c7 84 0e 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+4176], 0
  00233	5b		 pop	 ebx
$LN34@CGReqRegGu:
  00234	5e		 pop	 esi
$LN1@CGReqRegGu:

; 19995: 			}
; 19996: 		}
; 19997: 	}
; 19998: //#endif
; 19999: }

  00235	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00238	33 cd		 xor	 ecx, ebp
  0023a	5f		 pop	 edi
  0023b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c3		 ret	 0
?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ENDP ; CGReqRegGuildMark
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ; GCAnsRegGuildMark
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z
_TEXT	SEGMENT
tv376 = -32						; size = 4
tv373 = -32						; size = 4
tv363 = -28						; size = 4
tv379 = -26						; size = 2
_pMsgResult$251663 = -24				; size = 17
_pMsgResult$251655 = -24				; size = 17
_pMsgResult$251648 = -24				; size = 17
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpMsgResult$ = 16					; size = 4
?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z PROC ; GCAnsRegGuildMark, COMDAT

; 20002: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _lpMsgResult$[ebp]

; 20003: //#if (GS_CASTLE==1)
; 20004: 	if( lpMsgResult == NULL )

  00018	85 f6		 test	 esi, esi
  0001a	0f 84 c0 01 00
	00		 je	 $LN3@GCAnsRegGu

; 20005: 	{
; 20006: 		return;
; 20007: 	}
; 20008: 
; 20009: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  00020	85 db		 test	 ebx, ebx
  00022	0f 88 b8 01 00
	00		 js	 $LN3@GCAnsRegGu
  00028	33 c0		 xor	 eax, eax
  0002a	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 a5 01 00
	00		 je	 $LN3@GCAnsRegGu

; 20010: 	{
; 20011: 		return;
; 20012: 	}
; 20013: 
; 20014: 	if( gObj[iIndex].pInventory[lpMsgResult->iItemPos].IsItem() == FALSE )

  0003b	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00049	57		 push	 edi
  0004a	8b fb		 mov	 edi, ebx
  0004c	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00052	03 8c 07 24 0e
	00 00		 add	 ecx, DWORD PTR [edi+eax+3620]
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	85 c0		 test	 eax, eax
  00060	75 48		 jne	 SHORT $LN8@GCAnsRegGu

; 20015: 	{	
; 20016: 		PMSG_ANS_REGGUILDMARK pMsgResult ={0};
; 20017: 		pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x04, sizeof(pMsgResult));
; 20018: 		pMsgResult.btResult = 3;
; 20019: 		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00062	6a 11		 push	 17			; 00000011H
  00064	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgResult$251648[ebp]
  00067	51		 push	 ecx
  00068	89 45 e9	 mov	 DWORD PTR _pMsgResult$251648[ebp+1], eax
  0006b	53		 push	 ebx
  0006c	89 45 ed	 mov	 DWORD PTR _pMsgResult$251648[ebp+5], eax
  0006f	89 45 f1	 mov	 DWORD PTR _pMsgResult$251648[ebp+9], eax
  00072	89 45 f5	 mov	 DWORD PTR _pMsgResult$251648[ebp+13], eax
  00075	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$251648[ebp], 78778817 ; 04b211c1H
  0007c	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$251648[ebp+4], 3
  00080	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20020: 		gObj[iIndex].UseEventServer = 0;

  00085	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20055: 			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	c7 84 17 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+edx+4176], 0
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 20057: 			
; 20058: 		}
; 20059: 	}
; 20060: //#endif
; 20061: }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN8@GCAnsRegGu:

; 20021: 	}
; 20022: 	else
; 20023: 	{
; 20024: 		if( gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Type != ITEMGET(14,21) && 
; 20025: 			gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Level == 3 || 
; 20026: 			gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability <= 0.0f ) 

  000aa	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b3	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000b9	03 84 0f 24 0e
	00 00		 add	 eax, DWORD PTR [edi+ecx+3620]
  000c0	ba 15 1c 00 00	 mov	 edx, 7189		; 00001c15H
  000c5	66 39 50 06	 cmp	 WORD PTR [eax+6], dx
  000c9	74 07		 je	 SHORT $LN21@GCAnsRegGu
  000cb	66 83 78 08 03	 cmp	 WORD PTR [eax+8], 3
  000d0	74 0e		 je	 SHORT $LN5@GCAnsRegGu
$LN21@GCAnsRegGu:
  000d2	d9 ee		 fldz
  000d4	d8 50 24	 fcom	 DWORD PTR [eax+36]
  000d7	df e0		 fnstsw	 ax
  000d9	f6 c4 01	 test	 ah, 1
  000dc	75 19		 jne	 SHORT $LN6@GCAnsRegGu
  000de	dd d8		 fstp	 ST(0)
$LN5@GCAnsRegGu:

; 20027: 		{
; 20028: 			PMSG_ANS_REGGUILDMARK pMsgResult = {0};

  000e0	33 c0		 xor	 eax, eax
  000e2	89 45 e9	 mov	 DWORD PTR _pMsgResult$251655[ebp+1], eax
  000e5	89 45 ed	 mov	 DWORD PTR _pMsgResult$251655[ebp+5], eax
  000e8	89 45 f1	 mov	 DWORD PTR _pMsgResult$251655[ebp+9], eax
  000eb	89 45 f5	 mov	 DWORD PTR _pMsgResult$251655[ebp+13], eax

; 20029: 			pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x04, sizeof(pMsgResult));
; 20030: 			pMsgResult.btResult = 3;

  000ee	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$251655[ebp+4], 3

; 20031: 			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
; 20032: 			gObj[iIndex].UseEventServer = FALSE;
; 20033: 		}
; 20034: 		else

  000f2	e9 c1 00 00 00	 jmp	 $LN26@GCAnsRegGu
$LN6@GCAnsRegGu:

; 20035: 		{
; 20036: 			if( (gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability -= 1.0) > 0.0f )

  000f7	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  000fa	8b 84 0f 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+ecx+3620]
  00101	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00107	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  0010b	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00111	d9 5d e4	 fstp	 DWORD PTR tv363[ebp]
  00114	d9 45 e4	 fld	 DWORD PTR tv363[ebp]
  00117	d9 54 02 24	 fst	 DWORD PTR [edx+eax+36]
  0011b	de d9		 fcompp

; 20037: 			{
; 20038: 				::GCItemDurSend(iIndex, (BYTE)lpMsgResult->iItemPos, (BYTE)gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability, 0);

  0011d	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00120	8d 44 02 24	 lea	 eax, DWORD PTR [edx+eax+36]
  00124	df e0		 fnstsw	 ax
  00126	f6 c4 41	 test	 ah, 65			; 00000041H
  00129	75 48		 jne	 SHORT $LN2@GCAnsRegGu
  0012b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00137	d9 7d e6	 fnstcw	 WORD PTR tv379[ebp]
  0013a	8b 84 17 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+edx+3620]
  00141	6a 00		 push	 0
  00143	d9 44 08 24	 fld	 DWORD PTR [eax+ecx+36]
  00147	0f b7 45 e6	 movzx	 eax, WORD PTR tv379[ebp]
  0014b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00150	89 45 e0	 mov	 DWORD PTR tv376[ebp], eax
  00153	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  00157	d9 6d e0	 fldcw	 WORD PTR tv376[ebp]
  0015a	db 5d e0	 fistp	 DWORD PTR tv373[ebp]
  0015d	8a 4d e0	 mov	 cl, BYTE PTR tv373[ebp]
  00160	0f b6 d1	 movzx	 edx, cl
  00163	52		 push	 edx
  00164	d9 6d e6	 fldcw	 WORD PTR tv379[ebp]
  00167	50		 push	 eax
  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0016e	83 c4 10	 add	 esp, 16			; 00000010H

; 20039: 			}
; 20040: 			else

  00171	eb 17		 jmp	 SHORT $LN1@GCAnsRegGu
$LN2@GCAnsRegGu:

; 20041: 			{
; 20042: 				gObjInventoryDeleteItem(iIndex, lpMsgResult->iItemPos);

  00173	51		 push	 ecx
  00174	53		 push	 ebx
  00175	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 20043: 				GCInventoryItemDeleteSend(iIndex,lpMsgResult->iItemPos,1);

  0017a	0f b6 56 18	 movzx	 edx, BYTE PTR [esi+24]
  0017e	6a 01		 push	 1
  00180	52		 push	 edx
  00181	53		 push	 ebx
  00182	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00187	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@GCAnsRegGu:

; 20044: 			}
; 20045: 			
; 20046: 			PMSG_ANS_REGGUILDMARK pMsgResult;
; 20047: 			pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x04, sizeof(pMsgResult));
; 20048: 			
; 20049: 			pMsgResult.btResult = iResult;

  0018a	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 20050: 			pMsgResult.btGuildMark1 = SET_NUMBERH(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
; 20051: 			pMsgResult.btGuildMark2 = SET_NUMBERL(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
; 20052: 			pMsgResult.btGuildMark3 = SET_NUMBERH(SET_NUMBERLW(lpMsgResult->iRegMarkCount));

  0018d	8a 56 1d	 mov	 dl, BYTE PTR [esi+29]
  00190	88 45 ec	 mov	 BYTE PTR _pMsgResult$251663[ebp+4], al
  00193	0f b7 46 1e	 movzx	 eax, WORD PTR [esi+30]
  00197	8b c8		 mov	 ecx, eax
  00199	c1 e9 08	 shr	 ecx, 8
  0019c	88 45 f6	 mov	 BYTE PTR _pMsgResult$251663[ebp+14], al

; 20053: 			pMsgResult.btGuildMark4 = SET_NUMBERL(SET_NUMBERLW(lpMsgResult->iRegMarkCount));

  0019f	0f b6 46 1c	 movzx	 eax, BYTE PTR [esi+28]
  001a3	88 4d f5	 mov	 BYTE PTR _pMsgResult$251663[ebp+13], cl

; 20054: 			memcpy(&pMsgResult.szGuildName, lpMsgResult->szGuildName, sizeof(pMsgResult.szGuildName));

  001a6	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  001a9	88 55 f7	 mov	 BYTE PTR _pMsgResult$251663[ebp+15], dl
  001ac	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001af	88 45 f8	 mov	 BYTE PTR _pMsgResult$251663[ebp+16], al
  001b2	89 4d ed	 mov	 DWORD PTR _pMsgResult$251663[ebp+5], ecx
  001b5	89 55 f1	 mov	 DWORD PTR _pMsgResult$251663[ebp+9], edx
$LN26@GCAnsRegGu:

; 20055: 			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  001b8	6a 11		 push	 17			; 00000011H
  001ba	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$251663[ebp]
  001bd	50		 push	 eax
  001be	53		 push	 ebx
  001bf	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$251663[ebp], 78778817 ; 04b211c1H
  001c6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20056: 			gObj[iIndex].UseEventServer = 0;

  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d4	c7 84 0f 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+ecx+4176], 0
  001df	5f		 pop	 edi
$LN3@GCAnsRegGu:

; 20057: 			
; 20058: 		}
; 20059: 	}
; 20060: //#endif
; 20061: }

  001e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e3	5e		 pop	 esi
  001e4	33 cd		 xor	 ecx, ebp
  001e6	5b		 pop	 ebx
  001e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ENDP ; GCAnsRegGuildMark
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsNpcBuy@@YAXHHHH@Z				; GCAnsNpcBuy
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsNpcBuy@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
?GCAnsNpcBuy@@YAXHHHH@Z PROC				; GCAnsNpcBuy, COMDAT

; 20105: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20106: //#if(GS_CASTLE==1)
; 20107: 	PMSG_ANS_NPCBUY pMsgResult;
; 20108: 
; 20109: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x05, sizeof(pMsgResult));
; 20110: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 20111: 	pMsgResult.iNpcNumber = iNpcNumber;

  00013	8b 4d 10	 mov	 ecx, DWORD PTR _iNpcNumber$[ebp]

; 20112: 	pMsgResult.iNpcIndex = iNpcIndex;

  00016	8b 55 14	 mov	 edx, DWORD PTR _iNpcIndex$[ebp]
  00019	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20113: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0001c	6a 10		 push	 16			; 00000010H
  0001e	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00021	89 4d f4	 mov	 DWORD PTR _pMsgResult$[ebp+8], ecx
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	c7 45 ec c1 10
	b2 05		 mov	 DWORD PTR _pMsgResult$[ebp], 95555777 ; 05b210c1H
  00030	89 55 f8	 mov	 DWORD PTR _pMsgResult$[ebp+12], edx
  00033	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20114: //#endif
; 20115: }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GCAnsNpcBuy@@YAXHHHH@Z ENDP				; GCAnsNpcBuy
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsNpcRepair@@YAXHHHHHH@Z			; GCAnsNpcRepair
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsNpcRepair@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcHP$ = 24						; size = 4
_iNpcMaxHP$ = 28					; size = 4
?GCAnsNpcRepair@@YAXHHHHHH@Z PROC			; GCAnsNpcRepair, COMDAT

; 20215: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20216: //#if(GS_CASTLE==1)
; 20217: 	PMSG_ANS_NPCREPAIR pMsgResult;
; 20218: 
; 20219: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x06, sizeof(pMsgResult));
; 20220: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 20221: 	pMsgResult.iNpcNumber = iNpcNumber;
; 20222: 	pMsgResult.iNpcIndex = iNpcIndex;

  00013	8b 55 14	 mov	 edx, DWORD PTR _iNpcIndex$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _iNpcNumber$[ebp]
  00019	88 45 e8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20223: 	pMsgResult.iNpcHP = iNpcHP;

  0001c	8b 45 18	 mov	 eax, DWORD PTR _iNpcHP$[ebp]
  0001f	89 55 f0	 mov	 DWORD PTR _pMsgResult$[ebp+12], edx

; 20224: 	pMsgResult.iNpcMaxHP = iNpcMaxHP;
; 20225: 
; 20226: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00022	6a 18		 push	 24			; 00000018H
  00024	8d 55 e4	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00027	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+16], eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0002d	89 4d ec	 mov	 DWORD PTR _pMsgResult$[ebp+8], ecx
  00030	8b 4d 1c	 mov	 ecx, DWORD PTR _iNpcMaxHP$[ebp]
  00033	52		 push	 edx
  00034	50		 push	 eax
  00035	c7 45 e4 c1 18
	b2 06		 mov	 DWORD PTR _pMsgResult$[ebp], 112335041 ; 06b218c1H
  0003c	89 4d f8	 mov	 DWORD PTR _pMsgResult$[ebp+20], ecx
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20227: //#endif
; 20228: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCAnsNpcRepair@@YAXHHHHHH@Z ENDP			; GCAnsNpcRepair
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsNpcUpgrade@@YAXHHHHHH@Z			; GCAnsNpcUpgrade
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsNpcUpgrade@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcUpType$ = 24					; size = 4
_iNpcUpValue$ = 28					; size = 4
?GCAnsNpcUpgrade@@YAXHHHHHH@Z PROC			; GCAnsNpcUpgrade, COMDAT

; 20478: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20479: //#if(GS_CASTLE==1)
; 20480: 	PMSG_ANS_NPCUPGRADE pMsgResult;
; 20481: 
; 20482: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x07, sizeof(pMsgResult));
; 20483: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 20484: 	pMsgResult.iNpcNumber = iNpcNumber;
; 20485: 	pMsgResult.iNpcIndex = iNpcIndex;

  00013	8b 55 14	 mov	 edx, DWORD PTR _iNpcIndex$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _iNpcNumber$[ebp]
  00019	88 45 e8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20486: 	pMsgResult.iNpcUpType = iNpcUpType;

  0001c	8b 45 18	 mov	 eax, DWORD PTR _iNpcUpType$[ebp]
  0001f	89 55 f0	 mov	 DWORD PTR _pMsgResult$[ebp+12], edx

; 20487: 	pMsgResult.iNpcUpValue = iNpcUpValue;
; 20488: 
; 20489: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00022	6a 18		 push	 24			; 00000018H
  00024	8d 55 e4	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00027	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+16], eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0002d	89 4d ec	 mov	 DWORD PTR _pMsgResult$[ebp+8], ecx
  00030	8b 4d 1c	 mov	 ecx, DWORD PTR _iNpcUpValue$[ebp]
  00033	52		 push	 edx
  00034	50		 push	 eax
  00035	c7 45 e4 c1 18
	b2 07		 mov	 DWORD PTR _pMsgResult$[ebp], 129112257 ; 07b218c1H
  0003c	89 4d f8	 mov	 DWORD PTR _pMsgResult$[ebp+20], ecx
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20490: //#endif
; 20491: }

  00044	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00047	33 cd		 xor	 ecx, ebp
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCAnsNpcUpgrade@@YAXHHHHHH@Z ENDP			; GCAnsNpcUpgrade
_TEXT	ENDS
PUBLIC	??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ ; `string'
PUBLIC	??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ ; `string'
PUBLIC	?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ; CGReqTaxMoneyInfo
EXTRN	?GS_GDReqTaxInfo@@YAXHH@Z:PROC			; GS_GDReqTaxInfo
EXTRN	?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z:PROC ; CCastleSiege::CheckGuildOwnCastle
;	COMDAT ??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
CONST	SEGMENT
??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ DB '[Castl'
	DB	'eSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], '
	DB	'Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
CONST	SEGMENT
??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ DB '[Castl'
	DB	'eSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)'
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z PROC ; CGReqTaxMoneyInfo, COMDAT

; 20494: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20495: //#if(GS_CASTLE==1)
; 20496: 	if( lpMsg == NULL )

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	0f 84 e9 00 00
	00		 je	 $LN1@CGReqTaxMo

; 20497: 	{
; 20498: 		return;
; 20499: 	}
; 20500: 
; 20501: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00016	56		 push	 esi
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	57		 push	 edi
  00020	8d bc 06 3c 04
	00 00		 lea	 edi, DWORD PTR [esi+eax+1084]
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	8b c7		 mov	 eax, edi
  0002e	8b ff		 npad	 2
$LL11@CGReqTaxMo:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN12@CGReqTaxMo
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN13@CGReqTaxMo
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN12@CGReqTaxMo
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL11@CGReqTaxMo
$LN13@CGReqTaxMo:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN14@CGReqTaxMo
$LN12@CGReqTaxMo:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN14@CGReqTaxMo:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 96 00 00
	00		 je	 $LN15@CGReqTaxMo

; 20502: 	{
; 20503: 		return;
; 20504: 	}
; 20505: 	
; 20506: 	if( (g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	85 c0		 test	 eax, eax
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	74 58		 je	 SHORT $LN2@CGReqTaxMo
  00071	81 bc 06 48 04
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+eax+1096], 128 ; 00000080H
  0007c	75 4b		 jne	 SHORT $LN2@CGReqTaxMo

; 20509: 	}
; 20510: 	else
; 20511: 	{
; 20512: 		GS_GDReqTaxInfo(g_MapServerManager.GetMapSvrGroup(), iIndex);

  0007e	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  00083	85 c0		 test	 eax, eax
  00085	74 06		 je	 SHORT $LN8@CGReqTaxMo
  00087	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0008b	eb 03		 jmp	 SHORT $LN9@CGReqTaxMo
$LN8@CGReqTaxMo:
  0008d	83 c8 ff	 or	 eax, -1
$LN9@CGReqTaxMo:
  00090	53		 push	 ebx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?GS_GDReqTaxInfo@@YAXHH@Z ; GS_GDReqTaxInfo

; 20513: 		LogAddTD("[CastleSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009c	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  000a3	51		 push	 ecx
  000a4	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  000ab	52		 push	 edx
  000ac	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000b0	51		 push	 ecx
  000b1	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000b5	52		 push	 edx
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c1	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx

; 20514: 	}
; 20515: //#endif
; 20516: }

  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
$LN2@CGReqTaxMo:

; 20507: 	{
; 20508: 		LogAddC(2,"[CastleSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  000c9	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  000d0	51		 push	 ecx
  000d1	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  000d8	52		 push	 edx
  000d9	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000dd	51		 push	 ecx
  000de	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000e2	52		 push	 edx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
  000e8	6a 02		 push	 2
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000f0	83 c4 18	 add	 esp, 24			; 00000018H
$LN15@CGReqTaxMo:
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
$LN1@CGReqTaxMo:

; 20514: 	}
; 20515: //#endif
; 20516: }

  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ENDP ; CGReqTaxMoneyInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z			; GCAnsTaxMoneyInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 15
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_btTaxRateChaos$ = 16					; size = 1
_btTaxRateStore$ = 20					; size = 1
_i64Money$ = 24						; size = 8
?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z PROC			; GCAnsTaxMoneyInfo, COMDAT

; 20519: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20520: //#if (GS_CASTLE==1)
; 20521: 	PMSG_ANS_TAXMONEYINFO pMsgResult;
; 20522: 
; 20523: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x08, sizeof(pMsgResult));
; 20524: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 20525: 	pMsgResult.btTaxRateChaos = btTaxRateChaos;

  00013	8a 4d 10	 mov	 cl, BYTE PTR _btTaxRateChaos$[ebp]

; 20526: 	pMsgResult.btTaxRateStore = btTaxRateStore;

  00016	8a 55 14	 mov	 dl, BYTE PTR _btTaxRateStore$[ebp]
  00019	88 4d f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0001c	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20527: 	pMsgResult.btMoney1 = SET_NUMBERH(SET_NUMBERHW(HIDWORD(i64Money)));

  0001f	8b 45 1c	 mov	 eax, DWORD PTR _i64Money$[ebp+4]
  00022	8b c8		 mov	 ecx, eax
  00024	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  00027	8b c8		 mov	 ecx, eax
  00029	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0002c	88 55 f2	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  0002f	8b d1		 mov	 edx, ecx

; 20528: 	pMsgResult.btMoney2 = SET_NUMBERL(SET_NUMBERHW(HIDWORD(i64Money)));

  00031	88 4d f4	 mov	 BYTE PTR _pMsgResult$[ebp+8], cl

; 20529: 	pMsgResult.btMoney3 = SET_NUMBERH(SET_NUMBERLW(HIDWORD(i64Money)));

  00034	8b c8		 mov	 ecx, eax
  00036	c1 e9 08	 shr	 ecx, 8
  00039	88 4d f5	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl

; 20530: 	pMsgResult.btMoney4 = SET_NUMBERL(SET_NUMBERLW(HIDWORD(i64Money)));
; 20531: 	pMsgResult.btMoney5 = SET_NUMBERH( SET_NUMBERHW( LODWORD( i64Money ) ) ) ;

  0003c	8b 4d 18	 mov	 ecx, DWORD PTR _i64Money$[ebp]
  0003f	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+10], al
  00042	c1 ea 08	 shr	 edx, 8
  00045	8b c1		 mov	 eax, ecx
  00047	c1 e8 10	 shr	 eax, 16			; 00000010H
  0004a	88 55 f3	 mov	 BYTE PTR _pMsgResult$[ebp+7], dl
  0004d	8b d0		 mov	 edx, eax

; 20532: 	pMsgResult.btMoney6 = SET_NUMBERL( SET_NUMBERHW( LODWORD( i64Money ) ) ) ;

  0004f	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+12], al
  00052	c1 ea 08	 shr	 edx, 8

; 20533: 	pMsgResult.btMoney7 = SET_NUMBERH( SET_NUMBERLW( LODWORD( i64Money ) ) ) ;

  00055	8b c1		 mov	 eax, ecx

; 20534: 	pMsgResult.btMoney8 = SET_NUMBERL( SET_NUMBERLW( LODWORD( i64Money ) ) ) ;

  00057	88 4d fa	 mov	 BYTE PTR _pMsgResult$[ebp+14], cl

; 20535: 
; 20536: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0005a	6a 0f		 push	 15			; 0000000fH
  0005c	8d 4d ec	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  0005f	88 55 f7	 mov	 BYTE PTR _pMsgResult$[ebp+11], dl
  00062	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00065	51		 push	 ecx
  00066	c1 e8 08	 shr	 eax, 8
  00069	52		 push	 edx
  0006a	c7 45 ec c1 0f
	b2 08		 mov	 DWORD PTR _pMsgResult$[ebp], 145887169 ; 08b20fc1H
  00071	88 45 f9	 mov	 BYTE PTR _pMsgResult$[ebp+13], al
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20537: //#endif
; 20538: }

  00079	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	33 cd		 xor	 ecx, ebp
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z ENDP			; GCAnsTaxMoneyInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsTaxRateChange@@YAXHHEH@Z			; GCAnsTaxRateChange
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsTaxRateChange@@YAXHHEH@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_btTaxType$ = 16					; size = 1
_iTaxRate$ = 20						; size = 4
?GCAnsTaxRateChange@@YAXHHEH@Z PROC			; GCAnsTaxRateChange, COMDAT

; 20596: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20597: //#if (GS_CASTLE==1)
; 20598: 	PMSG_ANS_TAXRATECHANGE pMsgResult;
; 20599: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x09, sizeof(pMsgResult));
; 20600: 	pMsgResult.btResult = iResult;
; 20601: 	pMsgResult.btTaxType = btTaxType;

  00010	8a 4d 10	 mov	 cl, BYTE PTR _btTaxType$[ebp]
  00013	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00016	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00019	88 4d f5	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl

; 20602: 	pMsgResult.btTaxRate1 = SET_NUMBERH(SET_NUMBERHW(iTaxRate));

  0001c	8b 4d 14	 mov	 ecx, DWORD PTR _iTaxRate$[ebp]
  0001f	8b c1		 mov	 eax, ecx
  00021	c1 e8 10	 shr	 eax, 16			; 00000010H
  00024	8b d0		 mov	 edx, eax

; 20603: 	pMsgResult.btTaxRate2 = SET_NUMBERL(SET_NUMBERHW(iTaxRate));

  00026	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+7], al
  00029	c1 ea 08	 shr	 edx, 8

; 20604: 	pMsgResult.btTaxRate3 = SET_NUMBERH(SET_NUMBERLW(iTaxRate));

  0002c	8b c1		 mov	 eax, ecx

; 20605: 	pMsgResult.btTaxRate4 = SET_NUMBERL(SET_NUMBERLW(iTaxRate));

  0002e	88 4d f9	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl

; 20606: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00031	6a 0a		 push	 10			; 0000000aH
  00033	8d 4d f0	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  00036	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  00039	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0003c	51		 push	 ecx
  0003d	c1 e8 08	 shr	 eax, 8
  00040	52		 push	 edx
  00041	c7 45 f0 c1 0a
	b2 09		 mov	 DWORD PTR _pMsgResult$[ebp], 162663105 ; 09b20ac1H
  00048	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+8], al
  0004b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20607: //#endif
; 20608: }

  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCAnsTaxRateChange@@YAXHHEH@Z ENDP			; GCAnsTaxRateChange
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsMoneyDrawOut@@YAXHH_J@Z			; GCAnsMoneyDrawOut
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsMoneyDrawOut@@YAXHH_J@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_i64Money$ = 16						; size = 8
?GCAnsMoneyDrawOut@@YAXHH_J@Z PROC			; GCAnsMoneyDrawOut, COMDAT

; 20669: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20670: //#if(GS_CASTLE==1)
; 20671: 	PMSG_ANS_MONEYDRAWOUT pMsgResult;
; 20672: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x10, sizeof(pMsgResult));
; 20673: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00013	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20674: 	pMsgResult.btMoney1 = SET_NUMBERH(SET_NUMBERHW(HIDWORD(i64Money)));

  00016	8b 45 14	 mov	 eax, DWORD PTR _i64Money$[ebp+4]
  00019	8b c8		 mov	 ecx, eax
  0001b	c1 f9 1f	 sar	 ecx, 31			; 0000001fH
  0001e	8b c8		 mov	 ecx, eax
  00020	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00023	8b d1		 mov	 edx, ecx

; 20675: 	pMsgResult.btMoney2 = SET_NUMBERL(SET_NUMBERHW(HIDWORD(i64Money)));

  00025	88 4d f2	 mov	 BYTE PTR _pMsgResult$[ebp+6], cl

; 20676: 	pMsgResult.btMoney3 = SET_NUMBERH(SET_NUMBERLW(HIDWORD(i64Money)));

  00028	8b c8		 mov	 ecx, eax
  0002a	c1 e9 08	 shr	 ecx, 8
  0002d	88 4d f3	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl

; 20677: 	pMsgResult.btMoney4 = SET_NUMBERL(SET_NUMBERLW(HIDWORD(i64Money)));
; 20678: 	pMsgResult.btMoney5 = SET_NUMBERH( SET_NUMBERHW( LODWORD( i64Money ) ) ) ;

  00030	8b 4d 10	 mov	 ecx, DWORD PTR _i64Money$[ebp]
  00033	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+8], al
  00036	c1 ea 08	 shr	 edx, 8
  00039	8b c1		 mov	 eax, ecx
  0003b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003e	88 55 f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], dl
  00041	8b d0		 mov	 edx, eax

; 20679: 	pMsgResult.btMoney6 = SET_NUMBERL( SET_NUMBERHW( LODWORD( i64Money ) ) ) ;

  00043	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+10], al
  00046	c1 ea 08	 shr	 edx, 8

; 20680: 	pMsgResult.btMoney7 = SET_NUMBERH( SET_NUMBERLW( LODWORD( i64Money ) ) ) ;

  00049	8b c1		 mov	 eax, ecx

; 20681: 	pMsgResult.btMoney8 = SET_NUMBERL( SET_NUMBERLW( LODWORD( i64Money ) ) ) ;

  0004b	88 4d f8	 mov	 BYTE PTR _pMsgResult$[ebp+12], cl

; 20682: 	
; 20683: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0004e	6a 0d		 push	 13			; 0000000dH
  00050	8d 4d ec	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  00053	88 55 f5	 mov	 BYTE PTR _pMsgResult$[ebp+9], dl
  00056	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00059	51		 push	 ecx
  0005a	c1 e8 08	 shr	 eax, 8
  0005d	52		 push	 edx
  0005e	c7 45 ec c1 0d
	b2 10		 mov	 DWORD PTR _pMsgResult$[ebp], 280104385 ; 10b20dc1H
  00065	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+11], al
  00068	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20684: //#endif
; 20685: }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?GCAnsMoneyDrawOut@@YAXHH_J@Z ENDP			; GCAnsMoneyDrawOut
_TEXT	ENDS
PUBLIC	?GCAnsCsGateState@@YAXHHH@Z			; GCAnsCsGateState
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsGateState@@YAXHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 7
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iGateIndex$ = 16					; size = 4
?GCAnsCsGateState@@YAXHHH@Z PROC			; GCAnsCsGateState, COMDAT

; 20688: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20689: //#if(GS_CASTLE==1)
; 20690: 	PMSG_ANS_CSGATESTATE pMsgResult;
; 20691: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x11, sizeof(pMsgResult));
; 20692: 	pMsgResult.btResult = iResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20693: 	pMsgResult.btIndex1 = SET_NUMBERH( (iGateIndex &0xffff) );

  0000c	8b 45 10	 mov	 eax, DWORD PTR _iGateIndex$[ebp]
  0000f	8b c8		 mov	 ecx, eax

; 20694: 	pMsgResult.btIndex2 = SET_NUMBERL( (iGateIndex &0xffff) );
; 20695: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00011	6a 07		 push	 7
  00013	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00016	88 45 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], al
  00019	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001c	52		 push	 edx
  0001d	c1 e9 08	 shr	 ecx, 8
  00020	50		 push	 eax
  00021	c7 45 f8 c1 07
	b2 11		 mov	 DWORD PTR _pMsgResult$[ebp], 296880065 ; 11b207c1H
  00028	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20696: //#endif
; 20697: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCAnsCsGateState@@YAXHHH@Z ENDP			; GCAnsCsGateState
_TEXT	ENDS
PUBLIC	?GCAnsCsGateOperate@@YAXHHHH@Z			; GCAnsCsGateOperate
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsGateOperate@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 8
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iGateIndex$ = 16					; size = 4
_iGateOperate$ = 20					; size = 4
?GCAnsCsGateOperate@@YAXHHHH@Z PROC			; GCAnsCsGateOperate, COMDAT

; 20753: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20754: //#if(GS_CASTLE==1)
; 20755: 	PMSG_ANS_CSGATEOPERATE pMsgResult;
; 20756: 
; 20757: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x12, sizeof(pMsgResult));
; 20758: 	pMsgResult.btResult = iResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 20759: 	pMsgResult.btOperate = iGateOperate;

  00009	8a 4d 14	 mov	 cl, BYTE PTR _iGateOperate$[ebp]
  0000c	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20760: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xffff); //??

  0000f	8b 45 10	 mov	 eax, DWORD PTR _iGateIndex$[ebp]
  00012	8b d0		 mov	 edx, eax

; 20761: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xffff); //??

  00014	88 45 ff	 mov	 BYTE PTR _pMsgResult$[ebp+7], al

; 20762: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00017	6a 08		 push	 8
  00019	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0001c	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00022	50		 push	 eax
  00023	c1 ea 08	 shr	 edx, 8
  00026	51		 push	 ecx
  00027	c7 45 f8 c1 08
	b2 12		 mov	 DWORD PTR _pMsgResult$[ebp], 313657537 ; 12b208c1H
  0002e	88 55 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20763: //#endif
; 20764: }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?GCAnsCsGateOperate@@YAXHHHH@Z ENDP			; GCAnsCsGateOperate
_TEXT	ENDS
PUBLIC	?GCAnsCsGateCurState@@YAXHHH@Z			; GCAnsCsGateCurState
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsGateCurState@@YAXHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 7
_iIndex$ = 8						; size = 4
_iGateIndex$ = 12					; size = 4
_iGateOperate$ = 16					; size = 4
?GCAnsCsGateCurState@@YAXHHH@Z PROC			; GCAnsCsGateCurState, COMDAT

; 20767: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20768: //#if(GS_CASTLE==1)
; 20769: 	PMSG_ANS_CSGATECURSTATE pMsgResult;
; 20770: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x13, sizeof(pMsgResult));
; 20771: 	pMsgResult.btOperate = iGateOperate;

  00006	8a 45 10	 mov	 al, BYTE PTR _iGateOperate$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20772: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xffff); //??

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _iGateIndex$[ebp]
  0000f	8b c8		 mov	 ecx, eax

; 20773: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xffff); //??
; 20774: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00011	6a 07		 push	 7
  00013	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00016	88 45 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], al
  00019	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001c	52		 push	 edx
  0001d	c1 e9 08	 shr	 ecx, 8
  00020	50		 push	 eax
  00021	c7 45 f8 c1 07
	b2 13		 mov	 DWORD PTR _pMsgResult$[ebp], 330434497 ; 13b207c1H
  00028	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20775: //#endif
; 20776: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCAnsCsGateCurState@@YAXHHH@Z ENDP			; GCAnsCsGateCurState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCsAccessSwitchState@@YAXHHHE@Z		; GCAnsCsAccessSwitchState
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsAccessSwitchState@@YAXHHHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSwitchIndex$ = 12					; size = 4
_iSwitchUserIndex$ = 16					; size = 4
_btSwitchState$ = 20					; size = 1
?GCAnsCsAccessSwitchState@@YAXHHHE@Z PROC		; GCAnsCsAccessSwitchState, COMDAT

; 20779: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20780: //#if(GS_CASTLE==1)
; 20781: 	PMSG_ANS_NOTIFYSWITCHPROC pMsgResult;
; 20782: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x14, sizeof(pMsgResult));
; 20783: 	pMsgResult.btIndex1 = SET_NUMBERH(iSwitchIndex & 0xffff); //??

  00010	8b 45 0c	 mov	 eax, DWORD PTR _iSwitchIndex$[ebp]
  00013	8b c8		 mov	 ecx, eax

; 20784: 	pMsgResult.btIndex2 = SET_NUMBERL(iSwitchIndex & 0xffff); //??

  00015	88 45 f5	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 20785: 	pMsgResult.btUserIndex1 = SET_NUMBERH(iSwitchUserIndex & 0xffff); //??

  00018	8b 45 10	 mov	 eax, DWORD PTR _iSwitchUserIndex$[ebp]
  0001b	c1 e9 08	 shr	 ecx, 8
  0001e	8b d0		 mov	 edx, eax
  00020	c1 ea 08	 shr	 edx, 8
  00023	88 4d f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], cl

; 20786: 	pMsgResult.btUserIndex2 = SET_NUMBERL(iSwitchUserIndex & 0xffff); //??
; 20787: 	pMsgResult.btSwitchState = btSwitchState;
; 20788: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00026	6a 09		 push	 9
  00028	8d 4d f0	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  0002b	88 55 f6	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  0002e	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00031	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+7], al
  00034	8a 45 14	 mov	 al, BYTE PTR _btSwitchState$[ebp]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	c7 45 f0 c1 09
	b2 14		 mov	 DWORD PTR _pMsgResult$[ebp], 347212225 ; 14b209c1H
  00040	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+8], al
  00043	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20789: //#endif
; 20790: }

  00048	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004b	33 cd		 xor	 ecx, ebp
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GCAnsCsAccessSwitchState@@YAXHHHE@Z ENDP		; GCAnsCsAccessSwitchState
_TEXT	ENDS
PUBLIC	??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@ ; `string'
PUBLIC	??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@ ; `string'
PUBLIC	??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@ ; `string'
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCsAccessCrownState@@YAXHE@Z		; GCAnsCsAccessCrownState
;	COMDAT ??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@ DB '['
	DB	'CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%'
	DB	's](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@
CONST	SEGMENT
??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@ DB '['
	DB	'CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d'
	DB	' [%s](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@
CONST	SEGMENT
??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@ DB '['
	DB	'CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d'
	DB	' [%s](%s)(%s)', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?GCAnsCsAccessCrownState@@YAXHE@Z
_TEXT	SEGMENT
_iIndex$GSCopy$ = -20					; size = 4
_pMsgResult$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_btCrownState$ = 12					; size = 1
?GCAnsCsAccessCrownState@@YAXHE@Z PROC			; GCAnsCsAccessCrownState, COMDAT

; 20793: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 20794: //#if(GS_CASTLE==1)
; 20795: 	PMSG_ANS_NOTIFYCROWNPROC pMsgResult;
; 20796: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x15, sizeof(pMsgResult));
; 20797: 	pMsgResult.btCrownState = btCrownState;

  00011	8a 5d 0c	 mov	 bl, BYTE PTR _btCrownState$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 20798: if(g_ZtLicense.CheckUser(eZtUB::PrideMu) || g_ZtLicense.CheckUser(eZtUB::PrideMuLocal) || g_ZtLicense.CheckUser(eZtUB::Local3))

  00018	6a 11		 push	 17			; 00000011H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense

; 20821: 	{
; 20822: 		gObj[iIndex].m_iAccumulatedCrownAccessTime += GetTickCount() - g_CastleSiege.GetCrownAccessTickCount();

  0001f	89 7d ec	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], edi
  00022	c7 45 f0 c1 0c
	b2 15		 mov	 DWORD PTR _pMsgResult$[ebp], 363990209 ; 15b20cc1H
  00029	88 5d f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl
  0002c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00031	84 c0		 test	 al, al
  00033	0f 85 6d 01 00
	00		 jne	 $LN10@GCAnsCsAcc

; 20798: if(g_ZtLicense.CheckUser(eZtUB::PrideMu) || g_ZtLicense.CheckUser(eZtUB::PrideMuLocal) || g_ZtLicense.CheckUser(eZtUB::Local3))

  00039	6a 1a		 push	 26			; 0000001aH
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00040	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00045	84 c0		 test	 al, al
  00047	0f 85 59 01 00
	00		 jne	 $LN10@GCAnsCsAcc
  0004d	6a 1c		 push	 28			; 0000001cH
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00054	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00059	84 c0		 test	 al, al
  0005b	0f 85 45 01 00
	00		 jne	 $LN10@GCAnsCsAcc

; 20801: }
; 20802: else
; 20803: {
; 20804: 	if( btCrownState == 0 )

  00061	84 db		 test	 bl, bl
  00063	75 5f		 jne	 SHORT $LN8@GCAnsCsAcc

; 20805: 	{
; 20806: 		if( gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 || gObj[iIndex].m_iAccumulatedCrownAccessTime > 61000 ) //season4.0 changed

  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	8b c7		 mov	 eax, edi
  0006d	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00073	8b 94 08 1c 1c
	00 00		 mov	 edx, DWORD PTR [eax+ecx+7196]
  0007a	85 d2		 test	 edx, edx
  0007c	78 08		 js	 SHORT $LN6@GCAnsCsAcc
  0007e	81 fa 48 ee 00
	00		 cmp	 edx, 61000		; 0000ee48H
  00084	7e 11		 jle	 SHORT $LN7@GCAnsCsAcc
$LN6@GCAnsCsAcc:

; 20807: 		{
; 20808: 			gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  00086	c7 84 08 1c 1c
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+ecx+7196], 0
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN7@GCAnsCsAcc:

; 20809: 		}
; 20810: 
; 20811: 		LogAddTD("[CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d [%s](%s)(%s)",	gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);

  00097	8d 54 08 77	 lea	 edx, DWORD PTR [eax+ecx+119]
  0009b	52		 push	 edx
  0009c	8d 54 08 6c	 lea	 edx, DWORD PTR [eax+ecx+108]
  000a0	52		 push	 edx
  000a1	8d 94 08 3c 04
	00 00		 lea	 edx, DWORD PTR [eax+ecx+1084]
  000a8	8b 84 08 1c 1c
	00 00		 mov	 eax, DWORD PTR [eax+ecx+7196]
  000af	52		 push	 edx
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bc	83 c4 14	 add	 esp, 20			; 00000014H

; 20812: 	}
; 20813: 
; 20814: 	if( btCrownState == 1 )

  000bf	e9 c8 00 00 00	 jmp	 $LN1@GCAnsCsAcc
$LN8@GCAnsCsAcc:
  000c4	56		 push	 esi
  000c5	80 fb 01	 cmp	 bl, 1
  000c8	75 44		 jne	 SHORT $LN5@GCAnsCsAcc

; 20815: 	{
; 20816: 		LogAddTD("[CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d [%s](%s)(%s)",	gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	8b f7		 mov	 esi, edi
  000d1	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000d7	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000db	51		 push	 ecx
  000dc	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000e0	52		 push	 edx
  000e1	8b 94 06 1c 1c
	00 00		 mov	 edx, DWORD PTR [esi+eax+7196]
  000e8	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  000ef	51		 push	 ecx
  000f0	52		 push	 edx
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20817: 		gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  000fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00101	c7 84 06 1c 1c
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+7196], 0

; 20818: 	}
; 20819: 
; 20820: 	if( btCrownState == 2 )

  0010c	eb 7a		 jmp	 SHORT $LN19@GCAnsCsAcc
$LN5@GCAnsCsAcc:
  0010e	80 fb 02	 cmp	 bl, 2
  00111	75 78		 jne	 SHORT $LN18@GCAnsCsAcc

; 20821: 	{
; 20822: 		gObj[iIndex].m_iAccumulatedCrownAccessTime += GetTickCount() - g_CastleSiege.GetCrownAccessTickCount();

  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00119	8b 1d 00 02 00
	00		 mov	 ebx, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+512
  0011f	8b f7		 mov	 esi, edi
  00121	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00127	8d bc 0e 1c 1c
	00 00		 lea	 edi, DWORD PTR [esi+ecx+7196]
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00134	2b c3		 sub	 eax, ebx
  00136	01 07		 add	 DWORD PTR [edi], eax

; 20823: 		
; 20824: 		if( gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 || gObj[iIndex].m_iAccumulatedCrownAccessTime > 61000 ) //season4.0 changed

  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013d	8b 8c 06 1c 1c
	00 00		 mov	 ecx, DWORD PTR [esi+eax+7196]
  00144	85 c9		 test	 ecx, ecx
  00146	78 08		 js	 SHORT $LN2@GCAnsCsAcc
  00148	81 f9 48 ee 00
	00		 cmp	 ecx, 61000		; 0000ee48H
  0014e	7e 10		 jle	 SHORT $LN3@GCAnsCsAcc
$LN2@GCAnsCsAcc:

; 20825: 		{
; 20826: 			gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  00150	c7 84 06 1c 1c
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+7196], 0
  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@GCAnsCsAcc:

; 20827: 		}
; 20828: 
; 20829: 		LogAddTD("[CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%s](%s)(%s)", gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);

  00160	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00164	52		 push	 edx
  00165	8d 4c 06 6c	 lea	 ecx, DWORD PTR [esi+eax+108]
  00169	51		 push	 ecx
  0016a	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  00171	8b 84 06 1c 1c
	00 00		 mov	 eax, DWORD PTR [esi+eax+7196]
  00178	52		 push	 edx
  00179	50		 push	 eax
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00185	8b 7d ec	 mov	 edi, DWORD PTR _iIndex$GSCopy$[ebp]
$LN19@GCAnsCsAcc:
  00188	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@GCAnsCsAcc:
  0018b	5e		 pop	 esi
$LN1@GCAnsCsAcc:

; 20830: 	
; 20831: 		if( gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 ) //season4.0 changed
; 20832: 		{
; 20833: 			//gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;
; 20834: 		}
; 20835: 	}
; 20836: 
; 20837: 	pMsgResult.dwAccumulatedCrownAccessTime = gObj[iIndex].m_iAccumulatedCrownAccessTime; //??

  0018c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00192	8b cf		 mov	 ecx, edi
  00194	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0019a	8b 84 11 1c 1c
	00 00		 mov	 eax, DWORD PTR [ecx+edx+7196]
  001a1	89 45 f8	 mov	 DWORD PTR _pMsgResult$[ebp+8], eax
  001a4	eb 07		 jmp	 SHORT $LN9@GCAnsCsAcc
$LN10@GCAnsCsAcc:

; 20799: {
; 20800: 	pMsgResult.dwAccumulatedCrownAccessTime = 0;			

  001a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pMsgResult$[ebp+8], 0
$LN9@GCAnsCsAcc:

; 20838: }
; 20839: 
; 20840: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  001ad	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsgResult$[ebp+1]
  001b1	51		 push	 ecx
  001b2	8d 55 f0	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  001b5	52		 push	 edx
  001b6	57		 push	 edi
  001b7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20841: //#endif
; 20842: }

  001bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c2	5f		 pop	 edi
  001c3	33 cd		 xor	 ecx, ebp
  001c5	5b		 pop	 ebx
  001c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c3		 ret	 0
?GCAnsCsAccessCrownState@@YAXHE@Z ENDP			; GCAnsCsAccessCrownState
_TEXT	ENDS
PUBLIC	?GCAnsCsNotifyStart@@YAXHE@Z			; GCAnsCsNotifyStart
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsNotifyStart@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_btStartState$ = 12					; size = 1
?GCAnsCsNotifyStart@@YAXHE@Z PROC			; GCAnsCsNotifyStart, COMDAT

; 20845: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20846: //#if(GS_CASTLE==1)
; 20847: 	PMSG_ANS_NOTIFYCSSTART pMsgResult;
; 20848: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x17, sizeof(pMsgResult));
; 20849: 	pMsgResult.btStartState = btStartState;
; 20850: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00006	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00009	8a 45 0c	 mov	 al, BYTE PTR _btStartState$[ebp]
  0000c	6a 05		 push	 5
  0000e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	c7 45 f8 c1 05
	b2 17		 mov	 DWORD PTR _pMsgResult$[ebp], 397542849 ; 17b205c1H
  0001a	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20851: //#endif
; 20852: }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GCAnsCsNotifyStart@@YAXHE@Z ENDP			; GCAnsCsNotifyStart
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsCsNotifyProgress@@YAXHEPBD@Z		; GCAnsCsNotifyProgress
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsNotifyProgress@@YAXHEPBD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_btCastleSiegeState$ = 12				; size = 1
_lpszGuildName$ = 16					; size = 4
?GCAnsCsNotifyProgress@@YAXHEPBD@Z PROC			; GCAnsCsNotifyProgress, COMDAT

; 20855: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]

; 20856: 	if ( lpszGuildName == NULL )

  00013	85 c9		 test	 ecx, ecx
  00015	74 36		 je	 SHORT $LN2@GCAnsCsNot

; 20857: 	{
; 20858: 		return;
; 20859: 	}
; 20860: 
; 20861: 	PMSG_ANS_NOTIFYCSPROGRESS pMsgResult;
; 20862: 
; 20863: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x18, sizeof(pMsgResult));
; 20864: 	pMsgResult.btCastleSiegeState = btCastleSiegeState;

  00017	8a 45 0c	 mov	 al, BYTE PTR _btCastleSiegeState$[ebp]
  0001a	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20865: 	memset(pMsgResult.szGuildName, 0, sizeof(pMsgResult.szGuildName));

  0001d	33 c0		 xor	 eax, eax
  0001f	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00022	89 45 f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 20866: 	memcpy(pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002a	b2 0d		 mov	 dl, 13			; 0000000dH

; 20867: 
; 20868: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0002c	0f b6 d2	 movzx	 edx, dl
  0002f	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00032	52		 push	 edx
  00033	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00036	89 4d f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], ecx
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	c7 45 ec c1 0d
	b2 18		 mov	 DWORD PTR _pMsgResult$[ebp], 414322113 ; 18b20dc1H
  00045	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCAnsCsNot:

; 20869: }

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00050	33 cd		 xor	 ecx, ebp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?GCAnsCsNotifyProgress@@YAXHEPBD@Z ENDP			; GCAnsCsNotifyProgress
_TEXT	ENDS
PUBLIC	?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z			; GCAnsCsMapSvrTaxInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btTaxType$ = 12					; size = 1
_btTaxRate$ = 16					; size = 1
?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z PROC			; GCAnsCsMapSvrTaxInfo, COMDAT

; 20872: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20873: 	PMSG_ANS_MAPSVRTAXINFO pMsgResult;
; 20874: 	
; 20875: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1A, sizeof(pMsgResult));
; 20876: 	pMsgResult.btTaxType = btTaxType;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btTaxType$[ebp]

; 20877: 	pMsgResult.btTaxRate = btTaxRate;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btTaxRate$[ebp]

; 20878: 
; 20879: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0000c	6a 06		 push	 6
  0000e	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00011	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00014	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	c7 45 f8 c1 06
	b2 1a		 mov	 DWORD PTR _pMsgResult$[ebp], 447874753 ; 1ab206c1H
  00020	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20880: 
; 20881: }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ENDP			; GCAnsCsMapSvrTaxInfo
_TEXT	ENDS
PUBLIC	?GCAnsCsMiniMapData@@YAXHE@Z			; GCAnsCsMiniMapData
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsMiniMapData@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?GCAnsCsMiniMapData@@YAXHE@Z PROC			; GCAnsCsMiniMapData, COMDAT

; 20908: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20909: 	PMSG_ANS_MINIMAPDATA pMsgResult;
; 20910: 
; 20911: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1B, sizeof(pMsgResult));
; 20912: 	pMsgResult.btResult = btResult;
; 20913: 
; 20914: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00006	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00009	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  0000c	6a 05		 push	 5
  0000e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsgResult$[ebp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	c7 45 f8 c1 05
	b2 1b		 mov	 DWORD PTR _pMsgResult$[ebp], 464651713 ; 1bb205c1H
  0001a	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20915: }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GCAnsCsMiniMapData@@YAXHE@Z ENDP			; GCAnsCsMiniMapData
_TEXT	ENDS
PUBLIC	?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ; CGReqStopCsMiniMapData
EXTRN	?DelMiniMapDataReqUser@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::DelMiniMapDataReqUser
; Function compile flags: /Ogtp
;	COMDAT ?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z PROC ; CGReqStopCsMiniMapData, COMDAT

; 20920: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 20921: //#if(GS_CASTLE==1)
; 20922: 	if( gObjIsConnected(iIndex) == FALSE )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 0b		 je	 SHORT $LN2@CGReqStopC

; 20923: 	{
; 20924: 		return;
; 20925: 	}
; 20926: 
; 20927: 	g_CastleSiege.DelMiniMapDataReqUser(iIndex);

  00014	56		 push	 esi
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001a	e8 00 00 00 00	 call	 ?DelMiniMapDataReqUser@CCastleSiege@@QAEXH@Z ; CCastleSiege::DelMiniMapDataReqUser
$LN2@CGReqStopC:
  0001f	5e		 pop	 esi

; 20928: //#endif
; 20929: }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ENDP ; CGReqStopCsMiniMapData
_TEXT	ENDS
PUBLIC	?GCAnsCsSendCommand@@YAXHEEEE@Z			; GCAnsCsSendCommand
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsSendCommand@@YAXHEEEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 8
_iCsJoinSize$ = 8					; size = 4
_btTeam$ = 12						; size = 1
_btX$ = 16						; size = 1
_btY$ = 20						; size = 1
_btCommand$ = 24					; size = 1
?GCAnsCsSendCommand@@YAXHEEEE@Z PROC			; GCAnsCsSendCommand, COMDAT

; 20957: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20958: //#if(GS_CASTLE==1)
; 20959: 	PMSG_ANS_CSCOMMAND pMsgResult;
; 20960: 
; 20961: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1D, sizeof(pMsgResult));
; 20962: 	
; 20963: 	pMsgResult.btTeam = btTeam;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btTeam$[ebp]

; 20964: 	pMsgResult.btX = btX;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btX$[ebp]

; 20965: 	pMsgResult.btY = btY;

  0000c	8a 55 14	 mov	 dl, BYTE PTR _btY$[ebp]
  0000f	53		 push	 ebx
  00010	8b 5d 08	 mov	 ebx, DWORD PTR _iCsJoinSize$[ebp]
  00013	56		 push	 esi
  00014	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 20966: 	pMsgResult.btCommand = btCommand;

  00017	8a 45 18	 mov	 al, BYTE PTR _btCommand$[ebp]
  0001a	57		 push	 edi
  0001b	c7 45 f8 c1 08
	b2 1d		 mov	 DWORD PTR _pMsgResult$[ebp], 498206913 ; 1db208c1H
  00022	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00025	88 55 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], dl
  00028	88 45 ff	 mov	 BYTE PTR _pMsgResult$[ebp+7], al

; 20967: 	
; 20968: 	for( int iIndex = OBJ_STARTUSERINDZT; iIndex < OBJMAX; iIndex++ )

  0002b	bf b0 36 00 00	 mov	 edi, 14000		; 000036b0H
  00030	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
$LL5@GCAnsCsSen:

; 20969: 	{
; 20970: 		if( gObjIsConnected(iIndex) == FALSE ) continue;

  00035	57		 push	 edi
  00036	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003b	83 c4 04	 add	 esp, 4
  0003e	85 c0		 test	 eax, eax
  00040	74 2d		 je	 SHORT $LN4@GCAnsCsSen

; 20971: 
; 20972: 		if( (gObj[iIndex].m_btCsJoinSide == iCsJoinSize) && (gObj[iIndex].MapNumber == MAP_INDEX_CASTLESIEGE) )

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00047	0f b6 8c 06 02
	1c 00 00	 movzx	 ecx, BYTE PTR [esi+eax+7170]
  0004f	3b cb		 cmp	 ecx, ebx
  00051	75 1c		 jne	 SHORT $LN4@GCAnsCsSen
  00053	80 bc 06 49 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+329], 30 ; 0000001eH
  0005b	75 12		 jne	 SHORT $LN4@GCAnsCsSen

; 20973: 		{
; 20974: 			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0005d	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00061	52		 push	 edx
  00062	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCAnsCsSen:

; 20967: 	
; 20968: 	for( int iIndex = OBJ_STARTUSERINDZT; iIndex < OBJMAX; iIndex++ )

  0006f	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00075	47		 inc	 edi
  00076	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  0007c	7c b7		 jl	 SHORT $LL5@GCAnsCsSen
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 20975: 		}
; 20976: 	}
; 20977: //#endif
; 20978: }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?GCAnsCsSendCommand@@YAXHEEEE@Z ENDP			; GCAnsCsSendCommand
_TEXT	ENDS
PUBLIC	?GCAnsCsLeftTimeAlarm@@YAXEE@Z			; GCAnsCsLeftTimeAlarm
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsLeftTimeAlarm@@YAXEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_btHour$ = 8						; size = 1
_btMinute$ = 12						; size = 1
?GCAnsCsLeftTimeAlarm@@YAXEE@Z PROC			; GCAnsCsLeftTimeAlarm, COMDAT

; 20981: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 20982: 	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;
; 20983: 
; 20984: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1E, sizeof(pMsgResult));
; 20985: 	pMsgResult.btHour = btHour;

  00006	8a 45 08	 mov	 al, BYTE PTR _btHour$[ebp]

; 20986: 	pMsgResult.btMinute = btMinute;

  00009	8a 4d 0c	 mov	 cl, BYTE PTR _btMinute$[ebp]
  0000c	56		 push	 esi
  0000d	c7 45 f8 c1 06
	b2 1e		 mov	 DWORD PTR _pMsgResult$[ebp], 514983617 ; 1eb206c1H
  00014	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00017	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl

; 20987: 
; 20988: 	for (int iIndex = OBJ_STARTUSERINDZT;iIndex < OBJMAX;iIndex++)

  0001a	be b0 36 00 00	 mov	 esi, 14000		; 000036b0H
  0001f	90		 npad	 1
$LL4@GCAnsCsLef:

; 20989: 	{
; 20990: 		if ( !gObjIsConnected(iIndex) )

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 12		 je	 SHORT $LN3@GCAnsCsLef

; 20991: 		{
; 20992: 			continue;
; 20993: 		}
; 20994: 
; 20995: 		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0002d	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  00031	52		 push	 edx
  00032	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCAnsCsLef:

; 20987: 
; 20988: 	for (int iIndex = OBJ_STARTUSERINDZT;iIndex < OBJMAX;iIndex++)

  0003f	46		 inc	 esi
  00040	81 fe 98 3a 00
	00		 cmp	 esi, 15000		; 00003a98H
  00046	7c d8		 jl	 SHORT $LL4@GCAnsCsLef
  00048	5e		 pop	 esi

; 20996: 	}
; 20997: 
; 20998: }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?GCAnsCsLeftTimeAlarm@@YAXEE@Z ENDP			; GCAnsCsLeftTimeAlarm
_TEXT	ENDS
PUBLIC	?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z		; GCAnsSelfCsLeftTimeAlarm
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btHour$ = 12						; size = 1
_btMinute$ = 16						; size = 1
?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z PROC		; GCAnsSelfCsLeftTimeAlarm, COMDAT

; 21001: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 21002: 	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;
; 21003: 
; 21004: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1E, sizeof(pMsgResult));
; 21005: 	pMsgResult.btHour = btHour;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btHour$[ebp]

; 21006: 	pMsgResult.btMinute = btMinute;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btMinute$[ebp]
  0000c	56		 push	 esi

; 21007: 
; 21008: 	if ( !gObjIsConnected(iIndex))

  0000d	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00010	56		 push	 esi
  00011	c7 45 f8 c1 06
	b2 1e		 mov	 DWORD PTR _pMsgResult$[ebp], 514983617 ; 1eb206c1H
  00018	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001b	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  0001e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	74 12		 je	 SHORT $LN2@GCAnsSelfC

; 21009: 	{
; 21010: 		return;
; 21011: 	}
; 21012: 
; 21013: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0002a	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsgResult$[ebp+1]
  0002e	52		 push	 edx
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00032	50		 push	 eax
  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCAnsSelfC:
  0003c	5e		 pop	 esi

; 21014: }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z ENDP		; GCAnsSelfCsLeftTimeAlarm
_TEXT	ENDS
PUBLIC	?GCAnsCsSetEnterHuntZone@@YAXHEE@Z		; GCAnsCsSetEnterHuntZone
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btEnterHuntZone$ = 16					; size = 1
?GCAnsCsSetEnterHuntZone@@YAXHEE@Z PROC			; GCAnsCsSetEnterHuntZone, COMDAT

; 21042: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 21043: 	PMSG_ANS_CSHUNTZONEENTER pMsgResult;
; 21044: 
; 21045: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1F, sizeof(pMsgResult));
; 21046: 	pMsgResult.btResult = btResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]

; 21047: 	pMsgResult.btHuntZoneEnter = btEnterHuntZone;

  00009	8a 4d 10	 mov	 cl, BYTE PTR _btEnterHuntZone$[ebp]

; 21048: 
; 21049: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0000c	6a 06		 push	 6
  0000e	8d 55 f8	 lea	 edx, DWORD PTR _pMsgResult$[ebp]
  00011	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00014	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	c7 45 f8 c1 06
	b2 1f		 mov	 DWORD PTR _pMsgResult$[ebp], 531760833 ; 1fb206c1H
  00020	88 4d fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21050: }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ENDP			; GCAnsCsSetEnterHuntZone
_TEXT	ENDS
PUBLIC	??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z	; CGReqNpcDbList
EXTRN	?SendNpcStateList@CCastleSiege@@QAEXHH@Z:PROC	; CCastleSiege::SendNpcStateList
;	COMDAT ??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s],'
	DB	' Guild:(%s)(%d)', 00H			; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z PROC	; CGReqNpcDbList, COMDAT

; 21053: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21054: //#if(GS_CASTLE==1)
; 21055: 	PMSG_ANS_NPCDBLIST pResult;
; 21056: 
; 21057: 	if( lpMsg == NULL )

  00010	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00014	53		 push	 ebx
  00015	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00018	0f 84 14 01 00
	00		 je	 $LN3@CGReqNpcDb

; 21058: 	{
; 21059: 		return;
; 21060: 	}
; 21061: 
; 21062: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	56		 push	 esi
  00024	8b f3		 mov	 esi, ebx
  00026	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002c	57		 push	 edi
  0002d	8d bc 06 3c 04
	00 00		 lea	 edi, DWORD PTR [esi+eax+1084]
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00039	8b c7		 mov	 eax, edi
  0003b	eb 03 8d 49 00	 npad	 5
$LL14@CGReqNpcDb:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN15@CGReqNpcDb
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN16@CGReqNpcDb
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN15@CGReqNpcDb
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL14@CGReqNpcDb
$LN16@CGReqNpcDb:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN17@CGReqNpcDb
$LN15@CGReqNpcDb:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
$LN17@CGReqNpcDb:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 c3 00 00
	00		 je	 $LN18@CGReqNpcDb

; 21063: 	{
; 21064: 		return;
; 21065: 	}
; 21066: 	
; 21067: 	if( g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE || ( (gObj[iIndex].GuildStatus != 128) && (gObj[iIndex].GuildStatus != 64) ) )

  0006d	57		 push	 edi
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00073	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00078	85 c0		 test	 eax, eax
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	74 67		 je	 SHORT $LN6@CGReqNpcDb
  00081	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  00088	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0008e	74 05		 je	 SHORT $LN7@CGReqNpcDb
  00090	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00093	75 53		 jne	 SHORT $LN6@CGReqNpcDb
$LN7@CGReqNpcDb:

; 21074: 	}
; 21075: 	else
; 21076: 	{
; 21077: 		switch( lpMsg->btMonsterCode )

  00095	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00098	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0009c	48		 dec	 eax
  0009d	74 28		 je	 SHORT $LN2@CGReqNpcDb
  0009f	48		 dec	 eax
  000a0	0f 85 8a 00 00
	00		 jne	 $LN18@CGReqNpcDb

; 21081: 			break;
; 21082: 		case 2:
; 21083: 			g_CastleSiege.SendNpcStateList(iIndex, 283);

  000a6	68 1b 01 00 00	 push	 283			; 0000011bH
  000ab	53		 push	 ebx
  000ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b1	e8 00 00 00 00	 call	 ?SendNpcStateList@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SendNpcStateList
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 21084: 			break;
; 21085: 		}
; 21086: 	}
; 21087: //#endif
; 21088: }

  000b9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	33 cd		 xor	 ecx, ebp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
$LN2@CGReqNpcDb:

; 21078: 		{
; 21079: 		case 1:
; 21080: 			g_CastleSiege.SendNpcStateList(iIndex, 277);

  000c7	68 15 01 00 00	 push	 277			; 00000115H
  000cc	53		 push	 ebx
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000d2	e8 00 00 00 00	 call	 ?SendNpcStateList@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SendNpcStateList
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 21084: 			break;
; 21085: 		}
; 21086: 	}
; 21087: //#endif
; 21088: }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 cd		 xor	 ecx, ebp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN6@CGReqNpcDb:

; 21068: 	{
; 21069: 		LogAddC(2, "[CastleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  000e8	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  000ef	52		 push	 edx
  000f0	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  000f7	51		 push	 ecx
  000f8	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000fc	52		 push	 edx
  000fd	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00101	50		 push	 eax
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@
  00107	6a 02		 push	 2
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 21070: 		pResult.h.set((LPBYTE)&pResult, 0xB3, sizeof(pResult));
; 21071: 		pResult.iCount = 0;
; 21072: 		pResult.btResult = 2;
; 21073: 		DataSend(iIndex, (LPBYTE)&pResult, sizeof(pResult));

  0010f	6a 0c		 push	 12			; 0000000cH
  00111	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00114	51		 push	 ecx
  00115	53		 push	 ebx
  00116	c7 45 f0 c2 00
	0c b3		 mov	 DWORD PTR _pResult$[ebp], -1291059006 ; b30c00c2H
  0011d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+8], 0
  00124	c6 45 f4 02	 mov	 BYTE PTR _pResult$[ebp+4], 2
  00128	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0012d	83 c4 24	 add	 esp, 36			; 00000024H
$LN18@CGReqNpcDb:
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
$LN3@CGReqNpcDb:

; 21084: 			break;
; 21085: 		}
; 21086: 	}
; 21087: //#endif
; 21088: }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	5b		 pop	 ebx
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z ENDP	; CGReqNpcDbList
_TEXT	ENDS
PUBLIC	?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ; CGReqCsRegGuildList
EXTRN	?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z:PROC	; GS_GDReqAllGuildMarkRegInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z PROC ; CGReqCsRegGuildList, COMDAT

; 21091: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21092: //#if(GS_CASTLE==1)
; 21093: 	if( lpMsg == NULL ) return;

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 2c		 je	 SHORT $LN2@CGReqCsReg

; 21094: 
; 21095: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(), iIndex);

  00009	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN4@CGReqCsReg
  00012	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00019	51		 push	 ecx
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqAllGuildMarkRegInfo
  00020	83 c4 08	 add	 esp, 8

; 21096: //#endif
; 21097: }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0

; 21094: 
; 21095: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(), iIndex);

$LN4@CGReqCsReg:
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00028	83 c8 ff	 or	 eax, -1
  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqAllGuildMarkRegInfo
  00032	83 c4 08	 add	 esp, 8
$LN2@CGReqCsReg:

; 21096: //#endif
; 21097: }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ENDP ; CGReqCsRegGuildList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ; CGReqCsAttkGuildList
EXTRN	?GetCsAttkGuildList@CCastleSiege@@QAEHPAUPMSG_CSATTKGUILDLIST@@AAH@Z:PROC ; CCastleSiege::GetCsAttkGuildList
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z
_TEXT	SEGMENT
_iCount$ = -1636					; size = 4
_cBUFFER$ = -1632					; size = 1625
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z PROC ; CGReqCsAttkGuildList, COMDAT

; 21100: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 06 00
	00		 sub	 esp, 1636		; 00000664H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21101: //#if(GS_CASTLE==1)
; 21102: 	char cBUFFER[1625]; //season 2.5 changed old -> 1022
; 21103: 	PMSG_ANS_CSATTKGUILDLIST* lpMsgSend;
; 21104: 	PMSG_CSATTKGUILDLIST* lpMsgSendBody;
; 21105: 	int iCount;
; 21106: 
; 21107: 	if( lpMsg == NULL )	return;

  00013	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00017	0f 84 85 00 00
	00		 je	 $LN4@CGReqCsAtt

; 21108: 	
; 21109: 	lpMsgSend = (PMSG_ANS_CSATTKGUILDLIST*)(cBUFFER);
; 21110: 	lpMsgSendBody = (PMSG_CSATTKGUILDLIST*)(cBUFFER+sizeof(PMSG_ANS_CSATTKGUILDLIST));
; 21111: 
; 21112: 	iCount = 0;
; 21113: 
; 21114: 	lpMsgSend->btResult = g_CastleSiege.GetCsAttkGuildList(lpMsgSendBody, iCount);

  0001d	8d 85 9c f9 ff
	ff		 lea	 eax, DWORD PTR _iCount$[ebp]
  00023	50		 push	 eax
  00024	8d 8d ac f9 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER$[ebp+12]
  0002a	51		 push	 ecx
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00030	c7 85 9c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCount$[ebp], 0
  0003a	e8 00 00 00 00	 call	 ?GetCsAttkGuildList@CCastleSiege@@QAEHPAUPMSG_CSATTKGUILDLIST@@AAH@Z ; CCastleSiege::GetCsAttkGuildList
  0003f	88 85 a4 f9 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+4], al

; 21115: 	lpMsgSend->iCount = iCount;

  00045	8b 85 9c f9 ff
	ff		 mov	 eax, DWORD PTR _iCount$[ebp]
  0004b	89 85 a8 f9 ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], eax

; 21116: 
; 21117: 	if( lpMsgSend->iCount < 0 )	 lpMsgSend->iCount = 0;

  00051	85 c0		 test	 eax, eax
  00053	79 04		 jns	 SHORT $LN2@CGReqCsAtt
  00055	33 c0		 xor	 eax, eax

; 21118: 	if( lpMsgSend->iCount > 100 )lpMsgSend->iCount = 100;

  00057	eb 0a		 jmp	 SHORT $LN8@CGReqCsAtt
$LN2@CGReqCsAtt:
  00059	83 f8 64	 cmp	 eax, 100		; 00000064H
  0005c	7e 0b		 jle	 SHORT $LN1@CGReqCsAtt
  0005e	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
$LN8@CGReqCsAtt:
  00063	89 85 a8 f9 ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], eax
$LN1@CGReqCsAtt:

; 21119: 
; 21120: 	lpMsgSend->h.set((LPBYTE)lpMsgSend, 0xB5, ((lpMsgSend->iCount*sizeof(PMSG_CSATTKGUILDLIST))+sizeof(PMSG_ANS_CSATTKGUILDLIST)));
; 21121: 	DataSend(iIndex, (LPBYTE)lpMsgSend, ((lpMsgSend->iCount*sizeof(PMSG_CSATTKGUILDLIST))+sizeof(PMSG_ANS_CSATTKGUILDLIST)));

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0006c	c1 e0 04	 shl	 eax, 4
  0006f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00072	50		 push	 eax
  00073	8b d0		 mov	 edx, eax
  00075	88 85 a2 f9 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], al
  0007b	8d 85 a0 f9 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00081	50		 push	 eax
  00082	c1 ea 08	 shr	 edx, 8
  00085	51		 push	 ecx
  00086	c6 85 a0 f9 ff
	ff c2		 mov	 BYTE PTR _cBUFFER$[ebp], 194 ; 000000c2H
  0008d	88 95 a1 f9 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], dl
  00093	c6 85 a3 f9 ff
	ff b5		 mov	 BYTE PTR _cBUFFER$[ebp+3], 181 ; 000000b5H
  0009a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CGReqCsAtt:

; 21122: //#endif
; 21123: }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ENDP ; CGReqCsAttkGuildList
_TEXT	ENDS
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z	; CGReqWeaponUse
EXTRN	?SetWeaponCalDamageInfo@CWeapon@@QAEHGEEH@Z:PROC ; CWeapon::SetWeaponCalDamageInfo
EXTRN	?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z:PROC ; gObjNotifyUseWeaponV1
EXTRN	?GetTargetPointXY@CWeapon@@QAEHHHAAE0H@Z:PROC	; CWeapon::GetTargetPointXY
EXTRN	?g_CsNPC_Weapon@@3VCWeapon@@A:BYTE		; g_CsNPC_Weapon
; Function compile flags: /Ogtp
;	COMDAT ?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z
_TEXT	SEGMENT
_lpOwnerObj$ = -32					; size = 4
_iIndex$GSCopy$ = -28					; size = 4
tv223 = -24						; size = 4
_pMsg$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z PROC	; CGReqWeaponUse, COMDAT

; 21126: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00013	53		 push	 ebx
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 21127: 	WORD wObjIndex = MAKE_NUMBERW(aRecv->btObjIndexH, aRecv->btObjIndexL);

  00018	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0001c	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00020	66 c1 e0 08	 shl	 ax, 8
  00024	66 0b c2	 or	 ax, dx
  00027	0f b7 d8	 movzx	 ebx, ax

; 21128: 
; 21129: 	if ( !OBJMAX_RANGE(wObjIndex))

  0002a	b8 97 3a 00 00	 mov	 eax, 14999		; 00003a97H
  0002f	66 3b c3	 cmp	 ax, bx
  00032	1b c0		 sbb	 eax, eax
  00034	40		 inc	 eax

; 21185: 				}
; 21186: 			}
; 21187: 		}
; 21188: 	}
; 21189: 
; 21190: 	gObjNotifyUseWeaponV1(lpOwnerObj, lpWeaponObj, pMsg.btPointX, pMsg.btPointY);

  00035	89 4d e4	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], ecx
  00038	0f 84 4d 01 00
	00		 je	 $LN14@CGReqWeapo

; 21130: 	{
; 21131: 		return;
; 21132: 	}
; 21133: 
; 21134: 	if ( !OBJMAX_RANGE(iIndex))

  0003e	85 c9		 test	 ecx, ecx
  00040	0f 88 45 01 00
	00		 js	 $LN14@CGReqWeapo
  00046	33 c0		 xor	 eax, eax
  00048	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0004e	0f 9e c0	 setle	 al
  00051	85 c0		 test	 eax, eax
  00053	0f 84 32 01 00
	00		 je	 $LN14@CGReqWeapo

; 21135: 	{
; 21136: 		return;
; 21137: 	}
; 21138: 
; 21139: 	LPOBJ lpOwnerObj = &gObj[iIndex];

  00059	56		 push	 esi
  0005a	8b c1		 mov	 eax, ecx
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00062	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H

; 21140: 	LPOBJ lpWeaponObj = &gObj[wObjIndex];

  00068	8b f3		 mov	 esi, ebx
  0006a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00070	03 c1		 add	 eax, ecx
  00072	03 f1		 add	 esi, ecx

; 21141: 
; 21142: 	if ( lpOwnerObj->Type != OBJ_USER )

  00074	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  00079	89 45 e0	 mov	 DWORD PTR _lpOwnerObj$[ebp], eax
  0007c	0f 85 08 01 00
	00		 jne	 $LN22@CGReqWeapo

; 21143: 	{
; 21144: 		return;
; 21145: 	}
; 21146: 
; 21147: 	if ( lpWeaponObj->Type != OBJ_NPC )

  00082	66 83 7e 68 03	 cmp	 WORD PTR [esi+104], 3
  00087	0f 85 fd 00 00
	00		 jne	 $LN22@CGReqWeapo

; 21148: 	{
; 21149: 		return;
; 21150: 	}
; 21151: 
; 21152: 	PMSG_ANS_USEWEAPON pMsg = {0};
; 21153: 
; 21154: 	PHeadSubSetB((LPBYTE)&pMsg, 0xB7, 0x01, sizeof(pMsg));

  0008d	6a 0a		 push	 10			; 0000000aH
  0008f	6a 01		 push	 1
  00091	33 c0		 xor	 eax, eax
  00093	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00096	68 b7 00 00 00	 push	 183			; 000000b7H
  0009b	51		 push	 ecx
  0009c	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  000a0	89 45 ed	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  000a3	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  000a6	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+9], al
  000a9	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21155: 	pMsg.btResult = 1;

  000ae	c6 45 f0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 21156: 
; 21157: 	if ( lpWeaponObj->Class == 221 )	// Slingshot attack

  000b2	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  000b9	ba dd 00 00 00	 mov	 edx, 221		; 000000ddH
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	66 3b c2	 cmp	 ax, dx
  000c4	75 06		 jne	 SHORT $LN9@CGReqWeapo

; 21158: 	{
; 21159: 		pMsg.btWeaponType = 1;

  000c6	c6 45 f3 01	 mov	 BYTE PTR _pMsg$[ebp+7], 1

; 21160: 		pMsg.btObjIndexH = SET_NUMBERH(wObjIndex);
; 21161: 		pMsg.btObjIndexL = SET_NUMBERL(wObjIndex);
; 21162: 		g_CsNPC_Weapon.GetTargetPointXY(lpWeaponObj->Class, aRecv->btTargetIndex-1, pMsg.btPointX, pMsg.btPointY, TRUE);

  000ca	eb 0e		 jmp	 SHORT $LN23@CGReqWeapo
$LN9@CGReqWeapo:

; 21163: 	}
; 21164: 	else if( lpWeaponObj->Class == 222 )	// Slingshot defense

  000cc	ba de 00 00 00	 mov	 edx, 222		; 000000deH
  000d1	66 3b c2	 cmp	 ax, dx
  000d4	75 31		 jne	 SHORT $LN7@CGReqWeapo

; 21165: 	{
; 21166: 		pMsg.btWeaponType = 2;

  000d6	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+7], 2
$LN23@CGReqWeapo:

; 21167: 		pMsg.btObjIndexH = SET_NUMBERH(wObjIndex);

  000da	8b c3		 mov	 eax, ebx
  000dc	c1 e8 08	 shr	 eax, 8

; 21168: 		pMsg.btObjIndexL = SET_NUMBERL(wObjIndex);
; 21169: 		g_CsNPC_Weapon.GetTargetPointXY(lpWeaponObj->Class, aRecv->btTargetIndex-1, pMsg.btPointX, pMsg.btPointY, TRUE);

  000df	6a 01		 push	 1
  000e1	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  000e4	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  000e8	8d 4d f5	 lea	 ecx, DWORD PTR _pMsg$[ebp+9]
  000eb	51		 push	 ecx
  000ec	8d 55 f4	 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  000ef	52		 push	 edx
  000f0	88 5d f2	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  000f3	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  000fa	48		 dec	 eax
  000fb	50		 push	 eax
  000fc	51		 push	 ecx
  000fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  00102	e8 00 00 00 00	 call	 ?GetTargetPointXY@CWeapon@@QAEHHHAAE0H@Z ; CWeapon::GetTargetPointXY
$LN7@CGReqWeapo:

; 21170: 	}
; 21171: 
; 21172: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00107	8b 45 e4	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  0010a	6a 0a		 push	 10			; 0000000aH
  0010c	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0010f	52		 push	 edx
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21173: 
; 21174: 	pMsg.btResult = 2;

  00119	c6 45 f0 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  0011d	8d be ae 08 00
	00		 lea	 edi, DWORD PTR [esi+2222]
  00123	c7 45 e8 4b 00
	00 00		 mov	 DWORD PTR tv223[ebp], 75 ; 0000004bH
  0012a	8d 9b 00 00 00
	00		 npad	 6
$LL6@CGReqWeapo:

; 21177: 	{
; 21178: 		if ( lpWeaponObj->VpPlayer2[n].type == OBJ_USER )

  00130	80 7f 02 01	 cmp	 BYTE PTR [edi+2], 1
  00134	75 1d		 jne	 SHORT $LN5@CGReqWeapo

; 21179: 		{
; 21180: 			if ( lpWeaponObj->VpPlayer2[n].state )

  00136	80 7f fe 00	 cmp	 BYTE PTR [edi-2], 0
  0013a	74 17		 je	 SHORT $LN5@CGReqWeapo

; 21181: 			{
; 21182: 				if ( iIndex != lpWeaponObj->VpPlayer2[n].number )

  0013c	0f bf 07	 movsx	 eax, WORD PTR [edi]
  0013f	39 45 e4	 cmp	 DWORD PTR _iIndex$GSCopy$[ebp], eax
  00142	74 0f		 je	 SHORT $LN5@CGReqWeapo

; 21183: 				{
; 21184: 					DataSend(lpWeaponObj->VpPlayer2[n].number, (LPBYTE)&pMsg, sizeof(pMsg));

  00144	6a 0a		 push	 10			; 0000000aH
  00146	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00149	51		 push	 ecx
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CGReqWeapo:

; 21175: 
; 21176: 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00153	83 c7 0c	 add	 edi, 12			; 0000000cH
  00156	ff 4d e8	 dec	 DWORD PTR tv223[ebp]
  00159	75 d5		 jne	 SHORT $LL6@CGReqWeapo

; 21185: 				}
; 21186: 			}
; 21187: 		}
; 21188: 	}
; 21189: 
; 21190: 	gObjNotifyUseWeaponV1(lpOwnerObj, lpWeaponObj, pMsg.btPointX, pMsg.btPointY);

  0015b	0f b6 55 f5	 movzx	 edx, BYTE PTR _pMsg$[ebp+9]
  0015f	0f b6 45 f4	 movzx	 eax, BYTE PTR _pMsg$[ebp+8]
  00163	8b 4d e0	 mov	 ecx, DWORD PTR _lpOwnerObj$[ebp]
  00166	52		 push	 edx
  00167	50		 push	 eax
  00168	56		 push	 esi
  00169	51		 push	 ecx
  0016a	e8 00 00 00 00	 call	 ?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjNotifyUseWeaponV1

; 21191: 	g_CsNPC_Weapon.SetWeaponCalDamageInfo(wObjIndex, pMsg.btPointX, pMsg.btPointY, 10000);

  0016f	8b 55 f5	 mov	 edx, DWORD PTR _pMsg$[ebp+9]
  00172	8b 45 f4	 mov	 eax, DWORD PTR _pMsg$[ebp+8]
  00175	83 c4 10	 add	 esp, 16			; 00000010H
  00178	68 10 27 00 00	 push	 10000			; 00002710H
  0017d	52		 push	 edx
  0017e	50		 push	 eax
  0017f	53		 push	 ebx
  00180	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  00185	e8 00 00 00 00	 call	 ?SetWeaponCalDamageInfo@CWeapon@@QAEHGEEH@Z ; CWeapon::SetWeaponCalDamageInfo
$LN22@CGReqWeapo:
  0018a	5e		 pop	 esi
$LN14@CGReqWeapo:

; 21192: }

  0018b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018e	5f		 pop	 edi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c3		 ret	 0
?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z ENDP	; CGReqWeaponUse
_TEXT	ENDS
PUBLIC	?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ; CGReqWeaponDamageValue
EXTRN	?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjNotifyUseWeaponDamage
EXTRN	?GetWeaponCalDamageInfo@CWeapon@@QAEHGAAE0@Z:PROC ; CWeapon::GetWeaponCalDamageInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z
_TEXT	SEGMENT
_btTargetX$ = -1					; size = 1
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
_btTargetY$ = 15					; size = 1
?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z PROC ; CGReqWeaponDamageValue, COMDAT

; 21195: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 21196: 	if ( !OBJMAX_RANGE(iIndex) )

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b f9		 cmp	 edi, ecx
  0000c	0f 8c 84 00 00
	00		 jl	 $LN1@CGReqWeapo@2
  00012	33 c0		 xor	 eax, eax
  00014	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0001a	0f 9e c0	 setle	 al
  0001d	3b c1		 cmp	 eax, ecx
  0001f	74 75		 je	 SHORT $LN1@CGReqWeapo@2

; 21197: 	{
; 21198: 		return;
; 21199: 	}
; 21200: 
; 21201: 	BYTE btTargetX = 0;
; 21202: 	BYTE btTargetY = 0;
; 21203: 	WORD wObjIndex = MAKE_NUMBERW(aRecv->btObjIndexH, aRecv->btObjIndexL);

  00021	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00024	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00028	88 4d ff	 mov	 BYTE PTR _btTargetX$[ebp], cl
  0002b	88 4d 0f	 mov	 BYTE PTR _btTargetY$[ebp], cl
  0002e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00032	66 c1 e1 08	 shl	 cx, 8
  00036	56		 push	 esi
  00037	66 0b ca	 or	 cx, dx
  0003a	0f b7 f1	 movzx	 esi, cx

; 21204: 
; 21205: 	if ( g_CsNPC_Weapon.GetWeaponCalDamageInfo(wObjIndex, btTargetX, btTargetY) == TRUE )

  0003d	8d 45 0f	 lea	 eax, DWORD PTR _btTargetY$[ebp]
  00040	50		 push	 eax
  00041	8d 4d ff	 lea	 ecx, DWORD PTR _btTargetX$[ebp]
  00044	51		 push	 ecx
  00045	56		 push	 esi
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  0004b	e8 00 00 00 00	 call	 ?GetWeaponCalDamageInfo@CWeapon@@QAEHGAAE0@Z ; CWeapon::GetWeaponCalDamageInfo
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 27		 jne	 SHORT $LN2@CGReqWeapo@2

; 21206: 	{
; 21207: 		gObjNotifyUseWeaponDamage(&gObj[wObjIndex], btTargetX, btTargetY);

  00055	0f b6 55 0f	 movzx	 edx, BYTE PTR _btTargetY$[ebp]
  00059	0f b6 45 ff	 movzx	 eax, BYTE PTR _btTargetX$[ebp]
  0005d	8b ce		 mov	 ecx, esi
  0005f	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00065	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006b	52		 push	 edx
  0006c	50		 push	 eax
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ; gObjNotifyUseWeaponDamage
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	5e		 pop	 esi
  00077	5f		 pop	 edi

; 21212: 	}
; 21213: }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN2@CGReqWeapo@2:

; 21208: 	}
; 21209: 	else
; 21210: 	{
; 21211: 		MsgOutput(iIndex, lMsg.Get(MSGGET(6, 112)));

  0007c	68 70 06 00 00	 push	 1648			; 00000670H
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00086	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0008b	50		 push	 eax
  0008c	57		 push	 edi
  0008d	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00092	83 c4 08	 add	 esp, 8
  00095	5e		 pop	 esi
$LN1@CGReqWeapo@2:
  00096	5f		 pop	 edi

; 21212: 	}
; 21213: }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ENDP ; CGReqWeaponDamageValue
_TEXT	ENDS
PUBLIC	?GCSendObjectCreationState@@YAXH@Z		; GCSendObjectCreationState
; Function compile flags: /Ogtp
;	COMDAT ?GCSendObjectCreationState@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_iObjectIndex$ = 8					; size = 4
?GCSendObjectCreationState@@YAXH@Z PROC			; GCSendObjectCreationState, COMDAT

; 21217: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 21218: 	if ( !OBJMAX_RANGE(iObjectIndex) )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iObjectIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	78 6f		 js	 SHORT $LN1@GCSendObje
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 60		 je	 SHORT $LN1@GCSendObje

; 21219: 	{
; 21220: 		return;
; 21221: 	}
; 21222: 
; 21223: 	LPOBJ lpObj = &gObj[iObjectIndex];

  0001d	56		 push	 esi
  0001e	8b f3		 mov	 esi, ebx
  00020	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00026	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 21224: 	PMSG_NOTIFY_OBJECT_CREATION_STATE	pMsg = {0};

  0002c	33 c0		 xor	 eax, eax
  0002e	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00031	66 89 45 fd	 mov	 WORD PTR _pMsg$[ebp+5], ax

; 21225: 
; 21226: 	if(lpObj->Class == 278)

  00035	b8 16 01 00 00	 mov	 eax, 278		; 00000116H
  0003a	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003e	66 39 86 b8 00
	00 00		 cmp	 WORD PTR [esi+184], ax
  00045	75 35		 jne	 SHORT $LN7@GCSendObje

; 21227: 	{
; 21228: 		PHeadSubSetB((LPBYTE)&pMsg, 0xB9, 0x01, sizeof(pMsg));

  00047	6a 07		 push	 7
  00049	6a 01		 push	 1
  0004b	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004e	68 b9 00 00 00	 push	 185			; 000000b9H
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21229: 		pMsg.btObjIndexH = SET_NUMBERH(iObjectIndex);

  00059	8b d3		 mov	 edx, ebx
  0005b	c1 ea 08	 shr	 edx, 8

; 21230: 		pMsg.btObjIndexL = SET_NUMBERL(iObjectIndex);
; 21231: 		pMsg.btCreationState = lpObj->m_btCreationState;
; 21232: 		MsgSendV2(lpObj, (LPBYTE)&pMsg, sizeof(pMsg)); 

  0005e	6a 07		 push	 7
  00060	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00063	88 55 fc	 mov	 BYTE PTR _pMsg$[ebp+4], dl
  00066	88 5d fd	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00069	8a 86 15 1c 00
	00		 mov	 al, BYTE PTR [esi+7189]
  0006f	51		 push	 ecx
  00070	56		 push	 esi
  00071	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00074	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00079	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN7@GCSendObje:
  0007c	5e		 pop	 esi
$LN1@GCSendObje:
  0007d	5b		 pop	 ebx

; 21233: 	}
; 21234: }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?GCSendObjectCreationState@@YAXH@Z ENDP			; GCSendObjectCreationState
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ; CGReqGuildMarkOfCastleOwner
; Function compile flags: /Ogtp
;	COMDAT ?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z
_TEXT	SEGMENT
_pMsg$252408 = -52					; size = 36
_szGuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z PROC ; CGReqGuildMarkOfCastleOwner, COMDAT

; 21238: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]

; 21239: 	if ( !OBJMAX_RANGE(iIndex) )

  00014	85 db		 test	 ebx, ebx
  00016	0f 88 97 00 00
	00		 js	 $LN1@CGReqGuild@2
  0001c	33 c0		 xor	 eax, eax
  0001e	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 84 00 00
	00		 je	 $LN1@CGReqGuild@2

; 21240: 	{
; 21241: 		return;
; 21242: 	}
; 21243: 
; 21244: 	LPOBJ lpObj = &gObj[iIndex];
; 21245: 	char szGuildName[MAX_GUILD_LEN+1] = {0};
; 21246: 
; 21247: 	memcpy(szGuildName, g_CastleSiegeSync.GetCastleOwnerGuild(), MAX_GUILD_LEN);

  0002f	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+28
  00035	33 c0		 xor	 eax, eax
  00037	89 45 f1	 mov	 DWORD PTR _szGuildName$[ebp+1], eax
  0003a	89 45 f5	 mov	 DWORD PTR _szGuildName$[ebp+5], eax
  0003d	a1 18 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+24
  00042	56		 push	 esi

; 21248: 
; 21249: 	if ( szGuildName )
; 21250: 	{
; 21251: 		_GUILD_INFO_STRUCT * lpGuild = Guild.SearchGuild(szGuildName);

  00043	8d 55 f0	 lea	 edx, DWORD PTR _szGuildName$[ebp]
  00046	89 4d f4	 mov	 DWORD PTR _szGuildName$[ebp+4], ecx
  00049	52		 push	 edx
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0004f	89 45 f0	 mov	 DWORD PTR _szGuildName$[ebp], eax
  00052	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00057	8b f0		 mov	 esi, eax

; 21252: 
; 21253: 		if ( lpGuild != NULL )

  00059	85 f6		 test	 esi, esi
  0005b	74 55		 je	 SHORT $LN10@CGReqGuild@2

; 21254: 		{
; 21255: 			PMSG_ANS_GUILDMARK_OF_CASTLEOWNER pMsg = {0};

  0005d	33 c0		 xor	 eax, eax
  0005f	57		 push	 edi

; 21256: 
; 21257: 			PHeadSubSetB((LPBYTE)&pMsg, 0xB9, 0x02, sizeof(pMsg));

  00060	6a 24		 push	 36			; 00000024H
  00062	6a 02		 push	 2
  00064	89 45 cd	 mov	 DWORD PTR _pMsg$252408[ebp+1], eax
  00067	89 45 d1	 mov	 DWORD PTR _pMsg$252408[ebp+5], eax
  0006a	89 45 d5	 mov	 DWORD PTR _pMsg$252408[ebp+9], eax
  0006d	89 45 d9	 mov	 DWORD PTR _pMsg$252408[ebp+13], eax
  00070	89 45 dd	 mov	 DWORD PTR _pMsg$252408[ebp+17], eax
  00073	89 45 e1	 mov	 DWORD PTR _pMsg$252408[ebp+21], eax
  00076	89 45 e5	 mov	 DWORD PTR _pMsg$252408[ebp+25], eax
  00079	89 45 e9	 mov	 DWORD PTR _pMsg$252408[ebp+29], eax
  0007c	66 89 45 ed	 mov	 WORD PTR _pMsg$252408[ebp+33], ax
  00080	88 45 ef	 mov	 BYTE PTR _pMsg$252408[ebp+35], al
  00083	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$252408[ebp]
  00086	68 b9 00 00 00	 push	 185			; 000000b9H
  0008b	50		 push	 eax
  0008c	c6 45 cc 00	 mov	 BYTE PTR _pMsg$252408[ebp], 0
  00090	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21258: 			memcpy(pMsg.GuildMarkOfCastleOwner, lpGuild->Mark, sizeof(pMsg.GuildMarkOfCastleOwner));

  00095	83 c6 0d	 add	 esi, 13			; 0000000dH
  00098	b9 08 00 00 00	 mov	 ecx, 8
  0009d	8d 7d d0	 lea	 edi, DWORD PTR _pMsg$252408[ebp+4]
  000a0	f3 a5		 rep movsd

; 21259: 
; 21260: 			DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000a2	6a 24		 push	 36			; 00000024H
  000a4	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$252408[ebp]
  000a7	51		 push	 ecx
  000a8	53		 push	 ebx
  000a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ae	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b1	5f		 pop	 edi
$LN10@CGReqGuild@2:
  000b2	5e		 pop	 esi
$LN1@CGReqGuild@2:

; 21261: 		}
; 21262: 	}
; 21263: }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	5b		 pop	 ebx
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ENDP ; CGReqGuildMarkOfCastleOwner
_TEXT	ENDS
PUBLIC	??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@ ; `string'
PUBLIC	?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ; CGReqCastleHuntZoneEntrance
EXTRN	?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckCastleOwnerUnionMember
EXTRN	?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckCastleOwnerMember
EXTRN	?GetTaxHuntZone@CCastleSiegeSync@@QAEHHH@Z:PROC	; CCastleSiegeSync::GetTaxHuntZone
;	COMDAT ??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@ DB '['
	DB	'Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z PROC ; CGReqCastleHuntZoneEntrance, COMDAT

; 21267: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 21268: 	if( !OBJMAX_RANGE(iIndex) )

  00008	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000b	33 db		 xor	 ebx, ebx
  0000d	3b f3		 cmp	 esi, ebx
  0000f	0f 8c 31 01 00
	00		 jl	 $LN14@CGReqCastl@2
  00015	33 c0		 xor	 eax, eax
  00017	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  0001d	0f 9e c0	 setle	 al
  00020	3b c3		 cmp	 eax, ebx
  00022	0f 84 1e 01 00
	00		 je	 $LN14@CGReqCastl@2

; 21269: 	{
; 21270: 		return;
; 21271: 	}
; 21272: 	
; 21273: 	LPOBJ lpObj = &gObj[iIndex];

  00028	57		 push	 edi
  00029	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 21274: 
; 21275: 	PMSG_ANS_MOVE_TO_CASTLE_HUNTZONE pMsg = {0};
; 21276: 
; 21277: 	PHeadSubSetB((LPBYTE)&pMsg, 0xB9, 0x05, sizeof(pMsg));

  00035	6a 05		 push	 5
  00037	6a 05		 push	 5
  00039	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003c	68 b9 00 00 00	 push	 185			; 000000b9H
  00041	50		 push	 eax
  00042	88 5d f8	 mov	 BYTE PTR _pMsg$[ebp], bl
  00045	89 5d f9	 mov	 DWORD PTR _pMsg$[ebp+1], ebx
  00048	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 21278: 
; 21279: 	pMsg.btResult = 0;

  00050	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl

; 21280: 
; 21281: 	int iEnterTaxMoney = 0;
; 21282: 
; 21283: 	iEnterTaxMoney = g_CastleSiegeSync.GetTaxHuntZone(lpObj->m_Index, TRUE);

  00053	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00055	6a 01		 push	 1
  00057	51		 push	 ecx
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0005d	e8 00 00 00 00	 call	 ?GetTaxHuntZone@CCastleSiegeSync@@QAEHHH@Z ; CCastleSiegeSync::GetTaxHuntZone
  00062	8b f8		 mov	 edi, eax

; 21284: 
; 21285: 	if( iEnterTaxMoney < 0)

  00064	3b fb		 cmp	 edi, ebx
  00066	7d 02		 jge	 SHORT $LN12@CGReqCastl@2

; 21286: 	{
; 21287: 		iEnterTaxMoney = 0;

  00068	33 ff		 xor	 edi, edi
$LN12@CGReqCastl@2:

; 21288: 	}
; 21289: 
; 21290: 	BOOL bPermission = FALSE;
; 21291: 
; 21292: 	if( g_CastleSiege.GetHuntZoneEnter() )

  0006a	a1 fc 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+252
  0006f	85 c0		 test	 eax, eax
  00071	74 05		 je	 SHORT $LN23@CGReqCastl@2

; 21293: 	{
; 21294: 		bPermission = TRUE;

  00073	bb 01 00 00 00	 mov	 ebx, 1
$LN23@CGReqCastl@2:

; 21295: 	}
; 21296: 
; 21297: 	if( lpObj->lpGuild )

  00078	83 be 38 04 00
	00 00		 cmp	 DWORD PTR [esi+1080], 0
  0007f	74 23		 je	 SHORT $LN10@CGReqCastl@2

; 21298: 	{
; 21299: 		if( g_CastleSiege.CheckCastleOwnerMember(lpObj->m_Index) )

  00081	8b 16		 mov	 edx, DWORD PTR [esi]
  00083	52		 push	 edx
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00089	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  0008e	85 c0		 test	 eax, eax
  00090	74 05		 je	 SHORT $LN9@CGReqCastl@2

; 21300: 		{
; 21301: 			bPermission = TRUE;

  00092	bb 01 00 00 00	 mov	 ebx, 1
$LN9@CGReqCastl@2:

; 21302: 		}
; 21303: 
; 21304: 		if( g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) )

  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	50		 push	 eax
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009f	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
$LN10@CGReqCastl@2:

; 21305: 		{
; 21306: 			bPermission = TRUE;
; 21307: 		}
; 21308: 	}
; 21309: 	else
; 21310: 	{
; 21311: 		if( g_CastleSiege.GetHuntZoneEnter() )

  000a4	85 c0		 test	 eax, eax

; 21312: 		{
; 21313: 			bPermission = TRUE;
; 21314: 		}
; 21315: 	}
; 21316: 
; 21317: 	if( bPermission == TRUE )

  000a6	75 09		 jne	 SHORT $LN22@CGReqCastl@2
  000a8	83 fb 01	 cmp	 ebx, 1
  000ab	0f 85 82 00 00
	00		 jne	 $LN2@CGReqCastl@2
$LN22@CGReqCastl@2:

; 21318: 	{
; 21319: 		if( lpObj->Money >= iEnterTaxMoney )

  000b1	39 be f0 00 00
	00		 cmp	 DWORD PTR [esi+240], edi
  000b7	7c 7a		 jl	 SHORT $LN2@CGReqCastl@2

; 21320: 		{
; 21321: 			if( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )

  000b9	80 be 49 01 00
	00 1e		 cmp	 BYTE PTR [esi+329], 30	; 0000001eH
  000c0	75 71		 jne	 SHORT $LN2@CGReqCastl@2

; 21322: 			{
; 21323: 				if( gObjMoveGate(lpObj->m_Index, 95) == TRUE )

  000c2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000c4	6a 5f		 push	 95			; 0000005fH
  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000cc	83 c4 08	 add	 esp, 8
  000cf	83 f8 01	 cmp	 eax, 1
  000d2	75 5f		 jne	 SHORT $LN2@CGReqCastl@2

; 21324: 				{
; 21325: 					pMsg.btResult = 1;

  000d4	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 21326: 					int iOldMoney = lpObj->Money;

  000d7	8b 9e f0 00 00
	00		 mov	 ebx, DWORD PTR [esi+240]

; 21327: 
; 21328: 					lpObj->Money -= iEnterTaxMoney;

  000dd	8b d3		 mov	 edx, ebx
  000df	2b d7		 sub	 edx, edi

; 21329: 
; 21330: 					g_CastleSiegeSync.AddTributeMoney(iEnterTaxMoney);

  000e1	57		 push	 edi
  000e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000e7	89 96 f0 00 00
	00		 mov	 DWORD PTR [esi+240], edx
  000ed	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 21331: 					
; 21332: 					if( lpObj->Money < 0)

  000f2	83 be f0 00 00
	00 00		 cmp	 DWORD PTR [esi+240], 0
  000f9	7d 0a		 jge	 SHORT $LN1@CGReqCastl@2

; 21333: 					{
; 21334: 						lpObj->Money = 0;

  000fb	c7 86 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+240], 0
$LN1@CGReqCastl@2:

; 21335: 					}
; 21336: 					
; 21337: 					GCMoneySend(lpObj->m_Index, lpObj->Money);

  00105	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  0010b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0010d	50		 push	 eax
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 21338: 
; 21339: 					LogAddTD("[Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d", lpObj->AccountID, lpObj->Name, iOldMoney, iEnterTaxMoney, lpObj->Money);

  00114	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  0011a	52		 push	 edx
  0011b	57		 push	 edi
  0011c	53		 push	 ebx
  0011d	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00120	50		 push	 eax
  00121	83 c6 6c	 add	 esi, 108		; 0000006cH
  00124	56		 push	 esi
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00130	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@CGReqCastl@2:

; 21340: 				}
; 21341: 			}
; 21342: 		}
; 21343: 	}
; 21344: 
; 21345: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00133	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00136	6a 05		 push	 5
  00138	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0013b	51		 push	 ecx
  0013c	52		 push	 edx
  0013d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
  00145	5f		 pop	 edi
$LN14@CGReqCastl@2:
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx

; 21346: }

  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ENDP ; CGReqCastleHuntZoneEntrance
_TEXT	ENDS
PUBLIC	?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z	; CGReqJewelMix
EXTRN	?MixJewel@CJewelMixSystem@@SAHHHH@Z:PROC	; CJewelMixSystem::MixJewel
; Function compile flags: /Ogtp
;	COMDAT ?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z PROC	; CGReqJewelMix, COMDAT

; 21350: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21351: 	if ( lpMsg == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 16		 je	 SHORT $LN2@CGReqJewel

; 21352: 	{
; 21353: 		return;
; 21354: 	}
; 21355: 
; 21356: 	CJewelMixSystem::MixJewel(iIndex, lpMsg->btJewelType, lpMsg->btJewelMix);

  0000a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0000e	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?MixJewel@CJewelMixSystem@@SAHHHH@Z ; CJewelMixSystem::MixJewel
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGReqJewel:

; 21357: }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z ENDP	; CGReqJewelMix
_TEXT	ENDS
PUBLIC	?GCAnsJewelMix@@YAXHH@Z				; GCAnsJewelMix
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsJewelMix@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsJewelMix@@YAXHH@Z PROC				; GCAnsJewelMix, COMDAT

; 21360: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 21361: 	PMSG_ANS_JEWEL_UNMIX pMsg;
; 21362: 
; 21363: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBC, 0x00, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 00		 push	 0
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bc 00 00 00	 push	 188			; 000000bcH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21364: 	pMsg.btResult = iResult;
; 21365: 
; 21366: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00018	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001b	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  0001e	6a 05		 push	 5
  00020	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00023	52		 push	 edx
  00024	50		 push	 eax
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 21367: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GCAnsJewelMix@@YAXHH@Z ENDP				; GCAnsJewelMix
_TEXT	ENDS
PUBLIC	?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ; CGReqJewelUnMix
EXTRN	?UnMixJewel@CJewelMixSystem@@SAHHHHH@Z:PROC	; CJewelMixSystem::UnMixJewel
; Function compile flags: /Ogtp
;	COMDAT ?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z PROC	; CGReqJewelUnMix, COMDAT

; 21370: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21371: 	if ( lpMsg == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1b		 je	 SHORT $LN2@CGReqJewel@2

; 21372: 	{
; 21373: 		return;
; 21374: 	}
; 21375: 
; 21376: 	CJewelMixSystem::UnMixJewel(iIndex, lpMsg->btJewelType, lpMsg->btJewelLevel, lpMsg->btJewelPos);

  0000a	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0000e	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00016	51		 push	 ecx
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0001a	52		 push	 edx
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ?UnMixJewel@CJewelMixSystem@@SAHHHHH@Z ; CJewelMixSystem::UnMixJewel
  00022	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@CGReqJewel@2:

; 21377: }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ENDP	; CGReqJewelUnMix
_TEXT	ENDS
PUBLIC	?GCAnsJewelUnMix@@YAXHH@Z			; GCAnsJewelUnMix
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsJewelUnMix@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsJewelUnMix@@YAXHH@Z PROC				; GCAnsJewelUnMix, COMDAT

; 21380: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 21381: 	PMSG_ANS_JEWEL_UNMIX pMsg;
; 21382: 
; 21383: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBC, 0x01, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bc 00 00 00	 push	 188			; 000000bcH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21384: 	pMsg.btResult = iResult;
; 21385: 
; 21386: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00018	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0001b	8a 4d 0c	 mov	 cl, BYTE PTR _iResult$[ebp]
  0001e	6a 05		 push	 5
  00020	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00023	52		 push	 edx
  00024	50		 push	 eax
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 21387: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?GCAnsJewelUnMix@@YAXHH@Z ENDP				; GCAnsJewelUnMix
_TEXT	ENDS
PUBLIC	?GCAnsCrywolfInfo@@YAXHEE@Z			; GCAnsCrywolfInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsCrywolfInfo@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iIndex$ = 8						; size = 4
_btOccupationState$ = 12				; size = 1
_btCrywolfState$ = 16					; size = 1
?GCAnsCrywolfInfo@@YAXHEE@Z PROC			; GCAnsCrywolfInfo, COMDAT

; 21406: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 21407: 	PMSG_ANS_CRYWOLF_INFO pMsg={0};

  00006	33 c0		 xor	 eax, eax

; 21408: 
; 21409: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x00, sizeof(pMsg));

  00008	6a 06		 push	 6
  0000a	50		 push	 eax
  0000b	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp], al
  0000e	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00011	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00014	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	68 bd 00 00 00	 push	 189			; 000000bdH
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21410: 	pMsg.btOccupationState = btOccupationState;

  00022	8a 4d 0c	 mov	 cl, BYTE PTR _btOccupationState$[ebp]

; 21411: 	pMsg.btCrywolfState = btCrywolfState;

  00025	8a 55 10	 mov	 dl, BYTE PTR _btCrywolfState$[ebp]

; 21412: 	
; 21413: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00028	6a 06		 push	 6
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002d	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 21414: }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GCAnsCrywolfInfo@@YAXHEE@Z ENDP			; GCAnsCrywolfInfo
_TEXT	ENDS
PUBLIC	?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ; CGReqAlatrContract
EXTRN	?SetAltarUserIndex@CCrywolfAltar@@QAEHHHH@Z:PROC ; CCrywolfAltar::SetAltarUserIndex
EXTRN	?GetAltarState@CCrywolfAltar@@QAEHH@Z:PROC	; CCrywolfAltar::GetAltarState
EXTRN	?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A:BYTE	; g_CrywolfNPC_Altar
; Function compile flags: /Ogtp
;	COMDAT ?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z PROC ; CGReqAlatrContract, COMDAT

; 21417: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21418: 	int iAltarIndex = MAKE_NUMBERW(lpMsg->btObjIndexH, lpMsg->btObjIndexL);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0000a	0f b6 50 05	 movzx	 edx, BYTE PTR [eax+5]
  0000e	83 ec 08	 sub	 esp, 8
  00011	53		 push	 ebx
  00012	66 c1 e1 08	 shl	 cx, 8
  00016	0f b7 d9	 movzx	 ebx, cx
  00019	57		 push	 edi

; 21419: 
; 21420: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0001d	0b da		 or	 ebx, edx
  0001f	85 ff		 test	 edi, edi
  00021	0f 88 3d 01 00
	00		 js	 $LN8@CGReqAlatr
  00027	33 c0		 xor	 eax, eax
  00029	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0002f	0f 9e c0	 setle	 al
  00032	85 c0		 test	 eax, eax
  00034	0f 84 2a 01 00
	00		 je	 $LN8@CGReqAlatr

; 21421: 	{
; 21422: 		return;
; 21423: 	}
; 21424: 
; 21425: 	if ( !OBJMAX_RANGE(iAltarIndex))

  0003a	85 db		 test	 ebx, ebx
  0003c	0f 88 22 01 00
	00		 js	 $LN8@CGReqAlatr
  00042	33 c0		 xor	 eax, eax
  00044	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0004a	0f 9e c0	 setle	 al
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 0f 01 00
	00		 je	 $LN8@CGReqAlatr

; 21426: 	{
; 21427: 		return;
; 21428: 	}
; 21429: 
; 21430: 	LPOBJ lpObj = &gObj[iIndex];

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00060	56		 push	 esi

; 21431: 	LPOBJ lpAltarObj = &gObj[iAltarIndex];

  00061	8b f3		 mov	 esi, ebx
  00063	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00069	03 f0		 add	 esi, eax
  0006b	03 f8		 add	 edi, eax

; 21432: 
; 21433: 	if ( !CRYWOLF_ALTAR_CLASS_RANGE(lpAltarObj->Class))

  0006d	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00074	b9 cd 00 00 00	 mov	 ecx, 205		; 000000cdH
  00079	66 3b c1	 cmp	 ax, cx
  0007c	0f 82 e1 00 00
	00		 jb	 $LN16@CGReqAlatr
  00082	ba d1 00 00 00	 mov	 edx, 209		; 000000d1H
  00087	66 3b d0	 cmp	 dx, ax
  0008a	1b c0		 sbb	 eax, eax
  0008c	40		 inc	 eax
  0008d	0f 84 d0 00 00
	00		 je	 $LN16@CGReqAlatr

; 21434: 	{
; 21435: 		return;
; 21436: 	}
; 21437: 
; 21438: 	if ( !gObjIsConnected(lpObj))

  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00099	83 c4 04	 add	 esp, 4
  0009c	85 c0		 test	 eax, eax
  0009e	0f 84 bf 00 00
	00		 je	 $LN16@CGReqAlatr

; 21439: 	{
; 21440: 		return;
; 21441: 	}
; 21442: 
; 21443: 	PMSG_ANS_CRYWOLF_ALTAR_CONTRACT pMsg={0};

  000a4	33 c0		 xor	 eax, eax

; 21444: 
; 21445: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x03, sizeof(pMsg));

  000a6	6a 08		 push	 8
  000a8	6a 03		 push	 3
  000aa	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  000ad	66 89 45 fd	 mov	 WORD PTR _pMsg$[ebp+5], ax
  000b1	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+7], al
  000b4	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000b7	68 bd 00 00 00	 push	 189			; 000000bdH
  000bc	50		 push	 eax
  000bd	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  000c1	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21446: 	pMsg.btResult = 0;

  000c6	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 21447: 	pMsg.btAltarState = g_CrywolfNPC_Altar.GetAltarState(lpAltarObj->Class);

  000ca	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	51		 push	 ecx
  000d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A ; g_CrywolfNPC_Altar
  000da	e8 00 00 00 00	 call	 ?GetAltarState@CCrywolfAltar@@QAEHH@Z ; CCrywolfAltar::GetAltarState

; 21448: 	pMsg.btObjIndexH = lpMsg->btObjIndexH;

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000e2	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]

; 21449: 	pMsg.btObjIndexL = lpMsg->btObjIndexL;

  000e5	8a 49 05	 mov	 cl, BYTE PTR [ecx+5]
  000e8	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  000eb	88 55 fe	 mov	 BYTE PTR _pMsg$[ebp+6], dl
  000ee	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 21450: 
; 21451: 	if ( pMsg.btAltarState == 0 && lpObj->Type == OBJ_USER && lpObj->Class == CLASS_ELF && lpObj->Level >= MIN_ELF_LEVEL_ALTAR )

  000f1	84 c0		 test	 al, al
  000f3	75 40		 jne	 SHORT $LN3@CGReqAlatr
  000f5	66 83 7f 68 01	 cmp	 WORD PTR [edi+104], 1
  000fa	75 39		 jne	 SHORT $LN3@CGReqAlatr
  000fc	66 83 bf b8 00
	00 00 02	 cmp	 WORD PTR [edi+184], 2
  00104	75 2f		 jne	 SHORT $LN3@CGReqAlatr
  00106	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  0010b	66 39 97 be 00
	00 00		 cmp	 WORD PTR [edi+190], dx
  00112	7c 21		 jl	 SHORT $LN3@CGReqAlatr

; 21452: 	{
; 21453: 		if ( g_CrywolfNPC_Altar.SetAltarUserIndex(iAltarIndex, lpAltarObj->Class, iIndex) != FALSE )

  00114	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  0011b	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0011e	50		 push	 eax
  0011f	51		 push	 ecx
  00120	53		 push	 ebx
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A ; g_CrywolfNPC_Altar
  00126	e8 00 00 00 00	 call	 ?SetAltarUserIndex@CCrywolfAltar@@QAEHHHH@Z ; CCrywolfAltar::SetAltarUserIndex
  0012b	85 c0		 test	 eax, eax
  0012d	74 22		 je	 SHORT $LN1@CGReqAlatr

; 21454: 		{
; 21455: 			pMsg.btResult = 1;

  0012f	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 21456: 		}
; 21457: 	}
; 21458: 	else

  00133	eb 1c		 jmp	 SHORT $LN1@CGReqAlatr
$LN3@CGReqAlatr:

; 21459: 	{
; 21460: 		MsgOutput(iIndex, lMsg.Get(MSGGET(13, 9)));

  00135	68 09 0d 00 00	 push	 3337			; 00000d09H
  0013a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0013f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00144	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00147	50		 push	 eax
  00148	52		 push	 edx
  00149	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0014e	83 c4 08	 add	 esp, 8
$LN1@CGReqAlatr:

; 21461: 	}
; 21462: 
; 21463: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00151	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00154	6a 08		 push	 8
  00156	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00159	50		 push	 eax
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CGReqAlatr:
  00163	5e		 pop	 esi
$LN8@CGReqAlatr:
  00164	5f		 pop	 edi
  00165	5b		 pop	 ebx

; 21464: }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ENDP ; CGReqAlatrContract
_TEXT	ENDS
PUBLIC	?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ; CGReqPlusChaosRate
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?g_iCrywolfApplyMvpBenefit@@3HA:DWORD		; g_iCrywolfApplyMvpBenefit
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
; Function compile flags: /Ogtp
;	COMDAT ?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z PROC ; CGReqPlusChaosRate, COMDAT

; 21467: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 21468: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 61		 js	 SHORT $LN3@CGReqPlusC
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 52		 je	 SHORT $LN3@CGReqPlusC

; 21469: 	{
; 21470: 		return;
; 21471: 	}
; 21472: 
; 21473: 	PMSG_ANS_CRYWOLF_BENEFIT_PLUS_CHAOSRATE pMsg={0};
; 21474: 
; 21475: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x09, sizeof(pMsg));

  0001d	6a 05		 push	 5
  0001f	6a 09		 push	 9
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	68 bd 00 00 00	 push	 189			; 000000bdH
  00029	50		 push	 eax
  0002a	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0002e	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  00035	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 21476: 
; 21477: 	if(g_CrywolfSync.GetOccupationState() == 0 && g_iCrywolfApplyMvpBenefit != 0) //season 3.0 add-on

  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00042	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  00047	85 c0		 test	 eax, eax
  00049	75 15		 jne	 SHORT $LN1@CGReqPlusC
  0004b	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpBenefit@@3HA, eax ; g_iCrywolfApplyMvpBenefit
  00051	74 0d		 je	 SHORT $LN1@CGReqPlusC

; 21478: 	{
; 21479: 		pMsg.btPlusChaosRate = g_CrywolfSync.GetPlusChaosRate();

  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00058	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate
  0005d	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
$LN1@CGReqPlusC:

; 21480: 	}	
; 21481: 
; 21482: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00060	6a 05		 push	 5
  00062	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00065	51		 push	 ecx
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@CGReqPlusC:
  0006f	5e		 pop	 esi

; 21483: }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ENDP ; CGReqPlusChaosRate
_TEXT	ENDS
PUBLIC	?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ; CGReqKanturuStateInfo
EXTRN	?NotifyEntranceInfo@CKanturuEntranceNPC@@QAEXH@Z:PROC ; CKanturuEntranceNPC::NotifyEntranceInfo
EXTRN	?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A:DWORD ; g_KanturuEntranceNPC
; Function compile flags: /Ogtp
;	COMDAT ?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z PROC ; CGReqKanturuStateInfo, COMDAT

; 21486: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21487: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN2@CGReqKantu
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN2@CGReqKantu

; 21488: 	{
; 21489: 		return;
; 21490: 	}
; 21491: 
; 21492: //#if(GS_CASTLE==0)
; 21493: 	g_KanturuEntranceNPC.NotifyEntranceInfo(iIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A ; g_KanturuEntranceNPC
  0001f	e8 00 00 00 00	 call	 ?NotifyEntranceInfo@CKanturuEntranceNPC@@QAEXH@Z ; CKanturuEntranceNPC::NotifyEntranceInfo
$LN2@CGReqKantu:

; 21494: //#endif
; 21495: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ENDP ; CGReqKanturuStateInfo
_TEXT	ENDS
PUBLIC	?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ; GCReqEnterKanturuBossMap
EXTRN	?NotifyResultEnterKanturuBossMap@CKanturuEntranceNPC@@QAEXH@Z:PROC ; CKanturuEntranceNPC::NotifyResultEnterKanturuBossMap
; Function compile flags: /Ogtp
;	COMDAT ?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z PROC ; GCReqEnterKanturuBossMap, COMDAT

; 21500: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21501: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN2@GCReqEnter
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN2@GCReqEnter

; 21502: 	{
; 21503: 		return;
; 21504: 	}
; 21505: 
; 21506: //#if(GS_CASTLE==0)
; 21507: 	g_KanturuEntranceNPC.NotifyResultEnterKanturuBossMap(iIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A ; g_KanturuEntranceNPC
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterKanturuBossMap@CKanturuEntranceNPC@@QAEXH@Z ; CKanturuEntranceNPC::NotifyResultEnterKanturuBossMap
$LN2@GCReqEnter:

; 21508: //#endif
; 21509: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ENDP ; GCReqEnterKanturuBossMap
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqPCBangShopBuy@@YAXPAUPMSG_REQ_PCBANG_SHOP_BUY@@H@Z ; CGReqPCBangShopBuy
; Function compile flags: /Ogtp
;	COMDAT ?CGReqPCBangShopBuy@@YAXPAUPMSG_REQ_PCBANG_SHOP_BUY@@H@Z
_TEXT	SEGMENT
_pMsg$252520 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqPCBangShopBuy@@YAXPAUPMSG_REQ_PCBANG_SHOP_BUY@@H@Z PROC ; CGReqPCBangShopBuy, COMDAT

; 21512: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21513: 	if(lpMsg == NULL)

  00010	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	74 58		 je	 SHORT $LN1@CGReqPCBan

; 21514: 	{
; 21515: 		return;
; 21516: 	}
; 21517: 
; 21518: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001a	85 f6		 test	 esi, esi
  0001c	78 54		 js	 SHORT $LN1@CGReqPCBan
  0001e	33 c0		 xor	 eax, eax
  00020	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 45		 je	 SHORT $LN1@CGReqPCBan

; 21519: 	{
; 21520: 		return;
; 21521: 	}
; 21522: 
; 21523: 	if(PacketCheckTime(&gObj[iIndex]) == FALSE)

  0002d	8b c6		 mov	 eax, esi
  0002f	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00035	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00041	83 c4 04	 add	 esp, 4
  00044	85 c0		 test	 eax, eax
  00046	75 2a		 jne	 SHORT $LN1@CGReqPCBan

; 21524: 	{
; 21525: 		PMSG_POINT_BUY_ITEM pMsg;
; 21526: 		PHeadSubSetB((LPBYTE)&pMsg, 0xD1, 0x05, sizeof(pMsg));

  00048	6a 12		 push	 18			; 00000012H
  0004a	6a 05		 push	 5
  0004c	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$252520[ebp]
  0004f	68 d1 00 00 00	 push	 209			; 000000d1H
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21527: 		pMsg.Result = 6;
; 21528: 		pMsg.ItemPos = 0xFF;
; 21529: 		DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0005a	0f b6 55 e9	 movzx	 edx, BYTE PTR _pMsg$252520[ebp+1]
  0005e	52		 push	 edx
  0005f	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$252520[ebp]
  00062	50		 push	 eax
  00063	56		 push	 esi
  00064	66 c7 45 ec 06
	ff		 mov	 WORD PTR _pMsg$252520[ebp+4], 65286 ; 0000ff06H
  0006a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@CGReqPCBan:

; 21530: 		return;
; 21531: 	}
; 21532: #if(PC_BANG_POINT_SYSTEM==1)
; 21533: 	g_PCBangPointSystem.PCBangBuyItem(iIndex, lpMsg->btPosition);
; 21534: #endif
; 21535: }

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	33 cd		 xor	 ecx, ebp
  00077	5e		 pop	 esi
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?CGReqPCBangShopBuy@@YAXPAUPMSG_REQ_PCBANG_SHOP_BUY@@H@Z ENDP ; CGReqPCBangShopBuy
_TEXT	ENDS
PUBLIC	?CGReqPCBangShopOpen@@YAXPAUPMSG_REQ_PCBANG_SHOP_OPEN@@H@Z ; CGReqPCBangShopOpen
; Function compile flags: /Ogtp
;	COMDAT ?CGReqPCBangShopOpen@@YAXPAUPMSG_REQ_PCBANG_SHOP_OPEN@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqPCBangShopOpen@@YAXPAUPMSG_REQ_PCBANG_SHOP_OPEN@@H@Z PROC ; CGReqPCBangShopOpen, COMDAT

; 21539: 	if(lpMsg == NULL)
; 21540: 	{
; 21541: 		return;
; 21542: 	}
; 21543: 
; 21544: 	if ( OBJMAX_RANGE(iIndex) == FALSE )
; 21545: 	{
; 21546: 		return;
; 21547: 	}
; 21548: #if(PC_BANG_POINT_SYSTEM==1)
; 21549: 	g_PCBangPointSystem.PCBangShopOpen(iIndex);
; 21550: #endif
; 21551: }

  00000	c3		 ret	 0
?CGReqPCBangShopOpen@@YAXPAUPMSG_REQ_PCBANG_SHOP_OPEN@@H@Z ENDP ; CGReqPCBangShopOpen
_TEXT	ENDS
PUBLIC	?CGReqWerewolfMove@@YAXPAUPMSG_REQ_WEREWOLF_MOVE@@H@Z ; CGReqWerewolfMove
EXTRN	?GCReqWerewolfMove@CQuestInfo@@QAEXH@Z:PROC	; CQuestInfo::GCReqWerewolfMove
; Function compile flags: /Ogtp
;	COMDAT ?CGReqWerewolfMove@@YAXPAUPMSG_REQ_WEREWOLF_MOVE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqWerewolfMove@@YAXPAUPMSG_REQ_WEREWOLF_MOVE@@H@Z PROC ; CGReqWerewolfMove, COMDAT

; 21554: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21555: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 21		 je	 SHORT $LN3@CGReqWerew

; 21556: 	{
; 21557: 		return;
; 21558: 	}
; 21559: 
; 21560: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 1a		 js	 SHORT $LN3@CGReqWerew
  00010	33 c0		 xor	 eax, eax
  00012	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 0b		 je	 SHORT $LN3@CGReqWerew

; 21561: 	{
; 21562: 		return;
; 21563: 	}
; 21564: 
; 21565: 	g_QuestInfo.GCReqWerewolfMove(iIndex);

  0001f	51		 push	 ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00025	e8 00 00 00 00	 call	 ?GCReqWerewolfMove@CQuestInfo@@QAEXH@Z ; CQuestInfo::GCReqWerewolfMove
$LN3@CGReqWerew:

; 21566: }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?CGReqWerewolfMove@@YAXPAUPMSG_REQ_WEREWOLF_MOVE@@H@Z ENDP ; CGReqWerewolfMove
_TEXT	ENDS
PUBLIC	?CGReqGatekeeperMove@@YAXPAUPMSG_REQ_GATEKEEPER_MOVE@@H@Z ; CGReqGatekeeperMove
EXTRN	?GCReqGateKeeperMove@CQuestInfo@@QAEXH@Z:PROC	; CQuestInfo::GCReqGateKeeperMove
; Function compile flags: /Ogtp
;	COMDAT ?CGReqGatekeeperMove@@YAXPAUPMSG_REQ_GATEKEEPER_MOVE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGatekeeperMove@@YAXPAUPMSG_REQ_GATEKEEPER_MOVE@@H@Z PROC ; CGReqGatekeeperMove, COMDAT

; 21569: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21570: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 21		 je	 SHORT $LN3@CGReqGatek

; 21571: 	{
; 21572: 		return;
; 21573: 	}
; 21574: 
; 21575: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 1a		 js	 SHORT $LN3@CGReqGatek
  00010	33 c0		 xor	 eax, eax
  00012	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 0b		 je	 SHORT $LN3@CGReqGatek

; 21576: 	{
; 21577: 		return;
; 21578: 	}
; 21579: 
; 21580: 	g_QuestInfo.GCReqGateKeeperMove(iIndex);

  0001f	51		 push	 ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00025	e8 00 00 00 00	 call	 ?GCReqGateKeeperMove@CQuestInfo@@QAEXH@Z ; CQuestInfo::GCReqGateKeeperMove
$LN3@CGReqGatek:

; 21581: }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?CGReqGatekeeperMove@@YAXPAUPMSG_REQ_GATEKEEPER_MOVE@@H@Z ENDP ; CGReqGatekeeperMove
_TEXT	ENDS
PUBLIC	?CGReqEnterIllusionTemple@@YAXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER@@H@Z ; CGReqEnterIllusionTemple
EXTRN	?IllusionTempleAddUser@CIllusionTempleEvent@@QAEHHEE@Z:PROC ; CIllusionTempleEvent::IllusionTempleAddUser
; Function compile flags: /Ogtp
;	COMDAT ?CGReqEnterIllusionTemple@@YAXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqEnterIllusionTemple@@YAXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER@@H@Z PROC ; CGReqEnterIllusionTemple, COMDAT

; 21584: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21585: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 0e		 js	 SHORT $LN6@CGReqEnter@2
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	75 1a		 jne	 SHORT $LN1@CGReqEnter@2
$LN6@CGReqEnter@2:

; 21586: 	{
; 21587: 		LogAdd("return %s %d", __FILE__, __LINE__);

  00018	68 53 54 00 00	 push	 21587			; 00005453H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21592: }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN1@CGReqEnter@2:

; 21588: 		return;
; 21589: 	}
; 21590: 
; 21591: 	g_IllusionTempleEvent.IllusionTempleAddUser(iIndex,lpMsg->btFloorIndex-1, lpMsg->TicketPos);

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00035	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00039	8a 49 04	 mov	 cl, BYTE PTR [ecx+4]
  0003c	52		 push	 edx
  0003d	fe c9		 dec	 cl
  0003f	0f b6 d1	 movzx	 edx, cl
  00042	52		 push	 edx
  00043	50		 push	 eax
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00049	e8 00 00 00 00	 call	 ?IllusionTempleAddUser@CIllusionTempleEvent@@QAEHHEE@Z ; CIllusionTempleEvent::IllusionTempleAddUser

; 21592: }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?CGReqEnterIllusionTemple@@YAXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER@@H@Z ENDP ; CGReqEnterIllusionTemple
_TEXT	ENDS
PUBLIC	?CGReqUseIllusionTempleKillCntSkill@@YAXPAUPMSG_USE_ILLUSIONTEMPLE_KILLCOUNT_SKILL@@H@Z ; CGReqUseIllusionTempleKillCntSkill
EXTRN	?RunningSkill@CIllusionTempleEvent@@QAEXHGHE@Z:PROC ; CIllusionTempleEvent::RunningSkill
; Function compile flags: /Ogtp
;	COMDAT ?CGReqUseIllusionTempleKillCntSkill@@YAXPAUPMSG_USE_ILLUSIONTEMPLE_KILLCOUNT_SKILL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqUseIllusionTempleKillCntSkill@@YAXPAUPMSG_USE_ILLUSIONTEMPLE_KILLCOUNT_SKILL@@H@Z PROC ; CGReqUseIllusionTempleKillCntSkill, COMDAT

; 21595: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21596: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 0f		 js	 SHORT $LN6@CGReqUseIl
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	75 1a		 jne	 SHORT $LN1@CGReqUseIl
$LN6@CGReqUseIl:

; 21597: 	{
; 21598: 		LogAdd("return %s %d", __FILE__, __LINE__);

  00019	68 5e 54 00 00	 push	 21598			; 0000545eH
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21605: }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@CGReqUseIl:

; 21599: 		return;
; 21600: 	}
; 21601: 
; 21602: 	WORD TargetIndex = MAKE_NUMBERW( lpMsg->btTargetH, lpMsg->btTargetL );
; 21603: 
; 21604: 	g_IllusionTempleEvent.RunningSkill(iIndex, MAKE_NUMBERW( lpMsg->btSkillIdH, lpMsg->btSkillIdL ), TargetIndex, lpMsg->btDis);

  00033	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00036	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  0003a	56		 push	 esi
  0003b	0f b6 70 07	 movzx	 esi, BYTE PTR [eax+7]
  0003f	52		 push	 edx
  00040	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00044	66 c1 e2 08	 shl	 dx, 8
  00048	0f b7 d2	 movzx	 edx, dx
  0004b	0b d6		 or	 edx, esi
  0004d	52		 push	 edx
  0004e	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00052	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00056	66 c1 e2 08	 shl	 dx, 8
  0005a	66 0b d0	 or	 dx, ax
  0005d	0f b7 d2	 movzx	 edx, dx
  00060	52		 push	 edx
  00061	51		 push	 ecx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00067	e8 00 00 00 00	 call	 ?RunningSkill@CIllusionTempleEvent@@QAEXHGHE@Z ; CIllusionTempleEvent::RunningSkill
  0006c	5e		 pop	 esi

; 21605: }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?CGReqUseIllusionTempleKillCntSkill@@YAXPAUPMSG_USE_ILLUSIONTEMPLE_KILLCOUNT_SKILL@@H@Z ENDP ; CGReqUseIllusionTempleKillCntSkill
_TEXT	ENDS
PUBLIC	?CGReqIllusionTempleDropReward@@YAXPAUPMSG_ILLUSIONTEMPLE_DROP_REWARD@@H@Z ; CGReqIllusionTempleDropReward
EXTRN	?GiveItemReward@CIllusionTempleEvent@@QAEXH@Z:PROC ; CIllusionTempleEvent::GiveItemReward
; Function compile flags: /Ogtp
;	COMDAT ?CGReqIllusionTempleDropReward@@YAXPAUPMSG_ILLUSIONTEMPLE_DROP_REWARD@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqIllusionTempleDropReward@@YAXPAUPMSG_ILLUSIONTEMPLE_DROP_REWARD@@H@Z PROC ; CGReqIllusionTempleDropReward, COMDAT

; 21608: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21609: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 0f		 js	 SHORT $LN6@CGReqIllus
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	75 1a		 jne	 SHORT $LN1@CGReqIllus
$LN6@CGReqIllus:

; 21610: 	{
; 21611: 		LogAdd("return %s %d", __FILE__, __LINE__);

  00019	68 6b 54 00 00	 push	 21611			; 0000546bH
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21616: }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN1@CGReqIllus:

; 21612: 		return;
; 21613: 	}
; 21614: 
; 21615: 	g_IllusionTempleEvent.GiveItemReward(iIndex);

  00033	51		 push	 ecx
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00039	e8 00 00 00 00	 call	 ?GiveItemReward@CIllusionTempleEvent@@QAEXH@Z ; CIllusionTempleEvent::GiveItemReward

; 21616: }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?CGReqIllusionTempleDropReward@@YAXPAUPMSG_ILLUSIONTEMPLE_DROP_REWARD@@H@Z ENDP ; CGReqIllusionTempleDropReward
_TEXT	ENDS
PUBLIC	?GCSendIllusionTempleKillCount@@YAXHE@Z		; GCSendIllusionTempleKillCount
; Function compile flags: /Ogtp
;	COMDAT ?GCSendIllusionTempleKillCount@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_KillCount$ = 12					; size = 1
?GCSendIllusionTempleKillCount@@YAXHE@Z PROC		; GCSendIllusionTempleKillCount, COMDAT

; 21619: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 21620: 	PMSG_SEND_ILLUSIONTEMPLE_KILLCOUNT pMsg;
; 21621: 
; 21622: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x06, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 06		 push	 6
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bf 00 00 00	 push	 191			; 000000bfH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21623: 	pMsg.btKillCount = KillCount;
; 21624: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8a 4d 0c	 mov	 cl, BYTE PTR _KillCount$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00023	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 1c	 add	 esp, 28			; 0000001cH

; 21625: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCSendIllusionTempleKillCount@@YAXHE@Z ENDP		; GCSendIllusionTempleKillCount
_TEXT	ENDS
PUBLIC	?CGReqXMasToDeviasMapMove@@YAXPAUPMSG_REQ_XMASNPCMAP_MOVE@@H@Z ; CGReqXMasToDeviasMapMove
EXTRN	?ReqNPCXMasMapMoveDevias@@YAXH@Z:PROC		; ReqNPCXMasMapMoveDevias
; Function compile flags: /Ogtp
;	COMDAT ?CGReqXMasToDeviasMapMove@@YAXPAUPMSG_REQ_XMASNPCMAP_MOVE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqXMasToDeviasMapMove@@YAXPAUPMSG_REQ_XMASNPCMAP_MOVE@@H@Z PROC ; CGReqXMasToDeviasMapMove, COMDAT

; 21629: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21630: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 1f		 je	 SHORT $LN3@CGReqXMasT

; 21631: 	{
; 21632: 		return;
; 21633: 	}
; 21634: 
; 21635: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 18		 js	 SHORT $LN3@CGReqXMasT
  00010	33 c0		 xor	 eax, eax
  00012	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN3@CGReqXMasT

; 21636: 	{
; 21637: 		return;
; 21638: 	}
; 21639: 
; 21640: 	ReqNPCXMasMapMoveDevias(iIndex); //Move to Devias! :)

  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ?ReqNPCXMasMapMoveDevias@@YAXH@Z ; ReqNPCXMasMapMoveDevias
  00025	83 c4 04	 add	 esp, 4
$LN3@CGReqXMasT:

; 21641: }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?CGReqXMasToDeviasMapMove@@YAXPAUPMSG_REQ_XMASNPCMAP_MOVE@@H@Z ENDP ; CGReqXMasToDeviasMapMove
_TEXT	ENDS
PUBLIC	?CGReqXMasSetPayItem@@YAXPAUPMSG_REQ_XMAS_PAYITEM@@H@Z ; CGReqXMasSetPayItem
EXTRN	?EGAnsRegXMasSetPayItem@@YAXHH@Z:PROC		; EGAnsRegXMasSetPayItem
; Function compile flags: /Ogtp
;	COMDAT ?CGReqXMasSetPayItem@@YAXPAUPMSG_REQ_XMAS_PAYITEM@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqXMasSetPayItem@@YAXPAUPMSG_REQ_XMAS_PAYITEM@@H@Z PROC ; CGReqXMasSetPayItem, COMDAT

; 21645: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21646: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 21		 je	 SHORT $LN3@CGReqXMasS

; 21647: 	{
; 21648: 		return;
; 21649: 	}
; 21650: 
; 21651: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 1a		 js	 SHORT $LN3@CGReqXMasS
  00010	33 c0		 xor	 eax, eax
  00012	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 0b		 je	 SHORT $LN3@CGReqXMasS

; 21652: 	{
; 21653: 		return;
; 21654: 	}
; 21655: 
; 21656: 	EGAnsRegXMasSetPayItem(iIndex, 1);

  0001f	6a 01		 push	 1
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ?EGAnsRegXMasSetPayItem@@YAXHH@Z ; EGAnsRegXMasSetPayItem
  00027	83 c4 08	 add	 esp, 8
$LN3@CGReqXMasS:

; 21657: }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?CGReqXMasSetPayItem@@YAXPAUPMSG_REQ_XMAS_PAYITEM@@H@Z ENDP ; CGReqXMasSetPayItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGCheckNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHECKNAME@@H@Z ; CGCheckNameRequest
EXTRN	?bCanChangeCharacterName@@3HA:DWORD		; bCanChangeCharacterName
; Function compile flags: /Ogtp
;	COMDAT ?CGCheckNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHECKNAME@@H@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 15
_szChangeName$252590 = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGCheckNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHECKNAME@@H@Z PROC ; CGCheckNameRequest, COMDAT

; 21661: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 21662: 	if(gObj[iIndex].Connected < PLAYER_LOGGED)

  00018	8b c7		 mov	 eax, edi
  0001a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00020	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0002a	7d 34		 jge	 SHORT $LN5@CGCheckNam

; 21663: 	{
; 21664: 		LogAdd(lMsg.Get(476),iIndex,gObj[iIndex].Ip_addr);

  0002c	83 c0 18	 add	 eax, 24			; 00000018H
  0002f	50		 push	 eax
  00030	57		 push	 edi
  00031	68 dc 01 00 00	 push	 476			; 000001dcH
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0003b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 21665: 		CloseClient(iIndex);

  00047	57		 push	 edi
  00048	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 21698: }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN5@CGCheckNam:

; 21666: 		return;
; 21667: 	}
; 21668: 
; 21669: 	PMSG_ANS_CHARACTER_CHECKNAME pMsg; //loc4
; 21670: 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x15, sizeof(pMsg));

  00060	6a 0f		 push	 15			; 0000000fH
  00062	6a 15		 push	 21			; 00000015H
  00064	8d 55 e0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00067	68 f3 00 00 00	 push	 243			; 000000f3H
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21671: 
; 21672: 	if(bCanChangeCharacterName != FALSE) //serverinfo.dat

  00072	33 c0		 xor	 eax, eax
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	39 05 00 00 00
	00		 cmp	 DWORD PTR ?bCanChangeCharacterName@@3HA, eax ; bCanChangeCharacterName
  0007d	74 2f		 je	 SHORT $LN4@CGCheckNam

; 21673: 	{
; 21674: 		char szChangeName[10]; //loc8
; 21675: 		szChangeName[11] = '\0';
; 21676: 
; 21677: 		memcpy(szChangeName, lpMsg->ChangeName, sizeof(szChangeName));

  0007f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00082	66 8b 56 0c	 mov	 dx, WORD PTR [esi+12]
  00086	88 45 fb	 mov	 BYTE PTR _szChangeName$252590[ebp+11], al
  00089	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008c	89 45 f0	 mov	 DWORD PTR _szChangeName$252590[ebp], eax

; 21678: 
; 21679: 		int Value = 95; //underline
; 21680: 		char * check = strchr(szChangeName, Value);

  0008f	8d 45 f0	 lea	 eax, DWORD PTR _szChangeName$252590[ebp]
  00092	6a 5f		 push	 95			; 0000005fH
  00094	50		 push	 eax
  00095	89 4d f4	 mov	 DWORD PTR _szChangeName$252590[ebp+4], ecx
  00098	66 89 55 f8	 mov	 WORD PTR _szChangeName$252590[ebp+8], dx
  0009c	e8 00 00 00 00	 call	 _strchr
  000a1	83 c4 08	 add	 esp, 8

; 21681: 
; 21682: 		if(check != NULL)

  000a4	85 c0		 test	 eax, eax
  000a6	0f 95 c1	 setne	 cl
  000a9	88 4d ee	 mov	 BYTE PTR _pMsg$[ebp+14], cl

; 21683: 		{
; 21684: 			pMsg.Result = 1; //:FAILURE MSG? Special Character?
; 21685: 		}
; 21686: 		else
; 21687: 		{
; 21688: 			pMsg.Result = 0;
; 21689: 		}
; 21690: 	}
; 21691: 	else

  000ac	eb 03		 jmp	 SHORT $LN1@CGCheckNam
$LN4@CGCheckNam:

; 21692: 	{
; 21693: 		pMsg.Result = 0;

  000ae	88 45 ee	 mov	 BYTE PTR _pMsg$[ebp+14], al
$LN1@CGCheckNam:

; 21694: 	}
; 21695: 
; 21696: 	memcpy(pMsg.Name, lpMsg->ChangeName, sizeof(pMsg.Name));

  000b1	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000b4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000b7	66 8b 4e 0c	 mov	 cx, WORD PTR [esi+12]
  000bb	89 55 e4	 mov	 DWORD PTR _pMsg$[ebp+4], edx

; 21697: 	DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000be	0f b6 55 e1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  000c2	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  000c5	52		 push	 edx
  000c6	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	66 89 4d ec	 mov	 WORD PTR _pMsg$[ebp+12], cx
  000cf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 21698: }

  000d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	5f		 pop	 edi
  000db	33 cd		 xor	 ecx, ebp
  000dd	5e		 pop	 esi
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?CGCheckNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHECKNAME@@H@Z ENDP ; CGCheckNameRequest
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGChangeNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHANGENAME@@H@Z ; CGChangeNameRequest
; Function compile flags: /Ogtp
;	COMDAT ?CGChangeNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHANGENAME@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGChangeNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHANGENAME@@H@Z PROC ; CGChangeNameRequest, COMDAT

; 21702: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21703: 	if(bCanChangeCharacterName == FALSE) //serverinfo.dat

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanChangeCharacterName@@3HA, 0 ; bCanChangeCharacterName
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f 84 b6 00 00
	00		 je	 $LN3@CGChangeNa

; 21704: 	{
; 21705: 		return;
; 21706: 	}
; 21707: 
; 21708: 	if(gObj[iIndex].Connected < PLAYER_LOGGED)

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	56		 push	 esi
  0002b	8b f3		 mov	 esi, ebx
  0002d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00033	83 7c 06 04 02	 cmp	 DWORD PTR [esi+eax+4], 2
  00038	7d 36		 jge	 SHORT $LN1@CGChangeNa

; 21709: 	{
; 21710: 		LogAdd(lMsg.Get(476),iIndex,gObj[iIndex].Ip_addr);

  0003a	8d 44 06 18	 lea	 eax, DWORD PTR [esi+eax+24]
  0003e	50		 push	 eax
  0003f	53		 push	 ebx
  00040	68 dc 01 00 00	 push	 476			; 000001dcH
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 21711: 		CloseClient(iIndex);

  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	5e		 pop	 esi
  00060	5f		 pop	 edi
  00061	5b		 pop	 ebx

; 21724: }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	33 cd		 xor	 ecx, ebp
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN1@CGChangeNa:

; 21712: 		return;
; 21713: 	}
; 21714: 
; 21715: 	PMSG_ANS_CHARACTER_CHANGENAME pMsg;
; 21716: 	PHeadSetB((LPBYTE)&pMsg, 0x16, sizeof(pMsg));

  00070	6a 28		 push	 40			; 00000028H
  00072	8d 4d d4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00075	6a 16		 push	 22			; 00000016H
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 21717: 	pMsg.iIndex = iIndex;
; 21718: 
; 21719: 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, sizeof(pMsg.AccountID));

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00082	89 5d d8	 mov	 DWORD PTR _pMsg$[ebp+4], ebx
  00085	8b 54 06 6c	 mov	 edx, DWORD PTR [esi+eax+108]
  00089	89 55 dc	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  0008c	8b 4c 06 70	 mov	 ecx, DWORD PTR [esi+eax+112]
  00090	89 4d e0	 mov	 DWORD PTR _pMsg$[ebp+12], ecx
  00093	0f b7 54 06 74	 movzx	 edx, WORD PTR [esi+eax+116]

; 21720: 	memcpy(pMsg.Name, lpMsg->Name, sizeof(pMsg.Name));

  00098	8b 47 0e	 mov	 eax, DWORD PTR [edi+14]
  0009b	8b 4f 12	 mov	 ecx, DWORD PTR [edi+18]
  0009e	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 21721: 	memcpy(pMsg.ChangeName, lpMsg->ChangeName, sizeof(pMsg.ChangeName));

  000a1	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a4	66 89 55 e4	 mov	 WORD PTR _pMsg$[ebp+16], dx
  000a8	0f b7 57 16	 movzx	 edx, WORD PTR [edi+22]
  000ac	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+32], ecx
  000af	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000b2	89 45 e6	 mov	 DWORD PTR _pMsg$[ebp+18], eax

; 21722: 
; 21723: 	cDBSMng.Send((char *)&pMsg, pMsg.h.size);

  000b5	0f b6 45 d5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	89 4d ea	 mov	 DWORD PTR _pMsg$[ebp+22], ecx
  000bf	66 89 55 f8	 mov	 WORD PTR _pMsg$[ebp+36], dx
  000c3	0f b7 57 0c	 movzx	 edx, WORD PTR [edi+12]
  000c7	50		 push	 eax
  000c8	8d 4d d4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000cb	51		 push	 ecx
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000d1	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+26], dx
  000d5	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  000da	5e		 pop	 esi
$LN3@CGChangeNa:

; 21724: }

  000db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	5f		 pop	 edi
  000df	33 cd		 xor	 ecx, ebp
  000e1	5b		 pop	 ebx
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
?CGChangeNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHANGENAME@@H@Z ENDP ; CGChangeNameRequest
_TEXT	ENDS
PUBLIC	?CGReqRegLuckyCoinItemCount@@YAXPAUPMSG_REQ_REG_LUCKYCOIN@@H@Z ; CGReqRegLuckyCoinItemCount
EXTRN	?EGAnsRegLuckyCoinItem@@YAXH@Z:PROC		; EGAnsRegLuckyCoinItem
; Function compile flags: /Ogtp
;	COMDAT ?CGReqRegLuckyCoinItemCount@@YAXPAUPMSG_REQ_REG_LUCKYCOIN@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegLuckyCoinItemCount@@YAXPAUPMSG_REQ_REG_LUCKYCOIN@@H@Z PROC ; CGReqRegLuckyCoinItemCount, COMDAT

; 21728: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21729: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	78 3c		 js	 SHORT $LN3@CGReqRegLu
  0000a	33 c9		 xor	 ecx, ecx
  0000c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00011	0f 9e c1	 setle	 cl
  00014	85 c9		 test	 ecx, ecx
  00016	74 2e		 je	 SHORT $LN3@CGReqRegLu

; 21730: 	{
; 21731: 		return;
; 21732: 	}
; 21733: 
; 21734: 	if(gObj[iIndex].UseEventServer != 0)

  00018	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001e	8b c8		 mov	 ecx, eax
  00020	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00026	83 bc 11 50 10
	00 00 00	 cmp	 DWORD PTR [ecx+edx+4176], 0
  0002e	8d 8c 11 50 10
	00 00		 lea	 ecx, DWORD PTR [ecx+edx+4176]
  00035	75 0f		 jne	 SHORT $LN3@CGReqRegLu

; 21735: 	{
; 21736: 		return;
; 21737: 	}
; 21738: 
; 21739: 	gObj[iIndex].UseEventServer = 1;
; 21740: 
; 21741: 	EGAnsRegLuckyCoinItem(iIndex);

  00037	50		 push	 eax
  00038	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
  0003e	e8 00 00 00 00	 call	 ?EGAnsRegLuckyCoinItem@@YAXH@Z ; EGAnsRegLuckyCoinItem
  00043	83 c4 04	 add	 esp, 4
$LN3@CGReqRegLu:

; 21742: }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?CGReqRegLuckyCoinItemCount@@YAXPAUPMSG_REQ_REG_LUCKYCOIN@@H@Z ENDP ; CGReqRegLuckyCoinItemCount
_TEXT	ENDS
PUBLIC	?GCSendLuckyCoinCount@@YAXHH@Z			; GCSendLuckyCoinCount
; Function compile flags: /Ogtp
;	COMDAT ?GCSendLuckyCoinCount@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_iIndex$ = 8						; size = 4
_CoinCount$ = 12					; size = 4
?GCSendLuckyCoinCount@@YAXHH@Z PROC			; GCSendLuckyCoinCount, COMDAT

; 21746: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 21747: 	PMSG_ANS_LUCKYCOIN_COINT pMsg;
; 21748: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x0B, sizeof(pMsg));

  00007	6a 08		 push	 8
  00009	6a 0b		 push	 11			; 0000000bH
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	68 bf 00 00 00	 push	 191			; 000000bfH
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21749: 	pMsg.CoinCount = CoinCount;
; 21750: 	DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00019	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _CoinCount$[ebp]
  00020	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00023	52		 push	 edx
  00024	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00027	50		 push	 eax
  00028	56		 push	 esi
  00029	89 4d fc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 21751: 
; 21752: 	gObj[iIndex].UseEventServer = 0;

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00037	83 c4 1c	 add	 esp, 28			; 0000001cH
  0003a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00040	c7 84 0e 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+4176], 0
  0004b	5e		 pop	 esi

; 21753: }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GCSendLuckyCoinCount@@YAXHH@Z ENDP			; GCSendLuckyCoinCount
_TEXT	ENDS
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGSearchLuckyCoinItem@@YAXPAUPMSG_REQ_SEARCH_LUCKY_COIN@@H@Z ; CGSearchLuckyCoinItem
EXTRN	?EGAnsRegLuckyCoinItemPosition@@YAXHH@Z:PROC	; EGAnsRegLuckyCoinItemPosition
; Function compile flags: /Ogtp
;	COMDAT ?CGSearchLuckyCoinItem@@YAXPAUPMSG_REQ_SEARCH_LUCKY_COIN@@H@Z
_TEXT	SEGMENT
_iIndex$GSCopy$ = -20					; size = 4
_pMsg$252631 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGSearchLuckyCoinItem@@YAXPAUPMSG_REQ_SEARCH_LUCKY_COIN@@H@Z PROC ; CGSearchLuckyCoinItem, COMDAT

; 21757: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21758: 	int iValidItemPos = -1;
; 21759: 
; 21760: 	if(gObj[iIndex].UseEventServer != 0)

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 21786: 	}
; 21787: 	else
; 21788: 	{
; 21789: 		gObj[iIndex].pInventory[iValidItemPos].m_Durability -= 1.0f;

  00019	89 75 ec	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], esi
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	83 bc 06 50 10
	00 00 00	 cmp	 DWORD PTR [esi+eax+4176], 0
  0002a	0f 85 fa 00 00
	00		 jne	 $LN1@CGSearchLu

; 21761: 	{
; 21762: 		return;
; 21763: 	}
; 21764: 
; 21765: 	gObj[iIndex].bIsChaosMixCompleted = 1;
; 21766: 	gObj[iIndex].UseEventServer = 1;

  00030	c6 84 06 79 12
	00 00 01	 mov	 BYTE PTR [esi+eax+4729], 1
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	53		 push	 ebx
  0003e	57		 push	 edi
  0003f	c7 84 06 50 10
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+4176], 1
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 21767: 
; 21768: 	for(int n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++) //2

  0004f	bb 0c 00 00 00	 mov	 ebx, 12			; 0000000cH
  00054	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL6@CGSearchLu:

; 21769: 	{
; 21770: 		if( gObj[iIndex].pInventory[n].IsItem() == TRUE &&
; 21771: 			gObj[iIndex].pInventory[n].m_Type == ITEMGET(14,100))

  00060	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  00067	03 cf		 add	 ecx, edi
  00069	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006e	83 f8 01	 cmp	 eax, 1
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00076	75 13		 jne	 SHORT $LN5@CGSearchLu
  00078	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  0007f	ba 64 1c 00 00	 mov	 edx, 7268		; 00001c64H
  00084	66 39 54 39 06	 cmp	 WORD PTR [ecx+edi+6], dx
  00089	74 11		 je	 SHORT $LN11@CGSearchLu
$LN5@CGSearchLu:

; 21767: 
; 21768: 	for(int n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++) //2

  0008b	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00091	43		 inc	 ebx
  00092	81 ff f0 a8 00
	00		 cmp	 edi, 43248		; 0000a8f0H
  00098	7c c6		 jl	 SHORT $LL6@CGSearchLu

; 21769: 	{
; 21770: 		if( gObj[iIndex].pInventory[n].IsItem() == TRUE &&
; 21771: 			gObj[iIndex].pInventory[n].m_Type == ITEMGET(14,100))

  0009a	eb 05		 jmp	 SHORT $LN13@CGSearchLu
$LN11@CGSearchLu:

; 21772: 		{
; 21773: 			iValidItemPos = n;
; 21774: 			break;
; 21775: 		}
; 21776: 	}
; 21777: 
; 21778: 	if(iValidItemPos == -1)

  0009c	83 fb ff	 cmp	 ebx, -1
  0009f	75 60		 jne	 SHORT $LN2@CGSearchLu
$LN13@CGSearchLu:

; 21779: 	{
; 21780: 		PMSG_REGISTER_LUCKYCOIN pMsg = {0};

  000a1	33 c0		 xor	 eax, eax

; 21781: 		PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x0C, sizeof(pMsg));

  000a3	6a 0c		 push	 12			; 0000000cH
  000a5	6a 0c		 push	 12			; 0000000cH
  000a7	89 45 f1	 mov	 DWORD PTR _pMsg$252631[ebp+1], eax
  000aa	89 45 f5	 mov	 DWORD PTR _pMsg$252631[ebp+5], eax
  000ad	66 89 45 f9	 mov	 WORD PTR _pMsg$252631[ebp+9], ax
  000b1	88 45 fb	 mov	 BYTE PTR _pMsg$252631[ebp+11], al
  000b4	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$252631[ebp]
  000b7	68 bf 00 00 00	 push	 191			; 000000bfH
  000bc	50		 push	 eax
  000bd	c6 45 f0 00	 mov	 BYTE PTR _pMsg$252631[ebp], 0
  000c1	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21782: 		pMsg.btResult = 0;
; 21783: 		//missing pMsg.CoinCount
; 21784: 		DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000c6	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$252631[ebp+1]
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$GSCopy$[ebp]
  000cd	51		 push	 ecx
  000ce	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$252631[ebp]
  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	c6 45 f4 00	 mov	 BYTE PTR _pMsg$252631[ebp+4], 0
  000d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 21785: 		gObj[iIndex].UseEventServer = 0;

  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000e5	5f		 pop	 edi
  000e6	5b		 pop	 ebx
  000e7	c7 84 0e 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+ecx+4176], 0
  000f2	5e		 pop	 esi

; 21791: 	}
; 21792: }

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6	33 cd		 xor	 ecx, ebp
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN2@CGSearchLu:

; 21786: 	}
; 21787: 	else
; 21788: 	{
; 21789: 		gObj[iIndex].pInventory[iValidItemPos].m_Durability -= 1.0f;

  00101	8b d3		 mov	 edx, ebx
  00103	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00109	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  0010d	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00113	d9 5c 11 24	 fstp	 DWORD PTR [ecx+edx+36]
  00117	8d 44 11 24	 lea	 eax, DWORD PTR [ecx+edx+36]

; 21790: 		EGAnsRegLuckyCoinItemPosition(iIndex,iValidItemPos);

  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _iIndex$GSCopy$[ebp]
  0011e	53		 push	 ebx
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 ?EGAnsRegLuckyCoinItemPosition@@YAXHH@Z ; EGAnsRegLuckyCoinItemPosition
  00125	83 c4 08	 add	 esp, 8
  00128	5f		 pop	 edi
  00129	5b		 pop	 ebx
$LN1@CGSearchLu:

; 21791: 	}
; 21792: }

  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	5e		 pop	 esi
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
?CGSearchLuckyCoinItem@@YAXPAUPMSG_REQ_SEARCH_LUCKY_COIN@@H@Z ENDP ; CGSearchLuckyCoinItem
_TEXT	ENDS
PUBLIC	??_C@_0CP@JPCFCMEC@?$FLLuckyCoinEvent?$FN?5RegistCoin?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	_Ipos$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqLuckyCoinRegister@@YAXHEHE@Z		; CGReqLuckyCoinRegister
;	COMDAT ??_C@_0CP@JPCFCMEC@?$FLLuckyCoinEvent?$FN?5RegistCoin?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CP@JPCFCMEC@?$FLLuckyCoinEvent?$FN?5RegistCoin?5?$FL?$CFs?$FN@ DB '['
	DB	'LuckyCoinEvent] RegistCoin [%s][%s], Coin: %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqLuckyCoinRegister@@YAXHEHE@Z
_TEXT	SEGMENT
_Ipos$GSCopy$ = -28					; size = 1
tv202 = -24						; size = 4
tv199 = -24						; size = 4
tv205 = -18						; size = 2
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
_Coin$ = 16						; size = 4
_Ipos$ = 20						; size = 1
?CGReqLuckyCoinRegister@@YAXHEHE@Z PROC			; CGReqLuckyCoinRegister, COMDAT

; 21796: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8a 5d 14	 mov	 bl, BYTE PTR _Ipos$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 21797: 	PMSG_REGISTER_LUCKYCOIN pMsg = {0};

  00019	33 c0		 xor	 eax, eax

; 21798: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x0C, sizeof(pMsg));

  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	6a 0c		 push	 12			; 0000000cH
  0001f	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00022	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+5], eax
  00025	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+9], ax
  00029	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+11], al
  0002c	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	68 bf 00 00 00	 push	 191			; 000000bfH
  00034	50		 push	 eax
  00035	88 5d e4	 mov	 BYTE PTR _Ipos$GSCopy$[ebp], bl
  00038	c6 45 f0 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21799: 
; 21800: 	pMsg.btResult = Result;

  00041	8a 45 0c	 mov	 al, BYTE PTR _Result$[ebp]

; 21801: 	pMsg.CoinCount = Coin;

  00044	8b 4d 10	 mov	 ecx, DWORD PTR _Coin$[ebp]

; 21802: 
; 21803: 	if(Result == 1)
; 21804: 	{
; 21805: 		if(gObj[iIndex].pInventory[Ipos].m_Durability == 0.f)

  00047	8b f7		 mov	 esi, edi
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00052	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00055	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00058	3c 01		 cmp	 al, 1
  0005a	0f 85 95 00 00
	00		 jne	 $LN4@CGReqLucky
  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00065	8b 84 06 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+eax+3620]
  0006c	0f b6 cb	 movzx	 ecx, bl
  0006f	8b d1		 mov	 edx, ecx
  00071	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00077	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  0007b	d9 ee		 fldz
  0007d	da e9		 fucompp
  0007f	8d 54 10 24	 lea	 edx, DWORD PTR [eax+edx+36]
  00083	df e0		 fnstsw	 ax
  00085	f6 c4 44	 test	 ah, 68			; 00000044H
  00088	7a 18		 jp	 SHORT $LN3@CGReqLucky

; 21806: 		{
; 21807: 			gObjInventoryDeleteItem(iIndex, Ipos);

  0008a	51		 push	 ecx
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 21808: 			GCInventoryItemDeleteSend(iIndex, Ipos, 1);

  00091	8b 4d e4	 mov	 ecx, DWORD PTR _Ipos$GSCopy$[ebp]
  00094	6a 01		 push	 1
  00096	51		 push	 ecx
  00097	57		 push	 edi
  00098	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0009d	83 c4 14	 add	 esp, 20			; 00000014H

; 21809: 		}
; 21810: 		else

  000a0	eb 30		 jmp	 SHORT $LN2@CGReqLucky
$LN3@CGReqLucky:

; 21811: 		{
; 21812: 			GCItemDurSend2(iIndex, Ipos, (BYTE)gObj[iIndex].pInventory[Ipos].m_Durability, 0);

  000a2	d9 02		 fld	 DWORD PTR [edx]
  000a4	8b 4d e4	 mov	 ecx, DWORD PTR _Ipos$GSCopy$[ebp]
  000a7	d9 7d ee	 fnstcw	 WORD PTR tv205[ebp]
  000aa	6a 00		 push	 0
  000ac	0f b7 45 ee	 movzx	 eax, WORD PTR tv205[ebp]
  000b0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000b5	89 45 e8	 mov	 DWORD PTR tv202[ebp], eax
  000b8	d9 6d e8	 fldcw	 WORD PTR tv202[ebp]
  000bb	db 5d e8	 fistp	 DWORD PTR tv199[ebp]
  000be	8a 55 e8	 mov	 dl, BYTE PTR tv199[ebp]
  000c1	0f b6 c2	 movzx	 eax, dl
  000c4	50		 push	 eax
  000c5	d9 6d ee	 fldcw	 WORD PTR tv205[ebp]
  000c8	51		 push	 ecx
  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  000cf	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@CGReqLucky:

; 21813: 		}
; 21814: 		LogAddTD("[LuckyCoinEvent] RegistCoin [%s][%s], Coin: %d",gObj[iIndex].AccountID, gObj[iIndex].Name, Coin);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d7	8b 55 10	 mov	 edx, DWORD PTR _Coin$[ebp]
  000da	52		 push	 edx
  000db	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000df	51		 push	 ecx
  000e0	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000e4	52		 push	 edx
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JPCFCMEC@?$FLLuckyCoinEvent?$FN?5RegistCoin?5?$FL?$CFs?$FN@
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 21815: 	}
; 21816: 	else

  000f3	eb 28		 jmp	 SHORT $LN1@CGReqLucky
$LN4@CGReqLucky:

; 21817: 	{
; 21818: 		gObj[iIndex].pInventory[Ipos].m_Durability += 1.0f;

  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fb	8b 94 0e 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+ecx+3620]
  00102	0f b6 c3	 movzx	 eax, bl
  00105	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0010b	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  0010f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00115	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]
  00119	8d 44 02 24	 lea	 eax, DWORD PTR [edx+eax+36]
$LN1@CGReqLucky:

; 21819: 	}
; 21820: 
; 21821: 	DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0011d	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00121	50		 push	 eax
  00122	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00125	51		 push	 ecx
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 21822: 	gObj[iIndex].UseEventServer = 0;

  0012c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 21823: }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	5f		 pop	 edi
  00139	c7 84 16 50 10
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+4176], 0
  00144	5e		 pop	 esi
  00145	33 cd		 xor	 ecx, ebp
  00147	5b		 pop	 ebx
  00148	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
?CGReqLuckyCoinRegister@@YAXHEHE@Z ENDP			; CGReqLuckyCoinRegister
_TEXT	ENDS
PUBLIC	?GCSendLuckyCoinResult@@YAXHE@Z			; GCSendLuckyCoinResult
; Function compile flags: /Ogtp
;	COMDAT ?GCSendLuckyCoinResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?GCSendLuckyCoinResult@@YAXHE@Z PROC			; GCSendLuckyCoinResult, COMDAT

; 21921: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 21922: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 51		 js	 SHORT $LN3@GCSendLuck
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 42		 je	 SHORT $LN3@GCSendLuck

; 21923: 	{
; 21924: 		return;
; 21925: 	}
; 21926: 
; 21927: 	LPOBJ lpObj = &gObj[aIndex];
; 21928: 
; 21929: 	if ( !gObjIsConnected(aIndex))

  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	74 35		 je	 SHORT $LN3@GCSendLuck

; 21930: 	{
; 21931: 		return;
; 21932: 	}
; 21933: 
; 21934: 	PMSG_LUCKYCOIN_RESULT pMsg = {0};
; 21935: 
; 21936: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x0D, sizeof(pMsg));

  0002a	6a 05		 push	 5
  0002c	6a 0d		 push	 13			; 0000000dH
  0002e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00031	68 bf 00 00 00	 push	 191			; 000000bfH
  00036	50		 push	 eax
  00037	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003b	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  00042	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 21937: 	pMsg.btResult = result;
; 21938: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00047	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0004b	8a 4d 0c	 mov	 cl, BYTE PTR _result$[ebp]
  0004e	52		 push	 edx
  0004f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00052	50		 push	 eax
  00053	56		 push	 esi
  00054	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00057	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN3@GCSendLuck:
  0005f	5e		 pop	 esi

; 21939: }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?GCSendLuckyCoinResult@@YAXHE@Z ENDP			; GCSendLuckyCoinResult
_TEXT	ENDS
PUBLIC	?CGMoveRorenMarket@@YAXH@Z			; CGMoveRorenMarket
; Function compile flags: /Ogtp
;	COMDAT ?CGMoveRorenMarket@@YAXH@Z
_TEXT	SEGMENT
_nUserLevel$ = -4					; size = 4
_nPermitLevel$ = 8					; size = 4
_aIndex$ = 8						; size = 4
?CGMoveRorenMarket@@YAXH@Z PROC				; CGMoveRorenMarket, COMDAT

; 21941: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 21942: 	if (!OBJMAX_RANGE(aIndex)) return;

  00004	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00007	85 c0		 test	 eax, eax
  00009	0f 88 44 01 00
	00		 js	 $LN15@CGMoveRore
  0000f	33 c9		 xor	 ecx, ecx
  00011	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00016	0f 9e c1	 setle	 cl
  00019	85 c9		 test	 ecx, ecx
  0001b	0f 84 32 01 00
	00		 je	 $LN15@CGMoveRore

; 21943: 
; 21944: 	LPOBJ lpObj = &gObj[aIndex];

  00021	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00027	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	53		 push	 ebx
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	8b f8		 mov	 edi, eax

; 21945: 	int iMapNumber = lpObj->MapNumber;
; 21946: 	unsigned char attr;
; 21947: 	int nUserClass = lpObj->Class;
; 21948: 	int iGateNumber = 0;
; 21949: 	int nUserLevel = lpObj->Level;
; 21950: 	int nPermitLevel = 0;
; 21951: 
; 21952: 	if (!lpObj->Teleport)

  00032	80 bf a0 03 00
	00 00		 cmp	 BYTE PTR [edi+928], 0
  00039	0f bf 87 be 00
	00 00		 movsx	 eax, WORD PTR [edi+190]
  00040	0f b6 9f 49 01
	00 00		 movzx	 ebx, BYTE PTR [edi+329]
  00047	0f b7 b7 b8 00
	00 00		 movzx	 esi, WORD PTR [edi+184]
  0004e	89 45 fc	 mov	 DWORD PTR _nUserLevel$[ebp], eax
  00051	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _nPermitLevel$[ebp], 0
  00058	0f 85 f2 00 00
	00		 jne	 $LN25@CGMoveRore

; 21953: 	{
; 21954: 		if (!((lpObj->m_State >> 2) & 1))

  0005e	f6 87 20 02 00
	00 04		 test	 BYTE PTR [edi+544], 4
  00065	0f 85 e5 00 00
	00		 jne	 $LN25@CGMoveRore

; 21955: 		{
; 21956: 			if ((attr = MapC[iMapNumber].GetAttr(lpObj->X, lpObj->Y)) & 1)

  0006b	0f bf 8f 46 01
	00 00		 movsx	 ecx, WORD PTR [edi+326]
  00072	0f bf 97 44 01
	00 00		 movsx	 edx, WORD PTR [edi+324]
  00079	51		 push	 ecx
  0007a	8b cb		 mov	 ecx, ebx
  0007c	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00082	52		 push	 edx
  00083	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00089	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0008e	a8 01		 test	 al, 1
  00090	0f 84 ba 00 00
	00		 je	 $LN25@CGMoveRore

; 21957: 			{
; 21958: 				if (iMapNumber == 79)

  00096	83 fb 4f	 cmp	 ebx, 79			; 0000004fH
  00099	0f 85 a0 00 00
	00		 jne	 $LN14@CGMoveRore

; 21959: 				{				
; 21960: 					if (nUserClass != 1 && nUserClass != 2 && nUserClass != 5)

  0009f	83 fe 01	 cmp	 esi, 1
  000a2	74 22		 je	 SHORT $LN13@CGMoveRore
  000a4	83 fe 02	 cmp	 esi, 2
  000a7	74 1d		 je	 SHORT $LN13@CGMoveRore
  000a9	83 fe 05	 cmp	 esi, 5
  000ac	74 18		 je	 SHORT $LN13@CGMoveRore

; 21961: 					{
; 21962: 						if (nUserClass == 3 || nUserClass == 4 || nUserClass == 6)

  000ae	83 fe 03	 cmp	 esi, 3
  000b1	74 0a		 je	 SHORT $LN23@CGMoveRore
  000b3	83 fe 04	 cmp	 esi, 4
  000b6	74 05		 je	 SHORT $LN23@CGMoveRore
  000b8	83 fe 06	 cmp	 esi, 6
  000bb	75 10		 jne	 SHORT $LN24@CGMoveRore
$LN23@CGMoveRore:

; 21963: 						{
; 21964: 							nPermitLevel = 6;

  000bd	c7 45 08 06 00
	00 00		 mov	 DWORD PTR _nPermitLevel$[ebp], 6

; 21965: 						}
; 21966: 					}
; 21967: 					else 

  000c4	eb 07		 jmp	 SHORT $LN24@CGMoveRore
$LN13@CGMoveRore:

; 21968: 					{
; 21969: 						nPermitLevel = 10;

  000c6	c7 45 08 0a 00
	00 00		 mov	 DWORD PTR _nPermitLevel$[ebp], 10 ; 0000000aH
$LN24@CGMoveRore:

; 21970: 					}
; 21971: 
; 21972: 					if (nUserLevel >= nPermitLevel)

  000cd	8b 45 08	 mov	 eax, DWORD PTR _nPermitLevel$[ebp]
  000d0	39 45 fc	 cmp	 DWORD PTR _nUserLevel$[ebp], eax

; 21973: 					{
; 21974: 						iGateNumber = 17;
; 21975: 					}
; 21976: 					else

  000d3	7d 52		 jge	 SHORT $LN7@CGMoveRore

; 21977: 					{
; 21978: 						if (nUserClass != 1 && nUserClass != 3 && nUserClass != 4)

  000d5	83 fe 01	 cmp	 esi, 1
  000d8	74 4d		 je	 SHORT $LN7@CGMoveRore
  000da	83 fe 03	 cmp	 esi, 3
  000dd	74 48		 je	 SHORT $LN7@CGMoveRore
  000df	83 fe 04	 cmp	 esi, 4
  000e2	74 43		 je	 SHORT $LN7@CGMoveRore

; 21979: 						{
; 21980: 							if (nUserClass == 2)

  000e4	83 fe 02	 cmp	 esi, 2
  000e7	75 18		 jne	 SHORT $LN6@CGMoveRore

; 21981: 							{
; 21982: 								iGateNumber = 27;
; 21983: 							}
; 21984: 							else
; 21985: 							{
; 21986: 								if (nUserClass == 5)
; 21987: 								{
; 21988: 									iGateNumber = 267;
; 21989: 								}
; 21990: 								else
; 21991: 								{
; 21992: 									iGateNumber = 17;
; 21993: 								}
; 21994: 							}
; 21995: 						}
; 21996: 						else
; 21997: 						{
; 21998: 							iGateNumber = 17;
; 21999: 						}
; 22000: 					}
; 22001: 				}
; 22002: 				else
; 22003: 				{
; 22004: 					iGateNumber = 333;
; 22005: 				}
; 22006: 
; 22007: 				gObjMoveGate(lpObj->m_Index, iGateNumber);

  000e9	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000eb	be 1b 00 00 00	 mov	 esi, 27			; 0000001bH
  000f0	56		 push	 esi
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000f7	83 c4 08	 add	 esp, 8
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx

; 22008: 			}
; 22009: 		}
; 22010: 	}
; 22011: }

  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN6@CGMoveRore:

; 21981: 							{
; 21982: 								iGateNumber = 27;
; 21983: 							}
; 21984: 							else
; 21985: 							{
; 21986: 								if (nUserClass == 5)
; 21987: 								{
; 21988: 									iGateNumber = 267;
; 21989: 								}
; 21990: 								else
; 21991: 								{
; 21992: 									iGateNumber = 17;
; 21993: 								}
; 21994: 							}
; 21995: 						}
; 21996: 						else
; 21997: 						{
; 21998: 							iGateNumber = 17;
; 21999: 						}
; 22000: 					}
; 22001: 				}
; 22002: 				else
; 22003: 				{
; 22004: 					iGateNumber = 333;
; 22005: 				}
; 22006: 
; 22007: 				gObjMoveGate(lpObj->m_Index, iGateNumber);

  00101	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00103	83 ee 05	 sub	 esi, 5
  00106	f7 de		 neg	 esi
  00108	1b f6		 sbb	 esi, esi
  0010a	81 e6 06 ff ff
	ff		 and	 esi, -250		; ffffff06H
  00110	81 c6 0b 01 00
	00		 add	 esi, 267		; 0000010bH
  00116	56		 push	 esi
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0011d	83 c4 08	 add	 esp, 8
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx

; 22008: 			}
; 22009: 		}
; 22010: 	}
; 22011: }

  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
$LN7@CGMoveRore:

; 21981: 							{
; 21982: 								iGateNumber = 27;
; 21983: 							}
; 21984: 							else
; 21985: 							{
; 21986: 								if (nUserClass == 5)
; 21987: 								{
; 21988: 									iGateNumber = 267;
; 21989: 								}
; 21990: 								else
; 21991: 								{
; 21992: 									iGateNumber = 17;
; 21993: 								}
; 21994: 							}
; 21995: 						}
; 21996: 						else
; 21997: 						{
; 21998: 							iGateNumber = 17;
; 21999: 						}
; 22000: 					}
; 22001: 				}
; 22002: 				else
; 22003: 				{
; 22004: 					iGateNumber = 333;
; 22005: 				}
; 22006: 
; 22007: 				gObjMoveGate(lpObj->m_Index, iGateNumber);

  00127	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00129	be 11 00 00 00	 mov	 esi, 17			; 00000011H
  0012e	56		 push	 esi
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00135	83 c4 08	 add	 esp, 8
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx

; 22008: 			}
; 22009: 		}
; 22010: 	}
; 22011: }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
$LN14@CGMoveRore:

; 21981: 							{
; 21982: 								iGateNumber = 27;
; 21983: 							}
; 21984: 							else
; 21985: 							{
; 21986: 								if (nUserClass == 5)
; 21987: 								{
; 21988: 									iGateNumber = 267;
; 21989: 								}
; 21990: 								else
; 21991: 								{
; 21992: 									iGateNumber = 17;
; 21993: 								}
; 21994: 							}
; 21995: 						}
; 21996: 						else
; 21997: 						{
; 21998: 							iGateNumber = 17;
; 21999: 						}
; 22000: 					}
; 22001: 				}
; 22002: 				else
; 22003: 				{
; 22004: 					iGateNumber = 333;
; 22005: 				}
; 22006: 
; 22007: 				gObjMoveGate(lpObj->m_Index, iGateNumber);

  0013f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00141	be 4d 01 00 00	 mov	 esi, 333		; 0000014dH
  00146	56		 push	 esi
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0014d	83 c4 08	 add	 esp, 8
$LN25@CGMoveRore:
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
$LN15@CGMoveRore:

; 22008: 			}
; 22009: 		}
; 22010: 	}
; 22011: }

  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
?CGMoveRorenMarket@@YAXH@Z ENDP				; CGMoveRorenMarket
_TEXT	ENDS
PUBLIC	?CGMapMoveRecv@@YAXPAUPMSG_MAP_MOVE@@H@Z	; CGMapMoveRecv
EXTRN	?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::Move
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
; Function compile flags: /Ogtp
;	COMDAT ?CGMapMoveRecv@@YAXPAUPMSG_MAP_MOVE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMapMoveRecv@@YAXPAUPMSG_MAP_MOVE@@H@Z PROC		; CGMapMoveRecv, COMDAT

; 22014: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 22015: 	if ( !OBJMAX_RANGE(aIndex))

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	0f 88 0c 01 00
	00		 js	 $LN12@CGMapMoveR
  0000f	33 c0		 xor	 eax, eax
  00011	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 f9 00 00
	00		 je	 $LN12@CGMapMoveR

; 22016: 	{
; 22017: 		return;
; 22018: 	}
; 22019: 	
; 22020: 	if( (GetTickCount() - gObj[aIndex].MySelfDefenseTime) < 60000 /*&& g_EnableSelfDefense*/ ) 

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	56		 push	 esi
  00028	8b f3		 mov	 esi, ebx
  0002a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00030	57		 push	 edi
  00031	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003a	2b 87 1c 04 00
	00		 sub	 eax, DWORD PTR [edi+1052]
  00040	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00045	73 0d		 jae	 SHORT $LN10@CGMapMoveR

; 22021: 	{
; 22022: 		GCServerMsgStringSend(lMsg.Get(1133),aIndex,1);

  00047	6a 01		 push	 1
  00049	53		 push	 ebx
  0004a	68 6d 04 00 00	 push	 1133			; 0000046dH

; 22023: 		return;

  0004f	e9 9d 00 00 00	 jmp	 $LN19@CGMapMoveR
$LN10@CGMapMoveR:

; 22024: 	}
; 22025: 
; 22026: 	if ( lpMsg->wMoveNum == NULL )

  00054	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00057	66 83 7a 08 00	 cmp	 WORD PTR [edx+8], 0
  0005c	0f 84 b7 00 00
	00		 je	 $LN17@CGMapMoveR

; 22027: 	{
; 22028: 		return;
; 22029: 	}
; 22030: 		
; 22031: 	if ( gObj[aIndex].Teleport != 0 )

  00062	80 bf a0 03 00
	00 00		 cmp	 BYTE PTR [edi+928], 0

; 22032: 	{
; 22033: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), aIndex, 1);
; 22034: 		return;

  00069	75 56		 jne	 SHORT $LN20@CGMapMoveR

; 22035: 	}
; 22036: 
; 22037: 	if ( (gObj[aIndex].m_IfState.use) != 0 )

  0006b	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  00071	a8 03		 test	 al, 3
  00073	74 33		 je	 SHORT $LN6@CGMapMoveR

; 22038: 	{
; 22039: 		if (  gObj[aIndex].m_IfState.type  == 3 )

  00075	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0007a	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0007f	75 27		 jne	 SHORT $LN6@CGMapMoveR

; 22040: 		{
; 22041: 			gObj[aIndex].TargetShopNumber = -1;

  00081	83 c9 ff	 or	 ecx, -1
  00084	66 89 8f 5a 04
	00 00		 mov	 WORD PTR [edi+1114], cx

; 22042: 			gObj[aIndex].m_IfState.type = 0;

  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	81 a4 06 1c 0e
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+3612], -65473 ; ffff003fH

; 22043: 			gObj[aIndex].m_IfState.use = 0;

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	83 a4 06 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+eax+3612], -4 ; fffffffcH
$LN6@CGMapMoveR:

; 22044: 		}
; 22045: 	}
; 22046: 
; 22047: 	if ( gObj[aIndex].m_IfState.use > 0 )

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ad	03 c6		 add	 eax, esi
  000af	f6 80 1c 0e 00
	00 03		 test	 BYTE PTR [eax+3612], 3

; 22048: 	{
; 22049: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), aIndex, 1);
; 22050: 		return;

  000b6	77 09		 ja	 SHORT $LN20@CGMapMoveR

; 22051: 	}
; 22052: 
; 22053: 	if ( gObj[aIndex].IsInBattleGround != false )

  000b8	80 b8 46 10 00
	00 00		 cmp	 BYTE PTR [eax+4166], 0
  000bf	74 0a		 je	 SHORT $LN4@CGMapMoveR
$LN20@CGMapMoveR:

; 22054: 	{
; 22055: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), aIndex, 1);

  000c1	6a 01		 push	 1
  000c3	53		 push	 ebx
  000c4	68 44 06 00 00	 push	 1604			; 00000644H

; 22056: 		return;

  000c9	eb 26		 jmp	 SHORT $LN19@CGMapMoveR
$LN4@CGMapMoveR:

; 22057: 	}
; 22058: 
; 22059: 	BOOL bPlayerKiller = FALSE; 

  000cb	33 c9		 xor	 ecx, ecx

; 22060: 
; 22061: #ifdef PARTYKILLPKSET
; 22062: 	if(gObj[aIndex].PartyNumber >= 0) 
; 22063: 	{
; 22064: 		if(gParty.GetPKPartyPenalty(gObj[aIndex].PartyNumber) >= 5)
; 22065: 		{
; 22066: 			bPlayerKiller = TRUE;
; 22067: 		}
; 22068: 	}
; 22069: 	else if(gObj[aIndex].m_PK_Level >= 5)
; 22070: 	{
; 22071: 		bPlayerKiller = TRUE;
; 22072: 	}
; 22073: #else
; 22074: 	if(gObj[aIndex].m_PK_Level >= 5)

  000cd	80 b8 3d 01 00
	00 05		 cmp	 BYTE PTR [eax+317], 5
  000d4	7c 05		 jl	 SHORT $LN3@CGMapMoveR

; 22075: 	{
; 22076: 		bPlayerKiller = TRUE;

  000d6	b9 01 00 00 00	 mov	 ecx, 1
$LN3@CGMapMoveR:

; 22077: 	}
; 22078: #endif
; 22079: 
; 22080: #if(FIX_TELEPORT_DIE)
; 22081: 	if(gObj[aIndex].DieRegen)

  000db	80 b8 a2 03 00
	00 00		 cmp	 BYTE PTR [eax+930], 0

; 22082: 	{
; 22083: 		bPlayerKiller = TRUE;
; 22084: 	}
; 22085: #endif
; 22086: 
; 22087: 	if ( bPlayerKiller == TRUE )

  000e2	75 05		 jne	 SHORT $LN16@CGMapMoveR
  000e4	83 f9 01	 cmp	 ecx, 1
  000e7	75 20		 jne	 SHORT $LN1@CGMapMoveR
$LN16@CGMapMoveR:

; 22088: 	{
; 22089: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 101)), aIndex, 1);

  000e9	6a 01		 push	 1
  000eb	53		 push	 ebx
  000ec	68 65 04 00 00	 push	 1125			; 00000465H
$LN19@CGMapMoveR:
  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 22094: }

  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
$LN1@CGMapMoveR:

; 22090: 		return;
; 22091: 	}
; 22092: 
; 22093: 	gMoveCommand.Move(&gObj[aIndex], lpMsg->wMoveNum);

  00109	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  0010d	51		 push	 ecx
  0010e	50		 push	 eax
  0010f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00114	e8 00 00 00 00	 call	 ?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::Move
$LN17@CGMapMoveR:
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
$LN12@CGMapMoveR:
  0011b	5b		 pop	 ebx

; 22094: }

  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?CGMapMoveRecv@@YAXPAUPMSG_MAP_MOVE@@H@Z ENDP		; CGMapMoveRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMonkMagicAttackNumberSend
; Function compile flags: /Ogtp
;	COMDAT ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z
_TEXT	SEGMENT
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 2
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 1
?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z PROC ; GCMonkMagicAttackNumberSend, COMDAT

; 22210: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 22211: 	/*PMSG_MONK_MAGICATTACK_SEND pAttack;
; 22212: 	// ----
; 22213: 	PHeadSetBE((LPBYTE)&pAttack, 0x4A, sizeof(pAttack));
; 22214: 	// ----
; 22215: 	pAttack.MagicNumberH	= SET_NUMBERH(MagicNumber);
; 22216: 	pAttack.MagicNumberL	= SET_NUMBERL(MagicNumber);
; 22217: 	pAttack.SourceNumberH	= SET_NUMBERH(lpObj->m_Index);
; 22218: 	pAttack.SourceNumberL	= SET_NUMBERL(lpObj->m_Index);
; 22219: 	pAttack.TargetNumberH	= SET_NUMBERH(usernumber);
; 22220: 	pAttack.TargetNumberL	= SET_NUMBERL(usernumber);
; 22221: 	pAttack.TargetNumberH	&= 0x7F;
; 22222: 	// ----
; 22223: 	if( skillsuccess )
; 22224: 	{
; 22225: 		pAttack.TargetNumberH |= 0x80;
; 22226: 	}
; 22227: 	// ----
; 22228: 	if( lpObj->Type == 1 )
; 22229: 	{
; 22230: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);
; 22231: 	}
; 22232: 	// ----
; 22233: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);*/
; 22234: 	PMSG_MAGICATTACK_RESULT pAttack;
; 22235: 	PHeadSetBE((LPBYTE)&pAttack, 0x4A, sizeof(pAttack));

  00014	6a 09		 push	 9
  00016	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00019	6a 4a		 push	 74			; 0000004aH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 22236: 
; 22237: #if(DEV_SKILL)
; 22238: 	if(MagicNumber == 2)
; 22239: 	{
; 22240: 		MagicNumber = 618;
; 22241: 	}
; 22242: #endif
; 22243: 
; 22244: 	pAttack.MagicNumberH = SET_NUMBERH(MagicNumber);

  00021	8b 45 0c	 mov	 eax, DWORD PTR _MagicNumber$[ebp]
  00024	8b c8		 mov	 ecx, eax
  00026	c1 e9 08	 shr	 ecx, 8
  00029	88 4d f3	 mov	 BYTE PTR _pAttack$[ebp+3], cl

; 22245: 	pAttack.MagicNumberL = SET_NUMBERL(MagicNumber);
; 22246: 
; 22247: 	pAttack.SourceNumberH = SET_NUMBERH(lpObj->m_Index);

  0002c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002e	88 45 f4	 mov	 BYTE PTR _pAttack$[ebp+4], al
  00031	8b d1		 mov	 edx, ecx
  00033	c1 ea 08	 shr	 edx, 8

; 22248: 	pAttack.SourceNumberL = SET_NUMBERL(lpObj->m_Index);

  00036	8a c1		 mov	 al, cl
  00038	88 55 f5	 mov	 BYTE PTR _pAttack$[ebp+5], dl

; 22249: 	pAttack.TargetNumberH = SET_NUMBERH(usernumber);

  0003b	8b 55 10	 mov	 edx, DWORD PTR _usernumber$[ebp]
  0003e	88 45 f6	 mov	 BYTE PTR _pAttack$[ebp+6], al
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 08	 shr	 eax, 8

; 22250: 	pAttack.TargetNumberL = SET_NUMBERL(usernumber);
; 22251: 	pAttack.TargetNumberH &= 0x7F;

  00046	24 7f		 and	 al, 127			; 0000007fH
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22252: 
; 22253: 	if ( skillsuccess )

  0004b	80 7d 14 00	 cmp	 BYTE PTR _skillsuccess$[ebp], 0
  0004f	88 55 f8	 mov	 BYTE PTR _pAttack$[ebp+8], dl
  00052	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
  00055	74 05		 je	 SHORT $LN2@GCMonkMagi

; 22254: 		pAttack.TargetNumberH |= 0x80;

  00057	0c 80		 or	 al, 128			; 00000080H
  00059	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al
$LN2@GCMonkMagi:

; 22255: 
; 22256: 	if ( lpObj->Type == OBJ_USER )

  0005c	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00061	75 12		 jne	 SHORT $LN1@GCMonkMagi

; 22257: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00063	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$[ebp+1]
  00067	52		 push	 edx
  00068	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0006b	50		 push	 eax
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMonkMagi:

; 22258: 	
; 22259: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  00075	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pAttack$[ebp+1]
  00079	51		 push	 ecx
  0007a	8d 55 f0	 lea	 edx, DWORD PTR _pAttack$[ebp]
  0007d	52		 push	 edx
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 22260: }

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	33 cd		 xor	 ecx, ebp
  0008c	5e		 pop	 esi
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ENDP ; GCMonkMagicAttackNumberSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect
EXTRN	?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z:PROC ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
; Function compile flags: /Ogtp
;	COMDAT ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z
_TEXT	SEGMENT
_wTargetIndex$ = -36					; size = 2
_pDarkSideTargetList$ = -32				; size = 16
_wTargetList$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z PROC ; GCMonkDarkSideTargetSelect, COMDAT

; 22265: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 22266: 	WORD wMagicNumber	= MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);	//ebp-4

  00013	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00017	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  0001b	66 c1 e1 08	 shl	 cx, 8
  0001f	66 0b ca	 or	 cx, dx

; 22267: 	WORD wTargetIndex	= MAKE_NUMBERW(lpMsg->TargetNumberH, lpMsg->TargetNumberL);	//ebp-8

  00022	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00026	53		 push	 ebx
  00027	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	0f b7 f9	 movzx	 edi, cx
  0002f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00033	66 c1 e1 08	 shl	 cx, 8
  00037	66 0b ca	 or	 cx, dx
  0003a	0f b7 c1	 movzx	 eax, cx
  0003d	89 45 dc	 mov	 DWORD PTR _wTargetIndex$[ebp], eax

; 22268: 	WORD wTargetList[5];	//ebp-14 (not declared before for???)
; 22269: 	// ----
; 22270: 	for( int i = 0; i < 5; i++ )	//ebp-18
; 22271: 	{
; 22272: 		wTargetList[i] = 10000;	//0x2710 (maybe user start or maxobj)

  00040	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
  00045	0f b7 d0	 movzx	 edx, ax

; 22273: 	}
; 22274: 	// ----
; 22275: 	if( gObj[aIndex].CloseCount >= 0 )

  00048	8b f3		 mov	 esi, ebx
  0004a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00050	8b c2		 mov	 eax, edx
  00052	c1 e2 10	 shl	 edx, 16			; 00000010H
  00055	0b c2		 or	 eax, edx
  00057	89 45 f0	 mov	 DWORD PTR _wTargetList$[ebp], eax
  0005a	89 45 f4	 mov	 DWORD PTR _wTargetList$[ebp+4], eax
  0005d	66 89 45 f8	 mov	 WORD PTR _wTargetList$[ebp+8], ax
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	03 c6		 add	 eax, esi
  00068	80 78 0a 00	 cmp	 BYTE PTR [eax+10], 0
  0006c	0f 8d 0f 01 00
	00		 jge	 $LN11@GCMonkDark

; 22276: 	{
; 22277: 		return;
; 22278: 	}
; 22279: 	// ----
; 22280: 	CMagicInf * lpMagic = 0;
; 22281: 	lpMagic				= gObjGetMagicSearch(&gObj[aIndex], wMagicNumber);

  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00079	83 c4 08	 add	 esp, 8

; 22282: 	// ----
; 22283: 	if( lpMagic == 0 )

  0007c	85 c0		 test	 eax, eax
  0007e	0f 84 fd 00 00
	00		 je	 $LN11@GCMonkDark

; 22284: 	{
; 22285: 		return;
; 22286: 	}
; 22287: 	// ----
; 22288: 	if( !gObjUseSkill.SkillMonkDarkSideGetTargetIndex(aIndex, wTargetIndex, lpMagic, &wTargetList[0]) )

  00084	8d 55 f0	 lea	 edx, DWORD PTR _wTargetList$[ebp]
  00087	52		 push	 edx
  00088	50		 push	 eax
  00089	0f b7 45 dc	 movzx	 eax, WORD PTR _wTargetIndex$[ebp]
  0008d	50		 push	 eax
  0008e	53		 push	 ebx
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00094	e8 00 00 00 00	 call	 ?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
  00099	85 c0		 test	 eax, eax
  0009b	0f 84 e0 00 00
	00		 je	 $LN11@GCMonkDark

; 22289: 	{
; 22290: 		return;
; 22291: 	}
; 22292: 	// ----
; 22293: 	PMSG_MONK_DARKSIDE_SEND pDarkSideTargetList;
; 22294: 	memset(&pDarkSideTargetList, 0, sizeof(pDarkSideTargetList));

  000a1	33 c0		 xor	 eax, eax

; 22295: 	PHeadSetB((LPBYTE)&pDarkSideTargetList, 0x4B, sizeof(pDarkSideTargetList));

  000a3	6a 10		 push	 16			; 00000010H
  000a5	8d 4d e0	 lea	 ecx, DWORD PTR _pDarkSideTargetList$[ebp]
  000a8	6a 4b		 push	 75			; 0000004bH
  000aa	51		 push	 ecx
  000ab	89 45 e0	 mov	 DWORD PTR _pDarkSideTargetList$[ebp], eax
  000ae	89 45 e4	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+4], eax
  000b1	89 45 e8	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+8], eax
  000b4	89 45 ec	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+12], eax
  000b7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 22296: 	memcpy(pDarkSideTargetList.wTargetList, wTargetList, sizeof(wTargetList));

  000bc	8b 55 f0	 mov	 edx, DWORD PTR _wTargetList$[ebp]
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _wTargetList$[ebp+4]
  000c2	66 8b 4d f8	 mov	 cx, WORD PTR _wTargetList$[ebp+8]
  000c6	89 55 e6	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+6], edx

; 22297: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 22298: 	gObj[aIndex].m_btDarkSideTargetNum = 0;

  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	89 45 ea	 mov	 DWORD PTR _pDarkSideTargetList$[ebp+10], eax
  000d2	66 89 4d ee	 mov	 WORD PTR _pDarkSideTargetList$[ebp+14], cx
  000d6	66 89 7d e4	 mov	 WORD PTR _pDarkSideTargetList$[ebp+4], di

; 22299: 	// ----
; 22300: 	for( int i = 0; i < 5; i++ )
; 22301: 	{
; 22302: 		if( wTargetList[i] != 10000 )

  000da	b8 10 27 00 00	 mov	 eax, 10000		; 00002710H
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e2	c6 84 16 26 26
	00 00 00	 mov	 BYTE PTR [esi+edx+9766], 0
  000ea	b1 01		 mov	 cl, 1
  000ec	66 39 45 f0	 cmp	 WORD PTR _wTargetList$[ebp], ax
  000f0	74 0c		 je	 SHORT $LN3@GCMonkDark

; 22303: 		{
; 22304: 			++gObj[aIndex].m_btDarkSideTargetNum;

  000f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f7	00 8c 06 26 26
	00 00		 add	 BYTE PTR [esi+eax+9766], cl
$LN3@GCMonkDark:

; 22299: 	// ----
; 22300: 	for( int i = 0; i < 5; i++ )
; 22301: 	{
; 22302: 		if( wTargetList[i] != 10000 )

  000fe	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  00103	66 39 55 f2	 cmp	 WORD PTR _wTargetList$[ebp+2], dx
  00107	74 0c		 je	 SHORT $LN21@GCMonkDark

; 22303: 		{
; 22304: 			++gObj[aIndex].m_btDarkSideTargetNum;

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	00 8c 06 26 26
	00 00		 add	 BYTE PTR [esi+eax+9766], cl
$LN21@GCMonkDark:

; 22299: 	// ----
; 22300: 	for( int i = 0; i < 5; i++ )
; 22301: 	{
; 22302: 		if( wTargetList[i] != 10000 )

  00115	8b c2		 mov	 eax, edx
  00117	66 39 45 f4	 cmp	 WORD PTR _wTargetList$[ebp+4], ax
  0011b	74 0c		 je	 SHORT $LN23@GCMonkDark

; 22303: 		{
; 22304: 			++gObj[aIndex].m_btDarkSideTargetNum;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	00 8c 06 26 26
	00 00		 add	 BYTE PTR [esi+eax+9766], cl
$LN23@GCMonkDark:

; 22299: 	// ----
; 22300: 	for( int i = 0; i < 5; i++ )
; 22301: 	{
; 22302: 		if( wTargetList[i] != 10000 )

  00129	66 39 55 f6	 cmp	 WORD PTR _wTargetList$[ebp+6], dx
  0012d	74 0c		 je	 SHORT $LN25@GCMonkDark

; 22303: 		{
; 22304: 			++gObj[aIndex].m_btDarkSideTargetNum;

  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00134	00 8c 06 26 26
	00 00		 add	 BYTE PTR [esi+eax+9766], cl
$LN25@GCMonkDark:

; 22299: 	// ----
; 22300: 	for( int i = 0; i < 5; i++ )
; 22301: 	{
; 22302: 		if( wTargetList[i] != 10000 )

  0013b	8b c2		 mov	 eax, edx
  0013d	66 39 45 f8	 cmp	 WORD PTR _wTargetList$[ebp+8], ax
  00141	74 0c		 je	 SHORT $LN27@GCMonkDark

; 22303: 		{
; 22304: 			++gObj[aIndex].m_btDarkSideTargetNum;

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00148	00 8c 06 26 26
	00 00		 add	 BYTE PTR [esi+eax+9766], cl
$LN27@GCMonkDark:

; 22305: 		}
; 22306: 	}
; 22307: 	// ----
; 22308: 	memcpy(gObj[aIndex].m_wDarkSideTargetList, wTargetList, sizeof(wTargetList));

  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00155	8b 55 f0	 mov	 edx, DWORD PTR _wTargetList$[ebp]
  00158	8d 84 0e 28 26
	00 00		 lea	 eax, DWORD PTR [esi+ecx+9768]
  0015f	89 10		 mov	 DWORD PTR [eax], edx
  00161	8b 4d f4	 mov	 ecx, DWORD PTR _wTargetList$[ebp+4]
  00164	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00167	66 8b 55 f8	 mov	 dx, WORD PTR _wTargetList$[ebp+8]
  0016b	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 22309: 	DataSend(aIndex, (LPBYTE)&pDarkSideTargetList, pDarkSideTargetList.h.size);

  0016f	0f b6 45 e1	 movzx	 eax, BYTE PTR _pDarkSideTargetList$[ebp+1]
  00173	50		 push	 eax
  00174	8d 4d e0	 lea	 ecx, DWORD PTR _pDarkSideTargetList$[ebp]
  00177	51		 push	 ecx
  00178	53		 push	 ebx
  00179	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@GCMonkDark:

; 22310: }

  00181	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	33 cd		 xor	 ecx, ebp
  00188	5b		 pop	 ebx
  00189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ENDP ; GCMonkDarkSideTargetSelect
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendExp_INT64@@YAXHH_JHH@Z			; GCSendExp_INT64
; Function compile flags: /Ogtp
;	COMDAT ?GCSendExp_INT64@@YAXHH_JHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_exp$ = 16						; size = 8
_AttackDamage$ = 24					; size = 4
_MSBFlag$ = 28						; size = 4
?GCSendExp_INT64@@YAXHH_JHH@Z PROC			; GCSendExp_INT64, COMDAT

; 22314: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 22315: 	PMSG_KILLPLAYER_EXT pMsg;
; 22316: 
; 22317: 	PHeadSetBE((LPBYTE)&pMsg, 0x9C, sizeof(pMsg));

  00010	6a 10		 push	 16			; 00000010H
  00012	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 9c 00 00 00	 push	 156			; 0000009cH
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 22318: 	pMsg.NumberH = SET_NUMBERH(TargetIndex);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00023	8b c8		 mov	 ecx, eax

; 22319: 	pMsg.NumberL = SET_NUMBERL(TargetIndex);

  00025	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 22320: 	pMsg.ExpH = SET_NUMBERHW(exp);

  00028	8b 45 10	 mov	 eax, DWORD PTR _exp$[ebp]
  0002b	8b d0		 mov	 edx, eax
  0002d	c1 e9 08	 shr	 ecx, 8
  00030	c1 ea 10	 shr	 edx, 16			; 00000010H

; 22321: 	pMsg.ExpL = SET_NUMBERLW(exp);

  00033	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 22322: 	pMsg.DamageH = SET_NUMBERH(AttackDamage);

  00037	8b 45 18	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  0003a	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003d	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 22323: 	pMsg.DamageL = SET_NUMBERL(AttackDamage);
; 22324: 
; 22325: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00041	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00045	8b c8		 mov	 ecx, eax
  00047	c1 e9 08	 shr	 ecx, 8
  0004a	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al
  0004d	52		 push	 edx
  0004e	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00051	88 4d f6	 mov	 BYTE PTR _pMsg$[ebp+10], cl
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 22326: }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	83 c4 18	 add	 esp, 24			; 00000018H
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GCSendExp_INT64@@YAXHH_JHH@Z ENDP			; GCSendExp_INT64
_TEXT	ENDS
PUBLIC	?GCResultForExtendInvenOrWarehouse@@YAXHE@Z	; GCResultForExtendInvenOrWarehouse
; Function compile flags: /Ogtp
;	COMDAT ?GCResultForExtendInvenOrWarehouse@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_byIsSuccess$ = 12					; size = 1
?GCResultForExtendInvenOrWarehouse@@YAXHE@Z PROC	; GCResultForExtendInvenOrWarehouse, COMDAT

; 22335: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 22336: 	PMSG_EXPAND_RESULT pMsg;
; 22337: 	pMsg.h.set((LPBYTE)&pMsg, 0x2B, sizeof(pMsg));
; 22338: 	pMsg.IsSuccess = byIsSuccess;
; 22339: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00004	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00007	8a 45 0c	 mov	 al, BYTE PTR _byIsSuccess$[ebp]
  0000a	6a 04		 push	 4
  0000c	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0000f	51		 push	 ecx
  00010	52		 push	 edx
  00011	66 c7 45 fc c1
	04		 mov	 WORD PTR _pMsg$[ebp], 1217 ; 000004c1H
  00017	c6 45 fe 2b	 mov	 BYTE PTR _pMsg$[ebp+2], 43 ; 0000002bH
  0001b	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0001e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22340: }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?GCResultForExtendInvenOrWarehouse@@YAXHE@Z ENDP	; GCResultForExtendInvenOrWarehouse
_TEXT	ENDS
PUBLIC	__real@437f0000
PUBLIC	__real@406fc00000000000
PUBLIC	__real@437e0000
PUBLIC	__real@406fe00000000000
PUBLIC	?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ; CGInventoryEquipment
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@406fc00000000000
CONST	SEGMENT
__real@406fc00000000000 DQ 0406fc00000000000r	; 254
CONST	ENDS
;	COMDAT __real@437e0000
CONST	SEGMENT
__real@437e0000 DD 0437e0000r			; 254
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z PROC ; CGInventoryEquipment, COMDAT

; 22343: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 22344: 	if( !OBJMAX_RANGE(iIndex) )

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 ff 01 00
	00		 js	 $LN30@CGInventor@2
  00012	33 c0		 xor	 eax, eax
  00014	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 ec 01 00
	00		 je	 $LN30@CGInventor@2

; 22345: 	{
; 22346: 		return;
; 22347: 	}
; 22348: 	// ----
; 22349: 	LPOBJ lpObj = &gObj[iIndex];

  00025	56		 push	 esi
  00026	8b f7		 mov	 esi, edi
  00028	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 22350: 	// ----
; 22351: 	if( !gObjIsConnected(iIndex) )

  00034	57		 push	 edi
  00035	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003a	83 c4 04	 add	 esp, 4
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 cb 01 00
	00		 je	 $LN35@CGInventor@2

; 22352: 	{
; 22353: 		return;
; 22354: 	}
; 22355: 	// ----
; 22356: 	_tagPMSG_ANS_INVENTORY_EQUIPMENT_ITEM pMsg = { 0 };

  00045	33 c0		 xor	 eax, eax

; 22357: 	pMsg.btResult = 0;
; 22358: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x20, sizeof(_tagPMSG_ANS_INVENTORY_EQUIPMENT_ITEM));

  00047	6a 06		 push	 6
  00049	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0004c	6a 20		 push	 32			; 00000020H
  0004e	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00051	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00054	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00057	68 bf 00 00 00	 push	 191			; 000000bfH
  0005c	50		 push	 eax
  0005d	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00061	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 22359: 	pMsg.btItemPos = lpMsg->btItemPos;

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00069	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0006c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 22360: 	// ----
; 22361: 	if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 0.0 )

  0006f	8b 96 24 0e 00
	00		 mov	 edx, DWORD PTR [esi+3620]
  00075	0f b6 c0	 movzx	 eax, al
  00078	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00085	d9 ee		 fldz
  00087	da e9		 fucompp
  00089	df e0		 fnstsw	 ax
  0008b	f6 c4 44	 test	 ah, 68			; 00000044H
  0008e	7a 1c		 jp	 SHORT $LN27@CGInventor@2

; 22362: 	{
; 22363: 		pMsg.btResult = -1;
; 22364: 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00090	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00094	51		 push	 ecx
  00095	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00098	52		 push	 edx
  00099	57		 push	 edi
  0009a	c6 45 fd ff	 mov	 BYTE PTR _pMsg$[ebp+5], 255 ; 000000ffH
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	5e		 pop	 esi
  000a7	5f		 pop	 edi

; 22491: }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN27@CGInventor@2:
  000ac	53		 push	 ebx

; 22365: 		return;
; 22366: 	}
; 22367: 	// ----
; 22368: 	switch( lpObj->pInventory[lpMsg->btItemPos].m_Type )

  000ad	8a 59 04	 mov	 bl, BYTE PTR [ecx+4]
  000b0	0f b6 fb	 movzx	 edi, bl
  000b3	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  000b9	0f bf 44 17 06	 movsx	 eax, WORD PTR [edi+edx+6]
  000be	03 fa		 add	 edi, edx
  000c0	05 80 e5 ff ff	 add	 eax, -6784		; ffffe580H
  000c5	83 f8 06	 cmp	 eax, 6
  000c8	0f 87 26 01 00
	00		 ja	 $LN34@CGInventor@2
  000ce	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN42@CGInventor@2[eax*4]
$LN24@CGInventor@2:

; 22369: 	{
; 22370: 	case ITEMGET(13, 128):
; 22371: 	case ITEMGET(13, 129):
; 22372: 		{
; 22373: 			if( !lpObj->m_btSculptPos )

  000d5	8a 86 a0 27 00
	00		 mov	 al, BYTE PTR [esi+10144]
  000db	84 c0		 test	 al, al
  000dd	0f 85 af 00 00
	00		 jne	 $LN7@CGInventor@2

; 22374: 			{
; 22375: 				if( lpMsg->btValue == 254 )

  000e3	b3 fe		 mov	 bl, 254			; 000000feH
  000e5	38 59 05	 cmp	 BYTE PTR [ecx+5], bl
  000e8	0f 85 06 01 00
	00		 jne	 $LN34@CGInventor@2

; 22376: 				{
; 22377: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  000ee	d9 47 24	 fld	 DWORD PTR [edi+36]
  000f1	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  000f7	da e9		 fucompp
  000f9	df e0		 fnstsw	 ax
  000fb	f6 c4 44	 test	 ah, 68			; 00000044H
  000fe	0f 8a f0 00 00
	00		 jp	 $LN34@CGInventor@2

; 22378: 					{
; 22379: 						lpObj->m_btSculptPos = lpMsg->btItemPos;

  00104	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00107	88 86 a0 27 00
	00		 mov	 BYTE PTR [esi+10144], al

; 22380: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;
; 22381: 						pMsg.btResult = -2;
; 22382: 					}
; 22383: 				}
; 22384: 				break;
; 22385: 			}
; 22386: 			// ----
; 22387: 			if(		lpObj->m_btSculptPos < INVETORY_WEAR_SIZE 
; 22388: 				||	lpObj->m_btSculptPos >= MAIN_INVENTORY_SIZE )
; 22389: 			{
; 22390: 				break;
; 22391: 			}
; 22392: 			// ----
; 22393: 			if(		lpMsg->btValue			== 255
; 22394: 				&&	lpObj->m_btSculptPos	== lpMsg->btItemPos )
; 22395: 			{
; 22396: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )
; 22397: 				{
; 22398: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;
; 22399: 					pMsg.btResult = -1;
; 22400: 				}
; 22401: 				break;
; 22402: 			}
; 22403: 			// ----
; 22404: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);
; 22405:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 22406: 		}
; 22407: 		break;

  0010d	eb 6a		 jmp	 SHORT $LN41@CGInventor@2
$LN16@CGInventor@2:

; 22408: 		// --
; 22409: 	case ITEMGET(13, 130):
; 22410: 	case ITEMGET(13, 131):
; 22411: 	case ITEMGET(13, 132):
; 22412: 	case ITEMGET(13, 133):
; 22413: 		{
; 22414: 			if( !lpObj->m_btCharmPos )

  0010f	8a 86 a1 27 00
	00		 mov	 al, BYTE PTR [esi+10145]
  00115	84 c0		 test	 al, al
  00117	75 79		 jne	 SHORT $LN7@CGInventor@2

; 22415: 			{
; 22416: 				if( lpMsg->btValue == 254 )

  00119	b3 fe		 mov	 bl, 254			; 000000feH
  0011b	38 59 05	 cmp	 BYTE PTR [ecx+5], bl
  0011e	0f 85 d0 00 00
	00		 jne	 $LN34@CGInventor@2

; 22417: 				{
; 22418: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  00124	d9 47 24	 fld	 DWORD PTR [edi+36]
  00127	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  0012d	da e9		 fucompp
  0012f	df e0		 fnstsw	 ax
  00131	f6 c4 44	 test	 ah, 68			; 00000044H
  00134	0f 8a ba 00 00
	00		 jp	 $LN34@CGInventor@2

; 22419: 					{
; 22420: 						lpObj->m_btCharmPos = lpMsg->btItemPos;

  0013a	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  0013d	88 86 a1 27 00
	00		 mov	 BYTE PTR [esi+10145], al

; 22421: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;
; 22422: 						pMsg.btResult = -2;
; 22423: 					}
; 22424: 				}
; 22425: 				break;
; 22426: 			}
; 22427: 			// ----
; 22428: 			if(		lpObj->m_btCharmPos < INVETORY_WEAR_SIZE 
; 22429: 				||	lpObj->m_btCharmPos >= MAIN_INVENTORY_SIZE )
; 22430: 			{
; 22431: 				break;
; 22432: 			}
; 22433: 			// ----
; 22434: 			if(		lpMsg->btValue		== 255
; 22435: 				&&	lpObj->m_btCharmPos == lpMsg->btItemPos )
; 22436: 			{
; 22437: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )
; 22438: 				{
; 22439: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;
; 22440: 					pMsg.btResult = -1;
; 22441: 				}
; 22442: 				break;
; 22443: 			}
; 22444: 			// ----
; 22445: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);
; 22446:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 22447: 		}
; 22448: 		break;

  00143	eb 34		 jmp	 SHORT $LN41@CGInventor@2
$LN8@CGInventor@2:

; 22449: 		// --
; 22450: 	case ITEMGET(13, 134):
; 22451: 		{
; 22452: 			if( !lpObj->m_btArtifactPos )

  00145	8a 86 a2 27 00
	00		 mov	 al, BYTE PTR [esi+10146]
  0014b	84 c0		 test	 al, al
  0014d	75 43		 jne	 SHORT $LN7@CGInventor@2

; 22453: 			{
; 22454: 				if( lpMsg->btValue == 254 )

  0014f	b3 fe		 mov	 bl, 254			; 000000feH
  00151	38 59 05	 cmp	 BYTE PTR [ecx+5], bl
  00154	0f 85 9a 00 00
	00		 jne	 $LN34@CGInventor@2

; 22455: 				{
; 22456: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  0015a	d9 47 24	 fld	 DWORD PTR [edi+36]
  0015d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
  00163	da e9		 fucompp
  00165	df e0		 fnstsw	 ax
  00167	f6 c4 44	 test	 ah, 68			; 00000044H
  0016a	0f 8a 84 00 00
	00		 jp	 $LN34@CGInventor@2

; 22457: 					{
; 22458: 						lpObj->m_btArtifactPos = lpMsg->btItemPos;

  00170	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00173	88 86 a2 27 00
	00		 mov	 BYTE PTR [esi+10146], al
$LN41@CGInventor@2:

; 22459: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;

  00179	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  0017d	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437e0000
  00183	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00189	d9 5c 11 24	 fstp	 DWORD PTR [ecx+edx+36]

; 22460: 						pMsg.btResult = -2;

  0018d	88 5d fd	 mov	 BYTE PTR _pMsg$[ebp+5], bl

; 22461: 					}
; 22462: 				}
; 22463: 				break;

  00190	eb 62		 jmp	 SHORT $LN34@CGInventor@2
$LN7@CGInventor@2:

; 22464: 			}
; 22465: 			// ----
; 22466: 			if(		lpObj->m_btArtifactPos < INVETORY_WEAR_SIZE 
; 22467: 				||	lpObj->m_btArtifactPos >= MAIN_INVENTORY_SIZE )

  00192	3c 0c		 cmp	 al, 12			; 0000000cH
  00194	72 5e		 jb	 SHORT $LN34@CGInventor@2
  00196	3c cc		 cmp	 al, 204			; 000000ccH
  00198	73 5a		 jae	 SHORT $LN34@CGInventor@2

; 22468: 			{
; 22469: 				break;
; 22470: 			}
; 22471: 			// ----
; 22472: 			if(		lpMsg->btValue			== 255
; 22473: 				&&	lpObj->m_btArtifactPos	== lpMsg->btItemPos )

  0019a	b2 ff		 mov	 dl, 255			; 000000ffH
  0019c	38 51 05	 cmp	 BYTE PTR [ecx+5], dl
  0019f	75 24		 jne	 SHORT $LN2@CGInventor@2
  001a1	3a c3		 cmp	 al, bl
  001a3	75 20		 jne	 SHORT $LN2@CGInventor@2

; 22474: 			{
; 22475: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )

  001a5	d9 47 24	 fld	 DWORD PTR [edi+36]
  001a8	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fc00000000000
  001ae	da e9		 fucompp
  001b0	df e0		 fnstsw	 ax
  001b2	f6 c4 44	 test	 ah, 68			; 00000044H
  001b5	7a 3d		 jp	 SHORT $LN34@CGInventor@2

; 22476: 				{
; 22477: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;

  001b7	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  001bd	d9 5f 24	 fstp	 DWORD PTR [edi+36]

; 22478: 					pMsg.btResult = -1;

  001c0	88 55 fd	 mov	 BYTE PTR _pMsg$[ebp+5], dl

; 22479: 				}
; 22480: 				break;

  001c3	eb 2f		 jmp	 SHORT $LN34@CGInventor@2
$LN2@CGInventor@2:

; 22481: 			}
; 22482: 			// ----
; 22483: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);

  001c5	8b 16		 mov	 edx, DWORD PTR [esi]
  001c7	6a 01		 push	 1
  001c9	52		 push	 edx
  001ca	68 98 0d 00 00	 push	 3480			; 00000d98H
  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001d4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 22484:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  001df	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001e3	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001e6	50		 push	 eax
  001e7	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001ea	51		 push	 ecx
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f1	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@CGInventor@2:

; 22485: 		}
; 22486: 		break;
; 22487: 	}
; 22488: 	// ----
; 22489: 	gObjCalCharacter(iIndex);

  001f4	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  001f7	56		 push	 esi
  001f8	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 22490: 	DataSend(iIndex,(LPBYTE)&pMsg, pMsg.h.size);

  001fd	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00201	50		 push	 eax
  00202	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00205	51		 push	 ecx
  00206	56		 push	 esi
  00207	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0020c	83 c4 10	 add	 esp, 16			; 00000010H
  0020f	5b		 pop	 ebx
$LN35@CGInventor@2:
  00210	5e		 pop	 esi
$LN30@CGInventor@2:
  00211	5f		 pop	 edi

; 22491: }

  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
  00216	8b ff		 npad	 2
$LN42@CGInventor@2:
  00218	00 00 00 00	 DD	 $LN24@CGInventor@2
  0021c	00 00 00 00	 DD	 $LN24@CGInventor@2
  00220	00 00 00 00	 DD	 $LN16@CGInventor@2
  00224	00 00 00 00	 DD	 $LN16@CGInventor@2
  00228	00 00 00 00	 DD	 $LN16@CGInventor@2
  0022c	00 00 00 00	 DD	 $LN16@CGInventor@2
  00230	00 00 00 00	 DD	 $LN8@CGInventor@2
?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ENDP ; CGInventoryEquipment
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?UpdateCharInfo@@YAXH@Z				; UpdateCharInfo
; Function compile flags: /Ogtp
;	COMDAT ?UpdateCharInfo@@YAXH@Z
_TEXT	SEGMENT
_pRequest$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?UpdateCharInfo@@YAXH@Z PROC				; UpdateCharInfo, COMDAT

; 22494: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]

; 22495: 	if( !OBJMAX_RANGE(aIndex) )

  00013	85 c9		 test	 ecx, ecx
  00015	78 73		 js	 SHORT $LN2@UpdateChar
  00017	33 c0		 xor	 eax, eax
  00019	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  0001f	0f 9e c0	 setle	 al
  00022	85 c0		 test	 eax, eax
  00024	74 64		 je	 SHORT $LN2@UpdateChar

; 22496: 	{
; 22497: 		return;
; 22498: 	}
; 22499: 	// ----
; 22500: 	CHAR_UPDATEINFO pRequest;
; 22501: 	pRequest.h.set((LPBYTE)&pRequest, 0xFB, 8, sizeof(CHAR_UPDATEINFO));
; 22502: 	// ----
; 22503: 	pRequest.Strength		= gObj[aIndex].Strength;

  00026	8b c1		 mov	 eax, ecx
  00028	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0002e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	c7 45 e8 c1 14
	fb 08		 mov	 DWORD PTR _pRequest$[ebp], 150672577 ; 08fb14c1H
  0003b	0f b7 90 f4 00
	00 00		 movzx	 edx, WORD PTR [eax+244]
  00042	66 89 55 ec	 mov	 WORD PTR _pRequest$[ebp+4], dx

; 22504: 	pRequest.Dexterity		= gObj[aIndex].Dexterity;

  00046	0f b7 90 f6 00
	00 00		 movzx	 edx, WORD PTR [eax+246]
  0004d	66 89 55 ee	 mov	 WORD PTR _pRequest$[ebp+6], dx

; 22505: 	pRequest.Vitality		= gObj[aIndex].Vitality;

  00051	0f b7 90 f8 00
	00 00		 movzx	 edx, WORD PTR [eax+248]
  00058	66 89 55 f0	 mov	 WORD PTR _pRequest$[ebp+8], dx

; 22506: 	pRequest.Energy			= gObj[aIndex].Energy;

  0005c	0f b7 90 fa 00
	00 00		 movzx	 edx, WORD PTR [eax+250]
  00063	66 89 55 f2	 mov	 WORD PTR _pRequest$[ebp+10], dx

; 22507: 	pRequest.Leadership		= gObj[aIndex].Leadership;

  00067	0f b7 90 18 01
	00 00		 movzx	 edx, WORD PTR [eax+280]
  0006e	66 89 55 f4	 mov	 WORD PTR _pRequest$[ebp+12], dx

; 22508: 	pRequest.LevelUpPoint	= gObj[aIndex].LevelUpPoint;

  00072	8b 80 c0 00 00
	00		 mov	 eax, DWORD PTR [eax+192]

; 22509: 	// ----
; 22510: 	DataSend(aIndex, (LPBYTE)&pRequest, sizeof(pRequest));

  00078	6a 14		 push	 20			; 00000014H
  0007a	8d 55 e8	 lea	 edx, DWORD PTR _pRequest$[ebp]
  0007d	52		 push	 edx
  0007e	51		 push	 ecx
  0007f	89 45 f8	 mov	 DWORD PTR _pRequest$[ebp+16], eax
  00082	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@UpdateChar:

; 22511: }

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?UpdateCharInfo@@YAXH@Z ENDP				; UpdateCharInfo
_TEXT	ENDS
PUBLIC	?WarehouseNumberSend@@YAXH@Z			; WarehouseNumberSend
; Function compile flags: /Ogtp
;	COMDAT ?WarehouseNumberSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_aIndex$ = 8						; size = 4
?WarehouseNumberSend@@YAXH@Z PROC			; WarehouseNumberSend, COMDAT

; 22596: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 22597: 	LPOBJ lpObj = &gObj[aIndex];

  00006	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 22598: 	CHANGEWAREHOUSE pMsg;
; 22599: 	pMsg.h.set((LPBYTE)&pMsg, 0xFB, 0xC1, sizeof(pMsg));
; 22600: 	pMsg.Number = lpObj->WarehouseNumber;

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000f	8b c8		 mov	 ecx, eax
  00011	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00017	c7 45 f8 c1 08
	fb c1		 mov	 DWORD PTR _pMsg$[ebp], -1040512831 ; c1fb08c1H
  0001e	8b 8c 11 e8 2a
	00 00		 mov	 ecx, DWORD PTR [ecx+edx+10984]

; 22601: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00025	6a 08		 push	 8
  00027	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0002a	52		 push	 edx
  0002b	50		 push	 eax
  0002c	89 4d fc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx
  0002f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22602: }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?WarehouseNumberSend@@YAXH@Z ENDP			; WarehouseNumberSend
_TEXT	ENDS
PUBLIC	?CGRecvOffTrade@@YAXPAUPMSG_OFFTRADE@@H@Z	; CGRecvOffTrade
; Function compile flags: /Ogtp
;	COMDAT ?CGRecvOffTrade@@YAXPAUPMSG_OFFTRADE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRecvOffTrade@@YAXPAUPMSG_OFFTRADE@@H@Z PROC		; CGRecvOffTrade, COMDAT

; 22606: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 22607: 	if(!g_ZtLicense.CheckUser(eZtUB::MedoniAndrei))

  00003	6a 32		 push	 50			; 00000032H
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000a	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0000f	84 c0		 test	 al, al
  00011	74 2e		 je	 SHORT $LN3@CGRecvOffT

; 22608: 	{
; 22609: 		return;
; 22610: 	}
; 22611: 
; 22612: 	if(!OBJMAX_RANGE(aIndex))

  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	78 27		 js	 SHORT $LN3@CGRecvOffT
  0001a	33 c9		 xor	 ecx, ecx
  0001c	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00021	0f 9e c1	 setle	 cl
  00024	85 c9		 test	 ecx, ecx
  00026	74 19		 je	 SHORT $LN3@CGRecvOffT

; 22613: 	{
; 22614: 		return;
; 22615: 	}
; 22616: 
; 22617: 	LPOBJ lpObj = &gObj[aIndex];
; 22618: 
; 22619: 	lpObj->m_bActiveOffTrade = lpMsg->Active;

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0002b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00031	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003a	88 94 08 14 2b
	00 00		 mov	 BYTE PTR [eax+ecx+11028], dl
$LN3@CGRecvOffT:

; 22620: }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?CGRecvOffTrade@@YAXPAUPMSG_OFFTRADE@@H@Z ENDP		; CGRecvOffTrade
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?InventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCItem@@@Z ; InventoryInsertItemTemp
EXTRN	?gObjExtInventory2RectCheck@@YAEHHHHH@Z:PROC	; gObjExtInventory2RectCheck
EXTRN	?gObjExtInventory1RectCheck@@YAEHHHHH@Z:PROC	; gObjExtInventory1RectCheck
EXTRN	?gObjInventoryRectCheck@@YAEHHHHH@Z:PROC	; gObjInventoryRectCheck
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
; Function compile flags: /Ogtp
;	COMDAT ?InventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCItem@@@Z
_TEXT	SEGMENT
_iwidth$ = -228						; size = 4
_iheight$ = -224					; size = 4
_h$ = -220						; size = 4
_item$ = -216						; size = 212
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Item$ = 12						; size = 4
?InventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCItem@@@Z PROC ; InventoryInsertItemTemp, COMDAT

; 23114: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _Item$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 23115: 	CItem item;

  0001b	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00021	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 23116: 	int w,h,iwidth,iheight;
; 23117: 	BYTE blank = 0;
; 23118: 	int result = -1;
; 23119: 
; 23120: 	if(Item->GetSize((int &)iwidth,(int &)iheight)==0)

  00026	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0002c	50		 push	 eax
  0002d	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00033	51		 push	 ecx
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0003b	85 c0		 test	 eax, eax
  0003d	75 35		 jne	 SHORT $LN32@InventoryI

; 23121: 	{
; 23122: 		LogAdd(lMsg.Get(527),__FILE__,__LINE__);

  0003f	68 52 5a 00 00	 push	 23122			; 00005a52H
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00049	68 0f 02 00 00	 push	 527			; 0000020fH
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00053	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00058	50		 push	 eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	5f		 pop	 edi

; 23123: 		return -1;

  00063	0c ff		 or	 al, 255			; 000000ffH
  00065	5e		 pop	 esi

; 23209: }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN32@InventoryI:
  00074	53		 push	 ebx

; 23124: 	}
; 23125: 
; 23126: 	for(h = 0; h < 8; h++)

  00075	33 db		 xor	 ebx, ebx
  00077	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL60@InventoryI:

; 23127: 	{
; 23128: 		for(w = 0; w < 8; w++)

  00080	33 f6		 xor	 esi, esi
  00082	eb 0c 8d a4 24
	00 00 00 00 eb
	03 8d 49 00	 npad	 14
$LL28@InventoryI:

; 23129: 		{
; 23130: 			if(*(BYTE*)(lpObj->pInventoryMap+h*8+w) == 255)

  00090	8b 97 28 0e 00
	00		 mov	 edx, DWORD PTR [edi+3624]
  00096	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
  0009d	03 d0		 add	 edx, eax
  0009f	80 3c 32 ff	 cmp	 BYTE PTR [edx+esi], 255	; 000000ffH
  000a3	75 27		 jne	 SHORT $LN27@InventoryI

; 23131: 			{
; 23132: 				blank = gObjInventoryRectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  000a5	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  000ab	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000b1	8b 17		 mov	 edx, DWORD PTR [edi]
  000b3	50		 push	 eax
  000b4	51		 push	 ecx
  000b5	53		 push	 ebx
  000b6	56		 push	 esi
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  000bd	83 c4 14	 add	 esp, 20			; 00000014H

; 23133: 
; 23134: 				if(blank == 254)

  000c0	3c fe		 cmp	 al, 254			; 000000feH
  000c2	74 0e		 je	 SHORT $LN30@InventoryI

; 23135: 				{	
; 23136: 					result = -1;
; 23137: 					break;
; 23138: 				}
; 23139: 
; 23140: 				if(blank != 255)

  000c4	3c ff		 cmp	 al, 255			; 000000ffH
  000c6	0f 85 f6 00 00
	00		 jne	 $LN63@InventoryI
$LN27@InventoryI:

; 23127: 	{
; 23128: 		for(w = 0; w < 8; w++)

  000cc	46		 inc	 esi
  000cd	83 fe 08	 cmp	 esi, 8
  000d0	7c be		 jl	 SHORT $LL28@InventoryI
$LN30@InventoryI:

; 23124: 	}
; 23125: 
; 23126: 	for(h = 0; h < 8; h++)

  000d2	43		 inc	 ebx
  000d3	83 fb 08	 cmp	 ebx, 8
  000d6	7c a8		 jl	 SHORT $LL60@InventoryI

; 23141: 				{
; 23142: 					return blank;
; 23143: 				}
; 23144: 			}
; 23145: 		}
; 23146: 	}
; 23147: 	
; 23148: 	if(lpObj->ExpandedInventory == 0)

  000d8	80 bf 24 26 00
	00 00		 cmp	 BYTE PTR [edi+9764], 0

; 23149: 	{
; 23150: 		return -1;

  000df	0f 84 db 00 00
	00		 je	 $LN7@InventoryI

; 23151: 	}
; 23152: 	
; 23153: 	if(result == -1)
; 23154: 	{
; 23155: 		for(h = 0; h < 4; h++)

  000e5	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _h$[ebp], 0
  000ef	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
$LL61@InventoryI:

; 23156: 		{
; 23157: 			for( w = 0; w < 8; w++)

  000f4	33 f6		 xor	 esi, esi
  000f6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL58@InventoryI:

; 23158: 			{	
; 23159: 				if(*(BYTE*)((lpObj->pInventoryMap+64)+h*8+w) == 255)

  00100	8b 87 28 0e 00
	00		 mov	 eax, DWORD PTR [edi+3624]
  00106	03 c3		 add	 eax, ebx
  00108	80 3c 30 ff	 cmp	 BYTE PTR [eax+esi], 255	; 000000ffH
  0010c	75 2d		 jne	 SHORT $LN16@InventoryI

; 23160: 				{
; 23161: 					blank = gObjExtInventory1RectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  0010e	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _iheight$[ebp]
  00114	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _iwidth$[ebp]
  0011a	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  00120	51		 push	 ecx
  00121	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00123	52		 push	 edx
  00124	50		 push	 eax
  00125	56		 push	 esi
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 ?gObjExtInventory1RectCheck@@YAEHHHHH@Z ; gObjExtInventory1RectCheck
  0012c	83 c4 14	 add	 esp, 20			; 00000014H

; 23162: 
; 23163: 					if(blank == 254)

  0012f	3c fe		 cmp	 al, 254			; 000000feH
  00131	74 0e		 je	 SHORT $LN19@InventoryI

; 23164: 					{
; 23165: 						result = -1;
; 23166: 						break;
; 23167: 					}
; 23168: 					
; 23169: 					if(blank != 255)

  00133	3c ff		 cmp	 al, 255			; 000000ffH
  00135	0f 85 87 00 00
	00		 jne	 $LN63@InventoryI
$LN16@InventoryI:

; 23156: 		{
; 23157: 			for( w = 0; w < 8; w++)

  0013b	46		 inc	 esi
  0013c	83 fe 08	 cmp	 esi, 8
  0013f	7c bf		 jl	 SHORT $LL58@InventoryI
$LN19@InventoryI:

; 23151: 	}
; 23152: 	
; 23153: 	if(result == -1)
; 23154: 	{
; 23155: 		for(h = 0; h < 4; h++)

  00141	ff 85 24 ff ff
	ff		 inc	 DWORD PTR _h$[ebp]
  00147	83 c3 08	 add	 ebx, 8
  0014a	83 fb 60	 cmp	 ebx, 96			; 00000060H
  0014d	7c a5		 jl	 SHORT $LL61@InventoryI

; 23170: 					{
; 23171: 						return blank;
; 23172: 					}
; 23173: 				}
; 23174: 			}
; 23175: 		}
; 23176: 	}
; 23177: 	
; 23178: 	if(lpObj->ExpandedInventory == 1)

  0014f	80 bf 24 26 00
	00 01		 cmp	 BYTE PTR [edi+9764], 1

; 23179: 	{
; 23180: 		return -1;

  00156	74 68		 je	 SHORT $LN7@InventoryI

; 23181: 	}
; 23182: 	
; 23183: 	if(result == -1)
; 23184: 	{
; 23185: 		for(h = 0; h < 4; h++)

  00158	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _h$[ebp], 0
  00162	bb 60 00 00 00	 mov	 ebx, 96			; 00000060H
  00167	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL62@InventoryI:

; 23186: 		{
; 23187: 			for( w = 0; w < 8; w++)

  00170	33 f6		 xor	 esi, esi
$LL59@InventoryI:

; 23188: 			{	
; 23189: 				if(*(BYTE*)((lpObj->pInventoryMap+96)+h*8+w) == 255)

  00172	8b 97 28 0e 00
	00		 mov	 edx, DWORD PTR [edi+3624]
  00178	03 d3		 add	 edx, ebx
  0017a	80 3c 32 ff	 cmp	 BYTE PTR [edx+esi], 255	; 000000ffH
  0017e	75 29		 jne	 SHORT $LN5@InventoryI

; 23190: 				{
; 23191: 					blank = gObjExtInventory2RectCheck(lpObj->m_Index,w,h,iwidth,iheight);

  00180	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  00186	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  0018c	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  00192	50		 push	 eax
  00193	8b 07		 mov	 eax, DWORD PTR [edi]
  00195	51		 push	 ecx
  00196	52		 push	 edx
  00197	56		 push	 esi
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ?gObjExtInventory2RectCheck@@YAEHHHHH@Z ; gObjExtInventory2RectCheck
  0019e	83 c4 14	 add	 esp, 20			; 00000014H

; 23192: 					
; 23193: 					if(blank == 254)

  001a1	3c fe		 cmp	 al, 254			; 000000feH
  001a3	74 0a		 je	 SHORT $LN8@InventoryI

; 23194: 					{
; 23195: 						result = -1;
; 23196: 						break;
; 23197: 					}
; 23198: 					
; 23199: 					if(blank != 255)

  001a5	3c ff		 cmp	 al, 255			; 000000ffH
  001a7	75 19		 jne	 SHORT $LN63@InventoryI
$LN5@InventoryI:

; 23186: 		{
; 23187: 			for( w = 0; w < 8; w++)

  001a9	46		 inc	 esi
  001aa	83 fe 08	 cmp	 esi, 8
  001ad	7c c3		 jl	 SHORT $LL59@InventoryI
$LN8@InventoryI:

; 23181: 	}
; 23182: 	
; 23183: 	if(result == -1)
; 23184: 	{
; 23185: 		for(h = 0; h < 4; h++)

  001af	ff 85 24 ff ff
	ff		 inc	 DWORD PTR _h$[ebp]
  001b5	83 c3 08	 add	 ebx, 8
  001b8	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  001be	7c b0		 jl	 SHORT $LL62@InventoryI
$LN7@InventoryI:

; 23200: 					{
; 23201: 						return blank;
; 23202: 					}
; 23203: 				}
; 23204: 			}
; 23205: 		}
; 23206: 	}
; 23207: 	
; 23208: 	return result;

  001c0	0c ff		 or	 al, 255			; 000000ffH
$LN63@InventoryI:

; 23209: }

  001c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c5	5b		 pop	 ebx
  001c6	5f		 pop	 edi
  001c7	33 cd		 xor	 ecx, ebp
  001c9	5e		 pop	 esi
  001ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
?InventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCItem@@@Z ENDP ; InventoryInsertItemTemp
_TEXT	ENDS
PUBLIC	??_C@_0DC@LOFPCIL@Th?C?$LJng?5?D?$JB?a?$LL?$DPnh?C?$KCn?5v?a?$LK?$KNt?5kh?C?$LEng?5?D@ ; `string'
PUBLIC	??_C@_0BK@FJCFAOJL@You?5can?8t?5use?5Lucky?5items?$AA@ ; `string'
PUBLIC	_aRecv$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGMoveItemProc@@YAXPAUPMSG_MOVEITEM@@F@Z	; CGMoveItemProc
EXTRN	?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z:PROC	; gObjInventoryMoveItem
EXTRN	?GetSlot@CItem@@QAEEXZ:PROC			; CItem::GetSlot
;	COMDAT ??_C@_0DC@LOFPCIL@Th?C?$LJng?5?D?$JB?a?$LL?$DPnh?C?$KCn?5v?a?$LK?$KNt?5kh?C?$LEng?5?D@
CONST	SEGMENT
??_C@_0DC@LOFPCIL@Th?C?$LJng?5?D?$JB?a?$LL?$DPnh?C?$KCn?5v?a?$LK?$KNt?5kh?C?$LEng?5?D@ DB 'T'
	DB	'h', 0c3H, 0b9H, 'ng ', 0c4H, 091H, 0e1H, 0bbH, '?nh', 0c3H, 0a2H
	DB	'n v', 0e1H, 0baH, 0adH, 't kh', 0c3H, 0b4H, 'ng ', 0c4H, 091H
	DB	0e1H, 0bbH, '?ch', 0e1H, 0bbH, '?tr', 0e1H, 0bbH, 091H, 'ng.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FJCFAOJL@You?5can?8t?5use?5Lucky?5items?$AA@
CONST	SEGMENT
??_C@_0BK@FJCFAOJL@You?5can?8t?5use?5Lucky?5items?$AA@ DB 'You can''t use'
	DB	' Lucky items', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGMoveItemProc@@YAXPAUPMSG_MOVEITEM@@F@Z
_TEXT	SEGMENT
_DurTargetSend$ = -184					; size = 4
_DurSend$ = -180					; size = 4
_aRecv$GSCopy$ = -176					; size = 4
tv735 = -172						; size = 4
_h$ = -168						; size = 4
_lpObj$ = -164						; size = 4
_w$ = -160						; size = 4
tv817 = -156						; size = 4
tv726 = -156						; size = 4
tv451 = -156						; size = 4
tv835 = -152						; size = 4
_n$ = -152						; size = 4
_Target$ = -148						; size = 4
_TargetMap$253044 = -144				; size = 128
_ItemInfo$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?CGMoveItemProc@@YAXPAUPMSG_MOVEITEM@@F@Z PROC		; CGMoveItemProc, COMDAT

; 23212: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _aRecv$[ebp]
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 23266:                   }
; 23267:                }
; 23268:             }
; 23269:          }
; 23270:       }
; 23271: 
; 23272:       for (n = 0; n < CHAOS_BOX_SIZE; n++) 

  0001d	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _aRecv$GSCopy$[ebp], ebx
  00023	66 85 c0	 test	 ax, ax
  00026	0f 88 42 05 00
	00		 js	 $LN17@CGMoveItem

; 23213:    if (OBJMAX_RANGE(aIndex) == 0) 

  0002c	33 d2		 xor	 edx, edx
  0002e	b9 97 3a 00 00	 mov	 ecx, 14999		; 00003a97H
  00033	66 3b c1	 cmp	 ax, cx
  00036	0f 9e c2	 setle	 dl
  00039	8b ca		 mov	 ecx, edx
  0003b	85 c9		 test	 ecx, ecx
  0003d	0f 84 2b 05 00
	00		 je	 $LN17@CGMoveItem

; 23214:    { 
; 23215: 		return; 
; 23216:    }
; 23217: 
; 23218:    LPOBJ lpObj = &gObj[aIndex];

  00043	0f bf f0	 movsx	 esi, ax

; 23219: 
; 23220:    if (aRecv->Target == -1) 

  00046	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  0004a	8b fe		 mov	 edi, esi
  0004c	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00052	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	89 b5 64 ff ff
	ff		 mov	 DWORD PTR tv451[ebp], esi
  0005e	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi
  00064	83 f8 ff	 cmp	 eax, -1
  00067	0f 84 01 05 00
	00		 je	 $LN17@CGMoveItem

; 23221:    { 
; 23222: 		return; 
; 23223:    }
; 23224: 
; 23225:    if (aRecv->tFlag == 3 & aRecv->sFlag == 0 && lpObj->pInventory[aRecv->Source].IsItem()) //check input item

  0006d	33 c9		 xor	 ecx, ecx
  0006f	80 7b 05 03	 cmp	 BYTE PTR [ebx+5], 3
  00073	0f 94 c1	 sete	 cl
  00076	33 d2		 xor	 edx, edx
  00078	38 53 04	 cmp	 BYTE PTR [ebx+4], dl
  0007b	0f 94 c2	 sete	 dl
  0007e	85 ca		 test	 ecx, edx
  00080	74 5e		 je	 SHORT $LN75@CGMoveItem
  00082	0f b6 4b 06	 movzx	 ecx, BYTE PTR [ebx+6]
  00086	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0008c	03 8f 24 0e 00
	00		 add	 ecx, DWORD PTR [edi+3620]
  00092	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00097	85 c0		 test	 eax, eax
  00099	74 45		 je	 SHORT $LN75@CGMoveItem

; 23226:    {	
; 23227:       if ( g_LuckyItemManager.IsLuckyItemEquipment(lpObj->pInventory[aRecv->Source].m_Type))

  0009b	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  0009f	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  000a5	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000ab	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  000b0	52		 push	 edx
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  000b6	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  000bb	85 c0		 test	 eax, eax
  000bd	74 21		 je	 SHORT $LN75@CGMoveItem

; 23228:       {
; 23229:          GCServerMsgStringSend("You can't use Lucky items", aIndex, 0x01);

  000bf	6a 01		 push	 1
  000c1	56		 push	 esi
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FJCFAOJL@You?5can?8t?5use?5Lucky?5items?$AA@
  000c7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23389: 	}
; 23390: }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d5	33 cd		 xor	 ecx, ebp
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN75@CGMoveItem:

; 23230: 
; 23231:          return;
; 23232:       }
; 23233:    }
; 23234: 
; 23235:    int p = 0, c = 0, d = 0, w = 0, h = 0, n = 0;

  000e0	33 c0		 xor	 eax, eax

; 23236: 
; 23237:    int Target = -1;
; 23238: 
; 23239:    BYTE ItemInfo[MAX_ITEM_INFO];
; 23240: 
; 23241:    BOOL DurSend;
; 23242: 
; 23243:    BOOL DurTargetSend;
; 23244: 
; 23245:    if (aRecv->tFlag == 3 & aRecv->sFlag == 0 && lpObj->pInventory[aRecv->Source].IsItem())

  000e2	80 7b 05 03	 cmp	 BYTE PTR [ebx+5], 3
  000e6	89 85 60 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax
  000ec	89 85 58 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
  000f2	0f 94 c0	 sete	 al
  000f5	33 c9		 xor	 ecx, ecx
  000f7	38 4b 04	 cmp	 BYTE PTR [ebx+4], cl
  000fa	c7 85 6c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _Target$[ebp], -1
  00104	0f 94 c1	 sete	 cl
  00107	85 c1		 test	 eax, ecx
  00109	0f 84 0a 02 00
	00		 je	 $LN47@CGMoveItem
  0010f	0f b6 4b 06	 movzx	 ecx, BYTE PTR [ebx+6]
  00113	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00119	03 8f 24 0e 00
	00		 add	 ecx, DWORD PTR [edi+3620]
  0011f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00124	85 c0		 test	 eax, eax
  00126	0f 84 ed 01 00
	00		 je	 $LN47@CGMoveItem

; 23246:    {
; 23247:       ItemByteConvert(ItemInfo, lpObj->pInventory[aRecv->Source]);

  0012c	0f b6 73 06	 movzx	 esi, BYTE PTR [ebx+6]
  00130	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00136	03 b7 24 0e 00
	00		 add	 esi, DWORD PTR [edi+3620]
  0013c	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00142	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00145	8b fc		 mov	 edi, esp
  00147	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0014c	52		 push	 edx
  0014d	f3 a5		 rep movsd
  0014f	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 23248: 
; 23249:       int TargetMap[CHAOS_BOX_SIZE] = { '\0' };

  00154	33 ff		 xor	 edi, edi
  00156	6a 7c		 push	 124			; 0000007cH
  00158	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _TargetMap$253044[ebp+4]
  0015e	57		 push	 edi
  0015f	50		 push	 eax
  00160	89 bd 70 ff ff
	ff		 mov	 DWORD PTR _TargetMap$253044[ebp], edi
  00166	e8 00 00 00 00	 call	 _memset
  0016b	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _TargetMap$253044[ebp]
  00171	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H

; 23250: 
; 23251:       for (n = 0; n < CHAOS_BOX_SIZE; n++) 

  00177	89 bd 68 ff ff
	ff		 mov	 DWORD PTR _n$[ebp], edi
  0017d	89 bd 64 ff ff
	ff		 mov	 DWORD PTR tv726[ebp], edi
  00183	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv735[ebp], ecx
  00189	8d a4 24 00 00
	00 00		 npad	 7
$LL46@CGMoveItem:

; 23252: 	  {
; 23253:          if (lpObj->pChaosBox[n].IsItem()) 

  00190	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _lpObj$[ebp]
  00196	8b 8e 78 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3704]
  0019c	03 cf		 add	 ecx, edi
  0019e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001a3	85 c0		 test	 eax, eax
  001a5	74 65		 je	 SHORT $LN45@CGMoveItem

; 23254: 		 {
; 23255:             lpObj->pChaosBox[n].GetSize((int &)w, (int &)h);

  001a7	8b 8e 78 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3704]
  001ad	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _h$[ebp]
  001b3	52		 push	 edx
  001b4	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _w$[ebp]
  001ba	50		 push	 eax
  001bb	03 cf		 add	 ecx, edi
  001bd	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 23256: 
; 23257:             for (c = 0; c < w; c++) 

  001c2	33 f6		 xor	 esi, esi
  001c4	39 b5 60 ff ff
	ff		 cmp	 DWORD PTR _w$[ebp], esi
  001ca	7e 40		 jle	 SHORT $LN45@CGMoveItem

; 23254: 		 {
; 23255:             lpObj->pChaosBox[n].GetSize((int &)w, (int &)h);

  001cc	8b bd 54 ff ff
	ff		 mov	 edi, DWORD PTR tv735[ebp]
$LL42@CGMoveItem:

; 23258: 			{
; 23259:                for (d = 0; d < h; d++) 

  001d2	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  001d8	85 d2		 test	 edx, edx
  001da	7e 1e		 jle	 SHORT $LN41@CGMoveItem
  001dc	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  001e2	03 c6		 add	 eax, esi
  001e4	8b cf		 mov	 ecx, edi
$LL39@CGMoveItem:

; 23260: 			   {
; 23261:                   p = c + d * 8 + n;
; 23262: 
; 23263:                   if (p < CHAOS_BOX_SIZE) 

  001e6	83 f8 20	 cmp	 eax, 32			; 00000020H
  001e9	7d 06		 jge	 SHORT $LN38@CGMoveItem

; 23264: 				  {
; 23265:                      TargetMap[p] = 1;

  001eb	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
$LN38@CGMoveItem:

; 23258: 			{
; 23259:                for (d = 0; d < h; d++) 

  001f1	83 c0 08	 add	 eax, 8
  001f4	83 c1 20	 add	 ecx, 32			; 00000020H
  001f7	4a		 dec	 edx
  001f8	75 ec		 jne	 SHORT $LL39@CGMoveItem
$LN41@CGMoveItem:

; 23256: 
; 23257:             for (c = 0; c < w; c++) 

  001fa	46		 inc	 esi
  001fb	83 c7 04	 add	 edi, 4
  001fe	3b b5 60 ff ff
	ff		 cmp	 esi, DWORD PTR _w$[ebp]
  00204	7c cc		 jl	 SHORT $LL42@CGMoveItem
  00206	8b bd 64 ff ff
	ff		 mov	 edi, DWORD PTR tv726[ebp]
$LN45@CGMoveItem:

; 23250: 
; 23251:       for (n = 0; n < CHAOS_BOX_SIZE; n++) 

  0020c	ff 85 68 ff ff
	ff		 inc	 DWORD PTR _n$[ebp]
  00212	83 85 54 ff ff
	ff 04		 add	 DWORD PTR tv735[ebp], 4
  00219	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0021f	89 bd 64 ff ff
	ff		 mov	 DWORD PTR tv726[ebp], edi
  00225	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  0022b	0f 8c 5f ff ff
	ff		 jl	 $LL46@CGMoveItem

; 23266:                   }
; 23267:                }
; 23268:             }
; 23269:          }
; 23270:       }
; 23271: 
; 23272:       for (n = 0; n < CHAOS_BOX_SIZE; n++) 

  00231	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _TargetMap$253044[ebp]
  00237	33 ff		 xor	 edi, edi
  00239	89 95 68 ff ff
	ff		 mov	 DWORD PTR tv835[ebp], edx
  0023f	90		 npad	 1
$LL35@CGMoveItem:

; 23273: 	  {
; 23274:          if (!TargetMap[n]) 

  00240	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv835[ebp]
  00246	83 38 00	 cmp	 DWORD PTR [eax], 0
  00249	0f 85 b4 00 00
	00		 jne	 $LN34@CGMoveItem

; 23277: 
; 23278:             lpObj->pInventory[aRecv->Source].GetSize((int &)w, (int &)h);

  0024f	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00255	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _h$[ebp]
  0025b	51		 push	 ecx
  0025c	0f b6 4b 06	 movzx	 ecx, BYTE PTR [ebx+6]
  00260	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00266	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
  0026c	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _w$[ebp]
  00272	8b f7		 mov	 esi, edi
  00274	52		 push	 edx
  00275	89 b5 6c ff ff
	ff		 mov	 DWORD PTR _Target$[ebp], esi
  0027b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 23279: 
; 23280:             for (c = 0; c < w; c++) 

  00280	33 d2		 xor	 edx, edx
  00282	39 95 60 ff ff
	ff		 cmp	 DWORD PTR _w$[ebp], edx
  00288	7e 70		 jle	 SHORT $LN29@CGMoveItem

; 23275: 		 {
; 23276:             Target = n;

  0028a	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv835[ebp]
  00290	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _h$[ebp]
  00296	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv817[ebp], ecx
  0029c	8d 64 24 00	 npad	 4
$LL31@CGMoveItem:

; 23281: 			{
; 23282:                for (d = 0; d < h; d++) 

  002a0	85 f6		 test	 esi, esi
  002a2	7e 38		 jle	 SHORT $LN30@CGMoveItem
  002a4	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
$LL71@CGMoveItem:

; 23283: 			   {
; 23284:                   p = c + d * 8 + n;
; 23285: 
; 23286:                   if (p >= CHAOS_BOX_SIZE || TargetMap[p] || (n % 8) + c > 7) 

  002a7	83 f8 20	 cmp	 eax, 32			; 00000020H
  002aa	7d 11		 jge	 SHORT $LN24@CGMoveItem
  002ac	83 39 00	 cmp	 DWORD PTR [ecx], 0
  002af	75 0c		 jne	 SHORT $LN24@CGMoveItem
  002b1	8b df		 mov	 ebx, edi
  002b3	83 e3 07	 and	 ebx, 7
  002b6	03 da		 add	 ebx, edx
  002b8	83 fb 07	 cmp	 ebx, 7
  002bb	7e 0a		 jle	 SHORT $LN27@CGMoveItem
$LN24@CGMoveItem:

; 23287: 				  {
; 23288:                      Target = -1;

  002bd	c7 85 6c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _Target$[ebp], -1
$LN27@CGMoveItem:

; 23281: 			{
; 23282:                for (d = 0; d < h; d++) 

  002c7	83 c0 08	 add	 eax, 8
  002ca	83 c1 20	 add	 ecx, 32			; 00000020H
  002cd	4e		 dec	 esi
  002ce	75 d7		 jne	 SHORT $LL71@CGMoveItem
  002d0	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _h$[ebp]
  002d6	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _aRecv$GSCopy$[ebp]
$LN30@CGMoveItem:

; 23279: 
; 23280:             for (c = 0; c < w; c++) 

  002dc	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv817[ebp]
  002e2	42		 inc	 edx
  002e3	83 c1 04	 add	 ecx, 4
  002e6	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv817[ebp], ecx
  002ec	3b 95 60 ff ff
	ff		 cmp	 edx, DWORD PTR _w$[ebp]
  002f2	7c ac		 jl	 SHORT $LL31@CGMoveItem
  002f4	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _Target$[ebp]
$LN29@CGMoveItem:

; 23289:                   }
; 23290:                }
; 23291:             }
; 23292: 
; 23293:             if (Target != -1)

  002fa	83 fe ff	 cmp	 esi, -1
  002fd	0f 85 3b 01 00
	00		 jne	 $LN69@CGMoveItem
$LN34@CGMoveItem:

; 23266:                   }
; 23267:                }
; 23268:             }
; 23269:          }
; 23270:       }
; 23271: 
; 23272:       for (n = 0; n < CHAOS_BOX_SIZE; n++) 

  00303	83 85 68 ff ff
	ff 04		 add	 DWORD PTR tv835[ebp], 4
  0030a	47		 inc	 edi
  0030b	83 ff 20	 cmp	 edi, 32			; 00000020H
  0030e	0f 8c 2c ff ff
	ff		 jl	 $LL35@CGMoveItem

; 23294: 			{
; 23295:                break;
; 23296: 			}
; 23297:          }
; 23298:       }
; 23299:    }
; 23300:    else if (aRecv->tFlag == 0 & aRecv->sFlag == 3 && lpObj->pChaosBox[aRecv->Source].IsItem())

  00314	e9 12 01 00 00	 jmp	 $LN15@CGMoveItem
$LN47@CGMoveItem:
  00319	33 c9		 xor	 ecx, ecx
  0031b	80 7b 04 03	 cmp	 BYTE PTR [ebx+4], 3
  0031f	0f 94 c1	 sete	 cl
  00322	33 d2		 xor	 edx, edx
  00324	38 53 05	 cmp	 BYTE PTR [ebx+5], dl
  00327	0f 94 c2	 sete	 dl
  0032a	85 ca		 test	 ecx, edx
  0032c	74 6c		 je	 SHORT $LN21@CGMoveItem
  0032e	0f b6 4b 06	 movzx	 ecx, BYTE PTR [ebx+6]
  00332	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00338	03 8f 78 0e 00
	00		 add	 ecx, DWORD PTR [edi+3704]
  0033e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00343	85 c0		 test	 eax, eax
  00345	74 53		 je	 SHORT $LN21@CGMoveItem

; 23301:    {
; 23302:       ItemByteConvert(ItemInfo, lpObj->pChaosBox[aRecv->Source]);

  00347	0f b6 73 06	 movzx	 esi, BYTE PTR [ebx+6]
  0034b	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00351	03 b7 78 0e 00
	00		 add	 esi, DWORD PTR [edi+3704]
  00357	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0035d	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00360	8b fc		 mov	 edi, esp
  00362	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00367	50		 push	 eax
  00368	f3 a5		 rep movsd
  0036a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 23303: 
; 23304:       if (aRecv->Source > CHAOS_BOX_SIZE) { return; }

  0036f	8a 43 06	 mov	 al, BYTE PTR [ebx+6]
  00372	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00378	3c 20		 cmp	 al, 32			; 00000020H
  0037a	0f 87 ee 01 00
	00		 ja	 $LN17@CGMoveItem

; 23305: 
; 23306:       BYTE invPos = InventoryInsertItemTemp(lpObj, &lpObj->pChaosBox[aRecv->Source]);

  00380	0f b6 c8	 movzx	 ecx, al
  00383	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00389	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0038f	03 88 78 0e 00
	00		 add	 ecx, DWORD PTR [eax+3704]

; 23307: 
; 23308:       if (invPos >= 254) 
; 23309: 	  {
; 23310:          GCServerMsgStringSend("Thng ?nhn vt khng ?ch?trng.", aIndex, 0x01);
; 23311: 
; 23312:          return;
; 23313:       }
; 23314: 
; 23315:       Target = invPos;

  00395	e9 05 01 00 00	 jmp	 $LN78@CGMoveItem
$LN21@CGMoveItem:

; 23316:    }
; 23317:    else if (aRecv->tFlag == 0 & aRecv->sFlag == 0 && lpObj->pInventory[aRecv->Source].IsItem())

  0039a	33 c9		 xor	 ecx, ecx
  0039c	38 4b 05	 cmp	 BYTE PTR [ebx+5], cl
  0039f	0f 94 c1	 sete	 cl
  003a2	33 d2		 xor	 edx, edx
  003a4	38 53 04	 cmp	 BYTE PTR [ebx+4], dl
  003a7	0f 94 c2	 sete	 dl
  003aa	85 ca		 test	 ecx, edx
  003ac	0f 84 bc 01 00
	00		 je	 $LN17@CGMoveItem
  003b2	0f b6 4b 06	 movzx	 ecx, BYTE PTR [ebx+6]
  003b6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003bc	03 8f 24 0e 00
	00		 add	 ecx, DWORD PTR [edi+3620]
  003c2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003c7	85 c0		 test	 eax, eax
  003c9	0f 84 9f 01 00
	00		 je	 $LN17@CGMoveItem

; 23318:    {
; 23319:       ItemByteConvert(ItemInfo, lpObj->pInventory[aRecv->Source]);

  003cf	0f b6 73 06	 movzx	 esi, BYTE PTR [ebx+6]
  003d3	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  003d9	03 b7 24 0e 00
	00		 add	 esi, DWORD PTR [edi+3620]
  003df	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  003e5	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  003e8	8b fc		 mov	 edi, esp
  003ea	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  003ef	50		 push	 eax
  003f0	f3 a5		 rep movsd
  003f2	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 23320: 
; 23321:       if (aRecv->Source > 11) 

  003f7	8a 43 06	 mov	 al, BYTE PTR [ebx+6]

; 23322: 	  {
; 23323:          Target = lpObj->pInventory[aRecv->Source].GetSlot();

  003fa	0f b6 c8	 movzx	 ecx, al
  003fd	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00403	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00409	3c 0b		 cmp	 al, 11			; 0000000bH
  0040b	0f 86 82 00 00
	00		 jbe	 $LN16@CGMoveItem
  00411	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00417	03 8a 24 0e 00
	00		 add	 ecx, DWORD PTR [edx+3620]
  0041d	e8 00 00 00 00	 call	 ?GetSlot@CItem@@QAEEXZ	; CItem::GetSlot
$LN14@CGMoveItem:

; 23332: 
; 23333:             return;
; 23334:          }
; 23335: 
; 23336:          Target = invPos;

  00422	0f b6 c0	 movzx	 eax, al
  00425	89 85 6c ff ff
	ff		 mov	 DWORD PTR _Target$[ebp], eax
$LN15@CGMoveItem:

; 23337:       }
; 23338:    }
; 23339:    else
; 23340:    {
; 23341:       return; //Wrong type!
; 23342:    }
; 23343: 
; 23344:    if (Target == -1)

  0042b	83 bd 6c ff ff
	ff ff		 cmp	 DWORD PTR _Target$[ebp], -1
  00432	0f 84 36 01 00
	00		 je	 $LN17@CGMoveItem
  00438	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _Target$[ebp]
$LN69@CGMoveItem:

; 23345:    {
; 23346:       return;
; 23347:    }
; 23348: 
; 23349: 	bool bMoveItem = false;
; 23350: 
; 23351:    int result = gObjInventoryMoveItem(lpObj->m_Index, aRecv->Source, Target, DurSend, DurTargetSend, aRecv->sFlag, aRecv->tFlag, ItemInfo);

  0043e	0f b6 53 05	 movzx	 edx, BYTE PTR [ebx+5]
  00442	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00446	8b bd 5c ff ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  0044c	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  0044f	51		 push	 ecx
  00450	52		 push	 edx
  00451	50		 push	 eax
  00452	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  00456	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _DurTargetSend$[ebp]
  0045c	51		 push	 ecx
  0045d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0045f	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR _DurSend$[ebp]
  00465	52		 push	 edx
  00466	56		 push	 esi
  00467	50		 push	 eax
  00468	51		 push	 ecx
  00469	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  0046e	0f b6 c8	 movzx	 ecx, al

; 23352:   
; 23353:    if (result == aRecv->tFlag)

  00471	8a 43 05	 mov	 al, BYTE PTR [ebx+5]
  00474	0f b6 d0	 movzx	 edx, al
  00477	83 c4 20	 add	 esp, 32			; 00000020H
  0047a	3b ca		 cmp	 ecx, edx

; 23354:    {
; 23355: 		bMoveItem = true;
; 23356:    }
; 23357:    else

  0047c	0f 84 a0 00 00
	00		 je	 $LN74@CGMoveItem

; 23358:    {
; 23359: 		if(Target == 10)

  00482	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00485	75 51		 jne	 SHORT $LN9@CGMoveItem

; 23360: 		{
; 23361: 			Target = 11;

  00487	c7 85 6c ff ff
	ff 0b 00 00 00	 mov	 DWORD PTR _Target$[ebp], 11 ; 0000000bH
  00491	eb 53		 jmp	 SHORT $LN79@CGMoveItem
$LN16@CGMoveItem:

; 23324:       }
; 23325:       else 
; 23326: 	  {
; 23327:          BYTE invPos = InventoryInsertItemTemp(lpObj, &lpObj->pInventory[aRecv->Source]);

  00493	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00499	03 88 24 0e 00
	00		 add	 ecx, DWORD PTR [eax+3620]
$LN78@CGMoveItem:
  0049f	51		 push	 ecx
  004a0	50		 push	 eax
  004a1	e8 00 00 00 00	 call	 ?InventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCItem@@@Z ; InventoryInsertItemTemp
  004a6	83 c4 08	 add	 esp, 8

; 23328: 
; 23329:          if (invPos >= 254) 

  004a9	3c fe		 cmp	 al, 254			; 000000feH
  004ab	0f 82 71 ff ff
	ff		 jb	 $LN14@CGMoveItem

; 23330: 		 {
; 23331:             GCServerMsgStringSend("Thng ?nhn vt khng ?ch?trng.", aIndex, 0x01);

  004b1	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv451[ebp]
  004b7	6a 01		 push	 1
  004b9	52		 push	 edx
  004ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LOFPCIL@Th?C?$LJng?5?D?$JB?a?$LL?$DPnh?C?$KCn?5v?a?$LK?$KNt?5kh?C?$LEng?5?D@
  004bf	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23389: 	}
; 23390: }

  004c7	5f		 pop	 edi
  004c8	5e		 pop	 esi
  004c9	5b		 pop	 ebx
  004ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004cd	33 cd		 xor	 ecx, ebp
  004cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d4	8b e5		 mov	 esp, ebp
  004d6	5d		 pop	 ebp
  004d7	c3		 ret	 0
$LN9@CGMoveItem:

; 23362: 		}
; 23363: 		else if(Target == 0)

  004d8	85 f6		 test	 esi, esi
  004da	75 10		 jne	 SHORT $LN7@CGMoveItem

; 23364: 		{
; 23365: 			Target = 1;

  004dc	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _Target$[ebp], 1
$LN79@CGMoveItem:
  004e6	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _Target$[ebp]
$LN7@CGMoveItem:

; 23366: 		}
; 23367: 
; 23368: 	   int result = gObjInventoryMoveItem(lpObj->m_Index, aRecv->Source, Target, DurSend, DurTargetSend, aRecv->sFlag, aRecv->tFlag, ItemInfo);

  004ec	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  004f0	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  004f3	51		 push	 ecx
  004f4	50		 push	 eax
  004f5	52		 push	 edx
  004f6	0f b6 53 06	 movzx	 edx, BYTE PTR [ebx+6]
  004fa	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _DurTargetSend$[ebp]
  00500	50		 push	 eax
  00501	8b 07		 mov	 eax, DWORD PTR [edi]
  00503	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _DurSend$[ebp]
  00509	51		 push	 ecx
  0050a	56		 push	 esi
  0050b	52		 push	 edx
  0050c	50		 push	 eax
  0050d	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  00512	0f b6 c8	 movzx	 ecx, al

; 23369: 	  
; 23370: 	   if (result == aRecv->tFlag)

  00515	8a 43 05	 mov	 al, BYTE PTR [ebx+5]
  00518	0f b6 d0	 movzx	 edx, al
  0051b	83 c4 20	 add	 esp, 32			; 00000020H
  0051e	3b ca		 cmp	 ecx, edx
  00520	75 4c		 jne	 SHORT $LN17@CGMoveItem
$LN74@CGMoveItem:

; 23371: 	   {
; 23372: 			bMoveItem = true;
; 23373: 	   }
; 23374:    }
; 23375: 
; 23376:    if(bMoveItem)
; 23377:    {
; 23378: 		if (aRecv->tFlag == 0 && aRecv->sFlag == 3)

  00522	84 c0		 test	 al, al
  00524	75 13		 jne	 SHORT $LN4@CGMoveItem
  00526	80 7b 04 03	 cmp	 BYTE PTR [ebx+4], 3
  0052a	75 0d		 jne	 SHORT $LN4@CGMoveItem

; 23379: 		{
; 23380: 			GCUserChaosBoxSend(lpObj, 0);

  0052c	6a 00		 push	 0
  0052e	57		 push	 edi
  0052f	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  00534	83 c4 08	 add	 esp, 8
  00537	eb 20		 jmp	 SHORT $LN2@CGMoveItem
$LN4@CGMoveItem:

; 23381: 		}
; 23382: 		else if ((aRecv->tFlag == 3 || aRecv->tFlag == 0) && aRecv->sFlag == 0)

  00539	3c 03		 cmp	 al, 3
  0053b	74 04		 je	 SHORT $LN1@CGMoveItem
  0053d	84 c0		 test	 al, al
  0053f	75 18		 jne	 SHORT $LN2@CGMoveItem
$LN1@CGMoveItem:
  00541	80 7b 04 00	 cmp	 BYTE PTR [ebx+4], 0
  00545	75 12		 jne	 SHORT $LN2@CGMoveItem

; 23383: 		{
; 23384: 			GCInventoryItemDeleteSend(lpObj->m_Index, aRecv->Source, aRecv->sFlag);

  00547	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  0054b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0054d	6a 00		 push	 0
  0054f	50		 push	 eax
  00550	51		 push	 ecx
  00551	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00556	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGMoveItem:

; 23385: 		
; 23386: 		}
; 23387: 
; 23388: 		GCItemMoveResultSend(lpObj->m_Index, aRecv->tFlag, Target, ItemInfo);

  00559	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0055d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0055f	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00562	52		 push	 edx
  00563	56		 push	 esi
  00564	50		 push	 eax
  00565	51		 push	 ecx
  00566	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0056b	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@CGMoveItem:

; 23389: 	}
; 23390: }

  0056e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00571	5f		 pop	 edi
  00572	5e		 pop	 esi
  00573	33 cd		 xor	 ecx, ebp
  00575	5b		 pop	 ebx
  00576	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057b	8b e5		 mov	 esp, ebp
  0057d	5d		 pop	 ebp
  0057e	c3		 ret	 0
?CGMoveItemProc@@YAXPAUPMSG_MOVEITEM@@F@Z ENDP		; CGMoveItemProc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?pPostItemProc@@YAXPAUPMSG_POSTITEM@@F@Z	; pPostItemProc
; Function compile flags: /Ogtp
;	COMDAT ?pPostItemProc@@YAXPAUPMSG_POSTITEM@@F@Z
_TEXT	SEGMENT
_pMessage$ = -216					; size = 210
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?pPostItemProc@@YAXPAUPMSG_POSTITEM@@F@Z PROC		; pPostItemProc, COMDAT

; 213  : void pPostItemProc ( PMSG_POSTITEM* aRecv, short aIndex ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 214  :     if ( OBJMAX_RANGE ( aIndex ) == 0 ) { return; }

  00013	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  00017	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0001a	66 85 c0	 test	 ax, ax
  0001d	0f 88 90 00 00
	00		 js	 $LN1@pPostItemP
  00023	53		 push	 ebx
  00024	33 db		 xor	 ebx, ebx
  00026	b9 97 3a 00 00	 mov	 ecx, 14999		; 00003a97H
  0002b	66 3b c1	 cmp	 ax, cx
  0002e	0f 9e c3	 setle	 bl
  00031	8b c3		 mov	 eax, ebx
  00033	5b		 pop	 ebx
  00034	85 c0		 test	 eax, eax
  00036	74 7b		 je	 SHORT $LN1@pPostItemP

; 215  : 
; 216  :     LPOBJ lpObj = &gObj[aIndex];
; 217  :     int slen = strlen ( aRecv->chatmsg );

  00038	56		 push	 esi
  00039	8d 72 0d	 lea	 esi, DWORD PTR [edx+13]
  0003c	8b c6		 mov	 eax, esi
  0003e	57		 push	 edi
  0003f	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL10@pPostItemP:
  00042	8a 08		 mov	 cl, BYTE PTR [eax]
  00044	40		 inc	 eax
  00045	84 c9		 test	 cl, cl
  00047	75 f9		 jne	 SHORT $LL10@pPostItemP
  00049	2b c7		 sub	 eax, edi

; 218  : 
; 219  :     if ( slen < 1 || slen > ( MAX_CHAT_LEN - 1 ) ) { return; }

  0004b	48		 dec	 eax
  0004c	83 f8 57	 cmp	 eax, 87			; 00000057H
  0004f	77 60		 ja	 SHORT $LN11@pPostItemP

; 220  : 
; 221  : 	PMSG_POSTITEM pMessage;
; 222  : 	memcpy(pMessage.chatid, aRecv->chatid, 10);

  00051	8b 42 03	 mov	 eax, DWORD PTR [edx+3]
  00054	8b 4a 07	 mov	 ecx, DWORD PTR [edx+7]
  00057	89 8d 2f ff ff
	ff		 mov	 DWORD PTR _pMessage$[ebp+7], ecx
  0005d	89 85 2b ff ff
	ff		 mov	 DWORD PTR _pMessage$[ebp+3], eax
  00063	66 8b 42 0b	 mov	 ax, WORD PTR [edx+11]
  00067	66 89 85 33 ff
	ff ff		 mov	 WORD PTR _pMessage$[ebp+11], ax

; 223  : 	memcpy(pMessage.chatmsg, aRecv->chatmsg, 90);

  0006e	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00073	8d bd 35 ff ff
	ff		 lea	 edi, DWORD PTR _pMessage$[ebp+13]
  00079	f3 a5		 rep movsd
  0007b	66 a5		 movsw

; 224  : 	memcpy(pMessage.item_data, aRecv->item_data, 107);

  0007d	8d 72 67	 lea	 esi, DWORD PTR [edx+103]
  00080	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00085	8d 7d 8f	 lea	 edi, DWORD PTR _pMessage$[ebp+103]
  00088	f3 a5		 rep movsd
  0008a	66 a5		 movsw

; 225  : 	pMessage.h.set((LPBYTE)&pMessage, 0x78, sizeof(PMSG_POSTITEM));
; 226  : 	DataSendAll((LPBYTE)&pMessage, pMessage.h.size);

  0008c	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _pMessage$[ebp]
  00092	a4		 movsb
  00093	68 d2 00 00 00	 push	 210			; 000000d2H
  00098	51		 push	 ecx
  00099	66 c7 85 28 ff
	ff ff c1 d2	 mov	 WORD PTR _pMessage$[ebp], 53953 ; 0000d2c1H
  000a2	c6 85 2a ff ff
	ff 78		 mov	 BYTE PTR _pMessage$[ebp+2], 120 ; 00000078H
  000a9	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  000ae	83 c4 08	 add	 esp, 8
$LN11@pPostItemP:
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
$LN1@pPostItemP:

; 227  : }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 cd		 xor	 ecx, ebp
  000b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?pPostItemProc@@YAXPAUPMSG_POSTITEM@@F@Z ENDP		; pPostItemProc
_TEXT	ENDS
PUBLIC	??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@ ; `string'
PUBLIC	??_C@_0EB@KCPMCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5Editi@ ; `string'
PUBLIC	??_C@_0DH@FLAIJCIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ ; `string'
PUBLIC	??_C@_05MAJJAKPI@FALSE?$AA@			; `string'
PUBLIC	??_C@_04HCDDPBNL@TRUE?$AA@			; `string'
PUBLIC	??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ ; `string'
PUBLIC	??_C@_0CF@OGLOEHF@AttackSpeed?3?5?$CFd?0?$CFd?5MagicSpeed?3?5?$CF@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z	; CGLiveClient
EXTRN	?WraitLog@AntiCheatPlus@@QAEXPAD@Z:PROC		; AntiCheatPlus::WraitLog
EXTRN	?g_AntiCheatPlus@@3VAntiCheatPlus@@A:BYTE	; g_AntiCheatPlus
EXTRN	?g_bCheckSpeedHack@@3HA:DWORD			; g_bCheckSpeedHack
EXTRN	_sprintf:PROC
EXTRN	?g_bAbilityDebug@@3HA:DWORD			; g_bAbilityDebug
;	COMDAT ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
CONST	SEGMENT
??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@ DB '..:: Anti-Che'
	DB	'at ::..', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KCPMCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5Editi@
CONST	SEGMENT
??_C@_0EB@KCPMCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5Editi@ DB '['
	DB	'%s][%s] ip[%s] hdd[%d] -> Editing AttackSpeed [%d][%d] [%d][%'
	DB	'd]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FLAIJCIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
CONST	SEGMENT
??_C@_0DH@FLAIJCIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ DB '['
	DB	'%s][%s][%s] ClientHack Detected CheckSpeedHack : [%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAJJAKPI@FALSE?$AA@
CONST	SEGMENT
??_C@_05MAJJAKPI@FALSE?$AA@ DB 'FALSE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCDDPBNL@TRUE?$AA@
CONST	SEGMENT
??_C@_04HCDDPBNL@TRUE?$AA@ DB 'TRUE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
CONST	SEGMENT
??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ DB '['
	DB	'%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d'
	DB	'] [%d][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OGLOEHF@AttackSpeed?3?5?$CFd?0?$CFd?5MagicSpeed?3?5?$CF@
CONST	SEGMENT
??_C@_0CF@OGLOEHF@AttackSpeed?3?5?$CFd?0?$CFd?5MagicSpeed?3?5?$CF@ DB 'At'
	DB	'tackSpeed: %d,%d MagicSpeed: %d,%d', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z
_TEXT	SEGMENT
tv448 = -520						; size = 4
_szLogs$244833 = -516					; size = 512
_szTemp$244822 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpClientTime$ = 8					; size = 4
_aIndex$ = 12						; size = 2
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z PROC		; CGLiveClient, COMDAT

; 1702 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 1703 : 	if ( gObj[aIndex].Connected > PLAYER_CONNECTED )

  00019	0f bf f0	 movsx	 esi, ax
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	89 b5 f8 fd ff
	ff		 mov	 DWORD PTR tv448[ebp], esi
  00027	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002d	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  00032	57		 push	 edi
  00033	8b 7d 08	 mov	 edi, DWORD PTR _lpClientTime$[ebp]
  00036	7e 15		 jle	 SHORT $LN13@CGLiveClie

; 1704 : 	{
; 1705 : 		gObj[aIndex].ConnectCheckTime = GetTickCount();

  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00044	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN13@CGLiveClie:

; 1706 : 	}
; 1707 : 
; 1708 : #if(TESTSERVER==1)
; 1709 : 	return;
; 1710 : #endif
; 1711 : 
; 1712 : #ifdef _DC_FIX_
; 1713 : 	//return;
; 1714 : #endif
; 1715 : 
; 1716 : 	if ( gObj[aIndex].CheckSpeedHack != false )

  0004d	80 7c 06 44 00	 cmp	 BYTE PTR [esi+eax+68], 0
  00052	74 76		 je	 SHORT $LN18@CGLiveClie

; 1717 : 	{
; 1718 : 		int systemtick = GetTickCount() - gObj[aIndex].CheckTick2;

  00054	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1719 : 		int usertick = lpClientTime->Time - gObj[aIndex].CheckTick;
; 1720 : 		int checktime = systemtick - usertick;

  0005d	8b 4b 40	 mov	 ecx, DWORD PTR [ebx+64]
  00060	2b 43 48	 sub	 eax, DWORD PTR [ebx+72]
  00063	2b 4f 04	 sub	 ecx, DWORD PTR [edi+4]
  00066	03 c8		 add	 ecx, eax

; 1721 : 
; 1722 : #ifdef _DC_FIX_
; 1723 : 		if ( checktime < -30000 )

  00068	81 f9 d0 8a ff
	ff		 cmp	 ecx, -30000		; ffff8ad0H
  0006e	7d 2e		 jge	 SHORT $LN11@CGLiveClie

; 1724 : #else
; 1725 : 		if ( checktime < -7000 )
; 1726 : #endif
; 1727 : 		{
; 1728 : 			LogAddTD(lMsg.Get(MSGGET(1, 214)), gObj[aIndex].AccountID, gObj[aIndex].Name, checktime);

  00070	51		 push	 ecx
  00071	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  00074	52		 push	 edx
  00075	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00078	53		 push	 ebx
  00079	68 d6 01 00 00	 push	 470			; 000001d6H
  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00083	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00088	50		 push	 eax
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1729 : 			CloseClient(aIndex);

  0008f	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR tv448[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@CGLiveClie:

; 1730 : 		}
; 1731 : 
; 1732 : 		gObj[aIndex].CheckTickCount++;

  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a3	fe 44 06 4c	 inc	 BYTE PTR [esi+eax+76]

; 1733 : 
; 1734 : 		if ( gObj[aIndex].CheckTickCount > 45 )

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ac	80 7c 06 4c 2d	 cmp	 BYTE PTR [esi+eax+76], 45 ; 0000002dH
  000b1	76 17		 jbe	 SHORT $LN18@CGLiveClie

; 1735 : 		{
; 1736 : 			gObj[aIndex].CheckTick = lpClientTime->Time;

  000b3	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000b6	89 4c 06 40	 mov	 DWORD PTR [esi+eax+64], ecx

; 1737 : 			gObj[aIndex].CheckTickCount = 0;

  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c0	c6 44 16 4c 00	 mov	 BYTE PTR [esi+edx+76], 0
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN18@CGLiveClie:

; 1738 : 		}
; 1739 : 	}
; 1740 : 
; 1741 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  000ca	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  000cf	0f 85 ac 01 00
	00		 jne	 $LN1@CGLiveClie

; 1742 : 	{
; 1743 : 		if(g_bAbilityDebug == 1)

  000d5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bAbilityDebug@@3HA, 1 ; g_bAbilityDebug
  000dc	75 4b		 jne	 SHORT $LN8@CGLiveClie

; 1744 : 		{
; 1745 : 			char szTemp[256];
; 1746 : 			sprintf(szTemp, "AttackSpeed: %d,%d MagicSpeed: %d,%d", gObj[aIndex].m_AttackSpeed, lpClientTime->AttackSpeed, gObj[aIndex].m_MagicSpeed, lpClientTime->MagicSpeed);

  000de	0f b7 4f 0a	 movzx	 ecx, WORD PTR [edi+10]
  000e2	8b 94 06 90 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1168]
  000e9	51		 push	 ecx
  000ea	0f b7 4f 08	 movzx	 ecx, WORD PTR [edi+8]
  000ee	52		 push	 edx
  000ef	8b 94 06 8c 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1164]
  000f6	51		 push	 ecx
  000f7	52		 push	 edx
  000f8	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$244822[ebp]
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OGLOEHF@AttackSpeed?3?5?$CFd?0?$CFd?5MagicSpeed?3?5?$CF@
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _sprintf

; 1747 : 			GCServerMsgStringSend(szTemp, gObj[aIndex].m_Index, 1);

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010f	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  00112	6a 01		 push	 1
  00114	52		 push	 edx
  00115	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$244822[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00126	83 c4 24	 add	 esp, 36			; 00000024H
$LN8@CGLiveClie:

; 1748 : 		}
; 1749 : 
; 1750 : 		int SpeedPlus = 50;
; 1751 : 
; 1752 : 		if ( ( gObj[aIndex].m_AttackSpeed + SpeedPlus ) < lpClientTime->AttackSpeed || ( gObj[aIndex].m_MagicSpeed + SpeedPlus ) < lpClientTime->MagicSpeed )

  00129	8b 8c 06 8c 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1164]
  00130	0f b7 57 08	 movzx	 edx, WORD PTR [edi+8]
  00134	8d 59 32	 lea	 ebx, DWORD PTR [ecx+50]
  00137	3b da		 cmp	 ebx, edx
  00139	7c 1f		 jl	 SHORT $LN6@CGLiveClie
  0013b	8b 94 06 90 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1168]
  00142	0f b7 5f 0a	 movzx	 ebx, WORD PTR [edi+10]
  00146	83 c2 32	 add	 edx, 50			; 00000032H
  00149	3b d3		 cmp	 edx, ebx
  0014b	7c 0d		 jl	 SHORT $LN6@CGLiveClie

; 1775 : #else
; 1776 : 				CloseClient(aIndex);
; 1777 : #endif
; 1778 : 			}
; 1779 : 		}
; 1780 : 		else
; 1781 : 		{
; 1782 : 			gObj[aIndex].m_AttackSpeedHackDetectedCount = 0;

  0014d	c6 84 06 88 03
	00 00 00	 mov	 BYTE PTR [esi+eax+904], 0
  00155	e9 0b 01 00 00	 jmp	 $LN4@CGLiveClie
$LN6@CGLiveClie:

; 1753 : 		{
; 1754 : 			LogAddC(2, "[%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d] [%d][%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr, gObj[aIndex].m_AttackSpeed, lpClientTime->AttackSpeed, gObj[aIndex].m_MagicSpeed, lpClientTime->MagicSpeed);

  0015a	0f b7 57 0a	 movzx	 edx, WORD PTR [edi+10]
  0015e	52		 push	 edx
  0015f	8b 94 06 90 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1168]
  00166	52		 push	 edx
  00167	0f b7 57 08	 movzx	 edx, WORD PTR [edi+8]
  0016b	52		 push	 edx
  0016c	51		 push	 ecx
  0016d	8d 4c 06 18	 lea	 ecx, DWORD PTR [esi+eax+24]
  00171	51		 push	 ecx
  00172	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00176	52		 push	 edx
  00177	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0017b	50		 push	 eax
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
  00181	6a 02		 push	 2
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00189	83 c4 24	 add	 esp, 36			; 00000024H

; 1755 : 			LogAddC(2, "[%s][%s][%s] ClientHack Detected CheckSpeedHack : [%s]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr,(g_bCheckSpeedHack != FALSE) ? "TRUE" : "FALSE");

  0018c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bCheckSpeedHack@@3HA, 0 ; g_bCheckSpeedHack
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04HCDDPBNL@TRUE?$AA@
  00198	75 05		 jne	 SHORT $LN17@CGLiveClie
  0019a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MAJJAKPI@FALSE?$AA@
$LN17@CGLiveClie:
  0019f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a4	51		 push	 ecx
  001a5	8d 4c 06 18	 lea	 ecx, DWORD PTR [esi+eax+24]
  001a9	51		 push	 ecx
  001aa	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  001ae	52		 push	 edx
  001af	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  001b3	50		 push	 eax
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@FLAIJCIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
  001b9	6a 02		 push	 2
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001c1	83 c4 18	 add	 esp, 24			; 00000018H

; 1756 : 	
; 1757 : 			if(g_bCheckSpeedHack == FALSE)

  001c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bCheckSpeedHack@@3HA, 0 ; g_bCheckSpeedHack
  001cb	0f 84 b0 00 00
	00		 je	 $LN1@CGLiveClie

; 1758 : 			{
; 1759 : 				return;
; 1760 : 			}
; 1761 : 
; 1762 : 			gObj[aIndex].m_AttackSpeedHackDetectedCount++;

  001d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d6	fe 84 06 88 03
	00 00		 inc	 BYTE PTR [esi+eax+904]

; 1763 : 
; 1764 : 			if ( gObj[aIndex].m_AttackSpeedHackDetectedCount > 0 )

  001dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e2	80 bc 06 88 03
	00 00 00	 cmp	 BYTE PTR [esi+eax+904], 0
  001ea	76 79		 jbe	 SHORT $LN4@CGLiveClie

; 1765 : 			{
; 1766 : 
; 1767 : 				char szLogs[512];
; 1768 : 				sprintf(szLogs, "[%s][%s] ip[%s] hdd[%d] -> Editing AttackSpeed [%d][%d] [%d][%d]",
; 1769 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr, gObj[aIndex].hdd_id, 
; 1770 : 					gObj[aIndex].m_AttackSpeed, lpClientTime->AttackSpeed, gObj[aIndex].m_MagicSpeed, lpClientTime->MagicSpeed);

  001ec	0f b7 4f 0a	 movzx	 ecx, WORD PTR [edi+10]
  001f0	8b 94 06 90 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1168]
  001f7	51		 push	 ecx
  001f8	0f b7 4f 08	 movzx	 ecx, WORD PTR [edi+8]
  001fc	52		 push	 edx
  001fd	8b 94 06 8c 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1164]
  00204	51		 push	 ecx
  00205	8b 8c 06 8c 28
	00 00		 mov	 ecx, DWORD PTR [esi+eax+10380]
  0020c	52		 push	 edx
  0020d	51		 push	 ecx
  0020e	8d 54 06 18	 lea	 edx, DWORD PTR [esi+eax+24]
  00212	52		 push	 edx
  00213	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00217	51		 push	 ecx
  00218	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0021c	52		 push	 edx
  0021d	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szLogs$244833[ebp]
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KCPMCGNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ip?$FL?$CFs?$FN?5hdd?$FL?$CFd?$FN?5?9?$DO?5Editi@
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _sprintf
  0022e	83 c4 28	 add	 esp, 40			; 00000028H

; 1771 : 				g_AntiCheatPlus.WraitLog(szLogs);

  00231	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szLogs$244833[ebp]
  00237	51		 push	 ecx
  00238	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AntiCheatPlus@@3VAntiCheatPlus@@A ; g_AntiCheatPlus
  0023d	e8 00 00 00 00	 call	 ?WraitLog@AntiCheatPlus@@QAEXPAD@Z ; AntiCheatPlus::WraitLog

; 1772 : #ifdef _RECONNECT_
; 1773 : 				GCServerMsgStringSend("..:: Anti-Cheat ::..", aIndex, 0);

  00242	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR tv448[ebp]
  00248	6a 00		 push	 0
  0024a	56		 push	 esi
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PIPPDFMK@?4?4?3?3?5Anti?9Cheat?5?3?3?4?4?$AA@
  00250	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1774 : 				g_ConnectZt.SendClose(aIndex,NORM_DC);

  00258	6a 00		 push	 0
  0025a	56		 push	 esi
  0025b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00260	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
$LN4@CGLiveClie:

; 1783 : 		}
; 1784 : 
; 1785 : 		if ( szAuthKey[10] != AUTHKEY10 )

  00265	80 3d 0a 00 00
	00 49		 cmp	 BYTE PTR ?szAuthKey@@3PADA+10, 73 ; 00000049H
  0026c	74 05		 je	 SHORT $LN2@CGLiveClie

; 1786 : 		{
; 1787 : 			DestroyGIocp();

  0026e	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN2@CGLiveClie:

; 1788 : 		}
; 1789 : 
; 1790 : 		if ( szAuthKey[11] != AUTHKEY11 )

  00273	80 3d 0b 00 00
	00 f1		 cmp	 BYTE PTR ?szAuthKey@@3PADA+11, -15 ; fffffff1H
  0027a	74 05		 je	 SHORT $LN1@CGLiveClie

; 1791 : 		{
; 1792 : 			DestroyGIocp();

  0027c	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN1@CGLiveClie:

; 1793 : 		}
; 1794 : 	}
; 1795 : }

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	5f		 pop	 edi
  00285	5e		 pop	 esi
  00286	33 cd		 xor	 ecx, ebp
  00288	5b		 pop	 ebx
  00289	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ENDP		; CGLiveClient
_TEXT	ENDS
PUBLIC	?GCCheckMainExeKeySend@@YAXH@Z			; GCCheckMainExeKeySend
; Function compile flags: /Ogtp
;	COMDAT ?GCCheckMainExeKeySend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCCheckMainExeKeySend@@YAXH@Z PROC			; GCCheckMainExeKeySend, COMDAT

; 1798 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1799 : 	PMSG_CHECK_MAINEXE pMsg;
; 1800 : 
; 1801 : 	gObj[aIndex].CheckSumTableNum = rand() % MAX_CHECKSUM_KEY;

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	8b f7		 mov	 esi, edi
  0000d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00013	e8 00 00 00 00	 call	 _rand
  00018	25 ff 03 00 80	 and	 eax, -2147482625	; 800003ffH
  0001d	79 07		 jns	 SHORT $LN3@GCCheckMai
  0001f	48		 dec	 eax
  00020	0d 00 fc ff ff	 or	 eax, -1024		; fffffc00H
  00025	40		 inc	 eax
$LN3@GCCheckMai:
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	66 89 44 0e 60	 mov	 WORD PTR [esi+ecx+96], ax

; 1802 : 	gObj[aIndex].CheckSumTime = GetTickCount();

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1803 : 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  0003d	6a 06		 push	 6
  0003f	89 44 16 64	 mov	 DWORD PTR [esi+edx+100], eax
  00043	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	6a 03		 push	 3
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1804 : 	pMsg.m_wKey = EncryptCheckSumKey(gObj[aIndex].CheckSumTableNum);

  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00054	0f b7 54 0e 60	 movzx	 edx, WORD PTR [esi+ecx+96]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?EncryptCheckSumKey@@YAGG@Z ; EncryptCheckSumKey
  0005f	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 1805 : 
; 1806 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00063	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00067	50		 push	 eax
  00068	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0006b	51		 push	 ecx
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 1c	 add	 esp, 28			; 0000001cH
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 1807 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?GCCheckMainExeKeySend@@YAXH@Z ENDP			; GCCheckMainExeKeySend
_TEXT	ENDS
PUBLIC	??_C@_0BC@OHBNELPC@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0N@FJILNKII@?$FLBanChatHdd?$FN?$AA@	; `string'
PUBLIC	??_C@_0CD@GDGNGFHG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?1?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$FN?5PCBA@ ; `string'
PUBLIC	??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$AA@ ; `string'
PUBLIC	??_C@_05GEPBPPAJ@?$FL?$CFd?$FN?5?$AA@		; `string'
PUBLIC	??_C@_0CI@OGALPJEH@Please?5wait?5?$CFd?5seconds?5before?5ne@ ; `string'
PUBLIC	??_C@_0P@BFCGKFKP@Need?5Money?3?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0O@BMNAIKJI@Need?5Level?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BB@HLMAIFBF@?$FLBanPost?$FN?5?$CFd?5Sec?$AA@ ; `string'
PUBLIC	??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@	; `string'
PUBLIC	??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@ ; `string'
PUBLIC	_lpChat$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z		; PChatProc
EXTRN	?GDGuildServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z:PROC ; GDGuildServerGroupChattingSend
EXTRN	?g_iServerGroupGuildChatting@@3HA:DWORD		; g_iServerGroupGuildChatting
EXTRN	?GDUnionServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z:PROC ; GDUnionServerGroupChattingSend
EXTRN	?g_iServerGroupUnionChatting@@3HA:DWORD		; g_iServerGroupUnionChatting
EXTRN	?GetGuildUnionMemberList@TUnion@@QAEHHAAHPAH@Z:PROC ; TUnion::GetGuildUnionMemberList
EXTRN	?GDGuildNoticeSave@@YAXPAD0@Z:PROC		; GDGuildNoticeSave
EXTRN	?ManagementProc@CGMMng@@QAEHPAUOBJECTSTRUCT@@PADH@Z:PROC ; CGMMng::ManagementProc
EXTRN	?MoveFree2Kalima@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::MoveFree2Kalima
EXTRN	?gObjCheckIsInPCBang@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjCheckIsInPCBang
EXTRN	?Chat@CQuestionAnswer@@QAEXHPAD@Z:PROC		; CQuestionAnswer::Chat
EXTRN	?g_QuestionAnswer@@3VCQuestionAnswer@@A:BYTE	; g_QuestionAnswer
EXTRN	?MessageSendAllEx@@YAXHPAD0ZZ:PROC		; MessageSendAllEx
EXTRN	_strncat:PROC
EXTRN	?Chat@CBanSystem@@QAE_NH@Z:PROC			; CBanSystem::Chat
EXTRN	?g_BanSystem@@3VCBanSystem@@A:BYTE		; g_BanSystem
EXTRN	?MessaageAllGlobal@@YAXPADZZ:PROC		; MessaageAllGlobal
EXTRN	?CheckCommand@GMManager@@QAE_NHH@Z:PROC		; GMManager::CheckCommand
EXTRN	?g_GMManager@@3VGMManager@@A:BYTE		; g_GMManager
;	COMDAT ??_C@_0BC@OHBNELPC@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0BC@OHBNELPC@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@ DB '['
	DB	'%s] [%s] [%s] %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJILNKII@?$FLBanChatHdd?$FN?$AA@
CONST	SEGMENT
??_C@_0N@FJILNKII@?$FLBanChatHdd?$FN?$AA@ DB '[BanChatHdd]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GDGNGFHG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?1?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$FN?5PCBA@
CONST	SEGMENT
??_C@_0CD@GDGNGFHG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?1?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$FN?5PCBA@ DB '['
	DB	'%s][%s] Use [/', 0c0H, 0ccH, 0b5H, 0bfH, ' ', 0c4H, 0aeH, 0b8H
	DB	0aeH, 0b8H, 0b6H, '] PCBANG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$AA@
CONST	SEGMENT
??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$AA@ DB 0c0H, 0ccH
	DB	0b5H, 0bfH, ' ', 0c4H, 0aeH, 0b8H, 0aeH, 0b8H, 0b6H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GEPBPPAJ@?$FL?$CFd?$FN?5?$AA@
CONST	SEGMENT
??_C@_05GEPBPPAJ@?$FL?$CFd?$FN?5?$AA@ DB '[%d] ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OGALPJEH@Please?5wait?5?$CFd?5seconds?5before?5ne@
CONST	SEGMENT
??_C@_0CI@OGALPJEH@Please?5wait?5?$CFd?5seconds?5before?5ne@ DB 'Please w'
	DB	'ait %d seconds before next post', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFCGKFKP@Need?5Money?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@BFCGKFKP@Need?5Money?3?5?$CFd?$AA@ DB 'Need Money: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BMNAIKJI@Need?5Level?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@BMNAIKJI@Need?5Level?5?$CFd?$AA@ DB 'Need Level %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HLMAIFBF@?$FLBanPost?$FN?5?$CFd?5Sec?$AA@
CONST	SEGMENT
??_C@_0BB@HLMAIFBF@?$FLBanPost?$FN?5?$CFd?5Sec?$AA@ DB '[BanPost] %d Sec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@ DB '[%s] [%s] '
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@
CONST	SEGMENT
??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@ DB '[%s]:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@
CONST	SEGMENT
??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@ DB '['
	DB	'Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z
_TEXT	SEGMENT
tv1128 = -540						; size = 4
_lpGuildInfo$245081 = -540				; size = 4
_slen$ = -540						; size = 4
tv1027 = -536						; size = 4
_i$245077 = -536					; size = 4
_AdminConfigConflictFlag$ = -530			; size = 1
_PostConfigConflictFlag$ = -529				; size = 1
tv1550 = -528						; size = 4
_n$ = -528						; size = 4
_PostConfigConflictCount$ = -528			; size = 4
tv1024 = -524						; size = 4
_iGuildCount$245072 = -524				; size = 4
_lpChat$GSCopy$ = -520					; size = 4
_lpObj$ = -516						; size = 4
_lpRequest$245023 = -512				; size = 106
_iGuildList$245073 = -404				; size = 400
__$ArrayPad$ = -4					; size = 4
_lpChat$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z PROC		; PChatProc, COMDAT

; 2013 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  0001a	56		 push	 esi

; 2014 : 	int n;
; 2015 : 	LPOBJ lpObj = &gObj[aIndex];

  0001b	0f bf f0	 movsx	 esi, ax
  0001e	89 b5 f4 fd ff
	ff		 mov	 DWORD PTR tv1024[ebp], esi
  00024	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002a	57		 push	 edi
  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2016 : 	int number;
; 2017 : 	int slen = strlen(lpChat->chatmsg);

  00031	8d 41 0d	 lea	 eax, DWORD PTR [ecx+13]
  00034	03 fe		 add	 edi, esi
  00036	89 8d f8 fd ff
	ff		 mov	 DWORD PTR _lpChat$GSCopy$[ebp], ecx
  0003c	89 bd fc fd ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi
  00042	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv1027[ebp], eax
  00048	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0004b	eb 03 8d 49 00	 npad	 5
$LL137@PChatProc:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL137@PChatProc
  00057	2b c2		 sub	 eax, edx
  00059	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _slen$[ebp], eax

; 2018 : 
; 2019 : 	if ( slen < 1 )

  0005f	83 f8 01	 cmp	 eax, 1
  00062	0f 8c 44 0e 00
	00		 jl	 $LN51@PChatProc

; 2020 : 		return;
; 2021 : 
; 2022 : 	if ( slen > MAX_CHAT_LEN-1 )

  00068	83 f8 58	 cmp	 eax, 88			; 00000058H
  0006b	7e 27		 jle	 SHORT $LN107@PChatProc

; 2023 : 	{
; 2024 : 		LogAddTD("[Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d", lpObj->AccountID, lpObj->Name, slen);

  0006d	50		 push	 eax
  0006e	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  00071	51		 push	 ecx
  00072	83 c7 6c	 add	 edi, 108		; 0000006cH
  00075	57		 push	 edi
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN107@PChatProc:

; 2025 : 		return;
; 2026 : 	}
; 2027 : #if(CUSTOM_CHATFILTER)
; 2028 : 	g_ChatFilter.CheckSyntax(aIndex, lpChat->chatmsg);

  00094	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv1027[ebp]
  0009a	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR tv1024[ebp]
  000a0	53		 push	 ebx
  000a1	52		 push	 edx
  000a2	50		 push	 eax
  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChatFilter@@3VCChatFilter@@A ; g_ChatFilter
  000a8	e8 00 00 00 00	 call	 ?CheckSyntax@CChatFilter@@QAEXHPAD@Z ; CChatFilter::CheckSyntax

; 2029 : #endif
; 2030 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2031 : 	CHAT_LOG_DATA pChatMsg;
; 2032 : #endif
; 2033 : 
; 2034 : 	char szId[MAX_ACCOUNT_LEN+1];
; 2035 : 	szId[MAX_ACCOUNT_LEN] = 0;
; 2036 : 	memcpy(szId, gObj[aIndex].Name, MAX_ACCOUNT_LEN);

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	8b 4c 30 77	 mov	 ecx, DWORD PTR [eax+esi+119]
  000b6	8b 54 30 7b	 mov	 edx, DWORD PTR [eax+esi+123]
  000ba	66 8b 44 30 7f	 mov	 ax, WORD PTR [eax+esi+127]

; 2037 : 	memcpy(lpChat->chatid, szId, MAX_ACCOUNT_LEN);

  000bf	8b bd f8 fd ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  000c5	83 c7 03	 add	 edi, 3
  000c8	89 0f		 mov	 DWORD PTR [edi], ecx
  000ca	89 57 04	 mov	 DWORD PTR [edi+4], edx
  000cd	66 89 47 08	 mov	 WORD PTR [edi+8], ax

; 2038 : 
; 2039 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2040 : 	int szTargetNameCount = 0;
; 2041 : 	if ( gWriteChatLog )
; 2042 : 	{
; 2043 : 		pChatMsg.h.c = 0xC1;
; 2044 : 		pChatMsg.h.headcode = 0x02;
; 2045 : 		memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 2046 : 		memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_ACCOUNT_LEN);
; 2047 : 		pChatMsg.AccountID[MAX_ACCOUNT_LEN] = 0;
; 2048 : 		pChatMsg.Name[MAX_ACCOUNT_LEN] = 0;
; 2049 : 		pChatMsg.wServer = gGameServerCode;
; 2050 : 		pChatMsg.btType = 0xFF;
; 2051 : 	}
; 2052 : #endif
; 2053 : #ifdef _POST_CONFIG_
; 2054 : 	bool PostConfigConflictFlag = true;
; 2055 : 	bool AdminConfigConflictFlag = true;
; 2056 : 	int PostConfigConflictCount = 1;
; 2057 : 	int AdminConfigConflictCount = 0;
; 2058 : 	for(int i = 0; ZtConfig.Command.CommandPost[i] != '\0';i++)

  000d1	a0 30 03 00 00	 mov	 al, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+816
  000d6	33 db		 xor	 ebx, ebx
  000d8	c6 85 ef fd ff
	ff 01		 mov	 BYTE PTR _PostConfigConflictFlag$[ebp], 1
  000df	c6 85 ee fd ff
	ff 01		 mov	 BYTE PTR _AdminConfigConflictFlag$[ebp], 1
  000e6	c7 85 f0 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR _PostConfigConflictCount$[ebp], 1
  000f0	84 c0		 test	 al, al
  000f2	74 25		 je	 SHORT $LN104@PChatProc

; 2025 : 		return;
; 2026 : 	}
; 2027 : #if(CUSTOM_CHATFILTER)
; 2028 : 	g_ChatFilter.CheckSyntax(aIndex, lpChat->chatmsg);

  000f4	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv1027[ebp]
  000fa	b9 30 03 00 00	 mov	 ecx, OFFSET ?ZtConfig@@3VcZtConfigs@@A+816
  000ff	90		 npad	 1
$LL106@PChatProc:

; 2059 : 	{
; 2060 : 		if( ZtConfig.Command.CommandPost[i] != lpChat->chatmsg[i])

  00100	3a 02		 cmp	 al, BYTE PTR [edx]
  00102	74 06		 je	 SHORT $LN103@PChatProc

; 2061 : 		PostConfigConflictFlag = false;

  00104	88 9d ef fd ff
	ff		 mov	 BYTE PTR _PostConfigConflictFlag$[ebp], bl
$LN103@PChatProc:

; 2038 : 
; 2039 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2040 : 	int szTargetNameCount = 0;
; 2041 : 	if ( gWriteChatLog )
; 2042 : 	{
; 2043 : 		pChatMsg.h.c = 0xC1;
; 2044 : 		pChatMsg.h.headcode = 0x02;
; 2045 : 		memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 2046 : 		memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_ACCOUNT_LEN);
; 2047 : 		pChatMsg.AccountID[MAX_ACCOUNT_LEN] = 0;
; 2048 : 		pChatMsg.Name[MAX_ACCOUNT_LEN] = 0;
; 2049 : 		pChatMsg.wServer = gGameServerCode;
; 2050 : 		pChatMsg.btType = 0xFF;
; 2051 : 	}
; 2052 : #endif
; 2053 : #ifdef _POST_CONFIG_
; 2054 : 	bool PostConfigConflictFlag = true;
; 2055 : 	bool AdminConfigConflictFlag = true;
; 2056 : 	int PostConfigConflictCount = 1;
; 2057 : 	int AdminConfigConflictCount = 0;
; 2058 : 	for(int i = 0; ZtConfig.Command.CommandPost[i] != '\0';i++)

  0010a	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 2062 : 		PostConfigConflictCount++;

  0010d	ff 85 f0 fd ff
	ff		 inc	 DWORD PTR _PostConfigConflictCount$[ebp]
  00113	41		 inc	 ecx
  00114	42		 inc	 edx
  00115	84 c0		 test	 al, al
  00117	75 e7		 jne	 SHORT $LL106@PChatProc
$LN104@PChatProc:

; 2063 : 	};
; 2064 : 	for(int i = 0; ZtConfig.Command.AdminPostName[i] != '\0';i++)

  00119	8a 0d 68 06 00
	00		 mov	 cl, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A+1640
  0011f	33 c0		 xor	 eax, eax
  00121	84 c9		 test	 cl, cl
  00123	74 30		 je	 SHORT $LN156@PChatProc
  00125	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv1027[ebp]
  0012b	eb 03 8d 49 00	 npad	 5
$LL102@PChatProc:

; 2065 : 	{
; 2066 : 		if( ZtConfig.Command.AdminPostName[i] != lpChat->chatmsg[i])

  00130	3a 0c 10	 cmp	 cl, BYTE PTR [eax+edx]
  00133	74 07		 je	 SHORT $LN99@PChatProc

; 2067 : 		AdminConfigConflictFlag = false;

  00135	c6 85 ee fd ff
	ff 00		 mov	 BYTE PTR _AdminConfigConflictFlag$[ebp], 0
$LN99@PChatProc:

; 2063 : 	};
; 2064 : 	for(int i = 0; ZtConfig.Command.AdminPostName[i] != '\0';i++)

  0013c	8a 88 69 06 00
	00		 mov	 cl, BYTE PTR ?ZtConfig@@3VcZtConfigs@@A[eax+1641]

; 2068 : 		AdminConfigConflictCount = i;

  00142	8b d8		 mov	 ebx, eax
  00144	40		 inc	 eax
  00145	84 c9		 test	 cl, cl
  00147	75 e7		 jne	 SHORT $LL102@PChatProc

; 2069 : 	};
; 2070 : 	//LogAddTD("%d", ZtConfig.Command.PostColor);
; 2071 : 	if(AdminConfigConflictFlag)

  00149	38 8d ee fd ff
	ff		 cmp	 BYTE PTR _AdminConfigConflictFlag$[ebp], cl
  0014f	0f 84 7b 01 00
	00		 je	 $LN158@PChatProc
$LN156@PChatProc:

; 2072 : 	{
; 2073 : 			if ( slen > 2 )

  00155	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _slen$[ebp]
  0015b	83 fa 02	 cmp	 edx, 2
  0015e	0f 8e 72 01 00
	00		 jle	 $LN162@PChatProc

; 2074 : 			{
; 2075 : 				if ( CheckAuthorityCondition(98, lpObj) == true) //season4 changed

  00164	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0016a	51		 push	 ecx
  0016b	6a 62		 push	 98			; 00000062H
  0016d	e8 00 00 00 00	 call	 ?CheckAuthorityCondition@@YA_NHPAUOBJECTSTRUCT@@@Z ; CheckAuthorityCondition
  00172	83 c4 08	 add	 esp, 8
  00175	3c 01		 cmp	 al, 1
  00177	0f 85 59 01 00
	00		 jne	 $LN162@PChatProc

; 2076 : 				{
; 2077 : 					if(!g_GMManager.CheckCommand(aIndex, egm_cmd_gg))

  0017d	8b bd f4 fd ff
	ff		 mov	 edi, DWORD PTR tv1024[ebp]
  00183	6a 00		 push	 0
  00185	57		 push	 edi
  00186	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GMManager@@3VGMManager@@A ; g_GMManager
  0018b	e8 00 00 00 00	 call	 ?CheckCommand@GMManager@@QAE_NHH@Z ; GMManager::CheckCommand
  00190	84 c0		 test	 al, al
  00192	0f 84 13 0d 00
	00		 je	 $LN169@PChatProc

; 2078 : 					{
; 2079 : 						return;
; 2080 : 					}
; 2081 : 					DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  00198	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR _lpChat$GSCopy$[ebp]
  0019e	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  001a2	52		 push	 edx
  001a3	56		 push	 esi
  001a4	57		 push	 edi
  001a5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2082 : 
; 2083 : 					if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::ulasevich2) ||
; 2084 : 						g_ZtLicense.CheckUser(eZtUB::Almdar) || g_ZtLicense.CheckUser(eZtUB::Almdar2) ||
; 2085 : 						g_ZtLicense.CheckUser(eZtUB::SILVER1) || g_ZtLicense.CheckUser(eZtUB::SILVER2) || g_ZtLicense.CheckUser(eZtUB::SILVER_Local) || 
; 2086 : 						g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2))

  001ad	6a 17		 push	 23			; 00000017H
  001af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001b4	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001b9	84 c0		 test	 al, al
  001bb	0f 85 ad 00 00
	00		 jne	 $LN93@PChatProc
  001c1	6a 1c		 push	 28			; 0000001cH
  001c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001c8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001cd	84 c0		 test	 al, al
  001cf	0f 85 99 00 00
	00		 jne	 $LN93@PChatProc
  001d5	6a 24		 push	 36			; 00000024H
  001d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001dc	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001e1	84 c0		 test	 al, al
  001e3	0f 85 85 00 00
	00		 jne	 $LN93@PChatProc
  001e9	6a 39		 push	 57			; 00000039H
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  001f0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  001f5	84 c0		 test	 al, al
  001f7	75 75		 jne	 SHORT $LN93@PChatProc
  001f9	6a 3f		 push	 63			; 0000003fH
  001fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00200	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00205	84 c0		 test	 al, al
  00207	75 65		 jne	 SHORT $LN93@PChatProc
  00209	6a 07		 push	 7
  0020b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00210	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00215	84 c0		 test	 al, al
  00217	75 55		 jne	 SHORT $LN93@PChatProc
  00219	6a 08		 push	 8
  0021b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00220	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00225	84 c0		 test	 al, al
  00227	75 45		 jne	 SHORT $LN93@PChatProc
  00229	6a 2b		 push	 43			; 0000002bH
  0022b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00230	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00235	84 c0		 test	 al, al
  00237	75 35		 jne	 SHORT $LN93@PChatProc
  00239	6a 30		 push	 48			; 00000030H
  0023b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00240	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00245	84 c0		 test	 al, al
  00247	75 25		 jne	 SHORT $LN93@PChatProc
  00249	6a 31		 push	 49			; 00000031H
  0024b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00250	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00255	84 c0		 test	 al, al
  00257	75 15		 jne	 SHORT $LN93@PChatProc

; 2089 : 					}
; 2090 : 					else
; 2091 : 					{	
; 2092 : 						AllSendServerMsg(&lpChat->chatmsg[AdminConfigConflictCount+2]);

  00259	8d 74 1e 0f	 lea	 esi, DWORD PTR [esi+ebx+15]
  0025d	56		 push	 esi
  0025e	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00263	8b bd fc fd ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00269	83 c4 04	 add	 esp, 4
  0026c	eb 1c		 jmp	 SHORT $LN92@PChatProc
$LN93@PChatProc:

; 2087 : 					{
; 2088 : 						MessaageAllGlobal("[%s]:%s" , lpObj->Name , &lpChat->chatmsg[AdminConfigConflictCount+2]);

  0026e	8b bd fc fd ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00274	8d 74 1e 0f	 lea	 esi, DWORD PTR [esi+ebx+15]
  00278	56		 push	 esi
  00279	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  0027c	50		 push	 eax
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@
  00282	e8 00 00 00 00	 call	 ?MessaageAllGlobal@@YAXPADZZ ; MessaageAllGlobal
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN92@PChatProc:

; 2093 : 					}
; 2094 : 					
; 2095 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2096 : 					if ( gWriteChatLog && g_ZtLicense.user.ChatLog)

  0028a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00291	0f 84 14 0c 00
	00		 je	 $LN169@PChatProc
  00297	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  0029e	0f 84 07 0c 00
	00		 je	 $LN169@PChatProc

; 2097 : 					{
; 2098 : 						g_GMChatLog.Output("[%s] [%s] %s", lpObj->AccountID, lpObj->Name, &lpChat->chatmsg[AdminConfigConflictCount+2]);

  002a4	56		 push	 esi
  002a5	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  002a8	51		 push	 ecx
  002a9	83 c7 6c	 add	 edi, 108		; 0000006cH
  002ac	57		 push	 edi
  002ad	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  002b2	68 00 00 00 00	 push	 OFFSET ?g_GMChatLog@@3VCLogToFile@@A ; g_GMChatLog
  002b7	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  002bc	83 c4 14	 add	 esp, 20			; 00000014H
  002bf	5b		 pop	 ebx
  002c0	5f		 pop	 edi
  002c1	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  002c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c5	33 cd		 xor	 ecx, ebp
  002c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cc	8b e5		 mov	 esp, ebp
  002ce	5d		 pop	 ebp
  002cf	c3		 ret	 0
$LN158@PChatProc:

; 2099 : 					}
; 2100 : #else
; 2101 : 					LogAddTD(lMsg.Get(MSGGET(1, 215)), gObj[aIndex].AccountID, gObj[aIndex].Name, &lpChat->chatmsg[1]);
; 2102 : 
; 2103 : 
; 2104 : 					if ( gWriteChatLog )
; 2105 : 					{
; 2106 : 						memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 2107 : 						pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2108 : 						pChatMsg.btType = 0x03;
; 2109 : 					}
; 2110 : #endif
; 2111 : 					return;

  002d0	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _slen$[ebp]
$LN162@PChatProc:

; 2112 : 				}
; 2113 : 			}
; 2114 : 	}
; 2115 : 	if(PostConfigConflictFlag)

  002d6	80 bd ef fd ff
	ff 00		 cmp	 BYTE PTR _PostConfigConflictFlag$[ebp], 0
  002dd	0f 84 16 03 00
	00		 je	 $LN163@PChatProc

; 2116 : 	{
; 2117 : 		if (slen > PostConfigConflictCount)

  002e3	3b 95 f0 fd ff
	ff		 cmp	 edx, DWORD PTR _PostConfigConflictCount$[ebp]
  002e9	0f 8e 0a 03 00
	00		 jle	 $LN163@PChatProc

; 2118 : 		{
; 2119 : 			if ( slen > 2 )

  002ef	83 fa 02	 cmp	 edx, 2
  002f2	0f 8e 01 03 00
	00		 jle	 $LN163@PChatProc

; 2120 : 			{
; 2121 : 				{
; 2122 : #if(_BAN_SYSTEM_)
; 2123 : 					if ( lpObj->BanPost > time(NULL) )

  002f8	6a 00		 push	 0
  002fa	e8 00 00 00 00	 call	 __time64
  002ff	8b 9d fc fd ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00305	8b b3 b8 27 00
	00		 mov	 esi, DWORD PTR [ebx+10168]
  0030b	33 c9		 xor	 ecx, ecx
  0030d	83 c4 04	 add	 esp, 4
  00310	3b ca		 cmp	 ecx, edx
  00312	7c 3c		 jl	 SHORT $LN87@PChatProc
  00314	7f 04		 jg	 SHORT $LN138@PChatProc
  00316	3b f0		 cmp	 esi, eax
  00318	76 36		 jbe	 SHORT $LN87@PChatProc
$LN138@PChatProc:

; 2124 : 					{
; 2125 : 
; 2126 : 						MsgOutput(lpObj->m_Index, "[BanPost] %d Sec", (lpObj->BanPost-time(NULL)));

  0031a	6a 00		 push	 0
  0031c	e8 00 00 00 00	 call	 __time64
  00321	8b 8b b8 27 00
	00		 mov	 ecx, DWORD PTR [ebx+10168]
  00327	33 f6		 xor	 esi, esi
  00329	2b c8		 sub	 ecx, eax
  0032b	1b f2		 sbb	 esi, edx
  0032d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0032f	56		 push	 esi
  00330	51		 push	 ecx
  00331	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HLMAIFBF@?$FLBanPost?$FN?5?$CFd?5Sec?$AA@
  00336	52		 push	 edx
  00337	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0033c	83 c4 14	 add	 esp, 20			; 00000014H
  0033f	5b		 pop	 ebx
  00340	5f		 pop	 edi
  00341	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00342	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00345	33 cd		 xor	 ecx, ebp
  00347	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034c	8b e5		 mov	 esp, ebp
  0034e	5d		 pop	 ebp
  0034f	c3		 ret	 0
$LN87@PChatProc:

; 2127 : 						return;
; 2128 : 					}
; 2129 : #endif
; 2130 : 					#if(DEV_BANSYSTEM)
; 2131 : 					if(!g_BanSystem.Chat(aIndex))

  00350	8b b5 f4 fd ff
	ff		 mov	 esi, DWORD PTR tv1024[ebp]
  00356	56		 push	 esi
  00357	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BanSystem@@3VCBanSystem@@A ; g_BanSystem
  0035c	e8 00 00 00 00	 call	 ?Chat@CBanSystem@@QAE_NH@Z ; CBanSystem::Chat
  00361	84 c0		 test	 al, al

; 2132 : 					{
; 2133 : 						MsgOutput(lpObj->m_Index, "[BanChatHdd]");
; 2134 : 						return;

  00363	0f 84 d4 04 00
	00		 je	 $LN170@PChatProc

; 2135 : 					}
; 2136 : 					#endif
; 2137 : 					if(lpObj->Level < ZtConfig.Command.PostLevel)

  00369	0f bf 8b be 00
	00 00		 movsx	 ecx, WORD PTR [ebx+190]
  00370	a1 ec 05 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1516
  00375	3b c8		 cmp	 ecx, eax
  00377	7d 20		 jge	 SHORT $LN85@PChatProc

; 2138 : 					{
; 2139 : 						MsgNormal(aIndex,"Need Level %d",ZtConfig.Command.PostLevel);

  00379	50		 push	 eax
  0037a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BMNAIKJI@Need?5Level?5?$CFd?$AA@
  0037f	56		 push	 esi
  00380	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00385	83 c4 0c	 add	 esp, 12			; 0000000cH
  00388	5b		 pop	 ebx
  00389	5f		 pop	 edi
  0038a	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  0038b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038e	33 cd		 xor	 ecx, ebp
  00390	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00395	8b e5		 mov	 esp, ebp
  00397	5d		 pop	 ebp
  00398	c3		 ret	 0
$LN85@PChatProc:

; 2140 : 						return;
; 2141 : 					}
; 2142 : 
; 2143 : 					if(lpObj->Money < ZtConfig.Command.PostMoney)

  00399	a1 f0 05 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1520
  0039e	39 83 f0 00 00
	00		 cmp	 DWORD PTR [ebx+240], eax
  003a4	7d 20		 jge	 SHORT $LN84@PChatProc

; 2144 : 					{
; 2145 : 						MsgNormal(aIndex,"Need Money: %d",ZtConfig.Command.PostMoney);

  003a6	50		 push	 eax
  003a7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BFCGKFKP@Need?5Money?3?5?$CFd?$AA@
  003ac	56		 push	 esi
  003ad	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  003b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b5	5b		 pop	 ebx
  003b6	5f		 pop	 edi
  003b7	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  003b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bb	33 cd		 xor	 ecx, ebp
  003bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c2	8b e5		 mov	 esp, ebp
  003c4	5d		 pop	 ebp
  003c5	c3		 ret	 0
$LN84@PChatProc:

; 2146 : 						return;
; 2147 : 					}
; 2148 : #ifdef FLOOD_IN_POST
; 2149 : 					if(g_ZtLicense.CheckUser(eZtUB::drynea))

  003c6	6a 01		 push	 1
  003c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  003cd	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  003d2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  003d8	84 c0		 test	 al, al
  003da	74 73		 je	 SHORT $LN83@PChatProc

; 2150 : 					{
; 2151 : 						if(ZtConfig.DryneaConfig.PostFloodProtect == 1)

  003dc	83 3d 88 0c 00
	00 01		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+3208, 1
  003e3	75 62		 jne	 SHORT $LN80@PChatProc

; 2152 : 						{
; 2153 : 							if(lpObj->PostTickCount != 0)

  003e5	83 bb 40 28 00
	00 00		 cmp	 DWORD PTR [ebx+10304], 0
  003ec	74 59		 je	 SHORT $LN80@PChatProc

; 2154 : 							{
; 2155 : 								if ( 1000 * ZtConfig.DryneaConfig.PostFloodProtectTime >= GetTickCount() - lpObj->PostTickCount )

  003ee	ff d6		 call	 esi
  003f0	8b 15 8c 0c 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+3212
  003f6	2b 83 40 28 00
	00		 sub	 eax, DWORD PTR [ebx+10304]
  003fc	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  00402	3b d0		 cmp	 edx, eax
  00404	72 41		 jb	 SHORT $LN80@PChatProc

; 2156 : 								{
; 2157 : 									MsgNormal(aIndex,"Please wait %d seconds before next post", ZtConfig.DryneaConfig.PostFloodProtectTime - ((GetTickCount() - lpObj->PostTickCount) / 1000));

  00406	ff d6		 call	 esi
  00408	8b c8		 mov	 ecx, eax
  0040a	2b 8b 40 28 00
	00		 sub	 ecx, DWORD PTR [ebx+10304]
  00410	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00415	f7 e1		 mul	 ecx
  00417	a1 8c 0c 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+3212
  0041c	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1024[ebp]
  00422	c1 ea 06	 shr	 edx, 6
  00425	2b c2		 sub	 eax, edx
  00427	50		 push	 eax
  00428	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OGALPJEH@Please?5wait?5?$CFd?5seconds?5before?5ne@
  0042d	51		 push	 ecx
  0042e	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  00433	83 c4 0c	 add	 esp, 12			; 0000000cH
  00436	5b		 pop	 ebx
  00437	5f		 pop	 edi
  00438	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00439	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0043c	33 cd		 xor	 ecx, ebp
  0043e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00443	8b e5		 mov	 esp, ebp
  00445	5d		 pop	 ebp
  00446	c3		 ret	 0
$LN80@PChatProc:

; 2158 : 									return;
; 2159 : 								}
; 2160 : 							}
; 2161 : 						}
; 2162 : 
; 2163 : 						lpObj->PostTickCount = GetTickCount();

  00447	ff d6		 call	 esi
  00449	89 83 40 28 00
	00		 mov	 DWORD PTR [ebx+10304], eax
$LN83@PChatProc:

; 2164 : 					}
; 2165 : #endif
; 2166 : 					if(ZtConfig.Command.PostDelay > 0)

  0044f	83 3d 5c 06 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1628, 0
  00456	7e 61		 jle	 SHORT $LN79@PChatProc

; 2167 : 					{
; 2168 : 						if ( 1000 * ZtConfig.Command.PostDelay >= GetTickCount() - lpObj->PostTickCount )

  00458	ff d6		 call	 esi
  0045a	8b 15 5c 06 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1628
  00460	2b 83 40 28 00
	00		 sub	 eax, DWORD PTR [ebx+10304]
  00466	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  0046c	3b d0		 cmp	 edx, eax
  0046e	72 41		 jb	 SHORT $LN78@PChatProc

; 2169 : 						{
; 2170 : 							MsgNormal(aIndex,"Please wait %d seconds before next post", ZtConfig.Command.PostDelay - ((GetTickCount() - lpObj->PostTickCount) / 1000));

  00470	ff d6		 call	 esi
  00472	8b c8		 mov	 ecx, eax
  00474	2b 8b 40 28 00
	00		 sub	 ecx, DWORD PTR [ebx+10304]
  0047a	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0047f	f7 e1		 mul	 ecx
  00481	a1 5c 06 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1628
  00486	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1024[ebp]
  0048c	c1 ea 06	 shr	 edx, 6
  0048f	2b c2		 sub	 eax, edx
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OGALPJEH@Please?5wait?5?$CFd?5seconds?5before?5ne@
  00497	51		 push	 ecx
  00498	e8 00 00 00 00	 call	 ?MsgNormal@@YAXHPADZZ	; MsgNormal
  0049d	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a0	5b		 pop	 ebx
  004a1	5f		 pop	 edi
  004a2	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  004a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a6	33 cd		 xor	 ecx, ebp
  004a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ad	8b e5		 mov	 esp, ebp
  004af	5d		 pop	 ebp
  004b0	c3		 ret	 0
$LN78@PChatProc:

; 2171 : 							return;
; 2172 : 						}
; 2173 : 
; 2174 : 						lpObj->PostTickCount = GetTickCount();

  004b1	ff d6		 call	 esi
  004b3	89 83 40 28 00
	00		 mov	 DWORD PTR [ebx+10304], eax
$LN79@PChatProc:

; 2175 : 					}
; 2176 : 
; 2177 : 
; 2178 : 					//char ChatMessage[90];
; 2179 : 					//ZeroMemory(&ChatMessage,sizeof(ChatMessage));
; 2180 : 					//sprintf(ChatMessage, "%s %s",ZtConfig.Command.PostPrist,&lpChat->chatmsg[1]);break;
; 2181 : 
; 2182 : 					//memcpy(pMessage.Message, szTemp, 90);
; 2183 : 					lpObj->Money -= ZtConfig.Command.PostMoney;

  004b9	8b 15 f0 05 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1520
  004bf	29 93 f0 00 00
	00		 sub	 DWORD PTR [ebx+240], edx
  004c5	8b 83 f0 00 00
	00		 mov	 eax, DWORD PTR [ebx+240]

; 2184 : 					GCMoneySend(aIndex, lpObj->Money);

  004cb	50		 push	 eax
  004cc	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR tv1024[ebp]
  004d2	50		 push	 eax
  004d3	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  004d8	83 c4 08	 add	 esp, 8

; 2185 : 
; 2186 : #if(CUSTOM_POST_SERVER)
; 2187 : 					if(ZtConfig.Command.PostServer)

  004db	83 3d 60 06 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1632, 0
  004e2	0f 84 8e 00 00
	00		 je	 $LN77@PChatProc

; 2188 : 					{
; 2189 : 						BroadCastMessageInfo lpRequest = { 0 };

  004e8	6a 69		 push	 105			; 00000069H
  004ea	8d 8d 01 fe ff
	ff		 lea	 ecx, DWORD PTR _lpRequest$245023[ebp+1]
  004f0	6a 00		 push	 0
  004f2	51		 push	 ecx
  004f3	e8 00 00 00 00	 call	 _memset

; 2190 : 						lpRequest.h.set((LPBYTE)&lpRequest, 0xCD, sizeof(lpRequest));
; 2191 : 						lpRequest.Type = 2;
; 2192 : 						sprintf(lpRequest.Text, "[%d] ", gGameServerCode+1); 

  004f8	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  004ff	42		 inc	 edx
  00500	52		 push	 edx
  00501	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _lpRequest$245023[ebp+16]
  00507	68 00 00 00 00	 push	 OFFSET ??_C@_05GEPBPPAJ@?$FL?$CFd?$FN?5?$AA@
  0050c	50		 push	 eax
  0050d	c7 85 00 fe ff
	ff c2 00 6a cd	 mov	 DWORD PTR _lpRequest$245023[ebp], -848691006 ; cd6a00c2H
  00517	c6 85 04 fe ff
	ff 02		 mov	 BYTE PTR _lpRequest$245023[ebp+4], 2
  0051e	e8 00 00 00 00	 call	 _sprintf

; 2193 : 						strncat(lpRequest.Text, &lpChat->chatmsg[PostConfigConflictCount], 89-10);

  00523	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpChat$GSCopy$[ebp]
  00529	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _PostConfigConflictCount$[ebp]
  0052f	8d 74 11 0d	 lea	 esi, DWORD PTR [ecx+edx+13]
  00533	6a 4f		 push	 79			; 0000004fH
  00535	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR _lpRequest$245023[ebp+16]
  0053b	56		 push	 esi
  0053c	50		 push	 eax
  0053d	e8 00 00 00 00	 call	 _strncat

; 2194 : 						memcpy(lpRequest.Sender, lpChat->chatid, 10);		

  00542	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00544	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00547	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  0054b	83 c4 24	 add	 esp, 36			; 00000024H
  0054e	89 8d 06 fe ff
	ff		 mov	 DWORD PTR _lpRequest$245023[ebp+6], ecx

; 2195 : 						wsJServerCli.DataSend((PCHAR)&lpRequest, sizeof(BroadCastMessageInfo));

  00554	6a 6a		 push	 106			; 0000006aH
  00556	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _lpRequest$245023[ebp]
  0055c	51		 push	 ecx
  0055d	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00562	89 95 0a fe ff
	ff		 mov	 DWORD PTR _lpRequest$245023[ebp+10], edx
  00568	66 89 85 0e fe
	ff ff		 mov	 WORD PTR _lpRequest$245023[ebp+14], ax
  0056f	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2196 : 					}
; 2197 : 					else

  00574	eb 2b		 jmp	 SHORT $LN76@PChatProc
$LN77@PChatProc:

; 2198 : 					{
; 2199 : 						MessageSendAllEx(ZtConfig.Command.PostColor,lpChat->chatid, "%s %s", ZtConfig.Command.PostPrist,&lpChat->chatmsg[PostConfigConflictCount]);

  00576	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpChat$GSCopy$[ebp]
  0057c	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _PostConfigConflictCount$[ebp]
  00582	8b 0d 58 06 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+1624
  00588	8d 74 02 0d	 lea	 esi, DWORD PTR [edx+eax+13]
  0058c	56		 push	 esi
  0058d	68 f4 05 00 00	 push	 OFFSET ?ZtConfig@@3VcZtConfigs@@A+1524
  00592	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
  00597	57		 push	 edi
  00598	51		 push	 ecx
  00599	e8 00 00 00 00	 call	 ?MessageSendAllEx@@YAXHPAD0ZZ ; MessageSendAllEx
  0059e	83 c4 14	 add	 esp, 20			; 00000014H
$LN76@PChatProc:

; 2200 : 					}
; 2201 : #else
; 2202 : 					MessageSendAllEx(ZtConfig.Command.PostColor,lpChat->chatid, "%s %s", ZtConfig.Command.PostPrist,&lpChat->chatmsg[PostConfigConflictCount]);
; 2203 : #endif
; 2204 : 
; 2205 : 					#if(EVENT_QUESTIONANSWER)
; 2206 : 					g_QuestionAnswer.Chat(aIndex, &lpChat->chatmsg[PostConfigConflictCount]);

  005a1	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR tv1024[ebp]
  005a7	56		 push	 esi
  005a8	52		 push	 edx
  005a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestionAnswer@@3VCQuestionAnswer@@A ; g_QuestionAnswer
  005ae	e8 00 00 00 00	 call	 ?Chat@CQuestionAnswer@@QAEXHPAD@Z ; CQuestionAnswer::Chat

; 2207 : 					#endif
; 2208 : 
; 2209 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2210 : 					if ( gWriteChatLog && g_ZtLicense.user.ChatLog )

  005b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  005ba	0f 84 eb 08 00
	00		 je	 $LN169@PChatProc
  005c0	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  005c7	0f 84 de 08 00
	00		 je	 $LN169@PChatProc

; 2211 : 					{
; 2212 : 						g_PostLog.Output("[%s] [%s] %s", lpObj->AccountID, lpObj->Name, &lpChat->chatmsg[PostConfigConflictCount]);

  005cd	56		 push	 esi
  005ce	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  005d1	50		 push	 eax
  005d2	83 c3 6c	 add	 ebx, 108		; 0000006cH
  005d5	53		 push	 ebx
  005d6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  005db	68 00 00 00 00	 push	 OFFSET ?g_PostLog@@3VCLogToFile@@A ; g_PostLog
  005e0	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  005e5	83 c4 14	 add	 esp, 20			; 00000014H
  005e8	5b		 pop	 ebx
  005e9	5f		 pop	 edi
  005ea	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  005eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ee	33 cd		 xor	 ecx, ebp
  005f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f5	8b e5		 mov	 esp, ebp
  005f7	5d		 pop	 ebp
  005f8	c3		 ret	 0
$LN163@PChatProc:

; 2213 : 					}
; 2214 : #endif
; 2215 : 				}
; 2216 : 				return;
; 2217 : 			}
; 2218 : 		}
; 2219 : 	}
; 2220 : 
; 2221 : #endif
; 2222 : 	switch ( lpChat->chatmsg[0] )

  005f9	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR tv1027[ebp]
  005ff	8a 01		 mov	 al, BYTE PTR [ecx]
  00601	3c 21		 cmp	 al, 33			; 00000021H
  00603	0f 84 06 01 00
	00		 je	 $LN72@PChatProc
  00609	3c 2f		 cmp	 al, 47			; 0000002fH
  0060b	0f 85 7a 01 00
	00		 jne	 $LN71@PChatProc

; 2234 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2235 : 					if ( gWriteChatLog )
; 2236 : 					{
; 2237 : 						memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 2238 : 						pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2239 : 						pChatMsg.btType = 0x03;
; 2240 : 					}
; 2241 : #endif
; 2242 : 					return;
; 2243 : 				}
; 2244 : #if(_POST_CONFIG_ == 0)
; 2245 : 				else
; 2246 : 				{
; 2247 : #if(_BAN_SYSTEM_)
; 2248 : 					if ( lpObj->BanPost > time(NULL) )
; 2249 : 					{
; 2250 : 						MsgOutput(lpObj->m_Index, "[BanPost] %d Sec", (lpObj->BanPost-time(NULL)));
; 2251 : 						return;
; 2252 : 					}
; 2253 : #endif
; 2254 : 					if(lpObj->Level < ZtConfig.Command.PostLevel)
; 2255 : 					{
; 2256 : 						MsgNormal(aIndex,"Need Level %d",ZtConfig.Command.PostLevel);
; 2257 : 						return;
; 2258 : 					}
; 2259 : 
; 2260 : 					if(lpObj->Money < ZtConfig.Command.PostMoney)
; 2261 : 					{
; 2262 : 						MsgNormal(aIndex,"Need Money: %d",ZtConfig.Command.PostMoney);
; 2263 : 						return;
; 2264 : 					}
; 2265 : 					//char ChatMessage[90];
; 2266 : 					//ZeroMemory(&ChatMessage,sizeof(ChatMessage));
; 2267 : 					//sprintf(ChatMessage, "%s %s",ZtConfig.Command.PostPrist,&lpChat->chatmsg[1]);break;
; 2268 : 
; 2269 : 					//memcpy(pMessage.Message, szTemp, 90);
; 2270 : 					lpObj->Money -= ZtConfig.Command.PostMoney;
; 2271 : 					GCMoneySend(aIndex, lpObj->Money);
; 2272 : 					MessageSendAllEx(ZtConfig.Command.PostColor,lpChat->chatid, "%s %s", ZtConfig.Command.PostPrist,&lpChat->chatmsg[1]);
; 2273 : 				}
; 2274 : #endif
; 2275 : 				return;
; 2276 : 			}
; 2277 : 			break;
; 2278 : 
; 2279 : 		case '/':	// Command
; 2280 : 			if ( slen > 2 )

  00611	83 fa 02	 cmp	 edx, 2
  00614	0f 8e 71 01 00
	00		 jle	 $LN71@PChatProc

; 2281 : 			{
; 2282 : 				if(strcmp(&lpChat->chatmsg[1], " ") == 0) //season4 all changed

  0061a	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00620	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$AA@
  00625	83 c0 0e	 add	 eax, 14			; 0000000eH
$LL139@PChatProc:
  00628	8a 10		 mov	 dl, BYTE PTR [eax]
  0062a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0062c	75 1a		 jne	 SHORT $LN140@PChatProc
  0062e	84 d2		 test	 dl, dl
  00630	74 12		 je	 SHORT $LN141@PChatProc
  00632	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00635	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00638	75 0e		 jne	 SHORT $LN140@PChatProc
  0063a	83 c0 02	 add	 eax, 2
  0063d	83 c1 02	 add	 ecx, 2
  00640	84 d2		 test	 dl, dl
  00642	75 e4		 jne	 SHORT $LL139@PChatProc
$LN141@PChatProc:
  00644	33 c0		 xor	 eax, eax
  00646	eb 05		 jmp	 SHORT $LN142@PChatProc
$LN140@PChatProc:
  00648	1b c0		 sbb	 eax, eax
  0064a	83 d8 ff	 sbb	 eax, -1
$LN142@PChatProc:

; 2283 : 				{
; 2284 : 					if(gObjCheckIsInPCBang(lpObj) != FALSE) //season4 add-on :)

  0064d	8b b5 fc fd ff
	ff		 mov	 esi, DWORD PTR _lpObj$[ebp]
  00653	85 c0		 test	 eax, eax
  00655	75 43		 jne	 SHORT $LN65@PChatProc
  00657	56		 push	 esi
  00658	e8 00 00 00 00	 call	 ?gObjCheckIsInPCBang@@YAHPAUOBJECTSTRUCT@@@Z ; gObjCheckIsInPCBang
  0065d	83 c4 04	 add	 esp, 4
  00660	85 c0		 test	 eax, eax
  00662	74 36		 je	 SHORT $LN65@PChatProc

; 2285 : 					{
; 2286 : 						if(gMoveCommand.MoveFree2Kalima(lpObj) != FALSE)

  00664	56		 push	 esi
  00665	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0066a	e8 00 00 00 00	 call	 ?MoveFree2Kalima@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@@Z ; CMoveCommand::MoveFree2Kalima
  0066f	85 c0		 test	 eax, eax
  00671	74 27		 je	 SHORT $LN65@PChatProc

; 2287 : 						{
; 2288 : 							LogAddTD("[%s][%s] Use [/ ] PCBANG",lpObj->AccountID, lpObj->Name);

  00673	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00676	52		 push	 edx
  00677	83 c6 6c	 add	 esi, 108		; 0000006cH
  0067a	56		 push	 esi
  0067b	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GDGNGFHG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?1?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG?$FN?5PCBA@
  00680	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00686	83 c4 0c	 add	 esp, 12			; 0000000cH
  00689	5b		 pop	 ebx
  0068a	5f		 pop	 edi
  0068b	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  0068c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0068f	33 cd		 xor	 ecx, ebp
  00691	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00696	8b e5		 mov	 esp, ebp
  00698	5d		 pop	 ebp
  00699	c3		 ret	 0
$LN65@PChatProc:

; 2289 : 							return;
; 2290 : 						}
; 2291 : 					}
; 2292 : 				}
; 2293 : 				
; 2294 : 				if( (GetTickCount() - lpObj->MySelfDefenseTime) < 60000) //season 2.5 add-on

  0069a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  006a0	2b 86 1c 04 00
	00		 sub	 eax, DWORD PTR [esi+1052]
  006a6	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  006ab	73 2e		 jae	 SHORT $LN64@PChatProc

; 2295 : 				{
; 2296 : 					GCServerMsgStringSend(lMsg.Get(1133),lpObj->m_Index,1);

  006ad	8b 06		 mov	 eax, DWORD PTR [esi]
  006af	6a 01		 push	 1
  006b1	50		 push	 eax
  006b2	68 6d 04 00 00	 push	 1133			; 0000046dH
  006b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  006bc	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  006c1	50		 push	 eax
  006c2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  006ca	5b		 pop	 ebx
  006cb	5f		 pop	 edi
  006cc	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  006cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d0	33 cd		 xor	 ecx, ebp
  006d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d7	8b e5		 mov	 esp, ebp
  006d9	5d		 pop	 ebp
  006da	c3		 ret	 0
$LN64@PChatProc:

; 2297 : 					return;
; 2298 : 				}
; 2299 : 
; 2300 : 				if ( lpObj->CloseCount >= 0 )

  006db	80 7e 0a 00	 cmp	 BYTE PTR [esi+10], 0
  006df	0f 8d c6 07 00
	00		 jge	 $LN169@PChatProc

; 2301 : 				{
; 2302 : 					return;
; 2303 : 				}
; 2304 : 
; 2305 : 				cManager.ManagementProc(lpObj, lpChat->chatmsg, aIndex);

  006e5	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1024[ebp]
  006eb	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv1027[ebp]
  006f1	51		 push	 ecx
  006f2	52		 push	 edx
  006f3	56		 push	 esi
  006f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  006f9	e8 00 00 00 00	 call	 ?ManagementProc@CGMMng@@QAEHPAUOBJECTSTRUCT@@PADH@Z ; CGMMng::ManagementProc
  006fe	5b		 pop	 ebx
  006ff	5f		 pop	 edi
  00700	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00701	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00704	33 cd		 xor	 ecx, ebp
  00706	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0070b	8b e5		 mov	 esp, ebp
  0070d	5d		 pop	 ebp
  0070e	c3		 ret	 0
$LN72@PChatProc:

; 2223 : 	{
; 2224 : 
; 2225 : 		case '!':	// Global Announcement
; 2226 : 			if ( slen > 2 )

  0070f	83 fa 02	 cmp	 edx, 2
  00712	7e 77		 jle	 SHORT $LN71@PChatProc

; 2227 : 			{
; 2228 : 				if ( CheckAuthorityCondition(98, lpObj) == true) //season4 changed

  00714	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071a	50		 push	 eax
  0071b	6a 62		 push	 98			; 00000062H
  0071d	e8 00 00 00 00	 call	 ?CheckAuthorityCondition@@YA_NHPAUOBJECTSTRUCT@@@Z ; CheckAuthorityCondition
  00722	83 c4 08	 add	 esp, 8
  00725	3c 01		 cmp	 al, 1
  00727	0f 85 7e 07 00
	00		 jne	 $LN169@PChatProc

; 2229 : 				{
; 2230 : 					DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  0072d	8b bd f8 fd ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  00733	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  00737	8b 95 f4 fd ff
	ff		 mov	 edx, DWORD PTR tv1024[ebp]
  0073d	51		 push	 ecx
  0073e	57		 push	 edi
  0073f	52		 push	 edx
  00740	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2231 : 					AllSendServerMsg(&lpChat->chatmsg[1]);

  00745	83 c7 0e	 add	 edi, 14			; 0000000eH
  00748	57		 push	 edi
  00749	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 2232 : 
; 2233 : 					LogAddTD(lMsg.Get(MSGGET(1, 215)), gObj[aIndex].AccountID, gObj[aIndex].Name, &lpChat->chatmsg[1]);

  0074e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00753	83 c4 10	 add	 esp, 16			; 00000010H
  00756	57		 push	 edi
  00757	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  0075b	51		 push	 ecx
  0075c	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  00760	52		 push	 edx
  00761	68 d7 01 00 00	 push	 471			; 000001d7H
  00766	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0076b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00770	50		 push	 eax
  00771	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00777	83 c4 10	 add	 esp, 16			; 00000010H
  0077a	5b		 pop	 ebx
  0077b	5f		 pop	 edi
  0077c	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  0077d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00780	33 cd		 xor	 ecx, ebp
  00782	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00787	8b e5		 mov	 esp, ebp
  00789	5d		 pop	 ebp
  0078a	c3		 ret	 0
$LN71@PChatProc:

; 2306 : 				return;
; 2307 : 			}
; 2308 : 			break;
; 2309 : 	}
; 2310 : 
; 2311 : 	// Other Commands
; 2312 : 	if ( lpObj->ChatLitmitTime > 0 )

  0078b	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00791	0f b7 80 1c 01
	00 00		 movzx	 eax, WORD PTR [eax+284]
  00798	66 85 c0	 test	 ax, ax
  0079b	74 33		 je	 SHORT $LN62@PChatProc

; 2313 : 	{
; 2314 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(4, 223)), lpObj->ChatLitmitTime);

  0079d	50		 push	 eax
  0079e	68 df 04 00 00	 push	 1247			; 000004dfH
  007a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007a8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  007ad	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  007b3	50		 push	 eax
  007b4	8b 02		 mov	 eax, DWORD PTR [edx]
  007b6	50		 push	 eax
  007b7	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  007bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  007bf	5b		 pop	 ebx
  007c0	5f		 pop	 edi
  007c1	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  007c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c5	33 cd		 xor	 ecx, ebp
  007c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007cc	8b e5		 mov	 esp, ebp
  007ce	5d		 pop	 ebp
  007cf	c3		 ret	 0
$LN62@PChatProc:

; 2315 : 		return;
; 2316 : 	}
; 2317 : #if(_BAN_SYSTEM_)
; 2318 : 	if ( lpObj->BanChat > time(NULL) )

  007d0	6a 00		 push	 0
  007d2	e8 00 00 00 00	 call	 __time64
  007d7	8b 9d fc fd ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  007dd	8b b3 b4 27 00
	00		 mov	 esi, DWORD PTR [ebx+10164]
  007e3	33 c9		 xor	 ecx, ecx
  007e5	83 c4 04	 add	 esp, 4
  007e8	3b ca		 cmp	 ecx, edx
  007ea	7c 3c		 jl	 SHORT $LN61@PChatProc
  007ec	7f 04		 jg	 SHORT $LN143@PChatProc
  007ee	3b f0		 cmp	 esi, eax
  007f0	76 36		 jbe	 SHORT $LN61@PChatProc
$LN143@PChatProc:

; 2319 : 	{
; 2320 : 		MsgOutput(lpObj->m_Index, "[BanChat] %d Sec", (lpObj->BanChat-time(NULL)));

  007f2	6a 00		 push	 0
  007f4	e8 00 00 00 00	 call	 __time64
  007f9	8b 8b b4 27 00
	00		 mov	 ecx, DWORD PTR [ebx+10164]
  007ff	33 f6		 xor	 esi, esi
  00801	2b c8		 sub	 ecx, eax
  00803	1b f2		 sbb	 esi, edx
  00805	8b 13		 mov	 edx, DWORD PTR [ebx]
  00807	56		 push	 esi
  00808	51		 push	 ecx
  00809	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PAAPNLIE@?$FLBanChat?$FN?5?$CFd?5Sec?$AA@
  0080e	52		 push	 edx
  0080f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00814	83 c4 14	 add	 esp, 20			; 00000014H
  00817	5b		 pop	 ebx
  00818	5f		 pop	 edi
  00819	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  0081a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081d	33 cd		 xor	 ecx, ebp
  0081f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00824	8b e5		 mov	 esp, ebp
  00826	5d		 pop	 ebp
  00827	c3		 ret	 0
$LN61@PChatProc:

; 2321 : 		return;
; 2322 : 	}
; 2323 : #endif
; 2324 : 
; 2325 : 	#if(DEV_BANSYSTEM)
; 2326 : 	if(!g_BanSystem.Chat(aIndex))

  00828	8b bd f4 fd ff
	ff		 mov	 edi, DWORD PTR tv1024[ebp]
  0082e	57		 push	 edi
  0082f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BanSystem@@3VCBanSystem@@A ; g_BanSystem
  00834	e8 00 00 00 00	 call	 ?Chat@CBanSystem@@QAE_NH@Z ; CBanSystem::Chat
  00839	84 c0		 test	 al, al
  0083b	75 21		 jne	 SHORT $LN60@PChatProc
$LN170@PChatProc:

; 2327 : 	{
; 2328 : 		MsgOutput(lpObj->m_Index, "[BanChatHdd]");

  0083d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0083f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FJILNKII@?$FLBanChatHdd?$FN?$AA@
  00844	50		 push	 eax
  00845	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0084a	83 c4 08	 add	 esp, 8
  0084d	5b		 pop	 ebx
  0084e	5f		 pop	 edi
  0084f	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00850	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00853	33 cd		 xor	 ecx, ebp
  00855	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0085a	8b e5		 mov	 esp, ebp
  0085c	5d		 pop	 ebp
  0085d	c3		 ret	 0
$LN60@PChatProc:

; 2329 : 		return;
; 2330 : 	}
; 2331 : 	#endif
; 2332 : 
; 2333 : 	if ( (lpObj->Penalty&2)==2)

  0085e	f6 83 10 02 00
	00 02		 test	 BYTE PTR [ebx+528], 2
  00865	0f 85 40 06 00
	00		 jne	 $LN169@PChatProc

; 2334 : 		return;
; 2335 : 
; 2336 : 	// Party Message
; 2337 : 	if ( lpChat->chatmsg[0] == '~' || lpChat->chatmsg[0] == ']' )

  0086b	8b 9d e8 fd ff
	ff		 mov	 ebx, DWORD PTR tv1027[ebp]
  00871	8a 03		 mov	 al, BYTE PTR [ebx]
  00873	3c 7e		 cmp	 al, 126			; 0000007eH
  00875	0f 84 96 05 00
	00		 je	 $LN57@PChatProc
  0087b	3c 5d		 cmp	 al, 93			; 0000005dH
  0087d	0f 84 8e 05 00
	00		 je	 $LN57@PChatProc

; 2368 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2369 : 						if ( gWriteChatLog )
; 2370 : 						{
; 2371 : 							strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[number].Name);
; 2372 : 							szTargetNameCount++;
; 2373 : 						}
; 2374 : #endif
; 2375 : 					}
; 2376 : 				}
; 2377 : 			}
; 2378 : 		}
; 2379 : 	}
; 2380 : 	// Guild
; 2381 : 	else if ( lpChat->chatmsg[0] == '@' )

  00883	3c 40		 cmp	 al, 64			; 00000040H
  00885	0f 85 db 03 00
	00		 jne	 $LN48@PChatProc

; 2382 : 	{
; 2383 : 		if ( lpObj->GuildNumber > 0 )

  0088b	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00891	83 b9 34 04 00
	00 00		 cmp	 DWORD PTR [ecx+1076], 0
  00898	0f 8e 0d 06 00
	00		 jle	 $LN169@PChatProc

; 2384 : 		{
; 2385 : 			// Notice
; 2386 : 			if ( lpChat->chatmsg[1] == '>' )

  0089e	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  008a4	83 c0 0e	 add	 eax, 14			; 0000000eH
  008a7	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv1128[ebp], eax
  008ad	8a 00		 mov	 al, BYTE PTR [eax]
  008af	3c 3e		 cmp	 al, 62			; 0000003eH
  008b1	0f 85 98 00 00
	00		 jne	 $LN46@PChatProc

; 2387 : 			{
; 2388 : 				if ( lpObj->Name[0] == lpObj->lpGuild->Names[0][0] )

  008b7	8b c1		 mov	 eax, ecx
  008b9	8b b0 38 04 00
	00		 mov	 esi, DWORD PTR [eax+1080]
  008bf	8a 50 77	 mov	 dl, BYTE PTR [eax+119]
  008c2	83 c0 77	 add	 eax, 119		; 00000077H
  008c5	3a 56 2f	 cmp	 dl, BYTE PTR [esi+47]
  008c8	8d 4e 2f	 lea	 ecx, DWORD PTR [esi+47]
  008cb	0f 85 da 05 00
	00		 jne	 $LN169@PChatProc
$LL144@PChatProc:

; 2389 : 				{
; 2390 : 					if ( !strcmp(lpObj->Name, lpObj->lpGuild->Names[0] ) )

  008d1	8a 10		 mov	 dl, BYTE PTR [eax]
  008d3	3a 11		 cmp	 dl, BYTE PTR [ecx]
  008d5	75 1a		 jne	 SHORT $LN145@PChatProc
  008d7	84 d2		 test	 dl, dl
  008d9	74 12		 je	 SHORT $LN146@PChatProc
  008db	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  008de	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  008e1	75 0e		 jne	 SHORT $LN145@PChatProc
  008e3	83 c0 02	 add	 eax, 2
  008e6	83 c1 02	 add	 ecx, 2
  008e9	84 d2		 test	 dl, dl
  008eb	75 e4		 jne	 SHORT $LL144@PChatProc
$LN146@PChatProc:
  008ed	33 c0		 xor	 eax, eax
  008ef	eb 05		 jmp	 SHORT $LN147@PChatProc
$LN145@PChatProc:
  008f1	1b c0		 sbb	 eax, eax
  008f3	83 d8 ff	 sbb	 eax, -1
$LN147@PChatProc:
  008f6	85 c0		 test	 eax, eax
  008f8	0f 85 ad 05 00
	00		 jne	 $LN169@PChatProc

; 2391 : 					{
; 2392 : 						GDGuildNoticeSave(lpObj->lpGuild->Name, &lpChat->chatmsg[2]);

  008fe	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00904	83 c0 0f	 add	 eax, 15			; 0000000fH
  00907	50		 push	 eax
  00908	83 c6 04	 add	 esi, 4
  0090b	56		 push	 esi
  0090c	e8 00 00 00 00	 call	 ?GDGuildNoticeSave@@YAXPAD0@Z ; GDGuildNoticeSave

; 2393 : 						LogAdd(lMsg.Get(MSGGET(1, 216)), lpObj->lpGuild->Name, lpChat->chatmsg);

  00911	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00917	8b 91 38 04 00
	00		 mov	 edx, DWORD PTR [ecx+1080]
  0091d	83 c4 08	 add	 esp, 8
  00920	53		 push	 ebx
  00921	83 c2 04	 add	 edx, 4
  00924	52		 push	 edx
  00925	68 d8 01 00 00	 push	 472			; 000001d8H
  0092a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0092f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00934	50		 push	 eax
  00935	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0093b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0093e	5b		 pop	 ebx
  0093f	5f		 pop	 edi
  00940	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00941	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00944	33 cd		 xor	 ecx, ebp
  00946	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0094b	8b e5		 mov	 esp, ebp
  0094d	5d		 pop	 ebp
  0094e	c3		 ret	 0
$LN46@PChatProc:

; 2394 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2395 : 						if ( gWriteChatLog )
; 2396 : 						{
; 2397 : 							memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[2], MAX_CHAT_LEN-2);
; 2398 : 							pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2399 : 							pChatMsg.btType = 0x04;
; 2400 : 						}
; 2401 : #endif
; 2402 : 					}
; 2403 : 				}
; 2404 : 			}
; 2405 : 			// Aliances
; 2406 : 			else if ( lpChat->chatmsg[1] == '@' && lpObj->lpGuild->iGuildUnion )

  0094f	3c 40		 cmp	 al, 64			; 00000040H
  00951	0f 85 e4 01 00
	00		 jne	 $LN42@PChatProc
  00957	8b b1 38 04 00
	00		 mov	 esi, DWORD PTR [ecx+1080]
  0095d	83 be 1c 07 00
	00 00		 cmp	 DWORD PTR [esi+1820], 0
  00964	0f 84 d1 01 00
	00		 je	 $LN42@PChatProc

; 2407 : 			{
; 2408 : 				int iGuildCount = 0;

  0096a	33 ff		 xor	 edi, edi

; 2409 : 				int iGuildList[MAX_UNION_GUILD] ={0};

  0096c	68 8c 01 00 00	 push	 396			; 0000018cH
  00971	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _iGuildList$245073[ebp+4]
  00977	57		 push	 edi
  00978	50		 push	 eax
  00979	89 bd f4 fd ff
	ff		 mov	 DWORD PTR _iGuildCount$245072[ebp], edi
  0097f	89 bd 6c fe ff
	ff		 mov	 DWORD PTR _iGuildList$245073[ebp], edi
  00985	e8 00 00 00 00	 call	 _memset

; 2410 : 
; 2411 : 				if ( UnionManager.GetGuildUnionMemberList(lpObj->lpGuild->iGuildUnion, iGuildCount, iGuildList) == TRUE )

  0098a	8b 86 1c 07 00
	00		 mov	 eax, DWORD PTR [esi+1820]
  00990	83 c4 0c	 add	 esp, 12			; 0000000cH
  00993	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _iGuildList$245073[ebp]
  00999	51		 push	 ecx
  0099a	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _iGuildCount$245072[ebp]
  009a0	52		 push	 edx
  009a1	50		 push	 eax
  009a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  009a7	e8 00 00 00 00	 call	 ?GetGuildUnionMemberList@TUnion@@QAEHHAAHPAH@Z ; TUnion::GetGuildUnionMemberList
  009ac	83 f8 01	 cmp	 eax, 1
  009af	0f 85 46 01 00
	00		 jne	 $LN165@PChatProc

; 2412 : 				{
; 2413 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2414 : 					if ( gWriteChatLog && g_ZtLicense.user.ChatLog )

  009b5	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, edi ; gWriteChatLog
  009bb	74 37		 je	 SHORT $LN164@PChatProc
  009bd	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  009c4	74 2e		 je	 SHORT $LN164@PChatProc

; 2415 : 					{
; 2416 : 						g_AllianceChatLog.Output("[%s] [%s] [%s] %s", lpObj->AccountID, lpObj->Name, lpObj->GuildName,  &lpChat->chatmsg[1]);

  009c6	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  009cc	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1128[ebp]
  009d2	51		 push	 ecx
  009d3	8d 90 3c 04 00
	00		 lea	 edx, DWORD PTR [eax+1084]
  009d9	52		 push	 edx
  009da	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  009dd	51		 push	 ecx
  009de	83 c0 6c	 add	 eax, 108		; 0000006cH
  009e1	50		 push	 eax
  009e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OHBNELPC@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  009e7	68 00 00 00 00	 push	 OFFSET ?g_AllianceChatLog@@3VCLogToFile@@A ; g_AllianceChatLog
  009ec	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  009f1	83 c4 18	 add	 esp, 24			; 00000018H
$LN164@PChatProc:

; 2417 : 					}
; 2418 : #endif
; 2419 : 					for ( int i=0;i<iGuildCount;i++)

  009f4	89 bd e8 fd ff
	ff		 mov	 DWORD PTR _i$245077[ebp], edi
  009fa	39 bd f4 fd ff
	ff		 cmp	 DWORD PTR _iGuildCount$245072[ebp], edi
  00a00	0f 8e f5 00 00
	00		 jle	 $LN165@PChatProc
  00a06	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL39@PChatProc:

; 2420 : 					{
; 2421 : 						_GUILD_INFO_STRUCT *lpGuildInfo = Guild.SearchGuild_Number(iGuildList[i]);

  00a10	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _i$245077[ebp]
  00a16	8b 84 95 6c fe
	ff ff		 mov	 eax, DWORD PTR _iGuildList$245073[ebp+edx*4]
  00a1d	50		 push	 eax
  00a1e	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00a23	e8 00 00 00 00	 call	 ?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z ; CGuildClass::SearchGuild_Number
  00a28	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _lpGuildInfo$245081[ebp], eax

; 2422 : 
; 2423 : 						if ( !lpGuildInfo )

  00a2e	85 c0		 test	 eax, eax
  00a30	0f 84 ac 00 00
	00		 je	 $LN38@PChatProc

; 2424 : 							continue;
; 2425 : 
; 2426 : 						for (n=0;n<MAX_USER_GUILD;n++)

  00a36	33 ff		 xor	 edi, edi
  00a38	8d 70 2f	 lea	 esi, DWORD PTR [eax+47]
  00a3b	05 a0 03 00 00	 add	 eax, 928		; 000003a0H
  00a40	89 85 f0 fd ff
	ff		 mov	 DWORD PTR tv1550[ebp], eax
  00a46	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL35@PChatProc:

; 2427 : 						{
; 2428 : 							if ( lpGuildInfo->Use[n] )

  00a50	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _lpGuildInfo$245081[ebp]
  00a56	80 bc 39 40 04
	00 00 00	 cmp	 BYTE PTR [ecx+edi+1088], 0
  00a5e	74 6e		 je	 SHORT $LN34@PChatProc

; 2429 : 							{
; 2430 : 								number = lpGuildInfo->Index[n];

  00a60	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR tv1550[ebp]
  00a66	0f bf 1a	 movsx	 ebx, WORD PTR [edx]

; 2431 : 
; 2432 : 								if ( number >= 0 )

  00a69	85 db		 test	 ebx, ebx
  00a6b	78 61		 js	 SHORT $LN34@PChatProc

; 2433 : 								{
; 2434 : 									if ( lpGuildInfo->Names[n][0] == gObj[number].Name[0] )

  00a6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a73	8a 16		 mov	 dl, BYTE PTR [esi]
  00a75	8b c3		 mov	 eax, ebx
  00a77	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00a7d	3a 54 08 77	 cmp	 dl, BYTE PTR [eax+ecx+119]
  00a81	8d 4c 08 77	 lea	 ecx, DWORD PTR [eax+ecx+119]
  00a85	75 47		 jne	 SHORT $LN34@PChatProc

; 2435 : 									{
; 2436 : 										if ( !strcmp(lpGuildInfo->Names[n], gObj[number].Name ))

  00a87	8b c6		 mov	 eax, esi
  00a89	8d a4 24 00 00
	00 00		 npad	 7
$LL148@PChatProc:
  00a90	8a 10		 mov	 dl, BYTE PTR [eax]
  00a92	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00a94	75 1a		 jne	 SHORT $LN149@PChatProc
  00a96	84 d2		 test	 dl, dl
  00a98	74 12		 je	 SHORT $LN150@PChatProc
  00a9a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00a9d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00aa0	75 0e		 jne	 SHORT $LN149@PChatProc
  00aa2	83 c0 02	 add	 eax, 2
  00aa5	83 c1 02	 add	 ecx, 2
  00aa8	84 d2		 test	 dl, dl
  00aaa	75 e4		 jne	 SHORT $LL148@PChatProc
$LN150@PChatProc:
  00aac	33 c0		 xor	 eax, eax
  00aae	eb 05		 jmp	 SHORT $LN151@PChatProc
$LN149@PChatProc:
  00ab0	1b c0		 sbb	 eax, eax
  00ab2	83 d8 ff	 sbb	 eax, -1
$LN151@PChatProc:
  00ab5	85 c0		 test	 eax, eax
  00ab7	75 15		 jne	 SHORT $LN34@PChatProc

; 2437 : 										{
; 2438 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00ab9	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00abf	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00ac3	51		 push	 ecx
  00ac4	50		 push	 eax
  00ac5	53		 push	 ebx
  00ac6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00acb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@PChatProc:

; 2424 : 							continue;
; 2425 : 
; 2426 : 						for (n=0;n<MAX_USER_GUILD;n++)

  00ace	83 85 f0 fd ff
	ff 02		 add	 DWORD PTR tv1550[ebp], 2
  00ad5	47		 inc	 edi
  00ad6	83 c6 0b	 add	 esi, 11			; 0000000bH
  00ad9	83 ff 50	 cmp	 edi, 80			; 00000050H
  00adc	0f 8c 6e ff ff
	ff		 jl	 $LL35@PChatProc
$LN38@PChatProc:

; 2417 : 					}
; 2418 : #endif
; 2419 : 					for ( int i=0;i<iGuildCount;i++)

  00ae2	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _i$245077[ebp]
  00ae8	40		 inc	 eax
  00ae9	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _i$245077[ebp], eax
  00aef	3b 85 f4 fd ff
	ff		 cmp	 eax, DWORD PTR _iGuildCount$245072[ebp]
  00af5	0f 8c 15 ff ff
	ff		 jl	 $LL39@PChatProc
$LN165@PChatProc:

; 2439 : 										}
; 2440 : 									}
; 2441 : 								}
; 2442 : 							}
; 2443 : 						}
; 2444 : 					}
; 2445 : 				}
; 2446 : 
; 2447 : 				if ( g_iServerGroupUnionChatting == TRUE )

  00afb	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_iServerGroupUnionChatting@@3HA, 1 ; g_iServerGroupUnionChatting
  00b02	0f 85 a3 03 00
	00		 jne	 $LN169@PChatProc

; 2448 : 					GDUnionServerGroupChattingSend(lpObj->lpGuild->iGuildUnion, lpChat);

  00b08	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b0e	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpChat$GSCopy$[ebp]
  00b14	8b 88 38 04 00
	00		 mov	 ecx, DWORD PTR [eax+1080]
  00b1a	52		 push	 edx
  00b1b	8b 91 1c 07 00
	00		 mov	 edx, DWORD PTR [ecx+1820]
  00b21	52		 push	 edx
  00b22	e8 00 00 00 00	 call	 ?GDUnionServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z ; GDUnionServerGroupChattingSend
  00b27	83 c4 08	 add	 esp, 8
  00b2a	5b		 pop	 ebx
  00b2b	5f		 pop	 edi
  00b2c	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00b2d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b30	33 cd		 xor	 ecx, ebp
  00b32	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b37	8b e5		 mov	 esp, ebp
  00b39	5d		 pop	 ebp
  00b3a	c3		 ret	 0
$LN42@PChatProc:

; 2449 : 			}
; 2450 : 			// Just Guild
; 2451 : 			else
; 2452 : 			{
; 2453 : 				int count = lpObj->lpGuild->Count;
; 2454 : 
; 2455 : 				if ( count >= 0 )
; 2456 : 				{
; 2457 : 					for ( n=0;n<MAX_USER_GUILD;n++)

  00b3b	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00b45	33 db		 xor	 ebx, ebx
  00b47	bf a0 03 00 00	 mov	 edi, 928		; 000003a0H
  00b4c	8d 64 24 00	 npad	 4
$LL25@PChatProc:

; 2458 : 					{
; 2459 : 						if ( lpObj->lpGuild->Use[n] )

  00b50	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b56	8b 80 38 04 00
	00		 mov	 eax, DWORD PTR [eax+1080]
  00b5c	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00b62	80 bc 08 40 04
	00 00 00	 cmp	 BYTE PTR [eax+ecx+1088], 0
  00b6a	74 62		 je	 SHORT $LN24@PChatProc

; 2460 : 							{
; 2461 : 								number = lpObj->lpGuild->Index[n];

  00b6c	0f bf 34 07	 movsx	 esi, WORD PTR [edi+eax]

; 2462 : 
; 2463 : 								if ( number >= 0 )

  00b70	85 f6		 test	 esi, esi
  00b72	78 5a		 js	 SHORT $LN24@PChatProc

; 2464 : 								{
; 2465 : 									if ( lpObj->lpGuild->Names[n][0] == gObj[number].Name[0] )

  00b74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b7a	8b d6		 mov	 edx, esi
  00b7c	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00b82	8d 44 03 2f	 lea	 eax, DWORD PTR [ebx+eax+47]
  00b86	8d 4c 0a 77	 lea	 ecx, DWORD PTR [edx+ecx+119]
  00b8a	8a 10		 mov	 dl, BYTE PTR [eax]
  00b8c	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00b8e	75 3e		 jne	 SHORT $LN24@PChatProc
$LL152@PChatProc:

; 2466 : 									{
; 2467 : 										if ( !strcmp(lpObj->lpGuild->Names[n], gObj[number].Name ) )

  00b90	8a 10		 mov	 dl, BYTE PTR [eax]
  00b92	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00b94	75 1a		 jne	 SHORT $LN153@PChatProc
  00b96	84 d2		 test	 dl, dl
  00b98	74 12		 je	 SHORT $LN154@PChatProc
  00b9a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00b9d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00ba0	75 0e		 jne	 SHORT $LN153@PChatProc
  00ba2	83 c0 02	 add	 eax, 2
  00ba5	83 c1 02	 add	 ecx, 2
  00ba8	84 d2		 test	 dl, dl
  00baa	75 e4		 jne	 SHORT $LL152@PChatProc
$LN154@PChatProc:
  00bac	33 c0		 xor	 eax, eax
  00bae	eb 05		 jmp	 SHORT $LN155@PChatProc
$LN153@PChatProc:
  00bb0	1b c0		 sbb	 eax, eax
  00bb2	83 d8 ff	 sbb	 eax, -1
$LN155@PChatProc:
  00bb5	85 c0		 test	 eax, eax
  00bb7	75 15		 jne	 SHORT $LN24@PChatProc

; 2468 : 										{
; 2469 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00bb9	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _lpChat$GSCopy$[ebp]
  00bbf	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00bc3	51		 push	 ecx
  00bc4	50		 push	 eax
  00bc5	56		 push	 esi
  00bc6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00bcb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@PChatProc:

; 2449 : 			}
; 2450 : 			// Just Guild
; 2451 : 			else
; 2452 : 			{
; 2453 : 				int count = lpObj->lpGuild->Count;
; 2454 : 
; 2455 : 				if ( count >= 0 )
; 2456 : 				{
; 2457 : 					for ( n=0;n<MAX_USER_GUILD;n++)

  00bce	ff 85 f0 fd ff
	ff		 inc	 DWORD PTR _n$[ebp]
  00bd4	83 c7 02	 add	 edi, 2
  00bd7	83 c3 0b	 add	 ebx, 11			; 0000000bH
  00bda	81 ff 40 04 00
	00		 cmp	 edi, 1088		; 00000440H
  00be0	0f 8c 6a ff ff
	ff		 jl	 $LL25@PChatProc

; 2470 : 										}
; 2471 : 									}
; 2472 : 								}
; 2473 : 							}
; 2474 : 						}
; 2475 : 				}
; 2476 : 
; 2477 : 				if ( g_iServerGroupGuildChatting == TRUE )

  00be6	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_iServerGroupGuildChatting@@3HA, 1 ; g_iServerGroupGuildChatting

; 2478 : 				{
; 2479 : 					if ( lpObj->lpGuild->Count > 1 )

  00bed	8b b5 fc fd ff
	ff		 mov	 esi, DWORD PTR _lpObj$[ebp]
  00bf3	75 1e		 jne	 SHORT $LN17@PChatProc
  00bf5	8b 86 38 04 00
	00		 mov	 eax, DWORD PTR [esi+1080]
  00bfb	80 78 2d 01	 cmp	 BYTE PTR [eax+45], 1
  00bff	76 12		 jbe	 SHORT $LN17@PChatProc

; 2480 : 					{
; 2481 : 						GDGuildServerGroupChattingSend(lpObj->lpGuild->Number, lpChat);

  00c01	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR _lpChat$GSCopy$[ebp]
  00c07	8b 00		 mov	 eax, DWORD PTR [eax]
  00c09	52		 push	 edx
  00c0a	50		 push	 eax
  00c0b	e8 00 00 00 00	 call	 ?GDGuildServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z ; GDGuildServerGroupChattingSend
  00c10	83 c4 08	 add	 esp, 8
$LN17@PChatProc:

; 2482 : 					}
; 2483 : 				}
; 2484 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2485 : 				if ( gWriteChatLog && g_ZtLicense.user.ChatLog )

  00c13	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00c1a	0f 84 8b 02 00
	00		 je	 $LN169@PChatProc
  00c20	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  00c27	0f 84 7e 02 00
	00		 je	 $LN169@PChatProc

; 2486 : 				{
; 2487 : 					g_GuildChatLog.Output("[%s] [%s] [%s] %s", lpObj->AccountID, lpObj->Name, lpObj->GuildName, &lpChat->chatmsg[1]);

  00c2d	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv1128[ebp]
  00c33	51		 push	 ecx
  00c34	8d 96 3c 04 00
	00		 lea	 edx, DWORD PTR [esi+1084]
  00c3a	52		 push	 edx
  00c3b	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00c3e	50		 push	 eax
  00c3f	83 c6 6c	 add	 esi, 108		; 0000006cH
  00c42	56		 push	 esi
  00c43	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OHBNELPC@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  00c48	68 00 00 00 00	 push	 OFFSET ?g_GuildChatLog@@3VCLogToFile@@A ; g_GuildChatLog
  00c4d	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00c52	83 c4 18	 add	 esp, 24			; 00000018H
  00c55	5b		 pop	 ebx
  00c56	5f		 pop	 edi
  00c57	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00c58	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c5b	33 cd		 xor	 ecx, ebp
  00c5d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c62	8b e5		 mov	 esp, ebp
  00c64	5d		 pop	 ebp
  00c65	c3		 ret	 0
$LN48@PChatProc:

; 2488 : 				}
; 2489 : #endif
; 2490 : 
; 2491 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2492 : 				if ( gWriteChatLog )
; 2493 : 				{
; 2494 : 					memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 2495 : 					pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2496 : 					pChatMsg.btType = 0x02;
; 2497 : 				}
; 2498 : #endif
; 2499 : 
; 2500 : 			}
; 2501 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2502 : 			if ( gWriteChatLog )
; 2503 : 			{
; 2504 : 				strcpy(pChatMsg.szTargetName[szTargetNameCount], lpObj->GuildName);
; 2505 : 				szTargetNameCount++;
; 2506 : 			}
; 2507 : #endif
; 2508 : 		}
; 2509 : 	}
; 2510 : 	//-> 1.01.00, but names are not compared
; 2511 : 	else if( lpChat->chatmsg[0] == '$' )

  00c66	3c 24		 cmp	 al, 36			; 00000024H
  00c68	0f 85 0c 01 00
	00		 jne	 $LN14@PChatProc

; 2512 : 	{
; 2513 : 		if (gGENS)

  00c6e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  00c75	0f 84 30 02 00
	00		 je	 $LN169@PChatProc

; 2514 : 		{
; 2515 : 			if( lpObj->m_GensInfluence == 1 
; 2516 : 				|| lpObj->m_GensInfluence == 2 
; 2517 : 				&& lpObj->Money >= gGensSystem.ChatPrice )

  00c7b	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c81	8b 82 c4 22 00
	00		 mov	 eax, DWORD PTR [edx+8900]
  00c87	8b 0d b4 00 00
	00		 mov	 ecx, DWORD PTR ?gGensSystem@@3VGensSystem@@A+180
  00c8d	83 f8 01	 cmp	 eax, 1
  00c90	74 15		 je	 SHORT $LN11@PChatProc
  00c92	83 f8 02	 cmp	 eax, 2
  00c95	0f 85 10 02 00
	00		 jne	 $LN169@PChatProc
  00c9b	39 8a f0 00 00
	00		 cmp	 DWORD PTR [edx+240], ecx
  00ca1	0f 8c 04 02 00
	00		 jl	 $LN169@PChatProc
$LN11@PChatProc:

; 2518 : 			{
; 2519 : 				if( gGensSystem.ChatPrice > 0 )

  00ca7	85 c9		 test	 ecx, ecx
  00ca9	7e 18		 jle	 SHORT $LN10@PChatProc

; 2520 : 				{
; 2521 : 					lpObj->Money -= gGensSystem.ChatPrice;

  00cab	29 8a f0 00 00
	00		 sub	 DWORD PTR [edx+240], ecx
  00cb1	8b 82 f0 00 00
	00		 mov	 eax, DWORD PTR [edx+240]

; 2522 : 					GCMoneySend(lpObj->m_Index, lpObj->Money);

  00cb7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00cb9	50		 push	 eax
  00cba	51		 push	 ecx
  00cbb	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00cc0	83 c4 08	 add	 esp, 8
$LN10@PChatProc:

; 2523 : 				}
; 2524 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2525 : 				if ( gWriteChatLog && g_ZtLicense.user.ChatLog )

  00cc3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00cca	74 41		 je	 SHORT $LN160@PChatProc
  00ccc	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  00cd3	74 38		 je	 SHORT $LN160@PChatProc

; 2526 : 				{
; 2527 : 					g_GensChatLog.Output("[%s] [%s] [%s] %s", lpObj->AccountID, lpObj->Name, gGensSystem.GetGensInfluenceName(lpObj), &lpChat->chatmsg[1]);

  00cd5	8b bd f8 fd ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  00cdb	8b b5 fc fd ff
	ff		 mov	 esi, DWORD PTR _lpObj$[ebp]
  00ce1	8d 57 0e	 lea	 edx, DWORD PTR [edi+14]
  00ce4	52		 push	 edx
  00ce5	56		 push	 esi
  00ce6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00ceb	e8 00 00 00 00	 call	 ?GetGensInfluenceName@GensSystem@@QAEPADPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluenceName
  00cf0	50		 push	 eax
  00cf1	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00cf4	50		 push	 eax
  00cf5	83 c6 6c	 add	 esi, 108		; 0000006cH
  00cf8	56		 push	 esi
  00cf9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OHBNELPC@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  00cfe	68 00 00 00 00	 push	 OFFSET ?g_GensChatLog@@3VCLogToFile@@A ; g_GensChatLog
  00d03	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00d08	83 c4 18	 add	 esp, 24			; 00000018H
  00d0b	eb 06		 jmp	 SHORT $LN9@PChatProc
$LN160@PChatProc:
  00d0d	8b bd f8 fd ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
$LN9@PChatProc:

; 2528 : 				}
; 2529 : #endif
; 2530 : 
; 2531 : 				// ----
; 2532 : 				for( int i = OBJ_STARTUSERINDZT; i < OBJMAX; i++ )

  00d13	be 00 a7 40 09	 mov	 esi, 155232000		; 0940a700H
  00d18	bb 03 00 00 00	 mov	 ebx, 3
  00d1d	8d 49 00	 npad	 3
$LL8@PChatProc:

; 2533 : 				{
; 2534 : 					LPOBJ GensTarget = &gObj[i];

  00d20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d26	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]

; 2535 : 					// ----
; 2536 : 					if( !GensTarget )

  00d29	85 c0		 test	 eax, eax
  00d2b	0f 84 7a 01 00
	00		 je	 $LN169@PChatProc

; 2537 : 					{
; 2538 : 						break;
; 2539 : 					}
; 2540 : 					// ----
; 2541 : 					if( GensTarget->Connected == 3 && GensTarget->m_GensInfluence == lpObj->m_GensInfluence )

  00d31	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00d34	75 25		 jne	 SHORT $LN7@PChatProc
  00d36	8b 90 c4 22 00
	00		 mov	 edx, DWORD PTR [eax+8900]
  00d3c	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d42	3b 91 c4 22 00
	00		 cmp	 edx, DWORD PTR [ecx+8900]
  00d48	75 11		 jne	 SHORT $LN7@PChatProc

; 2542 : 					{
; 2543 : 						DataSend(GensTarget->m_Index, (LPBYTE)lpChat, lpChat->h.size);

  00d4a	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]
  00d4e	8b 00		 mov	 eax, DWORD PTR [eax]
  00d50	52		 push	 edx
  00d51	57		 push	 edi
  00d52	50		 push	 eax
  00d53	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00d58	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@PChatProc:

; 2528 : 				}
; 2529 : #endif
; 2530 : 
; 2531 : 				// ----
; 2532 : 				for( int i = OBJ_STARTUSERINDZT; i < OBJMAX; i++ )

  00d5b	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H
  00d61	81 fe 80 d7 e9
	09		 cmp	 esi, 166320000		; 09e9d780H
  00d67	7c b7		 jl	 SHORT $LL8@PChatProc
  00d69	5b		 pop	 ebx
  00d6a	5f		 pop	 edi
  00d6b	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00d6c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d6f	33 cd		 xor	 ecx, ebp
  00d71	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d76	8b e5		 mov	 esp, ebp
  00d78	5d		 pop	 ebp
  00d79	c3		 ret	 0
$LN14@PChatProc:

; 2544 : 					}
; 2545 : 				}
; 2546 : 			}
; 2547 : 			// ----
; 2548 : 			//GDGensServerGroupChattingSend(lpObj->m_GensInfluence, lpChat);	//-> Work with ZtDB, i think not need...
; 2549 : 		}
; 2550 : 	}
; 2551 : 	else
; 2552 : 	{
; 2553 : 		if(((lpObj->Authority&32)==32) && gObjSearchActiveEffect(lpObj, AT_INVISIBILITY) != FALSE) //season 2.5 add-on

  00d7a	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d80	f6 81 0c 02 00
	00 20		 test	 BYTE PTR [ecx+524], 32	; 00000020H
  00d87	74 15		 je	 SHORT $LN2@PChatProc
  00d89	8b d1		 mov	 edx, ecx
  00d8b	6a 12		 push	 18			; 00000012H
  00d8d	52		 push	 edx
  00d8e	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00d93	83 c4 08	 add	 esp, 8
  00d96	84 c0		 test	 al, al
  00d98	0f 85 0d 01 00
	00		 jne	 $LN169@PChatProc
$LN2@PChatProc:

; 2554 : 		{
; 2555 : 			return;
; 2556 : 		}
; 2557 : 
; 2558 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  00d9e	8b b5 f8 fd ff
	ff		 mov	 esi, DWORD PTR _lpChat$GSCopy$[ebp]
  00da4	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00da8	50		 push	 eax
  00da9	56		 push	 esi
  00daa	57		 push	 edi
  00dab	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2559 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);

  00db0	0f b6 4e 01	 movzx	 ecx, BYTE PTR [esi+1]
  00db4	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00dba	51		 push	 ecx
  00dbb	56		 push	 esi
  00dbc	52		 push	 edx
  00dbd	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00dc2	83 c4 18	 add	 esp, 24			; 00000018H

; 2560 : 
; 2561 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2562 : 		if ( gWriteChatLog && g_ZtLicense.user.ChatLog )

  00dc5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00dcc	0f 84 d9 00 00
	00		 je	 $LN169@PChatProc
  00dd2	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  00dd9	0f 84 cc 00 00
	00		 je	 $LN169@PChatProc

; 2563 : 		{
; 2564 : 			g_OtherChatLog.Output("[%s] [%s] %s", lpObj->AccountID, lpObj->Name, lpChat->chatmsg);

  00ddf	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de5	53		 push	 ebx
  00de6	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00de9	51		 push	 ecx
  00dea	83 c0 6c	 add	 eax, 108		; 0000006cH
  00ded	50		 push	 eax
  00dee	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  00df3	68 00 00 00 00	 push	 OFFSET ?g_OtherChatLog@@3VCLogToFile@@A ; g_OtherChatLog
  00df8	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00dfd	83 c4 14	 add	 esp, 20			; 00000014H
  00e00	5b		 pop	 ebx
  00e01	5f		 pop	 edi
  00e02	5e		 pop	 esi

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00e03	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e06	33 cd		 xor	 ecx, ebp
  00e08	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e0d	8b e5		 mov	 esp, ebp
  00e0f	5d		 pop	 ebp
  00e10	c3		 ret	 0
$LN57@PChatProc:

; 2338 : 	{
; 2339 : 		if ( lpObj->PartyNumber >= 0 )

  00e11	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00e17	8b 82 2c 04 00
	00		 mov	 eax, DWORD PTR [edx+1068]
  00e1d	85 c0		 test	 eax, eax
  00e1f	0f 88 86 00 00
	00		 js	 $LN169@PChatProc

; 2340 : 		{
; 2341 : 			int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  00e25	50		 push	 eax
  00e26	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00e2b	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 2342 : 
; 2343 : 			if ( partycount >= 0 )

  00e30	85 c0		 test	 eax, eax
  00e32	78 77		 js	 SHORT $LN169@PChatProc

; 2344 : 			{
; 2345 : 
; 2346 : #if(CUSTOM_CHAT_LOG==TRUE)
; 2347 : 				if ( gWriteChatLog && g_ZtLicense.user.ChatLog )

  00e34	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00e3b	74 35		 je	 SHORT $LN161@PChatProc
  00e3d	80 3d d6 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+214, 0
  00e44	74 2c		 je	 SHORT $LN161@PChatProc

; 2348 : 				{
; 2349 : 					g_PartyChatLog.Output("[%s] [%s] %s", lpObj->AccountID, lpObj->Name, &lpChat->chatmsg[1]);

  00e46	8b bd f8 fd ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  00e4c	8b 9d fc fd ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00e52	8d 47 0e	 lea	 eax, DWORD PTR [edi+14]
  00e55	50		 push	 eax
  00e56	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00e59	51		 push	 ecx
  00e5a	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00e5d	52		 push	 edx
  00e5e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HFNLKKFA@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$CFs?$AA@
  00e63	68 00 00 00 00	 push	 OFFSET ?g_PartyChatLog@@3VCLogToFile@@A ; g_PartyChatLog
  00e68	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00e6d	83 c4 14	 add	 esp, 20			; 00000014H
  00e70	eb 0c		 jmp	 SHORT $LN54@PChatProc
$LN161@PChatProc:
  00e72	8b bd f8 fd ff
	ff		 mov	 edi, DWORD PTR _lpChat$GSCopy$[ebp]
  00e78	8b 9d fc fd ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
$LN54@PChatProc:

; 2350 : 				}
; 2351 : #endif
; 2352 : 
; 2353 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2354 : 				if ( gWriteChatLog )
; 2355 : 				{
; 2356 : 					memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 2357 : 					pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2358 : 					pChatMsg.btType = 0x01;
; 2359 : 				}
; 2360 : #endif
; 2361 : 				for (n=0;n<MAX_USER_IN_PARTY;n++ )

  00e7e	33 f6		 xor	 esi, esi
$LL168@PChatProc:

; 2362 : 				{
; 2363 : 					number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  00e80	8b 83 2c 04 00
	00		 mov	 eax, DWORD PTR [ebx+1068]
  00e86	6b c0 1a	 imul	 eax, 26			; 0000001aH
  00e89	03 c6		 add	 eax, esi
  00e8b	8b 04 85 0c 00
	00 00		 mov	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]

; 2364 : 
; 2365 : 					if ( number >= 0 )

  00e92	85 c0		 test	 eax, eax
  00e94	78 0f		 js	 SHORT $LN52@PChatProc

; 2366 : 					{
; 2367 : 						DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00e96	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  00e9a	51		 push	 ecx
  00e9b	57		 push	 edi
  00e9c	50		 push	 eax
  00e9d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00ea2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@PChatProc:

; 2350 : 				}
; 2351 : #endif
; 2352 : 
; 2353 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2354 : 				if ( gWriteChatLog )
; 2355 : 				{
; 2356 : 					memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 2357 : 					pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2358 : 					pChatMsg.btType = 0x01;
; 2359 : 				}
; 2360 : #endif
; 2361 : 				for (n=0;n<MAX_USER_IN_PARTY;n++ )

  00ea5	46		 inc	 esi
  00ea6	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00ea9	7c d5		 jl	 SHORT $LL168@PChatProc
$LN169@PChatProc:
  00eab	5b		 pop	 ebx
$LN51@PChatProc:

; 2565 : 		}
; 2566 : #endif
; 2567 : 
; 2568 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2569 : 		if ( gWriteChatLog )
; 2570 : 		{
; 2571 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT_LEN);
; 2572 : 			pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 2573 : 			pChatMsg.btType = 0x00;
; 2574 : 		}
; 2575 : #endif
; 2576 : 	}
; 2577 : #if(CUSTOM_CHAT_LOG==FALSE)
; 2578 : 	if ( gWriteChatLog )
; 2579 : 	{
; 2580 : 		if ( pChatMsg.btType != 0xFF )
; 2581 : 		{
; 2582 : 			pChatMsg.btType |= szTargetNameCount<<4;
; 2583 : 			pChatMsg.h.size = sizeof(pChatMsg) - (5 - szTargetNameCount) - 1;
; 2584 : 
; 2585 : 			if ( gWriteChatLog )
; 2586 : 			{
; 2587 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);
; 2588 : 			}
; 2589 : 		}
; 2590 : 	}
; 2591 : #endif
; 2592 : }

  00eac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00eaf	5f		 pop	 edi
  00eb0	33 cd		 xor	 ecx, ebp
  00eb2	5e		 pop	 esi
  00eb3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00eb8	8b e5		 mov	 esp, ebp
  00eba	5d		 pop	 ebp
  00ebb	c3		 ret	 0
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ENDP		; PChatProc
_TEXT	ENDS
PUBLIC	??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z	; CSPJoinIdPassRequest
EXTRN	?ConnectUser@cOffTrade@@QAEXPAD@Z:PROC		; cOffTrade::ConnectUser
EXTRN	?gOffTrade@@3VcOffTrade@@A:BYTE			; gOffTrade
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?GJPUserClose@@YAXPAD@Z:PROC			; GJPUserClose
EXTRN	?GDReqUpdateStatus@OfflineMode@@QAEXH@Z:PROC	; OfflineMode::GDReqUpdateStatus
EXTRN	?g_OfflineMode@@3VOfflineMode@@A:BYTE		; g_OfflineMode
EXTRN	?GD_OfflineAfk@CZtGDManager@@QAEXHEE@Z:PROC	; CZtGDManager::GD_OfflineAfk
EXTRN	?g_ZtGDManager@@3VCZtGDManager@@A:BYTE		; g_ZtGDManager
EXTRN	_strncmp:PROC
EXTRN	?IsMember@CConMember@@QAEHPAD@Z:PROC		; CConMember::IsMember
EXTRN	?ConMember@@3VCConMember@@A:BYTE		; ConMember
EXTRN	?bCanConnectMember@@3HA:DWORD			; bCanConnectMember
EXTRN	?szGameServerExeSerial@@3PADA:BYTE		; szGameServerExeSerial
;	COMDAT ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ DB 'join send '
	DB	': (%d)%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ DB 'error : %d %s '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@ DB 'e'
	DB	'rror-L1: Serial error [%s] [%s]', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
tv809 = -144						; size = 4
_lpObj$ = -140						; size = 4
_aIndex$GSCopy$ = -136					; size = 4
_i$245236 = -132					; size = 4
_i$245227 = -132					; size = 4
_spMsg$ = -128						; size = 44
_pass$245255 = -84					; size = 21
_serial$ = -60						; size = 17
_pass$ = -40						; size = 21
_id$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequest, COMDAT

; 2793 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2794 : 	char serial[17];
; 2795 : 	char id[11];
; 2796 : 
; 2797 : 	if ( lpMsg->CliVersion[0] != szClientVersion[0] ||
; 2798 : 		 lpMsg->CliVersion[1] != szClientVersion[1] ||
; 2799 : 		 lpMsg->CliVersion[2] != szClientVersion[2] ||
; 2800 : 		 lpMsg->CliVersion[3] != szClientVersion[3] ||
; 2801 : 		 lpMsg->CliVersion[4] != szClientVersion[4] )

  00013	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA
  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00022	0f b6 47 1c	 movzx	 eax, BYTE PTR [edi+28]

; 2857 : 						{
; 2858 : 							g_ZtGDManager.GD_OfflineAfk(i, 0, 0);

  00026	89 b5 78 ff ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002c	3b c1		 cmp	 eax, ecx
  0002e	0f 85 d1 06 00
	00		 jne	 $LN24@CSPJoinIdP@2

; 2794 : 	char serial[17];
; 2795 : 	char id[11];
; 2796 : 
; 2797 : 	if ( lpMsg->CliVersion[0] != szClientVersion[0] ||
; 2798 : 		 lpMsg->CliVersion[1] != szClientVersion[1] ||
; 2799 : 		 lpMsg->CliVersion[2] != szClientVersion[2] ||
; 2800 : 		 lpMsg->CliVersion[3] != szClientVersion[3] ||
; 2801 : 		 lpMsg->CliVersion[4] != szClientVersion[4] )

  00034	0f b6 57 1d	 movzx	 edx, BYTE PTR [edi+29]
  00038	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  0003f	3b d0		 cmp	 edx, eax
  00041	0f 85 be 06 00
	00		 jne	 $LN24@CSPJoinIdP@2
  00047	0f b6 4f 1e	 movzx	 ecx, BYTE PTR [edi+30]
  0004b	0f be 15 02 00
	00 00		 movsx	 edx, BYTE PTR ?szClientVersion@@3PADA+2
  00052	3b ca		 cmp	 ecx, edx
  00054	0f 85 ab 06 00
	00		 jne	 $LN24@CSPJoinIdP@2
  0005a	0f b6 47 1f	 movzx	 eax, BYTE PTR [edi+31]
  0005e	0f be 0d 03 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA+3
  00065	3b c1		 cmp	 eax, ecx
  00067	0f 85 98 06 00
	00		 jne	 $LN24@CSPJoinIdP@2
  0006d	0f b6 57 20	 movzx	 edx, BYTE PTR [edi+32]
  00071	0f be 05 04 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  00078	3b d0		 cmp	 edx, eax
  0007a	0f 85 85 06 00
	00		 jne	 $LN24@CSPJoinIdP@2

; 2805 : 		return;
; 2806 : 	}
; 2807 : 
; 2808 : 	serial[16] = 0;
; 2809 : 	memcpy(serial, lpMsg->CliSerial, sizeof(lpMsg->CliSerial));

  00080	8b 57 25	 mov	 edx, DWORD PTR [edi+37]
  00083	8b 4f 21	 mov	 ecx, DWORD PTR [edi+33]
  00086	8b 47 29	 mov	 eax, DWORD PTR [edi+41]
  00089	89 55 c8	 mov	 DWORD PTR _serial$[ebp+4], edx

; 2810 : 	id[10]=0;
; 2811 : 	memcpy(id, lpMsg->Id, sizeof(lpMsg->Id));

  0008c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0008f	89 4d c4	 mov	 DWORD PTR _serial$[ebp], ecx
  00092	8b 4f 2d	 mov	 ecx, DWORD PTR [edi+45]
  00095	89 55 f0	 mov	 DWORD PTR _id$[ebp], edx
  00098	89 45 cc	 mov	 DWORD PTR _serial$[ebp+8], eax
  0009b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0009e	89 4d d0	 mov	 DWORD PTR _serial$[ebp+12], ecx
  000a1	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]

; 2812 : 	BuxConvert(id, MAX_ACCOUNT_LEN);

  000a5	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  000a8	6a 0a		 push	 10			; 0000000aH
  000aa	52		 push	 edx
  000ab	c6 45 d4 00	 mov	 BYTE PTR _serial$[ebp+16], 0
  000af	c6 45 fa 00	 mov	 BYTE PTR _id$[ebp+10], 0
  000b3	89 45 f4	 mov	 DWORD PTR _id$[ebp+4], eax
  000b6	66 89 4d f8	 mov	 WORD PTR _id$[ebp+8], cx
  000ba	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000bf	83 c4 08	 add	 esp, 8

; 2813 : 
; 2814 : 
; 2815 : 
; 2816 : 	if ( strcmp(serial, szGameServerExeSerial) != 0 )

  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  000c7	8d 45 c4	 lea	 eax, DWORD PTR _serial$[ebp]
  000ca	8d 9b 00 00 00
	00		 npad	 6
$LL36@CSPJoinIdP@2:
  000d0	8a 10		 mov	 dl, BYTE PTR [eax]
  000d2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000d4	75 1a		 jne	 SHORT $LN37@CSPJoinIdP@2
  000d6	84 d2		 test	 dl, dl
  000d8	74 12		 je	 SHORT $LN38@CSPJoinIdP@2
  000da	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000dd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000e0	75 0e		 jne	 SHORT $LN37@CSPJoinIdP@2
  000e2	83 c0 02	 add	 eax, 2
  000e5	83 c1 02	 add	 ecx, 2
  000e8	84 d2		 test	 dl, dl
  000ea	75 e4		 jne	 SHORT $LL36@CSPJoinIdP@2
$LN38@CSPJoinIdP@2:
  000ec	33 c0		 xor	 eax, eax
  000ee	eb 05		 jmp	 SHORT $LN39@CSPJoinIdP@2
$LN37@CSPJoinIdP@2:
  000f0	1b c0		 sbb	 eax, eax
  000f2	83 d8 ff	 sbb	 eax, -1
$LN39@CSPJoinIdP@2:
  000f5	85 c0		 test	 eax, eax
  000f7	74 36		 je	 SHORT $LN23@CSPJoinIdP@2

; 2817 : 	{
; 2818 : 		LogAddC(2, "error-L1: Serial error [%s] [%s]", id, serial);

  000f9	8d 45 c4	 lea	 eax, DWORD PTR _serial$[ebp]
  000fc	50		 push	 eax
  000fd	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  00100	51		 push	 ecx
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
  00106	6a 02		 push	 2
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2819 : 		GCJoinResult(JS_BAD_CLIENT_VERSION, aIndex);

  0010e	56		 push	 esi
  0010f	6a 06		 push	 6
  00111	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult

; 2820 : 		CloseClient(aIndex);

  00116	56		 push	 esi
  00117	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0011c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi

; 2984 : 	lpObj->m_btDestY = 0;
; 2985 : }

  00121	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
$LN23@CSPJoinIdP@2:

; 2821 : 		return;
; 2822 : 	}
; 2823 : 
; 2824 : 
; 2825 : 
; 2826 : 	
; 2827 : 	if ( bCanConnectMember == TRUE )

  0012f	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanConnectMember@@3HA, 1 ; bCanConnectMember
  00136	75 2d		 jne	 SHORT $LN21@CSPJoinIdP@2

; 2828 : 	{
; 2829 : 		if ( ConMember.IsMember(id) == FALSE )

  00138	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  0013b	52		 push	 edx
  0013c	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  00141	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  00146	85 c0		 test	 eax, eax
  00148	75 1b		 jne	 SHORT $LN21@CSPJoinIdP@2

; 2830 : 		{
; 2831 : 			GCJoinResult(JS_ONLY_VIP_MEMBERS, aIndex);

  0014a	56		 push	 esi
  0014b	6a 02		 push	 2
  0014d	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  00152	83 c4 08	 add	 esp, 8
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi

; 2984 : 	lpObj->m_btDestY = 0;
; 2985 : }

  00157	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015a	33 cd		 xor	 ecx, ebp
  0015c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
$LN21@CSPJoinIdP@2:

; 2832 : 			return;
; 2833 : 		}
; 2834 : 	}
; 2835 : 
; 2836 : 	LPOBJ lpObj = &gObj[aIndex];

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H

; 2837 : 
; 2838 : 	char pass[20+1];
; 2839 : 	memset(pass, 0, sizeof(pass));
; 2840 : 	memcpy(pass, lpMsg->Pass, sizeof(lpMsg->Pass));

  00170	8b 57 0e	 mov	 edx, DWORD PTR [edi+14]
  00173	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00176	33 c0		 xor	 eax, eax
  00178	89 45 d8	 mov	 DWORD PTR _pass$[ebp], eax
  0017b	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], ecx
  00181	0f b7 4f 16	 movzx	 ecx, WORD PTR [edi+22]
  00185	89 45 dc	 mov	 DWORD PTR _pass$[ebp+4], eax
  00188	89 45 e0	 mov	 DWORD PTR _pass$[ebp+8], eax
  0018b	89 55 d8	 mov	 DWORD PTR _pass$[ebp], edx
  0018e	89 45 e4	 mov	 DWORD PTR _pass$[ebp+12], eax
  00191	89 45 e8	 mov	 DWORD PTR _pass$[ebp+16], eax
  00194	88 45 ec	 mov	 BYTE PTR _pass$[ebp+20], al
  00197	8b 47 12	 mov	 eax, DWORD PTR [edi+18]

; 2841 : 	BuxConvert(pass, MAX_ACCOUNT_LEN);

  0019a	8d 55 d8	 lea	 edx, DWORD PTR _pass$[ebp]
  0019d	6a 0a		 push	 10			; 0000000aH
  0019f	52		 push	 edx
  001a0	89 45 dc	 mov	 DWORD PTR _pass$[ebp+4], eax
  001a3	66 89 4d e0	 mov	 WORD PTR _pass$[ebp+8], cx
  001a7	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2842 : 	memcpy(gObj[aIndex].Pass, pass, MAX_ACCOUNT_LEN);

  001ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b1	8b 4d d8	 mov	 ecx, DWORD PTR _pass$[ebp]
  001b4	8d 84 06 82 00
	00 00		 lea	 eax, DWORD PTR [esi+eax+130]
  001bb	89 08		 mov	 DWORD PTR [eax], ecx
  001bd	8b 55 dc	 mov	 edx, DWORD PTR _pass$[ebp+4]
  001c0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001c3	0f b7 4d e0	 movzx	 ecx, WORD PTR _pass$[ebp+8]
  001c7	66 89 48 08	 mov	 WORD PTR [eax+8], cx
  001cb	83 c4 08	 add	 esp, 8
  001ce	b8 80 76 97 08	 mov	 eax, 144144000		; 08977680H

; 2843 : 
; 2844 : #if(OFFLINE_MODE == TRUE)
; 2845 : 	for(int i = OBJ_MAXMONSTER; i < OBJMAX;i++)

  001d3	c7 85 7c ff ff
	ff c8 32 00 00	 mov	 DWORD PTR _i$245227[ebp], 13000 ; 000032c8H
  001dd	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv809[ebp], eax
  001e3	53		 push	 ebx
  001e4	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL20@CSPJoinIdP@2:

; 2846 : 	{
; 2847 : 		LPOBJ sObj = &gObj[i];

  001f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2848 : 		if(sObj->Connected == PLAYER_PLAYING)

  001f6	83 7c 10 04 03	 cmp	 DWORD PTR [eax+edx+4], 3
  001fb	8d 1c 10	 lea	 ebx, DWORD PTR [eax+edx]
  001fe	75 24		 jne	 SHORT $LN19@CSPJoinIdP@2

; 2849 : 		{
; 2850 : 			if(id[0] == sObj->AccountID[0])

  00200	8a 55 f0	 mov	 dl, BYTE PTR _id$[ebp]
  00203	3a 53 6c	 cmp	 dl, BYTE PTR [ebx+108]
  00206	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00209	75 19		 jne	 SHORT $LN19@CSPJoinIdP@2

; 2851 : 			{
; 2852 : 				if(!strncmp(id, sObj->AccountID, 10))

  0020b	6a 0a		 push	 10			; 0000000aH
  0020d	51		 push	 ecx
  0020e	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _strncmp
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021a	85 c0		 test	 eax, eax
  0021c	74 20		 je	 SHORT $LN32@CSPJoinIdP@2
  0021e	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv809[ebp]
$LN19@CSPJoinIdP@2:

; 2843 : 
; 2844 : #if(OFFLINE_MODE == TRUE)
; 2845 : 	for(int i = OBJ_MAXMONSTER; i < OBJMAX;i++)

  00224	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _i$245227[ebp]
  0022a	05 50 2b 00 00	 add	 eax, 11088		; 00002b50H
  0022f	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv809[ebp], eax
  00235	3d 80 d7 e9 09	 cmp	 eax, 166320000		; 09e9d780H
  0023a	7c b4		 jl	 SHORT $LL20@CSPJoinIdP@2

; 2887 : 		{
; 2888 : 			if(!strcmp(id,sObj->AccountID))

  0023c	eb 4e		 jmp	 SHORT $LN14@CSPJoinIdP@2
$LN32@CSPJoinIdP@2:

; 2853 : 				{
; 2854 : 					//if(!strncmp(pass, sObj->Pass, 10))
; 2855 : 					{
; 2856 : 						if(sObj->m_OfflineMode == true)

  0023e	80 bb d4 28 00
	00 01		 cmp	 BYTE PTR [ebx+10452], 1
  00245	75 45		 jne	 SHORT $LN14@CSPJoinIdP@2

; 2857 : 						{
; 2858 : 							g_ZtGDManager.GD_OfflineAfk(i, 0, 0);

  00247	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$245227[ebp]
  0024d	6a 00		 push	 0
  0024f	6a 00		 push	 0
  00251	51		 push	 ecx
  00252	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtGDManager@@3VCZtGDManager@@A ; g_ZtGDManager
  00257	e8 00 00 00 00	 call	 ?GD_OfflineAfk@CZtGDManager@@QAEXHEE@Z ; CZtGDManager::GD_OfflineAfk

; 2859 : 							sObj->m_OfflineMode = 0;
; 2860 : 							#if(OFFLINE_MODE_RESTORE)
; 2861 : 							g_OfflineMode.GDReqUpdateStatus(i);

  0025c	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _i$245227[ebp]
  00262	52		 push	 edx
  00263	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  00268	c6 83 d4 28 00
	00 00		 mov	 BYTE PTR [ebx+10452], 0
  0026f	e8 00 00 00 00	 call	 ?GDReqUpdateStatus@OfflineMode@@QAEXH@Z ; OfflineMode::GDReqUpdateStatus

; 2862 : 							#endif
; 2863 : 							GJPUserClose(sObj->AccountID);

  00274	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00277	53		 push	 ebx
  00278	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAD@Z	; GJPUserClose

; 2864 : 							gObjDel(i);			

  0027d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$245227[ebp]
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00289	83 c4 08	 add	 esp, 8
$LN14@CSPJoinIdP@2:

; 2865 : 								
; 2866 : 						}
; 2867 : 
; 2868 : 						break;
; 2869 : 					}				
; 2870 : 				}
; 2871 : 			}
; 2872 : 		}
; 2873 : 	}
; 2874 : #endif
; 2875 : 
; 2876 : 
; 2877 : #ifdef _OFFTRADE_
; 2878 : 	gOffTrade.ConnectUser(id);

  0028c	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  0028f	51		 push	 ecx
  00290	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  00295	e8 00 00 00 00	 call	 ?ConnectUser@cOffTrade@@QAEXPAD@Z ; cOffTrade::ConnectUser
  0029a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2879 : #endif
; 2880 : 	//---------------------------
; 2881 : 	//	OffTrade	OffExp
; 2882 : 	//---------------------------
; 2883 : 	for(int i = OBJ_MAXMONSTER; i<=OBJMAX;i++)

  002a0	c7 85 7c ff ff
	ff c8 32 00 00	 mov	 DWORD PTR _i$245236[ebp], 13000 ; 000032c8H
  002aa	81 c3 ec 76 97
	08		 add	 ebx, 144144108		; 089776ecH
$LL13@CSPJoinIdP@2:

; 2884 : 	{
; 2885 : 		LPOBJ sObj = &gObj[i];
; 2886 : 		if(sObj->Connected == 3)

  002b0	83 7b 98 03	 cmp	 DWORD PTR [ebx-104], 3
  002b4	75 33		 jne	 SHORT $LN12@CSPJoinIdP@2

; 2887 : 		{
; 2888 : 			if(!strcmp(id,sObj->AccountID))

  002b6	8b cb		 mov	 ecx, ebx
  002b8	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  002bb	eb 03 8d 49 00	 npad	 5
$LL40@CSPJoinIdP@2:
  002c0	8a 10		 mov	 dl, BYTE PTR [eax]
  002c2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  002c4	75 1a		 jne	 SHORT $LN41@CSPJoinIdP@2
  002c6	84 d2		 test	 dl, dl
  002c8	74 12		 je	 SHORT $LN42@CSPJoinIdP@2
  002ca	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002cd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002d0	75 0e		 jne	 SHORT $LN41@CSPJoinIdP@2
  002d2	83 c0 02	 add	 eax, 2
  002d5	83 c1 02	 add	 ecx, 2
  002d8	84 d2		 test	 dl, dl
  002da	75 e4		 jne	 SHORT $LL40@CSPJoinIdP@2
$LN42@CSPJoinIdP@2:
  002dc	33 c0		 xor	 eax, eax
  002de	eb 05		 jmp	 SHORT $LN43@CSPJoinIdP@2
$LN41@CSPJoinIdP@2:
  002e0	1b c0		 sbb	 eax, eax
  002e2	83 d8 ff	 sbb	 eax, -1
$LN43@CSPJoinIdP@2:
  002e5	85 c0		 test	 eax, eax
  002e7	74 1c		 je	 SHORT $LN33@CSPJoinIdP@2
$LN12@CSPJoinIdP@2:

; 2879 : #endif
; 2880 : 	//---------------------------
; 2881 : 	//	OffTrade	OffExp
; 2882 : 	//---------------------------
; 2883 : 	for(int i = OBJ_MAXMONSTER; i<=OBJMAX;i++)

  002e9	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _i$245236[ebp]
  002ef	40		 inc	 eax
  002f0	81 c3 50 2b 00
	00		 add	 ebx, 11088		; 00002b50H
  002f6	89 85 7c ff ff
	ff		 mov	 DWORD PTR _i$245236[ebp], eax
  002fc	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00301	7e ad		 jle	 SHORT $LL13@CSPJoinIdP@2

; 2887 : 		{
; 2888 : 			if(!strcmp(id,sObj->AccountID))

  00303	eb 3d		 jmp	 SHORT $LN8@CSPJoinIdP@2
$LN33@CSPJoinIdP@2:

; 2889 : 			{
; 2890 : 				//if(!strncmp(pass, sObj->Pass, 10))
; 2891 : 				{
; 2892 : 					if(sObj->OffExp == 1)

  00305	83 bb 2c 22 00
	00 01		 cmp	 DWORD PTR [ebx+8748], 1
  0030c	75 34		 jne	 SHORT $LN8@CSPJoinIdP@2

; 2893 : 					{
; 2894 : 						g_ZtGDManager.GD_OfflineAfk(i, 0, 1);

  0030e	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _i$245236[ebp]
  00314	6a 01		 push	 1
  00316	6a 00		 push	 0
  00318	52		 push	 edx
  00319	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtGDManager@@3VCZtGDManager@@A ; g_ZtGDManager
  0031e	e8 00 00 00 00	 call	 ?GD_OfflineAfk@CZtGDManager@@QAEXHEE@Z ; CZtGDManager::GD_OfflineAfk

; 2895 : 						GJPUserClose(sObj->AccountID);

  00323	53		 push	 ebx
  00324	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAD@Z	; GJPUserClose

; 2896 : 						gObjDel(i);

  00329	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _i$245236[ebp]
  0032f	51		 push	 ecx
  00330	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00335	83 c4 08	 add	 esp, 8

; 2897 : 						sObj->OffExp = 0;

  00338	c7 83 2c 22 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+8748], 0
$LN8@CSPJoinIdP@2:

; 2898 : 					}
; 2899 : 				}
; 2900 : 				break;
; 2901 : 			}
; 2902 : 		}
; 2903 : 	}
; 2904 : 	//---------------------------
; 2905 : 
; 2906 : 	
; 2907 : 
; 2908 : 	if (PacketCheckTime(lpObj) == FALSE )

  00342	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00348	52		 push	 edx
  00349	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0034e	83 c4 04	 add	 esp, 4
  00351	85 c0		 test	 eax, eax
  00353	75 12		 jne	 SHORT $LN7@CSPJoinIdP@2

; 2909 : 	{
; 2910 : 		LogAdd(lMsg.Get(MSGGET(1, 217)), aIndex, id);

  00355	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  0035b	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  0035e	50		 push	 eax
  0035f	56		 push	 esi
  00360	68 d9 01 00 00	 push	 473			; 000001d9H

; 2911 : 		CloseClient(aIndex);
; 2912 : 		return;

  00365	eb 1d		 jmp	 SHORT $LN46@CSPJoinIdP@2
$LN7@CSPJoinIdP@2:

; 2913 : 	}
; 2914 : 
; 2915 : 	if ( gObj[aIndex].Connected != PLAYER_CONNECTED )

  00367	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036d	83 7c 0e 04 01	 cmp	 DWORD PTR [esi+ecx+4], 1
  00372	74 3b		 je	 SHORT $LN6@CSPJoinIdP@2

; 2916 : 	{
; 2917 : 		LogAdd(lMsg.Get(MSGGET(1, 218)), aIndex, id);

  00374	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  0037a	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  0037d	51		 push	 ecx
  0037e	56		 push	 esi
  0037f	68 da 01 00 00	 push	 474			; 000001daH
$LN46@CSPJoinIdP@2:
  00384	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00389	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0038e	50		 push	 eax
  0038f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2918 : 		CloseClient(aIndex);

  00395	56		 push	 esi
  00396	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 2925 : 		{
; 2926 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  0039b	83 c4 10	 add	 esp, 16			; 00000010H
  0039e	5b		 pop	 ebx
  0039f	5f		 pop	 edi
  003a0	5e		 pop	 esi

; 2984 : 	lpObj->m_btDestY = 0;
; 2985 : }

  003a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a4	33 cd		 xor	 ecx, ebp
  003a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ab	8b e5		 mov	 esp, ebp
  003ad	5d		 pop	 ebp
  003ae	c3		 ret	 0
$LN6@CSPJoinIdP@2:

; 2919 : 		return;
; 2920 : 	}
; 2921 : 
; 2922 : 	if ( gObj[aIndex].LoginMsgSnd != FALSE )

  003af	8a 44 0e 08	 mov	 al, BYTE PTR [esi+ecx+8]
  003b3	84 c0		 test	 al, al
  003b5	74 53		 je	 SHORT $LN5@CSPJoinIdP@2

; 2923 : 	{
; 2924 : 		if ( gObj[aIndex].LoginMsgSnd == TRUE )

  003b7	3c 01		 cmp	 al, 1
  003b9	75 3a		 jne	 SHORT $LN4@CSPJoinIdP@2

; 2925 : 		{
; 2926 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  003bb	8d 54 0e 18	 lea	 edx, DWORD PTR [esi+ecx+24]
  003bf	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003c5	52		 push	 edx
  003c6	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  003c9	50		 push	 eax
  003ca	51		 push	 ecx
  003cb	68 db 01 00 00	 push	 475			; 000001dbH
  003d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003d5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003da	50		 push	 eax
$LN47@CSPJoinIdP@2:
  003db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003e1	83 c4 10	 add	 esp, 16			; 00000010H
  003e4	5b		 pop	 ebx
  003e5	5f		 pop	 edi
  003e6	5e		 pop	 esi

; 2984 : 	lpObj->m_btDestY = 0;
; 2985 : }

  003e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ea	33 cd		 xor	 ecx, ebp
  003ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f1	8b e5		 mov	 esp, ebp
  003f3	5d		 pop	 ebp
  003f4	c3		 ret	 0
$LN4@CSPJoinIdP@2:

; 2927 : 		}
; 2928 : 		else
; 2929 : 		{
; 2930 : 			LogAdd("error : %d %s %d", gObj[aIndex].LoginMsgSnd, __FILE__, __LINE__);

  003f5	68 72 0b 00 00	 push	 2930			; 00000b72H
  003fa	0f be d0	 movsx	 edx, al
  003fd	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00402	52		 push	 edx
  00403	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@

; 2931 : 		}
; 2932 : 
; 2933 : 		return;

  00408	eb d1		 jmp	 SHORT $LN47@CSPJoinIdP@2
$LN5@CSPJoinIdP@2:

; 2934 : 	}
; 2935 : 
; 2936 : 	#if(ENABLE_MULTICHAR)
; 2937 : 	gObj[aIndex].m_CharPage = 0;
; 2938 : 	#endif
; 2939 : 
; 2940 : 	SDHP_IDPASS spMsg;
; 2941 : 
; 2942 : 	PHeadSetB((LPBYTE)&spMsg, 0x01, sizeof(spMsg));

  0040a	6a 2c		 push	 44			; 0000002cH
  0040c	8d 45 80	 lea	 eax, DWORD PTR _spMsg$[ebp]
  0040f	6a 01		 push	 1
  00411	50		 push	 eax
  00412	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2943 : 	spMsg.Number = aIndex;

  00417	0f b7 8d 78 ff
	ff ff		 movzx	 ecx, WORD PTR _aIndex$GSCopy$[ebp]

; 2944 : 	memcpy(spMsg.Id, lpMsg->Id, sizeof(spMsg.Id));

  0041e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00421	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 2945 : 	memcpy(spMsg.Pass, lpMsg->Pass, sizeof(spMsg.Pass));
; 2946 : 	strcpy(spMsg.IpAddress, gObj[aIndex].Ip_addr);

  00424	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042a	66 89 4d 98	 mov	 WORD PTR _spMsg$[ebp+24], cx
  0042e	0f b7 4f 0c	 movzx	 ecx, WORD PTR [edi+12]
  00432	89 55 83	 mov	 DWORD PTR _spMsg$[ebp+3], edx
  00435	8b 57 0e	 mov	 edx, DWORD PTR [edi+14]
  00438	89 45 87	 mov	 DWORD PTR _spMsg$[ebp+7], eax
  0043b	8b 47 12	 mov	 eax, DWORD PTR [edi+18]
  0043e	66 89 4d 8b	 mov	 WORD PTR _spMsg$[ebp+11], cx
  00442	0f b7 4f 16	 movzx	 ecx, WORD PTR [edi+22]
  00446	89 55 8d	 mov	 DWORD PTR _spMsg$[ebp+13], edx
  00449	89 45 91	 mov	 DWORD PTR _spMsg$[ebp+17], eax
  0044c	8d 44 1e 18	 lea	 eax, DWORD PTR [esi+ebx+24]
  00450	8d 55 9a	 lea	 edx, DWORD PTR _spMsg$[ebp+26]
  00453	83 c4 0c	 add	 esp, 12			; 0000000cH
  00456	66 89 4d 95	 mov	 WORD PTR _spMsg$[ebp+21], cx
  0045a	2b d0		 sub	 edx, eax
  0045c	8d 64 24 00	 npad	 4
$LL28@CSPJoinIdP@2:
  00460	8a 08		 mov	 cl, BYTE PTR [eax]
  00462	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00465	40		 inc	 eax
  00466	84 c9		 test	 cl, cl
  00468	75 f6		 jne	 SHORT $LL28@CSPJoinIdP@2

; 2947 : 	gObj[aIndex].CheckTick = lpMsg->TickCount;

  0046a	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0046d	89 54 1e 40	 mov	 DWORD PTR [esi+ebx+64], edx

; 2948 : 	gObj[aIndex].CheckTick2 = GetTickCount();

  00471	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00477	ff d3		 call	 ebx
  00479	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047f	89 44 0e 48	 mov	 DWORD PTR [esi+ecx+72], eax

; 2949 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00483	ff d3		 call	 ebx
  00485	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0048b	89 44 16 3c	 mov	 DWORD PTR [esi+edx+60], eax

; 2950 : 	gObj[aIndex].CheckSpeedHack = true;

  0048f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00494	c6 44 06 44 01	 mov	 BYTE PTR [esi+eax+68], 1

; 2951 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  00499	ff d3		 call	 ebx
  0049b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004a1	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax

; 2952 : 	gObj[aIndex].LoginMsgSnd = 1;

  004a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ab	c6 44 16 08 01	 mov	 BYTE PTR [esi+edx+8], 1

; 2953 : 	gObj[aIndex].LoginMsgCount++;

  004b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b5	fe 44 06 09	 inc	 BYTE PTR [esi+eax+9]

; 2954 : #ifdef DISCONECT_FRIEND
; 2955 : 	if(g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(ulasevich) || g_ZtLicense.CheckUser(ulasevich2) || 
; 2956 : 		g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::GredyLocal) || g_ZtLicense.CheckUser(eZtUB::Gredy2)
; 2957 : 		 || g_ZtLicense.CheckUser(eZtUB::MU2Play) || g_ZtLicense.CheckUser(eZtUB::Sentinel) || g_ZtLicense.CheckUser(eZtUB::Escalate) || g_ZtLicense.CheckUser(eZtUB::eternalmu) ||
; 2958 : 		 g_ZtLicense.CheckUser(eZtUB::Artem) || g_ZtLicense.CheckUser(eZtUB::Artem2) || g_ZtLicense.CheckUser(eZtUB::RevoMU) || g_ZtLicense.CheckUser(eZtUB::GloryMU) ||
; 2959 : 		 g_ZtLicense.CheckUser(eZtUB::mu4you) || g_ZtLicense.CheckUser(eZtUB::NSGames))

  004b9	6a 00		 push	 0
  004bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004c0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004c5	84 c0		 test	 al, al
  004c7	0f 85 0c 01 00
	00		 jne	 $LN1@CSPJoinIdP@2
  004cd	6a 17		 push	 23			; 00000017H
  004cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004d4	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004d9	84 c0		 test	 al, al
  004db	0f 85 f8 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  004e1	6a 24		 push	 36			; 00000024H
  004e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004e8	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  004ed	84 c0		 test	 al, al
  004ef	0f 85 e4 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  004f5	6a 20		 push	 32			; 00000020H
  004f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  004fc	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00501	84 c0		 test	 al, al
  00503	0f 85 d0 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  00509	6a 21		 push	 33			; 00000021H
  0050b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00510	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00515	84 c0		 test	 al, al
  00517	0f 85 bc 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  0051d	6a 22		 push	 34			; 00000022H
  0051f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00524	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00529	84 c0		 test	 al, al
  0052b	0f 85 a8 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  00531	6a 36		 push	 54			; 00000036H
  00533	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00538	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0053d	84 c0		 test	 al, al
  0053f	0f 85 94 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  00545	6a 38		 push	 56			; 00000038H
  00547	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0054c	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00551	84 c0		 test	 al, al
  00553	0f 85 80 00 00
	00		 jne	 $LN1@CSPJoinIdP@2
  00559	6a 40		 push	 64			; 00000040H
  0055b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00560	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00565	84 c0		 test	 al, al
  00567	75 70		 jne	 SHORT $LN1@CSPJoinIdP@2
  00569	6a 4f		 push	 79			; 0000004fH
  0056b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00570	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00575	84 c0		 test	 al, al
  00577	75 60		 jne	 SHORT $LN1@CSPJoinIdP@2
  00579	6a 30		 push	 48			; 00000030H
  0057b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00580	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00585	84 c0		 test	 al, al
  00587	75 50		 jne	 SHORT $LN1@CSPJoinIdP@2
  00589	6a 31		 push	 49			; 00000031H
  0058b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00590	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00595	84 c0		 test	 al, al
  00597	75 40		 jne	 SHORT $LN1@CSPJoinIdP@2
  00599	6a 43		 push	 67			; 00000043H
  0059b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005a0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005a5	84 c0		 test	 al, al
  005a7	75 30		 jne	 SHORT $LN1@CSPJoinIdP@2
  005a9	6a 46		 push	 70			; 00000046H
  005ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005b0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005b5	84 c0		 test	 al, al
  005b7	75 20		 jne	 SHORT $LN1@CSPJoinIdP@2
  005b9	6a 4e		 push	 78			; 0000004eH
  005bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005c0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005c5	84 c0		 test	 al, al
  005c7	75 10		 jne	 SHORT $LN1@CSPJoinIdP@2
  005c9	6a 51		 push	 81			; 00000051H
  005cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  005d0	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  005d5	84 c0		 test	 al, al
  005d7	74 7b		 je	 SHORT $LN2@CSPJoinIdP@2
$LN1@CSPJoinIdP@2:

; 2960 : 	{
; 2961 : #define MAX_PASS_LEN 20
; 2962 : 		ZeroMemory(&gObj[aIndex].Pass,sizeof(gObj[aIndex].Pass));

  005d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005df	33 c0		 xor	 eax, eax
  005e1	89 84 0e 82 00
	00 00		 mov	 DWORD PTR [esi+ecx+130], eax
  005e8	89 84 0e 86 00
	00 00		 mov	 DWORD PTR [esi+ecx+134], eax
  005ef	8d 8c 0e 82 00
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+130]
  005f6	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  005f9	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  005fc	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  005ff	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 2963 : 		char pass[MAX_PASS_LEN+1];
; 2964 : 		pass[MAX_PASS_LEN]=0;
; 2965 : 		memcpy(pass, lpMsg->Pass, sizeof(lpMsg->Pass));

  00602	8b 57 0e	 mov	 edx, DWORD PTR [edi+14]
  00605	66 8b 4f 16	 mov	 cx, WORD PTR [edi+22]
  00609	89 55 ac	 mov	 DWORD PTR _pass$245255[ebp], edx
  0060c	88 45 c0	 mov	 BYTE PTR _pass$245255[ebp+20], al
  0060f	8b 47 12	 mov	 eax, DWORD PTR [edi+18]

; 2966 : 		BuxConvert(pass, MAX_ACCOUNT_LEN);//fix

  00612	8d 55 ac	 lea	 edx, DWORD PTR _pass$245255[ebp]
  00615	6a 0a		 push	 10			; 0000000aH
  00617	52		 push	 edx
  00618	89 45 b0	 mov	 DWORD PTR _pass$245255[ebp+4], eax
  0061b	66 89 4d b4	 mov	 WORD PTR _pass$245255[ebp+8], cx
  0061f	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2967 : 		gObj[aIndex].Pass[MAX_ACCOUNT_LEN] = 0;

  00624	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00629	c6 84 06 8c 00
	00 00 00	 mov	 BYTE PTR [esi+eax+140], 0

; 2968 : 		memcpy(gObj[aIndex].Pass, pass, MAX_ACCOUNT_LEN);

  00631	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00637	8b 55 ac	 mov	 edx, DWORD PTR _pass$245255[ebp]
  0063a	8d 84 0e 82 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx+130]
  00641	89 10		 mov	 DWORD PTR [eax], edx
  00643	8b 4d b0	 mov	 ecx, DWORD PTR _pass$245255[ebp+4]
  00646	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00649	66 8b 55 b4	 mov	 dx, WORD PTR _pass$245255[ebp+8]
  0064d	83 c4 08	 add	 esp, 8
  00650	66 89 50 08	 mov	 WORD PTR [eax+8], dx
$LN2@CSPJoinIdP@2:

; 2969 : 	}
; 2970 : #endif // DISCONECT_FRIEND
; 2971 : 
; 2972 : 	gObj[aIndex].AccountID[MAX_ACCOUNT_LEN] = 0;

  00654	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00659	c6 44 06 76 00	 mov	 BYTE PTR [esi+eax+118], 0

; 2973 : 	memcpy(gObj[aIndex].AccountID, id, MAX_ACCOUNT_LEN);

  0065e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00664	8b 55 f0	 mov	 edx, DWORD PTR _id$[ebp]
  00667	89 54 0e 6c	 mov	 DWORD PTR [esi+ecx+108], edx
  0066b	8d 44 0e 6c	 lea	 eax, DWORD PTR [esi+ecx+108]
  0066f	8b 4d f4	 mov	 ecx, DWORD PTR _id$[ebp+4]
  00672	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00675	66 8b 55 f8	 mov	 dx, WORD PTR _id$[ebp+8]
  00679	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 2974 : 	gObj[aIndex].m_cAccountItemBlock = 0;

  0067d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00682	c6 84 06 14 02
	00 00 00	 mov	 BYTE PTR [esi+eax+532], 0

; 2975 : 
; 2976 : 	gObj[aIndex].ukn_30 = 0; //season4.5 add-on

  0068a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00690	c7 44 0e 30 00
	00 00 00	 mov	 DWORD PTR [esi+ecx+48], 0

; 2977 : 
; 2978 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  00698	0f b6 55 81	 movzx	 edx, BYTE PTR _spMsg$[ebp+1]
  0069c	52		 push	 edx
  0069d	8d 45 80	 lea	 eax, DWORD PTR _spMsg$[ebp]
  006a0	50		 push	 eax
  006a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  006a6	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2979 : 	LogAddTD("join send : (%d)%s", aIndex, gObj[aIndex].AccountID);

  006ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006b1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  006b7	8d 54 0e 6c	 lea	 edx, DWORD PTR [esi+ecx+108]
  006bb	52		 push	 edx
  006bc	50		 push	 eax
  006bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
  006c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2980 : 	lpObj->m_bMapSvrMoveReq = false;

  006c8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2981 : 	lpObj->m_sPrevMapSvrCode = -1; 

  006d1	83 c9 ff	 or	 ecx, -1
  006d4	5b		 pop	 ebx

; 2982 : 	lpObj->m_sDestMapNumber = -1;

  006d5	0b d1		 or	 edx, ecx
  006d7	5f		 pop	 edi
  006d8	c6 80 e5 1b 00
	00 00		 mov	 BYTE PTR [eax+7141], 0
  006df	66 89 88 ec 1b
	00 00		 mov	 WORD PTR [eax+7148], cx
  006e6	66 89 90 ee 1b
	00 00		 mov	 WORD PTR [eax+7150], dx

; 2983 : 	lpObj->m_btDestX = 0;

  006ed	66 c7 80 f0 1b
	00 00 00 00	 mov	 WORD PTR [eax+7152], 0
  006f6	5e		 pop	 esi

; 2984 : 	lpObj->m_btDestY = 0;
; 2985 : }

  006f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006fa	33 cd		 xor	 ecx, ebp
  006fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00701	8b e5		 mov	 esp, ebp
  00703	5d		 pop	 ebp
  00704	c3		 ret	 0
$LN24@CSPJoinIdP@2:

; 2802 : 	{
; 2803 : 		GCJoinResult(JS_BAD_CLIENT_VERSION, aIndex);

  00705	56		 push	 esi
  00706	6a 06		 push	 6
  00708	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult

; 2804 : 		CloseClient(aIndex);

  0070d	56		 push	 esi
  0070e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 2984 : 	lpObj->m_btDestY = 0;
; 2985 : }

  00713	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00716	83 c4 0c	 add	 esp, 12			; 0000000cH
  00719	5f		 pop	 edi
  0071a	33 cd		 xor	 ecx, ebp
  0071c	5e		 pop	 esi
  0071d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00722	8b e5		 mov	 esp, ebp
  00724	5d		 pop	 ebp
  00725	c3		 ret	 0
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequest
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCLevelUpMsgSend@@YAXHH@Z			; GCLevelUpMsgSend
EXTRN	?gObjGetStatPointState@@YAXHAAF000@Z:PROC	; gObjGetStatPointState
; Function compile flags: /Ogtp
;	COMDAT ?GCLevelUpMsgSend@@YAXHH@Z
_TEXT	SEGMENT
tv323 = -100						; size = 4
_aIndex$GSCopy$ = -96					; size = 4
tv312 = -92						; size = 4
tv309 = -88						; size = 8
tv317 = -84						; size = 4
tv311 = -84						; size = 4
_MaxAddPoint$ = -80					; size = 2
_MinusPoint$ = -76					; size = 2
_MaxMinusPoint$ = -72					; size = 2
tv320 = -68						; size = 8
tv322 = -64						; size = 4
tv306 = -64						; size = 4
_AddPoint$ = -60					; size = 2
tv346 = -56						; size = 4
tv344 = -56						; size = 4
tv337 = -56						; size = 4
tv335 = -56						; size = 4
tv330 = -56						; size = 4
tv349 = -50						; size = 2
tv340 = -50						; size = 2
tv327 = -50						; size = 2
tv315 = -50						; size = 2
_pMsg$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_iSendEffect$ = 12					; size = 4
?GCLevelUpMsgSend@@YAXHH@Z PROC				; GCLevelUpMsgSend, COMDAT

; 3690 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 3691 : 	if ( !OBJMAX_RANGE(aIndex))

  00014	33 c0		 xor	 eax, eax

; 3692 : 	{
; 3693 : 		return;
; 3694 : 	}
; 3695 : 
; 3696 : 	short AddPoint=0;

  00016	89 75 a0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00019	3b f0		 cmp	 esi, eax
  0001b	0f 8c d3 01 00
	00		 jl	 $LN1@GCLevelUpM

; 3691 : 	if ( !OBJMAX_RANGE(aIndex))

  00021	33 c9		 xor	 ecx, ecx
  00023	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  00029	0f 9e c1	 setle	 cl
  0002c	3b c8		 cmp	 ecx, eax
  0002e	0f 84 c0 01 00
	00		 je	 $LN1@GCLevelUpM

; 3697 : 	short MaxAddPoint=0;
; 3698 : 	short MinusPoint=0;
; 3699 : 	short MaxMinusPoint=0;
; 3700 : 
; 3701 : 	gObjGetStatPointState(gObj[aIndex].m_Index, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);

  00034	53		 push	 ebx
  00035	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0003b	57		 push	 edi
  0003c	89 45 c4	 mov	 DWORD PTR _AddPoint$[ebp], eax
  0003f	89 45 b0	 mov	 DWORD PTR _MaxAddPoint$[ebp], eax
  00042	89 45 b4	 mov	 DWORD PTR _MinusPoint$[ebp], eax
  00045	89 45 b8	 mov	 DWORD PTR _MaxMinusPoint$[ebp], eax
  00048	8d 45 b8	 lea	 eax, DWORD PTR _MaxMinusPoint$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d b4	 lea	 ecx, DWORD PTR _MinusPoint$[ebp]
  0004f	51		 push	 ecx
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	8d 55 b0	 lea	 edx, DWORD PTR _MaxAddPoint$[ebp]
  00059	52		 push	 edx
  0005a	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  0005d	8d 45 c4	 lea	 eax, DWORD PTR _AddPoint$[ebp]
  00060	50		 push	 eax
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 3702 : 	
; 3703 : 	PMSG_LEVELUP pMsg;	//Need Visual Fix
; 3704 : 
; 3705 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x05, sizeof(pMsg));

  00067	6a 2c		 push	 44			; 0000002cH
  00069	6a 05		 push	 5
  0006b	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006e	68 f3 00 00 00	 push	 243			; 000000f3H
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3706 : 	pMsg.Level = gObj[aIndex].Level;

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3707 : 	pMsg.LevelUpPoint = gObj[aIndex].LevelUpPoint;
; 3708 : 	pMsg.MaxLife = (WORD)(((float)gObj[aIndex].MaxLife+(float)gObj[aIndex].AddLife));

  0007f	d9 7d ce	 fnstcw	 WORD PTR tv349[ebp]
  00082	66 8b 94 0e be
	00 00 00	 mov	 dx, WORD PTR [esi+ecx+190]
  0008a	66 89 55 d4	 mov	 WORD PTR _pMsg$[ebp+4], dx
  0008e	0f b7 84 0e c0
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+192]
  00096	66 89 45 d6	 mov	 WORD PTR _pMsg$[ebp+6], ax
  0009a	8d 94 0e c0 00
	00 00		 lea	 edx, DWORD PTR [esi+ecx+192]
  000a1	db 84 0e 4c 01
	00 00		 fild	 DWORD PTR [esi+ecx+332]
  000a8	8d bc 0e 4c 01
	00 00		 lea	 edi, DWORD PTR [esi+ecx+332]
  000af	8d 84 0e 00 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+256]
  000b6	89 45 c0	 mov	 DWORD PTR tv306[ebp], eax

; 3709 : 	pMsg.MaxMana = (WORD)(( (float)gObj[aIndex].MaxMana+(float)gObj[aIndex].AddMana));

  000b9	8d 9c 0e 14 01
	00 00		 lea	 ebx, DWORD PTR [esi+ecx+276]
  000c0	d8 00		 fadd	 DWORD PTR [eax]
  000c2	0f b7 45 ce	 movzx	 eax, WORD PTR tv349[ebp]
  000c6	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000cb	89 45 c8	 mov	 DWORD PTR tv346[ebp], eax
  000ce	89 5d ac	 mov	 DWORD PTR tv317[ebp], ebx
  000d1	d9 6d c8	 fldcw	 WORD PTR tv346[ebp]
  000d4	db 5d c8	 fistp	 DWORD PTR tv344[ebp]
  000d7	0f b7 45 c8	 movzx	 eax, WORD PTR tv344[ebp]
  000db	66 89 45 d8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  000df	8d 84 0e 50 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+336]
  000e6	d9 6d ce	 fldcw	 WORD PTR tv349[ebp]
  000e9	89 45 a4	 mov	 DWORD PTR tv312[ebp], eax
  000ec	db 00		 fild	 DWORD PTR [eax]
  000ee	d9 7d ce	 fnstcw	 WORD PTR tv340[ebp]
  000f1	d8 03		 fadd	 DWORD PTR [ebx]
  000f3	0f b7 45 ce	 movzx	 eax, WORD PTR tv340[ebp]
  000f7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000fc	89 45 c8	 mov	 DWORD PTR tv337[ebp], eax

; 3710 : 	pMsg.MaxBP = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;

  000ff	8d 9c 0e 2c 01
	00 00		 lea	 ebx, DWORD PTR [esi+ecx+300]
  00106	d9 6d c8	 fldcw	 WORD PTR tv337[ebp]
  00109	db 5d c8	 fistp	 DWORD PTR tv335[ebp]
  0010c	0f b7 45 c8	 movzx	 eax, WORD PTR tv335[ebp]
  00110	66 89 45 da	 mov	 WORD PTR _pMsg$[ebp+10], ax
  00114	8d 84 0e 30 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+304]
  0011b	89 45 9c	 mov	 DWORD PTR tv323[ebp], eax
  0011e	d9 6d ce	 fldcw	 WORD PTR tv340[ebp]
  00121	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00124	66 03 03	 add	 ax, WORD PTR [ebx]
  00127	66 89 45 de	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 3711 : 	pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  0012b	8d 84 0e 5c 01
	00 00		 lea	 eax, DWORD PTR [esi+ecx+348]
  00132	8d 8c 0e 58 01
	00 00		 lea	 ecx, DWORD PTR [esi+ecx+344]
  00139	66 8b 31	 mov	 si, WORD PTR [ecx]
  0013c	66 03 30	 add	 si, WORD PTR [eax]
  0013f	89 45 c8	 mov	 DWORD PTR tv330[ebp], eax

; 3712 : 	pMsg.AddPoint = AddPoint;

  00142	0f b7 45 c4	 movzx	 eax, WORD PTR _AddPoint$[ebp]
  00146	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 3713 : 	pMsg.MaxAddPoint = MaxAddPoint;

  0014a	0f b7 45 b0	 movzx	 eax, WORD PTR _MaxAddPoint$[ebp]
  0014e	66 89 45 e2	 mov	 WORD PTR _pMsg$[ebp+18], ax

; 3714 : 	pMsg.MinusPoint = MinusPoint;

  00152	0f b7 45 b4	 movzx	 eax, WORD PTR _MinusPoint$[ebp]
  00156	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 3715 : 	pMsg.MaxMinusPoint = MaxMinusPoint;

  0015a	0f b7 45 b8	 movzx	 eax, WORD PTR _MaxMinusPoint$[ebp]
  0015e	66 89 75 dc	 mov	 WORD PTR _pMsg$[ebp+12], si
  00162	66 89 45 e6	 mov	 WORD PTR _pMsg$[ebp+22], ax

; 3716 : 
; 3717 : 	pMsg.exUpPoint = gObj[aIndex].LevelUpPoint;

  00166	8b 12		 mov	 edx, DWORD PTR [edx]

; 3718 : 	pMsg.exMaxLife = gObj[aIndex].MaxLife+gObj[aIndex].AddLife;

  00168	8b 45 c0	 mov	 eax, DWORD PTR tv306[ebp]
  0016b	d9 7d ce	 fnstcw	 WORD PTR tv327[ebp]
  0016e	89 55 e8	 mov	 DWORD PTR _pMsg$[ebp+24], edx
  00171	db 07		 fild	 DWORD PTR [edi]

; 3719 : 	pMsg.exMaxMana = gObj[aIndex].MaxMana+gObj[aIndex].AddMana;
; 3720 : 	pMsg.exMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 3721 : 	pMsg.exMaxAG = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;
; 3722 : 
; 3723 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00173	8b 75 a0	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00176	d8 00		 fadd	 DWORD PTR [eax]
  00178	0f b7 45 ce	 movzx	 eax, WORD PTR tv327[ebp]
  0017c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00181	89 45 c0	 mov	 DWORD PTR tv322[ebp], eax
  00184	8b 45 a4	 mov	 eax, DWORD PTR tv312[ebp]
  00187	d9 6d c0	 fldcw	 WORD PTR tv322[ebp]
  0018a	df 7d bc	 fistp	 QWORD PTR tv320[ebp]
  0018d	8b 55 bc	 mov	 edx, DWORD PTR tv320[ebp]
  00190	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+28], edx
  00193	8b 55 ac	 mov	 edx, DWORD PTR tv317[ebp]
  00196	d9 6d ce	 fldcw	 WORD PTR tv327[ebp]
  00199	db 00		 fild	 DWORD PTR [eax]
  0019b	d9 7d ce	 fnstcw	 WORD PTR tv315[ebp]
  0019e	d8 02		 fadd	 DWORD PTR [edx]
  001a0	0f b7 45 ce	 movzx	 eax, WORD PTR tv315[ebp]
  001a4	8b 55 c8	 mov	 edx, DWORD PTR tv330[ebp]
  001a7	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  001ac	89 45 ac	 mov	 DWORD PTR tv311[ebp], eax
  001af	d9 6d ac	 fldcw	 WORD PTR tv311[ebp]
  001b2	df 7d a8	 fistp	 QWORD PTR tv309[ebp]
  001b5	8b 45 a8	 mov	 eax, DWORD PTR tv309[ebp]
  001b8	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+32], eax
  001bb	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001bd	03 0a		 add	 ecx, DWORD PTR [edx]
  001bf	d9 6d ce	 fldcw	 WORD PTR tv315[ebp]
  001c2	0f b6 55 d1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  001c6	8b 45 9c	 mov	 eax, DWORD PTR tv323[ebp]
  001c9	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+36], ecx
  001cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ce	03 0b		 add	 ecx, DWORD PTR [ebx]
  001d0	52		 push	 edx
  001d1	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001d4	50		 push	 eax
  001d5	56		 push	 esi
  001d6	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+40], ecx
  001d9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001de	83 c4 30	 add	 esp, 48			; 00000030H

; 3724 : 
; 3725 : 	if ( iSendEffect == 1 )

  001e1	83 7d 0c 01	 cmp	 DWORD PTR _iSendEffect$[ebp], 1
  001e5	5f		 pop	 edi
  001e6	5b		 pop	 ebx
  001e7	75 0b		 jne	 SHORT $LN1@GCLevelUpM

; 3726 : 	{
; 3727 : 		GCSendEffectInfo(aIndex, 0x10);

  001e9	6a 10		 push	 16			; 00000010H
  001eb	56		 push	 esi
  001ec	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo
  001f1	83 c4 08	 add	 esp, 8
$LN1@GCLevelUpM:

; 3728 : 	}
; 3729 : }

  001f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f7	33 cd		 xor	 ecx, ebp
  001f9	5e		 pop	 esi
  001fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
?GCLevelUpMsgSend@@YAXHH@Z ENDP				; GCLevelUpMsgSend
_TEXT	ENDS
PUBLIC	??_C@_0EO@JKBNGFPH@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@ ; `string'
PUBLIC	??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_0IG@INOJDOPM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Try?5Get?5LuckyI@ ; `string'
PUBLIC	??_C@_0EA@LDDOEGMA@?$FLImperial?5Fort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Di@ ; `string'
PUBLIC	??_C@_0DN@MJPFIFLE@?$FLDoubleGoer?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dimen@ ; `string'
PUBLIC	??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@ ; `string'
PUBLIC	__real@4014000000000000
PUBLIC	__real@40a00000
PUBLIC	??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@ ; `string'
PUBLIC	??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@ ; `string'
PUBLIC	??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
EXTRN	?SetRelicsCarrierViewState@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleEvent::SetRelicsCarrierViewState
EXTRN	?SetRegPedestal@CIllusionTempleEvent@@QAEXEHE@Z:PROC ; CIllusionTempleEvent::SetRegPedestal
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z:PROC ; CBloodCastle::CheckQuestItemSerial
EXTRN	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z:PROC ; gObjInventoryInsertItem
EXTRN	?ItemByteConvert@@YAXPAEHEEEEEEEEEQAEEE@Z:PROC	; ItemByteConvert
EXTRN	?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z:PROC ; gObjInventoryInsertItemTemp
EXTRN	?PickUpItem@ZtWinQuestSystem@@QAEHHH@Z:PROC	; ZtWinQuestSystem::PickUpItem
EXTRN	?g_ZtWinQuestSystem@@3VZtWinQuestSystem@@A:BYTE	; g_ZtWinQuestSystem
EXTRN	?MonsterDrop@cWinQuestSystem@@QAE_NHF@Z:PROC	; cWinQuestSystem::MonsterDrop
EXTRN	?gWinQuestSystem@@3VcWinQuestSystem@@A:BYTE	; gWinQuestSystem
EXTRN	?GetSetOptionName@CSetItemOption@@QAEPADHH@Z:PROC ; CSetItemOption::GetSetOptionName
EXTRN	?IsSetItem@CSetItemOption@@QAEHH@Z:PROC		; CSetItemOption::IsSetItem
EXTRN	?gSetItemOption@@3VCSetItemOption@@A:BYTE	; gSetItemOption
EXTRN	?CheckOverlapCsMarks@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckOverlapCsMarks
EXTRN	?ItemGetNotice@CItemGetNotice@@QAEXPAVCMapItem@@H@Z:PROC ; CItemGetNotice::ItemGetNotice
EXTRN	?g_ItemGetNotice@@3VCItemGetNotice@@A:BYTE	; g_ItemGetNotice
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z:PROC ; CKalimaGate::CheckOverlapKundunMark
EXTRN	?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z:PROC ; gObjOverlapItemUsingDur
EXTRN	?PickUpZen@CAchievements@@QAEXHH@Z:PROC		; CAchievements::PickUpZen
EXTRN	?ItemGive@MapClass@@QAEHHH_N@Z:PROC		; MapClass::ItemGive
EXTRN	?gObjGetItemCountInIventory@@YAHHHHH@Z:PROC	; gObjGetItemCountInIventory
EXTRN	?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z:PROC ; CQuestInfo::CountQuestItemInInventory
;	COMDAT ??_C@_0EO@JKBNGFPH@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@
CONST	SEGMENT
??_C@_0EO@JKBNGFPH@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@ DB '['
	DB	'Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics '
	DB	'Item(serial:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King'
	DB	'''s Weapon (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IG@INOJDOPM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Try?5Get?5LuckyI@
CONST	SEGMENT
??_C@_0IG@INOJDOPM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Try?5Get?5LuckyI@ DB '['
	DB	'%s][%s][%d]%d/%d Try Get LuckyItem serial:%u [%s][%d][%d][%d]'
	DB	'[%d][%d] dur:[%d]Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d] 380:[%d] '
	DB	'HO:[%d,%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LDDOEGMA@?$FLImperial?5Fort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Di@
CONST	SEGMENT
??_C@_0EA@LDDOEGMA@?$FLImperial?5Fort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Di@ DB '['
	DB	'Imperial Fort] [%s][%s] Make Dimension Magyon (Left Marker %d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MJPFIFLE@?$FLDoubleGoer?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dimen@
CONST	SEGMENT
??_C@_0DN@MJPFIFLE@?$FLDoubleGoer?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dimen@ DB '['
	DB	'DoubleGoer] [%s][%s] Make Dimension Magyon (Left Marker %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@
CONST	SEGMENT
??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@ DB '['
	DB	'Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT ??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@
CONST	SEGMENT
??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@ DB '[ Ch'
	DB	'angeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count'
	DB	':%d )', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@
CONST	SEGMENT
??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@ DB '[ Moon'
	DB	'StonePendant ] Too many have MoonStonePendant [%s][%s] ( Name'
	DB	':%s, Count:%d )', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@
CONST	SEGMENT
??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@ DB '[Ring'
	DB	' Event] Too many have Magician''s Ring [%s][%s] (Name:%s, Cou'
	DB	'nt:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@
CONST	SEGMENT
??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@ DB '['
	DB	'%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE'
	DB	' : %d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z
_TEXT	SEGMENT
tv3121 = -304						; size = 4
_iBridgeIndex$245911 = -300				; size = 4
_type$ = -300						; size = 4
_item_num$ = -296					; size = 4
_map_num$ = -292					; size = 4
tv3125 = -288						; size = 4
_n$245851 = -284					; size = 4
_pos$245836 = -284					; size = 4
_pos$245822 = -284					; size = 4
_pos$245811 = -284					; size = 4
_pos$245788 = -284					; size = 4
tv4001 = -280						; size = 4
_tmpSetOption$245873 = -280				; size = 4
_n$245832 = -280					; size = 4
_NewDur$245798 = -280					; size = 4
_pos$245777 = -280					; size = 4
_pos$245758 = -280					; size = 4
_pos$245750 = -280					; size = 4
_pos$245743 = -280					; size = 4
_pos$245736 = -280					; size = 4
tv3591 = -276						; size = 4
tv3589 = -276						; size = 4
tv3576 = -276						; size = 4
tv3574 = -276						; size = 4
tv3561 = -276						; size = 4
tv3559 = -276						; size = 4
tv3546 = -276						; size = 4
tv3544 = -276						; size = 4
tv3530 = -276						; size = 4
tv3528 = -276						; size = 4
_lpMsg$GSCopy$ = -276					; size = 4
_iMapNumber$245913 = -276				; size = 4
_NewDur$245827 = -276					; size = 4
_NewDur$245816 = -276					; size = 4
_level$ = -276						; size = 4
tv3458 = -272						; size = 4
tv3074 = -272						; size = 4
_n$245784 = -272					; size = 4
tv3594 = -270						; size = 2
tv3579 = -270						; size = 2
tv3564 = -270						; size = 2
tv3549 = -270						; size = 2
tv3533 = -270						; size = 2
tv3486 = -270						; size = 2
tv3453 = -270						; size = 2
tv3419 = -270						; size = 2
tv3397 = -270						; size = 2
tv3385 = -270						; size = 2
tv3364 = -270						; size = 2
tv3345 = -270						; size = 2
tv3295 = -270						; size = 2
_pos$245899 = -269					; size = 1
_pResult$ = -268					; size = 16
_szTempMsg$245914 = -252				; size = 128
_szItemName$ = -124					; size = 50
_szSetItemName$245872 = -72				; size = 48
_NewOption$245905 = -24					; size = 8
_NewOption$245791 = -20					; size = 8
_NewOption$245874 = -12					; size = 8
tv3483 = -8						; size = 4
tv3481 = -8						; size = 4
tv3450 = -8						; size = 4
tv3448 = -8						; size = 4
tv3431 = -8						; size = 4
tv3416 = -8						; size = 4
tv3414 = -8						; size = 4
tv3401 = -8						; size = 4
tv3400 = -8						; size = 4
tv3394 = -8						; size = 4
tv3392 = -8						; size = 4
tv3382 = -8						; size = 4
tv3380 = -8						; size = 4
tv3367 = -8						; size = 4
tv3360 = -8						; size = 4
tv3359 = -8						; size = 4
tv3354 = -8						; size = 4
tv3341 = -8						; size = 4
tv3339 = -8						; size = 4
tv3292 = -8						; size = 4
tv3289 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z PROC	; CGItemGetRequest, COMDAT

; 4060 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 4061 : 	int item_num, map_num;
; 4062 : 	PMSG_ITEMGETRESULT pResult;
; 4063 : 	int type;
; 4064 : 	int level;
; 4065 : 	int special;
; 4066 : 	int NOption;
; 4067 : 	char szItemName[50];
; 4068 : 	CMapItem * lpItem;
; 4069 : 
; 4070 : 	pResult.h.c = 0xC3;
; 4071 : 	pResult.h.headcode = 0x22;
; 4072 : 	pResult.h.size = sizeof(pResult);
; 4073 : 	pResult.result = -1;
; 4074 : 
; 4075 : 	if ( !gObjIsConnected(aIndex))

  0001a	53		 push	 ebx

; 4119 : 
; 4120 : 	if ( MAX_ITEM_TYPE_RANGE(item_num) == FALSE )

  0001b	89 85 ec fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  00021	c6 85 f4 fe ff
	ff c3		 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H
  00028	66 c7 85 f5 fe
	ff ff 10 22	 mov	 WORD PTR _pResult$[ebp+1], 8720 ; 00002210H
  00031	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00038	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	75 18		 jne	 SHORT $LN118@CGItemGetR

; 4076 : 	{
; 4077 : 		CloseClient(aIndex);

  00044	53		 push	 ebx
  00045	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004a	83 c4 04	 add	 esp, 4
  0004d	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN118@CGItemGetR:

; 4078 : 		return;
; 4079 : 	}
; 4080 : 
; 4081 : 	if ( gObj[aIndex].CloseType != -1 )

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00061	57		 push	 edi
  00062	8b fb		 mov	 edi, ebx
  00064	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0006a	80 7c 38 0b ff	 cmp	 BYTE PTR [eax+edi+11], -1
  0006f	0f 85 21 18 00
	00		 jne	 $LN208@CGItemGetR

; 4082 : 	{
; 4083 : 		return;
; 4084 : 	}
; 4085 : 
; 4086 : 	if ( gObj[aIndex].DieRegen != 0 )

  00075	80 bc 38 a2 03
	00 00 00	 cmp	 BYTE PTR [eax+edi+930], 0
  0007d	74 39		 je	 SHORT $LN116@CGItemGetR

; 4087 : 	{
; 4088 : 		pResult.result = -1;
; 4089 : 		pResult.h.size -= sizeof(pResult.Data);

  0007f	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00085	04 f4		 add	 al, 244			; 000000f4H

; 4090 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00087	0f b6 c8	 movzx	 ecx, al
  0008a	51		 push	 ecx
  0008b	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00091	52		 push	 edx
  00092	53		 push	 ebx
  00093	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  0009a	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  000a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	5f		 pop	 edi
  000a9	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN116@CGItemGetR:

; 4091 : 		return;
; 4092 : 	}
; 4093 : 
; 4094 : 	if ( gObj[aIndex].m_IfState.use != 0 )

  000b8	8b 84 38 1c 0e
	00 00		 mov	 eax, DWORD PTR [eax+edi+3612]
  000bf	a8 03		 test	 al, 3
  000c1	74 5d		 je	 SHORT $LN114@CGItemGetR

; 4095 : 	{
; 4096 : 		if ( gObj[aIndex].m_IfState.type != 3 )

  000c3	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000c8	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000cd	74 51		 je	 SHORT $LN114@CGItemGetR

; 4097 : 		{
; 4098 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 94)), aIndex, 1);

  000cf	6a 01		 push	 1
  000d1	53		 push	 ebx
  000d2	68 5e 04 00 00	 push	 1118			; 0000045eH
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000dc	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 4099 : 			pResult.result = -1;
; 4100 : 			pResult.h.size -= sizeof(pResult.Data);

  000e7	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  000ed	04 f4		 add	 al, 244			; 000000f4H
  000ef	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 4101 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000f5	0f b6 c0	 movzx	 eax, al
  000f8	50		 push	 eax
  000f9	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00108	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
  00110	5f		 pop	 edi
  00111	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN114@CGItemGetR:

; 4102 : 			return;
; 4103 : 		}
; 4104 : 	}
; 4105 : 
; 4106 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00120	53		 push	 ebx
  00121	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00126	83 c4 04	 add	 esp, 4
  00129	84 c0		 test	 al, al
  0012b	75 18		 jne	 SHORT $LN113@CGItemGetR

; 4107 : 	{
; 4108 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0012d	68 0c 10 00 00	 push	 4108			; 0000100cH
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN113@CGItemGetR:

; 4109 : 	}
; 4110 : 
; 4111 : 	if ( gObj[aIndex].pTransaction == TRUE )

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014a	80 bc 38 30 0e
	00 00 01	 cmp	 BYTE PTR [eax+edi+3632], 1
  00152	75 39		 jne	 SHORT $LN112@CGItemGetR

; 4112 : 	{
; 4113 : 		LogAddTD("[%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE : %d",	gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  00154	8b 94 38 1c 0e
	00 00		 mov	 edx, DWORD PTR [eax+edi+3612]
  0015b	c1 ea 06	 shr	 edx, 6
  0015e	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00164	52		 push	 edx
  00165	8d 4c 38 77	 lea	 ecx, DWORD PTR [eax+edi+119]
  00169	51		 push	 ecx
  0016a	8d 54 38 6c	 lea	 edx, DWORD PTR [eax+edi+108]
  0016e	52		 push	 edx
  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0017a	83 c4 10	 add	 esp, 16			; 00000010H
  0017d	5f		 pop	 edi
  0017e	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  0017f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00182	33 cd		 xor	 ecx, ebp
  00184	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
$LN112@CGItemGetR:

; 4114 : 		return;
; 4115 : 
; 4116 : 	}
; 4117 : 
; 4118 : 	item_num = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  0018d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00193	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00197	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  0019b	66 c1 e2 08	 shl	 dx, 8
  0019f	56		 push	 esi
  001a0	0f b7 f2	 movzx	 esi, dx
  001a3	0b f1		 or	 esi, ecx
  001a5	89 b5 d8 fe ff
	ff		 mov	 DWORD PTR _item_num$[ebp], esi

; 4119 : 
; 4120 : 	if ( MAX_ITEM_TYPE_RANGE(item_num) == FALSE )

  001ab	7c 0f		 jl	 SHORT $LN196@CGItemGetR
  001ad	33 c9		 xor	 ecx, ecx
  001af	81 fe 2b 01 00
	00		 cmp	 esi, 299		; 0000012bH
  001b5	0f 9e c1	 setle	 cl
  001b8	85 c9		 test	 ecx, ecx
  001ba	75 4f		 jne	 SHORT $LN111@CGItemGetR
$LN196@CGItemGetR:

; 4121 : 	{
; 4122 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  001bc	68 1a 10 00 00	 push	 4122			; 0000101aH
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 4123 : 		pResult.result = -1;
; 4124 : 		pResult.h.size -= sizeof(pResult.Data);

  001d1	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  001d7	04 f4		 add	 al, 244			; 000000f4H

; 4125 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001d9	0f b6 d0	 movzx	 edx, al
  001dc	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  001e2	52		 push	 edx
  001e3	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  001e9	50		 push	 eax
  001ea	53		 push	 ebx
  001eb	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  001f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f7	83 c4 18	 add	 esp, 24			; 00000018H
  001fa	5e		 pop	 esi
  001fb	5f		 pop	 edi
  001fc	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	33 cd		 xor	 ecx, ebp
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
$LN111@CGItemGetR:

; 4126 : 		return;
; 4127 : 	}
; 4128 : 
; 4129 : 	map_num = gObj[aIndex].MapNumber;

  0020b	0f b6 84 38 49
	01 00 00	 movzx	 eax, BYTE PTR [eax+edi+329]
  00213	89 85 dc fe ff
	ff		 mov	 DWORD PTR _map_num$[ebp], eax

; 4130 : 
; 4131 : 	if ( MAX_MAP_RANGE(map_num) == FALSE )

  00219	85 c0		 test	 eax, eax
  0021b	78 0e		 js	 SHORT $LN197@CGItemGetR
  0021d	33 c9		 xor	 ecx, ecx
  0021f	83 f8 52	 cmp	 eax, 82			; 00000052H
  00222	0f 9e c1	 setle	 cl
  00225	8b c1		 mov	 eax, ecx
  00227	85 c0		 test	 eax, eax
  00229	75 4f		 jne	 SHORT $LN110@CGItemGetR
$LN197@CGItemGetR:

; 4132 : 	{
; 4133 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  0022b	68 25 10 00 00	 push	 4133			; 00001025H
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 4134 : 		pResult.result = -1;
; 4135 : 		pResult.h.size -= sizeof(pResult.Data);

  00240	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00246	04 f4		 add	 al, 244			; 000000f4H

; 4136 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00248	0f b6 d0	 movzx	 edx, al
  0024b	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  00251	52		 push	 edx
  00252	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00258	50		 push	 eax
  00259	53		 push	 ebx
  0025a	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00261	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00266	83 c4 18	 add	 esp, 24			; 00000018H
  00269	5e		 pop	 esi
  0026a	5f		 pop	 edi
  0026b	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  0026c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026f	33 cd		 xor	 ecx, ebp
  00271	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c3		 ret	 0
$LN110@CGItemGetR:

; 4137 : 		return;
; 4138 : 	}
; 4139 : 
; 4140 : 	lpItem = &MapC[map_num].m_cItem[item_num];

  0027a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  00280	8b ce		 mov	 ecx, esi
  00282	69 c0 48 3d 05
	00		 imul	 eax, 343368		; 00053d48H
  00288	69 c9 74 04 00
	00		 imul	 ecx, 1140		; 00000474H
  0028e	8d b4 01 20 00
	00 00		 lea	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx+eax+32]

; 4141 : 
; 4142 : 	if ( lpItem->IsItem() == TRUE && lpItem->Give == false && lpItem->live == true)

  00295	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00298	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv3121[ebp], eax
  0029e	89 8d e0 fe ff
	ff		 mov	 DWORD PTR tv3125[ebp], ecx
  002a4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002a9	83 f8 01	 cmp	 eax, 1
  002ac	0f 85 c1 15 00
	00		 jne	 $LN109@CGItemGetR
  002b2	80 be db 00 00
	00 00		 cmp	 BYTE PTR [esi+219], 0
  002b9	0f 85 b4 15 00
	00		 jne	 $LN109@CGItemGetR
  002bf	38 86 da 00 00
	00		 cmp	 BYTE PTR [esi+218], al
  002c5	0f 85 a8 15 00
	00		 jne	 $LN109@CGItemGetR

; 4143 : 	{
; 4144 : 		if ( lpItem->m_QuestItem != false )

  002cb	80 be b1 00 00
	00 00		 cmp	 BYTE PTR [esi+177], 0
  002d2	74 19		 je	 SHORT $LN107@CGItemGetR

; 4145 : 		{
; 4146 : 			BOOL bNotFoundQuestItem = g_QuestInfo.CountQuestItemInInventory(aIndex, lpItem->m_Type, lpItem->m_Level); //season 2.5 add-on

  002d4	0f b7 56 0c	 movzx	 edx, WORD PTR [esi+12]
  002d8	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  002dc	52		 push	 edx
  002dd	50		 push	 eax
  002de	53		 push	 ebx
  002df	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  002e4	e8 00 00 00 00	 call	 ?CountQuestItemInInventory@CQuestInfo@@QAEHHFF@Z ; CQuestInfo::CountQuestItemInInventory

; 4147 : 
; 4148 : 			if(bNotFoundQuestItem == FALSE)

  002e9	85 c0		 test	 eax, eax

; 4149 : 			{
; 4150 : 				pResult.result = -1;
; 4151 : 				pResult.h.size -= sizeof(pResult.Data);
; 4152 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4153 : 				return;

  002eb	74 1f		 je	 SHORT $LN214@CGItemGetR
$LN107@CGItemGetR:

; 4154 : 			}
; 4155 : 		}
; 4156 : 
; 4157 : 		if ( lpItem->m_Type == ITEMGET(13,20) )

  002ed	b8 14 1a 00 00	 mov	 eax, 6676		; 00001a14H
  002f2	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  002f6	0f 85 c5 00 00
	00		 jne	 $LN205@CGItemGetR

; 4158 : 		{
; 4159 : 			switch ( lpItem->m_Level )

  002fc	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]
  00300	83 e8 00	 sub	 eax, 0
  00303	74 2c		 je	 SHORT $LN103@CGItemGetR
  00305	48		 dec	 eax
  00306	0f 85 b5 00 00
	00		 jne	 $LN205@CGItemGetR
$LN214@CGItemGetR:

; 4174 : 						return;
; 4175 : 					}
; 4176 : 					break;
; 4177 : 				}
; 4178 : 				case 1:
; 4179 : 					pResult.result = -1;
; 4180 : 					pResult.h.size -= sizeof(pResult.Data);

  0030c	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00312	04 f4		 add	 al, 244			; 000000f4H

; 4181 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00314	0f b6 c8	 movzx	 ecx, al
  00317	51		 push	 ecx
  00318	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0031e	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00325	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  0032b	52		 push	 edx

; 4182 : 					return;

  0032c	e9 5b 15 00 00	 jmp	 $LN210@CGItemGetR
$LN103@CGItemGetR:

; 4160 : 			{
; 4161 : 				case 0:
; 4162 : 				{
; 4163 : 					int iWRCount = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS, lpItem->m_Type%MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  00331	6a 00		 push	 0
  00333	6a 14		 push	 20			; 00000014H
  00335	6a 0d		 push	 13			; 0000000dH
  00337	53		 push	 ebx
  00338	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0033d	83 c4 10	 add	 esp, 16			; 00000010H

; 4164 : 
; 4165 : 					if ( iWRCount > 0 )

  00340	85 c0		 test	 eax, eax
  00342	7e 7d		 jle	 SHORT $LN205@CGItemGetR

; 4166 : 					{
; 4167 : 						LogAdd("[Ring Event] Too many have Magician's Ring [%s][%s] (Name:%s, Count:%d)", gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), iWRCount);

  00344	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034a	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  00350	50		 push	 eax
  00351	03 f7		 add	 esi, edi
  00353	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00358	50		 push	 eax
  00359	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  0035c	52		 push	 edx
  0035d	83 c6 6c	 add	 esi, 108		; 0000006cH
  00360	56		 push	 esi
  00361	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 4168 : 
; 4169 : 						pResult.result = -1;
; 4170 : 						pResult.h.size -= sizeof(pResult.Data);

  0036c	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00372	04 f4		 add	 al, 244			; 000000f4H
  00374	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 4171 : 
; 4172 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0037a	0f b6 c0	 movzx	 eax, al
  0037d	50		 push	 eax
  0037e	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00384	51		 push	 ecx
  00385	53		 push	 ebx
  00386	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  0038d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00392	83 c4 20	 add	 esp, 32			; 00000020H

; 4173 : 						::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 186)), aIndex, 1);

  00395	6a 01		 push	 1
  00397	53		 push	 ebx
  00398	68 ba 04 00 00	 push	 1210			; 000004baH
$LN215@CGItemGetR:
  0039d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003a2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003a7	50		 push	 eax
  003a8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 4849 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b0	5e		 pop	 esi
  003b1	5f		 pop	 edi
  003b2	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  003b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b6	33 cd		 xor	 ecx, ebp
  003b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bd	8b e5		 mov	 esp, ebp
  003bf	5d		 pop	 ebp
  003c0	c3		 ret	 0
$LN205@CGItemGetR:

; 4183 : 					break;
; 4184 : 				
; 4185 : 			}
; 4186 : 		}
; 4187 : 
; 4188 : 		if ( lpItem->m_Type == ITEMGET(13,20) && lpItem->m_Level == 2 )

  003c1	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  003c5	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  003ca	66 3b c2	 cmp	 ax, dx
  003cd	75 0b		 jne	 SHORT $LN100@CGItemGetR
  003cf	66 83 7e 0c 02	 cmp	 WORD PTR [esi+12], 2

; 4189 : 		{
; 4190 : 			pResult.result = -1;
; 4191 : 			pResult.h.size -= sizeof(pResult.Data);
; 4192 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			
; 4193 : 			return;

  003d4	0f 84 92 14 00
	00		 je	 $LN92@CGItemGetR
$LN100@CGItemGetR:

; 4194 : 		}
; 4195 : 
; 4196 : 		if ( lpItem->m_Type == ITEMGET(13,38) )

  003da	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  003df	66 3b c2	 cmp	 ax, dx
  003e2	75 74		 jne	 SHORT $LN98@CGItemGetR

; 4197 : 		{
; 4198 : 			int count = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS, lpItem->m_Type % MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  003e4	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]
  003e8	50		 push	 eax
  003e9	6a 26		 push	 38			; 00000026H
  003eb	6a 0d		 push	 13			; 0000000dH
  003ed	53		 push	 ebx
  003ee	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  003f3	83 c4 10	 add	 esp, 16			; 00000010H

; 4199 : 
; 4200 : 			if ( count > 0 )

  003f6	85 c0		 test	 eax, eax
  003f8	7e 5e		 jle	 SHORT $LN98@CGItemGetR

; 4201 : 			{
; 4202 : 				LogAdd("[ MoonStonePendant ] Too many have MoonStonePendant [%s][%s] ( Name:%s, Count:%d )", gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), count);

  003fa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00400	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  00406	50		 push	 eax
  00407	03 f7		 add	 esi, edi
  00409	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0040e	50		 push	 eax
  0040f	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00412	52		 push	 edx
  00413	83 c6 6c	 add	 esi, 108		; 0000006cH
  00416	56		 push	 esi
  00417	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 4203 : 
; 4204 : 				pResult.result = -1;
; 4205 : 				pResult.h.size -= sizeof(pResult.Data);

  00422	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00428	04 f4		 add	 al, 244			; 000000f4H
  0042a	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 4206 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  00430	0f b6 c0	 movzx	 eax, al
  00433	50		 push	 eax
  00434	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0043a	51		 push	 ecx
  0043b	53		 push	 ebx
  0043c	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00443	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00448	83 c4 20	 add	 esp, 32			; 00000020H

; 4207 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13, 56)), aIndex, 1);

  0044b	6a 01		 push	 1
  0044d	53		 push	 ebx
  0044e	68 38 0d 00 00	 push	 3384			; 00000d38H

; 4208 : 				return;

  00453	e9 45 ff ff ff	 jmp	 $LN215@CGItemGetR
$LN98@CGItemGetR:

; 4209 : 			}
; 4210 : 		}
; 4211 : 
; 4212 : 		if ( lpItem->m_Type == ITEMGET(13,39) )

  00458	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  0045d	66 39 56 0a	 cmp	 WORD PTR [esi+10], dx
  00461	75 74		 jne	 SHORT $LN96@CGItemGetR

; 4213 : 		{
; 4214 : 			int count = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS, lpItem->m_Type % MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  00463	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]
  00467	50		 push	 eax
  00468	6a 27		 push	 39			; 00000027H
  0046a	6a 0d		 push	 13			; 0000000dH
  0046c	53		 push	 ebx
  0046d	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  00472	83 c4 10	 add	 esp, 16			; 00000010H

; 4215 : 
; 4216 : 			if ( count > 0 )

  00475	85 c0		 test	 eax, eax
  00477	7e 5e		 jle	 SHORT $LN96@CGItemGetR

; 4217 : 			{
; 4218 : 				LogAdd("[ ChangeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count:%d )", gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), count);

  00479	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047f	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  00485	50		 push	 eax
  00486	03 f7		 add	 esi, edi
  00488	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0048d	50		 push	 eax
  0048e	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00491	52		 push	 edx
  00492	83 c6 6c	 add	 esi, 108		; 0000006cH
  00495	56		 push	 esi
  00496	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@
  0049b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 4219 : 
; 4220 : 				pResult.result = -1;
; 4221 : 				pResult.h.size -= sizeof(pResult.Data);

  004a1	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  004a7	04 f4		 add	 al, 244			; 000000f4H
  004a9	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 4222 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  004af	0f b6 c0	 movzx	 eax, al
  004b2	50		 push	 eax
  004b3	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  004b9	51		 push	 ecx
  004ba	53		 push	 ebx
  004bb	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  004c2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004c7	83 c4 20	 add	 esp, 32			; 00000020H

; 4223 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13, 63)), aIndex, 1);

  004ca	6a 01		 push	 1
  004cc	53		 push	 ebx
  004cd	68 3f 0d 00 00	 push	 3391			; 00000d3fH

; 4224 : 				return;

  004d2	e9 c6 fe ff ff	 jmp	 $LN215@CGItemGetR
$LN96@CGItemGetR:

; 4225 : 			}
; 4226 : 		}
; 4227 : 
; 4228 : 		type = lpItem->m_Type;

  004d7	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]

; 4229 : 		level = lpItem->m_Level;

  004db	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]

; 4230 : 		special = lpItem->m_Special[0];
; 4231 : 		NOption = lpItem->m_NewOption;
; 4232 : 		strcpy(szItemName, lpItem->GetName());

  004df	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  004e5	89 95 d4 fe ff
	ff		 mov	 DWORD PTR _type$[ebp], edx
  004eb	89 85 ec fe ff
	ff		 mov	 DWORD PTR _level$[ebp], eax
  004f1	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  004f6	8d 55 84	 lea	 edx, DWORD PTR _szItemName$[ebp]
  004f9	2b d0		 sub	 edx, eax
  004fb	eb 03 8d 49 00	 npad	 5
$LL125@CGItemGetR:
  00500	8a 08		 mov	 cl, BYTE PTR [eax]
  00502	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00505	40		 inc	 eax
  00506	84 c9		 test	 cl, cl
  00508	75 f6		 jne	 SHORT $LL125@CGItemGetR

; 4233 : 
; 4234 : 		if ( lpItem->m_Type == ITEMGET(14,15) )

  0050a	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  0050e	b9 0f 1c 00 00	 mov	 ecx, 7183		; 00001c0fH
  00513	66 3b c1	 cmp	 ax, cx
  00516	0f 85 19 01 00
	00		 jne	 $LN95@CGItemGetR

; 4235 : 		{
; 4236 : 			if ( MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE )

  0051c	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  00522	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  00528	6a 00		 push	 0
  0052a	52		 push	 edx
  0052b	53		 push	 ebx
  0052c	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  00532	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00537	83 f8 01	 cmp	 eax, 1
  0053a	0f 85 e1 00 00
	00		 jne	 $LN94@CGItemGetR

; 4237 : 			{
; 4238 : 				if ( !gObjCheckMaxZen(aIndex, lpItem->m_BuyMoney))

  00540	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00543	50		 push	 eax
  00544	53		 push	 ebx
  00545	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  0054a	83 c4 08	 add	 esp, 8
  0054d	85 c0		 test	 eax, eax

; 4239 : 				{
; 4240 : 					if ( gObj[aIndex].Money < MAX_ZEN )

  0054f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00554	75 6c		 jne	 SHORT $LN93@CGItemGetR
  00556	b9 00 94 35 77	 mov	 ecx, 2000000000		; 77359400H
  0055b	39 8c 38 f0 00
	00 00		 cmp	 DWORD PTR [eax+edi+240], ecx
  00562	0f 8d 04 13 00
	00		 jge	 $LN92@CGItemGetR

; 4241 : 					{
; 4242 : 						gObj[aIndex].Money = MAX_ZEN;

  00568	89 8c 38 f0 00
	00 00		 mov	 DWORD PTR [eax+edi+240], ecx

; 4243 : 						pResult.result = -2;
; 4244 : 						WORD hiWord = SET_NUMBERHW(gObj[aIndex].Money);

  0056f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00575	c6 85 f7 fe ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH
  0057c	0f b7 84 39 f2
	00 00 00	 movzx	 eax, WORD PTR [ecx+edi+242]

; 4245 : 						WORD loWord = SET_NUMBERLW(gObj[aIndex].Money);

  00584	0f b7 8c 39 f0
	00 00 00	 movzx	 ecx, WORD PTR [ecx+edi+240]

; 4246 : 						pResult.Data[0] = SET_NUMBERH(hiWord);

  0058c	8b d0		 mov	 edx, eax

; 4247 : 						pResult.Data[1] = SET_NUMBERL(hiWord);

  0058e	88 85 f9 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], al

; 4248 : 						pResult.Data[2] = SET_NUMBERH(loWord);

  00594	8b c1		 mov	 eax, ecx
  00596	c1 ea 08	 shr	 edx, 8

; 4249 : 						pResult.Data[3] = SET_NUMBERL(loWord);

  00599	88 8d fb fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], cl

; 4250 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0059f	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  005a6	88 95 f8 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], dl
  005ac	c1 e8 08	 shr	 eax, 8
  005af	51		 push	 ecx
  005b0	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  005b6	88 85 fa fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al
  005bc	52		 push	 edx

; 4251 : 						return;

  005bd	e9 ca 12 00 00	 jmp	 $LN210@CGItemGetR
$LN93@CGItemGetR:

; 4252 : 					}
; 4253 : 
; 4254 : 					pResult.result = -1;
; 4255 : 					pResult.h.size -= sizeof(pResult.Data);
; 4256 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			
; 4257 : 					return;
; 4258 : 				}
; 4259 : 
; 4260 : 				gObj[aIndex].Money += lpItem->m_BuyMoney;

  005c2	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  005c5	01 94 38 f0 00
	00 00		 add	 DWORD PTR [eax+edi+240], edx

; 4261 : 				pResult.result = -2;
; 4262 : 				WORD hiWord = SET_NUMBERHW(gObj[aIndex].Money);

  005cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005d2	c6 85 f7 fe ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH
  005d9	0f b7 84 39 f2
	00 00 00	 movzx	 eax, WORD PTR [ecx+edi+242]

; 4263 : 				WORD loWord = SET_NUMBERLW(gObj[aIndex].Money);

  005e1	0f b7 8c 39 f0
	00 00 00	 movzx	 ecx, WORD PTR [ecx+edi+240]

; 4264 : 				pResult.Data[0] = SET_NUMBERH(hiWord);
; 4265 : 				pResult.Data[1] = SET_NUMBERL(hiWord);
; 4266 : 				pResult.Data[2] = SET_NUMBERH(loWord);
; 4267 : 				pResult.Data[3] = SET_NUMBERL(loWord);
; 4268 : 				pResult.h.size -= 3;

  005e9	80 85 f5 fe ff
	ff fd		 add	 BYTE PTR _pResult$[ebp+1], 253 ; 000000fdH
  005f0	8b d0		 mov	 edx, eax
  005f2	88 85 f9 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], al
  005f8	8b c1		 mov	 eax, ecx
  005fa	88 8d fb fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], cl

; 4269 : #if(SYSTEM_ACHIEVEMENTS)
; 4270 : 				g_Achievements.PickUpZen(aIndex, lpItem->m_BuyMoney);

  00600	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  00603	51		 push	 ecx
  00604	c1 ea 08	 shr	 edx, 8
  00607	c1 e8 08	 shr	 eax, 8
  0060a	53		 push	 ebx
  0060b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00610	88 95 f8 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], dl
  00616	88 85 fa fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al
  0061c	e8 00 00 00 00	 call	 ?PickUpZen@CAchievements@@QAEXHH@Z ; CAchievements::PickUpZen
$LN94@CGItemGetR:

; 4271 : #endif
; 4272 : 			}
; 4273 : 
; 4274 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00621	0f b6 95 f5 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00628	52		 push	 edx
  00629	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0062f	50		 push	 eax

; 4275 : 		}
; 4276 : 		else

  00630	e9 57 12 00 00	 jmp	 $LN210@CGItemGetR
$LN95@CGItemGetR:

; 4277 : 		{
; 4278 : 			if ( lpItem->m_Type == ITEMGET(13,32) )

  00635	b9 20 1a 00 00	 mov	 ecx, 6688		; 00001a20H
  0063a	66 3b c1	 cmp	 ax, cx
  0063d	0f 85 f0 00 00
	00		 jne	 $LN89@CGItemGetR

; 4279 : 			{
; 4280 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 20, ITEMGET(13,32), 0);

  00643	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  00649	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  0064f	6a 00		 push	 0
  00651	51		 push	 ecx
  00652	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  00658	6a 14		 push	 20			; 00000014H
  0065a	53		 push	 ebx
  0065b	52		 push	 edx
  0065c	50		 push	 eax
  0065d	51		 push	 ecx
  0065e	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00663	83 c4 1c	 add	 esp, 28			; 0000001cH
  00666	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pos$245736[ebp], eax

; 4281 : 
; 4282 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  0066c	85 c0		 test	 eax, eax
  0066e	0f 88 bf 00 00
	00		 js	 $LN89@CGItemGetR
  00674	33 c0		 xor	 eax, eax
  00676	81 bd e8 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245736[ebp], 203 ; 000000cbH
  00680	0f 9e c0	 setle	 al
  00683	85 c0		 test	 eax, eax
  00685	0f 84 a8 00 00
	00		 je	 $LN89@CGItemGetR

; 4283 : 				{
; 4284 : 					pResult.result = -3;
; 4285 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0068b	0f b6 95 f5 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00692	52		 push	 edx
  00693	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00699	50		 push	 eax
  0069a	53		 push	 ebx
  0069b	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  006a2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4286 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  006a7	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245736[ebp]
  006ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006b3	d9 46 28	 fld	 DWORD PTR [esi+40]
  006b6	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4287 : 					GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  006bd	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3594[ebp]
  006c3	8b c2		 mov	 eax, edx
  006c5	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  006cb	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  006cf	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  006d3	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  006d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006dd	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  006e4	6a 00		 push	 0
  006e6	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  006ea	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3594[ebp]
  006f1	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  006f6	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv3591[ebp], eax
  006fc	d9 ad ec fe ff
	ff		 fldcw	 WORD PTR tv3591[ebp]
  00702	db 9d ec fe ff
	ff		 fistp	 DWORD PTR tv3589[ebp]
  00708	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv3589[ebp]
  0070e	0f b6 c8	 movzx	 ecx, al
  00711	51		 push	 ecx
  00712	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3594[ebp]
  00718	52		 push	 edx
  00719	53		 push	 ebx
  0071a	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0071f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00722	5e		 pop	 esi
  00723	5f		 pop	 edi
  00724	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  00725	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00728	33 cd		 xor	 ecx, ebp
  0072a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072f	8b e5		 mov	 esp, ebp
  00731	5d		 pop	 ebp
  00732	c3		 ret	 0
$LN89@CGItemGetR:

; 4288 : 					return;
; 4289 : 				}
; 4290 : 			}
; 4291 : 
; 4292 : 			if ( lpItem->m_Type == ITEMGET(13,33) )

  00733	ba 21 1a 00 00	 mov	 edx, 6689		; 00001a21H
  00738	66 39 56 0a	 cmp	 WORD PTR [esi+10], dx
  0073c	0f 85 f0 00 00
	00		 jne	 $LN87@CGItemGetR

; 4293 : 			{
; 4294 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 20, ITEMGET(13,33), 0);

  00742	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  00748	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  0074e	6a 00		 push	 0
  00750	52		 push	 edx
  00751	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  00757	6a 14		 push	 20			; 00000014H
  00759	53		 push	 ebx
  0075a	50		 push	 eax
  0075b	51		 push	 ecx
  0075c	52		 push	 edx
  0075d	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00762	83 c4 1c	 add	 esp, 28			; 0000001cH
  00765	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pos$245743[ebp], eax

; 4295 : 
; 4296 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  0076b	85 c0		 test	 eax, eax
  0076d	0f 88 bf 00 00
	00		 js	 $LN87@CGItemGetR
  00773	33 c0		 xor	 eax, eax
  00775	81 bd e8 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245743[ebp], 203 ; 000000cbH
  0077f	0f 9e c0	 setle	 al
  00782	85 c0		 test	 eax, eax
  00784	0f 84 a8 00 00
	00		 je	 $LN87@CGItemGetR

; 4297 : 				{
; 4298 : 					pResult.result = -3;
; 4299 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0078a	0f b6 85 f5 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00791	50		 push	 eax
  00792	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00798	51		 push	 ecx
  00799	53		 push	 ebx
  0079a	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  007a1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4300 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  007a6	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245743[ebp]
  007ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007b2	d9 46 28	 fld	 DWORD PTR [esi+40]
  007b5	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4301 : 					GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  007bc	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3579[ebp]
  007c2	8b c2		 mov	 eax, edx
  007c4	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  007ca	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  007ce	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  007d2	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  007d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007dc	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  007e3	6a 00		 push	 0
  007e5	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  007e9	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3579[ebp]
  007f0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  007f5	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv3576[ebp], eax
  007fb	d9 ad ec fe ff
	ff		 fldcw	 WORD PTR tv3576[ebp]
  00801	db 9d ec fe ff
	ff		 fistp	 DWORD PTR tv3574[ebp]
  00807	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv3574[ebp]
  0080d	0f b6 c8	 movzx	 ecx, al
  00810	51		 push	 ecx
  00811	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3579[ebp]
  00817	52		 push	 edx
  00818	53		 push	 ebx
  00819	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0081e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00821	5e		 pop	 esi
  00822	5f		 pop	 edi
  00823	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  00824	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00827	33 cd		 xor	 ecx, ebp
  00829	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0082e	8b e5		 mov	 esp, ebp
  00830	5d		 pop	 ebp
  00831	c3		 ret	 0
$LN87@CGItemGetR:

; 4302 : 					return;
; 4303 : 				}
; 4304 : 			}
; 4305 : 
; 4306 : 			if ( lpItem->m_Type == ITEMGET(13,34) )

  00832	ba 22 1a 00 00	 mov	 edx, 6690		; 00001a22H
  00837	66 39 56 0a	 cmp	 WORD PTR [esi+10], dx
  0083b	0f 85 f0 00 00
	00		 jne	 $LN85@CGItemGetR

; 4307 : 			{
; 4308 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 10, ITEMGET(13,34), 0);

  00841	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  00847	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  0084d	6a 00		 push	 0
  0084f	52		 push	 edx
  00850	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  00856	6a 0a		 push	 10			; 0000000aH
  00858	53		 push	 ebx
  00859	50		 push	 eax
  0085a	51		 push	 ecx
  0085b	52		 push	 edx
  0085c	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00861	83 c4 1c	 add	 esp, 28			; 0000001cH
  00864	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pos$245750[ebp], eax

; 4309 : 
; 4310 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  0086a	85 c0		 test	 eax, eax
  0086c	0f 88 bf 00 00
	00		 js	 $LN85@CGItemGetR
  00872	33 c0		 xor	 eax, eax
  00874	81 bd e8 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245750[ebp], 203 ; 000000cbH
  0087e	0f 9e c0	 setle	 al
  00881	85 c0		 test	 eax, eax
  00883	0f 84 a8 00 00
	00		 je	 $LN85@CGItemGetR

; 4311 : 				{
; 4312 : 					pResult.result = -3;
; 4313 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00889	0f b6 85 f5 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00890	50		 push	 eax
  00891	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00897	51		 push	 ecx
  00898	53		 push	 ebx
  00899	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  008a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4314 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  008a5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245750[ebp]
  008ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008b1	d9 46 28	 fld	 DWORD PTR [esi+40]
  008b4	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4315 : 					GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  008bb	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3564[ebp]
  008c1	8b c2		 mov	 eax, edx
  008c3	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  008c9	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  008cd	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  008d1	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  008d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008db	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  008e2	6a 00		 push	 0
  008e4	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  008e8	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3564[ebp]
  008ef	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  008f4	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv3561[ebp], eax
  008fa	d9 ad ec fe ff
	ff		 fldcw	 WORD PTR tv3561[ebp]
  00900	db 9d ec fe ff
	ff		 fistp	 DWORD PTR tv3559[ebp]
  00906	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv3559[ebp]
  0090c	0f b6 c8	 movzx	 ecx, al
  0090f	51		 push	 ecx
  00910	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3564[ebp]
  00916	52		 push	 edx
  00917	53		 push	 ebx
  00918	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0091d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00920	5e		 pop	 esi
  00921	5f		 pop	 edi
  00922	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  00923	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00926	33 cd		 xor	 ecx, ebp
  00928	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0092d	8b e5		 mov	 esp, ebp
  0092f	5d		 pop	 ebp
  00930	c3		 ret	 0
$LN85@CGItemGetR:

; 4316 : 					return;
; 4317 : 				}
; 4318 : 			}
; 4319 : 
; 4320 : 			if (lpItem->m_Type == ITEMGET(14,70) ||	lpItem->m_Type == ITEMGET(14,71) ||	lpItem->m_Type == ITEMGET(14,94)) //season 3.5 add-on

  00931	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  00935	ba 46 1c 00 00	 mov	 edx, 7238		; 00001c46H
  0093a	66 3b c2	 cmp	 ax, dx
  0093d	74 18		 je	 SHORT $LN83@CGItemGetR
  0093f	b9 47 1c 00 00	 mov	 ecx, 7239		; 00001c47H
  00944	66 3b c1	 cmp	 ax, cx
  00947	74 0e		 je	 SHORT $LN83@CGItemGetR
  00949	ba 5e 1c 00 00	 mov	 edx, 7262		; 00001c5eH
  0094e	66 3b c2	 cmp	 ax, dx
  00951	0f 85 f1 00 00
	00		 jne	 $LN82@CGItemGetR
$LN83@CGItemGetR:

; 4321 : 			{
; 4322 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 50, lpItem->m_Type, 0);

  00957	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  0095d	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  00963	6a 00		 push	 0
  00965	98		 cwde
  00966	50		 push	 eax
  00967	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  0096d	6a 32		 push	 50			; 00000032H
  0096f	53		 push	 ebx
  00970	51		 push	 ecx
  00971	52		 push	 edx
  00972	50		 push	 eax
  00973	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00978	83 c4 1c	 add	 esp, 28			; 0000001cH
  0097b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pos$245758[ebp], eax

; 4323 : 
; 4324 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00981	85 c0		 test	 eax, eax
  00983	0f 88 bf 00 00
	00		 js	 $LN82@CGItemGetR
  00989	33 c0		 xor	 eax, eax
  0098b	81 bd e8 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245758[ebp], 203 ; 000000cbH
  00995	0f 9e c0	 setle	 al
  00998	85 c0		 test	 eax, eax
  0099a	0f 84 a8 00 00
	00		 je	 $LN82@CGItemGetR

; 4325 : 				{
; 4326 : 					pResult.result = -3;
; 4327 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  009a0	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  009a7	51		 push	 ecx
  009a8	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  009ae	52		 push	 edx
  009af	53		 push	 ebx
  009b0	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  009b7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4328 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  009bc	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245758[ebp]
  009c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009c8	d9 46 28	 fld	 DWORD PTR [esi+40]
  009cb	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4329 : 					GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  009d2	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3549[ebp]
  009d8	8b c2		 mov	 eax, edx
  009da	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  009e0	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  009e4	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  009e8	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  009ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009f2	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  009f9	6a 00		 push	 0
  009fb	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  009ff	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3549[ebp]
  00a06	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a0b	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv3546[ebp], eax
  00a11	d9 ad ec fe ff
	ff		 fldcw	 WORD PTR tv3546[ebp]
  00a17	db 9d ec fe ff
	ff		 fistp	 DWORD PTR tv3544[ebp]
  00a1d	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv3544[ebp]
  00a23	0f b6 c8	 movzx	 ecx, al
  00a26	51		 push	 ecx
  00a27	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3549[ebp]
  00a2d	52		 push	 edx
  00a2e	53		 push	 ebx
  00a2f	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00a34	83 c4 1c	 add	 esp, 28			; 0000001cH
  00a37	5e		 pop	 esi
  00a38	5f		 pop	 edi
  00a39	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  00a3a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a3d	33 cd		 xor	 ecx, ebp
  00a3f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a44	8b e5		 mov	 esp, ebp
  00a46	5d		 pop	 ebp
  00a47	c3		 ret	 0
$LN82@CGItemGetR:

; 4330 : 					return;
; 4331 : 				}
; 4332 : 			}
; 4333 : 
; 4334 : 			if (lpItem->m_Type == ITEMGET(14,88) ||	lpItem->m_Type == ITEMGET(14,89) ||	lpItem->m_Type == ITEMGET(14,90) || lpItem->m_Type == ITEMGET(14,85) ||	lpItem->m_Type == ITEMGET(14,86) ||	lpItem->m_Type == ITEMGET(14,87)) //season 3.5 add-on

  00a48	0f b7 4e 0a	 movzx	 ecx, WORD PTR [esi+10]
  00a4c	ba 58 1c 00 00	 mov	 edx, 7256		; 00001c58H
  00a51	66 3b ca	 cmp	 cx, dx
  00a54	74 36		 je	 SHORT $LN80@CGItemGetR
  00a56	b8 59 1c 00 00	 mov	 eax, 7257		; 00001c59H
  00a5b	66 3b c8	 cmp	 cx, ax
  00a5e	74 2c		 je	 SHORT $LN80@CGItemGetR
  00a60	ba 5a 1c 00 00	 mov	 edx, 7258		; 00001c5aH
  00a65	66 3b ca	 cmp	 cx, dx
  00a68	74 22		 je	 SHORT $LN80@CGItemGetR
  00a6a	b8 55 1c 00 00	 mov	 eax, 7253		; 00001c55H
  00a6f	66 3b c8	 cmp	 cx, ax
  00a72	74 18		 je	 SHORT $LN80@CGItemGetR
  00a74	ba 56 1c 00 00	 mov	 edx, 7254		; 00001c56H
  00a79	66 3b ca	 cmp	 cx, dx
  00a7c	74 0e		 je	 SHORT $LN80@CGItemGetR
  00a7e	b8 57 1c 00 00	 mov	 eax, 7255		; 00001c57H
  00a83	66 3b c8	 cmp	 cx, ax
  00a86	0f 85 23 01 00
	00		 jne	 $LN71@CGItemGetR
$LN80@CGItemGetR:

; 4335 : 			{
; 4336 : 				int iMaxOverLapped = 1;
; 4337 : 
; 4338 : 				switch(lpItem->m_Type)

  00a8c	0f bf c9	 movsx	 ecx, cx
  00a8f	8d 91 ab e3 ff
	ff		 lea	 edx, DWORD PTR [ecx-7253]
  00a95	b8 01 00 00 00	 mov	 eax, 1
  00a9a	83 fa 05	 cmp	 edx, 5
  00a9d	77 21		 ja	 SHORT $LN78@CGItemGetR
  00a9f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN220@CGItemGetR[edx*4]
$LN77@CGItemGetR:

; 4339 : 				{
; 4340 : 				case ITEMGET(14,88):	iMaxOverLapped = 10;	break;

  00aa6	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00aab	eb 13		 jmp	 SHORT $LN78@CGItemGetR
$LN76@CGItemGetR:

; 4341 : 				case ITEMGET(14,89):	iMaxOverLapped = 30;	break;

  00aad	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  00ab2	eb 0c		 jmp	 SHORT $LN78@CGItemGetR
$LN75@CGItemGetR:

; 4342 : 				case ITEMGET(14,90):	iMaxOverLapped = 50;	break;//SEE CONFLICT 

  00ab4	b8 32 00 00 00	 mov	 eax, 50			; 00000032H

; 4343 : 					/*#ifdef SEASON6DOT3_ENG //zt
; 4344 : 				case ITEMGET(14,90):	iMaxOverLapped = 255;	break;
; 4345 : #else*/
; 4346 : 				case ITEMGET(14,85):	iMaxOverLapped = 3;	break;

  00ab9	eb 05		 jmp	 SHORT $LN78@CGItemGetR
$LN72@CGItemGetR:

; 4347 : 				case ITEMGET(14,86):	iMaxOverLapped = 3;	break;
; 4348 : 				case ITEMGET(14,87):	iMaxOverLapped = 3;	break;

  00abb	b8 03 00 00 00	 mov	 eax, 3
$LN78@CGItemGetR:

; 4349 : 				}
; 4350 : 
; 4351 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, iMaxOverLapped, lpItem->m_Type, 0);

  00ac0	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  00ac6	6a 00		 push	 0
  00ac8	51		 push	 ecx
  00ac9	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  00acf	50		 push	 eax
  00ad0	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  00ad6	53		 push	 ebx
  00ad7	51		 push	 ecx
  00ad8	52		 push	 edx
  00ad9	50		 push	 eax
  00ada	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00adf	83 c4 1c	 add	 esp, 28			; 0000001cH
  00ae2	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pos$245777[ebp], eax

; 4352 : 
; 4353 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00ae8	85 c0		 test	 eax, eax
  00aea	0f 88 bf 00 00
	00		 js	 $LN71@CGItemGetR
  00af0	33 c0		 xor	 eax, eax
  00af2	81 bd e8 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245777[ebp], 203 ; 000000cbH
  00afc	0f 9e c0	 setle	 al
  00aff	85 c0		 test	 eax, eax
  00b01	0f 84 a8 00 00
	00		 je	 $LN71@CGItemGetR

; 4354 : 				{
; 4355 : 					pResult.result = -3;
; 4356 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00b07	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00b0e	51		 push	 ecx
  00b0f	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00b15	52		 push	 edx
  00b16	53		 push	 ebx
  00b17	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00b1e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4357 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00b23	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245777[ebp]
  00b29	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b2f	d9 46 28	 fld	 DWORD PTR [esi+40]
  00b32	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4358 : 					GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  00b39	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3533[ebp]
  00b3f	8b c2		 mov	 eax, edx
  00b41	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00b47	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  00b4b	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  00b4f	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00b53	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b59	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  00b60	6a 00		 push	 0
  00b62	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  00b66	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3533[ebp]
  00b6d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00b72	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv3530[ebp], eax
  00b78	d9 ad ec fe ff
	ff		 fldcw	 WORD PTR tv3530[ebp]
  00b7e	db 9d ec fe ff
	ff		 fistp	 DWORD PTR tv3528[ebp]
  00b84	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv3528[ebp]
  00b8a	0f b6 c8	 movzx	 ecx, al
  00b8d	51		 push	 ecx
  00b8e	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3533[ebp]
  00b94	52		 push	 edx
  00b95	53		 push	 ebx
  00b96	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00b9b	83 c4 1c	 add	 esp, 28			; 0000001cH
  00b9e	5e		 pop	 esi
  00b9f	5f		 pop	 edi
  00ba0	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  00ba1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ba4	33 cd		 xor	 ecx, ebp
  00ba6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bab	8b e5		 mov	 esp, ebp
  00bad	5d		 pop	 ebp
  00bae	c3		 ret	 0
$LN71@CGItemGetR:

; 4359 : 					return;
; 4360 : 				}
; 4361 : 			}
; 4362 : 			
; 4363 : 			if ( lpItem->m_Type == ITEMGET(14,29) )

  00baf	ba 1d 1c 00 00	 mov	 edx, 7197		; 00001c1dH
  00bb4	66 39 56 0a	 cmp	 WORD PTR [esi+10], dx
  00bb8	0f 85 b2 02 00
	00		 jne	 $LN66@CGItemGetR

; 4364 : 			{
; 4365 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00bbe	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$245784[ebp], 0
$LL69@CGItemGetR:

; 4366 : 				{
; 4367 : 					int pos = ::g_KalimaGate.CheckOverlapKundunMark(aIndex, lpItem->m_Level);

  00bc8	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  00bcc	50		 push	 eax
  00bcd	53		 push	 ebx
  00bce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00bd3	e8 00 00 00 00	 call	 ?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z ; CKalimaGate::CheckOverlapKundunMark
  00bd8	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _pos$245788[ebp], eax

; 4368 : 
; 4369 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  00bde	85 c0		 test	 eax, eax
  00be0	0f 88 8a 02 00
	00		 js	 $LN66@CGItemGetR
  00be6	33 c0		 xor	 eax, eax
  00be8	81 bd e4 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245788[ebp], 203 ; 000000cbH
  00bf2	0f 9e c0	 setle	 al
  00bf5	85 c0		 test	 eax, eax
  00bf7	0f 84 73 02 00
	00		 je	 $LN66@CGItemGetR

; 4370 : 					{
; 4371 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00bfd	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  00c03	6a 01		 push	 1
  00c05	51		 push	 ecx
  00c06	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  00c0c	53		 push	 ebx
  00c0d	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  00c13	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00c18	83 f8 01	 cmp	 eax, 1
  00c1b	0f 85 37 02 00
	00		 jne	 $LN68@CGItemGetR

; 4372 : 						{
; 4373 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 4374 : 
; 4375 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  00c21	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  00c27	52		 push	 edx
  00c28	8d 45 ec	 lea	 eax, DWORD PTR _NewOption$245791[ebp]
  00c2b	50		 push	 eax
  00c2c	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 4376 : 
; 4377 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num, gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type, level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7, g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  00c31	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  00c37	83 c4 08	 add	 esp, 8
  00c3a	51		 push	 ecx
  00c3b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00c40	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  00c45	0f b6 d0	 movzx	 edx, al
  00c48	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  00c4e	52		 push	 edx
  00c4f	50		 push	 eax
  00c50	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00c55	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  00c5a	0f b6 96 ce 00
	00 00		 movzx	 edx, BYTE PTR [esi+206]
  00c61	d9 46 28	 fld	 DWORD PTR [esi+40]
  00c64	0f b6 c8	 movzx	 ecx, al
  00c67	0f b6 86 b2 00
	00 00		 movzx	 eax, BYTE PTR [esi+178]
  00c6e	51		 push	 ecx
  00c6f	0f b6 4d f2	 movzx	 ecx, BYTE PTR _NewOption$245791[ebp+6]
  00c73	c1 ea 07	 shr	 edx, 7
  00c76	52		 push	 edx
  00c77	0f b6 55 f1	 movzx	 edx, BYTE PTR _NewOption$245791[ebp+5]
  00c7b	50		 push	 eax
  00c7c	0f b6 45 f0	 movzx	 eax, BYTE PTR _NewOption$245791[ebp+4]
  00c80	51		 push	 ecx
  00c81	0f b6 4d ef	 movzx	 ecx, BYTE PTR _NewOption$245791[ebp+3]
  00c85	52		 push	 edx
  00c86	0f b6 55 ee	 movzx	 edx, BYTE PTR _NewOption$245791[ebp+2]
  00c8a	50		 push	 eax
  00c8b	0f b6 45 ed	 movzx	 eax, BYTE PTR _NewOption$245791[ebp+1]
  00c8f	51		 push	 ecx
  00c90	0f b6 4d ec	 movzx	 ecx, BYTE PTR _NewOption$245791[ebp]
  00c94	52		 push	 edx
  00c95	50		 push	 eax
  00c96	51		 push	 ecx
  00c97	e8 00 00 00 00	 call	 __ftol2_sse
  00c9c	0f b6 96 9a 00
	00 00		 movzx	 edx, BYTE PTR [esi+154]
  00ca3	0f b6 8e 98 00
	00 00		 movzx	 ecx, BYTE PTR [esi+152]
  00caa	50		 push	 eax
  00cab	0f b6 86 99 00
	00 00		 movzx	 eax, BYTE PTR [esi+153]
  00cb2	52		 push	 edx
  00cb3	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _level$[ebp]
  00cb9	50		 push	 eax
  00cba	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _type$[ebp]
  00cc0	51		 push	 ecx
  00cc1	52		 push	 edx
  00cc2	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  00cc8	50		 push	 eax
  00cc9	8b 02		 mov	 eax, DWORD PTR [edx]
  00ccb	8d 4d 84	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  00cce	51		 push	 ecx
  00ccf	50		 push	 eax
  00cd0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cd5	0f bf 8c 07 46
	01 00 00	 movsx	 ecx, WORD PTR [edi+eax+326]
  00cdd	0f bf 94 07 44
	01 00 00	 movsx	 edx, WORD PTR [edi+eax+324]
  00ce5	51		 push	 ecx
  00ce6	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  00cec	52		 push	 edx
  00ced	51		 push	 ecx
  00cee	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00cf2	52		 push	 edx
  00cf3	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  00cf7	50		 push	 eax
  00cf8	68 dd 01 00 00	 push	 477			; 000001ddH
  00cfd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00d02	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00d07	50		 push	 eax
  00d08	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4378 : 
; 4379 : 							pResult.result = -3;
; 4380 : 
; 4381 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  00d0e	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00d15	51		 push	 ecx
  00d16	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00d1c	52		 push	 edx
  00d1d	53		 push	 ebx
  00d1e	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00d25	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4382 : 
; 4383 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00d2a	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _pos$245788[ebp]
  00d30	83 c4 70	 add	 esp, 112		; 00000070H
  00d33	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00d39	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d3e	8b 94 07 24 0e
	00 00		 mov	 edx, DWORD PTR [edi+eax+3620]
  00d45	d9 44 0a 24	 fld	 DWORD PTR [edx+ecx+36]
  00d49	8d 44 0a 24	 lea	 eax, DWORD PTR [edx+ecx+36]
  00d4d	d8 46 28	 fadd	 DWORD PTR [esi+40]
  00d50	89 4d f8	 mov	 DWORD PTR tv3359[ebp], ecx
  00d53	d9 18		 fstp	 DWORD PTR [eax]

; 4384 : 
; 4385 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  00d55	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d5b	8b 84 17 24 0e
	00 00		 mov	 eax, DWORD PTR [edi+edx+3620]
  00d62	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  00d68	d8 5c 08 24	 fcomp	 DWORD PTR [eax+ecx+36]
  00d6c	8d 4c 08 24	 lea	 ecx, DWORD PTR [eax+ecx+36]
  00d70	df e0		 fnstsw	 ax
  00d72	f6 c4 41	 test	 ah, 65			; 00000041H
  00d75	0f 8a 74 02 00
	00		 jp	 $LN64@CGItemGetR

; 4386 : 							{
; 4387 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  00d7b	d9 01		 fld	 DWORD PTR [ecx]
  00d7d	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  00d83	e8 00 00 00 00	 call	 __ftol2_sse

; 4388 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  00d88	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _pos$245788[ebp]
  00d8e	68 ff 00 00 00	 push	 255			; 000000ffH
  00d93	51		 push	 ecx
  00d94	53		 push	 ebx
  00d95	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _NewDur$245798[ebp], eax
  00d9b	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 4389 : 								gObj[aIndex].pInventory[pos].Clear();

  00da0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00da6	8b 8c 17 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+edx+3620]
  00dad	03 4d f8	 add	 ecx, DWORD PTR tv3359[ebp]
  00db0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00db3	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 4390 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  00db8	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pos$245788[ebp]
  00dbe	6a 01		 push	 1
  00dc0	50		 push	 eax
  00dc1	53		 push	 ebx
  00dc2	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 4391 : 								::ItemSerialCreateSend(aIndex, 235, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, ItemGetNumberMake(14, 28), (BYTE)lpItem->m_Level, 0, 0, 0, 0, aIndex, 0, 0);

  00dc7	0f b6 4e 0c	 movzx	 ecx, BYTE PTR [esi+12]
  00dcb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dce	6a 00		 push	 0
  00dd0	6a 00		 push	 0
  00dd2	53		 push	 ebx
  00dd3	6a 00		 push	 0
  00dd5	6a 00		 push	 0
  00dd7	6a 00		 push	 0
  00dd9	6a 00		 push	 0
  00ddb	51		 push	 ecx
  00ddc	6a 1c		 push	 28			; 0000001cH
  00dde	6a 0e		 push	 14			; 0000000eH
  00de0	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00de5	83 c4 08	 add	 esp, 8
  00de8	50		 push	 eax
  00de9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dee	0f b6 94 07 46
	01 00 00	 movzx	 edx, BYTE PTR [edi+eax+326]
  00df6	0f b6 84 07 44
	01 00 00	 movzx	 eax, BYTE PTR [edi+eax+324]
  00dfe	52		 push	 edx
  00dff	50		 push	 eax
  00e00	68 eb 00 00 00	 push	 235			; 000000ebH
  00e05	53		 push	 ebx
  00e06	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 4392 : 
; 4393 : 								LogAddTD("[Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)", gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  00e0b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e10	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _NewDur$245798[ebp]
  00e16	51		 push	 ecx
  00e17	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00e1b	52		 push	 edx
  00e1c	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  00e20	50		 push	 eax
  00e21	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@
  00e26	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00e2c	83 c4 44	 add	 esp, 68			; 00000044H

; 4394 : 
; 4395 : 								if ( NewDur > 0 )

  00e2f	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _NewDur$245798[ebp], 0
  00e36	0f 8e 59 0a 00
	00		 jle	 $LN209@CGItemGetR

; 4396 : 								{
; 4397 : 									lpItem->m_State = 2;
; 4398 : 									lpItem->Give = false;
; 4399 : 									lpItem->live = true;
; 4400 : 									lpItem->m_Durability = (float)NewDur;

  00e3c	db 85 e8 fe ff
	ff		 fild	 DWORD PTR _NewDur$245798[ebp]
  00e42	c7 86 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+220], 2
  00e4c	66 c7 86 da 00
	00 00 01 00	 mov	 WORD PTR [esi+218], 1
  00e55	d9 5e 28	 fstp	 DWORD PTR [esi+40]
$LN68@CGItemGetR:

; 4364 : 			{
; 4365 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00e58	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _n$245784[ebp]
  00e5e	40		 inc	 eax
  00e5f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _n$245784[ebp], eax
  00e65	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  00e6a	0f 8c 58 fd ff
	ff		 jl	 $LL69@CGItemGetR
$LN66@CGItemGetR:

; 4407 : 								
; 4408 : 							}
; 4409 : 							return;
; 4410 : 						}
; 4411 : 					}
; 4412 : 					else
; 4413 : 					{
; 4414 : 						break;
; 4415 : 					}
; 4416 : 				}
; 4417 : 			}
; 4418 : 
; 4419 : 			//Season 5 DoppelGanger
; 4420 : 			if ( lpItem->m_Type == ITEMGET(14,110) ) // Double Goar

  00e70	b8 6e 1c 00 00	 mov	 eax, 7278		; 00001c6eH
  00e75	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  00e79	0f 85 f9 01 00
	00		 jne	 $LN59@CGItemGetR

; 4421 : 			{
; 4422 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 10, ITEMGET(14,110), 0);

  00e7f	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  00e85	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  00e8b	6a 00		 push	 0
  00e8d	50		 push	 eax
  00e8e	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  00e94	6a 0a		 push	 10			; 0000000aH
  00e96	53		 push	 ebx
  00e97	51		 push	 ecx
  00e98	52		 push	 edx
  00e99	50		 push	 eax
  00e9a	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00e9f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00ea2	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _pos$245811[ebp], eax

; 4423 : 				if ( MAIN_INVENTORY_RANGE(pos) )

  00ea8	85 c0		 test	 eax, eax
  00eaa	0f 88 c8 01 00
	00		 js	 $LN59@CGItemGetR
  00eb0	33 c0		 xor	 eax, eax
  00eb2	81 bd e4 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245811[ebp], 203 ; 000000cbH
  00ebc	0f 9e c0	 setle	 al
  00ebf	85 c0		 test	 eax, eax
  00ec1	0f 84 b1 01 00
	00		 je	 $LN59@CGItemGetR

; 4424 : 				{
; 4425 : 					pResult.result = -3; //#error
; 4426 : 
; 4427 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  00ec7	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00ece	51		 push	 ecx
  00ecf	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00ed5	52		 push	 edx
  00ed6	53		 push	 ebx
  00ed7	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00ede	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4428 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00ee3	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pos$245811[ebp]
  00ee9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00eef	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00ef5	8b 94 39 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+edi+3620]
  00efc	8d 4c 02 24	 lea	 ecx, DWORD PTR [edx+eax+36]
  00f00	89 45 f8	 mov	 DWORD PTR tv3400[ebp], eax
  00f03	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f06	d9 01		 fld	 DWORD PTR [ecx]
  00f08	d8 46 28	 fadd	 DWORD PTR [esi+40]
  00f0b	d9 19		 fstp	 DWORD PTR [ecx]

; 4429 : 
; 4430 : 					if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  00f0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f13	8b 94 39 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+edi+3620]
  00f1a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  00f20	d8 5c 02 24	 fcomp	 DWORD PTR [edx+eax+36]
  00f24	8d 4c 02 24	 lea	 ecx, DWORD PTR [edx+eax+36]
  00f28	df e0		 fnstsw	 ax
  00f2a	f6 c4 41	 test	 ah, 65			; 00000041H
  00f2d	0f 8a 1a 01 00
	00		 jp	 $LN58@CGItemGetR

; 4431 : 					{
; 4432 : 						int NewDur = gObj[aIndex].pInventory[pos].m_Durability - 5.0f;

  00f33	d9 01		 fld	 DWORD PTR [ecx]
  00f35	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  00f3b	e8 00 00 00 00	 call	 __ftol2_sse
  00f40	89 85 ec fe ff
	ff		 mov	 DWORD PTR _NewDur$245816[ebp], eax

; 4433 : 						::gObjInventoryItemSet(aIndex, pos, -1);

  00f46	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pos$245811[ebp]
  00f4c	68 ff 00 00 00	 push	 255			; 000000ffH
  00f51	50		 push	 eax
  00f52	53		 push	 ebx
  00f53	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 4434 : 						gObj[aIndex].pInventory[pos].Clear();

  00f58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f5e	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  00f65	03 4d f8	 add	 ecx, DWORD PTR tv3400[ebp]
  00f68	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f6b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 4435 : 						::GCInventoryItemDeleteSend(aIndex, pos, 1);

  00f70	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245811[ebp]
  00f76	6a 01		 push	 1
  00f78	52		 push	 edx
  00f79	53		 push	 ebx
  00f7a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 4436 : 						::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 111),
; 4437 : 							lpItem->m_Level, 0, 0, 0, 0, aIndex, 0, 0);

  00f7f	0f b6 4e 0c	 movzx	 ecx, BYTE PTR [esi+12]
  00f83	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f88	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f8b	6a 00		 push	 0
  00f8d	6a 00		 push	 0
  00f8f	53		 push	 ebx
  00f90	6a 00		 push	 0
  00f92	6a 00		 push	 0
  00f94	6a 00		 push	 0
  00f96	6a 00		 push	 0
  00f98	51		 push	 ecx
  00f99	03 c7		 add	 eax, edi
  00f9b	6a 6f		 push	 111			; 0000006fH
  00f9d	6a 0e		 push	 14			; 0000000eH
  00f9f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv3074[ebp], eax
  00fa5	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00faa	83 c4 08	 add	 esp, 8
  00fad	50		 push	 eax
  00fae	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv3074[ebp]
  00fb4	0f b6 90 46 01
	00 00		 movzx	 edx, BYTE PTR [eax+326]
  00fbb	0f b6 80 44 01
	00 00		 movzx	 eax, BYTE PTR [eax+324]
  00fc2	52		 push	 edx
  00fc3	50		 push	 eax
  00fc4	68 eb 00 00 00	 push	 235			; 000000ebH
  00fc9	53		 push	 ebx
  00fca	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 4438 : 
; 4439 : 						LogAdd("[DoubleGoer] [%s][%s] Make Dimension Magyon (Left Marker %d)",
; 4440 : 							gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  00fcf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fd4	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _NewDur$245816[ebp]
  00fda	53		 push	 ebx
  00fdb	8d 4c 38 77	 lea	 ecx, DWORD PTR [eax+edi+119]
  00fdf	51		 push	 ecx
  00fe0	8d 54 38 6c	 lea	 edx, DWORD PTR [eax+edi+108]
  00fe4	52		 push	 edx
  00fe5	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MJPFIFLE@?$FLDoubleGoer?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dimen@

; 4441 : 
; 4442 : 						if ( NewDur > 0 )
; 4443 : 						{
; 4444 : 							lpItem->m_State = 2;
; 4445 : 							lpItem->Give = false;
; 4446 : 							lpItem->live = true;
; 4447 : 							lpItem->m_Durability = NewDur;
; 4448 : 
; 4449 : 							//	continue;
; 4450 : 
; 4451 : 						}
; 4452 : 					}
; 4453 : 					else

  00fea	e9 03 02 00 00	 jmp	 $LN218@CGItemGetR
$LN64@CGItemGetR:

; 4401 : 									continue;
; 4402 : 								}
; 4403 : 							}
; 4404 : 							else
; 4405 : 							{
; 4406 : 								GCItemDurSend(aIndex,(BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  00fef	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _pos$245788[ebp]
  00ff5	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3486[ebp]
  00ffb	8b 94 3a 24 0e
	00 00		 mov	 edx, DWORD PTR [edx+edi+3620]
  01002	8b c1		 mov	 eax, ecx
  01004	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0100a	6a 00		 push	 0
  0100c	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01010	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3486[ebp]
  01017	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0101c	89 45 f8	 mov	 DWORD PTR tv3483[ebp], eax
  0101f	d9 6d f8	 fldcw	 WORD PTR tv3483[ebp]
  01022	db 5d f8	 fistp	 DWORD PTR tv3481[ebp]
  01025	8a 45 f8	 mov	 al, BYTE PTR tv3481[ebp]
  01028	0f b6 d0	 movzx	 edx, al
  0102b	52		 push	 edx
  0102c	51		 push	 ecx
  0102d	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3486[ebp]

; 4495 : 
; 4496 : 								//	continue;
; 4497 : 
; 4498 : 								}
; 4499 : 							}
; 4500 : 							else
; 4501 : 							{
; 4502 : 								GCItemDurSend(aIndex,pos, gObj[aIndex].pInventory[pos].m_Durability, 0);

  01033	53		 push	 ebx
  01034	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01039	83 c4 10	 add	 esp, 16			; 00000010H
  0103c	5e		 pop	 esi
  0103d	5f		 pop	 edi
  0103e	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  0103f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01042	33 cd		 xor	 ecx, ebp
  01044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01049	8b e5		 mov	 esp, ebp
  0104b	5d		 pop	 ebp
  0104c	c3		 ret	 0
$LN58@CGItemGetR:

; 4454 : 					{
; 4455 : 						GCItemDurSend(aIndex,pos, gObj[aIndex].pInventory[pos].m_Durability, 0);

  0104d	d9 01		 fld	 DWORD PTR [ecx]
  0104f	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3453[ebp]
  01055	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3453[ebp]
  0105c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01061	89 45 f8	 mov	 DWORD PTR tv3450[ebp], eax
  01064	d9 6d f8	 fldcw	 WORD PTR tv3450[ebp]
  01067	db 5d f8	 fistp	 DWORD PTR tv3448[ebp]
  0106a	8a 45 f8	 mov	 al, BYTE PTR tv3448[ebp]
  0106d	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3453[ebp]

; 4456 : 
; 4457 : 					}
; 4458 : 					return;

  01073	e9 de 01 00 00	 jmp	 $LN219@CGItemGetR
$LN59@CGItemGetR:

; 4459 : 				}
; 4460 : 				else
; 4461 : 				{
; 4462 : 
; 4463 : 				}
; 4464 : 			}
; 4465 : 			//Season 5 ImperialFort
; 4466 : #ifdef IMPERIAL_CONFLICT_OLD
; 4467 : 			if ( lpItem->m_Type == ITEMGET(14,101) ) // Imperial Fort

  01078	b8 65 1c 00 00	 mov	 eax, 7269		; 00001c65H
  0107d	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  01081	0f 85 f6 01 00
	00		 jne	 $LN53@CGItemGetR

; 4468 : 			{
; 4469 : 					int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 10, ITEMGET(14,101), 0);

  01087	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  0108d	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  01093	6a 00		 push	 0
  01095	50		 push	 eax
  01096	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  0109c	6a 0a		 push	 10			; 0000000aH
  0109e	53		 push	 ebx
  0109f	51		 push	 ecx
  010a0	52		 push	 edx
  010a1	50		 push	 eax
  010a2	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  010a7	83 c4 1c	 add	 esp, 28			; 0000001cH
  010aa	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _pos$245822[ebp], eax

; 4470 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  010b0	85 c0		 test	 eax, eax
  010b2	0f 88 c5 01 00
	00		 js	 $LN53@CGItemGetR
  010b8	33 c0		 xor	 eax, eax
  010ba	81 bd e4 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245822[ebp], 203 ; 000000cbH
  010c4	0f 9e c0	 setle	 al
  010c7	85 c0		 test	 eax, eax
  010c9	0f 84 ae 01 00
	00		 je	 $LN53@CGItemGetR

; 4471 : 					{
; 4472 : 						pResult.result = -3; // #error
; 4473 : 
; 4474 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  010cf	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  010d6	51		 push	 ecx
  010d7	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  010dd	52		 push	 edx
  010de	53		 push	 ebx
  010df	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  010e6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4475 : 						gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  010eb	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pos$245822[ebp]
  010f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010f7	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  010fd	8b 94 39 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+edi+3620]
  01104	8d 4c 02 24	 lea	 ecx, DWORD PTR [edx+eax+36]
  01108	89 45 f8	 mov	 DWORD PTR tv3431[ebp], eax
  0110b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0110e	d9 01		 fld	 DWORD PTR [ecx]
  01110	d8 46 28	 fadd	 DWORD PTR [esi+40]
  01113	d9 19		 fstp	 DWORD PTR [ecx]

; 4476 : 
; 4477 : 						if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  01115	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0111b	8b 94 39 24 0e
	00 00		 mov	 edx, DWORD PTR [ecx+edi+3620]
  01122	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@40a00000
  01128	d8 5c 02 24	 fcomp	 DWORD PTR [edx+eax+36]
  0112c	8d 4c 02 24	 lea	 ecx, DWORD PTR [edx+eax+36]
  01130	df e0		 fnstsw	 ax
  01132	f6 c4 41	 test	 ah, 65			; 00000041H
  01135	0f 8a f5 00 00
	00		 jp	 $LN52@CGItemGetR

; 4478 : 							{
; 4479 : 								int NewDur = gObj[aIndex].pInventory[pos].m_Durability - 5.0f;

  0113b	d9 01		 fld	 DWORD PTR [ecx]
  0113d	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@4014000000000000
  01143	e8 00 00 00 00	 call	 __ftol2_sse
  01148	89 85 ec fe ff
	ff		 mov	 DWORD PTR _NewDur$245827[ebp], eax

; 4480 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  0114e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pos$245822[ebp]
  01154	68 ff 00 00 00	 push	 255			; 000000ffH
  01159	50		 push	 eax
  0115a	53		 push	 ebx
  0115b	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 4481 : 								gObj[aIndex].pInventory[pos].Clear();

  01160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01166	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  0116d	03 4d f8	 add	 ecx, DWORD PTR tv3431[ebp]
  01170	83 c4 0c	 add	 esp, 12			; 0000000cH
  01173	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 4482 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  01178	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245822[ebp]
  0117e	6a 01		 push	 1
  01180	52		 push	 edx
  01181	53		 push	 ebx
  01182	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 4483 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 102),
; 4484 : 									lpItem->m_Level, 0, 0, 0, 0, aIndex, 0, 0);

  01187	0f b6 4e 0c	 movzx	 ecx, BYTE PTR [esi+12]
  0118b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01190	83 c4 0c	 add	 esp, 12			; 0000000cH
  01193	6a 00		 push	 0
  01195	6a 00		 push	 0
  01197	53		 push	 ebx
  01198	6a 00		 push	 0
  0119a	6a 00		 push	 0
  0119c	6a 00		 push	 0
  0119e	6a 00		 push	 0
  011a0	51		 push	 ecx
  011a1	03 c7		 add	 eax, edi
  011a3	6a 66		 push	 102			; 00000066H
  011a5	6a 0e		 push	 14			; 0000000eH
  011a7	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv3074[ebp], eax
  011ad	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  011b2	83 c4 08	 add	 esp, 8
  011b5	50		 push	 eax
  011b6	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv3074[ebp]
  011bc	0f b6 90 46 01
	00 00		 movzx	 edx, BYTE PTR [eax+326]
  011c3	0f b6 80 44 01
	00 00		 movzx	 eax, BYTE PTR [eax+324]
  011ca	52		 push	 edx
  011cb	50		 push	 eax
  011cc	68 eb 00 00 00	 push	 235			; 000000ebH
  011d1	53		 push	 ebx
  011d2	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend

; 4485 : 
; 4486 : 								LogAdd("[Imperial Fort] [%s][%s] Make Dimension Magyon (Left Marker %d)",
; 4487 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);

  011d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011dc	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _NewDur$245827[ebp]
  011e2	53		 push	 ebx
  011e3	8d 4c 38 77	 lea	 ecx, DWORD PTR [eax+edi+119]
  011e7	51		 push	 ecx
  011e8	8d 54 38 6c	 lea	 edx, DWORD PTR [eax+edi+108]
  011ec	52		 push	 edx
  011ed	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@LDDOEGMA@?$FLImperial?5Fort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Di@
$LN218@CGItemGetR:
  011f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  011f8	83 c4 44	 add	 esp, 68			; 00000044H

; 4488 : 
; 4489 : 								if ( NewDur > 0 )

  011fb	85 db		 test	 ebx, ebx
  011fd	0f 8e 92 06 00
	00		 jle	 $LN209@CGItemGetR

; 4490 : 								{
; 4491 : 									lpItem->m_State = 2;
; 4492 : 									lpItem->Give = false;
; 4493 : 									lpItem->live = true;
; 4494 : 									lpItem->m_Durability = NewDur;

  01203	db 85 ec fe ff
	ff		 fild	 DWORD PTR _NewDur$245827[ebp]
  01209	c7 86 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+220], 2
  01213	66 c7 86 da 00
	00 00 01 00	 mov	 WORD PTR [esi+218], 1
  0121c	d9 5e 28	 fstp	 DWORD PTR [esi+40]
  0121f	5e		 pop	 esi
  01220	5f		 pop	 edi
  01221	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  01222	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01225	33 cd		 xor	 ecx, ebp
  01227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0122c	8b e5		 mov	 esp, ebp
  0122e	5d		 pop	 ebp
  0122f	c3		 ret	 0
$LN52@CGItemGetR:

; 4495 : 
; 4496 : 								//	continue;
; 4497 : 
; 4498 : 								}
; 4499 : 							}
; 4500 : 							else
; 4501 : 							{
; 4502 : 								GCItemDurSend(aIndex,pos, gObj[aIndex].pInventory[pos].m_Durability, 0);

  01230	d9 01		 fld	 DWORD PTR [ecx]
  01232	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3419[ebp]
  01238	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3419[ebp]
  0123f	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01244	89 45 f8	 mov	 DWORD PTR tv3416[ebp], eax
  01247	d9 6d f8	 fldcw	 WORD PTR tv3416[ebp]
  0124a	db 5d f8	 fistp	 DWORD PTR tv3414[ebp]
  0124d	8a 45 f8	 mov	 al, BYTE PTR tv3414[ebp]
  01250	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3419[ebp]
$LN219@CGItemGetR:
  01256	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245822[ebp]
  0125c	0f b6 c8	 movzx	 ecx, al
  0125f	6a 00		 push	 0
  01261	51		 push	 ecx
  01262	52		 push	 edx
  01263	53		 push	 ebx
  01264	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01269	83 c4 10	 add	 esp, 16			; 00000010H
  0126c	5e		 pop	 esi
  0126d	5f		 pop	 edi
  0126e	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  0126f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01272	33 cd		 xor	 ecx, ebp
  01274	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01279	8b e5		 mov	 esp, ebp
  0127b	5d		 pop	 ebp
  0127c	c3		 ret	 0
$LN53@CGItemGetR:

; 4503 : 								
; 4504 : 							}
; 4505 : 						return;
; 4506 : 					}
; 4507 : 			}
; 4508 : #endif
; 4509 : 			
; 4510 : #ifdef IMPERIAL_CONFLICT_NEW
; 4511 : 			if ( lpItem->m_Type == ITEMGET(14,101) )	//OK
; 4512 : 			{
; 4513 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)
; 4514 : 				{
; 4515 : 					int pos = g_ImperialGuardian.CheckOverlapMysteriousPaper(aIndex, lpItem->m_Level);
; 4516 : 
; 4517 : 					if ( MAIN_INVENTORY_RANGE(pos) )
; 4518 : 					{
; 4519 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )
; 4520 : 						{
; 4521 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 4522 : 
; 4523 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);
; 4524 : 
; 4525 : 							//LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num, gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type, level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7, g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));
; 4526 : 
; 4527 : 							pResult.result = -3;
; 4528 : 
; 4529 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			
; 4530 : 
; 4531 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;
; 4532 : 
; 4533 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )
; 4534 : 							{
; 4535 : 								int NewDur = gObj[aIndex].pInventory[pos].m_Durability - 5.0f;
; 4536 : 								::gObjInventoryItemSet(aIndex, pos, -1);
; 4537 : 								gObj[aIndex].pInventory[pos].Clear();
; 4538 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);
; 4539 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, 
; 4540 : 									ItemGetNumberMake(14, 102), lpItem->m_Level, 0, 0, 0, 0, aIndex, 0, 0);
; 4541 : 
; 4542 : 								//LogAddTD("[Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)", gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);
; 4543 : 
; 4544 : 								if ( NewDur > 0 )
; 4545 : 								{
; 4546 : 									lpItem->m_State = 2;
; 4547 : 									lpItem->Give = false;
; 4548 : 									lpItem->live = true;
; 4549 : 									lpItem->m_Durability = NewDur;
; 4550 : 									continue;
; 4551 : 								}
; 4552 : 							}
; 4553 : 							else
; 4554 : 							{
; 4555 : 								GCItemDurSend(aIndex,pos, gObj[aIndex].pInventory[pos].m_Durability, 0);
; 4556 : 
; 4557 : 							}
; 4558 : 							return;
; 4559 : 						}
; 4560 : 					}
; 4561 : 					else
; 4562 : 					{
; 4563 : 						break;
; 4564 : 					}
; 4565 : 				}
; 4566 : 			}
; 4567 : #endif
; 4568 : 
; 4569 : 			//#if(SYSTEM_ACHIEVEMENTS) //start Game
; 4570 : 			//g_Achievements.PickUp(aIndex, lpItem->m_Type, lpItem->m_Level, lpItem->m_NewOption, lpItem->m_SetOption, lpItem->m_Durability);
; 4571 : 			//#endif
; 4572 : 			#if(ITEM_GET_NOTICE)
; 4573 : 						g_ItemGetNotice.ItemGetNotice(lpItem, aIndex);

  0127d	53		 push	 ebx
  0127e	56		 push	 esi
  0127f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemGetNotice@@3VCItemGetNotice@@A ; g_ItemGetNotice
  01284	e8 00 00 00 00	 call	 ?ItemGetNotice@CItemGetNotice@@QAEXPAVCMapItem@@H@Z ; CItemGetNotice::ItemGetNotice

; 4574 : 			#endif
; 4575 : 
; 4576 : 
; 4577 : 
; 4578 : 			if ( lpItem->m_Type == ITEMGET(14,21) && lpItem->m_Level == 3)

  01289	b8 15 1c 00 00	 mov	 eax, 7189		; 00001c15H
  0128e	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  01292	0f 85 cc 01 00
	00		 jne	 $LN204@CGItemGetR
  01298	66 83 7e 0c 03	 cmp	 WORD PTR [esi+12], 3
  0129d	0f 85 c1 01 00
	00		 jne	 $LN204@CGItemGetR

; 4579 : 			{
; 4580 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  012a3	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$245832[ebp], 0
  012ad	8d 49 00	 npad	 3
$LL48@CGItemGetR:

; 4581 : 				{
; 4582 : 					int pos = ::g_CastleSiegeSync.CheckOverlapCsMarks(aIndex);

  012b0	53		 push	 ebx
  012b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  012b6	e8 00 00 00 00	 call	 ?CheckOverlapCsMarks@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckOverlapCsMarks
  012bb	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _pos$245836[ebp], eax

; 4583 : 
; 4584 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  012c1	85 c0		 test	 eax, eax
  012c3	0f 88 9b 01 00
	00		 js	 $LN204@CGItemGetR
  012c9	33 c0		 xor	 eax, eax
  012cb	81 bd e4 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _pos$245836[ebp], 203 ; 000000cbH
  012d5	0f 9e c0	 setle	 al
  012d8	85 c0		 test	 eax, eax
  012da	0f 84 84 01 00
	00		 je	 $LN204@CGItemGetR

; 4585 : 					{
; 4586 : 						int Dur = (int)(gObj[aIndex].pInventory[pos].m_Durability + lpItem->m_Durability);

  012e0	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _pos$245836[ebp]
  012e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012ec	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  012f2	8b 94 0f 24 0e
	00 00		 mov	 edx, DWORD PTR [edi+ecx+3620]
  012f9	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv3458[ebp], eax
  012ff	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  01303	d8 46 28	 fadd	 DWORD PTR [esi+40]
  01306	e8 00 00 00 00	 call	 __ftol2_sse

; 4587 : 
; 4588 : 						if ( Dur <= 255 )

  0130b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01310	0f 8f c0 00 00
	00		 jg	 $LN44@CGItemGetR

; 4589 : 						{
; 4590 : 							if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  01316	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  0131c	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  01322	6a 01		 push	 1
  01324	50		 push	 eax
  01325	53		 push	 ebx
  01326	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  0132c	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  01331	83 f8 01	 cmp	 eax, 1
  01334	0f 85 12 01 00
	00		 jne	 $LN47@CGItemGetR

; 4591 : 							{
; 4592 : 								pResult.result = -3;
; 4593 : 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0133a	0f b6 85 f5 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01341	50		 push	 eax
  01342	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  01348	51		 push	 ecx
  01349	53		 push	 ebx
  0134a	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  01351	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4594 : 								gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  01356	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245836[ebp]
  0135c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01362	d9 46 28	 fld	 DWORD PTR [esi+40]
  01365	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4595 : 								GCItemDurSend( aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability,0);

  0136c	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3385[ebp]
  01372	8b c2		 mov	 eax, edx
  01374	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0137a	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  0137e	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  01382	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  01386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0138c	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  01393	6a 00		 push	 0
  01395	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  01399	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3385[ebp]
  013a0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  013a5	89 45 f8	 mov	 DWORD PTR tv3382[ebp], eax
  013a8	d9 6d f8	 fldcw	 WORD PTR tv3382[ebp]
  013ab	db 5d f8	 fistp	 DWORD PTR tv3380[ebp]
  013ae	8a 45 f8	 mov	 al, BYTE PTR tv3380[ebp]
  013b1	0f b6 c8	 movzx	 ecx, al
  013b4	51		 push	 ecx
  013b5	52		 push	 edx
  013b6	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3385[ebp]
  013bc	53		 push	 ebx
  013bd	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  013c2	83 c4 1c	 add	 esp, 28			; 0000001cH
  013c5	5e		 pop	 esi
  013c6	5f		 pop	 edi
  013c7	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  013c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013cb	33 cd		 xor	 ecx, ebp
  013cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013d2	8b e5		 mov	 esp, ebp
  013d4	5d		 pop	 ebp
  013d5	c3		 ret	 0
$LN44@CGItemGetR:

; 4596 : 								return;
; 4597 : 							}
; 4598 : 						}
; 4599 : 						else
; 4600 : 						{
; 4601 : 							lpItem->m_Durability = (float)(Dur - 255);
; 4602 : 							gObj[aIndex].pInventory[pos].m_Durability = 255.0f;

  013d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  013dc	05 01 ff ff ff	 add	 eax, -255		; ffffff01H
  013e1	89 45 f8	 mov	 DWORD PTR tv3401[ebp], eax
  013e4	db 45 f8	 fild	 DWORD PTR tv3401[ebp]
  013e7	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv3458[ebp]

; 4603 : 							GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  013ed	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3397[ebp]
  013f3	d9 5e 28	 fstp	 DWORD PTR [esi+40]
  013f6	6a 00		 push	 0
  013f8	8b 94 0f 24 0e
	00 00		 mov	 edx, DWORD PTR [edi+ecx+3620]
  013ff	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  01405	d9 5c 02 24	 fstp	 DWORD PTR [edx+eax+36]
  01409	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0140f	8b 94 0f 24 0e
	00 00		 mov	 edx, DWORD PTR [edi+ecx+3620]
  01416	d9 44 02 24	 fld	 DWORD PTR [edx+eax+36]
  0141a	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3397[ebp]
  01421	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _pos$245836[ebp]
  01427	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0142c	89 45 f8	 mov	 DWORD PTR tv3394[ebp], eax
  0142f	d9 6d f8	 fldcw	 WORD PTR tv3394[ebp]
  01432	db 5d f8	 fistp	 DWORD PTR tv3392[ebp]
  01435	8a 45 f8	 mov	 al, BYTE PTR tv3392[ebp]
  01438	0f b6 c8	 movzx	 ecx, al
  0143b	51		 push	 ecx
  0143c	52		 push	 edx
  0143d	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3397[ebp]
  01443	53		 push	 ebx
  01444	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01449	83 c4 10	 add	 esp, 16			; 00000010H
$LN47@CGItemGetR:

; 4579 : 			{
; 4580 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  0144c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$245832[ebp]
  01452	40		 inc	 eax
  01453	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _n$245832[ebp], eax
  01459	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  0145e	0f 8c 4c fe ff
	ff		 jl	 $LL48@CGItemGetR
$LN204@CGItemGetR:

; 4604 : 						}
; 4605 : 
; 4606 : 					}
; 4607 : 					else
; 4608 : 					{
; 4609 : 						break;
; 4610 : 					}
; 4611 : 				}
; 4612 : 			}
; 4613 : 
; 4614 : 			if (lpItem->m_Type == ITEMGET(14,100)) //season4.5 add-on

  01464	ba 64 1c 00 00	 mov	 edx, 7268		; 00001c64H
  01469	66 39 56 0a	 cmp	 WORD PTR [esi+10], dx
  0146d	0f 85 d8 01 00
	00		 jne	 $LN37@CGItemGetR

; 4615 : 			{
; 4616 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  01473	33 c0		 xor	 eax, eax
  01475	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _n$245851[ebp], eax
  0147b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv4001[ebp], eax
$LL39@CGItemGetR:

; 4617 : 				{
; 4618 : 					int pos = -1;
; 4619 : 
; 4620 : 					if(gObj[aIndex].pInventory[n].m_Type == ITEMGET(14,100))

  01481	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01486	8b 8c 07 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3620]
  0148d	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv4001[ebp]
  01493	b8 64 1c 00 00	 mov	 eax, 7268		; 00001c64H
  01498	66 39 44 11 06	 cmp	 WORD PTR [ecx+edx+6], ax
  0149d	0f 85 86 01 00
	00		 jne	 $LN38@CGItemGetR

; 4621 : 					{
; 4622 : 						if(gObj[aIndex].pInventory[n].m_Durability < 255.0f)

  014a3	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  014a7	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@406fe00000000000
  014ad	df e0		 fnstsw	 ax
  014af	f6 c4 05	 test	 ah, 5
  014b2	0f 8a 71 01 00
	00		 jp	 $LN38@CGItemGetR

; 4623 : 						{
; 4624 : 							pos = n;
; 4625 : 						}
; 4626 : 					}
; 4627 : 
; 4628 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  014b8	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _n$245851[ebp], 0
  014bf	0f 8c 64 01 00
	00		 jl	 $LN38@CGItemGetR
  014c5	33 c0		 xor	 eax, eax
  014c7	81 bd e4 fe ff
	ff cb 00 00 00	 cmp	 DWORD PTR _n$245851[ebp], 203 ; 000000cbH
  014d1	0f 9e c0	 setle	 al
  014d4	85 c0		 test	 eax, eax
  014d6	0f 84 4d 01 00
	00		 je	 $LN38@CGItemGetR

; 4629 : 					{
; 4630 : 						int Dur = (int)(gObj[aIndex].pInventory[pos].m_Durability + lpItem->m_Durability);

  014dc	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  014e0	d8 46 28	 fadd	 DWORD PTR [esi+40]
  014e3	e8 00 00 00 00	 call	 __ftol2_sse

; 4631 : 
; 4632 : 						if ( Dur <= 255 )

  014e8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  014ed	0f 8f c0 00 00
	00		 jg	 $LN33@CGItemGetR

; 4633 : 						{
; 4634 : 							if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  014f3	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _item_num$[ebp]
  014f9	6a 01		 push	 1
  014fb	51		 push	 ecx
  014fc	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  01502	53		 push	 ebx
  01503	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  01509	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  0150e	83 f8 01	 cmp	 eax, 1
  01511	0f 85 12 01 00
	00		 jne	 $LN38@CGItemGetR

; 4635 : 							{
; 4636 : 								pResult.result = -3;
; 4637 : 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01517	0f b6 95 f5 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0151e	52		 push	 edx
  0151f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  01525	50		 push	 eax
  01526	53		 push	 ebx
  01527	c6 85 f7 fe ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  0152e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4638 : 								gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  01533	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _n$245851[ebp]
  01539	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0153f	d9 46 28	 fld	 DWORD PTR [esi+40]
  01542	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]

; 4639 : 								GCItemDurSend( aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability,0);

  01549	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3345[ebp]
  0154f	8b c2		 mov	 eax, edx
  01551	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01557	d8 44 01 24	 fadd	 DWORD PTR [ecx+eax+36]
  0155b	d9 5c 01 24	 fstp	 DWORD PTR [ecx+eax+36]
  0155f	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  01563	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01569	8b 8c 39 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+edi+3620]
  01570	6a 00		 push	 0
  01572	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  01576	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3345[ebp]
  0157d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01582	89 45 f8	 mov	 DWORD PTR tv3341[ebp], eax
  01585	d9 6d f8	 fldcw	 WORD PTR tv3341[ebp]
  01588	db 5d f8	 fistp	 DWORD PTR tv3339[ebp]
  0158b	8a 45 f8	 mov	 al, BYTE PTR tv3339[ebp]
  0158e	0f b6 c8	 movzx	 ecx, al
  01591	51		 push	 ecx
  01592	52		 push	 edx
  01593	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3345[ebp]
  01599	53		 push	 ebx
  0159a	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0159f	83 c4 1c	 add	 esp, 28			; 0000001cH
  015a2	5e		 pop	 esi
  015a3	5f		 pop	 edi
  015a4	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  015a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015a8	33 cd		 xor	 ecx, ebp
  015aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015af	8b e5		 mov	 esp, ebp
  015b1	5d		 pop	 ebp
  015b2	c3		 ret	 0
$LN33@CGItemGetR:

; 4640 : 								return;
; 4641 : 							}
; 4642 : 						}
; 4643 : 						else
; 4644 : 						{
; 4645 : 							lpItem->m_Durability = (float)(Dur - 255);
; 4646 : 							gObj[aIndex].pInventory[pos].m_Durability = 255.0f;

  015b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 4647 : 							GCItemDurSend(aIndex, (BYTE)pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  015b9	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3364[ebp]
  015bf	05 01 ff ff ff	 add	 eax, -255		; ffffff01H
  015c4	89 45 f8	 mov	 DWORD PTR tv3367[ebp], eax
  015c7	db 45 f8	 fild	 DWORD PTR tv3367[ebp]
  015ca	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv4001[ebp]
  015d0	6a 00		 push	 0
  015d2	d9 5e 28	 fstp	 DWORD PTR [esi+40]
  015d5	8b 8c 17 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+edx+3620]
  015dc	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  015e2	d9 5c 08 24	 fstp	 DWORD PTR [eax+ecx+36]
  015e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015ec	8b 8c 17 24 0e
	00 00		 mov	 ecx, DWORD PTR [edi+edx+3620]
  015f3	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  015f7	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3364[ebp]
  015fe	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$245851[ebp]
  01604	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01609	89 45 f8	 mov	 DWORD PTR tv3360[ebp], eax
  0160c	d9 6d f8	 fldcw	 WORD PTR tv3360[ebp]
  0160f	db 5d f8	 fistp	 DWORD PTR tv3354[ebp]
  01612	8a 55 f8	 mov	 dl, BYTE PTR tv3354[ebp]
  01615	0f b6 c2	 movzx	 eax, dl
  01618	50		 push	 eax
  01619	51		 push	 ecx
  0161a	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3364[ebp]
  01620	53		 push	 ebx
  01621	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  01626	83 c4 10	 add	 esp, 16			; 00000010H
$LN38@CGItemGetR:

; 4615 : 			{
; 4616 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  01629	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv4001[ebp]
  0162f	ff 85 e4 fe ff
	ff		 inc	 DWORD PTR _n$245851[ebp]
  01635	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0163a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv4001[ebp], eax
  01640	3d f0 a8 00 00	 cmp	 eax, 43248		; 0000a8f0H
  01645	0f 8c 36 fe ff
	ff		 jl	 $LL39@CGItemGetR
$LN37@CGItemGetR:

; 4648 : 						}
; 4649 : 
; 4650 : 					}
; 4651 : 				}
; 4652 : 			}
; 4653 : 
; 4654 : #ifdef LUCKYITEM
; 4655 : 			if( g_LuckyItemManager.IsLuckyItemEquipment(lpItem->m_Type) || g_LuckyItemManager.IsLuckyItemTicket(lpItem->m_Type) )

  0164b	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]
  0164f	52		 push	 edx
  01650	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  01655	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  0165a	85 c0		 test	 eax, eax
  0165c	75 17		 jne	 SHORT $LN29@CGItemGetR
  0165e	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  01662	50		 push	 eax
  01663	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  01668	e8 00 00 00 00	 call	 ?IsLuckyItemTicket@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemTicket
  0166d	85 c0		 test	 eax, eax
  0166f	0f 84 ab 01 00
	00		 je	 $LN30@CGItemGetR
$LN29@CGItemGetR:

; 4656 : 			{
; 4657 : 				char szSetItemName[48]	= { 0 };

  01675	6a 2f		 push	 47			; 0000002fH
  01677	8d 4d b9	 lea	 ecx, DWORD PTR _szSetItemName$245872[ebp+1]
  0167a	6a 00		 push	 0
  0167c	51		 push	 ecx
  0167d	c6 45 b8 00	 mov	 BYTE PTR _szSetItemName$245872[ebp], 0
  01681	e8 00 00 00 00	 call	 _memset

; 4658 : 				int tmpSetOption		= 0;
; 4659 : 				BYTE NewOption[8]		= { 0 };
; 4660 : 				// ----
; 4661 : 				ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  01686	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  0168c	33 c0		 xor	 eax, eax
  0168e	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _tmpSetOption$245873[ebp], eax
  01694	88 45 f4	 mov	 BYTE PTR _NewOption$245874[ebp], al
  01697	89 45 f5	 mov	 DWORD PTR _NewOption$245874[ebp+1], eax
  0169a	66 89 45 f9	 mov	 WORD PTR _NewOption$245874[ebp+5], ax
  0169e	88 45 fb	 mov	 BYTE PTR _NewOption$245874[ebp+7], al
  016a1	52		 push	 edx
  016a2	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$245874[ebp]
  016a5	50		 push	 eax
  016a6	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 4662 : 				// ----
; 4663 : 				if( gSetItemOption.IsSetItem(lpItem->m_Type) )

  016ab	0f bf 4e 0a	 movsx	 ecx, WORD PTR [esi+10]
  016af	83 c4 14	 add	 esp, 20			; 00000014H
  016b2	51		 push	 ecx
  016b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  016b8	e8 00 00 00 00	 call	 ?IsSetItem@CSetItemOption@@QAEHH@Z ; CSetItemOption::IsSetItem
  016bd	85 c0		 test	 eax, eax
  016bf	74 4b		 je	 SHORT $LN28@CGItemGetR

; 4664 : 				{
; 4665 : 					if( lpItem->m_SetOption & 1 )

  016c1	8a 86 b2 00 00
	00		 mov	 al, BYTE PTR [esi+178]
  016c7	a8 01		 test	 al, 1
  016c9	74 0c		 je	 SHORT $LN27@CGItemGetR

; 4666 : 					{
; 4667 : 						tmpSetOption = 1;

  016cb	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _tmpSetOption$245873[ebp], 1

; 4668 : 					}
; 4669 : 					else

  016d5	eb 0e		 jmp	 SHORT $LN25@CGItemGetR
$LN27@CGItemGetR:

; 4670 : 					{
; 4671 : 						if( lpItem->m_SetOption & 2 )

  016d7	a8 02		 test	 al, 2
  016d9	74 0a		 je	 SHORT $LN25@CGItemGetR

; 4672 : 						{
; 4673 : 							tmpSetOption = 2;

  016db	c7 85 e8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _tmpSetOption$245873[ebp], 2
$LN25@CGItemGetR:

; 4674 : 						}
; 4675 : 					}
; 4676 : 					// ----
; 4677 : 					strcpy(szSetItemName, gSetItemOption.GetSetOptionName(type, tmpSetOption));

  016e5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _tmpSetOption$245873[ebp]
  016eb	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _type$[ebp]
  016f1	52		 push	 edx
  016f2	50		 push	 eax
  016f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  016f8	e8 00 00 00 00	 call	 ?GetSetOptionName@CSetItemOption@@QAEPADHH@Z ; CSetItemOption::GetSetOptionName
  016fd	8d 55 b8	 lea	 edx, DWORD PTR _szSetItemName$245872[ebp]
  01700	2b d0		 sub	 edx, eax
$LL168@CGItemGetR:
  01702	8a 08		 mov	 cl, BYTE PTR [eax]
  01704	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  01707	40		 inc	 eax
  01708	84 c9		 test	 cl, cl
  0170a	75 f6		 jne	 SHORT $LL168@CGItemGetR
$LN28@CGItemGetR:

; 4678 : 				}
; 4679 : 				// ----
; 4680 : 				LogAddTD("[%s][%s][%d]%d/%d Try Get LuckyItem serial:%u [%s][%d][%d][%d][%d][%d] dur:[%d]Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d] 380:[%d] HO:[%d,%d]",
; 4681 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, map_num, gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szSetItemName,
; 4682 : 					type, level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (INT)lpItem->m_Durability,
; 4683 : 					NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6],
; 4684 : 					lpItem->m_SetOption, lpItem->m_ItemOptionEx >> 7,
; 4685 : 					g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL),
; 4686 : 					g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL));

  0170c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01712	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  01718	03 cf		 add	 ecx, edi
  0171a	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv3074[ebp], ecx
  01720	52		 push	 edx
  01721	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01726	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  0172b	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  01731	0f b6 c0	 movzx	 eax, al
  01734	50		 push	 eax
  01735	51		 push	 ecx
  01736	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0173b	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01740	0f b6 8e b2 00
	00 00		 movzx	 ecx, BYTE PTR [esi+178]
  01747	d9 46 28	 fld	 DWORD PTR [esi+40]
  0174a	0f b6 d0	 movzx	 edx, al
  0174d	0f b6 86 ce 00
	00 00		 movzx	 eax, BYTE PTR [esi+206]
  01754	52		 push	 edx
  01755	0f b6 55 fa	 movzx	 edx, BYTE PTR _NewOption$245874[ebp+6]
  01759	c1 e8 07	 shr	 eax, 7
  0175c	50		 push	 eax
  0175d	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$245874[ebp+5]
  01761	51		 push	 ecx
  01762	0f b6 4d f8	 movzx	 ecx, BYTE PTR _NewOption$245874[ebp+4]
  01766	52		 push	 edx
  01767	0f b6 55 f7	 movzx	 edx, BYTE PTR _NewOption$245874[ebp+3]
  0176b	50		 push	 eax
  0176c	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$245874[ebp+2]
  01770	51		 push	 ecx
  01771	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$245874[ebp+1]
  01775	52		 push	 edx
  01776	0f b6 55 f4	 movzx	 edx, BYTE PTR _NewOption$245874[ebp]
  0177a	50		 push	 eax
  0177b	51		 push	 ecx
  0177c	52		 push	 edx
  0177d	e8 00 00 00 00	 call	 __ftol2_sse
  01782	0f b6 8e 99 00
	00 00		 movzx	 ecx, BYTE PTR [esi+153]
  01789	0f b6 96 98 00
	00 00		 movzx	 edx, BYTE PTR [esi+152]
  01790	50		 push	 eax
  01791	0f b6 86 9a 00
	00 00		 movzx	 eax, BYTE PTR [esi+154]
  01798	50		 push	 eax
  01799	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  0179f	51		 push	 ecx
  017a0	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  017a6	52		 push	 edx
  017a7	50		 push	 eax
  017a8	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  017ae	51		 push	 ecx
  017af	8b 08		 mov	 ecx, DWORD PTR [eax]
  017b1	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv3074[ebp]
  017b7	8d 55 b8	 lea	 edx, DWORD PTR _szSetItemName$245872[ebp]
  017ba	52		 push	 edx
  017bb	0f bf 90 46 01
	00 00		 movsx	 edx, WORD PTR [eax+326]
  017c2	51		 push	 ecx
  017c3	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  017ca	52		 push	 edx
  017cb	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  017d1	51		 push	 ecx
  017d2	52		 push	 edx
  017d3	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  017d6	51		 push	 ecx
  017d7	83 c0 6c	 add	 eax, 108		; 0000006cH
  017da	50		 push	 eax
  017db	68 00 00 00 00	 push	 OFFSET ??_C@_0IG@INOJDOPM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Try?5Get?5LuckyI@
  017e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4687 : 				// ----
; 4688 : 				pResult.result = -1;
; 4689 : 				// ----
; 4690 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  017e6	0f b6 95 f5 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  017ed	52		 push	 edx
  017ee	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  017f4	50		 push	 eax
  017f5	53		 push	 ebx
  017f6	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  017fd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01802	83 c4 70	 add	 esp, 112		; 00000070H

; 4691 : 				GCServerMsgStringSend(lMsg.Get(1118), aIndex, 1);

  01805	6a 01		 push	 1
  01807	53		 push	 ebx
  01808	68 5e 04 00 00	 push	 1118			; 0000045eH
  0180d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01812	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01817	50		 push	 eax
  01818	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0181d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@CGItemGetR:

; 4692 : 			}
; 4693 : #endif
; 4694 : 
; 4695 : 
; 4696 : 			if(g_ZtLicense.user.WinQuest)

  01820	80 3d ce 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+206, 0
  01827	0f 84 79 00 00
	00		 je	 $LN23@CGItemGetR

; 4697 : 			{
; 4698 :  				if(!gWinQuestSystem.MonsterDrop(aIndex,lpItem->m_Type) && MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE ) 

  0182d	0f b7 4e 0a	 movzx	 ecx, WORD PTR [esi+10]
  01831	51		 push	 ecx
  01832	53		 push	 ebx
  01833	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWinQuestSystem@@3VcWinQuestSystem@@A ; gWinQuestSystem
  01838	e8 00 00 00 00	 call	 ?MonsterDrop@cWinQuestSystem@@QAE_NHF@Z ; cWinQuestSystem::MonsterDrop
  0183d	84 c0		 test	 al, al
  0183f	75 65		 jne	 SHORT $LN23@CGItemGetR
  01841	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _item_num$[ebp]
  01847	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  0184d	6a 00		 push	 0
  0184f	52		 push	 edx
  01850	53		 push	 ebx
  01851	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  01857	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  0185c	83 f8 01	 cmp	 eax, 1
  0185f	75 45		 jne	 SHORT $LN23@CGItemGetR

; 4699 : 				{
; 4700 :  					lpItem->Clear();

  01861	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  01867	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
$LN92@CGItemGetR:

; 4701 : 					pResult.result = -1;

  0186c	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
$LN109@CGItemGetR:

; 4839 : 			{
; 4840 : 				pResult.result = -1;
; 4841 : 				pResult.h.size -= sizeof(pResult.Data);
; 4842 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4843 : 			}
; 4844 : 		}
; 4845 : 	}
; 4846 : 	else
; 4847 : 	{
; 4848 :    		pResult.h.size -= sizeof(pResult.Data);

  01873	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  01879	04 f4		 add	 al, 244			; 000000f4H
  0187b	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 4849 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01881	0f b6 c0	 movzx	 eax, al
  01884	50		 push	 eax
  01885	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0188b	51		 push	 ecx
$LN210@CGItemGetR:
  0188c	53		 push	 ebx
  0188d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01892	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN209@CGItemGetR:
  01895	5e		 pop	 esi
$LN208@CGItemGetR:
  01896	5f		 pop	 edi
  01897	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  01898	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0189b	33 cd		 xor	 ecx, ebp
  0189d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018a2	8b e5		 mov	 esp, ebp
  018a4	5d		 pop	 ebp
  018a5	c3		 ret	 0
$LN23@CGItemGetR:

; 4702 : 					pResult.h.size -= sizeof(pResult.Data);
; 4703 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4704 : 					return;
; 4705 : 				}
; 4706 : 			}
; 4707 : 
; 4708 : #if(CUSTOM_ZT_QUEST_SYSTEM==TRUE)
; 4709 : 			if( g_ZtWinQuestSystem.PickUpItem(aIndex,lpItem->m_Type) == 1 && MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE ) 

  018a6	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]
  018aa	52		 push	 edx
  018ab	53		 push	 ebx
  018ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtWinQuestSystem@@3VZtWinQuestSystem@@A ; g_ZtWinQuestSystem
  018b1	e8 00 00 00 00	 call	 ?PickUpItem@ZtWinQuestSystem@@QAEHHH@Z ; ZtWinQuestSystem::PickUpItem
  018b6	83 f8 01	 cmp	 eax, 1
  018b9	75 4d		 jne	 SHORT $LN22@CGItemGetR
  018bb	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  018c1	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  018c7	6a 00		 push	 0
  018c9	50		 push	 eax
  018ca	53		 push	 ebx
  018cb	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  018d1	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  018d6	83 f8 01	 cmp	 eax, 1
  018d9	75 2d		 jne	 SHORT $LN22@CGItemGetR

; 4710 : 			{
; 4711 :  				lpItem->Clear();

  018db	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  018e1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 4712 : 				pResult.result = -1;
; 4713 : 				pResult.h.size -= sizeof(pResult.Data);

  018e6	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  018ec	04 f4		 add	 al, 244			; 000000f4H

; 4714 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  018ee	0f b6 c8	 movzx	 ecx, al
  018f1	51		 push	 ecx
  018f2	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  018f8	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  018ff	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  01905	52		 push	 edx

; 4715 : 				return;

  01906	eb 84		 jmp	 SHORT $LN210@CGItemGetR
$LN22@CGItemGetR:

; 4716 : 			}
; 4717 : 			else if( g_ZtWinQuestSystem.PickUpItem(aIndex,lpItem->m_Type) == 2) 

  01908	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  0190c	50		 push	 eax
  0190d	53		 push	 ebx
  0190e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtWinQuestSystem@@3VZtWinQuestSystem@@A ; g_ZtWinQuestSystem
  01913	e8 00 00 00 00	 call	 ?PickUpItem@ZtWinQuestSystem@@QAEHHH@Z ; ZtWinQuestSystem::PickUpItem
  01918	83 f8 02	 cmp	 eax, 2

; 4718 : 			{
; 4719 : 				pResult.result = -1;
; 4720 : 				pResult.h.size -= sizeof(pResult.Data);
; 4721 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4722 : 				return;

  0191b	0f 84 eb e9 ff
	ff		 je	 $LN214@CGItemGetR

; 4723 : 			}
; 4724 : #endif
; 4725 : 
; 4726 : #if(SYSTEM_ACHIEVEMENTS)
; 4727 : 			//g_Achievements.PickUp(aIndex, lpItem->m_Type, lpItem->m_Level, lpItem->m_NewOption, lpItem->m_SetOption, lpItem->m_Durability);
; 4728 : #endif
; 4729 : 
; 4730 : 			pResult.result = ::gObjInventoryInsertItemTemp(&gObj[aIndex], lpItem);

  01921	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01926	03 c7		 add	 eax, edi
  01928	56		 push	 esi
  01929	50		 push	 eax
  0192a	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
  0192f	83 c4 08	 add	 esp, 8
  01932	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 4731 : 			
; 4732 : 			if ( pResult.result != 0xFF )

  01938	3c ff		 cmp	 al, 255			; 000000ffH
  0193a	0f 84 cc e9 ff
	ff		 je	 $LN214@CGItemGetR

; 4733 : 			{
; 4734 : 				ItemByteConvert((LPBYTE)&pResult.Data[0], 
; 4735 : 					lpItem->m_Type, 
; 4736 : 					lpItem->m_Option1, 
; 4737 : 					lpItem->m_Option2,	
; 4738 : 					lpItem->m_Option3, 
; 4739 : 					(BYTE)lpItem->m_Level, 
; 4740 : 					(BYTE)lpItem->m_Durability, 
; 4741 : 					lpItem->m_NewOption, 
; 4742 : 					lpItem->m_SetOption, 
; 4743 : 					lpItem->m_JewelOfHarmonyOption, 
; 4744 : 					lpItem->m_ItemOptionEx, 
; 4745 : 					lpItem->m_SocketOption, 
; 4746 : 					(BYTE)lpItem->m_SocketOptionIndex, 0);

  01940	0f b6 8e cf 00
	00 00		 movzx	 ecx, BYTE PTR [esi+207]
  01947	d9 46 28	 fld	 DWORD PTR [esi+40]
  0194a	0f b6 86 ce 00
	00 00		 movzx	 eax, BYTE PTR [esi+206]
  01951	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv3295[ebp]
  01957	6a 00		 push	 0
  01959	51		 push	 ecx
  0195a	0f b6 8e c8 00
	00 00		 movzx	 ecx, BYTE PTR [esi+200]
  01961	8d 96 d0 00 00
	00		 lea	 edx, DWORD PTR [esi+208]
  01967	52		 push	 edx
  01968	0f b6 96 b2 00
	00 00		 movzx	 edx, BYTE PTR [esi+178]
  0196f	50		 push	 eax
  01970	0f b6 86 9b 00
	00 00		 movzx	 eax, BYTE PTR [esi+155]
  01977	51		 push	 ecx
  01978	52		 push	 edx
  01979	50		 push	 eax
  0197a	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv3295[ebp]
  01981	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01986	89 45 f8	 mov	 DWORD PTR tv3292[ebp], eax
  01989	0f b6 46 0c	 movzx	 eax, BYTE PTR [esi+12]
  0198d	d9 6d f8	 fldcw	 WORD PTR tv3292[ebp]
  01990	db 5d f8	 fistp	 DWORD PTR tv3289[ebp]
  01993	8a 4d f8	 mov	 cl, BYTE PTR tv3289[ebp]
  01996	0f b6 d1	 movzx	 edx, cl
  01999	0f b6 8e 9a 00
	00 00		 movzx	 ecx, BYTE PTR [esi+154]
  019a0	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv3295[ebp]
  019a6	52		 push	 edx
  019a7	0f b6 96 99 00
	00 00		 movzx	 edx, BYTE PTR [esi+153]
  019ae	50		 push	 eax
  019af	0f b6 86 98 00
	00 00		 movzx	 eax, BYTE PTR [esi+152]
  019b6	51		 push	 ecx
  019b7	0f bf 4e 0a	 movsx	 ecx, WORD PTR [esi+10]
  019bb	52		 push	 edx
  019bc	50		 push	 eax
  019bd	51		 push	 ecx
  019be	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp+4]
  019c4	52		 push	 edx
  019c5	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEHEEEEEEEEEQAEEE@Z ; ItemByteConvert

; 4747 : 
; 4748 : 				if ( MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE )

  019ca	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _item_num$[ebp]
  019d0	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3121[ebp]
  019d6	83 c4 38	 add	 esp, 56			; 00000038H
  019d9	6a 00		 push	 0
  019db	50		 push	 eax
  019dc	53		 push	 ebx
  019dd	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  019e3	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  019e8	83 f8 01	 cmp	 eax, 1
  019eb	0f 85 a5 03 00
	00		 jne	 $LN18@CGItemGetR

; 4749 : 				{
; 4750 : 					BYTE pos = ::gObjInventoryInsertItem(aIndex, lpItem);

  019f1	56		 push	 esi
  019f2	53		 push	 ebx
  019f3	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ; gObjInventoryInsertItem
  019f8	83 c4 08	 add	 esp, 8
  019fb	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _pos$245899[ebp], al

; 4751 : 
; 4752 : 					if ( pos == 0xFF )

  01a01	3c ff		 cmp	 al, 255			; 000000ffH
  01a03	75 06		 jne	 SHORT $LN17@CGItemGetR

; 4753 : 					{
; 4754 : 						pResult.result = -1;

  01a05	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
$LN17@CGItemGetR:

; 4755 : 					}
; 4756 : 
; 4757 : #ifdef DEBUG_CODE
; 4758 : 					LogAddC(2,"pos: %d",pos);
; 4759 : #endif
; 4760 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01a0b	0f b6 8d f5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  01a12	51		 push	 ecx
  01a13	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  01a19	52		 push	 edx
  01a1a	53		 push	 ebx
  01a1b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4761 : #ifdef _FIX_
; 4762 : 					if ( pos != 0xFF )

  01a20	8a 85 f3 fe ff
	ff		 mov	 al, BYTE PTR _pos$245899[ebp]
  01a26	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a29	3c ff		 cmp	 al, 255			; 000000ffH
  01a2b	0f 84 b4 01 00
	00		 je	 $LN195@CGItemGetR

; 4763 : 					{
; 4764 : 						GCInventoryItemOneSend(aIndex, pos);

  01a31	0f b6 c0	 movzx	 eax, al
  01a34	50		 push	 eax
  01a35	53		 push	 ebx
  01a36	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 4773 : #endif
; 4774 : 					}
; 4775 : 					else
; 4776 : 					{
; 4777 : 						BYTE NewOption[MAX_EXOPTION_SIZE];
; 4778 : 
; 4779 : 						::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  01a3b	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  01a41	83 c4 08	 add	 esp, 8
  01a44	52		 push	 edx
  01a45	8d 45 e8	 lea	 eax, DWORD PTR _NewOption$245905[ebp]
  01a48	50		 push	 eax
  01a49	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 4780 : 						LogAddTD(lMsg.Get(477), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num, gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type, level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (INT)lpItem->m_Durability, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7, g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));

  01a4e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a54	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  01a5a	03 cf		 add	 ecx, edi
  01a5c	83 c4 08	 add	 esp, 8
  01a5f	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv3074[ebp], ecx
  01a65	52		 push	 edx
  01a66	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01a6b	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  01a70	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv3125[ebp]
  01a76	0f b6 c0	 movzx	 eax, al
  01a79	50		 push	 eax
  01a7a	51		 push	 ecx
  01a7b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01a80	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01a85	0f b6 8e b2 00
	00 00		 movzx	 ecx, BYTE PTR [esi+178]
  01a8c	d9 46 28	 fld	 DWORD PTR [esi+40]
  01a8f	0f b6 d0	 movzx	 edx, al
  01a92	0f b6 86 ce 00
	00 00		 movzx	 eax, BYTE PTR [esi+206]
  01a99	52		 push	 edx
  01a9a	0f b6 55 ee	 movzx	 edx, BYTE PTR _NewOption$245905[ebp+6]
  01a9e	c1 e8 07	 shr	 eax, 7
  01aa1	50		 push	 eax
  01aa2	0f b6 45 ed	 movzx	 eax, BYTE PTR _NewOption$245905[ebp+5]
  01aa6	51		 push	 ecx
  01aa7	0f b6 4d ec	 movzx	 ecx, BYTE PTR _NewOption$245905[ebp+4]
  01aab	52		 push	 edx
  01aac	0f b6 55 eb	 movzx	 edx, BYTE PTR _NewOption$245905[ebp+3]
  01ab0	50		 push	 eax
  01ab1	0f b6 45 ea	 movzx	 eax, BYTE PTR _NewOption$245905[ebp+2]
  01ab5	51		 push	 ecx
  01ab6	0f b6 4d e9	 movzx	 ecx, BYTE PTR _NewOption$245905[ebp+1]
  01aba	52		 push	 edx
  01abb	0f b6 55 e8	 movzx	 edx, BYTE PTR _NewOption$245905[ebp]
  01abf	50		 push	 eax
  01ac0	51		 push	 ecx
  01ac1	52		 push	 edx
  01ac2	e8 00 00 00 00	 call	 __ftol2_sse
  01ac7	0f b6 8e 99 00
	00 00		 movzx	 ecx, BYTE PTR [esi+153]
  01ace	0f b6 96 98 00
	00 00		 movzx	 edx, BYTE PTR [esi+152]
  01ad5	50		 push	 eax
  01ad6	0f b6 86 9a 00
	00 00		 movzx	 eax, BYTE PTR [esi+154]
  01add	50		 push	 eax
  01ade	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _level$[ebp]
  01ae4	51		 push	 ecx
  01ae5	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _type$[ebp]
  01aeb	52		 push	 edx
  01aec	50		 push	 eax
  01aed	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv3125[ebp]
  01af3	51		 push	 ecx
  01af4	8b 08		 mov	 ecx, DWORD PTR [eax]
  01af6	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv3074[ebp]
  01afc	8d 55 84	 lea	 edx, DWORD PTR _szItemName$[ebp]
  01aff	52		 push	 edx
  01b00	0f bf 90 46 01
	00 00		 movsx	 edx, WORD PTR [eax+326]
  01b07	51		 push	 ecx
  01b08	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  01b0f	52		 push	 edx
  01b10	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  01b16	51		 push	 ecx
  01b17	52		 push	 edx
  01b18	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  01b1b	51		 push	 ecx
  01b1c	83 c0 6c	 add	 eax, 108		; 0000006cH
  01b1f	50		 push	 eax
  01b20	68 dd 01 00 00	 push	 477			; 000001ddH
  01b25	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01b2a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01b2f	50		 push	 eax
  01b30	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4781 : 						::GCSendGetItemInfoForParty(aIndex, lpItem);

  01b36	56		 push	 esi
  01b37	53		 push	 ebx
  01b38	e8 00 00 00 00	 call	 ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ; GCSendGetItemInfoForParty
  01b3d	83 c4 6c	 add	 esp, 108		; 0000006cH

; 4782 : 
; 4783 : 						if ( BC_MAP_RANGE(map_num) )

  01b40	83 bd dc fe ff
	ff 34		 cmp	 DWORD PTR _map_num$[ebp], 52 ; 00000034H
  01b47	74 1f		 je	 SHORT $LN199@CGItemGetR
  01b49	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
  01b4f	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01b52	0f 8c a2 01 00
	00		 jl	 $LN207@CGItemGetR
  01b58	33 c9		 xor	 ecx, ecx
  01b5a	83 f8 11	 cmp	 eax, 17			; 00000011H
  01b5d	0f 9e c1	 setle	 cl
  01b60	85 c9		 test	 ecx, ecx
  01b62	0f 84 92 01 00
	00		 je	 $LN207@CGItemGetR
$LN199@CGItemGetR:

; 4784 : 						{
; 4785 : 							int iBridgeIndex = g_BloodCastle.GetBridgeIndex(map_num);

  01b68	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _map_num$[ebp]
  01b6e	52		 push	 edx
  01b6f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01b74	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex

; 4786 : 
; 4787 : 							if ( g_BloodCastle.CheckQuestItemSerial(iBridgeIndex, lpItem) )

  01b79	56		 push	 esi
  01b7a	50		 push	 eax
  01b7b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01b80	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _iBridgeIndex$245911[ebp], eax
  01b86	e8 00 00 00 00	 call	 ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
  01b8b	84 c0		 test	 al, al
  01b8d	0f 84 61 01 00
	00		 je	 $LN206@CGItemGetR

; 4788 : 							{
; 4789 : 								g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = gObj[aIndex].m_Index;

  01b93	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _iBridgeIndex$245911[ebp]
  01b99	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b9e	69 c9 60 04 00
	00		 imul	 ecx, 1120		; 00000460H
  01ba4	8b 14 38	 mov	 edx, DWORD PTR [eax+edi]
  01ba7	89 91 ec 03 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+1004], edx

; 4790 : 
; 4791 : 								int iMapNumber = g_BloodCastle.GetBridgeIndex(gObj[aIndex].MapNumber); //WZ Fix-me plz

  01bad	0f b6 84 38 49
	01 00 00	 movzx	 eax, BYTE PTR [eax+edi+329]
  01bb5	50		 push	 eax
  01bb6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01bbb	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex
  01bc0	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iMapNumber$245913[ebp], eax

; 4792 : 
; 4793 : 								char szTempMsg[128];
; 4794 : 
; 4795 : 								switch ( lpItem->m_Level )

  01bc6	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]
  01bca	83 e8 00	 sub	 eax, 0
  01bcd	0f 84 b4 00 00
	00		 je	 $LN9@CGItemGetR
  01bd3	48		 dec	 eax
  01bd4	74 77		 je	 SHORT $LN8@CGItemGetR
  01bd6	48		 dec	 eax
  01bd7	74 39		 je	 SHORT $LN7@CGItemGetR

; 4811 : 
; 4812 : 									default:
; 4813 : 										szTempMsg[0] = 0;

  01bd9	c6 85 04 ff ff
	ff 00		 mov	 BYTE PTR _szTempMsg$245914[ebp], 0
  01be0	e9 e5 00 00 00	 jmp	 $LN10@CGItemGetR
$LN195@CGItemGetR:

; 4765 : 					}
; 4766 : #endif
; 4767 : 
; 4768 : 					if ( pos == 0xFF )
; 4769 : 					{
; 4770 : 						::GCItemListSend(aIndex);

  01be5	53		 push	 ebx
  01be6	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend

; 4771 : #ifdef PERIOD
; 4772 : 						g_PeriodItemZt.OnRequestPeriodItemList(&gObj[aIndex]);

  01beb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01bf1	03 cf		 add	 ecx, edi
  01bf3	83 c4 04	 add	 esp, 4
  01bf6	51		 push	 ecx
  01bf7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemZt@@3VCPeriodItemZt@@A ; g_PeriodItemZt
  01bfc	e8 00 00 00 00	 call	 ?OnRequestPeriodItemList@CPeriodItemZt@@QAEXPAUOBJECTSTRUCT@@@Z ; CPeriodItemZt::OnRequestPeriodItemList
  01c01	5e		 pop	 esi
  01c02	5f		 pop	 edi
  01c03	5b		 pop	 ebx

; 4850 : 	}
; 4851 : }

  01c04	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c07	33 cd		 xor	 ecx, ebp
  01c09	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c0e	8b e5		 mov	 esp, ebp
  01c10	5d		 pop	 ebp
  01c11	c3		 ret	 0
$LN7@CGItemGetR:

; 4806 : 
; 4807 : 									case 2:	// Crossbow of Archangel
; 4808 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 152)), gObj[aIndex].Name);

  01c12	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c18	8d 54 39 77	 lea	 edx, DWORD PTR [ecx+edi+119]
  01c1c	52		 push	 edx
  01c1d	68 98 04 00 00	 push	 1176			; 00000498H
  01c22	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01c27	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01c2c	50		 push	 eax
  01c2d	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _szTempMsg$245914[ebp]
  01c33	50		 push	 eax
  01c34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 4809 : 										g_BloodCastle.SendNoticeMessage(iMapNumber, szTempMsg);

  01c3a	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iMapNumber$245913[ebp]
  01c40	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c43	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _szTempMsg$245914[ebp]
  01c49	51		 push	 ecx
  01c4a	52		 push	 edx

; 4810 : 										break;

  01c4b	eb 73		 jmp	 SHORT $LN213@CGItemGetR
$LN8@CGItemGetR:

; 4800 : 										break;
; 4801 : 
; 4802 : 									case 1:	// Sword of Archangel
; 4803 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 151)), gObj[aIndex].Name);

  01c4d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c52	8d 4c 38 77	 lea	 ecx, DWORD PTR [eax+edi+119]
  01c56	51		 push	 ecx
  01c57	68 97 04 00 00	 push	 1175			; 00000497H
  01c5c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01c61	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01c66	50		 push	 eax
  01c67	8d 95 04 ff ff
	ff		 lea	 edx, DWORD PTR _szTempMsg$245914[ebp]
  01c6d	52		 push	 edx
  01c6e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 4804 : 										g_BloodCastle.SendNoticeMessage(iMapNumber, szTempMsg);

  01c74	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _iMapNumber$245913[ebp]
  01c7a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c7d	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _szTempMsg$245914[ebp]
  01c83	50		 push	 eax
  01c84	51		 push	 ecx

; 4805 : 										break;

  01c85	eb 39		 jmp	 SHORT $LN213@CGItemGetR
$LN9@CGItemGetR:

; 4796 : 								{
; 4797 : 									case 0:	// Staff of Archangel
; 4798 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 150)), gObj[aIndex].Name);

  01c87	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c8d	8d 44 3a 77	 lea	 eax, DWORD PTR [edx+edi+119]
  01c91	50		 push	 eax
  01c92	68 96 04 00 00	 push	 1174			; 00000496H
  01c97	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01c9c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01ca1	50		 push	 eax
  01ca2	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _szTempMsg$245914[ebp]
  01ca8	51		 push	 ecx
  01ca9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 4799 : 										g_BloodCastle.SendNoticeMessage(iMapNumber, szTempMsg);

  01caf	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iMapNumber$245913[ebp]
  01cb5	83 c4 0c	 add	 esp, 12			; 0000000cH
  01cb8	8d 95 04 ff ff
	ff		 lea	 edx, DWORD PTR _szTempMsg$245914[ebp]
  01cbe	52		 push	 edx
  01cbf	50		 push	 eax
$LN213@CGItemGetR:
  01cc0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01cc5	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
$LN10@CGItemGetR:

; 4814 : 								}
; 4815 : 
; 4816 : 								LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King's Weapon (%d)", iBridgeIndex+1, gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->m_Level);

  01cca	0f bf 4e 0c	 movsx	 ecx, WORD PTR [esi+12]
  01cce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cd3	51		 push	 ecx
  01cd4	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _iBridgeIndex$245911[ebp]
  01cda	8d 54 38 77	 lea	 edx, DWORD PTR [eax+edi+119]
  01cde	52		 push	 edx
  01cdf	8d 44 38 6c	 lea	 eax, DWORD PTR [eax+edi+108]
  01ce3	50		 push	 eax
  01ce4	41		 inc	 ecx
  01ce5	51		 push	 ecx
  01ce6	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  01ceb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01cf1	83 c4 14	 add	 esp, 20			; 00000014H
$LN206@CGItemGetR:
  01cf4	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _map_num$[ebp]
$LN207@CGItemGetR:

; 4817 : 							}
; 4818 : 						}
; 4819 : 
; 4820 : 						if ( IT_MAP_RANGE(map_num) ) //Season 2.5 add-on

  01cfa	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  01cfd	0f 8c 92 fb ff
	ff		 jl	 $LN209@CGItemGetR
  01d03	33 d2		 xor	 edx, edx
  01d05	83 f8 32	 cmp	 eax, 50			; 00000032H
  01d08	0f 9e c2	 setle	 dl
  01d0b	8b c2		 mov	 eax, edx
  01d0d	85 c0		 test	 eax, eax
  01d0f	0f 84 80 fb ff
	ff		 je	 $LN209@CGItemGetR

; 4821 : 						{
; 4822 : 							if(lpItem->m_Type == ITEMGET(14,64))

  01d15	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  01d1a	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  01d1e	0f 85 71 fb ff
	ff		 jne	 $LN209@CGItemGetR

; 4823 : 							{
; 4824 : 								g_IllusionTempleEvent.SetRegPedestal(gObj[aIndex].MapNumber,aIndex,NewOption[8]); //check

  01d24	8b 4d f0	 mov	 ecx, DWORD PTR _NewOption$245905[ebp+8]
  01d27	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d2d	0f b6 84 3a 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+edi+329]
  01d35	51		 push	 ecx
  01d36	53		 push	 ebx
  01d37	50		 push	 eax
  01d38	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  01d3d	e8 00 00 00 00	 call	 ?SetRegPedestal@CIllusionTempleEvent@@QAEXEHE@Z ; CIllusionTempleEvent::SetRegPedestal

; 4825 : 								g_IllusionTempleEvent.SetRelicsCarrierViewState(&gObj[aIndex]);

  01d42	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d48	03 cf		 add	 ecx, edi
  01d4a	51		 push	 ecx
  01d4b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  01d50	e8 00 00 00 00	 call	 ?SetRelicsCarrierViewState@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::SetRelicsCarrierViewState

; 4826 : 								LogAddTD("[Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics Item(serial:%d)", map_num-(MAP_INDEX_ILLUSIONTEMPLE_MIN-1), gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->m_Number);

  01d55	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv3125[ebp]
  01d5b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01d5d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d62	51		 push	 ecx
  01d63	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _map_num$[ebp]
  01d69	8d 54 38 77	 lea	 edx, DWORD PTR [eax+edi+119]
  01d6d	52		 push	 edx
  01d6e	8d 44 38 6c	 lea	 eax, DWORD PTR [eax+edi+108]
  01d72	50		 push	 eax
  01d73	83 c1 d4	 add	 ecx, -44		; ffffffd4H
  01d76	51		 push	 ecx
  01d77	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@JKBNGFPH@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@
  01d7c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4850 : 	}
; 4851 : }

  01d82	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d85	83 c4 14	 add	 esp, 20			; 00000014H
  01d88	5e		 pop	 esi
  01d89	5f		 pop	 edi
  01d8a	33 cd		 xor	 ecx, ebp
  01d8c	5b		 pop	 ebx
  01d8d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d92	8b e5		 mov	 esp, ebp
  01d94	5d		 pop	 ebp
  01d95	c3		 ret	 0
$LN18@CGItemGetR:

; 4827 : 							}
; 4828 : 						}
; 4829 : 					}
; 4830 : 				}
; 4831 : 				else
; 4832 : 				{
; 4833 : 					pResult.result = -1;
; 4834 : 					pResult.h.size -= sizeof(pResult.Data);

  01d96	8a 85 f5 fe ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  01d9c	04 f4		 add	 al, 244			; 000000f4H

; 4835 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01d9e	0f b6 d0	 movzx	 edx, al
  01da1	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  01da7	52		 push	 edx
  01da8	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  01dae	c6 85 f7 fe ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  01db5	50		 push	 eax

; 4836 : 				}
; 4837 : 			}
; 4838 : 			else

  01db6	e9 d1 fa ff ff	 jmp	 $LN210@CGItemGetR
  01dbb	90		 npad	 1
$LN220@CGItemGetR:

; 4850 : 	}
; 4851 : }

  01dbc	00 00 00 00	 DD	 $LN72@CGItemGetR
  01dc0	00 00 00 00	 DD	 $LN72@CGItemGetR
  01dc4	00 00 00 00	 DD	 $LN72@CGItemGetR
  01dc8	00 00 00 00	 DD	 $LN77@CGItemGetR
  01dcc	00 00 00 00	 DD	 $LN76@CGItemGetR
  01dd0	00 00 00 00	 DD	 $LN75@CGItemGetR
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ENDP	; CGItemGetRequest
_TEXT	ENDS
PUBLIC	??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@ ; `string'
PUBLIC	??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z	; CGTalkRequestRecv
EXTRN	?GDGetWarehouseList@@YAXHPADH@Z:PROC		; GDGetWarehouseList
EXTRN	?GC_ShopInfo@CShop@@QAEXH@Z:PROC		; CShop::GC_ShopInfo
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjInventoryTrans@@YAHH@Z:PROC		; gObjInventoryTrans
EXTRN	?gDQChaosSuccessRateLevel7@@3HA:DWORD		; gDQChaosSuccessRateLevel7
EXTRN	?gDQChaosSuccessRateLevel6@@3HA:DWORD		; gDQChaosSuccessRateLevel6
EXTRN	?gDQChaosSuccessRateLevel5@@3HA:DWORD		; gDQChaosSuccessRateLevel5
EXTRN	?gDQChaosSuccessRateLevel4@@3HA:DWORD		; gDQChaosSuccessRateLevel4
EXTRN	?gDQChaosSuccessRateLevel3@@3HA:DWORD		; gDQChaosSuccessRateLevel3
EXTRN	?gDQChaosSuccessRateLevel1@@3HA:DWORD		; gDQChaosSuccessRateLevel1
EXTRN	?gDQChaosSuccessRateLevel2@@3HA:DWORD		; gDQChaosSuccessRateLevel2
EXTRN	?bCanChaosBox@@3HA:DWORD			; bCanChaosBox
EXTRN	?GDGetGuildWarehouseList@CGuildBank@@QAEXH@Z:PROC ; CGuildBank::GDGetGuildWarehouseList
EXTRN	?GCSendValueMenu@ZtUser@@QAE_NHH@Z:PROC		; ZtUser::GCSendValueMenu
EXTRN	?g_ZtUser@@3VZtUser@@A:BYTE			; g_ZtUser
EXTRN	?gHappyNewYearNpcEvent@@3HA:DWORD		; gHappyNewYearNpcEvent
EXTRN	?gMerryXMasNpcEvent@@3HA:DWORD			; gMerryXMasNpcEvent
EXTRN	?IsMapBattleZone@GensSystem@@QAEHH@Z:PROC	; GensSystem::IsMapBattleZone
EXTRN	?NpcTalk@@YAHPAUOBJECTSTRUCT@@0@Z:PROC		; NpcTalk
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@
; File e:\work\tranet_version\gs\include\prodef.h
CONST	SEGMENT
??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@ DB '['
	DB	'%s][%s] Open Chaos Box', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@
CONST	SEGMENT
??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@ DB '['
	DB	'ANTI-HACK][NPC Talk] Couldn''t talk.. (%s)(%s)', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z
_TEXT	SEGMENT
_pShopItemCount$ = -1064				; size = 6
tv704 = -1056						; size = 4
_pRequest$246593 = -1056				; size = 6
_lpMsg$GSCopy$ = -1048					; size = 4
_ShopNum$ = -1048					; size = 4
_aIndex$GSCopy$ = -1044					; size = 4
_pResult$ = -1040					; size = 11
_SendByte$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z PROC	; CGTalkRequestRecv, COMDAT

; 6317 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 04 00
	00		 sub	 esp, 1064		; 00000428H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6318 : 	LPOBJ lpObj = &gObj[aIndex];

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	8b fb		 mov	 edi, ebx
  00024	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0002a	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]

; 6319 : 	int DealerNumber ;
; 6320 : 	PMSG_TALKRESULT pResult;
; 6321 : 	PMSG_SHOPITEMCOUNT pShopItemCount;
; 6322 : 
; 6323 : 	if ( !PacketCheckTime(lpObj))

  0002d	56		 push	 esi

; 6329 : 	{
; 6330 : 		return;
; 6331 : 	}
; 6332 : 
; 6333 : 	if ( !gObjIsConnectedGP(aIndex) )

  0002e	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax

; 6609 : 		#else
; 6610 : 		GDGetWarehouseListOLD(aIndex, gObj[aIndex].AccountID);
; 6611 : 		#endif
; 6612 : 		
; 6613 : 		return;
; 6614 : 	}
; 6615 : 
; 6616 : 	if ( ShopNum == 101 )
; 6617 : 	{
; 6618 : 		return;
; 6619 : 	}
; 6620 : 	else
; 6621 : 	{
; 6622 : 		lOfs = 0;
; 6623 : 
; 6624 : 		lOfs += sizeof(pShopItemCount );
; 6625 : 
; 6626 : 		int size = lOfs + ShopC[ShopNum].SendItemDataLen;

  00034	89 9d ec fb ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0003a	89 bd e0 fb ff
	ff		 mov	 DWORD PTR tv704[ebp], edi
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 c0 07 00
	00		 je	 $LN40@CGTalkRequ

; 6324 : 	{
; 6325 : 		return;
; 6326 : 	}
; 6327 : 
; 6328 : 	if ( gObj[aIndex].CloseType != -1 )

  00050	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	80 7c 17 0b ff	 cmp	 BYTE PTR [edi+edx+11], -1
  0005b	0f 85 af 07 00
	00		 jne	 $LN40@CGTalkRequ

; 6329 : 	{
; 6330 : 		return;
; 6331 : 	}
; 6332 : 
; 6333 : 	if ( !gObjIsConnectedGP(aIndex) )

  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	75 2e		 jne	 SHORT $LN50@CGTalkRequ

; 6334 : 	{
; 6335 : 		LogAddTD("[ANTI-HACK][NPC Talk] Couldn't talk.. (%s)(%s)", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  00077	51		 push	 ecx
  00078	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  0007c	52		 push	 edx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6445 : 					ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
$LN50@CGTalkRequ:

; 6336 : 		return;
; 6337 : 	}
; 6338 : 
; 6339 : 	BYTE SendByte[1024];
; 6340 : 	int lOfs = 0;
; 6341 : 
; 6342 : 	if ( lpObj->m_IfState.use > 0 )

  0009c	f6 86 1c 0e 00
	00 03		 test	 BYTE PTR [esi+3612], 3
  000a3	0f 87 67 07 00
	00		 ja	 $LN40@CGTalkRequ

; 6343 : 	{
; 6344 : 		return;
; 6345 : 	}
; 6346 : 
; 6347 : 	DealerNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  000a9	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  000af	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  000b3	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  000b7	66 c1 e0 08	 shl	 ax, 8
  000bb	0f b7 c0	 movzx	 eax, ax
  000be	0b c1		 or	 eax, ecx

; 6348 : 	
; 6349 : 	if ( DealerNumber < 0 || DealerNumber > OBJMAX-1)

  000c0	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  000c5	0f 87 45 07 00
	00		 ja	 $LN40@CGTalkRequ

; 6350 : 	{
; 6351 : 		return;
; 6352 : 	}
; 6353 : 
; 6354 : 	if ( lpObj->MapNumber != gObj[DealerNumber].MapNumber )

  000cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d1	8a 8e 49 01 00
	00		 mov	 cl, BYTE PTR [esi+329]
  000d7	8b f8		 mov	 edi, eax
  000d9	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  000df	3a 8c 17 49 01
	00 00		 cmp	 cl, BYTE PTR [edi+edx+329]
  000e6	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000e9	0f 85 21 07 00
	00		 jne	 $LN40@CGTalkRequ

; 6355 : 	{
; 6356 : 		return;
; 6357 : 	}
; 6358 : 
; 6359 : //#if(GS_CASTLE==0)
; 6360 : 	if ( gObj[DealerNumber].Class == 367 )
; 6361 : 	{
; 6362 : 		if ( (lpObj->X < (gObj[DealerNumber].X-5) )|| (lpObj->X> (gObj[DealerNumber].X+5) )||(lpObj->Y < (gObj[DealerNumber].Y-10)) ||(lpObj->Y > (gObj[DealerNumber].Y+5)))

  000ef	0f bf 88 44 01
	00 00		 movsx	 ecx, WORD PTR [eax+324]
  000f6	ba 6f 01 00 00	 mov	 edx, 367		; 0000016fH
  000fb	66 39 90 b8 00
	00 00		 cmp	 WORD PTR [eax+184], dx
  00102	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  00109	8d 59 fb	 lea	 ebx, DWORD PTR [ecx-5]
  0010c	75 44		 jne	 SHORT $LN45@CGTalkRequ
  0010e	3b d3		 cmp	 edx, ebx
  00110	0f 8c fa 06 00
	00		 jl	 $LN40@CGTalkRequ
  00116	83 c1 05	 add	 ecx, 5
  00119	3b d1		 cmp	 edx, ecx
  0011b	0f 8f ef 06 00
	00		 jg	 $LN40@CGTalkRequ
  00121	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  00128	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  0012f	8d 59 f6	 lea	 ebx, DWORD PTR [ecx-10]
  00132	3b d3		 cmp	 edx, ebx
  00134	0f 8c d6 06 00
	00		 jl	 $LN40@CGTalkRequ
  0013a	83 c1 05	 add	 ecx, 5
  0013d	3b d1		 cmp	 edx, ecx
  0013f	7e 48		 jle	 SHORT $LN64@CGTalkRequ
  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  00144	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
$LN45@CGTalkRequ:

; 6363 : 		{
; 6364 : 			return;
; 6365 : 		}
; 6366 : 	}
; 6367 : 	else if ( (lpObj->X < (gObj[DealerNumber].X-5) )|| (lpObj->X> (gObj[DealerNumber].X+5) )||(lpObj->Y < (gObj[DealerNumber].Y-5)) ||(lpObj->Y > (gObj[DealerNumber].Y+5)))

  00152	3b d3		 cmp	 edx, ebx
  00154	0f 8c b6 06 00
	00		 jl	 $LN40@CGTalkRequ
  0015a	83 c1 05	 add	 ecx, 5
  0015d	3b d1		 cmp	 edx, ecx
  0015f	0f 8f ab 06 00
	00		 jg	 $LN40@CGTalkRequ
  00165	0f bf 88 46 01
	00 00		 movsx	 ecx, WORD PTR [eax+326]
  0016c	0f bf 96 46 01
	00 00		 movsx	 edx, WORD PTR [esi+326]
  00173	8d 59 fb	 lea	 ebx, DWORD PTR [ecx-5]
  00176	3b d3		 cmp	 edx, ebx
  00178	0f 8c 92 06 00
	00		 jl	 $LN40@CGTalkRequ
  0017e	83 c1 05	 add	 ecx, 5
  00181	3b d1		 cmp	 edx, ecx
  00183	0f 8f 87 06 00
	00		 jg	 $LN40@CGTalkRequ
$LN64@CGTalkRequ:

; 6368 : 	{
; 6369 : 		return;
; 6370 : 	}
; 6371 : //#else
; 6372 : 	//if ( (lpObj->X < (gObj[DealerNumber].X-5) )|| (lpObj->X> (gObj[DealerNumber].X+5) )||(lpObj->Y < (gObj[DealerNumber].Y-5)) ||(lpObj->Y > (gObj[DealerNumber].Y+5)))
; 6373 : 	//{
; 6374 : 	//	return;
; 6375 : 	//}
; 6376 : //#endif
; 6377 : 
; 6378 : 	int ShopNum = gObj[DealerNumber].ShopNumber;
; 6379 : 
; 6380 : 	if ( gObj[DealerNumber].Type == OBJ_NPC )

  00189	66 83 78 68 03	 cmp	 WORD PTR [eax+104], 3
  0018e	0f bf 88 5c 04
	00 00		 movsx	 ecx, WORD PTR [eax+1116]
  00195	89 8d e8 fb ff
	ff		 mov	 DWORD PTR _ShopNum$[ebp], ecx
  0019b	75 13		 jne	 SHORT $LN65@CGTalkRequ

; 6381 : 	{
; 6382 : 		if ( NpcTalk(&gObj[DealerNumber], lpObj) == TRUE )

  0019d	56		 push	 esi
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ?NpcTalk@@YAHPAUOBJECTSTRUCT@@0@Z ; NpcTalk
  001a4	83 c4 08	 add	 esp, 8
  001a7	83 f8 01	 cmp	 eax, 1
  001aa	0f 84 60 06 00
	00		 je	 $LN40@CGTalkRequ
$LN65@CGTalkRequ:

; 6383 : 		{
; 6384 : 			return;
; 6385 : 		}
; 6386 : 	}
; 6387 : 
; 6388 : 	if ( ::gObjFixInventoryPointer(aIndex) == false )

  001b0	8b 9d ec fb ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  001b6	53		 push	 ebx
  001b7	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  001bc	83 c4 04	 add	 esp, 4
  001bf	84 c0		 test	 al, al
  001c1	75 18		 jne	 SHORT $LN37@CGTalkRequ

; 6389 : 	{
; 6390 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  001c3	68 f6 18 00 00	 push	 6390			; 000018f6H
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@CGTalkRequ:

; 6391 : 	}
; 6392 : 
; 6393 : 	if ( gObj[DealerNumber].Class == 234 )

  001db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e0	ba ea 00 00 00	 mov	 edx, 234		; 000000eaH
  001e5	66 39 94 07 b8
	00 00 00	 cmp	 WORD PTR [edi+eax+184], dx
  001ed	75 3a		 jne	 SHORT $LN36@CGTalkRequ

; 6394 : 	{
; 6395 : 		pResult.h.c = 0xC3;
; 6396 : 		pResult.h.headcode = 0x30;
; 6397 : 		pResult.h.size = sizeof(pResult);
; 6398 : 		pResult.result = 0;
; 6399 : 		pResult.result = 5;
; 6400 : 
; 6401 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001ef	6a 0b		 push	 11			; 0000000bH
  001f1	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  001f7	50		 push	 eax
  001f8	53		 push	 ebx
  001f9	c6 85 f0 fb ff
	ff c3		 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H
  00200	66 c7 85 f1 fb
	ff ff 0b 30	 mov	 WORD PTR _pResult$[ebp+1], 12299 ; 0000300bH
  00209	c6 85 f3 fb ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+3], 5
  00210	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6445 : 					ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00215	83 c4 0c	 add	 esp, 12			; 0000000cH
  00218	5f		 pop	 edi
  00219	5e		 pop	 esi
  0021a	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  0021b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021e	33 cd		 xor	 ecx, ebp
  00220	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c3		 ret	 0
$LN36@CGTalkRequ:

; 6402 : 		return;
; 6403 : 	}
; 6404 : 
; 6405 : 	if ( gObj[DealerNumber].Type == OBJ_NPC && ShopNum < 0)

  00229	66 83 7c 07 68
	03		 cmp	 WORD PTR [edi+eax+104], 3
  0022f	75 0d		 jne	 SHORT $LN62@CGTalkRequ
  00231	83 bd e8 fb ff
	ff 00		 cmp	 DWORD PTR _ShopNum$[ebp], 0
  00238	0f 8c d2 05 00
	00		 jl	 $LN40@CGTalkRequ
$LN62@CGTalkRequ:

; 6406 : 	{
; 6407 : 		return;
; 6408 : 	}
; 6409 : 
; 6410 : 	if ( ShopNum < MAX_SHOP )

  0023e	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _ShopNum$[ebp]
  00244	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00247	0f 8d f7 00 00
	00		 jge	 $LN59@CGTalkRequ

; 6411 : 	{
; 6412 : 		if ( ShopC[ShopNum].ItemCount < TRUE )

  0024d	69 c0 9c 6f 00
	00		 imul	 eax, 28572		; 00006f9cH
  00253	83 b8 7c 00 00
	00 01		 cmp	 DWORD PTR ?ShopC@@3PAVCShop@@A[eax+124], 1
  0025a	7d 2d		 jge	 SHORT $LN33@CGTalkRequ

; 6413 : 		{
; 6414 : 			if ( (rand()%2) != 0 )

  0025c	e8 00 00 00 00	 call	 _rand
  00261	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00266	79 05		 jns	 SHORT $LN73@CGTalkRequ
  00268	48		 dec	 eax
  00269	83 c8 fe	 or	 eax, -2			; fffffffeH
  0026c	40		 inc	 eax
$LN73@CGTalkRequ:

; 6415 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 119)), aIndex);

  0026d	53		 push	 ebx
  0026e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00273	74 0a		 je	 SHORT $LN32@CGTalkRequ
  00275	68 77 04 00 00	 push	 1143			; 00000477H

; 6416 : 			else

  0027a	e9 99 00 00 00	 jmp	 $LN75@CGTalkRequ
$LN32@CGTalkRequ:

; 6417 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 120)), aIndex);

  0027f	68 78 04 00 00	 push	 1144			; 00000478H

; 6418 : 			return;

  00284	e9 8f 00 00 00	 jmp	 $LN75@CGTalkRequ
$LN33@CGTalkRequ:

; 6419 : 		}
; 6420 : //#ifdef GENS
; 6421 : 		if( !gPkLimitFree && !gGensSystem.IsMapBattleZone(lpObj->MapNumber)
; 6422 : //#endif	
; 6423 : 			)

  00289	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00290	0f 85 ae 00 00
	00		 jne	 $LN59@CGTalkRequ
  00296	0f b6 86 49 01
	00 00		 movzx	 eax, BYTE PTR [esi+329]
  0029d	50		 push	 eax
  0029e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  002a3	e8 00 00 00 00	 call	 ?IsMapBattleZone@GensSystem@@QAEHH@Z ; GensSystem::IsMapBattleZone
  002a8	85 c0		 test	 eax, eax
  002aa	0f 85 94 00 00
	00		 jne	 $LN59@CGTalkRequ

; 6424 : 		{
; 6425 : 			BOOL bPlayerKiller = FALSE; //season 2.5 add-on

  002b0	33 db		 xor	 ebx, ebx

; 6426 : 
; 6427 : 			if(ZtConfig.PvP.ZtPkPartySystem && lpObj->PartyNumber >= 0) //season 2.5 add-on

  002b2	39 1d 38 09 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2360, ebx
  002b8	74 1e		 je	 SHORT $LN66@CGTalkRequ
  002ba	8b 86 2c 04 00
	00		 mov	 eax, DWORD PTR [esi+1068]
  002c0	85 c0		 test	 eax, eax
  002c2	78 14		 js	 SHORT $LN66@CGTalkRequ

; 6428 : 			{
; 6429 : 				if( (gParty.GetPkLevel(lpObj->PartyNumber)) > 4)

  002c4	50		 push	 eax
  002c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002ca	e8 00 00 00 00	 call	 ?GetPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPkLevel
  002cf	3c 04		 cmp	 al, 4
  002d1	7e 05		 jle	 SHORT $LN66@CGTalkRequ

; 6430 : 				{
; 6431 : 					bPlayerKiller = TRUE;

  002d3	bb 01 00 00 00	 mov	 ebx, 1
$LN66@CGTalkRequ:

; 6432 : 				}
; 6433 : 			}
; 6434 : 
; 6435 : 			if( lpObj->m_PK_Level > 4 )

  002d8	80 be 3d 01 00
	00 04		 cmp	 BYTE PTR [esi+317], 4

; 6436 : 			{
; 6437 : 				bPlayerKiller = TRUE;
; 6438 : 			}
; 6439 : 
; 6440 : 			if ( bPlayerKiller == TRUE ) //season 2.5 changed

  002df	7f 05		 jg	 SHORT $LN57@CGTalkRequ
  002e1	83 fb 01	 cmp	 ebx, 1
  002e4	75 58		 jne	 SHORT $LN67@CGTalkRequ
$LN57@CGTalkRequ:

; 6441 : 			{
; 6442 : 				if ( (rand()%2) != 0 )

  002e6	e8 00 00 00 00	 call	 _rand
  002eb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002f0	79 05		 jns	 SHORT $LN74@CGTalkRequ
  002f2	48		 dec	 eax
  002f3	83 c8 fe	 or	 eax, -2			; fffffffeH
  002f6	40		 inc	 eax
$LN74@CGTalkRequ:
  002f7	74 0e		 je	 SHORT $LN25@CGTalkRequ

; 6443 : 					ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 121)), aIndex);

  002f9	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002ff	51		 push	 ecx
  00300	68 79 04 00 00	 push	 1145			; 00000479H

; 6444 : 				else

  00305	eb 0c		 jmp	 SHORT $LN77@CGTalkRequ
$LN25@CGTalkRequ:

; 6445 : 					ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00307	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0030d	50		 push	 eax
  0030e	68 7a 04 00 00	 push	 1146			; 0000047aH
$LN77@CGTalkRequ:
  00313	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
$LN75@CGTalkRequ:
  00318	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0031d	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00323	50		 push	 eax
  00324	57		 push	 edi
  00325	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  0032a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032d	5f		 pop	 edi
  0032e	5e		 pop	 esi
  0032f	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  00330	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00333	33 cd		 xor	 ecx, ebp
  00335	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c3		 ret	 0
$LN67@CGTalkRequ:

; 6446 : 
; 6447 : 				return;

  0033e	8b 9d ec fb ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
$LN59@CGTalkRequ:

; 6448 : 			}
; 6449 : 		}
; 6450 : 	}
; 6451 : 
; 6452 : 	if ( gMerryXMasNpcEvent == TRUE )

  00344	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gMerryXMasNpcEvent@@3HA, 1 ; gMerryXMasNpcEvent
  0034b	75 34		 jne	 SHORT $LN60@CGTalkRequ

; 6453 : 	{
; 6454 : 		if ( (rand()%6) == 0 )

  0034d	e8 00 00 00 00	 call	 _rand
  00352	99		 cdq
  00353	b9 06 00 00 00	 mov	 ecx, 6
  00358	f7 f9		 idiv	 ecx
  0035a	85 d2		 test	 edx, edx
  0035c	75 23		 jne	 SHORT $LN60@CGTalkRequ

; 6455 : 		{
; 6456 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 123)), aIndex);

  0035e	53		 push	 ebx
  0035f	68 7b 04 00 00	 push	 1147			; 0000047bH
  00364	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00369	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0036e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00374	50		 push	 eax
  00375	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00378	50		 push	 eax
  00379	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  0037e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@CGTalkRequ:

; 6457 : 		}
; 6458 : 	}
; 6459 : 
; 6460 : 	if ( ::gHappyNewYearNpcEvent == TRUE )

  00381	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gHappyNewYearNpcEvent@@3HA, 1 ; gHappyNewYearNpcEvent
  00388	75 34		 jne	 SHORT $LN61@CGTalkRequ

; 6461 : 	{
; 6462 : 		if ( (rand()%6) == 0 )

  0038a	e8 00 00 00 00	 call	 _rand
  0038f	99		 cdq
  00390	b9 06 00 00 00	 mov	 ecx, 6
  00395	f7 f9		 idiv	 ecx
  00397	85 d2		 test	 edx, edx
  00399	75 23		 jne	 SHORT $LN61@CGTalkRequ

; 6463 : 		{
; 6464 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 124)), aIndex);

  0039b	53		 push	 ebx
  0039c	68 7c 04 00 00	 push	 1148			; 0000047cH
  003a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003a6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b1	50		 push	 eax
  003b2	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  003b5	50		 push	 eax
  003b6	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  003bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN61@CGTalkRequ:

; 6465 : 		}
; 6466 : 	}
; 6467 : 
; 6468 : 	#if(CUSTOM_VALUE_MENU)
; 6469 : 	if(ZtConfig.ZtCustom.MultiWarehouse)

  003be	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+32, 0
  003c5	0f 84 92 00 00
	00		 je	 $LN70@CGTalkRequ

; 6470 : 	{
; 6471 : 		if ( ShopNum == 100 )

  003cb	83 bd e8 fb ff
	ff 64		 cmp	 DWORD PTR _ShopNum$[ebp], 100 ; 00000064H
  003d2	0f 85 85 00 00
	00		 jne	 $LN70@CGTalkRequ

; 6472 : 		{
; 6473 : 			if(g_ZtLicense.m_MultiWarehouseType)

  003d8	83 3d d8 61 00
	00 00		 cmp	 DWORD PTR ?g_ZtLicense@@3VCZtLicense@@A+25048, 0
  003df	74 7c		 je	 SHORT $LN70@CGTalkRequ

; 6474 : 			{
; 6475 : 				#if(DEV_GUILDBANK)
; 6476 : 				if(g_GuildBank.m_iEnable == 1 && 
; 6477 : 					gObj[aIndex].MapNumber == g_GuildBank.m_iGuildBankMap &&
; 6478 : 					gObj[DealerNumber].X == g_GuildBank.m_iGuildBankX &&
; 6479 : 					gObj[DealerNumber].Y == g_GuildBank.m_iGuildBankY)

  003e1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_GuildBank@@3VCGuildBank@@A, 1
  003e8	8b 9d e0 fb ff
	ff		 mov	 ebx, DWORD PTR tv704[ebp]
  003ee	75 50		 jne	 SHORT $LN15@CGTalkRequ
  003f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f5	0f b6 8c 03 49
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+329]
  003fd	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GuildBank@@3VCGuildBank@@A+4
  00403	75 3b		 jne	 SHORT $LN15@CGTalkRequ
  00405	0f bf 94 07 44
	01 00 00	 movsx	 edx, WORD PTR [edi+eax+324]
  0040d	3b 15 08 00 00
	00		 cmp	 edx, DWORD PTR ?g_GuildBank@@3VCGuildBank@@A+8
  00413	75 2b		 jne	 SHORT $LN15@CGTalkRequ
  00415	0f bf 84 07 46
	01 00 00	 movsx	 eax, WORD PTR [edi+eax+326]
  0041d	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_GuildBank@@3VCGuildBank@@A+12
  00423	75 1b		 jne	 SHORT $LN15@CGTalkRequ

; 6480 : 				{
; 6481 : 					if(g_ZtUser.GCSendValueMenu(aIndex, 2))

  00425	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0042b	6a 02		 push	 2
  0042d	51		 push	 ecx
  0042e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  00433	e8 00 00 00 00	 call	 ?GCSendValueMenu@ZtUser@@QAE_NHH@Z ; ZtUser::GCSendValueMenu
  00438	84 c0		 test	 al, al
  0043a	0f 85 d0 03 00
	00		 jne	 $LN40@CGTalkRequ
$LN15@CGTalkRequ:

; 6482 : 					{
; 6483 : 						return;
; 6484 : 					}
; 6485 : 				}
; 6486 : 				#endif
; 6487 : 
; 6488 : 				if(g_ZtUser.GCSendValueMenu(aIndex, 1))

  00440	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00446	6a 01		 push	 1
  00448	52		 push	 edx
  00449	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  0044e	e8 00 00 00 00	 call	 ?GCSendValueMenu@ZtUser@@QAE_NHH@Z ; ZtUser::GCSendValueMenu
  00453	84 c0		 test	 al, al
  00455	0f 85 b5 03 00
	00		 jne	 $LN40@CGTalkRequ
  0045b	eb 06		 jmp	 SHORT $LN71@CGTalkRequ
$LN70@CGTalkRequ:
  0045d	8b 9d e0 fb ff
	ff		 mov	 ebx, DWORD PTR tv704[ebp]
$LN71@CGTalkRequ:

; 6489 : 				{
; 6490 : 					return;
; 6491 : 				}
; 6492 : 			}
; 6493 : 		}
; 6494 : 	}
; 6495 : 	#endif
; 6496 : 
; 6497 : 	lpObj->TargetShopNumber = ShopNum;
; 6498 : 	lpObj->m_IfState.use = 1;
; 6499 : 	lpObj->m_IfState.type = 3;

  00463	8b 8e 1c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3612]
  00469	8b 85 e8 fb ff
	ff		 mov	 eax, DWORD PTR _ShopNum$[ebp]
  0046f	81 e1 fd 00 ff
	ff		 and	 ecx, -65283		; ffff00fdH
  00475	81 c9 c1 00 00
	00		 or	 ecx, 193		; 000000c1H
  0047b	66 89 86 5a 04
	00 00		 mov	 WORD PTR [esi+1114], ax
  00482	89 8e 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], ecx

; 6500 : 	lpObj->m_ShopTime = 0;

  00488	c6 86 90 03 00
	00 00		 mov	 BYTE PTR [esi+912], 0

; 6501 : 	pResult.h.c = 0xC3;

  0048f	c6 85 f0 fb ff
	ff c3		 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 6502 : 	pResult.h.headcode = 0x30;

  00496	66 c7 85 f1 fb
	ff ff 0b 30	 mov	 WORD PTR _pResult$[ebp+1], 12299 ; 0000300bH

; 6503 : 	pResult.h.size = sizeof(pResult);
; 6504 : 	pResult.result = 0;

  0049f	c6 85 f3 fb ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0

; 6505 : 
; 6506 : 	if ( ShopNum == 100 )

  004a6	83 f8 64	 cmp	 eax, 100		; 00000064H
  004a9	0f 85 f5 00 00
	00		 jne	 $LN13@CGTalkRequ

; 6507 : 	{
; 6508 : 		if ( gObj[aIndex].m_ReqWarehouseOpen != false )

  004af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b4	80 bc 03 1c 11
	00 00 00	 cmp	 BYTE PTR [ebx+eax+4380], 0
  004bc	0f 85 4e 03 00
	00		 jne	 $LN40@CGTalkRequ

; 6509 : 			return;
; 6510 : 		
; 6511 : 		gObj[aIndex].m_ReqWarehouseOpen = true;

  004c2	c6 84 03 1c 11
	00 00 01	 mov	 BYTE PTR [ebx+eax+4380], 1

; 6512 : 		lpObj->m_IfState.type = 6;
; 6513 : 		lpObj->m_IfState.state = 0;

  004ca	8b 96 1c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3612]
  004d0	81 e2 83 01 ff
	ff		 and	 edx, -65149		; ffff0183H
  004d6	81 ca 80 01 00
	00		 or	 edx, 384		; 00000180H
  004dc	89 96 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], edx

; 6563 : 	}
; 6564 : 
; 6565 : 	if ( ShopNum == 100 )
; 6566 : 	{
; 6567 : 		//#if(CUSTOM_VALUE_MENU)
; 6568 : 		//if(g_ZtLicense.m_MultiWarehouseType)
; 6569 : 		//{
; 6570 : 		//	#if(DEV_GUILDBANK)
; 6571 : 		//	if(g_GuildBank.m_iEnable == 1 && 
; 6572 : 		//	   gObj[aIndex].MapNumber == g_GuildBank.m_iGuildBankMap &&
; 6573 : 		//	   gObj[DealerNumber].X == g_GuildBank.m_iGuildBankX &&
; 6574 : 		//	   gObj[DealerNumber].Y == g_GuildBank.m_iGuildBankY)
; 6575 : 		//	{
; 6576 : 		//		if(g_ZtUser.GCSendValueMenu(aIndex, 2))
; 6577 : 		//		{
; 6578 : 		//			return;
; 6579 : 		//		}
; 6580 : 		//	}
; 6581 : 		//	#endif
; 6582 : 
; 6583 : 		//	if(g_ZtUser.GCSendValueMenu(aIndex, 1))
; 6584 : 		//	{
; 6585 : 		//		return;
; 6586 : 		//	}
; 6587 : 		//}
; 6588 : 		//#endif
; 6589 : 
; 6590 : 		gObj[aIndex].WarehouseTickCount = GetTickCount();

  004e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ee	89 84 13 74 0e
	00 00		 mov	 DWORD PTR [ebx+edx+3700], eax

; 6591 : 		gObj[aIndex].WarehouseCount = 0;

  004f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004fa	c6 84 03 64 0e
	00 00 00	 mov	 BYTE PTR [ebx+eax+3684], 0

; 6592 : 		#if(CUSTOM_MULTIWAREHOUSE)
; 6593 : 		lpObj->WareChange = false;
; 6594 : 		lpObj->WarehouseNumber = 0;
; 6595 : 		WarehouseNumberSend(lpObj->m_Index);

  00502	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00504	51		 push	 ecx
  00505	c6 86 e5 2a 00
	00 00		 mov	 BYTE PTR [esi+10981], 0
  0050c	c7 86 e8 2a 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+10984], 0
  00516	e8 00 00 00 00	 call	 ?WarehouseNumberSend@@YAXH@Z ; WarehouseNumberSend

; 6596 : 		#if(DEV_GUILDBANK)
; 6597 : 		gObj[aIndex].m_bGuildBank = false;

  0051b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00521	c6 84 13 25 2b
	00 00 00	 mov	 BYTE PTR [ebx+edx+11045], 0

; 6598 : 		if(g_GuildBank.m_iEnable == 1 && 
; 6599 : 		   gObj[aIndex].MapNumber == g_GuildBank.m_iGuildBankMap &&
; 6600 : 		   gObj[DealerNumber].X == g_GuildBank.m_iGuildBankX &&
; 6601 : 		   gObj[DealerNumber].Y == g_GuildBank.m_iGuildBankY)

  00529	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0052e	83 c4 04	 add	 esp, 4
  00531	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_GuildBank@@3VCGuildBank@@A, 1
  00538	0f 85 e3 02 00
	00		 jne	 $LN3@CGTalkRequ
  0053e	0f b6 8c 03 49
	01 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+329]
  00546	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GuildBank@@3VCGuildBank@@A+4
  0054c	0f 85 cf 02 00
	00		 jne	 $LN3@CGTalkRequ
  00552	0f bf 94 07 44
	01 00 00	 movsx	 edx, WORD PTR [edi+eax+324]
  0055a	3b 15 08 00 00
	00		 cmp	 edx, DWORD PTR ?g_GuildBank@@3VCGuildBank@@A+8
  00560	0f 85 bb 02 00
	00		 jne	 $LN3@CGTalkRequ
  00566	0f bf 8c 07 46
	01 00 00	 movsx	 ecx, WORD PTR [edi+eax+326]
  0056e	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GuildBank@@3VCGuildBank@@A+12
  00574	0f 85 a7 02 00
	00		 jne	 $LN3@CGTalkRequ

; 6602 : 		{
; 6603 : 			gObj[aIndex].m_bGuildBank = true;
; 6604 : 			g_GuildBank.GDGetGuildWarehouseList(aIndex);

  0057a	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00580	52		 push	 edx
  00581	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  00586	c6 84 03 25 2b
	00 00 01	 mov	 BYTE PTR [ebx+eax+11045], 1
  0058e	e8 00 00 00 00	 call	 ?GDGetGuildWarehouseList@CGuildBank@@QAEXH@Z ; CGuildBank::GDGetGuildWarehouseList
  00593	5f		 pop	 edi
  00594	5e		 pop	 esi
  00595	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  00596	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00599	33 cd		 xor	 ecx, ebp
  0059b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a0	8b e5		 mov	 esp, ebp
  005a2	5d		 pop	 ebp
  005a3	c3		 ret	 0
$LN13@CGTalkRequ:

; 6514 : 
; 6515 : 	}
; 6516 : 	else if ( ShopNum == 101 )

  005a4	83 f8 65	 cmp	 eax, 101		; 00000065H
  005a7	0f 85 7b 01 00
	00		 jne	 $LN10@CGTalkRequ

; 6517 : 	{
; 6518 : 		if ( bCanChaosBox == TRUE )

  005ad	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanChaosBox@@3HA, 1 ; bCanChaosBox
  005b4	0f 85 56 02 00
	00		 jne	 $LN40@CGTalkRequ

; 6519 : 		{
; 6520 : 			if ( lpObj->m_bPShopOpen == true )

  005ba	80 be c4 0e 00
	00 01		 cmp	 BYTE PTR [esi+3780], 1
  005c1	75 44		 jne	 SHORT $LN8@CGTalkRequ

; 6521 : 			{
; 6522 : 				LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed", lpObj->AccountID, lpObj->Name);

  005c3	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  005c6	50		 push	 eax
  005c7	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  005ca	51		 push	 ecx
  005cb	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  005d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 6523 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  005d6	8b 16		 mov	 edx, DWORD PTR [esi]
  005d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  005db	6a 01		 push	 1
  005dd	52		 push	 edx
  005de	68 c2 04 00 00	 push	 1218			; 000004c2H
  005e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005e8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  005ed	50		 push	 eax
  005ee	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  005f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  005f6	5f		 pop	 edi
  005f7	5e		 pop	 esi
  005f8	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  005f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005fc	33 cd		 xor	 ecx, ebp
  005fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00603	8b e5		 mov	 esp, ebp
  00605	5d		 pop	 ebp
  00606	c3		 ret	 0
$LN8@CGTalkRequ:

; 6524 : 				return;
; 6525 : 			}
; 6526 : 
; 6527 : 			lpObj->m_IfState.type = 7;
; 6528 : 			lpObj->m_IfState.state = 0;

  00607	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  0060d	25 c3 01 ff ff	 and	 eax, -65085		; ffff01c3H
  00612	0d c0 01 00 00	 or	 eax, 448		; 000001c0H
  00617	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax

; 6529 : 			pResult.result = 3;
; 6530 : 
; 6531 : 			if(gObj[DealerNumber].Class == 450) //Season 3.0 add-on

  0061d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00622	b9 c2 01 00 00	 mov	 ecx, 450		; 000001c2H
  00627	c6 85 f3 fb ff
	ff 03		 mov	 BYTE PTR _pResult$[ebp+3], 3
  0062e	66 39 8c 07 b8
	00 00 00	 cmp	 WORD PTR [edi+eax+184], cx
  00636	75 07		 jne	 SHORT $LN7@CGTalkRequ

; 6532 : 			{
; 6533 : 				pResult.result = 0x16; //season4 changed

  00638	c6 85 f3 fb ff
	ff 16		 mov	 BYTE PTR _pResult$[ebp+3], 22 ; 00000016H
$LN7@CGTalkRequ:

; 6534 : 			}
; 6535 : 
; 6536 : 			if(gObj[DealerNumber].Class == 478) //Season 4.0 add-on

  0063f	ba de 01 00 00	 mov	 edx, 478		; 000001deH
  00644	66 39 94 07 b8
	00 00 00	 cmp	 WORD PTR [edi+eax+184], dx
  0064c	75 07		 jne	 SHORT $LN6@CGTalkRequ

; 6537 : 			{
; 6538 : 				pResult.result = 0x20;

  0064e	c6 85 f3 fb ff
	ff 20		 mov	 BYTE PTR _pResult$[ebp+3], 32 ; 00000020H
$LN6@CGTalkRequ:

; 6539 : 			}
; 6540 : 
; 6541 : 			lpObj->bIsChaosMixCompleted = false;

  00655	c6 86 79 12 00
	00 00		 mov	 BYTE PTR [esi+4729], 0

; 6542 : 
; 6543 : 			pResult.level1 = gDQChaosSuccessRateLevel1;
; 6544 : 			pResult.level2 = gDQChaosSuccessRateLevel2;

  0065c	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?gDQChaosSuccessRateLevel2@@3HA
  00663	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gDQChaosSuccessRateLevel1@@3HA

; 6545 : 			pResult.level3 = gDQChaosSuccessRateLevel3;

  0066a	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?gDQChaosSuccessRateLevel3@@3HA
  00671	88 85 f4 fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], al

; 6546 : 			pResult.level4 = gDQChaosSuccessRateLevel4;

  00677	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gDQChaosSuccessRateLevel4@@3HA
  0067e	88 8d f5 fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], cl

; 6547 : 			pResult.level5 = gDQChaosSuccessRateLevel5;

  00684	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?gDQChaosSuccessRateLevel5@@3HA
  0068b	88 95 f6 fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], dl

; 6548 : 			pResult.level6 = gDQChaosSuccessRateLevel6;

  00691	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?gDQChaosSuccessRateLevel6@@3HA
  00698	88 85 f7 fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], al

; 6549 : 			pResult.level7 = gDQChaosSuccessRateLevel7; //season 3.0 add-on

  0069e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?gDQChaosSuccessRateLevel7@@3HA
  006a5	88 8d f8 fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+8], cl

; 6550 : 
; 6551 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  006ab	0f b6 8d f1 fb
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  006b2	88 95 f9 fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+9], dl
  006b8	51		 push	 ecx
  006b9	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  006bf	88 85 fa fb ff
	ff		 mov	 BYTE PTR _pResult$[ebp+10], al
  006c5	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  006cb	52		 push	 edx
  006cc	50		 push	 eax
  006cd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6552 : 			gObjInventoryTrans(lpObj->m_Index);

  006d2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006d4	51		 push	 ecx
  006d5	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans

; 6553 : 
; 6554 : 			LogAddTD("[%s][%s] Open Chaos Box", lpObj->AccountID, lpObj->Name);

  006da	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  006dd	52		 push	 edx
  006de	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  006e1	50		 push	 eax
  006e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@
  006e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6555 : 			gObjItemTextSave(lpObj);

  006ed	56		 push	 esi
  006ee	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave

; 6556 : 			gObjWarehouseTextSave(lpObj);

  006f3	56		 push	 esi
  006f4	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave

; 6557 : 			GCAnsCsMapSvrTaxInfo( lpObj->m_Index, 1, ::g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index));

  006f9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  006fb	83 c4 24	 add	 esp, 36			; 00000024H
  006fe	51		 push	 ecx
  006ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00704	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00709	8b 16		 mov	 edx, DWORD PTR [esi]
  0070b	50		 push	 eax
  0070c	6a 01		 push	 1
  0070e	52		 push	 edx
  0070f	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo
  00714	83 c4 0c	 add	 esp, 12			; 0000000cH
  00717	5f		 pop	 edi
  00718	5e		 pop	 esi
  00719	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  0071a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0071d	33 cd		 xor	 ecx, ebp
  0071f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00724	8b e5		 mov	 esp, ebp
  00726	5d		 pop	 ebp
  00727	c3		 ret	 0
$LN10@CGTalkRequ:

; 6558 : 		}
; 6559 : 	}
; 6560 : 	else
; 6561 : 	{
; 6562 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00728	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0072e	6a 0b		 push	 11			; 0000000bH
  00730	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00736	50		 push	 eax
  00737	51		 push	 ecx
  00738	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6609 : 		#else
; 6610 : 		GDGetWarehouseListOLD(aIndex, gObj[aIndex].AccountID);
; 6611 : 		#endif
; 6612 : 		
; 6613 : 		return;
; 6614 : 	}
; 6615 : 
; 6616 : 	if ( ShopNum == 101 )
; 6617 : 	{
; 6618 : 		return;
; 6619 : 	}
; 6620 : 	else
; 6621 : 	{
; 6622 : 		lOfs = 0;
; 6623 : 
; 6624 : 		lOfs += sizeof(pShopItemCount );
; 6625 : 
; 6626 : 		int size = lOfs + ShopC[ShopNum].SendItemDataLen;

  0073d	8b bd e8 fb ff
	ff		 mov	 edi, DWORD PTR _ShopNum$[ebp]
  00743	69 ff 9c 6f 00
	00		 imul	 edi, 28572		; 00006f9cH
  00749	8b 9f f8 69 00
	00		 mov	 ebx, DWORD PTR ?ShopC@@3PAVCShop@@A[edi+27128]
  0074f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00752	83 c3 06	 add	 ebx, 6

; 6627 : 		PHeadSetW((LPBYTE)&pShopItemCount, 0x31, size);

  00755	53		 push	 ebx
  00756	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR _pShopItemCount$[ebp]
  0075c	6a 31		 push	 49			; 00000031H
  0075e	51		 push	 ecx
  0075f	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 6628 : 		pShopItemCount.Type = 0;
; 6629 : 		pShopItemCount.count = ShopC[ShopNum].ItemCount;

  00764	8a 97 7c 00 00
	00		 mov	 dl, BYTE PTR ?ShopC@@3PAVCShop@@A[edi+124]

; 6630 : 		memcpy(SendByte, &pShopItemCount, sizeof(pShopItemCount));

  0076a	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _pShopItemCount$[ebp]
  00770	88 95 dd fb ff
	ff		 mov	 BYTE PTR _pShopItemCount$[ebp+5], dl

; 6631 : 		memcpy(&SendByte[lOfs], ShopC[ShopNum].SendItemData, ShopC[ShopNum].SendItemDataLen);

  00776	8b 97 f8 69 00
	00		 mov	 edx, DWORD PTR ?ShopC@@3PAVCShop@@A[edi+27128]
  0077c	c6 85 dc fb ff
	ff 00		 mov	 BYTE PTR _pShopItemCount$[ebp+4], 0
  00783	66 8b 8d dc fb
	ff ff		 mov	 cx, WORD PTR _pShopItemCount$[ebp+4]
  0078a	89 85 fc fb ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], eax
  00790	52		 push	 edx
  00791	8d 87 e0 63 00
	00		 lea	 eax, DWORD PTR ?ShopC@@3PAVCShop@@A[edi+25568]
  00797	66 89 8d 00 fc
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], cx
  0079e	50		 push	 eax
  0079f	8d 8d 02 fc ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp+6]
  007a5	51		 push	 ecx
  007a6	e8 00 00 00 00	 call	 _memcpy

; 6632 : 
; 6633 : 		DataSend(aIndex, SendByte, size);

  007ab	53		 push	 ebx
  007ac	8b 9d ec fb ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  007b2	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _SendByte$[ebp]
  007b8	52		 push	 edx
  007b9	53		 push	 ebx
  007ba	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6634 : 		GCAnsCsMapSvrTaxInfo(lpObj->m_Index,2,  ::g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index));

  007bf	8b 06		 mov	 eax, DWORD PTR [esi]
  007c1	83 c4 24	 add	 esp, 36			; 00000024H
  007c4	50		 push	 eax
  007c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  007ca	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  007cf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  007d1	50		 push	 eax
  007d2	6a 02		 push	 2
  007d4	51		 push	 ecx
  007d5	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo

; 6635 : 
; 6636 : #if(DONATE_SHOP==TRUE)
; 6637 : 		GC_SHOP_CLICK pRequest;
; 6638 : 		pRequest.h.set((LPBYTE)&pRequest, 0xFB, 0x06, sizeof(GC_SHOP_CLICK));
; 6639 : 		// ----
; 6640 : 		pRequest.Shop_Num = ShopNum;

  007da	66 8b 95 e8 fb
	ff ff		 mov	 dx, WORD PTR _ShopNum$[ebp]

; 6641 : 		// ----
; 6642 : 		DataSend(aIndex, (LPBYTE)&pRequest, sizeof(pRequest));

  007e1	6a 06		 push	 6
  007e3	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _pRequest$246593[ebp]
  007e9	50		 push	 eax
  007ea	53		 push	 ebx
  007eb	c7 85 e0 fb ff
	ff c1 06 fb 06	 mov	 DWORD PTR _pRequest$246593[ebp], 117114561 ; 06fb06c1H
  007f5	66 89 95 e4 fb
	ff ff		 mov	 WORD PTR _pRequest$246593[ebp+4], dx
  007fc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00801	83 c4 18	 add	 esp, 24			; 00000018H

; 6643 : 
; 6644 : 		ShopC[ShopNum].GC_ShopInfo(aIndex);

  00804	53		 push	 ebx
  00805	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[edi]
  0080b	e8 00 00 00 00	 call	 ?GC_ShopInfo@CShop@@QAEXH@Z ; CShop::GC_ShopInfo
$LN40@CGTalkRequ:
  00810	5f		 pop	 edi
  00811	5e		 pop	 esi
  00812	5b		 pop	 ebx

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  00813	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00816	33 cd		 xor	 ecx, ebp
  00818	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0081d	8b e5		 mov	 esp, ebp
  0081f	5d		 pop	 ebp
  00820	c3		 ret	 0
$LN3@CGTalkRequ:

; 6605 : 			return;
; 6606 : 		}
; 6607 : 		#endif
; 6608 : 		GDGetWarehouseList(aIndex, gObj[aIndex].AccountID, gObj[aIndex].WarehouseNumber);

  00821	8b 8c 03 e8 2a
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+10984]
  00828	51		 push	 ecx
  00829	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  0082d	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00833	52		 push	 edx
  00834	50		 push	 eax
  00835	e8 00 00 00 00	 call	 ?GDGetWarehouseList@@YAXHPADH@Z ; GDGetWarehouseList

; 6645 : #endif
; 6646 : 	}
; 6647 : }

  0083a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0083d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00840	5f		 pop	 edi
  00841	5e		 pop	 esi
  00842	33 cd		 xor	 ecx, ebp
  00844	5b		 pop	 ebx
  00845	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0084a	8b e5		 mov	 esp, ebp
  0084c	5d		 pop	 ebp
  0084d	c3		 ret	 0
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ENDP	; CGTalkRequestRecv
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z	; GCUserWarehouseSend
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -4120					; size = 4
tv251 = -4116						; size = 4
_n$246606 = -4112					; size = 4
_pMsg$ = -4108						; size = 6
_SendByte$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z PROC	; GCUserWarehouseSend, COMDAT

; 6650 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 10 00 00	 mov	 eax, 4120		; 00001018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 6651 : 	if ( lpObj->m_IfState.type != 6 )

  0001c	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  00022	8b c8		 mov	 ecx, eax
  00024	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0002a	57		 push	 edi

; 6678 : 		}
; 6679 : 	}
; 6680 : 
; 6681 : 	pMsg.h.sizeH = SET_NUMBERH(lOfs);

  0002b	89 b5 e8 ef ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], esi
  00031	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  00037	0f 85 30 01 00
	00		 jne	 $LN1@GCUserWare

; 6652 : 	{
; 6653 : 		return;
; 6654 : 	}
; 6655 : 
; 6656 : 	if ( lpObj->m_IfState.type == 6 && lpObj->m_IfState.state == 1 )

  0003d	24 3c		 and	 al, 60			; 0000003cH
  0003f	3c 04		 cmp	 al, 4
  00041	0f 84 26 01 00
	00		 je	 $LN1@GCUserWare

; 6657 : 	{
; 6658 : 		return;
; 6659 : 	}
; 6660 : 
; 6661 : 	PMSG_SHOPITEMCOUNT pMsg;
; 6662 : 	BYTE SendByte[WAREHOUSE_BUFF];
; 6663 : 	int lOfs = sizeof(pMsg);
; 6664 : 
; 6665 : 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  00047	33 ff		 xor	 edi, edi
  00049	57		 push	 edi
  0004a	8d 95 f4 ef ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  00050	6a 31		 push	 49			; 00000031H
  00052	52		 push	 edx
  00053	bb 06 00 00 00	 mov	 ebx, 6
  00058	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6666 : 	pMsg.count = 0;

  00060	66 89 bd f8 ef
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], di

; 6667 : 	pMsg.Type = 0;
; 6668 : 
; 6669 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  00067	89 bd f0 ef ff
	ff		 mov	 DWORD PTR _n$246606[ebp], edi
  0006d	89 bd ec ef ff
	ff		 mov	 DWORD PTR tv251[ebp], edi
$LL5@GCUserWare:

; 6670 : 	{
; 6671 : 		if ( lpObj->pWarehouse[n].IsItem() == TRUE )

  00073	8b 8e 5c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3676]
  00079	03 cf		 add	 ecx, edi
  0007b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00080	83 f8 01	 cmp	 eax, 1
  00083	75 4c		 jne	 SHORT $LN4@GCUserWare

; 6672 : 		{
; 6673 : 			SendByte[lOfs] = n;
; 6674 : 			lOfs++;
; 6675 : 			ItemByteConvert(&SendByte[lOfs], lpObj->pWarehouse[n] );

  00085	8b b6 5c 0e 00
	00		 mov	 esi, DWORD PTR [esi+3676]
  0008b	8a 85 f0 ef ff
	ff		 mov	 al, BYTE PTR _n$246606[ebp]
  00091	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00097	03 f7		 add	 esi, edi
  00099	8b fc		 mov	 edi, esp
  0009b	88 84 1d fc ef
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+ebx], al
  000a2	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000a7	f3 a5		 rep movsd
  000a9	8d 8c 1d fd ef
	ff ff		 lea	 ecx, DWORD PTR _SendByte$[ebp+ebx+1]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 6676 : 			lOfs += MAX_ITEM_INFO;
; 6677 : 			pMsg.count ++;

  000b6	8b b5 e8 ef ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$[ebp]
  000bc	8b bd ec ef ff
	ff		 mov	 edi, DWORD PTR tv251[ebp]
  000c2	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c8	83 c3 0d	 add	 ebx, 13			; 0000000dH
  000cb	fe 85 f9 ef ff
	ff		 inc	 BYTE PTR _pMsg$[ebp+5]
$LN4@GCUserWare:

; 6667 : 	pMsg.Type = 0;
; 6668 : 
; 6669 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  000d1	ff 85 f0 ef ff
	ff		 inc	 DWORD PTR _n$246606[ebp]
  000d7	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000dd	89 bd ec ef ff
	ff		 mov	 DWORD PTR tv251[ebp], edi
  000e3	81 ff c0 c6 00
	00		 cmp	 edi, 50880		; 0000c6c0H
  000e9	7c 88		 jl	 SHORT $LL5@GCUserWare

; 6682 : 	pMsg.h.sizeL = SET_NUMBERL(lOfs);
; 6683 : 	memcpy(SendByte, &pMsg, sizeof(pMsg));

  000eb	66 8b 8d f8 ef
	ff ff		 mov	 cx, WORD PTR _pMsg$[ebp+4]
  000f2	8b d3		 mov	 edx, ebx
  000f4	c1 ea 08	 shr	 edx, 8
  000f7	88 95 f5 ef ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], dl
  000fd	88 9d f6 ef ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], bl
  00103	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp]

; 6684 : 
; 6685 : 	DataSend(lpObj->m_Index, SendByte, lOfs);	// ???

  00109	53		 push	 ebx
  0010a	8d 95 fc ef ff
	ff		 lea	 edx, DWORD PTR _SendByte$[ebp]
  00110	89 85 fc ef ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], eax
  00116	8b 06		 mov	 eax, DWORD PTR [esi]
  00118	52		 push	 edx
  00119	50		 push	 eax
  0011a	66 89 8d 00 f0
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], cx
  00121	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6686 : 	GCWarehouseInventoryMoneySend(lpObj->m_Index, 1, lpObj->Money, lpObj->WarehouseMoney);

  00126	8b 8e 6c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3692]
  0012c	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	51		 push	 ecx
  00135	52		 push	 edx
  00136	6a 01		 push	 1
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 6687 : 
; 6688 : 	if ( lpObj->m_IfState.type == 6 )

  0013e	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  00144	8b c8		 mov	 ecx, eax
  00146	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0014c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014f	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  00155	75 16		 jne	 SHORT $LN1@GCUserWare

; 6689 : 	{
; 6690 : 		lpObj->m_IfState.state = 1;

  00157	83 e0 c7	 and	 eax, -57		; ffffffc7H
  0015a	83 c8 04	 or	 eax, 4
  0015d	89 86 1c 0e 00
	00		 mov	 DWORD PTR [esi+3612], eax

; 6691 : 		lpObj->WarehouseSave = TRUE;

  00163	c7 86 70 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+3696], 1
$LN1@GCUserWare:

; 6692 : 	}
; 6693 : }

  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	33 cd		 xor	 ecx, ebp
  00174	5b		 pop	 ebx
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; GCUserWarehouseSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGDonateItemBuy@@YAXPAUPMSG_DONATE_ITEMBUY@@H@Z ; CGDonateItemBuy
; Function compile flags: /Ogtp
;	COMDAT ?CGDonateItemBuy@@YAXPAUPMSG_DONATE_ITEMBUY@@H@Z
_TEXT	SEGMENT
_pMsg$246649 = -24					; size = 4
_pResult$246645 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDonateItemBuy@@YAXPAUPMSG_DONATE_ITEMBUY@@H@Z PROC	; CGDonateItemBuy, COMDAT

; 6734 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 6735 : 	if(!OBJMAX_RANGE(aIndex))

  00014	85 ff		 test	 edi, edi
  00016	78 6c		 js	 SHORT $LN4@CGDonateIt
  00018	33 c0		 xor	 eax, eax
  0001a	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00020	0f 9e c0	 setle	 al
  00023	85 c0		 test	 eax, eax
  00025	74 5d		 je	 SHORT $LN4@CGDonateIt

; 6736 : 	{
; 6737 : 		return;
; 6738 : 	}
; 6739 : 
; 6740 : 	LPOBJ lpUser = &gObj[aIndex];
; 6741 : 
; 6742 : 	if(!lpMsg->Result)

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002a	56		 push	 esi
  0002b	8b f7		 mov	 esi, edi
  0002d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00033	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  0003d	75 25		 jne	 SHORT $LN2@CGDonateIt

; 6743 : 	{
; 6744 : 		PMSG_BUYRESULT pResult;
; 6745 : 		PHeadSetB((LPBYTE)&pResult, 0x32, sizeof(pResult));

  0003f	6a 10		 push	 16			; 00000010H
  00041	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$246645[ebp]
  00044	6a 32		 push	 50			; 00000032H
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6746 : 		pResult.Result = -1;
; 6747 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0004c	0f b6 55 ed	 movzx	 edx, BYTE PTR _pResult$246645[ebp+1]
  00050	52		 push	 edx
  00051	8d 45 ec	 lea	 eax, DWORD PTR _pResult$246645[ebp]
  00054	50		 push	 eax
  00055	57		 push	 edi
  00056	c6 45 ef ff	 mov	 BYTE PTR _pResult$246645[ebp+3], 255 ; 000000ffH
  0005a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005f	83 c4 18	 add	 esp, 24			; 00000018H

; 6748 : 	}
; 6749 : 	else

  00062	eb 16		 jmp	 SHORT $LN1@CGDonateIt
$LN2@CGDonateIt:

; 6750 : 	{
; 6751 : 		PMSG_BUYREQUEST pMsg;
; 6752 : 		pMsg.Pos = lpUser->m_btCheckBuyDonatePos;

  00064	8a 8e f9 29 00
	00		 mov	 cl, BYTE PTR [esi+10745]

; 6753 : 		CGBuyRequestRecv(&pMsg, aIndex);

  0006a	8d 55 e8	 lea	 edx, DWORD PTR _pMsg$246649[ebp]
  0006d	57		 push	 edi
  0006e	52		 push	 edx
  0006f	88 4d eb	 mov	 BYTE PTR _pMsg$246649[ebp+3], cl
  00072	e8 00 00 00 00	 call	 ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ; CGBuyRequestRecv
  00077	83 c4 08	 add	 esp, 8
$LN1@CGDonateIt:

; 6754 : 	}
; 6755 : 
; 6756 : 	lpUser->m_bCheckBuyDonateItem = false;

  0007a	66 c7 86 f8 29
	00 00 00 00	 mov	 WORD PTR [esi+10744], 0
  00083	5e		 pop	 esi
$LN4@CGDonateIt:

; 6757 : 	lpUser->m_btCheckBuyDonatePos = 0;
; 6758 : }

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	5f		 pop	 edi
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?CGDonateItemBuy@@YAXPAUPMSG_DONATE_ITEMBUY@@H@Z ENDP	; CGDonateItemBuy
_TEXT	ENDS
PUBLIC	?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z:PROC	; CItem::Convert
EXTRN	?IsPet@CPetZt@@QAE_NH@Z:PROC			; CPetZt::IsPet
EXTRN	?g_PetZt@@3VCPetZt@@A:BYTE			; g_PetZt
; Function compile flags: /Ogtp
;	COMDAT ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z
_TEXT	SEGMENT
_pResult$ = -12						; size = 8
tv365 = -4						; size = 4
tv362 = -4						; size = 4
_lpObj$ = 8						; size = 4
tv384 = 12						; size = 4
_DurItem$ = 12						; size = 4
tv368 = 14						; size = 2
_pos$ = 16						; size = 4
_RequestPos$ = 20					; size = 4
?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z PROC ; ItemDurRepaire, COMDAT

; 7489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 7490 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 7491 : 	int result = TRUE;
; 7492 : 
; 7493 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof(pResult));

  00008	6a 08		 push	 8
  0000a	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	6a 34		 push	 52			; 00000034H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 7494 : 	int itemtype = DurItem->m_Type;

  00015	8b 75 0c	 mov	 esi, DWORD PTR _DurItem$[ebp]
  00018	0f bf 7e 06	 movsx	 edi, WORD PTR [esi+6]
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7495 : 
; 7496 : 	//season4 removed
; 7497 : 	/*if ( lpObj->m_IfState.type != 13 )
; 7498 : 	{
; 7499 : 		if ( itemtype ==ITEMGET(13,4)  || itemtype == ITEMGET(13,5))
; 7500 : 		{
; 7501 : 			pResult.Money = 0;
; 7502 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7503 : 			return;
; 7504 : 		}
; 7505 : 	}*/
; 7506 : 
; 7507 : 	//if( itemtype >= ITEMGET(14,0) 
; 7508 : 	//	|| (itemtype >= ITEMGET(13,0) && itemtype  < ITEMGET(13,4)) 
; 7509 : 	//	|| itemtype == ITEMGET(13,10) 
; 7510 : 	//	|| (itemtype >= ITEMGET(12, 7) && itemtype < ITEMGET(12,36)) 
; 7511 : 	//	|| ( itemtype > ITEMGET(12,43) && itemtype < ITEMGET(12, 49) )
; 7512 : 	//	|| ( itemtype > ITEMGET(12, 50) && itemtype < ITEMGET(13,0) )
; 7513 : 	//	|| itemtype == ITEMGET(4,7) || itemtype == ITEMGET(4,15) 
; 7514 : 	//	&& !IS_NEWWINGS(itemtype)
; 7515 : 	//	)
; 7516 : 	//{
; 7517 : 	//	pResult.Money = 0;
; 7518 : 	//	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7519 : 	//	return;
; 7520 : 	//}
; 7521 : 
; 7522 : 	if ( itemtype >= ITEMGET(14,0) || ( itemtype >= ITEMGET(13,0) && itemtype  < ITEMGET(13,4) ) || 
; 7523 : 		itemtype == ITEMGET(13,10) || (itemtype >= ITEMGET(12,7) && 
; 7524 : 		itemtype < ITEMGET(12,36)) || (itemtype > ITEMGET(12,43) &&		//43
; 7525 : 		itemtype < ITEMGET(12,49)) || (itemtype > ITEMGET(12,50) &&	
; 7526 : #ifdef NEWWINGS_6
; 7527 : 			itemtype < ITEMGET(12,180))|| (itemtype > ITEMGET(12,220) &&	//Custom Wings4	196
; 7528 : #else
; 7529 : 		itemtype < ITEMGET(12,180))|| (itemtype > ITEMGET(12,194) &&	//Custom Wings4
; 7530 : #endif
; 7531 : 		//itemtype != ITEMGET(12, 50) || itemtype != ITEMGET(12, 49) &&
; 7532 : 		itemtype < ITEMGET(13,0) ) ||
; 7533 : 		itemtype ==ITEMGET(4,7) || 
; 7534 : 		itemtype == ITEMGET(4,15) 
; 7535 : 		
; 7536 : 		)

  0001f	81 ff 00 1c 00
	00		 cmp	 edi, 7168		; 00001c00H
  00025	0f 8d 58 02 00
	00		 jge	 $LN24@ItemDurRep
  0002b	81 ff 00 1a 00
	00		 cmp	 edi, 6656		; 00001a00H
  00031	7c 0c		 jl	 SHORT $LN23@ItemDurRep
  00033	81 ff 04 1a 00
	00		 cmp	 edi, 6660		; 00001a04H
  00039	0f 8c 44 02 00
	00		 jl	 $LN24@ItemDurRep
$LN23@ItemDurRep:
  0003f	81 ff 0a 1a 00
	00		 cmp	 edi, 6666		; 00001a0aH
  00045	0f 84 38 02 00
	00		 je	 $LN24@ItemDurRep
  0004b	81 ff 07 18 00
	00		 cmp	 edi, 6151		; 00001807H
  00051	7c 0c		 jl	 SHORT $LN22@ItemDurRep
  00053	81 ff 24 18 00
	00		 cmp	 edi, 6180		; 00001824H
  00059	0f 8c 24 02 00
	00		 jl	 $LN24@ItemDurRep
$LN22@ItemDurRep:
  0005f	81 ff 2b 18 00
	00		 cmp	 edi, 6187		; 0000182bH
  00065	7e 0c		 jle	 SHORT $LN21@ItemDurRep
  00067	81 ff 31 18 00
	00		 cmp	 edi, 6193		; 00001831H
  0006d	0f 8c 10 02 00
	00		 jl	 $LN24@ItemDurRep
$LN21@ItemDurRep:
  00073	81 ff 32 18 00
	00		 cmp	 edi, 6194		; 00001832H
  00079	7e 0c		 jle	 SHORT $LN20@ItemDurRep
  0007b	81 ff b4 18 00
	00		 cmp	 edi, 6324		; 000018b4H
  00081	0f 8c fc 01 00
	00		 jl	 $LN24@ItemDurRep
$LN20@ItemDurRep:
  00087	81 ff dc 18 00
	00		 cmp	 edi, 6364		; 000018dcH
  0008d	7e 0c		 jle	 SHORT $LN19@ItemDurRep
  0008f	81 ff 00 1a 00
	00		 cmp	 edi, 6656		; 00001a00H
  00095	0f 8c e8 01 00
	00		 jl	 $LN24@ItemDurRep
$LN19@ItemDurRep:
  0009b	81 ff 07 08 00
	00		 cmp	 edi, 2055		; 00000807H
  000a1	0f 84 dc 01 00
	00		 je	 $LN24@ItemDurRep
  000a7	81 ff 0f 08 00
	00		 cmp	 edi, 2063		; 0000080fH
  000ad	0f 84 d0 01 00
	00		 je	 $LN24@ItemDurRep

; 7540 : 		return;
; 7541 : 	}
; 7542 : 
; 7543 : 	if ( itemtype == ITEMGET(13,64) ||
; 7544 : 		 itemtype == ITEMGET(13,65) ||
; 7545 : 		 itemtype == ITEMGET(13,67) ||
; 7546 : 		 itemtype == ITEMGET(13,76) ||
; 7547 : 		 itemtype == ITEMGET(13,80) ||
; 7548 : 		 itemtype == ITEMGET(13,106)||
; 7549 : 		 itemtype == ITEMGET(13,122)||
; 7550 : 		 itemtype == ITEMGET(13,123) )

  000b3	81 ff 40 1a 00
	00		 cmp	 edi, 6720		; 00001a40H
  000b9	74 6f		 je	 SHORT $LN31@ItemDurRep
  000bb	81 ff 41 1a 00
	00		 cmp	 edi, 6721		; 00001a41H
  000c1	74 67		 je	 SHORT $LN31@ItemDurRep
  000c3	81 ff 43 1a 00
	00		 cmp	 edi, 6723		; 00001a43H
  000c9	74 5f		 je	 SHORT $LN31@ItemDurRep
  000cb	81 ff 4c 1a 00
	00		 cmp	 edi, 6732		; 00001a4cH
  000d1	74 57		 je	 SHORT $LN31@ItemDurRep
  000d3	81 ff 50 1a 00
	00		 cmp	 edi, 6736		; 00001a50H
  000d9	74 4f		 je	 SHORT $LN31@ItemDurRep
  000db	81 ff 6a 1a 00
	00		 cmp	 edi, 6762		; 00001a6aH
  000e1	74 47		 je	 SHORT $LN31@ItemDurRep
  000e3	81 ff 7a 1a 00
	00		 cmp	 edi, 6778		; 00001a7aH
  000e9	74 3f		 je	 SHORT $LN31@ItemDurRep
  000eb	81 ff 7b 1a 00
	00		 cmp	 edi, 6779		; 00001a7bH
  000f1	74 37		 je	 SHORT $LN31@ItemDurRep

; 7551 : 	{
; 7552 : 		pResult.Money = 0;
; 7553 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7554 : 		return;
; 7555 : 	}
; 7556 : 
; 7557 : 	#if(ENABLE_PETZT)
; 7558 : 	if(g_PetZt.IsPet(itemtype))

  000f3	57		 push	 edi
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PetZt@@3VCPetZt@@A ; g_PetZt
  000f9	e8 00 00 00 00	 call	 ?IsPet@CPetZt@@QAE_NH@Z	; CPetZt::IsPet
  000fe	84 c0		 test	 al, al

; 7559 : 	{
; 7560 : 		pResult.Money = 0;
; 7561 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7562 : 		return;

  00100	0f 85 7d 01 00
	00		 jne	 $LN24@ItemDurRep

; 7563 : 	}
; 7564 : 	#endif
; 7565 : 
; 7566 : 	//No Repain Panda
; 7567 : 	if ( itemtype == ITEMGET(13,80) )
; 7568 : 	{
; 7569 : 		pResult.Money = 0;
; 7570 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7571 : 		return;
; 7572 : 	}
; 7573 : 	//No Repain Panda Ring
; 7574 : 	if ( itemtype == ITEMGET(13,76) )
; 7575 : 	{
; 7576 : 		pResult.Money = 0;
; 7577 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7578 : 		return;
; 7579 : 	}
; 7580 : 	//No Repain Skeleton Pet
; 7581 : 	if ( itemtype == ITEMGET(13,123) )
; 7582 : 	{
; 7583 : 		pResult.Money = 0;
; 7584 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7585 : 		return;
; 7586 : 	}
; 7587 : 	//No Repain Skeleton Ring
; 7588 : 	if ( itemtype == ITEMGET(13,122) )
; 7589 : 	{
; 7590 : 		pResult.Money = 0;
; 7591 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7592 : 		return;
; 7593 : 	}
; 7594 : 
; 7595 : 	if ( itemtype == ITEMGET(13,38) )

  00106	81 ff 26 1a 00
	00		 cmp	 edi, 6694		; 00001a26H
  0010c	75 14		 jne	 SHORT $LN11@ItemDurRep
$LN30@ItemDurRep:

; 7596 : 	{
; 7597 : 		pResult.Money = 0;
; 7598 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0010e	0f b6 55 f5	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00115	52		 push	 edx
  00116	8b 11		 mov	 edx, DWORD PTR [ecx]
  00118	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  0011b	50		 push	 eax
  0011c	52		 push	 edx

; 7599 : 		return;

  0011d	e9 70 01 00 00	 jmp	 $LN28@ItemDurRep
$LN11@ItemDurRep:

; 7600 : 	}
; 7601 : 
; 7602 : 	if ( itemtype == ITEMGET(13,39) )

  00122	81 ff 27 1a 00
	00		 cmp	 edi, 6695		; 00001a27H
  00128	75 14		 jne	 SHORT $LN10@ItemDurRep
$LN31@ItemDurRep:

; 7603 : 	{
; 7604 : 		pResult.Money = 0;
; 7605 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0012a	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0012e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00131	50		 push	 eax
  00132	8b 02		 mov	 eax, DWORD PTR [edx]
  00134	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00137	51		 push	 ecx
  00138	50		 push	 eax

; 7606 : 		return;

  00139	e9 54 01 00 00	 jmp	 $LN28@ItemDurRep
$LN10@ItemDurRep:

; 7607 : 	}
; 7608 : 
; 7609 : 	if ( itemtype == ITEMGET(13,40) ) //Second Edition

  0013e	81 ff 28 1a 00
	00		 cmp	 edi, 6696		; 00001a28H

; 7610 : 	{
; 7611 : 		pResult.Money = 0;
; 7612 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7613 : 		return;

  00144	0f 84 39 01 00
	00		 je	 $LN24@ItemDurRep

; 7614 : 	}
; 7615 : 
; 7616 : 	if ( itemtype == ITEMGET(13,41) ) //season 2.5 add-on

  0014a	81 ff 29 1a 00
	00		 cmp	 edi, 6697		; 00001a29H

; 7617 : 	{
; 7618 : 		pResult.Money = 0;
; 7619 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7620 : 		return;

  00150	74 bc		 je	 SHORT $LN30@ItemDurRep

; 7621 : 	}
; 7622 : 
; 7623 : 	if ( itemtype == ITEMGET(13,42) ) //season 2.5 add-on

  00152	81 ff 2a 1a 00
	00		 cmp	 edi, 6698		; 00001a2aH

; 7624 : 	{
; 7625 : 		pResult.Money = 0;
; 7626 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7627 : 		return;

  00158	74 d0		 je	 SHORT $LN31@ItemDurRep

; 7628 : 	}
; 7629 : #ifdef PERIOD
; 7630 : 	if( DurItem->IsPeriodItem() )

  0015a	8b ce		 mov	 ecx, esi
  0015c	e8 00 00 00 00	 call	 ?IsPeriodItem@CItem@@QAE_NXZ ; CItem::IsPeriodItem
  00161	84 c0		 test	 al, al

; 7631 : 	{
; 7632 : 		pResult.Money = 0;
; 7633 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 7634 : 		return;

  00163	0f 85 1a 01 00
	00		 jne	 $LN24@ItemDurRep

; 7635 : 	}
; 7636 : #endif
; 7637 : 	pResult.Money = GetNeedMoneyItemDurRepaire(DurItem, RequestPos);

  00169	8b 55 14	 mov	 edx, DWORD PTR _RequestPos$[ebp]
  0016c	52		 push	 edx
  0016d	56		 push	 esi
  0016e	e8 00 00 00 00	 call	 ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ; GetNeedMoneyItemDurRepaire

; 7638 : 
; 7639 : 	if ( pResult.Money <= 0 )

  00173	33 d2		 xor	 edx, edx
  00175	83 c4 08	 add	 esp, 8
  00178	3b c2		 cmp	 eax, edx
  0017a	7f 20		 jg	 SHORT $LN5@ItemDurRep

; 7640 : 	{
; 7641 : 		pResult.Money = 0;
; 7642 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0017c	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00180	50		 push	 eax
  00181	89 55 f8	 mov	 DWORD PTR _pResult$[ebp+4], edx
  00184	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00187	8b 02		 mov	 eax, DWORD PTR [edx]
  00189	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0018c	51		 push	 ecx
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
  00196	5f		 pop	 edi
  00197	5e		 pop	 esi

; 7666 : }

  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
$LN5@ItemDurRep:
  0019c	53		 push	 ebx

; 7643 : 		return;
; 7644 : 	}
; 7645 : 
; 7646 : 	if ( (lpObj->Money - pResult.Money) < 1 )

  0019d	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  001a0	8b 8b f0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+240]
  001a6	2b c8		 sub	 ecx, eax
  001a8	83 f9 01	 cmp	 ecx, 1
  001ab	7d 08		 jge	 SHORT $LN4@ItemDurRep

; 7647 : 	{
; 7648 : 		pResult.Money = 0;

  001ad	89 55 f8	 mov	 DWORD PTR _pResult$[ebp+4], edx

; 7649 : 	}
; 7650 : 	else

  001b0	e9 b3 00 00 00	 jmp	 $LN3@ItemDurRep
$LN4@ItemDurRep:

; 7651 : 	{
; 7652 : 		lpObj->Money -= pResult.Money;

  001b5	89 8b f0 00 00
	00		 mov	 DWORD PTR [ebx+240], ecx

; 7653 : 		pResult.Money = lpObj->Money;
; 7654 : 		DurItem->m_Durability = (float)((int)DurItem->m_BaseDurability);

  001bb	d9 46 2c	 fld	 DWORD PTR [esi+44]
  001be	89 4d f8	 mov	 DWORD PTR _pResult$[ebp+4], ecx
  001c1	e8 00 00 00 00	 call	 __ftol2_sse

; 7655 : 		DurItem->Convert(DurItem->m_Type, DurItem->m_Option1, DurItem->m_Option2, DurItem->m_Option3, DurItem->m_NewOption, DurItem->m_SetOption,DurItem->m_ItemOptionEx, NULL, 0xFF, 0, CURRENT_DB_VERSION);

  001c6	0f b6 8e ca 00
	00 00		 movzx	 ecx, BYTE PTR [esi+202]
  001cd	0f b6 96 ae 00
	00 00		 movzx	 edx, BYTE PTR [esi+174]
  001d4	6a 03		 push	 3
  001d6	6a 00		 push	 0
  001d8	68 ff 00 00 00	 push	 255			; 000000ffH
  001dd	6a 00		 push	 0
  001df	51		 push	 ecx
  001e0	0f b6 8e 96 00
	00 00		 movzx	 ecx, BYTE PTR [esi+150]
  001e7	89 45 0c	 mov	 DWORD PTR tv384[ebp], eax
  001ea	0f b6 86 97 00
	00 00		 movzx	 eax, BYTE PTR [esi+151]
  001f1	db 45 0c	 fild	 DWORD PTR tv384[ebp]
  001f4	52		 push	 edx
  001f5	0f b6 96 95 00
	00 00		 movzx	 edx, BYTE PTR [esi+149]
  001fc	d9 5e 24	 fstp	 DWORD PTR [esi+36]
  001ff	50		 push	 eax
  00200	0f b6 86 94 00
	00 00		 movzx	 eax, BYTE PTR [esi+148]
  00207	51		 push	 ecx
  00208	0f bf 4e 06	 movsx	 ecx, WORD PTR [esi+6]
  0020c	52		 push	 edx
  0020d	50		 push	 eax
  0020e	51		 push	 ecx
  0020f	8b ce		 mov	 ecx, esi
  00211	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEEE@Z ; CItem::Convert

; 7656 : 		
; 7657 : 		if ( DurItem->m_Type == ITEMGET(13,4)  || DurItem->m_Type == ITEMGET(13,5)) //season4.5 add-on

  00216	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  0021a	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  0021f	66 3b c2	 cmp	 ax, dx
  00222	74 0a		 je	 SHORT $LN1@ItemDurRep
  00224	b9 05 1a 00 00	 mov	 ecx, 6661		; 00001a05H
  00229	66 3b c1	 cmp	 ax, cx
  0022c	75 07		 jne	 SHORT $LN2@ItemDurRep
$LN1@ItemDurRep:

; 7658 : 		{
; 7659 : 			DurItem->PetValue();

  0022e	8b ce		 mov	 ecx, esi
  00230	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue
$LN2@ItemDurRep:

; 7660 : 		}
; 7661 : 
; 7662 : 		GCItemDurSend(lpObj->m_Index, (BYTE)pos, (BYTE)DurItem->m_Durability, FALSE);

  00235	d9 46 24	 fld	 DWORD PTR [esi+36]
  00238	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  0023b	d9 7d 0e	 fnstcw	 WORD PTR tv368[ebp]
  0023e	6a 00		 push	 0
  00240	0f b7 45 0e	 movzx	 eax, WORD PTR tv368[ebp]
  00244	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00249	89 45 fc	 mov	 DWORD PTR tv365[ebp], eax
  0024c	d9 6d fc	 fldcw	 WORD PTR tv365[ebp]
  0024f	db 5d fc	 fistp	 DWORD PTR tv362[ebp]
  00252	8a 55 fc	 mov	 dl, BYTE PTR tv362[ebp]
  00255	0f b6 c2	 movzx	 eax, dl
  00258	8b 13		 mov	 edx, DWORD PTR [ebx]
  0025a	d9 6d 0e	 fldcw	 WORD PTR tv368[ebp]
  0025d	50		 push	 eax
  0025e	51		 push	 ecx
  0025f	52		 push	 edx
  00260	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00265	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@ItemDurRep:

; 7663 : 	}
; 7664 : 
; 7665 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00268	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0026c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0026e	50		 push	 eax
  0026f	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00272	51		 push	 ecx
  00273	52		 push	 edx
  00274	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00279	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027c	5b		 pop	 ebx
  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi

; 7666 : }

  0027f	8b e5		 mov	 esp, ebp
  00281	5d		 pop	 ebp
  00282	c3		 ret	 0
$LN24@ItemDurRep:

; 7537 : 	{
; 7538 : 		pResult.Money = 0;
; 7539 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00283	0f b6 4d f5	 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00287	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028a	51		 push	 ecx
  0028b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028d	8d 55 f4	 lea	 edx, DWORD PTR _pResult$[ebp]
  00290	52		 push	 edx
  00291	51		 push	 ecx
$LN28@ItemDurRep:
  00292	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  00299	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0029e	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi

; 7666 : }

  002a3	8b e5		 mov	 esp, ebp
  002a5	5d		 pop	 ebp
  002a6	c3		 ret	 0
?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ENDP ; ItemDurRepaire
_TEXT	ENDS
PUBLIC	?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
EXTRN	?CanItemTouchCash@@YAHH@Z:PROC			; CanItemTouchCash
EXTRN	?IsCashItem@@YAHH@Z:PROC			; IsCashItem
; Function compile flags: /Ogtp
;	COMDAT ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z PROC ; CGModifyRequestItem, COMDAT

; 7669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7670 : 	LPOBJ lpObj = &gObj[aIndex];

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00011	8b f7		 mov	 esi, edi
  00013	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H

; 7671 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 7672 : 
; 7673 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof(pResult));

  00019	6a 08		 push	 8
  0001b	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0001e	6a 34		 push	 52			; 00000034H
  00020	51		 push	 ecx
  00021	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00024	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 7674 : 	pResult.Money = 0;
; 7675 : 
; 7676 : 	if ( gObj[aIndex].CloseType != -1 )

  00029	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  00039	80 7c 16 0b ff	 cmp	 BYTE PTR [esi+edx+11], -1
  0003e	74 19		 je	 SHORT $LN55@CGModifyRe

; 7677 : 	{
; 7678 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00040	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00044	50		 push	 eax
  00045	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00048	51		 push	 ecx
  00049	57		 push	 edi
  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 7888 : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN55@CGModifyRe:

; 7679 : 		return;
; 7680 : 	}
; 7681 : 
; 7682 : 	if ( !PacketCheckTime(lpObj))

  00059	53		 push	 ebx
  0005a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0005f	83 c4 04	 add	 esp, 4
  00062	85 c0		 test	 eax, eax

; 7683 : 	{
; 7684 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7685 : 		return;

  00064	74 21		 je	 SHORT $LN62@CGModifyRe

; 7686 : 	}
; 7687 : 
; 7688 : 	if (lpMsg->Requestpos == 1 && gObj[aIndex].Level < 50 )

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00069	80 78 04 01	 cmp	 BYTE PTR [eax+4], 1
  0006d	75 31		 jne	 SHORT $LN53@CGModifyRe
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	66 83 bc 0e be
	00 00 00 32	 cmp	 WORD PTR [esi+ecx+190], 50 ; 00000032H
  0007e	7d 20		 jge	 SHORT $LN53@CGModifyRe

; 7689 : 	{
; 7690 : 		pResult.Money = 0;

  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
$LN62@CGModifyRe:

; 7691 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00087	0f b6 55 f9	 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0008b	52		 push	 edx
  0008c	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0008f	50		 push	 eax
  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 7888 : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN53@CGModifyRe:

; 7692 : 		return;
; 7693 : 	}
; 7694 : 
; 7695 : 	if ( lpMsg->Position == 0xFF )

  000a0	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  000a3	3c ff		 cmp	 al, 255			; 000000ffH
  000a5	0f 85 14 03 00
	00		 jne	 $LN52@CGModifyRe

; 7696 : 	{
; 7697 : 		for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  000ab	33 ff		 xor	 edi, edi
  000ad	33 f6		 xor	 esi, esi
  000af	90		 npad	 1
$LL51@CGModifyRe:

; 7698 : 		{
; 7699 : 			if ( lpObj->pInventory[n].IsItem())

  000b0	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  000b6	03 ce		 add	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000bd	85 c0		 test	 eax, eax
  000bf	0f 84 d5 02 00
	00		 je	 $LN50@CGModifyRe

; 7700 : 			{
; 7701 : //#ifdef OLDCASHSHOP
; 7702 : 				if ( IsCashItem(lpObj->pInventory[n].m_Type ) == TRUE )

  000c5	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  000cb	0f bf 54 31 06	 movsx	 edx, WORD PTR [ecx+esi+6]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  000d6	83 c4 04	 add	 esp, 4
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	0f 84 b8 02 00
	00		 je	 $LN50@CGModifyRe

; 7703 : 					continue;
; 7704 : 
; 7705 : 				if ( CanItemTouchCash(lpObj->pInventory[n].m_Type ) == TRUE ) //season4 add-on

  000e2	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  000e8	0f bf 4c 30 06	 movsx	 ecx, WORD PTR [eax+esi+6]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 ?CanItemTouchCash@@YAHH@Z ; CanItemTouchCash
  000f3	83 c4 04	 add	 esp, 4
  000f6	83 f8 01	 cmp	 eax, 1
  000f9	0f 84 9b 02 00
	00		 je	 $LN50@CGModifyRe

; 7706 : 					continue;
; 7707 : //#endif
; 7708 : 
; 7709 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,20) && (lpObj->pInventory[n].m_Level == 0 ||lpObj->pInventory[n].m_Level == 1 ))

  000ff	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00105	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  0010a	03 ce		 add	 ecx, esi
  0010c	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00111	66 3b c2	 cmp	 ax, dx
  00114	75 17		 jne	 SHORT $LN45@CGModifyRe
  00116	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  0011a	66 85 d2	 test	 dx, dx
  0011d	0f 84 77 02 00
	00		 je	 $LN50@CGModifyRe
  00123	66 83 fa 01	 cmp	 dx, 1

; 7710 : 					continue;

  00127	0f 84 6d 02 00
	00		 je	 $LN50@CGModifyRe
$LN45@CGModifyRe:

; 7711 : 
; 7712 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,20) && lpObj->pInventory[n].m_Level == 2 )

  0012d	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00132	66 3b c2	 cmp	 ax, dx
  00135	75 0b		 jne	 SHORT $LN43@CGModifyRe
  00137	66 83 79 08 02	 cmp	 WORD PTR [ecx+8], 2
  0013c	0f 84 58 02 00
	00		 je	 $LN50@CGModifyRe
$LN43@CGModifyRe:

; 7713 : 					continue;
; 7714 : 
; 7715 : 				//season4 removed
; 7716 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  00142	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  00147	66 3b c2	 cmp	 ax, dx
  0014a	0f 84 4a 02 00
	00		 je	 $LN50@CGModifyRe
  00150	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  00155	66 3b c2	 cmp	 ax, dx
  00158	0f 84 3c 02 00
	00		 je	 $LN50@CGModifyRe

; 7717 : 					continue;
; 7718 : 				
; 7719 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,37) )

  0015e	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  00163	66 3b c2	 cmp	 ax, dx
  00166	0f 84 2e 02 00
	00		 je	 $LN50@CGModifyRe

; 7720 : 					continue;
; 7721 : 
; 7722 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,38) )

  0016c	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  00171	66 3b c2	 cmp	 ax, dx
  00174	0f 84 20 02 00
	00		 je	 $LN50@CGModifyRe

; 7723 : 					continue;
; 7724 : 
; 7725 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,39) )

  0017a	ba 27 1a 00 00	 mov	 edx, 6695		; 00001a27H
  0017f	66 3b c2	 cmp	 ax, dx
  00182	0f 84 12 02 00
	00		 je	 $LN50@CGModifyRe

; 7726 : 					continue;
; 7727 : 
; 7728 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(12,26) &&
; 7729 : 					(lpObj->pInventory[n].m_Level == 1 ||
; 7730 : 					 lpObj->pInventory[n].m_Level == 2 || 
; 7731 : 					 lpObj->pInventory[n].m_Level == 3 || 
; 7732 : 					 lpObj->pInventory[n].m_Level == 4 || 
; 7733 : 					 lpObj->pInventory[n].m_Level == 5 ))

  00188	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  0018d	66 3b c2	 cmp	 ax, dx
  00190	75 36		 jne	 SHORT $LN37@CGModifyRe
  00192	0f b7 49 08	 movzx	 ecx, WORD PTR [ecx+8]
  00196	66 83 f9 01	 cmp	 cx, 1
  0019a	0f 84 fa 01 00
	00		 je	 $LN50@CGModifyRe
  001a0	66 83 f9 02	 cmp	 cx, 2
  001a4	0f 84 f0 01 00
	00		 je	 $LN50@CGModifyRe
  001aa	66 83 f9 03	 cmp	 cx, 3
  001ae	0f 84 e6 01 00
	00		 je	 $LN50@CGModifyRe
  001b4	66 83 f9 04	 cmp	 cx, 4
  001b8	0f 84 dc 01 00
	00		 je	 $LN50@CGModifyRe
  001be	66 83 f9 05	 cmp	 cx, 5

; 7734 : 					 continue;

  001c2	0f 84 d2 01 00
	00		 je	 $LN50@CGModifyRe
$LN37@CGModifyRe:

; 7735 : 
; 7736 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,40) ) //Second Edition

  001c8	b9 28 1a 00 00	 mov	 ecx, 6696		; 00001a28H
  001cd	66 3b c1	 cmp	 ax, cx
  001d0	0f 84 c4 01 00
	00		 je	 $LN50@CGModifyRe

; 7737 : 					continue;
; 7738 : 
; 7739 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,41) ) //season 2.5 add-on

  001d6	ba 29 1a 00 00	 mov	 edx, 6697		; 00001a29H
  001db	66 3b c2	 cmp	 ax, dx
  001de	0f 84 b6 01 00
	00		 je	 $LN50@CGModifyRe

; 7740 : 					continue;
; 7741 : 
; 7742 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,42) ) //season 2.5 add-on

  001e4	b9 2a 1a 00 00	 mov	 ecx, 6698		; 00001a2aH
  001e9	66 3b c1	 cmp	 ax, cx
  001ec	0f 84 a8 01 00
	00		 je	 $LN50@CGModifyRe

; 7743 : 					continue;
; 7744 : 
; 7745 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,51) ) //season 2.5 add-on

  001f2	ba 33 1a 00 00	 mov	 edx, 6707		; 00001a33H
  001f7	66 3b c2	 cmp	 ax, dx
  001fa	0f 84 9a 01 00
	00		 je	 $LN50@CGModifyRe

; 7746 : 					continue;
; 7747 : #if(FIX_CRASH==TRUE)
; 7748 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,70) ) //season 4.0 add-on

  00200	b9 46 1a 00 00	 mov	 ecx, 6726		; 00001a46H
  00205	66 3b c1	 cmp	 ax, cx
  00208	0f 84 8c 01 00
	00		 je	 $LN50@CGModifyRe

; 7749 : 					continue;
; 7750 : #else
; 7751 : 				if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,70) ) //season 4.0 add-on
; 7752 : 					continue;
; 7753 : #endif
; 7754 : 
; 7755 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,66) ) //season 4.0 add-on

  0020e	ba 42 1a 00 00	 mov	 edx, 6722		; 00001a42H
  00213	66 3b c2	 cmp	 ax, dx
  00216	0f 84 7e 01 00
	00		 je	 $LN50@CGModifyRe

; 7756 : 					continue;
; 7757 : 
; 7758 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,67) || 
; 7759 : 					lpObj->pInventory[n].m_Type == ITEMGET(13,68)) //season 4.0 add-on

  0021c	b9 43 1a 00 00	 mov	 ecx, 6723		; 00001a43H
  00221	66 3b c1	 cmp	 ax, cx
  00224	0f 84 70 01 00
	00		 je	 $LN50@CGModifyRe
  0022a	ba 44 1a 00 00	 mov	 edx, 6724		; 00001a44H
  0022f	66 3b c2	 cmp	 ax, dx
  00232	0f 84 62 01 00
	00		 je	 $LN50@CGModifyRe

; 7760 : 					continue;
; 7761 : #ifdef ZTCLUSIVE_AMYLET
; 7762 : 				if(g_ZtLicense.CheckUser(eZtUB::ulasevich) || g_ZtLicense.CheckUser(eZtUB::Local3) || g_ZtLicense.CheckUser(eZtUB::Local) || g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  00238	6a 17		 push	 23			; 00000017H
  0023a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0023f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00244	84 c0		 test	 al, al
  00246	75 34		 jne	 SHORT $LN26@CGModifyRe
  00248	6a 1c		 push	 28			; 0000001cH
  0024a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0024f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00254	84 c0		 test	 al, al
  00256	75 24		 jne	 SHORT $LN26@CGModifyRe
  00258	6a 00		 push	 0
  0025a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0025f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00264	84 c0		 test	 al, al
  00266	75 14		 jne	 SHORT $LN26@CGModifyRe
  00268	6a 24		 push	 36			; 00000024H
  0026a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0026f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00274	84 c0		 test	 al, al
  00276	0f 84 97 00 00
	00		 je	 $LN25@CGModifyRe
$LN26@CGModifyRe:

; 7763 : 				{
; 7764 : 					if ( lpObj->pInventory[n].m_Type == ITEMGET(13,147) ||
; 7765 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,148) ||
; 7766 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,149) ||
; 7767 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,150) ||
; 7768 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,151) ||
; 7769 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,152) ||
; 7770 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,153) ||
; 7771 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,154) ||
; 7772 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,155) ||
; 7773 : 						lpObj->pInventory[n].m_Type == ITEMGET(13,156)
; 7774 : 						)

  0027c	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  00282	0f b7 44 30 06	 movzx	 eax, WORD PTR [eax+esi+6]
  00287	b9 93 1a 00 00	 mov	 ecx, 6803		; 00001a93H
  0028c	66 3b c1	 cmp	 ax, cx
  0028f	0f 84 05 01 00
	00		 je	 $LN50@CGModifyRe
  00295	ba 94 1a 00 00	 mov	 edx, 6804		; 00001a94H
  0029a	66 3b c2	 cmp	 ax, dx
  0029d	0f 84 f7 00 00
	00		 je	 $LN50@CGModifyRe
  002a3	b9 95 1a 00 00	 mov	 ecx, 6805		; 00001a95H
  002a8	66 3b c1	 cmp	 ax, cx
  002ab	0f 84 e9 00 00
	00		 je	 $LN50@CGModifyRe
  002b1	ba 96 1a 00 00	 mov	 edx, 6806		; 00001a96H
  002b6	66 3b c2	 cmp	 ax, dx
  002b9	0f 84 db 00 00
	00		 je	 $LN50@CGModifyRe
  002bf	b9 97 1a 00 00	 mov	 ecx, 6807		; 00001a97H
  002c4	66 3b c1	 cmp	 ax, cx
  002c7	0f 84 cd 00 00
	00		 je	 $LN50@CGModifyRe
  002cd	ba 98 1a 00 00	 mov	 edx, 6808		; 00001a98H
  002d2	66 3b c2	 cmp	 ax, dx
  002d5	0f 84 bf 00 00
	00		 je	 $LN50@CGModifyRe
  002db	b9 99 1a 00 00	 mov	 ecx, 6809		; 00001a99H
  002e0	66 3b c1	 cmp	 ax, cx
  002e3	0f 84 b1 00 00
	00		 je	 $LN50@CGModifyRe
  002e9	ba 9a 1a 00 00	 mov	 edx, 6810		; 00001a9aH
  002ee	66 3b c2	 cmp	 ax, dx
  002f1	0f 84 a3 00 00
	00		 je	 $LN50@CGModifyRe
  002f7	b9 9b 1a 00 00	 mov	 ecx, 6811		; 00001a9bH
  002fc	66 3b c1	 cmp	 ax, cx
  002ff	0f 84 95 00 00
	00		 je	 $LN50@CGModifyRe
  00305	ba 9c 1a 00 00	 mov	 edx, 6812		; 00001a9cH
  0030a	66 3b c2	 cmp	 ax, dx
  0030d	0f 84 87 00 00
	00		 je	 $LN50@CGModifyRe
$LN25@CGModifyRe:

; 7775 : 					{
; 7776 : 						continue;
; 7777 : 					}
; 7778 : 				}
; 7779 : #endif // ZTCLUSIVE_AMYLET
; 7780 : 
; 7781 : 				
; 7782 : 
; 7783 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13, 67) || 
; 7784 : 					lpObj->pInventory[n].m_Type == ITEMGET(13, 68) || //season 4.0 add-on
; 7785 : 					lpObj->pInventory[n].m_Type == ITEMGET(13, 76) || //season 4.6 add-on
; 7786 : 					lpObj->pInventory[n].m_Type == ITEMGET(13, 106) 
; 7787 : 					|| lpObj->pInventory[n].m_Type == ITEMGET(13, 122) // Season 5 Episode 2 JPN
; 7788 : 					|| lpObj->pInventory[n].m_Type == ITEMGET(13, 123) ) 

  00313	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00319	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  0031e	03 ce		 add	 ecx, esi
  00320	ba 43 1a 00 00	 mov	 edx, 6723		; 00001a43H
  00325	66 3b c2	 cmp	 ax, dx
  00328	74 70		 je	 SHORT $LN50@CGModifyRe
  0032a	ba 44 1a 00 00	 mov	 edx, 6724		; 00001a44H
  0032f	66 3b c2	 cmp	 ax, dx
  00332	74 66		 je	 SHORT $LN50@CGModifyRe
  00334	ba 4c 1a 00 00	 mov	 edx, 6732		; 00001a4cH
  00339	66 3b c2	 cmp	 ax, dx
  0033c	74 5c		 je	 SHORT $LN50@CGModifyRe
  0033e	ba 6a 1a 00 00	 mov	 edx, 6762		; 00001a6aH
  00343	66 3b c2	 cmp	 ax, dx
  00346	74 52		 je	 SHORT $LN50@CGModifyRe
  00348	ba 7a 1a 00 00	 mov	 edx, 6778		; 00001a7aH
  0034d	66 3b c2	 cmp	 ax, dx
  00350	74 48		 je	 SHORT $LN50@CGModifyRe
  00352	ba 7b 1a 00 00	 mov	 edx, 6779		; 00001a7bH
  00357	66 3b c2	 cmp	 ax, dx
  0035a	74 3e		 je	 SHORT $LN50@CGModifyRe

; 7789 : 				{
; 7790 : 					continue;
; 7791 : 				}
; 7792 : #ifdef PERIOD
; 7793 : 				if( lpObj->pInventory[n].IsPeriodItem() )	//season 5.4 add-on

  0035c	e8 00 00 00 00	 call	 ?IsPeriodItem@CItem@@QAE_NXZ ; CItem::IsPeriodItem
  00361	84 c0		 test	 al, al
  00363	75 35		 jne	 SHORT $LN50@CGModifyRe

; 7794 : 				{
; 7795 : 					continue;
; 7796 : 				}
; 7797 : #endif
; 7798 : 
; 7799 : #ifdef LUCKYITEM
; 7800 : 				if( g_LuckyItemManager.IsLuckyItemEquipment(lpObj->pInventory[n].m_Type) )	//season 6.1 add-on

  00365	8b 83 24 0e 00
	00		 mov	 eax, DWORD PTR [ebx+3620]
  0036b	0f bf 4c 30 06	 movsx	 ecx, WORD PTR [eax+esi+6]
  00370	51		 push	 ecx
  00371	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  00376	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  0037b	85 c0		 test	 eax, eax
  0037d	75 1b		 jne	 SHORT $LN50@CGModifyRe

; 7801 : 				{
; 7802 : 					continue;
; 7803 : 				}
; 7804 : #endif
; 7805 : 				ItemDurRepaire(lpObj,&lpObj->pInventory[n] , n, lpMsg->Requestpos);

  0037f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00382	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00386	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  0038c	50		 push	 eax
  0038d	57		 push	 edi
  0038e	03 ce		 add	 ecx, esi
  00390	51		 push	 ecx
  00391	53		 push	 ebx
  00392	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
  00397	83 c4 10	 add	 esp, 16			; 00000010H
$LN50@CGModifyRe:

; 7696 : 	{
; 7697 : 		for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  0039a	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  003a0	47		 inc	 edi
  003a1	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  003a7	0f 8c 03 fd ff
	ff		 jl	 $LL51@CGModifyRe

; 7806 : 			}
; 7807 : 		}
; 7808 : 
; 7809 : 		gObjCalCharacter(lpObj->m_Index);

  003ad	8b 13		 mov	 edx, DWORD PTR [ebx]
  003af	52		 push	 edx
  003b0	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  003b5	83 c4 04	 add	 esp, 4
  003b8	5f		 pop	 edi
  003b9	5e		 pop	 esi
  003ba	5b		 pop	 ebx

; 7888 : }

  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c3		 ret	 0
$LN52@CGModifyRe:

; 7810 : 		return;
; 7811 : 	}
; 7812 : 
; 7813 : 	if ( lpMsg->Position > MAIN_INVENTORY_SIZE-1)

  003bf	3c cb		 cmp	 al, 203			; 000000cbH
  003c1	0f 87 dd 01 00
	00		 ja	 $LN3@CGModifyRe

; 7814 : 	{
; 7815 : 		pResult.Money = 0;
; 7816 : 		return;
; 7817 : 	}
; 7818 : //#ifdef OLDCASHSHOP
; 7819 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Position].m_Type ) == TRUE )

  003c7	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  003cd	0f b6 c0	 movzx	 eax, al
  003d0	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  003d6	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  003db	52		 push	 edx
  003dc	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  003e1	83 c4 04	 add	 esp, 4
  003e4	83 f8 01	 cmp	 eax, 1
  003e7	0f 84 b7 01 00
	00		 je	 $LN3@CGModifyRe

; 7820 : 		return;
; 7821 : 
; 7822 : 	if ( CanItemTouchCash(lpObj->pInventory[lpMsg->Position].m_Type ) == TRUE ) //season4 add-on

  003ed	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  003f0	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  003f4	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  003fa	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00400	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  00405	52		 push	 edx
  00406	e8 00 00 00 00	 call	 ?CanItemTouchCash@@YAHH@Z ; CanItemTouchCash
  0040b	83 c4 04	 add	 esp, 4
  0040e	83 f8 01	 cmp	 eax, 1
  00411	0f 84 8d 01 00
	00		 je	 $LN3@CGModifyRe

; 7823 : 		return;
; 7824 : //#endif
; 7825 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,20) && (lpObj->pInventory[lpMsg->Position].m_Level == 0 ||lpObj->pInventory[lpMsg->Position].m_Level == 1 ))

  00417	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0041b	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00421	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00427	03 c8		 add	 ecx, eax
  00429	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0042d	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00432	66 3b c2	 cmp	 ax, dx
  00435	75 17		 jne	 SHORT $LN16@CGModifyRe
  00437	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  0043b	66 85 d2	 test	 dx, dx
  0043e	0f 84 60 01 00
	00		 je	 $LN3@CGModifyRe
  00444	66 83 fa 01	 cmp	 dx, 1

; 7826 : 		return;

  00448	0f 84 56 01 00
	00		 je	 $LN3@CGModifyRe
$LN16@CGModifyRe:

; 7827 : 
; 7828 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Position].m_Level == 2 )

  0044e	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00453	66 3b c2	 cmp	 ax, dx
  00456	75 0b		 jne	 SHORT $LN14@CGModifyRe
  00458	66 83 79 08 02	 cmp	 WORD PTR [ecx+8], 2
  0045d	0f 84 41 01 00
	00		 je	 $LN3@CGModifyRe
$LN14@CGModifyRe:

; 7829 : 		return;
; 7830 : 
; 7831 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,37) )

  00463	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  00468	66 3b c2	 cmp	 ax, dx
  0046b	0f 84 33 01 00
	00		 je	 $LN3@CGModifyRe

; 7832 : 		return;
; 7833 : 
; 7834 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,38) )

  00471	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  00476	66 3b c2	 cmp	 ax, dx
  00479	0f 84 25 01 00
	00		 je	 $LN3@CGModifyRe

; 7835 : 		return;
; 7836 : 
; 7837 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,40) ) //Second Edition

  0047f	ba 28 1a 00 00	 mov	 edx, 6696		; 00001a28H
  00484	66 3b c2	 cmp	 ax, dx
  00487	0f 84 17 01 00
	00		 je	 $LN3@CGModifyRe

; 7838 : 		return;
; 7839 : 
; 7840 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,41) ) //season 2.5 add-on

  0048d	ba 29 1a 00 00	 mov	 edx, 6697		; 00001a29H
  00492	66 3b c2	 cmp	 ax, dx
  00495	0f 84 09 01 00
	00		 je	 $LN3@CGModifyRe

; 7841 : 		return;
; 7842 : 
; 7843 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,42) ) //season 2.5 add-on

  0049b	ba 2a 1a 00 00	 mov	 edx, 6698		; 00001a2aH
  004a0	66 3b c2	 cmp	 ax, dx
  004a3	0f 84 fb 00 00
	00		 je	 $LN3@CGModifyRe

; 7844 : 		return;
; 7845 : 
; 7846 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,51) ) //season 2.5 add-on

  004a9	ba 33 1a 00 00	 mov	 edx, 6707		; 00001a33H
  004ae	66 3b c2	 cmp	 ax, dx
  004b1	0f 84 ed 00 00
	00		 je	 $LN3@CGModifyRe

; 7847 : 		return;
; 7848 : 
; 7849 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,70) ) //season 4.0 add-on

  004b7	ba 46 1a 00 00	 mov	 edx, 6726		; 00001a46H
  004bc	66 3b c2	 cmp	 ax, dx
  004bf	0f 84 df 00 00
	00		 je	 $LN3@CGModifyRe

; 7850 : 		return;
; 7851 : 
; 7852 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,66)) //season 4.0 add-on

  004c5	ba 42 1a 00 00	 mov	 edx, 6722		; 00001a42H
  004ca	66 3b c2	 cmp	 ax, dx
  004cd	0f 84 d1 00 00
	00		 je	 $LN3@CGModifyRe

; 7853 : 		return;
; 7854 : 
; 7855 : #if(FIX_CRASH==TRUE)
; 7856 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,70) ) //season 4.0 add-on
; 7857 : 		return;
; 7858 : #endif
; 7859 : #ifdef ZTCLUSIVE_AMYLET
; 7860 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,147) ||
; 7861 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,148) ||
; 7862 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,149) ||
; 7863 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,150) ||
; 7864 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,151) ||
; 7865 : 
; 7866 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,152) ||
; 7867 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,153) ||
; 7868 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,154) ||
; 7869 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,155) ||
; 7870 : 		lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,156) 
; 7871 : 		) 

  004d3	ba 93 1a 00 00	 mov	 edx, 6803		; 00001a93H
  004d8	66 3b c2	 cmp	 ax, dx
  004db	0f 84 c3 00 00
	00		 je	 $LN3@CGModifyRe
  004e1	ba 94 1a 00 00	 mov	 edx, 6804		; 00001a94H
  004e6	66 3b c2	 cmp	 ax, dx
  004e9	0f 84 b5 00 00
	00		 je	 $LN3@CGModifyRe
  004ef	ba 95 1a 00 00	 mov	 edx, 6805		; 00001a95H
  004f4	66 3b c2	 cmp	 ax, dx
  004f7	0f 84 a7 00 00
	00		 je	 $LN3@CGModifyRe
  004fd	ba 96 1a 00 00	 mov	 edx, 6806		; 00001a96H
  00502	66 3b c2	 cmp	 ax, dx
  00505	0f 84 99 00 00
	00		 je	 $LN3@CGModifyRe
  0050b	ba 97 1a 00 00	 mov	 edx, 6807		; 00001a97H
  00510	66 3b c2	 cmp	 ax, dx
  00513	0f 84 8b 00 00
	00		 je	 $LN3@CGModifyRe
  00519	ba 98 1a 00 00	 mov	 edx, 6808		; 00001a98H
  0051e	66 3b c2	 cmp	 ax, dx
  00521	0f 84 7d 00 00
	00		 je	 $LN3@CGModifyRe
  00527	ba 99 1a 00 00	 mov	 edx, 6809		; 00001a99H
  0052c	66 3b c2	 cmp	 ax, dx
  0052f	74 73		 je	 SHORT $LN3@CGModifyRe
  00531	ba 9a 1a 00 00	 mov	 edx, 6810		; 00001a9aH
  00536	66 3b c2	 cmp	 ax, dx
  00539	74 69		 je	 SHORT $LN3@CGModifyRe
  0053b	ba 9b 1a 00 00	 mov	 edx, 6811		; 00001a9bH
  00540	66 3b c2	 cmp	 ax, dx
  00543	74 5f		 je	 SHORT $LN3@CGModifyRe
  00545	ba 9c 1a 00 00	 mov	 edx, 6812		; 00001a9cH
  0054a	66 3b c2	 cmp	 ax, dx
  0054d	74 55		 je	 SHORT $LN3@CGModifyRe

; 7872 : 		return;
; 7873 : #endif
; 7874 : #ifdef PERIOD
; 7875 : 	if( lpObj->pInventory[lpMsg->Position].IsPeriodItem() )	//season 5.4 add-on

  0054f	e8 00 00 00 00	 call	 ?IsPeriodItem@CItem@@QAE_NXZ ; CItem::IsPeriodItem
  00554	84 c0		 test	 al, al
  00556	75 4c		 jne	 SHORT $LN3@CGModifyRe

; 7876 : 	{
; 7877 : 		return;
; 7878 : 	}
; 7879 : #endif
; 7880 : #ifdef LUCKYITEM
; 7881 : 	if( g_LuckyItemManager.IsLuckyItemEquipment(lpObj->pInventory[lpMsg->Position].m_Type) )	//season 6.1 add-on

  00558	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0055c	8b 8b 24 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3620]
  00562	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00568	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  0056d	52		 push	 edx
  0056e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  00573	e8 00 00 00 00	 call	 ?IsLuckyItemEquipment@LuckyItemManager@@QAEHH@Z ; LuckyItemManager::IsLuckyItemEquipment
  00578	85 c0		 test	 eax, eax
  0057a	75 28		 jne	 SHORT $LN3@CGModifyRe

; 7882 : 	{
; 7883 : 		return;
; 7884 : 	}
; 7885 : #endif
; 7886 : 	ItemDurRepaire(lpObj, &lpObj->pInventory[lpMsg->Position], lpMsg->Position, lpMsg->Requestpos);

  0057c	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  00580	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00584	51		 push	 ecx
  00585	50		 push	 eax
  00586	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0058c	03 83 24 0e 00
	00		 add	 eax, DWORD PTR [ebx+3620]
  00592	50		 push	 eax
  00593	53		 push	 ebx
  00594	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire

; 7887 : 	gObjCalCharacter(lpObj->m_Index);

  00599	8b 13		 mov	 edx, DWORD PTR [ebx]
  0059b	52		 push	 edx
  0059c	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  005a1	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@CGModifyRe:
  005a4	5f		 pop	 edi
  005a5	5e		 pop	 esi
  005a6	5b		 pop	 ebx

; 7888 : }

  005a7	8b e5		 mov	 esp, ebp
  005a9	5d		 pop	 ebp
  005aa	c3		 ret	 0
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ENDP ; CGModifyRequestItem
_TEXT	ENDS
PUBLIC	??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@ ; `string'
PUBLIC	??_C@_0BF@HPKACAG@You?5cannot?5trade?5now?$AA@	; `string'
PUBLIC	??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5np@ ; `string'
PUBLIC	??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
EXTRN	?bCanTrade@@3HA:DWORD				; bCanTrade
;	COMDAT ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@
CONST	SEGMENT
??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@ DB '['
	DB	'%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TY'
	DB	'PE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HPKACAG@You?5cannot?5trade?5now?$AA@
CONST	SEGMENT
??_C@_0BF@HPKACAG@You?5cannot?5trade?5now?$AA@ DB 'You cannot trade now', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5np@
CONST	SEGMENT
??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5np@ DB '[HACK'
	DB	'TOOL] : NPC-TradeRequest npc:%d ip:%s account:%s name:%s Stat'
	DB	'e:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ DB 'error '
	DB	': %s %d (%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z
_TEXT	SEGMENT
_iBridgeIndex$247061 = -32				; size = 4
_lpObj$ = -28						; size = 4
_lpMsg$GSCopy$ = -24					; size = 4
_number$ = -24						; size = 4
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z PROC	; CGTradeRequestSend, COMDAT

; 7897 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 7898 : 	int number;
; 7899 : 
; 7900 : 	if (bCanTrade == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanTrade@@3HA, 0 ; bCanTrade
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001b	56		 push	 esi
  0001c	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 7939 : 	{
; 7940 : 		return;
; 7941 : 	}
; 7942 : 
; 7943 : 
; 7944 : 	if ( gObj[number].Type == OBJ_MONSTER )

  0001f	89 75 e8	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00022	75 46		 jne	 SHORT $LN23@CGTradeReq

; 7901 : 	{
; 7902 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 125)), aIndex, 1);

  00024	6a 01		 push	 1
  00026	53		 push	 ebx
  00027	68 7d 04 00 00	 push	 1149			; 0000047dH
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00031	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7903 : 
; 7904 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 126)), aIndex, 1);

  0003f	6a 01		 push	 1
  00041	53		 push	 ebx
  00042	68 7e 04 00 00	 push	 1150			; 0000047eH
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 8074 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN23@CGTradeReq:

; 7905 : 		return;
; 7906 : 	}
; 7907 : 
; 7908 : 	if ( gObj[aIndex].CloseType != -1 )

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	57		 push	 edi
  00070	8b fb		 mov	 edi, ebx
  00072	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00078	03 c7		 add	 eax, edi
  0007a	80 78 0b ff	 cmp	 BYTE PTR [eax+11], -1
  0007e	0f 85 2a 04 00
	00		 jne	 $LN52@CGTradeReq

; 7909 : 	{
; 7910 : 		return;
; 7911 : 	}
; 7912 : 
; 7913 : 	LPOBJ lpObj = &gObj[aIndex];
; 7914 : 
; 7915 : 	if ( !PacketCheckTime(lpObj))

  00084	50		 push	 eax
  00085	89 45 e4	 mov	 DWORD PTR _lpObj$[ebp], eax
  00088	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0008d	83 c4 04	 add	 esp, 4
  00090	85 c0		 test	 eax, eax
  00092	0f 84 16 04 00
	00		 je	 $LN52@CGTradeReq

; 7916 : 	{
; 7917 : 		return;
; 7918 : 	}
; 7919 : 
; 7920 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00098	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0009c	8b 55 e8	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0009f	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000a3	66 c1 e1 08	 shl	 cx, 8
  000a7	0f b7 f1	 movzx	 esi, cx
  000aa	0b f0		 or	 esi, eax
  000ac	89 75 e8	 mov	 DWORD PTR _number$[ebp], esi

; 7921 : 
; 7922 : 	if ( OBJMAX_RANGE(number) == FALSE )

  000af	7c 0f		 jl	 SHORT $LN42@CGTradeReq
  000b1	33 c0		 xor	 eax, eax
  000b3	81 fe 97 3a 00
	00		 cmp	 esi, 14999		; 00003a97H
  000b9	0f 9e c0	 setle	 al
  000bc	85 c0		 test	 eax, eax
  000be	75 2a		 jne	 SHORT $LN20@CGTradeReq
$LN42@CGTradeReq:

; 7923 : 	{
; 7924 : 		LogAdd("error : %s %d (%d)", 
; 7925 : 			__FILE__, 
; 7926 : 			__LINE__, 
; 7927 : 			number);

  000c0	56		 push	 esi
  000c1	68 f6 1e 00 00	 push	 7926			; 00001ef6H
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d6	83 c4 10	 add	 esp, 16			; 00000010H
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx

; 8074 : }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN20@CGTradeReq:

; 7928 : 		return;
; 7929 : 	}
; 7930 : 
; 7931 : 
; 7932 : 	if ( number == aIndex )

  000ea	3b f3		 cmp	 esi, ebx
  000ec	0f 84 bc 03 00
	00		 je	 $LN52@CGTradeReq

; 7933 : 	{
; 7934 : 		return;
; 7935 : 	}
; 7936 : 
; 7937 : 
; 7938 : 	if ( !gObjIsConnected(number))

  000f2	56		 push	 esi
  000f3	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000f8	83 c4 04	 add	 esp, 4
  000fb	85 c0		 test	 eax, eax
  000fd	0f 84 ab 03 00
	00		 je	 $LN52@CGTradeReq

; 7939 : 	{
; 7940 : 		return;
; 7941 : 	}
; 7942 : 
; 7943 : 
; 7944 : 	if ( gObj[number].Type == OBJ_MONSTER )

  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00108	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0010e	0f b7 4c 06 68	 movzx	 ecx, WORD PTR [esi+eax+104]
  00113	83 f9 02	 cmp	 ecx, 2
  00116	0f 84 92 03 00
	00		 je	 $LN52@CGTradeReq

; 7945 : 	{
; 7946 : 		return;
; 7947 : 	}
; 7948 : 
; 7949 : 
; 7950 : 	if ( gObj[number].CloseCount >= 0 )

  0011c	80 7c 06 0a 00	 cmp	 BYTE PTR [esi+eax+10], 0
  00121	0f 8d 87 03 00
	00		 jge	 $LN52@CGTradeReq

; 7951 : 	{
; 7952 : 		return;
; 7953 : 	}
; 7954 : 
; 7955 : 
; 7956 : 	if( gObj[number].Type != OBJ_USER ) //season4 add-on

  00127	83 f9 01	 cmp	 ecx, 1
  0012a	74 44		 je	 SHORT $LN15@CGTradeReq

; 7957 : 	{
; 7958 : 		LogAddC(2,"[HACKTOOL] : NPC-TradeRequest npc:%d ip:%s account:%s name:%s State:%d",
; 7959 : 			gObj[number].Class,gObj[aIndex].Ip_addr,gObj[aIndex].AccountID,
; 7960 : 			gObj[aIndex].Name,gObj[aIndex].Connected);

  0012c	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  00130	51		 push	 ecx
  00131	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00135	52		 push	 edx
  00136	8d 4c 07 6c	 lea	 ecx, DWORD PTR [edi+eax+108]
  0013a	51		 push	 ecx
  0013b	8d 54 07 18	 lea	 edx, DWORD PTR [edi+eax+24]
  0013f	0f b7 84 06 b8
	00 00 00	 movzx	 eax, WORD PTR [esi+eax+184]
  00147	52		 push	 edx
  00148	50		 push	 eax
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5np@
  0014e	6a 02		 push	 2
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 7961 : 		CloseClient(aIndex);

  00156	53		 push	 ebx
  00157	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0015c	83 c4 20	 add	 esp, 32			; 00000020H
  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx

; 8074 : }

  00162	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00165	33 cd		 xor	 ecx, ebp
  00167	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
$LN15@CGTradeReq:

; 7962 : 		return;
; 7963 : 	}
; 7964 : 
; 7965 : 
; 7966 : 	if ( DS_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  00170	8a 8c 06 49 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+329]
  00177	80 f9 09	 cmp	 cl, 9
  0017a	74 0c		 je	 SHORT $LN43@CGTradeReq
  0017c	33 d2		 xor	 edx, edx
  0017e	80 f9 20	 cmp	 cl, 32			; 00000020H
  00181	0f 94 c2	 sete	 dl
  00184	85 d2		 test	 edx, edx
  00186	74 0d		 je	 SHORT $LN14@CGTradeReq
$LN43@CGTradeReq:

; 7967 : 	{
; 7968 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);

  00188	6a 01		 push	 1
  0018a	53		 push	 ebx
  0018b	68 c7 02 00 00	 push	 711			; 000002c7H

; 7969 : 		return;

  00190	e9 f0 00 00 00	 jmp	 $LN53@CGTradeReq
$LN14@CGTradeReq:

; 7970 : 	}
; 7971 : 
; 7972 : 	if ( gObj[aIndex].m_bPShopOpen == true )

  00195	80 bc 07 c4 0e
	00 00 01	 cmp	 BYTE PTR [edi+eax+3780], 1
  0019d	0f 84 0b 03 00
	00		 je	 $LN52@CGTradeReq

; 7973 : 	{
; 7974 : 		return;
; 7975 : 	}
; 7976 : 
; 7977 : 	if ( gObj[number].m_bPShopOpen == true )

  001a3	80 bc 06 c4 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3780], 1
  001ab	0f 84 fd 02 00
	00		 je	 $LN52@CGTradeReq

; 7978 : 	{
; 7979 : 		return;
; 7980 : 	}
; 7981 : 
; 7982 : 	if ( CC_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  001b1	80 f9 35	 cmp	 cl, 53			; 00000035H
  001b4	74 0e		 je	 SHORT $LN44@CGTradeReq
  001b6	80 f9 12	 cmp	 cl, 18			; 00000012H
  001b9	72 16		 jb	 SHORT $LN47@CGTradeReq
  001bb	b2 17		 mov	 dl, 23			; 00000017H
  001bd	3a d1		 cmp	 dl, cl
  001bf	1b c9		 sbb	 ecx, ecx
  001c1	41		 inc	 ecx
  001c2	74 0d		 je	 SHORT $LN47@CGTradeReq
$LN44@CGTradeReq:

; 7983 : 	{
; 7984 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 196)), aIndex, 1);

  001c4	6a 01		 push	 1
  001c6	53		 push	 ebx
  001c7	68 c4 04 00 00	 push	 1220			; 000004c4H

; 7985 : 		return;

  001cc	e9 b4 00 00 00	 jmp	 $LN53@CGTradeReq
$LN47@CGTradeReq:

; 7986 : 	}
; 7987 : 
; 7988 : 	if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  001d1	8a 8c 07 49 01
	00 00		 mov	 cl, BYTE PTR [edi+eax+329]
  001d8	80 f9 34	 cmp	 cl, 52			; 00000034H
  001db	74 11		 je	 SHORT $LN45@CGTradeReq
  001dd	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  001e0	72 4e		 jb	 SHORT $LN48@CGTradeReq
  001e2	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  001e7	3a d1		 cmp	 dl, cl
  001e9	1b d2		 sbb	 edx, edx
  001eb	42		 inc	 edx
  001ec	74 42		 je	 SHORT $LN48@CGTradeReq
$LN45@CGTradeReq:

; 7989 : 	{
; 7990 : 		int iBridgeIndex = g_BloodCastle.GetBridgeIndex(gObj[aIndex].MapNumber); //season 3.0 add-on

  001ee	0f b6 c1	 movzx	 eax, cl
  001f1	50		 push	 eax
  001f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001f7	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex

; 7991 : 
; 7992 : 		if( g_BloodCastle.GetCurrentState(iBridgeIndex) != 1 ||
; 7993 : 			g_BloodCastle.CheckCanEnter(iBridgeIndex) == false )

  001fc	50		 push	 eax
  001fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00202	89 45 e0	 mov	 DWORD PTR _iBridgeIndex$247061[ebp], eax
  00205	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0020a	83 f8 01	 cmp	 eax, 1
  0020d	75 12		 jne	 SHORT $LN8@CGTradeReq
  0020f	8b 4d e0	 mov	 ecx, DWORD PTR _iBridgeIndex$247061[ebp]
  00212	51		 push	 ecx
  00213	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00218	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  0021d	84 c0		 test	 al, al
  0021f	75 0a		 jne	 SHORT $LN46@CGTradeReq
$LN8@CGTradeReq:

; 7994 : 		{
; 7995 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 188)), aIndex, 1);

  00221	6a 01		 push	 1
  00223	53		 push	 ebx
  00224	68 bc 04 00 00	 push	 1212			; 000004bcH

; 7996 : 			return;

  00229	eb 5a		 jmp	 SHORT $LN53@CGTradeReq
$LN46@CGTradeReq:
  0022b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN48@CGTradeReq:

; 7997 : 		}	
; 7998 : 	}
; 7999 : 
; 8000 : 	if ( DG_MAP_RANGE(gObj[number].MapNumber) != FALSE )	//Season 5 DoppelGanger

  00230	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00238	80 f9 41	 cmp	 cl, 65			; 00000041H
  0023b	72 2a		 jb	 SHORT $LN49@CGTradeReq
  0023d	b2 44		 mov	 dl, 68			; 00000044H
  0023f	3a d1		 cmp	 dl, cl
  00241	1b c9		 sbb	 ecx, ecx
  00243	41		 inc	 ecx
  00244	74 21		 je	 SHORT $LN49@CGTradeReq

; 8001 : 	{
; 8002 : 		GCServerMsgStringSend("You cannot trade now", aIndex, 1);

  00246	6a 01		 push	 1
  00248	53		 push	 ebx
  00249	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HPKACAG@You?5cannot?5trade?5now?$AA@
  0024e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH
  00256	5f		 pop	 edi
  00257	5e		 pop	 esi
  00258	5b		 pop	 ebx

; 8074 : }

  00259	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025c	33 cd		 xor	 ecx, ebp
  0025e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
$LN49@CGTradeReq:

; 8003 : 		return;
; 8004 : 	}
; 8005 : 
; 8006 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  00267	0f b6 8c 07 49
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+329]
  0026f	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00272	72 35		 jb	 SHORT $LN50@CGTradeReq
  00274	b2 32		 mov	 dl, 50			; 00000032H
  00276	3a d1		 cmp	 dl, cl
  00278	1b c9		 sbb	 ecx, ecx
  0027a	41		 inc	 ecx
  0027b	74 2c		 je	 SHORT $LN50@CGTradeReq

; 8007 : 	{
; 8008 : 
; 8009 : 		::GCServerMsgStringSend(lMsg.Get(3396), aIndex, 1);

  0027d	6a 01		 push	 1
  0027f	53		 push	 ebx
  00280	68 44 0d 00 00	 push	 3396			; 00000d44H
$LN53@CGTradeReq:
  00285	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0028a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0028f	50		 push	 eax
  00290	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00295	83 c4 0c	 add	 esp, 12			; 0000000cH
  00298	5f		 pop	 edi
  00299	5e		 pop	 esi
  0029a	5b		 pop	 ebx

; 8074 : }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	33 cd		 xor	 ecx, ebp
  002a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c3		 ret	 0
$LN50@CGTradeReq:

; 8010 : 		return;
; 8011 : 	}
; 8012 : 
; 8013 : 	if ( (gObj[number].m_Option &1) != 1 )

  002a9	f6 84 06 8c 0e
	00 00 01	 test	 BYTE PTR [esi+eax+3724], 1
  002b1	75 25		 jne	 SHORT $LN5@CGTradeReq

; 8014 : 	{
; 8015 : 
; 8016 : 		::GCTradeResponseSend(0, aIndex, gObj[number].Name, 0, 0);

  002b3	6a 00		 push	 0
  002b5	6a 00		 push	 0
  002b7	8d 44 06 77	 lea	 eax, DWORD PTR [esi+eax+119]
  002bb	50		 push	 eax
  002bc	53		 push	 ebx
  002bd	6a 00		 push	 0
  002bf	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  002c4	83 c4 14	 add	 esp, 20			; 00000014H
  002c7	5f		 pop	 edi
  002c8	5e		 pop	 esi
  002c9	5b		 pop	 ebx

; 8074 : }

  002ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cd	33 cd		 xor	 ecx, ebp
  002cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c3		 ret	 0
$LN5@CGTradeReq:

; 8017 : 		return;
; 8018 : 	}
; 8019 : 
; 8020 : 	if ( lpObj->m_IfState.use > 0 )

  002d8	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002db	b9 03 00 00 00	 mov	 ecx, 3
  002e0	84 8a 1c 0e 00
	00		 test	 BYTE PTR [edx+3612], cl
  002e6	76 24		 jbe	 SHORT $LN4@CGTradeReq

; 8021 : 	{
; 8022 : 
; 8023 : 		::GCTradeResponseSend(3, aIndex, gObj[number].Name, 0, 0);

  002e8	6a 00		 push	 0
  002ea	6a 00		 push	 0
  002ec	8d 44 06 77	 lea	 eax, DWORD PTR [esi+eax+119]
  002f0	50		 push	 eax
  002f1	53		 push	 ebx
  002f2	51		 push	 ecx
  002f3	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  002f8	83 c4 14	 add	 esp, 20			; 00000014H
  002fb	5f		 pop	 edi
  002fc	5e		 pop	 esi
  002fd	5b		 pop	 ebx

; 8074 : }

  002fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00301	33 cd		 xor	 ecx, ebp
  00303	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0
$LN4@CGTradeReq:

; 8024 : 		return;
; 8025 : 	}
; 8026 : 
; 8027 : 	if (gObj[number].m_IfState.use > 0 )

  0030c	84 8c 06 1c 0e
	00 00		 test	 BYTE PTR [esi+eax+3612], cl
  00313	76 25		 jbe	 SHORT $LN3@CGTradeReq

; 8028 : 	{
; 8029 : 
; 8030 : 		::GCTradeResponseSend(2, aIndex, gObj[number].Name, 0, 0);

  00315	6a 00		 push	 0
  00317	6a 00		 push	 0
  00319	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0031d	51		 push	 ecx
  0031e	53		 push	 ebx
  0031f	6a 02		 push	 2
  00321	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00326	83 c4 14	 add	 esp, 20			; 00000014H
  00329	5f		 pop	 edi
  0032a	5e		 pop	 esi
  0032b	5b		 pop	 ebx

; 8074 : }

  0032c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032f	33 cd		 xor	 ecx, ebp
  00331	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00336	8b e5		 mov	 esp, ebp
  00338	5d		 pop	 ebp
  00339	c3		 ret	 0
$LN3@CGTradeReq:

; 8031 : 		return;
; 8032 : 	}
; 8033 : 
; 8034 : 	if ( ::gObjFixInventoryPointer(aIndex) == false )

  0033a	53		 push	 ebx
  0033b	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00340	83 c4 04	 add	 esp, 4
  00343	84 c0		 test	 al, al
  00345	75 18		 jne	 SHORT $LN2@CGTradeReq

; 8035 : 	{
; 8036 : 
; 8037 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d",
; 8038 : 			__FILE__,
; 8039 : 			__LINE__);

  00347	68 67 1f 00 00	 push	 8039			; 00001f67H
  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00351	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00356	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0035c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGTradeReq:

; 8040 : 	}
; 8041 : 
; 8042 : 	if ( gObj[aIndex].pTransaction == 1 )

  0035f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00364	80 bc 07 30 0e
	00 00 01	 cmp	 BYTE PTR [edi+eax+3632], 1
  0036c	75 3a		 jne	 SHORT $LN1@CGTradeReq

; 8043 : 	{
; 8044 : 
; 8045 : 		LogAddTD("[%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TYPE : %d",
; 8046 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  0036e	8b 94 07 1c 0e
	00 00		 mov	 edx, DWORD PTR [edi+eax+3612]
  00375	c1 ea 06	 shr	 edx, 6
  00378	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0037e	52		 push	 edx
  0037f	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  00383	51		 push	 ecx
  00384	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  00388	52		 push	 edx
  00389	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00394	83 c4 10	 add	 esp, 16			; 00000010H
  00397	5f		 pop	 edi
  00398	5e		 pop	 esi
  00399	5b		 pop	 ebx

; 8074 : }

  0039a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039d	33 cd		 xor	 ecx, ebp
  0039f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a4	8b e5		 mov	 esp, ebp
  003a6	5d		 pop	 ebp
  003a7	c3		 ret	 0
$LN1@CGTradeReq:

; 8047 : 		return;
; 8048 : 	}
; 8049 : 
; 8050 : 	lpObj->m_IfState.use = 1;
; 8051 : 	lpObj->m_IfState.state = 0;
; 8052 : 	lpObj->m_IfState.type = 1;

  003a8	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ab	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]

; 8053 : 	lpObj->TargetNumber = number;

  003b1	66 8b 55 e8	 mov	 dx, WORD PTR _number$[ebp]
  003b5	66 89 90 58 04
	00 00		 mov	 WORD PTR [eax+1112], dx
  003bc	81 e1 41 00 ff
	ff		 and	 ecx, -65471		; ffff0041H
  003c2	83 c9 41	 or	 ecx, 65			; 00000041H
  003c5	89 88 1c 0e 00
	00		 mov	 DWORD PTR [eax+3612], ecx

; 8054 : 	gObj[number].m_IfState.use = 1;

  003cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d0	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  003d7	83 e1 fd	 and	 ecx, -3			; fffffffdH
  003da	83 c9 01	 or	 ecx, 1
  003dd	89 8c 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], ecx

; 8055 : 	gObj[number].m_IfState.state = 0;

  003e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e9	83 a4 06 1c 0e
	00 00 c3	 and	 DWORD PTR [esi+eax+3612], -61 ; ffffffc3H

; 8056 : 	gObj[number].m_IfState.type = 1;

  003f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f6	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  003fd	81 e2 7f 00 ff
	ff		 and	 edx, -65409		; ffff007fH
  00403	83 ca 40	 or	 edx, 64			; 00000040H
  00406	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx

; 8057 : 	gObj[number].TargetNumber = aIndex;

  0040d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00412	66 89 9c 06 58
	04 00 00	 mov	 WORD PTR [esi+eax+1112], bx

; 8058 : 	lpObj->m_InterfaceTime = GetTickCount();

  0041a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  00420	ff d3		 call	 ebx
  00422	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00425	89 81 20 0e 00
	00		 mov	 DWORD PTR [ecx+3616], eax

; 8059 : 	gObj[number].m_InterfaceTime = GetTickCount();

  0042b	ff d3		 call	 ebx
  0042d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00433	89 84 16 20 0e
	00 00		 mov	 DWORD PTR [esi+edx+3616], eax

; 8060 : 
; 8061 : 	PMSG_TRADE_REQUESTSEND pMsg;
; 8062 : 
; 8063 : 	pMsg.h.c = 0xC3;
; 8064 : 	pMsg.h.headcode = 0x36;
; 8065 : 	pMsg.h.size = sizeof(pMsg);
; 8066 : 	memcpy(pMsg.szId, gObj[aIndex].Name, sizeof(pMsg.szId));

  0043a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043f	c6 45 ec c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H
  00443	66 c7 45 ed 0d
	36		 mov	 WORD PTR _pMsg$[ebp+1], 13837 ; 0000360dH
  00449	8b 4c 07 77	 mov	 ecx, DWORD PTR [edi+eax+119]
  0044d	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  00450	8b 54 07 7b	 mov	 edx, DWORD PTR [edi+eax+123]
  00454	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx

; 8067 : 
; 8068 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  00457	8b 55 e8	 mov	 edx, DWORD PTR _number$[ebp]
  0045a	66 8b 44 07 7f	 mov	 ax, WORD PTR [edi+eax+127]
  0045f	6a 0d		 push	 13			; 0000000dH
  00461	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00464	51		 push	 ecx
  00465	52		 push	 edx
  00466	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  0046a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8069 : 
; 8070 : 	LogAddTD(lMsg.Get(MSGGET(1, 230)), gObj[aIndex].AccountID, 
; 8071 : 		gObj[aIndex].Name, gObj[aIndex].Ip_addr, 
; 8072 : 		gObj[number].AccountID, gObj[number].Name, 
; 8073 : 		gObj[number].Ip_addr);

  0046f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00474	83 c4 0c	 add	 esp, 12			; 0000000cH
  00477	8d 4c 06 18	 lea	 ecx, DWORD PTR [esi+eax+24]
  0047b	51		 push	 ecx
  0047c	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00480	52		 push	 edx
  00481	8d 4c 06 6c	 lea	 ecx, DWORD PTR [esi+eax+108]
  00485	51		 push	 ecx
  00486	8d 54 07 18	 lea	 edx, DWORD PTR [edi+eax+24]
  0048a	52		 push	 edx
  0048b	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  0048f	51		 push	 ecx
  00490	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  00494	52		 push	 edx
  00495	68 e6 01 00 00	 push	 486			; 000001e6H
  0049a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0049f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004a4	50		 push	 eax
  004a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004ab	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN52@CGTradeReq:

; 8074 : }

  004ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b1	5f		 pop	 edi
  004b2	5e		 pop	 esi
  004b3	33 cd		 xor	 ecx, ebp
  004b5	5b		 pop	 ebx
  004b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bb	8b e5		 mov	 esp, ebp
  004bd	5d		 pop	 ebp
  004be	c3		 ret	 0
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ENDP	; CGTradeRequestSend
_TEXT	ENDS
PUBLIC	??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@ ; `string'
PUBLIC	??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@ ; `string'
PUBLIC	??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@ ; `string'
PUBLIC	??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@ ; `string'
PUBLIC	??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
;	COMDAT ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@
CONST	SEGMENT
??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@ DB '('
	DB	'%s)(%s) Trade Interface State Error : use:%d type:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'%s][%s] Trade Ready [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@ DB 'Interface State :'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@
CONST	SEGMENT
??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@ DB '['
	DB	'%s][%s] Made Trade Error (in Transaction) [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@
CONST	SEGMENT
??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@ DB '['
	DB	'%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_T'
	DB	'YPE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@
CONST	SEGMENT
??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@ DB 'e'
	DB	'rror-L1 : target:%d (A_ID:%s) %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@ DB 'e'
	DB	'rror-L1 : %d (A_ID:%s) %s %d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z
_TEXT	SEGMENT
_number$ = -8						; size = 4
_Result$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z PROC ; CGTradeResponseRecv, COMDAT

; 8080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8081 : 	BOOL Result = TRUE;
; 8082 : 	int number = gObj[aIndex].TargetNumber;

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00018	57		 push	 edi
  00019	0f bf bc 06 58
	04 00 00	 movsx	 edi, WORD PTR [esi+eax+1112]
  00021	89 7d f8	 mov	 DWORD PTR _number$[ebp], edi

; 8083 : 
; 8084 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00024	85 c9		 test	 ecx, ecx
  00026	78 11		 js	 SHORT $LN41@CGTradeRes
  00028	33 d2		 xor	 edx, edx
  0002a	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00030	0f 9e c2	 setle	 dl
  00033	8b ca		 mov	 ecx, edx
  00035	85 c9		 test	 ecx, ecx
  00037	75 2c		 jne	 SHORT $LN46@CGTradeRes
$LN41@CGTradeRes:

; 8085 : 	{
; 8086 : 		LogAdd("error-L1 : %d (A_ID:%s) %s %d", number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  00039	68 96 1f 00 00	 push	 8086			; 00001f96H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00043	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00047	50		 push	 eax
  00048	57		 push	 edi
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 8087 : 		Result = FALSE;
; 8088 : 		lpMsg->Response = false;

  00054	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00057	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	83 c4 14	 add	 esp, 20			; 00000014H
  00063	eb 03		 jmp	 SHORT $LN32@CGTradeRes
$LN46@CGTradeRes:
  00065	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
$LN32@CGTradeRes:

; 8089 : 	}
; 8090 : 
; 8091 : 	if ( OBJMAX_RANGE(number) == FALSE )

  00068	85 ff		 test	 edi, edi
  0006a	78 0f		 js	 SHORT $LN42@CGTradeRes
  0006c	33 c9		 xor	 ecx, ecx
  0006e	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00074	0f 9e c1	 setle	 cl
  00077	85 c9		 test	 ecx, ecx
  00079	75 5e		 jne	 SHORT $LN31@CGTradeRes
$LN42@CGTradeRes:

; 8092 : 	{
; 8093 : 		if ( gObj[aIndex].m_IfState.use != FALSE )

  0007b	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00082	f6 c1 03	 test	 cl, 3
  00085	74 29		 je	 SHORT $LN29@CGTradeRes

; 8094 : 		{
; 8095 : 			if ( gObj[aIndex].m_IfState.type == 1 )

  00087	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0008d	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00090	75 1e		 jne	 SHORT $LN29@CGTradeRes

; 8096 : 			{
; 8097 : 				gObj[aIndex].m_IfState.use = FALSE;

  00092	83 a4 06 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+eax+3612], -4 ; fffffffcH

; 8098 : 				gObj[aIndex].TargetNumber = -1;

  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	83 c9 ff	 or	 ecx, -1
  000a3	66 89 8c 16 58
	04 00 00	 mov	 WORD PTR [esi+edx+1112], cx
  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN29@CGTradeRes:

; 8099 : 			}
; 8100 : 		}
; 8101 : 
; 8102 : 		LogAdd("error-L1 : target:%d (A_ID:%s) %s %d", number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  000b0	68 a6 1f 00 00	 push	 8102			; 00001fa6H
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000ba	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  000be	50		 push	 eax
  000bf	57		 push	 edi
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 8139 : 	{
; 8140 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.use, gObj[aIndex].m_IfState.type);

  000cb	83 c4 14	 add	 esp, 20			; 00000014H
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  000d4	5b		 pop	 ebx

; 8232 : 			}
; 8233 : 		}
; 8234 : 	}
; 8235 : }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN31@CGTradeRes:

; 8103 : 		Result = FALSE;
; 8104 : 		lpMsg->Response = false;
; 8105 : 		return; //season4 add-on (fix)
; 8106 : 	}
; 8107 : 
; 8108 : 	if ( gObjIsConnected(number) == FALSE )

  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000df	83 c4 04	 add	 esp, 4
  000e2	85 c0		 test	 eax, eax
  000e4	75 03		 jne	 SHORT $LN28@CGTradeRes

; 8109 : 	{
; 8110 : 		Result = FALSE;
; 8111 : 		lpMsg->Response = false;

  000e6	88 43 03	 mov	 BYTE PTR [ebx+3], al
$LN28@CGTradeRes:

; 8112 : 	}
; 8113 : 	
; 8114 : 	if ( gObj[aIndex].CloseType != -1 )

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	80 7c 06 0b ff	 cmp	 BYTE PTR [esi+eax+11], -1
  000f3	74 09		 je	 SHORT $LN27@CGTradeRes

; 8115 : 	{
; 8116 : 		Result = FALSE;
; 8117 : 		lpMsg->Response = false;

  000f5	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN27@CGTradeRes:

; 8118 : 	}
; 8119 : 
; 8120 : 	if ( gObj[aIndex].m_bPShopOpen == true )

  000fe	80 bc 06 c4 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3780], 1
  00106	75 09		 jne	 SHORT $LN26@CGTradeRes

; 8121 : 	{
; 8122 : 		Result = FALSE;
; 8123 : 		lpMsg->Response = false;

  00108	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0010c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN26@CGTradeRes:

; 8124 : 	}
; 8125 : 
; 8126 : 	if ( gObj[number].m_bPShopOpen == true )

  00111	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00117	80 bc 07 c4 0e
	00 00 01	 cmp	 BYTE PTR [edi+eax+3780], 1
  0011f	75 09		 jne	 SHORT $LN25@CGTradeRes

; 8127 : 	{
; 8128 : 		Result = FALSE;
; 8129 : 		lpMsg->Response = false;

  00121	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  00125	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN25@CGTradeRes:

; 8130 : 	}
; 8131 : 
; 8132 : 	if ( gObj[aIndex].X < (gObj[number].X -2 ) || gObj[aIndex].X > (gObj[number].X +2 ) || gObj[aIndex].Y < (gObj[number].Y -2 ) || gObj[aIndex].Y > (gObj[number].Y +2 ) )

  0012a	0f bf 8c 07 44
	01 00 00	 movsx	 ecx, WORD PTR [edi+eax+324]
  00132	0f bf 94 06 44
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+324]
  0013a	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]
  0013d	3b d3		 cmp	 edx, ebx
  0013f	7c 25		 jl	 SHORT $LN50@CGTradeRes
  00141	83 c1 02	 add	 ecx, 2
  00144	3b d1		 cmp	 edx, ecx
  00146	7f 1e		 jg	 SHORT $LN50@CGTradeRes
  00148	0f bf 8c 07 46
	01 00 00	 movsx	 ecx, WORD PTR [edi+eax+326]
  00150	0f bf 94 06 46
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+326]
  00158	8d 59 fe	 lea	 ebx, DWORD PTR [ecx-2]
  0015b	3b d3		 cmp	 edx, ebx
  0015d	7c 07		 jl	 SHORT $LN50@CGTradeRes
  0015f	83 c1 02	 add	 ecx, 2
  00162	3b d1		 cmp	 edx, ecx
  00164	7e 0c		 jle	 SHORT $LN51@CGTradeRes
$LN50@CGTradeRes:

; 8133 : 	{
; 8134 : 		Result = FALSE;
; 8135 : 		lpMsg->Response = false;

  00166	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00169	c6 41 03 00	 mov	 BYTE PTR [ecx+3], 0
  0016d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN51@CGTradeRes:

; 8136 : 	}
; 8137 : 
; 8138 : 	if ( gObj[aIndex].m_IfState.use == FALSE || gObj[aIndex].m_IfState.type != 1 || gObj[aIndex].m_IfState.state != 0 )

  00172	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00179	f6 c1 03	 test	 cl, 3
  0017c	0f 84 ea 03 00
	00		 je	 $LN21@CGTradeRes
  00182	8b d1		 mov	 edx, ecx
  00184	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  0018a	83 fa 40	 cmp	 edx, 64			; 00000040H
  0018d	0f 85 d9 03 00
	00		 jne	 $LN21@CGTradeRes
  00193	f6 c1 3c	 test	 cl, 60			; 0000003cH
  00196	0f 85 d0 03 00
	00		 jne	 $LN21@CGTradeRes

; 8141 : 		return;
; 8142 : 	}
; 8143 : 
; 8144 : 	if ( gObj[number].m_IfState.use == FALSE || gObj[number].m_IfState.type != 1 || gObj[number].m_IfState.state != 0 )

  0019c	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  001a3	f6 c1 03	 test	 cl, 3
  001a6	0f 84 a6 03 00
	00		 je	 $LN19@CGTradeRes
  001ac	8b d1		 mov	 edx, ecx
  001ae	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  001b4	83 fa 40	 cmp	 edx, 64			; 00000040H
  001b7	0f 85 95 03 00
	00		 jne	 $LN19@CGTradeRes
  001bd	f6 c1 3c	 test	 cl, 60			; 0000003cH
  001c0	0f 85 8c 03 00
	00		 jne	 $LN19@CGTradeRes

; 8148 : 	}
; 8149 : 
; 8150 : 	if ( gObjFixInventoryPointer(aIndex) == false )

  001c6	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  001cf	83 c4 04	 add	 esp, 4
  001d2	84 c0		 test	 al, al
  001d4	75 18		 jne	 SHORT $LN18@CGTradeRes

; 8151 : 	{
; 8152 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  001d6	68 d8 1f 00 00	 push	 8152			; 00001fd8H
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGTradeRes:

; 8153 : 	}
; 8154 : 
; 8155 : 	if ( gObj[aIndex].pTransaction == 1 )

  001ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f3	80 bc 06 30 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3632], 1
  001fb	75 30		 jne	 SHORT $LN17@CGTradeRes

; 8156 : 	{
; 8157 : 		LogAddTD("[%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_TYPE : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  001fd	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00204	c1 e9 06	 shr	 ecx, 6
  00207	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0020d	51		 push	 ecx
  0020e	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00212	52		 push	 edx
  00213	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00217	50		 push	 eax
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@
  0021d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00223	83 c4 10	 add	 esp, 16			; 00000010H
  00226	5f		 pop	 edi
  00227	5e		 pop	 esi
  00228	5b		 pop	 ebx

; 8232 : 			}
; 8233 : 		}
; 8234 : 	}
; 8235 : }

  00229	8b e5		 mov	 esp, ebp
  0022b	5d		 pop	 ebp
  0022c	c3		 ret	 0
$LN17@CGTradeRes:

; 8158 : 		return;
; 8159 : 	}
; 8160 : 
; 8161 : 	if ( lpMsg->Response == false )

  0022d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00230	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  00234	75 19		 jne	 SHORT $LN16@CGTradeRes

; 8162 : 	{
; 8163 : 		GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, 0, 0);

  00236	6a 00		 push	 0
  00238	6a 00		 push	 0
  0023a	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0023e	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00241	52		 push	 edx
  00242	50		 push	 eax
  00243	6a 00		 push	 0
  00245	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 8164 : 		Result = FALSE;
; 8165 : 	}
; 8166 : 	else

  0024a	e9 8c 01 00 00	 jmp	 $LN55@CGTradeRes
$LN16@CGTradeRes:

; 8167 : 	{
; 8168 : 		Result = TRUE;

  0024f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 1
  00256	33 db		 xor	 ebx, ebx
  00258	eb 0b		 jmp	 SHORT $LN14@CGTradeRes
  0025a	8d 9b 00 00 00
	00		 npad	 6
$LL45@CGTradeRes:
  00260	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN14@CGTradeRes:

; 8169 : 
; 8170 : 		for ( int i=0;i<TRADE_BOX_SIZE;i++)
; 8171 : 		{
; 8172 : 			gObj[aIndex].Trade[i].Clear();

  00265	8b 8c 06 4c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3660]
  0026c	03 cb		 add	 ecx, ebx
  0026e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 8173 : 			gObj[number].Trade[i].Clear();

  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00279	8b 8c 0f 4c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+3660]
  00280	03 cb		 add	 ecx, ebx
  00282	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00287	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  0028d	81 fb 80 1a 00
	00		 cmp	 ebx, 6784		; 00001a80H
  00293	7c cb		 jl	 SHORT $LL45@CGTradeRes

; 8174 : 		}
; 8175 : 
; 8176 : 		memset(gObj[aIndex].TradeMap, (BYTE)-1, TRADE_BOX_MAP_SIZE );

  00295	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029b	8b 8c 16 50 0e
	00 00		 mov	 ecx, DWORD PTR [esi+edx+3664]
  002a2	83 c8 ff	 or	 eax, -1
  002a5	89 01		 mov	 DWORD PTR [ecx], eax
  002a7	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  002aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  002ad	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  002b0	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  002b3	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  002b6	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  002b9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 8177 : 		memset(gObj[number].TradeMap, (BYTE)-1, TRADE_BOX_MAP_SIZE );

  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c2	8b 8c 0f 50 0e
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+3664]
  002c9	0b c0		 or	 eax, eax
  002cb	89 01		 mov	 DWORD PTR [ecx], eax
  002cd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  002d0	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  002d3	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  002d6	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  002d9	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  002dc	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  002df	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 8178 : 		gObj[aIndex].m_IfState.state = 1;

  002e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e7	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]

; 8179 : 		gObj[number].m_IfState.state = 1;
; 8180 : 		gObj[aIndex].TradeMoney = 0;
; 8181 : 		gObj[number].TradeMoney = 0;
; 8182 : 
; 8183 : 		if (::gObjInventoryTrans(aIndex) == FALSE )

  002ee	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  002f1	83 e2 c7	 and	 edx, -57		; ffffffc7H
  002f4	83 ca 04	 or	 edx, 4
  002f7	89 94 06 1c 0e
	00 00		 mov	 DWORD PTR [esi+eax+3612], edx
  002fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00303	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  0030a	83 e1 c7	 and	 ecx, -57		; ffffffc7H
  0030d	83 c9 04	 or	 ecx, 4
  00310	89 8c 07 1c 0e
	00 00		 mov	 DWORD PTR [edi+eax+3612], ecx
  00317	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031d	33 c0		 xor	 eax, eax
  0031f	89 84 16 54 0e
	00 00		 mov	 DWORD PTR [esi+edx+3668], eax
  00326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0032c	53		 push	 ebx
  0032d	89 84 0f 54 0e
	00 00		 mov	 DWORD PTR [edi+ecx+3668], eax
  00334	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  00339	83 c4 04	 add	 esp, 4
  0033c	85 c0		 test	 eax, eax
  0033e	75 07		 jne	 SHORT $LN47@CGTradeRes

; 8184 : 			Result = 2;

  00340	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 2
$LN47@CGTradeRes:

; 8185 : 
; 8186 : 		if (::gObjInventoryTrans(number) == FALSE )

  00347	8b 55 f8	 mov	 edx, DWORD PTR _number$[ebp]
  0034a	52		 push	 edx
  0034b	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  00350	83 c4 04	 add	 esp, 4
  00353	85 c0		 test	 eax, eax
  00355	75 09		 jne	 SHORT $LN10@CGTradeRes

; 8187 : 			Result = 3;

  00357	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 3

; 8188 : 
; 8189 : 		if ( Result != TRUE )

  0035e	eb 0a		 jmp	 SHORT $LN44@CGTradeRes
$LN10@CGTradeRes:
  00360	83 7d fc 01	 cmp	 DWORD PTR _Result$[ebp], 1
  00364	0f 84 64 01 00
	00		 je	 $LN9@CGTradeRes
$LN44@CGTradeRes:

; 8190 : 		{
; 8191 : 			lpMsg->Response = false;

  0036a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0036d	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 8192 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, 0, 0);

  00371	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00377	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0037a	6a 00		 push	 0
  0037c	6a 00		 push	 0
  0037e	8d 54 0e 77	 lea	 edx, DWORD PTR [esi+ecx+119]
  00382	52		 push	 edx
  00383	50		 push	 eax
  00384	6a 00		 push	 0
  00386	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 8193 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, 0, 0);

  0038b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00391	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00394	6a 00		 push	 0
  00396	6a 00		 push	 0
  00398	8d 54 0f 77	 lea	 edx, DWORD PTR [edi+ecx+119]
  0039c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003a0	52		 push	 edx
  003a1	53		 push	 ebx
  003a2	51		 push	 ecx
  003a3	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 8194 : 
; 8195 : 			if ( Result == 2 )

  003a8	8b 45 fc	 mov	 eax, DWORD PTR _Result$[ebp]
  003ab	83 c4 28	 add	 esp, 40			; 00000028H
  003ae	83 f8 02	 cmp	 eax, 2
  003b1	0f 85 f0 00 00
	00		 jne	 $LN8@CGTradeRes

; 8196 : 			{
; 8197 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name);

  003b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bc	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  003c0	52		 push	 edx
  003c1	8d 4c 07 6c	 lea	 ecx, DWORD PTR [edi+eax+108]
  003c5	51		 push	 ecx
  003c6	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  003ca	52		 push	 edx
  003cb	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  003cf	50		 push	 eax
$LN57@CGTradeRes:
  003d0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@
  003d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
$LN55@CGTradeRes:

; 8200 : 			{
; 8201 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",	gObj[number].AccountID, gObj[number].Name, gObj[aIndex].AccountID, gObj[aIndex].Name);

  003db	83 c4 14	 add	 esp, 20			; 00000014H
$LN48@CGTradeRes:

; 8213 : 		}
; 8214 : 	}
; 8215 : 
; 8216 : 	if ( Result == FALSE )
; 8217 : 	{
; 8218 : 		if ( gObj[aIndex].m_IfState.use != FALSE && gObj[aIndex].m_IfState.type == 1 )

  003de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e3	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  003ea	f6 c1 03	 test	 cl, 3
  003ed	74 47		 je	 SHORT $LN53@CGTradeRes
  003ef	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  003f5	83 f9 40	 cmp	 ecx, 64			; 00000040H
  003f8	75 3c		 jne	 SHORT $LN53@CGTradeRes

; 8219 : 		{
; 8220 : 			gObj[aIndex].m_IfState.use = FALSE;

  003fa	83 a4 06 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+eax+3612], -4 ; fffffffcH

; 8221 : 			gObj[aIndex].TargetNumber = -1;

  00402	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00408	83 c9 ff	 or	 ecx, -1
  0040b	66 89 8c 16 58
	04 00 00	 mov	 WORD PTR [esi+edx+1112], cx

; 8222 : 			LogAddTD("Interface State : %d", gObj[aIndex].m_IfState.use);

  00413	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00418	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  0041f	83 e1 03	 and	 ecx, 3
  00422	51		 push	 ecx
  00423	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0042e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00433	83 c4 08	 add	 esp, 8
$LN53@CGTradeRes:

; 8223 : 		}
; 8224 : 
; 8225 : 		if ( gObj[number].TargetNumber == aIndex )

  00436	0f bf 94 07 58
	04 00 00	 movsx	 edx, WORD PTR [edi+eax+1112]
  0043e	3b 55 0c	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  00441	0f 85 4d 01 00
	00		 jne	 $LN1@CGTradeRes

; 8226 : 		{
; 8227 : 			if ( gObj[number].m_IfState.use != FALSE && gObj[number].m_IfState.type == 1 )

  00447	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  0044e	8d 84 07 1c 0e
	00 00		 lea	 eax, DWORD PTR [edi+eax+3612]
  00455	f6 c1 03	 test	 cl, 3
  00458	0f 84 36 01 00
	00		 je	 $LN1@CGTradeRes
  0045e	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00464	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00467	0f 85 27 01 00
	00		 jne	 $LN1@CGTradeRes

; 8228 : 			{
; 8229 : 				gObj[number].m_IfState.use = FALSE;

  0046d	83 20 fc	 and	 DWORD PTR [eax], -4	; fffffffcH

; 8230 : 				gObj[number].TargetNumber = -1;

  00470	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00476	83 c8 ff	 or	 eax, -1
  00479	66 89 84 0f 58
	04 00 00	 mov	 WORD PTR [edi+ecx+1112], ax

; 8231 : 				LogAddTD("Interface State : %d", gObj[number].m_IfState.use);

  00481	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00487	8b 84 17 1c 0e
	00 00		 mov	 eax, DWORD PTR [edi+edx+3612]
  0048e	83 e0 03	 and	 eax, 3
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0049d	83 c4 08	 add	 esp, 8
  004a0	5f		 pop	 edi
  004a1	5e		 pop	 esi
  004a2	5b		 pop	 ebx

; 8232 : 			}
; 8233 : 		}
; 8234 : 	}
; 8235 : }

  004a3	8b e5		 mov	 esp, ebp
  004a5	5d		 pop	 ebp
  004a6	c3		 ret	 0
$LN8@CGTradeRes:

; 8198 : 			}
; 8199 : 			else if ( Result == 3 )

  004a7	83 f8 03	 cmp	 eax, 3
  004aa	0f 85 2e ff ff
	ff		 jne	 $LN48@CGTradeRes

; 8200 : 			{
; 8201 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",	gObj[number].AccountID, gObj[number].Name, gObj[aIndex].AccountID, gObj[aIndex].Name);

  004b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b5	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  004b9	51		 push	 ecx
  004ba	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  004be	52		 push	 edx
  004bf	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  004c3	51		 push	 ecx
  004c4	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]
  004c8	52		 push	 edx

; 8202 : 			}
; 8203 : 
; 8204 : 			Result = FALSE;
; 8205 : 		}
; 8206 : 		else

  004c9	e9 02 ff ff ff	 jmp	 $LN57@CGTradeRes
$LN9@CGTradeRes:

; 8207 : 		{
; 8208 : 			lpMsg->Response = true;

  004ce	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004d1	c6 40 03 01	 mov	 BYTE PTR [eax+3], 1

; 8209 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, gObj[aIndex].Level, gObj[aIndex].GuildNumber);

  004d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004da	8b 8c 06 34 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1076]
  004e1	0f b7 94 06 be
	00 00 00	 movzx	 edx, WORD PTR [esi+eax+190]
  004e9	51		 push	 ecx
  004ea	8b 4d f8	 mov	 ecx, DWORD PTR _number$[ebp]
  004ed	52		 push	 edx
  004ee	8d 44 06 77	 lea	 eax, DWORD PTR [esi+eax+119]
  004f2	50		 push	 eax
  004f3	51		 push	 ecx
  004f4	6a 01		 push	 1
  004f6	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 8210 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, gObj[number].Level, gObj[number].GuildNumber);

  004fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00500	8b 94 07 34 04
	00 00		 mov	 edx, DWORD PTR [edi+eax+1076]
  00507	0f b7 8c 07 be
	00 00 00	 movzx	 ecx, WORD PTR [edi+eax+190]
  0050f	52		 push	 edx
  00510	51		 push	 ecx
  00511	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00515	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00518	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0051c	52		 push	 edx
  0051d	53		 push	 ebx
  0051e	51		 push	 ecx
  0051f	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 8211 : 
; 8212 : 			LogAddTD("[%s][%s] Trade Ready [%s][%s]", gObj[number].AccountID, gObj[number].Name, gObj[aIndex].AccountID, gObj[aIndex].Name);

  00524	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00529	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0052d	52		 push	 edx
  0052e	8d 4c 06 6c	 lea	 ecx, DWORD PTR [esi+eax+108]
  00532	51		 push	 ecx
  00533	8d 54 07 77	 lea	 edx, DWORD PTR [edi+eax+119]
  00537	52		 push	 edx
  00538	8d 44 07 6c	 lea	 eax, DWORD PTR [edi+eax+108]
  0053c	50		 push	 eax
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  00542	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00548	83 c4 3c	 add	 esp, 60			; 0000003cH
  0054b	5f		 pop	 edi
  0054c	5e		 pop	 esi
  0054d	5b		 pop	 ebx

; 8232 : 			}
; 8233 : 		}
; 8234 : 	}
; 8235 : }

  0054e	8b e5		 mov	 esp, ebp
  00550	5d		 pop	 ebp
  00551	c3		 ret	 0
$LN19@CGTradeRes:

; 8145 : 	{
; 8146 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[number].AccountID, gObj[number].Name, gObj[number].m_IfState.use, gObj[number].m_IfState.type);

  00552	8b d1		 mov	 edx, ecx
  00554	c1 ea 06	 shr	 edx, 6
  00557	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0055d	52		 push	 edx
  0055e	83 e1 03	 and	 ecx, 3
  00561	51		 push	 ecx
  00562	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  00566	8d 54 07 6c	 lea	 edx, DWORD PTR [edi+eax+108]

; 8147 : 		return;

  0056a	eb 18		 jmp	 SHORT $LN56@CGTradeRes
$LN21@CGTradeRes:

; 8139 : 	{
; 8140 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.use, gObj[aIndex].m_IfState.type);

  0056c	8b d1		 mov	 edx, ecx
  0056e	c1 ea 06	 shr	 edx, 6
  00571	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00577	52		 push	 edx
  00578	83 e1 03	 and	 ecx, 3
  0057b	51		 push	 ecx
  0057c	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00580	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
$LN56@CGTradeRes:
  00584	51		 push	 ecx
  00585	52		 push	 edx
  00586	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@
  0058b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00591	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGTradeRes:
  00594	5f		 pop	 edi
  00595	5e		 pop	 esi
  00596	5b		 pop	 ebx

; 8232 : 			}
; 8233 : 		}
; 8234 : 	}
; 8235 : }

  00597	8b e5		 mov	 esp, ebp
  00599	5d		 pop	 ebp
  0059a	c3		 ret	 0
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ENDP ; CGTradeResponseRecv
_TEXT	ENDS
PUBLIC	?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z	; CGTradeMoneyRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z
_TEXT	SEGMENT
tv326 = -8						; size = 4
_pMsg$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z PROC	; CGTradeMoneyRecv, COMDAT

; 8298 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8299 : 	PMSG_DEFRESULT pMsg;
; 8300 : 	int money = 0;
; 8301 : 	int number;
; 8302 : 
; 8303 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00010	8b f7		 mov	 esi, edi
  00012	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00018	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	0f 84 c9 01 00
	00		 je	 $LN1@CGTradeMon

; 8304 : 		return;
; 8305 : 
; 8306 : 	if ( !OBJMAX_RANGE(aIndex) )

  0002c	85 ff		 test	 edi, edi
  0002e	78 0f		 js	 SHORT $LN17@CGTradeMon
  00030	33 c0		 xor	 eax, eax
  00032	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00038	0f 9e c0	 setle	 al
  0003b	85 c0		 test	 eax, eax
  0003d	75 1f		 jne	 SHORT $LN9@CGTradeMon
$LN17@CGTradeMon:

; 8307 : 	{
; 8308 : 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, aIndex);

  0003f	57		 push	 edi
  00040	68 74 20 00 00	 push	 8308			; 00002074H
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 8370 : 	}
; 8371 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN9@CGTradeMon:

; 8309 : 		return;
; 8310 : 	}
; 8311 : 
; 8312 : 	if ( gObj[aIndex].CloseType != -1 )

  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00067	80 ca ff	 or	 dl, -1
  0006a	38 50 0b	 cmp	 BYTE PTR [eax+11], dl
  0006d	74 27		 je	 SHORT $LN8@CGTradeMon

; 8313 : 	{
; 8314 : 		LogAdd(lMsg.Get(MSGGET(1, 231)), gObj[aIndex].AccountID, gObj[aIndex].Name);

  0006f	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  00072	52		 push	 edx
  00073	83 c0 6c	 add	 eax, 108		; 0000006cH
  00076	50		 push	 eax
  00077	68 e7 01 00 00	 push	 487			; 000001e7H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00081	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 8370 : 	}
; 8371 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
$LN8@CGTradeMon:

; 8315 : 		return;
; 8316 : 	}
; 8317 : 
; 8318 : 	number = gObj[aIndex].TargetNumber;

  00096	0f bf b8 58 04
	00 00		 movsx	 edi, WORD PTR [eax+1112]
  0009d	53		 push	 ebx

; 8319 : 
; 8320 : 	if ( !OBJMAX_RANGE(number) )

  0009e	85 ff		 test	 edi, edi
  000a0	78 0f		 js	 SHORT $LN18@CGTradeMon
  000a2	33 db		 xor	 ebx, ebx
  000a4	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  000aa	0f 9e c3	 setle	 bl
  000ad	85 db		 test	 ebx, ebx
  000af	75 29		 jne	 SHORT $LN7@CGTradeMon
$LN18@CGTradeMon:

; 8321 : 	{
; 8322 : 		LogAdd(lMsg.Get(MSGGET(1, 232)), gObj[aIndex].AccountID, gObj[aIndex].Name, number);

  000b1	57		 push	 edi
  000b2	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  000b5	51		 push	 ecx
  000b6	83 c0 6c	 add	 eax, 108		; 0000006cH
  000b9	50		 push	 eax
  000ba	68 e8 01 00 00	 push	 488			; 000001e8H
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c4	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d0	83 c4 10	 add	 esp, 16			; 00000010H
  000d3	5b		 pop	 ebx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi

; 8370 : 	}
; 8371 : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
$LN7@CGTradeMon:

; 8323 : 		return;
; 8324 : 	}
; 8325 : 
; 8326 : 	if ( gObj[number].CloseType != -1 )

  000da	8b df		 mov	 ebx, edi
  000dc	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  000e2	38 54 0b 0b	 cmp	 BYTE PTR [ebx+ecx+11], dl
  000e6	74 32		 je	 SHORT $LN6@CGTradeMon

; 8327 : 	{
; 8328 : 		LogAdd(lMsg.Get(MSGGET(1, 233)), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name);

  000e8	8d 54 0b 77	 lea	 edx, DWORD PTR [ebx+ecx+119]
  000ec	52		 push	 edx
  000ed	8d 4c 0b 6c	 lea	 ecx, DWORD PTR [ebx+ecx+108]
  000f1	51		 push	 ecx
  000f2	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  000f5	52		 push	 edx
  000f6	83 c0 6c	 add	 eax, 108		; 0000006cH
  000f9	50		 push	 eax
  000fa	68 e9 01 00 00	 push	 489			; 000001e9H
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00104	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00109	50		 push	 eax
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	5b		 pop	 ebx
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi

; 8370 : 	}
; 8371 : }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
$LN6@CGTradeMon:

; 8329 : 		return;
; 8330 : 	}
; 8331 : 
; 8332 : 	if ( gObj[aIndex].m_IfState.use == FALSE && gObj[aIndex].m_IfState.type != 1 )

  0011a	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  00120	f6 c1 03	 test	 cl, 3
  00123	75 0f		 jne	 SHORT $LN5@CGTradeMon
  00125	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0012b	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0012e	0f 85 c0 00 00
	00		 jne	 $LN19@CGTradeMon
$LN5@CGTradeMon:

; 8333 : 	{
; 8334 : 		return;
; 8335 : 	}
; 8336 : 
; 8337 : 	if ( ::gObjCanItemTouch(&gObj[aIndex], 1) == FALSE )

  00134	6a 01		 push	 1
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  0013c	83 c4 08	 add	 esp, 8
  0013f	85 c0		 test	 eax, eax
  00141	0f 84 ad 00 00
	00		 je	 $LN19@CGTradeMon

; 8338 : 	{
; 8339 : 		return;
; 8340 : 	}
; 8341 : 
; 8342 : 	if ( lpMsg->Money > 999999999 )

  00147	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014d	89 4d f8	 mov	 DWORD PTR tv326[ebp], ecx
  00150	81 f9 ff c9 9a
	3b		 cmp	 ecx, 999999999		; 3b9ac9ffH
  00156	0f 87 98 00 00
	00		 ja	 $LN19@CGTradeMon

; 8343 : 	{
; 8344 : 		return;
; 8345 : 	}
; 8346 : 
; 8347 : 	money = lpMsg->Money;
; 8348 : 
; 8349 : 	if ( (gObj[aIndex].Money - money) < 0 )

  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00162	8b 84 16 f0 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+240]
  00169	2b c1		 sub	 eax, ecx
  0016b	0f 88 83 00 00
	00		 js	 $LN19@CGTradeMon

; 8350 : 	{
; 8351 : 		return;
; 8352 : 	}
; 8353 : 
; 8354 : 	GCMoneySend(aIndex, gObj[aIndex].Money - money);

  00171	50		 push	 eax
  00172	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 8355 : 
; 8356 : 	PHeadSetB((LPBYTE)&pMsg, 0x3A, sizeof(pMsg));

  0017b	6a 04		 push	 4
  0017d	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00180	6a 3a		 push	 58			; 0000003aH
  00182	51		 push	 ecx
  00183	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8357 : 	pMsg.result = 1;
; 8358 : 
; 8359 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00188	0f b6 55 fd	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0018c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0018f	52		 push	 edx
  00190	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00193	50		 push	 eax
  00194	51		 push	 ecx
  00195	c6 45 ff 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  00199	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8360 : 
; 8361 : 	if ( number >= 0)
; 8362 : 	{
; 8363 : 		gObj[aIndex].TradeMoney = money;

  0019e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a4	8b 45 f8	 mov	 eax, DWORD PTR tv326[ebp]
  001a7	89 84 16 54 0e
	00 00		 mov	 DWORD PTR [esi+edx+3668], eax

; 8364 : 		gObj[aIndex].TradeOk  = false;

  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b4	c6 84 0e 58 0e
	00 00 00	 mov	 BYTE PTR [esi+ecx+3672], 0

; 8365 : 		gObj[number].TradeOk  = false;

  001bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8366 : 
; 8367 : 		GCTradeOkButtonSend(number, 2);

  001c2	6a 02		 push	 2
  001c4	57		 push	 edi
  001c5	c6 84 13 58 0e
	00 00 00	 mov	 BYTE PTR [ebx+edx+3672], 0
  001cd	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 8368 : 		GCTradeOkButtonSend(aIndex, 0);

  001d2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001d5	6a 00		 push	 0
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 8369 : 		GCTradeMoneyOther(number, gObj[aIndex].TradeMoney);

  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e3	8b 94 0e 54 0e
	00 00		 mov	 edx, DWORD PTR [esi+ecx+3668]
  001ea	52		 push	 edx
  001eb	57		 push	 edi
  001ec	e8 00 00 00 00	 call	 ?GCTradeMoneyOther@@YAHHK@Z ; GCTradeMoneyOther
  001f1	83 c4 38	 add	 esp, 56			; 00000038H
$LN19@CGTradeMon:
  001f4	5b		 pop	 ebx
$LN1@CGTradeMon:
  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi

; 8370 : 	}
; 8371 : }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ENDP	; CGTradeMoneyRecv
_TEXT	ENDS
PUBLIC	?CGTradeCancelButtonRecv@@YAXH@Z		; CGTradeCancelButtonRecv
EXTRN	?gObjTradeCancel@@YAXH@Z:PROC			; gObjTradeCancel
; Function compile flags: /Ogtp
;	COMDAT ?CGTradeCancelButtonRecv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGTradeCancelButtonRecv@@YAXH@Z PROC			; CGTradeCancelButtonRecv, COMDAT

; 8455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8456 : 	int number = gObj[aIndex].TargetNumber;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000e	8b c7		 mov	 eax, edi
  00010	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00016	0f bf b4 08 58
	04 00 00	 movsx	 esi, WORD PTR [eax+ecx+1112]

; 8457 : 	gObjTradeCancel(aIndex);

  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 8458 : 	CGTradeResult(aIndex, 0);

  00024	6a 00		 push	 0
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8459 : 
; 8460 : 	if ( number >= 0 )

  0002f	85 f6		 test	 esi, esi
  00031	78 11		 js	 SHORT $LN1@CGTradeCan

; 8461 : 	{
; 8462 : 		gObjTradeCancel(number);

  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 8463 : 		CGTradeResult(number, 0);

  00039	6a 00		 push	 0
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGTradeCan:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 8464 : 	}
; 8465 : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?CGTradeCancelButtonRecv@@YAXH@Z ENDP			; CGTradeCancelButtonRecv
_TEXT	ENDS
PUBLIC	??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ ; `string'
PUBLIC	??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@ ; `string'
PUBLIC	??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ ; `string'
PUBLIC	??_C@_0DI@ONJOHKCH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ ; `string'
PUBLIC	??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@ ; `string'
PUBLIC	??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ ; `string'
PUBLIC	??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@ ; `string'
PUBLIC	??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@ ; `string'
PUBLIC	??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@ ; `string'
PUBLIC	??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@ ; `string'
PUBLIC	??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@ ; `string'
PUBLIC	?CGPShopReqSetItemPriceEx@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE_EX@@H@Z ; CGPShopReqSetItemPriceEx
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?CheckPrice@PersonalShopZt@@QAE_NHHHHHHH@Z:PROC	; PersonalShopZt::CheckPrice
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
;	COMDAT ??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
CONST	SEGMENT
??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ DB '['
	DB	'PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
CONST	SEGMENT
??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Price Change - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
CONST	SEGMENT
??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ DB '['
	DB	'PShop] [%s][%s] Changing Item Price : %d (B: %d, S: %d, C: %d'
	DB	') (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@ONJOHKCH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
CONST	SEGMENT
??_C@_0DI@ONJOHKCH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ DB '['
	DB	'PShop] [%s][%s] ERROR : Personal Shop Item Check Price', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
CONST	SEGMENT
??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@ DB 'e'
	DB	'rror-L2 : CopyItem [%s][%s] return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
CONST	SEGMENT
??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
CONST	SEGMENT
??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Does Not Exist : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
CONST	SEGMENT
??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Position Out of Bound : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
CONST	SEGMENT
??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@ DB '['
	DB	'PShop] [%s][%s] ERROR : Level is Under 6 : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
CONST	SEGMENT
??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@ DB '[PS'
	DB	'hop] ERROR : Index is not CHARACTER : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
CONST	SEGMENT
??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@ DB '[PS'
	DB	'hop] ERROR : Index is not CONNECTED : %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqSetItemPriceEx@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE_EX@@H@Z
_TEXT	SEGMENT
_iCreditPrice$ = -28					; size = 4
_aLifeCnt$ = -24					; size = 2
_aChaosCnt$ = -20					; size = 2
_aSoulCnt$ = -16					; size = 2
_aBlessCnt$ = -12					; size = 2
_iBonusPrice$ = -8					; size = 4
_iItemPrice$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqSetItemPriceEx@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE_EX@@H@Z PROC ; CGPShopReqSetItemPriceEx, COMDAT

; 8491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 8492 : 	if ( gDoPShopOpen  == FALSE )

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000d	75 1a		 jne	 SHORT $LN13@CGPShopReq@2

; 8493 : 	{
; 8494 : 		CGPShopAnsSetItemPrice(aIndex, 0, lpMsg->btItemPos);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00012	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00016	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00019	51		 push	 ecx
  0001a	6a 00		 push	 0
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8615 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN13@CGPShopReq@2:
  00029	57		 push	 edi

; 8495 : 		return;
; 8496 : 	}
; 8497 : 
; 8498 : 	if ( !gObjIsConnected(aIndex))

  0002a	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	75 14		 jne	 SHORT $LN12@CGPShopReq@2

; 8499 : 	{
; 8500 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  0003a	57		 push	 edi
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00046	83 c4 08	 add	 esp, 8
  00049	5f		 pop	 edi

; 8615 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN12@CGPShopReq@2:
  0004e	53		 push	 ebx

; 8501 : 		return;
; 8502 : 	}
; 8503 : 
; 8504 : 	if ( gObj[aIndex].Type != OBJ_USER )

  0004f	8b df		 mov	 ebx, edi
  00051	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00057	56		 push	 esi
  00058	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	66 83 7c 33 68
	01		 cmp	 WORD PTR [ebx+esi+104], 1
  00064	74 16		 je	 SHORT $LN11@CGPShopReq@2

; 8505 : 	{
; 8506 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00066	57		 push	 edi
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00072	83 c4 08	 add	 esp, 8
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	5f		 pop	 edi

; 8615 : }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN11@CGPShopReq@2:

; 8507 : 		return;
; 8508 : 	}
; 8509 : 
; 8510 : 	if ( gObj[aIndex].Level <= 5 )

  0007c	0f b7 84 33 be
	00 00 00	 movzx	 eax, WORD PTR [ebx+esi+190]
  00084	66 83 f8 05	 cmp	 ax, 5
  00088	7f 31		 jg	 SHORT $LN10@CGPShopReq@2

; 8511 : 	{
; 8512 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);

  0008a	98		 cwde
  0008b	50		 push	 eax
  0008c	8d 4c 33 77	 lea	 ecx, DWORD PTR [ebx+esi+119]
  00090	51		 push	 ecx
  00091	8d 54 33 6c	 lea	 edx, DWORD PTR [ebx+esi+108]
  00095	52		 push	 edx
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8513 : 		CGPShopAnsSetItemPrice(aIndex, 5, lpMsg->btItemPos);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a4	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000a8	51		 push	 ecx
  000a9	6a 05		 push	 5
  000ab	57		 push	 edi

; 8565 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  000ac	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000b1	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	5f		 pop	 edi

; 8615 : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
$LN10@CGPShopReq@2:

; 8514 : 		return;
; 8515 : 	}
; 8516 : 
; 8517 : 	if ( INVENTORY_RANGE(lpMsg->btItemPos) == FALSE )

  000bb	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  000be	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  000c1	b2 eb		 mov	 dl, 235			; 000000ebH
  000c3	3a d0		 cmp	 dl, al
  000c5	1b c9		 sbb	 ecx, ecx
  000c7	41		 inc	 ecx
  000c8	75 33		 jne	 SHORT $LN9@CGPShopReq@2

; 8518 : 	{
; 8519 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Position Out of Bound : %d",
; 8520 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);

  000ca	0f b6 c0	 movzx	 eax, al
  000cd	50		 push	 eax
  000ce	8d 4c 33 77	 lea	 ecx, DWORD PTR [ebx+esi+119]
  000d2	51		 push	 ecx
  000d3	8d 54 33 6c	 lea	 edx, DWORD PTR [ebx+esi+108]
  000d7	52		 push	 edx
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8521 : 		CGPShopAnsSetItemPrice(aIndex, 2, lpMsg->btItemPos);

  000e3	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000e7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000ea	50		 push	 eax
  000eb	6a 02		 push	 2
  000ed	51		 push	 ecx

; 8565 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  000ee	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000f3	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	5f		 pop	 edi

; 8615 : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN9@CGPShopReq@2:

; 8522 : 		return;
; 8523 : 	}
; 8524 : 
; 8525 : 	if ( gObj[aIndex].Inventory1[lpMsg->btItemPos].IsItem() == FALSE )

  000fd	0f b6 c8	 movzx	 ecx, al
  00100	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00106	03 8c 33 34 0e
	00 00		 add	 ecx, DWORD PTR [ebx+esi+3636]
  0010d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00112	85 c0		 test	 eax, eax
  00114	75 39		 jne	 SHORT $LN8@CGPShopReq@2

; 8526 : 	{
; 8527 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Does Not Exist : %d",
; 8528 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);

  00116	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	52		 push	 edx
  00120	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  00124	51		 push	 ecx
  00125	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  00129	52		 push	 edx
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8529 : 		CGPShopAnsSetItemPrice(aIndex, 3, lpMsg->btItemPos);

  00135	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0013c	50		 push	 eax
  0013d	6a 03		 push	 3
  0013f	51		 push	 ecx

; 8565 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  00140	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00145	83 c4 1c	 add	 esp, 28			; 0000001cH
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	5f		 pop	 edi

; 8615 : }

  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
$LN8@CGPShopReq@2:

; 8530 : 		return;
; 8531 : 	}
; 8532 : 
; 8533 : 	CItem * sitem = &gObj[aIndex].Inventory1[lpMsg->btItemPos];

  0014f	0f b6 77 04	 movzx	 esi, BYTE PTR [edi+4]

; 8534 : 	int iItemPrice = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->sItemPrice4, lpMsg->sItemPrice3), MAKE_NUMBERW(lpMsg->sItemPrice2, lpMsg->sItemPrice1));

  00153	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  00157	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  0015d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00163	03 b4 13 34 0e
	00 00		 add	 esi, DWORD PTR [ebx+edx+3636]
  0016a	0f b6 57 06	 movzx	 edx, BYTE PTR [edi+6]
  0016e	0f b6 4f 07	 movzx	 ecx, BYTE PTR [edi+7]
  00172	66 c1 e0 08	 shl	 ax, 8
  00176	0f b7 c0	 movzx	 eax, ax
  00179	0b c1		 or	 eax, ecx
  0017b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0017e	66 c1 e2 08	 shl	 dx, 8
  00182	0f b7 ca	 movzx	 ecx, dx
  00185	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  00189	0b ca		 or	 ecx, edx
  0018b	0b c1		 or	 eax, ecx

; 8535 : 
; 8536 : #if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 8537 : 	int iBonusPrice = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->sBonusPrice4, lpMsg->sBonusPrice3), MAKE_NUMBERW(lpMsg->sBonusPrice2, lpMsg->sBonusPrice1));

  0018d	0f b6 57 0a	 movzx	 edx, BYTE PTR [edi+10]
  00191	0f b6 4f 0b	 movzx	 ecx, BYTE PTR [edi+11]
  00195	89 45 fc	 mov	 DWORD PTR _iItemPrice$[ebp], eax
  00198	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  0019c	66 c1 e0 08	 shl	 ax, 8
  001a0	0f b7 c0	 movzx	 eax, ax
  001a3	0b c1		 or	 eax, ecx
  001a5	c1 e0 10	 shl	 eax, 16			; 00000010H
  001a8	66 c1 e2 08	 shl	 dx, 8
  001ac	0f b7 ca	 movzx	 ecx, dx
  001af	0f b6 57 09	 movzx	 edx, BYTE PTR [edi+9]
  001b3	0b ca		 or	 ecx, edx
  001b5	0b c1		 or	 eax, ecx

; 8538 : 	short aBlessCnt = MAKE_NUMBERW(lpMsg->sBlessCnt2,lpMsg->sBlessCnt1);

  001b7	0f b6 4f 0d	 movzx	 ecx, BYTE PTR [edi+13]
  001bb	89 45 f8	 mov	 DWORD PTR _iBonusPrice$[ebp], eax
  001be	0f b6 47 0e	 movzx	 eax, BYTE PTR [edi+14]
  001c2	66 c1 e0 08	 shl	 ax, 8
  001c6	66 0b c1	 or	 ax, cx

; 8539 : 	short aSoulCnt = MAKE_NUMBERW(lpMsg->sSoulCnt2,lpMsg->sSoulCnt1);

  001c9	0f b6 4f 0f	 movzx	 ecx, BYTE PTR [edi+15]
  001cd	0f b7 d0	 movzx	 edx, ax
  001d0	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  001d4	66 c1 e0 08	 shl	 ax, 8
  001d8	66 0b c1	 or	 ax, cx

; 8540 : 	short aChaosCnt = MAKE_NUMBERW(lpMsg->sChaosCnt2,lpMsg->sChaosCnt1);

  001db	0f b6 4f 11	 movzx	 ecx, BYTE PTR [edi+17]
  001df	89 55 f4	 mov	 DWORD PTR _aBlessCnt$[ebp], edx
  001e2	0f b7 d0	 movzx	 edx, ax
  001e5	0f b6 47 12	 movzx	 eax, BYTE PTR [edi+18]
  001e9	66 c1 e0 08	 shl	 ax, 8
  001ed	66 0b c1	 or	 ax, cx

; 8541 : 	short aLifeCnt = MAKE_NUMBERW(lpMsg->sLifeCnt2,lpMsg->sLifeCnt1);

  001f0	0f b6 4f 13	 movzx	 ecx, BYTE PTR [edi+19]
  001f4	89 55 f0	 mov	 DWORD PTR _aSoulCnt$[ebp], edx
  001f7	0f b7 d0	 movzx	 edx, ax
  001fa	0f b6 47 14	 movzx	 eax, BYTE PTR [edi+20]
  001fe	66 c1 e0 08	 shl	 ax, 8
  00202	66 0b c1	 or	 ax, cx

; 8542 : 	int iCreditPrice = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->sCreditPrice4, lpMsg->sCreditPrice3), MAKE_NUMBERW(lpMsg->sCreditPrice2, lpMsg->sCreditPrice1));

  00205	0f b6 4f 17	 movzx	 ecx, BYTE PTR [edi+23]
  00209	89 55 ec	 mov	 DWORD PTR _aChaosCnt$[ebp], edx
  0020c	0f b7 d0	 movzx	 edx, ax
  0020f	0f b6 47 18	 movzx	 eax, BYTE PTR [edi+24]
  00213	66 c1 e0 08	 shl	 ax, 8
  00217	89 55 e8	 mov	 DWORD PTR _aLifeCnt$[ebp], edx
  0021a	0f b6 57 16	 movzx	 edx, BYTE PTR [edi+22]
  0021e	0f b7 c0	 movzx	 eax, ax
  00221	0b c1		 or	 eax, ecx
  00223	66 c1 e2 08	 shl	 dx, 8
  00227	0f b7 ca	 movzx	 ecx, dx
  0022a	0f b6 57 15	 movzx	 edx, BYTE PTR [edi+21]
  0022e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00231	0b ca		 or	 ecx, edx
  00233	0b c1		 or	 eax, ecx

; 8543 : #endif
; 8544 : 	if ( gObjCheckSerial0ItemList(sitem) != FALSE )

  00235	56		 push	 esi
  00236	89 45 e4	 mov	 DWORD PTR _iCreditPrice$[ebp], eax
  00239	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0023e	83 c4 04	 add	 esp, 4
  00241	85 c0		 test	 eax, eax
  00243	74 79		 je	 SHORT $LN7@CGPShopReq@2

; 8545 : 	{
; 8546 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  00245	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0024a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0024f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00254	50		 push	 eax
  00255	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 8547 : 		GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0025e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00263	8b 8c 03 54 01
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+340]
  0026a	d9 84 03 fc 00
	00 00		 fld	 DWORD PTR [ebx+eax+252]
  00271	83 c4 08	 add	 esp, 8
  00274	51		 push	 ecx
  00275	6a 01		 push	 1
  00277	68 fd 00 00 00	 push	 253			; 000000fdH
  0027c	e8 00 00 00 00	 call	 __ftol2_sse
  00281	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00284	50		 push	 eax
  00285	52		 push	 edx
  00286	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 8548 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)",
; 8549 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->GetName(), lpMsg->btItemPos);

  0028b	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0028f	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00295	83 c4 14	 add	 esp, 20			; 00000014H
  00298	51		 push	 ecx
  00299	8b ce		 mov	 ecx, esi
  0029b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  002a0	50		 push	 eax
  002a1	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  002a4	52		 push	 edx
  002a5	83 c3 6c	 add	 ebx, 108		; 0000006cH
  002a8	53		 push	 ebx
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002b4	83 c4 14	 add	 esp, 20			; 00000014H
  002b7	5e		 pop	 esi
  002b8	5b		 pop	 ebx
  002b9	5f		 pop	 edi

; 8615 : }

  002ba	8b e5		 mov	 esp, ebp
  002bc	5d		 pop	 ebp
  002bd	c3		 ret	 0
$LN7@CGPShopReq@2:

; 8550 : 		return;
; 8551 : 	}
; 8552 : 
; 8553 : 	if ( gObjInventorySearchSerialNumber(&gObj[aIndex], sitem->GetNumber()) == FALSE )

  002be	8b ce		 mov	 ecx, esi
  002c0	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  002c5	50		 push	 eax
  002c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cb	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  002ce	51		 push	 ecx
  002cf	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  002d4	83 c4 08	 add	 esp, 8
  002d7	85 c0		 test	 eax, eax
  002d9	75 58		 jne	 SHORT $LN6@CGPShopReq@2

; 8554 : 	{
; 8555 : 		GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  002db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e0	8b 94 03 54 01
	00 00		 mov	 edx, DWORD PTR [ebx+eax+340]
  002e7	d9 84 03 fc 00
	00 00		 fld	 DWORD PTR [ebx+eax+252]
  002ee	52		 push	 edx
  002ef	6a 01		 push	 1
  002f1	68 fd 00 00 00	 push	 253			; 000000fdH
  002f6	e8 00 00 00 00	 call	 __ftol2_sse
  002fb	50		 push	 eax
  002fc	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002ff	50		 push	 eax
  00300	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 8556 : 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 8557 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  00305	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0030a	68 6d 21 00 00	 push	 8557			; 0000216dH
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00314	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  00318	51		 push	 ecx
  00319	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  0031d	52		 push	 edx
  0031e	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00323	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00329	83 c4 28	 add	 esp, 40			; 00000028H
  0032c	5e		 pop	 esi
  0032d	5b		 pop	 ebx
  0032e	5f		 pop	 edi

; 8615 : }

  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c3		 ret	 0
$LN6@CGPShopReq@2:

; 8558 : 		return;
; 8559 : 	}
; 8560 : #if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 8561 : 	if ( iItemPrice < 0 || iBonusPrice < 0 || aBlessCnt < 0 || aSoulCnt < 0 || aChaosCnt < 0 || aLifeCnt < 0 || iCreditPrice < 0)

  00333	83 7d fc 00	 cmp	 DWORD PTR _iItemPrice$[ebp], 0
  00337	0f 8c 9c 01 00
	00		 jl	 $LN18@CGPShopReq@2
  0033d	83 7d f8 00	 cmp	 DWORD PTR _iBonusPrice$[ebp], 0
  00341	0f 8c 92 01 00
	00		 jl	 $LN18@CGPShopReq@2
  00347	66 83 7d f4 00	 cmp	 WORD PTR _aBlessCnt$[ebp], 0
  0034c	0f 8c 87 01 00
	00		 jl	 $LN18@CGPShopReq@2
  00352	66 83 7d f0 00	 cmp	 WORD PTR _aSoulCnt$[ebp], 0
  00357	0f 8c 7c 01 00
	00		 jl	 $LN18@CGPShopReq@2
  0035d	66 83 7d ec 00	 cmp	 WORD PTR _aChaosCnt$[ebp], 0
  00362	0f 8c 71 01 00
	00		 jl	 $LN18@CGPShopReq@2
  00368	8b 55 e8	 mov	 edx, DWORD PTR _aLifeCnt$[ebp]
  0036b	66 85 d2	 test	 dx, dx
  0036e	0f 88 65 01 00
	00		 js	 $LN18@CGPShopReq@2
  00374	8b 4d e4	 mov	 ecx, DWORD PTR _iCreditPrice$[ebp]
  00377	85 c9		 test	 ecx, ecx
  00379	0f 88 5a 01 00
	00		 js	 $LN18@CGPShopReq@2

; 8566 : 		return;
; 8567 : 	}
; 8568 : #else
; 8569 : 	if ( iItemPrice <= 0 )
; 8570 : 	{
; 8571 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d",
; 8572 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue);
; 8573 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);
; 8574 : 		return;
; 8575 : 	}
; 8576 : #endif
; 8577 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  0037f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00384	f6 84 03 10 02
	00 00 0c	 test	 BYTE PTR [ebx+eax+528], 12 ; 0000000cH
  0038c	0f 85 14 01 00
	00		 jne	 $LN2@CGPShopReq@2

; 8582 : 		return;
; 8583 : 	}
; 8584 : #if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 8585 : 	if(!g_PersonalShopZt.CheckPrice(iItemPrice, iBonusPrice, aBlessCnt, aSoulCnt, aChaosCnt, aLifeCnt, iCreditPrice))

  00392	51		 push	 ecx
  00393	0f bf 4d ec	 movsx	 ecx, WORD PTR _aChaosCnt$[ebp]
  00397	0f bf c2	 movsx	 eax, dx
  0039a	0f bf 55 f0	 movsx	 edx, WORD PTR _aSoulCnt$[ebp]
  0039e	50		 push	 eax
  0039f	0f bf 45 f4	 movsx	 eax, WORD PTR _aBlessCnt$[ebp]
  003a3	51		 push	 ecx
  003a4	8b 4d f8	 mov	 ecx, DWORD PTR _iBonusPrice$[ebp]
  003a7	52		 push	 edx
  003a8	8b 55 fc	 mov	 edx, DWORD PTR _iItemPrice$[ebp]
  003ab	50		 push	 eax
  003ac	51		 push	 ecx
  003ad	52		 push	 edx
  003ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PersonalShopZt@@3VPersonalShopZt@@A ; g_PersonalShopZt
  003b3	e8 00 00 00 00	 call	 ?CheckPrice@PersonalShopZt@@QAE_NHHHHHHH@Z ; PersonalShopZt::CheckPrice
  003b8	84 c0		 test	 al, al
  003ba	75 34		 jne	 SHORT $LN1@CGPShopReq@2

; 8586 : 	{
; 8587 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Check Price", gObj[aIndex].AccountID, gObj[aIndex].Name);

  003bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c1	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  003c5	51		 push	 ecx
  003c6	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  003ca	52		 push	 edx
  003cb	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@ONJOHKCH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
  003d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8588 : 		CGPShopAnsSetItemPrice(aIndex, 0, lpMsg->btItemPos);

  003d6	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  003da	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003dd	50		 push	 eax
  003de	6a 00		 push	 0
  003e0	51		 push	 ecx
  003e1	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  003e6	83 c4 18	 add	 esp, 24			; 00000018H
  003e9	5e		 pop	 esi
  003ea	5b		 pop	 ebx
  003eb	5f		 pop	 edi

; 8615 : }

  003ec	8b e5		 mov	 esp, ebp
  003ee	5d		 pop	 ebp
  003ef	c3		 ret	 0
$LN1@CGPShopReq@2:

; 8589 : 		return;
; 8590 : 	}
; 8591 : #endif
; 8592 : 	sitem->m_iPShopValue = iItemPrice;
; 8593 : #if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 8594 : 	sitem->m_iPShopBonus = iBonusPrice;

  003f0	8b 45 f8	 mov	 eax, DWORD PTR _iBonusPrice$[ebp]
  003f3	8b 55 fc	 mov	 edx, DWORD PTR _iItemPrice$[ebp]

; 8595 : 	sitem->m_PShopBlessValue = aBlessCnt;

  003f6	0f b7 4d f4	 movzx	 ecx, WORD PTR _aBlessCnt$[ebp]
  003fa	89 46 78	 mov	 DWORD PTR [esi+120], eax

; 8596 : 	sitem->m_PShopSoulValue = aSoulCnt;
; 8597 : 	sitem->m_PShopChaosValue = aChaosCnt;

  003fd	66 8b 45 ec	 mov	 ax, WORD PTR _aChaosCnt$[ebp]
  00401	66 89 86 80 00
	00 00		 mov	 WORD PTR [esi+128], ax

; 8598 : 	sitem->m_PShopLifeValue = aLifeCnt;
; 8599 : 	#if(DEV_PERSONAL_CREDIT)
; 8600 : 	sitem->m_iPShopCredit = iCreditPrice;
; 8601 : 	#endif
; 8602 : #endif
; 8603 : 	ItemAttribute[sitem->m_Type].Name[31] = 0;

  00408	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  0040c	89 56 74	 mov	 DWORD PTR [esi+116], edx
  0040f	6b c0 70	 imul	 eax, 112		; 00000070H
  00412	66 8b 55 f0	 mov	 dx, WORD PTR _aSoulCnt$[ebp]
  00416	66 89 56 7e	 mov	 WORD PTR [esi+126], dx
  0041a	8b 55 e4	 mov	 edx, DWORD PTR _iCreditPrice$[ebp]
  0041d	66 89 4e 7c	 mov	 WORD PTR [esi+124], cx
  00421	0f b7 4d e8	 movzx	 ecx, WORD PTR _aLifeCnt$[ebp]
  00425	89 96 84 00 00
	00		 mov	 DWORD PTR [esi+132], edx

; 8604 : #if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 8605 : 	LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (B: %d, S: %d, C: %d) (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d",
; 8606 : 		gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue,
; 8607 : 		sitem->m_PShopBlessValue,sitem->m_PShopSoulValue,sitem->m_PShopChaosValue,sitem->m_Type, 
; 8608 : 		ItemAttribute[sitem->m_Type].Name, sitem->m_Level, sitem->m_Number,
; 8609 : 		sitem->m_Durability);

  0042b	83 ec 08	 sub	 esp, 8
  0042e	66 89 8e 82 00
	00 00		 mov	 WORD PTR [esi+130], cx
  00435	c6 80 1f 00 00
	00 00		 mov	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+31], 0
  0043c	8b 16		 mov	 edx, DWORD PTR [esi]
  0043e	d9 46 24	 fld	 DWORD PTR [esi+36]
  00441	0f bf 46 06	 movsx	 eax, WORD PTR [esi+6]
  00445	dd 1c 24	 fstp	 QWORD PTR [esp]
  00448	52		 push	 edx
  00449	0f bf 56 08	 movsx	 edx, WORD PTR [esi+8]
  0044d	52		 push	 edx
  0044e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00454	8b d0		 mov	 edx, eax
  00456	6b d2 70	 imul	 edx, 112		; 00000070H
  00459	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0045f	52		 push	 edx
  00460	0f bf 56 7e	 movsx	 edx, WORD PTR [esi+126]
  00464	50		 push	 eax
  00465	0f bf 86 80 00
	00 00		 movsx	 eax, WORD PTR [esi+128]
  0046c	50		 push	 eax
  0046d	0f bf 46 7c	 movsx	 eax, WORD PTR [esi+124]
  00471	52		 push	 edx
  00472	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
  00475	50		 push	 eax
  00476	52		 push	 edx
  00477	8d 44 0b 77	 lea	 eax, DWORD PTR [ebx+ecx+119]
  0047b	50		 push	 eax
  0047c	8d 4c 0b 6c	 lea	 ecx, DWORD PTR [ebx+ecx+108]
  00480	51		 push	 ecx
  00481	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8610 : #else
; 8611 : 	LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (Type:%d (%s), Lev:%d, Serial:%u, Dur:%d",
; 8612 : 		gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue, sitem->m_Type, ItemAttribute[sitem->m_Type].Name, sitem->m_Level, sitem->m_Number, sitem->m_Durability);
; 8613 : #endif
; 8614 : 	CGPShopAnsSetItemPrice(aIndex, 1, lpMsg->btItemPos);

  0048c	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00490	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00493	52		 push	 edx
  00494	6a 01		 push	 1
  00496	50		 push	 eax
  00497	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  0049c	83 c4 40	 add	 esp, 64			; 00000040H
  0049f	5e		 pop	 esi
  004a0	5b		 pop	 ebx
  004a1	5f		 pop	 edi

; 8615 : }

  004a2	8b e5		 mov	 esp, ebp
  004a4	5d		 pop	 ebp
  004a5	c3		 ret	 0
$LN2@CGPShopReq@2:

; 8578 : 	{
; 8579 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Price Change - Item Block",
; 8580 : 			gObj[aIndex].AccountID, gObj[aIndex].Name,sitem->m_iPShopValue);

  004a6	8b 4e 74	 mov	 ecx, DWORD PTR [esi+116]
  004a9	51		 push	 ecx
  004aa	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  004ae	52		 push	 edx
  004af	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  004b3	50		 push	 eax
  004b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
  004b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8581 : 		CGPShopAnsSetItemPrice(aIndex, 6, lpMsg->btItemPos);

  004bf	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  004c3	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004c6	51		 push	 ecx
  004c7	6a 06		 push	 6
  004c9	52		 push	 edx
  004ca	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  004cf	83 c4 1c	 add	 esp, 28			; 0000001cH
  004d2	5e		 pop	 esi
  004d3	5b		 pop	 ebx
  004d4	5f		 pop	 edi

; 8615 : }

  004d5	8b e5		 mov	 esp, ebp
  004d7	5d		 pop	 ebp
  004d8	c3		 ret	 0
$LN18@CGPShopReq@2:

; 8562 : 	{
; 8563 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d ",
; 8564 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, iItemPrice);

  004d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004de	8b 4d fc	 mov	 ecx, DWORD PTR _iItemPrice$[ebp]
  004e1	51		 push	 ecx
  004e2	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  004e6	52		 push	 edx
  004e7	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  004eb	50		 push	 eax
  004ec	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
  004f1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8565 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  004f7	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  004fb	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004fe	51		 push	 ecx
  004ff	6a 04		 push	 4
  00501	52		 push	 edx
  00502	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00507	83 c4 1c	 add	 esp, 28			; 0000001cH
  0050a	5e		 pop	 esi
  0050b	5b		 pop	 ebx
  0050c	5f		 pop	 edi

; 8615 : }

  0050d	8b e5		 mov	 esp, ebp
  0050f	5d		 pop	 ebp
  00510	c3		 ret	 0
?CGPShopReqSetItemPriceEx@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE_EX@@H@Z ENDP ; CGPShopReqSetItemPriceEx
_TEXT	ENDS
PUBLIC	??_C@_0FD@CIGJAOKN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ ; `string'
PUBLIC	??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ ; `string'
PUBLIC	?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
;	COMDAT ??_C@_0FD@CIGJAOKN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
CONST	SEGMENT
??_C@_0FD@CIGJAOKN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ DB '['
	DB	'PShop] [%s][%s] Changing Item Price : %d (Type:%d (%s), Lev:%'
	DB	'd, Serial:%u, Dur:%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
CONST	SEGMENT
??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ DB '['
	DB	'PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z
_TEXT	SEGMENT
_iItemPrice$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z PROC ; CGPShopReqSetItemPrice, COMDAT

; 8618 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8619 : 	if ( gDoPShopOpen  == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000b	75 1a		 jne	 SHORT $LN11@CGPShopReq@3

; 8620 : 	{
; 8621 : 		CGPShopAnsSetItemPrice(aIndex, 0, lpMsg->btItemPos);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00010	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00014	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00017	51		 push	 ecx
  00018	6a 00		 push	 0
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8702 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN11@CGPShopReq@3:
  00027	53		 push	 ebx

; 8622 : 		return;
; 8623 : 	}
; 8624 : 
; 8625 : 	if ( !gObjIsConnected(aIndex))

  00028	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0002b	53		 push	 ebx
  0002c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00031	83 c4 04	 add	 esp, 4
  00034	85 c0		 test	 eax, eax
  00036	75 14		 jne	 SHORT $LN10@CGPShopReq@3

; 8626 : 	{
; 8627 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00038	53		 push	 ebx
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00044	83 c4 08	 add	 esp, 8
  00047	5b		 pop	 ebx

; 8702 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN10@CGPShopReq@3:
  0004c	56		 push	 esi

; 8628 : 		return;
; 8629 : 	}
; 8630 : 
; 8631 : 	if ( gObj[aIndex].Type != OBJ_USER )

  0004d	8b f3		 mov	 esi, ebx
  0004f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00055	57		 push	 edi
  00056	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005c	66 83 7c 3e 68
	01		 cmp	 WORD PTR [esi+edi+104], 1
  00062	74 16		 je	 SHORT $LN9@CGPShopReq@3

; 8632 : 	{
; 8633 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00064	53		 push	 ebx
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00070	83 c4 08	 add	 esp, 8
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx

; 8702 : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
$LN9@CGPShopReq@3:

; 8634 : 		return;
; 8635 : 	}
; 8636 : 
; 8637 : 	if ( gObj[aIndex].Level <= 5 )

  0007a	0f b7 84 3e be
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+190]
  00082	66 83 f8 05	 cmp	 ax, 5
  00086	7f 31		 jg	 SHORT $LN8@CGPShopReq@3

; 8638 : 	{
; 8639 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);

  00088	98		 cwde
  00089	50		 push	 eax
  0008a	8d 4c 3e 77	 lea	 ecx, DWORD PTR [esi+edi+119]
  0008e	51		 push	 ecx
  0008f	8d 54 3e 6c	 lea	 edx, DWORD PTR [esi+edi+108]
  00093	52		 push	 edx
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8640 : 		CGPShopAnsSetItemPrice(aIndex, 5, lpMsg->btItemPos);

  0009f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a2	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000a6	51		 push	 ecx
  000a7	6a 05		 push	 5
  000a9	53		 push	 ebx

; 8692 : 		CGPShopAnsSetItemPrice(aIndex, 6, lpMsg->btItemPos);

  000aa	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000af	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx

; 8702 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
$LN8@CGPShopReq@3:

; 8641 : 		return;
; 8642 : 	}
; 8643 : 
; 8644 : 	if ( INVENTORY_RANGE(lpMsg->btItemPos) == FALSE )

  000b9	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  000bc	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  000bf	b2 eb		 mov	 dl, 235			; 000000ebH
  000c1	3a d0		 cmp	 dl, al
  000c3	1b c9		 sbb	 ecx, ecx
  000c5	41		 inc	 ecx
  000c6	75 33		 jne	 SHORT $LN7@CGPShopReq@3

; 8645 : 	{
; 8646 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Position Out of Bound : %d",
; 8647 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);

  000c8	0f b6 c0	 movzx	 eax, al
  000cb	50		 push	 eax
  000cc	8d 4c 3e 77	 lea	 ecx, DWORD PTR [esi+edi+119]
  000d0	51		 push	 ecx
  000d1	8d 54 3e 6c	 lea	 edx, DWORD PTR [esi+edi+108]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8648 : 		CGPShopAnsSetItemPrice(aIndex, 2, lpMsg->btItemPos);

  000e1	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  000e5	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000e8	50		 push	 eax
  000e9	6a 02		 push	 2
  000eb	51		 push	 ecx

; 8692 : 		CGPShopAnsSetItemPrice(aIndex, 6, lpMsg->btItemPos);

  000ec	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000f1	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 8702 : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
$LN7@CGPShopReq@3:

; 8649 : 		return;
; 8650 : 	}
; 8651 : 
; 8652 : 	if ( gObj[aIndex].Inventory1[lpMsg->btItemPos].IsItem() == FALSE )

  000fb	0f b6 c8	 movzx	 ecx, al
  000fe	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00104	03 8c 3e 34 0e
	00 00		 add	 ecx, DWORD PTR [esi+edi+3636]
  0010b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00110	85 c0		 test	 eax, eax
  00112	75 39		 jne	 SHORT $LN6@CGPShopReq@3

; 8653 : 	{
; 8654 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Does Not Exist : %d",
; 8655 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);

  00114	0f b6 53 04	 movzx	 edx, BYTE PTR [ebx+4]
  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011d	52		 push	 edx
  0011e	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00122	51		 push	 ecx
  00123	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00127	52		 push	 edx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8656 : 		CGPShopAnsSetItemPrice(aIndex, 3, lpMsg->btItemPos);

  00133	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00137	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0013a	50		 push	 eax
  0013b	6a 03		 push	 3
  0013d	51		 push	 ecx

; 8692 : 		CGPShopAnsSetItemPrice(aIndex, 6, lpMsg->btItemPos);

  0013e	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00143	83 c4 1c	 add	 esp, 28			; 0000001cH
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx

; 8702 : }

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
$LN6@CGPShopReq@3:

; 8657 : 		return;
; 8658 : 	}
; 8659 : 
; 8660 : 	CItem * sitem = &gObj[aIndex].Inventory1[lpMsg->btItemPos];

  0014d	0f b6 7b 04	 movzx	 edi, BYTE PTR [ebx+4]

; 8661 : 	int iItemPrice = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->sItemPrice4, lpMsg->sItemPrice3), MAKE_NUMBERW(lpMsg->sItemPrice2, lpMsg->sItemPrice1));

  00151	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  00155	69 ff d4 00 00
	00		 imul	 edi, 212		; 000000d4H
  0015b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00161	03 bc 16 34 0e
	00 00		 add	 edi, DWORD PTR [esi+edx+3636]
  00168	0f b6 53 06	 movzx	 edx, BYTE PTR [ebx+6]
  0016c	0f b6 4b 07	 movzx	 ecx, BYTE PTR [ebx+7]
  00170	66 c1 e0 08	 shl	 ax, 8
  00174	0f b7 c0	 movzx	 eax, ax
  00177	0b c1		 or	 eax, ecx
  00179	66 c1 e2 08	 shl	 dx, 8
  0017d	0f b7 ca	 movzx	 ecx, dx
  00180	0f b6 53 05	 movzx	 edx, BYTE PTR [ebx+5]
  00184	c1 e0 10	 shl	 eax, 16			; 00000010H
  00187	0b ca		 or	 ecx, edx
  00189	0b c1		 or	 eax, ecx

; 8662 : 
; 8663 : 	if ( gObjCheckSerial0ItemList(sitem) != FALSE )

  0018b	57		 push	 edi
  0018c	89 45 fc	 mov	 DWORD PTR _iItemPrice$[ebp], eax
  0018f	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00194	83 c4 04	 add	 esp, 4
  00197	85 c0		 test	 eax, eax
  00199	74 79		 je	 SHORT $LN5@CGPShopReq@3

; 8664 : 	{
; 8665 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  0019b	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  001a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001a5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001aa	50		 push	 eax
  001ab	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 8666 : 		GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  001b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b9	8b 8c 06 54 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+340]
  001c0	d9 84 06 fc 00
	00 00		 fld	 DWORD PTR [esi+eax+252]
  001c7	83 c4 08	 add	 esp, 8
  001ca	51		 push	 ecx
  001cb	6a 01		 push	 1
  001cd	68 fd 00 00 00	 push	 253			; 000000fdH
  001d2	e8 00 00 00 00	 call	 __ftol2_sse
  001d7	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001da	50		 push	 eax
  001db	52		 push	 edx
  001dc	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 8667 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)",
; 8668 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->GetName(), lpMsg->btItemPos);

  001e1	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  001e5	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001eb	83 c4 14	 add	 esp, 20			; 00000014H
  001ee	51		 push	 ecx
  001ef	8b cf		 mov	 ecx, edi
  001f1	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001f6	50		 push	 eax
  001f7	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  001fa	52		 push	 edx
  001fb	83 c6 6c	 add	 esi, 108		; 0000006cH
  001fe	56		 push	 esi
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0020a	83 c4 14	 add	 esp, 20			; 00000014H
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	5b		 pop	 ebx

; 8702 : }

  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
$LN5@CGPShopReq@3:

; 8669 : 		return;
; 8670 : 	}
; 8671 : 
; 8672 : 	if ( gObjInventorySearchSerialNumber(&gObj[aIndex], sitem->GetNumber()) == FALSE )

  00214	8b cf		 mov	 ecx, edi
  00216	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0021b	50		 push	 eax
  0021c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00221	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00224	51		 push	 ecx
  00225	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0022a	83 c4 08	 add	 esp, 8
  0022d	85 c0		 test	 eax, eax

; 8673 : 	{
; 8674 : 		GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  0022f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00234	75 53		 jne	 SHORT $LN4@CGPShopReq@3
  00236	8b 94 06 54 01
	00 00		 mov	 edx, DWORD PTR [esi+eax+340]
  0023d	d9 84 06 fc 00
	00 00		 fld	 DWORD PTR [esi+eax+252]
  00244	52		 push	 edx
  00245	6a 01		 push	 1
  00247	68 fd 00 00 00	 push	 253			; 000000fdH
  0024c	e8 00 00 00 00	 call	 __ftol2_sse
  00251	50		 push	 eax
  00252	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 8675 : 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 8676 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00260	68 e4 21 00 00	 push	 8676			; 000021e4H
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0026a	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0026e	51		 push	 ecx
  0026f	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00273	52		 push	 edx
  00274	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0027f	83 c4 28	 add	 esp, 40			; 00000028H
  00282	5f		 pop	 edi
  00283	5e		 pop	 esi
  00284	5b		 pop	 ebx

; 8702 : }

  00285	8b e5		 mov	 esp, ebp
  00287	5d		 pop	 ebp
  00288	c3		 ret	 0
$LN4@CGPShopReq@3:

; 8677 : 		return;
; 8678 : 	}
; 8679 : 
; 8680 : 	if ( iItemPrice <= 0 )

  00289	8b 4d fc	 mov	 ecx, DWORD PTR _iItemPrice$[ebp]
  0028c	85 c9		 test	 ecx, ecx
  0028e	7f 33		 jg	 SHORT $LN3@CGPShopReq@3

; 8681 : 	{
; 8682 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d",
; 8683 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue);

  00290	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  00293	51		 push	 ecx
  00294	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00298	52		 push	 edx
  00299	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0029d	50		 push	 eax
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
  002a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8684 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  002a9	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]

; 8692 : 		CGPShopAnsSetItemPrice(aIndex, 6, lpMsg->btItemPos);

  002ad	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002b0	51		 push	 ecx
  002b1	6a 04		 push	 4
  002b3	52		 push	 edx
  002b4	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  002b9	83 c4 1c	 add	 esp, 28			; 0000001cH
  002bc	5f		 pop	 edi
  002bd	5e		 pop	 esi
  002be	5b		 pop	 ebx

; 8702 : }

  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
$LN3@CGPShopReq@3:

; 8685 : 		return;
; 8686 : 	}
; 8687 : 
; 8688 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  002c3	f6 84 06 10 02
	00 00 0c	 test	 BYTE PTR [esi+eax+528], 12 ; 0000000cH
  002cb	75 6c		 jne	 SHORT $LN1@CGPShopReq@3

; 8693 : 		return;
; 8694 : 	}
; 8695 : 
; 8696 : 	sitem->m_iPShopValue = iItemPrice;
; 8697 : 	ItemAttribute[sitem->m_Type].Name[31] = 0;

  002cd	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  002d1	6b c0 70	 imul	 eax, 112		; 00000070H

; 8698 : 
; 8699 : 	LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (Type:%d (%s), Lev:%d, Serial:%u, Dur:%d",
; 8700 : 		gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue, sitem->m_Type, ItemAttribute[sitem->m_Type].Name, sitem->m_Level, sitem->m_Number, sitem->m_Durability);

  002d4	83 ec 08	 sub	 esp, 8
  002d7	89 4f 74	 mov	 DWORD PTR [edi+116], ecx
  002da	c6 80 1f 00 00
	00 00		 mov	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+31], 0
  002e1	8b 17		 mov	 edx, DWORD PTR [edi]
  002e3	d9 47 24	 fld	 DWORD PTR [edi+36]
  002e6	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  002ea	dd 1c 24	 fstp	 QWORD PTR [esp]
  002ed	52		 push	 edx
  002ee	0f bf 57 08	 movsx	 edx, WORD PTR [edi+8]
  002f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f8	52		 push	 edx
  002f9	8b d0		 mov	 edx, eax
  002fb	6b d2 70	 imul	 edx, 112		; 00000070H
  002fe	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00304	52		 push	 edx
  00305	50		 push	 eax
  00306	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  00309	50		 push	 eax
  0030a	8d 54 0e 77	 lea	 edx, DWORD PTR [esi+ecx+119]
  0030e	52		 push	 edx
  0030f	8d 44 0e 6c	 lea	 eax, DWORD PTR [esi+ecx+108]
  00313	50		 push	 eax
  00314	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CIGJAOKN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
  00319	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8701 : 	CGPShopAnsSetItemPrice(aIndex, 1, lpMsg->btItemPos);

  0031f	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00323	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00326	51		 push	 ecx
  00327	6a 01		 push	 1
  00329	52		 push	 edx
  0032a	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  0032f	83 c4 34	 add	 esp, 52			; 00000034H
  00332	5f		 pop	 edi
  00333	5e		 pop	 esi
  00334	5b		 pop	 ebx

; 8702 : }

  00335	8b e5		 mov	 esp, ebp
  00337	5d		 pop	 ebp
  00338	c3		 ret	 0
$LN1@CGPShopReq@3:

; 8689 : 	{
; 8690 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Price Change - Item Block",
; 8691 : 			gObj[aIndex].AccountID, gObj[aIndex].Name,sitem->m_iPShopValue);

  00339	8b 4f 74	 mov	 ecx, DWORD PTR [edi+116]
  0033c	51		 push	 ecx
  0033d	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00341	52		 push	 edx
  00342	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00346	50		 push	 eax
  00347	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
  0034c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8692 : 		CGPShopAnsSetItemPrice(aIndex, 6, lpMsg->btItemPos);

  00352	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  00356	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00359	51		 push	 ecx
  0035a	6a 06		 push	 6
  0035c	52		 push	 edx
  0035d	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00362	83 c4 1c	 add	 esp, 28			; 0000001cH
  00365	5f		 pop	 edi
  00366	5e		 pop	 esi
  00367	5b		 pop	 ebx

; 8702 : }

  00368	8b e5		 mov	 esp, ebp
  0036a	5d		 pop	 ebp
  0036b	c3		 ret	 0
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ENDP ; CGPShopReqSetItemPrice
_TEXT	ENDS
PUBLIC	??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@ ; `string'
PUBLIC	??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@ ; `string'
PUBLIC	??_C@_0O@EAKBJPFK@No?5Price?5Item?$AA@		; `string'
PUBLIC	??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@ ; `string'
PUBLIC	??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@ ; `string'
PUBLIC	??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@ ; `string'
PUBLIC	??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z	; CGPShopReqOpen
EXTRN	?PShop_CheckInventoryPrice@PersonalShopZt@@QAE_NF@Z:PROC ; PersonalShopZt::PShop_CheckInventoryPrice
;	COMDAT ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@
CONST	SEGMENT
??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@ DB '['
	DB	'PShop] [%s][%s] ERROR : Cant''t Open Shop - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@
CONST	SEGMENT
??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@ DB '['
	DB	'PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EAKBJPFK@No?5Price?5Item?$AA@
CONST	SEGMENT
??_C@_0O@EAKBJPFK@No?5Price?5Item?$AA@ DB 'No Price Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@
CONST	SEGMENT
??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Already Opened - Changing PShop'
	DB	' Name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@
CONST	SEGMENT
??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Opened', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@
CONST	SEGMENT
??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@ DB '['
	DB	'PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@
CONST	SEGMENT
??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@ DB '['
	DB	'PShop] [%s][%s] ERROR : m_IfState.type is Using : %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z
_TEXT	SEGMENT
tv465 = -68						; size = 4
_aIndex$GSCopy$ = -64					; size = 4
_bEnablePShopOpen$ = -57				; size = 1
_pMsg$247413 = -56					; size = 52
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z PROC	; CGPShopReqOpen, COMDAT

; 8723 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 8724 : 	if (::gDoPShopOpen == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 8750 : 	{
; 8751 : 		LogAddTD("[PShop] [%s][%s] ERROR : Cant't Open Shop - Item Block",
; 8752 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  0001f	89 5d c0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  00022	0f 84 53 03 00
	00		 je	 $LN1@CGPShopReq@4

; 8725 : 	{
; 8726 : 		return;
; 8727 : 	}
; 8728 : 
; 8729 : 	if ( !gObjIsConnected(aIndex))

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	75 1f		 jne	 SHORT $LN23@CGPShopReq@4

; 8730 : 	{
; 8731 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d",aIndex);

  00035	53		 push	 ebx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00041	83 c4 08	 add	 esp, 8
  00044	5f		 pop	 edi
  00045	5b		 pop	 ebx

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN23@CGPShopReq@4:

; 8732 : 		return;
; 8733 : 	}
; 8734 : 
; 8735 : 	if ( gObj[aIndex].Type != OBJ_USER )

  00054	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  0005a	56		 push	 esi
  0005b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00061	66 83 7c 33 68
	01		 cmp	 WORD PTR [ebx+esi+104], 1
  00067	74 23		 je	 SHORT $LN22@CGPShopReq@4

; 8736 : 	{
; 8737 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00069	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0006c	50		 push	 eax
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00078	83 c4 08	 add	 esp, 8
  0007b	5e		 pop	 esi
  0007c	5f		 pop	 edi
  0007d	5b		 pop	 ebx

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN22@CGPShopReq@4:

; 8738 : 		return;
; 8739 : 	}
; 8740 : 
; 8741 : 	if ( gObj[aIndex].Level <= 5 )

  0008c	0f b7 84 33 be
	00 00 00	 movzx	 eax, WORD PTR [ebx+esi+190]
  00094	66 83 f8 05	 cmp	 ax, 5
  00098	7f 38		 jg	 SHORT $LN21@CGPShopReq@4

; 8742 : 	{
; 8743 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d",
; 8744 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);

  0009a	0f bf c8	 movsx	 ecx, ax
  0009d	51		 push	 ecx
  0009e	8d 54 33 77	 lea	 edx, DWORD PTR [ebx+esi+119]
  000a2	52		 push	 edx
  000a3	8d 44 33 6c	 lea	 eax, DWORD PTR [ebx+esi+108]
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8745 : 		::CGPShopAnsOpen( aIndex, 2);

  000b3	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  000b6	6a 02		 push	 2
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  000be	83 c4 18	 add	 esp, 24			; 00000018H
  000c1	5e		 pop	 esi
  000c2	5f		 pop	 edi
  000c3	5b		 pop	 ebx

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c7	33 cd		 xor	 ecx, ebp
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
$LN21@CGPShopReq@4:

; 8746 : 		return;
; 8747 : 	}
; 8748 : 
; 8749 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  000d2	f6 84 33 10 02
	00 00 0c	 test	 BYTE PTR [ebx+esi+528], 12 ; 0000000cH
  000da	0f 85 77 02 00
	00		 jne	 $LN19@CGPShopReq@4

; 8754 : 		return;
; 8755 : 	}	
; 8756 : 
; 8757 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000e0	0f b6 84 33 49
	01 00 00	 movzx	 eax, BYTE PTR [ebx+esi+329]
  000e8	3c 35		 cmp	 al, 53			; 00000035H
  000ea	74 0d		 je	 SHORT $LN31@CGPShopReq@4
  000ec	3c 12		 cmp	 al, 18			; 00000012H
  000ee	72 2c		 jb	 SHORT $LN18@CGPShopReq@4
  000f0	b2 17		 mov	 dl, 23			; 00000017H
  000f2	3a d0		 cmp	 dl, al
  000f4	1b c0		 sbb	 eax, eax
  000f6	40		 inc	 eax
  000f7	74 23		 je	 SHORT $LN18@CGPShopReq@4
$LN31@CGPShopReq@4:

; 8758 : 	{
; 8759 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 197)), aIndex, 1);

  000f9	8b 75 c0	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  000fc	6a 01		 push	 1
  000fe	56		 push	 esi
  000ff	68 c5 04 00 00	 push	 1221			; 000004c5H
  00104	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00109	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8760 : 		::CGPShopAnsOpen( aIndex, 0);

  00114	6a 00		 push	 0
  00116	56		 push	 esi

; 8761 : 		return;

  00117	e9 56 02 00 00	 jmp	 $LN34@CGPShopReq@4
$LN18@CGPShopReq@4:

; 8762 : 	}	
; 8763 : 
; 8764 : 	bool bEnablePShopOpen = false;
; 8765 : 
; 8766 : 	if ( gObj[aIndex].m_IfState.use == FALSE )

  0011c	8b 84 33 1c 0e
	00 00		 mov	 eax, DWORD PTR [ebx+esi+3612]
  00123	8b c8		 mov	 ecx, eax
  00125	83 e1 03	 and	 ecx, 3
  00128	c6 45 c7 00	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 0
  0012c	75 06		 jne	 SHORT $LN17@CGPShopReq@4

; 8767 : 	{
; 8768 : 		bEnablePShopOpen  = true;

  0012e	c6 45 c7 01	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 1

; 8769 : 	}
; 8770 : 	else

  00132	eb 34		 jmp	 SHORT $LN11@CGPShopReq@4
$LN17@CGPShopReq@4:

; 8771 : 	{
; 8772 : 		if ( gObj[aIndex].m_IfState.use == TRUE )
; 8773 : 		{
; 8774 : 			switch ( gObj[aIndex].m_IfState.type )

  00134	c1 e8 06	 shr	 eax, 6
  00137	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0013c	83 f9 01	 cmp	 ecx, 1
  0013f	0f 85 e8 01 00
	00		 jne	 $LN15@CGPShopReq@4
  00145	83 f8 08	 cmp	 eax, 8
  00148	75 05		 jne	 SHORT $LN32@CGPShopReq@4

; 8775 : 			{
; 8776 : 				case 8:
; 8777 : 					bEnablePShopOpen = true; break;

  0014a	88 4d c7	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], cl

; 8778 : 			}
; 8779 : 
; 8780 : 			if ( !bEnablePShopOpen  )

  0014d	eb 19		 jmp	 SHORT $LN11@CGPShopReq@4
$LN32@CGPShopReq@4:

; 8781 : 			{
; 8782 : 				LogAddTD("[PShop] [%s][%s] ERROR : m_IfState.type is Using : %d",
; 8783 : 					gObj[aIndex].AccountID, gObj[aIndex].Name,
; 8784 : 					gObj[aIndex].m_IfState.type);

  0014f	50		 push	 eax
  00150	8d 44 33 77	 lea	 eax, DWORD PTR [ebx+esi+119]
  00154	50		 push	 eax
  00155	8d 4c 33 6c	 lea	 ecx, DWORD PTR [ebx+esi+108]
  00159	51		 push	 ecx
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00165	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@CGPShopReq@4:

; 8792 : 			return;
; 8793 : 		}
; 8794 : 	}
; 8795 : 
; 8796 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00168	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0016b	52		 push	 edx
  0016c	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00171	83 c4 04	 add	 esp, 4
  00174	84 c0		 test	 al, al
  00176	75 18		 jne	 SHORT $LN9@CGPShopReq@4

; 8797 : 	{
; 8798 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d",
; 8799 : 			__FILE__ ,__LINE__);

  00178	68 5f 22 00 00	 push	 8799			; 0000225fH
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGPShopReq@4:

; 8800 : 	}
; 8801 : 
; 8802 : 	if ( gObj[aIndex].pTransaction == 1 )

  00190	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00195	80 bc 03 30 0e
	00 00 01	 cmp	 BYTE PTR [ebx+eax+3632], 1
  0019d	75 48		 jne	 SHORT $LN8@CGPShopReq@4

; 8803 : 	{
; 8804 : 		LogAddTD("[PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d",
; 8805 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  0019f	8b 8c 03 1c 0e
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+3612]
  001a6	c1 e9 06	 shr	 ecx, 6
  001a9	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  001af	51		 push	 ecx
  001b0	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  001b4	52		 push	 edx
  001b5	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  001b9	50		 push	 eax
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c5	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@CGPShopReq@4:

; 8834 : 		}
; 8835 : 	}
; 8836 : 	else
; 8837 : 	{
; 8838 : 		CGPShopAnsOpen(aIndex, 0);

  001c8	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  001cb	6a 00		 push	 0
  001cd	52		 push	 edx
  001ce	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  001d3	83 c4 08	 add	 esp, 8
  001d6	5e		 pop	 esi
  001d7	5f		 pop	 edi
  001d8	5b		 pop	 ebx

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  001d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001dc	33 cd		 xor	 ecx, ebp
  001de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
$LN8@CGPShopReq@4:

; 8806 : 		bEnablePShopOpen = false;
; 8807 : 	}
; 8808 : 
; 8809 : 	if ( bEnablePShopOpen )

  001e7	80 7d c7 00	 cmp	 BYTE PTR _bEnablePShopOpen$[ebp], 0
  001eb	74 db		 je	 SHORT $LN7@CGPShopReq@4

; 8810 : 	{
; 8811 : 		if ( gObj[aIndex].m_bPShopOpen == false )

  001ed	80 bc 03 c4 0e
	00 00 00	 cmp	 BYTE PTR [ebx+eax+3780], 0
  001f5	8d 8c 03 c4 0e
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+3780]

; 8812 : 		{
; 8813 : 			gObj[aIndex].m_bPShopOpen = true;
; 8814 : 			memcpy(gObj[aIndex].m_szPShopText, lpMsg->szPShopText, sizeof(lpMsg->szPShopText));

  001fc	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  001ff	75 39		 jne	 SHORT $LN6@CGPShopReq@4
  00201	c6 01 01	 mov	 BYTE PTR [ecx], 1
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020a	8d bc 0b c8 0e
	00 00		 lea	 edi, DWORD PTR [ebx+ecx+3784]
  00211	b9 09 00 00 00	 mov	 ecx, 9
  00216	f3 a5		 rep movsd

; 8815 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Opened",
; 8816 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021d	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  00221	52		 push	 edx
  00222	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  00226	50		 push	 eax
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8817 : 		}
; 8818 : 		else

  00235	e9 82 00 00 00	 jmp	 $LN5@CGPShopReq@4
$LN6@CGPShopReq@4:

; 8819 : 		{
; 8820 : 			memcpy(gObj[aIndex].m_szPShopText, lpMsg->szPShopText, sizeof(lpMsg->szPShopText));
; 8821 : 			
; 8822 : 			PMSG_ANS_PSHOP_TEXT_CHANGED pMsg;
; 8823 : 
; 8824 : 			PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x10, sizeof(pMsg));

  0023a	6a 34		 push	 52			; 00000034H
  0023c	8d bc 03 c8 0e
	00 00		 lea	 edi, DWORD PTR [ebx+eax+3784]
  00243	b9 09 00 00 00	 mov	 ecx, 9
  00248	6a 10		 push	 16			; 00000010H
  0024a	89 75 bc	 mov	 DWORD PTR tv465[ebp], esi
  0024d	f3 a5		 rep movsd
  0024f	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$247413[ebp]
  00252	6a 3f		 push	 63			; 0000003fH
  00254	51		 push	 ecx
  00255	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8825 : 			pMsg.NumberH = SET_NUMBERH(aIndex);

  0025a	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]

; 8826 : 			pMsg.NumberL = SET_NUMBERL(aIndex);
; 8827 : 			memcpy(pMsg.btPShopText, lpMsg->szPShopText, sizeof(pMsg.btPShopText));

  0025d	8b 75 bc	 mov	 esi, DWORD PTR tv465[ebp]
  00260	88 45 cd	 mov	 BYTE PTR _pMsg$247413[ebp+5], al
  00263	8b d0		 mov	 edx, eax

; 8828 : 			memcpy(pMsg.btName, gObj[aIndex].Name, sizeof(pMsg.btName));

  00265	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026a	c1 ea 08	 shr	 edx, 8
  0026d	88 55 cc	 mov	 BYTE PTR _pMsg$247413[ebp+4], dl
  00270	03 c3		 add	 eax, ebx
  00272	b9 09 00 00 00	 mov	 ecx, 9
  00277	8d 7d ce	 lea	 edi, DWORD PTR _pMsg$247413[ebp+6]
  0027a	f3 a5		 rep movsd
  0027c	8b 48 77	 mov	 ecx, DWORD PTR [eax+119]
  0027f	89 4d f2	 mov	 DWORD PTR _pMsg$247413[ebp+42], ecx
  00282	8b 50 7b	 mov	 edx, DWORD PTR [eax+123]
  00285	89 55 f6	 mov	 DWORD PTR _pMsg$247413[ebp+46], edx
  00288	66 8b 48 7f	 mov	 cx, WORD PTR [eax+127]

; 8829 : 
; 8830 : 			MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  0028c	0f b6 55 c9	 movzx	 edx, BYTE PTR _pMsg$247413[ebp+1]
  00290	66 89 4d fa	 mov	 WORD PTR _pMsg$247413[ebp+50], cx
  00294	52		 push	 edx
  00295	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$247413[ebp]
  00298	51		 push	 ecx
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 8831 : 
; 8832 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Already Opened - Changing PShop Name",
; 8833 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  0029f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a4	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  002a8	52		 push	 edx
  002a9	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  002ad	50		 push	 eax
  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@
  002b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002b9	83 c4 28	 add	 esp, 40			; 00000028H
$LN5@CGPShopReq@4:

; 8839 : 		return;
; 8840 : 	}
; 8841 : 
; 8842 : 
; 8843 : //#if(CUSTOM_PERSONAL_SHOP==TRUE)
; 8844 : 	if(g_PersonalShopZt.Enable)

  002bc	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A, 0
  002c3	74 2a		 je	 SHORT $LN2@CGPShopReq@4

; 8845 : 	{
; 8846 : 		if(!g_PersonalShopZt.PShop_CheckInventoryPrice(aIndex))

  002c5	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002c8	51		 push	 ecx
  002c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PersonalShopZt@@3VPersonalShopZt@@A ; g_PersonalShopZt
  002ce	e8 00 00 00 00	 call	 ?PShop_CheckInventoryPrice@PersonalShopZt@@QAE_NF@Z ; PersonalShopZt::PShop_CheckInventoryPrice
  002d3	84 c0		 test	 al, al
  002d5	75 18		 jne	 SHORT $LN2@CGPShopReq@4

; 8847 : 		{
; 8848 : 			::GCServerMsgStringSend("No Price Item", aIndex, 1);

  002d7	8b 75 c0	 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  002da	6a 01		 push	 1
  002dc	56		 push	 esi
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EAKBJPFK@No?5Price?5Item?$AA@
  002e2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8849 : 			::CGPShopAnsOpen( aIndex, 0);

  002e7	6a 00		 push	 0
  002e9	56		 push	 esi

; 8850 : 			return;

  002ea	e9 83 00 00 00	 jmp	 $LN34@CGPShopReq@4
$LN2@CGPShopReq@4:

; 8851 : 		}	
; 8852 : 	}
; 8853 : //#endif
; 8854 : 	
; 8855 : 	CGPShopAnsOpen(aIndex, 1);

  002ef	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002f2	6a 01		 push	 1
  002f4	52		 push	 edx
  002f5	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen

; 8856 : 
; 8857 : 	if(gObj[aIndex].m_bActiveOffTrade == true)

  002fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ff	83 c4 08	 add	 esp, 8
  00302	80 bc 03 14 2b
	00 00 01	 cmp	 BYTE PTR [ebx+eax+11028], 1
  0030a	75 6e		 jne	 SHORT $LN33@CGPShopReq@4

; 8858 : 	{
; 8859 : #if(_RECONNECT_==TRUE)
; 8860 : 		g_ConnectZt.SendClose(aIndex, TRUE);

  0030c	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0030f	6a 01		 push	 1
  00311	51		 push	 ecx
  00312	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00317	e8 00 00 00 00	 call	 ?SendClose@ConnectZt@@QAEXHH@Z ; ConnectZt::SendClose
  0031c	5e		 pop	 esi
  0031d	5f		 pop	 edi
  0031e	5b		 pop	 ebx

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  0031f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00322	33 cd		 xor	 ecx, ebp
  00324	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00329	8b e5		 mov	 esp, ebp
  0032b	5d		 pop	 ebp
  0032c	c3		 ret	 0
$LN15@CGPShopReq@4:

; 8785 : 			}
; 8786 : 		}
; 8787 : 		else
; 8788 : 		{
; 8789 : 			LogAddTD("[PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d",
; 8790 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 8791 : 				gObj[aIndex].m_IfState.type);

  0032d	50		 push	 eax
  0032e	8d 44 33 77	 lea	 eax, DWORD PTR [ebx+esi+119]
  00332	50		 push	 eax
  00333	8d 4c 33 6c	 lea	 ecx, DWORD PTR [ebx+esi+108]
  00337	51		 push	 ecx
  00338	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00343	83 c4 10	 add	 esp, 16			; 00000010H
  00346	5e		 pop	 esi
  00347	5f		 pop	 edi
  00348	5b		 pop	 ebx

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  00349	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034c	33 cd		 xor	 ecx, ebp
  0034e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00353	8b e5		 mov	 esp, ebp
  00355	5d		 pop	 ebp
  00356	c3		 ret	 0
$LN19@CGPShopReq@4:

; 8750 : 	{
; 8751 : 		LogAddTD("[PShop] [%s][%s] ERROR : Cant't Open Shop - Item Block",
; 8752 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);

  00357	8d 54 33 77	 lea	 edx, DWORD PTR [ebx+esi+119]
  0035b	52		 push	 edx
  0035c	8d 44 33 6c	 lea	 eax, DWORD PTR [ebx+esi+108]
  00360	50		 push	 eax
  00361	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8753 : 		::CGPShopAnsOpen( aIndex, 3);

  0036c	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0036f	6a 03		 push	 3
  00371	51		 push	 ecx
$LN34@CGPShopReq@4:
  00372	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00377	83 c4 14	 add	 esp, 20			; 00000014H
$LN33@CGPShopReq@4:
  0037a	5e		 pop	 esi
$LN1@CGPShopReq@4:

; 8861 : #else
; 8862 : 		CloseClient(aIndex);
; 8863 : 		lpObj->m_OfflineMode = true;
; 8864 : #endif
; 8865 : 	}
; 8866 : }

  0037b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037e	5f		 pop	 edi
  0037f	33 cd		 xor	 ecx, ebp
  00381	5b		 pop	 ebx
  00382	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00387	8b e5		 mov	 esp, ebp
  00389	5d		 pop	 ebp
  0038a	c3		 ret	 0
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ENDP	; CGPShopReqOpen
_TEXT	ENDS
PUBLIC	??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@ ; `string'
PUBLIC	?CGPShopReqClose@@YAXH@Z			; CGPShopReqClose
;	COMDAT ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@
CONST	SEGMENT
??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@ DB '['
	DB	'PShop] [%s][%s] Requested to Close PShop', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqClose@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGPShopReqClose@@YAXH@Z PROC				; CGPShopReqClose, COMDAT

; 8885 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 8886 : 	if ( !gObjIsConnected(aIndex))

  00004	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 12		 jne	 SHORT $LN2@CGPShopReq@5

; 8887 : 	{
; 8888 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00014	57		 push	 edi
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00020	83 c4 08	 add	 esp, 8
  00023	5f		 pop	 edi

; 8903 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN2@CGPShopReq@5:

; 8889 : 		return;
; 8890 : 	}
; 8891 : 
; 8892 : 	if ( gObj[aIndex].Type != OBJ_USER )

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	56		 push	 esi
  0002c	8b f7		 mov	 esi, edi
  0002e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00034	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  0003a	74 13		 je	 SHORT $LN1@CGPShopReq@5

; 8893 : 	{
; 8894 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  0003c	57		 push	 edi
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00048	83 c4 08	 add	 esp, 8
  0004b	5e		 pop	 esi
  0004c	5f		 pop	 edi

; 8903 : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN1@CGPShopReq@5:

; 8895 : 		return;
; 8896 : 	}
; 8897 : 
; 8898 : 	LogAddTD("[PShop] [%s][%s] Requested to Close PShop",
; 8899 : 		gObj[aIndex].AccountID, gObj[aIndex].Name);

  0004f	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00053	51		 push	 ecx
  00054	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00058	52		 push	 edx
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8900 : 	gObj[aIndex].m_bPShopOpen = false;

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	33 c0		 xor	 eax, eax
  0006c	88 84 0e c4 0e
	00 00		 mov	 BYTE PTR [esi+ecx+3780], al

; 8901 : 	memset(gObj[aIndex].m_szPShopText, 0, sizeof(gObj[aIndex].m_szPShopText));

  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00079	8d 8c 16 c8 0e
	00 00		 lea	 ecx, DWORD PTR [esi+edx+3784]
  00080	89 01		 mov	 DWORD PTR [ecx], eax
  00082	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00085	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00088	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0008b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0008e	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00091	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 8902 : 	CGPShopAnsClose(aIndex, 1);

  00094	6a 01		 push	 1
  00096	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00099	57		 push	 edi
  0009a	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0009d	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	5e		 pop	 esi
  000a6	5f		 pop	 edi

; 8903 : }

  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?CGPShopReqClose@@YAXH@Z ENDP				; CGPShopReqClose
_TEXT	ENDS
PUBLIC	??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@ ; `string'
PUBLIC	??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
;	COMDAT ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in It'
	DB	'em Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@
CONST	SEGMENT
??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@ DB '['
	DB	'PShop] [%s][%s] is Receiving PShop List From [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Requester Transac'
	DB	'tion == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not '
	DB	'Open PShop', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Requested to Him(/Her)Self', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Clos'
	DB	'ing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Clo'
	DB	'sing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller is Not CHA'
	DB	'RACTER (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller did Not CO'
	DB	'NNECTED (%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyList, COMDAT

; 8934 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8935 : 	if ( ::gDoPShopOpen == FALSE )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000a	0f 84 a4 02 00
	00		 je	 $LN12@CGPShopReq@6

; 8936 : 	{
; 8937 : 		return;
; 8938 : 	}
; 8939 : 
; 8940 : 	if ( gObjIsConnected(MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE)

  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00014	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00018	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0001c	66 c1 e0 08	 shl	 ax, 8
  00020	0f b7 c8	 movzx	 ecx, ax
  00023	0b ca		 or	 ecx, edx
  00025	57		 push	 edi
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected

; 8941 : 	{
; 8942 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller did Not CONNECTED (%d)",
; 8943 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0002c	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  00030	66 c1 e2 08	 shl	 dx, 8
  00034	83 c4 04	 add	 esp, 4
  00037	0f b7 ca	 movzx	 ecx, dx
  0003a	85 c0		 test	 eax, eax
  0003c	75 3e		 jne	 SHORT $LN10@CGPShopReq@6
  0003e	8b 7d 0c	 mov	 edi, DWORD PTR _aSourceIndex$[ebp]
  00041	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00045	8b c7		 mov	 eax, edi
  00047	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0004d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	0b ca		 or	 ecx, edx
  00055	51		 push	 ecx
  00056	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00059	51		 push	 ecx
  0005a	83 c0 6c	 add	 eax, 108		; 0000006cH
  0005d	50		 push	 eax
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8944 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  00069	6a 00		 push	 0
  0006b	6a 02		 push	 2
  0006d	6a ff		 push	 -1
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00075	83 c4 20	 add	 esp, 32			; 00000020H
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi

; 9018 : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN10@CGPShopReq@6:

; 8945 : 		return;
; 8946 : 	}
; 8947 : 
; 8948 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  0007c	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00080	0b c8		 or	 ecx, eax
  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	8b f9		 mov	 edi, ecx
  00089	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  0008f	03 f8		 add	 edi, eax

; 8949 : 
; 8950 : 	if ( lpObj->Type != OBJ_USER )

  00091	66 83 7f 68 01	 cmp	 WORD PTR [edi+104], 1
  00096	74 34		 je	 SHORT $LN9@CGPShopReq@6

; 8951 : 	{
; 8952 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller is Not CHARACTER (%d)",
; 8953 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00098	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  0009b	8b d6		 mov	 edx, esi
  0009d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000a3	51		 push	 ecx
  000a4	03 c2		 add	 eax, edx
  000a6	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  000a9	51		 push	 ecx
  000aa	83 c0 6c	 add	 eax, 108		; 0000006cH
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8954 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  000b9	6a 00		 push	 0
  000bb	6a 02		 push	 2
  000bd	6a ff		 push	 -1
  000bf	56		 push	 esi
  000c0	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  000c5	83 c4 20	 add	 esp, 32			; 00000020H
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi

; 9018 : }

  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN9@CGPShopReq@6:

; 8955 : 		return;
; 8956 : 	}
; 8957 : 
; 8958 : 	if ( lpObj->CloseCount >= 0 )	

  000cc	80 7f 0a 00	 cmp	 BYTE PTR [edi+10], 0
  000d0	7c 34		 jl	 SHORT $LN8@CGPShopReq@6

; 8959 : 	{
; 8960 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",
; 8961 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL) );

  000d2	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  000d5	8b d6		 mov	 edx, esi
  000d7	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000dd	51		 push	 ecx
  000de	03 c2		 add	 eax, edx
  000e0	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  000e3	51		 push	 ecx
  000e4	83 c0 6c	 add	 eax, 108		; 0000006cH
  000e7	50		 push	 eax
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8962 : 		CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);

  000f3	6a 02		 push	 2
  000f5	6a 00		 push	 0
  000f7	6a ff		 push	 -1
  000f9	56		 push	 esi
  000fa	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  000ff	83 c4 20	 add	 esp, 32			; 00000020H
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi

; 9018 : }

  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN8@CGPShopReq@6:
  00106	53		 push	 ebx

; 8963 : 		return;
; 8964 : 	}
; 8965 : 
; 8966 : 	if ( gObj[aSourceIndex].CloseCount >= 0 )	

  00107	8b 5d 0c	 mov	 ebx, DWORD PTR _aSourceIndex$[ebp]
  0010a	8b f3		 mov	 esi, ebx
  0010c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00112	80 7c 06 0a 00	 cmp	 BYTE PTR [esi+eax+10], 0
  00117	7c 2a		 jl	 SHORT $LN7@CGPShopReq@6

; 8967 : 	{
; 8968 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",
; 8969 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00119	51		 push	 ecx
  0011a	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0011e	52		 push	 edx
  0011f	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00123	50		 push	 eax
  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8970 : 		CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  0012f	6a 02		 push	 2
  00131	6a 00		 push	 0
  00133	6a ff		 push	 -1
  00135	53		 push	 ebx
  00136	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0013b	83 c4 20	 add	 esp, 32			; 00000020H
  0013e	5b		 pop	 ebx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi

; 9018 : }

  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
$LN7@CGPShopReq@6:

; 8971 : 		return;
; 8972 : 	}
; 8973 : 
; 8974 : 	if ( lpObj->m_Index == aSourceIndex )

  00143	39 1f		 cmp	 DWORD PTR [edi], ebx
  00145	75 29		 jne	 SHORT $LN6@CGPShopReq@6

; 8975 : 	{
; 8976 : 		LogAddTD("[PShop] [%s][%s] PShop List Requested to Him(/Her)Self",
; 8977 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name);

  00147	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0014b	51		 push	 ecx
  0014c	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00150	52		 push	 edx
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8978 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  0015c	6a 00		 push	 0
  0015e	6a 02		 push	 2
  00160	6a ff		 push	 -1
  00162	53		 push	 ebx
  00163	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00168	83 c4 1c	 add	 esp, 28			; 0000001cH
  0016b	5b		 pop	 ebx
  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi

; 9018 : }

  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
$LN6@CGPShopReq@6:

; 8979 : 		return;
; 8980 : 	}
; 8981 : 
; 8982 : 	if ( lpObj->m_bPShopOpen == false )

  00170	80 bf c4 0e 00
	00 00		 cmp	 BYTE PTR [edi+3780], 0
  00177	75 31		 jne	 SHORT $LN5@CGPShopReq@6

; 8983 : 	{
; 8984 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not Open PShop",
; 8985 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, lpObj->AccountID, lpObj->Name);

  00179	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  0017c	51		 push	 ecx
  0017d	83 c7 6c	 add	 edi, 108		; 0000006cH
  00180	57		 push	 edi
  00181	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00185	52		 push	 edx
  00186	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0018a	50		 push	 eax
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8986 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 3, 0);

  00196	6a 00		 push	 0
  00198	6a 03		 push	 3

; 8994 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 4, 0);

  0019a	6a ff		 push	 -1
  0019c	53		 push	 ebx
  0019d	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  001a2	83 c4 24	 add	 esp, 36			; 00000024H
  001a5	5b		 pop	 ebx
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 9018 : }

  001a8	5d		 pop	 ebp
  001a9	c3		 ret	 0
$LN5@CGPShopReq@6:

; 8987 : 		return;
; 8988 : 	}
; 8989 : 
; 8990 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty&8) == 8 )

  001aa	f6 87 10 02 00
	00 0c		 test	 BYTE PTR [edi+528], 12	; 0000000cH
  001b1	0f 85 ce 00 00
	00		 jne	 $LN3@CGPShopReq@6

; 8995 : 		return;
; 8996 : 	}
; 8997 : 
; 8998 : 	if ( !::gObjFixInventoryPointer(aSourceIndex))

  001b7	53		 push	 ebx
  001b8	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  001bd	83 c4 04	 add	 esp, 4
  001c0	84 c0		 test	 al, al
  001c2	75 18		 jne	 SHORT $LN2@CGPShopReq@6

; 8999 : 	{
; 9000 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d",
; 9001 : 			__FILE__, __LINE__);

  001c4	68 29 23 00 00	 push	 9001			; 00002329H
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGPShopReq@6:

; 9002 : 	}
; 9003 : 
; 9004 : 	if ( gObj[aSourceIndex].pTransaction == 1 )

  001dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e1	80 bc 06 30 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3632], 1

; 9005 : 	{
; 9006 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Requester Transaction == 1, IF_TYPE : %d",
; 9007 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].m_IfState.type);

  001e9	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  001ed	75 2a		 jne	 SHORT $LN1@CGPShopReq@6
  001ef	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  001f6	c1 e9 06	 shr	 ecx, 6
  001f9	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  001ff	51		 push	 ecx
  00200	52		 push	 edx
  00201	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00205	50		 push	 eax
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00211	83 c4 10	 add	 esp, 16			; 00000010H
  00214	5b		 pop	 ebx
  00215	5f		 pop	 edi
  00216	5e		 pop	 esi

; 9018 : }

  00217	5d		 pop	 ebp
  00218	c3		 ret	 0
$LN1@CGPShopReq@6:

; 9008 : 		return;
; 9009 : 	}
; 9010 : 
; 9011 : 	LogAddTD("[PShop] [%s][%s] is Receiving PShop List From [%s][%s]",
; 9012 : 		gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, lpObj->AccountID, lpObj->Name);

  00219	8d 5f 77	 lea	 ebx, DWORD PTR [edi+119]
  0021c	53		 push	 ebx
  0021d	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00220	51		 push	 ecx
  00221	52		 push	 edx
  00222	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00226	50		 push	 eax
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9013 : 
; 9014 : 	gObj[aSourceIndex].m_bPShopWantDeal = true;

  00232	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00238	c6 84 0e ec 0e
	00 00 01	 mov	 BYTE PTR [esi+ecx+3820], 1

; 9015 : 	gObj[aSourceIndex].m_iPShopDealerIndex = lpObj->m_Index;

  00240	8b 17		 mov	 edx, DWORD PTR [edi]
  00242	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00247	89 94 06 f0 0e
	00 00		 mov	 DWORD PTR [esi+eax+3824], edx

; 9016 : 	memcpy(gObj[aSourceIndex].m_szPShopDealerName, lpObj->Name, MAX_ACCOUNT_LEN);

  0024e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00254	8b 13		 mov	 edx, DWORD PTR [ebx]
  00256	8d 84 0e f4 0e
	00 00		 lea	 eax, DWORD PTR [esi+ecx+3828]
  0025d	89 10		 mov	 DWORD PTR [eax], edx
  0025f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00262	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00265	66 8b 53 08	 mov	 dx, WORD PTR [ebx+8]

; 9017 : 	::CGPShopAnsBuyList(aSourceIndex, lpObj->m_Index, 1, false);

  00269	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  0026c	6a 00		 push	 0
  0026e	66 89 50 08	 mov	 WORD PTR [eax+8], dx
  00272	8b 07		 mov	 eax, DWORD PTR [edi]
  00274	6a 01		 push	 1
  00276	50		 push	 eax
  00277	51		 push	 ecx
  00278	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  0027d	83 c4 24	 add	 esp, 36			; 00000024H
  00280	5b		 pop	 ebx
  00281	5f		 pop	 edi
  00282	5e		 pop	 esi

; 9018 : }

  00283	5d		 pop	 ebp
  00284	c3		 ret	 0
$LN3@CGPShopReq@6:

; 8991 : 	{
; 8992 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in Item Block",
; 8993 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, lpObj->AccountID, lpObj->Name);

  00285	8d 57 77	 lea	 edx, DWORD PTR [edi+119]
  00288	52		 push	 edx
  00289	83 c7 6c	 add	 edi, 108		; 0000006cH
  0028c	57		 push	 edi
  0028d	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00291	51		 push	 ecx
  00292	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00296	52		 push	 edx
  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 8994 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 4, 0);

  002a2	6a 00		 push	 0
  002a4	6a 04		 push	 4
  002a6	6a ff		 push	 -1
  002a8	53		 push	 ebx
  002a9	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  002ae	83 c4 24	 add	 esp, 36			; 00000024H
  002b1	5b		 pop	 ebx
  002b2	5f		 pop	 edi
  002b3	5e		 pop	 esi
$LN12@CGPShopReq@6:

; 9018 : }

  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyList
_TEXT	ENDS
PUBLIC	??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@ ; `string'
PUBLIC	??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ ; `string'
PUBLIC	??_C@_0BD@DHABCDPC@No?5Empty?5Inventory?$AA@	; `string'
PUBLIC	??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0P@GLCMHBBE@Un?5Pack?5Jewels?$AA@		; `string'
PUBLIC	??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0P@KHKEGFKG@No?5Jewels?5Bank?$AA@		; `string'
PUBLIC	??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0BB@OCLJIALE@Block?5Trade?5Item?$AA@	; `string'
PUBLIC	??_C@_0EJ@OFBBNFMD@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ ; `string'
PUBLIC	??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItemEx
EXTRN	?PShop_CheckInventoryEmpty@@YA_NF@Z:PROC	; PShop_CheckInventoryEmpty
EXTRN	?ZtUserDataSend@@YAXH@Z:PROC			; ZtUserDataSend
EXTRN	?GDSaveUserInfo@GameShop@@QAEXH@Z:PROC		; GameShop::GDSaveUserInfo
EXTRN	?gGameShop@@3VGameShop@@A:BYTE			; gGameShop
EXTRN	?gObjInventoryItemSet_PShop@@YAXHHE@Z:PROC	; gObjInventoryItemSet_PShop
EXTRN	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjOnlyInventoryInsertItem
EXTRN	?GetText@CZtText@@QAEPADH@Z:PROC		; CZtText::GetText
EXTRN	?g_ZtText@@3VCZtText@@A:BYTE			; g_ZtText
EXTRN	?GetInventoryEmptyPoint@@YAHH@Z:PROC		; GetInventoryEmptyPoint
EXTRN	?CheckTrade@CItemMove@@QAE_NH@Z:PROC		; CItemMove::CheckTrade
EXTRN	?CheckTrade@CAccountSecurity@@QAE_NH@Z:PROC	; CAccountSecurity::CheckTrade
EXTRN	__except_handler4:PROC
EXTRN	__local_unwind4:PROC
;	COMDAT ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is i'
	DB	'n Item Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'Not Choose Item Price', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
CONST	SEGMENT
??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@ DB '['
	DB	'PShop] [%s][%s] Sold All Items - Auto Closing PShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
CONST	SEGMENT
??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ DB '['
	DB	'PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s]'
	DB	'[%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, S'
	DB	'erial:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHABCDPC@No?5Empty?5Inventory?$AA@
CONST	SEGMENT
??_C@_0BD@DHABCDPC@No?5Empty?5Inventory?$AA@ DB 'No Empty Inventory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No R'
	DB	'oom to Buy Item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GLCMHBBE@Un?5Pack?5Jewels?$AA@
CONST	SEGMENT
??_C@_0P@GLCMHBBE@Un?5Pack?5Jewels?$AA@ DB 'Un Pack Jewels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Boun'
	DB	'dle Jewels - Type: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KHKEGFKG@No?5Jewels?5Bank?$AA@
CONST	SEGMENT
??_C@_0P@KHKEGFKG@No?5Jewels?5Bank?$AA@ DB 'No Jewels Bank', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No e'
	DB	'nough Jewels - Type: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCLJIALE@Block?5Trade?5Item?$AA@
CONST	SEGMENT
??_C@_0BB@OCLJIALE@Block?5Trade?5Item?$AA@ DB 'Block Trade Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@OFBBNFMD@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EJ@OFBBNFMD@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack'
	DB	' of Credit', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exce'
	DB	'eding Zen of the Host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack'
	DB	' of Zen', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Requester Tra'
	DB	'nsaction == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
CONST	SEGMENT
??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Alre'
	DB	'ady Trade With Other', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is C'
	DB	'losing Connection', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch'
	DB	' [%s] - [%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'not Open PShop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not'
	DB	' CHARACTER (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller did No'
	DB	't CONNECTED (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffff20H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN142@CGPShopReq@7
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
_iITEM_LOG_TYPE$ = -208					; size = 4
_x$247792 = -204					; size = 4
_iITEM_LOG_LEVEL$ = -200				; size = 4
_lpObj$ = -196						; size = 4
_iITEM_LOG_DUR$ = -192					; size = 4
_x$247784 = -188					; size = 4
_iITEM_LOG_SERIAL$ = -184				; size = 4
_x$247796 = -180					; size = 4
_x$247788 = -176					; size = 4
_iFreeSpaceReq$247687 = -172				; size = 4
_lpMsg$GSCopy$ = -168					; size = 4
tv2035 = -164						; size = 4
_invSize$247658 = -164					; size = 4
tv2188 = -160						; size = 4
_JewelType$247754 = -160				; size = 4
_iPShopCreditValue$247661 = -160			; size = 4
tv2167 = -156						; size = 4
tv2094 = -156						; size = 4
_iPShopBonusValue$247660 = -156				; size = 4
_JewelLevel$247755 = -152				; size = 4
_lpSourceObj$ = -152					; size = 4
_ExBankPlus$247663 = -146				; size = 1
_ExBankMinus$247664 = -145				; size = 1
tv2129 = -144						; size = 4
tv2127 = -144						; size = 4
tv2116 = -144						; size = 4
tv2114 = -144						; size = 4
tv2105 = -144						; size = 4
tv2103 = -144						; size = 4
tv1887 = -144						; size = 4
_iPShopValue$247659 = -144				; size = 4
tv2040 = -140						; size = 4
_bBoundle$247698 = -140					; size = 4
tv2132 = -138						; size = 2
tv2119 = -138						; size = 2
tv2108 = -138						; size = 2
_btNewItemPos$247736 = -137				; size = 1
tv1825 = -136						; size = 4
_n$247657 = -136					; size = 4
_aSourceIndex$GSCopy$ = -132				; size = 4
_iJewelId$247773 = -128					; size = 16
_iBoundleId$247772 = -112				; size = 16
_JewelCount$247699 = -96				; size = 16
_aPShopJewel$247688 = -80				; size = 8
_aPShopJewelBoundle$247689 = -72			; size = 24
_szName$ = -48						; size = 11
_aPShopJewelValue$247662 = -36				; size = 8
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyItemEx, COMDAT

; 9141 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 9246 : 	{
; 9247 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 9248 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00039	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  0003f	8b 5d 0c	 mov	 ebx, DWORD PTR _aSourceIndex$[ebp]
  00042	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], ebx

; 9142 : 	if ( gDoPShopOpen == FALSE )

  00048	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0004f	0f 84 e1 15 00
	00		 je	 $LN145@CGPShopReq@7

; 9143 : 		return;
; 9144 : 
; 9145 : 	LPOBJ lpSourceObj = &gObj[aSourceIndex];

  00055	8b f3		 mov	 esi, ebx
  00057	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0005d	89 b5 78 ff ff
	ff		 mov	 DWORD PTR tv1825[ebp], esi
  00063	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	89 b5 68 ff ff
	ff		 mov	 DWORD PTR _lpSourceObj$[ebp], esi

; 9146 : 
; 9147 : 	if ( gObjIsConnected( MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE )

  0006f	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00073	66 c1 e1 08	 shl	 cx, 8
  00077	0f b7 d1	 movzx	 edx, cx
  0007a	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0007e	0b d0		 or	 edx, eax
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00086	83 c4 04	 add	 esp, 4
  00089	85 c0		 test	 eax, eax
  0008b	75 39		 jne	 SHORT $LN126@CGPShopReq@7

; 9148 : 	{
; 9149 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller did Not CONNECTED (%d)",
; 9150 : 			lpSourceObj->AccountID, lpSourceObj->Name, MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0008d	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00091	66 c1 e1 08	 shl	 cx, 8
  00095	0f b7 d1	 movzx	 edx, cx
  00098	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0009c	0b d0		 or	 edx, eax
  0009e	52		 push	 edx
  0009f	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  000a2	51		 push	 ecx
  000a3	83 c6 6c	 add	 esi, 108		; 0000006cH
  000a6	56		 push	 esi
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9151 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  000b2	6a 02		 push	 2
  000b4	6a 00		 push	 0
  000b6	6a ff		 push	 -1
  000b8	53		 push	 ebx
  000b9	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  000be	83 c4 20	 add	 esp, 32			; 00000020H

; 9152 : 		return;

  000c1	e9 70 15 00 00	 jmp	 $LN145@CGPShopReq@7
$LN126@CGPShopReq@7:

; 9153 : 	}
; 9154 : 
; 9155 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  000c6	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  000ca	66 c1 e2 08	 shl	 dx, 8
  000ce	0f b7 c2	 movzx	 eax, dx
  000d1	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  000d5	0b c1		 or	 eax, ecx
  000d7	8b d8		 mov	 ebx, eax
  000d9	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  000df	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e5	89 9d 3c ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], ebx

; 9156 : 	
; 9157 : 
; 9158 : 	if ( lpObj->Type != OBJ_USER )

  000eb	66 83 7b 68 01	 cmp	 WORD PTR [ebx+104], 1
  000f0	74 2e		 je	 SHORT $LN125@CGPShopReq@7

; 9159 : 	{
; 9160 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not CHARACTER (%d)",
; 9161 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  000f2	50		 push	 eax
  000f3	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  000f6	52		 push	 edx
  000f7	83 c6 6c	 add	 esi, 108		; 0000006cH
  000fa	56		 push	 esi
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9162 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  00106	6a 02		 push	 2
  00108	6a 00		 push	 0
  0010a	6a ff		 push	 -1
  0010c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00118	83 c4 20	 add	 esp, 32			; 00000020H

; 9163 : 		return;

  0011b	e9 16 15 00 00	 jmp	 $LN145@CGPShopReq@7
$LN125@CGPShopReq@7:

; 9164 : 	}
; 9165 : 
; 9166 : 	if ( lpObj->CloseCount >= 0 )	

  00120	80 7b 0a 00	 cmp	 BYTE PTR [ebx+10], 0
  00124	7c 2e		 jl	 SHORT $LN124@CGPShopReq@7

; 9167 : 	{
; 9168 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",
; 9169 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)  );

  00126	50		 push	 eax
  00127	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  0012a	51		 push	 ecx
  0012b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0012e	56		 push	 esi
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9170 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);

  0013a	6a 02		 push	 2
  0013c	6a 00		 push	 0
  0013e	6a ff		 push	 -1
  00140	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0014c	83 c4 20	 add	 esp, 32			; 00000020H

; 9171 : 		return;

  0014f	e9 e2 14 00 00	 jmp	 $LN145@CGPShopReq@7
$LN124@CGPShopReq@7:

; 9172 : 	}
; 9173 : 
; 9174 : 
; 9175 : 	if ( lpSourceObj->CloseCount >= 0 )	

  00154	80 7e 0a 00	 cmp	 BYTE PTR [esi+10], 0
  00158	7c 2e		 jl	 SHORT $LN123@CGPShopReq@7

; 9176 : 	{
; 9177 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",
; 9178 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0015a	50		 push	 eax
  0015b	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0015e	50		 push	 eax
  0015f	83 c6 6c	 add	 esi, 108		; 0000006cH
  00162	56		 push	 esi
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9179 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  0016e	6a 02		 push	 2
  00170	6a 00		 push	 0
  00172	6a ff		 push	 -1
  00174	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0017a	51		 push	 ecx
  0017b	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00180	83 c4 20	 add	 esp, 32			; 00000020H

; 9180 : 		return;

  00183	e9 ae 14 00 00	 jmp	 $LN145@CGPShopReq@7
$LN123@CGPShopReq@7:

; 9181 : 	}
; 9182 : 
; 9183 : 	/*if ( lpSourceObj->pInventory[0].m_Type == ITEMGET(0,41) )
; 9184 : 	{
; 9185 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Mining (%d)",
; 9186 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 9187 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 10);
; 9188 : 		return;
; 9189 : 	}*/
; 9190 : 
; 9191 : #if(CUSTOM_ACCOUNT_SECURITY)
; 9192 : 	if(g_AccountSecurity.CheckTrade(lpSourceObj->m_Index) == false)

  00188	8b 16		 mov	 edx, DWORD PTR [esi]
  0018a	52		 push	 edx
  0018b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  00190	e8 00 00 00 00	 call	 ?CheckTrade@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckTrade
  00195	84 c0		 test	 al, al
  00197	75 1a		 jne	 SHORT $LN122@CGPShopReq@7

; 9193 : 	{
; 9194 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 10);

  00199	6a 0a		 push	 10			; 0000000aH
  0019b	6a 00		 push	 0
  0019d	6a ff		 push	 -1
  0019f	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  001ab	83 c4 10	 add	 esp, 16			; 00000010H

; 9195 : 		return;

  001ae	e9 83 14 00 00	 jmp	 $LN145@CGPShopReq@7
$LN122@CGPShopReq@7:

; 9196 : 	}
; 9197 : #endif
; 9198 : 
; 9199 : #if (ENABLETEST_NEWPVP == 1)
; 9200 : 	if (g_NewPVP.IsDuel(gObj[aSourceIndex])) {
; 9201 : 		 GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);
; 9202 : 		 return;
; 9203 : 	}
; 9204 : 	
; 9205 : 	if (g_NewPVP.IsObserver(gObj[aSourceIndex])) {
; 9206 : 		 GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);
; 9207 : 		 return;
; 9208 : 	}
; 9209 : #endif
; 9210 : 
; 9211 : 	if ( lpObj->m_bPShopOpen == false )

  001b3	80 bb c4 0e 00
	00 00		 cmp	 BYTE PTR [ebx+3780], 0
  001ba	75 2e		 jne	 SHORT $LN121@CGPShopReq@7

; 9212 : 	{
; 9213 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did not Open PShop",
; 9214 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  001bc	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  001bf	51		 push	 ecx
  001c0	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  001c3	52		 push	 edx
  001c4	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  001c7	50		 push	 eax
  001c8	83 c6 6c	 add	 esi, 108		; 0000006cH
  001cb	56		 push	 esi
  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9215 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 3);

  001d7	6a 03		 push	 3
  001d9	6a 00		 push	 0
  001db	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001dd	51		 push	 ecx
  001de	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  001e4	52		 push	 edx

; 9216 : 		return;

  001e5	e9 44 14 00 00	 jmp	 $LN172@CGPShopReq@7
$LN121@CGPShopReq@7:

; 9217 : 	}
; 9218 : 
; 9219 : 	char szName[MAX_ACCOUNT_LEN+1] = {0};

  001ea	33 c0		 xor	 eax, eax
  001ec	89 45 d1	 mov	 DWORD PTR _szName$[ebp+1], eax
  001ef	89 45 d5	 mov	 DWORD PTR _szName$[ebp+5], eax
  001f2	66 89 45 d9	 mov	 WORD PTR _szName$[ebp+9], ax

; 9220 : 	memcpy(szName, lpMsg->btName, sizeof(lpMsg->btName));

  001f6	8b 47 06	 mov	 eax, DWORD PTR [edi+6]
  001f9	89 45 d0	 mov	 DWORD PTR _szName$[ebp], eax
  001fc	8b 4f 0a	 mov	 ecx, DWORD PTR [edi+10]
  001ff	89 4d d4	 mov	 DWORD PTR _szName$[ebp+4], ecx
  00202	66 8b 57 0e	 mov	 dx, WORD PTR [edi+14]
  00206	66 89 55 d8	 mov	 WORD PTR _szName$[ebp+8], dx

; 9221 : 	szName[MAX_ACCOUNT_LEN] = 0;

  0020a	c6 45 da 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 9222 : 	int iITEM_LOG_TYPE;
; 9223 : 	int iITEM_LOG_LEVEL;
; 9224 : 	int iITEM_LOG_DUR;
; 9225 : 	int iITEM_LOG_SERIAL;
; 9226 : 
; 9227 : 	if ( strcmp(szName, lpObj->Name) )

  0020e	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00211	8d 45 d0	 lea	 eax, DWORD PTR _szName$[ebp]
$LL157@CGPShopReq@7:
  00214	8a 10		 mov	 dl, BYTE PTR [eax]
  00216	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00218	75 1a		 jne	 SHORT $LN158@CGPShopReq@7
  0021a	84 d2		 test	 dl, dl
  0021c	74 12		 je	 SHORT $LN159@CGPShopReq@7
  0021e	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00221	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00224	75 0e		 jne	 SHORT $LN158@CGPShopReq@7
  00226	83 c0 02	 add	 eax, 2
  00229	83 c1 02	 add	 ecx, 2
  0022c	84 d2		 test	 dl, dl
  0022e	75 e4		 jne	 SHORT $LL157@CGPShopReq@7
$LN159@CGPShopReq@7:
  00230	33 c0		 xor	 eax, eax
  00232	eb 05		 jmp	 SHORT $LN160@CGPShopReq@7
$LN158@CGPShopReq@7:
  00234	1b c0		 sbb	 eax, eax
  00236	83 d8 ff	 sbb	 eax, -1
$LN160@CGPShopReq@7:
  00239	85 c0		 test	 eax, eax
  0023b	74 22		 je	 SHORT $LN120@CGPShopReq@7

; 9228 : 	{
; 9229 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch [%s] - [%s]",
; 9230 : 			lpSourceObj->AccountID, lpSourceObj->Name,szName, lpObj->Name);

  0023d	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  00240	50		 push	 eax
  00241	8d 45 d0	 lea	 eax, DWORD PTR _szName$[ebp]
  00244	50		 push	 eax
  00245	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00248	51		 push	 ecx
  00249	83 c6 6c	 add	 esi, 108		; 0000006cH
  0024c	56		 push	 esi
  0024d	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9231 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  00258	6a 06		 push	 6

; 9232 : 
; 9233 : 		return;

  0025a	e9 c3 13 00 00	 jmp	 $LN173@CGPShopReq@7
$LN120@CGPShopReq@7:

; 9234 : 	}
; 9235 : 
; 9236 : 	if ( lpObj->CloseType != -1 )

  0025f	80 7b 0b ff	 cmp	 BYTE PTR [ebx+11], -1
  00263	74 2e		 je	 SHORT $LN119@CGPShopReq@7

; 9237 : 	{
; 9238 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is Closing Connection",
; 9239 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00265	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  00268	50		 push	 eax
  00269	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  0026c	51		 push	 ecx
  0026d	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  00270	52		 push	 edx
  00271	83 c6 6c	 add	 esi, 108		; 0000006cH
  00274	56		 push	 esi
  00275	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9240 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,2);

  00280	6a 02		 push	 2
  00282	6a 00		 push	 0
  00284	8b 03		 mov	 eax, DWORD PTR [ebx]
  00286	50		 push	 eax
  00287	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0028d	51		 push	 ecx

; 9241 : 
; 9242 : 		return;

  0028e	e9 9b 13 00 00	 jmp	 $LN172@CGPShopReq@7
$LN119@CGPShopReq@7:

; 9243 : 	}
; 9244 : 
; 9245 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty &8) == 8 )

  00293	8b 83 10 02 00
	00		 mov	 eax, DWORD PTR [ebx+528]
  00299	a8 0c		 test	 al, 12			; 0000000cH
  0029b	0f 85 64 13 00
	00		 jne	 $LN117@CGPShopReq@7

; 9250 : 
; 9251 : 		return;
; 9252 : 	}
; 9253 : 
; 9254 : 	if ( (lpSourceObj->Penalty &4) == 4 || (lpSourceObj->Penalty &8) == 8 )

  002a1	f6 86 10 02 00
	00 0c		 test	 BYTE PTR [esi+528], 12	; 0000000cH
  002a8	0f 85 2c 13 00
	00		 jne	 $LN115@CGPShopReq@7

; 9260 : 	}
; 9261 : 
; 9262 : 	EnterCriticalSection(&lpObj->m_critPShopTrade);

  002ae	8d 83 00 0f 00
	00		 lea	 eax, DWORD PTR [ebx+3840]
  002b4	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv1887[ebp], eax
  002ba	50		 push	 eax
  002bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 9263 : 
; 9264 : 	if ( lpObj->m_bPShopTransaction == true )

  002c1	80 bb c5 0e 00
	00 01		 cmp	 BYTE PTR [ebx+3781], 1
  002c8	75 43		 jne	 SHORT $LN114@CGPShopReq@7

; 9265 : 	{
; 9266 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Already Trade With Other",
; 9267 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  002ca	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  002cd	50		 push	 eax
  002ce	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  002d1	52		 push	 edx
  002d2	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  002d5	50		 push	 eax
  002d6	83 c6 6c	 add	 esi, 108		; 0000006cH
  002d9	56		 push	 esi
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9268 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,4);

  002e5	6a 04		 push	 4
  002e7	6a 00		 push	 0
  002e9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  002eb	51		 push	 ecx
  002ec	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  002f2	52		 push	 edx
  002f3	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  002f8	83 c4 24	 add	 esp, 36			; 00000024H

; 9269 : 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  002fb	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv1887[ebp]
  00301	50		 push	 eax
  00302	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9270 : 
; 9271 : 	}
; 9272 : 	else

  00308	e9 29 13 00 00	 jmp	 $LN145@CGPShopReq@7
$LN114@CGPShopReq@7:

; 9273 : 	{
; 9274 : 		lpObj->m_bPShopTransaction = true;

  0030d	c6 83 c5 0e 00
	00 01		 mov	 BYTE PTR [ebx+3781], 1

; 9275 : 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00314	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv1887[ebp]
  0031a	51		 push	 ecx
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 9276 : 
; 9277 : 		if ( gObjCheckSerial0ItemList(&lpObj->Inventory1[lpMsg->btItemPos]) != FALSE )

  00321	0f b6 57 10	 movzx	 edx, BYTE PTR [edi+16]
  00325	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0032b	03 93 34 0e 00
	00		 add	 edx, DWORD PTR [ebx+3636]
  00331	52		 push	 edx
  00332	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00337	83 c4 04	 add	 esp, 4
  0033a	85 c0		 test	 eax, eax
  0033c	0f 84 a2 00 00
	00		 je	 $LN112@CGPShopReq@7

; 9278 : 		{
; 9279 : 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  00342	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00347	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0034c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00351	50		 push	 eax
  00352	8b 03		 mov	 eax, DWORD PTR [ebx]
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 9280 : 			GCReFillSend(aSourceIndex,(WORD)lpSourceObj->Life, 0xFD, 1, lpSourceObj->iShield);

  0035a	8b 8e 54 01 00
	00		 mov	 ecx, DWORD PTR [esi+340]
  00360	51		 push	 ecx
  00361	6a 01		 push	 1
  00363	68 fd 00 00 00	 push	 253			; 000000fdH
  00368	d9 86 fc 00 00
	00		 fld	 DWORD PTR [esi+252]
  0036e	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv2132[ebp]
  00374	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv2132[ebp]
  0037b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00380	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv2129[ebp], eax
  00386	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv2129[ebp]
  0038c	db 9d 70 ff ff
	ff		 fistp	 DWORD PTR tv2127[ebp]
  00392	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv2132[ebp]
  00398	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR tv2127[ebp]
  0039f	0f b7 c2	 movzx	 eax, dx
  003a2	50		 push	 eax
  003a3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  003a9	51		 push	 ecx
  003aa	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  003af	83 c4 1c	 add	 esp, 28			; 0000001cH

; 9281 : 
; 9282 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%d)",
; 9283 : 				lpObj->AccountID, lpObj->Name, lpObj->Inventory1[lpMsg->btItemPos].GetName(), lpMsg->btItemPos);

  003b2	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  003b6	51		 push	 ecx
  003b7	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003bd	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  003c3	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003c8	50		 push	 eax
  003c9	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  003cc	50		 push	 eax
  003cd	83 c3 6c	 add	 ebx, 108		; 0000006cH
  003d0	53		 push	 ebx
  003d1	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  003d6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003dc	83 c4 14	 add	 esp, 20			; 00000014H

; 9284 : 
; 9285 : 			return;

  003df	e9 52 12 00 00	 jmp	 $LN145@CGPShopReq@7
$LN112@CGPShopReq@7:

; 9286 : 		}
; 9287 : 
; 9288 : 
; 9289 : 
; 9290 : 		// New for Check Item Serials
; 9291 : 		if ( ::gObjInventorySearchSerialNumber(&gObj[aSourceIndex], lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  003e4	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  003e8	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003ee	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  003f4	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  003f9	50		 push	 eax
  003fa	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv1825[ebp]
  00400	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00406	50		 push	 eax
  00407	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0040c	83 c4 08	 add	 esp, 8
  0040f	85 c0		 test	 eax, eax
  00411	0f 85 87 00 00
	00		 jne	 $LN111@CGPShopReq@7

; 9292 : 		{
; 9293 : 			::GCReFillSend(aSourceIndex,(WORD)lpSourceObj->Life, -3, 1, lpSourceObj->iShield);

  00417	8b 8e 54 01 00
	00		 mov	 ecx, DWORD PTR [esi+340]
  0041d	51		 push	 ecx
  0041e	6a 01		 push	 1
  00420	68 fd 00 00 00	 push	 253			; 000000fdH
  00425	d9 86 fc 00 00
	00		 fld	 DWORD PTR [esi+252]
  0042b	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv2119[ebp]
  00431	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv2119[ebp]
  00438	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0043d	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv2116[ebp], eax
  00443	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv2116[ebp]
  00449	db 9d 70 ff ff
	ff		 fistp	 DWORD PTR tv2114[ebp]
  0044f	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv2119[ebp]
  00455	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR tv2114[ebp]
  0045c	0f b7 c2	 movzx	 eax, dx
  0045f	50		 push	 eax
  00460	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00466	51		 push	 ecx
  00467	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 9294 : 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 9295 : 				__FILE__, __LINE__);

  0046c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00471	68 4f 24 00 00	 push	 9295			; 0000244fH
  00476	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0047b	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv1825[ebp]
  00481	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00485	52		 push	 edx
  00486	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0048a	50		 push	 eax
  0048b	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00490	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00496	83 c4 28	 add	 esp, 40			; 00000028H

; 9296 : 
; 9297 : 			return;

  00499	e9 98 11 00 00	 jmp	 $LN145@CGPShopReq@7
$LN111@CGPShopReq@7:

; 9298 : 		}
; 9299 : 
; 9300 : 		if ( ::gObjInventorySearchSerialNumber(lpObj, lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  0049e	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  004a2	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  004a8	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  004ae	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  004b3	50		 push	 eax
  004b4	53		 push	 ebx
  004b5	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  004ba	83 c4 08	 add	 esp, 8
  004bd	85 c0		 test	 eax, eax
  004bf	75 76		 jne	 SHORT $LN110@CGPShopReq@7

; 9301 : 		{
; 9302 : 			GCReFillSend(lpObj->m_Index,(WORD)lpObj->Life, -3, 1, lpObj->iShield);

  004c1	8b 8b 54 01 00
	00		 mov	 ecx, DWORD PTR [ebx+340]
  004c7	51		 push	 ecx
  004c8	6a 01		 push	 1
  004ca	68 fd 00 00 00	 push	 253			; 000000fdH
  004cf	d9 83 fc 00 00
	00		 fld	 DWORD PTR [ebx+252]
  004d5	d9 bd 76 ff ff
	ff		 fnstcw	 WORD PTR tv2108[ebp]
  004db	0f b7 85 76 ff
	ff ff		 movzx	 eax, WORD PTR tv2108[ebp]
  004e2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  004e7	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv2105[ebp], eax
  004ed	d9 ad 70 ff ff
	ff		 fldcw	 WORD PTR tv2105[ebp]
  004f3	db 9d 70 ff ff
	ff		 fistp	 DWORD PTR tv2103[ebp]
  004f9	d9 ad 76 ff ff
	ff		 fldcw	 WORD PTR tv2108[ebp]
  004ff	66 8b 95 70 ff
	ff ff		 mov	 dx, WORD PTR tv2103[ebp]
  00506	0f b7 c2	 movzx	 eax, dx
  00509	50		 push	 eax
  0050a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0050c	51		 push	 ecx
  0050d	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 9303 : 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 9304 : 				lpObj->AccountID, lpObj->Name,
; 9305 : 				__FILE__, __LINE__);

  00512	68 59 24 00 00	 push	 9305			; 00002459H
  00517	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0051c	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  0051f	50		 push	 eax
  00520	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00523	53		 push	 ebx
  00524	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00529	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0052f	83 c4 28	 add	 esp, 40			; 00000028H

; 9306 : 
; 9307 : 			return;

  00532	e9 ff 10 00 00	 jmp	 $LN145@CGPShopReq@7
$LN110@CGPShopReq@7:

; 9308 : 		}
; 9309 : 
; 9310 : 		if (gObjFixInventoryPointer(aSourceIndex) == false )

  00537	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0053d	52		 push	 edx
  0053e	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00543	83 c4 04	 add	 esp, 4
  00546	84 c0		 test	 al, al
  00548	75 18		 jne	 SHORT $LN109@CGPShopReq@7

; 9311 : 		{
; 9312 : 			LogAdd( "[Fix Inv.Ptr] False Location - %s, %d", 
; 9313 : 				__FILE__, __LINE__);

  0054a	68 61 24 00 00	 push	 9313			; 00002461H
  0054f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00554	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00559	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0055f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN109@CGPShopReq@7:

; 9314 : 		}
; 9315 : 
; 9316 : 		if ( gObj[aSourceIndex].pTransaction == 1 )

  00562	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00567	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv1825[ebp]
  0056d	80 bc 01 30 0e
	00 00 01	 cmp	 BYTE PTR [ecx+eax+3632], 1
  00575	75 2b		 jne	 SHORT $LN108@CGPShopReq@7

; 9317 : 		{
; 9318 : 			LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Requester Transaction == 1, IF_TYPE : %d",
; 9319 : 				lpSourceObj->AccountID, lpSourceObj->Name, lpSourceObj->m_IfState.type);

  00577	8b 96 1c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3612]
  0057d	c1 ea 06	 shr	 edx, 6
  00580	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00586	52		 push	 edx
  00587	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0058a	50		 push	 eax
  0058b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0058e	56		 push	 esi
  0058f	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00594	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0059a	83 c4 10	 add	 esp, 16			; 00000010H

; 9320 : 			return;

  0059d	e9 94 10 00 00	 jmp	 $LN145@CGPShopReq@7
$LN108@CGPShopReq@7:

; 9321 : 		}
; 9322 : 
; 9323 : 		iITEM_LOG_TYPE=0;
; 9324 : 		iITEM_LOG_LEVEL=0;
; 9325 : 		iITEM_LOG_DUR=0;
; 9326 : 		iITEM_LOG_SERIAL = 0;
; 9327 : 
; 9328 : 		__try

  005a2	9b		 fwait
  005a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 9329 : 		{
; 9330 : 			if ( PSHOP_RANGE(lpMsg->btItemPos) == FALSE )

  005aa	0f b6 77 10	 movzx	 esi, BYTE PTR [edi+16]
  005ae	8d 86 34 ff ff
	ff		 lea	 eax, DWORD PTR [esi-204]
  005b4	85 c0		 test	 eax, eax
  005b6	78 0e		 js	 SHORT $LN156@CGPShopReq@7
  005b8	33 c9		 xor	 ecx, ecx
  005ba	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005bd	0f 9e c1	 setle	 cl
  005c0	8b c1		 mov	 eax, ecx
  005c2	85 c0		 test	 eax, eax
  005c4	75 2c		 jne	 SHORT $LN106@CGPShopReq@7
$LN156@CGPShopReq@7:

; 9331 : 			{
; 9332 : 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 5);

  005c6	6a 05		 push	 5
  005c8	6a 00		 push	 0
  005ca	8b 13		 mov	 edx, DWORD PTR [ebx]
  005cc	52		 push	 edx
  005cd	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  005d3	50		 push	 eax
  005d4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9333 : 				return;

  005d9	6a fe		 push	 -2			; fffffffeH
  005db	9b		 fwait
  005dc	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  005df	51		 push	 ecx
  005e0	68 00 00 00 00	 push	 OFFSET ___security_cookie
  005e5	e8 00 00 00 00	 call	 __local_unwind4
  005ea	83 c4 1c	 add	 esp, 28			; 0000001cH
  005ed	e9 44 10 00 00	 jmp	 $LN145@CGPShopReq@7
$LN106@CGPShopReq@7:

; 9334 : 			}
; 9335 : 
; 9336 : 			if ( lpObj->m_bMapSvrMoveQuit == true )

  005f2	80 bb e4 1b 00
	00 01		 cmp	 BYTE PTR [ebx+7140], 1
  005f9	75 2b		 jne	 SHORT $LN105@CGPShopReq@7

; 9337 : 			{
; 9338 : 				CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  005fb	6a 02		 push	 2
  005fd	6a 00		 push	 0
  005ff	6a ff		 push	 -1
  00601	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00607	52		 push	 edx
  00608	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9339 : 				return;

  0060d	6a fe		 push	 -2			; fffffffeH
  0060f	9b		 fwait
  00610	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00613	50		 push	 eax
  00614	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00619	e8 00 00 00 00	 call	 __local_unwind4
  0061e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00621	e9 10 10 00 00	 jmp	 $LN145@CGPShopReq@7
$LN105@CGPShopReq@7:

; 9340 : 			}
; 9341 : 
; 9342 : 			if ( lpObj->Inventory1[lpMsg->btItemPos].IsItem() == TRUE )

  00626	8b ce		 mov	 ecx, esi
  00628	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0062e	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  00634	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00639	83 f8 01	 cmp	 eax, 1
  0063c	0f 85 bd 0b 00
	00		 jne	 $LN1@CGPShopReq@7

; 9343 : 			{
; 9344 : 				int n;
; 9345 : 				int invSize;
; 9346 : 				int iPShopValue = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  00642	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _lpMsg$GSCopy$[ebp]
  00648	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  0064c	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00652	8b 93 34 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3636]
  00658	8b 7c 10 74	 mov	 edi, DWORD PTR [eax+edx+116]
  0065c	89 bd 70 ff ff
	ff		 mov	 DWORD PTR _iPShopValue$247659[ebp], edi

; 9347 : 				int iPShopBonusValue = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopBonus;

  00662	8b 4c 10 78	 mov	 ecx, DWORD PTR [eax+edx+120]
  00666	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _iPShopBonusValue$247660[ebp], ecx

; 9348 : 				#if(DEV_PERSONAL_CREDIT)
; 9349 : 				int iPShopCreditValue = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopCredit;

  0066c	8b 94 10 84 00
	00 00		 mov	 edx, DWORD PTR [eax+edx+132]
  00673	89 95 60 ff ff
	ff		 mov	 DWORD PTR _iPShopCreditValue$247661[ebp], edx

; 9350 : 				#endif
; 9351 : 				short aPShopJewelValue[4];
; 9352 : 
; 9353 : 				bool ExBankPlus = false;

  00679	c6 85 6e ff ff
	ff 00		 mov	 BYTE PTR _ExBankPlus$247663[ebp], 0

; 9354 : 				bool ExBankMinus = false;

  00680	c6 85 6f ff ff
	ff 00		 mov	 BYTE PTR _ExBankMinus$247664[ebp], 0

; 9355 : 
; 9356 : 				if(g_ZtLicense.CheckUser(SILVER1) || g_ZtLicense.CheckUser(SILVER2))

  00687	6a 07		 push	 7
  00689	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0068e	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00693	84 c0		 test	 al, al
  00695	75 10		 jne	 SHORT $LN102@CGPShopReq@7
  00697	6a 08		 push	 8
  00699	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0069e	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  006a3	84 c0		 test	 al, al
  006a5	74 0e		 je	 SHORT $LN103@CGPShopReq@7
$LN102@CGPShopReq@7:

; 9357 : 				{
; 9358 : 					ExBankPlus = true;

  006a7	c6 85 6e ff ff
	ff 01		 mov	 BYTE PTR _ExBankPlus$247663[ebp], 1

; 9359 : 					ExBankMinus = true;

  006ae	c6 85 6f ff ff
	ff 01		 mov	 BYTE PTR _ExBankMinus$247664[ebp], 1
$LN103@CGPShopReq@7:

; 9360 : 				}
; 9361 : 
; 9362 : 				aPShopJewelValue[0] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopBlessValue;

  006b5	8b 8b 34 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3636]
  006bb	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  006bf	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  006c5	03 c1		 add	 eax, ecx
  006c7	0f b7 50 7c	 movzx	 edx, WORD PTR [eax+124]
  006cb	66 89 55 dc	 mov	 WORD PTR _aPShopJewelValue$247662[ebp], dx

; 9363 : 				aPShopJewelValue[1] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopSoulValue;

  006cf	0f b7 50 7e	 movzx	 edx, WORD PTR [eax+126]
  006d3	66 89 55 de	 mov	 WORD PTR _aPShopJewelValue$247662[ebp+2], dx

; 9364 : 				aPShopJewelValue[2] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopChaosValue;

  006d7	66 8b 90 80 00
	00 00		 mov	 dx, WORD PTR [eax+128]
  006de	66 89 55 e0	 mov	 WORD PTR _aPShopJewelValue$247662[ebp+4], dx

; 9365 : 				aPShopJewelValue[3] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopLifeValue;

  006e2	66 8b 80 82 00
	00 00		 mov	 ax, WORD PTR [eax+130]
  006e9	66 89 45 e2	 mov	 WORD PTR _aPShopJewelValue$247662[ebp+6], ax

; 9366 : 
; 9367 : 				if ( iPShopValue < 0 ||
; 9368 : 					 iPShopBonusValue < 0 ||
; 9369 : 					 aPShopJewelValue[0] < 0 ||
; 9370 : 					 aPShopJewelValue[1] < 0 ||
; 9371 : 					 aPShopJewelValue[2] < 0 ||
; 9372 : 					 aPShopJewelValue[3] < 0
; 9373 : 					 #if(DEV_PERSONAL_CREDIT)
; 9374 : 					 || iPShopCreditValue < 0
; 9375 : 					 #endif
; 9376 : 					 )

  006ed	85 ff		 test	 edi, edi
  006ef	0f 88 8d 0e 00
	00		 js	 $LN100@CGPShopReq@7
  006f5	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _iPShopBonusValue$247660[ebp], 0
  006fc	0f 8c 80 0e 00
	00		 jl	 $LN100@CGPShopReq@7
  00702	66 83 7d dc 00	 cmp	 WORD PTR _aPShopJewelValue$247662[ebp], 0
  00707	0f 8c 75 0e 00
	00		 jl	 $LN100@CGPShopReq@7
  0070d	66 83 7d de 00	 cmp	 WORD PTR _aPShopJewelValue$247662[ebp+2], 0
  00712	0f 8c 6a 0e 00
	00		 jl	 $LN100@CGPShopReq@7
  00718	66 85 d2	 test	 dx, dx
  0071b	0f 88 61 0e 00
	00		 js	 $LN100@CGPShopReq@7
  00721	66 85 c0	 test	 ax, ax
  00724	0f 88 58 0e 00
	00		 js	 $LN100@CGPShopReq@7
  0072a	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR _iPShopCreditValue$247661[ebp], 0
  00731	0f 8c 4b 0e 00
	00		 jl	 $LN100@CGPShopReq@7

; 9383 : 				}
; 9384 : 
; 9385 : 				if( iPShopValue > 0 )

  00737	85 ff		 test	 edi, edi

; 9386 : 				{
; 9387 : 					if ( gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue )

  00739	8b bd 78 ff ff
	ff		 mov	 edi, DWORD PTR tv1825[ebp]

; 9383 : 				}
; 9384 : 
; 9385 : 				if( iPShopValue > 0 )

  0073f	0f 8e cd 00 00
	00		 jle	 $LN97@CGPShopReq@7

; 9386 : 				{
; 9387 : 					if ( gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue )

  00745	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  00749	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0074f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00755	8b 94 17 f0 00
	00 00		 mov	 edx, DWORD PTR [edi+edx+240]
  0075c	3b 54 08 74	 cmp	 edx, DWORD PTR [eax+ecx+116]
  00760	7d 4d		 jge	 SHORT $LN98@CGPShopReq@7

; 9388 : 					{
; 9389 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",
; 9390 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00762	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  00765	50		 push	 eax
  00766	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00769	50		 push	 eax
  0076a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00770	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00773	51		 push	 ecx
  00774	83 c0 6c	 add	 eax, 108		; 0000006cH
  00777	50		 push	 eax
  00778	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0077d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9391 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);

  00783	6a 07		 push	 7
  00785	6a 00		 push	 0
  00787	8b 13		 mov	 edx, DWORD PTR [ebx]
  00789	52		 push	 edx
  0078a	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00790	50		 push	 eax
  00791	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9392 : 						return;

  00796	6a fe		 push	 -2			; fffffffeH
  00798	9b		 fwait
  00799	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0079c	51		 push	 ecx
  0079d	68 00 00 00 00	 push	 OFFSET ___security_cookie
  007a2	e8 00 00 00 00	 call	 __local_unwind4
  007a7	83 c4 30	 add	 esp, 48			; 00000030H
  007aa	e9 87 0e 00 00	 jmp	 $LN145@CGPShopReq@7
$LN98@CGPShopReq@7:

; 9393 : 					}
; 9394 : 
; 9395 : 					if ( gObjCheckMaxZen(lpObj->m_Index, iPShopValue) == FALSE )

  007af	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _iPShopValue$247659[ebp]
  007b5	52		 push	 edx
  007b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  007b8	50		 push	 eax
  007b9	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  007be	83 c4 08	 add	 esp, 8
  007c1	85 c0		 test	 eax, eax
  007c3	75 4d		 jne	 SHORT $LN97@CGPShopReq@7

; 9396 : 					{
; 9397 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",
; 9398 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  007c5	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  007c8	50		 push	 eax
  007c9	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  007cc	51		 push	 ecx
  007cd	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  007d3	8d 50 77	 lea	 edx, DWORD PTR [eax+119]
  007d6	52		 push	 edx
  007d7	83 c0 6c	 add	 eax, 108		; 0000006cH
  007da	50		 push	 eax
  007db	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  007e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9399 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  007e6	6a 08		 push	 8
  007e8	6a 00		 push	 0
  007ea	8b 03		 mov	 eax, DWORD PTR [ebx]
  007ec	50		 push	 eax
  007ed	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  007f3	51		 push	 ecx
  007f4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9400 : 						return;

  007f9	6a fe		 push	 -2			; fffffffeH
  007fb	9b		 fwait
  007fc	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  007ff	52		 push	 edx
  00800	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00805	e8 00 00 00 00	 call	 __local_unwind4
  0080a	83 c4 30	 add	 esp, 48			; 00000030H
  0080d	e9 24 0e 00 00	 jmp	 $LN145@CGPShopReq@7
$LN97@CGPShopReq@7:

; 9401 : 					}
; 9402 : 				}
; 9403 : 				// --
; 9404 : 				//g_PersonalShopZt.BonusPrice;
; 9405 : 				if( iPShopBonusValue > 0 )

  00812	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _iPShopBonusValue$247660[ebp], 0
  00819	0f 8e 95 00 00
	00		 jle	 $LN91@CGPShopReq@7

; 9406 : 				{
; 9407 : 					if(g_PersonalShopZt.BonusPrice == 1)

  0081f	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A+20
  00824	83 f8 01	 cmp	 eax, 1
  00827	75 63		 jne	 SHORT $LN95@CGPShopReq@7

; 9408 : 					{
; 9409 : 						if ( gObj[aSourceIndex].ZtCred < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopBonus )

  00829	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0082e	d9 84 07 a8 22
	00 00		 fld	 DWORD PTR [edi+eax+8872]
  00835	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  00839	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0083f	8b 93 34 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3636]
  00845	db 44 11 78	 fild	 DWORD PTR [ecx+edx+120]
  00849	de d9		 fcompp
$LN183@CGPShopReq@7:
  0084b	df e0		 fnstsw	 ax
  0084d	f6 c4 41	 test	 ah, 65			; 00000041H
  00850	75 62		 jne	 SHORT $LN91@CGPShopReq@7

; 9410 : 						{
; 9411 : 							LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",
; 9412 : 								lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  00852	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  00855	50		 push	 eax
  00856	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00859	53		 push	 ebx
  0085a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00860	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00863	51		 push	 ecx
  00864	83 c0 6c	 add	 eax, 108		; 0000006cH
  00867	50		 push	 eax
  00868	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
$LN184@CGPShopReq@7:
  0086d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9413 : 							//::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);
; 9414 : 							return;

  00873	6a fe		 push	 -2			; fffffffeH
  00875	9b		 fwait
  00876	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  00879	52		 push	 edx
  0087a	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0087f	e8 00 00 00 00	 call	 __local_unwind4
  00884	83 c4 20	 add	 esp, 32			; 00000020H
  00887	e9 aa 0d 00 00	 jmp	 $LN145@CGPShopReq@7
$LN95@CGPShopReq@7:

; 9415 : 						}
; 9416 : 					}
; 9417 : 					else if(g_PersonalShopZt.BonusPrice == 2)

  0088c	83 f8 02	 cmp	 eax, 2
  0088f	75 23		 jne	 SHORT $LN91@CGPShopReq@7

; 9418 : 					{
; 9419 : 						if ( gObj[aSourceIndex].GameShop.WCoinC < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopBonus )

  00891	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  00895	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0089b	8b 8b 34 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3636]
  008a1	db 44 08 78	 fild	 DWORD PTR [eax+ecx+120]
  008a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008ab	dc 9c 17 00 23
	00 00		 fcomp	 QWORD PTR [edi+edx+8960]

; 9420 : 						{
; 9421 : 							LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",
; 9422 : 								lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 9423 : 							//::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);
; 9424 : 							return;

  008b2	eb 97		 jmp	 SHORT $LN183@CGPShopReq@7
$LN91@CGPShopReq@7:

; 9425 : 						}							
; 9426 : 					}
; 9427 : 
; 9428 : 					//if ( gObjCheckMaxZen(lpObj->m_Index, iPShopBonusValue) == FALSE )
; 9429 : 					//{
; 9430 : 					//	LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",
; 9431 : 					//		lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 9432 : 					//	::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);
; 9433 : 					//	return;
; 9434 : 					//}
; 9435 : 				}
; 9436 : 
; 9437 : 				#if(DEV_PERSONAL_CREDIT)
; 9438 : 
; 9439 : 				if(iPShopCreditValue > 0)

  008b4	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR _iPShopCreditValue$247661[ebp], 0
  008bb	7e 55		 jle	 SHORT $LN88@CGPShopReq@7

; 9440 : 				{
; 9441 : 					if(g_PersonalShopZt.CreditPrice == 1)

  008bd	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A+24, 1
  008c4	75 4c		 jne	 SHORT $LN88@CGPShopReq@7

; 9442 : 					{
; 9443 : 						if ( gObj[aSourceIndex].ZtCred < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopCredit )

  008c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008cb	d9 84 07 a8 22
	00 00		 fld	 DWORD PTR [edi+eax+8872]
  008d2	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  008d6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  008dc	8b 93 34 0e 00
	00		 mov	 edx, DWORD PTR [ebx+3636]
  008e2	db 84 11 84 00
	00 00		 fild	 DWORD PTR [ecx+edx+132]
  008e9	de d9		 fcompp
  008eb	df e0		 fnstsw	 ax
  008ed	f6 c4 41	 test	 ah, 65			; 00000041H
  008f0	75 20		 jne	 SHORT $LN88@CGPShopReq@7

; 9444 : 						{
; 9445 : 							LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Credit",
; 9446 : 								lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  008f2	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  008f5	50		 push	 eax
  008f6	83 c3 6c	 add	 ebx, 108		; 0000006cH
  008f9	53		 push	 ebx
  008fa	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  00900	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00903	51		 push	 ecx
  00904	83 c0 6c	 add	 eax, 108		; 0000006cH
  00907	50		 push	 eax
  00908	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@OFBBNFMD@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@

; 9447 : 							return;

  0090d	e9 5b ff ff ff	 jmp	 $LN184@CGPShopReq@7
$LN88@CGPShopReq@7:

; 9448 : 						}
; 9449 : 					}
; 9450 : 				}
; 9451 : 
; 9452 : 				#endif
; 9453 : 
; 9454 : 
; 9455 : 				#if(CUSTOM_ITEM_MOVE)
; 9456 : 				if(g_ItemMove.CheckTrade(lpObj->Inventory1[lpMsg->btItemPos].m_Type))

  00912	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  00916	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  0091c	8b 8b 34 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3636]
  00922	0f bf 54 08 06	 movsx	 edx, WORD PTR [eax+ecx+6]
  00927	52		 push	 edx
  00928	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMove@@3VCItemMove@@A ; g_ItemMove
  0092d	e8 00 00 00 00	 call	 ?CheckTrade@CItemMove@@QAE_NH@Z ; CItemMove::CheckTrade
  00932	84 c0		 test	 al, al
  00934	74 3a		 je	 SHORT $LN87@CGPShopReq@7

; 9457 : 				{
; 9458 : 					GCServerMsgStringSend("Block Trade Item",lpObj->m_Index,1);

  00936	6a 01		 push	 1
  00938	8b 03		 mov	 eax, DWORD PTR [ebx]
  0093a	50		 push	 eax
  0093b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OCLJIALE@Block?5Trade?5Item?$AA@
  00940	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9459 : 					::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 10);

  00945	6a 0a		 push	 10			; 0000000aH
  00947	6a 00		 push	 0
  00949	6a ff		 push	 -1
  0094b	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00951	51		 push	 ecx
  00952	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9460 : 					return;

  00957	6a fe		 push	 -2			; fffffffeH
  00959	9b		 fwait
  0095a	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  0095d	52		 push	 edx
  0095e	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00963	e8 00 00 00 00	 call	 __local_unwind4
  00968	83 c4 28	 add	 esp, 40			; 00000028H
  0096b	e9 c6 0c 00 00	 jmp	 $LN145@CGPShopReq@7
$LN87@CGPShopReq@7:

; 9461 : 				}
; 9462 : 				#endif
; 9463 : 
; 9464 : 				int iFreeSpaceReq = 0;

  00970	33 f6		 xor	 esi, esi
  00972	89 b5 54 ff ff
	ff		 mov	 DWORD PTR _iFreeSpaceReq$247687[ebp], esi
$LN174@CGPShopReq@7:

; 9465 : 				short aPShopJewel[4];
; 9466 : 				short aPShopJewelBoundle[4][3];
; 9467 : 				
; 9468 : 				for( n = 0; n < 4; n++)

  00978	89 b5 78 ff ff
	ff		 mov	 DWORD PTR _n$247657[ebp], esi
  0097e	83 fe 04	 cmp	 esi, 4
  00981	0f 8d bb 00 00
	00		 jge	 $LN84@CGPShopReq@7

; 9469 : 				{
; 9470 : 					int tmpJewelCnt = aPShopJewelValue[n];

  00987	0f bf 7c 75 dc	 movsx	 edi, WORD PTR _aPShopJewelValue$247662[ebp+esi*2]

; 9471 : 
; 9472 : 					if( tmpJewelCnt > 0 )

  0098c	85 ff		 test	 edi, edi
  0098e	0f 8e a8 00 00
	00		 jle	 $LN83@CGPShopReq@7

; 9473 : 					{
; 9474 : 						aPShopJewelBoundle[n][0] = tmpJewelCnt/30;

  00994	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00999	f7 ef		 imul	 edi
  0099b	03 d7		 add	 edx, edi
  0099d	c1 fa 04	 sar	 edx, 4
  009a0	8b c2		 mov	 eax, edx
  009a2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  009a5	03 c2		 add	 eax, edx
  009a7	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  009aa	03 c9		 add	 ecx, ecx
  009ac	8d 54 0d b8	 lea	 edx, DWORD PTR _aPShopJewelBoundle$247689[ebp+ecx]
  009b0	89 95 5c ff ff
	ff		 mov	 DWORD PTR tv2035[ebp], edx
  009b6	66 89 02	 mov	 WORD PTR [edx], ax

; 9475 : 						tmpJewelCnt = tmpJewelCnt%30;

  009b9	8b d0		 mov	 edx, eax
  009bb	c1 e2 04	 shl	 edx, 4
  009be	2b d0		 sub	 edx, eax
  009c0	f7 da		 neg	 edx
  009c2	8d 3c 57	 lea	 edi, DWORD PTR [edi+edx*2]

; 9476 : 						aPShopJewelBoundle[n][1] = tmpJewelCnt/20;

  009c5	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  009ca	f7 ef		 imul	 edi
  009cc	c1 fa 03	 sar	 edx, 3
  009cf	8b c2		 mov	 eax, edx
  009d1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  009d4	03 c2		 add	 eax, edx
  009d6	8d 54 0d ba	 lea	 edx, DWORD PTR _aPShopJewelBoundle$247689[ebp+ecx+2]
  009da	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv2040[ebp], edx
  009e0	66 89 02	 mov	 WORD PTR [edx], ax

; 9477 : 						tmpJewelCnt = tmpJewelCnt%20;

  009e3	8b d0		 mov	 edx, eax
  009e5	f7 da		 neg	 edx
  009e7	03 d2		 add	 edx, edx
  009e9	03 d2		 add	 edx, edx
  009eb	2b d0		 sub	 edx, eax
  009ed	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]

; 9478 : 						aPShopJewelBoundle[n][2] = tmpJewelCnt/10;

  009f0	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  009f5	f7 ef		 imul	 edi
  009f7	c1 fa 02	 sar	 edx, 2
  009fa	8b c2		 mov	 eax, edx
  009fc	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  009ff	03 c2		 add	 eax, edx
  00a01	66 89 44 0d bc	 mov	 WORD PTR _aPShopJewelBoundle$247689[ebp+ecx+4], ax

; 9479 : 						aPShopJewel[n] = tmpJewelCnt%10;

  00a06	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00a09	03 d2		 add	 edx, edx
  00a0b	8b cf		 mov	 ecx, edi
  00a0d	2b ca		 sub	 ecx, edx
  00a0f	66 89 4c 75 b0	 mov	 WORD PTR _aPShopJewel$247688[ebp+esi*2], cx

; 9480 : 
; 9481 : 						iFreeSpaceReq += aPShopJewel[n] + aPShopJewelBoundle[n][0] + aPShopJewelBoundle[n][1] + aPShopJewelBoundle[n][2];

  00a14	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv2035[ebp]
  00a1a	0f bf 12	 movsx	 edx, WORD PTR [edx]
  00a1d	98		 cwde
  00a1e	03 d0		 add	 edx, eax
  00a20	0f bf c9	 movsx	 ecx, cx
  00a23	03 d1		 add	 edx, ecx
  00a25	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv2040[ebp]
  00a2b	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00a2e	03 8d 54 ff ff
	ff		 add	 ecx, DWORD PTR _iFreeSpaceReq$247687[ebp]
  00a34	03 ca		 add	 ecx, edx
  00a36	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _iFreeSpaceReq$247687[ebp], ecx
$LN83@CGPShopReq@7:

; 9465 : 				short aPShopJewel[4];
; 9466 : 				short aPShopJewelBoundle[4][3];
; 9467 : 				
; 9468 : 				for( n = 0; n < 4; n++)

  00a3c	46		 inc	 esi
  00a3d	e9 36 ff ff ff	 jmp	 $LN174@CGPShopReq@7
$LN84@CGPShopReq@7:

; 9482 : 					}
; 9483 : 				}
; 9484 : 
; 9485 : 				if( iFreeSpaceReq > 0 )

  00a42	8b b5 54 ff ff
	ff		 mov	 esi, DWORD PTR _iFreeSpaceReq$247687[ebp]
  00a48	85 f6		 test	 esi, esi
  00a4a	7e 16		 jle	 SHORT $LN81@CGPShopReq@7

; 9486 : 				{
; 9487 : 					int iEmptyCount = GetInventoryEmptyPoint(lpObj->m_Index);

  00a4c	8b 13		 mov	 edx, DWORD PTR [ebx]
  00a4e	52		 push	 edx
  00a4f	e8 00 00 00 00	 call	 ?GetInventoryEmptyPoint@@YAHH@Z ; GetInventoryEmptyPoint
  00a54	83 c4 04	 add	 esp, 4

; 9488 : 					/*
; 9489 : 					invSize = MAIN_INVENTORY_SIZE;
; 9490 : 				
; 9491 : 					if( lpObj->ExpandedInventory < 4 )	
; 9492 : 					{
; 9493 : 						invSize = (MAIN_INVENTORY_SIZE)-(32*(4-lpObj->ExpandedInventory));
; 9494 : 					}
; 9495 : 
; 9496 : 					for ( int x=0; x<invSize;x++)
; 9497 : 					{
; 9498 : 						if ( lpObj->pInventoryMap[x] == 0xFF )
; 9499 : 						{
; 9500 : 							iEmptyCount++;
; 9501 : 						}
; 9502 : 					}
; 9503 : 					*/
; 9504 : 
; 9505 : 					
; 9506 : 
; 9507 : 					if( iEmptyCount < iFreeSpaceReq )

  00a57	3b c6		 cmp	 eax, esi
  00a59	7d 07		 jge	 SHORT $LN81@CGPShopReq@7

; 9508 : 					{
; 9509 : 						ExBankPlus = true;

  00a5b	c6 85 6e ff ff
	ff 01		 mov	 BYTE PTR _ExBankPlus$247663[ebp], 1
$LN81@CGPShopReq@7:

; 9510 : 
; 9511 : 						//LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Store Reward",
; 9512 : 						//	lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 9513 : 						//::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 17);
; 9514 : 						//MsgOutput(aSourceIndex, "Trander no Empty Inventory");
; 9515 : 						//return;
; 9516 : 					}
; 9517 : 				}
; 9518 : 
; 9519 : 				bool bBoundle[4];
; 9520 : 				bBoundle[0] = false;

  00a62	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bBoundle$247698[ebp], 0

; 9521 : 				bBoundle[1] = false;
; 9522 : 				bBoundle[2] = false;
; 9523 : 				bBoundle[3] = false;
; 9524 : 
; 9525 : 				int JewelCount[4];
; 9526 : 				JewelCount[0] = 0;

  00a6c	33 d2		 xor	 edx, edx
  00a6e	89 55 a0	 mov	 DWORD PTR _JewelCount$247699[ebp], edx

; 9527 : 				JewelCount[1] = 0;

  00a71	89 55 a4	 mov	 DWORD PTR _JewelCount$247699[ebp+4], edx

; 9528 : 				JewelCount[2] = 0;

  00a74	89 55 a8	 mov	 DWORD PTR _JewelCount$247699[ebp+8], edx

; 9529 : 				JewelCount[3] = 0;

  00a77	89 55 ac	 mov	 DWORD PTR _JewelCount$247699[ebp+12], edx

; 9530 : 					
; 9531 : 				invSize = MAIN_INVENTORY_SIZE;

  00a7a	b9 cc 00 00 00	 mov	 ecx, 204		; 000000ccH
  00a7f	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _invSize$247658[ebp], ecx

; 9532 : 				
; 9533 : 				if( lpSourceObj->ExpandedInventory < 4 )	{

  00a85	8b bd 68 ff ff
	ff		 mov	 edi, DWORD PTR _lpSourceObj$[ebp]
  00a8b	8a 87 24 26 00
	00		 mov	 al, BYTE PTR [edi+9764]
  00a91	3c 04		 cmp	 al, 4
  00a93	73 0f		 jae	 SHORT $LN80@CGPShopReq@7

; 9534 : 					invSize = (MAIN_INVENTORY_SIZE)-(32*(4-lpSourceObj->ExpandedInventory));

  00a95	0f b6 c8	 movzx	 ecx, al
  00a98	c1 e1 05	 shl	 ecx, 5
  00a9b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00a9e	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _invSize$247658[ebp], ecx
$LN80@CGPShopReq@7:

; 9535 : 				}
; 9536 : 
; 9537 : 				if(ExBankMinus == true)	//silver check

  00aa4	80 bd 6f ff ff
	ff 01		 cmp	 BYTE PTR _ExBankMinus$247664[ebp], 1
  00aab	0f 85 a0 00 00
	00		 jne	 $LN79@CGPShopReq@7

; 9538 : 				{
; 9539 : 					JewelCount[0] = lpSourceObj->BlessBank;

  00ab1	8b 87 e8 27 00
	00		 mov	 eax, DWORD PTR [edi+10216]
  00ab7	89 45 a0	 mov	 DWORD PTR _JewelCount$247699[ebp], eax

; 9540 : 					JewelCount[1] = lpSourceObj->SoulBank;

  00aba	8b 8f ec 27 00
	00		 mov	 ecx, DWORD PTR [edi+10220]
  00ac0	89 4d a4	 mov	 DWORD PTR _JewelCount$247699[ebp+4], ecx

; 9541 : 					JewelCount[2] = lpSourceObj->ChaosBank;

  00ac3	8b 87 e4 27 00
	00		 mov	 eax, DWORD PTR [edi+10212]
  00ac9	89 45 a8	 mov	 DWORD PTR _JewelCount$247699[ebp+8], eax

; 9542 : 					JewelCount[3] = lpSourceObj->LifeBank;

  00acc	8b 8f f0 27 00
	00		 mov	 ecx, DWORD PTR [edi+10224]
  00ad2	89 4d ac	 mov	 DWORD PTR _JewelCount$247699[ebp+12], ecx

; 9543 : 
; 9544 : 					for( n = 0; n < 4; n++)

  00ad5	33 c0		 xor	 eax, eax
$LN175@CGPShopReq@7:
  00ad7	89 85 78 ff ff
	ff		 mov	 DWORD PTR _n$247657[ebp], eax
  00add	83 f8 04	 cmp	 eax, 4
  00ae0	0f 8d 9c 02 00
	00		 jge	 $LN52@CGPShopReq@7

; 9545 : 					{
; 9546 : 						if( JewelCount[n] < aPShopJewelValue[n] )

  00ae6	0f bf 54 45 dc	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp+eax*2]
  00aeb	39 54 85 a0	 cmp	 DWORD PTR _JewelCount$247699[ebp+eax*4], edx
  00aef	7d 5d		 jge	 SHORT $LN75@CGPShopReq@7

; 9547 : 						{
; 9548 : 							LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No enough Jewels - Type: %d",
; 9549 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);

  00af1	50		 push	 eax
  00af2	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00af5	51		 push	 ecx
  00af6	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00af9	52		 push	 edx
  00afa	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  00afd	50		 push	 eax
  00afe	83 c7 6c	 add	 edi, 108		; 0000006cH
  00b01	57		 push	 edi
  00b02	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00b07	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9550 : 							::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 11+n);

  00b0d	8a 85 78 ff ff
	ff		 mov	 al, BYTE PTR _n$247657[ebp]
  00b13	04 0b		 add	 al, 11			; 0000000bH
  00b15	0f b6 c8	 movzx	 ecx, al
  00b18	51		 push	 ecx
  00b19	6a 00		 push	 0
  00b1b	8b 13		 mov	 edx, DWORD PTR [ebx]
  00b1d	52		 push	 edx
  00b1e	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00b24	56		 push	 esi
  00b25	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9551 : 							MsgOutput(aSourceIndex, "No Jewels Bank");

  00b2a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KHKEGFKG@No?5Jewels?5Bank?$AA@
  00b2f	56		 push	 esi
  00b30	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 9552 : 							return;

  00b35	6a fe		 push	 -2			; fffffffeH
  00b37	9b		 fwait
  00b38	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00b3b	50		 push	 eax
  00b3c	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00b41	e8 00 00 00 00	 call	 __local_unwind4
  00b46	83 c4 3c	 add	 esp, 60			; 0000003cH
  00b49	e9 e8 0a 00 00	 jmp	 $LN145@CGPShopReq@7
$LN75@CGPShopReq@7:

; 9543 : 
; 9544 : 					for( n = 0; n < 4; n++)

  00b4e	40		 inc	 eax
  00b4f	eb 86		 jmp	 SHORT $LN175@CGPShopReq@7
$LN79@CGPShopReq@7:

; 9553 : 						}
; 9554 : 
; 9555 : 					}
; 9556 : 
; 9557 : 				}
; 9558 : 				else
; 9559 : 				{
; 9560 : 					for( n = INVENTORY_BAG_START; n < invSize; n++)

  00b51	c7 85 78 ff ff
	ff 0c 00 00 00	 mov	 DWORD PTR _n$247657[ebp], 12 ; 0000000cH
  00b5b	eb 03 8d 49 00	 npad	 5
$LL73@CGPShopReq@7:
  00b60	39 8d 78 ff ff
	ff		 cmp	 DWORD PTR _n$247657[ebp], ecx
  00b66	0f 8d 16 01 00
	00		 jge	 $LN71@CGPShopReq@7

; 9561 : 					{
; 9562 : 						if( !lpSourceObj->pInventory[n].IsItem() )

  00b6c	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _n$247657[ebp]
  00b72	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00b78	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00b7e	03 ce		 add	 ecx, esi
  00b80	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00b85	85 c0		 test	 eax, eax

; 9563 : 							continue;

  00b87	0f 84 e2 00 00
	00		 je	 $LN72@CGPShopReq@7

; 9564 : 
; 9565 : 						if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,13) )

  00b8d	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  00b93	03 ce		 add	 ecx, esi
  00b95	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00b99	ba 0d 1c 00 00	 mov	 edx, 7181		; 00001c0dH
  00b9e	66 3b c2	 cmp	 ax, dx
  00ba1	75 08		 jne	 SHORT $LN69@CGPShopReq@7

; 9566 : 						{
; 9567 : 							JewelCount[0]++;

  00ba3	ff 45 a0	 inc	 DWORD PTR _JewelCount$247699[ebp]
  00ba6	e9 c4 00 00 00	 jmp	 $LN72@CGPShopReq@7
$LN69@CGPShopReq@7:

; 9568 : 						}
; 9569 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,14) )

  00bab	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  00bb0	66 3b c2	 cmp	 ax, dx
  00bb3	75 08		 jne	 SHORT $LN67@CGPShopReq@7

; 9570 : 						{
; 9571 : 							JewelCount[1]++;

  00bb5	ff 45 a4	 inc	 DWORD PTR _JewelCount$247699[ebp+4]
  00bb8	e9 b2 00 00 00	 jmp	 $LN72@CGPShopReq@7
$LN67@CGPShopReq@7:

; 9572 : 						}
; 9573 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,15) )

  00bbd	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00bc2	66 3b c2	 cmp	 ax, dx
  00bc5	75 08		 jne	 SHORT $LN65@CGPShopReq@7

; 9574 : 						{
; 9575 : 							JewelCount[2]++;

  00bc7	ff 45 a8	 inc	 DWORD PTR _JewelCount$247699[ebp+8]
  00bca	e9 a0 00 00 00	 jmp	 $LN72@CGPShopReq@7
$LN65@CGPShopReq@7:

; 9576 : 						}
; 9577 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,16) )

  00bcf	ba 10 1c 00 00	 mov	 edx, 7184		; 00001c10H
  00bd4	66 3b c2	 cmp	 ax, dx
  00bd7	75 08		 jne	 SHORT $LN63@CGPShopReq@7

; 9578 : 						{
; 9579 : 							JewelCount[3]++;

  00bd9	ff 45 ac	 inc	 DWORD PTR _JewelCount$247699[ebp+12]
  00bdc	e9 8e 00 00 00	 jmp	 $LN72@CGPShopReq@7
$LN63@CGPShopReq@7:

; 9580 : 						}
; 9581 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,30) )

  00be1	ba 1e 18 00 00	 mov	 edx, 6174		; 0000181eH
  00be6	66 3b c2	 cmp	 ax, dx
  00be9	75 1a		 jne	 SHORT $LN61@CGPShopReq@7

; 9582 : 						{
; 9583 : 							bBoundle[0] = true;

  00beb	c6 85 74 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$247698[ebp], 1

; 9584 : 							JewelCount[0] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  00bf2	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00bf6	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00bf9	8b 4d a0	 mov	 ecx, DWORD PTR _JewelCount$247699[ebp]
  00bfc	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  00c00	89 55 a0	 mov	 DWORD PTR _JewelCount$247699[ebp], edx
  00c03	eb 6a		 jmp	 SHORT $LN72@CGPShopReq@7
$LN61@CGPShopReq@7:

; 9585 : 						}
; 9586 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,31) )

  00c05	ba 1f 18 00 00	 mov	 edx, 6175		; 0000181fH
  00c0a	66 3b c2	 cmp	 ax, dx
  00c0d	75 1a		 jne	 SHORT $LN59@CGPShopReq@7

; 9587 : 						{
; 9588 : 							bBoundle[1] = true;

  00c0f	c6 85 75 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$247698[ebp+1], 1

; 9589 : 							JewelCount[1] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  00c16	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00c1a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00c1d	8b 4d a4	 mov	 ecx, DWORD PTR _JewelCount$247699[ebp+4]
  00c20	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  00c24	89 55 a4	 mov	 DWORD PTR _JewelCount$247699[ebp+4], edx
  00c27	eb 46		 jmp	 SHORT $LN72@CGPShopReq@7
$LN59@CGPShopReq@7:

; 9590 : 						}
; 9591 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,141) )

  00c29	ba 8d 18 00 00	 mov	 edx, 6285		; 0000188dH
  00c2e	66 3b c2	 cmp	 ax, dx
  00c31	75 1a		 jne	 SHORT $LN57@CGPShopReq@7

; 9592 : 						{
; 9593 : 							bBoundle[2] = true;

  00c33	c6 85 76 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$247698[ebp+2], 1

; 9594 : 							JewelCount[2] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  00c3a	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00c3e	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00c41	8b 4d a8	 mov	 ecx, DWORD PTR _JewelCount$247699[ebp+8]
  00c44	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  00c48	89 55 a8	 mov	 DWORD PTR _JewelCount$247699[ebp+8], edx
  00c4b	eb 22		 jmp	 SHORT $LN72@CGPShopReq@7
$LN57@CGPShopReq@7:

; 9595 : 						}
; 9596 : 						else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,136) )

  00c4d	ba 88 18 00 00	 mov	 edx, 6280		; 00001888H
  00c52	66 3b c2	 cmp	 ax, dx
  00c55	75 18		 jne	 SHORT $LN72@CGPShopReq@7

; 9597 : 						{
; 9598 : 							bBoundle[3] = true;

  00c57	c6 85 77 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$247698[ebp+3], 1

; 9599 : 							JewelCount[3] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  00c5e	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00c62	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00c65	8b 4d ac	 mov	 ecx, DWORD PTR _JewelCount$247699[ebp+12]
  00c68	8d 54 41 0a	 lea	 edx, DWORD PTR [ecx+eax*2+10]
  00c6c	89 55 ac	 mov	 DWORD PTR _JewelCount$247699[ebp+12], edx
$LN72@CGPShopReq@7:

; 9553 : 						}
; 9554 : 
; 9555 : 					}
; 9556 : 
; 9557 : 				}
; 9558 : 				else
; 9559 : 				{
; 9560 : 					for( n = INVENTORY_BAG_START; n < invSize; n++)

  00c6f	ff 85 78 ff ff
	ff		 inc	 DWORD PTR _n$247657[ebp]
  00c75	33 d2		 xor	 edx, edx
  00c77	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _invSize$247658[ebp]
  00c7d	e9 de fe ff ff	 jmp	 $LL73@CGPShopReq@7
$LN71@CGPShopReq@7:

; 9600 : 						}
; 9601 : 					}
; 9602 : 
; 9603 : 					for( n = 0; n < 4; n++)

  00c82	33 c0		 xor	 eax, eax
$LN176@CGPShopReq@7:
  00c84	89 85 78 ff ff
	ff		 mov	 DWORD PTR _n$247657[ebp], eax
  00c8a	83 f8 04	 cmp	 eax, 4
  00c8d	0f 8d ef 00 00
	00		 jge	 $LN52@CGPShopReq@7

; 9604 : 					{
; 9605 : 						if( JewelCount[n] < aPShopJewelValue[n] )

  00c93	0f bf 4c 45 dc	 movsx	 ecx, WORD PTR _aPShopJewelValue$247662[ebp+eax*2]
  00c98	8b 54 85 a0	 mov	 edx, DWORD PTR _JewelCount$247699[ebp+eax*4]
  00c9c	3b d1		 cmp	 edx, ecx
  00c9e	7d 6b		 jge	 SHORT $LN51@CGPShopReq@7

; 9606 : 						{
; 9607 : 							LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No enough Jewels - Type: %d",
; 9608 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);

  00ca0	50		 push	 eax
  00ca1	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00ca4	51		 push	 ecx
  00ca5	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00ca8	52		 push	 edx
  00ca9	8d 47 77	 lea	 eax, DWORD PTR [edi+119]
  00cac	50		 push	 eax
  00cad	83 c7 6c	 add	 edi, 108		; 0000006cH
  00cb0	57		 push	 edi
  00cb1	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00cb6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9609 : 							::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 11+n);

  00cbc	8a 85 78 ff ff
	ff		 mov	 al, BYTE PTR _n$247657[ebp]
  00cc2	04 0b		 add	 al, 11			; 0000000bH
  00cc4	0f b6 c8	 movzx	 ecx, al
  00cc7	51		 push	 ecx
  00cc8	6a 00		 push	 0
  00cca	8b 13		 mov	 edx, DWORD PTR [ebx]
  00ccc	52		 push	 edx
  00ccd	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00cd3	56		 push	 esi
  00cd4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00cd9	83 c4 28	 add	 esp, 40			; 00000028H

; 9610 : 							MsgOutput(aSourceIndex, g_ZtText.GetText(253));

  00cdc	68 fd 00 00 00	 push	 253			; 000000fdH
  00ce1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtText@@3VCZtText@@A ; g_ZtText
  00ce6	e8 00 00 00 00	 call	 ?GetText@CZtText@@QAEPADH@Z ; CZtText::GetText
  00ceb	50		 push	 eax
  00cec	56		 push	 esi
  00ced	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 9611 : 							return;

  00cf2	6a fe		 push	 -2			; fffffffeH
  00cf4	9b		 fwait
  00cf5	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00cf8	50		 push	 eax
  00cf9	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00cfe	e8 00 00 00 00	 call	 __local_unwind4
  00d03	83 c4 14	 add	 esp, 20			; 00000014H
  00d06	e9 2b 09 00 00	 jmp	 $LN145@CGPShopReq@7
$LN51@CGPShopReq@7:

; 9612 : 						}
; 9613 : 						else if( bBoundle[n] && JewelCount[n] > aPShopJewelValue[n] )	//Fix?

  00d0b	80 bc 05 74 ff
	ff ff 00	 cmp	 BYTE PTR _bBoundle$247698[ebp+eax], 0
  00d13	74 67		 je	 SHORT $LN49@CGPShopReq@7
  00d15	3b d1		 cmp	 edx, ecx
  00d17	7e 63		 jle	 SHORT $LN49@CGPShopReq@7

; 9614 : 						{
; 9615 : 							LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Boundle Jewels - Type: %d",
; 9616 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);

  00d19	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _n$247657[ebp]
  00d1f	51		 push	 ecx
  00d20	8d 53 77	 lea	 edx, DWORD PTR [ebx+119]
  00d23	52		 push	 edx
  00d24	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  00d27	50		 push	 eax
  00d28	8d 4f 77	 lea	 ecx, DWORD PTR [edi+119]
  00d2b	51		 push	 ecx
  00d2c	83 c7 6c	 add	 edi, 108		; 0000006cH
  00d2f	57		 push	 edi
  00d30	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00d35	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9617 : 							::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 14+n);

  00d3b	8a 85 78 ff ff
	ff		 mov	 al, BYTE PTR _n$247657[ebp]
  00d41	04 0e		 add	 al, 14			; 0000000eH
  00d43	0f b6 d0	 movzx	 edx, al
  00d46	52		 push	 edx
  00d47	6a 00		 push	 0
  00d49	8b 03		 mov	 eax, DWORD PTR [ebx]
  00d4b	50		 push	 eax
  00d4c	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00d52	56		 push	 esi
  00d53	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9618 : 							MsgOutput(aSourceIndex, "Un Pack Jewels");

  00d58	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GLCMHBBE@Un?5Pack?5Jewels?$AA@
  00d5d	56		 push	 esi
  00d5e	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 9619 : 							return;

  00d63	6a fe		 push	 -2			; fffffffeH
  00d65	9b		 fwait
  00d66	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00d69	51		 push	 ecx
  00d6a	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00d6f	e8 00 00 00 00	 call	 __local_unwind4
  00d74	83 c4 3c	 add	 esp, 60			; 0000003cH
  00d77	e9 ba 08 00 00	 jmp	 $LN145@CGPShopReq@7
$LN49@CGPShopReq@7:

; 9600 : 						}
; 9601 : 					}
; 9602 : 
; 9603 : 					for( n = 0; n < 4; n++)

  00d7c	40		 inc	 eax
  00d7d	e9 02 ff ff ff	 jmp	 $LN176@CGPShopReq@7
$LN52@CGPShopReq@7:

; 9620 : 						}
; 9621 : 					}
; 9622 : 				}
; 9623 : 				
; 9624 : 				BYTE btNewItemPos = 0;
; 9625 : 				btNewItemPos = ::gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);

  00d82	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00d88	0f b6 72 10	 movzx	 esi, BYTE PTR [edx+16]
  00d8c	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00d92	03 b3 34 0e 00
	00		 add	 esi, DWORD PTR [ebx+3636]
  00d98	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00d9e	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00da3	8b fc		 mov	 edi, esp
  00da5	f3 a5		 rep movsd
  00da7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00dad	50		 push	 eax
  00dae	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  00db3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00db9	88 85 77 ff ff
	ff		 mov	 BYTE PTR _btNewItemPos$247736[ebp], al

; 9626 : 
; 9627 : 				if ( btNewItemPos == 0xFF )

  00dbf	3c ff		 cmp	 al, 255			; 000000ffH
  00dc1	75 60		 jne	 SHORT $LN48@CGPShopReq@7

; 9628 : 				{
; 9629 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",
; 9630 : 						gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 9631 : 						lpObj->AccountID, lpObj->Name);

  00dc3	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  00dc9	8b c6		 mov	 eax, esi
  00dcb	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00dd1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dd7	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00dda	51		 push	 ecx
  00ddb	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00dde	52		 push	 edx
  00ddf	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  00de2	51		 push	 ecx
  00de3	83 c0 6c	 add	 eax, 108		; 0000006cH
  00de6	50		 push	 eax
  00de7	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00dec	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9632 : 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  00df2	6a 08		 push	 8
  00df4	6a 00		 push	 0
  00df6	8b 13		 mov	 edx, DWORD PTR [ebx]
  00df8	52		 push	 edx
  00df9	56		 push	 esi
  00dfa	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9633 : 					MsgOutput(aSourceIndex, "No Empty Inventory");

  00dff	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DHABCDPC@No?5Empty?5Inventory?$AA@
  00e04	56		 push	 esi
  00e05	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 9634 : 					return;

  00e0a	6a fe		 push	 -2			; fffffffeH
  00e0c	9b		 fwait
  00e0d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00e10	50		 push	 eax
  00e11	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00e16	e8 00 00 00 00	 call	 __local_unwind4
  00e1b	83 c4 38	 add	 esp, 56			; 00000038H
  00e1e	e9 13 08 00 00	 jmp	 $LN145@CGPShopReq@7
$LN48@CGPShopReq@7:

; 9635 : 				}
; 9636 : 				
; 9637 : 				iITEM_LOG_TYPE = lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  00e23	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00e29	0f b6 79 10	 movzx	 edi, BYTE PTR [ecx+16]
  00e2d	8b f7		 mov	 esi, edi
  00e2f	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00e35	03 b3 34 0e 00
	00		 add	 esi, DWORD PTR [ebx+3636]
  00e3b	0f bf 4e 06	 movsx	 ecx, WORD PTR [esi+6]
  00e3f	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], ecx

; 9638 : 				iITEM_LOG_LEVEL = lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  00e45	0f bf 56 08	 movsx	 edx, WORD PTR [esi+8]
  00e49	89 95 38 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], edx

; 9639 : 				iITEM_LOG_DUR = (int)lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  00e4f	d9 46 24	 fld	 DWORD PTR [esi+36]
  00e52	e8 00 00 00 00	 call	 __ftol2_sse
  00e57	89 85 40 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], eax

; 9640 : 				iITEM_LOG_SERIAL = lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  00e5d	8b 06		 mov	 eax, DWORD PTR [esi]
  00e5f	89 85 48 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], eax

; 9641 : 				::gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, -1);

  00e65	68 ff 00 00 00	 push	 255			; 000000ffH
  00e6a	57		 push	 edi
  00e6b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00e6d	51		 push	 ecx
  00e6e	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  00e73	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9642 : 				lpObj->Inventory1[lpMsg->btItemPos].Clear();

  00e76	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _lpMsg$GSCopy$[ebp]
  00e7c	0f b6 4e 10	 movzx	 ecx, BYTE PTR [esi+16]
  00e80	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00e86	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  00e8c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9643 : 				::GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, TRUE);

  00e91	6a 01		 push	 1
  00e93	0f b6 56 10	 movzx	 edx, BYTE PTR [esi+16]
  00e97	52		 push	 edx
  00e98	8b 03		 mov	 eax, DWORD PTR [ebx]
  00e9a	50		 push	 eax
  00e9b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00ea0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9644 : 
; 9645 : 				if( iPShopValue > 0 )

  00ea3	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _iPShopValue$247659[ebp]

; 9646 : 				{
; 9647 : 					gObj[aSourceIndex].Money -= iPShopValue;

  00ea9	8b bd 7c ff ff
	ff		 mov	 edi, DWORD PTR _aSourceIndex$GSCopy$[ebp]

; 9649 : 					::GCMoneySend(aSourceIndex, lpSourceObj->Money);

  00eaf	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR _lpSourceObj$[ebp]

; 9644 : 
; 9645 : 				if( iPShopValue > 0 )

  00eb5	85 c9		 test	 ecx, ecx
  00eb7	7e 3b		 jle	 SHORT $LN47@CGPShopReq@7

; 9646 : 				{
; 9647 : 					gObj[aSourceIndex].Money -= iPShopValue;

  00eb9	8b d7		 mov	 edx, edi
  00ebb	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00ec1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ec6	8d 84 02 f0 00
	00 00		 lea	 eax, DWORD PTR [edx+eax+240]
  00ecd	29 08		 sub	 DWORD PTR [eax], ecx

; 9648 : 					lpObj->Money += iPShopValue;

  00ecf	01 8b f0 00 00
	00		 add	 DWORD PTR [ebx+240], ecx

; 9649 : 					::GCMoneySend(aSourceIndex, lpSourceObj->Money);

  00ed5	8b 8e f0 00 00
	00		 mov	 ecx, DWORD PTR [esi+240]
  00edb	51		 push	 ecx
  00edc	57		 push	 edi
  00edd	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 9650 : 					::GCMoneySend(lpObj->m_Index, lpObj->Money);

  00ee2	8b 93 f0 00 00
	00		 mov	 edx, DWORD PTR [ebx+240]
  00ee8	52		 push	 edx
  00ee9	8b 03		 mov	 eax, DWORD PTR [ebx]
  00eeb	50		 push	 eax
  00eec	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00ef1	83 c4 10	 add	 esp, 16			; 00000010H
$LN47@CGPShopReq@7:

; 9651 : 				}
; 9652 : 
; 9653 : 				if( iPShopBonusValue > 0 )

  00ef4	33 c0		 xor	 eax, eax
  00ef6	39 85 64 ff ff
	ff		 cmp	 DWORD PTR _iPShopBonusValue$247660[ebp], eax
  00efc	0f 8e 9e 00 00
	00		 jle	 $LN46@CGPShopReq@7

; 9654 : 				{
; 9655 : 					if(g_PersonalShopZt.BonusPrice == 1)

  00f02	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A+20
  00f07	83 f8 01	 cmp	 eax, 1
  00f0a	75 3f		 jne	 SHORT $LN45@CGPShopReq@7

; 9656 : 					{
; 9657 : 						gObj[aSourceIndex].ZtCred -= iPShopBonusValue;

  00f0c	8b cf		 mov	 ecx, edi
  00f0e	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00f14	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f1a	8d 84 11 a8 22
	00 00		 lea	 eax, DWORD PTR [ecx+edx+8872]
  00f21	db 85 64 ff ff
	ff		 fild	 DWORD PTR _iPShopBonusValue$247660[ebp]
  00f27	d9 9d 64 ff ff
	ff		 fstp	 DWORD PTR tv2167[ebp]
  00f2d	d9 00		 fld	 DWORD PTR [eax]
  00f2f	d9 85 64 ff ff
	ff		 fld	 DWORD PTR tv2167[ebp]
  00f35	d9 c0		 fld	 ST(0)
  00f37	de ea		 fsubp	 ST(2), ST(0)
  00f39	d9 c9		 fxch	 ST(1)
  00f3b	d9 18		 fstp	 DWORD PTR [eax]

; 9658 : 						lpObj->ZtCred += iPShopBonusValue;

  00f3d	d8 83 a8 22 00
	00		 fadd	 DWORD PTR [ebx+8872]
  00f43	d9 9b a8 22 00
	00		 fstp	 DWORD PTR [ebx+8872]
  00f49	eb 4a		 jmp	 SHORT $LN43@CGPShopReq@7
$LN45@CGPShopReq@7:

; 9659 : 					}
; 9660 : 					else if(g_PersonalShopZt.BonusPrice == 2)

  00f4b	83 f8 02	 cmp	 eax, 2
  00f4e	75 45		 jne	 SHORT $LN43@CGPShopReq@7

; 9661 : 					{
; 9662 : 						gObj[aSourceIndex].GameShop.WCoinC -= iPShopBonusValue;

  00f50	8b c7		 mov	 eax, edi
  00f52	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00f58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f5e	8d 84 08 00 23
	00 00		 lea	 eax, DWORD PTR [eax+ecx+8960]
  00f65	db 85 64 ff ff
	ff		 fild	 DWORD PTR _iPShopBonusValue$247660[ebp]
  00f6b	dd 00		 fld	 QWORD PTR [eax]
  00f6d	d8 e1		 fsub	 ST(0), ST(1)
  00f6f	dd 18		 fstp	 QWORD PTR [eax]

; 9663 : 						lpObj->GameShop.WCoinC += iPShopBonusValue;

  00f71	dc 83 00 23 00
	00		 fadd	 QWORD PTR [ebx+8960]
  00f77	dd 9b 00 23 00
	00		 fstp	 QWORD PTR [ebx+8960]

; 9664 : 						gGameShop.GDSaveUserInfo(aSourceIndex);

  00f7d	57		 push	 edi
  00f7e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00f83	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo

; 9665 : 						gGameShop.GDSaveUserInfo(lpObj->m_Index);

  00f88	8b 13		 mov	 edx, DWORD PTR [ebx]
  00f8a	52		 push	 edx
  00f8b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00f90	e8 00 00 00 00	 call	 ?GDSaveUserInfo@GameShop@@QAEXH@Z ; GameShop::GDSaveUserInfo
$LN43@CGPShopReq@7:

; 9666 : 					}
; 9667 : 			
; 9668 : 					ZtUserDataSend(aSourceIndex);

  00f95	57		 push	 edi
  00f96	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  00f9b	83 c4 04	 add	 esp, 4
  00f9e	33 c0		 xor	 eax, eax
$LN46@CGPShopReq@7:

; 9669 : 				}
; 9670 : 
; 9671 : 				#if(DEV_PERSONAL_CREDIT)
; 9672 : 				if( iPShopCreditValue > 0 )

  00fa0	39 85 60 ff ff
	ff		 cmp	 DWORD PTR _iPShopCreditValue$247661[ebp], eax
  00fa6	7e 51		 jle	 SHORT $LN42@CGPShopReq@7

; 9673 : 				{
; 9674 : 					if(g_PersonalShopZt.CreditPrice == 1)

  00fa8	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A+24, 1
  00faf	75 3d		 jne	 SHORT $LN41@CGPShopReq@7

; 9675 : 					{
; 9676 : 						gObj[aSourceIndex].ZtCred -= iPShopCreditValue;

  00fb1	8b c7		 mov	 eax, edi
  00fb3	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00fb9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fbf	8d 84 08 a8 22
	00 00		 lea	 eax, DWORD PTR [eax+ecx+8872]
  00fc6	db 85 60 ff ff
	ff		 fild	 DWORD PTR _iPShopCreditValue$247661[ebp]
  00fcc	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR tv2188[ebp]
  00fd2	d9 00		 fld	 DWORD PTR [eax]
  00fd4	d9 85 60 ff ff
	ff		 fld	 DWORD PTR tv2188[ebp]
  00fda	d9 c0		 fld	 ST(0)
  00fdc	de ea		 fsubp	 ST(2), ST(0)
  00fde	d9 c9		 fxch	 ST(1)
  00fe0	d9 18		 fstp	 DWORD PTR [eax]

; 9677 : 						lpObj->ZtCred += iPShopCreditValue;

  00fe2	d8 83 a8 22 00
	00		 fadd	 DWORD PTR [ebx+8872]
  00fe8	d9 9b a8 22 00
	00		 fstp	 DWORD PTR [ebx+8872]
$LN41@CGPShopReq@7:

; 9678 : 					}
; 9679 : 					ZtUserDataSend(aSourceIndex);

  00fee	57		 push	 edi
  00fef	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  00ff4	83 c4 04	 add	 esp, 4
  00ff7	33 c0		 xor	 eax, eax
$LN42@CGPShopReq@7:

; 9680 : 				}
; 9681 : 				#endif
; 9682 : 
; 9683 : 				JewelCount[0] = 0;

  00ff9	89 45 a0	 mov	 DWORD PTR _JewelCount$247699[ebp], eax

; 9684 : 				JewelCount[1] = 0;

  00ffc	89 45 a4	 mov	 DWORD PTR _JewelCount$247699[ebp+4], eax

; 9685 : 				JewelCount[2] = 0;

  00fff	89 45 a8	 mov	 DWORD PTR _JewelCount$247699[ebp+8], eax

; 9686 : 				JewelCount[3] = 0;

  01002	89 45 ac	 mov	 DWORD PTR _JewelCount$247699[ebp+12], eax

; 9687 : 
; 9688 : 				// silver check
; 9689 : 				if(ExBankMinus == true)

  01005	80 bd 6f ff ff
	ff 01		 cmp	 BYTE PTR _ExBankMinus$247664[ebp], 1
  0100c	0f 85 ff 01 00
	00		 jne	 $LN40@CGPShopReq@7

; 9690 : 				{
; 9691 : 					lpSourceObj->BlessBank -= aPShopJewelValue[0];

  01012	0f bf 55 dc	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp]
  01016	29 96 e8 27 00
	00		 sub	 DWORD PTR [esi+10216], edx

; 9692 : 					lpSourceObj->SoulBank -= aPShopJewelValue[1];

  0101c	0f bf 45 de	 movsx	 eax, WORD PTR _aPShopJewelValue$247662[ebp+2]
  01020	29 86 ec 27 00
	00		 sub	 DWORD PTR [esi+10220], eax

; 9693 : 					lpSourceObj->ChaosBank -= aPShopJewelValue[2];

  01026	0f bf 4d e0	 movsx	 ecx, WORD PTR _aPShopJewelValue$247662[ebp+4]
  0102a	29 8e e4 27 00
	00		 sub	 DWORD PTR [esi+10212], ecx

; 9694 : 					lpSourceObj->LifeBank -= aPShopJewelValue[3];

  01030	0f bf 55 e2	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp+6]
  01034	29 96 f0 27 00
	00		 sub	 DWORD PTR [esi+10224], edx

; 9695 : 					ZtUserDataSend(lpSourceObj->m_Index);

  0103a	8b 06		 mov	 eax, DWORD PTR [esi]
  0103c	50		 push	 eax
  0103d	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  01042	83 c4 04	 add	 esp, 4
$LN36@CGPShopReq@7:

; 9749 : 						}
; 9750 : 					}
; 9751 : 				}
; 9752 : 
; 9753 : 				int iBoundleId[4] = {ITEMGET(12,30), ITEMGET(12,31), ITEMGET(12,141),ITEMGET(12,136)};

  01045	c7 45 90 1e 18
	00 00		 mov	 DWORD PTR _iBoundleId$247772[ebp], 6174 ; 0000181eH
  0104c	c7 45 94 1f 18
	00 00		 mov	 DWORD PTR _iBoundleId$247772[ebp+4], 6175 ; 0000181fH
  01053	c7 45 98 8d 18
	00 00		 mov	 DWORD PTR _iBoundleId$247772[ebp+8], 6285 ; 0000188dH
  0105a	c7 45 9c 88 18
	00 00		 mov	 DWORD PTR _iBoundleId$247772[ebp+12], 6280 ; 00001888H

; 9754 : 				int iJewelId[4] = {ITEMGET(14,13), ITEMGET(14,14), ITEMGET(12,15), ITEMGET(14,16)};

  01061	c7 45 80 0d 1c
	00 00		 mov	 DWORD PTR _iJewelId$247773[ebp], 7181 ; 00001c0dH
  01068	c7 45 84 0e 1c
	00 00		 mov	 DWORD PTR _iJewelId$247773[ebp+4], 7182 ; 00001c0eH
  0106f	c7 45 88 0f 18
	00 00		 mov	 DWORD PTR _iJewelId$247773[ebp+8], 6159 ; 0000180fH
  01076	c7 45 8c 10 1c
	00 00		 mov	 DWORD PTR _iJewelId$247773[ebp+12], 7184 ; 00001c10H

; 9755 : 
; 9756 : 				if(ExBankPlus == true)

  0107d	80 bd 6e ff ff
	ff 01		 cmp	 BYTE PTR _ExBankPlus$247663[ebp], 1
  01084	0f 85 d0 03 00
	00		 jne	 $LN24@CGPShopReq@7

; 9757 : 				{
; 9758 : 					if(aPShopJewelValue[0] > 0)

  0108a	66 8b 45 dc	 mov	 ax, WORD PTR _aPShopJewelValue$247662[ebp]
  0108e	66 85 c0	 test	 ax, ax
  01091	7e 09		 jle	 SHORT $LN23@CGPShopReq@7

; 9759 : 					{
; 9760 : 						lpObj->BlessBank += aPShopJewelValue[0];

  01093	0f bf d0	 movsx	 edx, ax
  01096	01 93 e8 27 00
	00		 add	 DWORD PTR [ebx+10216], edx
$LN23@CGPShopReq@7:

; 9761 : 					}
; 9762 : 					if(aPShopJewelValue[1] > 0)

  0109c	66 8b 45 de	 mov	 ax, WORD PTR _aPShopJewelValue$247662[ebp+2]
  010a0	66 85 c0	 test	 ax, ax
  010a3	7e 07		 jle	 SHORT $LN22@CGPShopReq@7

; 9763 : 					{
; 9764 : 						lpObj->SoulBank += aPShopJewelValue[1];

  010a5	98		 cwde
  010a6	01 83 ec 27 00
	00		 add	 DWORD PTR [ebx+10220], eax
$LN22@CGPShopReq@7:

; 9765 : 					}	
; 9766 : 					if(aPShopJewelValue[2] > 0)

  010ac	66 8b 45 e0	 mov	 ax, WORD PTR _aPShopJewelValue$247662[ebp+4]
  010b0	66 85 c0	 test	 ax, ax
  010b3	7e 09		 jle	 SHORT $LN21@CGPShopReq@7

; 9767 : 					{
; 9768 : 						lpObj->ChaosBank += aPShopJewelValue[2];

  010b5	0f bf c8	 movsx	 ecx, ax
  010b8	01 8b e4 27 00
	00		 add	 DWORD PTR [ebx+10212], ecx
$LN21@CGPShopReq@7:

; 9769 : 					}	
; 9770 : 					if(aPShopJewelValue[3] > 0)

  010be	66 8b 45 e2	 mov	 ax, WORD PTR _aPShopJewelValue$247662[ebp+6]
  010c2	66 85 c0	 test	 ax, ax
  010c5	7e 09		 jle	 SHORT $LN20@CGPShopReq@7

; 9771 : 					{
; 9772 : 						lpObj->LifeBank += aPShopJewelValue[3];

  010c7	0f bf d0	 movsx	 edx, ax
  010ca	01 93 f0 27 00
	00		 add	 DWORD PTR [ebx+10224], edx
$LN20@CGPShopReq@7:

; 9773 : 					}
; 9774 : 					ZtUserDataSend(lpObj->m_Index);

  010d0	8b 03		 mov	 eax, DWORD PTR [ebx]
  010d2	50		 push	 eax
  010d3	e8 00 00 00 00	 call	 ?ZtUserDataSend@@YAXH@Z	; ZtUserDataSend
  010d8	83 c4 04	 add	 esp, 4
$LN16@CGPShopReq@7:

; 9818 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9819 : 								if(lpObj->m_OfflineTrade)
; 9820 : 								{
; 9821 : 									lpObj->OffTradeWaitItem++;
; 9822 : 								}
; 9823 : 	#endif
; 9824 : 							}
; 9825 : 						}
; 9826 : 					}
; 9827 : 				}
; 9828 : 
; 9829 : 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  010db	6a 01		 push	 1
  010dd	0f b6 95 77 ff
	ff ff		 movzx	 edx, BYTE PTR _btNewItemPos$247736[ebp]
  010e4	52		 push	 edx
  010e5	8b 03		 mov	 eax, DWORD PTR [ebx]
  010e7	50		 push	 eax
  010e8	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  010ee	56		 push	 esi
  010ef	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9830 : 				::CGPShopAnsSoldItem(lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  010f4	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  010fa	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  010fe	52		 push	 edx
  010ff	56		 push	 esi
  01100	8b 03		 mov	 eax, DWORD PTR [ebx]
  01102	50		 push	 eax
  01103	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem

; 9831 : 
; 9832 : //#if(OFFLINE_TRADE==TRUE)
; 9833 : 				GDUserItemSave(lpObj);		

  01108	53		 push	 ebx
  01109	e8 00 00 00 00	 call	 ?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ; GDUserItemSave

; 9834 : #ifndef FIX_DS_CRASH
; 9835 : 				GJSetCharacterInfo(lpObj, lpObj->m_Index, 0);	
; 9836 : 				GJSetCharacterInfo(lpObj, aSourceIndex, 0);		
; 9837 : #endif
; 9838 : //#endif
; 9839 : 
; 9840 : 				LogAddTD("[PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%d",
; 9841 : 					gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].Ip_addr,
; 9842 : 					lpObj->AccountID, lpObj->Name, lpObj->Ip_addr, iPShopValue, iITEM_LOG_TYPE,
; 9843 : 					ItemAttribute[iITEM_LOG_TYPE].Name, iITEM_LOG_LEVEL, iITEM_LOG_DUR, iITEM_LOG_SERIAL);

  0110e	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  01111	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  01114	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0111a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01120	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  01123	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_SERIAL$[ebp]
  01129	51		 push	 ecx
  0112a	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_DUR$[ebp]
  01130	51		 push	 ecx
  01131	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_LEVEL$[ebp]
  01137	51		 push	 ecx
  01138	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _iITEM_LOG_TYPE$[ebp]
  0113e	8b f1		 mov	 esi, ecx
  01140	6b f6 70	 imul	 esi, 112		; 00000070H
  01143	81 c6 00 00 00
	00		 add	 esi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01149	56		 push	 esi
  0114a	51		 push	 ecx
  0114b	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _iPShopValue$247659[ebp]
  01151	51		 push	 ecx
  01152	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  01155	51		 push	 ecx
  01156	57		 push	 edi
  01157	52		 push	 edx
  01158	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  0115b	52		 push	 edx
  0115c	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  0115f	51		 push	 ecx
  01160	83 c0 6c	 add	 eax, 108		; 0000006cH
  01163	50		 push	 eax
  01164	68 00 00 00 00	 push	 OFFSET ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
  01169	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0116f	83 c4 54	 add	 esp, 84			; 00000054H

; 9844 : 
; 9845 : 				if (PShop_CheckInventoryEmpty(lpObj->m_Index) == true )

  01172	0f b7 13	 movzx	 edx, WORD PTR [ebx]
  01175	52		 push	 edx
  01176	e8 00 00 00 00	 call	 ?PShop_CheckInventoryEmpty@@YA_NF@Z ; PShop_CheckInventoryEmpty
  0117b	83 c4 04	 add	 esp, 4
  0117e	3c 01		 cmp	 al, 1
  01180	0f 85 f0 03 00
	00		 jne	 $LN2@CGPShopReq@7

; 9846 : 				{
; 9847 : 					LogAddTD("[PShop] [%s][%s] Sold All Items - Auto Closing PShop",
; 9848 : 						lpObj->AccountID, lpObj->Name);::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 195)), lpObj->m_Index, 1);

  01186	57		 push	 edi
  01187	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0118a	50		 push	 eax
  0118b	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
  01190	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01196	83 c4 0c	 add	 esp, 12			; 0000000cH
  01199	6a 01		 push	 1
  0119b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0119d	50		 push	 eax
  0119e	68 c3 04 00 00	 push	 1219			; 000004c3H
  011a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  011a8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  011ad	50		 push	 eax
  011ae	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9849 : 					lpObj->m_bPShopOpen = false;

  011b3	c6 83 c4 0e 00
	00 00		 mov	 BYTE PTR [ebx+3780], 0

; 9850 : 					memset(lpObj->m_szPShopText, 0, sizeof(lpObj->m_szPShopText));

  011ba	33 c0		 xor	 eax, eax
  011bc	89 83 c8 0e 00
	00		 mov	 DWORD PTR [ebx+3784], eax
  011c2	89 83 cc 0e 00
	00		 mov	 DWORD PTR [ebx+3788], eax
  011c8	89 83 d0 0e 00
	00		 mov	 DWORD PTR [ebx+3792], eax
  011ce	89 83 d4 0e 00
	00		 mov	 DWORD PTR [ebx+3796], eax
  011d4	89 83 d8 0e 00
	00		 mov	 DWORD PTR [ebx+3800], eax
  011da	89 83 dc 0e 00
	00		 mov	 DWORD PTR [ebx+3804], eax
  011e0	89 83 e0 0e 00
	00		 mov	 DWORD PTR [ebx+3808], eax
  011e6	89 83 e4 0e 00
	00		 mov	 DWORD PTR [ebx+3812], eax
  011ec	89 83 e8 0e 00
	00		 mov	 DWORD PTR [ebx+3816], eax

; 9851 : 					::CGPShopAnsClose(lpObj->m_Index, 1);

  011f2	6a 01		 push	 1
  011f4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  011f6	51		 push	 ecx
  011f7	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  011fc	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGPShopReq@7:

; 9867 : 				}
; 9868 : 
; 9869 : 			}
; 9870 : 		}
; 9871 : 		__finally

  011ff	9b		 fwait
  01200	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  01207	e8 c6 03 00 00	 call	 $LN144@CGPShopReq@7
  0120c	e9 25 04 00 00	 jmp	 $LN145@CGPShopReq@7
$LN40@CGPShopReq@7:

; 9696 : 				}
; 9697 : 				else
; 9698 : 				{
; 9699 : 					for ( n = INVETORY_WEAR_SIZE ; n< invSize; n++)

  01211	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
$LN177@CGPShopReq@7:
  01216	89 bd 78 ff ff
	ff		 mov	 DWORD PTR _n$247657[ebp], edi
  0121c	3b bd 5c ff ff
	ff		 cmp	 edi, DWORD PTR _invSize$247658[ebp]
  01222	0f 8d 1d fe ff
	ff		 jge	 $LN36@CGPShopReq@7

; 9700 : 					{
; 9701 : 						if ( !lpSourceObj->pInventory[n].IsItem() )

  01228	8b c7		 mov	 eax, edi
  0122a	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  01230	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv2094[ebp], eax
  01236	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  0123c	03 c8		 add	 ecx, eax
  0123e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  01243	85 c0		 test	 eax, eax

; 9702 : 							continue;

  01245	0f 84 09 02 00
	00		 je	 $LN37@CGPShopReq@7

; 9703 : 
; 9704 : 						int JewelType = lpSourceObj->pInventory[n].m_Type;

  0124b	8b 86 24 0e 00
	00		 mov	 eax, DWORD PTR [esi+3620]
  01251	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv2094[ebp]
  01257	0f bf 4c 10 06	 movsx	 ecx, WORD PTR [eax+edx+6]
  0125c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _JewelType$247754[ebp], ecx

; 9705 : 						int JewelLevel = lpSourceObj->pInventory[n].m_Level;

  01262	0f bf 44 10 08	 movsx	 eax, WORD PTR [eax+edx+8]
  01267	89 85 68 ff ff
	ff		 mov	 DWORD PTR _JewelLevel$247755[ebp], eax

; 9706 : 
; 9707 : 						switch(JewelType)

  0126d	81 f9 8d 18 00
	00		 cmp	 ecx, 6285		; 0000188dH
  01273	0f 8f 8b 00 00
	00		 jg	 $LN140@CGPShopReq@7
  01279	74 1d		 je	 SHORT $LN28@CGPShopReq@7
  0127b	8d 81 f1 e7 ff
	ff		 lea	 eax, DWORD PTR [ecx-6159]
  01281	83 f8 79	 cmp	 eax, 121		; 00000079H
  01284	0f 87 ca 01 00
	00		 ja	 $LN37@CGPShopReq@7
  0128a	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN161@CGPShopReq@7[eax]
  01291	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN185@CGPShopReq@7[ecx*4]
$LN28@CGPShopReq@7:

; 9729 : 						case ITEMGET(12,15):
; 9730 : 						case ITEMGET(12,141):
; 9731 : 							if( JewelCount[2] < aPShopJewelValue[2] )

  01298	0f bf 55 e0	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp+4]
  0129c	39 55 a8	 cmp	 DWORD PTR _JewelCount$247699[ebp+8], edx
  0129f	0f 8d af 01 00
	00		 jge	 $LN37@CGPShopReq@7

; 9732 : 							{
; 9733 : 								gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  012a5	68 ff 00 00 00	 push	 255			; 000000ffH
  012aa	57		 push	 edi
  012ab	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  012b1	50		 push	 eax
  012b2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  012b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9734 : 								lpSourceObj->pInventory[n].Clear();

  012ba	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  012c0	03 8d 64 ff ff
	ff		 add	 ecx, DWORD PTR tv2094[ebp]
  012c6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9735 : 								GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  012cb	6a 01		 push	 1
  012cd	57		 push	 edi
  012ce	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  012d4	51		 push	 ecx
  012d5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  012da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9736 : 								JewelCount[2] += (JewelType == ITEMGET(12,15) ) ? 1 : ((JewelLevel+1)*10);

  012dd	81 bd 60 ff ff
	ff 0f 18 00 00	 cmp	 DWORD PTR _JewelType$247754[ebp], 6159 ; 0000180fH
  012e7	75 07		 jne	 SHORT $LN136@CGPShopReq@7
  012e9	b8 01 00 00 00	 mov	 eax, 1
  012ee	eb 0c		 jmp	 SHORT $LN137@CGPShopReq@7
$LN136@CGPShopReq@7:
  012f0	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$247755[ebp]
  012f6	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  012fa	03 c0		 add	 eax, eax
$LN137@CGPShopReq@7:
  012fc	01 45 a8	 add	 DWORD PTR _JewelCount$247699[ebp+8], eax

; 9737 : 							}
; 9738 : 							break;

  012ff	e9 50 01 00 00	 jmp	 $LN37@CGPShopReq@7
$LN140@CGPShopReq@7:

; 9706 : 
; 9707 : 						switch(JewelType)

  01304	81 e9 0d 1c 00
	00		 sub	 ecx, 7181		; 00001c0dH
  0130a	0f 84 e1 00 00
	00		 je	 $LN32@CGPShopReq@7
  01310	49		 dec	 ecx
  01311	74 75		 je	 SHORT $LN30@CGPShopReq@7
  01313	83 e9 02	 sub	 ecx, 2
  01316	0f 85 38 01 00
	00		 jne	 $LN37@CGPShopReq@7
$LN26@CGPShopReq@7:

; 9739 : 						case ITEMGET(14,16):
; 9740 : 						case ITEMGET(12,136):
; 9741 : 							if( JewelCount[3] < aPShopJewelValue[3] )

  0131c	0f bf 55 e2	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp+6]
  01320	39 55 ac	 cmp	 DWORD PTR _JewelCount$247699[ebp+12], edx
  01323	0f 8d 2b 01 00
	00		 jge	 $LN37@CGPShopReq@7

; 9742 : 							{
; 9743 : 								gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  01329	68 ff 00 00 00	 push	 255			; 000000ffH
  0132e	57		 push	 edi
  0132f	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  01335	50		 push	 eax
  01336	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0133b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9744 : 								lpSourceObj->pInventory[n].Clear();

  0133e	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  01344	03 8d 64 ff ff
	ff		 add	 ecx, DWORD PTR tv2094[ebp]
  0134a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9745 : 								GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  0134f	6a 01		 push	 1
  01351	57		 push	 edi
  01352	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  01358	51		 push	 ecx
  01359	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0135e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9746 : 								JewelCount[3] += (JewelType == ITEMGET(14,16) ) ? 1 : ((JewelLevel+1)*10);

  01361	81 bd 60 ff ff
	ff 10 1c 00 00	 cmp	 DWORD PTR _JewelType$247754[ebp], 7184 ; 00001c10H
  0136b	75 07		 jne	 SHORT $LN138@CGPShopReq@7
  0136d	b8 01 00 00 00	 mov	 eax, 1
  01372	eb 0c		 jmp	 SHORT $LN139@CGPShopReq@7
$LN138@CGPShopReq@7:
  01374	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$247755[ebp]
  0137a	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  0137e	03 c0		 add	 eax, eax
$LN139@CGPShopReq@7:
  01380	01 45 ac	 add	 DWORD PTR _JewelCount$247699[ebp+12], eax

; 9747 : 							}
; 9748 : 							break;

  01383	e9 cc 00 00 00	 jmp	 $LN37@CGPShopReq@7
$LN30@CGPShopReq@7:

; 9717 : 							}
; 9718 : 							break;
; 9719 : 						case ITEMGET(14,14):
; 9720 : 						case ITEMGET(12,31):
; 9721 : 							if( JewelCount[1] < aPShopJewelValue[1] )

  01388	0f bf 55 de	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp+2]
  0138c	39 55 a4	 cmp	 DWORD PTR _JewelCount$247699[ebp+4], edx
  0138f	0f 8d bf 00 00
	00		 jge	 $LN37@CGPShopReq@7

; 9722 : 							{
; 9723 : 								gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  01395	68 ff 00 00 00	 push	 255			; 000000ffH
  0139a	57		 push	 edi
  0139b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  013a1	50		 push	 eax
  013a2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  013a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9724 : 								lpSourceObj->pInventory[n].Clear();

  013aa	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  013b0	03 8d 64 ff ff
	ff		 add	 ecx, DWORD PTR tv2094[ebp]
  013b6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9725 : 								GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  013bb	6a 01		 push	 1
  013bd	57		 push	 edi
  013be	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  013c4	51		 push	 ecx
  013c5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  013ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9726 : 								JewelCount[1] += (JewelType == ITEMGET(14,14) ) ? 1 : ((JewelLevel+1)*10);

  013cd	81 bd 60 ff ff
	ff 0e 1c 00 00	 cmp	 DWORD PTR _JewelType$247754[ebp], 7182 ; 00001c0eH
  013d7	75 07		 jne	 SHORT $LN134@CGPShopReq@7
  013d9	b8 01 00 00 00	 mov	 eax, 1
  013de	eb 0c		 jmp	 SHORT $LN135@CGPShopReq@7
$LN134@CGPShopReq@7:
  013e0	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$247755[ebp]
  013e6	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  013ea	03 c0		 add	 eax, eax
$LN135@CGPShopReq@7:
  013ec	01 45 a4	 add	 DWORD PTR _JewelCount$247699[ebp+4], eax

; 9727 : 							}
; 9728 : 							break;

  013ef	eb 63		 jmp	 SHORT $LN37@CGPShopReq@7
$LN32@CGPShopReq@7:

; 9708 : 						{
; 9709 : 						case ITEMGET(14,13):
; 9710 : 						case ITEMGET(12,30):
; 9711 : 							if( JewelCount[0] < aPShopJewelValue[0] )

  013f1	0f bf 55 dc	 movsx	 edx, WORD PTR _aPShopJewelValue$247662[ebp]
  013f5	39 55 a0	 cmp	 DWORD PTR _JewelCount$247699[ebp], edx
  013f8	7d 5a		 jge	 SHORT $LN37@CGPShopReq@7

; 9712 : 							{
; 9713 : 								gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  013fa	68 ff 00 00 00	 push	 255			; 000000ffH
  013ff	57		 push	 edi
  01400	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  01406	50		 push	 eax
  01407	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0140c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9714 : 								lpSourceObj->pInventory[n].Clear();

  0140f	8b 8e 24 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3620]
  01415	03 8d 64 ff ff
	ff		 add	 ecx, DWORD PTR tv2094[ebp]
  0141b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9715 : 								GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  01420	6a 01		 push	 1
  01422	57		 push	 edi
  01423	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  01429	51		 push	 ecx
  0142a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0142f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9716 : 								JewelCount[0] += (JewelType == ITEMGET(14,13) ) ? 1 : ((JewelLevel+1)*10);

  01432	81 bd 60 ff ff
	ff 0d 1c 00 00	 cmp	 DWORD PTR _JewelType$247754[ebp], 7181 ; 00001c0dH
  0143c	75 07		 jne	 SHORT $LN132@CGPShopReq@7
  0143e	b8 01 00 00 00	 mov	 eax, 1
  01443	eb 0c		 jmp	 SHORT $LN133@CGPShopReq@7
$LN132@CGPShopReq@7:
  01445	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$247755[ebp]
  0144b	8d 44 80 05	 lea	 eax, DWORD PTR [eax+eax*4+5]
  0144f	03 c0		 add	 eax, eax
$LN133@CGPShopReq@7:
  01451	01 45 a0	 add	 DWORD PTR _JewelCount$247699[ebp], eax
$LN37@CGPShopReq@7:

; 9696 : 				}
; 9697 : 				else
; 9698 : 				{
; 9699 : 					for ( n = INVETORY_WEAR_SIZE ; n< invSize; n++)

  01454	47		 inc	 edi
  01455	e9 bc fd ff ff	 jmp	 $LN177@CGPShopReq@7
$LN24@CGPShopReq@7:

; 9775 : 				}
; 9776 : 				else
; 9777 : 				{
; 9778 : 					for( n = 0; n < 4; n++ )

  0145a	33 f6		 xor	 esi, esi
$LN182@CGPShopReq@7:
  0145c	89 b5 78 ff ff
	ff		 mov	 DWORD PTR _n$247657[ebp], esi
  01462	83 fe 04	 cmp	 esi, 4
  01465	0f 8d 70 fc ff
	ff		 jge	 $LN16@CGPShopReq@7

; 9779 : 					{
; 9780 : 						if( aPShopJewelValue[n] > 0 )

  0146b	66 83 7c 75 dc
	00		 cmp	 WORD PTR _aPShopJewelValue$247662[ebp+esi*2], 0
  01471	0f 8e f9 00 00
	00		 jle	 $LN3@CGPShopReq@7

; 9781 : 						{
; 9782 : 							for(int x = 0; x < aPShopJewelBoundle[n][0]; x++)

  01477	33 ff		 xor	 edi, edi
$LN178@CGPShopReq@7:
  01479	89 bd 44 ff ff
	ff		 mov	 DWORD PTR _x$247784[ebp], edi
  0147f	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  01482	0f bf 54 4d b8	 movsx	 edx, WORD PTR _aPShopJewelBoundle$247689[ebp+ecx*2]
  01487	3b fa		 cmp	 edi, edx
  01489	7d 2b		 jge	 SHORT $LN12@CGPShopReq@7

; 9783 : 							{	
; 9784 : 								ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],2,1,0,0,0,lpObj->m_Index,0,0);							

  0148b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0148d	6a 00		 push	 0
  0148f	6a 00		 push	 0
  01491	50		 push	 eax
  01492	6a 00		 push	 0
  01494	6a 00		 push	 0
  01496	6a 00		 push	 0
  01498	6a 01		 push	 1
  0149a	6a 02		 push	 2
  0149c	8b 4c b5 90	 mov	 ecx, DWORD PTR _iBoundleId$247772[ebp+esi*4]
  014a0	51		 push	 ecx
  014a1	6a 00		 push	 0
  014a3	6a 00		 push	 0
  014a5	68 eb 00 00 00	 push	 235			; 000000ebH
  014aa	50		 push	 eax
  014ab	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  014b0	83 c4 34	 add	 esp, 52			; 00000034H

; 9781 : 						{
; 9782 : 							for(int x = 0; x < aPShopJewelBoundle[n][0]; x++)

  014b3	47		 inc	 edi
  014b4	eb c3		 jmp	 SHORT $LN178@CGPShopReq@7
$LN12@CGPShopReq@7:

; 9785 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9786 : 								if(lpObj->m_OfflineTrade)
; 9787 : 								{
; 9788 : 									lpObj->OffTradeWaitItem++;
; 9789 : 								}
; 9790 : 	#endif
; 9791 : 							}
; 9792 : 
; 9793 : 							for(int x = 0; x < aPShopJewelBoundle[n][1]; x++)

  014b6	33 ff		 xor	 edi, edi
$LN179@CGPShopReq@7:
  014b8	89 bd 50 ff ff
	ff		 mov	 DWORD PTR _x$247788[ebp], edi
  014be	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  014c1	0f bf 44 55 ba	 movsx	 eax, WORD PTR _aPShopJewelBoundle$247689[ebp+edx*2+2]
  014c6	3b f8		 cmp	 edi, eax
  014c8	7d 2b		 jge	 SHORT $LN9@CGPShopReq@7

; 9794 : 							{	
; 9795 : 								ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],1,1,0,0,0,lpObj->m_Index,0,0);

  014ca	8b 03		 mov	 eax, DWORD PTR [ebx]
  014cc	6a 00		 push	 0
  014ce	6a 00		 push	 0
  014d0	50		 push	 eax
  014d1	6a 00		 push	 0
  014d3	6a 00		 push	 0
  014d5	6a 00		 push	 0
  014d7	6a 01		 push	 1
  014d9	6a 01		 push	 1
  014db	8b 4c b5 90	 mov	 ecx, DWORD PTR _iBoundleId$247772[ebp+esi*4]
  014df	51		 push	 ecx
  014e0	6a 00		 push	 0
  014e2	6a 00		 push	 0
  014e4	68 eb 00 00 00	 push	 235			; 000000ebH
  014e9	50		 push	 eax
  014ea	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  014ef	83 c4 34	 add	 esp, 52			; 00000034H

; 9785 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9786 : 								if(lpObj->m_OfflineTrade)
; 9787 : 								{
; 9788 : 									lpObj->OffTradeWaitItem++;
; 9789 : 								}
; 9790 : 	#endif
; 9791 : 							}
; 9792 : 
; 9793 : 							for(int x = 0; x < aPShopJewelBoundle[n][1]; x++)

  014f2	47		 inc	 edi
  014f3	eb c3		 jmp	 SHORT $LN179@CGPShopReq@7
$LN9@CGPShopReq@7:

; 9796 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9797 : 								if(lpObj->m_OfflineTrade)
; 9798 : 								{
; 9799 : 									lpObj->OffTradeWaitItem++;
; 9800 : 								}
; 9801 : 	#endif
; 9802 : 							}
; 9803 : 
; 9804 : 							for(int x = 0; x < aPShopJewelBoundle[n][2]; x++)

  014f5	33 ff		 xor	 edi, edi
$LN180@CGPShopReq@7:
  014f7	89 bd 34 ff ff
	ff		 mov	 DWORD PTR _x$247792[ebp], edi
  014fd	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  01500	0f bf 44 55 bc	 movsx	 eax, WORD PTR _aPShopJewelBoundle$247689[ebp+edx*2+4]
  01505	3b f8		 cmp	 edi, eax
  01507	7d 2b		 jge	 SHORT $LN6@CGPShopReq@7

; 9805 : 							{	
; 9806 : 								ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],0,1,0,0,0,lpObj->m_Index,0,0);

  01509	8b 03		 mov	 eax, DWORD PTR [ebx]
  0150b	6a 00		 push	 0
  0150d	6a 00		 push	 0
  0150f	50		 push	 eax
  01510	6a 00		 push	 0
  01512	6a 00		 push	 0
  01514	6a 00		 push	 0
  01516	6a 01		 push	 1
  01518	6a 00		 push	 0
  0151a	8b 4c b5 90	 mov	 ecx, DWORD PTR _iBoundleId$247772[ebp+esi*4]
  0151e	51		 push	 ecx
  0151f	6a 00		 push	 0
  01521	6a 00		 push	 0
  01523	68 eb 00 00 00	 push	 235			; 000000ebH
  01528	50		 push	 eax
  01529	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0152e	83 c4 34	 add	 esp, 52			; 00000034H

; 9796 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9797 : 								if(lpObj->m_OfflineTrade)
; 9798 : 								{
; 9799 : 									lpObj->OffTradeWaitItem++;
; 9800 : 								}
; 9801 : 	#endif
; 9802 : 							}
; 9803 : 
; 9804 : 							for(int x = 0; x < aPShopJewelBoundle[n][2]; x++)

  01531	47		 inc	 edi
  01532	eb c3		 jmp	 SHORT $LN180@CGPShopReq@7
$LN6@CGPShopReq@7:

; 9807 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9808 : 								if(lpObj->m_OfflineTrade)
; 9809 : 								{
; 9810 : 									lpObj->OffTradeWaitItem++;
; 9811 : 								}
; 9812 : 	#endif
; 9813 : 							}
; 9814 : 
; 9815 : 							for(int x = 0; x < aPShopJewel[n]; x++)

  01534	33 ff		 xor	 edi, edi
$LN181@CGPShopReq@7:
  01536	89 bd 4c ff ff
	ff		 mov	 DWORD PTR _x$247796[ebp], edi
  0153c	0f bf 54 75 b0	 movsx	 edx, WORD PTR _aPShopJewel$247688[ebp+esi*2]
  01541	3b fa		 cmp	 edi, edx
  01543	7d 2b		 jge	 SHORT $LN3@CGPShopReq@7

; 9816 : 							{	
; 9817 : 								ItemSerialCreateSend(lpObj->m_Index,235,0,0,iJewelId[n],0,1,0,0,0,lpObj->m_Index,0,0);

  01545	8b 03		 mov	 eax, DWORD PTR [ebx]
  01547	6a 00		 push	 0
  01549	6a 00		 push	 0
  0154b	50		 push	 eax
  0154c	6a 00		 push	 0
  0154e	6a 00		 push	 0
  01550	6a 00		 push	 0
  01552	6a 01		 push	 1
  01554	6a 00		 push	 0
  01556	8b 4c b5 80	 mov	 ecx, DWORD PTR _iJewelId$247773[ebp+esi*4]
  0155a	51		 push	 ecx
  0155b	6a 00		 push	 0
  0155d	6a 00		 push	 0
  0155f	68 eb 00 00 00	 push	 235			; 000000ebH
  01564	50		 push	 eax
  01565	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0156a	83 c4 34	 add	 esp, 52			; 00000034H

; 9807 : 	#if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9808 : 								if(lpObj->m_OfflineTrade)
; 9809 : 								{
; 9810 : 									lpObj->OffTradeWaitItem++;
; 9811 : 								}
; 9812 : 	#endif
; 9813 : 							}
; 9814 : 
; 9815 : 							for(int x = 0; x < aPShopJewel[n]; x++)

  0156d	47		 inc	 edi
  0156e	eb c6		 jmp	 SHORT $LN181@CGPShopReq@7
$LN3@CGPShopReq@7:

; 9775 : 				}
; 9776 : 				else
; 9777 : 				{
; 9778 : 					for( n = 0; n < 4; n++ )

  01570	46		 inc	 esi
  01571	e9 e6 fe ff ff	 jmp	 $LN182@CGPShopReq@7
$LN2@CGPShopReq@7:

; 9852 : 
; 9853 : //#if(OFFLINE_TRADE==TRUE)
; 9854 : //					g_OfflineTrade.UserOnlineOffSell(lpObj);
; 9855 : //#endif
; 9856 : 
; 9857 : #if (OFFLINE_TRADE == 1 || OFFLINE_ATTACK == 1)
; 9858 : 					if( lpObj->m_OfflineTrade && lpObj->OffTradeWaitItem == 0 )
; 9859 : 					{
; 9860 : 						//gObjDel(lpObj->m_Index);
; 9861 : 					}
; 9862 : #endif
; 9863 : 				}
; 9864 : 				else
; 9865 : 				{
; 9866 : 					lpObj->m_bPShopItemChange = true;

  01576	c6 83 c6 0e 00
	00 01		 mov	 BYTE PTR [ebx+3782], 1
  0157d	e9 7d fc ff ff	 jmp	 $LN1@CGPShopReq@7
$LN100@CGPShopReq@7:

; 9377 : 				{
; 9378 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did Not Choose Item Price",
; 9379 : 						lpSourceObj->AccountID, lpSourceObj->Name,
; 9380 : 						lpObj->AccountID, lpObj->Name);

  01582	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  01585	50		 push	 eax
  01586	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  01589	52		 push	 edx
  0158a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _lpSourceObj$[ebp]
  01590	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  01593	51		 push	 ecx
  01594	83 c0 6c	 add	 eax, 108		; 0000006cH
  01597	50		 push	 eax
  01598	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0159d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9381 : 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  015a3	6a 06		 push	 6
  015a5	6a 00		 push	 0
  015a7	8b 13		 mov	 edx, DWORD PTR [ebx]
  015a9	52		 push	 edx
  015aa	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  015b0	50		 push	 eax
  015b1	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 9382 : 					return;

  015b6	6a fe		 push	 -2			; fffffffeH
  015b8	9b		 fwait
  015b9	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  015bc	51		 push	 ecx
  015bd	68 00 00 00 00	 push	 OFFSET ___security_cookie
  015c2	e8 00 00 00 00	 call	 __local_unwind4
  015c7	83 c4 30	 add	 esp, 48			; 00000030H
  015ca	eb 6a		 jmp	 SHORT $LN145@CGPShopReq@7
$LN142@CGPShopReq@7:
$LN186@CGPShopReq@7:

; 9867 : 				}
; 9868 : 
; 9869 : 			}
; 9870 : 		}
; 9871 : 		__finally

  015cc	8b 9d 3c ff ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
$LN144@CGPShopReq@7:

; 9872 : 		{
; 9873 : 			lpObj->m_bPShopTransaction = false;

  015d2	c6 83 c5 0e 00
	00 00		 mov	 BYTE PTR [ebx+3781], 0
$LN143@CGPShopReq@7:
$LN171@CGPShopReq@7:
  015d9	c3		 ret	 0
$LN115@CGPShopReq@7:

; 9255 : 	{
; 9256 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 9257 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  015da	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  015dd	50		 push	 eax
  015de	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  015e1	52		 push	 edx
  015e2	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  015e5	50		 push	 eax
  015e6	83 c6 6c	 add	 esi, 108		; 0000006cH
  015e9	56		 push	 esi
  015ea	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  015ef	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9258 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  015f5	6a 09		 push	 9
  015f7	6a 00		 push	 0
  015f9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  015fb	51		 push	 ecx
  015fc	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  01602	52		 push	 edx

; 9259 : 		return;

  01603	eb 29		 jmp	 SHORT $LN172@CGPShopReq@7
$LN117@CGPShopReq@7:

; 9246 : 	{
; 9247 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 9248 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);

  01605	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  01608	50		 push	 eax
  01609	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  0160c	50		 push	 eax
  0160d	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  01610	51		 push	 ecx
  01611	83 c6 6c	 add	 esi, 108		; 0000006cH
  01614	56		 push	 esi
  01615	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0161a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9249 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  01620	6a 09		 push	 9
$LN173@CGPShopReq@7:
  01622	6a 00		 push	 0
  01624	8b 13		 mov	 edx, DWORD PTR [ebx]
  01626	52		 push	 edx
  01627	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0162d	50		 push	 eax
$LN172@CGPShopReq@7:
  0162e	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01633	83 c4 24	 add	 esp, 36			; 00000024H
$LN145@CGPShopReq@7:

; 9874 : 		}
; 9875 : 	}
; 9876 : }

  01636	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  01639	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01640	59		 pop	 ecx
  01641	5f		 pop	 edi
  01642	5e		 pop	 esi
  01643	5b		 pop	 ebx
  01644	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01647	33 cd		 xor	 ecx, ebp
  01649	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0164e	8b e5		 mov	 esp, ebp
  01650	5d		 pop	 ebp
  01651	c3		 ret	 0
  01652	8b ff		 npad	 2
$LN185@CGPShopReq@7:
  01654	00 00 00 00	 DD	 $LN28@CGPShopReq@7
  01658	00 00 00 00	 DD	 $LN32@CGPShopReq@7
  0165c	00 00 00 00	 DD	 $LN30@CGPShopReq@7
  01660	00 00 00 00	 DD	 $LN26@CGPShopReq@7
  01664	00 00 00 00	 DD	 $LN37@CGPShopReq@7
$LN161@CGPShopReq@7:
  01668	00		 DB	 0
  01669	04		 DB	 4
  0166a	04		 DB	 4
  0166b	04		 DB	 4
  0166c	04		 DB	 4
  0166d	04		 DB	 4
  0166e	04		 DB	 4
  0166f	04		 DB	 4
  01670	04		 DB	 4
  01671	04		 DB	 4
  01672	04		 DB	 4
  01673	04		 DB	 4
  01674	04		 DB	 4
  01675	04		 DB	 4
  01676	04		 DB	 4
  01677	01		 DB	 1
  01678	02		 DB	 2
  01679	04		 DB	 4
  0167a	04		 DB	 4
  0167b	04		 DB	 4
  0167c	04		 DB	 4
  0167d	04		 DB	 4
  0167e	04		 DB	 4
  0167f	04		 DB	 4
  01680	04		 DB	 4
  01681	04		 DB	 4
  01682	04		 DB	 4
  01683	04		 DB	 4
  01684	04		 DB	 4
  01685	04		 DB	 4
  01686	04		 DB	 4
  01687	04		 DB	 4
  01688	04		 DB	 4
  01689	04		 DB	 4
  0168a	04		 DB	 4
  0168b	04		 DB	 4
  0168c	04		 DB	 4
  0168d	04		 DB	 4
  0168e	04		 DB	 4
  0168f	04		 DB	 4
  01690	04		 DB	 4
  01691	04		 DB	 4
  01692	04		 DB	 4
  01693	04		 DB	 4
  01694	04		 DB	 4
  01695	04		 DB	 4
  01696	04		 DB	 4
  01697	04		 DB	 4
  01698	04		 DB	 4
  01699	04		 DB	 4
  0169a	04		 DB	 4
  0169b	04		 DB	 4
  0169c	04		 DB	 4
  0169d	04		 DB	 4
  0169e	04		 DB	 4
  0169f	04		 DB	 4
  016a0	04		 DB	 4
  016a1	04		 DB	 4
  016a2	04		 DB	 4
  016a3	04		 DB	 4
  016a4	04		 DB	 4
  016a5	04		 DB	 4
  016a6	04		 DB	 4
  016a7	04		 DB	 4
  016a8	04		 DB	 4
  016a9	04		 DB	 4
  016aa	04		 DB	 4
  016ab	04		 DB	 4
  016ac	04		 DB	 4
  016ad	04		 DB	 4
  016ae	04		 DB	 4
  016af	04		 DB	 4
  016b0	04		 DB	 4
  016b1	04		 DB	 4
  016b2	04		 DB	 4
  016b3	04		 DB	 4
  016b4	04		 DB	 4
  016b5	04		 DB	 4
  016b6	04		 DB	 4
  016b7	04		 DB	 4
  016b8	04		 DB	 4
  016b9	04		 DB	 4
  016ba	04		 DB	 4
  016bb	04		 DB	 4
  016bc	04		 DB	 4
  016bd	04		 DB	 4
  016be	04		 DB	 4
  016bf	04		 DB	 4
  016c0	04		 DB	 4
  016c1	04		 DB	 4
  016c2	04		 DB	 4
  016c3	04		 DB	 4
  016c4	04		 DB	 4
  016c5	04		 DB	 4
  016c6	04		 DB	 4
  016c7	04		 DB	 4
  016c8	04		 DB	 4
  016c9	04		 DB	 4
  016ca	04		 DB	 4
  016cb	04		 DB	 4
  016cc	04		 DB	 4
  016cd	04		 DB	 4
  016ce	04		 DB	 4
  016cf	04		 DB	 4
  016d0	04		 DB	 4
  016d1	04		 DB	 4
  016d2	04		 DB	 4
  016d3	04		 DB	 4
  016d4	04		 DB	 4
  016d5	04		 DB	 4
  016d6	04		 DB	 4
  016d7	04		 DB	 4
  016d8	04		 DB	 4
  016d9	04		 DB	 4
  016da	04		 DB	 4
  016db	04		 DB	 4
  016dc	04		 DB	 4
  016dd	04		 DB	 4
  016de	04		 DB	 4
  016df	04		 DB	 4
  016e0	04		 DB	 4
  016e1	03		 DB	 3
?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyItemEx
_TEXT	ENDS
PUBLIC	??_C@_0IE@IMPNINKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ ; `string'
PUBLIC	_aSourceIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
EXTRN	?UserOnlineOffSell@cOffTrade@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; cOffTrade::UserOnlineOffSell
EXTRN	?ValueUpdate@cOffTrade@@QAEXHHH@Z:PROC		; cOffTrade::ValueUpdate
EXTRN	?CheckMoney@cOffTrade@@QAE_NHHH@Z:PROC		; cOffTrade::CheckMoney
;	COMDAT ??_C@_0IE@IMPNINKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
CONST	SEGMENT
??_C@_0IE@IMPNINKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ DB '['
	DB	'PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s]'
	DB	'[%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, S'
	DB	'erial:%u', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffffa4H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN34@CGPShopReq@8
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
_iITEM_LOG_LEVEL$ = -76					; size = 4
_iITEM_LOG_DUR$ = -72					; size = 4
_lpObj$ = -68						; size = 4
_iITEM_LOG_TYPE$ = -64					; size = 4
_aSourceIndex$GSCopy$ = -60				; size = 4
tv909 = -56						; size = 4
tv1011 = -52						; size = 4
tv956 = -52						; size = 4
_dwCost$247856 = -52					; size = 4
_lpMsg$GSCopy$ = -48					; size = 4
_iITEM_LOG_SERIAL$ = -48				; size = 4
tv999 = -41						; size = 1
_btNewItemPos$247858 = -41				; size = 1
_szName$ = -40						; size = 11
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyItem, COMDAT

; 9879 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 9969 : 	{
; 9970 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 9971 : 			gObj[aSourceIndex].AccountID, 
; 9972 : 			gObj[aSourceIndex].Name, 
; 9973 : 			lpObj->AccountID, 
; 9974 : 			lpObj->Name);

  00036	89 75 d0	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], esi
  00039	8b 7d 0c	 mov	 edi, DWORD PTR _aSourceIndex$[ebp]
  0003c	89 7d c4	 mov	 DWORD PTR _aSourceIndex$GSCopy$[ebp], edi

; 9880 : 	if ( gDoPShopOpen == FALSE )

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00046	0f 84 dd 07 00
	00		 je	 $LN37@CGPShopReq@8

; 9881 : 	{
; 9882 : 		return;
; 9883 : 	}
; 9884 : 
; 9885 : 	if ( gObjIsConnected( MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE )

  0004c	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00050	66 c1 e0 08	 shl	 ax, 8
  00054	0f b7 c8	 movzx	 ecx, ax
  00057	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  0005b	0b ca		 or	 ecx, edx
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00063	83 c4 04	 add	 esp, 4

; 9886 : 	{
; 9887 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller did Not CONNECTED (%d)",
; 9888 : 			gObj[aSourceIndex].AccountID, 
; 9889 : 			gObj[aSourceIndex].Name, 
; 9890 : 			MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00066	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  0006a	66 c1 e2 08	 shl	 dx, 8
  0006e	0f b7 ca	 movzx	 ecx, dx

; 9881 : 	{
; 9882 : 		return;
; 9883 : 	}
; 9884 : 
; 9885 : 	if ( gObjIsConnected( MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE )

  00071	85 c0		 test	 eax, eax
  00073	75 3c		 jne	 SHORT $LN27@CGPShopReq@8

; 9886 : 	{
; 9887 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller did Not CONNECTED (%d)",
; 9888 : 			gObj[aSourceIndex].AccountID, 
; 9889 : 			gObj[aSourceIndex].Name, 
; 9890 : 			MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  00075	8b c7		 mov	 eax, edi
  00077	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0007d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	0f b6 56 05	 movzx	 edx, BYTE PTR [esi+5]
  00087	0b ca		 or	 ecx, edx
  00089	51		 push	 ecx
  0008a	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  0008d	51		 push	 ecx
  0008e	83 c0 6c	 add	 eax, 108		; 0000006cH
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
$LN47@CGPShopReq@8:
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9891 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  0009d	6a 02		 push	 2
  0009f	6a 00		 push	 0
  000a1	6a ff		 push	 -1
  000a3	57		 push	 edi
  000a4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  000a9	83 c4 20	 add	 esp, 32			; 00000020H

; 9892 : 		return;

  000ac	e9 78 07 00 00	 jmp	 $LN37@CGPShopReq@8
$LN27@CGPShopReq@8:

; 9893 : 	}
; 9894 : 
; 9895 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  000b1	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  000b5	0b c8		 or	 ecx, eax
  000b7	8b d9		 mov	 ebx, ecx
  000b9	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	03 d8		 add	 ebx, eax
  000c6	89 5d bc	 mov	 DWORD PTR _lpObj$[ebp], ebx

; 9896 : 
; 9897 : 	if ( lpObj->Type != OBJ_USER )

  000c9	66 83 7b 68 01	 cmp	 WORD PTR [ebx+104], 1
  000ce	74 1a		 je	 SHORT $LN26@CGPShopReq@8

; 9898 : 	{
; 9899 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not CHARACTER (%d)",
; 9900 : 			gObj[aSourceIndex].AccountID, 
; 9901 : 			gObj[aSourceIndex].Name,  
; 9902 : 			MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  000d0	8b d7		 mov	 edx, edi
  000d2	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000d8	03 c2		 add	 eax, edx
  000da	51		 push	 ecx
  000db	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  000de	51		 push	 ecx
  000df	83 c0 6c	 add	 eax, 108		; 0000006cH
  000e2	50		 push	 eax
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@

; 9903 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);
; 9904 : 		return;

  000e8	eb ad		 jmp	 SHORT $LN47@CGPShopReq@8
$LN26@CGPShopReq@8:

; 9905 : 	}
; 9906 : 
; 9907 : 	if ( lpObj->CloseCount >= 0 )	

  000ea	80 7b 0a 00	 cmp	 BYTE PTR [ebx+10], 0
  000ee	7c 1a		 jl	 SHORT $LN25@CGPShopReq@8

; 9908 : 	{
; 9909 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",
; 9910 : 			gObj[aSourceIndex].AccountID, 
; 9911 : 			gObj[aSourceIndex].Name,  
; 9912 : 			MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)  );

  000f0	8b d7		 mov	 edx, edi
  000f2	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  000f8	03 c2		 add	 eax, edx
  000fa	51		 push	 ecx
  000fb	8d 48 77	 lea	 ecx, DWORD PTR [eax+119]
  000fe	51		 push	 ecx
  000ff	83 c0 6c	 add	 eax, 108		; 0000006cH
  00102	50		 push	 eax
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@

; 9913 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);
; 9914 : 		return;

  00108	eb 8d		 jmp	 SHORT $LN47@CGPShopReq@8
$LN25@CGPShopReq@8:

; 9915 : 	}
; 9916 : 
; 9917 : 	if ( gObj[aSourceIndex].CloseCount >= 0 )	

  0010a	8b f7		 mov	 esi, edi
  0010c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00112	89 75 c8	 mov	 DWORD PTR tv909[ebp], esi
  00115	80 7c 06 0a 00	 cmp	 BYTE PTR [esi+eax+10], 0
  0011a	7c 15		 jl	 SHORT $LN24@CGPShopReq@8

; 9918 : 	{
; 9919 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",
; 9920 : 			gObj[aSourceIndex].AccountID, 
; 9921 : 			gObj[aSourceIndex].Name,  
; 9922 : 			MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));

  0011c	51		 push	 ecx
  0011d	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00121	52		 push	 edx
  00122	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00126	50		 push	 eax
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@

; 9923 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);
; 9924 : 		return;

  0012c	e9 66 ff ff ff	 jmp	 $LN47@CGPShopReq@8
$LN24@CGPShopReq@8:

; 9925 : 	}
; 9926 : 
; 9927 : 	if ( lpObj->m_bPShopOpen == false )

  00131	80 bb c4 0e 00
	00 00		 cmp	 BYTE PTR [ebx+3780], 0
  00138	75 24		 jne	 SHORT $LN23@CGPShopReq@8

; 9928 : 	{
; 9929 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did not Open PShop",
; 9930 : 			gObj[aSourceIndex].AccountID, 
; 9931 : 			gObj[aSourceIndex].Name,	
; 9932 : 			lpObj->AccountID, 
; 9933 : 			lpObj->Name);

  0013a	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0013d	51		 push	 ecx
  0013e	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00141	52		 push	 edx
  00142	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00146	51		 push	 ecx
  00147	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0014b	52		 push	 edx
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9934 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 3);

  00157	6a 03		 push	 3

; 9935 : 		return;

  00159	e9 bd 06 00 00	 jmp	 $LN45@CGPShopReq@8
$LN23@CGPShopReq@8:

; 9936 : 	}
; 9937 : 
; 9938 : 	char szName[MAX_ACCOUNT_LEN+1] = {0};

  0015e	33 c9		 xor	 ecx, ecx
  00160	89 4d d9	 mov	 DWORD PTR _szName$[ebp+1], ecx
  00163	89 4d dd	 mov	 DWORD PTR _szName$[ebp+5], ecx
  00166	66 89 4d e1	 mov	 WORD PTR _szName$[ebp+9], cx

; 9939 : 	memcpy(szName, lpMsg->btName, sizeof(lpMsg->btName));

  0016a	8b 4d d0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0016d	8b 51 06	 mov	 edx, DWORD PTR [ecx+6]
  00170	89 55 d8	 mov	 DWORD PTR _szName$[ebp], edx
  00173	8b 51 0a	 mov	 edx, DWORD PTR [ecx+10]
  00176	89 55 dc	 mov	 DWORD PTR _szName$[ebp+4], edx
  00179	66 8b 49 0e	 mov	 cx, WORD PTR [ecx+14]
  0017d	66 89 4d e0	 mov	 WORD PTR _szName$[ebp+8], cx

; 9940 : 	szName[MAX_ACCOUNT_LEN] = 0;

  00181	c6 45 e2 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 9941 : 	int iITEM_LOG_TYPE;
; 9942 : 	int iITEM_LOG_LEVEL;
; 9943 : 	int iITEM_LOG_DUR;
; 9944 : 	int iITEM_LOG_SERIAL;
; 9945 : 
; 9946 : 	if ( strcmp(szName, lpObj->Name) )

  00185	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00188	8d 55 d8	 lea	 edx, DWORD PTR _szName$[ebp]
  0018b	89 55 cc	 mov	 DWORD PTR tv1011[ebp], edx
$LN39@CGPShopReq@8:
  0018e	8b 55 cc	 mov	 edx, DWORD PTR tv1011[ebp]
  00191	8a 12		 mov	 dl, BYTE PTR [edx]
  00193	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00195	75 21		 jne	 SHORT $LN40@CGPShopReq@8
  00197	84 d2		 test	 dl, dl
  00199	74 19		 je	 SHORT $LN41@CGPShopReq@8
  0019b	8b 55 cc	 mov	 edx, DWORD PTR tv1011[ebp]
  0019e	8a 52 01	 mov	 dl, BYTE PTR [edx+1]
  001a1	88 55 d7	 mov	 BYTE PTR tv999[ebp], dl
  001a4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001a7	75 0f		 jne	 SHORT $LN40@CGPShopReq@8
  001a9	83 45 cc 02	 add	 DWORD PTR tv1011[ebp], 2
  001ad	83 c1 02	 add	 ecx, 2
  001b0	84 d2		 test	 dl, dl
  001b2	75 da		 jne	 SHORT $LN39@CGPShopReq@8
$LN41@CGPShopReq@8:
  001b4	33 c9		 xor	 ecx, ecx
  001b6	eb 05		 jmp	 SHORT $LN42@CGPShopReq@8
$LN40@CGPShopReq@8:
  001b8	1b c9		 sbb	 ecx, ecx
  001ba	83 d9 ff	 sbb	 ecx, -1
$LN42@CGPShopReq@8:
  001bd	85 c9		 test	 ecx, ecx
  001bf	74 29		 je	 SHORT $LN22@CGPShopReq@8

; 9947 : 	{
; 9948 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch [%s] - [%s]",
; 9949 : 			gObj[aSourceIndex].AccountID, 
; 9950 : 			gObj[aSourceIndex].Name, 
; 9951 : 			szName, 
; 9952 : 			lpObj->Name);

  001c1	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  001c4	51		 push	 ecx
  001c5	8d 4d d8	 lea	 ecx, DWORD PTR _szName$[ebp]
  001c8	51		 push	 ecx
  001c9	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  001cd	52		 push	 edx
  001ce	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  001d2	50		 push	 eax
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9953 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  001de	6a 06		 push	 6
  001e0	6a 00		 push	 0
  001e2	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001e4	51		 push	 ecx

; 9954 : 		return;

  001e5	e9 36 06 00 00	 jmp	 $LN46@CGPShopReq@8
$LN22@CGPShopReq@8:

; 9955 : 	}
; 9956 : 
; 9957 : 	if ( lpObj->CloseType != -1 )

  001ea	80 7b 0b ff	 cmp	 BYTE PTR [ebx+11], -1
  001ee	74 24		 je	 SHORT $LN21@CGPShopReq@8

; 9958 : 	{
; 9959 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is Closing Connection",
; 9960 : 			gObj[aSourceIndex].AccountID, 
; 9961 : 			gObj[aSourceIndex].Name, 
; 9962 : 			lpObj->AccountID, 
; 9963 : 			lpObj->Name);

  001f0	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  001f3	51		 push	 ecx
  001f4	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  001f7	52		 push	 edx
  001f8	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  001fc	51		 push	 ecx
  001fd	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00201	52		 push	 edx
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9964 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,2);

  0020d	6a 02		 push	 2

; 9965 : 		return;

  0020f	e9 07 06 00 00	 jmp	 $LN45@CGPShopReq@8
$LN21@CGPShopReq@8:

; 9966 : 	}
; 9967 : 
; 9968 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty &8) == 8 )

  00214	8b 8b 10 02 00
	00		 mov	 ecx, DWORD PTR [ebx+528]
  0021a	f6 c1 0c	 test	 cl, 12			; 0000000cH
  0021d	0f 85 d9 05 00
	00		 jne	 $LN19@CGPShopReq@8

; 9976 : 		return;
; 9977 : 	}
; 9978 : 
; 9979 : 	if ( (gObj[aSourceIndex].Penalty &4) == 4 || (gObj[aSourceIndex].Penalty &8) == 8 )

  00223	f6 84 06 10 02
	00 00 0c	 test	 BYTE PTR [esi+eax+528], 12 ; 0000000cH
  0022b	0f 85 a5 05 00
	00		 jne	 $LN17@CGPShopReq@8

; 9988 : 	}
; 9989 : 
; 9990 : 	EnterCriticalSection(&lpObj->m_critPShopTrade);

  00231	8d 83 00 0f 00
	00		 lea	 eax, DWORD PTR [ebx+3840]
  00237	89 45 cc	 mov	 DWORD PTR tv956[ebp], eax
  0023a	50		 push	 eax
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 9991 : 
; 9992 : 	if ( lpObj->m_bPShopTransaction == true )

  00241	80 bb c5 0e 00
	00 01		 cmp	 BYTE PTR [ebx+3781], 1
  00248	75 41		 jne	 SHORT $LN16@CGPShopReq@8

; 9993 : 	{
; 9994 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Already Trade With Other",
; 9995 : 			gObj[aSourceIndex].AccountID, 
; 9996 : 			gObj[aSourceIndex].Name, 
; 9997 : 			lpObj->AccountID, 
; 9998 : 			lpObj->Name);

  0024a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024f	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  00252	51		 push	 ecx
  00253	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00256	51		 push	 ecx
  00257	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0025b	52		 push	 edx
  0025c	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00260	50		 push	 eax
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9999 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,4);

  0026c	6a 04		 push	 4
  0026e	6a 00		 push	 0
  00270	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00272	51		 push	 ecx
  00273	57		 push	 edi
  00274	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00279	83 c4 24	 add	 esp, 36			; 00000024H

; 10000: 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  0027c	8b 55 cc	 mov	 edx, DWORD PTR tv956[ebp]
  0027f	52		 push	 edx
  00280	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 10001: 	}
; 10002: 	else

  00286	e9 9e 05 00 00	 jmp	 $LN37@CGPShopReq@8
$LN16@CGPShopReq@8:

; 10003: 	{
; 10004: 		lpObj->m_bPShopTransaction = true;

  0028b	c6 83 c5 0e 00
	00 01		 mov	 BYTE PTR [ebx+3781], 1

; 10005: 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00292	8b 45 cc	 mov	 eax, DWORD PTR tv956[ebp]
  00295	50		 push	 eax
  00296	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 10006: 
; 10007: 		if ( gObjCheckSerial0ItemList(&lpObj->Inventory1[lpMsg->btItemPos]) != FALSE )

  0029c	8b 4d d0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0029f	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  002a3	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  002a9	03 93 34 0e 00
	00		 add	 edx, DWORD PTR [ebx+3636]
  002af	52		 push	 edx
  002b0	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  002b5	83 c4 04	 add	 esp, 4
  002b8	85 c0		 test	 eax, eax
  002ba	74 7a		 je	 SHORT $LN14@CGPShopReq@8

; 10008: 		{
; 10009: 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  002bc	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  002c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002c6	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  002cb	50		 push	 eax
  002cc	8b 03		 mov	 eax, DWORD PTR [ebx]
  002ce	50		 push	 eax
  002cf	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  002d4	83 c4 08	 add	 esp, 8

; 10010: 			GCReFillSend(aSourceIndex,gObj[aSourceIndex].Life, 0xFD, 1, gObj[aSourceIndex].iShield);

  002d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002dc	8b 8c 06 54 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+340]
  002e3	51		 push	 ecx
  002e4	6a 01		 push	 1
  002e6	68 fd 00 00 00	 push	 253			; 000000fdH
  002eb	d9 84 06 fc 00
	00 00		 fld	 DWORD PTR [esi+eax+252]
  002f2	e8 00 00 00 00	 call	 __ftol2_sse
  002f7	50		 push	 eax
  002f8	57		 push	 edi
  002f9	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  002fe	83 c4 14	 add	 esp, 20			; 00000014H

; 10011: 
; 10012: 			LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%d)",
; 10013: 				lpObj->AccountID, lpObj->Name, lpObj->Inventory1[lpMsg->btItemPos].GetName(),
; 10014: 				lpMsg->btItemPos);

  00301	8b 55 d0	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00304	0f b6 4a 10	 movzx	 ecx, BYTE PTR [edx+16]
  00308	51		 push	 ecx
  00309	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  0030f	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  00315	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0031a	50		 push	 eax
  0031b	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  0031e	50		 push	 eax
  0031f	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00322	53		 push	 ebx
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  00328	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0032e	83 c4 14	 add	 esp, 20			; 00000014H

; 10015: 			return;

  00331	e9 f3 04 00 00	 jmp	 $LN37@CGPShopReq@8
$LN14@CGPShopReq@8:

; 10016: 		}
; 10017: 
; 10018: 		if ( ::gObjInventorySearchSerialNumber(&gObj[aSourceIndex], lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  00336	8b 45 d0	 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  00339	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0033d	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00343	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  00349	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0034e	50		 push	 eax
  0034f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00355	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00358	52		 push	 edx
  00359	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0035e	83 c4 08	 add	 esp, 8
  00361	85 c0		 test	 eax, eax
  00363	75 53		 jne	 SHORT $LN13@CGPShopReq@8

; 10019: 		{
; 10020: 			::GCReFillSend(aSourceIndex, gObj[aSourceIndex].Life, -3, 1, gObj[aSourceIndex].iShield);

  00365	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036a	8b 8c 06 54 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax+340]
  00371	51		 push	 ecx
  00372	6a 01		 push	 1
  00374	68 fd 00 00 00	 push	 253			; 000000fdH
  00379	d9 84 06 fc 00
	00 00		 fld	 DWORD PTR [esi+eax+252]
  00380	e8 00 00 00 00	 call	 __ftol2_sse
  00385	50		 push	 eax
  00386	57		 push	 edi
  00387	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 10021: 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 10022: 				gObj[aSourceIndex].AccountID, 
; 10023: 				gObj[aSourceIndex].Name,
; 10024: 				__FILE__, 
; 10025: 				__LINE__);

  0038c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00391	68 29 27 00 00	 push	 10025			; 00002729H
  00396	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0039b	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0039f	52		 push	 edx
  003a0	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  003a4	50		 push	 eax
  003a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  003aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003b0	83 c4 28	 add	 esp, 40			; 00000028H

; 10026: 			return;

  003b3	e9 71 04 00 00	 jmp	 $LN37@CGPShopReq@8
$LN13@CGPShopReq@8:

; 10027: 		}
; 10028: 
; 10029: 		if ( ::gObjInventorySearchSerialNumber(lpObj, lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  003b8	8b 4d d0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  003bb	0f b6 49 10	 movzx	 ecx, BYTE PTR [ecx+16]
  003bf	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  003c5	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  003cb	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  003d0	50		 push	 eax
  003d1	53		 push	 ebx
  003d2	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  003d7	83 c4 08	 add	 esp, 8
  003da	85 c0		 test	 eax, eax
  003dc	75 47		 jne	 SHORT $LN12@CGPShopReq@8

; 10030: 		{
; 10031: 			GCReFillSend(lpObj->m_Index, lpObj->Life, -3, 1, lpObj->iShield);

  003de	8b 93 54 01 00
	00		 mov	 edx, DWORD PTR [ebx+340]
  003e4	52		 push	 edx
  003e5	6a 01		 push	 1
  003e7	68 fd 00 00 00	 push	 253			; 000000fdH
  003ec	d9 83 fc 00 00
	00		 fld	 DWORD PTR [ebx+252]
  003f2	e8 00 00 00 00	 call	 __ftol2_sse
  003f7	50		 push	 eax
  003f8	8b 03		 mov	 eax, DWORD PTR [ebx]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 10032: 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",
; 10033: 				lpObj->AccountID, 
; 10034: 				lpObj->Name,
; 10035: 				__FILE__, 
; 10036: 				__LINE__);

  00400	68 34 27 00 00	 push	 10036			; 00002734H
  00405	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0040a	8d 43 77	 lea	 eax, DWORD PTR [ebx+119]
  0040d	50		 push	 eax
  0040e	83 c3 6c	 add	 ebx, 108		; 0000006cH
  00411	53		 push	 ebx
  00412	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00417	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0041d	83 c4 28	 add	 esp, 40			; 00000028H

; 10037: 			return;

  00420	e9 04 04 00 00	 jmp	 $LN37@CGPShopReq@8
$LN12@CGPShopReq@8:

; 10038: 		}
; 10039: 
; 10040: 		if (gObjFixInventoryPointer(aSourceIndex) == false )

  00425	57		 push	 edi
  00426	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0042b	83 c4 04	 add	 esp, 4
  0042e	84 c0		 test	 al, al
  00430	75 18		 jne	 SHORT $LN11@CGPShopReq@8

; 10041: 		{
; 10042: 			LogAdd( "[Fix Inv.Ptr] False Location - %s, %d",
; 10043: 				__FILE__, 
; 10044: 				__LINE__);

  00432	68 3c 27 00 00	 push	 10044			; 0000273cH
  00437	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00441	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00447	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@CGPShopReq@8:

; 10045: 		}
; 10046: 
; 10047: 		if ( gObj[aSourceIndex].pTransaction == 1 )

  0044a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0044f	80 bc 06 30 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3632], 1
  00457	75 2e		 jne	 SHORT $LN10@CGPShopReq@8

; 10048: 		{
; 10049: 			LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Requester Transaction == 1, IF_TYPE : %d",
; 10050: 				gObj[aSourceIndex].AccountID, 
; 10051: 				gObj[aSourceIndex].Name, 
; 10052: 				gObj[aSourceIndex].m_IfState.type);

  00459	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00460	c1 e9 06	 shr	 ecx, 6
  00463	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00469	51		 push	 ecx
  0046a	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0046e	52		 push	 edx
  0046f	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00473	50		 push	 eax
  00474	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00479	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0047f	83 c4 10	 add	 esp, 16			; 00000010H

; 10053: 			return;

  00482	e9 a2 03 00 00	 jmp	 $LN37@CGPShopReq@8
$LN10@CGPShopReq@8:

; 10054: 		}
; 10055: 
; 10056: 		iITEM_LOG_TYPE=0;
; 10057: 		iITEM_LOG_LEVEL=0;
; 10058: 		iITEM_LOG_DUR=0;
; 10059: 		iITEM_LOG_SERIAL = 0;
; 10060: 
; 10061: 		__try

  00487	9b		 fwait
  00488	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 10062: 		{
; 10063: 			if ( PSHOP_RANGE(lpMsg->btItemPos) == FALSE )

  0048f	8b 4d d0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  00492	0f b6 49 10	 movzx	 ecx, BYTE PTR [ecx+16]
  00496	8d 81 34 ff ff
	ff		 lea	 eax, DWORD PTR [ecx-204]
  0049c	85 c0		 test	 eax, eax
  0049e	78 0e		 js	 SHORT $LN38@CGPShopReq@8
  004a0	33 d2		 xor	 edx, edx
  004a2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004a5	0f 9e c2	 setle	 dl
  004a8	8b c2		 mov	 eax, edx
  004aa	85 c0		 test	 eax, eax
  004ac	75 26		 jne	 SHORT $LN8@CGPShopReq@8
$LN38@CGPShopReq@8:

; 10064: 			{
; 10065: 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 5);

  004ae	6a 05		 push	 5
  004b0	6a 00		 push	 0
  004b2	8b 03		 mov	 eax, DWORD PTR [ebx]
  004b4	50		 push	 eax
  004b5	57		 push	 edi
  004b6	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 10066: 				return;

  004bb	6a fe		 push	 -2			; fffffffeH
  004bd	9b		 fwait
  004be	8d 4d f0	 lea	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  004c1	51		 push	 ecx
  004c2	68 00 00 00 00	 push	 OFFSET ___security_cookie
  004c7	e8 00 00 00 00	 call	 __local_unwind4
  004cc	83 c4 1c	 add	 esp, 28			; 0000001cH
  004cf	e9 55 03 00 00	 jmp	 $LN37@CGPShopReq@8
$LN8@CGPShopReq@8:

; 10067: 			}
; 10068: 
; 10069: 			if ( lpObj->m_bMapSvrMoveQuit == true )

  004d4	80 bb e4 1b 00
	00 01		 cmp	 BYTE PTR [ebx+7140], 1
  004db	75 25		 jne	 SHORT $LN7@CGPShopReq@8

; 10070: 			{
; 10071: 				CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  004dd	6a 02		 push	 2
  004df	6a 00		 push	 0
  004e1	6a ff		 push	 -1
  004e3	57		 push	 edi
  004e4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 10072: 				return;

  004e9	6a fe		 push	 -2			; fffffffeH
  004eb	9b		 fwait
  004ec	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  004ef	52		 push	 edx
  004f0	68 00 00 00 00	 push	 OFFSET ___security_cookie
  004f5	e8 00 00 00 00	 call	 __local_unwind4
  004fa	83 c4 1c	 add	 esp, 28			; 0000001cH
  004fd	e9 27 03 00 00	 jmp	 $LN37@CGPShopReq@8
$LN7@CGPShopReq@8:

; 10073: 			}
; 10074: 
; 10075: 			if ( lpObj->Inventory1[lpMsg->btItemPos].IsItem() == TRUE )

  00502	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00508	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  0050e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00513	83 f8 01	 cmp	 eax, 1
  00516	0f 85 a0 02 00
	00		 jne	 $LN1@CGPShopReq@8

; 10076: 			{
; 10077: 				if ( lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue <= 0 )

  0051c	8b 8b 34 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3636]
  00522	8b 45 d0	 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  00525	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  00529	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0052f	83 7c 0a 74 00	 cmp	 DWORD PTR [edx+ecx+116], 0
  00534	7f 48		 jg	 SHORT $LN5@CGPShopReq@8

; 10078: 				{
; 10079: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did Not Choose Item Price",
; 10080: 						gObj[aSourceIndex].AccountID, 
; 10081: 						gObj[aSourceIndex].Name, 
; 10082: 						lpObj->AccountID, 
; 10083: 						lpObj->Name);

  00536	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0053b	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  0053e	51		 push	 ecx
  0053f	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  00542	51		 push	 ecx
  00543	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00547	52		 push	 edx
  00548	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0054c	50		 push	 eax
  0054d	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00552	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 10084: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  00558	6a 06		 push	 6
  0055a	6a 00		 push	 0
  0055c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0055e	51		 push	 ecx
  0055f	57		 push	 edi
$LN48@CGPShopReq@8:
  00560	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 10085: 					return;

  00565	6a fe		 push	 -2			; fffffffeH
  00567	9b		 fwait
  00568	8d 55 f0	 lea	 edx, DWORD PTR __$SEHRec$[ebp+8]
  0056b	52		 push	 edx
  0056c	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00571	e8 00 00 00 00	 call	 __local_unwind4
  00576	83 c4 30	 add	 esp, 48			; 00000030H
  00579	e9 ab 02 00 00	 jmp	 $LN37@CGPShopReq@8
$LN5@CGPShopReq@8:

; 10086: 				}
; 10087: 
; 10088: 				DWORD dwCost = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  0057e	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00582	8b d0		 mov	 edx, eax
  00584	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  0058a	8b 4c 0a 74	 mov	 ecx, DWORD PTR [edx+ecx+116]
  0058e	89 4d cc	 mov	 DWORD PTR _dwCost$247856[ebp], ecx

; 10089: 
; 10090: #ifdef _OFFTRADE_
; 10091: 				if(!gOffTrade.CheckMoney(aSourceIndex, lpObj->m_Index, lpMsg->btItemPos))return;

  00591	50		 push	 eax
  00592	8b 13		 mov	 edx, DWORD PTR [ebx]
  00594	52		 push	 edx
  00595	57		 push	 edi
  00596	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  0059b	e8 00 00 00 00	 call	 ?CheckMoney@cOffTrade@@QAE_NHHH@Z ; cOffTrade::CheckMoney
  005a0	84 c0		 test	 al, al
  005a2	75 19		 jne	 SHORT $LN4@CGPShopReq@8
  005a4	6a fe		 push	 -2			; fffffffeH
  005a6	9b		 fwait
  005a7	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  005aa	50		 push	 eax
  005ab	68 00 00 00 00	 push	 OFFSET ___security_cookie
  005b0	e8 00 00 00 00	 call	 __local_unwind4
  005b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b8	e9 6c 02 00 00	 jmp	 $LN37@CGPShopReq@8
$LN4@CGPShopReq@8:

; 10092: #else
; 10093: 				if ( gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue )
; 10094: 				{
; 10095: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",
; 10096: 						gObj[aSourceIndex].AccountID, 
; 10097: 						gObj[aSourceIndex].Name, 
; 10098: 						lpObj->AccountID, 
; 10099: 						lpObj->Name);
; 10100: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);
; 10101: 					return;
; 10102: 				}
; 10103: 
; 10104: 				if ( gObjCheckMaxZen(lpObj->m_Index, dwCost) == FALSE )
; 10105: 				{
; 10106: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",
; 10107: 						gObj[aSourceIndex].AccountID, 
; 10108: 						gObj[aSourceIndex].Name, 
; 10109: 						lpObj->AccountID, 
; 10110: 						lpObj->Name);
; 10111: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);
; 10112: 					return;
; 10113: 				}
; 10114: 
; 10115: #endif
; 10116: 				
; 10117: 				BYTE btNewItemPos = 0;
; 10118: 				btNewItemPos = ::gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);

  005bd	8b 4d d0	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  005c0	0f b6 71 10	 movzx	 esi, BYTE PTR [ecx+16]
  005c4	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  005ca	03 b3 34 0e 00
	00		 add	 esi, DWORD PTR [ebx+3636]
  005d0	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  005d6	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  005db	8b fc		 mov	 edi, esp
  005dd	f3 a5		 rep movsd
  005df	8b 75 c4	 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  005e2	56		 push	 esi
  005e3	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  005e8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  005ee	88 45 d7	 mov	 BYTE PTR _btNewItemPos$247858[ebp], al

; 10119: 
; 10120: 				if ( btNewItemPos == 0xFF )

  005f1	3c ff		 cmp	 al, 255			; 000000ffH
  005f3	75 32		 jne	 SHORT $LN3@CGPShopReq@8

; 10121: 				{
; 10122: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",
; 10123: 						gObj[aSourceIndex].AccountID, 
; 10124: 						gObj[aSourceIndex].Name, 
; 10125: 						lpObj->AccountID, 
; 10126: 						lpObj->Name);

  005f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005fa	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  005fd	51		 push	 ecx
  005fe	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00601	52		 push	 edx
  00602	8b 4d c8	 mov	 ecx, DWORD PTR tv909[ebp]
  00605	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00609	52		 push	 edx
  0060a	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0060e	50		 push	 eax
  0060f	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00614	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 10127: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  0061a	6a 08		 push	 8
  0061c	6a 00		 push	 0
  0061e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00620	51		 push	 ecx
  00621	56		 push	 esi

; 10128: 					return;

  00622	e9 39 ff ff ff	 jmp	 $LN48@CGPShopReq@8
$LN3@CGPShopReq@8:

; 10129: 				}
; 10130: 				
; 10131: 				iITEM_LOG_TYPE = lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  00627	8b 7d d0	 mov	 edi, DWORD PTR _lpMsg$GSCopy$[ebp]
  0062a	0f b6 77 10	 movzx	 esi, BYTE PTR [edi+16]
  0062e	69 f6 d4 00 00
	00		 imul	 esi, 212		; 000000d4H
  00634	03 b3 34 0e 00
	00		 add	 esi, DWORD PTR [ebx+3636]
  0063a	0f bf 56 06	 movsx	 edx, WORD PTR [esi+6]
  0063e	89 55 c0	 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], edx

; 10132: 				iITEM_LOG_LEVEL = lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  00641	0f bf 46 08	 movsx	 eax, WORD PTR [esi+8]
  00645	89 45 b4	 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], eax

; 10133: 				iITEM_LOG_DUR = (int)lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  00648	d9 46 24	 fld	 DWORD PTR [esi+36]
  0064b	e8 00 00 00 00	 call	 __ftol2_sse
  00650	89 45 b8	 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], eax

; 10134: 				iITEM_LOG_SERIAL = lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  00653	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00655	89 4d d0	 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], ecx

; 10135: 
; 10136: 				::gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, -1);

  00658	68 ff 00 00 00	 push	 255			; 000000ffH
  0065d	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  00661	50		 push	 eax
  00662	8b 13		 mov	 edx, DWORD PTR [ebx]
  00664	52		 push	 edx
  00665	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  0066a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10137: 				lpObj->Inventory1[lpMsg->btItemPos].Clear();

  0066d	0f b6 4f 10	 movzx	 ecx, BYTE PTR [edi+16]
  00671	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00677	03 8b 34 0e 00
	00		 add	 ecx, DWORD PTR [ebx+3636]
  0067d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10138: 				::GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, TRUE);

  00682	6a 01		 push	 1
  00684	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  00688	50		 push	 eax
  00689	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0068b	51		 push	 ecx
  0068c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00691	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10139: 
; 10140: #ifdef _OFFTRADE_
; 10141: 				gOffTrade.ValueUpdate(aSourceIndex, lpObj->m_Index, dwCost);

  00694	8b 55 cc	 mov	 edx, DWORD PTR _dwCost$247856[ebp]
  00697	52		 push	 edx
  00698	8b 03		 mov	 eax, DWORD PTR [ebx]
  0069a	50		 push	 eax
  0069b	8b 75 c4	 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$[ebp]
  0069e	56		 push	 esi
  0069f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  006a4	e8 00 00 00 00	 call	 ?ValueUpdate@cOffTrade@@QAEXHHH@Z ; cOffTrade::ValueUpdate

; 10142: #else
; 10143: 				gObj[aSourceIndex].Money -= dwCost;
; 10144: 				lpObj->Money += dwCost;
; 10145: 				::GCMoneySend(aSourceIndex, gObj[aSourceIndex].Money);
; 10146: 				::GCMoneySend(lpObj->m_Index, lpObj->Money);
; 10147: #endif
; 10148: 
; 10149: 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  006a9	6a 01		 push	 1
  006ab	0f b6 4d d7	 movzx	 ecx, BYTE PTR _btNewItemPos$247858[ebp]
  006af	51		 push	 ecx
  006b0	8b 13		 mov	 edx, DWORD PTR [ebx]
  006b2	52		 push	 edx
  006b3	56		 push	 esi
  006b4	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 10150: 				::CGPShopAnsSoldItem(lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  006b9	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  006bd	50		 push	 eax
  006be	56		 push	 esi
  006bf	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  006c1	51		 push	 ecx
  006c2	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem

; 10151: 
; 10152: 				GDUserItemSave(lpObj);	//OffTrade

  006c7	53		 push	 ebx
  006c8	e8 00 00 00 00	 call	 ?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ; GDUserItemSave

; 10153: #ifndef FIX_DS_CRASH
; 10154: 				GJSetCharacterInfo(lpObj, lpObj->m_Index, 0);	//OffTrade
; 10155: 				GJSetCharacterInfo(lpObj, aSourceIndex, 0);	//OffTrade
; 10156: #endif
; 10157: 
; 10158: 				LogAddTD("[PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%u", 
; 10159: 					gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].Ip_addr, lpObj->AccountID, lpObj->Name, lpObj->Ip_addr, dwCost, 
; 10160: 					iITEM_LOG_TYPE, ItemAttribute[iITEM_LOG_TYPE].Name, iITEM_LOG_LEVEL, iITEM_LOG_DUR, iITEM_LOG_SERIAL);

  006cd	8d 73 6c	 lea	 esi, DWORD PTR [ebx+108]
  006d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006d5	8b 55 d0	 mov	 edx, DWORD PTR _iITEM_LOG_SERIAL$[ebp]
  006d8	52		 push	 edx
  006d9	8b 4d b8	 mov	 ecx, DWORD PTR _iITEM_LOG_DUR$[ebp]
  006dc	51		 push	 ecx
  006dd	8b 55 b4	 mov	 edx, DWORD PTR _iITEM_LOG_LEVEL$[ebp]
  006e0	52		 push	 edx
  006e1	8b 4d c0	 mov	 ecx, DWORD PTR _iITEM_LOG_TYPE$[ebp]
  006e4	8b d1		 mov	 edx, ecx
  006e6	6b d2 70	 imul	 edx, 112		; 00000070H
  006e9	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  006ef	52		 push	 edx
  006f0	51		 push	 ecx
  006f1	8b 4d cc	 mov	 ecx, DWORD PTR _dwCost$247856[ebp]
  006f4	51		 push	 ecx
  006f5	8d 53 18	 lea	 edx, DWORD PTR [ebx+24]
  006f8	52		 push	 edx
  006f9	8d 7b 77	 lea	 edi, DWORD PTR [ebx+119]
  006fc	57		 push	 edi
  006fd	56		 push	 esi
  006fe	8b 4d c8	 mov	 ecx, DWORD PTR tv909[ebp]
  00701	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00705	52		 push	 edx
  00706	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0070a	52		 push	 edx
  0070b	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0070f	50		 push	 eax
  00710	68 00 00 00 00	 push	 OFFSET ??_C@_0IE@IMPNINKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
  00715	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0071b	83 c4 54	 add	 esp, 84			; 00000054H

; 10161: 
; 10162: 				if (PShop_CheckInventoryEmpty(lpObj->m_Index) == true )

  0071e	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
  00721	51		 push	 ecx
  00722	e8 00 00 00 00	 call	 ?PShop_CheckInventoryEmpty@@YA_NF@Z ; PShop_CheckInventoryEmpty
  00727	83 c4 04	 add	 esp, 4
  0072a	3c 01		 cmp	 al, 1
  0072c	0f 85 83 00 00
	00		 jne	 $LN2@CGPShopReq@8

; 10163: 				{
; 10164: 					LogAddTD("[PShop] [%s][%s] Sold All Items - Auto Closing PShop",
; 10165: 						lpObj->AccountID, lpObj->Name);

  00732	57		 push	 edi
  00733	56		 push	 esi
  00734	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
  00739	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0073f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10166: 					::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 195)), lpObj->m_Index, 1);

  00742	6a 01		 push	 1
  00744	8b 13		 mov	 edx, DWORD PTR [ebx]
  00746	52		 push	 edx
  00747	68 c3 04 00 00	 push	 1219			; 000004c3H
  0074c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00751	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00756	50		 push	 eax
  00757	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 10167: 					lpObj->m_bPShopOpen = false;

  0075c	c6 83 c4 0e 00
	00 00		 mov	 BYTE PTR [ebx+3780], 0

; 10168: 					memset(lpObj->m_szPShopText, 0, sizeof(lpObj->m_szPShopText));

  00763	33 c0		 xor	 eax, eax
  00765	89 83 c8 0e 00
	00		 mov	 DWORD PTR [ebx+3784], eax
  0076b	89 83 cc 0e 00
	00		 mov	 DWORD PTR [ebx+3788], eax
  00771	89 83 d0 0e 00
	00		 mov	 DWORD PTR [ebx+3792], eax
  00777	89 83 d4 0e 00
	00		 mov	 DWORD PTR [ebx+3796], eax
  0077d	89 83 d8 0e 00
	00		 mov	 DWORD PTR [ebx+3800], eax
  00783	89 83 dc 0e 00
	00		 mov	 DWORD PTR [ebx+3804], eax
  00789	89 83 e0 0e 00
	00		 mov	 DWORD PTR [ebx+3808], eax
  0078f	89 83 e4 0e 00
	00		 mov	 DWORD PTR [ebx+3812], eax
  00795	89 83 e8 0e 00
	00		 mov	 DWORD PTR [ebx+3816], eax

; 10169: 					::CGPShopAnsClose(lpObj->m_Index, 1);

  0079b	6a 01		 push	 1
  0079d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0079f	50		 push	 eax
  007a0	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  007a5	83 c4 14	 add	 esp, 20			; 00000014H

; 10170: #ifdef _OFFTRADE_
; 10171: 					gOffTrade.UserOnlineOffSell(lpObj);

  007a8	53		 push	 ebx
  007a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gOffTrade@@3VcOffTrade@@A ; gOffTrade
  007ae	e8 00 00 00 00	 call	 ?UserOnlineOffSell@cOffTrade@@QAEXPAUOBJECTSTRUCT@@@Z ; cOffTrade::UserOnlineOffSell

; 10172: #endif
; 10173: 				}
; 10174: 				else

  007b3	eb 07		 jmp	 SHORT $LN1@CGPShopReq@8
$LN2@CGPShopReq@8:

; 10175: 				{
; 10176: 					lpObj->m_bPShopItemChange = true;

  007b5	c6 83 c6 0e 00
	00 01		 mov	 BYTE PTR [ebx+3782], 1
$LN1@CGPShopReq@8:

; 10177: 				}
; 10178: 
; 10179: 			}
; 10180: 		}
; 10181: 		__finally

  007bc	9b		 fwait
  007bd	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  007c4	e8 05 00 00 00	 call	 $LN36@CGPShopReq@8
  007c9	eb 5e		 jmp	 SHORT $LN37@CGPShopReq@8
$LN34@CGPShopReq@8:
$LN49@CGPShopReq@8:
  007cb	8b 5d bc	 mov	 ebx, DWORD PTR _lpObj$[ebp]
$LN36@CGPShopReq@8:

; 10182: 		{
; 10183: 			lpObj->m_bPShopTransaction = false;

  007ce	c6 83 c5 0e 00
	00 00		 mov	 BYTE PTR [ebx+3781], 0
$LN35@CGPShopReq@8:
$LN44@CGPShopReq@8:
  007d5	c3		 ret	 0
$LN17@CGPShopReq@8:

; 9980 : 	{
; 9981 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 9982 : 			gObj[aSourceIndex].AccountID, 
; 9983 : 			gObj[aSourceIndex].Name, 
; 9984 : 			lpObj->AccountID, 
; 9985 : 			lpObj->Name);

  007d6	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  007d9	51		 push	 ecx
  007da	8d 4b 6c	 lea	 ecx, DWORD PTR [ebx+108]
  007dd	51		 push	 ecx
  007de	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  007e2	52		 push	 edx
  007e3	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  007e7	50		 push	 eax
  007e8	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  007ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9986 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  007f3	6a 09		 push	 9
  007f5	6a 00		 push	 0
  007f7	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  007f9	51		 push	 ecx

; 9987 : 		return;

  007fa	eb 24		 jmp	 SHORT $LN46@CGPShopReq@8
$LN19@CGPShopReq@8:

; 9969 : 	{
; 9970 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 9971 : 			gObj[aSourceIndex].AccountID, 
; 9972 : 			gObj[aSourceIndex].Name, 
; 9973 : 			lpObj->AccountID, 
; 9974 : 			lpObj->Name);

  007fc	8d 4b 77	 lea	 ecx, DWORD PTR [ebx+119]
  007ff	51		 push	 ecx
  00800	8d 53 6c	 lea	 edx, DWORD PTR [ebx+108]
  00803	52		 push	 edx
  00804	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00808	51		 push	 ecx
  00809	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0080d	52		 push	 edx
  0080e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00813	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9975 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  00819	6a 09		 push	 9
$LN45@CGPShopReq@8:
  0081b	6a 00		 push	 0
  0081d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0081f	50		 push	 eax
$LN46@CGPShopReq@8:
  00820	57		 push	 edi
  00821	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00826	83 c4 24	 add	 esp, 36			; 00000024H
$LN37@CGPShopReq@8:

; 10184: 		}
; 10185: 	}
; 10186: }

  00829	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0082c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00833	59		 pop	 ecx
  00834	5f		 pop	 edi
  00835	5e		 pop	 esi
  00836	5b		 pop	 ebx
  00837	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0083a	33 cd		 xor	 ecx, ebp
  0083c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00841	8b e5		 mov	 esp, ebp
  00843	5d		 pop	 ebp
  00844	c3		 ret	 0
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyItem
_TEXT	ENDS
PUBLIC	??_C@_0EP@LJAEGDAD@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIre@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
EXTRN	?Paint@PartyClass@@QAEXH@Z:PROC			; PartyClass::Paint
EXTRN	?Add@PartyClass@@QAEHHHHH@Z:PROC		; PartyClass::Add
EXTRN	?Create@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::Create
;	COMDAT ??_C@_0EP@LJAEGDAD@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIre@
CONST	SEGMENT
??_C@_0EP@LJAEGDAD@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIre@ DB '[HA'
	DB	'CKTOOL] : NPC-TradeRequest(result) npc:%d ip:%s account:%s na'
	DB	'me:%s State:%d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -280					; size = 4
_number$ = -276						; size = 4
_pnumber$ = -272					; size = 4
_aIndex$GSCopy$ = -268					; size = 4
_result$ = -261						; size = 1
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z PROC ; CGPartyRequestResultRecv, COMDAT

; 10395: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10396: 	int number;
; 10397: 	BYTE result = false;
; 10398: 	char szTemp[256];
; 10399: 	int pnumber = -1;
; 10400: 
; 10401: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001c	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  00022	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00028	57		 push	 edi
  00029	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002f	51		 push	 ecx

; 10516: 			{
; 10517: 				GCResultSend(number, 0x41, 2);

  00030	89 bd e8 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], edi
  00036	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  0003d	c7 85 f0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _pnumber$[ebp], -1
  00047	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0004c	83 c4 04	 add	 esp, 4
  0004f	85 c0		 test	 eax, eax
  00051	0f 84 7b 04 00
	00		 je	 $LN27@CGPartyReq@2

; 10402: 	{
; 10403: 		return;
; 10404: 	}
; 10405: 
; 10406: 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00057	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  0005b	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0005f	66 c1 e2 08	 shl	 dx, 8
  00063	53		 push	 ebx
  00064	0f b7 da	 movzx	 ebx, dx
  00067	0b d8		 or	 ebx, eax
  00069	89 9d ec fe ff
	ff		 mov	 DWORD PTR _number$[ebp], ebx

; 10407: 
; 10408: 	if ( number < 0 || number > OBJMAX-1)

  0006f	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00075	0f 87 56 04 00
	00		 ja	 $LN47@CGPartyReq@2

; 10409: 	{
; 10410: 		return;
; 10411: 	}
; 10412: 
; 10413: 	if ( !gObjIsConnected(&gObj[aIndex]))

  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00081	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0008a	83 c4 04	 add	 esp, 4
  0008d	85 c0		 test	 eax, eax
  0008f	0f 84 3c 04 00
	00		 je	 $LN47@CGPartyReq@2

; 10414: 	{
; 10415: 		return;
; 10416: 	}
; 10417: 
; 10418: 	if ( !gObjIsConnected(&gObj[number]))

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	8b fb		 mov	 edi, ebx
  0009c	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  000a2	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000ab	83 c4 04	 add	 esp, 4
  000ae	85 c0		 test	 eax, eax
  000b0	75 15		 jne	 SHORT $LN25@CGPartyReq@2

; 10419: 	{
; 10420: 		GCResultSend(aIndex, 0x41, 0x04);

  000b2	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  000b8	6a 04		 push	 4
  000ba	6a 41		 push	 65			; 00000041H
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10421: 	}
; 10422: 	else

  000c5	eb 07		 jmp	 SHORT $LN24@CGPartyReq@2
$LN25@CGPartyReq@2:

; 10423: 	{
; 10424: 		result = true;

  000c7	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _result$[ebp], 1
$LN24@CGPartyReq@2:

; 10425: 	}
; 10426: 
; 10427: 	if( gObj[number].Type != OBJ_USER ) //season4 add-on

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	66 83 7c 07 68
	01		 cmp	 WORD PTR [edi+eax+104], 1
  000d9	74 4a		 je	 SHORT $LN23@CGPartyReq@2

; 10428: 	{
; 10429: 		LogAddC(2,"[HACKTOOL] : NPC-TradeRequest(result) npc:%d ip:%s account:%s name:%s State:%d",
; 10430: 			gObj[number].Class,gObj[aIndex].Ip_addr,gObj[aIndex].AccountID,
; 10431: 			gObj[aIndex].Name,gObj[aIndex].Connected);

  000db	8b 4c 06 04	 mov	 ecx, DWORD PTR [esi+eax+4]
  000df	51		 push	 ecx
  000e0	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000e4	52		 push	 edx
  000e5	8d 4c 06 6c	 lea	 ecx, DWORD PTR [esi+eax+108]
  000e9	51		 push	 ecx
  000ea	8d 54 06 18	 lea	 edx, DWORD PTR [esi+eax+24]
  000ee	0f b7 84 07 b8
	00 00 00	 movzx	 eax, WORD PTR [edi+eax+184]
  000f6	52		 push	 edx
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@LJAEGDAD@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIre@
  000fd	6a 02		 push	 2
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 10432: 		CloseClient(aIndex);

  00105	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00111	83 c4 20	 add	 esp, 32			; 00000020H
  00114	5b		 pop	 ebx
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi

; 10544: 	}
; 10545: }

  00117	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011a	33 cd		 xor	 ecx, ebp
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
$LN23@CGPartyReq@2:

; 10433: 		return;
; 10434: 	}
; 10435: 
; 10436: 	if ( gObj[number].MapNumber != gObj[aIndex].MapNumber )

  00125	8a 94 07 49 01
	00 00		 mov	 dl, BYTE PTR [edi+eax+329]
  0012c	3a 94 06 49 01
	00 00		 cmp	 dl, BYTE PTR [esi+eax+329]
  00133	74 19		 je	 SHORT $LN22@CGPartyReq@2

; 10437: 	{
; 10438: 		result = false;
; 10439: 		GCResultSend(number, 0x41, 0x00);

  00135	6a 00		 push	 0
  00137	6a 41		 push	 65			; 00000041H
  00139	53		 push	 ebx
  0013a	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  00141	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00146	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@CGPartyReq@2:

; 10440: 	}	
; 10441: 
; 10442: 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  0014e	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00156	80 f9 35	 cmp	 cl, 53			; 00000035H
  00159	74 0e		 je	 SHORT $LN38@CGPartyReq@2
  0015b	80 f9 12	 cmp	 cl, 18			; 00000012H
  0015e	72 40		 jb	 SHORT $LN41@CGPartyReq@2
  00160	b2 17		 mov	 dl, 23			; 00000017H
  00162	3a d1		 cmp	 dl, cl
  00164	1b c9		 sbb	 ecx, ecx
  00166	41		 inc	 ecx
  00167	74 37		 je	 SHORT $LN41@CGPartyReq@2
$LN38@CGPartyReq@2:

; 10443: 	{
; 10444: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), aIndex, 1);

  00169	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0016f	6a 01		 push	 1
  00171	50		 push	 eax
  00172	68 c6 04 00 00	 push	 1222			; 000004c6H
  00177	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0017c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 10445: 		result = false;
; 10446: 		::GCResultSend(number, 0x41, 0x00);

  00187	6a 00		 push	 0
  00189	6a 41		 push	 65			; 00000041H
  0018b	53		 push	 ebx
  0018c	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  00193	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019d	83 c4 18	 add	 esp, 24			; 00000018H
$LN41@CGPartyReq@2:

; 10447: 	}
; 10448: 
; 10449: 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) ) //season 2.5 add-on

  001a0	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  001a8	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  001ab	72 22		 jb	 SHORT $LN43@CGPartyReq@2
  001ad	b2 32		 mov	 dl, 50			; 00000032H
  001af	3a d1		 cmp	 dl, cl
  001b1	1b c9		 sbb	 ecx, ecx
  001b3	41		 inc	 ecx
  001b4	74 19		 je	 SHORT $LN43@CGPartyReq@2

; 10450: 	{
; 10451: 		result = false;
; 10452: 		::GCResultSend(number, 0x41, 0x00);

  001b6	6a 00		 push	 0
  001b8	6a 41		 push	 65			; 00000041H
  001ba	53		 push	 ebx
  001bb	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  001c2	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@CGPartyReq@2:

; 10453: 	}
; 10454: 
; 10455: 	if ( lpMsg->Result == 0 )

  001cf	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$[ebp]
  001d5	80 79 03 00	 cmp	 BYTE PTR [ecx+3], 0
  001d9	75 19		 jne	 SHORT $LN19@CGPartyReq@2

; 10456: 	{
; 10457: 		result = false;
; 10458: 		::GCResultSend(number, 0x41, 0x01);

  001db	6a 01		 push	 1
  001dd	6a 41		 push	 65			; 00000041H
  001df	53		 push	 ebx
  001e0	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  001e7	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@CGPartyReq@2:

; 10459: 	}
; 10460: 
; 10461: 	if ( gObj[number].m_IfState.use == 0 || gObj[number].m_IfState.type != 2)

  001f4	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  001fb	f6 c1 03	 test	 cl, 3
  001fe	74 0e		 je	 SHORT $LN17@CGPartyReq@2
  00200	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00206	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0020c	74 19		 je	 SHORT $LN18@CGPartyReq@2
$LN17@CGPartyReq@2:

; 10462: 	{
; 10463: 		result = false;
; 10464: 		::GCResultSend(number, 0x41, 0x00);

  0020e	6a 00		 push	 0
  00210	6a 41		 push	 65			; 00000041H
  00212	53		 push	 ebx
  00213	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  0021a	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGPartyReq@2:

; 10465: 	}	
; 10466: 	
; 10467: 	if ( gObj[aIndex].m_IfState.use == 0 || gObj[aIndex].m_IfState.type != 2)

  00227	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  0022e	f6 c1 03	 test	 cl, 3
  00231	74 0e		 je	 SHORT $LN15@CGPartyReq@2
  00233	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00239	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0023f	74 19		 je	 SHORT $LN16@CGPartyReq@2
$LN15@CGPartyReq@2:

; 10468: 	{
; 10469: 		result = false;
; 10470: 		::GCResultSend(number, 0x41, 0x00);

  00241	6a 00		 push	 0
  00243	6a 41		 push	 65			; 00000041H
  00245	53		 push	 ebx
  00246	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$[ebp], 0
  0024d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00252	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00257	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CGPartyReq@2:

; 10471: 	}
; 10472: 
; 10473: 	if(gGENS)

  0025a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  00261	74 5f		 je	 SHORT $LN12@CGPartyReq@2

; 10474: 	{
; 10475: 		if( gGensSystem.CheckPartyEnter )

  00263	80 3d ae 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VGensSystem@@A+174, 0
  0026a	74 56		 je	 SHORT $LN12@CGPartyReq@2

; 10476: 		{
; 10477: 			if( gGensSystem.GetGensInfluence(&gObj[aIndex]) != gGensSystem.GetGensInfluence(&gObj[number]) )

  0026c	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  0026f	52		 push	 edx
  00270	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  00275	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  0027a	8b d8		 mov	 ebx, eax
  0027c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00281	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00284	51		 push	 ecx
  00285	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VGensSystem@@A ; gGensSystem
  0028a	e8 00 00 00 00	 call	 ?GetGensInfluence@GensSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; GensSystem::GetGensInfluence
  0028f	3b c3		 cmp	 eax, ebx
  00291	74 24		 je	 SHORT $LN39@CGPartyReq@2

; 10478: 			{
; 10479: 				::GCResultSend(aIndex, 0x41, 0x06);

  00293	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00299	6a 06		 push	 6
  0029b	6a 41		 push	 65			; 00000041H
  0029d	52		 push	 edx
  0029e	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a6	5b		 pop	 ebx
  002a7	5f		 pop	 edi
  002a8	5e		 pop	 esi

; 10544: 	}
; 10545: }

  002a9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ac	33 cd		 xor	 ecx, ebp
  002ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
$LN39@CGPartyReq@2:

; 10480: 				return;

  002b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bc	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _number$[ebp]
$LN12@CGPartyReq@2:

; 10481: 			}
; 10482: 		}
; 10483: 		// ----
; 10484: 		//-> Allow party on battle maps
; 10485: 		/*if( gGensSystem.IsMapBattleZone(gObj[aIndex].MapNumber) )
; 10486: 		{
; 10487: 			::GCResultSend(aIndex, 0x41, 0x07);
; 10488: 			return;
; 10489: 		}*/
; 10490: 	}
; 10491: 
; 10492: 	if ( result == 1 )

  002c2	80 bd fb fe ff
	ff 01		 cmp	 BYTE PTR _result$[ebp], 1
  002c9	0f 85 82 01 00
	00		 jne	 $LN44@CGPartyReq@2

; 10493: 	{
; 10494: 		if ( gObj[number].PartyNumber < 0 )

  002cf	83 bc 07 2c 04
	00 00 00	 cmp	 DWORD PTR [edi+eax+1068], 0
  002d7	7d 39		 jge	 SHORT $LN49@CGPartyReq@2

; 10495: 		{
; 10496: 			gObj[number].PartyNumber = gParty.Create(number, gObj[number].DBNumber, gObj[number].Level);

  002d9	0f bf 8c 07 be
	00 00 00	 movsx	 ecx, WORD PTR [edi+eax+190]
  002e1	8b 54 07 2c	 mov	 edx, DWORD PTR [edi+eax+44]
  002e5	51		 push	 ecx
  002e6	52		 push	 edx
  002e7	53		 push	 ebx
  002e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002ed	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  002f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f8	89 84 0f 2c 04
	00 00		 mov	 DWORD PTR [edi+ecx+1068], eax
  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10497: 		}
; 10498: 
; 10499: 		if ( gObj[number].PartyNumber >= 0  )

  00304	83 bc 07 2c 04
	00 00 00	 cmp	 DWORD PTR [edi+eax+1068], 0
  0030c	0f 8c 3f 01 00
	00		 jl	 $LN44@CGPartyReq@2
$LN49@CGPartyReq@2:

; 10500: 		{
; 10501: 			pnumber = gObj[number].PartyNumber;
; 10502: 			int iPartyPos = gParty.Add(gObj[number].PartyNumber, aIndex, gObj[aIndex].DBNumber, gObj[aIndex].Level);

  00312	0f bf 94 06 be
	00 00 00	 movsx	 edx, WORD PTR [esi+eax+190]
  0031a	8b 8c 07 2c 04
	00 00		 mov	 ecx, DWORD PTR [edi+eax+1068]
  00321	8b 44 06 2c	 mov	 eax, DWORD PTR [esi+eax+44]
  00325	52		 push	 edx
  00326	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0032c	50		 push	 eax
  0032d	52		 push	 edx
  0032e	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _pnumber$[ebp], ecx
  00334	51		 push	 ecx
  00335	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0033a	e8 00 00 00 00	 call	 ?Add@PartyClass@@QAEHHHHH@Z ; PartyClass::Add

; 10503: 
; 10504: 			if ( iPartyPos >= 0 )

  0033f	85 c0		 test	 eax, eax
  00341	0f 88 9f 00 00
	00		 js	 $LN8@CGPartyReq@2

; 10505: 			{
; 10506: 				gObj[aIndex].PartyNumber = gObj[number].PartyNumber;

  00347	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034c	8b 8c 07 2c 04
	00 00		 mov	 ecx, DWORD PTR [edi+eax+1068]
  00353	89 8c 06 2c 04
	00 00		 mov	 DWORD PTR [esi+eax+1068], ecx

; 10507: 				result = true;
; 10508: 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[aIndex].Name);

  0035a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00360	8d 44 16 77	 lea	 eax, DWORD PTR [esi+edx+119]
  00364	50		 push	 eax
  00365	68 53 04 00 00	 push	 1107			; 00000453H
  0036a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0036f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00374	50		 push	 eax
  00375	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0037b	51		 push	 ecx
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 10509: 				::GCServerMsgStringSend(szTemp, number, 1);

  00382	6a 01		 push	 1
  00384	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  0038a	53		 push	 ebx
  0038b	52		 push	 edx
  0038c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 10510: 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[number].Name);

  00391	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00396	83 c4 18	 add	 esp, 24			; 00000018H
  00399	8d 4c 07 77	 lea	 ecx, DWORD PTR [edi+eax+119]
  0039d	51		 push	 ecx
  0039e	68 53 04 00 00	 push	 1107			; 00000453H
  003a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003a8	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003ad	50		 push	 eax
  003ae	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  003b4	52		 push	 edx
  003b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 10511: 				::GCServerMsgStringSend(szTemp, aIndex, 1);

  003bb	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  003c1	6a 01		 push	 1
  003c3	50		 push	 eax
  003c4	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  003ca	51		 push	 ecx
  003cb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 10512: 
; 10513: 				gParty.Paint(pnumber);

  003d0	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _pnumber$[ebp]
  003d6	83 c4 18	 add	 esp, 24			; 00000018H
  003d9	52		 push	 edx
  003da	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  003df	e8 00 00 00 00	 call	 ?Paint@PartyClass@@QAEXH@Z ; PartyClass::Paint
  003e4	eb 66		 jmp	 SHORT $LN40@CGPartyReq@2
$LN8@CGPartyReq@2:

; 10514: 			}
; 10515: 			else if ( iPartyPos == -1 )

  003e6	83 f8 ff	 cmp	 eax, -1
  003e9	75 1c		 jne	 SHORT $LN6@CGPartyReq@2

; 10516: 			{
; 10517: 				GCResultSend(number, 0x41, 2);

  003eb	6a 02		 push	 2
  003ed	6a 41		 push	 65			; 00000041H
  003ef	53		 push	 ebx
  003f0	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 10518: 				GCResultSend(aIndex, 0x41, 2);

  003f5	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  003fb	6a 02		 push	 2
  003fd	6a 41		 push	 65			; 00000041H
  003ff	50		 push	 eax
  00400	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00405	eb 42		 jmp	 SHORT $LN50@CGPartyReq@2
$LN6@CGPartyReq@2:

; 10519: 			}
; 10520: 			else if ( iPartyPos == -2 )

  00407	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0040a	75 40		 jne	 SHORT $LN40@CGPartyReq@2

; 10521: 			{
; 10522: 				result = 2;
; 10523: 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 84)), gObj[aIndex].Name);

  0040c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00412	8d 54 0e 77	 lea	 edx, DWORD PTR [esi+ecx+119]
  00416	52		 push	 edx
  00417	68 54 04 00 00	 push	 1108			; 00000454H
  0041c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00421	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00426	50		 push	 eax
  00427	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0042d	50		 push	 eax
  0042e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 10524: 				GCServerMsgStringSend(szTemp, aIndex, 1);

  00434	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0043a	6a 01		 push	 1
  0043c	51		 push	 ecx
  0043d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00443	52		 push	 edx
  00444	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
$LN50@CGPartyReq@2:
  00449	83 c4 18	 add	 esp, 24			; 00000018H
$LN40@CGPartyReq@2:
  0044c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN44@CGPartyReq@2:

; 10525: 			}
; 10526: 		}
; 10527: 	}
; 10528: 
; 10529: 	if ( gObj[aIndex].m_IfState.use !=  0 && gObj[aIndex].m_IfState.type == 2)

  00451	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  00458	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  0045d	f6 c1 03	 test	 cl, 3
  00460	74 2a		 je	 SHORT $LN45@CGPartyReq@2
  00462	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00468	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0046e	75 1c		 jne	 SHORT $LN45@CGPartyReq@2

; 10530: 	{
; 10531: 		gObj[aIndex].m_IfState.use = 0;

  00470	21 94 06 1c 0e
	00 00		 and	 DWORD PTR [esi+eax+3612], edx

; 10532: 		gObj[aIndex].PartyTargetUser = -1;

  00477	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047c	c7 84 06 30 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+eax+1072], -1
  00487	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN45@CGPartyReq@2:

; 10533: 	}
; 10534: 
; 10535: 	if ( gObj[number].m_IfState.use !=  0 && gObj[number].m_IfState.type == 2)

  0048c	8b 8c 07 1c 0e
	00 00		 mov	 ecx, DWORD PTR [edi+eax+3612]
  00493	f6 c1 03	 test	 cl, 3
  00496	74 26		 je	 SHORT $LN2@CGPartyReq@2
  00498	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  0049e	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  004a4	75 18		 jne	 SHORT $LN2@CGPartyReq@2

; 10536: 	{
; 10537: 		gObj[number].m_IfState.use = 0;

  004a6	21 94 07 1c 0e
	00 00		 and	 DWORD PTR [edi+eax+3612], edx

; 10538: 		gObj[number].PartyTargetUser = -1;

  004ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b3	c7 84 0f 30 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edi+ecx+1072], -1
$LN2@CGPartyReq@2:

; 10539: 	}
; 10540: 
; 10541: 	if ( pnumber >= 0 )

  004be	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pnumber$[ebp]
  004c4	85 c0		 test	 eax, eax
  004c6	78 09		 js	 SHORT $LN47@CGPartyReq@2

; 10542: 	{
; 10543: 		CGPartyListAll(pnumber);

  004c8	50		 push	 eax
  004c9	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  004ce	83 c4 04	 add	 esp, 4
$LN47@CGPartyReq@2:
  004d1	5b		 pop	 ebx
$LN27@CGPartyReq@2:

; 10544: 	}
; 10545: }

  004d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d5	5f		 pop	 edi
  004d6	33 cd		 xor	 ecx, ebp
  004d8	5e		 pop	 esi
  004d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004de	8b e5		 mov	 esp, ebp
  004e0	5d		 pop	 ebp
  004e1	c3		 ret	 0
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ENDP ; CGPartyRequestResultRecv
_TEXT	ENDS
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0P@GAPFACKC@User?5Not?5found?$AA@		; `string'
PUBLIC	??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z	; CGPartyDelUser
EXTRN	?Destroy@PartyClass@@QAEHH@Z:PROC		; PartyClass::Destroy
EXTRN	?ResetPkLevel@PartyClass@@QAEXH@Z:PROC		; PartyClass::ResetPkLevel
EXTRN	?ChangeLeader@PartyClass@@QAEXH@Z:PROC		; PartyClass::ChangeLeader
EXTRN	?SetPkCount@PartyClass@@QAEXH@Z:PROC		; PartyClass::SetPkCount
EXTRN	?Delete@PartyClass@@QAEXHH@Z:PROC		; PartyClass::Delete
EXTRN	?GetIndexUser@PartyClass@@QAEHHHAAH0@Z:PROC	; PartyClass::GetIndexUser
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@ DB '%s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAPFACKC@User?5Not?5found?$AA@
CONST	SEGMENT
??_C@_0P@GAPFACKC@User?5Not?5found?$AA@ DB 'User Not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@ DB 'No Party %s %s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z
_TEXT	SEGMENT
_dbnumber$ = -8						; size = 4
_usernumber$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
tv455 = 12						; size = 4
_count$ = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z PROC	; CGPartyDelUser, COMDAT

; 10707: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 10708: 	int usernumber = -1; //loc1
; 10709: 	int dbnumber = -1; //loc2
; 10710: 
; 10711: 	if ( gObj[aIndex].PartyNumber < 0 )

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	53		 push	 ebx
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00011	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00017	83 cb ff	 or	 ebx, -1
  0001a	89 5d fc	 mov	 DWORD PTR _usernumber$[ebp], ebx
  0001d	89 5d f8	 mov	 DWORD PTR _dbnumber$[ebp], ebx
  00020	8b 84 0f 2c 04
	00 00		 mov	 eax, DWORD PTR [edi+ecx+1068]
  00027	85 c0		 test	 eax, eax
  00029	79 1e		 jns	 SHORT $LN19@CGPartyDel

; 10712: 	{
; 10713: 		LogAdd("No Party %s %s", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0002b	8d 44 0f 77	 lea	 eax, DWORD PTR [edi+ecx+119]
  0002f	50		 push	 eax
  00030	8d 4c 0f 6c	 lea	 ecx, DWORD PTR [edi+ecx+108]
  00034	51		 push	 ecx
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN19@CGPartyDel:

; 10714: 		return;
; 10715: 	}
; 10716: 
; 10717: 	if ( !gParty.GetIndexUser(gObj[aIndex].PartyNumber, lpMsg->Number, usernumber, dbnumber))

  00049	8d 55 f8	 lea	 edx, DWORD PTR _dbnumber$[ebp]
  0004c	52		 push	 edx
  0004d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00050	8d 4d fc	 lea	 ecx, DWORD PTR _usernumber$[ebp]
  00053	51		 push	 ecx
  00054	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0005f	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser
  00064	85 c0		 test	 eax, eax
  00066	75 14		 jne	 SHORT $LN18@CGPartyDel
$LN35@CGPartyDel:

; 10718: 	{
; 10719: 		LogAdd("User Not found");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAPFACKC@User?5Not?5found?$AA@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00073	83 c4 04	 add	 esp, 4
  00076	5f		 pop	 edi
  00077	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN18@CGPartyDel:

; 10720: 		return;
; 10721: 	}
; 10722: 
; 10723: 	if ( usernumber < 0 )

  0007c	83 7d fc 00	 cmp	 DWORD PTR _usernumber$[ebp], 0

; 10724: 	{
; 10725: 		LogAdd("User Not found");
; 10726: 		return;

  00080	7c e6		 jl	 SHORT $LN35@CGPartyDel

; 10727: 	}
; 10728: 
; 10729: 	int count; //loc3
; 10730: 	int number; //loc4
; 10731: 	int pnumber = gObj[aIndex].PartyNumber; //loc5

  00082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00088	56		 push	 esi
  00089	8b b4 17 2c 04
	00 00		 mov	 esi, DWORD PTR [edi+edx+1068]

; 10732: 
; 10733: 	if ( pnumber < 0 )

  00090	85 f6		 test	 esi, esi
  00092	79 07		 jns	 SHORT $LN16@CGPartyDel

; 10734: 	{
; 10735: 		LogAdd("%s %d", __FILE__, __LINE__);

  00094	68 ef 29 00 00	 push	 10735			; 000029efH

; 10736: 		return;

  00099	eb 1a		 jmp	 SHORT $LN34@CGPartyDel
$LN16@CGPartyDel:

; 10737: 	}
; 10738: 
; 10739: 	count = gParty.GetCount(pnumber);

  0009b	56		 push	 esi
  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000a1	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  000a6	8b c8		 mov	 ecx, eax
  000a8	89 4d 0c	 mov	 DWORD PTR _count$[ebp], ecx

; 10740: 
; 10741: 	if ( count < 1 )

  000ab	83 f9 01	 cmp	 ecx, 1
  000ae	7d 1f		 jge	 SHORT $LN15@CGPartyDel

; 10742: 	{
; 10743: 		LogAdd("%s %d", __FILE__, __LINE__);

  000b0	68 f7 29 00 00	 push	 10743			; 000029f7H
$LN34@CGPartyDel:
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	5e		 pop	 esi
  000c9	5f		 pop	 edi
  000ca	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
$LN15@CGPartyDel:

; 10744: 		return;
; 10745: 	}
; 10746: #ifdef IMPERIAL_CONFLICT_NEW
; 10747: 	if ( CImperialGuardian::IsEventMap(gObj[usernumber].MapNumber) )
; 10748: 		return;
; 10749: #endif
; 10750: #if(_NEW_PT_SYSTEM_==TRUE)
; 10751: 
; 10752: 	if ( count > 2 && lpMsg->Number == 0)

  000cf	83 f9 02	 cmp	 ecx, 2
  000d2	7e 71		 jle	 SHORT $LN28@CGPartyDel
  000d4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d7	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  000db	75 68		 jne	 SHORT $LN28@CGPartyDel

; 10753: 	{
; 10754: 		gParty.Delete(pnumber, lpMsg->Number);

  000dd	6a 00		 push	 0
  000df	56		 push	 esi
  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000e5	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 10755: 		count = gParty.GetCount(gObj[aIndex].PartyNumber);

  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f0	8b 94 0f 2c 04
	00 00		 mov	 edx, DWORD PTR [edi+ecx+1068]
  000f7	52		 push	 edx
  000f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000fd	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 10756: 		gObj[usernumber].PartyNumber = -1;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010b	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00111	89 9c 08 2c 04
	00 00		 mov	 DWORD PTR [eax+ecx+1068], ebx

; 10757: 		gObj[usernumber].PartyTargetUser = -1;

  00118	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  0011b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00120	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H

; 10758: 		gParty.SetPkCount(pnumber);

  00126	56		 push	 esi
  00127	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0012c	89 9c 02 30 04
	00 00		 mov	 DWORD PTR [edx+eax+1072], ebx
  00133	e8 00 00 00 00	 call	 ?SetPkCount@PartyClass@@QAEXH@Z ; PartyClass::SetPkCount

; 10759: 		gParty.ChangeLeader(pnumber);

  00138	56		 push	 esi
  00139	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0013e	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader

; 10760: 		GCPartyDelUserSend(usernumber);
; 10761: 		CGPartyListAll(pnumber);
; 10762: 		return;

  00143	eb 6c		 jmp	 SHORT $LN33@CGPartyDel
$LN28@CGPartyDel:

; 10763: 	}
; 10764: #endif
; 10765: 	if ( lpMsg->Number == 0 || count <= 2)

  00145	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00148	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0014b	84 c0		 test	 al, al
  0014d	74 7b		 je	 SHORT $LN12@CGPartyDel
  0014f	83 f9 02	 cmp	 ecx, 2
  00152	7e 76		 jle	 SHORT $LN12@CGPartyDel

; 10930: #else
; 10931: 
; 10932: 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)
; 10933: 		{
; 10934: 			number = gParty.m_PartyS[pnumber].Number[n];
; 10935: 
; 10936: 			if ( number >= 0 )
; 10937: 			{
; 10938: 				gParty.Delete(pnumber, n);
; 10939: 				gObj[number].PartyNumber = -1;
; 10940: 				gObj[number].PartyTargetUser = -1;
; 10941: 				GCPartyDelUserSend(number);
; 10942: 			}
; 10943: 		}
; 10944: 
; 10945: 		gParty.Destroy(pnumber);
; 10946: 
; 10947: 
; 10948: #endif
; 10949: 
; 10950: 	}
; 10951: 	else
; 10952: 	{
; 10953: 		gParty.Delete(pnumber, lpMsg->Number);

  00154	0f b6 c0	 movzx	 eax, al
  00157	50		 push	 eax
  00158	56		 push	 esi
  00159	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0015e	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 10954: 		count = gParty.GetCount(gObj[aIndex].PartyNumber);

  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00169	8b 94 0f 2c 04
	00 00		 mov	 edx, DWORD PTR [edi+ecx+1068]
  00170	52		 push	 edx
  00171	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00176	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 10955: 		gObj[usernumber].PartyNumber = -1;

  0017b	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00184	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0018a	89 9c 08 2c 04
	00 00		 mov	 DWORD PTR [eax+ecx+1068], ebx

; 10956: 		gObj[usernumber].PartyTargetUser = -1;

  00191	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00199	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H

; 10957: 		gParty.SetPkCount(pnumber); //season 2.5 add-on

  0019f	56		 push	 esi
  001a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001a5	89 9c 02 30 04
	00 00		 mov	 DWORD PTR [edx+eax+1072], ebx
  001ac	e8 00 00 00 00	 call	 ?SetPkCount@PartyClass@@QAEXH@Z ; PartyClass::SetPkCount
$LN33@CGPartyDel:

; 10958: 		GCPartyDelUserSend(usernumber);

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  001b4	51		 push	 ecx
  001b5	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 10959: 		CGPartyListAll(pnumber);

  001ba	56		 push	 esi
  001bb	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  001c0	83 c4 08	 add	 esp, 8
  001c3	5e		 pop	 esi
  001c4	5f		 pop	 edi
  001c5	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c3		 ret	 0
$LN12@CGPartyDel:

; 10766: 	{
; 10767: 		if(IT_MAP_RANGE(gObj[usernumber].MapNumber) != FALSE ) //season 2.5 add-on

  001ca	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d3	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  001d9	8a 94 0a 49 01
	00 00		 mov	 dl, BYTE PTR [edx+ecx+329]
  001e0	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  001e3	0f 82 47 01 00
	00		 jb	 $LN29@CGPartyDel
  001e9	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  001ee	3a ca		 cmp	 cl, dl
  001f0	1b c9		 sbb	 ecx, ecx
  001f2	41		 inc	 ecx
  001f3	0f 84 a7 00 00
	00		 je	 $LN10@CGPartyDel

; 10768: 		{
; 10769: 			if(lpMsg->Number == 0 && count > 2 )

  001f9	84 c0		 test	 al, al
  001fb	0f 85 9f 00 00
	00		 jne	 $LN10@CGPartyDel
  00201	83 7d 0c 02	 cmp	 DWORD PTR _count$[ebp], 2
  00205	0f 8e 95 00 00
	00		 jle	 $LN10@CGPartyDel

; 10770: 			{
; 10771: 				gParty.Delete(pnumber, lpMsg->Number);

  0020b	6a 00		 push	 0
  0020d	56		 push	 esi
  0020e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00213	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 10772: 				count = gParty.GetCount(gObj[aIndex].PartyNumber);

  00218	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021e	8b 84 17 2c 04
	00 00		 mov	 eax, DWORD PTR [edi+edx+1068]
  00225	50		 push	 eax
  00226	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0022b	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 10773: 
; 10774: 				gObj[usernumber].PartyNumber = -1;

  00230	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  00233	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00239	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0023f	89 9c 11 2c 04
	00 00		 mov	 DWORD PTR [ecx+edx+1068], ebx

; 10775: 				gObj[usernumber].PartyTargetUser = -1;

  00246	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024c	8b f8		 mov	 edi, eax
  0024e	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00251	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00257	89 9c 08 30 04
	00 00		 mov	 DWORD PTR [eax+ecx+1072], ebx

; 10776: 
; 10777: 				gParty.SetPkCount(pnumber);

  0025e	56		 push	 esi
  0025f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00264	e8 00 00 00 00	 call	 ?SetPkCount@PartyClass@@QAEXH@Z ; PartyClass::SetPkCount

; 10778: 				gParty.ResetPkLevel(pnumber);

  00269	56		 push	 esi
  0026a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0026f	e8 00 00 00 00	 call	 ?ResetPkLevel@PartyClass@@QAEXH@Z ; PartyClass::ResetPkLevel

; 10779: 				GCPartyDelUserSend(usernumber);

  00274	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  00277	52		 push	 edx
  00278	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 10780: 				CGPartyListAll(pnumber);

  0027d	56		 push	 esi
  0027e	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00283	83 c4 08	 add	 esp, 8

; 10781: 
; 10782: 				if(count == 0)

  00286	85 ff		 test	 edi, edi
  00288	0f 85 12 01 00
	00		 jne	 $LN30@CGPartyDel

; 10926: 			}
; 10927: 		}
; 10928: 
; 10929: 		gParty.Destroy(pnumber);

  0028e	56		 push	 esi
  0028f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00294	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
  00299	5e		 pop	 esi
  0029a	5f		 pop	 edi
  0029b	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  0029c	8b e5		 mov	 esp, ebp
  0029e	5d		 pop	 ebp
  0029f	c3		 ret	 0
$LN10@CGPartyDel:

; 10783: 				{
; 10784: 					gParty.Destroy(pnumber);
; 10785: 				}
; 10786: 				return;
; 10787: 			}
; 10788: 		}
; 10789: 		if(IT_MAP_RANGE(gObj[usernumber].MapNumber) != FALSE ) //season 2.5 add-on

  002a0	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  002a3	0f 82 87 00 00
	00		 jb	 $LN29@CGPartyDel
  002a9	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  002ae	3a ca		 cmp	 cl, dl
  002b0	1b c9		 sbb	 ecx, ecx
  002b2	41		 inc	 ecx
  002b3	74 7b		 je	 SHORT $LN29@CGPartyDel

; 10790: 		{
; 10791: 			if(count <= 2 )

  002b5	83 7d 0c 02	 cmp	 DWORD PTR _count$[ebp], 2
  002b9	7f 75		 jg	 SHORT $LN29@CGPartyDel

; 10792: 			{
; 10793: 				gParty.Delete(pnumber, lpMsg->Number);

  002bb	0f b6 d0	 movzx	 edx, al
  002be	52		 push	 edx
  002bf	56		 push	 esi
  002c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002c5	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 10794: 				count = gParty.GetCount(gObj[aIndex].PartyNumber);

  002ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cf	8b 8c 07 2c 04
	00 00		 mov	 ecx, DWORD PTR [edi+eax+1068]
  002d6	51		 push	 ecx
  002d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002dc	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 10795: 
; 10796: 				gObj[usernumber].PartyNumber = -1;

  002e1	8b 55 fc	 mov	 edx, DWORD PTR _usernumber$[ebp]
  002e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e9	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  002ef	89 9c 02 2c 04
	00 00		 mov	 DWORD PTR [edx+eax+1068], ebx

; 10797: 				gObj[usernumber].PartyTargetUser = -1;

  002f6	8b 4d fc	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  002f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ff	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00305	89 9c 11 30 04
	00 00		 mov	 DWORD PTR [ecx+edx+1072], ebx

; 10798: 
; 10799: 				gParty.SetPkCount(pnumber);

  0030c	56		 push	 esi
  0030d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00312	e8 00 00 00 00	 call	 ?SetPkCount@PartyClass@@QAEXH@Z ; PartyClass::SetPkCount

; 10800: 
; 10801: 				if(lpMsg == NULL)
; 10802: 				{
; 10803: 					gParty.ResetPkLevel(pnumber);
; 10804: 				}
; 10805: 				
; 10806: 				GCPartyDelUserSend(usernumber);

  00317	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 10807: 				CGPartyListAll(pnumber);

  00320	56		 push	 esi
  00321	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00326	83 c4 08	 add	 esp, 8
  00329	5e		 pop	 esi
  0032a	5f		 pop	 edi
  0032b	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  0032c	8b e5		 mov	 esp, ebp
  0032e	5d		 pop	 ebp
  0032f	c3		 ret	 0
$LN29@CGPartyDel:

; 10808: 				return;
; 10809: 			}
; 10810: 		}
; 10811: 
; 10812: #if(_NEW_PT_SYSTEM_==TRUE)
; 10813: 
; 10814: 		//if(lpMsg->Number == 0)
; 10815: 		//{
; 10816: 		//		gParty.Delete(pnumber, lpMsg->Number);
; 10817: 		//		count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10818: 
; 10819: 		//		gObj[usernumber].PartyNumber = -1;
; 10820: 		//		gObj[usernumber].PartyTargetUser = -1;
; 10821: 
; 10822: 		//		gParty.SetPkCount(pnumber);
; 10823: 		//		gParty.ResetPkLevel(pnumber);
; 10824: 		//		GCPartyDelUserSend(usernumber);
; 10825: 		//		CGPartyListAll(pnumber);
; 10826: 
; 10827: 		//		if(count == 0)
; 10828: 		//		{
; 10829: 		//			gParty.Destroy(pnumber);
; 10830: 		//		}
; 10831: 		//}
; 10832: 		//else
; 10833: 		//{
; 10834: 		//	if(count <= 2 )
; 10835: 		//	{
; 10836: 		//		gParty.Delete(pnumber, lpMsg->Number);
; 10837: 		//		count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10838: 
; 10839: 		//		gObj[usernumber].PartyNumber = -1;
; 10840: 		//		gObj[usernumber].PartyTargetUser = -1;
; 10841: 
; 10842: 		//		gParty.SetPkCount(pnumber);
; 10843: 
; 10844: 		//		if(lpMsg == NULL)
; 10845: 		//		{
; 10846: 		//			gParty.ResetPkLevel(pnumber);
; 10847: 		//		}
; 10848: 		//		
; 10849: 		//		GCPartyDelUserSend(usernumber);
; 10850: 		//		CGPartyListAll(pnumber);
; 10851: 		//		return;
; 10852: 		//	}
; 10853: 		//}
; 10854: 
; 10855: 		//if(lpMsg == NULL)
; 10856: 		//{
; 10857: 		//		gParty.Delete(pnumber, lpMsg->Number);
; 10858: 		//		count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10859: 
; 10860: 		//		gObj[usernumber].PartyNumber = -1;
; 10861: 		//		gObj[usernumber].PartyTargetUser = -1;
; 10862: 
; 10863: 		//		gParty.SetPkCount(pnumber);
; 10864: 		//		gParty.ResetPkLevel(pnumber);
; 10865: 		//		GCPartyDelUserSend(usernumber);
; 10866: 		//		CGPartyListAll(pnumber);
; 10867: 
; 10868: 		//		if(count == 0)
; 10869: 		//		{
; 10870: 		//			gParty.Destroy(pnumber);
; 10871: 		//		}
; 10872: 		//}
; 10873: 		//else
; 10874: 		//{
; 10875: 		//	for ( int n=0;n<MAX_USER_IN_PARTY;n++)
; 10876: 		//	{
; 10877: 		//		number = gParty.m_PartyS[pnumber].Number[n];
; 10878: 
; 10879: 		//		if ( number >= 0 )
; 10880: 		//		{
; 10881: 		//			gParty.Delete(pnumber, n);
; 10882: 		//			gObj[number].PartyNumber = -1;
; 10883: 		//			gObj[number].PartyTargetUser = -1;
; 10884: 
; 10885: 		//			GCPartyDelUserSend(number);
; 10886: 		//		}
; 10887: 		//	}
; 10888: 
; 10889: 		//	gParty.Destroy(pnumber);
; 10890: 		//}
; 10891: 
; 10892: 
; 10893: 
; 10894: 
; 10895: 				//gParty.Delete(pnumber, lpMsg->Number);
; 10896: 				//count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10897: 
; 10898: 				//gObj[usernumber].PartyNumber = -1;
; 10899: 				//gObj[usernumber].PartyTargetUser = -1;
; 10900: 
; 10901: 				//gParty.SetPkCount(pnumber);
; 10902: 				//gParty.ResetPkLevel(pnumber);
; 10903: 				//GCPartyDelUserSend(usernumber);
; 10904: 				//CGPartyListAll(pnumber);
; 10905: 
; 10906: 				//if(count == 0)
; 10907: 				//{
; 10908: 				//	gParty.Destroy(pnumber);
; 10909: 				//}
; 10910: 
; 10911: 
; 10912: 
; 10913: 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00330	8b c6		 mov	 eax, esi
  00332	6b c0 68	 imul	 eax, 104		; 00000068H
  00335	33 db		 xor	 ebx, ebx
  00337	05 0c 00 00 00	 add	 eax, OFFSET ?gParty@@3VPartyClass@@A+12
  0033c	89 45 0c	 mov	 DWORD PTR tv455[ebp], eax
  0033f	90		 npad	 1
$LL5@CGPartyDel:

; 10914: 		{
; 10915: 			number = gParty.m_PartyS[pnumber].Number[n];

  00340	8b 38		 mov	 edi, DWORD PTR [eax]

; 10916: 
; 10917: 			if ( number >= 0 )

  00342	85 ff		 test	 edi, edi
  00344	78 43		 js	 SHORT $LN4@CGPartyDel

; 10918: 			{
; 10919: 				gParty.Delete(pnumber, n);

  00346	53		 push	 ebx
  00347	56		 push	 esi
  00348	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0034d	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 10920: 				gObj[number].PartyNumber = -1;

  00352	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00358	8b c7		 mov	 eax, edi
  0035a	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00360	83 c9 ff	 or	 ecx, -1
  00363	89 8c 10 2c 04
	00 00		 mov	 DWORD PTR [eax+edx+1068], ecx

; 10921: 				gObj[number].PartyTargetUser = -1;

  0036a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10922: 
; 10923: 				GCPartyDelUserSend(number);

  00370	57		 push	 edi
  00371	89 8c 10 30 04
	00 00		 mov	 DWORD PTR [eax+edx+1072], ecx
  00378	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 10924: 
; 10925: 				CGPartyListAll(pnumber);///

  0037d	56		 push	 esi
  0037e	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00383	8b 45 0c	 mov	 eax, DWORD PTR tv455[ebp]
  00386	83 c4 08	 add	 esp, 8
$LN4@CGPartyDel:

; 10808: 				return;
; 10809: 			}
; 10810: 		}
; 10811: 
; 10812: #if(_NEW_PT_SYSTEM_==TRUE)
; 10813: 
; 10814: 		//if(lpMsg->Number == 0)
; 10815: 		//{
; 10816: 		//		gParty.Delete(pnumber, lpMsg->Number);
; 10817: 		//		count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10818: 
; 10819: 		//		gObj[usernumber].PartyNumber = -1;
; 10820: 		//		gObj[usernumber].PartyTargetUser = -1;
; 10821: 
; 10822: 		//		gParty.SetPkCount(pnumber);
; 10823: 		//		gParty.ResetPkLevel(pnumber);
; 10824: 		//		GCPartyDelUserSend(usernumber);
; 10825: 		//		CGPartyListAll(pnumber);
; 10826: 
; 10827: 		//		if(count == 0)
; 10828: 		//		{
; 10829: 		//			gParty.Destroy(pnumber);
; 10830: 		//		}
; 10831: 		//}
; 10832: 		//else
; 10833: 		//{
; 10834: 		//	if(count <= 2 )
; 10835: 		//	{
; 10836: 		//		gParty.Delete(pnumber, lpMsg->Number);
; 10837: 		//		count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10838: 
; 10839: 		//		gObj[usernumber].PartyNumber = -1;
; 10840: 		//		gObj[usernumber].PartyTargetUser = -1;
; 10841: 
; 10842: 		//		gParty.SetPkCount(pnumber);
; 10843: 
; 10844: 		//		if(lpMsg == NULL)
; 10845: 		//		{
; 10846: 		//			gParty.ResetPkLevel(pnumber);
; 10847: 		//		}
; 10848: 		//		
; 10849: 		//		GCPartyDelUserSend(usernumber);
; 10850: 		//		CGPartyListAll(pnumber);
; 10851: 		//		return;
; 10852: 		//	}
; 10853: 		//}
; 10854: 
; 10855: 		//if(lpMsg == NULL)
; 10856: 		//{
; 10857: 		//		gParty.Delete(pnumber, lpMsg->Number);
; 10858: 		//		count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10859: 
; 10860: 		//		gObj[usernumber].PartyNumber = -1;
; 10861: 		//		gObj[usernumber].PartyTargetUser = -1;
; 10862: 
; 10863: 		//		gParty.SetPkCount(pnumber);
; 10864: 		//		gParty.ResetPkLevel(pnumber);
; 10865: 		//		GCPartyDelUserSend(usernumber);
; 10866: 		//		CGPartyListAll(pnumber);
; 10867: 
; 10868: 		//		if(count == 0)
; 10869: 		//		{
; 10870: 		//			gParty.Destroy(pnumber);
; 10871: 		//		}
; 10872: 		//}
; 10873: 		//else
; 10874: 		//{
; 10875: 		//	for ( int n=0;n<MAX_USER_IN_PARTY;n++)
; 10876: 		//	{
; 10877: 		//		number = gParty.m_PartyS[pnumber].Number[n];
; 10878: 
; 10879: 		//		if ( number >= 0 )
; 10880: 		//		{
; 10881: 		//			gParty.Delete(pnumber, n);
; 10882: 		//			gObj[number].PartyNumber = -1;
; 10883: 		//			gObj[number].PartyTargetUser = -1;
; 10884: 
; 10885: 		//			GCPartyDelUserSend(number);
; 10886: 		//		}
; 10887: 		//	}
; 10888: 
; 10889: 		//	gParty.Destroy(pnumber);
; 10890: 		//}
; 10891: 
; 10892: 
; 10893: 
; 10894: 
; 10895: 				//gParty.Delete(pnumber, lpMsg->Number);
; 10896: 				//count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 10897: 
; 10898: 				//gObj[usernumber].PartyNumber = -1;
; 10899: 				//gObj[usernumber].PartyTargetUser = -1;
; 10900: 
; 10901: 				//gParty.SetPkCount(pnumber);
; 10902: 				//gParty.ResetPkLevel(pnumber);
; 10903: 				//GCPartyDelUserSend(usernumber);
; 10904: 				//CGPartyListAll(pnumber);
; 10905: 
; 10906: 				//if(count == 0)
; 10907: 				//{
; 10908: 				//	gParty.Destroy(pnumber);
; 10909: 				//}
; 10910: 
; 10911: 
; 10912: 
; 10913: 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00389	43		 inc	 ebx
  0038a	83 c0 04	 add	 eax, 4
  0038d	89 45 0c	 mov	 DWORD PTR tv455[ebp], eax
  00390	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00393	7c ab		 jl	 SHORT $LL5@CGPartyDel

; 10926: 			}
; 10927: 		}
; 10928: 
; 10929: 		gParty.Destroy(pnumber);

  00395	56		 push	 esi
  00396	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0039b	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
$LN30@CGPartyDel:
  003a0	5e		 pop	 esi
  003a1	5f		 pop	 edi
  003a2	5b		 pop	 ebx

; 10960: 	}		
; 10961: }

  003a3	8b e5		 mov	 esp, ebp
  003a5	5d		 pop	 ebp
  003a6	c3		 ret	 0
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ENDP	; CGPartyDelUser
_TEXT	ENDS
PUBLIC	?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
EXTRN	?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjGuildMasterCapacityTest
; Function compile flags: /Ogtp
;	COMDAT ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z PROC ; CGGuildMasterAnswerRecv, COMDAT

; 11529: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11530: 	if ( lpMsg->Result == 1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	80 78 03 01	 cmp	 BYTE PTR [eax+3], 1

; 11531: 	{
; 11532: 		if ( !gObjGuildMasterCapacityTest(&gObj[aIndex]))

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00010	75 53		 jne	 SHORT $LN4@CGGuildMas@3
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00017	8b f7		 mov	 esi, edi
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildMasterCapacityTest
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	75 29		 jne	 SHORT $LN3@CGGuildMas@3

; 11533: 		{
; 11534: 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	8b 84 0e 1c 0e
	00 00		 mov	 eax, DWORD PTR [esi+ecx+3612]
  0003c	a8 03		 test	 al, 3
  0003e	74 14		 je	 SHORT $LN7@CGGuildMas@3
  00040	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00045	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0004a	75 08		 jne	 SHORT $LN7@CGGuildMas@3

; 11535: 			{
; 11536: 				gObj[aIndex].m_IfState.use = 0;

  0004c	83 a4 0e 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+ecx+3612], -4 ; fffffffcH
$LN7@CGGuildMas@3:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
$LN1@CGGuildMas@3:

; 11549: 	}
; 11550: }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN3@CGGuildMas@3:

; 11537: 			}
; 11538: 
; 11539: 			return;
; 11540: 		}
; 11541: 
; 11542: 		GCGuildMasterManagerRun(aIndex);

  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?GCGuildMasterManagerRun@@YAXH@Z ; GCGuildMasterManagerRun
  0005e	83 c4 04	 add	 esp, 4
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 11549: 	}
; 11550: }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN4@CGGuildMas@3:

; 11543: 		return;
; 11544: 	}
; 11545: 
; 11546: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  00065	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00068	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0006e	8d 8c 08 1c 0e
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+3612]
  00075	8b 01		 mov	 eax, DWORD PTR [ecx]
  00077	a8 03		 test	 al, 3
  00079	74 db		 je	 SHORT $LN1@CGGuildMas@3
  0007b	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00080	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00085	75 cf		 jne	 SHORT $LN1@CGGuildMas@3

; 11547: 	{
; 11548: 		gObj[aIndex].m_IfState.use = 0;

  00087	83 21 fc	 and	 DWORD PTR [ecx], -4	; fffffffcH

; 11549: 	}
; 11550: }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ENDP ; CGGuildMasterAnswerRecv
_TEXT	ENDS
PUBLIC	??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@ ; `string'
PUBLIC	??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@ ; `string'
PUBLIC	??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	_GuildName$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarRequestResult@@YAXPADHH@Z		; GCGuildWarRequestResult
;	COMDAT ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@
CONST	SEGMENT
??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@ DB 'Error on '
	DB	'declaring war : Target GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@
CONST	SEGMENT
??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@ DB '['
	DB	'U.System][Guildwar] Can''t declare guildwar between Same Unio'
	DB	'n (%s / %d) <-> (%s / %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@
CONST	SEGMENT
??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@ DB 'Error on d'
	DB	'eclaring war : GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCGuildWarRequestResult@@YAXPADHH@Z
_TEXT	SEGMENT
tv473 = -40						; size = 4
tv448 = -36						; size = 4
_lpMyGuild$ = -32					; size = 4
_GuildName$GSCopy$ = -28				; size = 4
_n$248552 = -28						; size = 4
_aIndex$GSCopy$ = -24					; size = 4
_pMsg$ = -20						; size = 4
__guildname$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestResult@@YAXPADHH@Z PROC		; GCGuildWarRequestResult, COMDAT

; 11864: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 11865: //#if(GS_CASTLE == 1)
; 11866: //	return;
; 11867: //#endif
; 11868: 	PMSG_GUILDWARREQUEST_RESULT pMsg;
; 11869: 
; 11870: 	PHeadSetB((LPBYTE)&pMsg, 0x60, sizeof(pMsg));

  00018	6a 04		 push	 4
  0001a	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0001d	6a 60		 push	 96			; 00000060H
  0001f	51		 push	 ecx

; 11904: 	{
; 11905: 		pMsg.Result = 5;

  00020	89 45 e4	 mov	 DWORD PTR _GuildName$GSCopy$[ebp], eax
  00023	89 7d e8	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  00026	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	8b f7		 mov	 esi, edi
  00032	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c6 45 ef 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3
  0003f	83 bc 06 34 04
	00 00 01	 cmp	 DWORD PTR [esi+eax+1076], 1
  00047	89 75 dc	 mov	 DWORD PTR tv448[ebp], esi
  0004a	7d 22		 jge	 SHORT $LN26@GCGuildWar@2

; 11871: 	pMsg.Result = 3;
; 11872: 
; 11873: 	if ( gObj[aIndex].GuildNumber < 1)
; 11874: 	{
; 11875: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0004c	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00050	52		 push	 edx
  00051	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00054	50		 push	 eax
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN26@GCGuildWar@2:
  0006e	53		 push	 ebx

; 11876: 		return;
; 11877: 	}
; 11878: 
; 11879: 	_GUILD_INFO_STRUCT * lpMyGuild = gObj[aIndex].lpGuild;

  0006f	8b 9c 06 38 04
	00 00		 mov	 ebx, DWORD PTR [esi+eax+1080]
  00076	89 5d e0	 mov	 DWORD PTR _lpMyGuild$[ebp], ebx

; 11880: 
; 11881: 	if ( !lpMyGuild )

  00079	85 db		 test	 ebx, ebx
  0007b	75 23		 jne	 SHORT $LN25@GCGuildWar@2

; 11882: 	{
; 11883: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007d	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00081	51		 push	 ecx
  00082	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00085	52		 push	 edx
  00086	57		 push	 edi

; 12017: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00087	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	5b		 pop	 ebx
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	33 cd		 xor	 ecx, ebp
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN25@GCGuildWar@2:

; 11884: 		return;
; 11885: 	}
; 11886: 
; 11887: 	if ( lpMyGuild->WarState == 1 || lpMyGuild->WarDeclareState == 1 )

  000a0	80 bb 91 05 00
	00 01		 cmp	 BYTE PTR [ebx+1425], 1
  000a7	0f 84 1b 04 00
	00		 je	 $LN23@GCGuildWar@2
  000ad	80 bb 90 05 00
	00 01		 cmp	 BYTE PTR [ebx+1424], 1
  000b4	0f 84 0e 04 00
	00		 je	 $LN23@GCGuildWar@2

; 11892: 		return;
; 11893: 	}
; 11894: 
; 11895: 	if ( gPkLimitFree == FALSE && gObj[aIndex].m_PK_Level >= 6)

  000ba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  000c1	75 45		 jne	 SHORT $LN22@GCGuildWar@2
  000c3	80 bc 06 3d 01
	00 00 06	 cmp	 BYTE PTR [esi+eax+317], 6
  000cb	7c 3b		 jl	 SHORT $LN22@GCGuildWar@2

; 11896: 	{
; 11897: 		pMsg.Result = 4;
; 11898: 		LogAdd("Error on declaring war : GuildMaster Is Murderer 0x04 %s %s", lpMyGuild->Names[0], gObj[aIndex].Name);

  000cd	8d 44 06 77	 lea	 eax, DWORD PTR [esi+eax+119]
  000d1	50		 push	 eax
  000d2	83 c3 2f	 add	 ebx, 47			; 0000002fH
  000d5	53		 push	 ebx
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@
  000db	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11899: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e5	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000e9	51		 push	 ecx
  000ea	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000ed	52		 push	 edx
  000ee	57		 push	 edi
  000ef	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f4	83 c4 18	 add	 esp, 24			; 00000018H
  000f7	5b		 pop	 ebx
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  000fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fd	33 cd		 xor	 ecx, ebp
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN22@GCGuildWar@2:

; 11900: 		return;
; 11901: 	}
; 11902: 
; 11903: 	if ( strcmp(lpMyGuild->Names[0], gObj[aIndex].Name ) )

  00108	8d 74 06 77	 lea	 esi, DWORD PTR [esi+eax+119]
  0010c	8d 7b 2f	 lea	 edi, DWORD PTR [ebx+47]
  0010f	89 7d d8	 mov	 DWORD PTR tv473[ebp], edi
  00112	8b ce		 mov	 ecx, esi
  00114	8b c7		 mov	 eax, edi
$LL45@GCGuildWar@2:
  00116	8a 10		 mov	 dl, BYTE PTR [eax]
  00118	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0011a	75 1a		 jne	 SHORT $LN46@GCGuildWar@2
  0011c	84 d2		 test	 dl, dl
  0011e	74 12		 je	 SHORT $LN47@GCGuildWar@2
  00120	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00123	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00126	75 0e		 jne	 SHORT $LN46@GCGuildWar@2
  00128	83 c0 02	 add	 eax, 2
  0012b	83 c1 02	 add	 ecx, 2
  0012e	84 d2		 test	 dl, dl
  00130	75 e4		 jne	 SHORT $LL45@GCGuildWar@2
$LN47@GCGuildWar@2:
  00132	33 c0		 xor	 eax, eax
  00134	eb 05		 jmp	 SHORT $LN48@GCGuildWar@2
$LN46@GCGuildWar@2:
  00136	1b c0		 sbb	 eax, eax
  00138	83 d8 ff	 sbb	 eax, -1
$LN48@GCGuildWar@2:
  0013b	85 c0		 test	 eax, eax
  0013d	74 42		 je	 SHORT $LN21@GCGuildWar@2

; 11906: 		LogAdd(lMsg.Get(MSGGET(1, 235)), lpMyGuild->Names[0], gObj[aIndex].Name);

  0013f	56		 push	 esi
  00140	57		 push	 edi
  00141	68 eb 01 00 00	 push	 491			; 000001ebH
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0014b	c6 45 ef 05	 mov	 BYTE PTR _pMsg$[ebp+3], 5
  0014f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00154	50		 push	 eax
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11907: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0015b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0015f	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00162	50		 push	 eax
  00163	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00166	51		 push	 ecx
  00167	52		 push	 edx
  00168	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016d	83 c4 18	 add	 esp, 24			; 00000018H
  00170	5b		 pop	 ebx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  00173	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	33 cd		 xor	 ecx, ebp
  00178	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
$LN21@GCGuildWar@2:

; 11908: 		return;
; 11909: 	}
; 11910: 
; 11911: 	char _guildname[MAX_GUILD_LEN+1];
; 11912: 	memset(_guildname, 0, sizeof(_guildname));

  00181	33 c0		 xor	 eax, eax
  00183	89 45 f0	 mov	 DWORD PTR __guildname$[ebp], eax
  00186	89 45 f4	 mov	 DWORD PTR __guildname$[ebp+4], eax
  00189	88 45 f8	 mov	 BYTE PTR __guildname$[ebp+8], al

; 11913: 	memcpy(_guildname, GuildName, MAX_GUILD_LEN);

  0018c	8b 45 e4	 mov	 eax, DWORD PTR _GuildName$GSCopy$[ebp]
  0018f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00191	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 11914: 
; 11915: 	if ( !strncmp(lpMyGuild->Name, GuildName, MAX_GUILD_LEN))

  00194	6a 08		 push	 8
  00196	50		 push	 eax
  00197	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  0019a	56		 push	 esi
  0019b	89 4d f0	 mov	 DWORD PTR __guildname$[ebp], ecx
  0019e	89 55 f4	 mov	 DWORD PTR __guildname$[ebp+4], edx
  001a1	e8 00 00 00 00	 call	 _strncmp
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a9	85 c0		 test	 eax, eax
  001ab	0f 84 57 03 00
	00		 je	 $LN55@GCGuildWar@2

; 11916: 	{
; 11917: 		return;
; 11918: 	}
; 11919: 
; 11920: 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(_guildname);

  001b1	8d 45 f0	 lea	 eax, DWORD PTR __guildname$[ebp]
  001b4	50		 push	 eax
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  001ba	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  001bf	8b f8		 mov	 edi, eax

; 11921: 
; 11922: 	if ( lpNode )

  001c1	85 ff		 test	 edi, edi
  001c3	0f 84 d5 02 00
	00		 je	 $LN19@GCGuildWar@2

; 11923: 	{
; 11924: 		if ( lpNode->WarState == 1 || lpNode->WarDeclareState == 1 )

  001c9	80 bf 91 05 00
	00 01		 cmp	 BYTE PTR [edi+1425], 1
  001d0	0f 84 8b 02 00
	00		 je	 $LN17@GCGuildWar@2
  001d6	80 bf 90 05 00
	00 01		 cmp	 BYTE PTR [edi+1424], 1
  001dd	0f 84 7e 02 00
	00		 je	 $LN17@GCGuildWar@2

; 11930: 		}
; 11931: 
; 11932: 		if ( lpMyGuild->iGuildUnion != 0 && lpMyGuild->iGuildUnion == lpNode->iGuildUnion )

  001e3	8b 83 1c 07 00
	00		 mov	 eax, DWORD PTR [ebx+1820]
  001e9	85 c0		 test	 eax, eax
  001eb	74 2e		 je	 SHORT $LN16@GCGuildWar@2
  001ed	3b 87 1c 07 00
	00		 cmp	 eax, DWORD PTR [edi+1820]
  001f3	75 26		 jne	 SHORT $LN16@GCGuildWar@2

; 11933: 		{
; 11934: 			LogAddTD("[U.System][Guildwar] Can't declare guildwar between Same Union (%s / %d) <-> (%s / %d)", lpMyGuild->Name, lpMyGuild->iGuildUnion, lpNode->Name, lpMyGuild->iGuildUnion);

  001f5	50		 push	 eax
  001f6	83 c7 04	 add	 edi, 4
  001f9	57		 push	 edi
  001fa	50		 push	 eax
  001fb	56		 push	 esi
  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00207	83 c4 14	 add	 esp, 20			; 00000014H
  0020a	5b		 pop	 ebx
  0020b	5f		 pop	 edi
  0020c	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  0020d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00210	33 cd		 xor	 ecx, ebp
  00212	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c3		 ret	 0
$LN16@GCGuildWar@2:

; 11935: 			return;
; 11936: 		}
; 11937: 
; 11938: 		int n=0;

  0021b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00221	33 db		 xor	 ebx, ebx
  00223	83 c6 77	 add	 esi, 119		; 00000077H
$LL15@GCGuildWar@2:

; 11939: 		int warmaster=-1;
; 11940: 
; 11941: 		while ( true )
; 11942: 		{
; 11943: 			if ( gObj[n].Type == OBJ_USER )

  00226	66 83 7e f1 01	 cmp	 WORD PTR [esi-15], 1
  0022b	75 3c		 jne	 SHORT $LN10@GCGuildWar@2

; 11944: 			{
; 11945: 				if ( gObj[n].Connected > PLAYER_LOGGED )

  0022d	83 7e 8d 02	 cmp	 DWORD PTR [esi-115], 2
  00231	7e 36		 jle	 SHORT $LN10@GCGuildWar@2

; 11946: 				{
; 11947: 					if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  00233	8a 16		 mov	 dl, BYTE PTR [esi]
  00235	3a 57 2f	 cmp	 dl, BYTE PTR [edi+47]
  00238	8d 4f 2f	 lea	 ecx, DWORD PTR [edi+47]
  0023b	75 2c		 jne	 SHORT $LN10@GCGuildWar@2

; 11948: 					{
; 11949: 						if ( !strcmp(gObj[n].Name, lpNode->Names[0]))

  0023d	8b c6		 mov	 eax, esi
  0023f	90		 npad	 1
$LL49@GCGuildWar@2:
  00240	8a 10		 mov	 dl, BYTE PTR [eax]
  00242	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00244	75 1a		 jne	 SHORT $LN50@GCGuildWar@2
  00246	84 d2		 test	 dl, dl
  00248	74 12		 je	 SHORT $LN51@GCGuildWar@2
  0024a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0024d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00250	75 0e		 jne	 SHORT $LN50@GCGuildWar@2
  00252	83 c0 02	 add	 eax, 2
  00255	83 c1 02	 add	 ecx, 2
  00258	84 d2		 test	 dl, dl
  0025a	75 e4		 jne	 SHORT $LL49@GCGuildWar@2
$LN51@GCGuildWar@2:
  0025c	33 c0		 xor	 eax, eax
  0025e	eb 05		 jmp	 SHORT $LN52@GCGuildWar@2
$LN50@GCGuildWar@2:
  00260	1b c0		 sbb	 eax, eax
  00262	83 d8 ff	 sbb	 eax, -1
$LN52@GCGuildWar@2:
  00265	85 c0		 test	 eax, eax
  00267	74 15		 je	 SHORT $LN42@GCGuildWar@2
$LN10@GCGuildWar@2:

; 11957: 								return;
; 11958: 							}
; 11959: 
; 11960: 							warmaster = n;
; 11961: 							break;
; 11962: 						}
; 11963: 					}
; 11964: 				}
; 11965: 			}
; 11966: 
; 11967: 			if ( n < OBJMAX-1 )

  00269	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0026f	0f 8d e6 01 00
	00		 jge	 $LN6@GCGuildWar@2

; 11968: 			{
; 11969: 				n++;

  00275	43		 inc	 ebx
  00276	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H

; 11970: 			}
; 11971: 			else
; 11972: 			{
; 11973: 				break;
; 11974: 			}
; 11975: 		}

  0027c	eb a8		 jmp	 SHORT $LL15@GCGuildWar@2
$LN42@GCGuildWar@2:

; 11950: 						{
; 11951: 							if ( gPkLimitFree == FALSE && gObj[n].m_PK_Level >= 6)

  0027e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00285	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11968: 			{
; 11969: 				n++;

  0028b	89 5d e4	 mov	 DWORD PTR _n$248552[ebp], ebx
  0028e	75 53		 jne	 SHORT $LN9@GCGuildWar@2

; 11950: 						{
; 11951: 							if ( gPkLimitFree == FALSE && gObj[n].m_PK_Level >= 6)

  00290	8b c3		 mov	 eax, ebx
  00292	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00298	80 bc 30 3d 01
	00 00 06	 cmp	 BYTE PTR [eax+esi+317], 6
  002a0	7c 41		 jl	 SHORT $LN9@GCGuildWar@2

; 11952: 							{
; 11953: 								pMsg.Result = 4;
; 11954: 
; 11955: 								LogAdd("Error on declaring war : Target GuildMaster Is Murderer 0x04 %s %s", lpMyGuild->Names[0], gObj[aIndex].Name);

  002a2	8b 4d dc	 mov	 ecx, DWORD PTR tv448[ebp]
  002a5	8b 45 d8	 mov	 eax, DWORD PTR tv473[ebp]
  002a8	8d 54 31 77	 lea	 edx, DWORD PTR [ecx+esi+119]
  002ac	52		 push	 edx
  002ad	50		 push	 eax
  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@
  002b3	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11956: 								DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  002bd	0f b6 4d ed	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  002c1	8b 45 e8	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  002c4	51		 push	 ecx
  002c5	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$[ebp]
  002c8	52		 push	 edx
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002cf	83 c4 18	 add	 esp, 24			; 00000018H
  002d2	5b		 pop	 ebx
  002d3	5f		 pop	 edi
  002d4	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  002d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d8	33 cd		 xor	 ecx, ebp
  002da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002df	8b e5		 mov	 esp, ebp
  002e1	5d		 pop	 ebp
  002e2	c3		 ret	 0
$LN9@GCGuildWar@2:

; 11976: 		
; 11977: 		if ( warmaster >= 1 )

  002e3	83 fb 01	 cmp	 ebx, 1
  002e6	0f 8c 6f 01 00
	00		 jl	 $LN6@GCGuildWar@2

; 11978: 		{
; 11979: 			if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) || CC_MAP_RANGE(gObj[warmaster].MapNumber) )

  002ec	8b 4d dc	 mov	 ecx, DWORD PTR tv448[ebp]
  002ef	0f b6 84 31 49
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+329]
  002f7	3c 35		 cmp	 al, 53			; 00000035H
  002f9	0f 84 2d 01 00
	00		 je	 $LN4@GCGuildWar@2
  002ff	3c 12		 cmp	 al, 18			; 00000012H
  00301	72 0d		 jb	 SHORT $LN43@GCGuildWar@2
  00303	b2 17		 mov	 dl, 23			; 00000017H
  00305	3a d0		 cmp	 dl, al
  00307	1b c0		 sbb	 eax, eax
  00309	40		 inc	 eax
  0030a	0f 85 1c 01 00
	00		 jne	 $LN4@GCGuildWar@2
$LN43@GCGuildWar@2:
  00310	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00316	0f b6 84 33 49
	01 00 00	 movzx	 eax, BYTE PTR [ebx+esi+329]
  0031e	8d 0c 33	 lea	 ecx, DWORD PTR [ebx+esi]
  00321	3c 35		 cmp	 al, 53			; 00000035H
  00323	0f 84 03 01 00
	00		 je	 $LN4@GCGuildWar@2
  00329	3c 12		 cmp	 al, 18			; 00000012H
  0032b	72 0d		 jb	 SHORT $LN44@GCGuildWar@2
  0032d	b2 17		 mov	 dl, 23			; 00000017H
  0032f	3a d0		 cmp	 dl, al
  00331	1b c0		 sbb	 eax, eax
  00333	40		 inc	 eax
  00334	0f 85 f2 00 00
	00		 jne	 $LN4@GCGuildWar@2
$LN44@GCGuildWar@2:

; 11982: 				return;
; 11983: 			}
; 11984: 
; 11985: 			if ( (gObj[warmaster].m_Option&1) != 1 )
; 11986: 			{
; 11987: 				pMsg.Result = 4;
; 11988: 				DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0033a	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0033e	f6 81 8c 0e 00
	00 01		 test	 BYTE PTR [ecx+3724], 1
  00345	8b 55 e8	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00348	50		 push	 eax
  00349	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0034c	51		 push	 ecx
  0034d	52		 push	 edx
  0034e	75 1d		 jne	 SHORT $LN3@GCGuildWar@2

; 12017: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00350	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  00354	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00359	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035c	5b		 pop	 ebx
  0035d	5f		 pop	 edi
  0035e	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  0035f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00362	33 cd		 xor	 ecx, ebp
  00364	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00369	8b e5		 mov	 esp, ebp
  0036b	5d		 pop	 ebp
  0036c	c3		 ret	 0
$LN3@GCGuildWar@2:

; 11989: 				return;
; 11990: 			}
; 11991: 
; 11992: 			pMsg.Result = 1;

  0036d	c6 45 ef 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 11993: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00371	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11994: 			GCGuildWarRequestSend(lpMyGuild->Name, warmaster, type);

  00376	8b 5d 10	 mov	 ebx, DWORD PTR _type$[ebp]
  00379	8b 45 e4	 mov	 eax, DWORD PTR _n$248552[ebp]
  0037c	53		 push	 ebx
  0037d	50		 push	 eax
  0037e	8b 45 e0	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  00381	83 c0 04	 add	 eax, 4
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 ?GCGuildWarRequestSend@@YAXPADHH@Z ; GCGuildWarRequestSend

; 11995: 			lpMyGuild->WarDeclareState = 1;

  0038a	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  0038d	c6 81 90 05 00
	00 01		 mov	 BYTE PTR [ecx+1424], 1
  00394	83 c4 18	 add	 esp, 24			; 00000018H

; 11996: 			lpNode->WarDeclareState = 1;

  00397	c6 87 90 05 00
	00 01		 mov	 BYTE PTR [edi+1424], 1

; 11997: 			lpMyGuild->WarType = type;

  0039e	88 99 92 05 00
	00		 mov	 BYTE PTR [ecx+1426], bl

; 11998: 			lpNode->WarType = type;
; 11999: 
; 12000: 			LogAddTD(lMsg.Get(MSGGET(1, 236)), gObj[aIndex].AccountID, gObj[aIndex].Name, lpMyGuild->Name, lpNode->Name);

  003a4	83 c1 04	 add	 ecx, 4
  003a7	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  003aa	56		 push	 esi
  003ab	51		 push	 ecx
  003ac	8b 4d dc	 mov	 ecx, DWORD PTR tv448[ebp]
  003af	88 9f 92 05 00
	00		 mov	 BYTE PTR [edi+1426], bl
  003b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ba	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  003be	52		 push	 edx
  003bf	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  003c3	50		 push	 eax
  003c4	68 ec 01 00 00	 push	 492			; 000001ecH
  003c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003ce	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003d3	50		 push	 eax
  003d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12001: 
; 12002: 			strcpy(lpMyGuild->TargetGuildName, lpNode->Name);

  003da	8b 5d e0	 mov	 ebx, DWORD PTR _lpMyGuild$[ebp]
  003dd	8d 8b e0 04 00
	00		 lea	 ecx, DWORD PTR [ebx+1248]
  003e3	83 c4 14	 add	 esp, 20			; 00000014H
  003e6	8b c6		 mov	 eax, esi
  003e8	2b ce		 sub	 ecx, esi
  003ea	8d 9b 00 00 00
	00		 npad	 6
$LL37@GCGuildWar@2:
  003f0	8a 10		 mov	 dl, BYTE PTR [eax]
  003f2	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  003f5	40		 inc	 eax
  003f6	84 d2		 test	 dl, dl
  003f8	75 f6		 jne	 SHORT $LL37@GCGuildWar@2

; 12003: 			strcpy(lpNode->TargetGuildName, lpMyGuild->Name);

  003fa	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  003fd	8d 97 e0 04 00
	00		 lea	 edx, DWORD PTR [edi+1248]
  00403	2b d0		 sub	 edx, eax
$LL38@GCGuildWar@2:
  00405	8a 08		 mov	 cl, BYTE PTR [eax]
  00407	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0040a	40		 inc	 eax
  0040b	84 c9		 test	 cl, cl
  0040d	75 f6		 jne	 SHORT $LL38@GCGuildWar@2

; 12004: 			lpMyGuild->lpTargetGuildNode = lpNode;

  0040f	89 bb 8c 05 00
	00		 mov	 DWORD PTR [ebx+1420], edi

; 12005: 			lpNode->lpTargetGuildNode = lpMyGuild;

  00415	89 9f 8c 05 00
	00		 mov	 DWORD PTR [edi+1420], ebx
  0041b	5b		 pop	 ebx
  0041c	5f		 pop	 edi
  0041d	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  0041e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00421	33 cd		 xor	 ecx, ebp
  00423	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00428	8b e5		 mov	 esp, ebp
  0042a	5d		 pop	 ebp
  0042b	c3		 ret	 0
$LN4@GCGuildWar@2:

; 11980: 			{
; 11981: 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 199)), aIndex, 1);

  0042c	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0042f	6a 01		 push	 1
  00431	51		 push	 ecx
  00432	68 c7 04 00 00	 push	 1223			; 000004c7H
  00437	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0043c	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00441	50		 push	 eax
  00442	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 12017: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00447	83 c4 0c	 add	 esp, 12			; 0000000cH
  0044a	5b		 pop	 ebx
  0044b	5f		 pop	 edi
  0044c	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  0044d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00450	33 cd		 xor	 ecx, ebp
  00452	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00457	8b e5		 mov	 esp, ebp
  00459	5d		 pop	 ebp
  0045a	c3		 ret	 0
$LN6@GCGuildWar@2:

; 12006: 		}
; 12007: 		else
; 12008: 		{
; 12009: 			pMsg.Result = 2;

  0045b	c6 45 ef 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 12010: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 12011: 			//return;
; 12012: 		}
; 12013: 	}
; 12014: 	else

  0045f	eb 41		 jmp	 SHORT $LN57@GCGuildWar@2
$LN17@GCGuildWar@2:

; 11925: 		{
; 11926: 			pMsg.Result = 4;

  00461	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 11927: 			LogAdd(lMsg.Get(MSGGET(1, 234)), lpNode->WarState, lpNode->WarDeclareState, lpNode->Name);

  00465	0f b6 87 90 05
	00 00		 movzx	 eax, BYTE PTR [edi+1424]
  0046c	0f b6 8f 91 05
	00 00		 movzx	 ecx, BYTE PTR [edi+1425]
  00473	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00476	52		 push	 edx
  00477	50		 push	 eax
  00478	51		 push	 ecx
  00479	68 ea 01 00 00	 push	 490			; 000001eaH
  0047e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00483	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00488	50		 push	 eax
  00489	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11928: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0048f	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00493	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00496	52		 push	 edx
  00497	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0049a	50		 push	 eax
  0049b	51		 push	 ecx

; 11929: 			return;

  0049c	eb 62		 jmp	 SHORT $LN56@GCGuildWar@2
$LN19@GCGuildWar@2:

; 12015: 	{
; 12016: 		pMsg.Result = 0;

  0049e	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
$LN57@GCGuildWar@2:

; 12017: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  004a2	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  004a6	8b 4d e8	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  004a9	52		 push	 edx
  004aa	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004ad	50		 push	 eax
  004ae	51		 push	 ecx
  004af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b7	5b		 pop	 ebx
  004b8	5f		 pop	 edi
  004b9	5e		 pop	 esi

; 12018: 		return;
; 12019: 	}
; 12020: }

  004ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bd	33 cd		 xor	 ecx, ebp
  004bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c4	8b e5		 mov	 esp, ebp
  004c6	5d		 pop	 ebp
  004c7	c3		 ret	 0
$LN23@GCGuildWar@2:

; 11888: 	{
; 11889: 		pMsg.Result = 4;

  004c8	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 11890: 		LogAdd(lMsg.Get(MSGGET(1, 234)), lpMyGuild->WarState, lpMyGuild->WarDeclareState, lpMyGuild->Name);

  004cc	0f b6 83 90 05
	00 00		 movzx	 eax, BYTE PTR [ebx+1424]
  004d3	0f b6 8b 91 05
	00 00		 movzx	 ecx, BYTE PTR [ebx+1425]
  004da	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  004dd	52		 push	 edx
  004de	50		 push	 eax
  004df	51		 push	 ecx
  004e0	68 ea 01 00 00	 push	 490			; 000001eaH
  004e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004ea	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004ef	50		 push	 eax
  004f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11891: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  004f6	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  004fa	52		 push	 edx
  004fb	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004fe	50		 push	 eax
  004ff	57		 push	 edi
$LN56@GCGuildWar@2:
  00500	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00505	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN55@GCGuildWar@2:

; 12018: 		return;
; 12019: 	}
; 12020: }

  00508	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050b	5b		 pop	 ebx
  0050c	5f		 pop	 edi
  0050d	33 cd		 xor	 ecx, ebp
  0050f	5e		 pop	 esi
  00510	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00515	8b e5		 mov	 esp, ebp
  00517	5d		 pop	 ebp
  00518	c3		 ret	 0
?GCGuildWarRequestResult@@YAXPADHH@Z ENDP		; GCGuildWarRequestResult
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?GetBattleTeamScore@@YAHHH@Z:PROC		; GetBattleTeamScore
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z:PROC ; gSetBattleTeamMaster
EXTRN	?BattleSoccerGoalEnd@@YAXH@Z:PROC		; BattleSoccerGoalEnd
EXTRN	?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?gBSGround@@3PAPAVCBattleSoccer@@A:DWORD	; gBSGround
EXTRN	?gCheckBlankBattleGround@@YAHXZ:PROC		; gCheckBlankBattleGround
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
; Function compile flags: /Ogtp
;	COMDAT ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$ = -300					; size = 4
_pResult$248616 = -300					; size = 4
tv640 = -296						; size = 4
_pResult$248631 = -296					; size = 4
_pResult$248605 = -296					; size = 4
_pNotice$248611 = -292					; size = 272
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z PROC ; GCGuildWarRequestSendRecv, COMDAT

; 12044: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 12045: //#if(GS_CASTLE == 1)
; 12046: //	return;
; 12047: //#endif
; 12048: 
; 12049: 	PMSG_GUILDWAR_DECLARE pMsg;
; 12050: 	int count=0;
; 12051: 	int g_call=0;
; 12052: 	
; 12053: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof(pMsg));

  0001c	6a 0d		 push	 13			; 0000000dH
  0001e	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00021	6a 62		 push	 98			; 00000062H
  00023	50		 push	 eax

; 12054: 	pMsg.Type = 0;
; 12055: 	
; 12056: 	_GUILD_INFO_STRUCT * lpMyNode = gObj[aIndex].lpGuild;

  00024	89 b5 d4 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], esi
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0002f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	33 db		 xor	 ebx, ebx
  0003d	88 5d f7	 mov	 BYTE PTR _pMsg$[ebp+11], bl
  00040	89 b5 d8 fe ff
	ff		 mov	 DWORD PTR tv640[ebp], esi
  00046	8b b4 0e 38 04
	00 00		 mov	 esi, DWORD PTR [esi+ecx+1080]
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12057: 
; 12058: 	if ( !lpMyNode )

  00050	3b f3		 cmp	 esi, ebx
  00052	75 3f		 jne	 SHORT $LN50@GCGuildWar@3

; 12059: 	{
; 12060: 		PMSG_GUILDWARREQUEST_RESULT pResult;
; 12061: 
; 12062: 		pResult.h.c = 0xC1;
; 12063: 		pResult.h.headcode = 0x60;
; 12064: 		pResult.h.size = sizeof(pMsg);
; 12065: 		pResult.Result = 0;
; 12066: 
; 12067: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00054	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0005a	6a 0d		 push	 13			; 0000000dH
  0005c	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$248605[ebp]
  00062	51		 push	 ecx
  00063	52		 push	 edx
  00064	c6 85 d8 fe ff
	ff c1		 mov	 BYTE PTR _pResult$248605[ebp], 193 ; 000000c1H
  0006b	66 c7 85 d9 fe
	ff ff 0d 60	 mov	 WORD PTR _pResult$248605[ebp+1], 24589 ; 0000600dH
  00074	88 9d db fe ff
	ff		 mov	 BYTE PTR _pResult$248605[ebp+3], bl
  0007a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12290: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 12291: 					}
; 12292: 				}
; 12293: 			}
; 12294: 		}
; 12295: 	}
; 12296: }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN50@GCGuildWar@3:

; 12068: 		return;
; 12069: 	}
; 12070: 
; 12071: 	if ( lpMyNode->lpTargetGuildNode && lpMsg->Result )

  00093	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00099	3b c3		 cmp	 eax, ebx
  0009b	0f 84 94 00 00
	00		 je	 $LN48@GCGuildWar@3
  000a1	38 5f 03	 cmp	 BYTE PTR [edi+3], bl
  000a4	0f 84 8b 00 00
	00		 je	 $LN48@GCGuildWar@3

; 12072: 	{
; 12073: 		int iTarGetIndex = lpMyNode->lpTargetGuildNode->Index[0];

  000aa	0f bf 80 a0 03
	00 00		 movsx	 eax, WORD PTR [eax+928]

; 12074: 
; 12075: 		if ( BC_MAP_RANGE(gObj[iTarGetIndex].MapNumber) || CC_MAP_RANGE(gObj[iTarGetIndex].MapNumber) || DS_MAP_RANGE(gObj[iTarGetIndex].MapNumber))

  000b1	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  000b7	8a 84 08 49 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+329]
  000be	3c 34		 cmp	 al, 52			; 00000034H
  000c0	74 34		 je	 SHORT $LN47@GCGuildWar@3
  000c2	3c 0b		 cmp	 al, 11			; 0000000bH
  000c4	72 0e		 jb	 SHORT $LN67@GCGuildWar@3
  000c6	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  000cb	3a c8		 cmp	 cl, al
  000cd	1b c9		 sbb	 ecx, ecx
  000cf	41		 inc	 ecx
  000d0	3b cb		 cmp	 ecx, ebx
  000d2	75 22		 jne	 SHORT $LN47@GCGuildWar@3
$LN67@GCGuildWar@3:
  000d4	3c 35		 cmp	 al, 53			; 00000035H
  000d6	74 1e		 je	 SHORT $LN47@GCGuildWar@3
  000d8	3c 12		 cmp	 al, 18			; 00000012H
  000da	72 0b		 jb	 SHORT $LN68@GCGuildWar@3
  000dc	b2 17		 mov	 dl, 23			; 00000017H
  000de	3a d0		 cmp	 dl, al
  000e0	1b c9		 sbb	 ecx, ecx
  000e2	41		 inc	 ecx
  000e3	3b cb		 cmp	 ecx, ebx
  000e5	75 0f		 jne	 SHORT $LN47@GCGuildWar@3
$LN68@GCGuildWar@3:
  000e7	3c 09		 cmp	 al, 9
  000e9	74 0b		 je	 SHORT $LN47@GCGuildWar@3
  000eb	33 c9		 xor	 ecx, ecx
  000ed	3c 20		 cmp	 al, 32			; 00000020H
  000ef	0f 94 c1	 sete	 cl
  000f2	3b cb		 cmp	 ecx, ebx
  000f4	74 3f		 je	 SHORT $LN48@GCGuildWar@3
$LN47@GCGuildWar@3:

; 12076: 		{
; 12077: 			PMSG_NOTICE pNotice;
; 12078: 
; 12079: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 199)));

  000f6	68 c7 04 00 00	 push	 1223			; 000004c7H
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00100	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00105	50		 push	 eax
  00106	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$248611[ebp]
  0010c	6a 01		 push	 1
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 12080: 
; 12081: 			DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00114	0f b6 85 dd fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$248611[ebp+1]
  0011b	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00121	50		 push	 eax
  00122	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$248611[ebp]
  00128	51		 push	 ecx
  00129	52		 push	 edx
  0012a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0012f	83 c4 18	 add	 esp, 24			; 00000018H

; 12082: 
; 12083: 			lpMsg->Result = 0;

  00132	88 5f 03	 mov	 BYTE PTR [edi+3], bl
$LN48@GCGuildWar@3:

; 12084: 		}
; 12085: 	}
; 12086: 
; 12087: 	pMsg.Type = lpMyNode->WarType;

  00135	8a 86 92 05 00
	00		 mov	 al, BYTE PTR [esi+1426]
  0013b	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 12088: 
; 12089: 	if ( lpMsg->Result == 0 )

  0013e	38 5f 03	 cmp	 BYTE PTR [edi+3], bl
  00141	0f 85 81 00 00
	00		 jne	 $LN46@GCGuildWar@3

; 12090: 	{
; 12091: 		if ( lpMyNode->lpTargetGuildNode )

  00147	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0014d	3b c3		 cmp	 eax, ebx
  0014f	0f 84 45 05 00
	00		 je	 $LN1@GCGuildWar@3

; 12092: 		{
; 12093: 			if ( lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  00155	80 b8 90 05 00
	00 01		 cmp	 BYTE PTR [eax+1424], 1
  0015c	0f 85 38 05 00
	00		 jne	 $LN1@GCGuildWar@3

; 12094: 			{
; 12095: 				lpMyNode->lpTargetGuildNode->WarDeclareState = 0;
; 12096: 				lpMyNode->WarDeclareState = 0;
; 12097: 
; 12098: 				PMSG_GUILDWARREQUEST_RESULT pResult;
; 12099: 
; 12100: 				PHeadSetB((LPBYTE)&pResult, 0x60, sizeof(pResult));

  00162	6a 04		 push	 4
  00164	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$248616[ebp]
  0016a	6a 60		 push	 96			; 00000060H
  0016c	88 98 90 05 00
	00		 mov	 BYTE PTR [eax+1424], bl
  00172	51		 push	 ecx
  00173	88 9e 90 05 00
	00		 mov	 BYTE PTR [esi+1424], bl
  00179	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12101: 				pResult.Result = 6;
; 12102: 
; 12103: 				if ( lpMyNode->lpTargetGuildNode->Index[0] >= 0 )

  0017e	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  00184	c6 85 d7 fe ff
	ff 06		 mov	 BYTE PTR _pResult$248616[ebp+3], 6
  0018b	0f b7 82 a0 03
	00 00		 movzx	 eax, WORD PTR [edx+928]
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
  00195	66 3b c3	 cmp	 ax, bx
  00198	0f 8c fc 04 00
	00		 jl	 $LN1@GCGuildWar@3

; 12104: 				{
; 12105: 					DataSend(lpMyNode->lpTargetGuildNode->Index[0], (LPBYTE)&pResult, pResult.h.size);

  0019e	0f b6 8d d5 fe
	ff ff		 movzx	 ecx, BYTE PTR _pResult$248616[ebp+1]
  001a5	51		 push	 ecx
  001a6	8d 95 d4 fe ff
	ff		 lea	 edx, DWORD PTR _pResult$248616[ebp]
  001ac	98		 cwde
  001ad	52		 push	 edx
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12290: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 12291: 					}
; 12292: 				}
; 12293: 			}
; 12294: 		}
; 12295: 	}
; 12296: }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN46@GCGuildWar@3:

; 12106: 				}
; 12107: 			}
; 12108: 		}
; 12109: 	}
; 12110: 	else
; 12111: 	{
; 12112: 		if ( lpMyNode->WarDeclareState == 1 )

  001c8	80 be 90 05 00
	00 01		 cmp	 BYTE PTR [esi+1424], 1
  001cf	0f 85 c5 04 00
	00		 jne	 $LN1@GCGuildWar@3

; 12113: 		{
; 12114: 			if ( lpMyNode->lpTargetGuildNode )

  001d5	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  001db	3b c3		 cmp	 eax, ebx
  001dd	0f 84 b7 04 00
	00		 je	 $LN1@GCGuildWar@3

; 12115: 			{
; 12116: 				if (lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  001e3	80 b8 90 05 00
	00 01		 cmp	 BYTE PTR [eax+1424], 1
  001ea	0f 85 aa 04 00
	00		 jne	 $LN1@GCGuildWar@3

; 12117: 				{
; 12118: 					PMSG_TELEPORT pTeleportMsg;
; 12119: 
; 12120: 					if ( lpMyNode->WarType == 1 )

  001f0	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  001f7	0f 85 98 00 00
	00		 jne	 $LN38@GCGuildWar@3

; 12121: 					{
; 12122: 						lpMyNode->BattleGroundIndex = gCheckBlankBattleGround();

  001fd	e8 00 00 00 00	 call	 ?gCheckBlankBattleGround@@YAHXZ ; gCheckBlankBattleGround
  00202	88 86 93 05 00
	00		 mov	 BYTE PTR [esi+1427], al

; 12123: 
; 12124: 						switch ( lpMyNode->BattleGroundIndex )

  00208	3c ff		 cmp	 al, 255			; 000000ffH
  0020a	0f 84 69 01 00
	00		 je	 $LN35@GCGuildWar@3

; 12138: 								return;
; 12139: 						}
; 12140: 	
; 12141: 						pTeleportMsg.MoveNumber = 51;
; 12142: 						lpMyNode->lpTargetGuildNode->BattleGroundIndex = lpMyNode->BattleGroundIndex;

  00210	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  00216	88 81 93 05 00
	00		 mov	 BYTE PTR [ecx+1427], al

; 12143: 
; 12144: 						if ( gBSGround[0]->m_BallIndex >= 0 )

  0021c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A ; gBSGround
  00222	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00225	3b c3		 cmp	 eax, ebx
  00227	7c 15		 jl	 SHORT $LN34@GCGuildWar@3

; 12145: 						{
; 12146: 							gObjMonsterRegen(&gObj[gBSGround[0]->m_BallIndex]);

  00229	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  0022f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  0023b	83 c4 04	 add	 esp, 4
$LN34@GCGuildWar@3:

; 12147: 						}
; 12148: 
; 12149: 						BattleSoccerGoalEnd(0);

  0023e	53		 push	 ebx
  0023f	e8 00 00 00 00	 call	 ?BattleSoccerGoalEnd@@YAXH@Z ; BattleSoccerGoalEnd

; 12150: 						lpMyNode->PlayScore = 0;
; 12151: 						lpMyNode->lpTargetGuildNode->PlayScore = 0;

  00244	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0024a	88 9e 95 05 00
	00		 mov	 BYTE PTR [esi+1429], bl
  00250	88 98 95 05 00
	00		 mov	 BYTE PTR [eax+1429], bl

; 12152: 						gBattleGroundEnable(lpMyNode->BattleGroundIndex, TRUE);

  00256	0f b6 8e 93 05
	00 00		 movzx	 ecx, BYTE PTR [esi+1427]
  0025d	6a 01		 push	 1
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 12153: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 0, lpMyNode->Name, lpMyNode);

  00265	0f b6 86 93 05
	00 00		 movzx	 eax, BYTE PTR [esi+1427]
  0026c	56		 push	 esi
  0026d	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00270	52		 push	 edx
  00271	53		 push	 ebx
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster

; 12154: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 1, lpMyNode->lpTargetGuildNode->Name, lpMyNode->lpTargetGuildNode);

  00278	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0027e	0f b6 8e 93 05
	00 00		 movzx	 ecx, BYTE PTR [esi+1427]
  00285	50		 push	 eax
  00286	83 c0 04	 add	 eax, 4
  00289	50		 push	 eax
  0028a	6a 01		 push	 1
  0028c	51		 push	 ecx
  0028d	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster
  00292	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN38@GCGuildWar@3:

; 12155: 					}
; 12156: 
; 12157: 					lpMyNode->WarDeclareState = 2;
; 12158: 					lpMyNode->WarState = 1;
; 12159: 					lpMyNode->lpTargetGuildNode->WarDeclareState = 2;

  00295	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  0029b	66 c7 86 90 05
	00 00 02 01	 mov	 WORD PTR [esi+1424], 258 ; 00000102H
  002a4	b0 02		 mov	 al, 2
  002a6	88 82 90 05 00
	00		 mov	 BYTE PTR [edx+1424], al

; 12160: 					lpMyNode->lpTargetGuildNode->WarState = 1;

  002ac	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002b2	c6 80 91 05 00
	00 01		 mov	 BYTE PTR [eax+1425], 1

; 12161: 					lpMyNode->PlayScore = 0;
; 12162: 					lpMyNode->lpTargetGuildNode->PlayScore = 0;

  002b9	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  002bf	88 9e 95 05 00
	00		 mov	 BYTE PTR [esi+1429], bl
  002c5	88 99 95 05 00
	00		 mov	 BYTE PTR [ecx+1429], bl

; 12163: 					lpMyNode->BattleTeamCode = 0;
; 12164: 					lpMyNode->lpTargetGuildNode->BattleTeamCode = 1;

  002cb	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  002d1	88 9e 94 05 00
	00		 mov	 BYTE PTR [esi+1428], bl
  002d7	c6 82 94 05 00
	00 01		 mov	 BYTE PTR [edx+1428], 1

; 12165: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));

  002de	33 c0		 xor	 eax, eax
  002e0	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  002e3	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 12166: 					memcpy(pMsg.GuildName, lpMyNode->lpTargetGuildNode->Name, sizeof(pMsg.GuildName));

  002e6	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002ec	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ef	89 4d ef	 mov	 DWORD PTR _pMsg$[ebp+3], ecx
  002f2	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002f5	89 55 f3	 mov	 DWORD PTR _pMsg$[ebp+7], edx

; 12167: 					pMsg.TeamCode = lpMyNode->BattleTeamCode;

  002f8	8a 86 94 05 00
	00		 mov	 al, BYTE PTR [esi+1428]

; 12168: 					count = 0;
; 12169: 
; 12170: 					for ( int n=0;n<MAX_USER_GUILD;n++)

  002fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00304	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  00307	33 ff		 xor	 edi, edi
  00309	8d a4 24 00 00
	00 00		 npad	 7
$LL33@GCGuildWar@3:

; 12171: 					{
; 12172: 						if ( lpMyNode->Use[n] )

  00310	38 9c 3e 40 04
	00 00		 cmp	 BYTE PTR [esi+edi+1088], bl
  00317	0f 84 75 01 00
	00		 je	 $LN32@GCGuildWar@3

; 12173: 						{
; 12174: 							if ( lpMyNode->Index[n] >= 0 )

  0031d	0f b7 84 7e a0
	03 00 00	 movzx	 eax, WORD PTR [esi+edi*2+928]
  00325	66 3b c3	 cmp	 ax, bx
  00328	0f 8c 64 01 00
	00		 jl	 $LN32@GCGuildWar@3

; 12175: 							{
; 12176: 								g_call = 0;
; 12177: 
; 12178: 								if ( n > 0 )

  0032e	3b fb		 cmp	 edi, ebx
  00330	0f 8e a8 00 00
	00		 jle	 $LN76@GCGuildWar@3

; 12179: 								{
; 12180: 									if ( lpMyNode->WarType == 1 )

  00336	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0033d	0f 85 a1 00 00
	00		 jne	 $LN69@GCGuildWar@3

; 12181: 									{
; 12182: 										if ( gObj[lpMyNode->Index[0]].PartyNumber  >= 0 )

  00343	0f bf 8e a0 03
	00 00		 movsx	 ecx, WORD PTR [esi+928]
  0034a	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00350	8b 8c 11 2c 04
	00 00		 mov	 ecx, DWORD PTR [ecx+edx+1068]
  00357	3b cb		 cmp	 ecx, ebx
  00359	0f 8c 33 01 00
	00		 jl	 $LN32@GCGuildWar@3

; 12183: 										{
; 12184: 											if ( gObj[lpMyNode->Index[0]].PartyNumber == gObj[lpMyNode->Index[n]].PartyNumber )

  0035f	0f bf d8	 movsx	 ebx, ax
  00362	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00368	3b 8c 13 2c 04
	00 00		 cmp	 ecx, DWORD PTR [ebx+edx+1068]
  0036f	0f 85 1b 01 00
	00		 jne	 $LN74@GCGuildWar@3

; 12185: 											{
; 12186: 												g_call = 1;
; 12187: 											}
; 12188: 										}
; 12189: 									}
; 12190: 									else 

  00375	33 db		 xor	 ebx, ebx
  00377	eb 6b		 jmp	 SHORT $LN69@GCGuildWar@3
$LN35@GCGuildWar@3:

; 12125: 						{
; 12126: 							case 0xFF:
; 12127: 								lpMyNode->WarDeclareState = 0;
; 12128: 								lpMyNode->WarState = 0;
; 12129: 								lpMyNode->lpTargetGuildNode->WarDeclareState = 0;

  00379	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  0037f	66 89 9e 90 05
	00 00		 mov	 WORD PTR [esi+1424], bx

; 12130: 								lpMyNode->lpTargetGuildNode->WarState = 0;
; 12131: 
; 12132: 								PMSG_GUILDWARREQUEST_RESULT pResult;
; 12133: 
; 12134: 								PHeadSetB((LPBYTE)&pResult, 0x60, sizeof(pResult));

  00386	6a 04		 push	 4
  00388	88 9a 90 05 00
	00		 mov	 BYTE PTR [edx+1424], bl
  0038e	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00394	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$248631[ebp]
  0039a	6a 60		 push	 96			; 00000060H
  0039c	51		 push	 ecx
  0039d	88 98 91 05 00
	00		 mov	 BYTE PTR [eax+1425], bl
  003a3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12135: 								pResult.Result = 4;
; 12136: 
; 12137: 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003a8	0f b6 95 d9 fe
	ff ff		 movzx	 edx, BYTE PTR _pResult$248631[ebp+1]
  003af	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  003b5	52		 push	 edx
  003b6	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$248631[ebp]
  003bc	50		 push	 eax
  003bd	51		 push	 ecx
  003be	c6 85 db fe ff
	ff 04		 mov	 BYTE PTR _pResult$248631[ebp+3], 4
  003c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003ca	83 c4 18	 add	 esp, 24			; 00000018H
  003cd	5f		 pop	 edi
  003ce	5e		 pop	 esi
  003cf	5b		 pop	 ebx

; 12291: 					}
; 12292: 				}
; 12293: 			}
; 12294: 		}
; 12295: 	}
; 12296: }

  003d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d3	33 cd		 xor	 ecx, ebp
  003d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003da	8b e5		 mov	 esp, ebp
  003dc	5d		 pop	 ebp
  003dd	c3		 ret	 0
$LN76@GCGuildWar@3:

; 12191: 									{
; 12192: 										g_call = 1;
; 12193: 									}
; 12194: 								}
; 12195: 								else if ( n== 0 )

  003de	0f 85 ae 00 00
	00		 jne	 $LN32@GCGuildWar@3
$LN69@GCGuildWar@3:

; 12196: 								{
; 12197: 									g_call = 1;
; 12198: 								}
; 12199: 
; 12200: 								if ( g_call )
; 12201: 								{
; 12202: 									DataSend(lpMyNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  003e4	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  003e8	52		 push	 edx
  003e9	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  003ec	0f bf d0	 movsx	 edx, ax
  003ef	51		 push	 ecx
  003f0	52		 push	 edx
  003f1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12203: 
; 12204: 									// Declared guild war against (%s)
; 12205: 									LogAddTD(lMsg.Get(MSGGET(1, 238)), lpMyNode->Name);

  003f9	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  003fc	50		 push	 eax
  003fd	68 ee 01 00 00	 push	 494			; 000001eeH
  00402	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00407	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0040c	50		 push	 eax
  0040d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12206: 									GCGuildWarScore(lpMyNode->Index[n]);

  00413	0f bf 8c 7e a0
	03 00 00	 movsx	 ecx, WORD PTR [esi+edi*2+928]
  0041b	51		 push	 ecx
  0041c	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12207: 									int x = 60;
; 12208: 
; 12209: 									if ( lpMyNode->WarType == 1 )

  00424	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0042b	75 5b		 jne	 SHORT $LN71@GCGuildWar@3

; 12210: 									{
; 12211: 										gObj[lpMyNode->Index[n]].IsInBattleGround = true;

  0042d	0f bf 94 7e a0
	03 00 00	 movsx	 edx, WORD PTR [esi+edi*2+928]
  00435	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043a	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00440	c6 84 02 46 10
	00 00 01	 mov	 BYTE PTR [edx+eax+4166], 1

; 12212: 										pTeleportMsg.MoveNumber = 51;
; 12213: 
; 12214: 										if ( gPkLimitFree || gObj[lpMyNode->Index[n]].m_PK_Level < 6 )

  00448	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, ebx ; gPkLimitFree
  0044e	75 1e		 jne	 SHORT $LN18@GCGuildWar@3
  00450	0f bf 8c 7e a0
	03 00 00	 movsx	 ecx, WORD PTR [esi+edi*2+928]
  00458	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0045e	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  00464	80 bc 11 3d 01
	00 00 06	 cmp	 BYTE PTR [ecx+edx+317], 6
  0046c	7d 24		 jge	 SHORT $LN32@GCGuildWar@3
$LN18@GCGuildWar@3:

; 12215: 										{
; 12216: 											gObjTeleport(lpMyNode->Index[n], 6, x++, 153);

  0046e	0f bf 94 7e a0
	03 00 00	 movsx	 edx, WORD PTR [esi+edi*2+928]
  00476	68 99 00 00 00	 push	 153			; 00000099H
  0047b	6a 3c		 push	 60			; 0000003cH
  0047d	6a 06		 push	 6
  0047f	52		 push	 edx
  00480	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  00485	83 c4 10	 add	 esp, 16			; 00000010H
$LN71@GCGuildWar@3:
  00488	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0048e	eb 02		 jmp	 SHORT $LN32@GCGuildWar@3
$LN74@GCGuildWar@3:
  00490	33 db		 xor	 ebx, ebx
$LN32@GCGuildWar@3:

; 12168: 					count = 0;
; 12169: 
; 12170: 					for ( int n=0;n<MAX_USER_GUILD;n++)

  00492	47		 inc	 edi
  00493	83 ff 50	 cmp	 edi, 80			; 00000050H
  00496	0f 8c 74 fe ff
	ff		 jl	 $LL33@GCGuildWar@3

; 12217: 											count++;
; 12218: 										}
; 12219: 									}
; 12220: 								}
; 12221: 							}
; 12222: 						}
; 12223: 					}
; 12224: 
; 12225: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));

  0049c	33 c0		 xor	 eax, eax
  0049e	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  004a1	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 12226: 					memcpy(pMsg.GuildName, lpMyNode->Name, sizeof(pMsg.GuildName));

  004a4	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  004a7	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  004aa	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004ad	89 4d f3	 mov	 DWORD PTR _pMsg$[ebp+7], ecx

; 12227: 
; 12228: 					pMsg.TeamCode = lpMyNode->lpTargetGuildNode->BattleTeamCode;

  004b0	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  004b6	8a 88 94 05 00
	00		 mov	 cl, BYTE PTR [eax+1428]
  004bc	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+12], cl

; 12229: 					count = 0;
; 12230: 
; 12231: 					for (int n=0;n<MAX_USER_GUILD;n++)

  004bf	33 ff		 xor	 edi, edi
$LL17@GCGuildWar@3:

; 12232: 					{
; 12233: 						if ( lpMyNode->lpTargetGuildNode->Use[n] )

  004c1	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  004c7	38 9c 39 40 04
	00 00		 cmp	 BYTE PTR [ecx+edi+1088], bl
  004ce	0f 84 1b 01 00
	00		 je	 $LN16@GCGuildWar@3

; 12234: 						{
; 12235: 							if ( lpMyNode->lpTargetGuildNode->Index[n] >= 0 )

  004d4	0f b7 84 79 a0
	03 00 00	 movzx	 eax, WORD PTR [ecx+edi*2+928]
  004dc	66 3b c3	 cmp	 ax, bx
  004df	0f 8c 0a 01 00
	00		 jl	 $LN16@GCGuildWar@3

; 12236: 							{
; 12237: 								g_call = 0;
; 12238: 
; 12239: 								if ( n > 0 )

  004e5	3b fb		 cmp	 edi, ebx
  004e7	7e 3f		 jle	 SHORT $LN77@GCGuildWar@3

; 12240: 								{
; 12241: 									if ( lpMyNode->WarType == 1 )

  004e9	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  004f0	75 3c		 jne	 SHORT $LN70@GCGuildWar@3

; 12242: 									{
; 12243: 										if ( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber  >= 0 )

  004f2	0f bf 89 a0 03
	00 00		 movsx	 ecx, WORD PTR [ecx+928]
  004f9	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  004ff	8b 8c 11 2c 04
	00 00		 mov	 ecx, DWORD PTR [ecx+edx+1068]
  00506	3b cb		 cmp	 ecx, ebx
  00508	0f 8c e1 00 00
	00		 jl	 $LN16@GCGuildWar@3

; 12244: 										{
; 12245: 											if ( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber == gObj[lpMyNode->lpTargetGuildNode->Index[n]].PartyNumber )

  0050e	0f bf d8	 movsx	 ebx, ax
  00511	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00517	3b 8c 13 2c 04
	00 00		 cmp	 ecx, DWORD PTR [ebx+edx+1068]
  0051e	0f 85 c9 00 00
	00		 jne	 $LN73@GCGuildWar@3

; 12246: 											{
; 12247: 												g_call = 1;
; 12248: 											}
; 12249: 										}
; 12250: 									}
; 12251: 									else 

  00524	33 db		 xor	 ebx, ebx
  00526	eb 06		 jmp	 SHORT $LN70@GCGuildWar@3
$LN77@GCGuildWar@3:

; 12252: 									{
; 12253: 										g_call = 1;
; 12254: 									}
; 12255: 								}
; 12256: 								else if ( n== 0 )

  00528	0f 85 c1 00 00
	00		 jne	 $LN16@GCGuildWar@3
$LN70@GCGuildWar@3:

; 12257: 								{
; 12258: 									g_call = 1;
; 12259: 								}
; 12260: 
; 12261: 								if ( g_call )
; 12262: 								{
; 12263: 									DataSend(lpMyNode->lpTargetGuildNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  0052e	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00532	52		 push	 edx
  00533	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00536	0f bf d0	 movsx	 edx, ax
  00539	51		 push	 ecx
  0053a	52		 push	 edx
  0053b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 12264: 
; 12265: 									LogAddTD(lMsg.Get(MSGGET(1, 238)), lpMyNode->lpTargetGuildNode->Name);

  00540	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00546	83 c4 0c	 add	 esp, 12			; 0000000cH
  00549	83 c0 04	 add	 eax, 4
  0054c	50		 push	 eax
  0054d	68 ee 01 00 00	 push	 494			; 000001eeH
  00552	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00557	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0055c	50		 push	 eax
  0055d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12266: 									GCGuildWarScore(lpMyNode->lpTargetGuildNode->Index[n]);

  00563	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  00569	0f bf 94 79 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+edi*2+928]
  00571	52		 push	 edx
  00572	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore

; 12267: 									int x = 59;
; 12268: 
; 12269: 									if ( lpMyNode->lpTargetGuildNode->WarType == 1 )

  00577	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]

; 12270: 									{
; 12271: 
; 12272: 										if ( gPkLimitFree != 0 || gObj[lpMyNode->lpTargetGuildNode->Index[n]].m_PK_Level < 6 )

  0057d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00583	83 c4 0c	 add	 esp, 12			; 0000000cH
  00586	80 b8 92 05 00
	00 01		 cmp	 BYTE PTR [eax+1426], 1
  0058d	75 60		 jne	 SHORT $LN16@GCGuildWar@3
  0058f	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, ebx ; gPkLimitFree
  00595	75 18		 jne	 SHORT $LN2@GCGuildWar@3
  00597	0f bf 8c 78 a0
	03 00 00	 movsx	 ecx, WORD PTR [eax+edi*2+928]
  0059f	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  005a5	80 bc 11 3d 01
	00 00 06	 cmp	 BYTE PTR [ecx+edx+317], 6
  005ad	7d 40		 jge	 SHORT $LN16@GCGuildWar@3
$LN2@GCGuildWar@3:

; 12273: 										{
; 12274: 											gObj[lpMyNode->lpTargetGuildNode->Index[n]].IsInBattleGround = true;

  005af	0f bf 84 78 a0
	03 00 00	 movsx	 eax, WORD PTR [eax+edi*2+928]
  005b7	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  005bd	c6 84 10 46 10
	00 00 01	 mov	 BYTE PTR [eax+edx+4166], 1

; 12275: 											gObjTeleport(lpMyNode->lpTargetGuildNode->Index[n], 6, x++, 164);

  005c5	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  005cb	0f bf 94 79 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+edi*2+928]
  005d3	68 a4 00 00 00	 push	 164			; 000000a4H
  005d8	6a 3b		 push	 59			; 0000003bH
  005da	6a 06		 push	 6
  005dc	52		 push	 edx
  005dd	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  005e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005e8	83 c4 10	 add	 esp, 16			; 00000010H
  005eb	eb 02		 jmp	 SHORT $LN16@GCGuildWar@3
$LN73@GCGuildWar@3:
  005ed	33 db		 xor	 ebx, ebx
$LN16@GCGuildWar@3:

; 12229: 					count = 0;
; 12230: 
; 12231: 					for (int n=0;n<MAX_USER_GUILD;n++)

  005ef	47		 inc	 edi
  005f0	83 ff 50	 cmp	 edi, 80			; 00000050H
  005f3	0f 8c c8 fe ff
	ff		 jl	 $LL17@GCGuildWar@3

; 12276: 											count++;
; 12277: 										}
; 12278: 									}
; 12279: 								}
; 12280: 							}
; 12281: 						}
; 12282: 					}
; 12283: 
; 12284: 					cManager.BattleInfoSend(GetBattleTeamName(0,0), GetBattleTeamScore(0,0), GetBattleTeamName(0, 1), GetBattleTeamScore(0,1));

  005f9	6a 01		 push	 1
  005fb	53		 push	 ebx
  005fc	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  00601	83 c4 08	 add	 esp, 8
  00604	50		 push	 eax
  00605	6a 01		 push	 1
  00607	53		 push	 ebx
  00608	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  0060d	83 c4 08	 add	 esp, 8
  00610	50		 push	 eax
  00611	53		 push	 ebx
  00612	53		 push	 ebx
  00613	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  00618	83 c4 08	 add	 esp, 8
  0061b	50		 push	 eax
  0061c	53		 push	 ebx
  0061d	53		 push	 ebx
  0061e	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  00623	83 c4 08	 add	 esp, 8
  00626	50		 push	 eax
  00627	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  0062c	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend

; 12285: 
; 12286: 					if ( lpMyNode->WarType == 1 )

  00631	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  00638	75 60		 jne	 SHORT $LN1@GCGuildWar@3

; 12287: 					{
; 12288: 						gObjAddMsgSendDelay(&gObj[aIndex], 5, aIndex, 10000, 0);

  0063a	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00640	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv640[ebp]
  00646	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0064c	53		 push	 ebx
  0064d	68 10 27 00 00	 push	 10000			; 00002710H
  00652	50		 push	 eax
  00653	6a 05		 push	 5
  00655	52		 push	 edx
  00656	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0065b	83 c4 14	 add	 esp, 20			; 00000014H

; 12289: 						GCServerMsgStringSendGuild(lpMyNode->lpTargetGuildNode,lMsg.Get(MSGGET(4, 130)), 1);

  0065e	6a 01		 push	 1
  00660	68 82 04 00 00	 push	 1154			; 00000482H
  00665	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0066a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0066f	50		 push	 eax
  00670	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00676	50		 push	 eax
  00677	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  0067c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12290: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  0067f	6a 01		 push	 1
  00681	68 82 04 00 00	 push	 1154			; 00000482H
  00686	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0068b	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00690	50		 push	 eax
  00691	56		 push	 esi
  00692	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  00697	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar@3:

; 12291: 					}
; 12292: 				}
; 12293: 			}
; 12294: 		}
; 12295: 	}
; 12296: }

  0069a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0069d	5f		 pop	 edi
  0069e	5e		 pop	 esi
  0069f	33 cd		 xor	 ecx, ebp
  006a1	5b		 pop	 ebx
  006a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a7	8b e5		 mov	 esp, ebp
  006a9	5d		 pop	 ebp
  006aa	c3		 ret	 0
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ENDP ; GCGuildWarRequestSendRecv
_TEXT	ENDS
PUBLIC	??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@ ; `string'
PUBLIC	??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@ ; `string'
PUBLIC	??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
EXTRN	?GetWarehouseUsedHowMuch@@YAHHHH@Z:PROC		; GetWarehouseUsedHowMuch
EXTRN	?CheckWerehouse@CAccountSecurity@@QAE_NH@Z:PROC	; CAccountSecurity::CheckWerehouse
;	COMDAT ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@
CONST	SEGMENT
??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@ DB '['
	DB	'%s][%s] error-L1 : used not Warehouse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@
CONST	SEGMENT
??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@ DB 'Get WareHo'
	DB	'use Money(In WareHouse) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@
CONST	SEGMENT
??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@ DB 'Get WareHo'
	DB	'use Money(In Inventory) : %d - %d = %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z
_TEXT	SEGMENT
_rZen$248752 = -268					; size = 4
_aIndex$GSCopy$ = -264					; size = 4
_msg$248761 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z PROC ; CGWarehouseMoneyInOut, COMDAT

; 12367: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 12368: 	int money = 0;
; 12369: 
; 12370: 	if ( !gObjIsConnected(aIndex))

  00017	53		 push	 ebx

; 12484: 				}
; 12485: 				else
; 12486: 				{
; 12487: 					lpObj->WarehouseMoney +=money;

  00018	89 9d f8 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	75 35		 jne	 SHORT $LN25@CGWarehous@2

; 12371: 	{
; 12372: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0002a	68 54 30 00 00	 push	 12372			; 00003054H
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00039	6a 02		 push	 2
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 12373: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00041	6a 00		 push	 0
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	53		 push	 ebx
  00048	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0004d	83 c4 20	 add	 esp, 32			; 00000020H
  00050	5b		 pop	 ebx

; 12507: }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN25@CGWarehous@2:

; 12374: 		return;
; 12375: 	}
; 12376: 
; 12377: 	LPOBJ lpObj = &gObj[aIndex];

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H

; 12378: 	money = lpMsg->Money;

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0006d	56		 push	 esi
  0006e	8d 34 03	 lea	 esi, DWORD PTR [ebx+eax]

; 12379: 	
; 12380: 	if ( lpObj->m_IfState.state == 0 )

  00071	8b 86 1c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3612]
  00077	57		 push	 edi
  00078	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0007b	a8 3c		 test	 al, 60			; 0000003cH

; 12381: 	{
; 12382: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 12383: 		return;

  0007d	0f 84 c7 02 00
	00		 je	 $LN15@CGWarehous@2

; 12384: 	}
; 12385: 
; 12386: 	if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 6 )

  00083	8b d0		 mov	 edx, eax
  00085	80 e2 03	 and	 dl, 3
  00088	80 fa 01	 cmp	 dl, 1
  0008b	72 0c		 jb	 SHORT $LN22@CGWarehous@2
  0008d	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00092	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  00097	74 17		 je	 SHORT $LN28@CGWarehous@2
$LN22@CGWarehous@2:

; 12387: 	{
; 12388: #if(CUSTOM_MULTIWAREHOUSE)
; 12389: 		if (lpObj->WarehouseNumber < 0 || lpObj->WarehouseNumber > 5)

  00099	8b 86 e8 2a 00
	00		 mov	 eax, DWORD PTR [esi+10984]
  0009f	85 c0		 test	 eax, eax
  000a1	0f 88 c9 02 00
	00		 js	 $LN20@CGWarehous@2
  000a7	83 f8 05	 cmp	 eax, 5
  000aa	0f 8f c0 02 00
	00		 jg	 $LN20@CGWarehous@2
$LN28@CGWarehous@2:

; 12394: 			return;
; 12395: 		}
; 12396: 	}
; 12397: 
; 12398: 	switch ( lpMsg->Type )

  000b0	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  000b4	83 e8 00	 sub	 eax, 0
  000b7	0f 84 d5 01 00
	00		 je	 $LN17@CGWarehous@2
  000bd	48		 dec	 eax

; 12499: 
; 12500: 		default:
; 12501: 			GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 12502: 			return;

  000be	0f 85 1c 02 00
	00		 jne	 $LN31@CGWarehous@2

; 12429: 			}
; 12430: 			break;
; 12431: 		case 0x01:
; 12432: 			{
; 12433: 				if ( bCanWarehouseLock == TRUE)

  000c4	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  000cb	75 49		 jne	 SHORT $LN10@CGWarehous@2

; 12434: 				{
; 12435: 					if ( lpObj->WarehouseLock == 1)

  000cd	80 be 68 0e 00
	00 01		 cmp	 BYTE PTR [esi+3688], 1
  000d4	75 40		 jne	 SHORT $LN10@CGWarehous@2

; 12436: 					{
; 12437: 						GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  000d6	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  000dc	50		 push	 eax
  000dd	50		 push	 eax
  000de	50		 push	 eax
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 12438: 						GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index,1);

  000e5	8b 16		 mov	 edx, DWORD PTR [esi]
  000e7	83 c4 10	 add	 esp, 16			; 00000010H
  000ea	6a 01		 push	 1
  000ec	52		 push	 edx
  000ed	68 46 06 00 00	 push	 1606			; 00000646H
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx

; 12507: }

  00108	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	33 cd		 xor	 ecx, ebp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
$LN10@CGWarehous@2:

; 12439: 						return;
; 12440: 					}
; 12441: 				}
; 12442: 
; 12443: 				#if(CUSTOM_ACCOUNT_SECURITY)
; 12444: 				if(g_AccountSecurity.CheckWerehouse(aIndex) == false)

  00116	8b 9d f8 fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$[ebp]
  0011c	53		 push	 ebx
  0011d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  00122	e8 00 00 00 00	 call	 ?CheckWerehouse@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckWerehouse
  00127	84 c0		 test	 al, al

; 12445: 				{
; 12446: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 12447: 					//GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index,1);
; 12448: 					return;

  00129	0f 84 43 01 00
	00		 je	 $LN7@CGWarehous@2

; 12449: 				}
; 12450: 				#endif
; 12451: 
; 12452: 				if ( money <= 0 || money > MAX_WAREHOUSE_ZEN )

  0012f	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00132	3d ff 93 35 77	 cmp	 eax, 1999999999		; 773593ffH
  00137	0f 87 35 01 00
	00		 ja	 $LN7@CGWarehous@2

; 12455: 					return;
; 12456: 				}
; 12457: 				
; 12458: 				if ( money > lpObj->WarehouseMoney )

  0013d	8b 86 6c 0e 00
	00		 mov	 eax, DWORD PTR [esi+3692]
  00143	3b f8		 cmp	 edi, eax

; 12459: 				{
; 12460: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 12461: 					return;

  00145	0f 8f 27 01 00
	00		 jg	 $LN7@CGWarehous@2

; 12462: 				}
; 12463: 
; 12464: 				lpObj->WarehouseMoney -= money;
; 12465: 				lpObj->Money += money;
; 12466: 				int rZen = GetWarehouseUsedHowMuch(lpObj->Level, lpObj->MLevel, lpObj->WarehousePW);

  0014b	0f bf 8e 66 0e
	00 00		 movsx	 ecx, WORD PTR [esi+3686]
  00152	0f bf 96 d0 00
	00 00		 movsx	 edx, WORD PTR [esi+208]
  00159	01 be f0 00 00
	00		 add	 DWORD PTR [esi+240], edi
  0015f	2b c7		 sub	 eax, edi
  00161	89 86 6c 0e 00
	00		 mov	 DWORD PTR [esi+3692], eax
  00167	0f bf 86 be 00
	00 00		 movsx	 eax, WORD PTR [esi+190]
  0016e	51		 push	 ecx
  0016f	52		 push	 edx
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 12467: 
; 12468: 				if ( (lpObj->Money-rZen) > 0 )

  00176	8b 9e f0 00 00
	00		 mov	 ebx, DWORD PTR [esi+240]
  0017c	8b cb		 mov	 ecx, ebx
  0017e	2b c8		 sub	 ecx, eax
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH
  00183	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _rZen$248752[ebp], eax
  00189	85 c9		 test	 ecx, ecx
  0018b	7e 31		 jle	 SHORT $LN5@CGWarehous@2

; 12469: 				{
; 12470: 					int oldmoney = lpObj->Money;
; 12471: 					lpObj->Money -= rZen;
; 12472: 					GCMoneySend(lpObj->m_Index, lpObj->Money);

  0018d	51		 push	 ecx
  0018e	89 8e f0 00 00
	00		 mov	 DWORD PTR [esi+240], ecx
  00194	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 12473: 					
; 12474: 					LogAdd("Get WareHouse Money(In Inventory) : %d - %d = %d", oldmoney, rZen, lpObj->Money);

  0019c	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  001a2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _rZen$248752[ebp]
  001a8	52		 push	 edx
  001a9	50		 push	 eax
  001aa	53		 push	 ebx
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001b6	83 c4 18	 add	 esp, 24			; 00000018H
  001b9	e9 56 01 00 00	 jmp	 $LN18@CGWarehous@2
$LN5@CGWarehous@2:

; 12475: 				}
; 12476: 				else if ( (lpObj->WarehouseMoney-rZen) > 0 )

  001be	8b 96 6c 0e 00
	00		 mov	 edx, DWORD PTR [esi+3692]
  001c4	8b ca		 mov	 ecx, edx
  001c6	2b c8		 sub	 ecx, eax
  001c8	85 c9		 test	 ecx, ecx
  001ca	7e 38		 jle	 SHORT $LN3@CGWarehous@2

; 12477: 				{
; 12478: 					int oldmoney = lpObj->WarehouseMoney;
; 12479: 					lpObj->WarehouseMoney -= rZen;
; 12480: 
; 12481: 					LogAdd("Get WareHouse Money(In WareHouse) : %d - %d = %d", oldmoney, rZen, lpObj->WarehouseMoney);

  001cc	51		 push	 ecx
  001cd	50		 push	 eax
  001ce	52		 push	 edx
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@
  001d4	89 8e 6c 0e 00
	00		 mov	 DWORD PTR [esi+3692], ecx
  001da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 12482: 
; 12483: 					GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  001e0	8b 8e 6c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3692]
  001e6	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  001ec	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  001f2	51		 push	 ecx
  001f3	52		 push	 edx
  001f4	6a 01		 push	 1
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  001fc	83 c4 20	 add	 esp, 32			; 00000020H

; 12495: 					return;
; 12496: 				}
; 12497: 			}
; 12498: 			break;

  001ff	e9 10 01 00 00	 jmp	 $LN18@CGWarehous@2
$LN3@CGWarehous@2:

; 12488: 					lpObj->Money -= money;
; 12489: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00204	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  0020a	6a 00		 push	 0
  0020c	6a 00		 push	 0
  0020e	03 d7		 add	 edx, edi
  00210	6a 00		 push	 0
  00212	2b df		 sub	 ebx, edi
  00214	51		 push	 ecx
  00215	89 96 6c 0e 00
	00		 mov	 DWORD PTR [esi+3692], edx
  0021b	89 9e f0 00 00
	00		 mov	 DWORD PTR [esi+240], ebx
  00221	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 12490: 
; 12491: 					char msg[255];
; 12492: 
; 12493: 					wsprintf(msg, lMsg.Get(MSGGET(6, 69)), rZen);

  00226	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _rZen$248752[ebp]
  0022c	83 c4 10	 add	 esp, 16			; 00000010H
  0022f	52		 push	 edx
  00230	68 45 06 00 00	 push	 1605			; 00000645H
  00235	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0023a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0023f	50		 push	 eax
  00240	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$248761[ebp]
  00246	50		 push	 eax
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 12494: 					GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  0024d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0024f	6a 01		 push	 1
  00251	51		 push	 ecx
  00252	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$248761[ebp]
  00258	52		 push	 edx
  00259	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0025e	83 c4 18	 add	 esp, 24			; 00000018H
  00261	5f		 pop	 edi
  00262	5e		 pop	 esi
  00263	5b		 pop	 ebx

; 12507: }

  00264	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00267	33 cd		 xor	 ecx, ebp
  00269	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026e	8b e5		 mov	 esp, ebp
  00270	5d		 pop	 ebp
  00271	c3		 ret	 0
$LN7@CGWarehous@2:

; 12453: 				{
; 12454: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00272	6a 00		 push	 0
  00274	6a 00		 push	 0
  00276	6a 00		 push	 0
  00278	53		 push	 ebx
  00279	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0027e	83 c4 10	 add	 esp, 16			; 00000010H
  00281	5f		 pop	 edi
  00282	5e		 pop	 esi
  00283	5b		 pop	 ebx

; 12507: }

  00284	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00287	33 cd		 xor	 ecx, ebp
  00289	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
$LN17@CGWarehous@2:

; 12399: 	{
; 12400: 		case 0x00:
; 12401: 			{
; 12402: 				if ( money <= 0 || money > MAX_WAREHOUSE_ZEN )

  00292	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00295	3d ff 93 35 77	 cmp	 eax, 1999999999		; 773593ffH
  0029a	0f 87 aa 00 00
	00		 ja	 $LN15@CGWarehous@2

; 12405: 					return;
; 12406: 				}
; 12407: #if(FIX_ZEN_MOVE==TRUE)
; 12408: 				unsigned long long totalzen = lpObj->WarehouseMoney + money;

  002a0	8b 8e 6c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3692]
  002a6	03 cf		 add	 ecx, edi

; 12409: 				if ( totalzen > MAX_WAREHOUSE_ZEN )

  002a8	81 f9 00 94 35
	77		 cmp	 ecx, 2000000000		; 77359400H
  002ae	76 26		 jbe	 SHORT $LN14@CGWarehous@2

; 12410: 				{
; 12411: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  002b0	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  002b6	6a 00		 push	 0
  002b8	6a 00		 push	 0
  002ba	6a 00		 push	 0
  002bc	52		 push	 edx
  002bd	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  002c2	83 c4 10	 add	 esp, 16			; 00000010H
  002c5	5f		 pop	 edi
  002c6	5e		 pop	 esi
  002c7	5b		 pop	 ebx

; 12507: }

  002c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cb	33 cd		 xor	 ecx, ebp
  002cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d2	8b e5		 mov	 esp, ebp
  002d4	5d		 pop	 ebp
  002d5	c3		 ret	 0
$LN14@CGWarehous@2:

; 12412: 					return;
; 12413: 				}
; 12414: #else				
; 12415: 				if ( (lpObj->WarehouseMoney+money) > MAX_WAREHOUSE_ZEN )
; 12416: 				{
; 12417: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 12418: 					return;
; 12419: 				}
; 12420: #endif
; 12421: 				if ( money > lpObj->Money )

  002d6	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  002dc	3b f8		 cmp	 edi, eax
  002de	7e 26		 jle	 SHORT $LN13@CGWarehous@2
$LN31@CGWarehous@2:

; 12422: 				{
; 12423: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  002e0	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  002e6	6a 00		 push	 0
  002e8	6a 00		 push	 0
  002ea	6a 00		 push	 0
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  002f2	83 c4 10	 add	 esp, 16			; 00000010H
  002f5	5f		 pop	 edi
  002f6	5e		 pop	 esi
  002f7	5b		 pop	 ebx

; 12507: }

  002f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fb	33 cd		 xor	 ecx, ebp
  002fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
$LN13@CGWarehous@2:

; 12424: 					return;
; 12425: 				}
; 12426: 
; 12427: 				lpObj->Money-=money;

  00306	2b c7		 sub	 eax, edi
  00308	89 86 f0 00 00
	00		 mov	 DWORD PTR [esi+240], eax

; 12428: 				lpObj->WarehouseMoney+=money;

  0030e	89 8e 6c 0e 00
	00		 mov	 DWORD PTR [esi+3692], ecx
$LN18@CGWarehous@2:

; 12503: 	}
; 12504: 
; 12505: 	lpObj->WarehouseCount++;
; 12506: 	GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  00314	8b 8e 6c 0e 00
	00		 mov	 ecx, DWORD PTR [esi+3692]
  0031a	8b 96 f0 00 00
	00		 mov	 edx, DWORD PTR [esi+240]
  00320	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00326	fe 86 64 0e 00
	00		 inc	 BYTE PTR [esi+3684]
  0032c	51		 push	 ecx
  0032d	52		 push	 edx
  0032e	6a 01		 push	 1
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00336	83 c4 10	 add	 esp, 16			; 00000010H
  00339	5f		 pop	 edi
  0033a	5e		 pop	 esi
  0033b	5b		 pop	 ebx

; 12507: }

  0033c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033f	33 cd		 xor	 ecx, ebp
  00341	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00346	8b e5		 mov	 esp, ebp
  00348	5d		 pop	 ebp
  00349	c3		 ret	 0
$LN15@CGWarehous@2:

; 12403: 				{
; 12404: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  0034a	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00350	6a 00		 push	 0
  00352	6a 00		 push	 0
  00354	6a 00		 push	 0
  00356	51		 push	 ecx
  00357	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0035c	83 c4 10	 add	 esp, 16			; 00000010H
  0035f	5f		 pop	 edi
  00360	5e		 pop	 esi
  00361	5b		 pop	 ebx

; 12507: }

  00362	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00365	33 cd		 xor	 ecx, ebp
  00367	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036c	8b e5		 mov	 esp, ebp
  0036e	5d		 pop	 ebp
  0036f	c3		 ret	 0
$LN20@CGWarehous@2:

; 12390: #endif
; 12391: 		{
; 12392: 			GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  00370	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00376	6a 00		 push	 0
  00378	6a 00		 push	 0
  0037a	6a 00		 push	 0
  0037c	52		 push	 edx
  0037d	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 12393: 			LogAdd("[%s][%s] error-L1 : used not Warehouse", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00382	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00387	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  0038b	51		 push	 ecx
  0038c	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  00390	52		 push	 edx
  00391	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@
  00396	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 12507: }

  0039c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039f	83 c4 1c	 add	 esp, 28			; 0000001cH
  003a2	5f		 pop	 edi
  003a3	5e		 pop	 esi
  003a4	33 cd		 xor	 ecx, ebp
  003a6	5b		 pop	 ebx
  003a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ac	8b e5		 mov	 esp, ebp
  003ae	5d		 pop	 ebp
  003af	c3		 ret	 0
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ENDP ; CGWarehouseMoneyInOut
_TEXT	ENDS
PUBLIC	??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@ ; `string'
PUBLIC	??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ ; `string'
PUBLIC	?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z		; CGAttack
EXTRN	?CheckCombo@CComboAttack@@QAEHHH@Z:PROC		; CComboAttack::CheckCombo
EXTRN	?gComboAttack@@3VCComboAttack@@A:DWORD		; gComboAttack
EXTRN	?gSpeedHackPenalty@@3HA:DWORD			; gSpeedHackPenalty
;	COMDAT ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@
CONST	SEGMENT
??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@ DB '['
	DB	'CGAttack] [UserIndex Error] :%s %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
CONST	SEGMENT
??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z
_TEXT	SEGMENT
_usernumber$ = -8					; size = 4
tv269 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z PROC			; CGAttack, COMDAT

; 13604: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 13605: 	LPOBJ lpObj;
; 13606: 	LPOBJ lpTargetObj;
; 13607: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00009	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0000d	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  00011	66 c1 e0 08	 shl	 ax, 8
  00015	0f b7 c0	 movzx	 eax, ax
  00018	0b c1		 or	 eax, ecx
  0001a	89 45 f8	 mov	 DWORD PTR _usernumber$[ebp], eax

; 13608: 
; 13609: 	if ( usernumber < 0 || usernumber > OBJMAX-1)

  0001d	3d 97 3a 00 00	 cmp	 eax, 14999		; 00003a97H
  00022	0f 87 e1 01 00
	00		 ja	 $LN9@CGAttack

; 13612: 		return;
; 13613: 	}
; 13614: 
; 13615: 	if ( !gObj[usernumber].Live )

  00028	57		 push	 edi
  00029	8b f8		 mov	 edi, eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  00036	80 7c 07 6a 00	 cmp	 BYTE PTR [edi+eax+106], 0
  0003b	89 7d fc	 mov	 DWORD PTR tv269[ebp], edi
  0003e	0f 84 b2 00 00
	00		 je	 $LN14@CGAttack

; 13616: 	{
; 13617: 		#if(FIX_OBJECT_VIEWE)
; 13618: 		g_ObjectViewe.GCIndexLive(aIndex, usernumber, gObj[usernumber].Type, gObj[usernumber].Live);
; 13619: 		#endif
; 13620: 
; 13621: 		#if(FIX_VIEWE_MONSTER)
; 13622: 		//gObjDel(usernumber);
; 13623: 		//gObjClearViewport(&gObj[aIndex]);
; 13624: 		//gObjViewportListCreate(gObj[aIndex].m_Index);
; 13625: 		//gObjViewportListProtocolCreate(&gObj[aIndex]);
; 13626: 		//MsgOutput(aIndex, "[INDEX]: %d", usernumber);
; 13627: 		#endif
; 13628: 		return;
; 13629: 
; 13630: 	}
; 13631: 
; 13632: 	lpObj = &gObj[aIndex];

  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00048	56		 push	 esi
  00049	8b f3		 mov	 esi, ebx
  0004b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00051	03 f0		 add	 esi, eax

; 13633: 	int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;

  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00059	2b 86 6c 03 00
	00		 sub	 eax, DWORD PTR [esi+876]

; 13634: 
; 13635: 	if ( iTimeCalc < lpObj->m_DetectSpeedHackTime) //season4 changed (fix)

  0005f	8b 8e 74 03 00
	00		 mov	 ecx, DWORD PTR [esi+884]
  00065	3b c1		 cmp	 eax, ecx
  00067	0f 8d da 00 00
	00		 jge	 $LN7@CGAttack

; 13636: 	{
; 13637: 		lpObj->m_DetectCount++;
; 13638: 		lpObj->m_SumLastAttackTime += iTimeCalc;

  0006d	01 86 78 03 00
	00		 add	 DWORD PTR [esi+888], eax
  00073	8b 86 78 03 00
	00		 mov	 eax, DWORD PTR [esi+888]
  00079	ba 01 00 00 00	 mov	 edx, 1
  0007e	01 96 7c 03 00
	00		 add	 DWORD PTR [esi+892], edx
  00084	8b be 7c 03 00
	00		 mov	 edi, DWORD PTR [esi+892]

; 13639: 
; 13640: 		if ( lpObj->m_DetectCount > gHackCheckCount )

  0008a	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  00090	0f 86 a0 00 00
	00		 jbe	 $LN13@CGAttack

; 13641: 		{
; 13642: 			lpObj->m_DetectedHackKickCount++;

  00096	01 96 80 03 00
	00		 add	 DWORD PTR [esi+896], edx

; 13643: 			lpObj->m_SpeedHackPenalty = gSpeedHackPenalty;

  0009c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gSpeedHackPenalty@@3HA ; gSpeedHackPenalty
  000a2	89 96 84 03 00
	00		 mov	 DWORD PTR [esi+900], edx

; 13644: 			
; 13645: 			if ( gIsKickDetecHackCountLimit )

  000a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  000af	74 4a		 je	 SHORT $LN4@CGAttack

; 13646: 			{
; 13647: 				if ( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  000b1	8b 96 80 03 00
	00		 mov	 edx, DWORD PTR [esi+896]
  000b7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  000bd	7e 3c		 jle	 SHORT $LN4@CGAttack

; 13648: 				{
; 13649: 					LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class), lpObj->m_DetectedHackKickCount);

  000bf	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  000c6	52		 push	 edx
  000c7	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  000cc	50		 push	 eax
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  000d7	50		 push	 eax
  000d8	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  000db	51		 push	 ecx
  000dc	83 c6 6c	 add	 esi, 108		; 0000006cH
  000df	56		 push	 esi
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 13650: 					CloseClient(aIndex);

  000eb	53		 push	 ebx
  000ec	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000f1	83 c4 18	 add	 esp, 24			; 00000018H
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
$LN14@CGAttack:
  000f6	5f		 pop	 edi

; 13685: }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
$LN4@CGAttack:

; 13651: 					return;
; 13652: 				}
; 13653: 			}
; 13654: 
; 13655: 			LogAddTD("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class), lpObj->m_DetectSpeedHackTime, lpObj->m_SumLastAttackTime/lpObj->m_DetectCount, lpObj->m_SpeedHackPenalty);

  000fb	8b 96 84 03 00
	00		 mov	 edx, DWORD PTR [esi+900]
  00101	52		 push	 edx
  00102	33 d2		 xor	 edx, edx
  00104	f7 f7		 div	 edi
  00106	50		 push	 eax
  00107	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  0010e	51		 push	 ecx
  0010f	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00114	50		 push	 eax
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0011f	50		 push	 eax
  00120	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00123	51		 push	 ecx
  00124	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  00127	52		 push	 edx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00133	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN13@CGAttack:

; 13656: 		}
; 13657: 
; 13658: 		lpObj->m_LastAttackTime = GetTickCount();

  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 13659: 	}
; 13660: 	else

  0013c	8b 7d fc	 mov	 edi, DWORD PTR tv269[ebp]
  0013f	89 86 6c 03 00
	00		 mov	 DWORD PTR [esi+876], eax
  00145	eb 0e		 jmp	 SHORT $LN3@CGAttack
$LN7@CGAttack:

; 13661: 	{
; 13662: 		lpObj->m_SumLastAttackTime = 0;

  00147	33 c0		 xor	 eax, eax
  00149	89 86 78 03 00
	00		 mov	 DWORD PTR [esi+888], eax

; 13663: 		lpObj->m_DetectCount = 0;

  0014f	89 86 7c 03 00
	00		 mov	 DWORD PTR [esi+892], eax
$LN3@CGAttack:

; 13664: 	}
; 13665: 
; 13666: 	lpObj->m_LastAttackTime = GetTickCount();

  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0015b	89 86 6c 03 00
	00		 mov	 DWORD PTR [esi+876], eax

; 13667: 
; 13668: 	if ( bIsIgnorePacketSpeedHackDetect )

  00161	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  00168	74 47		 je	 SHORT $LN1@CGAttack

; 13669: 	{
; 13670: 		if ( lpObj->m_SpeedHackPenalty > 0 )

  0016a	8b 86 84 03 00
	00		 mov	 eax, DWORD PTR [esi+900]
  00170	85 c0		 test	 eax, eax
  00172	7e 3d		 jle	 SHORT $LN1@CGAttack

; 13671: 		{
; 13672: 			lpObj->m_SpeedHackPenalty--;

  00174	48		 dec	 eax

; 13673: 			
; 13674: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left)", lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class), lpObj->m_SpeedHackPenalty);

  00175	50		 push	 eax
  00176	89 86 84 03 00
	00		 mov	 DWORD PTR [esi+900], eax
  0017c	0f b7 86 b8 00
	00 00		 movzx	 eax, WORD PTR [esi+184]
  00183	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00188	50		 push	 eax
  00189	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0018e	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00193	50		 push	 eax
  00194	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00197	51		 push	 ecx
  00198	83 c6 6c	 add	 esi, 108		; 0000006cH
  0019b	56		 push	 esi
  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a7	83 c4 14	 add	 esp, 20			; 00000014H
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	5f		 pop	 edi

; 13685: }

  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c3		 ret	 0
$LN1@CGAttack:

; 13675: 			return;
; 13676: 		}
; 13677: 	}
; 13678: 	
; 13679: 	lpTargetObj = &gObj[usernumber];
; 13680: 	lpObj->Dir = lpMsg->DirDis;

  001b1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001b4	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  001b7	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13681: 	GCActionSend(lpObj, lpMsg->AttackAction, aIndex, usernumber);

  001bd	8b 55 f8	 mov	 edx, DWORD PTR _usernumber$[ebp]
  001c0	52		 push	 edx
  001c1	88 8e 48 01 00
	00		 mov	 BYTE PTR [esi+328], cl
  001c7	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  001cb	53		 push	 ebx
  001cc	50		 push	 eax
  001cd	56		 push	 esi
  001ce	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ; GCActionSend
  001d3	83 c4 10	 add	 esp, 16			; 00000010H

; 13682: 	gComboAttack.CheckCombo(aIndex, 0);

  001d6	6a 00		 push	 0
  001d8	53		 push	 ebx
  001d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  001de	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo

; 13683: 	gObjAttack(lpObj, lpTargetObj, NULL, FALSE, FALSE, 0, FALSE,0,0);

  001e3	6a 00		 push	 0
  001e5	6a 00		 push	 0
  001e7	6a 00		 push	 0
  001e9	6a 00		 push	 0
  001eb	6a 00		 push	 0
  001ed	6a 00		 push	 0
  001ef	6a 00		 push	 0
  001f1	57		 push	 edi
  001f2	56		 push	 esi
  001f3	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  001f8	83 c4 24	 add	 esp, 36			; 00000024H

; 13684: 	lpObj->UseMagicNumber = 0;

  001fb	c6 86 cd 04 00
	00 00		 mov	 BYTE PTR [esi+1229], 0
  00202	5e		 pop	 esi
  00203	5b		 pop	 ebx
  00204	5f		 pop	 edi

; 13685: }

  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
$LN9@CGAttack:

; 13610: 	{
; 13611: 		LogAdd("[CGAttack] [UserIndex Error] :%s %d %d", __FILE__, __LINE__, usernumber);

  00209	50		 push	 eax
  0020a	68 2b 35 00 00	 push	 13611			; 0000352bH
  0020f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0021f	83 c4 10	 add	 esp, 16			; 00000010H

; 13685: }

  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ENDP			; CGAttack
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCKillPlayerExpSend@@YAXHHHHH@Z		; GCKillPlayerExpSend
; Function compile flags: /Ogtp
;	COMDAT ?GCKillPlayerExpSend@@YAXHHHHH@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_exp$ = 16						; size = 4
_AttackDamage$ = 20					; size = 4
_MSBFlag$ = 24						; size = 4
?GCKillPlayerExpSend@@YAXHHHHH@Z PROC			; GCKillPlayerExpSend, COMDAT

; 13783: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 13784: #if EXP_FIX == TRUE
; 13785: 	GCKillPlayerExtSend(aIndex, TargetIndex, exp, AttackDamage, MSBFlag);

  0000e	8b 45 18	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  00011	8b 55 14	 mov	 edx, DWORD PTR _AttackDamage$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00017	50		 push	 eax
  00018	8b 45 10	 mov	 eax, DWORD PTR _exp$[ebp]
  0001b	52		 push	 edx
  0001c	99		 cdq
  0001d	52		 push	 edx
  0001e	50		 push	 eax
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?GCKillPlayerExtSend@@YAXHH_JHH@Z ; GCKillPlayerExtSend

; 13786: 	return;
; 13787: #endif
; 13788: 	//GCKillPlayerExtSend(aIndex, TargetIndex, exp, AttackDamage, MSBFlag);
; 13789: 
; 13790: 	PMSG_KILLPLAYER pkillMsg;
; 13791: 
; 13792: 	PHeadSetBE((LPBYTE)&pkillMsg, 0x16, sizeof(pkillMsg));
; 13793: 	pkillMsg.NumberH = SET_NUMBERH(TargetIndex);
; 13794: 	pkillMsg.NumberL = SET_NUMBERL(TargetIndex);
; 13795: 	pkillMsg.ExpH = SET_NUMBERH(exp);
; 13796: 	pkillMsg.ExpL = SET_NUMBERL(exp);
; 13797: 	pkillMsg.DamageH = SET_NUMBERH(AttackDamage);
; 13798: 	pkillMsg.DamageL = SET_NUMBERL(AttackDamage);
; 13799: 
; 13800: 	pkillMsg.Exp = exp;
; 13801: 
; 13802: 	pkillMsg.ExDamage = AttackDamage;
; 13803: 
; 13804: 	if ( MSBFlag != FALSE )
; 13805: 	{
; 13806: 		pkillMsg.NumberH &= 0x7F;
; 13807: 		pkillMsg.NumberH |= 0x80;
; 13808: 	}
; 13809: 
; 13810: 	if (  BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )
; 13811: 	{
; 13812: 		g_BloodCastle.AddExperience(aIndex, exp);
; 13813: 	}
; 13814: 
; 13815: 	DataSend(aIndex, (LPBYTE)&pkillMsg, pkillMsg.h.size);
; 13816: }

  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	83 c4 18	 add	 esp, 24			; 00000018H
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?GCKillPlayerExpSend@@YAXHHHHH@Z ENDP			; GCKillPlayerExpSend
_TEXT	ENDS
PUBLIC	??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ ; `string'
PUBLIC	??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ ; `string'
PUBLIC	??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ ; `string'
PUBLIC	?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; CGMagicAttack
EXTRN	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?g_iSkillDistanceKick@@3HA:DWORD		; g_iSkillDistanceKick
EXTRN	?g_iSkillDistanceKickCount@@3HA:DWORD		; g_iSkillDistanceKickCount
EXTRN	?g_iSkillDiatanceKickCheckTime@@3HA:DWORD	; g_iSkillDiatanceKickCheckTime
EXTRN	?gCheckSkillDistance@@YAHHHH@Z:PROC		; gCheckSkillDistance
EXTRN	?gObjCheckAttackArea@@YAHHH@Z:PROC		; gObjCheckAttackArea
;	COMDAT ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@ DB 'error :%s %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. '
	DB	'count(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
CONST	SEGMENT
??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ DB '['
	DB	'0x19] CGMagicAttack() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
CONST	SEGMENT
??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ DB '['
	DB	'0x19] CGMagicAttack() - Invalid Status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
CONST	SEGMENT
??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) e'
	DB	'rrortype = %d', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
_usernumber$ = -4					; size = 4
_MagicNumber$ = 8					; size = 2
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; CGMagicAttack, COMDAT

; 13952: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 13953: 	LPOBJ lpObj;
; 13954: 	LPOBJ lpTargetObj;
; 13955: 
; 13956: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL); //loc3

  00004	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00007	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0000b	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  0000f	66 c1 e1 08	 shl	 cx, 8
  00013	53		 push	 ebx
  00014	0f b7 d9	 movzx	 ebx, cx

; 13957: 	CMagicInf * lpMagic; //loc4
; 13958: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL); //loc5

  00017	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0001b	0b da		 or	 ebx, edx
  0001d	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00021	66 c1 e1 08	 shl	 cx, 8
  00025	66 0b ca	 or	 cx, dx
  00028	0f b7 c1	 movzx	 eax, cx
  0002b	89 5d fc	 mov	 DWORD PTR _usernumber$[ebp], ebx
  0002e	89 45 08	 mov	 DWORD PTR _MagicNumber$[ebp], eax

; 13959: 
; 13960: 	if ( usernumber < 0 || usernumber > OBJMAX-1 )

  00031	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00037	0f 87 ed 02 00
	00		 ja	 $LN25@CGMagicAtt@2

; 13963: 		return;
; 13964: 	}
; 13965: 
; 13966: 	if ( gObj[usernumber].Live == 0 || gObj[usernumber].Connected  < PLAYER_LOGGED )

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	8b cb		 mov	 ecx, ebx
  00044	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  0004a	80 7c 01 6a 00	 cmp	 BYTE PTR [ecx+eax+106], 0
  0004f	0f 84 ad 01 00
	00		 je	 $LN27@CGMagicAtt@2
  00055	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0005a	0f 8c a2 01 00
	00		 jl	 $LN27@CGMagicAtt@2

; 13967: 	{
; 13968: 		#if(FIX_OBJECT_VIEWE)
; 13969: 		g_ObjectViewe.GCIndexLive(aIndex, usernumber, gObj[usernumber].Type, gObj[usernumber].Live);
; 13970: 		#endif
; 13971: 		return;
; 13972: 	}
; 13973: 
; 13974: 	if ( gObj[aIndex].CloseCount >= 0 )

  00060	56		 push	 esi
  00061	57		 push	 edi
  00062	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00065	8b f7		 mov	 esi, edi
  00067	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0006d	80 7c 06 0a 00	 cmp	 BYTE PTR [esi+eax+10], 0
  00072	0f 8d 88 01 00
	00		 jge	 $LN31@CGMagicAtt@2

; 13975: 	{
; 13976: 		return;
; 13977: 	}
; 13978: 
; 13979: 	//season 4.5 add-on start
; 13980: 	BYTE attr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 13981: 
; 13982: 	if ( (attr&1) == 1 && MagicNumber == 58) //safezone

  00078	0f bf 94 06 46
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+326]
  00080	0f bf 8c 06 44
	01 00 00	 movsx	 ecx, WORD PTR [esi+eax+324]
  00088	52		 push	 edx
  00089	51		 push	 ecx
  0008a	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00092	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00098	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0009e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000a3	a8 01		 test	 al, 1
  000a5	74 42		 je	 SHORT $LN21@CGMagicAtt@2
  000a7	66 83 7d 08 3a	 cmp	 WORD PTR _MagicNumber$[ebp], 58 ; 0000003aH
  000ac	75 3b		 jne	 SHORT $LN21@CGMagicAtt@2

; 13983: 	{
; 13984: 		GCMagicAttackNumberSend(&gObj[aIndex], 40, aIndex, 1);

  000ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b4	6a 01		 push	 1
  000b6	57		 push	 edi
  000b7	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  000ba	6a 28		 push	 40			; 00000028H
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 13985: 		gObjSetPosition(aIndex,gObj[aIndex].X, gObj[aIndex].Y);

  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c7	0f bf 8c 06 46
	01 00 00	 movsx	 ecx, WORD PTR [esi+eax+326]
  000cf	0f bf 94 06 44
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+324]
  000d7	51		 push	 ecx
  000d8	52		 push	 edx
  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  000df	83 c4 1c	 add	 esp, 28			; 0000001cH
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 14099: }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
$LN21@CGMagicAtt@2:

; 13986: 		return;
; 13987: 	}
; 13988: 	//season 4.5 add-on end
; 13989: 
; 13990: 	lpObj = &gObj[aIndex];

  000e9	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13991: 	lpTargetObj = &gObj[usernumber];
; 13992: 	
; 13993: 	int attackret = gObjCheckAttackArea(aIndex, usernumber);

  000ef	53		 push	 ebx
  000f0	57		 push	 edi
  000f1	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  000f6	83 c4 08	 add	 esp, 8

; 13994: 
; 13995: 	if ( attackret )

  000f9	85 c0		 test	 eax, eax
  000fb	74 64		 je	 SHORT $LN18@CGMagicAtt@2

; 13996: 	{
; 13997: 		LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) errortype = %d",	lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 208)+lpObj->MapNumber), lpObj->X, lpObj->Y, attackret);

  000fd	0f bf 8e 46 01
	00 00		 movsx	 ecx, WORD PTR [esi+326]
  00104	0f bf 96 44 01
	00 00		 movsx	 edx, WORD PTR [esi+324]
  0010b	50		 push	 eax
  0010c	0f b6 86 49 01
	00 00		 movzx	 eax, BYTE PTR [esi+329]
  00113	51		 push	 ecx
  00114	52		 push	 edx
  00115	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  0011a	50		 push	 eax
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00120	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00125	50		 push	 eax
  00126	8d 4e 77	 lea	 ecx, DWORD PTR [esi+119]
  00129	51		 push	 ecx
  0012a	8d 56 6c	 lea	 edx, DWORD PTR [esi+108]
  0012d	52		 push	 edx
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 13998: 
; 13999: 		if ( lpObj->Class == 275 )

  00139	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  0013e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00141	66 39 86 b8 00
	00 00		 cmp	 WORD PTR [esi+184], ax
  00148	75 0a		 jne	 SHORT $LN19@CGMagicAtt@2

; 14000: 		{
; 14001: 			lpObj->TargetNumber = -1;

  0014a	83 c9 ff	 or	 ecx, -1
  0014d	66 89 8e 58 04
	00 00		 mov	 WORD PTR [esi+1112], cx
$LN19@CGMagicAtt@2:

; 14002: 		}
; 14003: 
; 14004: 		if ( bIsIgnorePacketSpeedHackDetect )

  00154	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  0015b	0f 85 9f 00 00
	00		 jne	 $LN31@CGMagicAtt@2
$LN18@CGMagicAtt@2:

; 14005: 		{
; 14006: 			return;
; 14007: 		}
; 14008: 	}
; 14009: 
; 14010: 	if ( lpObj->Type == OBJ_USER )

  00161	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1
  00166	0f 85 cc 00 00
	00		 jne	 $LN17@CGMagicAtt@2

; 14011: 	{
; 14012: 		if ( MagicNumber == 58 )

  0016c	8b 45 08	 mov	 eax, DWORD PTR _MagicNumber$[ebp]
  0016f	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  00173	75 07		 jne	 SHORT $LN16@CGMagicAtt@2

; 14013: 		{
; 14014: 			usernumber = 58;

  00175	c7 45 fc 3a 00
	00 00		 mov	 DWORD PTR _usernumber$[ebp], 58 ; 0000003aH
$LN16@CGMagicAtt@2:

; 14015: 		}
; 14016: 
; 14017: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  0017c	0f b7 d8	 movzx	 ebx, ax
  0017f	53		 push	 ebx
  00180	56		 push	 esi
  00181	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00186	83 c4 08	 add	 esp, 8
  00189	8b f8		 mov	 edi, eax

; 14022: 
; 14023: 		switch(MagicNumber) //season 3.5 add-on

  0018b	83 fb 33	 cmp	 ebx, 51			; 00000033H
  0018e	75 18		 jne	 SHORT $LN12@CGMagicAtt@2

; 14018: 
; 14019: 		short Energy = lpObj->Energy + lpObj->AddEnergy; //season 3.5 add-on
; 14020: 		short Strength = lpObj->Strength + lpObj->AddStrength; //season 3.5 add-on
; 14021: 		short Dexterity = lpObj->Dexterity + lpObj->AddDexterity; //season 3.5 add-on 

  00190	66 8b 96 22 01
	00 00		 mov	 dx, WORD PTR [esi+290]
  00197	66 03 96 f6 00
	00 00		 add	 dx, WORD PTR [esi+246]

; 14024: 		{
; 14025: 		case AT_SKILL_ELFHARDEN:
; 14026: 			{
; 14027: 				if(Dexterity < 646)

  0019e	b8 86 02 00 00	 mov	 eax, 646		; 00000286H
  001a3	66 3b d0	 cmp	 dx, ax
  001a6	7c 58		 jl	 SHORT $LN31@CGMagicAtt@2
$LN12@CGMagicAtt@2:

; 14028: 				{
; 14029: 					return;
; 14030: 				}
; 14031: 			}
; 14032: 			break;
; 14033: 		}
; 14034: 
; 14035: 		if ( lpMagic == NULL )

  001a8	85 ff		 test	 edi, edi
  001aa	74 54		 je	 SHORT $LN31@CGMagicAtt@2

; 14036: 		{
; 14037: 			return;
; 14038: 		}
; 14039: 
; 14040: 		if ( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ChangeUP3rd, lpMagic->m_Skill) < 1 )

  001ac	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001af	0f b6 96 bc 00
	00 00		 movzx	 edx, BYTE PTR [esi+188]
  001b6	0f b6 86 bb 00
	00 00		 movzx	 eax, BYTE PTR [esi+187]
  001bd	51		 push	 ecx
  001be	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  001c5	52		 push	 edx
  001c6	50		 push	 eax
  001c7	51		 push	 ecx
  001c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  001cd	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  001d2	83 f8 01	 cmp	 eax, 1
  001d5	7c 29		 jl	 SHORT $LN31@CGMagicAtt@2

; 14041: 		{
; 14042: 			return;
; 14043: 		}
; 14044: 
; 14045: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == 0 )

  001d7	8b 96 48 04 00
	00		 mov	 edx, DWORD PTR [esi+1096]
  001dd	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001e0	52		 push	 edx
  001e1	50		 push	 eax
  001e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  001e7	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  001ec	85 c0		 test	 eax, eax
  001ee	75 17		 jne	 SHORT $LN9@CGMagicAtt@2

; 14046: 		{
; 14047: 			LogAddC(2, "[0x19] CGMagicAttack() - Invalid Status");

  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
  001f5	6a 02		 push	 2
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001fd	83 c4 08	 add	 esp, 8
$LN31@CGMagicAtt@2:
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
$LN27@CGMagicAtt@2:
  00202	5b		 pop	 ebx

; 14099: }

  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
$LN9@CGMagicAtt@2:

; 14048: 			return;
; 14049: 		}
; 14050: 
; 14051: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  00207	0f b6 8e 0c 1c
	00 00		 movzx	 ecx, BYTE PTR [esi+7180]
  0020e	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00211	51		 push	 ecx
  00212	52		 push	 edx
  00213	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00218	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  0021d	85 c0		 test	 eax, eax
  0021f	79 2d		 jns	 SHORT $LN29@CGMagicAtt@2

; 14052: 		{
; 14053: 			LogAddC(2, "[0x19] CGMagicAttack() - Invalid KillCount");

  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
  00226	6a 02		 push	 2
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0022e	83 c4 08	 add	 esp, 8
  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	5b		 pop	 ebx

; 14099: }

  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
$LN17@CGMagicAtt@2:

; 14054: 			return;
; 14055: 		}
; 14056: 	}
; 14057: 	else
; 14058: 	{
; 14059: 		lpMagic = gObjGetMagic(lpObj, MagicNumber);

  00238	0f b7 45 08	 movzx	 eax, WORD PTR _MagicNumber$[ebp]
  0023c	50		 push	 eax
  0023d	56		 push	 esi
  0023e	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  00243	8b f8		 mov	 edi, eax
  00245	83 c4 08	 add	 esp, 8

; 14060: 
; 14061: 		if ( lpMagic == NULL )

  00248	85 ff		 test	 edi, edi
  0024a	74 b4		 je	 SHORT $LN31@CGMagicAtt@2
  0024c	eb 03		 jmp	 SHORT $LN6@CGMagicAtt@2
$LN29@CGMagicAtt@2:
  0024e	8b 5d fc	 mov	 ebx, DWORD PTR _usernumber$[ebp]
$LN6@CGMagicAtt@2:

; 14062: 		{
; 14063: 			return;
; 14064: 		}
; 14065: 	}
; 14066: 
; 14067: 	if ( lpMagic->m_Skill != 24 && lpMagic->m_Skill != 490 && gObjUseSkill.SpeedHackCheck(aIndex) == FALSE )

  00251	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00254	83 f8 18	 cmp	 eax, 24			; 00000018H
  00257	74 19		 je	 SHORT $LN5@CGMagicAtt@2
  00259	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  0025e	74 12		 je	 SHORT $LN5@CGMagicAtt@2
  00260	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00263	51		 push	 ecx
  00264	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00269	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  0026e	85 c0		 test	 eax, eax
  00270	74 8e		 je	 SHORT $LN31@CGMagicAtt@2
$LN5@CGMagicAtt@2:

; 14068: 	{
; 14069: 		return;
; 14070: 	}
; 14071: 
; 14072: 	if ( !gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill))

  00272	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00275	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00278	52		 push	 edx
  00279	53		 push	 ebx
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  00280	83 c4 0c	 add	 esp, 12			; 0000000cH
  00283	85 c0		 test	 eax, eax
  00285	0f 85 88 00 00
	00		 jne	 $LN4@CGMagicAtt@2

; 14073: 	{
; 14074: 		DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  0028b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00291	ff d7		 call	 edi

; 14075: 		
; 14076: 		if ( dwTick > (g_iSkillDiatanceKickCheckTime*1000) )

  00293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3HA ; g_iSkillDiatanceKickCheckTime
  00299	2b 86 d4 1f 00
	00		 sub	 eax, DWORD PTR [esi+8148]
  0029f	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  002a5	3b c1		 cmp	 eax, ecx
  002a7	76 12		 jbe	 SHORT $LN30@CGMagicAtt@2

; 14077: 		{
; 14078: 			lpObj->m_iSkillDistanceErrorCount = 0;

  002a9	c7 86 d0 1f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+8144], 0

; 14079: 			lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  002b3	ff d7		 call	 edi
  002b5	89 86 d4 1f 00
	00		 mov	 DWORD PTR [esi+8148], eax
$LN30@CGMagicAtt@2:

; 14080: 		}
; 14081: 
; 14082: 		lpObj->m_iSkillDistanceErrorCount++;

  002bb	ff 86 d0 1f 00
	00		 inc	 DWORD PTR [esi+8144]
  002c1	8b 86 d0 1f 00
	00		 mov	 eax, DWORD PTR [esi+8144]

; 14083: 
; 14084: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  002c7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  002cd	0f 8e 2d ff ff
	ff		 jle	 $LN31@CGMagicAtt@2

; 14085: 		{
; 14086: 			if ( g_iSkillDistanceKick )

  002d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  002da	74 26		 je	 SHORT $LN1@CGMagicAtt@2

; 14087: 			{
; 14088: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)", lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);

  002dc	50		 push	 eax
  002dd	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  002e0	52		 push	 edx
  002e1	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  002e4	50		 push	 eax
  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  002ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14089: 				CloseClient(lpObj->m_Index);

  002f0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002f2	51		 push	 ecx
  002f3	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002f8	83 c4 14	 add	 esp, 20			; 00000014H
  002fb	5f		 pop	 edi
  002fc	5e		 pop	 esi
  002fd	5b		 pop	 ebx

; 14099: }

  002fe	8b e5		 mov	 esp, ebp
  00300	5d		 pop	 ebp
  00301	c3		 ret	 0
$LN1@CGMagicAtt@2:
  00302	5f		 pop	 edi

; 14090: 				return;
; 14091: 			}
; 14092: 
; 14093: 			lpObj->m_iSkillDistanceErrorCount = 0;

  00303	c7 86 d0 1f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+8144], 0
  0030d	5e		 pop	 esi
  0030e	5b		 pop	 ebx

; 14099: }

  0030f	8b e5		 mov	 esp, ebp
  00311	5d		 pop	 ebp
  00312	c3		 ret	 0
$LN4@CGMagicAtt@2:

; 14094: 		}
; 14095: 		return;
; 14096: 	}
; 14097: 	
; 14098: 	gObjUseSkill.UseSkill(aIndex, usernumber, lpMagic);

  00313	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00316	57		 push	 edi
  00317	53		 push	 ebx
  00318	52		 push	 edx
  00319	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0031e	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
  00323	5f		 pop	 edi
  00324	5e		 pop	 esi
  00325	5b		 pop	 ebx

; 14099: }

  00326	8b e5		 mov	 esp, ebp
  00328	5d		 pop	 ebp
  00329	c3		 ret	 0
$LN25@CGMagicAtt@2:

; 13961: 	{
; 13962: 		LogAdd("error :%s %d %d", __FILE__, __LINE__, usernumber);

  0032a	53		 push	 ebx
  0032b	68 8a 36 00 00	 push	 13962			; 0000368aH
  00330	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00340	83 c4 10	 add	 esp, 16			; 00000010H
  00343	5b		 pop	 ebx

; 14099: }

  00344	8b e5		 mov	 esp, ebp
  00346	5d		 pop	 ebp
  00347	c3		 ret	 0
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; CGMagicAttack
_TEXT	ENDS
PUBLIC	??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z	; CGTeleportRecv
EXTRN	?NotifyCsSelfLeftTime@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifyCsSelfLeftTime
EXTRN	?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifySelfCsJoinSide
EXTRN	?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?IsInGate@CGate@@QAEHHH@Z:PROC			; CGate::IsInGate
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	?gObjTeleportMagicUse@@YAXHEE@Z:PROC		; gObjTeleportMagicUse
EXTRN	?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicBPUse
EXTRN	?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicManaUse
EXTRN	?CheckTeleportMagicAxisY@CCastleSiege@@QAEHHHH@Z:PROC ; CCastleSiege::CheckTeleportMagicAxisY
EXTRN	?gObjCheckTeleportArea@@YAHHEE@Z:PROC		; gObjCheckTeleportArea
EXTRN	?GetRestrictionSpellStatus@CIllusionTempleEvent@@QAEHHE@Z:PROC ; CIllusionTempleEvent::GetRestrictionSpellStatus
EXTRN	?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z:PROC ; CIllusionTempleEvent::CheckTeleport
EXTRN	?GetState@CIllusionTempleEvent@@QAEEE@Z:PROC	; CIllusionTempleEvent::GetState
;	COMDAT ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@ DB '['
	DB	'%s][%s] Try Teleport Not Move Area [%d,%d]', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z
_TEXT	SEGMENT
_usemana$249671 = -40					; size = 4
_y$249645 = -36						; size = 1
_x$249644 = -32						; size = 1
_lpMsg$GSCopy$ = -32					; size = 4
_pTeleportResult$249666 = -28				; size = 10
_pTeleportResult$249624 = -28				; size = 10
_pAttack$249646 = -16					; size = 9
_pTeleportResult$249640 = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z PROC		; CGTeleportRecv, COMDAT

; 14314: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 14533: 		}
; 14534: 		gObj[aIndex].NewCombo = bCombo;

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	89 45 e0	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  0001a	85 db		 test	 ebx, ebx
  0001c	0f 88 6b 01 00
	00		 js	 $LN2@CGTeleport

; 14315: 	if ( !OBJMAX_RANGE(aIndex))

  00022	33 c0		 xor	 eax, eax
  00024	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 58 01 00
	00		 je	 $LN2@CGTeleport

; 14316: 	{
; 14317: 		return;
; 14318: 	}
; 14319: 
; 14320: 	if(gObjSearchActiveEffect(&gObj[aIndex], AT_STUN) == 1 || gObjSearchActiveEffect(&gObj[aIndex], AT_SLEEP) == 1) //Season3 update

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	56		 push	 esi
  0003c	8b f3		 mov	 esi, ebx
  0003e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00044	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00047	6a 3d		 push	 61			; 0000003dH
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0004f	83 c4 08	 add	 esp, 8
  00052	3c 01		 cmp	 al, 1
  00054	0f 84 19 04 00
	00		 je	 $LN25@CGTeleport
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005f	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00062	6a 48		 push	 72			; 00000048H
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0006a	83 c4 08	 add	 esp, 8
  0006d	3c 01		 cmp	 al, 1
  0006f	0f 84 fe 03 00
	00		 je	 $LN25@CGTeleport

; 14333: 		return;
; 14334: 	}
; 14335: 
; 14336: 	if(IT_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE) //season 2.5 add-on

  00075	57		 push	 edi
  00076	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	8a 84 3e 49 01
	00 00		 mov	 al, BYTE PTR [esi+edi+329]
  00083	3c 2d		 cmp	 al, 45			; 0000002dH
  00085	72 55		 jb	 SHORT $LN48@CGTeleport
  00087	b2 32		 mov	 dl, 50			; 00000032H
  00089	3a d0		 cmp	 dl, al
  0008b	1b c9		 sbb	 ecx, ecx
  0008d	41		 inc	 ecx
  0008e	74 4c		 je	 SHORT $LN48@CGTeleport

; 14337: 	{
; 14338: 		if(g_IllusionTempleEvent.GetState(gObj[aIndex].MapNumber) == 2)

  00090	50		 push	 eax
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00096	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  0009b	3c 02		 cmp	 al, 2
  0009d	75 37		 jne	 SHORT $LN43@CGTeleport

; 14339: 		{
; 14340: 			if(g_IllusionTempleEvent.CheckTeleport(aIndex) != FALSE)

  0009f	53		 push	 ebx
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  000a5	e8 00 00 00 00	 call	 ?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckTeleport
  000aa	85 c0		 test	 eax, eax

; 14341: 			{
; 14342: 				PMSG_TELEPORT_RESULT pTeleportResult;
; 14343: 
; 14344: 				pTeleportResult.h.c = 0xC3;
; 14345: 				pTeleportResult.h.size = sizeof(pTeleportResult);
; 14346: 				pTeleportResult.h.headcode = 0x1C;
; 14347: 				pTeleportResult.MoveNumber = 0;
; 14348: 				pTeleportResult.MapNumber = gObj[aIndex].MapNumber;
; 14349: 				pTeleportResult.MapX = gObj[aIndex].X;
; 14350: 				pTeleportResult.MapY = gObj[aIndex].Y;
; 14351: 				pTeleportResult.Dir = gObj[aIndex].Dir;
; 14352: 				DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);
; 14353: 				return;

  000ac	0f 85 89 00 00
	00		 jne	 $LN52@CGTeleport

; 14354: 			}
; 14355: 			if(g_IllusionTempleEvent.GetRestrictionSpellStatus(gObj[aIndex].m_iIllusionTempleIndex,gObj[aIndex].MapNumber) != FALSE)

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b7	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  000bf	8b 94 06 78 20
	00 00		 mov	 edx, DWORD PTR [esi+eax+8312]
  000c6	51		 push	 ecx
  000c7	52		 push	 edx
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  000cd	e8 00 00 00 00	 call	 ?GetRestrictionSpellStatus@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::GetRestrictionSpellStatus
  000d2	85 c0		 test	 eax, eax

; 14356: 			{
; 14357: 				PMSG_TELEPORT_RESULT pTeleportResult;
; 14358: 
; 14359: 				pTeleportResult.h.c = 0xC3;
; 14360: 				pTeleportResult.h.size = sizeof(pTeleportResult);
; 14361: 				pTeleportResult.h.headcode = 0x1C;
; 14362: 				pTeleportResult.MoveNumber = 0;
; 14363: 				pTeleportResult.MapNumber = gObj[aIndex].MapNumber;
; 14364: 				pTeleportResult.MapX = gObj[aIndex].X;
; 14365: 				pTeleportResult.MapY = gObj[aIndex].Y;
; 14366: 				pTeleportResult.Dir = gObj[aIndex].Dir;
; 14367: 				DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);
; 14368: 				return;

  000d4	75 65		 jne	 SHORT $LN52@CGTeleport
$LN43@CGTeleport:
  000d6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN48@CGTeleport:

; 14369: 			}
; 14370: 		}
; 14371: 	}
; 14372: 
; 14373: 	if(IT_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE) //season 2.5 add-on

  000dc	8a 8c 3e 49 01
	00 00		 mov	 cl, BYTE PTR [esi+edi+329]
  000e3	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000e6	72 1e		 jb	 SHORT $LN19@CGTeleport
  000e8	b2 32		 mov	 dl, 50			; 00000032H
  000ea	3a d1		 cmp	 dl, cl
  000ec	1b c0		 sbb	 eax, eax
  000ee	40		 inc	 eax
  000ef	74 15		 je	 SHORT $LN19@CGTeleport

; 14374: 	{
; 14375: 		if(g_IllusionTempleEvent.GetState(gObj[aIndex].MapNumber) == 1)

  000f1	51		 push	 ecx
  000f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  000f7	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  000fc	3c 01		 cmp	 al, 1

; 14376: 		{
; 14377: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 14378: 
; 14379: 			pTeleportResult.h.c = 0xC3;
; 14380: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 14381: 			pTeleportResult.h.headcode = 0x1C;
; 14382: 			pTeleportResult.MoveNumber = 0;
; 14383: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;
; 14384: 			pTeleportResult.MapX = gObj[aIndex].X;
; 14385: 			pTeleportResult.MapY = gObj[aIndex].Y;
; 14386: 			pTeleportResult.Dir = gObj[aIndex].Dir;
; 14387: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);
; 14388: 			return;

  000fe	74 3b		 je	 SHORT $LN52@CGTeleport
  00100	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN19@CGTeleport:

; 14389: 		}
; 14390: 	}
; 14391: 
; 14392: 	if(CC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE) //season 4.0 add-on (fix)

  00106	0f b6 84 3e 49
	01 00 00	 movzx	 eax, BYTE PTR [esi+edi+329]
  0010e	3c 35		 cmp	 al, 53			; 00000035H
  00110	74 11		 je	 SHORT $LN42@CGTeleport
  00112	3c 12		 cmp	 al, 18			; 00000012H
  00114	0f 82 82 00 00
	00		 jb	 $LN49@CGTeleport
  0011a	b1 17		 mov	 cl, 23			; 00000017H
  0011c	3a c8		 cmp	 cl, al
  0011e	1b c0		 sbb	 eax, eax
  00120	40		 inc	 eax
  00121	74 79		 je	 SHORT $LN49@CGTeleport
$LN42@CGTeleport:

; 14393: 	{
; 14394: 		if(g_ChaosCastle.GetCurrentState(gObj[aIndex].m_cChaosCastleIndex) == 3)

  00123	0f be 94 3e a5
	0e 00 00	 movsx	 edx, BYTE PTR [esi+edi+3749]
  0012b	52		 push	 edx
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00131	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  00136	83 f8 03	 cmp	 eax, 3
  00139	75 61		 jne	 SHORT $LN49@CGTeleport
$LN52@CGTeleport:

; 14395: 		{
; 14396: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 14397: 
; 14398: 			pTeleportResult.h.c = 0xC3;
; 14399: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 14400: 			pTeleportResult.h.headcode = 0x1C;
; 14401: 			pTeleportResult.MoveNumber = 0;

  0013b	33 c0		 xor	 eax, eax
  0013d	66 89 45 f4	 mov	 WORD PTR _pTeleportResult$249640[ebp+4], ax

; 14402: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00146	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pTeleportResult$249640[ebp], 2755 ; 00000ac3H
  0014c	c6 45 f2 1c	 mov	 BYTE PTR _pTeleportResult$249640[ebp+2], 28 ; 0000001cH
  00150	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00158	88 4d f6	 mov	 BYTE PTR _pTeleportResult$249640[ebp+6], cl

; 14403: 			pTeleportResult.MapX = gObj[aIndex].X;

  0015b	0f b6 94 06 44
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+324]
  00163	88 55 f7	 mov	 BYTE PTR _pTeleportResult$249640[ebp+7], dl

; 14404: 			pTeleportResult.MapY = gObj[aIndex].Y;

  00166	0f b6 8c 06 46
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+326]
  0016e	88 4d f8	 mov	 BYTE PTR _pTeleportResult$249640[ebp+8], cl

; 14405: 			pTeleportResult.Dir = gObj[aIndex].Dir;

  00171	0f b6 94 06 48
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+328]

; 14406: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  00179	6a 0a		 push	 10			; 0000000aH
  0017b	8d 45 f0	 lea	 eax, DWORD PTR _pTeleportResult$249640[ebp]
  0017e	88 55 f9	 mov	 BYTE PTR _pTeleportResult$249640[ebp+9], dl
  00181	50		 push	 eax
$LN53@CGTeleport:
  00182	53		 push	 ebx
  00183	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN51@CGTeleport:
  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
$LN2@CGTeleport:
  0018d	5b		 pop	 ebx

; 14535: 	}
; 14536: #endif
; 14537: }

  0018e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00191	33 cd		 xor	 ecx, ebp
  00193	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
$LN49@CGTeleport:

; 14407: 			return;
; 14408: 		}
; 14409: 	}
; 14410: 
; 14411: 
; 14412: #ifdef IMPERIAL_CONFLICT_NEW
; 14413: 	if( lpMsg->MoveNumber )
; 14414: 	{
; 14415: 		if ( CImperialGuardian::IsEventMap(gObj[aIndex].MapNumber) )
; 14416: 		{
; 14417: 			int nZoneIndex = g_ImperialGuardian.GetCurrentZoneIndex(aIndex);
; 14418: 
; 14419: 			if ( nZoneIndex >= 0 )
; 14420: 				g_ImperialGuardian.CGEnterPortal(aIndex, nZoneIndex + 1);
; 14421: 
; 14422: 			return;
; 14423: 		}
; 14424: 	}
; 14425: #endif
; 14426: 
; 14427: 	if ( lpMsg->MoveNumber == 0 )

  0019c	8b 7d e0	 mov	 edi, DWORD PTR _lpMsg$GSCopy$[ebp]
  0019f	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  001a3	66 85 c0	 test	 ax, ax
  001a6	0f 85 ea 01 00
	00		 jne	 $LN16@CGTeleport

; 14428: 	{
; 14429: 		CMagicInf * lpMagic;
; 14430: 		BYTE x;
; 14431: 		BYTE y;
; 14432: 		PMSG_MAGICATTACK_RESULT pAttack;
; 14433: 
; 14434: 		PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  001ac	6a 09		 push	 9
  001ae	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$249646[ebp]
  001b1	6a 19		 push	 25			; 00000019H
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 14435: 		pAttack.MagicNumberH = SET_NUMBERH(6);
; 14436: 		pAttack.MagicNumberL = SET_NUMBERL(6);
; 14437: 		pAttack.SourceNumberH = SET_NUMBERH(aIndex);
; 14438: 		pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 14439: 		pAttack.TargetNumberH = SET_NUMBERH(aIndex);
; 14440: 		pAttack.TargetNumberL = SET_NUMBERL(aIndex);
; 14441: 
; 14442: 
; 14443: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], 6);

  001b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bf	8b c3		 mov	 eax, ebx
  001c1	c1 e8 08	 shr	 eax, 8
  001c4	88 45 f5	 mov	 BYTE PTR _pAttack$249646[ebp+5], al
  001c7	88 45 f7	 mov	 BYTE PTR _pAttack$249646[ebp+7], al
  001ca	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  001cd	6a 06		 push	 6
  001cf	50		 push	 eax
  001d0	66 c7 45 f3 00
	06		 mov	 WORD PTR _pAttack$249646[ebp+3], 1536 ; 00000600H
  001d6	88 5d f6	 mov	 BYTE PTR _pAttack$249646[ebp+6], bl
  001d9	88 5d f8	 mov	 BYTE PTR _pAttack$249646[ebp+8], bl
  001dc	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  001e1	8b f8		 mov	 edi, eax

; 14444: 		x = lpMsg->MapX;

  001e3	8b 45 e0	 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]

; 14445: 		y = lpMsg->MapY;

  001e6	8a 50 07	 mov	 dl, BYTE PTR [eax+7]
  001e9	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  001ec	88 55 dc	 mov	 BYTE PTR _y$249645[ebp], dl

; 14446: 
; 14447: 		if ( gObjCheckTeleportArea(aIndex, x, y) == FALSE )

  001ef	8b 45 dc	 mov	 eax, DWORD PTR _y$249645[ebp]
  001f2	88 4d e0	 mov	 BYTE PTR _x$249644[ebp], cl
  001f5	8b 4d e0	 mov	 ecx, DWORD PTR _x$249644[ebp]
  001f8	50		 push	 eax
  001f9	51		 push	 ecx
  001fa	53		 push	 ebx
  001fb	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  00200	83 c4 20	 add	 esp, 32			; 00000020H
  00203	85 c0		 test	 eax, eax

; 14448: 		{
; 14449: 			LogAddC(2, "[%s][%s] Try Teleport Not Move Area [%d,%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);

  00205	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020a	75 7c		 jne	 SHORT $LN15@CGTeleport
  0020c	0f b6 55 dc	 movzx	 edx, BYTE PTR _y$249645[ebp]
  00210	0f b6 4d e0	 movzx	 ecx, BYTE PTR _x$249644[ebp]
  00214	52		 push	 edx
  00215	51		 push	 ecx
  00216	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0021a	52		 push	 edx
  0021b	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0021f	50		 push	 eax
  00220	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@
  00225	6a 02		 push	 2
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0022d	83 c4 18	 add	 esp, 24			; 00000018H

; 14450: 
; 14451: 			if ( szAuthKey[5] != AUTHKEY5 )

  00230	80 3d 05 00 00
	00 6c		 cmp	 BYTE PTR ?szAuthKey@@3PADA+5, 108 ; 0000006cH
  00237	74 05		 je	 SHORT $LN14@CGTeleport

; 14452: 			{
; 14453: 				DestroyGIocp();

  00239	e8 00 00 00 00	 call	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN14@CGTeleport:

; 14454: 			}
; 14455: 
; 14456: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 14457: 
; 14458: 			pTeleportResult.h.c = 0xC3;
; 14459: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 14460: 			pTeleportResult.h.headcode = 0x1C;
; 14461: 			pTeleportResult.MoveNumber = 0;
; 14462: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  0023e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00243	33 c9		 xor	 ecx, ecx
  00245	66 89 4d e8	 mov	 WORD PTR _pTeleportResult$249666[ebp+4], cx
  00249	66 c7 45 e4 c3
	0a		 mov	 WORD PTR _pTeleportResult$249666[ebp], 2755 ; 00000ac3H
  0024f	c6 45 e6 1c	 mov	 BYTE PTR _pTeleportResult$249666[ebp+2], 28 ; 0000001cH
  00253	0f b6 94 06 49
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+329]
  0025b	88 55 ea	 mov	 BYTE PTR _pTeleportResult$249666[ebp+6], dl

; 14463: 			pTeleportResult.MapX = gObj[aIndex].X;

  0025e	8a 8c 06 44 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+324]
  00265	88 4d eb	 mov	 BYTE PTR _pTeleportResult$249666[ebp+7], cl

; 14464: 			pTeleportResult.MapY = gObj[aIndex].Y;

  00268	0f b6 94 06 46
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+326]
  00270	88 55 ec	 mov	 BYTE PTR _pTeleportResult$249666[ebp+8], dl

; 14465: 			pTeleportResult.Dir = gObj[aIndex].Dir;

  00273	8a 84 06 48 01
	00 00		 mov	 al, BYTE PTR [esi+eax+328]

; 14466: 
; 14467: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  0027a	6a 0a		 push	 10			; 0000000aH
  0027c	8d 4d e4	 lea	 ecx, DWORD PTR _pTeleportResult$249666[ebp]
  0027f	88 45 ed	 mov	 BYTE PTR _pTeleportResult$249666[ebp+9], al
  00282	51		 push	 ecx

; 14468: 			return;

  00283	e9 fa fe ff ff	 jmp	 $LN53@CGTeleport
$LN15@CGTeleport:

; 14469: 		}
; 14470: 
; 14471: //#if(GS_CASTLE==1)
; 14472: 		if(gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE )

  00288	80 bc 06 49 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+329], 30 ; 0000001eH
  00290	75 30		 jne	 SHORT $LN12@CGTeleport

; 14473: 		{
; 14474: 			if( g_CastleSiege.CheckTeleportMagicAxisY(gObj[aIndex].Y,x,y) == FALSE )

  00292	0f b6 55 dc	 movzx	 edx, BYTE PTR _y$249645[ebp]
  00296	0f b6 4d e0	 movzx	 ecx, BYTE PTR _x$249644[ebp]
  0029a	52		 push	 edx
  0029b	0f bf 94 06 46
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+326]
  002a3	51		 push	 ecx
  002a4	52		 push	 edx
  002a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002aa	e8 00 00 00 00	 call	 ?CheckTeleportMagicAxisY@CCastleSiege@@QAEHHHH@Z ; CCastleSiege::CheckTeleportMagicAxisY
  002af	85 c0		 test	 eax, eax

; 14475: 			{
; 14476: 				y = gObj[aIndex].Y;

  002b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b6	75 0a		 jne	 SHORT $LN12@CGTeleport
  002b8	8a 8c 06 46 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+326]
  002bf	88 4d dc	 mov	 BYTE PTR _y$249645[ebp], cl
$LN12@CGTeleport:

; 14477: 			}
; 14478: 		}
; 14479: //#endif
; 14480: 
; 14481: 		if ( lpMagic )

  002c2	85 ff		 test	 edi, edi
  002c4	0f 84 61 01 00
	00		 je	 $LN46@CGTeleport

; 14482: 		{
; 14483: 			int usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  002ca	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  002cd	57		 push	 edi
  002ce	52		 push	 edx
  002cf	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  002d4	83 c4 08	 add	 esp, 8
  002d7	89 45 d8	 mov	 DWORD PTR _usemana$249671[ebp], eax

; 14484: 
; 14485: 			if ( usemana >= 0 )

  002da	85 c0		 test	 eax, eax
  002dc	0f 88 49 01 00
	00		 js	 $LN46@CGTeleport

; 14486: 			{
; 14487: 				int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  002e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e7	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  002ea	57		 push	 edi
  002eb	51		 push	 ecx
  002ec	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  002f1	8b f8		 mov	 edi, eax
  002f3	83 c4 08	 add	 esp, 8

; 14488: 				
; 14489: 				if ( usebp >= 0 )

  002f6	85 ff		 test	 edi, edi
  002f8	0f 88 2d 01 00
	00		 js	 $LN46@CGTeleport

; 14490: 				{
; 14491: 					if ( gObj[aIndex].Type == OBJ_USER )

  002fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00304	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  0030a	75 12		 jne	 SHORT $LN8@CGTeleport

; 14492: 					{
; 14493: 						DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  0030c	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$249646[ebp+1]
  00310	50		 push	 eax
  00311	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$249646[ebp]
  00314	51		 push	 ecx
  00315	53		 push	 ebx
  00316	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0031b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CGTeleport:

; 14494: 					}
; 14495: 
; 14496: 					MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  0031e	0f b6 55 f1	 movzx	 edx, BYTE PTR _pAttack$249646[ebp+1]
  00322	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00328	52		 push	 edx
  00329	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$249646[ebp]
  0032c	50		 push	 eax
  0032d	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00330	52		 push	 edx
  00331	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 14497: 					gObjTeleportMagicUse(aIndex, x, y);

  00336	8b 45 dc	 mov	 eax, DWORD PTR _y$249645[ebp]
  00339	8b 4d e0	 mov	 ecx, DWORD PTR _x$249644[ebp]
  0033c	50		 push	 eax
  0033d	51		 push	 ecx
  0033e	53		 push	 ebx
  0033f	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse

; 14498: 					gObj[aIndex].Mana = (float)usemana;

  00344	db 45 d8	 fild	 DWORD PTR _usemana$249671[ebp]
  00347	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034d	83 c4 18	 add	 esp, 24			; 00000018H
  00350	d9 9c 16 10 01
	00 00		 fstp	 DWORD PTR [esi+edx+272]

; 14499: 					gObj[aIndex].BP = usebp;

  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035c	89 bc 06 28 01
	00 00		 mov	 DWORD PTR [esi+eax+296], edi

; 14500: 					GCManaSend(gObj[aIndex].m_Index, gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  00363	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00369	8b 8c 3e 28 01
	00 00		 mov	 ecx, DWORD PTR [esi+edi+296]
  00370	d9 84 3e 10 01
	00 00		 fld	 DWORD PTR [esi+edi+272]
  00377	51		 push	 ecx
  00378	6a 00		 push	 0
  0037a	68 ff 00 00 00	 push	 255			; 000000ffH
  0037f	e8 00 00 00 00	 call	 __ftol2_sse
  00384	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  00387	50		 push	 eax
  00388	52		 push	 edx
  00389	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend
  0038e	83 c4 14	 add	 esp, 20			; 00000014H

; 14501: 				}
; 14502: 			}
; 14503: 		}
; 14504: 	}

  00391	e9 95 00 00 00	 jmp	 $LN46@CGTeleport
$LN16@CGTeleport:

; 14505: 	else if ( gGateC.IsInGate(aIndex, lpMsg->MoveNumber) )

  00396	50		 push	 eax
  00397	53		 push	 ebx
  00398	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  0039d	e8 00 00 00 00	 call	 ?IsInGate@CGate@@QAEHHH@Z ; CGate::IsInGate
  003a2	85 c0		 test	 eax, eax
  003a4	74 10		 je	 SHORT $LN6@CGTeleport

; 14506: 	{
; 14507: 		gObjMoveGate(aIndex, lpMsg->MoveNumber);

  003a6	0f b7 4f 04	 movzx	 ecx, WORD PTR [edi+4]
  003aa	51		 push	 ecx
  003ab	53		 push	 ebx
  003ac	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  003b1	83 c4 08	 add	 esp, 8

; 14508: 	}
; 14509: 	else

  003b4	eb 75		 jmp	 SHORT $LN46@CGTeleport
$LN6@CGTeleport:

; 14510: 	{
; 14511: 		gObjClearViewport(&gObj[aIndex]);

  003b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bc	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  003bf	50		 push	 eax
  003c0	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 14512: 		GCTeleportSend(&gObj[aIndex], lpMsg->MoveNumber, gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y, gObj[aIndex].Dir);

  003c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003cb	0f b6 94 0e 48
	01 00 00	 movzx	 edx, BYTE PTR [esi+ecx+328]
  003d3	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  003d6	0f b6 88 46 01
	00 00		 movzx	 ecx, BYTE PTR [eax+326]
  003dd	52		 push	 edx
  003de	0f b6 90 44 01
	00 00		 movzx	 edx, BYTE PTR [eax+324]
  003e5	51		 push	 ecx
  003e6	0f b6 88 49 01
	00 00		 movzx	 ecx, BYTE PTR [eax+329]
  003ed	52		 push	 edx
  003ee	0f b7 57 04	 movzx	 edx, WORD PTR [edi+4]
  003f2	51		 push	 ecx
  003f3	52		 push	 edx
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend

; 14513: 
; 14514: //#if(GS_CASTLE==1)
; 14515: 		if(gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE)

  003fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ff	83 c4 1c	 add	 esp, 28			; 0000001cH
  00402	80 bc 06 49 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+329], 30 ; 0000001eH
  0040a	75 1f		 jne	 SHORT $LN46@CGTeleport

; 14516: 		{
; 14517: 			if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  0040c	83 3d 28 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 7
  00413	75 16		 jne	 SHORT $LN46@CGTeleport

; 14518: 			{
; 14519: 				g_CastleSiege.NotifySelfCsJoinSide(aIndex);

  00415	53		 push	 ebx
  00416	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0041b	e8 00 00 00 00	 call	 ?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifySelfCsJoinSide

; 14520: 				g_CastleSiege.NotifyCsSelfLeftTime(aIndex);

  00420	53		 push	 ebx
  00421	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00426	e8 00 00 00 00	 call	 ?NotifyCsSelfLeftTime@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifyCsSelfLeftTime
$LN46@CGTeleport:

; 14521: 			}
; 14522: 		}
; 14523: //#endif
; 14524: 	}
; 14525: 
; 14526: #if(DEV_COMBO_CUSTOM==TRUE)
; 14527: 	if(g_ZtLicense.user.ComboCustom)

  0042b	80 3d dc 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+220, 0
  00432	0f 84 53 fd ff
	ff		 je	 $LN51@CGTeleport

; 14528: 	{
; 14529: 		int bCombo = 0;
; 14530: 		if(gComboAttack.CheckCombo(aIndex, 6))

  00438	6a 06		 push	 6
  0043a	53		 push	 ebx
  0043b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  00440	33 ff		 xor	 edi, edi
  00442	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo
  00447	85 c0		 test	 eax, eax
  00449	74 05		 je	 SHORT $LN1@CGTeleport

; 14531: 		{
; 14532: 			bCombo = 1;

  0044b	bf 01 00 00 00	 mov	 edi, 1
$LN1@CGTeleport:

; 14533: 		}
; 14534: 		gObj[aIndex].NewCombo = bCombo;

  00450	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00456	85 ff		 test	 edi, edi
  00458	0f 95 c1	 setne	 cl
  0045b	5f		 pop	 edi
  0045c	88 8c 16 88 28
	00 00		 mov	 BYTE PTR [esi+edx+10376], cl
  00463	5e		 pop	 esi
  00464	5b		 pop	 ebx

; 14535: 	}
; 14536: #endif
; 14537: }

  00465	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00468	33 cd		 xor	 ecx, ebp
  0046a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046f	8b e5		 mov	 esp, ebp
  00471	5d		 pop	 ebp
  00472	c3		 ret	 0
$LN25@CGTeleport:

; 14321: 	{
; 14322: 		PMSG_TELEPORT_RESULT pTeleportResult;
; 14323: 
; 14324: 		pTeleportResult.h.c = 0xC3;
; 14325: 		pTeleportResult.h.size = sizeof(pTeleportResult);
; 14326: 		pTeleportResult.h.headcode = 0x1C;
; 14327: 		pTeleportResult.MoveNumber = 0;

  00473	33 c0		 xor	 eax, eax
  00475	66 89 45 e8	 mov	 WORD PTR _pTeleportResult$249624[ebp+4], ax

; 14328: 		pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  00479	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047e	66 c7 45 e4 c3
	0a		 mov	 WORD PTR _pTeleportResult$249624[ebp], 2755 ; 00000ac3H
  00484	c6 45 e6 1c	 mov	 BYTE PTR _pTeleportResult$249624[ebp+2], 28 ; 0000001cH
  00488	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  00490	88 4d ea	 mov	 BYTE PTR _pTeleportResult$249624[ebp+6], cl

; 14329: 		pTeleportResult.MapX = gObj[aIndex].X;

  00493	0f b6 94 06 44
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+324]
  0049b	88 55 eb	 mov	 BYTE PTR _pTeleportResult$249624[ebp+7], dl

; 14330: 		pTeleportResult.MapY = gObj[aIndex].Y;

  0049e	0f b6 8c 06 46
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+326]
  004a6	88 4d ec	 mov	 BYTE PTR _pTeleportResult$249624[ebp+8], cl

; 14331: 		pTeleportResult.Dir = gObj[aIndex].Dir;

  004a9	0f b6 94 06 48
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+328]

; 14332: 		DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  004b1	6a 0a		 push	 10			; 0000000aH
  004b3	8d 45 e4	 lea	 eax, DWORD PTR _pTeleportResult$249624[ebp]
  004b6	50		 push	 eax
  004b7	53		 push	 ebx
  004b8	88 55 ed	 mov	 BYTE PTR _pTeleportResult$249624[ebp+9], dl
  004bb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14535: 	}
; 14536: #endif
; 14537: }

  004c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c6	5e		 pop	 esi
  004c7	33 cd		 xor	 ecx, ebp
  004c9	5b		 pop	 ebx
  004ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004cf	8b e5		 mov	 esp, ebp
  004d1	5d		 pop	 ebp
  004d2	c3		 ret	 0
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ENDP		; CGTeleportRecv
_TEXT	ENDS
PUBLIC	??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
;	COMDAT ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@
CONST	SEGMENT
??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@ DB '['
	DB	'%s][%s] Try Target Teleport Not Move Area [%d,%d]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z
_TEXT	SEGMENT
_usemana$249726 = -36					; size = 4
_aIndex$GSCopy$ = -32					; size = 4
_y$ = -28						; size = 1
_x$ = -24						; size = 1
_usebp$249728 = -20					; size = 4
_lpMagic$ = -20						; size = 4
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z PROC ; CGTargetTeleportRecv, COMDAT

; 14540: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 14611: 				}
; 14612: 
; 14613: 				MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  00018	89 5d e0	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0001b	85 db		 test	 ebx, ebx
  0001d	0f 88 5e 02 00
	00		 js	 $LN6@CGTargetTe

; 14541: 	if ( !OBJMAX_RANGE(aIndex))

  00023	33 c0		 xor	 eax, eax
  00025	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  0002b	0f 9e c0	 setle	 al
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 4b 02 00
	00		 je	 $LN6@CGTargetTe

; 14542: 	{
; 14543: 		return;
; 14544: 	}
; 14545: 
; 14546: 	if(gObjSearchActiveEffect(&gObj[aIndex], AT_STUN) == 1)

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	56		 push	 esi
  0003c	8b f3		 mov	 esi, ebx
  0003e	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00044	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00047	6a 3d		 push	 61			; 0000003dH
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0004f	83 c4 08	 add	 esp, 8
  00052	3c 01		 cmp	 al, 1
  00054	0f 84 26 02 00
	00		 je	 $LN21@CGTargetTe

; 14547: 	{
; 14548: 		return;
; 14549: 	}
; 14550: 
; 14551: 	if(gObjSearchActiveEffect(&gObj[aIndex], AT_SLEEP) == 1)

  0005a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00063	6a 48		 push	 72			; 00000048H
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  0006b	83 c4 08	 add	 esp, 8
  0006e	3c 01		 cmp	 al, 1
  00070	0f 84 0a 02 00
	00		 je	 $LN21@CGTargetTe

; 14552: 	{
; 14553: 		return;
; 14554: 	}
; 14555: 
; 14556: 	CMagicInf * lpMagic;
; 14557: 	BYTE x;
; 14558: 	BYTE y;
; 14559: 	PMSG_MAGICATTACK_RESULT pAttack;
; 14560: 
; 14561: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  00076	6a 09		 push	 9
  00078	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  0007b	6a 19		 push	 25			; 00000019H
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 14562: 	pAttack.MagicNumberH = SET_NUMBERH(AT_SKILL_TARGET_TELEPORT);
; 14563: 	pAttack.MagicNumberL = SET_NUMBERL(AT_SKILL_TARGET_TELEPORT);
; 14564: 	pAttack.SourceNumberH = SET_NUMBERH(aIndex);
; 14565: 	pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 14566: 	int iTargetIndex = MAKE_NUMBERW(lpMsg->NumberL, lpMsg->NumberH);

  00083	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00087	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  0008b	66 c1 e0 08	 shl	 ax, 8
  0008f	8b d3		 mov	 edx, ebx
  00091	88 5d f6	 mov	 BYTE PTR _pAttack$[ebp+6], bl
  00094	0f b7 d8	 movzx	 ebx, ax

; 14567: 	pAttack.TargetNumberH = SET_NUMBERH(iTargetIndex);
; 14568: 	pAttack.TargetNumberL = SET_NUMBERL(iTargetIndex);
; 14569: 	lpMagic = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TARGET_TELEPORT);

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009c	c1 ea 08	 shr	 edx, 8
  0009f	0b d9		 or	 ebx, ecx
  000a1	88 55 f5	 mov	 BYTE PTR _pAttack$[ebp+5], dl
  000a4	8b d3		 mov	 edx, ebx
  000a6	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000a9	c1 ea 08	 shr	 edx, 8
  000ac	6a 0f		 push	 15			; 0000000fH
  000ae	51		 push	 ecx
  000af	66 c7 45 f3 00
	0f		 mov	 WORD PTR _pAttack$[ebp+3], 3840 ; 00000f00H
  000b5	88 55 f7	 mov	 BYTE PTR _pAttack$[ebp+7], dl
  000b8	88 5d f8	 mov	 BYTE PTR _pAttack$[ebp+8], bl
  000bb	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 14570: 	x = lpMsg->MapX;

  000c0	8a 57 05	 mov	 dl, BYTE PTR [edi+5]
  000c3	89 45 ec	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 14571: 	y = lpMsg->MapY;

  000c6	8a 47 06	 mov	 al, BYTE PTR [edi+6]

; 14572: 
; 14573: 	if ( !gObjIsConnectedGP(iTargetIndex) )

  000c9	53		 push	 ebx
  000ca	88 55 e8	 mov	 BYTE PTR _x$[ebp], dl
  000cd	88 45 e4	 mov	 BYTE PTR _y$[ebp], al
  000d0	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  000d5	83 c4 18	 add	 esp, 24			; 00000018H
  000d8	85 c0		 test	 eax, eax

; 14574: 	{
; 14575: 		LogAddC(2, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);

  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14576: 		return;

  000df	74 7b		 je	 SHORT $LN22@CGTargetTe

; 14577: 	}
; 14578: 
; 14579: 	if(IT_MAP_RANGE(gObj[iTargetIndex].MapNumber) != FALSE) //season 2.5 add-on

  000e1	8b fb		 mov	 edi, ebx
  000e3	69 ff 50 2b 00
	00		 imul	 edi, 11088		; 00002b50H
  000e9	0f b6 8c 07 49
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+329]
  000f1	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000f4	72 24		 jb	 SHORT $LN20@CGTargetTe
  000f6	b2 32		 mov	 dl, 50			; 00000032H
  000f8	3a d1		 cmp	 dl, cl
  000fa	1b c9		 sbb	 ecx, ecx
  000fc	41		 inc	 ecx
  000fd	74 1b		 je	 SHORT $LN20@CGTargetTe

; 14580: 	{
; 14581: 		if(g_IllusionTempleEvent.CheckTeleport(gObj[iTargetIndex].m_Index) != FALSE)

  000ff	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  00102	50		 push	 eax
  00103	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  00108	e8 00 00 00 00	 call	 ?CheckTeleport@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::CheckTeleport
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 6b 01 00
	00		 jne	 $LN21@CGTargetTe
  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN20@CGTargetTe:

; 14582: 		{
; 14583: 			return;
; 14584: 		}
; 14585: 	}
; 14586: 
; 14587: 	if ( gObj[aIndex].PartyNumber != gObj[iTargetIndex].PartyNumber || gObj[aIndex].PartyNumber == -1 || gObj[iTargetIndex].PartyNumber == -1)

  0011a	8b 8c 06 2c 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1068]
  00121	8b 84 07 2c 04
	00 00		 mov	 eax, DWORD PTR [edi+eax+1068]
  00128	3b c8		 cmp	 ecx, eax
  0012a	0f 85 50 01 00
	00		 jne	 $LN21@CGTargetTe
  00130	83 f9 ff	 cmp	 ecx, -1
  00133	0f 84 47 01 00
	00		 je	 $LN21@CGTargetTe
  00139	83 f8 ff	 cmp	 eax, -1
  0013c	0f 84 3e 01 00
	00		 je	 $LN21@CGTargetTe

; 14588: 	{
; 14589: 		return;
; 14590: 	}
; 14591: 
; 14592: 	if ( !gObjCheckTeleportArea(iTargetIndex, x, y))

  00142	8b 4d e4	 mov	 ecx, DWORD PTR _y$[ebp]
  00145	8b 55 e8	 mov	 edx, DWORD PTR _x$[ebp]
  00148	51		 push	 ecx
  00149	52		 push	 edx
  0014a	53		 push	 ebx
  0014b	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH
  00153	85 c0		 test	 eax, eax
  00155	75 3a		 jne	 SHORT $LN5@CGTargetTe

; 14593: 	{
; 14594: 		LogAddC(2, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);

  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN22@CGTargetTe:
  0015c	0f b6 4d e4	 movzx	 ecx, BYTE PTR _y$[ebp]
  00160	0f b6 55 e8	 movzx	 edx, BYTE PTR _x$[ebp]
  00164	51		 push	 ecx
  00165	52		 push	 edx
  00166	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0016a	51		 push	 ecx
  0016b	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0016f	52		 push	 edx
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@
  00175	6a 02		 push	 2
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0017d	83 c4 18	 add	 esp, 24			; 00000018H
  00180	5e		 pop	 esi
  00181	5f		 pop	 edi
  00182	5b		 pop	 ebx

; 14620: #endif
; 14621: 				return;
; 14622: 			}
; 14623: 		}
; 14624: 	}
; 14625: }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
$LN5@CGTargetTe:

; 14595: 		return;
; 14596: 	}
; 14597: 
; 14598: 	if ( lpMagic )

  00191	8b 45 ec	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00194	85 c0		 test	 eax, eax
  00196	0f 84 e4 00 00
	00		 je	 $LN21@CGTargetTe

; 14599: 	{
; 14600: 		int usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  0019c	50		 push	 eax
  0019d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a2	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  001ab	83 c4 08	 add	 esp, 8
  001ae	89 45 dc	 mov	 DWORD PTR _usemana$249726[ebp], eax

; 14601: 
; 14602: 		if ( usemana >= 0 )

  001b1	85 c0		 test	 eax, eax
  001b3	0f 88 c7 00 00
	00		 js	 $LN21@CGTargetTe

; 14603: 		{
; 14604: 			int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  001b9	8b 55 ec	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c1	52		 push	 edx
  001c2	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  001cb	83 c4 08	 add	 esp, 8
  001ce	89 45 ec	 mov	 DWORD PTR _usebp$249728[ebp], eax

; 14605: 			
; 14606: 			if ( usebp >= 0 )

  001d1	85 c0		 test	 eax, eax
  001d3	0f 88 a7 00 00
	00		 js	 $LN21@CGTargetTe

; 14607: 			{
; 14608: 				if ( gObj[aIndex].Type == OBJ_USER )

  001d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001df	66 83 7c 16 68
	01		 cmp	 WORD PTR [esi+edx+104], 1
  001e5	75 15		 jne	 SHORT $LN1@CGTargetTe

; 14609: 				{
; 14610: 					DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  001e7	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  001eb	8b 55 e0	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  001ee	50		 push	 eax
  001ef	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  001f2	51		 push	 ecx
  001f3	52		 push	 edx
  001f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGTargetTe:

; 14611: 				}
; 14612: 
; 14613: 				MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  001fc	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00200	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00206	50		 push	 eax
  00207	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  0020a	51		 push	 ecx
  0020b	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 14614: 				gObjTeleportMagicUse(iTargetIndex, x, y);

  00214	8b 4d e4	 mov	 ecx, DWORD PTR _y$[ebp]
  00217	8b 55 e8	 mov	 edx, DWORD PTR _x$[ebp]
  0021a	51		 push	 ecx
  0021b	52		 push	 edx
  0021c	53		 push	 ebx
  0021d	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse

; 14615: 				gObj[aIndex].Mana = (float)usemana;

  00222	db 45 dc	 fild	 DWORD PTR _usemana$249726[ebp]
  00225	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14616: 				gObj[aIndex].BP = usebp;

  0022a	8b 55 ec	 mov	 edx, DWORD PTR _usebp$249728[ebp]
  0022d	83 c4 18	 add	 esp, 24			; 00000018H
  00230	d9 9c 06 10 01
	00 00		 fstp	 DWORD PTR [esi+eax+272]
  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023d	89 94 0e 28 01
	00 00		 mov	 DWORD PTR [esi+ecx+296], edx

; 14617: 				GCManaSend(gObj[aIndex].m_Index, gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  00244	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024a	8b 84 1e 28 01
	00 00		 mov	 eax, DWORD PTR [esi+ebx+296]
  00251	d9 84 1e 10 01
	00 00		 fld	 DWORD PTR [esi+ebx+272]
  00258	50		 push	 eax
  00259	6a 00		 push	 0
  0025b	68 ff 00 00 00	 push	 255			; 000000ffH
  00260	e8 00 00 00 00	 call	 __ftol2_sse
  00265	8b 0c 1e	 mov	 ecx, DWORD PTR [esi+ebx]
  00268	50		 push	 eax
  00269	51		 push	 ecx
  0026a	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 14618: #if(FIX_MUHELPER_TP == TRUE)
; 14619: 				gObj[iTargetIndex].MuHelperTeleportFix = true;

  0026f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00275	83 c4 14	 add	 esp, 20			; 00000014H
  00278	c6 84 17 cd 28
	00 00 01	 mov	 BYTE PTR [edi+edx+10445], 1
$LN21@CGTargetTe:
  00280	5e		 pop	 esi
$LN6@CGTargetTe:

; 14620: #endif
; 14621: 				return;
; 14622: 			}
; 14623: 		}
; 14624: 	}
; 14625: }

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	5f		 pop	 edi
  00285	33 cd		 xor	 ecx, ebp
  00287	5b		 pop	 ebx
  00288	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c3		 ret	 0
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ENDP ; CGTargetTeleportRecv
_TEXT	ENDS
PUBLIC	??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@ ; `string'
PUBLIC	??_C@_0BB@LIMFEILN@CItem?3?3GetName?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@ ; `string'
PUBLIC	??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@ ; `string'
PUBLIC	??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@ ; `string'
PUBLIC	??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ ; `string'
PUBLIC	??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ ; `string'
PUBLIC	__real@3fe4cccccccccccd
PUBLIC	??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@ ; `string'
PUBLIC	__real@4046800000000000
PUBLIC	??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@ ; `string'
PUBLIC	__real@4039000000000000
PUBLIC	??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@ ; `string'
PUBLIC	__real@4059000000000000
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@ ; `string'
PUBLIC	??_C@_0BG@ENOGABJL@SD?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@ ; `string'
PUBLIC	??_C@_0BG@DNDHNGMN@HP?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@ ; `string'
PUBLIC	??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@ ; `string'
PUBLIC	??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@ ; `string'
PUBLIC	??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@ ; `string'
PUBLIC	??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@ ; `string'
PUBLIC	??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@ ; `string'
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z		; CGUseItemRecv
EXTRN	?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAH@Z:PROC ; gObjMagicAdd
EXTRN	?IsClass@CItem@@QAEHDHH@Z:PROC			; CItem::IsClass
EXTRN	?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestState
EXTRN	?gObjUseCashShopStatFruit@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjUseCashShopStatFruit
EXTRN	?gObjUseCashShopStatPotion@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjUseCashShopStatPotion
EXTRN	?gObjUseFullRecoveryPotion@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjUseFullRecoveryPotion
EXTRN	?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemInsert
EXTRN	?gObjCheckRaiseTalismanMap@@YAHH@Z:PROC		; gObjCheckRaiseTalismanMap
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?GetKalimaGateLevel2@CKalimaGate@@QAEHH@Z:PROC	; CKalimaGate::GetKalimaGateLevel2
EXTRN	?gObjUseBlessAndSoulPotion@@YAXHH@Z:PROC	; gObjUseBlessAndSoulPotion
EXTRN	?GDUpdateExtendedWarehouseCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z:PROC ; GDUpdateExtendedWarehouseCount
EXTRN	?GDUpdateExtendedInvenCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z:PROC ; GDUpdateExtendedInvenCount
EXTRN	?gObjUseRecoveryPotion@@YAXPAUOBJECTSTRUCT@@HN@Z:PROC ; gObjUseRecoveryPotion
EXTRN	?gObjUseCashShopPkDownItem@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; gObjUseCashShopPkDownItem
EXTRN	?gObjUseMinusStatFruit@@YAXHH@Z:PROC		; gObjUseMinusStatFruit
EXTRN	?gObjUsePlusStatFruit@@YAXHH@Z:PROC		; gObjUsePlusStatFruit
EXTRN	?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; gObjUseDrink
EXTRN	?SearchUserDropQuestItem@CIllusionTempleEvent@@QAEXEH@Z:PROC ; CIllusionTempleEvent::SearchUserDropQuestItem
EXTRN	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDropQuestItem
EXTRN	?StrengthenItemByJewelOfRise@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CJewelOfHarmonySystem::StrengthenItemByJewelOfRise
EXTRN	?LuckyItemRepaire@LuckyItemManager@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; LuckyItemManager::LuckyItemRepaire
EXTRN	?JewelMain@cNewJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; cNewJewels::JewelMain
EXTRN	?CheckJewel@cNewJewels@@QAE_NH@Z:PROC		; cNewJewels::CheckJewel
EXTRN	?gNewJewels@@3VcNewJewels@@A:BYTE		; gNewJewels
EXTRN	?gObjItemRandomOption3Up@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemRandomOption3Up
EXTRN	?gObjItemRandomLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemRandomLevelUp
EXTRN	?gObjItemLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC	; gObjItemLevelUp
EXTRN	?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
EXTRN	?StrengthenItemByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CJewelOfHarmonySystem::StrengthenItemByJewelOfHarmony
EXTRN	?IsSocketOption@CSocketOption@@QAEEPAVCItem@@@Z:PROC ; CSocketOption::IsSocketOption
EXTRN	?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z:PROC ; gObjSetItemEffect
EXTRN	?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjSearchItemMinus
;	COMDAT ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIMFEILN@CItem?3?3GetName?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@LIMFEILN@CItem?3?3GetName?$CI?$CJ?$AA@ DB 'CItem::GetName()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@
CONST	SEGMENT
??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@ DB '['
	DB	'Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] '
	DB	'X:[%d] Y:[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@ DB '['
	DB	'Using Item] [Charm of Move] [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@
CONST	SEGMENT
??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@ DB '['
	DB	'Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X'
	DB	':[%d] Y:[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@
CONST	SEGMENT
??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@ DB '[PCS]'
	DB	' Use Free Kalima Ticket Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@
CONST	SEGMENT
??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@ DB '[PCS]'
	DB	' Use Free Kalima Ticket Success', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
CONST	SEGMENT
??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ DB '[Castle'
	DB	'Siege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s]['
	DB	'%s]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
CONST	SEGMENT
??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ DB '[Castle'
	DB	'Siege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s]['
	DB	'%s] - (Guild : %s)', 00H			; `string'
CONST	ENDS
;	COMDAT __real@3fe4cccccccccccd
CONST	SEGMENT
__real@3fe4cccccccccccd DQ 03fe4cccccccccccdr	; 0.65
CONST	ENDS
;	COMDAT ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@ DB '['
	DB	'Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@
CONST	SEGMENT
??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4046800000000000
CONST	SEGMENT
__real@4046800000000000 DQ 04046800000000000r	; 45
CONST	ENDS
;	COMDAT ??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@
CONST	SEGMENT
??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT ??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@
CONST	SEGMENT
??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@
CONST	SEGMENT
??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ENOGABJL@SD?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@
CONST	SEGMENT
??_C@_0BG@ENOGABJL@SD?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@ DB 'SD Delay:'
	DB	' %d / %d ms.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNDHNGMN@HP?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@
CONST	SEGMENT
??_C@_0BG@DNDHNGMN@HP?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@ DB 'HP Delay:'
	DB	' %d / %d ms.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@
CONST	SEGMENT
??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@ DB 'e'
	DB	'rror-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@
CONST	SEGMENT
??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@ DB '['
	DB	'%s][%s] CGUseItemRecv()_Inventory return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@
CONST	SEGMENT
??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@ DB '['
	DB	'%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@
CONST	SEGMENT
??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@ DB '['
	DB	'%s][%s] CGUseItemRecv()_CloseType return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@
CONST	SEGMENT
??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@ DB '['
	DB	'%s][%s] CGUseItemRecv()_If return %s %d', 00H ; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z
_TEXT	SEGMENT
_citem$ = -280						; size = 4
tv4751 = -276						; size = 4
tv4666 = -276						; size = 4
_bCheckEquipmentToMove$250268 = -276			; size = 4
_bCheckEquipmentToMove$250261 = -276			; size = 4
_iKalimaGateX$250250 = -276				; size = 4
tv2520 = -276						; size = 4
tv2478 = -276						; size = 4
_iLevel$250229 = -276					; size = 4
_level$250187 = -276					; size = 4
_skillnumber$250135 = -276				; size = 4
_iHPGage$250032 = -276					; size = 4
_iHPGage$250016 = -276					; size = 4
_iHPGage$250000 = -276					; size = 4
tv4138 = -272						; size = 4
tv2682 = -270						; size = 2
tv4283 = -268						; size = 4
tv4259 = -268						; size = 4
tv4227 = -268						; size = 4
tv4101 = -268						; size = 4
_iLevel$250245 = -268					; size = 4
_iDur$250231 = -268					; size = 4
_BuffEffectID$250220 = -268				; size = 4
_addskill$250138 = -268					; size = 4
_iShieldGage$250054 = -268				; size = 4
_iShieldGage$250047 = -268				; size = 4
_tLife$249956 = -268					; size = 4
_iItemUseType$ = -268					; size = 4
_lpMsg$GSCopy$ = -264					; size = 4
_iSerial$250230 = -264					; size = 4
_iShieldGage$250031 = -264				; size = 4
_iShieldGage$250015 = -264				; size = 4
_iShieldGage$249999 = -264				; size = 4
_tMana$249983 = -264					; size = 4
_nAddRate$249958 = -264					; size = 4
_szTemp$250275 = -260					; size = 256
_szTemp$250265 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z PROC		; CGUseItemRecv, COMDAT

; 15301: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 15302: 	int pos;
; 15303: 
; 15304: 	CItem * citem;
; 15305: 
; 15306: 	int iItemUseType = lpMsg->btItemUseType;
; 15307: 
; 15308: 	//      .
; 15309: 	if ( gObj[aIndex].m_IfState.use && 
; 15310: 		gObj[aIndex].m_IfState.type != 3 )

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00021	8b f7		 mov	 esi, edi
  00023	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H

; 16354: 		{
; 16355: 			int iLevel = citem->m_Level;

  00029	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax
  0002f	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00033	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iItemUseType$[ebp], eax
  00039	8b 84 31 1c 0e
	00 00		 mov	 eax, DWORD PTR [ecx+esi+3612]
  00040	a8 03		 test	 al, 3
  00042	74 65		 je	 SHORT $LN279@CGUseItemR

; 15302: 	int pos;
; 15303: 
; 15304: 	CItem * citem;
; 15305: 
; 15306: 	int iItemUseType = lpMsg->btItemUseType;
; 15307: 
; 15308: 	//      .
; 15309: 	if ( gObj[aIndex].m_IfState.use && 
; 15310: 		gObj[aIndex].m_IfState.type != 3 )

  00044	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00049	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0004e	74 59		 je	 SHORT $LN279@CGUseItemR

; 15311: 	{
; 15312: 		//////////////////////
; 15313: 		GCReFillSend(aIndex, 
; 15314: 			gObj[aIndex].Life, 
; 15315: 			0xFD, 
; 15316: 			TRUE, 
; 15317: 			gObj[aIndex].iShield);

  00050	8b 94 31 54 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+340]
  00057	d9 84 31 fc 00
	00 00		 fld	 DWORD PTR [ecx+esi+252]
  0005e	52		 push	 edx
  0005f	6a 01		 push	 1
  00061	68 fd 00 00 00	 push	 253			; 000000fdH
  00066	e8 00 00 00 00	 call	 __ftol2_sse
  0006b	50		 push	 eax
  0006c	57		 push	 edi
  0006d	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 15318: 		LogAdd("[%s][%s] CGUseItemRecv()_If return %s %d",
; 15319: 			gObj[aIndex].AccountID,
; 15320: 			gObj[aIndex].Name, 
; 15321: 			__FILE__,
; 15322: 			__LINE__);

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00077	68 da 3b 00 00	 push	 15322			; 00003bdaH
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00081	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  00085	51		 push	 ecx
  00086	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  0008a	52		 push	 edx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00096	83 c4 28	 add	 esp, 40			; 00000028H
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0009b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009e	33 cd		 xor	 ecx, ebp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN279@CGUseItemR:

; 15323: 		return;
; 15324: 	}
; 15325: 
; 15326: 	//    
; 15327: 	if ( gObj[aIndex].CloseType != -1 )

  000a9	80 7c 31 0b ff	 cmp	 BYTE PTR [ecx+esi+11], -1
  000ae	74 59		 je	 SHORT $LN278@CGUseItemR

; 15328: 	{
; 15329: 		////////////
; 15330: 		GCReFillSend(aIndex, 
; 15331: 			gObj[aIndex].Life, 
; 15332: 			0xFD, 
; 15333: 			TRUE, 
; 15334: 			gObj[aIndex].iShield);

  000b0	8b 84 31 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+esi+340]
  000b7	d9 84 31 fc 00
	00 00		 fld	 DWORD PTR [ecx+esi+252]
  000be	50		 push	 eax
  000bf	6a 01		 push	 1
  000c1	68 fd 00 00 00	 push	 253			; 000000fdH
  000c6	e8 00 00 00 00	 call	 __ftol2_sse
  000cb	50		 push	 eax
  000cc	57		 push	 edi
  000cd	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 15335: 		LogAdd("[%s][%s] CGUseItemRecv()_CloseType return %s %d",
; 15336: 			gObj[aIndex].AccountID,
; 15337: 			gObj[aIndex].Name,
; 15338: 			__FILE__,
; 15339: 			__LINE__);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d7	68 eb 3b 00 00	 push	 15339			; 00003bebH
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000e1	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  000e5	51		 push	 ecx
  000e6	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  000ea	52		 push	 edx
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f6	83 c4 28	 add	 esp, 40			; 00000028H
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi

; 16547: 	}
; 16548: }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 cd		 xor	 ecx, ebp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
$LN278@CGUseItemR:

; 15340: 
; 15341: 		return;
; 15342: 	}
; 15343: 
; 15344: 	///////////
; 15345: 	if ( gObjFixInventoryPointer(aIndex) == false )

  00109	57		 push	 edi
  0010a	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0010f	83 c4 04	 add	 esp, 4
  00112	84 c0		 test	 al, al
  00114	75 18		 jne	 SHORT $LN277@CGUseItemR

; 15346: 	{
; 15347: 		///////////////////
; 15348: 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d",	
; 15349: 			__FILE__, 
; 15350: 			__LINE__);

  00116	68 f6 3b 00 00	 push	 15350			; 00003bf6H
  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN277@CGUseItemR:

; 15351: 
; 15352: 	}
; 15353: 
; 15354: 	/////////////
; 15355: 	if ( gObj[aIndex].pTransaction == 1 )

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00133	80 bc 30 30 0e
	00 00 01	 cmp	 BYTE PTR [eax+esi+3632], 1
  0013b	75 39		 jne	 SHORT $LN276@CGUseItemR

; 15356: 	{
; 15357: 
; 15358: 		LogAddTD("[%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : %d",
; 15359: 			gObj[aIndex].AccountID,
; 15360: 			gObj[aIndex].Name,
; 15361: 			gObj[aIndex].m_IfState.type);

  0013d	8b 8c 30 1c 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3612]
  00144	c1 e9 06	 shr	 ecx, 6
  00147	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0014d	51		 push	 ecx
  0014e	8d 54 30 77	 lea	 edx, DWORD PTR [eax+esi+119]
  00152	52		 push	 edx
  00153	8d 44 30 6c	 lea	 eax, DWORD PTR [eax+esi+108]
  00157	50		 push	 eax
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00163	83 c4 10	 add	 esp, 16			; 00000010H
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi

; 16547: 	}
; 16548: }

  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
$LN276@CGUseItemR:

; 15362: 		
; 15363: 		return;
; 15364: 	}
; 15365: 
; 15366: 	pos = lpMsg->inventoryPos;

  00176	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  0017c	8a 4a 03	 mov	 cl, BYTE PTR [edx+3]
  0017f	53		 push	 ebx
  00180	0f b6 d9	 movzx	 ebx, cl

; 15367: 
; 15368: 	/////////////////
; 15369: 	if ( pos > MAIN_INVENTORY_SIZE-1 )

  00183	81 fb cb 00 00
	00		 cmp	 ebx, 203		; 000000cbH
  00189	7e 6d		 jle	 SHORT $LN275@CGUseItemR

; 15370: 	{
; 15371: 		/////////////
; 15372: 		LogAdd(lMsg.Get(MSGGET(1, 241)), 
; 15373: 			__FILE__, 
; 15374: 			__LINE__);

  0018b	68 0e 3c 00 00	 push	 15374			; 00003c0eH
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00195	68 f1 01 00 00	 push	 497			; 000001f1H
  0019a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0019f	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 15375: 		GCReFillSend(aIndex, 
; 15376: 			gObj[aIndex].Life, 
; 15377: 			0xFD, 
; 15378: 			TRUE, 
; 15379: 			gObj[aIndex].iShield);

  001ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b0	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  001b7	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c1	51		 push	 ecx
  001c2	6a 01		 push	 1
  001c4	68 fd 00 00 00	 push	 253			; 000000fdH
  001c9	e8 00 00 00 00	 call	 __ftol2_sse
  001ce	50		 push	 eax
  001cf	57		 push	 edi
  001d0	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 15380: 		LogAdd("[%s][%s] CGUseItemRecv()_Inventory return %s %d", 
; 15381: 			gObj[aIndex].AccountID, 
; 15382: 			gObj[aIndex].Name, 
; 15383: 			__FILE__, 
; 15384: 			__LINE__);

  001d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001da	68 18 3c 00 00	 push	 15384			; 00003c18H
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001e4	8d 54 30 77	 lea	 edx, DWORD PTR [eax+esi+119]
  001e8	52		 push	 edx
  001e9	8d 44 30 6c	 lea	 eax, DWORD PTR [eax+esi+108]
  001ed	50		 push	 eax
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@

; 15385: 
; 15386: 		return;

  001f3	e9 7e 29 00 00	 jmp	 $LN363@CGUseItemR
$LN275@CGUseItemR:

; 15387: 	}
; 15388: 
; 15389: 	//    
; 15390: 	if ( lpMsg->inventoryPos == lpMsg->invenrotyTarget )

  001f8	3a 4a 04	 cmp	 cl, BYTE PTR [edx+4]
  001fb	75 45		 jne	 SHORT $LN274@CGUseItemR

; 15391: 	{
; 15392: 		GCReFillSend(aIndex, 
; 15393: 			gObj[aIndex].Life, 
; 15394: 			0xFD, 
; 15395: 			TRUE, 
; 15396: 			gObj[aIndex].iShield);

  001fd	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  00204	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  0020b	51		 push	 ecx
  0020c	6a 01		 push	 1
  0020e	68 fd 00 00 00	 push	 253			; 000000fdH
  00213	e8 00 00 00 00	 call	 __ftol2_sse
  00218	50		 push	 eax
  00219	57		 push	 edi
  0021a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 15397: 		LogAdd("error-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d",
; 15398: 			gObj[aIndex].AccountID,	
; 15399: 			gObj[aIndex].Name,	
; 15400: 			__FILE__, 
; 15401: 			__LINE__);

  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00224	68 29 3c 00 00	 push	 15401			; 00003c29H
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0022e	8d 54 30 77	 lea	 edx, DWORD PTR [eax+esi+119]
  00232	52		 push	 edx
  00233	8d 44 30 6c	 lea	 eax, DWORD PTR [eax+esi+108]
  00237	50		 push	 eax
  00238	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@

; 15402: 		return;

  0023d	e9 34 29 00 00	 jmp	 $LN363@CGUseItemR
$LN274@CGUseItemR:

; 15403: 	}
; 15404: 
; 15405: 	citem = &gObj[aIndex].pInventory[pos];

  00242	8b 84 30 24 0e
	00 00		 mov	 eax, DWORD PTR [eax+esi+3620]
  00249	8b cb		 mov	 ecx, ebx
  0024b	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00251	03 c1		 add	 eax, ecx
  00253	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv4138[ebp], ecx

; 15406: 
; 15407: #if(CUSTOM_POTIONTICK)
; 15408: 	if(g_ZtLicense.CheckUser(eZtUB::Local)			|| 
; 15409: 		g_ZtLicense.CheckUser(eZtUB::Gredy)			|| 
; 15410: 		g_ZtLicense.CheckUser(eZtUB::GredyLocal)	|| 
; 15411: 		g_ZtLicense.CheckUser(eZtUB::Gredy2)		||
; 15412: 		g_ZtLicense.CheckUser(eZtUB::SILVER1)		||
; 15413: 		g_ZtLicense.CheckUser(eZtUB::SILVER2)		||
; 15414: 		g_ZtLicense.CheckUser(eZtUB::SILVER_Local)	||
; 15415: 		g_ZtLicense.CheckUser(eZtUB::Stone) )

  00259	6a 00		 push	 0
  0025b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00260	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _citem$[ebp], eax
  00266	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0026b	84 c0		 test	 al, al
  0026d	75 74		 jne	 SHORT $LN272@CGUseItemR
  0026f	6a 20		 push	 32			; 00000020H
  00271	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00276	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0027b	84 c0		 test	 al, al
  0027d	75 64		 jne	 SHORT $LN272@CGUseItemR
  0027f	6a 21		 push	 33			; 00000021H
  00281	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00286	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0028b	84 c0		 test	 al, al
  0028d	75 54		 jne	 SHORT $LN272@CGUseItemR
  0028f	6a 22		 push	 34			; 00000022H
  00291	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00296	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0029b	84 c0		 test	 al, al
  0029d	75 44		 jne	 SHORT $LN272@CGUseItemR
  0029f	6a 07		 push	 7
  002a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002a6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002ab	84 c0		 test	 al, al
  002ad	75 34		 jne	 SHORT $LN272@CGUseItemR
  002af	6a 08		 push	 8
  002b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002b6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002bb	84 c0		 test	 al, al
  002bd	75 24		 jne	 SHORT $LN272@CGUseItemR
  002bf	6a 2b		 push	 43			; 0000002bH
  002c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002c6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002cb	84 c0		 test	 al, al
  002cd	75 14		 jne	 SHORT $LN272@CGUseItemR
  002cf	6a 37		 push	 55			; 00000037H
  002d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  002d6	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  002db	84 c0		 test	 al, al
  002dd	0f 84 d6 00 00
	00		 je	 $LN264@CGUseItemR
$LN272@CGUseItemR:

; 15416: 	{
; 15417: 		if(citem->m_Type >= ITEMGET(14, 0) && citem->m_Type <= ITEMGET(14, 3) || citem->m_Type== ITEMGET(14, 70))

  002e3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  002e9	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  002ed	ba 00 1c 00 00	 mov	 edx, 7168		; 00001c00H
  002f2	66 3b c2	 cmp	 ax, dx
  002f5	7c 0a		 jl	 SHORT $LN269@CGUseItemR
  002f7	b9 03 1c 00 00	 mov	 ecx, 7171		; 00001c03H
  002fc	66 3b c1	 cmp	 ax, cx
  002ff	7e 0a		 jle	 SHORT $LN270@CGUseItemR
$LN269@CGUseItemR:
  00301	ba 46 1c 00 00	 mov	 edx, 7238		; 00001c46H
  00306	66 3b c2	 cmp	 ax, dx
  00309	75 42		 jne	 SHORT $LN271@CGUseItemR
$LN270@CGUseItemR:

; 15418: 		{
; 15419: 			DWORD CurrentTick	= GetTickCount();

  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 15420: 			DWORD Delay			= CurrentTick - gObj[aIndex].m_PotionTick;

  00311	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00317	2b 84 31 0c 29
	00 00		 sub	 eax, DWORD PTR [ecx+esi+10508]

; 15421: 			if( Delay < ZtConfig.CommonServer.PotionDelay )

  0031e	8b 0d 30 01 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+304
  00324	3b c1		 cmp	 eax, ecx
  00326	0f 83 8d 00 00
	00		 jae	 $LN264@CGUseItemR

; 15422: 			{
; 15423: 				MsgOutput(aIndex, "HP Delay: %d / %d ms.", Delay, ZtConfig.CommonServer.PotionDelay);

  0032c	51		 push	 ecx
  0032d	50		 push	 eax
  0032e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DNDHNGMN@HP?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@
  00333	57		 push	 edi
  00334	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00339	83 c4 10	 add	 esp, 16			; 00000010H
  0033c	5b		 pop	 ebx
  0033d	5f		 pop	 edi
  0033e	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0033f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00342	33 cd		 xor	 ecx, ebp
  00344	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c3		 ret	 0
$LN271@CGUseItemR:

; 15424: 				return;
; 15425: 			}
; 15426: 		}
; 15427: 		else if(g_ZtLicense.CheckUser(eZtUB::Stone))

  0034d	6a 37		 push	 55			; 00000037H
  0034f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00354	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00359	84 c0		 test	 al, al
  0035b	74 5c		 je	 SHORT $LN264@CGUseItemR

; 15428: 		{
; 15429: 			if(citem->m_Type >= ITEMGET(14, 35) && citem->m_Type <= ITEMGET(14, 40))

  0035d	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  00363	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00367	b9 23 1c 00 00	 mov	 ecx, 7203		; 00001c23H
  0036c	66 3b c1	 cmp	 ax, cx
  0036f	7c 48		 jl	 SHORT $LN264@CGUseItemR
  00371	ba 28 1c 00 00	 mov	 edx, 7208		; 00001c28H
  00376	66 3b c2	 cmp	 ax, dx
  00379	7f 3e		 jg	 SHORT $LN264@CGUseItemR

; 15430: 			{
; 15431: 				DWORD CurrentTick	= GetTickCount();

  0037b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 15432: 				DWORD Delay			= CurrentTick - gObj[aIndex].m_PotionTick;

  00381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00387	2b 84 31 0c 29
	00 00		 sub	 eax, DWORD PTR [ecx+esi+10508]

; 15433: 				if( Delay < ZtConfig.CommonServer.PotionDelay )

  0038e	8b 0d 30 01 00
	00		 mov	 ecx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+304
  00394	3b c1		 cmp	 eax, ecx
  00396	73 21		 jae	 SHORT $LN264@CGUseItemR

; 15434: 				{
; 15435: 					MsgOutput(aIndex, "SD Delay: %d / %d ms.", Delay, ZtConfig.CommonServer.PotionDelay);

  00398	51		 push	 ecx
  00399	50		 push	 eax
  0039a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@ENOGABJL@SD?5Delay?3?5?$CFd?5?1?5?$CFd?5ms?4?$AA@
  0039f	57		 push	 edi
  003a0	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  003a5	83 c4 10	 add	 esp, 16			; 00000010H
  003a8	5b		 pop	 ebx
  003a9	5f		 pop	 edi
  003aa	5e		 pop	 esi

; 16547: 	}
; 16548: }

  003ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ae	33 cd		 xor	 ecx, ebp
  003b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b5	8b e5		 mov	 esp, ebp
  003b7	5d		 pop	 ebp
  003b8	c3		 ret	 0
$LN264@CGUseItemR:

; 15436: 					return;
; 15437: 				}
; 15438: 			}
; 15439: 		}
; 15440: 	}
; 15441: #endif
; 15442: 
; 15443: 	if ( citem->IsItem() )

  003b9	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  003bf	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003c4	85 c0		 test	 eax, eax
  003c6	0f 84 68 27 00
	00		 je	 $LN263@CGUseItemR

; 15444: 	{
; 15445: 		if ( gObjCheckSerial0ItemList(citem) )

  003cc	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  003d8	83 c4 04	 add	 esp, 4
  003db	85 c0		 test	 eax, eax
  003dd	74 7d		 je	 SHORT $LN262@CGUseItemR

; 15446: 		{
; 15447: 			MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  003df	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  003e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003e9	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  003ee	50		 push	 eax
  003ef	57		 push	 edi
  003f0	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 15448: 			GCReFillSend(aIndex, 
; 15449: 				gObj[aIndex].Life, 
; 15450: 				0xFD, 
; 15451: 				TRUE, 
; 15452: 				gObj[aIndex].iShield);

  003f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003fa	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  00401	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  00408	83 c4 08	 add	 esp, 8
  0040b	51		 push	 ecx
  0040c	6a 01		 push	 1
  0040e	68 fd 00 00 00	 push	 253			; 000000fdH
  00413	e8 00 00 00 00	 call	 __ftol2_sse
  00418	50		 push	 eax
  00419	57		 push	 edi
  0041a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 15453: 			LogAddTD("[ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)", 
; 15454: 				gObj[aIndex].AccountID, 
; 15455: 				gObj[aIndex].Name, 
; 15456: 				citem->GetName(), 
; 15457: 				pos);

  0041f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  00425	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042b	83 c4 14	 add	 esp, 20			; 00000014H
  0042e	53		 push	 ebx
  0042f	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00434	50		 push	 eax
  00435	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  00438	50		 push	 eax
  00439	83 c6 6c	 add	 esi, 108		; 0000006cH
  0043c	56		 push	 esi
  0043d	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@
  00442	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16092: 				{
; 16093: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  00448	83 c4 14	 add	 esp, 20			; 00000014H
  0044b	5b		 pop	 ebx
  0044c	5f		 pop	 edi
  0044d	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0044e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00451	33 cd		 xor	 ecx, ebp
  00453	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00458	8b e5		 mov	 esp, ebp
  0045a	5d		 pop	 ebp
  0045b	c3		 ret	 0
$LN262@CGUseItemR:

; 15458: 			return;
; 15459: 		}
; 15460: 
; 15461: 		if ( gObjInventorySearchSerialNumber(&gObj[aIndex], citem->GetNumber()) == FALSE )

  0045c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  00462	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00467	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046d	50		 push	 eax
  0046e	03 ce		 add	 ecx, esi
  00470	51		 push	 ecx
  00471	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00476	83 c4 08	 add	 esp, 8
  00479	85 c0		 test	 eax, eax
  0047b	75 4a		 jne	 SHORT $LN261@CGUseItemR

; 15462: 		{
; 15463: 			GCReFillSend(aIndex, 
; 15464: 				gObj[aIndex].Life, 
; 15465: 				0xFD, 
; 15466: 				TRUE, 
; 15467: 				gObj[aIndex].iShield);			

  0047d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00482	8b 94 30 54 01
	00 00		 mov	 edx, DWORD PTR [eax+esi+340]
  00489	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  00490	52		 push	 edx
  00491	6a 01		 push	 1
  00493	68 fd 00 00 00	 push	 253			; 000000fdH
  00498	e8 00 00 00 00	 call	 __ftol2_sse
  0049d	50		 push	 eax
  0049e	57		 push	 edi
  0049f	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 15468: 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",	
; 15469: 				gObj[aIndex].AccountID,	
; 15470: 				gObj[aIndex].Name,	
; 15471: 				__FILE__, 
; 15472: 				__LINE__);

  004a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004a9	68 70 3c 00 00	 push	 15472			; 00003c70H
  004ae	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  004b3	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  004b7	51		 push	 ecx
  004b8	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  004bc	52		 push	 edx
  004bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@

; 15473: 			return;

  004c2	e9 af 26 00 00	 jmp	 $LN363@CGUseItemR
$LN261@CGUseItemR:

; 15474: 		}
; 15475: 
; 15476: 		if ( citem->m_serial && !gObjCanItemTouch(&gObj[aIndex], 1) )

  004c7	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  004cd	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  004d1	74 20		 je	 SHORT $LN260@CGUseItemR
  004d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004d8	03 c6		 add	 eax, esi
  004da	6a 01		 push	 1
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  004e2	83 c4 08	 add	 esp, 8
  004e5	85 c0		 test	 eax, eax

; 15477: 		{
; 15478: 			GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 15479: 			return;

  004e7	0f 84 fa 1d 00
	00		 je	 $LN132@CGUseItemR
  004ed	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
$LN260@CGUseItemR:

; 15480: 		}
; 15481: 
; 15482: 		if (citem->m_Type == ITEMGET(14,0) || 
; 15483: 			citem->m_Type == ITEMGET(14,1) || 
; 15484: 			citem->m_Type == ITEMGET(14,2) || 
; 15485: 			citem->m_Type == ITEMGET(14,3) )

  004f3	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  004f7	ba 00 1c 00 00	 mov	 edx, 7168		; 00001c00H
  004fc	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv4751[ebp], eax
  00502	66 3b c2	 cmp	 ax, dx
  00505	0f 84 bf 23 00
	00		 je	 $LN258@CGUseItemR
  0050b	ba 01 1c 00 00	 mov	 edx, 7169		; 00001c01H
  00510	66 3b c2	 cmp	 ax, dx
  00513	0f 84 b1 23 00
	00		 je	 $LN258@CGUseItemR
  00519	ba 02 1c 00 00	 mov	 edx, 7170		; 00001c02H
  0051e	66 3b c2	 cmp	 ax, dx
  00521	0f 84 a3 23 00
	00		 je	 $LN258@CGUseItemR
  00527	ba 03 1c 00 00	 mov	 edx, 7171		; 00001c03H
  0052c	66 3b c2	 cmp	 ax, dx
  0052f	0f 84 95 23 00
	00		 je	 $LN258@CGUseItemR

; 15562: 			}
; 15563: 		}
; 15564: 		else if(citem->m_Type == ITEMGET(14,4) || 
; 15565: 				citem->m_Type == ITEMGET(14,5) || 
; 15566: 				citem->m_Type == ITEMGET(14,6)  )

  00535	ba 04 1c 00 00	 mov	 edx, 7172		; 00001c04H
  0053a	66 3b c2	 cmp	 ax, dx
  0053d	0f 84 ea 21 00
	00		 je	 $LN238@CGUseItemR
  00543	ba 05 1c 00 00	 mov	 edx, 7173		; 00001c05H
  00548	66 3b c2	 cmp	 ax, dx
  0054b	0f 84 dc 21 00
	00		 je	 $LN238@CGUseItemR
  00551	ba 06 1c 00 00	 mov	 edx, 7174		; 00001c06H
  00556	66 3b c2	 cmp	 ax, dx
  00559	0f 84 ce 21 00
	00		 je	 $LN238@CGUseItemR

; 15602: 			}
; 15603: 		}
; 15604: 		else if ( citem->m_Type == ITEMGET(14,38) )

  0055f	b9 26 1c 00 00	 mov	 ecx, 7206		; 00001c26H
  00564	66 3b c1	 cmp	 ax, cx
  00567	0f 85 20 02 00
	00		 jne	 $LN228@CGUseItemR

; 15605: 		{
; 15606: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 5/100;

  0056d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15607: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 10.0f / 100.0f );

  00573	db 84 31 4c 01
	00 00		 fild	 DWORD PTR [ecx+esi+332]
  0057a	8b 84 31 5c 01
	00 00		 mov	 eax, DWORD PTR [ecx+esi+348]
  00581	03 84 31 58 01
	00 00		 add	 eax, DWORD PTR [ecx+esi+344]
  00588	d8 84 31 00 01
	00 00		 fadd	 DWORD PTR [ecx+esi+256]
  0058f	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00592	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00597	f7 ea		 imul	 edx
  00599	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  0059f	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  005a5	c1 fa 05	 sar	 edx, 5
  005a8	8b c2		 mov	 eax, edx
  005aa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005ad	03 c2		 add	 eax, edx
  005af	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$249999[ebp], eax
  005b5	e8 00 00 00 00	 call	 __ftol2_sse

; 15608: 
; 15609: 			if ( gObj[aIndex].iShield < 0 )

  005ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005c0	83 bc 32 54 01
	00 00 00	 cmp	 DWORD PTR [edx+esi+340], 0
  005c8	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iHPGage$250000[ebp], eax
  005ce	8d 84 32 54 01
	00 00		 lea	 eax, DWORD PTR [edx+esi+340]
  005d5	7d 06		 jge	 SHORT $LN328@CGUseItemR

; 15610: 			{
; 15611: 				gObj[aIndex].iShield = 0;

  005d7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN328@CGUseItemR:
  005dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15612: 			}
; 15613: 
; 15614: 			if ( gObj[aIndex].FillLife > 0.0f )

  005e3	d9 ee		 fldz
  005e5	d8 9c 31 08 01
	00 00		 fcomp	 DWORD PTR [ecx+esi+264]
  005ec	8d 94 31 08 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+264]
  005f3	df e0		 fnstsw	 ax
  005f5	f6 c4 05	 test	 ah, 5
  005f8	7a 3f		 jp	 SHORT $LN225@CGUseItemR

; 15615: 			{
; 15616: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  005fa	d9 02		 fld	 DWORD PTR [edx]
  005fc	8d 84 31 fc 00
	00 00		 lea	 eax, DWORD PTR [ecx+esi+252]
  00603	d8 00		 fadd	 DWORD PTR [eax]
  00605	d9 18		 fstp	 DWORD PTR [eax]

; 15617: 
; 15618: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  00607	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0060d	db 84 31 4c 01
	00 00		 fild	 DWORD PTR [ecx+esi+332]
  00614	8d 94 31 fc 00
	00 00		 lea	 edx, DWORD PTR [ecx+esi+252]
  0061b	d8 84 31 00 01
	00 00		 fadd	 DWORD PTR [ecx+esi+256]
  00622	d9 02		 fld	 DWORD PTR [edx]
  00624	d8 d9		 fcomp	 ST(1)
  00626	df e0		 fnstsw	 ax
  00628	f6 c4 41	 test	 ah, 65			; 00000041H
  0062b	75 0a		 jne	 SHORT $LN345@CGUseItemR

; 15619: 				{
; 15620: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  0062d	d9 1a		 fstp	 DWORD PTR [edx]
  0062f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00635	eb 02		 jmp	 SHORT $LN225@CGUseItemR
$LN345@CGUseItemR:
  00637	dd d8		 fstp	 ST(0)
$LN225@CGUseItemR:

; 15621: 				}
; 15622: 			}
; 15623: 
; 15624: 			if ( gObj[aIndex].iFillShield > 0 )

  00639	8b 94 31 64 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+356]
  00640	85 d2		 test	 edx, edx
  00642	7e 2e		 jle	 SHORT $LN223@CGUseItemR

; 15625: 			{
; 15626: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00644	01 94 31 54 01
	00 00		 add	 DWORD PTR [ecx+esi+340], edx
  0064b	8d 84 31 54 01
	00 00		 lea	 eax, DWORD PTR [ecx+esi+340]

; 15627: 
; 15628: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00652	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00657	8b 8c 30 5c 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+348]
  0065e	03 8c 30 58 01
	00 00		 add	 ecx, DWORD PTR [eax+esi+344]
  00665	8d 84 30 54 01
	00 00		 lea	 eax, DWORD PTR [eax+esi+340]
  0066c	39 08		 cmp	 DWORD PTR [eax], ecx
  0066e	7e 02		 jle	 SHORT $LN223@CGUseItemR

; 15629: 				{
; 15630: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00670	89 08		 mov	 DWORD PTR [eax], ecx
$LN223@CGUseItemR:

; 15631: 				}
; 15632: 			}
; 15633: 
; 15634: 			gObj[aIndex].FillLife = (float)iHPGage;

  00672	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00677	db 85 ec fe ff
	ff		 fild	 DWORD PTR _iHPGage$250000[ebp]

; 15635: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 15636: 			gObj[aIndex].FillLifeCount = 4;
; 15637: 			gObj[aIndex].iFillShield = iShieldGage;
; 15638: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 15639: 			gObj[aIndex].iFillShieldCount = 4;
; 15640: 
; 15641: 			GCSendEffectInfo(aIndex, 3);

  0067d	6a 03		 push	 3
  0067f	57		 push	 edi
  00680	d9 9d f4 fe ff
	ff		 fstp	 DWORD PTR tv4227[ebp]
  00686	d9 85 f4 fe ff
	ff		 fld	 DWORD PTR tv4227[ebp]
  0068c	d9 94 30 08 01
	00 00		 fst	 DWORD PTR [eax+esi+264]
  00693	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00699	d9 9c 31 0c 01
	00 00		 fstp	 DWORD PTR [ecx+esi+268]
  006a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006a6	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$249999[ebp]
  006ac	b8 04 00 00 00	 mov	 eax, 4
  006b1	88 84 32 1f 01
	00 00		 mov	 BYTE PTR [edx+esi+287], al
  006b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006be	89 8c 32 64 01
	00 00		 mov	 DWORD PTR [edx+esi+356], ecx
  006c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006cb	89 8c 32 60 01
	00 00		 mov	 DWORD PTR [edx+esi+352], ecx
  006d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006d8	89 84 31 68 01
	00 00		 mov	 DWORD PTR [ecx+esi+360], eax
  006df	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 15642: 
; 15643: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  006e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006ea	6a 01		 push	 1
  006ec	03 d6		 add	 edx, esi
  006ee	53		 push	 ebx
  006ef	52		 push	 edx
  006f0	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  006f5	83 c4 14	 add	 esp, 20			; 00000014H
  006f8	85 c0		 test	 eax, eax
  006fa	75 32		 jne	 SHORT $LN222@CGUseItemR

; 15644: 			{
; 15645: 				gObjInventoryItemSet(aIndex, pos, -1);

  006fc	68 ff 00 00 00	 push	 255			; 000000ffH
  00701	53		 push	 ebx
  00702	57		 push	 edi
  00703	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15646: 				gObj[aIndex].pInventory[pos].Clear();

  00708	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0070d	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  00714	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  0071a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0071d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15647: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00722	6a 01		 push	 1
  00724	53		 push	 ebx
  00725	57		 push	 edi
  00726	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN222@CGUseItemR:

; 15648: 			}
; 15649: 
; 15650: 			LogAddTD("[%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%f]", 
; 15651: 				gObj[aIndex].AccountID, 
; 15652: 				gObj[aIndex].Name, 
; 15653: 				gObj[aIndex].iShield, 
; 15654: 				gObj[aIndex].Life, 
; 15655: 				gObj[aIndex].iShield+iShieldGage, 
; 15656: 				(double)(gObj[aIndex].Life+(float)iHPGage));

  0072e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00733	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  0073a	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  00741	d8 85 f4 fe ff
	ff		 fadd	 DWORD PTR tv4227[ebp]
  00747	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _iShieldGage$249999[ebp]
  0074d	83 ec 08	 sub	 esp, 8
  00750	03 d1		 add	 edx, ecx
  00752	dd 1c 24	 fstp	 QWORD PTR [esp]
  00755	52		 push	 edx
  00756	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  0075d	83 ec 08	 sub	 esp, 8
  00760	dd 1c 24	 fstp	 QWORD PTR [esp]
  00763	51		 push	 ecx
  00764	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  00768	51		 push	 ecx
  00769	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  0076d	52		 push	 edx
  0076e	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@
  00773	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00779	83 c4 24	 add	 esp, 36			; 00000024H
  0077c	5b		 pop	 ebx
  0077d	5f		 pop	 edi
  0077e	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0077f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00782	33 cd		 xor	 ecx, ebp
  00784	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00789	8b e5		 mov	 esp, ebp
  0078b	5d		 pop	 ebp
  0078c	c3		 ret	 0
$LN228@CGUseItemR:

; 15657: 		}
; 15658: 		else if ( citem->m_Type == ITEMGET(14,39) ) 

  0078d	b9 27 1c 00 00	 mov	 ecx, 7207		; 00001c27H
  00792	66 3b c1	 cmp	 ax, cx
  00795	0f 85 22 02 00
	00		 jne	 $LN220@CGUseItemR

; 15659: 		{
; 15660: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 10/100;

  0079b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15661: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 25.0f / 100.0f );

  007a1	db 84 31 4c 01
	00 00		 fild	 DWORD PTR [ecx+esi+332]
  007a8	8b 84 31 5c 01
	00 00		 mov	 eax, DWORD PTR [ecx+esi+348]
  007af	03 84 31 58 01
	00 00		 add	 eax, DWORD PTR [ecx+esi+344]
  007b6	d8 84 31 00 01
	00 00		 fadd	 DWORD PTR [ecx+esi+256]
  007bd	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  007c0	03 d2		 add	 edx, edx
  007c2	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  007c7	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4039000000000000
  007cd	f7 ea		 imul	 edx
  007cf	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  007d5	c1 fa 05	 sar	 edx, 5
  007d8	8b c2		 mov	 eax, edx
  007da	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007dd	03 c2		 add	 eax, edx
  007df	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$250015[ebp], eax
  007e5	e8 00 00 00 00	 call	 __ftol2_sse

; 15662: 
; 15663: 			if ( gObj[aIndex].iShield < 0 )

  007ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007f0	83 bc 32 54 01
	00 00 00	 cmp	 DWORD PTR [edx+esi+340], 0
  007f8	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iHPGage$250016[ebp], eax
  007fe	8d 84 32 54 01
	00 00		 lea	 eax, DWORD PTR [edx+esi+340]
  00805	7d 06		 jge	 SHORT $LN329@CGUseItemR

; 15664: 			{
; 15665: 				gObj[aIndex].iShield = 0;

  00807	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN329@CGUseItemR:
  0080d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15666: 			}
; 15667: 
; 15668: 			if ( gObj[aIndex].FillLife > 0.0f )

  00813	d9 ee		 fldz
  00815	d8 9c 31 08 01
	00 00		 fcomp	 DWORD PTR [ecx+esi+264]
  0081c	8d 94 31 08 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+264]
  00823	df e0		 fnstsw	 ax
  00825	f6 c4 05	 test	 ah, 5
  00828	7a 3f		 jp	 SHORT $LN217@CGUseItemR

; 15669: 			{
; 15670: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  0082a	d9 02		 fld	 DWORD PTR [edx]
  0082c	8d 84 31 fc 00
	00 00		 lea	 eax, DWORD PTR [ecx+esi+252]
  00833	d8 00		 fadd	 DWORD PTR [eax]
  00835	d9 18		 fstp	 DWORD PTR [eax]

; 15671: 
; 15672: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  00837	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0083d	db 84 31 4c 01
	00 00		 fild	 DWORD PTR [ecx+esi+332]
  00844	8d 94 31 fc 00
	00 00		 lea	 edx, DWORD PTR [ecx+esi+252]
  0084b	d8 84 31 00 01
	00 00		 fadd	 DWORD PTR [ecx+esi+256]
  00852	d9 02		 fld	 DWORD PTR [edx]
  00854	d8 d9		 fcomp	 ST(1)
  00856	df e0		 fnstsw	 ax
  00858	f6 c4 41	 test	 ah, 65			; 00000041H
  0085b	75 0a		 jne	 SHORT $LN348@CGUseItemR

; 15673: 				{
; 15674: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  0085d	d9 1a		 fstp	 DWORD PTR [edx]
  0085f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00865	eb 02		 jmp	 SHORT $LN217@CGUseItemR
$LN348@CGUseItemR:
  00867	dd d8		 fstp	 ST(0)
$LN217@CGUseItemR:

; 15675: 				}
; 15676: 			}
; 15677: 
; 15678: 			if ( gObj[aIndex].iFillShield > 0 )

  00869	8b 94 31 64 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+356]
  00870	85 d2		 test	 edx, edx
  00872	7e 2e		 jle	 SHORT $LN215@CGUseItemR

; 15679: 			{
; 15680: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00874	01 94 31 54 01
	00 00		 add	 DWORD PTR [ecx+esi+340], edx
  0087b	8d 84 31 54 01
	00 00		 lea	 eax, DWORD PTR [ecx+esi+340]

; 15681: 
; 15682: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00882	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00887	8b 8c 30 5c 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+348]
  0088e	03 8c 30 58 01
	00 00		 add	 ecx, DWORD PTR [eax+esi+344]
  00895	8d 84 30 54 01
	00 00		 lea	 eax, DWORD PTR [eax+esi+340]
  0089c	39 08		 cmp	 DWORD PTR [eax], ecx
  0089e	7e 02		 jle	 SHORT $LN215@CGUseItemR

; 15683: 				{
; 15684: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  008a0	89 08		 mov	 DWORD PTR [eax], ecx
$LN215@CGUseItemR:

; 15685: 				}
; 15686: 			}
; 15687: 
; 15688: 			gObj[aIndex].FillLife = (float)iHPGage;

  008a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008a7	db 85 ec fe ff
	ff		 fild	 DWORD PTR _iHPGage$250016[ebp]

; 15689: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 15690: 			gObj[aIndex].FillLifeCount = 4;
; 15691: 			gObj[aIndex].iFillShield = iShieldGage;
; 15692: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 15693: 			gObj[aIndex].iFillShieldCount = 4;
; 15694: 
; 15695: 			GCSendEffectInfo(aIndex, 3);

  008ad	6a 03		 push	 3
  008af	57		 push	 edi
  008b0	d9 9d f4 fe ff
	ff		 fstp	 DWORD PTR tv4259[ebp]
  008b6	d9 85 f4 fe ff
	ff		 fld	 DWORD PTR tv4259[ebp]
  008bc	d9 94 30 08 01
	00 00		 fst	 DWORD PTR [eax+esi+264]
  008c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008c9	d9 9c 31 0c 01
	00 00		 fstp	 DWORD PTR [ecx+esi+268]
  008d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008d6	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$250015[ebp]
  008dc	b8 04 00 00 00	 mov	 eax, 4
  008e1	88 84 32 1f 01
	00 00		 mov	 BYTE PTR [edx+esi+287], al
  008e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008ee	89 8c 32 64 01
	00 00		 mov	 DWORD PTR [edx+esi+356], ecx
  008f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008fb	89 8c 32 60 01
	00 00		 mov	 DWORD PTR [edx+esi+352], ecx
  00902	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00908	89 84 31 68 01
	00 00		 mov	 DWORD PTR [ecx+esi+360], eax
  0090f	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 15696: 
; 15697: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00914	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0091a	6a 01		 push	 1
  0091c	03 d6		 add	 edx, esi
  0091e	53		 push	 ebx
  0091f	52		 push	 edx
  00920	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00925	83 c4 14	 add	 esp, 20			; 00000014H
  00928	85 c0		 test	 eax, eax
  0092a	75 32		 jne	 SHORT $LN214@CGUseItemR

; 15698: 			{
; 15699: 				gObjInventoryItemSet(aIndex, pos, -1);

  0092c	68 ff 00 00 00	 push	 255			; 000000ffH
  00931	53		 push	 ebx
  00932	57		 push	 edi
  00933	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15700: 				gObj[aIndex].pInventory[pos].Clear();

  00938	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0093d	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  00944	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  0094a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0094d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15701: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00952	6a 01		 push	 1
  00954	53		 push	 ebx
  00955	57		 push	 edi
  00956	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0095b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN214@CGUseItemR:

; 15702: 			}
; 15703: 
; 15704: 			LogAddTD("[%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 15705: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 15706: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 15707: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));

  0095e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00963	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  0096a	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  00971	d8 85 f4 fe ff
	ff		 fadd	 DWORD PTR tv4259[ebp]
  00977	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _iShieldGage$250015[ebp]
  0097d	83 ec 08	 sub	 esp, 8
  00980	03 d1		 add	 edx, ecx
  00982	dd 1c 24	 fstp	 QWORD PTR [esp]
  00985	52		 push	 edx
  00986	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  0098d	83 ec 08	 sub	 esp, 8
  00990	dd 1c 24	 fstp	 QWORD PTR [esp]
  00993	51		 push	 ecx
  00994	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  00998	51		 push	 ecx
  00999	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  0099d	52		 push	 edx
  0099e	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@
  009a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  009a9	83 c4 24	 add	 esp, 36			; 00000024H
  009ac	5b		 pop	 ebx
  009ad	5f		 pop	 edi
  009ae	5e		 pop	 esi

; 16547: 	}
; 16548: }

  009af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009b2	33 cd		 xor	 ecx, ebp
  009b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009b9	8b e5		 mov	 esp, ebp
  009bb	5d		 pop	 ebp
  009bc	c3		 ret	 0
$LN220@CGUseItemR:

; 15708: 		}
; 15709: 		else if ( citem->m_Type == ITEMGET(14,40) )

  009bd	b9 28 1c 00 00	 mov	 ecx, 7208		; 00001c28H
  009c2	66 3b c1	 cmp	 ax, cx
  009c5	0f 85 24 02 00
	00		 jne	 $LN212@CGUseItemR

; 15710: 		{
; 15711: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 20/100;

  009cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15712: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 45.0f / 100.0f );

  009d1	db 84 31 4c 01
	00 00		 fild	 DWORD PTR [ecx+esi+332]
  009d8	8b 84 31 5c 01
	00 00		 mov	 eax, DWORD PTR [ecx+esi+348]
  009df	03 84 31 58 01
	00 00		 add	 eax, DWORD PTR [ecx+esi+344]
  009e6	d8 84 31 00 01
	00 00		 fadd	 DWORD PTR [ecx+esi+256]
  009ed	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  009f0	03 d2		 add	 edx, edx
  009f2	03 d2		 add	 edx, edx
  009f4	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4046800000000000
  009fa	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  009ff	f7 ea		 imul	 edx
  00a01	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  00a07	c1 fa 05	 sar	 edx, 5
  00a0a	8b c2		 mov	 eax, edx
  00a0c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00a0f	03 c2		 add	 eax, edx
  00a11	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$250031[ebp], eax
  00a17	e8 00 00 00 00	 call	 __ftol2_sse

; 15713: 
; 15714: 			if ( gObj[aIndex].iShield < 0 )

  00a1c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a22	83 bc 32 54 01
	00 00 00	 cmp	 DWORD PTR [edx+esi+340], 0
  00a2a	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iHPGage$250032[ebp], eax
  00a30	8d 84 32 54 01
	00 00		 lea	 eax, DWORD PTR [edx+esi+340]
  00a37	7d 06		 jge	 SHORT $LN330@CGUseItemR

; 15715: 			{
; 15716: 				gObj[aIndex].iShield = 0;

  00a39	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN330@CGUseItemR:
  00a3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15717: 			}
; 15718: 
; 15719: 			if ( gObj[aIndex].FillLife > 0.0f )

  00a45	d9 ee		 fldz
  00a47	d8 9c 31 08 01
	00 00		 fcomp	 DWORD PTR [ecx+esi+264]
  00a4e	8d 94 31 08 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+264]
  00a55	df e0		 fnstsw	 ax
  00a57	f6 c4 05	 test	 ah, 5
  00a5a	7a 3f		 jp	 SHORT $LN209@CGUseItemR

; 15720: 			{
; 15721: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  00a5c	d9 02		 fld	 DWORD PTR [edx]
  00a5e	8d 84 31 fc 00
	00 00		 lea	 eax, DWORD PTR [ecx+esi+252]
  00a65	d8 00		 fadd	 DWORD PTR [eax]
  00a67	d9 18		 fstp	 DWORD PTR [eax]

; 15722: 
; 15723: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  00a69	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a6f	db 84 31 4c 01
	00 00		 fild	 DWORD PTR [ecx+esi+332]
  00a76	8d 94 31 fc 00
	00 00		 lea	 edx, DWORD PTR [ecx+esi+252]
  00a7d	d8 84 31 00 01
	00 00		 fadd	 DWORD PTR [ecx+esi+256]
  00a84	d9 02		 fld	 DWORD PTR [edx]
  00a86	d8 d9		 fcomp	 ST(1)
  00a88	df e0		 fnstsw	 ax
  00a8a	f6 c4 41	 test	 ah, 65			; 00000041H
  00a8d	75 0a		 jne	 SHORT $LN351@CGUseItemR

; 15724: 				{
; 15725: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  00a8f	d9 1a		 fstp	 DWORD PTR [edx]
  00a91	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a97	eb 02		 jmp	 SHORT $LN209@CGUseItemR
$LN351@CGUseItemR:
  00a99	dd d8		 fstp	 ST(0)
$LN209@CGUseItemR:

; 15726: 				}
; 15727: 			}
; 15728: 
; 15729: 			if ( gObj[aIndex].iFillShield > 0 )

  00a9b	8b 94 31 64 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+356]
  00aa2	85 d2		 test	 edx, edx
  00aa4	7e 2e		 jle	 SHORT $LN207@CGUseItemR

; 15730: 			{
; 15731: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00aa6	01 94 31 54 01
	00 00		 add	 DWORD PTR [ecx+esi+340], edx
  00aad	8d 84 31 54 01
	00 00		 lea	 eax, DWORD PTR [ecx+esi+340]

; 15732: 
; 15733: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00ab4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab9	8b 8c 30 5c 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+348]
  00ac0	03 8c 30 58 01
	00 00		 add	 ecx, DWORD PTR [eax+esi+344]
  00ac7	8d 84 30 54 01
	00 00		 lea	 eax, DWORD PTR [eax+esi+340]
  00ace	39 08		 cmp	 DWORD PTR [eax], ecx
  00ad0	7e 02		 jle	 SHORT $LN207@CGUseItemR

; 15734: 				{
; 15735: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00ad2	89 08		 mov	 DWORD PTR [eax], ecx
$LN207@CGUseItemR:

; 15736: 				}
; 15737: 			}
; 15738: 
; 15739: 			gObj[aIndex].FillLife = (float)iHPGage;

  00ad4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ad9	db 85 ec fe ff
	ff		 fild	 DWORD PTR _iHPGage$250032[ebp]

; 15740: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 15741: 			gObj[aIndex].FillLifeCount = 4;
; 15742: 			gObj[aIndex].iFillShield = iShieldGage;
; 15743: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 15744: 			gObj[aIndex].iFillShieldCount = 4;
; 15745: 
; 15746: 			GCSendEffectInfo(aIndex, 3);

  00adf	6a 03		 push	 3
  00ae1	57		 push	 edi
  00ae2	d9 9d f4 fe ff
	ff		 fstp	 DWORD PTR tv4283[ebp]
  00ae8	d9 85 f4 fe ff
	ff		 fld	 DWORD PTR tv4283[ebp]
  00aee	d9 94 30 08 01
	00 00		 fst	 DWORD PTR [eax+esi+264]
  00af5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00afb	d9 9c 31 0c 01
	00 00		 fstp	 DWORD PTR [ecx+esi+268]
  00b02	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b08	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$250031[ebp]
  00b0e	b8 04 00 00 00	 mov	 eax, 4
  00b13	88 84 32 1f 01
	00 00		 mov	 BYTE PTR [edx+esi+287], al
  00b1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b20	89 8c 32 64 01
	00 00		 mov	 DWORD PTR [edx+esi+356], ecx
  00b27	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b2d	89 8c 32 60 01
	00 00		 mov	 DWORD PTR [edx+esi+352], ecx
  00b34	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b3a	89 84 31 68 01
	00 00		 mov	 DWORD PTR [ecx+esi+360], eax
  00b41	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 15747: 
; 15748: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00b46	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b4c	6a 01		 push	 1
  00b4e	03 d6		 add	 edx, esi
  00b50	53		 push	 ebx
  00b51	52		 push	 edx
  00b52	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00b57	83 c4 14	 add	 esp, 20			; 00000014H
  00b5a	85 c0		 test	 eax, eax
  00b5c	75 32		 jne	 SHORT $LN206@CGUseItemR

; 15749: 			{
; 15750: 				gObjInventoryItemSet(aIndex, pos, -1);

  00b5e	68 ff 00 00 00	 push	 255			; 000000ffH
  00b63	53		 push	 ebx
  00b64	57		 push	 edi
  00b65	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15751: 				gObj[aIndex].pInventory[pos].Clear();

  00b6a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b6f	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  00b76	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  00b7c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b7f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15752: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00b84	6a 01		 push	 1
  00b86	53		 push	 ebx
  00b87	57		 push	 edi
  00b88	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00b8d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN206@CGUseItemR:

; 15753: 			}
; 15754: 
; 15755: 			LogAddTD("[%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%f]", 
; 15756: 				gObj[aIndex].AccountID, 
; 15757: 				gObj[aIndex].Name, 
; 15758: 				gObj[aIndex].iShield, 
; 15759: 				gObj[aIndex].Life, 
; 15760: 				gObj[aIndex].iShield+iShieldGage, 
; 15761: 				(double)(gObj[aIndex].Life+(float)iHPGage));

  00b90	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b95	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  00b9c	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  00ba3	d8 85 f4 fe ff
	ff		 fadd	 DWORD PTR tv4283[ebp]
  00ba9	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _iShieldGage$250031[ebp]
  00baf	83 ec 08	 sub	 esp, 8
  00bb2	03 d1		 add	 edx, ecx
  00bb4	dd 1c 24	 fstp	 QWORD PTR [esp]
  00bb7	52		 push	 edx
  00bb8	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  00bbf	83 ec 08	 sub	 esp, 8
  00bc2	dd 1c 24	 fstp	 QWORD PTR [esp]
  00bc5	51		 push	 ecx
  00bc6	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  00bca	51		 push	 ecx
  00bcb	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  00bcf	52		 push	 edx
  00bd0	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@
  00bd5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00bdb	83 c4 24	 add	 esp, 36			; 00000024H
  00bde	5b		 pop	 ebx
  00bdf	5f		 pop	 edi
  00be0	5e		 pop	 esi

; 16547: 	}
; 16548: }

  00be1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00be4	33 cd		 xor	 ecx, ebp
  00be6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00beb	8b e5		 mov	 esp, ebp
  00bed	5d		 pop	 ebp
  00bee	c3		 ret	 0
$LN212@CGUseItemR:

; 15762: 		}
; 15763: 		else if ( citem->m_Type == ITEMGET(14,35) )

  00bef	b9 23 1c 00 00	 mov	 ecx, 7203		; 00001c23H
  00bf4	66 3b c1	 cmp	 ax, cx
  00bf7	0f 85 fc 00 00
	00		 jne	 $LN204@CGUseItemR

; 15764: 		{
; 15765: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 25 / 100;

  00bfd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c03	8b 94 31 5c 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+348]
  00c0a	03 94 31 58 01
	00 00		 add	 edx, DWORD PTR [ecx+esi+344]
  00c11	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00c16	6b d2 19	 imul	 edx, 25			; 00000019H
  00c19	f7 ea		 imul	 edx
  00c1b	c1 fa 05	 sar	 edx, 5
  00c1e	8b c2		 mov	 eax, edx
  00c20	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00c23	03 c2		 add	 eax, edx

; 15766: 
; 15767: 			if ( gObj[aIndex].iShield < 0 )

  00c25	83 bc 31 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+esi+340], 0
  00c2d	8d 94 31 54 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+340]
  00c34	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$250047[ebp], eax
  00c3a	7d 0c		 jge	 SHORT $LN203@CGUseItemR

; 15768: 			{
; 15769: 				gObj[aIndex].iShield = 0;

  00c3c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00c42	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN203@CGUseItemR:

; 15770: 			}
; 15771: 
; 15772: 			if ( gObj[aIndex].iFillShield > 0 )

  00c48	8b 94 31 64 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+356]
  00c4f	85 d2		 test	 edx, edx
  00c51	7e 40		 jle	 SHORT $LN201@CGUseItemR

; 15773: 			{
; 15774: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00c53	01 94 31 54 01
	00 00		 add	 DWORD PTR [ecx+esi+340], edx
  00c5a	8d 84 31 54 01
	00 00		 lea	 eax, DWORD PTR [ecx+esi+340]

; 15775: 
; 15776: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )

  00c61	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c67	8b 84 31 58 01
	00 00		 mov	 eax, DWORD PTR [ecx+esi+344]
  00c6e	03 84 31 5c 01
	00 00		 add	 eax, DWORD PTR [ecx+esi+348]
$LN384@CGUseItemR:
  00c75	39 84 31 54 01
	00 00		 cmp	 DWORD PTR [ecx+esi+340], eax
  00c7c	8d 94 31 54 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+340]
  00c83	7e 08		 jle	 SHORT $LN340@CGUseItemR

; 15777: 				{
; 15778: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00c85	89 02		 mov	 DWORD PTR [edx], eax
  00c87	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN340@CGUseItemR:
  00c8d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$250047[ebp]
$LN201@CGUseItemR:

; 15779: 				}
; 15780: 			}
; 15781: 
; 15782: 			gObj[aIndex].iFillShieldCount = 2;

  00c93	c7 84 31 68 01
	00 00 02 00 00
	00		 mov	 DWORD PTR [ecx+esi+360], 2

; 15783: 			gObj[aIndex].iFillShield = iShieldGage;

  00c9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ca4	89 84 31 64 01
	00 00		 mov	 DWORD PTR [ecx+esi+356], eax

; 15784: 			gObj[aIndex].iFillShieldMax = iShieldGage;

  00cab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15785: 
; 15786: 			GCSendEffectInfo(aIndex, 3);

  00cb1	6a 03		 push	 3
  00cb3	57		 push	 edi
  00cb4	89 84 32 60 01
	00 00		 mov	 DWORD PTR [edx+esi+352], eax
  00cbb	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 15787: 
; 15788: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00cc0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cc5	6a 01		 push	 1
  00cc7	03 c6		 add	 eax, esi
  00cc9	53		 push	 ebx
  00cca	50		 push	 eax
  00ccb	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00cd0	83 c4 14	 add	 esp, 20			; 00000014H
  00cd3	85 c0		 test	 eax, eax
  00cd5	0f 85 a4 1e 00
	00		 jne	 $LN343@CGUseItemR

; 15789: 			{
; 15790: 				gObjInventoryItemSet(aIndex, pos, -1);

  00cdb	68 ff 00 00 00	 push	 255			; 000000ffH
  00ce0	53		 push	 ebx
  00ce1	57		 push	 edi
  00ce2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15791: 				gObj[aIndex].pInventory[pos].Clear();

  00ce7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ced	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]

; 15792: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 15793: 			}
; 15794: 		}

  00cf4	e9 9a 15 00 00	 jmp	 $LN378@CGUseItemR
$LN204@CGUseItemR:

; 15795: 		else if ( citem->m_Type == ITEMGET(14,36) )

  00cf9	ba 24 1c 00 00	 mov	 edx, 7204		; 00001c24H
  00cfe	66 3b c2	 cmp	 ax, dx
  00d01	0f 85 81 00 00
	00		 jne	 $LN198@CGUseItemR

; 15796: 		{
; 15797: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 35 / 100;

  00d07	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d0d	8b 94 31 5c 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+348]
  00d14	03 94 31 58 01
	00 00		 add	 edx, DWORD PTR [ecx+esi+344]
  00d1b	6b d2 23	 imul	 edx, 35			; 00000023H
$LN386@CGUseItemR:
  00d1e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00d23	f7 ea		 imul	 edx
  00d25	c1 fa 05	 sar	 edx, 5
  00d28	8b c2		 mov	 eax, edx
  00d2a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00d2d	03 c2		 add	 eax, edx

; 15798: 
; 15799: 			if ( gObj[aIndex].iShield < 0 )

  00d2f	83 bc 31 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+esi+340], 0
  00d37	8d 94 31 54 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+340]
  00d3e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$250054[ebp], eax
  00d44	7d 0c		 jge	 SHORT $LN197@CGUseItemR

; 15800: 			{
; 15801: 				gObj[aIndex].iShield = 0;

  00d46	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00d4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN197@CGUseItemR:

; 15802: 			}
; 15803: 
; 15804: 			if ( gObj[aIndex].iFillShield > 0 )

  00d52	8b 94 31 64 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+356]
  00d59	85 d2		 test	 edx, edx
  00d5b	0f 8e 32 ff ff
	ff		 jle	 $LN201@CGUseItemR

; 15805: 			{
; 15806: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00d61	01 94 31 54 01
	00 00		 add	 DWORD PTR [ecx+esi+340], edx
  00d68	8d 84 31 54 01
	00 00		 lea	 eax, DWORD PTR [ecx+esi+340]

; 15807: 
; 15808: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )

  00d6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d75	8b 84 31 5c 01
	00 00		 mov	 eax, DWORD PTR [ecx+esi+348]
  00d7c	03 84 31 58 01
	00 00		 add	 eax, DWORD PTR [ecx+esi+344]

; 15809: 				{
; 15810: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 15811: 				}
; 15812: 			}
; 15813: 
; 15814: 			gObj[aIndex].iFillShieldCount = 2;
; 15815: 			gObj[aIndex].iFillShield = iShieldGage;
; 15816: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 15817: 
; 15818: 			GCSendEffectInfo(aIndex, 3);
; 15819: 
; 15820: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )
; 15821: 			{
; 15822: 				gObjInventoryItemSet(aIndex, pos, -1);
; 15823: 				gObj[aIndex].pInventory[pos].Clear();
; 15824: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 15825: 			}
; 15826: 		}

  00d83	e9 ed fe ff ff	 jmp	 $LN384@CGUseItemR
$LN198@CGUseItemR:

; 15827: 		else if ( citem->m_Type == ITEMGET(14,37) )

  00d88	ba 25 1c 00 00	 mov	 edx, 7205		; 00001c25H
  00d8d	66 3b c2	 cmp	 ax, dx
  00d90	75 1c		 jne	 SHORT $LN192@CGUseItemR

; 15828: 		{
; 15829: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 45 / 100;

  00d92	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d98	8b 94 31 5c 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+348]
  00d9f	03 94 31 58 01
	00 00		 add	 edx, DWORD PTR [ecx+esi+344]
  00da6	6b d2 2d	 imul	 edx, 45			; 0000002dH

; 15830: 
; 15831: 			if ( gObj[aIndex].iShield < 0 )
; 15832: 			{
; 15833: 				gObj[aIndex].iShield = 0;
; 15834: 			}
; 15835: 
; 15836: 			if ( gObj[aIndex].iFillShield > 0 )
; 15837: 			{
; 15838: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;
; 15839: 
; 15840: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 15841: 				{
; 15842: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 15843: 				}
; 15844: 			}
; 15845: 
; 15846: 			gObj[aIndex].iFillShieldCount = 2;
; 15847: 			gObj[aIndex].iFillShield = iShieldGage;
; 15848: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 15849: 
; 15850: 			GCSendEffectInfo(aIndex, 3);
; 15851: 
; 15852: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )
; 15853: 			{
; 15854: 				gObjInventoryItemSet(aIndex, pos, -1);
; 15855: 				gObj[aIndex].pInventory[pos].Clear();
; 15856: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 15857: 			}
; 15858: 		}

  00da9	e9 70 ff ff ff	 jmp	 $LN386@CGUseItemR
$LN192@CGUseItemR:

; 15859: 		else if ( citem->m_Type == ITEMGET(14,8) )

  00dae	ba 08 1c 00 00	 mov	 edx, 7176		; 00001c08H
  00db3	66 3b c2	 cmp	 ax, dx
  00db6	0f 85 16 01 00
	00		 jne	 $LN186@CGUseItemR

; 15860: 		{
; 15861: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00dbc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dc1	6a 01		 push	 1
  00dc3	03 c6		 add	 eax, esi
  00dc5	53		 push	 ebx
  00dc6	50		 push	 eax
  00dc7	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00dcc	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dcf	85 c0		 test	 eax, eax
  00dd1	75 33		 jne	 SHORT $LN185@CGUseItemR

; 15862: 			{
; 15863: 				gObjInventoryItemSet(aIndex, pos, -1);

  00dd3	68 ff 00 00 00	 push	 255			; 000000ffH
  00dd8	53		 push	 ebx
  00dd9	57		 push	 edi
  00dda	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15864: 				gObj[aIndex].pInventory[pos].Clear();

  00ddf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00de5	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  00dec	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  00df2	83 c4 0c	 add	 esp, 12			; 0000000cH
  00df5	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15865: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00dfa	6a 01		 push	 1
  00dfc	53		 push	 ebx
  00dfd	57		 push	 edi
  00dfe	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00e03	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN185@CGUseItemR:

; 15866: 			}
; 15867: 
; 15868: 			if(gObjSearchActiveEffect(&gObj[aIndex], AT_POISON) == 1) //S3 Addition -> Poison

  00e06	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e0c	03 d6		 add	 edx, esi
  00e0e	6a 37		 push	 55			; 00000037H
  00e10	52		 push	 edx
  00e11	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00e16	83 c4 08	 add	 esp, 8
  00e19	3c 01		 cmp	 al, 1

; 15869: 			{
; 15870: 				gObjRemoveBuffEffect(&gObj[aIndex], AT_POISON);

  00e1b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e20	75 3f		 jne	 SHORT $LN184@CGUseItemR
  00e22	03 c6		 add	 eax, esi
  00e24	6a 37		 push	 55			; 00000037H
  00e26	50		 push	 eax
  00e27	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 15871: 				gObj[aIndex].lpAttackObj = NULL;

  00e2c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e32	c7 84 31 d4 03
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+esi+980], 0

; 15872: 				GCMagicCancelSend(&gObj[aIndex], 1);

  00e3d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e43	03 d6		 add	 edx, esi
  00e45	6a 01		 push	 1
  00e47	52		 push	 edx
  00e48	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@G@Z ; GCMagicCancelSend
  00e4d	83 c4 10	 add	 esp, 16			; 00000010H
  00e50	5b		 pop	 ebx
  00e51	5f		 pop	 edi
  00e52	5e		 pop	 esi

; 16547: 	}
; 16548: }

  00e53	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e56	33 cd		 xor	 ecx, ebp
  00e58	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e5d	8b e5		 mov	 esp, ebp
  00e5f	5d		 pop	 ebp
  00e60	c3		 ret	 0
$LN184@CGUseItemR:

; 15873: 			}
; 15874: 			else if(gObjSearchActiveEffect(&gObj[aIndex], AT_ICE) == 1) //S3 Addition -> Ice

  00e61	03 c6		 add	 eax, esi
  00e63	6a 38		 push	 56			; 00000038H
  00e65	50		 push	 eax
  00e66	e8 00 00 00 00	 call	 ?gObjSearchActiveEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSearchActiveEffect
  00e6b	83 c4 08	 add	 esp, 8
  00e6e	3c 01		 cmp	 al, 1
  00e70	0f 85 09 1d 00
	00		 jne	 $LN343@CGUseItemR

; 15875: 			{
; 15876: 				gObjRemoveBuffEffect(&gObj[aIndex], AT_ICE);

  00e76	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e7c	03 ce		 add	 ecx, esi
  00e7e	6a 38		 push	 56			; 00000038H
  00e80	51		 push	 ecx
  00e81	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 15877: 				gObj[aIndex].DelayActionTime = 0;

  00e86	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e8c	33 c0		 xor	 eax, eax
  00e8e	89 84 32 c0 03
	00 00		 mov	 DWORD PTR [edx+esi+960], eax

; 15878: 				gObj[aIndex].DelayLevel = 0;

  00e95	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e9b	88 84 31 c4 03
	00 00		 mov	 BYTE PTR [ecx+esi+964], al

; 15879: 				gObj[aIndex].lpAttackObj = NULL;

  00ea2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ea8	89 84 32 d4 03
	00 00		 mov	 DWORD PTR [edx+esi+980], eax

; 15880: 				GCMagicCancelSend(&gObj[aIndex], 7);

  00eaf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00eb4	03 c6		 add	 eax, esi
  00eb6	6a 07		 push	 7
  00eb8	50		 push	 eax
  00eb9	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@G@Z ; GCMagicCancelSend
  00ebe	83 c4 10	 add	 esp, 16			; 00000010H
  00ec1	5b		 pop	 ebx
  00ec2	5f		 pop	 edi
  00ec3	5e		 pop	 esi

; 16547: 	}
; 16548: }

  00ec4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ec7	33 cd		 xor	 ecx, ebp
  00ec9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ece	8b e5		 mov	 esp, ebp
  00ed0	5d		 pop	 ebp
  00ed1	c3		 ret	 0
$LN186@CGUseItemR:

; 15881: 			}
; 15882: 		}
; 15883: 		else if ( citem->m_Type == ITEMGET(14,46) )

  00ed2	b9 2e 1c 00 00	 mov	 ecx, 7214		; 00001c2eH
  00ed7	66 3b c1	 cmp	 ax, cx
  00eda	75 51		 jne	 SHORT $LN180@CGUseItemR

; 15884: 		{
; 15885: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00edc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ee2	6a 01		 push	 1
  00ee4	03 d6		 add	 edx, esi
  00ee6	53		 push	 ebx
  00ee7	52		 push	 edx
  00ee8	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00eed	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ef0	85 c0		 test	 eax, eax
  00ef2	75 32		 jne	 SHORT $LN179@CGUseItemR

; 15886: 			{
; 15887: 				gObjInventoryItemSet(aIndex, pos, -1);

  00ef4	68 ff 00 00 00	 push	 255			; 000000ffH
  00ef9	53		 push	 ebx
  00efa	57		 push	 edi
  00efb	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15888: 				gObj[aIndex].pInventory[pos].Clear();

  00f00	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f05	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  00f0c	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  00f12	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f15	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15889: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00f1a	6a 01		 push	 1
  00f1c	53		 push	 ebx
  00f1d	57		 push	 edi
  00f1e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f23	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN179@CGUseItemR:

; 15890: 			}
; 15891: 
; 15892: 			gObjSetItemEffect(&gObj[aIndex], 35);

  00f26	6a 23		 push	 35			; 00000023H
  00f28	e9 a1 01 00 00	 jmp	 $LN376@CGUseItemR
$LN180@CGUseItemR:

; 15893: 		}
; 15894: 		else if ( citem->m_Type == ITEMGET(14,47) )

  00f2d	ba 2f 1c 00 00	 mov	 edx, 7215		; 00001c2fH
  00f32	66 3b c2	 cmp	 ax, dx
  00f35	75 6e		 jne	 SHORT $LN177@CGUseItemR

; 15895: 		{
; 15896: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00f37	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f3c	6a 01		 push	 1
  00f3e	03 c6		 add	 eax, esi
  00f40	53		 push	 ebx
  00f41	50		 push	 eax
  00f42	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00f47	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f4a	85 c0		 test	 eax, eax
  00f4c	75 33		 jne	 SHORT $LN176@CGUseItemR

; 15897: 			{
; 15898: 				gObjInventoryItemSet(aIndex, pos, -1);

  00f4e	68 ff 00 00 00	 push	 255			; 000000ffH
  00f53	53		 push	 ebx
  00f54	57		 push	 edi
  00f55	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15899: 				gObj[aIndex].pInventory[pos].Clear();

  00f5a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f60	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  00f67	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  00f6d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f70	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15900: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00f75	6a 01		 push	 1
  00f77	53		 push	 ebx
  00f78	57		 push	 edi
  00f79	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f7e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN176@CGUseItemR:

; 15901: 			}
; 15902: 
; 15903: 			gObjSetItemEffect(&gObj[aIndex], 36);

  00f81	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f87	03 d6		 add	 edx, esi
  00f89	6a 24		 push	 36			; 00000024H
  00f8b	52		 push	 edx

; 15934: 			}
; 15935: 
; 15936: 			gObjSetItemEffect(&gObj[aIndex], 39);

  00f8c	e8 00 00 00 00	 call	 ?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSetItemEffect
  00f91	83 c4 08	 add	 esp, 8
  00f94	5b		 pop	 ebx
  00f95	5f		 pop	 edi
  00f96	5e		 pop	 esi

; 16547: 	}
; 16548: }

  00f97	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f9a	33 cd		 xor	 ecx, ebp
  00f9c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fa1	8b e5		 mov	 esp, ebp
  00fa3	5d		 pop	 ebp
  00fa4	c3		 ret	 0
$LN177@CGUseItemR:

; 15904: 		}
; 15905: 		else if ( citem->m_Type == ITEMGET(14,48) )

  00fa5	b9 30 1c 00 00	 mov	 ecx, 7216		; 00001c30H
  00faa	66 3b c1	 cmp	 ax, cx
  00fad	75 51		 jne	 SHORT $LN174@CGUseItemR

; 15906: 		{
; 15907: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00faf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fb5	6a 01		 push	 1
  00fb7	03 d6		 add	 edx, esi
  00fb9	53		 push	 ebx
  00fba	52		 push	 edx
  00fbb	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00fc0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fc3	85 c0		 test	 eax, eax
  00fc5	75 32		 jne	 SHORT $LN173@CGUseItemR

; 15908: 			{
; 15909: 				gObjInventoryItemSet(aIndex, pos, -1);

  00fc7	68 ff 00 00 00	 push	 255			; 000000ffH
  00fcc	53		 push	 ebx
  00fcd	57		 push	 edi
  00fce	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15910: 				gObj[aIndex].pInventory[pos].Clear();

  00fd3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fd8	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  00fdf	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  00fe5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15911: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00fed	6a 01		 push	 1
  00fef	53		 push	 ebx
  00ff0	57		 push	 edi
  00ff1	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00ff6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN173@CGUseItemR:

; 15912: 			}
; 15913: 
; 15914: 			gObjSetItemEffect(&gObj[aIndex], 37);

  00ff9	6a 25		 push	 37			; 00000025H
  00ffb	e9 ce 00 00 00	 jmp	 $LN376@CGUseItemR
$LN174@CGUseItemR:

; 15915: 		}
; 15916: 		else if ( citem->m_Type == ITEMGET(14,49) )

  01000	ba 31 1c 00 00	 mov	 edx, 7217		; 00001c31H
  01005	66 3b c2	 cmp	 ax, dx
  01008	75 6e		 jne	 SHORT $LN171@CGUseItemR

; 15917: 		{
; 15918: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  0100a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0100f	6a 01		 push	 1
  01011	03 c6		 add	 eax, esi
  01013	53		 push	 ebx
  01014	50		 push	 eax
  01015	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  0101a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0101d	85 c0		 test	 eax, eax
  0101f	75 33		 jne	 SHORT $LN170@CGUseItemR

; 15919: 			{
; 15920: 				gObjInventoryItemSet(aIndex, pos, -1);

  01021	68 ff 00 00 00	 push	 255			; 000000ffH
  01026	53		 push	 ebx
  01027	57		 push	 edi
  01028	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15921: 				gObj[aIndex].pInventory[pos].Clear();

  0102d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01033	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  0103a	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01040	83 c4 0c	 add	 esp, 12			; 0000000cH
  01043	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15922: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01048	6a 01		 push	 1
  0104a	53		 push	 ebx
  0104b	57		 push	 edi
  0104c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01051	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN170@CGUseItemR:

; 15923: 			}
; 15924: 
; 15925: 			gObjSetItemEffect(&gObj[aIndex], 38);

  01054	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0105a	03 d6		 add	 edx, esi
  0105c	6a 26		 push	 38			; 00000026H
  0105e	52		 push	 edx
  0105f	e8 00 00 00 00	 call	 ?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSetItemEffect
  01064	83 c4 08	 add	 esp, 8
  01067	5b		 pop	 ebx
  01068	5f		 pop	 edi
  01069	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0106a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0106d	33 cd		 xor	 ecx, ebp
  0106f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01074	8b e5		 mov	 esp, ebp
  01076	5d		 pop	 ebp
  01077	c3		 ret	 0
$LN171@CGUseItemR:

; 15926: 		}
; 15927: 		else if ( citem->m_Type == ITEMGET(14,50) )

  01078	b9 32 1c 00 00	 mov	 ecx, 7218		; 00001c32H
  0107d	66 3b c1	 cmp	 ax, cx
  01080	75 6e		 jne	 SHORT $LN168@CGUseItemR

; 15928: 		{
; 15929: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  01082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01088	6a 01		 push	 1
  0108a	03 d6		 add	 edx, esi
  0108c	53		 push	 ebx
  0108d	52		 push	 edx
  0108e	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01093	83 c4 0c	 add	 esp, 12			; 0000000cH
  01096	85 c0		 test	 eax, eax
  01098	75 32		 jne	 SHORT $LN167@CGUseItemR

; 15930: 			{
; 15931: 				gObjInventoryItemSet(aIndex, pos, -1);

  0109a	68 ff 00 00 00	 push	 255			; 000000ffH
  0109f	53		 push	 ebx
  010a0	57		 push	 edi
  010a1	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15932: 				gObj[aIndex].pInventory[pos].Clear();

  010a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010ab	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  010b2	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  010b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  010bb	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15933: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  010c0	6a 01		 push	 1
  010c2	53		 push	 ebx
  010c3	57		 push	 edi
  010c4	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  010c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN167@CGUseItemR:

; 15934: 			}
; 15935: 
; 15936: 			gObjSetItemEffect(&gObj[aIndex], 39);

  010cc	6a 27		 push	 39			; 00000027H
$LN376@CGUseItemR:
  010ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010d4	03 ce		 add	 ecx, esi
  010d6	51		 push	 ecx
  010d7	e8 00 00 00 00	 call	 ?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSetItemEffect
  010dc	83 c4 08	 add	 esp, 8
  010df	5b		 pop	 ebx
  010e0	5f		 pop	 edi
  010e1	5e		 pop	 esi

; 16547: 	}
; 16548: }

  010e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010e5	33 cd		 xor	 ecx, ebp
  010e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010ec	8b e5		 mov	 esp, ebp
  010ee	5d		 pop	 ebp
  010ef	c3		 ret	 0
$LN168@CGUseItemR:

; 15937: 		}
; 15938: 		else if ( citem->m_Type == ITEMGET(14,63) || citem->m_Type == ITEMGET(14,64) )

  010f0	ba 3f 1c 00 00	 mov	 edx, 7231		; 00001c3fH
  010f5	66 3b c2	 cmp	 ax, dx
  010f8	0f 84 3a 15 00
	00		 je	 $LN164@CGUseItemR
  010fe	b9 40 1c 00 00	 mov	 ecx, 7232		; 00001c40H
  01103	66 3b c1	 cmp	 ax, cx
  01106	0f 84 2c 15 00
	00		 je	 $LN164@CGUseItemR

; 15961: 			}
; 15962: 		}
; 15963: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(citem->m_Type) == TRUE && 
; 15964: 			g_SocketOption.IsSocketOption(&gObj[aIndex].pInventory[lpMsg->invenrotyTarget]) == FALSE) //season4 add-on

  0110c	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv4751[ebp]
  01112	52		 push	 edx
  01113	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  01118	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
  0111d	83 f8 01	 cmp	 eax, 1
  01120	75 5c		 jne	 SHORT $LN157@CGUseItemR
  01122	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01128	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0112c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01132	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  01138	03 8c 32 24 0e
	00 00		 add	 ecx, DWORD PTR [edx+esi+3620]
  0113f	51		 push	 ecx
  01140	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketOption@@3VCSocketOption@@A ; g_SocketOption
  01145	e8 00 00 00 00	 call	 ?IsSocketOption@CSocketOption@@QAEEPAVCItem@@@Z ; CSocketOption::IsSocketOption
  0114a	84 c0		 test	 al, al
  0114c	75 30		 jne	 SHORT $LN157@CGUseItemR

; 15965: 		{
; 15966: 			if ( g_kJewelOfHarmonySystem.StrengthenItemByJewelOfHarmony(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  0114e	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01154	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  01158	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0115c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01161	51		 push	 ecx
  01162	52		 push	 edx
  01163	03 c6		 add	 eax, esi
  01165	50		 push	 eax
  01166	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0116b	e8 00 00 00 00	 call	 ?StrengthenItemByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::StrengthenItemByJewelOfHarmony
  01170	83 f8 01	 cmp	 eax, 1
  01173	0f 85 6e 11 00
	00		 jne	 $LN132@CGUseItemR

; 15967: 			{
; 15968: 				gObjInventoryItemSet(aIndex, pos, -1);
; 15969: 				gObj[aIndex].pInventory[pos].Clear();
; 15970: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 15971: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 15972: 			}
; 15973: 			else

  01179	e9 ba 02 00 00	 jmp	 $LN380@CGUseItemR
$LN157@CGUseItemR:

; 15974: 			{
; 15975: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 15976: 			}
; 15977: 		}
; 15978: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(citem->m_Type) == TRUE )

  0117e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  01184	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  01188	50		 push	 eax
  01189	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0118e	e8 00 00 00 00	 call	 ?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
  01193	83 f8 01	 cmp	 eax, 1
  01196	75 30		 jne	 SHORT $LN153@CGUseItemR

; 15979: 		{
; 15980: 			if ( g_kJewelOfHarmonySystem.SmeltItemBySmeltingStone(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01198	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  0119e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  011a2	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  011a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011ab	51		 push	 ecx
  011ac	52		 push	 edx
  011ad	03 c6		 add	 eax, esi
  011af	50		 push	 eax
  011b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  011b5	e8 00 00 00 00	 call	 ?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
  011ba	83 f8 01	 cmp	 eax, 1
  011bd	0f 85 24 11 00
	00		 jne	 $LN132@CGUseItemR

; 15981: 			{
; 15982: 				gObjInventoryItemSet(aIndex, pos, -1);
; 15983: 				gObj[aIndex].pInventory[pos].Clear();
; 15984: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 15985: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 15986: 			}
; 15987: 			else

  011c3	e9 70 02 00 00	 jmp	 $LN380@CGUseItemR
$LN153@CGUseItemR:

; 15988: 			{
; 15989: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 15990: 			}
; 15991: 		}
; 15992: 		else if ( citem->m_Type == ITEMGET(14,13) ) // Jewel Of Bless

  011c8	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  011ce	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  011d2	b9 0d 1c 00 00	 mov	 ecx, 7181		; 00001c0dH
  011d7	66 3b c1	 cmp	 ax, cx
  011da	75 7f		 jne	 SHORT $LN149@CGUseItemR

; 15993: 		{
; 15994: 			if ( gObjItemLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  011dc	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  011e2	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  011e6	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  011ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011f0	52		 push	 edx
  011f1	50		 push	 eax
  011f2	03 ce		 add	 ecx, esi
  011f4	51		 push	 ecx
  011f5	e8 00 00 00 00	 call	 ?gObjItemLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemLevelUp
  011fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  011fd	83 f8 01	 cmp	 eax, 1
  01200	0f 85 79 19 00
	00		 jne	 $LN343@CGUseItemR

; 15995: 			{
; 15996: 				gObjInventoryItemSet(aIndex, pos, -1);

  01206	68 ff 00 00 00	 push	 255			; 000000ffH
  0120b	53		 push	 ebx
  0120c	57		 push	 edi
  0120d	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15997: 				gObj[aIndex].pInventory[pos].Clear();

  01212	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01218	8b 8c 32 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+esi+3620]
  0121f	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01225	83 c4 0c	 add	 esp, 12			; 0000000cH
  01228	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15998: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  0122d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01233	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  01237	51		 push	 ecx

; 16059: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  01238	57		 push	 edi
  01239	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 16060: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  0123e	6a 01		 push	 1
  01240	53		 push	 ebx
  01241	57		 push	 edi
  01242	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16092: 				{
; 16093: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  01247	83 c4 14	 add	 esp, 20			; 00000014H
  0124a	5b		 pop	 ebx
  0124b	5f		 pop	 edi
  0124c	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0124d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01250	33 cd		 xor	 ecx, ebp
  01252	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01257	8b e5		 mov	 esp, ebp
  01259	5d		 pop	 ebp
  0125a	c3		 ret	 0
$LN149@CGUseItemR:

; 15999: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 16000: 			}
; 16001: 		}
; 16002: 		else if ( citem->m_Type == ITEMGET(14,14) ) // Jewel Of Soul

  0125b	ba 0e 1c 00 00	 mov	 edx, 7182		; 00001c0eH
  01260	66 3b c2	 cmp	 ax, dx
  01263	75 2e		 jne	 SHORT $LN146@CGUseItemR

; 16003: 		{
; 16004: 			if ( gObjItemRandomLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01265	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  0126b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0126f	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  01273	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01278	51		 push	 ecx
  01279	52		 push	 edx
  0127a	03 c6		 add	 eax, esi
  0127c	50		 push	 eax
  0127d	e8 00 00 00 00	 call	 ?gObjItemRandomLevelUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemRandomLevelUp
  01282	83 c4 0c	 add	 esp, 12			; 0000000cH
  01285	83 f8 01	 cmp	 eax, 1
  01288	0f 85 f1 18 00
	00		 jne	 $LN343@CGUseItemR

; 16005: 			{
; 16006: 				gObjInventoryItemSet(aIndex, pos, -1);
; 16007: 				gObj[aIndex].pInventory[pos].Clear();
; 16008: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 16009: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 16010: 			}
; 16011: 		}

  0128e	e9 a5 01 00 00	 jmp	 $LN380@CGUseItemR
$LN146@CGUseItemR:

; 16012: 		else if ( citem->m_Type == ITEMGET(14,16) ) // Jewel Of Life

  01293	b9 10 1c 00 00	 mov	 ecx, 7184		; 00001c10H
  01298	66 3b c1	 cmp	 ax, cx
  0129b	0f 85 8d 00 00
	00		 jne	 $LN143@CGUseItemR

; 16013: 		{
; 16014: 			if ( gObjItemRandomOption3Up(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  012a1	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  012a7	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  012ab	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  012af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012b5	52		 push	 edx
  012b6	50		 push	 eax
  012b7	03 ce		 add	 ecx, esi
  012b9	51		 push	 ecx
  012ba	e8 00 00 00 00	 call	 ?gObjItemRandomOption3Up@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemRandomOption3Up
  012bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  012c2	83 f8 01	 cmp	 eax, 1
  012c5	75 55		 jne	 SHORT $LN142@CGUseItemR

; 16015: 			{
; 16016: 				gObjInventoryItemSet(aIndex, pos, -1);

  012c7	68 ff 00 00 00	 push	 255			; 000000ffH
  012cc	53		 push	 ebx
  012cd	57		 push	 edi
  012ce	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16017: 				gObj[aIndex].pInventory[pos].Clear();

  012d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012d9	8b 8c 32 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+esi+3620]
  012e0	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  012e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  012e9	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16018: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  012ee	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  012f4	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  012f8	51		 push	 ecx
  012f9	57		 push	 edi
  012fa	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 16019: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  012ff	6a 01		 push	 1
  01301	53		 push	 ebx
  01302	57		 push	 edi
  01303	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16092: 				{
; 16093: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  01308	83 c4 14	 add	 esp, 20			; 00000014H
  0130b	5b		 pop	 ebx
  0130c	5f		 pop	 edi
  0130d	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0130e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01311	33 cd		 xor	 ecx, ebp
  01313	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01318	8b e5		 mov	 esp, ebp
  0131a	5d		 pop	 ebp
  0131b	c3		 ret	 0
$LN142@CGUseItemR:

; 16020: 			}
; 16021: 			else
; 16022: 			{
; 16023: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0131c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01321	8b 94 30 54 01
	00 00		 mov	 edx, DWORD PTR [eax+esi+340]
  01328	52		 push	 edx

; 16024: 			}

  01329	e9 a1 11 00 00	 jmp	 $LN369@CGUseItemR
$LN143@CGUseItemR:

; 16025: 		}
; 16026: #ifdef _NEW_JEWELS_
; 16027: 		else if ( gNewJewels.CheckJewel(citem->m_Type) ) // Jewel Of Exellent

  0132e	98		 cwde
  0132f	50		 push	 eax
  01330	b9 00 00 00 00	 mov	 ecx, OFFSET ?gNewJewels@@3VcNewJewels@@A ; gNewJewels
  01335	e8 00 00 00 00	 call	 ?CheckJewel@cNewJewels@@QAE_NH@Z ; cNewJewels::CheckJewel
  0133a	84 c0		 test	 al, al
  0133c	74 33		 je	 SHORT $LN139@CGUseItemR

; 16028: 		{
; 16029: 			gNewJewels.JewelMain(&gObj[aIndex],lpMsg->inventoryPos, lpMsg->invenrotyTarget);

  0133e	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01344	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  01348	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0134c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01351	51		 push	 ecx
  01352	52		 push	 edx
  01353	03 c6		 add	 eax, esi
  01355	50		 push	 eax
  01356	b9 00 00 00 00	 mov	 ecx, OFFSET ?gNewJewels@@3VcNewJewels@@A ; gNewJewels
  0135b	e8 00 00 00 00	 call	 ?JewelMain@cNewJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z ; cNewJewels::JewelMain
  01360	5b		 pop	 ebx
  01361	5f		 pop	 edi
  01362	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01363	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01366	33 cd		 xor	 ecx, ebp
  01368	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0136d	8b e5		 mov	 esp, ebp
  0136f	5d		 pop	 ebp
  01370	c3		 ret	 0
$LN139@CGUseItemR:

; 16030: 		}
; 16031: #endif
; 16032: #ifdef LUCKYITEM
; 16033: 		else if( citem->m_Type == ITEMGET(14, 160) )	//1.01.00 update

  01371	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  01377	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0137b	ba a0 1c 00 00	 mov	 edx, 7328		; 00001ca0H
  01380	66 3b c2	 cmp	 ax, dx
  01383	75 7f		 jne	 SHORT $LN137@CGUseItemR

; 16034: 		{
; 16035: 			if( g_LuckyItemManager.LuckyItemRepaire(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) )

  01385	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  0138b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0138f	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  01393	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01398	51		 push	 ecx
  01399	52		 push	 edx
  0139a	03 c6		 add	 eax, esi
  0139c	50		 push	 eax
  0139d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LuckyItemManager@@3ULuckyItemManager@@A ; g_LuckyItemManager
  013a2	e8 00 00 00 00	 call	 ?LuckyItemRepaire@LuckyItemManager@@QAEHPAUOBJECTSTRUCT@@HH@Z ; LuckyItemManager::LuckyItemRepaire
  013a7	85 c0		 test	 eax, eax
  013a9	0f 84 38 0f 00
	00		 je	 $LN132@CGUseItemR

; 16036: 			{
; 16037: 				gObjInventoryItemSet(aIndex, pos, -1);

  013af	68 ff 00 00 00	 push	 255			; 000000ffH
  013b4	53		 push	 ebx
  013b5	57		 push	 edi
  013b6	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16038: 				gObj[aIndex].pInventory[pos].Clear();

  013bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  013c1	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  013c8	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  013ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  013d1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16039: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  013d6	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  013dc	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  013e0	50		 push	 eax
  013e1	57		 push	 edi
  013e2	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 16040: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  013e7	6a 01		 push	 1
  013e9	53		 push	 ebx
  013ea	57		 push	 edi
  013eb	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16092: 				{
; 16093: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  013f0	83 c4 14	 add	 esp, 20			; 00000014H
  013f3	5b		 pop	 ebx
  013f4	5f		 pop	 edi
  013f5	5e		 pop	 esi

; 16547: 	}
; 16548: }

  013f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013f9	33 cd		 xor	 ecx, ebp
  013fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01400	8b e5		 mov	 esp, ebp
  01402	5d		 pop	 ebp
  01403	c3		 ret	 0
$LN137@CGUseItemR:

; 16041: 			}
; 16042: 			else
; 16043: 			{
; 16044: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 16045: 			}
; 16046: 		}
; 16047: 		else if( citem->m_Type == ITEMGET(14, 161)  )

  01404	ba a1 1c 00 00	 mov	 edx, 7329		; 00001ca1H
  01409	66 3b c2	 cmp	 ax, dx
  0140c	75 7f		 jne	 SHORT $LN133@CGUseItemR

; 16048: //#ifdef __ALIEN__
; 16049: //			&& (!g_HarmonyOptionOnSocket
; 16050: //			&& gItemSocketOption.IsSocketItem(&gObj[aIndex].pInventory[lpMsg->invenrotyTarget]) == FALSE) )
; 16051: //#else
; 16052: //			)	//1.01.00 update
; 16053: //#endif
; 16054: 		{
; 16055: 			if( g_kJewelOfHarmonySystem.StrengthenItemByJewelOfRise(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) )

  0140e	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01414	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  01418	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0141c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01421	51		 push	 ecx
  01422	52		 push	 edx
  01423	03 c6		 add	 eax, esi
  01425	50		 push	 eax
  01426	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0142b	e8 00 00 00 00	 call	 ?StrengthenItemByJewelOfRise@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::StrengthenItemByJewelOfRise
  01430	85 c0		 test	 eax, eax
  01432	0f 84 af 0e 00
	00		 je	 $LN132@CGUseItemR
$LN380@CGUseItemR:

; 16056: 			{
; 16057: 				gObjInventoryItemSet(aIndex, pos, -1);

  01438	68 ff 00 00 00	 push	 255			; 000000ffH
  0143d	53		 push	 ebx
  0143e	57		 push	 edi
  0143f	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16058: 				gObj[aIndex].pInventory[pos].Clear();

  01444	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0144a	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  01451	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01457	83 c4 0c	 add	 esp, 12			; 0000000cH
  0145a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16059: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  0145f	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  01465	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  01469	50		 push	 eax
  0146a	57		 push	 edi
  0146b	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 16060: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01470	6a 01		 push	 1
  01472	53		 push	 ebx
  01473	57		 push	 edi
  01474	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16092: 				{
; 16093: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  01479	83 c4 14	 add	 esp, 20			; 00000014H
  0147c	5b		 pop	 ebx
  0147d	5f		 pop	 edi
  0147e	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0147f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01482	33 cd		 xor	 ecx, ebp
  01484	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01489	8b e5		 mov	 esp, ebp
  0148b	5d		 pop	 ebp
  0148c	c3		 ret	 0
$LN133@CGUseItemR:

; 16061: 			}
; 16062: 			else
; 16063: 			{
; 16064: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 16065: 			}
; 16066: 		}
; 16067: #endif
; 16068: 		else if ( citem->m_Type >= ITEMGET(15,0) ||	citem->m_Type == ITEMGET(12,7) || 
; 16069: 			(citem->m_Type >= ITEMGET(12,8) && citem->m_Type <= ITEMGET(12,24) ) || 
; 16070: 			citem->m_Type == ITEMGET(12,35) ||	// Scroll of Fire Scream
; 16071: 			citem->m_Type == ITEMGET(12,44) ||
; 16072: 			citem->m_Type == ITEMGET(12,45) ||
; 16073: 			citem->m_Type == ITEMGET(12,46) ||
; 16074: 			citem->m_Type == ITEMGET(12,47) ||
; 16075: 			citem->m_Type == ITEMGET(12,48) ) //season4

  0148d	ba 00 1e 00 00	 mov	 edx, 7680		; 00001e00H
  01492	66 3b c2	 cmp	 ax, dx
  01495	0f 8d 7a 0f 00
	00		 jge	 $LN128@CGUseItemR
  0149b	ba 07 18 00 00	 mov	 edx, 6151		; 00001807H
  014a0	66 3b c2	 cmp	 ax, dx
  014a3	0f 84 6c 0f 00
	00		 je	 $LN128@CGUseItemR
  014a9	ba 08 18 00 00	 mov	 edx, 6152		; 00001808H
  014ae	66 3b c2	 cmp	 ax, dx
  014b1	7c 0e		 jl	 SHORT $LN127@CGUseItemR
  014b3	ba 18 18 00 00	 mov	 edx, 6168		; 00001818H
  014b8	66 3b c2	 cmp	 ax, dx
  014bb	0f 8e 54 0f 00
	00		 jle	 $LN128@CGUseItemR
$LN127@CGUseItemR:
  014c1	ba 23 18 00 00	 mov	 edx, 6179		; 00001823H
  014c6	66 3b c2	 cmp	 ax, dx
  014c9	0f 84 46 0f 00
	00		 je	 $LN128@CGUseItemR
  014cf	ba 2c 18 00 00	 mov	 edx, 6188		; 0000182cH
  014d4	66 3b c2	 cmp	 ax, dx
  014d7	0f 84 38 0f 00
	00		 je	 $LN128@CGUseItemR
  014dd	ba 2d 18 00 00	 mov	 edx, 6189		; 0000182dH
  014e2	66 3b c2	 cmp	 ax, dx
  014e5	0f 84 2a 0f 00
	00		 je	 $LN128@CGUseItemR
  014eb	ba 2e 18 00 00	 mov	 edx, 6190		; 0000182eH
  014f0	66 3b c2	 cmp	 ax, dx
  014f3	0f 84 1c 0f 00
	00		 je	 $LN128@CGUseItemR
  014f9	ba 2f 18 00 00	 mov	 edx, 6191		; 0000182fH
  014fe	66 3b c2	 cmp	 ax, dx
  01501	0f 84 0e 0f 00
	00		 je	 $LN128@CGUseItemR
  01507	ba 30 18 00 00	 mov	 edx, 6192		; 00001830H
  0150c	66 3b c2	 cmp	 ax, dx
  0150f	0f 84 00 0f 00
	00		 je	 $LN128@CGUseItemR

; 16127: 				}
; 16128: 			}
; 16129: 		}
; 16130: 		else if ( citem->m_Type == ITEMGET(14,10) )

  01515	ba 0a 1c 00 00	 mov	 edx, 7178		; 00001c0aH
  0151a	66 3b c2	 cmp	 ax, dx
  0151d	0f 85 ff 02 00
	00		 jne	 $LN115@CGUseItemR

; 16131: 		{
; 16132: 			LogAddTD("[Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]", 
; 16133: 				gObj[aIndex].AccountID, 
; 16134: 				gObj[aIndex].Name, 
; 16135: 				gObj[aIndex].MapNumber);

  01523	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01528	0f b6 8c 30 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+esi+329]
  01530	51		 push	 ecx
  01531	8d 54 30 77	 lea	 edx, DWORD PTR [eax+esi+119]
  01535	52		 push	 edx
  01536	8d 44 30 6c	 lea	 eax, DWORD PTR [eax+esi+108]
  0153a	50		 push	 eax
  0153b	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@
  01540	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16136: 
; 16137: 			if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) )

  01546	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0154c	8a 84 31 49 01
	00 00		 mov	 al, BYTE PTR [ecx+esi+329]
  01553	83 c4 10	 add	 esp, 16			; 00000010H
  01556	3c 34		 cmp	 al, 52			; 00000034H
  01558	74 0d		 je	 SHORT $LN318@CGUseItemR
  0155a	3c 0b		 cmp	 al, 11			; 0000000bH
  0155c	72 39		 jb	 SHORT $LN331@CGUseItemR
  0155e	b2 11		 mov	 dl, 17			; 00000011H
  01560	3a d0		 cmp	 dl, al
  01562	1b c9		 sbb	 ecx, ecx
  01564	41		 inc	 ecx
  01565	74 30		 je	 SHORT $LN331@CGUseItemR
$LN318@CGUseItemR:

; 16138: 			{
; 16139: 				int iBridgeIndex = g_BloodCastle.GetBridgeIndex(gObj[aIndex].MapNumber);

  01567	0f b6 c0	 movzx	 eax, al
  0156a	50		 push	 eax
  0156b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01570	e8 00 00 00 00	 call	 ?GetBridgeIndex@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeIndex

; 16140: 
; 16141: 				if ( g_BloodCastle.GetCurrentState(iBridgeIndex) == 2 )

  01575	50		 push	 eax
  01576	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0157b	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState

; 16142: 				{
; 16143: 					g_BloodCastle.SearchUserDropQuestItem(aIndex);

  01580	57		 push	 edi
  01581	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01586	83 f8 02	 cmp	 eax, 2
  01589	75 07		 jne	 SHORT $LN113@CGUseItemR
  0158b	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 16144: 				}
; 16145: 				else

  01590	eb 05		 jmp	 SHORT $LN331@CGUseItemR
$LN113@CGUseItemR:

; 16146: 				{
; 16147: 					g_BloodCastle.SearchUserDeleteQuestItem(aIndex);

  01592	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN331@CGUseItemR:

; 16148: 				}
; 16149: 			}
; 16150: 
; 16151: 			if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) ) //Season2.5 add-on

  01597	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0159d	8a 8c 31 49 01
	00 00		 mov	 cl, BYTE PTR [ecx+esi+329]
  015a4	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  015a7	72 15		 jb	 SHORT $LN111@CGUseItemR
  015a9	b2 32		 mov	 dl, 50			; 00000032H
  015ab	3a d1		 cmp	 dl, cl
  015ad	1b c0		 sbb	 eax, eax
  015af	40		 inc	 eax
  015b0	74 0c		 je	 SHORT $LN111@CGUseItemR

; 16152: 			{
; 16153: 				g_IllusionTempleEvent.SearchUserDropQuestItem(gObj[aIndex].MapNumber, aIndex);

  015b2	57		 push	 edi
  015b3	51		 push	 ecx
  015b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTempleEvent@@3VCIllusionTempleEvent@@A ; g_IllusionTempleEvent
  015b9	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CIllusionTempleEvent@@QAEXEH@Z ; CIllusionTempleEvent::SearchUserDropQuestItem
$LN111@CGUseItemR:

; 16154: 			}
; 16155: 
; 16156: 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 3 )

  015be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015c4	8b 84 31 1c 0e
	00 00		 mov	 eax, DWORD PTR [ecx+esi+3612]
  015cb	a8 03		 test	 al, 3
  015cd	74 34		 je	 SHORT $LN110@CGUseItemR
  015cf	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  015d4	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  015d9	75 28		 jne	 SHORT $LN110@CGUseItemR

; 16157: 			{
; 16158: 				gObj[aIndex].TargetShopNumber = -1;

  015db	83 c8 ff	 or	 eax, -1
  015de	66 89 84 31 5a
	04 00 00	 mov	 WORD PTR [ecx+esi+1114], ax

; 16159: 				gObj[aIndex].m_IfState.type = 0;

  015e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015eb	81 a4 30 1c 0e
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [eax+esi+3612], -65473 ; ffff003fH

; 16160: 				gObj[aIndex].m_IfState.use = 0;

  015f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  015fb	83 a4 30 1c 0e
	00 00 fc	 and	 DWORD PTR [eax+esi+3612], -4 ; fffffffcH
$LN110@CGUseItemR:

; 16161: 			}
; 16162: 
; 16163: 			gObjInventoryItemSet(aIndex, pos, -1);

  01603	68 ff 00 00 00	 push	 255			; 000000ffH
  01608	53		 push	 ebx
  01609	57		 push	 edi
  0160a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16164: 			gObj[aIndex].pInventory[pos].Clear();

  0160f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01615	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  0161c	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01622	83 c4 0c	 add	 esp, 12			; 0000000cH
  01625	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16165: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  0162a	6a 01		 push	 1
  0162c	53		 push	 ebx
  0162d	57		 push	 edi
  0162e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16166: 
; 16167: 			if ( gObj[aIndex].MapNumber == MAP_INDEX_DEVIAS )

  01633	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01639	8a 84 32 49 01
	00 00		 mov	 al, BYTE PTR [edx+esi+329]
  01640	83 c4 0c	 add	 esp, 12			; 0000000cH
  01643	3c 02		 cmp	 al, 2

; 16168: 			{
; 16169: 				gObjMoveGate(aIndex, 22);

  01645	0f 84 a3 00 00
	00		 je	 $LN321@CGUseItemR

; 16170: 			}
; 16171: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_NORIA )

  0164b	3c 03		 cmp	 al, 3

; 16172: 			{
; 16173: 				gObjMoveGate(aIndex, 27);

  0164d	0f 84 bf 00 00
	00		 je	 $LN375@CGUseItemR

; 16174: 			}
; 16175: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_LOSTTOWER )

  01653	3c 04		 cmp	 al, 4
  01655	75 1c		 jne	 SHORT $LN105@CGUseItemR

; 16176: 			{
; 16177: 				gObjMoveGate(aIndex, 42);

  01657	6a 2a		 push	 42			; 0000002aH
  01659	57		 push	 edi
  0165a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0165f	83 c4 08	 add	 esp, 8
  01662	5b		 pop	 ebx
  01663	5f		 pop	 edi
  01664	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01665	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01668	33 cd		 xor	 ecx, ebp
  0166a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0166f	8b e5		 mov	 esp, ebp
  01671	5d		 pop	 ebp
  01672	c3		 ret	 0
$LN105@CGUseItemR:

; 16178: 			}
; 16179: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_ATHLANSE )

  01673	3c 07		 cmp	 al, 7
  01675	75 1c		 jne	 SHORT $LN103@CGUseItemR

; 16180: 			{
; 16181: 				gObjMoveGate(aIndex, 49);

  01677	6a 31		 push	 49			; 00000031H
  01679	57		 push	 edi
  0167a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0167f	83 c4 08	 add	 esp, 8
  01682	5b		 pop	 ebx
  01683	5f		 pop	 edi
  01684	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01685	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01688	33 cd		 xor	 ecx, ebp
  0168a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0168f	8b e5		 mov	 esp, ebp
  01691	5d		 pop	 ebp
  01692	c3		 ret	 0
$LN103@CGUseItemR:

; 16182: 			}
; 16183: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_TARKAN )

  01693	3c 08		 cmp	 al, 8
  01695	75 1c		 jne	 SHORT $LN101@CGUseItemR

; 16184: 			{
; 16185: 				gObjMoveGate(aIndex, 57);

  01697	6a 39		 push	 57			; 00000039H
  01699	57		 push	 edi
  0169a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0169f	83 c4 08	 add	 esp, 8
  016a2	5b		 pop	 ebx
  016a3	5f		 pop	 edi
  016a4	5e		 pop	 esi

; 16547: 	}
; 16548: }

  016a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016a8	33 cd		 xor	 ecx, ebp
  016aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016af	8b e5		 mov	 esp, ebp
  016b1	5d		 pop	 ebp
  016b2	c3		 ret	 0
$LN101@CGUseItemR:

; 16186: 			}
; 16187: 			else if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  016b3	3c 34		 cmp	 al, 52			; 00000034H
  016b5	74 37		 je	 SHORT $LN321@CGUseItemR
  016b7	3c 0b		 cmp	 al, 11			; 0000000bH
  016b9	72 0c		 jb	 SHORT $LN332@CGUseItemR
  016bb	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  016c0	3a c8		 cmp	 cl, al
  016c2	1b c9		 sbb	 ecx, ecx
  016c4	41		 inc	 ecx

; 16188: 			{
; 16189: 				gObjMoveGate(aIndex, 22);

  016c5	75 27		 jne	 SHORT $LN321@CGUseItemR
$LN332@CGUseItemR:

; 16190: 			}
; 16191: 			else if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  016c7	3c 35		 cmp	 al, 53			; 00000035H
  016c9	74 23		 je	 SHORT $LN321@CGUseItemR
  016cb	3c 12		 cmp	 al, 18			; 00000012H
  016cd	72 0c		 jb	 SHORT $LN342@CGUseItemR
  016cf	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  016d4	3a c8		 cmp	 cl, al
  016d6	1b c9		 sbb	 ecx, ecx
  016d8	41		 inc	 ecx

; 16192: 			{
; 16193: 				gObjMoveGate(aIndex, 22);

  016d9	75 13		 jne	 SHORT $LN321@CGUseItemR
$LN342@CGUseItemR:

; 16194: 			}
; 16195: 			else if ( KALIMA_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  016db	3c 18		 cmp	 al, 24			; 00000018H
  016dd	72 2b		 jb	 SHORT $LN95@CGUseItemR
  016df	3c 1d		 cmp	 al, 29			; 0000001dH
  016e1	76 0b		 jbe	 SHORT $LN321@CGUseItemR
  016e3	33 c9		 xor	 ecx, ecx
  016e5	3c 24		 cmp	 al, 36			; 00000024H
  016e7	0f 94 c1	 sete	 cl
  016ea	85 c9		 test	 ecx, ecx
  016ec	74 1c		 je	 SHORT $LN95@CGUseItemR
$LN321@CGUseItemR:

; 16196: 			{
; 16197: 				gObjMoveGate(aIndex, 22);

  016ee	6a 16		 push	 22			; 00000016H
  016f0	57		 push	 edi
  016f1	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  016f6	83 c4 08	 add	 esp, 8
  016f9	5b		 pop	 ebx
  016fa	5f		 pop	 edi
  016fb	5e		 pop	 esi

; 16547: 	}
; 16548: }

  016fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016ff	33 cd		 xor	 ecx, ebp
  01701	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01706	8b e5		 mov	 esp, ebp
  01708	5d		 pop	 ebp
  01709	c3		 ret	 0
$LN95@CGUseItemR:

; 16198: 			}
; 16199: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_AIDA )

  0170a	3c 21		 cmp	 al, 33			; 00000021H

; 16200: 			{
; 16201: 				gObjMoveGate(aIndex, 27);

  0170c	74 04		 je	 SHORT $LN375@CGUseItemR

; 16202: 			}
; 16203: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )

  0170e	3c 22		 cmp	 al, 34			; 00000022H
  01710	75 1c		 jne	 SHORT $LN91@CGUseItemR
$LN375@CGUseItemR:

; 16204: 			{
; 16205: 				gObjMoveGate(aIndex, 27);

  01712	6a 1b		 push	 27			; 0000001bH
  01714	57		 push	 edi
  01715	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0171a	83 c4 08	 add	 esp, 8
  0171d	5b		 pop	 ebx
  0171e	5f		 pop	 edi
  0171f	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01720	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01723	33 cd		 xor	 ecx, ebp
  01725	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0172a	8b e5		 mov	 esp, ebp
  0172c	5d		 pop	 ebp
  0172d	c3		 ret	 0
$LN91@CGUseItemR:

; 16206: 			}
; 16207: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_ELBELAND ) //season 3.0 add-on

  0172e	3c 33		 cmp	 al, 51			; 00000033H
  01730	75 1f		 jne	 SHORT $LN89@CGUseItemR

; 16208: 			{
; 16209: 				gObjMoveGate(aIndex, 267);

  01732	68 0b 01 00 00	 push	 267			; 0000010bH
  01737	57		 push	 edi
  01738	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0173d	83 c4 08	 add	 esp, 8
  01740	5b		 pop	 ebx
  01741	5f		 pop	 edi
  01742	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01743	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01746	33 cd		 xor	 ecx, ebp
  01748	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0174d	8b e5		 mov	 esp, ebp
  0174f	5d		 pop	 ebp
  01750	c3		 ret	 0
$LN89@CGUseItemR:

; 16210: 			}
; 16211: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_SWAMPOFCALMNESS ) //season 3.0 add-on

  01751	3c 38		 cmp	 al, 56			; 00000038H
  01753	75 1f		 jne	 SHORT $LN87@CGUseItemR

; 16212: 			{
; 16213: 				gObjMoveGate(aIndex, 273);

  01755	68 11 01 00 00	 push	 273			; 00000111H
  0175a	57		 push	 edi
  0175b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01760	83 c4 08	 add	 esp, 8
  01763	5b		 pop	 ebx
  01764	5f		 pop	 edi
  01765	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01766	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01769	33 cd		 xor	 ecx, ebp
  0176b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01770	8b e5		 mov	 esp, ebp
  01772	5d		 pop	 ebp
  01773	c3		 ret	 0
$LN87@CGUseItemR:

; 16214: 			}
; 16215: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_RAKLION ) //season 4.0 add-on

  01774	3c 39		 cmp	 al, 57			; 00000039H
  01776	75 1f		 jne	 SHORT $LN85@CGUseItemR

; 16216: 			{
; 16217: 				gObjMoveGate(aIndex, 286);

  01778	68 1e 01 00 00	 push	 286			; 0000011eH
  0177d	57		 push	 edi
  0177e	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01783	83 c4 08	 add	 esp, 8
  01786	5b		 pop	 ebx
  01787	5f		 pop	 edi
  01788	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01789	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0178c	33 cd		 xor	 ecx, ebp
  0178e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01793	8b e5		 mov	 esp, ebp
  01795	5d		 pop	 ebp
  01796	c3		 ret	 0
$LN85@CGUseItemR:

; 16218: 			}
; 16219: //#if(GS_CASTLE==1)
; 16220: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE )

  01797	3c 1e		 cmp	 al, 30			; 0000001eH
  01799	75 6b		 jne	 SHORT $LN83@CGUseItemR

; 16221:               {
; 16222:                 if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )

  0179b	83 3d 28 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 7
  017a2	75 26		 jne	 SHORT $LN82@CGUseItemR

; 16223:                 {
; 16224:                   if ( gObj[aIndex].m_btCsJoinSide == 1 )

  017a4	80 bc 32 02 1c
	00 00 01	 cmp	 BYTE PTR [edx+esi+7170], 1
  017ac	75 3c		 jne	 SHORT $LN81@CGUseItemR
$LN77@CGUseItemR:

; 16237: 				  {
; 16238:                     gObjMoveGate(aIndex, 101);

  017ae	6a 65		 push	 101			; 00000065H
  017b0	57		 push	 edi
  017b1	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  017b6	83 c4 08	 add	 esp, 8
  017b9	5b		 pop	 ebx
  017ba	5f		 pop	 edi
  017bb	5e		 pop	 esi

; 16547: 	}
; 16548: }

  017bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017bf	33 cd		 xor	 ecx, ebp
  017c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017c6	8b e5		 mov	 esp, ebp
  017c8	5d		 pop	 ebp
  017c9	c3		 ret	 0
$LN82@CGUseItemR:

; 16225: 				  {
; 16226: 					gObjMoveGate(aIndex, 101);
; 16227: 				  }
; 16228:                   else
; 16229: 				  {
; 16230: 					gObjMoveGate(aIndex, 100);
; 16231: 				  }
; 16232:                 }
; 16233:                 else
; 16234:                 {
; 16235:                   if (g_CastleSiege.CheckCastleOwnerMember(aIndex) == TRUE || 
; 16236: 					  g_CastleSiege.CheckCastleOwnerUnionMember(aIndex) == TRUE )

  017ca	57		 push	 edi
  017cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  017d0	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  017d5	83 f8 01	 cmp	 eax, 1
  017d8	74 d4		 je	 SHORT $LN77@CGUseItemR
  017da	57		 push	 edi
  017db	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  017e0	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  017e5	83 f8 01	 cmp	 eax, 1
  017e8	74 c4		 je	 SHORT $LN77@CGUseItemR
$LN81@CGUseItemR:

; 16239: 				  }
; 16240:                   else
; 16241: 				  {
; 16242:                     gObjMoveGate(aIndex, 100);

  017ea	6a 64		 push	 100			; 00000064H
  017ec	57		 push	 edi
  017ed	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  017f2	83 c4 08	 add	 esp, 8
  017f5	5b		 pop	 ebx
  017f6	5f		 pop	 edi
  017f7	5e		 pop	 esi

; 16547: 	}
; 16548: }

  017f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017fb	33 cd		 xor	 ecx, ebp
  017fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01802	8b e5		 mov	 esp, ebp
  01804	5d		 pop	 ebp
  01805	c3		 ret	 0
$LN83@CGUseItemR:

; 16243: 				  }
; 16244:                 }
; 16245:               }
; 16246: //#endif
; 16247: 			else
; 16248: 			{
; 16249: 				gObjMoveGate(aIndex, 17);

  01806	6a 11		 push	 17			; 00000011H
  01808	57		 push	 edi
  01809	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0180e	83 c4 08	 add	 esp, 8
  01811	5b		 pop	 ebx
  01812	5f		 pop	 edi
  01813	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01814	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01817	33 cd		 xor	 ecx, ebp
  01819	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0181e	8b e5		 mov	 esp, ebp
  01820	5d		 pop	 ebp
  01821	c3		 ret	 0
$LN115@CGUseItemR:

; 16250: 			}
; 16251: 		}
; 16252: 		else if ( citem->m_Type == ITEMGET(14,9) )

  01822	ba 09 1c 00 00	 mov	 edx, 7177		; 00001c09H
  01827	66 3b c2	 cmp	 ax, dx
  0182a	75 65		 jne	 SHORT $LN73@CGUseItemR

; 16253: 		{
; 16254: 			int level = citem->m_Level;

  0182c	8b c1		 mov	 eax, ecx
  0182e	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]

; 16255: 
; 16256: 			gObjInventoryItemSet(aIndex, pos, -1);

  01832	68 ff 00 00 00	 push	 255			; 000000ffH
  01837	53		 push	 ebx
  01838	57		 push	 edi
  01839	89 8d ec fe ff
	ff		 mov	 DWORD PTR _level$250187[ebp], ecx
  0183f	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16257: 			gObj[aIndex].pInventory[pos].Clear();

  01844	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0184a	8b 8c 32 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+esi+3620]
  01851	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01857	83 c4 0c	 add	 esp, 12			; 0000000cH
  0185a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16258: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  0185f	6a 01		 push	 1
  01861	53		 push	 ebx
  01862	57		 push	 edi
  01863	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16259: 			gObjUseDrink(&gObj[aIndex], level);

  01868	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _level$250187[ebp]
  0186e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01874	50		 push	 eax
  01875	03 ce		 add	 ecx, esi
  01877	51		 push	 ecx
  01878	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseDrink
  0187d	83 c4 14	 add	 esp, 20			; 00000014H
  01880	5b		 pop	 ebx
  01881	5f		 pop	 edi
  01882	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01883	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01886	33 cd		 xor	 ecx, ebp
  01888	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0188d	8b e5		 mov	 esp, ebp
  0188f	5d		 pop	 ebp
  01890	c3		 ret	 0
$LN73@CGUseItemR:

; 16260: 		}
; 16261: 		else if ( citem->m_Type == ITEMGET(14,20) )

  01891	ba 14 1c 00 00	 mov	 edx, 7188		; 00001c14H
  01896	66 3b c2	 cmp	 ax, dx
  01899	75 5e		 jne	 SHORT $LN71@CGUseItemR

; 16262: 		{
; 16263: 			if ( citem->m_Level == 0 )

  0189b	66 83 79 08 00	 cmp	 WORD PTR [ecx+8], 0
  018a0	0f 85 d9 12 00
	00		 jne	 $LN343@CGUseItemR

; 16264: 			{
; 16265: 				gObjInventoryItemSet(aIndex, pos, -1);

  018a6	68 ff 00 00 00	 push	 255			; 000000ffH
  018ab	53		 push	 ebx
  018ac	57		 push	 edi
  018ad	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16266: 				gObj[aIndex].pInventory[pos].Clear();

  018b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018b7	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  018be	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  018c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  018c7	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16267: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  018cc	6a 01		 push	 1
  018ce	53		 push	 ebx
  018cf	57		 push	 edi
  018d0	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16268: 				gObjUseDrink(&gObj[aIndex], 2);

  018d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018db	03 ce		 add	 ecx, esi
  018dd	6a 02		 push	 2
  018df	51		 push	 ecx
  018e0	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseDrink
  018e5	83 c4 14	 add	 esp, 20			; 00000014H
  018e8	5b		 pop	 ebx
  018e9	5f		 pop	 edi
  018ea	5e		 pop	 esi

; 16547: 	}
; 16548: }

  018eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018ee	33 cd		 xor	 ecx, ebp
  018f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018f5	8b e5		 mov	 esp, ebp
  018f7	5d		 pop	 ebp
  018f8	c3		 ret	 0
$LN71@CGUseItemR:

; 16269: 			}
; 16270: 		}
; 16271: 		else if ( citem->m_Type == ITEMGET(13,15) )

  018f9	ba 0f 1a 00 00	 mov	 edx, 6671		; 00001a0fH
  018fe	66 3b c2	 cmp	 ax, dx
  01901	75 49		 jne	 SHORT $LN68@CGUseItemR

; 16272: 		{
; 16273: 			if ( iItemUseType == 0 )

  01903	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _iItemUseType$[ebp]
  01909	85 c0		 test	 eax, eax
  0190b	75 1b		 jne	 SHORT $LN67@CGUseItemR

; 16274: 			{
; 16275: 				gObjUsePlusStatFruit(aIndex, pos);

  0190d	53		 push	 ebx
  0190e	57		 push	 edi
  0190f	e8 00 00 00 00	 call	 ?gObjUsePlusStatFruit@@YAXHH@Z ; gObjUsePlusStatFruit
  01914	83 c4 08	 add	 esp, 8
  01917	5b		 pop	 ebx
  01918	5f		 pop	 edi
  01919	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0191a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0191d	33 cd		 xor	 ecx, ebp
  0191f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01924	8b e5		 mov	 esp, ebp
  01926	5d		 pop	 ebp
  01927	c3		 ret	 0
$LN67@CGUseItemR:

; 16276: 			}
; 16277: 			else if ( iItemUseType == 1 )

  01928	83 f8 01	 cmp	 eax, 1
  0192b	0f 85 4e 12 00
	00		 jne	 $LN343@CGUseItemR

; 16278: 			{
; 16279: 				gObjUseMinusStatFruit(aIndex, pos);

  01931	53		 push	 ebx
  01932	57		 push	 edi
  01933	e8 00 00 00 00	 call	 ?gObjUseMinusStatFruit@@YAXHH@Z ; gObjUseMinusStatFruit
  01938	83 c4 08	 add	 esp, 8
  0193b	5b		 pop	 ebx
  0193c	5f		 pop	 edi
  0193d	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0193e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01941	33 cd		 xor	 ecx, ebp
  01943	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01948	8b e5		 mov	 esp, ebp
  0194a	5d		 pop	 ebp
  0194b	c3		 ret	 0
$LN68@CGUseItemR:

; 16280: 			}
; 16281: 		}
; 16282: 		else if(citem->m_Type == ITEMGET(13,54) || 
; 16283: 				citem->m_Type == ITEMGET(13,55) || 
; 16284: 				citem->m_Type == ITEMGET(13,56) || 
; 16285: 				citem->m_Type == ITEMGET(13,57) || 
; 16286: 				citem->m_Type == ITEMGET(13,58) )

  0194c	b9 36 1a 00 00	 mov	 ecx, 6710		; 00001a36H
  01951	66 3b c1	 cmp	 ax, cx
  01954	0f 84 99 0a 00
	00		 je	 $LN62@CGUseItemR
  0195a	ba 37 1a 00 00	 mov	 edx, 6711		; 00001a37H
  0195f	66 3b c2	 cmp	 ax, dx
  01962	0f 84 8b 0a 00
	00		 je	 $LN62@CGUseItemR
  01968	b9 38 1a 00 00	 mov	 ecx, 6712		; 00001a38H
  0196d	66 3b c1	 cmp	 ax, cx
  01970	0f 84 7d 0a 00
	00		 je	 $LN62@CGUseItemR
  01976	ba 39 1a 00 00	 mov	 edx, 6713		; 00001a39H
  0197b	66 3b c2	 cmp	 ax, dx
  0197e	0f 84 6f 0a 00
	00		 je	 $LN62@CGUseItemR
  01984	b9 3a 1a 00 00	 mov	 ecx, 6714		; 00001a3aH
  01989	66 3b c1	 cmp	 ax, cx
  0198c	0f 84 61 0a 00
	00		 je	 $LN62@CGUseItemR

; 16289: 		}
; 16290: 		else if(citem->m_Type == ITEMGET(14,78) || 
; 16291: 				citem->m_Type == ITEMGET(14,79) || 
; 16292: 				citem->m_Type == ITEMGET(14,80) || 
; 16293: 				citem->m_Type == ITEMGET(14,81) || 
; 16294: 				citem->m_Type == ITEMGET(14,82) )

  01992	ba 4e 1c 00 00	 mov	 edx, 7246		; 00001c4eH
  01997	66 3b c2	 cmp	 ax, dx
  0199a	0f 84 30 0a 00
	00		 je	 $LN59@CGUseItemR
  019a0	b9 4f 1c 00 00	 mov	 ecx, 7247		; 00001c4fH
  019a5	66 3b c1	 cmp	 ax, cx
  019a8	0f 84 22 0a 00
	00		 je	 $LN59@CGUseItemR
  019ae	ba 50 1c 00 00	 mov	 edx, 7248		; 00001c50H
  019b3	66 3b c2	 cmp	 ax, dx
  019b6	0f 84 14 0a 00
	00		 je	 $LN59@CGUseItemR
  019bc	b9 51 1c 00 00	 mov	 ecx, 7249		; 00001c51H
  019c1	66 3b c1	 cmp	 ax, cx
  019c4	0f 84 06 0a 00
	00		 je	 $LN59@CGUseItemR
  019ca	ba 52 1c 00 00	 mov	 edx, 7250		; 00001c52H
  019cf	66 3b c2	 cmp	 ax, dx
  019d2	0f 84 f8 09 00
	00		 je	 $LN59@CGUseItemR

; 16297: 		}
; 16298: 		else if (citem->m_Type == ITEMGET(14,72) )

  019d8	b9 48 1c 00 00	 mov	 ecx, 7240		; 00001c48H
  019dd	66 3b c1	 cmp	 ax, cx
  019e0	75 23		 jne	 SHORT $LN57@CGUseItemR

; 16299: 		{
; 16300: 			gObjUseCashShopPkDownItem(&gObj[aIndex], pos);

  019e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019e8	03 d6		 add	 edx, esi
  019ea	53		 push	 ebx
  019eb	52		 push	 edx
  019ec	e8 00 00 00 00	 call	 ?gObjUseCashShopPkDownItem@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseCashShopPkDownItem
  019f1	83 c4 08	 add	 esp, 8
  019f4	5b		 pop	 ebx
  019f5	5f		 pop	 edi
  019f6	5e		 pop	 esi

; 16547: 	}
; 16548: }

  019f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019fa	33 cd		 xor	 ecx, ebp
  019fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a01	8b e5		 mov	 esp, ebp
  01a03	5d		 pop	 ebp
  01a04	c3		 ret	 0
$LN57@CGUseItemR:

; 16301: 		}
; 16302: 		else if(citem->m_Type == ITEMGET(14,70) || 
; 16303: 				citem->m_Type == ITEMGET(14,71) )

  01a05	b9 46 1c 00 00	 mov	 ecx, 7238		; 00001c46H
  01a0a	66 3b c1	 cmp	 ax, cx
  01a0d	0f 84 9a 09 00
	00		 je	 $LN54@CGUseItemR
  01a13	ba 47 1c 00 00	 mov	 edx, 7239		; 00001c47H
  01a18	66 3b c2	 cmp	 ax, dx
  01a1b	0f 84 8c 09 00
	00		 je	 $LN54@CGUseItemR

; 16306: 		}
; 16307: 		else if( citem->m_Type == ITEMGET(14,94) ) //season 3.5 add-on

  01a21	b9 5e 1c 00 00	 mov	 ecx, 7262		; 00001c5eH
  01a26	66 3b c1	 cmp	 ax, cx

; 16308: 		{
; 16309: 			gObjUseRecoveryPotion(&gObj[aIndex], pos, (double)0.65);

  01a29	74 0a		 je	 SHORT $LN374@CGUseItemR

; 16310: 		}
; 16311: 
; 16312: 		else if( citem->m_Type == ITEMGET(14, 133) )	//1.01.00

  01a2b	b9 85 1c 00 00	 mov	 ecx, 7301		; 00001c85H
  01a30	66 3b c1	 cmp	 ax, cx
  01a33	75 2f		 jne	 SHORT $LN50@CGUseItemR
$LN374@CGUseItemR:

; 16313: 		{
; 16314: 			gObjUseRecoveryPotion(&gObj[aIndex], pos, (double)0.65);

  01a35	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3fe4cccccccccccd
  01a3b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a41	83 ec 08	 sub	 esp, 8
  01a44	dd 1c 24	 fstp	 QWORD PTR [esp]
  01a47	03 d6		 add	 edx, esi
  01a49	53		 push	 ebx
  01a4a	52		 push	 edx
  01a4b	e8 00 00 00 00	 call	 ?gObjUseRecoveryPotion@@YAXPAUOBJECTSTRUCT@@HN@Z ; gObjUseRecoveryPotion
  01a50	83 c4 10	 add	 esp, 16			; 00000010H
  01a53	5b		 pop	 ebx
  01a54	5f		 pop	 edi
  01a55	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01a56	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a59	33 cd		 xor	 ecx, ebp
  01a5b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a60	8b e5		 mov	 esp, ebp
  01a62	5d		 pop	 ebp
  01a63	c3		 ret	 0
$LN50@CGUseItemR:

; 16315: 		}
; 16316: 		else if( citem->m_Type == ITEMGET(14, 162) )	//1.01.00 update

  01a64	b9 a2 1c 00 00	 mov	 ecx, 7330		; 00001ca2H
  01a69	66 3b c1	 cmp	 ax, cx
  01a6c	75 35		 jne	 SHORT $LN48@CGUseItemR

; 16317: 		{
; 16318: 			GDUpdateExtendedInvenCount(&gObj[aIndex], 1, 0, lpMsg->inventoryPos, 0, 0);

  01a6e	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  01a74	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  01a78	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01a7e	6a 00		 push	 0
  01a80	6a 00		 push	 0
  01a82	50		 push	 eax
  01a83	6a 00		 push	 0
  01a85	03 ce		 add	 ecx, esi
  01a87	6a 01		 push	 1
  01a89	51		 push	 ecx
  01a8a	e8 00 00 00 00	 call	 ?GDUpdateExtendedInvenCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z ; GDUpdateExtendedInvenCount
  01a8f	83 c4 18	 add	 esp, 24			; 00000018H
  01a92	5b		 pop	 ebx
  01a93	5f		 pop	 edi
  01a94	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01a95	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a98	33 cd		 xor	 ecx, ebp
  01a9a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a9f	8b e5		 mov	 esp, ebp
  01aa1	5d		 pop	 ebp
  01aa2	c3		 ret	 0
$LN48@CGUseItemR:

; 16319: 		}
; 16320: 		else if( citem->m_Type == ITEMGET(14, 163) )	//1.01.00 update

  01aa3	ba a3 1c 00 00	 mov	 edx, 7331		; 00001ca3H
  01aa8	66 3b c2	 cmp	 ax, dx
  01aab	75 35		 jne	 SHORT $LN46@CGUseItemR

; 16321: 		{
; 16322: 			GDUpdateExtendedWarehouseCount(&gObj[aIndex], 1, 0, lpMsg->inventoryPos, 0, 0);

  01aad	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$[ebp]
  01ab3	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  01ab7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01abd	6a 00		 push	 0
  01abf	6a 00		 push	 0
  01ac1	51		 push	 ecx
  01ac2	6a 00		 push	 0
  01ac4	03 d6		 add	 edx, esi
  01ac6	6a 01		 push	 1
  01ac8	52		 push	 edx
  01ac9	e8 00 00 00 00	 call	 ?GDUpdateExtendedWarehouseCount@@YAXPAUOBJECTSTRUCT@@EKH_N1@Z ; GDUpdateExtendedWarehouseCount
  01ace	83 c4 18	 add	 esp, 24			; 00000018H
  01ad1	5b		 pop	 ebx
  01ad2	5f		 pop	 edi
  01ad3	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01ad4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ad7	33 cd		 xor	 ecx, ebp
  01ad9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ade	8b e5		 mov	 esp, ebp
  01ae0	5d		 pop	 ebp
  01ae1	c3		 ret	 0
$LN46@CGUseItemR:

; 16323: 		}
; 16324: 
; 16325: 		else if(citem->m_Type == ITEMGET(14,85) || 
; 16326: 				citem->m_Type == ITEMGET(14,86) || 
; 16327: 				citem->m_Type == ITEMGET(14,87) ) //S3 Addition

  01ae2	b9 55 1c 00 00	 mov	 ecx, 7253		; 00001c55H
  01ae7	66 3b c1	 cmp	 ax, cx
  01aea	0f 84 01 08 00
	00		 je	 $LN43@CGUseItemR
  01af0	ba 56 1c 00 00	 mov	 edx, 7254		; 00001c56H
  01af5	66 3b c2	 cmp	 ax, dx
  01af8	0f 84 f3 07 00
	00		 je	 $LN43@CGUseItemR
  01afe	b9 57 1c 00 00	 mov	 ecx, 7255		; 00001c57H
  01b03	66 3b c1	 cmp	 ax, cx
  01b06	0f 84 e5 07 00
	00		 je	 $LN43@CGUseItemR

; 16352: 		}
; 16353: 		else if ( citem->m_Type == ITEMGET(14,7) )

  01b0c	ba 07 1c 00 00	 mov	 edx, 7175		; 00001c07H
  01b11	66 3b c2	 cmp	 ax, dx
  01b14	0f 85 2c 01 00
	00		 jne	 $LN35@CGUseItemR

; 16354: 		{
; 16355: 			int iLevel = citem->m_Level;

  01b1a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  01b20	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  01b24	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iLevel$250229[ebp], eax

; 16356: 			int iSerial = citem->GetNumber();

  01b2a	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 16357: 			int iDur = (int)citem->m_Durability;

  01b2f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  01b35	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iSerial$250230[ebp], eax
  01b3b	d9 41 24	 fld	 DWORD PTR [ecx+36]
  01b3e	e8 00 00 00 00	 call	 __ftol2_sse

; 16358: 
; 16359: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  01b43	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b49	6a 01		 push	 1
  01b4b	03 d6		 add	 edx, esi
  01b4d	53		 push	 ebx
  01b4e	52		 push	 edx
  01b4f	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iDur$250231[ebp], eax
  01b55	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01b5a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b5d	85 c0		 test	 eax, eax
  01b5f	75 32		 jne	 SHORT $LN34@CGUseItemR

; 16360: 			{
; 16361: 				gObjInventoryItemSet(aIndex, pos, -1);

  01b61	68 ff 00 00 00	 push	 255			; 000000ffH
  01b66	53		 push	 ebx
  01b67	57		 push	 edi
  01b68	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16362: 				gObj[aIndex].pInventory[pos].Clear();

  01b6d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b72	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  01b79	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01b7f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b82	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16363: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01b87	6a 01		 push	 1
  01b89	53		 push	 ebx
  01b8a	57		 push	 edi
  01b8b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01b90	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@CGUseItemR:

; 16364: 			}	
; 16365: 			
; 16366: 			if ( gObj[aIndex].lpGuild )

  01b93	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b98	8b 8c 30 38 04
	00 00		 mov	 ecx, DWORD PTR [eax+esi+1080]
  01b9f	85 c9		 test	 ecx, ecx
  01ba1	74 33		 je	 SHORT $LN33@CGUseItemR

; 16367: 			{
; 16368: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s] - (Guild : %s)", 
; 16369: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].lpGuild->Name);

  01ba3	83 c1 04	 add	 ecx, 4
  01ba6	51		 push	 ecx
  01ba7	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  01bab	51		 push	 ecx
  01bac	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iSerial$250230[ebp]
  01bb2	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  01bb6	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _iDur$250231[ebp]
  01bbc	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _iLevel$250229[ebp]
  01bc2	52		 push	 edx
  01bc3	50		 push	 eax
  01bc4	51		 push	 ecx
  01bc5	56		 push	 esi
  01bc6	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
  01bcb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01bd1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 16370: 			}
; 16371: 			else

  01bd4	eb 2d		 jmp	 SHORT $LN32@CGUseItemR
$LN33@CGUseItemR:

; 16372: 			{
; 16373: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s]", 
; 16374: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name);

  01bd6	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iDur$250231[ebp]
  01bdc	8d 54 30 77	 lea	 edx, DWORD PTR [eax+esi+119]
  01be0	52		 push	 edx
  01be1	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _iSerial$250230[ebp]
  01be7	8d 44 30 6c	 lea	 eax, DWORD PTR [eax+esi+108]
  01beb	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _iLevel$250229[ebp]
  01bf1	50		 push	 eax
  01bf2	51		 push	 ecx
  01bf3	52		 push	 edx
  01bf4	56		 push	 esi
  01bf5	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
  01bfa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01c00	83 c4 18	 add	 esp, 24			; 00000018H
$LN32@CGUseItemR:

; 16375: 			}
; 16376: 
; 16377: 			if ( iLevel == 0 )

  01c03	85 f6		 test	 esi, esi
  01c05	75 1b		 jne	 SHORT $LN31@CGUseItemR

; 16378: 			{
; 16379: 				gObjUseBlessAndSoulPotion(aIndex, iLevel);

  01c07	56		 push	 esi
  01c08	57		 push	 edi
  01c09	e8 00 00 00 00	 call	 ?gObjUseBlessAndSoulPotion@@YAXHH@Z ; gObjUseBlessAndSoulPotion
  01c0e	83 c4 08	 add	 esp, 8
  01c11	5b		 pop	 ebx
  01c12	5f		 pop	 edi
  01c13	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01c14	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c17	33 cd		 xor	 ecx, ebp
  01c19	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c1e	8b e5		 mov	 esp, ebp
  01c20	5d		 pop	 ebp
  01c21	c3		 ret	 0
$LN31@CGUseItemR:

; 16380: 			}
; 16381: 			else if ( iLevel == 1 )

  01c22	83 fe 01	 cmp	 esi, 1
  01c25	0f 85 54 0f 00
	00		 jne	 $LN343@CGUseItemR

; 16382: 			{
; 16383: 				gObjUseBlessAndSoulPotion(aIndex, iLevel);

  01c2b	56		 push	 esi
  01c2c	57		 push	 edi
  01c2d	e8 00 00 00 00	 call	 ?gObjUseBlessAndSoulPotion@@YAXHH@Z ; gObjUseBlessAndSoulPotion
  01c32	83 c4 08	 add	 esp, 8
  01c35	5b		 pop	 ebx
  01c36	5f		 pop	 edi
  01c37	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01c38	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c3b	33 cd		 xor	 ecx, ebp
  01c3d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c42	8b e5		 mov	 esp, ebp
  01c44	5d		 pop	 ebp
  01c45	c3		 ret	 0
$LN35@CGUseItemR:

; 16384: 			}
; 16385: 		}
; 16386: 		else if ( citem->m_Type == ITEMGET(13,48) )

  01c46	b9 30 1a 00 00	 mov	 ecx, 6704		; 00001a30H
  01c4b	66 3b c1	 cmp	 ax, cx
  01c4e	0f 85 7d 01 00
	00		 jne	 $LN27@CGUseItemR

; 16387: 		{
; 16388: 			if ( (gObj[aIndex].MapNumber < MAP_INDEX_KALIMA1 || 
; 16389: 				gObj[aIndex].MapNumber > MAP_INDEX_KALIMA6 ) && 
; 16390: 				gObj[aIndex].MapNumber != MAP_INDEX_KALIMA7 )

  01c54	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c5a	8a 84 32 49 01
	00 00		 mov	 al, BYTE PTR [edx+esi+329]
  01c61	3c 18		 cmp	 al, 24			; 00000018H
  01c63	72 08		 jb	 SHORT $LN25@CGUseItemR
  01c65	3c 1d		 cmp	 al, 29			; 0000001dH
  01c67	0f 86 12 0f 00
	00		 jbe	 $LN343@CGUseItemR
$LN25@CGUseItemR:
  01c6d	3c 24		 cmp	 al, 36			; 00000024H
  01c6f	0f 84 0a 0f 00
	00		 je	 $LN343@CGUseItemR

; 16391: 			{
; 16392: 				int iLevel = g_KalimaGate.GetKalimaGateLevel2(aIndex);

  01c75	57		 push	 edi
  01c76	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  01c7b	e8 00 00 00 00	 call	 ?GetKalimaGateLevel2@CKalimaGate@@QAEHH@Z ; CKalimaGate::GetKalimaGateLevel2

; 16393: 				int iSerial = citem->GetNumber();

  01c80	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  01c86	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iLevel$250245[ebp], eax
  01c8c	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 16394: 				int iDuration = (int)citem->m_Durability;
; 16395: 				BOOL bKalimaGateCreateResult = FALSE;
; 16396: 				int iKalimaGateX = 0;
; 16397: 				int iKalimaGateY = 0;
; 16398: 
; 16399: 				iLevel++;
; 16400: 				iKalimaGateX = gObj[aIndex].X + rand()%6 - 2;

  01c91	e8 00 00 00 00	 call	 _rand
  01c96	99		 cdq
  01c97	b9 06 00 00 00	 mov	 ecx, 6
  01c9c	f7 f9		 idiv	 ecx
  01c9e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ca3	0f bf 8c 30 44
	01 00 00	 movsx	 ecx, WORD PTR [eax+esi+324]
  01cab	8d 54 0a fe	 lea	 edx, DWORD PTR [edx+ecx-2]
  01caf	89 95 ec fe ff
	ff		 mov	 DWORD PTR _iKalimaGateX$250250[ebp], edx

; 16401: 				iKalimaGateY = gObj[aIndex].Y + rand()%6 - 2;

  01cb5	e8 00 00 00 00	 call	 _rand
  01cba	99		 cdq
  01cbb	b9 06 00 00 00	 mov	 ecx, 6
  01cc0	f7 f9		 idiv	 ecx
  01cc2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cc7	0f bf 8c 30 46
	01 00 00	 movsx	 ecx, WORD PTR [eax+esi+326]
  01ccf	8d 44 0a fe	 lea	 eax, DWORD PTR [edx+ecx-2]

; 16402: 
; 16403: 				bKalimaGateCreateResult = g_KalimaGate.CreateKalimaGate(aIndex, iLevel, iKalimaGateX, iKalimaGateY);

  01cd3	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iKalimaGateX$250250[ebp]
  01cd9	50		 push	 eax
  01cda	8a 85 f4 fe ff
	ff		 mov	 al, BYTE PTR _iLevel$250245[ebp]
  01ce0	fe c0		 inc	 al
  01ce2	0f b6 c0	 movzx	 eax, al
  01ce5	52		 push	 edx
  01ce6	50		 push	 eax
  01ce7	57		 push	 edi
  01ce8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  01ced	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate

; 16404: 
; 16405: 				if ( bKalimaGateCreateResult == TRUE )
; 16406: 				{
; 16407: 					if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  01cf2	6a 01		 push	 1
  01cf4	83 f8 01	 cmp	 eax, 1
  01cf7	75 68		 jne	 SHORT $LN24@CGUseItemR
  01cf9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cff	03 ce		 add	 ecx, esi
  01d01	53		 push	 ebx
  01d02	51		 push	 ecx
  01d03	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01d08	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d0b	85 c0		 test	 eax, eax
  01d0d	75 33		 jne	 SHORT $LN23@CGUseItemR

; 16408: 					{
; 16409: 						gObjInventoryItemSet(aIndex, pos, -1);

  01d0f	68 ff 00 00 00	 push	 255			; 000000ffH
  01d14	53		 push	 ebx
  01d15	57		 push	 edi
  01d16	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16410: 						gObj[aIndex].pInventory[pos].Clear();

  01d1b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d21	8b 8c 32 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+esi+3620]
  01d28	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01d2e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d31	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16411: 						GCInventoryItemDeleteSend(aIndex, pos, 1);

  01d36	6a 01		 push	 1
  01d38	53		 push	 ebx
  01d39	57		 push	 edi
  01d3a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01d3f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@CGUseItemR:

; 16412: 					}
; 16413: 
; 16414: 					LogAddTD("[PCS] Use Free Kalima Ticket Success");

  01d42	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@
  01d47	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01d4d	83 c4 04	 add	 esp, 4
  01d50	5b		 pop	 ebx
  01d51	5f		 pop	 edi
  01d52	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01d53	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d56	33 cd		 xor	 ecx, ebp
  01d58	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d5d	8b e5		 mov	 esp, ebp
  01d5f	5d		 pop	 ebp
  01d60	c3		 ret	 0
$LN24@CGUseItemR:

; 16415: 				}
; 16416: 				else
; 16417: 				{
; 16418: 					GCItemDurSend(aIndex,(BYTE)pos,(BYTE)gObj[aIndex].pInventory[pos].m_Durability,1); //GS 19 Second Edition

  01d61	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d66	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  01d6d	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv4138[ebp]
  01d73	d9 bd f2 fe ff
	ff		 fnstcw	 WORD PTR tv2682[ebp]
  01d79	0f b7 85 f2 fe
	ff ff		 movzx	 eax, WORD PTR tv2682[ebp]
  01d80	d9 44 11 24	 fld	 DWORD PTR [ecx+edx+36]
  01d84	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  01d89	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv2520[ebp], eax
  01d8f	d9 ad ec fe ff
	ff		 fldcw	 WORD PTR tv2520[ebp]
  01d95	db 9d ec fe ff
	ff		 fistp	 DWORD PTR tv2478[ebp]
  01d9b	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR tv2478[ebp]
  01da1	0f b6 c8	 movzx	 ecx, al
  01da4	51		 push	 ecx
  01da5	53		 push	 ebx
  01da6	d9 ad f2 fe ff
	ff		 fldcw	 WORD PTR tv2682[ebp]
  01dac	57		 push	 edi
  01dad	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend

; 16419: 					LogAddTD("[PCS] Use Free Kalima Ticket Failed");

  01db2	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@
  01db7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01dbd	83 c4 14	 add	 esp, 20			; 00000014H
  01dc0	5b		 pop	 ebx
  01dc1	5f		 pop	 edi
  01dc2	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01dc3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01dc6	33 cd		 xor	 ecx, ebp
  01dc8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01dcd	8b e5		 mov	 esp, ebp
  01dcf	5d		 pop	 ebp
  01dd0	c3		 ret	 0
$LN27@CGUseItemR:

; 16420: 				}
; 16421: 			}
; 16422: 		}
; 16423: 		else if ( citem->m_Type == ITEMGET(13,69) ) //season 4 add-on

  01dd1	ba 45 1a 00 00	 mov	 edx, 6725		; 00001a45H
  01dd6	66 3b c2	 cmp	 ax, dx
  01dd9	0f 85 e8 01 00
	00		 jne	 $LN20@CGUseItemR

; 16424: 		{
; 16425: 			BOOL bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove(&gObj[aIndex],gObj[aIndex].m_wRaiseTalismanSaveMap);

  01ddf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01de4	0f bf 8c 30 02
	02 00 00	 movsx	 ecx, WORD PTR [eax+esi+514]
  01dec	03 c6		 add	 eax, esi
  01dee	51		 push	 ecx
  01def	50		 push	 eax
  01df0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  01df5	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 16426: 
; 16427: 			if( BC_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE &&
; 16428: 				CC_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE &&
; 16429: 				KALIMA_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE &&
; 16430: 				DS_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE &&
; 16431: 				IT_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE &&
; 16432: 				gObj[aIndex].MapNumber != MAP_INDEX_CASTLESIEGE &&
; 16433: 				gObj[aIndex].MapNumber != MAP_INDEX_CASTLEHUNTZONE && 
; 16434: #ifdef IMPERIAL_CONFLICT_NEW
; 16435: 				 !CImperialGuardian::IsEventMap(gObj[aIndex].MapNumber) &&
; 16436: #endif
; 16437: 				bCheckEquipmentToMove == TRUE )

  01dfa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e00	8a 8c 32 49 01
	00 00		 mov	 cl, BYTE PTR [edx+esi+329]
  01e07	89 85 ec fe ff
	ff		 mov	 DWORD PTR _bCheckEquipmentToMove$250261[ebp], eax
  01e0d	80 f9 34	 cmp	 cl, 52			; 00000034H
  01e10	0f 84 71 01 00
	00		 je	 $LN19@CGUseItemR
  01e16	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  01e19	72 10		 jb	 SHORT $LN333@CGUseItemR
  01e1b	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  01e20	3a c1		 cmp	 al, cl
  01e22	1b c0		 sbb	 eax, eax
  01e24	40		 inc	 eax
  01e25	0f 85 5c 01 00
	00		 jne	 $LN19@CGUseItemR
$LN333@CGUseItemR:
  01e2b	80 f9 35	 cmp	 cl, 53			; 00000035H
  01e2e	0f 84 53 01 00
	00		 je	 $LN19@CGUseItemR
  01e34	80 f9 12	 cmp	 cl, 18			; 00000012H
  01e37	72 10		 jb	 SHORT $LN323@CGUseItemR
  01e39	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  01e3e	3a c1		 cmp	 al, cl
  01e40	1b c0		 sbb	 eax, eax
  01e42	40		 inc	 eax
  01e43	0f 85 3e 01 00
	00		 jne	 $LN19@CGUseItemR
$LN323@CGUseItemR:
  01e49	80 f9 18	 cmp	 cl, 24			; 00000018H
  01e4c	72 19		 jb	 SHORT $LN324@CGUseItemR
  01e4e	80 f9 1d	 cmp	 cl, 29			; 0000001dH
  01e51	0f 86 30 01 00
	00		 jbe	 $LN19@CGUseItemR
  01e57	33 c0		 xor	 eax, eax
  01e59	80 f9 24	 cmp	 cl, 36			; 00000024H
  01e5c	0f 94 c0	 sete	 al
  01e5f	85 c0		 test	 eax, eax
  01e61	0f 85 20 01 00
	00		 jne	 $LN19@CGUseItemR
$LN324@CGUseItemR:
  01e67	80 f9 09	 cmp	 cl, 9
  01e6a	0f 84 17 01 00
	00		 je	 $LN19@CGUseItemR
  01e70	33 c0		 xor	 eax, eax
  01e72	80 f9 20	 cmp	 cl, 32			; 00000020H
  01e75	0f 94 c0	 sete	 al
  01e78	85 c0		 test	 eax, eax
  01e7a	0f 85 07 01 00
	00		 jne	 $LN19@CGUseItemR
  01e80	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  01e83	72 10		 jb	 SHORT $LN325@CGUseItemR
  01e85	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  01e8a	3a c1		 cmp	 al, cl
  01e8c	1b c0		 sbb	 eax, eax
  01e8e	40		 inc	 eax
  01e8f	0f 85 f2 00 00
	00		 jne	 $LN19@CGUseItemR
$LN325@CGUseItemR:
  01e95	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  01e98	0f 84 e9 00 00
	00		 je	 $LN19@CGUseItemR
  01e9e	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  01ea1	0f 84 e0 00 00
	00		 je	 $LN19@CGUseItemR
  01ea7	83 bd ec fe ff
	ff 01		 cmp	 DWORD PTR _bCheckEquipmentToMove$250261[ebp], 1
  01eae	0f 85 d3 00 00
	00		 jne	 $LN19@CGUseItemR

; 16438: 			{
; 16439: 				gObjTeleport(aIndex, gObj[aIndex].m_wRaiseTalismanSaveMap, 
; 16440: 					gObj[aIndex].m_wRaiseTalismanSaveX, gObj[aIndex].m_wRaiseTalismanSaveY);

  01eb4	0f bf 8c 32 00
	02 00 00	 movsx	 ecx, WORD PTR [edx+esi+512]
  01ebc	0f bf 84 32 fe
	01 00 00	 movsx	 eax, WORD PTR [edx+esi+510]
  01ec4	51		 push	 ecx
  01ec5	0f bf 8c 32 02
	02 00 00	 movsx	 ecx, WORD PTR [edx+esi+514]
  01ecd	50		 push	 eax
  01ece	51		 push	 ecx
  01ecf	57		 push	 edi
  01ed0	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 16441: 				gObjInventoryItemSet(aIndex, pos, -1);

  01ed5	68 ff 00 00 00	 push	 255			; 000000ffH
  01eda	53		 push	 ebx
  01edb	57		 push	 edi
  01edc	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16442: 				gObj[aIndex].pInventory[pos].Clear();

  01ee1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ee7	8b 8c 32 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+esi+3620]
  01eee	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  01ef4	83 c4 1c	 add	 esp, 28			; 0000001cH
  01ef7	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16443: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01efc	6a 01		 push	 1
  01efe	53		 push	 ebx
  01eff	57		 push	 edi
  01f00	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16444: 
; 16445: 				LogAddTD("[Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X:[%d] Y:[%d]", 
; 16446: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_wRaiseTalismanSaveMap,
; 16447: 					gObj[aIndex].m_wRaiseTalismanSaveX, gObj[aIndex].m_wRaiseTalismanSaveY);

  01f05	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f0a	0f bf 8c 30 00
	02 00 00	 movsx	 ecx, WORD PTR [eax+esi+512]
  01f12	0f bf 94 30 fe
	01 00 00	 movsx	 edx, WORD PTR [eax+esi+510]
  01f1a	51		 push	 ecx
  01f1b	0f bf 8c 30 02
	02 00 00	 movsx	 ecx, WORD PTR [eax+esi+514]
  01f23	52		 push	 edx
  01f24	51		 push	 ecx
  01f25	8d 54 30 77	 lea	 edx, DWORD PTR [eax+esi+119]
  01f29	52		 push	 edx
  01f2a	8d 44 30 6c	 lea	 eax, DWORD PTR [eax+esi+108]
  01f2e	50		 push	 eax
  01f2f	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@
  01f34	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16448: 
; 16449: 				gObj[aIndex].m_wRaiseTalismanSaveMap = 0;

  01f3a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f40	33 c9		 xor	 ecx, ecx
  01f42	66 89 8c 32 02
	02 00 00	 mov	 WORD PTR [edx+esi+514], cx

; 16450: 				gObj[aIndex].m_wRaiseTalismanSaveX = 0;

  01f4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16451: 				gObj[aIndex].m_wRaiseTalismanSaveY = 0;

  01f50	33 d2		 xor	 edx, edx

; 16452: 
; 16453: 				GCServerCmd(aIndex, 60, 0, 0);

  01f52	52		 push	 edx
  01f53	33 c0		 xor	 eax, eax
  01f55	52		 push	 edx
  01f56	66 89 84 31 fe
	01 00 00	 mov	 WORD PTR [ecx+esi+510], ax
  01f5e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f63	6a 3c		 push	 60			; 0000003cH
  01f65	57		 push	 edi
  01f66	66 89 94 30 00
	02 00 00	 mov	 WORD PTR [eax+esi+512], dx
  01f6e	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd
  01f73	83 c4 34	 add	 esp, 52			; 00000034H
  01f76	5b		 pop	 ebx
  01f77	5f		 pop	 edi
  01f78	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01f79	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01f7c	33 cd		 xor	 ecx, ebp
  01f7e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01f83	8b e5		 mov	 esp, ebp
  01f85	5d		 pop	 ebp
  01f86	c3		 ret	 0
$LN19@CGUseItemR:

; 16454: 			}
; 16455: 			else
; 16456: 			{
; 16457: 				char szTemp[256];
; 16458: 				wsprintf(szTemp, lMsg.Get(1252));

  01f87	68 e4 04 00 00	 push	 1252			; 000004e4H
  01f8c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01f91	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  01f96	50		 push	 eax
  01f97	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$250265[ebp]
  01f9d	51		 push	 ecx
  01f9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16459: 				GCServerMsgStringSend(szTemp, aIndex, 1);

  01fa4	6a 01		 push	 1
  01fa6	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$250265[ebp]
  01fac	57		 push	 edi
  01fad	52		 push	 edx
  01fae	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01fb3	83 c4 14	 add	 esp, 20			; 00000014H
  01fb6	5b		 pop	 ebx
  01fb7	5f		 pop	 edi
  01fb8	5e		 pop	 esi

; 16547: 	}
; 16548: }

  01fb9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01fbc	33 cd		 xor	 ecx, ebp
  01fbe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01fc3	8b e5		 mov	 esp, ebp
  01fc5	5d		 pop	 ebp
  01fc6	c3		 ret	 0
$LN20@CGUseItemR:

; 16460: 			}
; 16461: 		}
; 16462: 		else if ( citem->m_Type == ITEMGET(13,70) ) //season 4 add-on

  01fc7	b9 46 1a 00 00	 mov	 ecx, 6726		; 00001a46H
  01fcc	66 3b c1	 cmp	 ax, cx
  01fcf	0f 85 e7 01 00
	00		 jne	 $LN16@CGUseItemR

; 16463: 		{
; 16464: 			BOOL bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove(&gObj[aIndex],gObj[aIndex].m_wTeleportTalismanSaveMap);

  01fd5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fda	0f bf 8c 30 08
	02 00 00	 movsx	 ecx, WORD PTR [eax+esi+520]
  01fe2	03 c6		 add	 eax, esi
  01fe4	51		 push	 ecx
  01fe5	50		 push	 eax
  01fe6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  01feb	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 16465: 
; 16466: 			if( gObjCheckRaiseTalismanMap(gObj[aIndex].MapNumber) == TRUE && bCheckEquipmentToMove == TRUE)

  01ff0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ff6	89 85 ec fe ff
	ff		 mov	 DWORD PTR _bCheckEquipmentToMove$250268[ebp], eax
  01ffc	0f b6 84 32 49
	01 00 00	 movzx	 eax, BYTE PTR [edx+esi+329]
  02004	50		 push	 eax
  02005	e8 00 00 00 00	 call	 ?gObjCheckRaiseTalismanMap@@YAHH@Z ; gObjCheckRaiseTalismanMap
  0200a	83 c4 04	 add	 esp, 4
  0200d	83 f8 01	 cmp	 eax, 1
  02010	0f 85 66 01 00
	00		 jne	 $LN15@CGUseItemR
  02016	39 85 ec fe ff
	ff		 cmp	 DWORD PTR _bCheckEquipmentToMove$250268[ebp], eax
  0201c	0f 85 5a 01 00
	00		 jne	 $LN15@CGUseItemR

; 16467: 			{
; 16468: 				if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  02022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02028	50		 push	 eax
  02029	03 ce		 add	 ecx, esi
  0202b	53		 push	 ebx
  0202c	51		 push	 ecx
  0202d	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  02032	83 c4 0c	 add	 esp, 12			; 0000000cH
  02035	85 c0		 test	 eax, eax

; 16469: 				{
; 16470: 					gObjTeleport(aIndex, gObj[aIndex].m_wTeleportTalismanSaveMap, 
; 16471: 						gObj[aIndex].m_wTeleportTalismanSaveX, gObj[aIndex].m_wTeleportTalismanSaveY);

  02037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0203c	0f 85 b7 00 00
	00		 jne	 $LN14@CGUseItemR
  02042	0f bf 94 30 06
	02 00 00	 movsx	 edx, WORD PTR [eax+esi+518]
  0204a	0f bf 8c 30 04
	02 00 00	 movsx	 ecx, WORD PTR [eax+esi+516]
  02052	52		 push	 edx
  02053	0f bf 94 30 08
	02 00 00	 movsx	 edx, WORD PTR [eax+esi+520]
  0205b	51		 push	 ecx
  0205c	52		 push	 edx
  0205d	57		 push	 edi
  0205e	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 16472: 					gObjInventoryItemSet(aIndex, pos, -1);

  02063	68 ff 00 00 00	 push	 255			; 000000ffH
  02068	53		 push	 ebx
  02069	57		 push	 edi
  0206a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16473: 					gObj[aIndex].pInventory[pos].Clear();

  0206f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02074	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  0207b	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  02081	83 c4 1c	 add	 esp, 28			; 0000001cH
  02084	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16474: 					GCInventoryItemDeleteSend(aIndex, pos, 1);

  02089	6a 01		 push	 1
  0208b	53		 push	 ebx
  0208c	57		 push	 edi
  0208d	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 16475: 
; 16476: 					gObj[aIndex].m_wTeleportTalismanSaveX = 0;

  02092	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02098	33 c9		 xor	 ecx, ecx
  0209a	66 89 8c 32 04
	02 00 00	 mov	 WORD PTR [edx+esi+516], cx

; 16477: 					gObj[aIndex].m_wTeleportTalismanSaveY = 0;

  020a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16478: 					gObj[aIndex].m_wTeleportTalismanSaveMap = 0;

  020a8	33 d2		 xor	 edx, edx

; 16479: 
; 16480: 					GCServerCmd(aIndex, 61, 0, 0);

  020aa	52		 push	 edx
  020ab	33 c0		 xor	 eax, eax
  020ad	52		 push	 edx
  020ae	66 89 84 31 06
	02 00 00	 mov	 WORD PTR [ecx+esi+518], ax
  020b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020bb	6a 3d		 push	 61			; 0000003dH
  020bd	57		 push	 edi
  020be	66 89 94 30 08
	02 00 00	 mov	 WORD PTR [eax+esi+520], dx
  020c6	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 16481: 
; 16482: 					LogAddTD("[Using Item] [Charm of Move] [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name);

  020cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020d0	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  020d4	51		 push	 ecx
  020d5	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  020d9	52		 push	 edx
  020da	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@
  020df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16545: 		LogAdd("error-L3 : %s return %s %d %d",	
; 16546: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);

  020e5	83 c4 28	 add	 esp, 40			; 00000028H
  020e8	5b		 pop	 ebx
  020e9	5f		 pop	 edi
  020ea	5e		 pop	 esi

; 16547: 	}
; 16548: }

  020eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  020ee	33 cd		 xor	 ecx, ebp
  020f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  020f5	8b e5		 mov	 esp, ebp
  020f7	5d		 pop	 ebp
  020f8	c3		 ret	 0
$LN14@CGUseItemR:

; 16483: 				}
; 16484: 				else
; 16485: 				{
; 16486: 					gObj[aIndex].m_wTeleportTalismanSaveX = gObj[aIndex].X;

  020f9	0f b7 8c 30 44
	01 00 00	 movzx	 ecx, WORD PTR [eax+esi+324]
  02101	66 89 8c 30 04
	02 00 00	 mov	 WORD PTR [eax+esi+516], cx

; 16487: 					gObj[aIndex].m_wTeleportTalismanSaveY = gObj[aIndex].Y;

  02109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0210e	66 8b 94 30 46
	01 00 00	 mov	 dx, WORD PTR [eax+esi+326]
  02116	66 89 94 30 06
	02 00 00	 mov	 WORD PTR [eax+esi+518], dx

; 16488: 					gObj[aIndex].m_wTeleportTalismanSaveMap = gObj[aIndex].MapNumber;

  0211e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02123	0f b6 8c 30 49
	01 00 00	 movzx	 ecx, BYTE PTR [eax+esi+329]
  0212b	66 89 8c 30 08
	02 00 00	 mov	 WORD PTR [eax+esi+520], cx

; 16489: 
; 16490: 					LogAddTD("[Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] X:[%d] Y:[%d]", 
; 16491: 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_wTeleportTalismanSaveMap,
; 16492: 						gObj[aIndex].m_wTeleportTalismanSaveX, gObj[aIndex].m_wTeleportTalismanSaveY);

  02133	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02138	0f bf 94 30 06
	02 00 00	 movsx	 edx, WORD PTR [eax+esi+518]
  02140	0f bf 8c 30 04
	02 00 00	 movsx	 ecx, WORD PTR [eax+esi+516]
  02148	52		 push	 edx
  02149	0f bf 94 30 08
	02 00 00	 movsx	 edx, WORD PTR [eax+esi+520]
  02151	51		 push	 ecx
  02152	52		 push	 edx
  02153	8d 4c 30 77	 lea	 ecx, DWORD PTR [eax+esi+119]
  02157	51		 push	 ecx
  02158	8d 54 30 6c	 lea	 edx, DWORD PTR [eax+esi+108]
  0215c	52		 push	 edx
  0215d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@
  02162	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  02168	83 c4 18	 add	 esp, 24			; 00000018H
  0216b	5b		 pop	 ebx
  0216c	5f		 pop	 edi
  0216d	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0216e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02171	33 cd		 xor	 ecx, ebp
  02173	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02178	8b e5		 mov	 esp, ebp
  0217a	5d		 pop	 ebp
  0217b	c3		 ret	 0
$LN15@CGUseItemR:

; 16493: 				}				
; 16494: 			}
; 16495: 			else
; 16496: 			{
; 16497: 				char szTemp[256];
; 16498: 				wsprintf(szTemp, lMsg.Get(1252));

  0217c	68 e4 04 00 00	 push	 1252			; 000004e4H
  02181	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  02186	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0218b	50		 push	 eax
  0218c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$250275[ebp]
  02192	50		 push	 eax
  02193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16499: 				GCServerMsgStringSend(szTemp, aIndex, 1);

  02199	6a 01		 push	 1
  0219b	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$250275[ebp]
  021a1	57		 push	 edi
  021a2	51		 push	 ecx
  021a3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  021a8	83 c4 14	 add	 esp, 20			; 00000014H
  021ab	5b		 pop	 ebx
  021ac	5f		 pop	 edi
  021ad	5e		 pop	 esi

; 16547: 	}
; 16548: }

  021ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  021b1	33 cd		 xor	 ecx, ebp
  021b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  021b8	8b e5		 mov	 esp, ebp
  021ba	5d		 pop	 ebp
  021bb	c3		 ret	 0
$LN16@CGUseItemR:

; 16500: 			}			
; 16501: 		}
; 16502: 		else if ( citem->m_Type == ITEMGET(13,66) ) //season 4 add-on

  021bc	ba 42 1a 00 00	 mov	 edx, 6722		; 00001a42H
  021c1	66 3b c2	 cmp	 ax, dx
  021c4	0f 85 82 00 00
	00		 jne	 $LN10@CGUseItemR

; 16503: 		{
; 16504: 			if(gObj[aIndex].Level < 15)

  021ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  021cf	66 83 bc 30 be
	00 00 00 0f	 cmp	 WORD PTR [eax+esi+190], 15 ; 0000000fH
  021d8	7d 2c		 jge	 SHORT $LN9@CGUseItemR

; 16505: 			{
; 16506: 				GCServerMsgStringSend(lMsg.Get(2613), aIndex, 1);

  021da	6a 01		 push	 1
  021dc	57		 push	 edi
  021dd	68 35 0a 00 00	 push	 2613			; 00000a35H
  021e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  021e7	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  021ec	50		 push	 eax
  021ed	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 16534: 			GCInventoryItemDeleteSend(aIndex, pos, 1);	

  021f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  021f5	5b		 pop	 ebx
  021f6	5f		 pop	 edi
  021f7	5e		 pop	 esi

; 16547: 	}
; 16548: }

  021f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  021fb	33 cd		 xor	 ecx, ebp
  021fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02202	8b e5		 mov	 esp, ebp
  02204	5d		 pop	 ebp
  02205	c3		 ret	 0
$LN9@CGUseItemR:

; 16507: 			}
; 16508: 			else
; 16509: 			{
; 16510: 				gObjTeleport(aIndex, MAP_INDEX_SANTATOWN, 220, 20);

  02206	6a 14		 push	 20			; 00000014H
  02208	68 dc 00 00 00	 push	 220			; 000000dcH
  0220d	6a 3e		 push	 62			; 0000003eH
  0220f	57		 push	 edi
  02210	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 16511: 
; 16512: 				if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  02215	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0221b	6a 01		 push	 1
  0221d	03 ce		 add	 ecx, esi
  0221f	53		 push	 ebx
  02220	51		 push	 ecx
  02221	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  02226	83 c4 1c	 add	 esp, 28			; 0000001cH
  02229	85 c0		 test	 eax, eax
  0222b	0f 85 4e 09 00
	00		 jne	 $LN343@CGUseItemR

; 16513: 				{
; 16514: 					gObjInventoryItemSet(aIndex, pos, -1);

  02231	68 ff 00 00 00	 push	 255			; 000000ffH
  02236	53		 push	 ebx
  02237	57		 push	 edi
  02238	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16515: 					gObj[aIndex].pInventory[pos].Clear();

  0223d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02243	8b 8c 32 24 0e
	00 00		 mov	 ecx, DWORD PTR [edx+esi+3620]

; 16516: 					GCInventoryItemDeleteSend(aIndex, pos, 1);
; 16517: 				}
; 16518: 			}	

  0224a	eb 47		 jmp	 SHORT $LN378@CGUseItemR
$LN10@CGUseItemR:

; 16519: 		}
; 16520: 		else if ( citem->m_Type == ITEMGET(13,81) ) //season 4.5 add-on Amulet 1

  0224c	b9 51 1a 00 00	 mov	 ecx, 6737		; 00001a51H
  02251	66 3b c1	 cmp	 ax, cx
  02254	75 05		 jne	 SHORT $LN5@CGUseItemR

; 16521: 		{
; 16522: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex], citem->m_Type, -1);

  02256	6a ff		 push	 -1
  02258	51		 push	 ecx

; 16523: 
; 16524: 			gObjInventoryItemSet(aIndex, pos, -1);
; 16525: 			gObj[aIndex].pInventory[pos].Clear();
; 16526: 			GCInventoryItemDeleteSend(aIndex, pos, 1);	

  02259	eb 0d		 jmp	 SHORT $LN371@CGUseItemR
$LN5@CGUseItemR:

; 16527: 		}
; 16528: 		else if ( citem->m_Type == ITEMGET(13,82) ) //season 4.5 add-on Amulet 2

  0225b	b9 52 1a 00 00	 mov	 ecx, 6738		; 00001a52H
  02260	66 3b c1	 cmp	 ax, cx
  02263	75 59		 jne	 SHORT $LN3@CGUseItemR

; 16529: 		{
; 16530: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex], citem->m_Type, -1);

  02265	6a ff		 push	 -1
  02267	51		 push	 ecx
$LN371@CGUseItemR:
  02268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0226e	03 d6		 add	 edx, esi
  02270	52		 push	 edx
  02271	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  02276	e8 00 00 00 00	 call	 ?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CCashItemPeriodSystem::GDReqPeriodItemInsert

; 16531: 
; 16532: 			gObjInventoryItemSet(aIndex, pos, -1);

  0227b	68 ff 00 00 00	 push	 255			; 000000ffH
  02280	53		 push	 ebx
  02281	57		 push	 edi
  02282	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16533: 			gObj[aIndex].pInventory[pos].Clear();

  02287	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0228c	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
$LN378@CGUseItemR:
  02293	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  02299	83 c4 0c	 add	 esp, 12			; 0000000cH
  0229c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16534: 			GCInventoryItemDeleteSend(aIndex, pos, 1);	

  022a1	6a 01		 push	 1
  022a3	53		 push	 ebx
  022a4	57		 push	 edi
  022a5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  022aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  022ad	5b		 pop	 ebx
  022ae	5f		 pop	 edi
  022af	5e		 pop	 esi

; 16547: 	}
; 16548: }

  022b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  022b3	33 cd		 xor	 ecx, ebp
  022b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  022ba	8b e5		 mov	 esp, ebp
  022bc	5d		 pop	 ebp
  022bd	c3		 ret	 0
$LN3@CGUseItemR:

; 16535: 		}
; 16536: 		else
; 16537: 		{
; 16538: 			LogAdd("error-L3 : %s return %s %d %d %s", gObj[aIndex].Name, __FILE__,__LINE__, pos, "CItem::GetName()");

  022be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  022c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LIMFEILN@CItem?3?3GetName?$CI?$CJ?$AA@
  022c9	53		 push	 ebx
  022ca	68 9a 40 00 00	 push	 16538			; 0000409aH
  022cf	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  022d4	8d 54 31 77	 lea	 edx, DWORD PTR [ecx+esi+119]
  022d8	52		 push	 edx
  022d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@
  022de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  022e4	83 c4 18	 add	 esp, 24			; 00000018H
$LN132@CGUseItemR:

; 16539: 			GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  022e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  022ec	e9 d6 01 00 00	 jmp	 $LN367@CGUseItemR
$LN43@CGUseItemR:

; 16328: 		{
; 16329: 			int BuffEffectID = 0;
; 16330: 
; 16331: 			if(citem->m_Type == ITEMGET(14,85))

  022f1	ba 55 1c 00 00	 mov	 edx, 7253		; 00001c55H
  022f6	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _BuffEffectID$250220[ebp], 0
  02300	66 3b c2	 cmp	 ax, dx
  02303	75 0c		 jne	 SHORT $LN42@CGUseItemR

; 16332: 			{
; 16333: 				BuffEffectID = 78;

  02305	c7 85 f4 fe ff
	ff 4e 00 00 00	 mov	 DWORD PTR _BuffEffectID$250220[ebp], 78 ; 0000004eH
  0230f	eb 2a		 jmp	 SHORT $LN38@CGUseItemR
$LN42@CGUseItemR:

; 16334: 			}
; 16335: 			else if(citem->m_Type == ITEMGET(14,86))

  02311	b9 56 1c 00 00	 mov	 ecx, 7254		; 00001c56H
  02316	66 3b c1	 cmp	 ax, cx
  02319	75 0c		 jne	 SHORT $LN40@CGUseItemR

; 16336: 			{
; 16337: 				BuffEffectID = 79;

  0231b	c7 85 f4 fe ff
	ff 4f 00 00 00	 mov	 DWORD PTR _BuffEffectID$250220[ebp], 79 ; 0000004fH
  02325	eb 14		 jmp	 SHORT $LN38@CGUseItemR
$LN40@CGUseItemR:

; 16338: 			}
; 16339: 			else if(citem->m_Type == ITEMGET(14,87))

  02327	ba 57 1c 00 00	 mov	 edx, 7255		; 00001c57H
  0232c	66 3b c2	 cmp	 ax, dx
  0232f	75 0a		 jne	 SHORT $LN38@CGUseItemR

; 16340: 			{
; 16341: 				BuffEffectID = 80;

  02331	c7 85 f4 fe ff
	ff 50 00 00 00	 mov	 DWORD PTR _BuffEffectID$250220[ebp], 80 ; 00000050H
$LN38@CGUseItemR:

; 16342: 			}
; 16343: 
; 16344: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  0233b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02340	6a 01		 push	 1
  02342	03 c6		 add	 eax, esi
  02344	53		 push	 ebx
  02345	50		 push	 eax
  02346	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  0234b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0234e	85 c0		 test	 eax, eax
  02350	75 33		 jne	 SHORT $LN37@CGUseItemR

; 16345: 			{
; 16346: 				gObjInventoryItemSet(aIndex, pos, -1);

  02352	68 ff 00 00 00	 push	 255			; 000000ffH
  02357	53		 push	 ebx
  02358	57		 push	 edi
  02359	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16347: 				gObj[aIndex].pInventory[pos].Clear();

  0235e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02364	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  0236b	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  02371	83 c4 0c	 add	 esp, 12			; 0000000cH
  02374	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16348: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  02379	6a 01		 push	 1
  0237b	53		 push	 ebx
  0237c	57		 push	 edi
  0237d	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02382	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@CGUseItemR:

; 16349: 			}
; 16350: 
; 16351: 			gObjSetItemEffect(&gObj[aIndex], BuffEffectID);

  02385	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _BuffEffectID$250220[ebp]
  0238b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02390	52		 push	 edx
  02391	03 c6		 add	 eax, esi
  02393	50		 push	 eax
  02394	e8 00 00 00 00	 call	 ?gObjSetItemEffect@@YAEPAUOBJECTSTRUCT@@H@Z ; gObjSetItemEffect
  02399	83 c4 08	 add	 esp, 8
  0239c	5b		 pop	 ebx
  0239d	5f		 pop	 edi
  0239e	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0239f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  023a2	33 cd		 xor	 ecx, ebp
  023a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  023a9	8b e5		 mov	 esp, ebp
  023ab	5d		 pop	 ebp
  023ac	c3		 ret	 0
$LN54@CGUseItemR:

; 16304: 		{
; 16305: 			gObjUseFullRecoveryPotion(&gObj[aIndex], pos);

  023ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023b3	03 ce		 add	 ecx, esi
  023b5	53		 push	 ebx
  023b6	51		 push	 ecx
  023b7	e8 00 00 00 00	 call	 ?gObjUseFullRecoveryPotion@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseFullRecoveryPotion
  023bc	83 c4 08	 add	 esp, 8
  023bf	5b		 pop	 ebx
  023c0	5f		 pop	 edi
  023c1	5e		 pop	 esi

; 16547: 	}
; 16548: }

  023c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  023c5	33 cd		 xor	 ecx, ebp
  023c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  023cc	8b e5		 mov	 esp, ebp
  023ce	5d		 pop	 ebp
  023cf	c3		 ret	 0
$LN59@CGUseItemR:

; 16295: 		{
; 16296: 			gObjUseCashShopStatPotion(&gObj[aIndex], pos);

  023d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023d6	03 d6		 add	 edx, esi
  023d8	53		 push	 ebx
  023d9	52		 push	 edx
  023da	e8 00 00 00 00	 call	 ?gObjUseCashShopStatPotion@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseCashShopStatPotion
  023df	83 c4 08	 add	 esp, 8
  023e2	5b		 pop	 ebx
  023e3	5f		 pop	 edi
  023e4	5e		 pop	 esi

; 16547: 	}
; 16548: }

  023e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  023e8	33 cd		 xor	 ecx, ebp
  023ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  023ef	8b e5		 mov	 esp, ebp
  023f1	5d		 pop	 ebp
  023f2	c3		 ret	 0
$LN62@CGUseItemR:

; 16287: 		{
; 16288: 			gObjUseCashShopStatFruit(&gObj[aIndex], pos);

  023f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023f8	03 c6		 add	 eax, esi
  023fa	53		 push	 ebx
  023fb	50		 push	 eax
  023fc	e8 00 00 00 00	 call	 ?gObjUseCashShopStatFruit@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseCashShopStatFruit
  02401	83 c4 08	 add	 esp, 8
  02404	5b		 pop	 ebx
  02405	5f		 pop	 edi
  02406	5e		 pop	 esi

; 16547: 	}
; 16548: }

  02407	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0240a	33 cd		 xor	 ecx, ebp
  0240c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02411	8b e5		 mov	 esp, ebp
  02413	5d		 pop	 ebp
  02414	c3		 ret	 0
$LN128@CGUseItemR:

; 16076: 		{
; 16077: 			if ( (gObj[aIndex].Strength + gObj[aIndex].AddStrength) < citem->m_RequireStrength )

  02415	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0241b	0f bf 94 31 20
	01 00 00	 movsx	 edx, WORD PTR [ecx+esi+288]
  02423	03 ce		 add	 ecx, esi
  02425	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv4101[ebp], ecx
  0242b	0f b7 89 f4 00
	00 00		 movzx	 ecx, WORD PTR [ecx+244]
  02432	03 d1		 add	 edx, ecx
  02434	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  0243a	0f b7 49 4a	 movzx	 ecx, WORD PTR [ecx+74]
  0243e	3b d1		 cmp	 edx, ecx

; 16078: 			{
; 16079: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 16080: 				return;

  02440	7c 24		 jl	 SHORT $LN370@CGUseItemR

; 16081: 			}
; 16082: 			
; 16083: 			if ( (gObj[aIndex].Dexterity + gObj[aIndex].AddDexterity) < citem->m_RequireDexterity )

  02442	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv4101[ebp]
  02448	0f bf 91 22 01
	00 00		 movsx	 edx, WORD PTR [ecx+290]
  0244f	0f b7 89 f6 00
	00 00		 movzx	 ecx, WORD PTR [ecx+246]
  02456	03 d1		 add	 edx, ecx
  02458	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  0245e	0f b7 49 4c	 movzx	 ecx, WORD PTR [ecx+76]
  02462	3b d1		 cmp	 edx, ecx
  02464	7d 3a		 jge	 SHORT $LN125@CGUseItemR
$LN370@CGUseItemR:

; 16084: 			{
; 16085: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  02466	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv4101[ebp]
  0246c	8b 90 54 01 00
	00		 mov	 edx, DWORD PTR [eax+340]
  02472	d9 80 fc 00 00
	00		 fld	 DWORD PTR [eax+252]
  02478	52		 push	 edx
  02479	6a 01		 push	 1
  0247b	68 fd 00 00 00	 push	 253			; 000000fdH
  02480	e8 00 00 00 00	 call	 __ftol2_sse
  02485	50		 push	 eax
  02486	57		 push	 edi
  02487	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  0248c	83 c4 14	 add	 esp, 20			; 00000014H
  0248f	5b		 pop	 ebx
  02490	5f		 pop	 edi
  02491	5e		 pop	 esi

; 16547: 	}
; 16548: }

  02492	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02495	33 cd		 xor	 ecx, ebp
  02497	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0249c	8b e5		 mov	 esp, ebp
  0249e	5d		 pop	 ebp
  0249f	c3		 ret	 0
$LN125@CGUseItemR:

; 16086: 				return;
; 16087: 			}
; 16088: 
; 16089: 			if ( citem->m_Type == ITEMGET(15,18) )

  024a0	b9 12 1e 00 00	 mov	 ecx, 7698		; 00001e12H
  024a5	66 3b c1	 cmp	 ax, cx
  024a8	75 53		 jne	 SHORT $LN337@CGUseItemR

; 16090: 			{
; 16091: 				if ( g_QuestInfo.GetQuestState(&gObj[aIndex], 2) != 2 )

  024aa	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv4101[ebp]
  024b0	6a 02		 push	 2
  024b2	52		 push	 edx
  024b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  024b8	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  024bd	83 f8 02	 cmp	 eax, 2

; 16092: 				{
; 16093: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  024c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  024c5	74 3b		 je	 SHORT $LN123@CGUseItemR
$LN367@CGUseItemR:
  024c7	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  024ce	51		 push	 ecx
$LN369@CGUseItemR:
  024cf	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  024d6	6a 01		 push	 1
  024d8	68 fd 00 00 00	 push	 253			; 000000fdH
  024dd	e8 00 00 00 00	 call	 __ftol2_sse
  024e2	50		 push	 eax
  024e3	57		 push	 edi
  024e4	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  024e9	83 c4 14	 add	 esp, 20			; 00000014H
  024ec	5b		 pop	 ebx
  024ed	5f		 pop	 edi
  024ee	5e		 pop	 esi

; 16547: 	}
; 16548: }

  024ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  024f2	33 cd		 xor	 ecx, ebp
  024f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  024f9	8b e5		 mov	 esp, ebp
  024fb	5d		 pop	 ebp
  024fc	c3		 ret	 0
$LN337@CGUseItemR:

; 16094: 					return;

  024fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN123@CGUseItemR:

; 16095: 				}
; 16096: 			}
; 16097: 
; 16098: 			if (citem->m_Type >= ITEMGET(12,8) && citem->m_Type <= ITEMGET(12,24) )

  02502	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  02508	0f b7 4a 06	 movzx	 ecx, WORD PTR [edx+6]
  0250c	ba 08 18 00 00	 mov	 edx, 6152		; 00001808H
  02511	66 3b ca	 cmp	 cx, dx
  02514	7c 20		 jl	 SHORT $LN121@CGUseItemR
  02516	ba 18 18 00 00	 mov	 edx, 6168		; 00001818H
  0251b	66 3b ca	 cmp	 cx, dx
  0251e	7f 16		 jg	 SHORT $LN121@CGUseItemR

; 16099: 			{
; 16100: 				if ( gObj[aIndex].Level < citem->m_RequireLevel )

  02520	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  02526	0f bf 8c 30 be
	00 00 00	 movsx	 ecx, WORD PTR [eax+esi+190]
  0252e	0f b7 52 50	 movzx	 edx, WORD PTR [edx+80]
  02532	3b ca		 cmp	 ecx, edx

; 16101: 				{
; 16102: 					GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 16103: 					return;

  02534	7c 91		 jl	 SHORT $LN367@CGUseItemR
$LN121@CGUseItemR:

; 16104: 				}
; 16105: 			}
; 16106: 
; 16107: 			int skillnumber;
; 16108: 
; 16109: 			if ( citem->IsClass(gObj[aIndex].Class, gObj[aIndex].ChangeUP, gObj[aIndex].ChangeUP3rd) == FALSE )

  02536	0f b6 94 30 bc
	00 00 00	 movzx	 edx, BYTE PTR [eax+esi+188]
  0253e	0f b6 8c 30 bb
	00 00 00	 movzx	 ecx, BYTE PTR [eax+esi+187]
  02546	52		 push	 edx
  02547	0f b6 94 30 b8
	00 00 00	 movzx	 edx, BYTE PTR [eax+esi+184]
  0254f	51		 push	 ecx
  02550	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  02556	52		 push	 edx
  02557	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDHH@Z ; CItem::IsClass
  0255c	85 c0		 test	 eax, eax

; 16110: 			{	
; 16111: 				GCInventoryItemDeleteSend(aIndex, -1, 1);
; 16112: 			}
; 16113: 			else

  0255e	0f 84 b3 00 00
	00		 je	 $LN118@CGUseItemR

; 16114: 			{
; 16115: 				int addskill = gObjMagicAdd(&gObj[aIndex], citem->m_Type>>(9), citem->m_Type %  MAX_SUBTYPE_ITEMS, citem->m_Level, skillnumber);

  02564	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$[ebp]
  0256a	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0256e	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  02572	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _skillnumber$250135[ebp]
  02578	52		 push	 edx
  02579	0f bf d0	 movsx	 edx, ax
  0257c	81 e2 ff 01 00
	80		 and	 edx, -2147483137	; 800001ffH
  02582	51		 push	 ecx
  02583	79 08		 jns	 SHORT $LN362@CGUseItemR
  02585	4a		 dec	 edx
  02586	81 ca 00 fe ff
	ff		 or	 edx, -512		; fffffe00H
  0258c	42		 inc	 edx
$LN362@CGUseItemR:
  0258d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02593	66 c1 f8 09	 sar	 ax, 9
  02597	0f b6 c0	 movzx	 eax, al
  0259a	52		 push	 edx
  0259b	50		 push	 eax
  0259c	03 ce		 add	 ecx, esi
  0259e	51		 push	 ecx
  0259f	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAH@Z ; gObjMagicAdd
  025a4	83 c4 14	 add	 esp, 20			; 00000014H
  025a7	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _addskill$250138[ebp], eax

; 16116: 
; 16117: 				if ( addskill >= 0 )

  025ad	85 c0		 test	 eax, eax
  025af	78 66		 js	 SHORT $LN118@CGUseItemR

; 16118: 				{
; 16119: 					gObjInventoryItemSet(aIndex, pos, -1);

  025b1	68 ff 00 00 00	 push	 255			; 000000ffH
  025b6	53		 push	 ebx
  025b7	57		 push	 edi
  025b8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 16120: 					GCMagicListOneSend(aIndex, addskill, skillnumber, citem->m_Level, 0, 0);

  025bd	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  025c3	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  025c7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _skillnumber$250135[ebp]
  025cd	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _addskill$250138[ebp]
  025d3	6a 00		 push	 0
  025d5	6a 00		 push	 0
  025d7	50		 push	 eax
  025d8	51		 push	 ecx
  025d9	52		 push	 edx
  025da	57		 push	 edi
  025db	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDGEGE@Z ; GCMagicListOneSend

; 16121: 					gObj[aIndex].pInventory[pos].Clear();

  025e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025e5	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  025ec	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  025f2	83 c4 24	 add	 esp, 36			; 00000024H
  025f5	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 16122: 					GCInventoryItemDeleteSend(aIndex, pos, 1);

  025fa	6a 01		 push	 1
  025fc	53		 push	 ebx
  025fd	57		 push	 edi
  025fe	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02603	83 c4 0c	 add	 esp, 12			; 0000000cH
  02606	5b		 pop	 ebx
  02607	5f		 pop	 edi
  02608	5e		 pop	 esi

; 16547: 	}
; 16548: }

  02609	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0260c	33 cd		 xor	 ecx, ebp
  0260e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02613	8b e5		 mov	 esp, ebp
  02615	5d		 pop	 ebp
  02616	c3		 ret	 0
$LN118@CGUseItemR:

; 16123: 				}
; 16124: 				else
; 16125: 				{
; 16126: 					GCInventoryItemDeleteSend(aIndex, -1, 1);

  02617	6a 01		 push	 1
  02619	68 ff 00 00 00	 push	 255			; 000000ffH
  0261e	57		 push	 edi
  0261f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02624	83 c4 0c	 add	 esp, 12			; 0000000cH
  02627	5b		 pop	 ebx
  02628	5f		 pop	 edi
  02629	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0262a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0262d	33 cd		 xor	 ecx, ebp
  0262f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02634	8b e5		 mov	 esp, ebp
  02636	5d		 pop	 ebp
  02637	c3		 ret	 0
$LN164@CGUseItemR:

; 15939: 		{
; 15940: 			switch(citem->m_Type)

  02638	98		 cwde
  02639	2d 3f 1c 00 00	 sub	 eax, 7231		; 00001c3fH
  0263e	74 4a		 je	 SHORT $LN161@CGUseItemR
  02640	48		 dec	 eax
  02641	0f 85 87 00 00
	00		 jne	 $LN162@CGUseItemR

; 15946: 				}
; 15947: 				break;
; 15948: 			case ITEMGET(14,64):
; 15949: 				{
; 15950: 					gObj[aIndex].Mana = gObj[aIndex].MaxMana + gObj[aIndex].AddMana;

  02647	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0264c	db 84 30 50 01
	00 00		 fild	 DWORD PTR [eax+esi+336]
  02653	d8 84 30 14 01
	00 00		 fadd	 DWORD PTR [eax+esi+276]
  0265a	d9 9c 30 10 01
	00 00		 fstp	 DWORD PTR [eax+esi+272]

; 15951: 					GCManaSend(aIndex,gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  02661	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02666	8b 8c 30 28 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+296]
  0266d	d9 84 30 10 01
	00 00		 fld	 DWORD PTR [eax+esi+272]
  02674	51		 push	 ecx
  02675	6a 00		 push	 0
  02677	68 ff 00 00 00	 push	 255			; 000000ffH
  0267c	e8 00 00 00 00	 call	 __ftol2_sse
  02681	50		 push	 eax
  02682	57		 push	 edi
  02683	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 15952: 				}
; 15953: 				break;

  02688	eb 41		 jmp	 SHORT $LN365@CGUseItemR
$LN161@CGUseItemR:

; 15941: 			{
; 15942: 			case ITEMGET(14,63):
; 15943: 				{
; 15944: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  0268a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0268f	db 84 30 4c 01
	00 00		 fild	 DWORD PTR [eax+esi+332]
  02696	d8 84 30 00 01
	00 00		 fadd	 DWORD PTR [eax+esi+256]
  0269d	d9 9c 30 fc 00
	00 00		 fstp	 DWORD PTR [eax+esi+252]

; 15945: 					GCReFillSend(aIndex,gObj[aIndex].Life, -1, 0,gObj[aIndex].iShield);

  026a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026a9	8b 94 30 54 01
	00 00		 mov	 edx, DWORD PTR [eax+esi+340]
  026b0	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  026b7	52		 push	 edx
  026b8	6a 00		 push	 0
  026ba	68 ff 00 00 00	 push	 255			; 000000ffH
  026bf	e8 00 00 00 00	 call	 __ftol2_sse
  026c4	50		 push	 eax
  026c5	57		 push	 edi
  026c6	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
$LN365@CGUseItemR:
  026cb	83 c4 14	 add	 esp, 20			; 00000014H
$LN162@CGUseItemR:

; 15954: 			}
; 15955: 
; 15956: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  026ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026d3	6a 01		 push	 1
  026d5	03 c6		 add	 eax, esi
  026d7	53		 push	 ebx
  026d8	50		 push	 eax
  026d9	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  026de	83 c4 0c	 add	 esp, 12			; 0000000cH
  026e1	85 c0		 test	 eax, eax
  026e3	0f 85 96 04 00
	00		 jne	 $LN343@CGUseItemR

; 15957: 			{
; 15958: 				gObjInventoryItemSet(aIndex, pos, -1);

  026e9	68 ff 00 00 00	 push	 255			; 000000ffH
  026ee	53		 push	 ebx
  026ef	57		 push	 edi
  026f0	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15959: 				gObj[aIndex].pInventory[pos].Clear();

  026f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026fb	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  02702	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  02708	83 c4 0c	 add	 esp, 12			; 0000000cH
  0270b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15960: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  02710	6a 01		 push	 1
  02712	53		 push	 ebx
  02713	57		 push	 edi
  02714	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02719	83 c4 0c	 add	 esp, 12			; 0000000cH
  0271c	5b		 pop	 ebx
  0271d	5f		 pop	 edi
  0271e	5e		 pop	 esi

; 16547: 	}
; 16548: }

  0271f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02722	33 cd		 xor	 ecx, ebp
  02724	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02729	8b e5		 mov	 esp, ebp
  0272b	5d		 pop	 ebp
  0272c	c3		 ret	 0
$LN238@CGUseItemR:

; 15567: 		{
; 15568: 			int tMana = (citem->m_Value*10) - (gObj[aIndex].Level);

  0272d	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  02730	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02736	0f bf 94 32 be
	00 00 00	 movsx	 edx, WORD PTR [edx+esi+190]
  0273e	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  02741	03 c9		 add	 ecx, ecx
  02743	2b ca		 sub	 ecx, edx
  02745	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _tMana$249983[ebp], ecx

; 15569: 
; 15570: 			if ( tMana < 0 )

  0274b	79 0a		 jns	 SHORT $LN237@CGUseItemR

; 15571: 			{
; 15572: 				tMana=0;

  0274d	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tMana$249983[ebp], 0
$LN237@CGUseItemR:

; 15573: 			}
; 15574: 
; 15575: 			switch ( citem->m_Type )

  02757	98		 cwde
  02758	2d 04 1c 00 00	 sub	 eax, 7172		; 00001c04H
  0275d	74 63		 je	 SHORT $LN234@CGUseItemR
  0275f	48		 dec	 eax
  02760	74 26		 je	 SHORT $LN233@CGUseItemR
  02762	48		 dec	 eax
  02763	0f 85 8f 00 00
	00		 jne	 $LN341@CGUseItemR

; 15583: 				case ITEMGET(14,6):
; 15584: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*40/100; 

  02769	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0276e	db 84 30 50 01
	00 00		 fild	 DWORD PTR [eax+esi+336]
  02775	d8 84 30 14 01
	00 00		 fadd	 DWORD PTR [eax+esi+276]
  0277c	e8 00 00 00 00	 call	 __ftol2_sse
  02781	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  02784	03 c9		 add	 ecx, ecx

; 15585: 					break;

  02786	eb 55		 jmp	 SHORT $LN366@CGUseItemR
$LN233@CGUseItemR:

; 15579: 					break;
; 15580: 				case ITEMGET(14,5):
; 15581: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*30/100; 

  02788	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0278d	db 84 30 50 01
	00 00		 fild	 DWORD PTR [eax+esi+336]
  02794	d8 84 30 14 01
	00 00		 fadd	 DWORD PTR [eax+esi+276]
  0279b	e8 00 00 00 00	 call	 __ftol2_sse
  027a0	8b c8		 mov	 ecx, eax
  027a2	c1 e1 04	 shl	 ecx, 4
  027a5	2b c8		 sub	 ecx, eax
  027a7	03 c9		 add	 ecx, ecx
  027a9	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  027ae	f7 e9		 imul	 ecx
  027b0	c1 fa 05	 sar	 edx, 5
  027b3	8b ca		 mov	 ecx, edx
  027b5	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  027b8	03 ca		 add	 ecx, edx
  027ba	01 8d f8 fe ff
	ff		 add	 DWORD PTR _tMana$249983[ebp], ecx

; 15582: 					break;

  027c0	eb 36		 jmp	 SHORT $LN341@CGUseItemR
$LN234@CGUseItemR:

; 15576: 			{
; 15577: 				case ITEMGET(14,4):
; 15578: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*20/100; 

  027c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  027c7	db 84 30 50 01
	00 00		 fild	 DWORD PTR [eax+esi+336]
  027ce	d8 84 30 14 01
	00 00		 fadd	 DWORD PTR [eax+esi+276]
  027d5	e8 00 00 00 00	 call	 __ftol2_sse
  027da	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
$LN366@CGUseItemR:
  027dd	03 c9		 add	 ecx, ecx
  027df	03 c9		 add	 ecx, ecx
  027e1	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  027e6	f7 e9		 imul	 ecx
  027e8	c1 fa 05	 sar	 edx, 5
  027eb	8b c2		 mov	 eax, edx
  027ed	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  027f0	03 c2		 add	 eax, edx
  027f2	01 85 f8 fe ff
	ff		 add	 DWORD PTR _tMana$249983[ebp], eax
$LN341@CGUseItemR:

; 15586: 			}
; 15587: 
; 15588: 			gObj[aIndex].Mana += tMana;

  027f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  027fe	db 85 f8 fe ff
	ff		 fild	 DWORD PTR _tMana$249983[ebp]
  02804	8d 84 31 10 01
	00 00		 lea	 eax, DWORD PTR [ecx+esi+272]
  0280b	d8 00		 fadd	 DWORD PTR [eax]
  0280d	d9 18		 fstp	 DWORD PTR [eax]

; 15589: 
; 15590: 			if ( gObj[aIndex].Mana > (gObj[aIndex].MaxMana+gObj[aIndex].AddMana-1.0f) )

  0280f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02815	db 84 31 50 01
	00 00		 fild	 DWORD PTR [ecx+esi+336]
  0281c	8d 94 31 10 01
	00 00		 lea	 edx, DWORD PTR [ecx+esi+272]
  02823	d8 84 31 14 01
	00 00		 fadd	 DWORD PTR [ecx+esi+276]
  0282a	d9 02		 fld	 DWORD PTR [edx]
  0282c	d9 c1		 fld	 ST(1)
  0282e	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  02834	de d9		 fcompp
  02836	df e0		 fnstsw	 ax
  02838	f6 c4 05	 test	 ah, 5
  0283b	7a 0a		 jp	 SHORT $LN354@CGUseItemR

; 15591: 			{
; 15592: 				gObj[aIndex].Mana = gObj[aIndex].MaxMana+gObj[aIndex].AddMana;

  0283d	d9 1a		 fstp	 DWORD PTR [edx]
  0283f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02845	eb 02		 jmp	 SHORT $LN231@CGUseItemR
$LN354@CGUseItemR:
  02847	dd d8		 fstp	 ST(0)
$LN231@CGUseItemR:

; 15593: 			}
; 15594: 			
; 15595: 			GCManaSend(aIndex, gObj[aIndex].Mana, 0xFF, 0, gObj[aIndex].BP);

  02849	8b 94 31 28 01
	00 00		 mov	 edx, DWORD PTR [ecx+esi+296]
  02850	d9 84 31 10 01
	00 00		 fld	 DWORD PTR [ecx+esi+272]
  02857	52		 push	 edx
  02858	6a 00		 push	 0
  0285a	68 ff 00 00 00	 push	 255			; 000000ffH
  0285f	e8 00 00 00 00	 call	 __ftol2_sse
  02864	50		 push	 eax
  02865	57		 push	 edi
  02866	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHHEEH@Z	; GCManaSend

; 15596: 
; 15597: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  0286b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02870	6a 01		 push	 1
  02872	03 c6		 add	 eax, esi
  02874	53		 push	 ebx
  02875	50		 push	 eax
  02876	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  0287b	83 c4 20	 add	 esp, 32			; 00000020H
  0287e	85 c0		 test	 eax, eax
  02880	0f 85 f9 02 00
	00		 jne	 $LN343@CGUseItemR

; 15598: 			{
; 15599: 				gObjInventoryItemSet(aIndex, pos, -1);

  02886	68 ff 00 00 00	 push	 255			; 000000ffH
  0288b	53		 push	 ebx
  0288c	57		 push	 edi
  0288d	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15600: 				gObj[aIndex].pInventory[pos].Clear();

  02892	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02898	8b 8c 31 24 0e
	00 00		 mov	 ecx, DWORD PTR [ecx+esi+3620]
  0289f	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  028a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  028a8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15601: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  028ad	6a 01		 push	 1
  028af	53		 push	 ebx
  028b0	57		 push	 edi
  028b1	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  028b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  028b9	5b		 pop	 ebx
  028ba	5f		 pop	 edi
  028bb	5e		 pop	 esi

; 16547: 	}
; 16548: }

  028bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  028bf	33 cd		 xor	 ecx, ebp
  028c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  028c6	8b e5		 mov	 esp, ebp
  028c8	5d		 pop	 ebp
  028c9	c3		 ret	 0
$LN258@CGUseItemR:

; 15486: 		{
; 15487: 			int tLife = (citem->m_Value*10) - (gObj[aIndex].Level*2);

  028ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028d0	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  028d3	0f bf 94 32 be
	00 00 00	 movsx	 edx, WORD PTR [edx+esi+190]
  028db	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  028de	2b ca		 sub	 ecx, edx
  028e0	03 c9		 add	 ecx, ecx
  028e2	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _tLife$249956[ebp], ecx

; 15488: 
; 15489: 			if ( tLife <  0 )

  028e8	79 0a		 jns	 SHORT $LN334@CGUseItemR

; 15490: 			{
; 15491: 				tLife = 0;

  028ea	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tLife$249956[ebp], 0
$LN334@CGUseItemR:

; 15492: 			}
; 15493: 
; 15494: 			int nAddRate=0;
; 15495: 
; 15496: 			switch ( citem->m_Type )

  028f4	98		 cwde
  028f5	05 00 e4 ff ff	 add	 eax, -7168		; ffffe400H
  028fa	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _nAddRate$249958[ebp], 0
  02904	83 f8 03	 cmp	 eax, 3
  02907	77 35		 ja	 SHORT $LN255@CGUseItemR
  02909	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN387@CGUseItemR[eax*4]
$LN254@CGUseItemR:

; 15497: 			{
; 15498: 				case ITEMGET(14,0):
; 15499: 					nAddRate = 10;

  02910	c7 85 f8 fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR _nAddRate$249958[ebp], 10 ; 0000000aH

; 15500: 					break;

  0291a	eb 22		 jmp	 SHORT $LN255@CGUseItemR
$LN253@CGUseItemR:

; 15501: 				case ITEMGET(14,1): 
; 15502: 					nAddRate = 20;

  0291c	c7 85 f8 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _nAddRate$249958[ebp], 20 ; 00000014H

; 15503: 					break;

  02926	eb 16		 jmp	 SHORT $LN255@CGUseItemR
$LN252@CGUseItemR:

; 15504: 				case ITEMGET(14,2):
; 15505: 					nAddRate = 30;

  02928	c7 85 f8 fe ff
	ff 1e 00 00 00	 mov	 DWORD PTR _nAddRate$249958[ebp], 30 ; 0000001eH

; 15506: 					break;

  02932	eb 0a		 jmp	 SHORT $LN255@CGUseItemR
$LN251@CGUseItemR:

; 15507: 				case ITEMGET(14,3): 
; 15508: 					nAddRate = 40;

  02934	c7 85 f8 fe ff
	ff 28 00 00 00	 mov	 DWORD PTR _nAddRate$249958[ebp], 40 ; 00000028H
$LN255@CGUseItemR:

; 15509: 					break;
; 15510: 			}
; 15511: 
; 15512: 			if ( citem->m_Level == 1 )

  0293e	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _citem$[ebp]
  02944	66 83 78 08 01	 cmp	 WORD PTR [eax+8], 1
  02949	75 07		 jne	 SHORT $LN250@CGUseItemR

; 15513: 			{
; 15514: 				nAddRate += 5;

  0294b	83 85 f8 fe ff
	ff 05		 add	 DWORD PTR _nAddRate$249958[ebp], 5
$LN250@CGUseItemR:

; 15515: 			}
; 15516: 
; 15517: 			tLife += ((int)gObj[aIndex].MaxLife * nAddRate) / 100;

  02952	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02958	d9 84 31 00 01
	00 00		 fld	 DWORD PTR [ecx+esi+256]
  0295f	e8 00 00 00 00	 call	 __ftol2_sse
  02964	8b c8		 mov	 ecx, eax
  02966	0f af 8d f8 fe
	ff ff		 imul	 ecx, DWORD PTR _nAddRate$249958[ebp]
  0296d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  02972	f7 e9		 imul	 ecx
  02974	c1 fa 05	 sar	 edx, 5
  02977	8b c2		 mov	 eax, edx
  02979	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0297c	03 c2		 add	 eax, edx
  0297e	01 85 f4 fe ff
	ff		 add	 DWORD PTR _tLife$249956[ebp], eax

; 15518: 
; 15519: 			if ( citem->m_Type == ITEMGET(14,0) )
; 15520: 			{
; 15521: 				if ( citem->m_Level < 2 )

  02984	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  0298a	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  0298f	66 39 8d ec fe
	ff ff		 cmp	 WORD PTR tv4751[ebp], cx
  02996	75 2a		 jne	 SHORT $LN248@CGUseItemR
  02998	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  0299c	66 83 f8 02	 cmp	 ax, 2
  029a0	7d 20		 jge	 SHORT $LN248@CGUseItemR

; 15522: 				{
; 15523: 					gObj[aIndex].FillLife += tLife;

  029a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029a7	db 85 f4 fe ff
	ff		 fild	 DWORD PTR _tLife$249956[ebp]
  029ad	8d 84 30 08 01
	00 00		 lea	 eax, DWORD PTR [eax+esi+264]

; 15524: 					tLife = 0;

  029b4	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tLife$249956[ebp], 0
  029be	d8 00		 fadd	 DWORD PTR [eax]
  029c0	d9 18		 fstp	 DWORD PTR [eax]
$LN248@CGUseItemR:

; 15525: 				}
; 15526: 			}
; 15527: 
; 15528: 			if ( gObj[aIndex].FillLife > 0.0f )

  029c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029c8	d9 ee		 fldz
  029ca	d8 94 31 08 01
	00 00		 fcom	 DWORD PTR [ecx+esi+264]
  029d1	8d 8c 31 08 01
	00 00		 lea	 ecx, DWORD PTR [ecx+esi+264]
  029d8	df e0		 fnstsw	 ax
  029da	f6 c4 05	 test	 ah, 5
  029dd	0f 8a 8c 00 00
	00		 jp	 $LN357@CGUseItemR

; 15529: 			{
; 15530: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  029e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029e9	d9 01		 fld	 DWORD PTR [ecx]
  029eb	d8 84 32 fc 00
	00 00		 fadd	 DWORD PTR [edx+esi+252]
  029f2	8d 84 32 fc 00
	00 00		 lea	 eax, DWORD PTR [edx+esi+252]
  029f9	d9 18		 fstp	 DWORD PTR [eax]

; 15531: 
; 15532: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife +gObj[aIndex].AddLife) )

  029fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a00	db 84 30 4c 01
	00 00		 fild	 DWORD PTR [eax+esi+332]
  02a07	8d 8c 30 fc 00
	00 00		 lea	 ecx, DWORD PTR [eax+esi+252]
  02a0e	d8 84 30 00 01
	00 00		 fadd	 DWORD PTR [eax+esi+256]
  02a15	d9 01		 fld	 DWORD PTR [ecx]
  02a17	d8 d9		 fcomp	 ST(1)
  02a19	df e0		 fnstsw	 ax
  02a1b	f6 c4 41	 test	 ah, 65			; 00000041H
  02a1e	75 10		 jne	 SHORT $LN360@CGUseItemR

; 15533: 				{
; 15534: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  02a20	d9 19		 fstp	 DWORD PTR [ecx]

; 15535: 					gObj[aIndex].FillLife = 0;

  02a22	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a27	d9 9c 30 08 01
	00 00		 fstp	 DWORD PTR [eax+esi+264]
  02a2e	eb 04		 jmp	 SHORT $LN246@CGUseItemR
$LN360@CGUseItemR:
  02a30	dd d8		 fstp	 ST(0)
  02a32	dd d8		 fstp	 ST(0)
$LN246@CGUseItemR:

; 15536: 				}
; 15537: 
; 15538: 				GCReFillSend(gObj[aIndex].m_Index, gObj[aIndex].Life, 0xFF, FALSE, gObj[aIndex].iShield);

  02a34	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a39	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  02a40	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  02a47	51		 push	 ecx
  02a48	6a 00		 push	 0
  02a4a	68 ff 00 00 00	 push	 255			; 000000ffH
  02a4f	e8 00 00 00 00	 call	 __ftol2_sse
  02a54	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a5a	50		 push	 eax
  02a5b	8b 04 32	 mov	 eax, DWORD PTR [edx+esi]
  02a5e	50		 push	 eax
  02a5f	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend
  02a64	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _citem$[ebp]
  02a6a	83 c4 14	 add	 esp, 20			; 00000014H
  02a6d	eb 02		 jmp	 SHORT $LN247@CGUseItemR
$LN357@CGUseItemR:
  02a6f	dd d8		 fstp	 ST(0)
$LN247@CGUseItemR:

; 15539: 			}
; 15540: 
; 15541: 			gObj[aIndex].FillLifeMax = (float)tLife;

  02a71	db 85 f4 fe ff
	ff		 fild	 DWORD PTR _tLife$249956[ebp]
  02a77	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a7d	d9 9d ec fe ff
	ff		 fstp	 DWORD PTR tv4666[ebp]
  02a83	d9 85 ec fe ff
	ff		 fld	 DWORD PTR tv4666[ebp]
  02a89	d9 94 31 0c 01
	00 00		 fst	 DWORD PTR [ecx+esi+268]

; 15542: 			gObj[aIndex].FillLife = (float)tLife;

  02a90	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15543: 
; 15544: 			if ( citem->m_Type == ITEMGET(14,0) && citem->m_Level < 2 )

  02a95	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  02a9a	d9 9c 30 08 01
	00 00		 fstp	 DWORD PTR [eax+esi+264]
  02aa1	66 39 4a 06	 cmp	 WORD PTR [edx+6], cx
  02aa5	75 17		 jne	 SHORT $LN245@CGUseItemR
  02aa7	66 83 7a 08 02	 cmp	 WORD PTR [edx+8], 2
  02aac	7d 10		 jge	 SHORT $LN245@CGUseItemR

; 15545: 			{
; 15546: 				gObj[aIndex].FillLifeCount = 0;

  02aae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ab4	c6 84 32 1f 01
	00 00 00	 mov	 BYTE PTR [edx+esi+287], 0
  02abc	eb 17		 jmp	 SHORT $LN243@CGUseItemR
$LN245@CGUseItemR:

; 15547: 			}
; 15548: 			else if ( citem->m_Level == 1 )

  02abe	66 83 7a 08 01	 cmp	 WORD PTR [edx+8], 1
  02ac3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02ac9	0f 95 c0	 setne	 al
  02acc	04 02		 add	 al, 2
  02ace	88 84 31 1f 01
	00 00		 mov	 BYTE PTR [ecx+esi+287], al
$LN243@CGUseItemR:

; 15549: 			{
; 15550: 				gObj[aIndex].FillLifeCount = 2;
; 15551: 			}
; 15552: 			else
; 15553: 			{
; 15554: 				gObj[aIndex].FillLifeCount = 3;
; 15555: 			}
; 15556: 
; 15557: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  02ad5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02adb	6a 01		 push	 1
  02add	03 d6		 add	 edx, esi
  02adf	53		 push	 ebx
  02ae0	52		 push	 edx
  02ae1	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  02ae6	83 c4 0c	 add	 esp, 12			; 0000000cH
  02ae9	85 c0		 test	 eax, eax
  02aeb	0f 85 8e 00 00
	00		 jne	 $LN343@CGUseItemR

; 15558: 			{
; 15559: 				gObjInventoryItemSet(aIndex, pos, -1);

  02af1	68 ff 00 00 00	 push	 255			; 000000ffH
  02af6	53		 push	 ebx
  02af7	57		 push	 edi
  02af8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 15560: 				gObj[aIndex].pInventory[pos].Clear();

  02afd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b02	8b 8c 30 24 0e
	00 00		 mov	 ecx, DWORD PTR [eax+esi+3620]
  02b09	03 8d f0 fe ff
	ff		 add	 ecx, DWORD PTR tv4138[ebp]
  02b0f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b12	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 15561: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  02b17	6a 01		 push	 1
  02b19	53		 push	 ebx
  02b1a	57		 push	 edi
  02b1b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02b20	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b23	5b		 pop	 ebx
  02b24	5f		 pop	 edi
  02b25	5e		 pop	 esi

; 16547: 	}
; 16548: }

  02b26	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02b29	33 cd		 xor	 ecx, ebp
  02b2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02b30	8b e5		 mov	 esp, ebp
  02b32	5d		 pop	 ebp
  02b33	c3		 ret	 0
$LN263@CGUseItemR:

; 16540: 		}
; 16541: 	}
; 16542: 	else
; 16543: 	{
; 16544: 		GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  02b34	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b39	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  02b40	d9 84 30 fc 00
	00 00		 fld	 DWORD PTR [eax+esi+252]
  02b47	51		 push	 ecx
  02b48	6a 01		 push	 1
  02b4a	68 fd 00 00 00	 push	 253			; 000000fdH
  02b4f	e8 00 00 00 00	 call	 __ftol2_sse
  02b54	50		 push	 eax
  02b55	57		 push	 edi
  02b56	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHHEEH@Z ; GCReFillSend

; 16545: 		LogAdd("error-L3 : %s return %s %d %d",	
; 16546: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);

  02b5b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02b61	53		 push	 ebx
  02b62	68 a2 40 00 00	 push	 16546			; 000040a2H
  02b67	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  02b6c	8d 44 32 77	 lea	 eax, DWORD PTR [edx+esi+119]
  02b70	50		 push	 eax
  02b71	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@
$LN363@CGUseItemR:
  02b76	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  02b7c	83 c4 28	 add	 esp, 40			; 00000028H
$LN343@CGUseItemR:

; 16547: 	}
; 16548: }

  02b7f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02b82	5b		 pop	 ebx
  02b83	5f		 pop	 edi
  02b84	33 cd		 xor	 ecx, ebp
  02b86	5e		 pop	 esi
  02b87	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02b8c	8b e5		 mov	 esp, ebp
  02b8e	5d		 pop	 ebp
  02b8f	c3		 ret	 0
$LN387@CGUseItemR:
  02b90	00 00 00 00	 DD	 $LN254@CGUseItemR
  02b94	00 00 00 00	 DD	 $LN253@CGUseItemR
  02b98	00 00 00 00	 DD	 $LN252@CGUseItemR
  02b9c	00 00 00 00	 DD	 $LN251@CGUseItemR
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ENDP		; CGUseItemRecv
_TEXT	ENDS
PUBLIC	?CGCloseWindow@@YAXH@Z				; CGCloseWindow
EXTRN	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A:BYTE	; gQeustNpcTeleport
; Function compile flags: /Ogtp
;	COMDAT ?CGCloseWindow@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGCloseWindow@@YAXH@Z PROC				; CGCloseWindow, COMDAT

; 17399: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17400: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	8b f7		 mov	 esi, edi
  0000f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00015	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  0001c	f6 c1 03	 test	 cl, 3
  0001f	0f 84 89 01 00
	00		 je	 $LN1@CGCloseWin
  00025	c1 e9 06	 shr	 ecx, 6
  00028	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0002e	0f 84 7a 01 00
	00		 je	 $LN1@CGCloseWin

; 17401: 	{
; 17402: 		if ( gObj[aIndex].m_IfState.type == 7 )

  00034	83 f9 07	 cmp	 ecx, 7
  00037	0f 84 71 01 00
	00		 je	 $LN1@CGCloseWin

; 17403: 		{
; 17404: 			return;
; 17405: 		}
; 17406: 
; 17407: 		if ( gObj[aIndex].m_IfState.type == 10 && gObj[aIndex].TargetShopNumber == 229 )

  0003d	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00040	75 2e		 jne	 SHORT $LN9@CGCloseWin
  00042	b9 e5 00 00 00	 mov	 ecx, 229		; 000000e5H
  00047	66 39 8c 06 5a
	04 00 00	 cmp	 WORD PTR [esi+eax+1114], cx
  0004f	75 1f		 jne	 SHORT $LN9@CGCloseWin

; 17408: 		{
; 17409: 			gQeustNpcTeleport.TalkRefDel();

  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  00056	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel

; 17410: 			gObj[aIndex].TargetShopNumber = -1;

  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	83 ca ff	 or	 edx, -1
  00063	66 89 94 06 5a
	04 00 00	 mov	 WORD PTR [esi+eax+1114], dx
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN9@CGCloseWin:

; 17411: 		}
; 17412: 
; 17413: 
; 17414: 		if( gObj[aIndex].TargetShopNumber == 568 )	//1.01.00

  00070	b9 38 02 00 00	 mov	 ecx, 568		; 00000238H
  00075	66 39 8c 06 5a
	04 00 00	 cmp	 WORD PTR [esi+eax+1114], cx
  0007d	75 1f		 jne	 SHORT $LN8@CGCloseWin

; 17415: 		{
; 17416: 			gQeustNpcTeleport.TalkRefDel();

  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  00084	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel

; 17417: 			gObj[aIndex].TargetShopNumber = -1;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	83 ca ff	 or	 edx, -1
  00091	66 89 94 06 5a
	04 00 00	 mov	 WORD PTR [esi+eax+1114], dx
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN8@CGCloseWin:

; 17418: 		}
; 17419: 
; 17420: 		if ( gObj[aIndex].m_IfState.type == 3 )

  0009e	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  000a5	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000ab	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  000b1	75 2c		 jne	 SHORT $LN14@CGCloseWin

; 17421: 		{
; 17422: #if(DONATE_SHOP==TRUE)
; 17423: 			if( gObj[aIndex].TargetShopNumber < DONAT_SHOP_START && DONAT_SHOP_END > gObj[aIndex].TargetShopNumber )

  000b3	0f b7 94 06 5a
	04 00 00	 movzx	 edx, WORD PTR [esi+eax+1114]
  000bb	8d 8c 06 5a 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1114]
  000c2	66 83 fa 14	 cmp	 dx, 20			; 00000014H
  000c6	7d 17		 jge	 SHORT $LN14@CGCloseWin
  000c8	53		 push	 ebx
  000c9	bb 2d 00 00 00	 mov	 ebx, 45			; 0000002dH
  000ce	66 3b da	 cmp	 bx, dx
  000d1	5b		 pop	 ebx
  000d2	7e 0b		 jle	 SHORT $LN14@CGCloseWin

; 17424: 			{
; 17425: 				gObj[aIndex].TargetShopNumber = -1;

  000d4	83 ca ff	 or	 edx, -1
  000d7	66 89 11	 mov	 WORD PTR [ecx], dx
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN14@CGCloseWin:

; 17426: 			}
; 17427: #else
; 17428: 			gObj[aIndex].TargetShopNumber = -1;
; 17429: #endif
; 17430: 		}
; 17431: 
; 17432: 		if ( gObj[aIndex].m_IfState.type == 1 )

  000df	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  000e6	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  000ec	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000ef	75 0e		 jne	 SHORT $LN5@CGCloseWin

; 17433: 		{
; 17434: 			CGTradeCancelButtonRecv(aIndex);

  000f1	57		 push	 edi
  000f2	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fc	83 c4 04	 add	 esp, 4
$LN5@CGCloseWin:

; 17435: 		}
; 17436: 
; 17437: 		if ( gObj[aIndex].m_IfState.type == 6 )

  000ff	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00106	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  0010c	81 fa 80 01 00
	00		 cmp	 edx, 384		; 00000180H
  00112	75 0e		 jne	 SHORT $LN4@CGCloseWin

; 17438: 		{
; 17439: 			CGWarehouseUseEnd(aIndex);

  00114	57		 push	 edi
  00115	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	83 c4 04	 add	 esp, 4
$LN4@CGCloseWin:

; 17440: 		}
; 17441: 
; 17442: 		if ( gObj[aIndex].m_IfState.type == 13 )

  00122	8b 94 06 1c 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3612]
  00129	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0012c	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00132	81 fa 40 03 00
	00		 cmp	 edx, 832		; 00000340H
  00138	75 19		 jne	 SHORT $LN3@CGCloseWin

; 17443: 		{
; 17444: 			g_MixSystem.ChaosBoxInit(&gObj[aIndex]);

  0013a	51		 push	 ecx
  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00140	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 17445: 			gObjInventoryCommit(aIndex);

  00145	57		 push	 edi
  00146	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00150	83 c4 04	 add	 esp, 4
$LN3@CGCloseWin:

; 17446: 		}
; 17447: 
; 17448: 		if ( gObj[aIndex].m_IfState.type == 18 ) //season4 add-on

  00153	8b 8c 06 1c 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3612]
  0015a	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00160	81 f9 80 04 00
	00		 cmp	 ecx, 1152		; 00000480H
  00166	75 10		 jne	 SHORT $LN2@CGCloseWin

; 17449: 		{
; 17450: 			gObj[aIndex].TargetShopNumber = -1;

  00168	83 ca ff	 or	 edx, -1
  0016b	66 89 94 06 5a
	04 00 00	 mov	 WORD PTR [esi+eax+1114], dx
  00173	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@CGCloseWin:

; 17451: 		}
; 17452: 
; 17453: 		gObj[aIndex].m_IfState.state = 0;

  00178	83 a4 06 1c 0e
	00 00 c3	 and	 DWORD PTR [esi+eax+3612], -61 ; ffffffc3H

; 17454: 		gObj[aIndex].m_IfState.type = 0;

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00185	81 a4 06 1c 0e
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+3612], -65473 ; ffff003fH

; 17455: 		gObj[aIndex].m_IfState.use = 0;

  00190	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00195	83 a4 06 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+eax+3612], -4 ; fffffffcH

; 17456: 
; 17457: 		if ( szAuthKey[7] != AUTHKEY7)

  0019d	80 3d 07 00 00
	00 ae		 cmp	 BYTE PTR ?szAuthKey@@3PADA+7, -82 ; ffffffaeH
  001a4	74 08		 je	 SHORT $LN1@CGCloseWin
  001a6	5f		 pop	 edi
  001a7	5e		 pop	 esi

; 17460: 		}
; 17461: 	}
; 17462: }

  001a8	5d		 pop	 ebp

; 17458: 		{
; 17459: 			DestroyGIocp();

  001a9	e9 00 00 00 00	 jmp	 ?DestroyGIocp@@YAXXZ	; DestroyGIocp
$LN1@CGCloseWin:
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi

; 17460: 		}
; 17461: 	}
; 17462: }

  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
?CGCloseWindow@@YAXH@Z ENDP				; CGCloseWindow
_TEXT	ENDS
PUBLIC	??_C@_0FK@MCHLAMKK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::LeaveUserChaosCastle
EXTRN	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC	; CChaosCastle::PayUserEnterMoney
EXTRN	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::EnterUserChaosCastle
EXTRN	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::CheckUserEnterMoney
EXTRN	?CheckWearingMOPH@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::CheckWearingMOPH
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
;	COMDAT ??_C@_0FK@MCHLAMKK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FK@MCHLAMKK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle'
	DB	' (Guard Mail Set Serial:%u)', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z
_TEXT	SEGMENT
_dwITEM_SERIAL$ = -556					; size = 4
_btGuardMailSetItemPos$ = -552				; size = 1
tv749 = -548						; size = 4
_pMsg$250863 = -548					; size = 4
_iENTER_LEVEL$ = -544					; size = 4
_pResult$ = -540					; size = 5
_pNotice$250829 = -532					; size = 272
_pNotice$250809 = -532					; size = 272
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z PROC ; CGRequestEnterChaosCastle, COMDAT

; 17718: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 17719: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	85 ff		 test	 edi, edi
  0001c	78 0f		 js	 SHORT $LN60@CGRequestE@3
  0001e	33 c9		 xor	 ecx, ecx
  00020	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00026	0f 9e c1	 setle	 cl
  00029	85 c9		 test	 ecx, ecx
  0002b	75 27		 jne	 SHORT $LN45@CGRequestE@3
$LN60@CGRequestE@3:

; 17720: 	{
; 17721: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0002d	68 39 45 00 00	 push	 17721			; 00004539H
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 17974: }

  00046	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN45@CGRequestE@3:

; 17722: 		return;
; 17723: 	}
; 17724: 
; 17725: 	BYTE btChaosCastleNumber = lpMsg->iChaosCastleNumber-1;
; 17726: 	BYTE btGuardMailSetItemPos = lpMsg->iItemPos;

  00054	8a 40 05	 mov	 al, BYTE PTR [eax+5]
  00057	56		 push	 esi

; 17727: 	int iITEM_LEVEL=0;
; 17728: 	DWORD dwITEM_SERIAL=0;
; 17729: 	PMSG_RESULT_MOVECHAOSCASTLE pResult;
; 17730: 
; 17731: 	PHeadSubSetB((LPBYTE)&pResult, 0xAF, 0x01, sizeof(pResult));

  00058	6a 05		 push	 5
  0005a	6a 01		 push	 1
  0005c	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  00062	68 af 00 00 00	 push	 175			; 000000afH
  00067	51		 push	 ecx
  00068	88 85 d8 fd ff
	ff		 mov	 BYTE PTR _btGuardMailSetItemPos$[ebp], al
  0006e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 17732: 	pResult.Result = 0;
; 17733: 
; 17734: 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00079	8b f7		 mov	 esi, edi
  0007b	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00081	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	c6 85 e8 fd ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+4], 0
  0008e	66 83 78 68 01	 cmp	 WORD PTR [eax+104], 1
  00093	0f 85 e8 01 00
	00		 jne	 $LN72@CGRequestE@3
  00099	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0009d	0f 8e de 01 00
	00		 jle	 $LN72@CGRequestE@3

; 17735: 	{
; 17736: 		return;
; 17737: 	}
; 17738: 
; 17739: 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) || CC_MAP_RANGE(gObj[iIndex].MapNumber) || DS_MAP_RANGE(gObj[iIndex].MapNumber) )

  000a3	8a 88 49 01 00
	00		 mov	 cl, BYTE PTR [eax+329]
  000a9	80 f9 34	 cmp	 cl, 52			; 00000034H
  000ac	0f 84 59 05 00
	00		 je	 $LN41@CGRequestE@3
  000b2	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000b5	72 10		 jb	 SHORT $LN61@CGRequestE@3
  000b7	ba 11 00 00 00	 mov	 edx, 17			; 00000011H
  000bc	3a d1		 cmp	 dl, cl
  000be	1b d2		 sbb	 edx, edx
  000c0	42		 inc	 edx
  000c1	0f 85 44 05 00
	00		 jne	 $LN41@CGRequestE@3
$LN61@CGRequestE@3:
  000c7	80 f9 35	 cmp	 cl, 53			; 00000035H
  000ca	0f 84 3b 05 00
	00		 je	 $LN41@CGRequestE@3
  000d0	80 f9 12	 cmp	 cl, 18			; 00000012H
  000d3	72 10		 jb	 SHORT $LN62@CGRequestE@3
  000d5	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  000da	3a d1		 cmp	 dl, cl
  000dc	1b d2		 sbb	 edx, edx
  000de	42		 inc	 edx
  000df	0f 85 26 05 00
	00		 jne	 $LN41@CGRequestE@3
$LN62@CGRequestE@3:
  000e5	80 f9 09	 cmp	 cl, 9
  000e8	0f 84 1d 05 00
	00		 je	 $LN41@CGRequestE@3
  000ee	33 d2		 xor	 edx, edx
  000f0	80 f9 20	 cmp	 cl, 32			; 00000020H
  000f3	0f 94 c2	 sete	 dl
  000f6	8b ca		 mov	 ecx, edx
  000f8	85 c9		 test	 ecx, ecx
  000fa	0f 85 0b 05 00
	00		 jne	 $LN41@CGRequestE@3

; 17744: 		return;
; 17745: 	}
; 17746: 
; 17747: 	if ( gObj[iIndex].m_IfState.use && gObj[iIndex].m_IfState.type != 12 )

  00100	8b 88 1c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3612]
  00106	f6 c1 03	 test	 cl, 3
  00109	74 12		 je	 SHORT $LN40@CGRequestE@3
  0010b	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00111	81 f9 00 03 00
	00		 cmp	 ecx, 768		; 00000300H
  00117	0f 85 64 01 00
	00		 jne	 $LN72@CGRequestE@3
$LN40@CGRequestE@3:

; 17748: 	{
; 17749: 		return;
; 17750: 	}
; 17751: 
; 17752: 	if ( gPkLimitFree == FALSE )

  0011d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00124	53		 push	 ebx
  00125	75 47		 jne	 SHORT $LN69@CGRequestE@3

; 17753: 	{
; 17754: 		BOOL bPlayerKiller = FALSE; //Season 2.5 add-on

  00127	33 db		 xor	 ebx, ebx

; 17755: 
; 17756: 		if(ZtConfig.PvP.ZtPkPartySystem && gObj[iIndex].PartyNumber >= 0) //Season 2.5 add-on

  00129	39 1d 38 09 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2360, ebx
  0012f	74 1e		 je	 SHORT $LN65@CGRequestE@3
  00131	8b 80 2c 04 00
	00		 mov	 eax, DWORD PTR [eax+1068]
  00137	85 c0		 test	 eax, eax
  00139	78 14		 js	 SHORT $LN65@CGRequestE@3

; 17757: 		{
; 17758: 			if(gParty.GetPkLevel(gObj[iIndex].PartyNumber) >= 6)

  0013b	50		 push	 eax
  0013c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00141	e8 00 00 00 00	 call	 ?GetPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPkLevel
  00146	3c 06		 cmp	 al, 6
  00148	7c 05		 jl	 SHORT $LN65@CGRequestE@3

; 17759: 			{
; 17760: 				bPlayerKiller = TRUE;

  0014a	bb 01 00 00 00	 mov	 ebx, 1
$LN65@CGRequestE@3:

; 17761: 			}
; 17762: 		}
; 17763: 
; 17764: 		if(gObj[iIndex].m_PK_Level >= 6)

  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00154	03 c6		 add	 eax, esi
  00156	80 b8 3d 01 00
	00 06		 cmp	 BYTE PTR [eax+317], 6

; 17765: 		{
; 17766: 			bPlayerKiller = TRUE;
; 17767: 		}
; 17768: 
; 17769: 		if ( bPlayerKiller == TRUE )

  0015d	7d 05		 jge	 SHORT $LN63@CGRequestE@3
  0015f	83 fb 01	 cmp	 ebx, 1
  00162	75 0a		 jne	 SHORT $LN69@CGRequestE@3
$LN63@CGRequestE@3:

; 17770: 		{
; 17771: 			PMSG_NOTICE pNotice;
; 17772: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 201)));

  00164	68 c9 04 00 00	 push	 1225			; 000004c9H

; 17773: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 17774: 			return;

  00169	e9 5b 04 00 00	 jmp	 $LN75@CGRequestE@3
$LN69@CGRequestE@3:

; 17775: 		}
; 17776: 	}
; 17777: 
; 17778: 	if ( gObjDuelCheck(&gObj[iIndex]) == TRUE )

  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDuelCheck
  00174	83 c4 04	 add	 esp, 4
  00177	83 f8 01	 cmp	 eax, 1
  0017a	75 0a		 jne	 SHORT $LN34@CGRequestE@3

; 17779: 	{
; 17780: 		PMSG_NOTICE pNotice;
; 17781: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 202)));

  0017c	68 ca 04 00 00	 push	 1226			; 000004caH

; 17782: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 17783: 		return;

  00181	e9 43 04 00 00	 jmp	 $LN75@CGRequestE@3
$LN34@CGRequestE@3:

; 17784: 	}
; 17785: 
; 17786: 	if ( gObj[iIndex].lpGuild )

  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018c	8b 84 0e 38 04
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1080]
  00193	85 c0		 test	 eax, eax
  00195	74 13		 je	 SHORT $LN32@CGRequestE@3

; 17787: 	{
; 17788: 		if ( gObj[iIndex].lpGuild->WarState == 1 )

  00197	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  0019e	75 0a		 jne	 SHORT $LN32@CGRequestE@3

; 17789: 		{
; 17790: 			PMSG_NOTICE pNotice;
; 17791: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 203)));

  001a0	68 cb 04 00 00	 push	 1227			; 000004cbH

; 17792: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 17793: 			return;

  001a5	e9 1f 04 00 00	 jmp	 $LN75@CGRequestE@3
$LN32@CGRequestE@3:

; 17794: 		}
; 17795: 	}
; 17796: 
; 17797: 	if ( gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,3) ||	// Dino
; 17798: 		 gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,2) ||	// Uniria
; 17799: 		 gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,37) )	// Fenrir

  001aa	8b 94 0e 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+ecx+3620]
  001b1	0f b7 82 a6 06
	00 00		 movzx	 eax, WORD PTR [edx+1702]
  001b8	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  001bd	66 3b c2	 cmp	 ax, dx
  001c0	0f 84 fe 03 00
	00		 je	 $LN30@CGRequestE@3
  001c6	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  001cb	66 3b c2	 cmp	 ax, dx
  001ce	0f 84 f0 03 00
	00		 je	 $LN30@CGRequestE@3
  001d4	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  001d9	66 3b c2	 cmp	 ax, dx
  001dc	0f 84 e2 03 00
	00		 je	 $LN30@CGRequestE@3

; 17804: 		return;
; 17805: 	}
; 17806: 
; 17807: 	BOOL bPlayerKiller = FALSE; //Season 2.5 add-on

  001e2	33 db		 xor	 ebx, ebx

; 17808: 
; 17809: 	if(ZtConfig.PvP.ZtPkPartySystem && gObj[iIndex].PartyNumber >= 0) //Season 2.5 add-on

  001e4	39 1d 38 09 00
	00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+2360, ebx
  001ea	74 25		 je	 SHORT $LN70@CGRequestE@3
  001ec	8b 84 0e 2c 04
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1068]
  001f3	85 c0		 test	 eax, eax
  001f5	78 1a		 js	 SHORT $LN70@CGRequestE@3

; 17810: 	{
; 17811: 		if(gParty.GetPkLevel(gObj[iIndex].PartyNumber) >= 5)

  001f7	50		 push	 eax
  001f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001fd	e8 00 00 00 00	 call	 ?GetPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPkLevel

; 17812: 		{
; 17813: 			bPlayerKiller = TRUE;

  00202	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00208	3c 05		 cmp	 al, 5
  0020a	7c 05		 jl	 SHORT $LN70@CGRequestE@3
  0020c	bb 01 00 00 00	 mov	 ebx, 1
$LN70@CGRequestE@3:

; 17814: 		}
; 17815: 	}
; 17816: 
; 17817: 	if(gObj[iIndex].m_PK_Level >= 4)

  00211	80 bc 0e 3d 01
	00 00 04	 cmp	 BYTE PTR [esi+ecx+317], 4

; 17818: 	{
; 17819: 		bPlayerKiller = TRUE;
; 17820: 	}
; 17821: 
; 17822: 	if ( bPlayerKiller == TRUE )

  00219	7d 05		 jge	 SHORT $LN64@CGRequestE@3
  0021b	83 fb 01	 cmp	 ebx, 1
  0021e	75 18		 jne	 SHORT $LN26@CGRequestE@3
$LN64@CGRequestE@3:

; 17823: 	{
; 17824: 		pResult.Result = 8;
; 17825: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00220	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00227	50		 push	 eax
  00228	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0022e	c6 85 e8 fd ff
	ff 08		 mov	 BYTE PTR _pResult$[ebp+4], 8
  00235	51		 push	 ecx

; 17826: 		return;

  00236	eb 3f		 jmp	 SHORT $LN78@CGRequestE@3
$LN26@CGRequestE@3:

; 17827: 	}
; 17828: 
; 17829: 	int iENTER_LEVEL = g_ChaosCastle.GetUserLevelToEnter(iIndex);

  00238	57		 push	 edi
  00239	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0023e	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  00243	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], eax

; 17830: 
; 17831: 	if ( iENTER_LEVEL == -1 )

  00249	83 f8 ff	 cmp	 eax, -1

; 17832: 	{
; 17833: 		pResult.Result = 1;
; 17834: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 17835: 		return;

  0024c	0f 84 57 03 00
	00		 je	 $LN23@CGRequestE@3

; 17836: 	}
; 17837: 
; 17838: 	if ( g_ChaosCastle.CheckCanEnter(iENTER_LEVEL) == false )

  00252	50		 push	 eax
  00253	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00258	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter
  0025d	84 c0		 test	 al, al
  0025f	75 30		 jne	 SHORT $LN24@CGRequestE@3

; 17839: 	{
; 17840: 		pResult.Result = 2;

  00261	c6 85 e8 fd ff
	ff 02		 mov	 BYTE PTR _pResult$[ebp+4], 2
$LN80@CGRequestE@3:

; 17896: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00268	0f b6 8d e5 fd
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  0026f	51		 push	 ecx
  00270	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  00276	52		 push	 edx
$LN78@CGRequestE@3:

; 17851: 		}
; 17852: 		else
; 17853: 		{
; 17854: 			pResult.Result = 1;
; 17855: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00277	57		 push	 edi
  00278	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN73@CGRequestE@3:
  00280	5b		 pop	 ebx
$LN72@CGRequestE@3:
  00281	5e		 pop	 esi
  00282	5f		 pop	 edi

; 17974: }

  00283	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00286	33 cd		 xor	 ecx, ebp
  00288	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c3		 ret	 0
$LN24@CGRequestE@3:

; 17841: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 17842: 		return;
; 17843: 	}
; 17844: 
; 17845: 	if ( gObj[iIndex].pInventory[btGuardMailSetItemPos].IsItem() == TRUE )

  00291	0f b6 9d d8 fd
	ff ff		 movzx	 ebx, BYTE PTR _btGuardMailSetItemPos$[ebp]
  00298	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029d	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  002a4	89 9d dc fd ff
	ff		 mov	 DWORD PTR tv749[ebp], ebx
  002aa	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  002b0	03 cb		 add	 ecx, ebx
  002b2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002b7	83 f8 01	 cmp	 eax, 1
  002ba	0f 85 e9 02 00
	00		 jne	 $LN23@CGRequestE@3

; 17846: 	{
; 17847: 		if ( gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Type == ITEMGET(13,29) ) // Armor of Guardman

  002c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c5	8b 8c 06 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+eax+3620]
  002cc	ba 1d 1a 00 00	 mov	 edx, 6685		; 00001a1dH
  002d1	66 39 54 0b 06	 cmp	 WORD PTR [ebx+ecx+6], dx
  002d6	0f 85 b2 02 00
	00		 jne	 $LN22@CGRequestE@3

; 17848: 		{
; 17849: 			iITEM_LEVEL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Level;
; 17850: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Number;

  002dc	8b 0c 0b	 mov	 ecx, DWORD PTR [ebx+ecx]
  002df	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], ecx

; 17864: 	}
; 17865: 
; 17866: 	if ( g_ChaosCastle.CheckWearingMOPH(iIndex) == TRUE )

  002e5	57		 push	 edi
  002e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002eb	e8 00 00 00 00	 call	 ?CheckWearingMOPH@CChaosCastle@@QAEHH@Z ; CChaosCastle::CheckWearingMOPH
  002f0	83 f8 01	 cmp	 eax, 1
  002f3	75 2b		 jne	 SHORT $LN19@CGRequestE@3

; 17867: 	{
; 17868: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 205)), iIndex, 1);

  002f5	50		 push	 eax
  002f6	57		 push	 edi
  002f7	68 cd 04 00 00	 push	 1229			; 000004cdH
  002fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00301	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00306	50		 push	 eax
  00307	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0030c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0030f	5b		 pop	 ebx
  00310	5e		 pop	 esi
  00311	5f		 pop	 edi

; 17974: }

  00312	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00315	33 cd		 xor	 ecx, ebp
  00317	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031c	8b e5		 mov	 esp, ebp
  0031e	5d		 pop	 ebp
  0031f	c3		 ret	 0
$LN19@CGRequestE@3:

; 17869: 		return;
; 17870: 	}
; 17871: 
; 17872: 	//season 2.5 add-on
; 17873: 	BYTE attr = MapC[gObj[iIndex].MapNumber].GetAttr(gObj[iIndex].X, gObj[iIndex].Y);

  00320	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17874: 
; 17875: 	if ( (attr&1) != 1 )

  00325	0f bf 94 06 46
	01 00 00	 movsx	 edx, WORD PTR [esi+eax+326]
  0032d	0f bf 8c 06 44
	01 00 00	 movsx	 ecx, WORD PTR [esi+eax+324]
  00335	52		 push	 edx
  00336	51		 push	 ecx
  00337	0f b6 8c 06 49
	01 00 00	 movzx	 ecx, BYTE PTR [esi+eax+329]
  0033f	69 c9 48 3d 05
	00		 imul	 ecx, 343368		; 00053d48H
  00345	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0034b	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00350	a8 01		 test	 al, 1
  00352	0f 84 28 ff ff
	ff		 je	 $LN73@CGRequestE@3

; 17876: 	{
; 17877: 		return;
; 17878: 	}
; 17879: 
; 17880: 	int iBC_INDEX = -1;
; 17881: 
; 17882: 	if ( g_ChaosCastle.CheckUserEnterMoney(iIndex, iENTER_LEVEL) )

  00358	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _iENTER_LEVEL$[ebp]
  0035e	53		 push	 ebx
  0035f	57		 push	 edi
  00360	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00365	e8 00 00 00 00	 call	 ?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::CheckUserEnterMoney
  0036a	85 c0		 test	 eax, eax
  0036c	0f 84 10 02 00
	00		 je	 $LN17@CGRequestE@3

; 17883: 	{
; 17884: 		iBC_INDEX = g_ChaosCastle.EnterUserChaosCastle(iENTER_LEVEL, iIndex);

  00372	57		 push	 edi
  00373	53		 push	 ebx
  00374	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00379	e8 00 00 00 00	 call	 ?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::EnterUserChaosCastle
  0037e	8b d8		 mov	 ebx, eax

; 17885: 
; 17886: 		if ( iBC_INDEX == -1 )

  00380	83 fb ff	 cmp	 ebx, -1
  00383	75 1b		 jne	 SHORT $LN16@CGRequestE@3

; 17857: 		}
; 17858: 	}
; 17859: 	else
; 17860: 	{
; 17861: 		pResult.Result = 1;
; 17862: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00385	0f b6 95 e5 fd
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  0038c	52		 push	 edx
  0038d	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]

; 17887: 		{
; 17888: 			pResult.Result = 5;

  00393	c6 85 e8 fd ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+4], 5
  0039a	50		 push	 eax
  0039b	e9 d7 fe ff ff	 jmp	 $LN78@CGRequestE@3
$LN16@CGRequestE@3:

; 17898: 	}
; 17899: 
; 17900: 	BOOL bRES = g_ChaosCastle.PayUserEnterMoney(iIndex, iENTER_LEVEL);

  003a0	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _iENTER_LEVEL$[ebp]
  003a6	51		 push	 ecx
  003a7	57		 push	 edi
  003a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  003ad	e8 00 00 00 00	 call	 ?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::PayUserEnterMoney

; 17901: 
; 17902: 	if ( bRES == FALSE )

  003b2	85 c0		 test	 eax, eax
  003b4	75 2d		 jne	 SHORT $LN14@CGRequestE@3

; 17903: 	{
; 17904: 		g_ChaosCastle.LeaveUserChaosCastle(iENTER_LEVEL, iIndex);

  003b6	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _iENTER_LEVEL$[ebp]
  003bc	57		 push	 edi
  003bd	52		 push	 edx
  003be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  003c3	e8 00 00 00 00	 call	 ?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::LeaveUserChaosCastle
  003c8	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003cf	50		 push	 eax
  003d0	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]

; 17905: 		pResult.Result = 5;

  003d6	c6 85 e8 fd ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+4], 5
  003dd	51		 push	 ecx
  003de	e9 94 fe ff ff	 jmp	 $LN78@CGRequestE@3
$LN14@CGRequestE@3:

; 17906: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 17907: 		return;
; 17908: 	}
; 17909: 
; 17910: 	gObjInventoryDeleteItem(iIndex, btGuardMailSetItemPos);

  003e3	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR tv749[ebp]
  003e9	52		 push	 edx
  003ea	57		 push	 edi
  003eb	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 17911: 	GCInventoryItemDeleteSend(iIndex, btGuardMailSetItemPos, 1);

  003f0	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _btGuardMailSetItemPos$[ebp]
  003f6	6a 01		 push	 1
  003f8	50		 push	 eax
  003f9	57		 push	 edi
  003fa	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 17912: 
; 17913: 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  003ff	0f b6 8d e5 fd
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  00406	51		 push	 ecx
  00407	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _pResult$[ebp]
  0040d	52		 push	 edx
  0040e	57		 push	 edi
  0040f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17914: 
; 17915: 	gObj[iIndex].m_cChaosCastleIndex = iENTER_LEVEL;

  00414	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00419	8a 8d e0 fd ff
	ff		 mov	 cl, BYTE PTR _iENTER_LEVEL$[ebp]
  0041f	88 8c 06 a5 0e
	00 00		 mov	 BYTE PTR [esi+eax+3749], cl

; 17916: 	gObj[iIndex].m_cChaosCastleSubIndex = iBC_INDEX;

  00426	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042c	88 9c 16 a6 0e
	00 00		 mov	 BYTE PTR [esi+edx+3750], bl

; 17917: 	gObj[iIndex].m_IfState.state = 0;

  00433	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00438	83 a4 06 1c 0e
	00 00 c3	 and	 DWORD PTR [esi+eax+3612], -61 ; ffffffc3H

; 17918: 	gObj[iIndex].m_IfState.type = 0;

  00440	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00445	81 a4 06 1c 0e
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+3612], -65473 ; ffff003fH

; 17919: 	gObj[iIndex].m_IfState.use = 0;

  00450	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00455	83 a4 06 1c 0e
	00 00 fc	 and	 DWORD PTR [esi+eax+3612], -4 ; fffffffcH

; 17920: 
; 17921: 	if ( gObj[iIndex].m_bPShopOpen == true )

  0045d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00462	83 c4 20	 add	 esp, 32			; 00000020H
  00465	80 bc 06 c4 0e
	00 00 01	 cmp	 BYTE PTR [esi+eax+3780], 1
  0046d	75 0e		 jne	 SHORT $LN13@CGRequestE@3

; 17922: 	{
; 17923: 		CGPShopReqClose(iIndex);

  0046f	57		 push	 edi
  00470	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  00475	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047a	83 c4 04	 add	 esp, 4
$LN13@CGRequestE@3:

; 17924: 	}
; 17925: 
; 17926: 	if ( gObj[iIndex].PartyNumber >= 0 )

  0047d	8b 8c 06 2c 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1068]
  00484	85 c9		 test	 ecx, ecx
  00486	78 30		 js	 SHORT $LN11@CGRequestE@3

; 17927: 	{
; 17928: 		PMSG_PARTYDELUSER pMsg;
; 17929: 		int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);

  00488	8b 44 06 2c	 mov	 eax, DWORD PTR [esi+eax+44]
  0048c	50		 push	 eax
  0048d	57		 push	 edi
  0048e	51		 push	 ecx
  0048f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00494	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 17930: 
; 17931: 		if ( pindex >= 0 )

  00499	85 c0		 test	 eax, eax
  0049b	78 16		 js	 SHORT $LN67@CGRequestE@3

; 17932: 		{
; 17933: 			pMsg.Number = pindex;
; 17934: 			CGPartyDelUser(&pMsg, iIndex);

  0049d	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$250863[ebp]
  004a3	57		 push	 edi
  004a4	51		 push	 ecx
  004a5	88 85 df fd ff
	ff		 mov	 BYTE PTR _pMsg$250863[ebp+3], al
  004ab	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  004b0	83 c4 08	 add	 esp, 8
$LN67@CGRequestE@3:
  004b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN11@CGRequestE@3:

; 17935: 		}
; 17936: 	}
; 17937: 
; 17938: 	if ( gObj[iIndex].Class == CLASS_ELF && gObj[iIndex].m_RecallMon >= 0)

  004b8	66 83 bc 06 b8
	00 00 00 02	 cmp	 WORD PTR [esi+eax+184], 2
  004c1	75 1d		 jne	 SHORT $LN10@CGRequestE@3
  004c3	83 bc 06 50 04
	00 00 00	 cmp	 DWORD PTR [esi+eax+1104], 0
  004cb	7c 13		 jl	 SHORT $LN10@CGRequestE@3

; 17939: 	{
; 17940: 		GCRecallMonLife(iIndex, 60, 0);

  004cd	6a 00		 push	 0
  004cf	6a 3c		 push	 60			; 0000003cH
  004d1	57		 push	 edi
  004d2	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 17941: 		gObjMonsterCallKill(iIndex);

  004d7	57		 push	 edi
  004d8	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  004dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@CGRequestE@3:

; 17942: 	}
; 17943: 
; 17944: 	char szTemp[256];
; 17945: 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 206)), iENTER_LEVEL+1);

  004e0	8b 9d e0 fd ff
	ff		 mov	 ebx, DWORD PTR _iENTER_LEVEL$[ebp]
  004e6	43		 inc	 ebx
  004e7	53		 push	 ebx
  004e8	68 ce 04 00 00	 push	 1230			; 000004ceH
  004ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004f2	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  004f7	50		 push	 eax
  004f8	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  004fe	52		 push	 edx
  004ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 17946: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  00505	6a 01		 push	 1
  00507	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0050d	57		 push	 edi
  0050e	50		 push	 eax
  0050f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 17947: 
; 17948: 	switch ( iENTER_LEVEL+1 )

  00514	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00517	83 c4 18	 add	 esp, 24			; 00000018H
  0051a	83 f8 06	 cmp	 eax, 6
  0051d	77 2d		 ja	 SHORT $LN8@CGRequestE@3
  0051f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN81@CGRequestE@3[eax*4]
$LN7@CGRequestE@3:

; 17949: 	{
; 17950: 		case 1:
; 17951: 			gObjMoveGate(iIndex, 82);

  00526	6a 52		 push	 82			; 00000052H

; 17952: 			break;

  00528	eb 19		 jmp	 SHORT $LN74@CGRequestE@3
$LN6@CGRequestE@3:

; 17953: 		case 2:
; 17954: 			gObjMoveGate(iIndex, 83);

  0052a	6a 53		 push	 83			; 00000053H

; 17955: 			break;

  0052c	eb 15		 jmp	 SHORT $LN74@CGRequestE@3
$LN5@CGRequestE@3:

; 17956: 		case 3:
; 17957: 			gObjMoveGate(iIndex, 84);

  0052e	6a 54		 push	 84			; 00000054H

; 17958: 			break;

  00530	eb 11		 jmp	 SHORT $LN74@CGRequestE@3
$LN4@CGRequestE@3:

; 17959: 		case 4:
; 17960: 			gObjMoveGate(iIndex, 85);

  00532	6a 55		 push	 85			; 00000055H

; 17961: 			break;

  00534	eb 0d		 jmp	 SHORT $LN74@CGRequestE@3
$LN3@CGRequestE@3:

; 17962: 		case 5:
; 17963: 			gObjMoveGate(iIndex, 86);

  00536	6a 56		 push	 86			; 00000056H

; 17964: 			break;

  00538	eb 09		 jmp	 SHORT $LN74@CGRequestE@3
$LN2@CGRequestE@3:

; 17965: 		case 6:
; 17966: 			gObjMoveGate(iIndex, 87);

  0053a	6a 57		 push	 87			; 00000057H

; 17967: 			break;

  0053c	eb 05		 jmp	 SHORT $LN74@CGRequestE@3
$LN1@CGRequestE@3:

; 17968: 		case 7:
; 17969: 			gObjMoveGate(iIndex, 272);

  0053e	68 10 01 00 00	 push	 272			; 00000110H
$LN74@CGRequestE@3:
  00543	57		 push	 edi
  00544	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00549	83 c4 08	 add	 esp, 8
$LN8@CGRequestE@3:

; 17970: 			break;
; 17971: 	}
; 17972: 
; 17973: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%u)", iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);

  0054c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00551	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _dwITEM_SERIAL$[ebp]
  00557	51		 push	 ecx
  00558	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0055c	52		 push	 edx
  0055d	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00561	50		 push	 eax
  00562	53		 push	 ebx
  00563	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@MCHLAMKK@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  00568	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0056e	83 c4 14	 add	 esp, 20			; 00000014H
  00571	5b		 pop	 ebx
  00572	5e		 pop	 esi
  00573	5f		 pop	 edi

; 17974: }

  00574	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00577	33 cd		 xor	 ecx, ebp
  00579	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057e	8b e5		 mov	 esp, ebp
  00580	5d		 pop	 ebp
  00581	c3		 ret	 0
$LN17@CGRequestE@3:

; 17889: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 17890: 			return;
; 17891: 		}
; 17892: 	}
; 17893: 	else
; 17894: 	{
; 17895: 		pResult.Result = 7;

  00582	c6 85 e8 fd ff
	ff 07		 mov	 BYTE PTR _pResult$[ebp+4], 7

; 17897: 		return;

  00589	e9 da fc ff ff	 jmp	 $LN80@CGRequestE@3
$LN22@CGRequestE@3:

; 17851: 		}
; 17852: 		else
; 17853: 		{
; 17854: 			pResult.Result = 1;
; 17855: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0058e	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00595	50		 push	 eax
  00596	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pResult$[ebp]
  0059c	c6 85 e8 fd ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+4], 1
  005a3	51		 push	 ecx

; 17856: 			return;

  005a4	e9 ce fc ff ff	 jmp	 $LN78@CGRequestE@3
$LN23@CGRequestE@3:

; 17857: 		}
; 17858: 	}
; 17859: 	else
; 17860: 	{
; 17861: 		pResult.Result = 1;
; 17862: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  005a9	0f b6 95 e5 fd
	ff ff		 movzx	 edx, BYTE PTR _pResult$[ebp+1]
  005b0	52		 push	 edx
  005b1	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  005b7	c6 85 e8 fd ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+4], 1
  005be	50		 push	 eax

; 17863: 		return;

  005bf	e9 b3 fc ff ff	 jmp	 $LN78@CGRequestE@3
$LN30@CGRequestE@3:

; 17800: 	{
; 17801: 		PMSG_NOTICE pNotice;
; 17802: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 204)));

  005c4	68 cc 04 00 00	 push	 1228			; 000004ccH
$LN75@CGRequestE@3:
  005c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005ce	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  005d3	50		 push	 eax
  005d4	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$250829[ebp]
  005da	6a 01		 push	 1
  005dc	51		 push	 ecx
  005dd	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 17803: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  005e2	0f b6 95 ed fd
	ff ff		 movzx	 edx, BYTE PTR _pNotice$250829[ebp+1]
  005e9	52		 push	 edx
  005ea	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$250829[ebp]
  005f0	50		 push	 eax
  005f1	57		 push	 edi
  005f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005f7	83 c4 18	 add	 esp, 24			; 00000018H
  005fa	5b		 pop	 ebx
  005fb	5e		 pop	 esi
  005fc	5f		 pop	 edi

; 17974: }

  005fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00600	33 cd		 xor	 ecx, ebp
  00602	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00607	8b e5		 mov	 esp, ebp
  00609	5d		 pop	 ebp
  0060a	c3		 ret	 0
$LN41@CGRequestE@3:

; 17740: 	{
; 17741: 		PMSG_NOTICE pNotice;
; 17742: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 200)));

  0060b	68 c8 04 00 00	 push	 1224			; 000004c8H
  00610	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00615	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0061a	50		 push	 eax
  0061b	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$250809[ebp]
  00621	6a 01		 push	 1
  00623	51		 push	 ecx
  00624	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 17743: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00629	0f b6 95 ed fd
	ff ff		 movzx	 edx, BYTE PTR _pNotice$250809[ebp+1]
  00630	52		 push	 edx
  00631	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$250809[ebp]
  00637	50		 push	 eax
  00638	57		 push	 edi
  00639	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17974: }

  0063e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00641	83 c4 18	 add	 esp, 24			; 00000018H
  00644	5e		 pop	 esi
  00645	33 cd		 xor	 ecx, ebp
  00647	5f		 pop	 edi
  00648	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0064d	8b e5		 mov	 esp, ebp
  0064f	5d		 pop	 ebp
  00650	c3		 ret	 0
  00651	8d 49 00	 npad	 3
$LN81@CGRequestE@3:
  00654	00 00 00 00	 DD	 $LN7@CGRequestE@3
  00658	00 00 00 00	 DD	 $LN6@CGRequestE@3
  0065c	00 00 00 00	 DD	 $LN5@CGRequestE@3
  00660	00 00 00 00	 DD	 $LN4@CGRequestE@3
  00664	00 00 00 00	 DD	 $LN3@CGRequestE@3
  00668	00 00 00 00	 DD	 $LN2@CGRequestE@3
  0066c	00 00 00 00	 DD	 $LN1@CGRequestE@3
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ENDP ; CGRequestEnterChaosCastle
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ; CGDuelOkRequestRecv
; Function compile flags: /Ogtp
;	COMDAT ?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z
_TEXT	SEGMENT
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z PROC	; CGDuelOkRequestRecv, COMDAT

; 18455: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00009	33 c5		 xor	 eax, ebp
  0000b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18456: //#if(GS_CASTLE==1)
; 18457: 	return;
; 18458: //#endif
; 18459: 	int iDuelIndex;
; 18460: 	PMSG_ANS_START_DUEL pMsgSend;
; 18461: 
; 18462: 	iDuelIndex = -1;
; 18463: 
; 18464: 	pMsgSend.h.c = 0xC1;
; 18465: 	pMsgSend.h.headcode = 0xAA;
; 18466: 	pMsgSend.h.size = sizeof(pMsgSend);
; 18467: 
; 18468: 	if ( gObj[aIndex].CloseType != -1 )
; 18469: 	{
; 18470: 		return;
; 18471: 	}
; 18472: 	
; 18473: 	iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 18474: 
; 18475: 	if ( OBJMAX_RANGE(iDuelIndex) )
; 18476: 	{
; 18477: 		if ( !gObjIsConnected(iDuelIndex) )
; 18478: 			return;
; 18479: 
; 18480: 		if ( gObj[iDuelIndex].Type == OBJ_MONSTER )
; 18481: 			return;
; 18482: 
; 18483: 		if ( gObj[iDuelIndex].CloseCount >= 0 )
; 18484: 			return;
; 18485: 
; 18486: 		if ( lpMsg->bDuelOK )
; 18487: 		{
; 18488: 			if ( BC_MAP_RANGE(gObj[iDuelIndex].MapNumber) || CC_MAP_RANGE(gObj[iDuelIndex].MapNumber) || DS_MAP_RANGE(gObj[iDuelIndex].MapNumber) )
; 18489: 			{
; 18490: 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), aIndex, 1);
; 18491: 				gObj[aIndex].m_iDuelUserRequested = -1;
; 18492: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18493: 				memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 18494: 				pMsgSend.bDuelStart = false;
; 18495: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18496: 				return;
; 18497: 			}
; 18498: 		}
; 18499: 
; 18500: 		if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser ) )
; 18501: 		{
; 18502: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), aIndex, 1);
; 18503: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 18504: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 18505: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18506: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 18507: 			pMsgSend.bDuelStart = false;
; 18508: 
; 18509: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18510: 			return;
; 18511: 		}
; 18512: 
; 18513: 		if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )
; 18514: 		{
; 18515: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 173)), aIndex, 1);
; 18516: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 18517: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18518: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 18519: 			pMsgSend.bDuelStart = false;
; 18520: 
; 18521: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18522: 			return;
; 18523: 		}
; 18524: 
; 18525: 		if ( gObj[iDuelIndex].m_iDuelUserReserved == aIndex )
; 18526: 		{
; 18527: 			char szDuelName[MAX_ACCOUNT_LEN+1]={0};
; 18528: 			char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 18529: 			memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);
; 18530: 			szDuelName[MAX_ACCOUNT_LEN] = 0;
; 18531: 			memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);
; 18532: 			szDuelName2[MAX_ACCOUNT_LEN] = 0;
; 18533: 
; 18534: 			if ( !strcmp(szDuelName, szDuelName2))
; 18535: 			{
; 18536: 				if ( lpMsg->bDuelOK == false)
; 18537: 				{
; 18538: 					gObj[aIndex].m_iDuelUserRequested = -1;
; 18539: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18540: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 18541: 					pMsgSend.bDuelStart = false;
; 18542: 
; 18543: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18544: 				}
; 18545: 				else if ( lpMsg->bDuelOK == true )
; 18546: 				{
; 18547: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18548: 					gObj[iDuelIndex].m_btDuelScore = 0;
; 18549: 					gObj[iDuelIndex].m_iDuelUser = aIndex;
; 18550: 					gObj[iDuelIndex].m_iDuelTickCount = GetTickCount();
; 18551: 					gObj[aIndex].m_iDuelUserRequested = -1;
; 18552: 					gObj[aIndex].m_iDuelUserReserved = -1;
; 18553: 					gObj[aIndex].m_btDuelScore = 0;
; 18554: 					gObj[aIndex].m_iDuelUser = iDuelIndex;
; 18555: 					gObj[aIndex].m_iDuelTickCount = GetTickCount();
; 18556: 
; 18557: 					pMsgSend.bDuelStart = true;
; 18558: 					pMsgSend.NumberH = SET_NUMBERH(iDuelIndex);
; 18559: 					pMsgSend.NumberL = SET_NUMBERL(iDuelIndex);
; 18560: 					memcpy(pMsgSend.szName, szDuelName, sizeof(pMsgSend.szName));
; 18561: 
; 18562: 					DataSend(aIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18563: 
; 18564: 					pMsgSend.NumberH = SET_NUMBERH(aIndex);
; 18565: 					pMsgSend.NumberL = SET_NUMBERL(aIndex);
; 18566: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 18567: 
; 18568: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18569: 
; 18570: 					GCSendDuelScore(gObj[aIndex].m_Index, gObj[iDuelIndex].m_Index);
; 18571: 
; 18572: 					LogAddTD("[Duel] [%s][%s] Duel Started [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name,	gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 18573: 				}
; 18574: 			}
; 18575: 			else
; 18576: 			{
; 18577: 				gObj[aIndex].m_iDuelUserRequested = -1;
; 18578: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18579: 				pMsgSend.bDuelStart = false;
; 18580: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18581: 				return;
; 18582: 			}
; 18583: 		}
; 18584: 		else
; 18585: 		{
; 18586: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 18587: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 18588: 			pMsgSend.bDuelStart = false;
; 18589: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 18590: 			return;
; 18591: 		}
; 18592: 	}
; 18593: }

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00011	33 cd		 xor	 ecx, ebp
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ENDP	; CGDuelOkRequestRecv
_TEXT	ENDS
PUBLIC	??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@ ; `string'
PUBLIC	_iIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ; CGReqMapSvrAuth
EXTRN	?GJReqMapSvrAuth@@YAXHPAD0HHHH@Z:PROC		; GJReqMapSvrAuth
;	COMDAT ??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@
CONST	SEGMENT
??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@ DB '[MapSe'
	DB	'rverMng] Map Server Join Send : [%s][%s](%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z
_TEXT	SEGMENT
_iIndex$GSCopy$ = -40					; size = 4
_btSerial$ = -36					; size = 17
_id$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z PROC ; CGReqMapSvrAuth, COMDAT

; 19580: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19581: 	if ( lpMsg->btCliVersion[0] != szClientVersion[0] ||
; 19582: 		 lpMsg->btCliVersion[1] != szClientVersion[1] ||
; 19583: 		 lpMsg->btCliVersion[2] != szClientVersion[2] ||
; 19584: 		 lpMsg->btCliVersion[3] != szClientVersion[3] ||
; 19585: 		 lpMsg->btCliVersion[4] != szClientVersion[4] )

  00010	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f b6 47 30	 movzx	 eax, BYTE PTR [edi+48]

; 19646: 	}
; 19647: 
; 19648: 	gObj[iIndex].CheckTick = lpMsg->iTickCount;

  00023	89 75 d8	 mov	 DWORD PTR _iIndex$GSCopy$[ebp], esi
  00026	3b c1		 cmp	 eax, ecx
  00028	0f 85 f4 02 00
	00		 jne	 $LN9@CGReqMapSv

; 19581: 	if ( lpMsg->btCliVersion[0] != szClientVersion[0] ||
; 19582: 		 lpMsg->btCliVersion[1] != szClientVersion[1] ||
; 19583: 		 lpMsg->btCliVersion[2] != szClientVersion[2] ||
; 19584: 		 lpMsg->btCliVersion[3] != szClientVersion[3] ||
; 19585: 		 lpMsg->btCliVersion[4] != szClientVersion[4] )

  0002e	0f b6 57 31	 movzx	 edx, BYTE PTR [edi+49]
  00032	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00039	3b d0		 cmp	 edx, eax
  0003b	0f 85 e1 02 00
	00		 jne	 $LN9@CGReqMapSv
  00041	0f b6 4f 32	 movzx	 ecx, BYTE PTR [edi+50]
  00045	0f be 15 02 00
	00 00		 movsx	 edx, BYTE PTR ?szClientVersion@@3PADA+2
  0004c	3b ca		 cmp	 ecx, edx
  0004e	0f 85 ce 02 00
	00		 jne	 $LN9@CGReqMapSv
  00054	0f b6 47 33	 movzx	 eax, BYTE PTR [edi+51]
  00058	0f be 0d 03 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA+3
  0005f	3b c1		 cmp	 eax, ecx
  00061	0f 85 bb 02 00
	00		 jne	 $LN9@CGReqMapSv
  00067	0f b6 57 34	 movzx	 edx, BYTE PTR [edi+52]
  0006b	0f be 05 04 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  00072	3b d0		 cmp	 edx, eax
  00074	0f 85 a8 02 00
	00		 jne	 $LN9@CGReqMapSv

; 19589: 		return;
; 19590: 	}
; 19591: 
; 19592: 	BYTE btSerial[17];
; 19593: 
; 19594: 	btSerial[16]=0;
; 19595: 	memcpy(btSerial, lpMsg->btCliSerial, sizeof(lpMsg->btCliSerial));

  0007a	8b 57 39	 mov	 edx, DWORD PTR [edi+57]
  0007d	8b 4f 35	 mov	 ecx, DWORD PTR [edi+53]
  00080	8b 47 3d	 mov	 eax, DWORD PTR [edi+61]
  00083	89 55 e0	 mov	 DWORD PTR _btSerial$[ebp+4], edx

; 19596: 	char id[MAX_ACCOUNT_LEN+1];
; 19597: 	id[MAX_ACCOUNT_LEN] = 0;
; 19598: 	memcpy(id, lpMsg->szAccountID, MAX_ACCOUNT_LEN);

  00086	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00089	89 4d dc	 mov	 DWORD PTR _btSerial$[ebp], ecx
  0008c	8b 4f 41	 mov	 ecx, DWORD PTR [edi+65]
  0008f	89 55 f0	 mov	 DWORD PTR _id$[ebp], edx
  00092	89 45 e4	 mov	 DWORD PTR _btSerial$[ebp+8], eax
  00095	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00098	89 4d e8	 mov	 DWORD PTR _btSerial$[ebp+12], ecx
  0009b	66 8b 4f 0c	 mov	 cx, WORD PTR [edi+12]

; 19599: 	BuxConvert(id, MAX_ACCOUNT_LEN);

  0009f	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  000a2	6a 0a		 push	 10			; 0000000aH
  000a4	52		 push	 edx
  000a5	c6 45 ec 00	 mov	 BYTE PTR _btSerial$[ebp+16], 0
  000a9	c6 45 fa 00	 mov	 BYTE PTR _id$[ebp+10], 0
  000ad	89 45 f4	 mov	 DWORD PTR _id$[ebp+4], eax
  000b0	66 89 4d f8	 mov	 WORD PTR _id$[ebp+8], cx
  000b4	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000b9	83 c4 08	 add	 esp, 8

; 19600: 
; 19601: 	if ( strcmp((char*)btSerial, szGameServerExeSerial) )

  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  000c1	8d 45 dc	 lea	 eax, DWORD PTR _btSerial$[ebp]
$LL13@CGReqMapSv:
  000c4	8a 10		 mov	 dl, BYTE PTR [eax]
  000c6	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000c8	75 1a		 jne	 SHORT $LN14@CGReqMapSv
  000ca	84 d2		 test	 dl, dl
  000cc	74 12		 je	 SHORT $LN15@CGReqMapSv
  000ce	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000d1	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000d4	75 0e		 jne	 SHORT $LN14@CGReqMapSv
  000d6	83 c0 02	 add	 eax, 2
  000d9	83 c1 02	 add	 ecx, 2
  000dc	84 d2		 test	 dl, dl
  000de	75 e4		 jne	 SHORT $LL13@CGReqMapSv
$LN15@CGReqMapSv:
  000e0	33 c0		 xor	 eax, eax
  000e2	eb 05		 jmp	 SHORT $LN16@CGReqMapSv
$LN14@CGReqMapSv:
  000e4	1b c0		 sbb	 eax, eax
  000e6	83 d8 ff	 sbb	 eax, -1
$LN16@CGReqMapSv:
  000e9	85 c0		 test	 eax, eax
  000eb	74 36		 je	 SHORT $LN8@CGReqMapSv

; 19602: 	{
; 19603: 		LogAddC(2, "error-L1: Serial error [%s] [%s]", id, btSerial);

  000ed	8d 45 dc	 lea	 eax, DWORD PTR _btSerial$[ebp]
  000f0	50		 push	 eax
  000f1	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  000f4	51		 push	 ecx
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
  000fa	6a 02		 push	 2
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 19604: 		GCAnsMapSvrAuth(iIndex, 6);

  00102	6a 06		 push	 6
  00104	56		 push	 esi
  00105	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth

; 19605: 		CloseClient(iIndex);

  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00110	83 c4 1c	 add	 esp, 28			; 0000001cH
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi

; 19663: 
; 19664: 
; 19665: }

  00115	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00118	33 cd		 xor	 ecx, ebp
  0011a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN8@CGReqMapSv:
  00123	53		 push	 ebx

; 19606: 		return;
; 19607: 	}
; 19608: 
; 19609: 	if ( bCanConnectMember == TRUE )

  00124	bb 01 00 00 00	 mov	 ebx, 1
  00129	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?bCanConnectMember@@3HA, ebx ; bCanConnectMember
  0012f	75 2e		 jne	 SHORT $LN6@CGReqMapSv

; 19610: 	{
; 19611: 		if ( ConMember.IsMember(id) == FALSE )

  00131	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  00134	52		 push	 edx
  00135	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  0013a	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  0013f	85 c0		 test	 eax, eax
  00141	75 1c		 jne	 SHORT $LN6@CGReqMapSv

; 19612: 		{
; 19613: 			GCAnsMapSvrAuth(iIndex, 2);	

  00143	6a 02		 push	 2
  00145	56		 push	 esi
  00146	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth
  0014b	83 c4 08	 add	 esp, 8
  0014e	5b		 pop	 ebx
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi

; 19663: 
; 19664: 
; 19665: }

  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	33 cd		 xor	 ecx, ebp
  00156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
$LN6@CGReqMapSv:

; 19614: 			return;
; 19615: 		}
; 19616: 	}
; 19617: 
; 19618: 	LPOBJ lpObj = &gObj[iIndex];

  0015f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00164	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0016a	03 c6		 add	 eax, esi

; 19619: 
; 19620: 	if ( PacketCheckTime(lpObj) == FALSE )

  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00172	83 c4 04	 add	 esp, 4
  00175	85 c0		 test	 eax, eax
  00177	75 0f		 jne	 SHORT $LN5@CGReqMapSv

; 19621: 	{
; 19622: 		LogAdd(lMsg.Get(MSGGET(1, 217)), iIndex, id);

  00179	8b 75 d8	 mov	 esi, DWORD PTR _iIndex$GSCopy$[ebp]
  0017c	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  0017f	51		 push	 ecx
  00180	56		 push	 esi
  00181	68 d9 01 00 00	 push	 473			; 000001d9H

; 19623: 		CloseClient(iIndex);
; 19624: 		return;

  00186	eb 18		 jmp	 SHORT $LN18@CGReqMapSv
$LN5@CGReqMapSv:

; 19625: 	}
; 19626: 
; 19627: 	if ( gObj[iIndex].Connected != PLAYER_CONNECTED )

  00188	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018d	39 5c 06 04	 cmp	 DWORD PTR [esi+eax+4], ebx
  00191	74 38		 je	 SHORT $LN4@CGReqMapSv

; 19628: 	{
; 19629: 		LogAdd(lMsg.Get(MSGGET(1, 218)), iIndex, id);

  00193	8b 75 d8	 mov	 esi, DWORD PTR _iIndex$GSCopy$[ebp]
  00196	8d 55 f0	 lea	 edx, DWORD PTR _id$[ebp]
  00199	52		 push	 edx
  0019a	56		 push	 esi
  0019b	68 da 01 00 00	 push	 474			; 000001daH
$LN18@CGReqMapSv:
  001a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001a5	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001aa	50		 push	 eax
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 19630: 		CloseClient(iIndex);

  001b1	56		 push	 esi
  001b2	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 19637: 		{
; 19638: 			LogAdd(lMsg.Get(MSGGET(1, 219)), iIndex, id, gObj[iIndex].Ip_addr);

  001b7	83 c4 10	 add	 esp, 16			; 00000010H
  001ba	5b		 pop	 ebx
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi

; 19663: 
; 19664: 
; 19665: }

  001bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
$LN4@CGReqMapSv:

; 19631: 		return;
; 19632: 	}
; 19633: 
; 19634: 	if ( gObj[iIndex].LoginMsgSnd != 0 )

  001cb	8a 4c 06 08	 mov	 cl, BYTE PTR [esi+eax+8]
  001cf	84 c9		 test	 cl, cl
  001d1	74 51		 je	 SHORT $LN3@CGReqMapSv

; 19635: 	{
; 19636: 		if ( gObj[iIndex].LoginMsgSnd == 1 )

  001d3	80 f9 01	 cmp	 cl, 1
  001d6	75 37		 jne	 SHORT $LN2@CGReqMapSv

; 19637: 		{
; 19638: 			LogAdd(lMsg.Get(MSGGET(1, 219)), iIndex, id, gObj[iIndex].Ip_addr);

  001d8	8b 55 d8	 mov	 edx, DWORD PTR _iIndex$GSCopy$[ebp]
  001db	8d 44 06 18	 lea	 eax, DWORD PTR [esi+eax+24]
  001df	50		 push	 eax
  001e0	8d 4d f0	 lea	 ecx, DWORD PTR _id$[ebp]
  001e3	51		 push	 ecx
  001e4	52		 push	 edx
  001e5	68 db 01 00 00	 push	 475			; 000001dbH
  001ea	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001ef	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  001f4	50		 push	 eax
$LN19@CGReqMapSv:
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001fb	83 c4 10	 add	 esp, 16			; 00000010H
  001fe	5b		 pop	 ebx
  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi

; 19663: 
; 19664: 
; 19665: }

  00201	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00204	33 cd		 xor	 ecx, ebp
  00206	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
$LN2@CGReqMapSv:

; 19639: 		}
; 19640: 		else
; 19641: 		{
; 19642: 			LogAdd("error : %d %s %d", gObj[iIndex].LoginMsgSnd, __FILE__, __LINE__);

  0020f	68 ba 4c 00 00	 push	 19642			; 00004cbaH
  00214	0f be c1	 movsx	 eax, cl
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0021c	50		 push	 eax
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@

; 19643: 		}
; 19644: 
; 19645: 		return;

  00222	eb d1		 jmp	 SHORT $LN19@CGReqMapSv
$LN3@CGReqMapSv:

; 19646: 	}
; 19647: 
; 19648: 	gObj[iIndex].CheckTick = lpMsg->iTickCount;

  00224	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]

; 19649: 	gObj[iIndex].CheckTick2 = GetTickCount();

  00227	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0022d	89 4c 06 40	 mov	 DWORD PTR [esi+eax+64], ecx
  00231	ff d3		 call	 ebx
  00233	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00239	89 44 16 48	 mov	 DWORD PTR [esi+edx+72], eax

; 19650: 	gObj[iIndex].ConnectCheckTime = GetTickCount(); 

  0023d	ff d3		 call	 ebx
  0023f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00245	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax

; 19651: 	gObj[iIndex].CheckSpeedHack = true;

  00249	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024f	c6 44 16 44 01	 mov	 BYTE PTR [esi+edx+68], 1

; 19652: 	gObj[iIndex].ConnectCheckTime = GetTickCount();

  00254	ff d3		 call	 ebx
  00256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025c	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax

; 19653: 	gObj[iIndex].LoginMsgSnd = 1;

  00260	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00266	c6 44 16 08 01	 mov	 BYTE PTR [esi+edx+8], 1

; 19654: 	gObj[iIndex].LoginMsgCount++;

  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00270	fe 44 06 09	 inc	 BYTE PTR [esi+eax+9]

; 19655: 	gObj[iIndex].AccountID[MAX_ACCOUNT_LEN] = 0;

  00274	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00279	c6 44 06 76 00	 mov	 BYTE PTR [esi+eax+118], 0

; 19656: 	memcpy(gObj[iIndex].AccountID, id, MAX_ACCOUNT_LEN);

  0027e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00284	8b 55 f0	 mov	 edx, DWORD PTR _id$[ebp]
  00287	89 54 0e 6c	 mov	 DWORD PTR [esi+ecx+108], edx
  0028b	8d 44 0e 6c	 lea	 eax, DWORD PTR [esi+ecx+108]
  0028f	8b 4d f4	 mov	 ecx, DWORD PTR _id$[ebp+4]
  00292	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00295	66 8b 55 f8	 mov	 dx, WORD PTR _id$[ebp+8]
  00299	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 19657: 	memset(gObj[iIndex].Name, 0, MAX_ACCOUNT_LEN);

  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a3	33 c0		 xor	 eax, eax
  002a5	89 44 0e 77	 mov	 DWORD PTR [esi+ecx+119], eax
  002a9	89 44 0e 7b	 mov	 DWORD PTR [esi+ecx+123], eax
  002ad	8d 4c 0e 77	 lea	 ecx, DWORD PTR [esi+ecx+119]
  002b1	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 19658: 	gObj[iIndex].m_cAccountItemBlock = 0;

  002b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bb	88 84 16 14 02
	00 00		 mov	 BYTE PTR [esi+edx+532], al

; 19659: 	gObj[iIndex].ukn_30 = 0; //season4.5 add-on

  002c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c8	89 44 0e 30	 mov	 DWORD PTR [esi+ecx+48], eax

; 19660: 	GJReqMapSvrAuth(iIndex, gObj[iIndex].AccountID, lpMsg->szCharName, lpMsg->iJoinAuthCode1, lpMsg->iJoinAuthCode2, lpMsg->iJoinAuthCode3, lpMsg->iJoinAuthCode4);

  002cc	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  002cf	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  002d2	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  002d5	52		 push	 edx
  002d6	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  002d9	50		 push	 eax
  002da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002df	51		 push	 ecx
  002e0	52		 push	 edx
  002e1	83 c7 10	 add	 edi, 16			; 00000010H
  002e4	57		 push	 edi
  002e5	8b 7d d8	 mov	 edi, DWORD PTR _iIndex$GSCopy$[ebp]
  002e8	8d 4c 06 6c	 lea	 ecx, DWORD PTR [esi+eax+108]
  002ec	51		 push	 ecx
  002ed	57		 push	 edi
  002ee	e8 00 00 00 00	 call	 ?GJReqMapSvrAuth@@YAXHPAD0HHHH@Z ; GJReqMapSvrAuth

; 19661: 
; 19662: 	LogAddTD("[MapServerMng] Map Server Join Send : [%s][%s](%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);

  002f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f8	57		 push	 edi
  002f9	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  002fd	52		 push	 edx
  002fe	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00302	50		 push	 eax
  00303	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@
  00308	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0030e	83 c4 2c	 add	 esp, 44			; 0000002cH
  00311	5b		 pop	 ebx
  00312	5f		 pop	 edi
  00313	5e		 pop	 esi

; 19663: 
; 19664: 
; 19665: }

  00314	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00317	33 cd		 xor	 ecx, ebp
  00319	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031e	8b e5		 mov	 esp, ebp
  00320	5d		 pop	 ebp
  00321	c3		 ret	 0
$LN9@CGReqMapSv:

; 19586: 	{
; 19587: 		GCAnsMapSvrAuth(iIndex, 6);

  00322	6a 06		 push	 6
  00324	56		 push	 esi
  00325	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth

; 19588: 		CloseClient(iIndex);

  0032a	56		 push	 esi
  0032b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 19663: 
; 19664: 
; 19665: }

  00330	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00333	83 c4 0c	 add	 esp, 12			; 0000000cH
  00336	5f		 pop	 edi
  00337	33 cd		 xor	 ecx, ebp
  00339	5e		 pop	 esi
  0033a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0033f	8b e5		 mov	 esp, ebp
  00341	5d		 pop	 ebp
  00342	c3		 ret	 0
?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ENDP ; CGReqMapSvrAuth
_TEXT	ENDS
PUBLIC	?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ; CGReqRegCastleSiege
EXTRN	?GS_GDReqRegAttackGuild@@YAXHH@Z:PROC		; GS_GDReqRegAttackGuild
EXTRN	?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckUnionGuildMaster
; Function compile flags: /Ogtp
;	COMDAT ?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z PROC ; CGReqRegCastleSiege, COMDAT

; 19757: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19758: //#if (GS_CASTLE==1)
; 19759: 	if( g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGSIEGE )

  00003	83 3d 28 00 00
	00 01		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 1
  0000a	74 15		 je	 SHORT $LN7@CGReqRegCa

; 19760: 	{
; 19761: 		GCAnsRegCastleSiege(iIndex, 7, "");

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00014	6a 07		 push	 7
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19781: 	}
; 19782: //#endif
; 19783: }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN7@CGReqRegCa:

; 19762: 		return;
; 19763: 	}
; 19764: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	56		 push	 esi
  00027	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0002a	8b d6		 mov	 edx, esi
  0002c	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00037	8d 84 02 3c 04
	00 00		 lea	 eax, DWORD PTR [edx+eax+1084]
  0003e	8b ff		 npad	 2
$LL15@CGReqRegCa:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN16@CGReqRegCa
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN17@CGReqRegCa
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN16@CGReqRegCa
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL15@CGReqRegCa
$LN17@CGReqRegCa:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN18@CGReqRegCa
$LN16@CGReqRegCa:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
$LN18@CGReqRegCa:
  00065	85 c0		 test	 eax, eax
  00067	75 13		 jne	 SHORT $LN6@CGReqRegCa

; 19765: 	{
; 19766: 		GCAnsRegCastleSiege(iIndex, 6, "");

  00069	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006e	6a 06		 push	 6

; 19775: 	{
; 19776: 		GCAnsRegCastleSiege(iIndex, 3, "");

  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	5e		 pop	 esi

; 19781: 	}
; 19782: //#endif
; 19783: }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN6@CGReqRegCa:

; 19767: 		return;
; 19768: 	}
; 19769: 	if( g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE )

  0007c	56		 push	 esi
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00082	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00087	85 c0		 test	 eax, eax
  00089	75 12		 jne	 SHORT $LN5@CGReqRegCa

; 19770: 	{
; 19771: 		GCAnsRegCastleSiege(iIndex, 0, "");

  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00090	50		 push	 eax

; 19775: 	{
; 19776: 		GCAnsRegCastleSiege(iIndex, 3, "");

  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	5e		 pop	 esi

; 19781: 	}
; 19782: //#endif
; 19783: }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
$LN5@CGReqRegCa:

; 19772: 	}
; 19773: 	else if( (g_CastleSiege.CheckCastleOwnerMember(iIndex) != FALSE) || 
; 19774: 		(g_CastleSiege.CheckCastleOwnerUnionMember(iIndex) != FALSE) )

  0009d	56		 push	 esi
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a3	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  000a8	85 c0		 test	 eax, eax
  000aa	75 39		 jne	 SHORT $LN2@CGReqRegCa
  000ac	56		 push	 esi
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b2	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  000b7	85 c0		 test	 eax, eax
  000b9	75 2a		 jne	 SHORT $LN2@CGReqRegCa

; 19777: 	}
; 19778: 	else
; 19779: 	{
; 19780: 		GS_GDReqRegAttackGuild(g_MapServerManager.GetMapSvrGroup(), iIndex);

  000bb	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  000c0	85 c0		 test	 eax, eax
  000c2	74 11		 je	 SHORT $LN12@CGReqRegCa
  000c4	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  000c8	56		 push	 esi
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?GS_GDReqRegAttackGuild@@YAXHH@Z ; GS_GDReqRegAttackGuild
  000cf	83 c4 08	 add	 esp, 8
  000d2	5e		 pop	 esi

; 19781: 	}
; 19782: //#endif
; 19783: }

  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0

; 19777: 	}
; 19778: 	else
; 19779: 	{
; 19780: 		GS_GDReqRegAttackGuild(g_MapServerManager.GetMapSvrGroup(), iIndex);

$LN12@CGReqRegCa:
  000d5	83 c8 ff	 or	 eax, -1
  000d8	56		 push	 esi
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?GS_GDReqRegAttackGuild@@YAXHH@Z ; GS_GDReqRegAttackGuild
  000df	83 c4 08	 add	 esp, 8
  000e2	5e		 pop	 esi

; 19781: 	}
; 19782: //#endif
; 19783: }

  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN2@CGReqRegCa:

; 19775: 	{
; 19776: 		GCAnsRegCastleSiege(iIndex, 3, "");

  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000ea	6a 03		 push	 3
  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f5	5e		 pop	 esi

; 19781: 	}
; 19782: //#endif
; 19783: }

  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ENDP ; CGReqRegCastleSiege
_TEXT	ENDS
PUBLIC	?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ; CGReqGiveUpCastleSiege
EXTRN	?GS_GDReqGuildSetGiveUp@@YAXHHH@Z:PROC		; GS_GDReqGuildSetGiveUp
; Function compile flags: /Ogtp
;	COMDAT ?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z PROC ; CGReqGiveUpCastleSiege, COMDAT

; 19815: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19816: //#if(GS_CASTLE==1)
; 19817: 	if( (g_CastleSiege.GetCastleState() < CASTLESIEGE_STATE_REGSIEGE) || (g_CastleSiege.GetCastleState() > CASTLESIEGE_STATE_REGMARK) ) //Fixed

  00003	a1 28 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40
  00008	48		 dec	 eax
  00009	83 f8 02	 cmp	 eax, 2
  0000c	0f 87 7d 00 00
	00		 ja	 $LN3@CGReqGiveU@2

; 19820: 		return;
; 19821: 	}
; 19822: 
; 19823: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	8b d6		 mov	 edx, esi
  0001d	69 d2 50 2b 00
	00		 imul	 edx, 11088		; 00002b50H
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00028	8d 84 02 3c 04
	00 00		 lea	 eax, DWORD PTR [edx+eax+1084]
  0002f	90		 npad	 1
$LL14@CGReqGiveU@2:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN15@CGReqGiveU@2
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN16@CGReqGiveU@2
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN15@CGReqGiveU@2
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL14@CGReqGiveU@2
$LN16@CGReqGiveU@2:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN17@CGReqGiveU@2
$LN15@CGReqGiveU@2:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN17@CGReqGiveU@2:
  00055	85 c0		 test	 eax, eax
  00057	74 33		 je	 SHORT $LN18@CGReqGiveU@2

; 19824: 	{
; 19825: 		return;
; 19826: 	}
; 19827: 	
; 19828: 	if( g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE )

  00059	56		 push	 esi
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0005f	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00064	85 c0		 test	 eax, eax
  00066	74 24		 je	 SHORT $LN18@CGReqGiveU@2

; 19829: 	{
; 19830: 		return;
; 19831: 	}
; 19832: 
; 19833: 	GS_GDReqGuildSetGiveUp(g_MapServerManager.GetMapSvrGroup(), iIndex, lpMsg->btGiveUp);

  00068	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  0006d	85 c0		 test	 eax, eax
  0006f	74 06		 je	 SHORT $LN11@CGReqGiveU@2
  00071	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00075	eb 03		 jmp	 SHORT $LN12@CGReqGiveU@2
$LN11@CGReqGiveU@2:
  00077	83 c8 ff	 or	 eax, -1
$LN12@CGReqGiveU@2:
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0007d	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00081	52		 push	 edx
  00082	56		 push	 esi
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?GS_GDReqGuildSetGiveUp@@YAXHHH@Z ; GS_GDReqGuildSetGiveUp
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGReqGiveU@2:
  0008c	5e		 pop	 esi

; 19834: //#endif
; 19835: }

  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
$LN3@CGReqGiveU@2:

; 19818: 	{
; 19819: 		GCAnsGiveUpCastleSiege(iIndex, 3, 0, 0, "");

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00097	6a 00		 push	 0
  00099	6a 00		 push	 0
  0009b	6a 03		 push	 3
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ?GCAnsGiveUpCastleSiege@@YAXHHHHPAD@Z ; GCAnsGiveUpCastleSiege
  000a3	83 c4 14	 add	 esp, 20			; 00000014H

; 19834: //#endif
; 19835: }

  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ENDP ; CGReqGiveUpCastleSiege
_TEXT	ENDS
PUBLIC	??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ ; `string'
PUBLIC	??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@ ; `string'
PUBLIC	??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ ; `string'
PUBLIC	?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z	; CGReqNpcBuy
EXTRN	?CheckAddDbNPC@CCastleSiege@@QAEHHHHAAE@Z:PROC	; CCastleSiege::CheckAddDbNPC
;	COMDAT ??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
CONST	SEGMENT
??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ DB '[C'
	DB	'astleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@
CONST	SEGMENT
??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@ DB '['
	DB	'CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc'
	DB	':(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
CONST	SEGMENT
??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ DB '[C'
	DB	'astleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC'
	DB	'() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_btResult$251697 = 11					; size = 1
_iIndex$ = 12						; size = 4
?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z PROC		; CGReqNpcBuy, COMDAT

; 20064: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 20065: //#if (GS_CASTLE==1)
; 20066: 	if( lpMsg == NULL )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 84 67 01 00
	00		 je	 $LN1@CGReqNpcBu

; 20067: 	{
; 20068: 		return;
; 20069: 	}
; 20070: 
; 20071: 	if( ::gObjIsConnected(iIndex) == FALSE )

  0000f	56		 push	 esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 51 01 00
	00		 je	 $LN15@CGReqNpcBu

; 20072: 	{
; 20073: 		return;
; 20074: 	}
; 20075: 
; 20076: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0002f	53		 push	 ebx
  00030	8d 9c 06 3c 04
	00 00		 lea	 ebx, DWORD PTR [esi+eax+1084]
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003c	8b c3		 mov	 eax, ebx
  0003e	8b ff		 npad	 2
$LL11@CGReqNpcBu:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN12@CGReqNpcBu
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN13@CGReqNpcBu
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN12@CGReqNpcBu
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL11@CGReqNpcBu
$LN13@CGReqNpcBu:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN14@CGReqNpcBu
$LN12@CGReqNpcBu:
  00060	1b c0		 sbb	 eax, eax
  00062	83 d8 ff	 sbb	 eax, -1
$LN14@CGReqNpcBu:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 07 01 00
	00		 je	 $LN16@CGReqNpcBu

; 20077: 	{
; 20078: 		return;
; 20079: 	}
; 20080: 
; 20081: 	if( g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE || (gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER) )

  0006d	53		 push	 ebx
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00073	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00078	85 c0		 test	 eax, eax
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	0f 84 bd 00 00
	00		 je	 $LN4@CGReqNpcBu
  00085	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  0008c	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00092	74 09		 je	 SHORT $LN5@CGReqNpcBu
  00094	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00097	0f 85 a5 00 00
	00		 jne	 $LN4@CGReqNpcBu
$LN5@CGReqNpcBu:

; 20084: 	}
; 20085: 	else
; 20086: 	{
; 20087: 		BYTE btResult = 0;
; 20088: 
; 20089: 		BOOL bRETVAL = g_CastleSiege.CheckAddDbNPC(iIndex, lpMsg->iNpcNumber, lpMsg->iNpcIndex, btResult);

  0009d	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000a0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000a3	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  000a6	8d 4d 0b	 lea	 ecx, DWORD PTR _btResult$251697[ebp]
  000a9	51		 push	 ecx
  000aa	52		 push	 edx
  000ab	50		 push	 eax
  000ac	53		 push	 ebx
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b2	c6 45 0b 00	 mov	 BYTE PTR _btResult$251697[ebp], 0
  000b6	e8 00 00 00 00	 call	 ?CheckAddDbNPC@CCastleSiege@@QAEHHHHAAE@Z ; CCastleSiege::CheckAddDbNPC

; 20090: 
; 20091: 		if( bRETVAL == FALSE )
; 20092: 		{
; 20093: 			GCAnsNpcBuy(iIndex, btResult, lpMsg->iNpcNumber, lpMsg->iNpcIndex);

  000bb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000be	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000c1	51		 push	 ecx
  000c2	52		 push	 edx
  000c3	85 c0		 test	 eax, eax
  000c5	75 47		 jne	 SHORT $LN2@CGReqNpcBu
  000c7	0f b6 45 0b	 movzx	 eax, BYTE PTR _btResult$251697[ebp]
  000cb	50		 push	 eax
  000cc	53		 push	 ebx
  000cd	e8 00 00 00 00	 call	 ?GCAnsNpcBuy@@YAXHHHH@Z	; GCAnsNpcBuy

; 20094: 			LogAddC(2, "[CastleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d7	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000da	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000dd	51		 push	 ecx
  000de	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  000e5	52		 push	 edx
  000e6	51		 push	 ecx
  000e7	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  000ee	52		 push	 edx
  000ef	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000f3	51		 push	 ecx
  000f4	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000f8	52		 push	 edx
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
  000fe	6a 02		 push	 2
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00106	83 c4 30	 add	 esp, 48			; 00000030H
  00109	5b		 pop	 ebx
  0010a	5e		 pop	 esi
  0010b	5f		 pop	 edi

; 20099: 		}
; 20100: 	}
; 20101: //#endif
; 20102: }

  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN2@CGReqNpcBu:

; 20095: 		}
; 20096: 		else
; 20097: 		{
; 20098: 			LogAddC(2, "[CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00113	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  0011a	51		 push	 ecx
  0011b	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  00122	52		 push	 edx
  00123	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00127	51		 push	 ecx
  00128	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0012c	52		 push	 edx
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@
  00132	6a 02		 push	 2
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0013a	83 c4 20	 add	 esp, 32			; 00000020H
  0013d	5b		 pop	 ebx
  0013e	5e		 pop	 esi
  0013f	5f		 pop	 edi

; 20099: 		}
; 20100: 	}
; 20101: //#endif
; 20102: }

  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN4@CGReqNpcBu:

; 20082: 	{
; 20083: 		LogAddC(2, "[CastleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  00142	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00145	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00148	51		 push	 ecx
  00149	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  00150	52		 push	 edx
  00151	51		 push	 ecx
  00152	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  00159	52		 push	 edx
  0015a	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  0015e	51		 push	 ecx
  0015f	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00163	52		 push	 edx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
  00169	6a 02		 push	 2
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00171	83 c4 20	 add	 esp, 32			; 00000020H
$LN16@CGReqNpcBu:
  00174	5b		 pop	 ebx
$LN15@CGReqNpcBu:
  00175	5e		 pop	 esi
$LN1@CGReqNpcBu:
  00176	5f		 pop	 edi

; 20099: 		}
; 20100: 	}
; 20101: //#endif
; 20102: }

  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z ENDP		; CGReqNpcBuy
_TEXT	ENDS
PUBLIC	??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@ ; `string'
PUBLIC	??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fd3333340000000
PUBLIC	??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z	; CGReqNpcRepair
EXTRN	?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z:PROC	; GS_GDReqCastleNpcRepair
EXTRN	??1_CS_NPC_DATA@@UAE@XZ:PROC			; _CS_NPC_DATA::~_CS_NPC_DATA
EXTRN	?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z:PROC ; CCastleSiege::GetNpcData
EXTRN	??0_CS_NPC_DATA@@QAE@XZ:PROC			; _CS_NPC_DATA::_CS_NPC_DATA
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
CONST	SEGMENT
??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s],'
	DB	' Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@
CONST	SEGMENT
??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), N'
	DB	'pc:(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Money isn''t enough [%s]'
	DB	'[%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd3333340000000
CONST	SEGMENT
__real@3fd3333340000000 DQ 03fd3333340000000r	; 0.3
CONST	ENDS
;	COMDAT ??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch '
	DB	'[%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s]'
	DB	', Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z$0
__ehfuncinfo$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
xdata$x	ENDS
;	COMDAT ?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
_TEXT	SEGMENT
_pNpcData$ = -132					; size = 116
tv497 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv499 = 8						; size = 4
tv488 = 8						; size = 4
tv486 = 8						; size = 4
tv285 = 8						; size = 4
_iRepairCost$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z PROC	; CGReqNpcRepair, COMDAT

; 20118: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 20119: //#if (GS_CASTLE==1)
; 20120: 	if( lpMsg == NULL )

  00028	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002b	85 ff		 test	 edi, edi
  0002d	0f 84 7b 03 00
	00		 je	 $LN22@CGReqNpcRe

; 20121: 	{
; 20122: 		return;
; 20123: 	}
; 20124: 
; 20125: 	if( ::gObjIsConnected(iIndex) == FALSE )

  00033	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 67 03 00
	00		 je	 $LN22@CGReqNpcRe

; 20126: 	{
; 20127: 		return;
; 20128: 	}
; 20129: 
; 20130: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00052	8d 9c 06 3c 04
	00 00		 lea	 ebx, DWORD PTR [esi+eax+1084]
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005e	8b c3		 mov	 eax, ebx
$LL28@CGReqNpcRe:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00064	75 1a		 jne	 SHORT $LN29@CGReqNpcRe
  00066	84 d2		 test	 dl, dl
  00068	74 12		 je	 SHORT $LN30@CGReqNpcRe
  0006a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00070	75 0e		 jne	 SHORT $LN29@CGReqNpcRe
  00072	83 c0 02	 add	 eax, 2
  00075	83 c1 02	 add	 ecx, 2
  00078	84 d2		 test	 dl, dl
  0007a	75 e4		 jne	 SHORT $LL28@CGReqNpcRe
$LN30@CGReqNpcRe:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN31@CGReqNpcRe
$LN29@CGReqNpcRe:
  00080	1b c0		 sbb	 eax, eax
  00082	83 d8 ff	 sbb	 eax, -1
$LN31@CGReqNpcRe:
  00085	85 c0		 test	 eax, eax
  00087	0f 84 21 03 00
	00		 je	 $LN22@CGReqNpcRe

; 20131: 	{
; 20132: 		return;
; 20133: 	}
; 20134: 
; 20135: 	if( (g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) && (gObj[iIndex].GuildStatus != G_SUB_MASTER) )

  0008d	53		 push	 ebx
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00093	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00098	85 c0		 test	 eax, eax
  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009f	0f 84 df 02 00
	00		 je	 $LN17@CGReqNpcRe
  000a5	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  000ac	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000b2	74 09		 je	 SHORT $LN18@CGReqNpcRe
  000b4	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000b7	0f 85 c7 02 00
	00		 jne	 $LN17@CGReqNpcRe
$LN18@CGReqNpcRe:

; 20138: 		return;
; 20139: 	}
; 20140: 
; 20141: 	_CS_NPC_DATA pNpcData;

  000bd	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  000c3	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 20142: 	BOOL bRETVAL;
; 20143: 	int iNpcIndex;
; 20144: 	int iRepairCost;
; 20145: 
; 20146: 	bRETVAL = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber, lpMsg->iNpcIndex,pNpcData);

  000c8	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000cb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ce	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  000d4	51		 push	 ecx
  000d5	52		 push	 edx
  000d6	50		 push	 eax
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000dc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e3	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 20147: 
; 20148: 	if( bRETVAL == FALSE )

  000e8	85 c0		 test	 eax, eax
  000ea	75 6f		 jne	 SHORT $LN16@CGReqNpcRe

; 20149: 	{
; 20150: 		GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);

  000ec	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000ef	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000f2	50		 push	 eax
  000f3	50		 push	 eax
  000f4	51		 push	 ecx
  000f5	52		 push	 edx
  000f6	50		 push	 eax
  000f7	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 20151: 		LogAddC(2, "[CastleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00105	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00108	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0010b	51		 push	 ecx
  0010c	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  0011c	52		 push	 edx
  0011d	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00121	51		 push	 ecx
  00122	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00126	52		 push	 edx
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
$LN34@CGReqNpcRe:
  0012c	6a 02		 push	 2
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00134	83 c4 38	 add	 esp, 56			; 00000038H
$LN35@CGReqNpcRe:

; 20152: 		return;

  00137	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  0013d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00144	e8 00 00 00 00	 call	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA

; 20205: 					//return;
; 20206: 				}
; 20207: 			}
; 20208: 		}
; 20209: 	}	
; 20210: //#endif
; 20211: }

  00149	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00153	59		 pop	 ecx
  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	5b		 pop	 ebx
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
$LN16@CGReqNpcRe:

; 20153: 	}
; 20154: 	else
; 20155: 	{
; 20156: 		iNpcIndex = pNpcData.m_iNPC_OBJINDEX;

  0015b	8b 5d 94	 mov	 ebx, DWORD PTR _pNpcData$[ebp+24]

; 20157: 
; 20158: 		if( gObjIsConnected(iNpcIndex) == FALSE )

  0015e	53		 push	 ebx
  0015f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00164	83 c4 04	 add	 esp, 4
  00167	85 c0		 test	 eax, eax
  00169	75 46		 jne	 SHORT $LN14@CGReqNpcRe

; 20159: 		{
; 20160: 			GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);

  0016b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0016e	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00171	50		 push	 eax
  00172	50		 push	 eax
  00173	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00176	50		 push	 eax
  00177	51		 push	 ecx
  00178	6a 00		 push	 0
  0017a	52		 push	 edx
$LN36@CGReqNpcRe:
  0017b	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 20161: 			LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00185	8b 4d 88	 mov	 ecx, DWORD PTR _pNpcData$[ebp+12]
  00188	8b 55 84	 mov	 edx, DWORD PTR _pNpcData$[ebp+8]
  0018b	51		 push	 ecx
  0018c	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  00193	52		 push	 edx
  00194	51		 push	 ecx
  00195	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  0019c	52		 push	 edx
  0019d	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  001a1	51		 push	 ecx
  001a2	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  001a6	52		 push	 edx
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@

; 20162: 			return;

  001ac	e9 7b ff ff ff	 jmp	 $LN34@CGReqNpcRe
$LN14@CGReqNpcRe:

; 20163: 		}
; 20164: 		else if( gObj[iNpcIndex].Live == 0 )

  001b1	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  001b7	89 5d 08	 mov	 DWORD PTR tv285[ebp], ebx
  001ba	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR tv285[ebp]
  001c3	03 cb		 add	 ecx, ebx
  001c5	80 79 6a 00	 cmp	 BYTE PTR [ecx+106], 0
  001c9	75 14		 jne	 SHORT $LN12@CGReqNpcRe

; 20165: 		{
; 20166: 			GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);

  001cb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001ce	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  001d1	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001d4	6a 00		 push	 0
  001d6	6a 00		 push	 0
  001d8	51		 push	 ecx
  001d9	52		 push	 edx
  001da	6a 00		 push	 0
  001dc	50		 push	 eax

; 20167: 			LogAddC(2, "[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);
; 20168: 			return;

  001dd	eb 9c		 jmp	 SHORT $LN36@CGReqNpcRe
$LN12@CGReqNpcRe:

; 20169: 		}
; 20170: 		else
; 20171: 		{
; 20172: 			if( (gObj[iNpcIndex].MaxLife == gObj[iNpcIndex].Life) || (gObj[iNpcIndex].MaxLife < gObj[iNpcIndex].Life) )

  001df	d9 81 00 01 00
	00		 fld	 DWORD PTR [ecx+256]
  001e5	d9 81 fc 00 00
	00		 fld	 DWORD PTR [ecx+252]
  001eb	da e9		 fucompp
  001ed	df e0		 fnstsw	 ax
  001ef	f6 c4 44	 test	 ah, 68			; 00000044H
  001f2	0f 8b 61 01 00
	00		 jnp	 $LN9@CGReqNpcRe
  001f8	d9 81 00 01 00
	00		 fld	 DWORD PTR [ecx+256]
  001fe	d9 81 fc 00 00
	00		 fld	 DWORD PTR [ecx+252]
  00204	de d9		 fcompp
  00206	df e0		 fnstsw	 ax
  00208	f6 c4 41	 test	 ah, 65			; 00000041H
  0020b	0f 84 48 01 00
	00		 je	 $LN9@CGReqNpcRe

; 20177: 			}
; 20178: 			else
; 20179: 			{
; 20180: 				iRepairCost = 0;
; 20181: 
; 20182: 				switch( lpMsg->iNpcNumber )

  00211	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00214	8b d0		 mov	 edx, eax
  00216	81 ea 15 01 00
	00		 sub	 edx, 277		; 00000115H
  0021c	74 53		 je	 SHORT $LN5@CGReqNpcRe
  0021e	83 ea 06	 sub	 edx, 6
  00221	74 1c		 je	 SHORT $LN4@CGReqNpcRe

; 20190: 					default:
; 20191: 						GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);

  00223	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00226	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	51		 push	 ecx
  0022e	50		 push	 eax
  0022f	6a 00		 push	 0
  00231	52		 push	 edx
  00232	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair
  00237	83 c4 18	 add	 esp, 24			; 00000018H

; 20192: 						return;

  0023a	e9 f8 fe ff ff	 jmp	 $LN35@CGReqNpcRe
$LN4@CGReqNpcRe:

; 20186: 						break;
; 20187: 					case 283:
; 20188: 							iRepairCost	= (gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life)* 0.3f + float((gObj[iNpcIndex].m_btCsNpcDfLevel + gObj[iNpcIndex].m_btCsNpcRgLevel) * 1000000);

  0023f	0f b6 81 01 1c
	00 00		 movzx	 eax, BYTE PTR [ecx+7169]
  00246	0f b6 91 00 1c
	00 00		 movzx	 edx, BYTE PTR [ecx+7168]
  0024d	03 c2		 add	 eax, edx
  0024f	69 c0 40 42 0f
	00		 imul	 eax, 1000000		; 000f4240H
  00255	89 45 08	 mov	 DWORD PTR tv499[ebp], eax
  00258	db 45 08	 fild	 DWORD PTR tv499[ebp]
  0025b	d9 81 00 01 00
	00		 fld	 DWORD PTR [ecx+256]
  00261	d8 a1 fc 00 00
	00		 fsub	 DWORD PTR [ecx+252]
  00267	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd3333340000000
  0026d	de c1		 faddp	 ST(1), ST(0)

; 20189: 						break;

  0026f	eb 2b		 jmp	 SHORT $LN33@CGReqNpcRe
$LN5@CGReqNpcRe:

; 20183: 				{
; 20184: 					case 277:
; 20185: 							iRepairCost	= float((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life) * 0.5f) + float(gObj[iNpcIndex].m_btCsNpcDfLevel * 1000000);

  00271	0f b6 81 00 1c
	00 00		 movzx	 eax, BYTE PTR [ecx+7168]
  00278	d9 81 00 01 00
	00		 fld	 DWORD PTR [ecx+256]
  0027e	d8 a1 fc 00 00
	00		 fsub	 DWORD PTR [ecx+252]
  00284	69 c0 40 42 0f
	00		 imul	 eax, 1000000		; 000f4240H
  0028a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00290	d9 5d 08	 fstp	 DWORD PTR tv488[ebp]
  00293	d9 45 08	 fld	 DWORD PTR tv488[ebp]
  00296	89 45 08	 mov	 DWORD PTR tv486[ebp], eax
  00299	da 45 08	 fiadd	 DWORD PTR tv486[ebp]
$LN33@CGReqNpcRe:
  0029c	e8 00 00 00 00	 call	 __ftol2_sse

; 20193: 				}
; 20194: 
; 20195: 				if( gObj[iIndex].Money < iRepairCost )

  002a1	8b c8		 mov	 ecx, eax
  002a3	89 45 08	 mov	 DWORD PTR _iRepairCost$[ebp], eax
  002a6	39 8c 1e f0 00
	00 00		 cmp	 DWORD PTR [esi+ebx+240], ecx
  002ad	7d 48		 jge	 SHORT $LN2@CGReqNpcRe

; 20196: 				{
; 20197: 					GCAnsNpcRepair(iIndex, 3, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);

  002af	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  002b2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002b5	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  002b8	6a 00		 push	 0
  002ba	6a 00		 push	 0
  002bc	52		 push	 edx
  002bd	50		 push	 eax
  002be	6a 03		 push	 3
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 20198: 					LogAddC(2, "[CastleSiege] CGReqNpcRepair() ERROR - Money isn't enough [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);

  002c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cb	8b 55 88	 mov	 edx, DWORD PTR _pNpcData$[ebp+12]
  002ce	8b 4d 84	 mov	 ecx, DWORD PTR _pNpcData$[ebp+8]
  002d1	52		 push	 edx
  002d2	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  002d9	51		 push	 ecx
  002da	52		 push	 edx
  002db	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  002e2	51		 push	 ecx
  002e3	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  002e7	52		 push	 edx
  002e8	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  002ec	50		 push	 eax
  002ed	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@

; 20199: 					return;

  002f2	e9 35 fe ff ff	 jmp	 $LN34@CGReqNpcRe
$LN2@CGReqNpcRe:

; 20200: 				}
; 20201: 				else
; 20202: 				{
; 20203: 					LogAddC(2, "[CastleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);	

  002f7	8b 4d 88	 mov	 ecx, DWORD PTR _pNpcData$[ebp+12]
  002fa	8b 55 84	 mov	 edx, DWORD PTR _pNpcData$[ebp+8]
  002fd	8b 84 1e 48 04
	00 00		 mov	 eax, DWORD PTR [esi+ebx+1096]
  00304	51		 push	 ecx
  00305	52		 push	 edx
  00306	50		 push	 eax
  00307	8d 8c 1e 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+ebx+1084]
  0030e	51		 push	 ecx
  0030f	8d 54 1e 77	 lea	 edx, DWORD PTR [esi+ebx+119]
  00313	52		 push	 edx
  00314	8d 44 1e 6c	 lea	 eax, DWORD PTR [esi+ebx+108]
  00318	50		 push	 eax
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@
  0031e	6a 02		 push	 2
  00320	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 20204: 					GS_GDReqCastleNpcRepair(g_MapServerManager.GetMapSvrGroup(), iIndex, lpMsg->iNpcNumber, lpMsg->iNpcIndex, iRepairCost);

  00326	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  0032b	83 c4 20	 add	 esp, 32			; 00000020H
  0032e	85 c0		 test	 eax, eax
  00330	74 06		 je	 SHORT $LN25@CGReqNpcRe
  00332	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00336	eb 03		 jmp	 SHORT $LN26@CGReqNpcRe
$LN25@CGReqNpcRe:
  00338	83 c8 ff	 or	 eax, -1
$LN26@CGReqNpcRe:
  0033b	8b 4d 08	 mov	 ecx, DWORD PTR _iRepairCost$[ebp]
  0033e	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00341	51		 push	 ecx
  00342	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00345	52		 push	 edx
  00346	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00349	51		 push	 ecx
  0034a	52		 push	 edx
  0034b	50		 push	 eax
  0034c	e8 00 00 00 00	 call	 ?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z ; GS_GDReqCastleNpcRepair
  00351	83 c4 14	 add	 esp, 20			; 00000014H

; 20205: 					//return;
; 20206: 				}
; 20207: 			}
; 20208: 		}
; 20209: 	}	
; 20210: //#endif
; 20211: }

  00354	e9 de fd ff ff	 jmp	 $LN35@CGReqNpcRe
$LN9@CGReqNpcRe:

; 20173: 			{
; 20174: 				gObj[iNpcIndex].Life = gObj[iNpcIndex].MaxLife;

  00359	d9 81 00 01 00
	00		 fld	 DWORD PTR [ecx+256]

; 20175: 				GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);

  0035f	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00362	6a 00		 push	 0
  00364	d9 99 fc 00 00
	00		 fstp	 DWORD PTR [ecx+252]
  0036a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0036d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00370	6a 00		 push	 0
  00372	50		 push	 eax
  00373	51		 push	 ecx
  00374	6a 00		 push	 0
  00376	52		 push	 edx
  00377	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair
  0037c	83 c4 18	 add	 esp, 24			; 00000018H

; 20176: 				return;

  0037f	e9 b3 fd ff ff	 jmp	 $LN35@CGReqNpcRe
$LN17@CGReqNpcRe:

; 20136: 	{
; 20137: 		LogAddC(2, "[CastleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  00384	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  0038b	51		 push	 ecx
  0038c	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  00393	52		 push	 edx
  00394	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00398	51		 push	 ecx
  00399	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0039d	52		 push	 edx
  0039e	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  003a3	6a 02		 push	 2
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  003ab	83 c4 18	 add	 esp, 24			; 00000018H
$LN22@CGReqNpcRe:

; 20205: 					//return;
; 20206: 				}
; 20207: 			}
; 20208: 		}
; 20209: 	}	
; 20210: //#endif
; 20211: }

  003ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003b8	59		 pop	 ecx
  003b9	5f		 pop	 edi
  003ba	5e		 pop	 esi
  003bb	5b		 pop	 ebx
  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z$0:
  00000	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__ehhandler$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z ENDP	; CGReqNpcRepair
PUBLIC	??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@ ; `string'
PUBLIC	??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ; CGReqNpcUpgrade
EXTRN	?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z:PROC	; GS_GDReqCastleNpcUpgrade
EXTRN	?PayForUpgradeDbNpc@CCastleSiege@@QAEHHHHHHH@Z:PROC ; CCastleSiege::PayForUpgradeDbNpc
;	COMDAT ??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
CONST	SEGMENT
??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s]'
	DB	', Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[Ca'
	DB	'stleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d'
	DB	'), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@
CONST	SEGMENT
??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@ DB '['
	DB	'CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upg'
	DB	'rade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Gu'
	DB	'ild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:'
	DB	'%d, Gem:%d, Need Gem:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], '
	DB	'Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTL'
	DB	'V:%d, Money:%d, Need Money:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - UpType doesn''t Exist ['
	DB	'%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$1
__ehfuncinfo$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
xdata$x	ENDS
;	COMDAT ?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
_TEXT	SEGMENT
_m_NpcData$251780 = -256				; size = 116
_m_NpcData$251804 = -140				; size = 116
_iNXT_UPVALUE$ = -24					; size = 4
_iNEED_GEMOFDEFEND$ = -20				; size = 4
_iGEMOFDEFEND_COUNT$ = -16				; size = 4
_bENABLE_UPGRADE$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
tv1198 = 8						; size = 4
_iNEED_MONEY$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z PROC	; CGReqNpcUpgrade, COMDAT

; 20234: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 20235: //#if (GS_CASTLE==1)
; 20236: 
; 20237: 	if( lpMsg == NULL )

  0002b	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0002e	33 ff		 xor	 edi, edi
  00030	3b f7		 cmp	 esi, edi
  00032	0f 84 bd 06 00
	00		 je	 $LN1@CGReqNpcUp

; 20238: 	{
; 20239: 		return;
; 20240: 	}
; 20241: 
; 20242: 	if( ::gObjIsConnected(iIndex) == FALSE )

  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0003b	53		 push	 ebx
  0003c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00041	83 c4 04	 add	 esp, 4
  00044	85 c0		 test	 eax, eax
  00046	0f 84 a9 06 00
	00		 je	 $LN1@CGReqNpcUp

; 20243: 	{
; 20244: 		return;
; 20245: 	}
; 20246: 
; 20247: 	int iNEED_GEMOFDEFEND = 0; 
; 20248: 	int	iNEED_MONEY = 0;
; 20249: 	int	iCUR_UPLVL = 0;
; 20250: 	int	iNXT_UPLVL = 0; 
; 20251: 	int	iNXT_UPVALUE = 0;
; 20252: 	int	bENABLE_UPGRADE = FALSE;
; 20253: 
; 20254: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00057	8d 94 03 3c 04
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1084]
  0005e	89 7d ec	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], edi
  00061	89 7d 08	 mov	 DWORD PTR _iNEED_MONEY$[ebp], edi
  00064	89 7d e8	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
  00067	89 7d f0	 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], edi
  0006a	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006f	8b c2		 mov	 eax, edx
$LL109@CGReqNpcUp:
  00071	8a 08		 mov	 cl, BYTE PTR [eax]
  00073	3a 0f		 cmp	 cl, BYTE PTR [edi]
  00075	75 1d		 jne	 SHORT $LN110@CGReqNpcUp
  00077	84 c9		 test	 cl, cl
  00079	74 12		 je	 SHORT $LN111@CGReqNpcUp
  0007b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0007e	3a 4f 01	 cmp	 cl, BYTE PTR [edi+1]
  00081	75 11		 jne	 SHORT $LN110@CGReqNpcUp
  00083	83 c0 02	 add	 eax, 2
  00086	83 c7 02	 add	 edi, 2
  00089	84 c9		 test	 cl, cl
  0008b	75 e4		 jne	 SHORT $LL109@CGReqNpcUp
$LN111@CGReqNpcUp:
  0008d	33 c0		 xor	 eax, eax
  0008f	83 cf ff	 or	 edi, -1
  00092	eb 09		 jmp	 SHORT $LN112@CGReqNpcUp
$LN110@CGReqNpcUp:
  00094	1b c0		 sbb	 eax, eax
  00096	bf ff ff ff ff	 mov	 edi, -1
  0009b	1b c7		 sbb	 eax, edi
$LN112@CGReqNpcUp:
  0009d	85 c0		 test	 eax, eax
  0009f	0f 84 50 06 00
	00		 je	 $LN1@CGReqNpcUp

; 20255: 		return;
; 20256: 
; 20257: 	if( (g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )

  000a5	52		 push	 edx
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ab	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  000b0	85 c0		 test	 eax, eax
  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b7	0f 84 10 06 00
	00		 je	 $LN54@CGReqNpcUp
  000bd	81 bc 03 48 04
	00 00 80 00 00
	00		 cmp	 DWORD PTR [ebx+eax+1096], 128 ; 00000080H
  000c8	0f 85 ff 05 00
	00		 jne	 $LN54@CGReqNpcUp

; 20260: 		return;
; 20261: 	}
; 20262: 
; 20263: 	switch( lpMsg->iNpcNumber )

  000ce	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000d1	2d 15 01 00 00	 sub	 eax, 277		; 00000115H
  000d6	0f 84 1d 02 00
	00		 je	 $LN51@CGReqNpcUp
  000dc	83 e8 06	 sub	 eax, 6
  000df	0f 85 77 03 00
	00		 jne	 $LN104@CGReqNpcUp

; 20333: 		break;
; 20334: 		case 283://Statue
; 20335: 		{
; 20336: 			_CS_NPC_DATA m_NpcData;

  000e5	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]
  000eb	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 20337: 
; 20338: 			BOOL bResult;
; 20339: 			
; 20340: 			bResult	= g_CastleSiege.GetNpcData(lpMsg->iNpcNumber, lpMsg->iNpcIndex, m_NpcData);

  000f0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000f3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]
  000fc	51		 push	 ecx
  000fd	52		 push	 edx
  000fe	50		 push	 eax
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00104	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0010b	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 20341: 
; 20342: 			if( bResult )

  00110	85 c0		 test	 eax, eax
  00112	0f 84 a3 01 00
	00		 je	 $LN32@CGReqNpcUp

; 20343: 			{
; 20344: 				switch( lpMsg->iNpcUpType )

  00118	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0011b	8b c1		 mov	 eax, ecx
  0011d	48		 dec	 eax
  0011e	0f 84 55 01 00
	00		 je	 $LN29@CGReqNpcUp
  00124	48		 dec	 eax
  00125	0f 84 0b 01 00
	00		 je	 $LN27@CGReqNpcUp
  0012b	48		 dec	 eax
  0012c	74 75		 je	 SHORT $LN25@CGReqNpcUp

; 20405: 					default:
; 20406: 						{
; 20407: 							GCAnsNpcUpgrade(iIndex, 5, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);

  0012e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00131	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00134	52		 push	 edx
  00135	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00138	51		 push	 ecx
  00139	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0013c	50		 push	 eax
  0013d	51		 push	 ecx
  0013e	6a 05		 push	 5
  00140	52		 push	 edx
  00141	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 20408: 							LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - UpType doesn't Exist [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d", gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00146	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00149	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0014c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00151	51		 push	 ecx
  00152	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00155	52		 push	 edx
  00156	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00159	51		 push	 ecx
  0015a	8b 8c 03 34 04
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1076]
  00161	52		 push	 edx
  00162	51		 push	 ecx
  00163	8d 94 03 3c 04
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1084]
  0016a	52		 push	 edx
  0016b	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  0016f	51		 push	 ecx
  00170	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  00174	52		 push	 edx
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00180	83 c4 3c	 add	 esp, 60			; 0000003cH

; 20409: 							return;

  00183	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]
  00189	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  0018c	e8 00 00 00 00	 call	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  00191	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00194	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019b	59		 pop	 ecx
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
$LN25@CGReqNpcUp:

; 20371: 							}
; 20372: 						}
; 20373: 						break;
; 20374: 					case 3:
; 20375: 						{
; 20376: 							iCUR_UPLVL = 0;
; 20377: 
; 20378: 							for( int i = 0; i < 3; i++ )
; 20379: 							{
; 20380: 								if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CSTATUE[i] )

  001a3	8b 45 98	 mov	 eax, DWORD PTR _m_NpcData$251804[ebp+36]
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iNpcUpMaxHP_CSTATUE
  001ac	33 d2		 xor	 edx, edx
  001ae	3b c1		 cmp	 eax, ecx
  001b0	7c 05		 jl	 SHORT $LN23@CGReqNpcUp

; 20381: 								{
; 20382: 									iCUR_UPLVL = (i+1);

  001b2	ba 01 00 00 00	 mov	 edx, 1
$LN23@CGReqNpcUp:

; 20371: 							}
; 20372: 						}
; 20373: 						break;
; 20374: 					case 3:
; 20375: 						{
; 20376: 							iCUR_UPLVL = 0;
; 20377: 
; 20378: 							for( int i = 0; i < 3; i++ )
; 20379: 							{
; 20380: 								if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CSTATUE[i] )

  001b7	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CSTATUE+12
  001bd	7c 05		 jl	 SHORT $LN80@CGReqNpcUp

; 20381: 								{
; 20382: 									iCUR_UPLVL = (i+1);

  001bf	ba 02 00 00 00	 mov	 edx, 2
$LN80@CGReqNpcUp:

; 20371: 							}
; 20372: 						}
; 20373: 						break;
; 20374: 					case 3:
; 20375: 						{
; 20376: 							iCUR_UPLVL = 0;
; 20377: 
; 20378: 							for( int i = 0; i < 3; i++ )
; 20379: 							{
; 20380: 								if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CSTATUE[i] )

  001c4	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CSTATUE+24
  001ca	7c 05		 jl	 SHORT $LN82@CGReqNpcUp

; 20381: 								{
; 20382: 									iCUR_UPLVL = (i+1);

  001cc	ba 03 00 00 00	 mov	 edx, 3
$LN82@CGReqNpcUp:

; 20383: 								}
; 20384: 							}
; 20385: 
; 20386: 							iNXT_UPLVL = 0;
; 20387: 
; 20388: 							for(int i = 0; i < 3; i++ )
; 20389: 							{
; 20390: 								if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CSTATUE[i] )

  001d1	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001d4	33 ff		 xor	 edi, edi
  001d6	3b c1		 cmp	 eax, ecx
  001d8	7c 05		 jl	 SHORT $LN19@CGReqNpcUp

; 20391: 								{
; 20392: 									iNXT_UPLVL = (i+1);

  001da	bf 01 00 00 00	 mov	 edi, 1
$LN19@CGReqNpcUp:

; 20383: 								}
; 20384: 							}
; 20385: 
; 20386: 							iNXT_UPLVL = 0;
; 20387: 
; 20388: 							for(int i = 0; i < 3; i++ )
; 20389: 							{
; 20390: 								if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CSTATUE[i] )

  001df	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CSTATUE+12
  001e5	7c 05		 jl	 SHORT $LN87@CGReqNpcUp

; 20391: 								{
; 20392: 									iNXT_UPLVL = (i+1);

  001e7	bf 02 00 00 00	 mov	 edi, 2
$LN87@CGReqNpcUp:

; 20383: 								}
; 20384: 							}
; 20385: 
; 20386: 							iNXT_UPLVL = 0;
; 20387: 
; 20388: 							for(int i = 0; i < 3; i++ )
; 20389: 							{
; 20390: 								if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CSTATUE[i] )

  001ec	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CSTATUE+24
  001f2	7c 07		 jl	 SHORT $LN89@CGReqNpcUp

; 20391: 								{
; 20392: 									iNXT_UPLVL = (i+1);

  001f4	bf 03 00 00 00	 mov	 edi, 3

; 20393: 								}
; 20394: 							}
; 20395: 
; 20396: 							if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )

  001f9	eb 12		 jmp	 SHORT $LN106@CGReqNpcUp
$LN89@CGReqNpcUp:
  001fb	83 ff 01	 cmp	 edi, 1
  001fe	0f 8c ac 00 00
	00		 jl	 $LN28@CGReqNpcUp
  00204	83 ff 03	 cmp	 edi, 3
  00207	0f 8f a3 00 00
	00		 jg	 $LN28@CGReqNpcUp
$LN106@CGReqNpcUp:
  0020d	42		 inc	 edx
  0020e	3b fa		 cmp	 edi, edx
  00210	0f 85 9a 00 00
	00		 jne	 $LN28@CGReqNpcUp

; 20397: 							{
; 20398: 								bENABLE_UPGRADE = TRUE;
; 20399: 								iNXT_UPVALUE = g_iNpcUpMaxHP_CSTATUE[(iNXT_UPLVL-1)][0];

  00216	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00219	03 c0		 add	 eax, eax
  0021b	8b 8c 00 f4 ff
	ff ff		 mov	 ecx, DWORD PTR _g_iNpcUpMaxHP_CSTATUE[eax+eax-12]

; 20400: 								iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CSTATUE[(iNXT_UPLVL-1)][1];

  00222	8b 94 00 f8 ff
	ff ff		 mov	 edx, DWORD PTR _g_iNpcUpMaxHP_CSTATUE[eax+eax-8]
  00229	03 c0		 add	 eax, eax

; 20401: 								iNEED_MONEY = g_iNpcUpMaxHP_CSTATUE[(iNXT_UPLVL-1)][2];

  0022b	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR _g_iNpcUpMaxHP_CSTATUE[eax-4]
  00231	89 4d e8	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], ecx

; 20402: 							}
; 20403: 						}
; 20404: 						break;

  00234	eb 6d		 jmp	 SHORT $LN121@CGReqNpcUp
$LN27@CGReqNpcUp:

; 20357: 							}
; 20358: 						}
; 20359: 						break;
; 20360: 					case 2:
; 20361: 						{
; 20362: 							iCUR_UPLVL = m_NpcData.m_iNPC_RG_LEVEL;
; 20363: 							iNXT_UPLVL = lpMsg->iNpcUpValue;

  00236	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 20364: 							
; 20365: 							if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )

  00239	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  0023c	83 f9 02	 cmp	 ecx, 2
  0023f	77 6f		 ja	 SHORT $LN28@CGReqNpcUp
  00241	8b 55 94	 mov	 edx, DWORD PTR _m_NpcData$251804[ebp+32]
  00244	42		 inc	 edx
  00245	3b fa		 cmp	 edi, edx
  00247	75 67		 jne	 SHORT $LN28@CGReqNpcUp

; 20366: 							{
; 20367: 								bENABLE_UPGRADE = TRUE;
; 20368: 								iNXT_UPVALUE = iNXT_UPLVL;
; 20369: 								iNEED_GEMOFDEFEND = g_iNpcUpRgLevel_CSTATUE[(iNXT_UPLVL-1)][1];

  00249	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0024c	03 c0		 add	 eax, eax
  0024e	8b 8c 00 f8 ff
	ff ff		 mov	 ecx, DWORD PTR _g_iNpcUpRgLevel_CSTATUE[eax+eax-8]

; 20370: 								iNEED_MONEY = g_iNpcUpRgLevel_CSTATUE[(iNXT_UPLVL-1)][2];

  00255	8b 94 00 fc ff
	ff ff		 mov	 edx, DWORD PTR _g_iNpcUpRgLevel_CSTATUE[eax+eax-4]
  0025c	03 c0		 add	 eax, eax
  0025e	89 4d ec	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], ecx
  00261	89 7d e8	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
  00264	89 55 08	 mov	 DWORD PTR _iNEED_MONEY$[ebp], edx
  00267	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], 1

; 20418: 			}
; 20419: 		}

  0026e	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]

; 20420: 		break;

  00274	e9 d0 01 00 00	 jmp	 $LN123@CGReqNpcUp
$LN29@CGReqNpcUp:

; 20345: 				{
; 20346: 					case 1:
; 20347: 						{
; 20348: 							iCUR_UPLVL = m_NpcData.m_iNPC_DF_LEVEL;
; 20349: 							iNXT_UPLVL = lpMsg->iNpcUpValue;

  00279	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 20350: 
; 20351: 							if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) ) //Fixed

  0027c	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0027f	83 f8 02	 cmp	 eax, 2
  00282	77 2c		 ja	 SHORT $LN28@CGReqNpcUp
  00284	8b 4d 90	 mov	 ecx, DWORD PTR _m_NpcData$251804[ebp+28]
  00287	41		 inc	 ecx
  00288	3b f9		 cmp	 edi, ecx
  0028a	75 24		 jne	 SHORT $LN28@CGReqNpcUp

; 20352: 							{
; 20353: 								bENABLE_UPGRADE = TRUE;
; 20354: 								iNXT_UPVALUE = iNXT_UPLVL;
; 20355: 								iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CSTATUE[(iNXT_UPLVL-1)][1];

  0028c	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0028f	03 c0		 add	 eax, eax
  00291	8b 94 00 f8 ff
	ff ff		 mov	 edx, DWORD PTR _g_iNpcUpDfLevel_CSTATUE[eax+eax-8]
  00298	03 c0		 add	 eax, eax

; 20356: 								iNEED_MONEY = g_iNpcUpDfLevel_CSTATUE[(iNXT_UPLVL-1)][2];

  0029a	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR _g_iNpcUpDfLevel_CSTATUE[eax-4]
  002a0	89 7d e8	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
$LN121@CGReqNpcUp:
  002a3	89 45 08	 mov	 DWORD PTR _iNEED_MONEY$[ebp], eax
  002a6	89 55 ec	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], edx
  002a9	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], 1
$LN28@CGReqNpcUp:

; 20418: 			}
; 20419: 		}

  002b0	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]

; 20420: 		break;

  002b6	e9 8e 01 00 00	 jmp	 $LN123@CGReqNpcUp
$LN32@CGReqNpcUp:

; 20410: 						}
; 20411: 						break;
; 20412: 				}
; 20413: 			}
; 20414: 			else
; 20415: 			{
; 20416: 				GCAnsNpcUpgrade(iIndex, 7, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);		

  002bb	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  002be	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  002c1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  002c4	51		 push	 ecx
  002c5	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  002c8	52		 push	 edx
  002c9	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002cc	50		 push	 eax
  002cd	51		 push	 ecx
  002ce	6a 07		 push	 7
  002d0	52		 push	 edx
  002d1	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 20417: 				return;

  002d6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]
  002dc	83 c4 18	 add	 esp, 24			; 00000018H
  002df	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  002e2	e8 00 00 00 00	 call	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  002e7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f1	59		 pop	 ecx
  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	8b e5		 mov	 esp, ebp
  002f7	5d		 pop	 ebp
  002f8	c3		 ret	 0
$LN51@CGReqNpcUp:

; 20264: 	{
; 20265: 		case 277://Castle Gate
; 20266: 		{
; 20267: 			_CS_NPC_DATA m_NpcData;

  002f9	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251780[ebp]
  002ff	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 20268: 			BOOL bResult = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber, lpMsg->iNpcIndex, m_NpcData);

  00304	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00307	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0030a	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _m_NpcData$251780[ebp]
  00310	50		 push	 eax
  00311	51		 push	 ecx
  00312	52		 push	 edx
  00313	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00318	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0031f	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 20269: 
; 20270: 			if( bResult )
; 20271: 			{
; 20272: 				switch( lpMsg->iNpcUpType )

  00324	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00327	85 c0		 test	 eax, eax
  00329	0f 84 86 03 00
	00		 je	 $LN50@CGReqNpcUp
  0032f	8b c1		 mov	 eax, ecx
  00331	48		 dec	 eax
  00332	0f 84 d0 00 00
	00		 je	 $LN47@CGReqNpcUp
  00338	83 e8 02	 sub	 eax, 2
  0033b	74 3b		 je	 SHORT $LN45@CGReqNpcUp

; 20319: 					default:
; 20320: 						{
; 20321: 							GCAnsNpcUpgrade(iIndex, 5, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);

  0033d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00340	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00343	50		 push	 eax
  00344	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00347	51		 push	 ecx
  00348	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0034b	51		 push	 ecx
  0034c	52		 push	 edx
  0034d	6a 05		 push	 5
  0034f	50		 push	 eax
$LN125@CGReqNpcUp:
  00350	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 20322: 							return;

  00355	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251780[ebp]
  0035b	83 c4 18	 add	 esp, 24			; 00000018H
  0035e	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00361	e8 00 00 00 00	 call	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  00366	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00369	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00370	59		 pop	 ecx
  00371	5f		 pop	 edi
  00372	5e		 pop	 esi
  00373	5b		 pop	 ebx
  00374	8b e5		 mov	 esp, ebp
  00376	5d		 pop	 ebp
  00377	c3		 ret	 0
$LN45@CGReqNpcUp:

; 20285: 						}
; 20286: 					}
; 20287: 					break;
; 20288: 
; 20289: 					case 3:
; 20290: 					{
; 20291: 						iCUR_UPLVL = 0;
; 20292: 
; 20293: 						for( int i = 0; i < 3; i++ )
; 20294: 						{
; 20295: 							if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CGATE[i] )

  00378	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _m_NpcData$251780[ebp+36]
  0037e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_iNpcUpMaxHP_CGATE
  00384	33 d2		 xor	 edx, edx
  00386	3b c1		 cmp	 eax, ecx
  00388	7c 05		 jl	 SHORT $LN43@CGReqNpcUp

; 20296: 							{
; 20297: 								iCUR_UPLVL = (i+1);

  0038a	ba 01 00 00 00	 mov	 edx, 1
$LN43@CGReqNpcUp:

; 20285: 						}
; 20286: 					}
; 20287: 					break;
; 20288: 
; 20289: 					case 3:
; 20290: 					{
; 20291: 						iCUR_UPLVL = 0;
; 20292: 
; 20293: 						for( int i = 0; i < 3; i++ )
; 20294: 						{
; 20295: 							if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CGATE[i] )

  0038f	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CGATE+12
  00395	7c 05		 jl	 SHORT $LN94@CGReqNpcUp

; 20296: 							{
; 20297: 								iCUR_UPLVL = (i+1);

  00397	ba 02 00 00 00	 mov	 edx, 2
$LN94@CGReqNpcUp:

; 20285: 						}
; 20286: 					}
; 20287: 					break;
; 20288: 
; 20289: 					case 3:
; 20290: 					{
; 20291: 						iCUR_UPLVL = 0;
; 20292: 
; 20293: 						for( int i = 0; i < 3; i++ )
; 20294: 						{
; 20295: 							if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CGATE[i] )

  0039c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CGATE+24
  003a2	7c 05		 jl	 SHORT $LN96@CGReqNpcUp

; 20296: 							{
; 20297: 								iCUR_UPLVL = (i+1);

  003a4	ba 03 00 00 00	 mov	 edx, 3
$LN96@CGReqNpcUp:

; 20298: 							}
; 20299: 						}
; 20300: 						iNXT_UPLVL = 0;
; 20301: 
; 20302: 						for(int i = 0; i < 3; i++ )
; 20303: 						{
; 20304: 							if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CGATE[i] )

  003a9	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  003ac	33 ff		 xor	 edi, edi
  003ae	3b c1		 cmp	 eax, ecx
  003b0	7c 05		 jl	 SHORT $LN39@CGReqNpcUp

; 20305: 							{
; 20306: 								iNXT_UPLVL = (i+1);

  003b2	bf 01 00 00 00	 mov	 edi, 1
$LN39@CGReqNpcUp:

; 20298: 							}
; 20299: 						}
; 20300: 						iNXT_UPLVL = 0;
; 20301: 
; 20302: 						for(int i = 0; i < 3; i++ )
; 20303: 						{
; 20304: 							if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CGATE[i] )

  003b7	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CGATE+12
  003bd	7c 05		 jl	 SHORT $LN101@CGReqNpcUp

; 20305: 							{
; 20306: 								iNXT_UPLVL = (i+1);

  003bf	bf 02 00 00 00	 mov	 edi, 2
$LN101@CGReqNpcUp:

; 20298: 							}
; 20299: 						}
; 20300: 						iNXT_UPLVL = 0;
; 20301: 
; 20302: 						for(int i = 0; i < 3; i++ )
; 20303: 						{
; 20304: 							if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CGATE[i] )

  003c4	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _g_iNpcUpMaxHP_CGATE+24
  003ca	7c 07		 jl	 SHORT $LN103@CGReqNpcUp

; 20305: 							{
; 20306: 								iNXT_UPLVL = (i+1);

  003cc	bf 03 00 00 00	 mov	 edi, 3

; 20307: 							}
; 20308: 						}
; 20309: 
; 20310: 						if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )

  003d1	eb 0a		 jmp	 SHORT $LN108@CGReqNpcUp
$LN103@CGReqNpcUp:
  003d3	83 ff 01	 cmp	 edi, 1
  003d6	7c 6b		 jl	 SHORT $LN46@CGReqNpcUp
  003d8	83 ff 03	 cmp	 edi, 3
  003db	7f 66		 jg	 SHORT $LN46@CGReqNpcUp
$LN108@CGReqNpcUp:
  003dd	42		 inc	 edx
  003de	3b fa		 cmp	 edi, edx
  003e0	75 61		 jne	 SHORT $LN46@CGReqNpcUp

; 20311: 						{
; 20312: 							bENABLE_UPGRADE = TRUE;
; 20313: 							iNXT_UPVALUE = g_iNpcUpMaxHP_CGATE[(iNXT_UPLVL-1)][0];

  003e2	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  003e5	03 c0		 add	 eax, eax
  003e7	8b 8c 00 f4 ff
	ff ff		 mov	 ecx, DWORD PTR _g_iNpcUpMaxHP_CGATE[eax+eax-12]

; 20314: 							iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CGATE[(iNXT_UPLVL-1)][1];

  003ee	8b 94 00 f8 ff
	ff ff		 mov	 edx, DWORD PTR _g_iNpcUpMaxHP_CGATE[eax+eax-8]
  003f5	03 c0		 add	 eax, eax

; 20315: 							iNEED_MONEY = g_iNpcUpMaxHP_CGATE[(iNXT_UPLVL-1)][2];

  003f7	8b 80 fc ff ff
	ff		 mov	 eax, DWORD PTR _g_iNpcUpMaxHP_CGATE[eax-4]
  003fd	89 4d e8	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], ecx
  00400	89 55 ec	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], edx
  00403	89 45 08	 mov	 DWORD PTR _iNEED_MONEY$[ebp], eax

; 20316: 						}
; 20317: 					}
; 20318: 					break;

  00406	eb 34		 jmp	 SHORT $LN124@CGReqNpcUp
$LN47@CGReqNpcUp:

; 20273: 				{
; 20274: 					case 1:
; 20275: 					{
; 20276: 						iCUR_UPLVL = m_NpcData.m_iNPC_DF_LEVEL;
; 20277: 						iNXT_UPLVL = lpMsg->iNpcUpValue;

  00408	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 20278: 
; 20279: 						if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )

  0040b	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  0040e	83 f9 02	 cmp	 ecx, 2
  00411	77 30		 ja	 SHORT $LN46@CGReqNpcUp
  00413	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _m_NpcData$251780[ebp+28]
  00419	42		 inc	 edx
  0041a	3b fa		 cmp	 edi, edx
  0041c	75 25		 jne	 SHORT $LN46@CGReqNpcUp

; 20282: 							iNXT_UPVALUE = iNXT_UPLVL;
; 20283: 							iNEED_GEMOFDEFEND =  g_iNpcUpDfLevel_CGATE[(iNXT_UPLVL-1)][1];

  0041e	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00421	03 c0		 add	 eax, eax
  00423	8b 8c 00 f8 ff
	ff ff		 mov	 ecx, DWORD PTR _g_iNpcUpDfLevel_CGATE[eax+eax-8]

; 20284: 							iNEED_MONEY = g_iNpcUpDfLevel_CGATE[(iNXT_UPLVL-1)][2];

  0042a	8b 94 00 fc ff
	ff ff		 mov	 edx, DWORD PTR _g_iNpcUpDfLevel_CGATE[eax+eax-4]
  00431	03 c0		 add	 eax, eax
  00433	89 7d e8	 mov	 DWORD PTR _iNXT_UPVALUE$[ebp], edi
  00436	89 4d ec	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$[ebp], ecx
  00439	89 55 08	 mov	 DWORD PTR _iNEED_MONEY$[ebp], edx
$LN124@CGReqNpcUp:

; 20280: 						{
; 20281: 							bENABLE_UPGRADE = TRUE;

  0043c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$[ebp], 1
$LN46@CGReqNpcUp:

; 20331: 			}
; 20332: 		}

  00443	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251780[ebp]
$LN123@CGReqNpcUp:
  00449	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00450	e8 00 00 00 00	 call	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA

; 20421: 	}
; 20422: 
; 20423: 	int iGEMOFDEFEND_COUNT;
; 20424: 	int x;
; 20425: 	int bRETVAL;
; 20426: 
; 20427: 	if( bENABLE_UPGRADE == FALSE )

  00455	33 c0		 xor	 eax, eax
  00457	39 45 f0	 cmp	 DWORD PTR _bENABLE_UPGRADE$[ebp], eax
  0045a	75 30		 jne	 SHORT $LN13@CGReqNpcUp
$LN104@CGReqNpcUp:

; 20428: 	{
; 20429: 		GCAnsNpcUpgrade(iIndex, 6, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);		

  0045c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0045f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00462	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00465	50		 push	 eax
  00466	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00469	51		 push	 ecx
  0046a	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0046d	52		 push	 edx
  0046e	50		 push	 eax
  0046f	6a 06		 push	 6
  00471	51		 push	 ecx
  00472	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  00477	83 c4 18	 add	 esp, 24			; 00000018H

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  0047a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0047d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00484	59		 pop	 ecx
  00485	5f		 pop	 edi
  00486	5e		 pop	 esi
  00487	5b		 pop	 ebx
  00488	8b e5		 mov	 esp, ebp
  0048a	5d		 pop	 ebp
  0048b	c3		 ret	 0
$LN13@CGReqNpcUp:

; 20430: 	}
; 20431: 	else 
; 20432: 	{
; 20433: 		if( gObj[iIndex].Money < iNEED_MONEY )

  0048c	8b 55 08	 mov	 edx, DWORD PTR _iNEED_MONEY$[ebp]
  0048f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00495	39 94 0b f0 00
	00 00		 cmp	 DWORD PTR [ebx+ecx+240], edx
  0049c	7d 77		 jge	 SHORT $LN11@CGReqNpcUp

; 20434: 		{
; 20435: 			GCAnsNpcUpgrade(iIndex, 3, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);

  0049e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  004a1	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  004a4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004a7	52		 push	 edx
  004a8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  004ab	50		 push	 eax
  004ac	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004af	51		 push	 ecx
  004b0	52		 push	 edx
  004b1	6a 03		 push	 3
  004b3	50		 push	 eax
  004b4	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 20436: 			LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Money:%d, Need Money:%d", gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,gObj[iIndex].Money,iNEED_MONEY);

  004b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004be	8b 4d 08	 mov	 ecx, DWORD PTR _iNEED_MONEY$[ebp]
  004c1	8b 94 03 f0 00
	00 00		 mov	 edx, DWORD PTR [ebx+eax+240]
  004c8	51		 push	 ecx
  004c9	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  004cc	52		 push	 edx
  004cd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  004d0	57		 push	 edi
  004d1	51		 push	 ecx
  004d2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004d5	52		 push	 edx
  004d6	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  004d9	51		 push	 ecx
  004da	8b 8c 03 34 04
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1076]
  004e1	52		 push	 edx
  004e2	51		 push	 ecx
  004e3	8d 94 03 3c 04
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1084]
  004ea	52		 push	 edx
  004eb	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  004ef	51		 push	 ecx
  004f0	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  004f4	52		 push	 edx
  004f5	68 00 00 00 00	 push	 OFFSET ??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  004fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00500	83 c4 48	 add	 esp, 72			; 00000048H

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  00503	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00506	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0050d	59		 pop	 ecx
  0050e	5f		 pop	 edi
  0050f	5e		 pop	 esi
  00510	5b		 pop	 ebx
  00511	8b e5		 mov	 esp, ebp
  00513	5d		 pop	 ebp
  00514	c3		 ret	 0
$LN11@CGReqNpcUp:

; 20437: 		}
; 20438: 		else
; 20439: 		{
; 20440: 			for( iGEMOFDEFEND_COUNT = 0, x = 0; x < INVENTORY_SIZE; x++ )

  00515	89 45 f0	 mov	 DWORD PTR _iGEMOFDEFEND_COUNT$[ebp], eax
  00518	89 45 08	 mov	 DWORD PTR tv1198[ebp], eax
$LN9@CGReqNpcUp:

; 20441: 			{
; 20442: 				if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  0051b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00520	8b 8c 03 24 0e
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+3620]
  00527	03 4d 08	 add	 ecx, DWORD PTR tv1198[ebp]
  0052a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0052f	83 f8 01	 cmp	 eax, 1
  00532	75 1f		 jne	 SHORT $LN8@CGReqNpcUp

; 20443: 				{
; 20444: 					if( gObj[iIndex].pInventory[x].m_Type == ITEMGET(14,31) )

  00534	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0053a	8b 94 0b 24 0e
	00 00		 mov	 edx, DWORD PTR [ebx+ecx+3620]
  00541	8b 4d 08	 mov	 ecx, DWORD PTR tv1198[ebp]
  00544	b8 1f 1c 00 00	 mov	 eax, 7199		; 00001c1fH
  00549	66 39 44 0a 06	 cmp	 WORD PTR [edx+ecx+6], ax
  0054e	75 03		 jne	 SHORT $LN8@CGReqNpcUp

; 20445: 					{
; 20446: 						iGEMOFDEFEND_COUNT += 1;

  00550	ff 45 f0	 inc	 DWORD PTR _iGEMOFDEFEND_COUNT$[ebp]
$LN8@CGReqNpcUp:

; 20437: 		}
; 20438: 		else
; 20439: 		{
; 20440: 			for( iGEMOFDEFEND_COUNT = 0, x = 0; x < INVENTORY_SIZE; x++ )

  00553	8b 45 08	 mov	 eax, DWORD PTR tv1198[ebp]
  00556	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  0055b	89 45 08	 mov	 DWORD PTR tv1198[ebp], eax
  0055e	3d 70 c3 00 00	 cmp	 eax, 50032		; 0000c370H
  00563	7c b6		 jl	 SHORT $LN9@CGReqNpcUp

; 20447: 					}
; 20448: 				}
; 20449: 			}
; 20450: 
; 20451: 			if( iGEMOFDEFEND_COUNT < iNEED_GEMOFDEFEND )

  00565	8b 55 ec	 mov	 edx, DWORD PTR _iNEED_GEMOFDEFEND$[ebp]
  00568	39 55 f0	 cmp	 DWORD PTR _iGEMOFDEFEND_COUNT$[ebp], edx
  0056b	7d 73		 jge	 SHORT $LN4@CGReqNpcUp

; 20452: 			{
; 20453: 				GCAnsNpcUpgrade(iIndex, 4, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);

  0056d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00570	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00573	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00576	50		 push	 eax
  00577	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0057a	51		 push	 ecx
  0057b	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0057e	52		 push	 edx
  0057f	50		 push	 eax
  00580	6a 04		 push	 4
  00582	51		 push	 ecx
  00583	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 20454: 				LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Gem:%d, Need Gem:%d",	gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,iGEMOFDEFEND_COUNT,iNEED_GEMOFDEFEND);

  00588	8b 55 ec	 mov	 edx, DWORD PTR _iNEED_GEMOFDEFEND$[ebp]
  0058b	8b 4d f0	 mov	 ecx, DWORD PTR _iGEMOFDEFEND_COUNT$[ebp]
  0058e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00593	52		 push	 edx
  00594	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00597	51		 push	 ecx
  00598	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0059b	57		 push	 edi
  0059c	52		 push	 edx
  0059d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  005a0	51		 push	 ecx
  005a1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  005a4	52		 push	 edx
  005a5	8b 94 03 34 04
	00 00		 mov	 edx, DWORD PTR [ebx+eax+1076]
  005ac	51		 push	 ecx
  005ad	52		 push	 edx
  005ae	8d 8c 03 3c 04
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+1084]
  005b5	51		 push	 ecx
  005b6	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  005ba	52		 push	 edx
  005bb	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  005bf	50		 push	 eax
  005c0	68 00 00 00 00	 push	 OFFSET ??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  005c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005cb	83 c4 48	 add	 esp, 72			; 00000048H

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  005ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005d8	59		 pop	 ecx
  005d9	5f		 pop	 edi
  005da	5e		 pop	 esi
  005db	5b		 pop	 ebx
  005dc	8b e5		 mov	 esp, ebp
  005de	5d		 pop	 ebp
  005df	c3		 ret	 0
$LN4@CGReqNpcUp:

; 20455: 			}
; 20456: 			else
; 20457: 			{
; 20458: 				bRETVAL = g_CastleSiege.PayForUpgradeDbNpc(iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,(iNXT_UPLVL-1));

  005e0	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  005e3	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  005e6	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  005e9	50		 push	 eax
  005ea	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  005ed	51		 push	 ecx
  005ee	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  005f1	52		 push	 edx
  005f2	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  005f5	50		 push	 eax
  005f6	51		 push	 ecx
  005f7	52		 push	 edx
  005f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  005fd	e8 00 00 00 00	 call	 ?PayForUpgradeDbNpc@CCastleSiege@@QAEHHHHHHH@Z ; CCastleSiege::PayForUpgradeDbNpc

; 20459: 				
; 20460: 				if( bRETVAL == FALSE )

  00602	85 c0		 test	 eax, eax
  00604	0f 84 eb 00 00
	00		 je	 $LN1@CGReqNpcUp

; 20461: 				{
; 20462: 				}
; 20463: 				else
; 20464: 				{
; 20465: 					gObj[iIndex].m_bIsCastleNPCUpgradeCompleted = TRUE;

  0060a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20466: 					LogAddTD("[CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upgrade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)", lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE);

  0060f	8b 4d e8	 mov	 ecx, DWORD PTR _iNXT_UPVALUE$[ebp]
  00612	51		 push	 ecx
  00613	c6 84 03 04 1c
	00 00 01	 mov	 BYTE PTR [ebx+eax+7172], 1
  0061b	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0061e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00621	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00624	52		 push	 edx
  00625	50		 push	 eax
  00626	51		 push	 ecx
  00627	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@
  0062c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20467: 					GS_GDReqCastleNpcUpgrade(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE,(iNXT_UPLVL-1));

  00632	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  00637	83 c4 14	 add	 esp, 20			; 00000014H
  0063a	85 c0		 test	 eax, eax
  0063c	74 06		 je	 SHORT $LN63@CGReqNpcUp
  0063e	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00642	eb 03		 jmp	 SHORT $LN64@CGReqNpcUp
$LN63@CGReqNpcUp:
  00644	83 c8 ff	 or	 eax, -1
$LN64@CGReqNpcUp:
  00647	8b 55 e8	 mov	 edx, DWORD PTR _iNXT_UPVALUE$[ebp]
  0064a	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]
  0064d	51		 push	 ecx
  0064e	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00651	52		 push	 edx
  00652	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00655	51		 push	 ecx
  00656	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00659	52		 push	 edx
  0065a	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0065d	51		 push	 ecx
  0065e	52		 push	 edx
  0065f	50		 push	 eax
  00660	e8 00 00 00 00	 call	 ?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z ; GS_GDReqCastleNpcUpgrade

; 20468: 					LogAddTD("[CastleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d", gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);

  00665	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00668	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0066b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00670	57		 push	 edi
  00671	51		 push	 ecx
  00672	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00675	52		 push	 edx
  00676	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00679	51		 push	 ecx
  0067a	8b 8c 03 34 04
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+1076]
  00681	52		 push	 edx
  00682	51		 push	 ecx
  00683	8d 94 03 3c 04
	00 00		 lea	 edx, DWORD PTR [ebx+eax+1084]
  0068a	52		 push	 edx
  0068b	8d 4c 03 77	 lea	 ecx, DWORD PTR [ebx+eax+119]
  0068f	51		 push	 ecx
  00690	8d 54 03 6c	 lea	 edx, DWORD PTR [ebx+eax+108]
  00694	52		 push	 edx
  00695	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  0069a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006a0	83 c4 44	 add	 esp, 68			; 00000044H

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  006a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006ad	59		 pop	 ecx
  006ae	5f		 pop	 edi
  006af	5e		 pop	 esi
  006b0	5b		 pop	 ebx
  006b1	8b e5		 mov	 esp, ebp
  006b3	5d		 pop	 ebp
  006b4	c3		 ret	 0
$LN50@CGReqNpcUp:

; 20323: 						}
; 20324: 						break;
; 20325: 				}
; 20326: 			}
; 20327: 			else
; 20328: 			{
; 20329: 				GCAnsNpcUpgrade(iIndex, 7, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);

  006b5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  006b8	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  006bb	50		 push	 eax
  006bc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  006bf	51		 push	 ecx
  006c0	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  006c3	52		 push	 edx
  006c4	50		 push	 eax
  006c5	6a 07		 push	 7
  006c7	51		 push	 ecx

; 20330: 				return;	

  006c8	e9 83 fc ff ff	 jmp	 $LN125@CGReqNpcUp
$LN54@CGReqNpcUp:

; 20258: 	{
; 20259: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  006cd	8b 94 03 48 04
	00 00		 mov	 edx, DWORD PTR [ebx+eax+1096]
  006d4	52		 push	 edx
  006d5	8d 8c 03 3c 04
	00 00		 lea	 ecx, DWORD PTR [ebx+eax+1084]
  006dc	51		 push	 ecx
  006dd	8d 54 03 77	 lea	 edx, DWORD PTR [ebx+eax+119]
  006e1	52		 push	 edx
  006e2	8d 44 03 6c	 lea	 eax, DWORD PTR [ebx+eax+108]
  006e6	50		 push	 eax
  006e7	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  006ec	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006f2	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGReqNpcUp:

; 20469: 				}	
; 20470: 			}
; 20471: 		}
; 20472: 
; 20473: 	}
; 20474: //#endif
; 20475: }

  006f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006ff	59		 pop	 ecx
  00700	5f		 pop	 edi
  00701	5e		 pop	 esi
  00702	5b		 pop	 ebx
  00703	8b e5		 mov	 esp, ebp
  00705	5d		 pop	 ebp
  00706	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$1:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251804[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$0:
  0000b	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _m_NpcData$251780[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__ehhandler$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a fc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-260]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ENDP	; CGReqNpcUpgrade
PUBLIC	??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ; CGReqTaxRateChange
EXTRN	?GS_GDReqTaxRateChange@@YAXHHHH@Z:PROC		; GS_GDReqTaxRateChange
;	COMDAT ??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
CONST	SEGMENT
??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s]['
	DB	'%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), '
	DB	'TaxType:%d, TaxRate:%d', 00H		; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z PROC ; CGReqTaxRateChange, COMDAT

; 20541: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 20542: //#if(GS_CASTLE==1)
; 20543: 
; 20544: 	int iMaxTaxRate;
; 20545: 	int iTaxRate;
; 20546: 
; 20547: 	if( lpMsg == NULL )

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	0f 84 90 01 00
	00		 je	 $LN1@CGReqTaxRa

; 20548: 	{
; 20549: 		return;
; 20550: 	}
; 20551: 
; 20552: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001e	57		 push	 edi
  0001f	8d bc 06 3c 04
	00 00		 lea	 edi, DWORD PTR [esi+eax+1084]
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002b	8b c7		 mov	 eax, edi
  0002d	8d 49 00	 npad	 3
$LL19@CGReqTaxRa:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN20@CGReqTaxRa
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN21@CGReqTaxRa
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN20@CGReqTaxRa
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL19@CGReqTaxRa
$LN21@CGReqTaxRa:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN22@CGReqTaxRa
$LN20@CGReqTaxRa:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN22@CGReqTaxRa:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 40 01 00
	00		 je	 $LN23@CGReqTaxRa

; 20553: 	{
; 20554: 		return;
; 20555: 	}
; 20556: 
; 20557: 	if( (g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	85 c0		 test	 eax, eax
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	0f 84 fe 00 00
	00		 je	 $LN10@CGReqTaxRa
  00075	81 bc 06 48 04
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+eax+1096], 128 ; 00000080H
  00080	0f 85 ed 00 00
	00		 jne	 $LN10@CGReqTaxRa

; 20560: 	}
; 20561: 	else
; 20562: 	{
; 20563: 		iMaxTaxRate = 0;
; 20564: 
; 20565: 		switch( lpMsg->btTaxType )

  00086	0f b6 4b 04	 movzx	 ecx, BYTE PTR [ebx+4]
  0008a	8b c1		 mov	 eax, ecx
  0008c	33 d2		 xor	 edx, edx
  0008e	48		 dec	 eax
  0008f	74 0d		 je	 SHORT $LN6@CGReqTaxRa
  00091	48		 dec	 eax
  00092	74 0a		 je	 SHORT $LN6@CGReqTaxRa
  00094	48		 dec	 eax
  00095	75 0c		 jne	 SHORT $LN7@CGReqTaxRa

; 20569: 			break;
; 20570: 		case 2:
; 20571: 			iMaxTaxRate = 3;
; 20572: 			break;
; 20573: 		case 3:
; 20574: 			iMaxTaxRate = 300000;

  00097	ba e0 93 04 00	 mov	 edx, 300000		; 000493e0H

; 20575: 			break;

  0009c	eb 05		 jmp	 SHORT $LN7@CGReqTaxRa
$LN6@CGReqTaxRa:

; 20566: 		{
; 20567: 		case 1:
; 20568: 			iMaxTaxRate = 3;

  0009e	ba 03 00 00 00	 mov	 edx, 3
$LN7@CGReqTaxRa:

; 20576: 		}
; 20577: 
; 20578: 		iTaxRate = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->btTaxRate1, lpMsg->btTaxRate2), MAKE_NUMBERW(lpMsg->btTaxRate3, lpMsg->btTaxRate4)); 

  000a3	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  000a7	66 c1 e0 08	 shl	 ax, 8
  000ab	0f b7 f8	 movzx	 edi, ax
  000ae	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  000b2	0b f8		 or	 edi, eax
  000b4	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  000b8	0f b6 5b 08	 movzx	 ebx, BYTE PTR [ebx+8]
  000bc	66 c1 e0 08	 shl	 ax, 8
  000c0	0f b7 c0	 movzx	 eax, ax
  000c3	c1 e7 10	 shl	 edi, 16			; 00000010H
  000c6	0b c3		 or	 eax, ebx
  000c8	0b f8		 or	 edi, eax

; 20579: 
; 20580: 		if( (iTaxRate < 0) || (iTaxRate > iMaxTaxRate) )

  000ca	7c 5d		 jl	 SHORT $LN2@CGReqTaxRa
  000cc	3b fa		 cmp	 edi, edx
  000ce	7f 59		 jg	 SHORT $LN2@CGReqTaxRa

; 20584: 		}
; 20585: 		else
; 20586: 		{
; 20587: 			GS_GDReqTaxRateChange(g_MapServerManager.GetMapSvrGroup(), iIndex, lpMsg->btTaxType, iTaxRate);

  000d0	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  000d5	85 c0		 test	 eax, eax
  000d7	74 06		 je	 SHORT $LN16@CGReqTaxRa
  000d9	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  000dd	eb 03		 jmp	 SHORT $LN17@CGReqTaxRa
$LN16@CGReqTaxRa:
  000df	83 c8 ff	 or	 eax, -1
$LN17@CGReqTaxRa:
  000e2	57		 push	 edi
  000e3	51		 push	 ecx
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000e7	51		 push	 ecx
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ?GS_GDReqTaxRateChange@@YAXHHHH@Z ; GS_GDReqTaxRateChange

; 20588: 			LogAddTD("[CastleSiege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, lpMsg->btTaxType, iTaxRate);

  000ee	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000f1	0f b6 4a 04	 movzx	 ecx, BYTE PTR [edx+4]
  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fa	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  00101	57		 push	 edi
  00102	51		 push	 ecx
  00103	52		 push	 edx
  00104	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  0010b	51		 push	 ecx
  0010c	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00110	52		 push	 edx
  00111	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00115	50		 push	 eax
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00121	83 c4 2c	 add	 esp, 44			; 0000002cH
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx

; 20589: 		}
; 20590: 	}
; 20591: //#endif
; 20592: }

  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN2@CGReqTaxRa:

; 20581: 		{
; 20582: 			GCAnsTaxRateChange(iIndex,0,0,0);

  00129	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	6a 00		 push	 0
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 ?GCAnsTaxRateChange@@YAXHHEH@Z ; GCAnsTaxRateChange

; 20583: 			LogAddTD("[CastleSiege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, lpMsg->btTaxType, iTaxRate);

  00138	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0013b	0f b6 4a 04	 movzx	 ecx, BYTE PTR [edx+4]
  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00144	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  0014b	57		 push	 edi
  0014c	51		 push	 ecx
  0014d	52		 push	 edx
  0014e	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  00155	51		 push	 ecx
  00156	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0015a	52		 push	 edx
  0015b	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0015f	50		 push	 eax
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016b	83 c4 2c	 add	 esp, 44			; 0000002cH
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx

; 20589: 		}
; 20590: 	}
; 20591: //#endif
; 20592: }

  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
$LN10@CGReqTaxRa:

; 20558: 	{
; 20559: 		LogAddC(2,"[CastleSiege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  00173	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  0017a	51		 push	 ecx
  0017b	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  00182	52		 push	 edx
  00183	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00187	51		 push	 ecx
  00188	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  0018c	52		 push	 edx
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00192	6a 02		 push	 2
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0019a	83 c4 18	 add	 esp, 24			; 00000018H
$LN23@CGReqTaxRa:
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
$LN1@CGReqTaxRa:
  0019f	5b		 pop	 ebx

; 20589: 		}
; 20590: 	}
; 20591: //#endif
; 20592: }

  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ENDP ; CGReqTaxRateChange
_TEXT	ENDS
PUBLIC	??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ; CGReqMoneyDrawOut
EXTRN	?GS_GDReqCastleMoneyChange@@YAXHHH@Z:PROC	; GS_GDReqCastleMoneyChange
EXTRN	?CheckCastleHasMoney@CCastleSiege@@QAEH_J@Z:PROC ; CCastleSiege::CheckCastleHasMoney
;	COMDAT ??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
; File e:\work\tranet_version\gs\gameserver\mapservermanager.h
CONST	SEGMENT
??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], '
	DB	'Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d)'
	DB	', Money:%d, TotMoney:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s]['
	DB	'%s], Guild:(%s)(%d), Money:%d, TotMoney:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], G'
	DB	'uild:(%s)(%d), Money:%d, TotMoney:%d', 00H	; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z PROC ; CGReqMoneyDrawOut, COMDAT

; 20614: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20615: //#if(GS_CASTLE==1)
; 20616: 	int iMoneyChange;
; 20617: 	BOOL bRETVAL;
; 20618: 
; 20619: 	if( lpMsg == NULL )

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	0f 84 f4 01 00
	00		 je	 $LN1@CGReqMoney

; 20620: 	{
; 20621: 		return;
; 20622: 	}
; 20623: 
; 20624: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	53		 push	 ebx
  00013	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00016	56		 push	 esi
  00017	8b f3		 mov	 esi, ebx
  00019	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001f	57		 push	 edi
  00020	8d bc 06 3c 04
	00 00		 lea	 edi, DWORD PTR [esi+eax+1084]
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	8b c7		 mov	 eax, edi
  0002e	8b ff		 npad	 2
$LL17@CGReqMoney:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN18@CGReqMoney
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN19@CGReqMoney
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN18@CGReqMoney
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL17@CGReqMoney
$LN19@CGReqMoney:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN20@CGReqMoney
$LN18@CGReqMoney:
  00050	1b c0		 sbb	 eax, eax
  00052	83 d8 ff	 sbb	 eax, -1
$LN20@CGReqMoney:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 a1 01 00
	00		 je	 $LN21@CGReqMoney

; 20625: 	{
; 20626: 		return;
; 20627: 	}
; 20628: 	
; 20629: 	if( (g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	85 c0		 test	 eax, eax
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	0f 84 5f 01 00
	00		 je	 $LN8@CGReqMoney
  00075	81 bc 06 48 04
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+eax+1096], 128 ; 00000080H
  00080	0f 85 4e 01 00
	00		 jne	 $LN8@CGReqMoney

; 20632: 	}
; 20633: 	else
; 20634: 	{
; 20635: 		iMoneyChange = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->btMoney4, lpMsg->btMoney3), MAKE_NUMBERW(lpMsg->btMoney2, lpMsg->btMoney1));

  00086	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00089	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0008d	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  00091	66 c1 e1 08	 shl	 cx, 8
  00095	0f b7 f9	 movzx	 edi, cx
  00098	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0009c	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  000a0	0b fa		 or	 edi, edx
  000a2	66 c1 e1 08	 shl	 cx, 8
  000a6	0f b7 d1	 movzx	 edx, cx
  000a9	c1 e7 10	 shl	 edi, 16			; 00000010H
  000ac	0b d0		 or	 edx, eax
  000ae	0b fa		 or	 edi, edx

; 20636: 
; 20637: 		if( iMoneyChange <= 0 )

  000b0	7f 47		 jg	 SHORT $LN6@CGReqMoney

; 20638: 		{
; 20639: 			GCAnsMoneyDrawOut(iIndex, 0, 0);

  000b2	6a 00		 push	 0
  000b4	6a 00		 push	 0
  000b6	6a 00		 push	 0
  000b8	53		 push	 ebx
  000b9	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut

; 20640: 			LogAddTD("[CastleSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, iMoneyChange, gObj[iIndex].Money);

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	8b 8c 06 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+240]
  000ca	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  000d1	51		 push	 ecx
  000d2	57		 push	 edi
  000d3	52		 push	 edx
  000d4	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  000db	51		 push	 ecx
  000dc	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  000e0	52		 push	 edx
  000e1	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  000e5	50		 push	 eax
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f1	83 c4 2c	 add	 esp, 44			; 0000002cH
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 20661: 				}
; 20662: 			}
; 20663: 		}
; 20664: 	}
; 20665: //#endif
; 20666: }

  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
$LN6@CGReqMoney:

; 20641: 		}
; 20642: 		else
; 20643: 		{
; 20644: 			bRETVAL = g_CastleSiege.CheckCastleHasMoney(iMoneyChange);
; 20645: 
; 20646: 			if( bRETVAL == FALSE )

  000f9	8b c7		 mov	 eax, edi
  000fb	99		 cdq
  000fc	52		 push	 edx
  000fd	50		 push	 eax
  000fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00103	e8 00 00 00 00	 call	 ?CheckCastleHasMoney@CCastleSiege@@QAEH_J@Z ; CCastleSiege::CheckCastleHasMoney
  00108	85 c0		 test	 eax, eax
  0010a	75 44		 jne	 SHORT $LN4@CGReqMoney

; 20647: 			{
; 20648: 				GCAnsMoneyDrawOut(iIndex, 0, 0);

  0010c	50		 push	 eax
  0010d	50		 push	 eax
  0010e	50		 push	 eax
  0010f	53		 push	 ebx
  00110	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut

; 20649: 				LogAddTD("[CastleSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, iMoneyChange, gObj[iIndex].Money);

  00115	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011a	8b 8c 06 f0 00
	00 00		 mov	 ecx, DWORD PTR [esi+eax+240]
  00121	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  00128	51		 push	 ecx
  00129	57		 push	 edi
  0012a	52		 push	 edx
  0012b	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  00132	51		 push	 ecx
  00133	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  00137	52		 push	 edx
  00138	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  0013c	50		 push	 eax
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00148	83 c4 2c	 add	 esp, 44			; 0000002cH
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx

; 20661: 				}
; 20662: 			}
; 20663: 		}
; 20664: 	}
; 20665: //#endif
; 20666: }

  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
$LN4@CGReqMoney:

; 20650: 			}
; 20651: 			else
; 20652: 			{
; 20653: 				if( (gObj[iIndex].Money + iMoneyChange) > MAX_ZEN )

  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00156	8b 94 0e f0 00
	00 00		 mov	 edx, DWORD PTR [esi+ecx+240]
  0015d	03 d7		 add	 edx, edi
  0015f	81 fa 00 94 35
	77		 cmp	 edx, 2000000000		; 77359400H
  00165	7e 14		 jle	 SHORT $LN2@CGReqMoney

; 20654: 				{
; 20655: 					GCAnsMoneyDrawOut(iIndex, 0, 0);

  00167	6a 00		 push	 0
  00169	6a 00		 push	 0
  0016b	6a 00		 push	 0
  0016d	53		 push	 ebx
  0016e	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut
  00173	83 c4 10	 add	 esp, 16			; 00000010H
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5b		 pop	 ebx

; 20661: 				}
; 20662: 			}
; 20663: 		}
; 20664: 	}
; 20665: //#endif
; 20666: }

  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN2@CGReqMoney:

; 20656: 				}
; 20657: 				else
; 20658: 				{
; 20659: 					GS_GDReqCastleMoneyChange(g_MapServerManager.GetMapSvrGroup(), iIndex, -iMoneyChange);

  0017b	a1 c0 32 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+78528
  00180	85 c0		 test	 eax, eax
  00182	74 06		 je	 SHORT $LN14@CGReqMoney
  00184	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00188	eb 03		 jmp	 SHORT $LN15@CGReqMoney
$LN14@CGReqMoney:
  0018a	83 c8 ff	 or	 eax, -1
$LN15@CGReqMoney:
  0018d	8b cf		 mov	 ecx, edi
  0018f	f7 d9		 neg	 ecx
  00191	51		 push	 ecx
  00192	53		 push	 ebx
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 ?GS_GDReqCastleMoneyChange@@YAXHHH@Z ; GS_GDReqCastleMoneyChange

; 20660: 					LogAddTD("[CastleSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, iMoneyChange, gObj[iIndex].Money);

  00199	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0019e	8b 94 06 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax+240]
  001a5	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  001ac	52		 push	 edx
  001ad	57		 push	 edi
  001ae	51		 push	 ecx
  001af	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  001b6	52		 push	 edx
  001b7	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  001bb	51		 push	 ecx
  001bc	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  001c0	52		 push	 edx
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001cc	83 c4 28	 add	 esp, 40			; 00000028H
  001cf	5f		 pop	 edi
  001d0	5e		 pop	 esi
  001d1	5b		 pop	 ebx

; 20661: 				}
; 20662: 			}
; 20663: 		}
; 20664: 	}
; 20665: //#endif
; 20666: }

  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN8@CGReqMoney:

; 20630: 	{
; 20631: 		LogAddC(2,"[CastleSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  001d4	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  001db	51		 push	 ecx
  001dc	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  001e3	52		 push	 edx
  001e4	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  001e8	51		 push	 ecx
  001e9	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  001ed	52		 push	 edx
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  001f3	6a 02		 push	 2
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001fb	83 c4 18	 add	 esp, 24			; 00000018H
$LN21@CGReqMoney:
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx
$LN1@CGReqMoney:

; 20661: 				}
; 20662: 			}
; 20663: 		}
; 20664: 	}
; 20665: //#endif
; 20666: }

  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ENDP ; CGReqMoneyDrawOut
_TEXT	ENDS
PUBLIC	??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ; CGReqCsGateOperate
EXTRN	?SendCsGateStateViewPort@CCastleSiege@@QAEXHE@Z:PROC ; CCastleSiege::SendCsGateStateViewPort
EXTRN	?OperateGate@CCastleSiege@@QAEHHHH@Z:PROC	; CCastleSiege::OperateGate
EXTRN	?CheckCsGateAlive@CCastleSiege@@QAEHH@Z:PROC	; CCastleSiege::CheckCsGateAlive
;	COMDAT ??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
; File e:\work\tranet_version\gs\gameserver\castlesiege.h
CONST	SEGMENT
??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Gate Doesn''t Exist [%s][%s'
	DB	'], Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR'
	DB	':(%d)(X:%d,Y:%d)(STATUE:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s'
	DB	'], Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d)', 00H				; `string'
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\protocol.cpp
CONST	ENDS
;	COMDAT ?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z PROC ; CGReqCsGateOperate, COMDAT

; 20700: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 20701: //#if(GS_CASTLE==1)
; 20702: 	int iGateIndex;
; 20703: 
; 20704: 	if( strcmp(gObj[iIndex].GuildName, "") == 0 )

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f3		 mov	 esi, ebx
  0000a	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00010	57		 push	 edi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00017	8d 84 3e 3c 04
	00 00		 lea	 eax, DWORD PTR [esi+edi+1084]
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LL14@CGReqCsGat:
  00023	8a 10		 mov	 dl, BYTE PTR [eax]
  00025	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00027	75 1a		 jne	 SHORT $LN15@CGReqCsGat
  00029	84 d2		 test	 dl, dl
  0002b	74 12		 je	 SHORT $LN16@CGReqCsGat
  0002d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00030	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00033	75 0e		 jne	 SHORT $LN15@CGReqCsGat
  00035	83 c0 02	 add	 eax, 2
  00038	83 c1 02	 add	 ecx, 2
  0003b	84 d2		 test	 dl, dl
  0003d	75 e4		 jne	 SHORT $LL14@CGReqCsGat
$LN16@CGReqCsGat:
  0003f	33 c0		 xor	 eax, eax
  00041	eb 05		 jmp	 SHORT $LN17@CGReqCsGat
$LN15@CGReqCsGat:
  00043	1b c0		 sbb	 eax, eax
  00045	83 d8 ff	 sbb	 eax, -1
$LN17@CGReqCsGat:
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 d5 01 00
	00		 je	 $LN1@CGReqCsGat

; 20705: 	{
; 20706: 		return;
; 20707: 	}
; 20708: 	
; 20709: 	if( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )

  00050	83 3d 28 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 7
  00057	75 37		 jne	 SHORT $LN8@CGReqCsGat

; 20710: 	{
; 20711: 		if( gObj[iIndex].m_btCsJoinSide != 1 )

  00059	80 bc 3e 02 1c
	00 00 01	 cmp	 BYTE PTR [esi+edi+7170], 1
  00061	74 7d		 je	 SHORT $LN18@CGReqCsGat

; 20712: 		{
; 20713: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  00063	8b 84 3e 48 04
	00 00		 mov	 eax, DWORD PTR [esi+edi+1096]
  0006a	50		 push	 eax
  0006b	8d 84 3e 3c 04
	00 00		 lea	 eax, DWORD PTR [esi+edi+1084]
  00072	50		 push	 eax
  00073	8d 4c 3e 77	 lea	 ecx, DWORD PTR [esi+edi+119]
  00077	51		 push	 ecx
  00078	8d 54 3e 6c	 lea	 edx, DWORD PTR [esi+edi+108]
  0007c	52		 push	 edx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00088	83 c4 14	 add	 esp, 20			; 00000014H
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 20748: 	}
; 20749: //#endif
; 20750: }

  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
$LN8@CGReqCsGat:

; 20714: 			return;
; 20715: 		}
; 20716: 	}
; 20717: 	else
; 20718: 	{
; 20719: 		if( (g_CastleSiege.CheckCastleOwnerMember(iIndex) == FALSE) && (g_CastleSiege.CheckCastleOwnerUnionMember(iIndex) == FALSE) )

  00090	53		 push	 ebx
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00096	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  0009b	85 c0		 test	 eax, eax
  0009d	75 41		 jne	 SHORT $LN18@CGReqCsGat
  0009f	53		 push	 ebx
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a5	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  000aa	85 c0		 test	 eax, eax
  000ac	75 32		 jne	 SHORT $LN18@CGReqCsGat

; 20720: 		{
; 20721: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b3	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  000ba	51		 push	 ecx
  000bb	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  000c2	52		 push	 edx
  000c3	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  000c7	51		 push	 ecx
  000c8	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  000cc	52		 push	 edx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d8	83 c4 14	 add	 esp, 20			; 00000014H
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 20748: 	}
; 20749: //#endif
; 20750: }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN18@CGReqCsGat:

; 20722: 			return;
; 20723: 		}
; 20724: 	}
; 20725: 	
; 20726: 	iGateIndex = MAKE_NUMBERW(lpMsg->btIndex1,lpMsg->btIndex2);

  000e0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000e3	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000e7	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  000eb	66 c1 e1 08	 shl	 cx, 8
  000ef	0f b7 f9	 movzx	 edi, cx
  000f2	0b fa		 or	 edi, edx

; 20727: 
; 20728: 	if( g_CastleSiege.CheckCsGateAlive(iGateIndex) == TRUE ) 

  000f4	57		 push	 edi
  000f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000fa	e8 00 00 00 00	 call	 ?CheckCsGateAlive@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCsGateAlive
  000ff	83 f8 01	 cmp	 eax, 1
  00102	0f 85 e4 00 00
	00		 jne	 $LN4@CGReqCsGat

; 20729: 	{
; 20730: 		int iOperateGate = g_CastleSiege.OperateGate(iGateIndex, gObj[iGateIndex].m_iCsNpcExistVal, lpMsg->btOperate);
; 20731: 
; 20732: 		if( iOperateGate == 0 )

  00108	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0010b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0010f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00115	8b df		 mov	 ebx, edi
  00117	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  0011d	8b 84 13 f4 1b
	00 00		 mov	 eax, DWORD PTR [ebx+edx+7156]
  00124	51		 push	 ecx
  00125	50		 push	 eax
  00126	57		 push	 edi
  00127	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0012c	e8 00 00 00 00	 call	 ?OperateGate@CCastleSiege@@QAEHHHH@Z ; CCastleSiege::OperateGate
  00131	85 c0		 test	 eax, eax
  00133	75 3f		 jne	 SHORT $LN3@CGReqCsGat

; 20733: 		{
; 20734: 			GCAnsCsGateOperate(iIndex, 0, -1, 0);

  00135	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00138	50		 push	 eax
  00139	6a ff		 push	 -1
  0013b	50		 push	 eax
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 20735: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s], Guild:(%s)(%d)",	gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);	

  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00147	8b 94 06 48 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1096]
  0014e	52		 push	 edx
  0014f	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  00156	51		 push	 ecx
  00157	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  0015b	52		 push	 edx
  0015c	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  00160	50		 push	 eax
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@

; 20747: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);	

  00166	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016c	83 c4 24	 add	 esp, 36			; 00000024H
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx

; 20748: 	}
; 20749: //#endif
; 20750: }

  00172	5d		 pop	 ebp
  00173	c3		 ret	 0
$LN3@CGReqCsGat:

; 20736: 		}
; 20737: 		else
; 20738: 		{
; 20739: 			GCAnsCsGateOperate(iIndex, 1, iGateIndex, lpMsg->btOperate);

  00174	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00177	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0017b	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0017e	52		 push	 edx
  0017f	57		 push	 edi
  00180	6a 01		 push	 1
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 20740: 			g_CastleSiege.SendCsGateStateViewPort(iGateIndex, lpMsg->btOperate);

  00188	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0018b	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0018f	83 c4 10	 add	 esp, 16			; 00000010H
  00192	52		 push	 edx
  00193	57		 push	 edi
  00194	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00199	e8 00 00 00 00	 call	 ?SendCsGateStateViewPort@CCastleSiege@@QAEXHE@Z ; CCastleSiege::SendCsGateStateViewPort

; 20741: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR:(%d)(X:%d,Y:%d)(STATUE:%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildNumber,iGateIndex, gObj[iGateIndex].X, gObj[iGateIndex].Y, gObj[iGateIndex].m_btCsGateOpen);

  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a3	0f b6 8c 03 f9
	1b 00 00	 movzx	 ecx, BYTE PTR [ebx+eax+7161]
  001ab	0f bf 94 03 46
	01 00 00	 movsx	 edx, WORD PTR [ebx+eax+326]
  001b3	51		 push	 ecx
  001b4	0f bf 8c 03 44
	01 00 00	 movsx	 ecx, WORD PTR [ebx+eax+324]
  001bc	52		 push	 edx
  001bd	8b 94 06 34 04
	00 00		 mov	 edx, DWORD PTR [esi+eax+1076]
  001c4	51		 push	 ecx
  001c5	57		 push	 edi
  001c6	52		 push	 edx
  001c7	8d 8c 06 3c 04
	00 00		 lea	 ecx, DWORD PTR [esi+eax+1084]
  001ce	51		 push	 ecx
  001cf	8d 54 06 77	 lea	 edx, DWORD PTR [esi+eax+119]
  001d3	52		 push	 edx
  001d4	8d 44 06 6c	 lea	 eax, DWORD PTR [esi+eax+108]
  001d8	50		 push	 eax
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@

; 20747: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);	

  001de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e4	83 c4 24	 add	 esp, 36			; 00000024H
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx

; 20748: 	}
; 20749: //#endif
; 20750: }

  001ea	5d		 pop	 ebp
  001eb	c3		 ret	 0
$LN4@CGReqCsGat:

; 20742: 		}
; 20743: 	}
; 20744: 	else
; 20745: 	{
; 20746: 		GCAnsCsGateOperate(iIndex, 2, -1, 0);

  001ec	6a 00		 push	 0
  001ee	6a ff		 push	 -1
  001f0	6a 02		 push	 2
  001f2	53		 push	 ebx
  001f3	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 20747: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);	

  001f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fd	8b 8c 06 48 04
	00 00		 mov	 ecx, DWORD PTR [esi+eax+1096]
  00204	51		 push	 ecx
  00205	8d 94 06 3c 04
	00 00		 lea	 edx, DWORD PTR [esi+eax+1084]
  0020c	52		 push	 edx
  0020d	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00211	51		 push	 ecx
  00212	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00216	52		 push	 edx
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00222	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@CGReqCsGat:
  00225	5f		 pop	 edi
  00226	5e		 pop	 esi
  00227	5b		 pop	 ebx

; 20748: 	}
; 20749: //#endif
; 20750: }

  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ENDP ; CGReqCsGateOperate
_TEXT	ENDS
PUBLIC	?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ; CGReqCsMiniMapData
EXTRN	?AddMiniMapDataReqUser@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::AddMiniMapDataReqUser
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z PROC ; CGReqCsMiniMapData, COMDAT

; 20884: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 20885: //#if(GS_CASTLE==1)
; 20886: 	if( gObjIsConnected(iIndex) == FALSE )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 62		 je	 SHORT $LN1@CGReqCsMin

; 20887: 	{
; 20888: 		return;
; 20889: 	}
; 20890: 
; 20891: 	if( (gObj[iIndex].m_btCsJoinSide <= 0) || ( g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE ) )

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001a	8b c6		 mov	 eax, esi
  0001c	69 c0 50 2b 00
	00		 imul	 eax, 11088		; 00002b50H
  00022	80 bc 08 02 1c
	00 00 00	 cmp	 BYTE PTR [eax+ecx+7170], 0
  0002a	76 3f		 jbe	 SHORT $LN4@CGReqCsMin
  0002c	56		 push	 esi
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00032	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00037	85 c0		 test	 eax, eax
  00039	74 30		 je	 SHORT $LN4@CGReqCsMin

; 20894: 	}
; 20895: 	else if( g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE )

  0003b	83 3d 28 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 7
  00042	74 0e		 je	 SHORT $LN2@CGReqCsMin

; 20896: 	{
; 20897: 		GCAnsCsMiniMapData(iIndex, 2);

  00044	6a 02		 push	 2
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  0004c	83 c4 08	 add	 esp, 8
  0004f	5e		 pop	 esi

; 20903: 	}
; 20904: //#endif
; 20905: }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN2@CGReqCsMin:

; 20898: 	}
; 20899: 	else
; 20900: 	{
; 20901: 		g_CastleSiege.AddMiniMapDataReqUser(iIndex);

  00052	56		 push	 esi
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00058	e8 00 00 00 00	 call	 ?AddMiniMapDataReqUser@CCastleSiege@@QAEXH@Z ; CCastleSiege::AddMiniMapDataReqUser

; 20902: 		GCAnsCsMiniMapData(iIndex, 1);

  0005d	6a 01		 push	 1
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  00065	83 c4 08	 add	 esp, 8
  00068	5e		 pop	 esi

; 20903: 	}
; 20904: //#endif
; 20905: }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN4@CGReqCsMin:

; 20892: 	{
; 20893: 		GCAnsCsMiniMapData(iIndex, 3);

  0006b	6a 03		 push	 3
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  00073	83 c4 08	 add	 esp, 8
$LN1@CGReqCsMin:
  00076	5e		 pop	 esi

; 20903: 	}
; 20904: //#endif
; 20905: }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ENDP ; CGReqCsMiniMapData
_TEXT	ENDS
PUBLIC	?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ; CGReqCsSendCommand
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z PROC	; CGReqCsSendCommand, COMDAT

; 20934: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 20935: //#if(GS_CASTLE==1)
; 20936: 	if( gObjIsConnected(iIndex) == FALSE )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 5e		 je	 SHORT $LN2@CGReqCsSen

; 20937: 	{
; 20938: 		return;
; 20939: 	}
; 20940: 
; 20941: 	if( gObj[iIndex].m_btCsJoinSide <= 0 ||	g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE )

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	56		 push	 esi
  0001a	8b f7		 mov	 esi, edi
  0001c	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00022	80 bc 06 02 1c
	00 00 00	 cmp	 BYTE PTR [esi+eax+7170], 0
  0002a	76 45		 jbe	 SHORT $LN9@CGReqCsSen
  0002c	57		 push	 edi
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00032	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00037	85 c0		 test	 eax, eax
  00039	74 36		 je	 SHORT $LN9@CGReqCsSen

; 20942: 	{
; 20943: 		return;
; 20944: 	}
; 20945: 
; 20946: 	if( g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE )

  0003b	83 3d 28 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 7
  00042	75 2d		 jne	 SHORT $LN9@CGReqCsSen

; 20947: 	{
; 20948: 		return;
; 20949: 	}
; 20950: 
; 20951: 	GCAnsCsSendCommand(gObj[iIndex].m_btCsJoinSide, lpMsg->btTeam, lpMsg->btX, lpMsg->btY, lpMsg->btCommand);

  00044	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00047	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0004b	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  0004f	51		 push	 ecx
  00050	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00054	52		 push	 edx
  00055	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005e	51		 push	 ecx
  0005f	0f b6 8c 06 02
	1c 00 00	 movzx	 ecx, BYTE PTR [esi+eax+7170]
  00067	52		 push	 edx
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?GCAnsCsSendCommand@@YAXHEEEE@Z ; GCAnsCsSendCommand
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@CGReqCsSen:
  00071	5e		 pop	 esi
$LN2@CGReqCsSen:
  00072	5f		 pop	 edi

; 20952: //#endif
; 20953: }

  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ENDP	; CGReqCsSendCommand
_TEXT	ENDS
PUBLIC	?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ; CGReqCsSetEnterHuntZone
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z PROC ; CGReqCsSetEnterHuntZone, COMDAT

; 21017: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 21018: //#if(GS_CASTLE==1)
; 21019: 	if( gObjIsConnected(iIndex) == FALSE )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 61		 je	 SHORT $LN1@CGReqCsSet

; 21020: 	{
; 21021: 		return;
; 21022: 	}
; 21023: 	
; 21024: 	if( g_CastleSiege.CheckCastleOwnerMember(iIndex) == FALSE )

  00014	56		 push	 esi
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001a	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  0001f	85 c0		 test	 eax, eax
  00021	75 16		 jne	 SHORT $LN4@CGReqCsSet

; 21025: 	{
; 21026: 		GCAnsCsSetEnterHuntZone(iIndex, 2, lpMsg->btHuntZoneEnter);

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00026	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002a	51		 push	 ecx
  0002b	6a 02		 push	 2

; 21035: 		GCAnsCsSetEnterHuntZone(iIndex, 1, lpMsg->btHuntZoneEnter);

  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	5e		 pop	 esi

; 21036: 	}
; 21037: 
; 21038: //#endif
; 21039: }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN4@CGReqCsSet:

; 21027: 	}
; 21028: 	else if( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )

  00039	83 3d 28 00 00
	00 07		 cmp	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+40, 7
  00040	75 16		 jne	 SHORT $LN2@CGReqCsSet

; 21029: 	{
; 21030: 		GCAnsCsSetEnterHuntZone(iIndex, 0, lpMsg->btHuntZoneEnter);

  00042	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00045	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00049	50		 push	 eax
  0004a	6a 00		 push	 0

; 21035: 		GCAnsCsSetEnterHuntZone(iIndex, 1, lpMsg->btHuntZoneEnter);

  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	5e		 pop	 esi

; 21036: 	}
; 21037: 
; 21038: //#endif
; 21039: }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN2@CGReqCsSet:

; 21031: 	}
; 21032: 	else
; 21033: 	{
; 21034: 		g_CastleSiege.SetHuntZoneEnter(lpMsg->btHuntZoneEnter);

  00058	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0005f	89 0d fc 00 00
	00		 mov	 DWORD PTR ?g_CastleSiege@@3VCCastleSiege@@A+252, ecx

; 21035: 		GCAnsCsSetEnterHuntZone(iIndex, 1, lpMsg->btHuntZoneEnter);

  00065	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  00069	52		 push	 edx
  0006a	6a 01		 push	 1
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGReqCsSet:
  00075	5e		 pop	 esi

; 21036: 	}
; 21037: 
; 21038: //#endif
; 21039: }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ENDP ; CGReqCsSetEnterHuntZone
_TEXT	ENDS
PUBLIC	?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ; CGReqCrywolfInfo
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
; Function compile flags: /Ogtp
;	COMDAT ?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z PROC ; CGReqCrywolfInfo, COMDAT

; 21390: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 21391: 	if ( !OBJMAX_RANGE(iIndex))

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 28		 js	 SHORT $LN2@CGReqCrywo
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 97 3a 00
	00		 cmp	 ecx, 14999		; 00003a97H
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 19		 je	 SHORT $LN2@CGReqCrywo

; 21392: 	{
; 21393: 		return;
; 21394: 	}
; 21395: 
; 21396: 	LPOBJ lpObj = &gObj[iIndex];
; 21397: //#if(GS_CASTLE==1)
; 21398: 	GCAnsCrywolfInfo(iIndex, g_Crywolf.GetOccupationState(), g_Crywolf.GetCrywolfState());

  00019	0f b6 05 ec b7
	0f 00		 movzx	 eax, BYTE PTR ?g_Crywolf@@3VCCrywolf@@A+1030124
  00020	0f b6 15 f0 b7
	0f 00		 movzx	 edx, BYTE PTR ?g_Crywolf@@3VCCrywolf@@A+1030128
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?GCAnsCrywolfInfo@@YAXHEE@Z ; GCAnsCrywolfInfo
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGReqCrywo:

; 21399: //#else
; 21400: //	GCAnsCrywolfInfo(iIndex, g_CrywolfSync.GetOccupationState(), g_CrywolfSync.GetCrywolfState());
; 21401: //#endif
; 21402: }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ENDP ; CGReqCrywolfInfo
_TEXT	ENDS
PUBLIC	??_C@_0DD@MMKHBDDM@?$FLLuckyCoinEvent?$FN?5TradeCoin?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	?CGReqLuckyCoinTrade@@YAXPAUPMSG_REQ_TRADE_LUCKYCOIN@@H@Z ; CGReqLuckyCoinTrade
EXTRN	?LuckyCoint10ItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; LuckyCoint10ItemBagOpen
EXTRN	?LuckyCoint20ItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; LuckyCoint20ItemBagOpen
EXTRN	?LuckyCoint30ItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; LuckyCoint30ItemBagOpen
;	COMDAT ??_C@_0DD@MMKHBDDM@?$FLLuckyCoinEvent?$FN?5TradeCoin?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0DD@MMKHBDDM@?$FLLuckyCoinEvent?$FN?5TradeCoin?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'LuckyCoinEvent] TradeCoin [%s][%s], TradeCoin: %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqLuckyCoinTrade@@YAXPAUPMSG_REQ_TRADE_LUCKYCOIN@@H@Z
_TEXT	SEGMENT
_pLuckyCoinEventItemBoxOpen$ = -16			; size = 4
tv438 = -12						; size = 4
tv436 = -12						; size = 4
tv363 = -12						; size = 4
_LuckyCoinCount$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_LuckyCoinNumber$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
tv441 = 14						; size = 2
?CGReqLuckyCoinTrade@@YAXPAUPMSG_REQ_TRADE_LUCKYCOIN@@H@Z PROC ; CGReqLuckyCoinTrade, COMDAT

; 21829: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	57		 push	 edi

; 21830: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 a1 02 00
	00		 js	 $LN8@CGReqLucky@2
  00012	33 c0		 xor	 eax, eax
  00014	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 8e 02 00
	00		 je	 $LN8@CGReqLucky@2

; 21831: 	{
; 21832: 		return;
; 21833: 	}
; 21834: 
; 21835: 	LPOBJ lpObj = &gObj[iIndex]; //1

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	56		 push	 esi
  0002b	8b f7		 mov	 esi, edi
  0002d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00033	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]

; 21836: 	
; 21837: 	if ( !gObjIsConnected(iIndex))

  00036	57		 push	 edi
  00037	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx
  0003a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003f	83 c4 04	 add	 esp, 4
  00042	85 c0		 test	 eax, eax
  00044	0f 84 68 02 00
	00		 je	 $LN34@CGReqLucky@2

; 21838: 	{
; 21839: 		return;
; 21840: 	}
; 21841: 
; 21842: 	LuckyCoinEventItemBoxOpen	pLuckyCoinEventItemBoxOpen; //2
; 21843: 	int LuckyCoinNumber = lpMsg->LuckyCoinNumber; //3

  0004a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0004d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00050	89 45 fc	 mov	 DWORD PTR _LuckyCoinNumber$[ebp], eax

; 21844: 	int LuckyCoinCount; //4
; 21845: 	int n; //5
; 21846: 
; 21847: 	switch(LuckyCoinNumber)

  00053	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00056	74 2d		 je	 SHORT $LN19@CGReqLucky@2
  00058	83 f8 14	 cmp	 eax, 20			; 00000014H
  0005b	74 1f		 je	 SHORT $LN18@CGReqLucky@2
  0005d	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00060	74 11		 je	 SHORT $LN17@CGReqLucky@2

; 21858: 	default:
; 21859: 		GCSendLuckyCoinResult(iIndex, 4);

  00062	6a 04		 push	 4
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?GCSendLuckyCoinResult@@YAXHE@Z ; GCSendLuckyCoinResult
  0006a	83 c4 08	 add	 esp, 8
  0006d	5e		 pop	 esi
  0006e	5f		 pop	 edi

; 21916: 	}
; 21917: }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN17@CGReqLucky@2:

; 21855: 	case 30:
; 21856: 		pLuckyCoinEventItemBoxOpen = LuckyCoint30ItemBagOpen;

  00073	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pLuckyCoinEventItemBoxOpen$[ebp], OFFSET ?LuckyCoint30ItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; LuckyCoint30ItemBagOpen

; 21857: 		break;

  0007a	eb 10		 jmp	 SHORT $LN20@CGReqLucky@2
$LN18@CGReqLucky@2:

; 21851: 		break;
; 21852: 	case 20:
; 21853: 		pLuckyCoinEventItemBoxOpen = LuckyCoint20ItemBagOpen;

  0007c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pLuckyCoinEventItemBoxOpen$[ebp], OFFSET ?LuckyCoint20ItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; LuckyCoint20ItemBagOpen

; 21854: 		break;

  00083	eb 07		 jmp	 SHORT $LN20@CGReqLucky@2
$LN19@CGReqLucky@2:

; 21848: 	{
; 21849: 	case 10:
; 21850: 		pLuckyCoinEventItemBoxOpen = LuckyCoint10ItemBagOpen;

  00085	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pLuckyCoinEventItemBoxOpen$[ebp], OFFSET ?LuckyCoint10ItemBagOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; LuckyCoint10ItemBagOpen
$LN20@CGReqLucky@2:
  0008c	53		 push	 ebx

; 21860: 		return;
; 21861: 	}
; 21862: 
; 21863: 	LuckyCoinCount = 0; //4

  0008d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _LuckyCoinCount$[ebp], 0
  0009a	bf f0 09 00 00	 mov	 edi, 2544		; 000009f0H
  0009f	90		 npad	 1
$LL15@CGReqLucky@2:

; 21866: 	{
; 21867: 		if( gObj[iIndex].pInventory[n].IsItem() == TRUE &&
; 21868: 			gObj[iIndex].pInventory[n].m_Type == ITEMGET(14,100))

  000a0	8b 8c 1e 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ebx+3620]
  000a7	03 cf		 add	 ecx, edi
  000a9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ae	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	75 22		 jne	 SHORT $LN14@CGReqLucky@2
  000b9	8b 84 1e 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+ebx+3620]
  000c0	b9 64 1c 00 00	 mov	 ecx, 7268		; 00001c64H
  000c5	66 39 4c 38 06	 cmp	 WORD PTR [eax+edi+6], cx
  000ca	75 0f		 jne	 SHORT $LN14@CGReqLucky@2

; 21869: 		{
; 21870: 			LuckyCoinCount = (int)(LuckyCoinCount + (float)gObj[iIndex].pInventory[n].m_Durability);

  000cc	d9 44 38 24	 fld	 DWORD PTR [eax+edi+36]
  000d0	da 45 f4	 fiadd	 DWORD PTR _LuckyCoinCount$[ebp]
  000d3	e8 00 00 00 00	 call	 __ftol2_sse
  000d8	89 45 f4	 mov	 DWORD PTR _LuckyCoinCount$[ebp], eax
$LN14@CGReqLucky@2:

; 21864: 	
; 21865: 	for(n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++) //5

  000db	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000e1	81 ff f0 a8 00
	00		 cmp	 edi, 43248		; 0000a8f0H
  000e7	7c b7		 jl	 SHORT $LL15@CGReqLucky@2

; 21871: 		}
; 21872: 	}
; 21873: 
; 21874: 	if(LuckyCoinCount < LuckyCoinNumber)

  000e9	8b 55 fc	 mov	 edx, DWORD PTR _LuckyCoinNumber$[ebp]
  000ec	39 55 f4	 cmp	 DWORD PTR _LuckyCoinCount$[ebp], edx
  000ef	7d 15		 jge	 SHORT $LN11@CGReqLucky@2

; 21875: 	{
; 21876: 		GCSendLuckyCoinResult(iIndex, 0);

  000f1	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000f4	6a 00		 push	 0
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ?GCSendLuckyCoinResult@@YAXHE@Z ; GCSendLuckyCoinResult
  000fc	83 c4 08	 add	 esp, 8
  000ff	5b		 pop	 ebx
  00100	5e		 pop	 esi
  00101	5f		 pop	 edi

; 21916: 	}
; 21917: }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN11@CGReqLucky@2:

; 21877: 	}
; 21878: 	else if( !CheckInventoryEmptySpace(lpObj, 4, 2) )

  00106	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00109	6a 02		 push	 2
  0010b	6a 04		 push	 4
  0010d	57		 push	 edi
  0010e	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
  00116	85 c0		 test	 eax, eax
  00118	75 15		 jne	 SHORT $LN9@CGReqLucky@2

; 21879: 	{
; 21880: 		GCSendLuckyCoinResult(iIndex, 2);

  0011a	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0011d	6a 02		 push	 2
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 ?GCSendLuckyCoinResult@@YAXHE@Z ; GCSendLuckyCoinResult
  00125	83 c4 08	 add	 esp, 8
  00128	5b		 pop	 ebx
  00129	5e		 pop	 esi
  0012a	5f		 pop	 edi

; 21916: 	}
; 21917: }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
$LN9@CGReqLucky@2:

; 21881: 	}
; 21882: 	else
; 21883: 	{
; 21884: 		//????????????????????????????????????????????????????????????????
; 21885: 		gObj[iIndex].bIsChaosMixCompleted = true;

  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00135	c6 84 16 79 12
	00 00 01	 mov	 BYTE PTR [esi+edx+4729], 1

; 21886: 		lpObj->ChaosLock = TRUE;
; 21887: 		gObjInventoryTrans(lpObj->m_Index);

  0013d	8b 07		 mov	 eax, DWORD PTR [edi]
  0013f	50		 push	 eax
  00140	c7 87 88 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+3720], 1
  0014a	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  0014f	83 c4 04	 add	 esp, 4

; 21888: 
; 21889: 		for(n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++) //5

  00152	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
  00157	bb f0 09 00 00	 mov	 ebx, 2544		; 000009f0H
  0015c	8d 64 24 00	 npad	 4
$LL7@CGReqLucky@2:

; 21890: 		{
; 21891: 			if( gObj[iIndex].pInventory[n].IsItem() == TRUE && gObj[iIndex].pInventory[n].m_Type == ITEMGET(14,100))

  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00166	8b 8c 0e 24 0e
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3620]
  0016d	03 cb		 add	 ecx, ebx
  0016f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00174	83 f8 01	 cmp	 eax, 1
  00177	75 50		 jne	 SHORT $LN6@CGReqLucky@2
  00179	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017f	8b 84 16 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+edx+3620]
  00186	b9 64 1c 00 00	 mov	 ecx, 7268		; 00001c64H
  0018b	66 39 4c 18 06	 cmp	 WORD PTR [eax+ebx+6], cx
  00190	75 37		 jne	 SHORT $LN6@CGReqLucky@2

; 21892: 			{
; 21893: 				if(gObj[iIndex].pInventory[n].m_Durability < (float)LuckyCoinNumber)

  00192	d9 44 18 24	 fld	 DWORD PTR [eax+ebx+36]
  00196	8d 4c 18 24	 lea	 ecx, DWORD PTR [eax+ebx+36]
  0019a	db 45 fc	 fild	 DWORD PTR _LuckyCoinNumber$[ebp]
  0019d	de d9		 fcompp
  0019f	df e0		 fnstsw	 ax
  001a1	f6 c4 41	 test	 ah, 65			; 00000041H
  001a4	75 3a		 jne	 SHORT $LN3@CGReqLucky@2

; 21894: 				{
; 21895: 					LuckyCoinNumber -= (int)gObj[iIndex].pInventory[n].m_Durability;

  001a6	d9 01		 fld	 DWORD PTR [ecx]
  001a8	e8 00 00 00 00	 call	 __ftol2_sse

; 21896: 					gObjInventoryDeleteItem(iIndex, n);

  001ad	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001b0	29 45 fc	 sub	 DWORD PTR _LuckyCoinNumber$[ebp], eax
  001b3	57		 push	 edi
  001b4	52		 push	 edx
  001b5	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 21897: 					GCInventoryItemDeleteSend(iIndex, n, 1);

  001ba	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001bd	6a 01		 push	 1
  001bf	57		 push	 edi
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  001c6	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@CGReqLucky@2:

; 21888: 
; 21889: 		for(n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++) //5

  001c9	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  001cf	47		 inc	 edi
  001d0	81 fb f0 a8 00
	00		 cmp	 ebx, 43248		; 0000a8f0H
  001d6	7c 88		 jl	 SHORT $LL7@CGReqLucky@2

; 21864: 	
; 21865: 	for(n = INVETORY_WEAR_SIZE; n < MAIN_INVENTORY_SIZE; n++) //5

  001d8	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$[ebp]
  001db	e9 97 00 00 00	 jmp	 $LN5@CGReqLucky@2
$LN3@CGReqLucky@2:

; 21898: 				}
; 21899: 				else
; 21900: 				{
; 21901: 					if(gObj[iIndex].pInventory[n].m_Durability == (float)LuckyCoinNumber)

  001e0	db 45 fc	 fild	 DWORD PTR _LuckyCoinNumber$[ebp]
  001e3	8b 84 16 24 0e
	00 00		 mov	 eax, DWORD PTR [esi+edx+3620]
  001ea	8b cf		 mov	 ecx, edi
  001ec	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  001f2	d9 5d f4	 fstp	 DWORD PTR tv363[ebp]
  001f5	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  001f9	d9 45 f4	 fld	 DWORD PTR tv363[ebp]
  001fc	d9 c0		 fld	 ST(0)
  001fe	dd ea		 fucomp	 ST(2)
  00200	df e0		 fnstsw	 ax
  00202	dd d9		 fstp	 ST(1)
  00204	f6 c4 44	 test	 ah, 68			; 00000044H
  00207	7a 1d		 jp	 SHORT $LN1@CGReqLucky@2

; 21902: 					{
; 21903: 						gObjInventoryDeleteItem(iIndex, n);

  00209	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  0020c	dd d8		 fstp	 ST(0)
  0020e	57		 push	 edi
  0020f	53		 push	 ebx
  00210	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 21904: 						GCInventoryItemDeleteSend(iIndex, n, 1);

  00215	6a 01		 push	 1
  00217	57		 push	 edi
  00218	53		 push	 ebx
  00219	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 21905: 						break; //

  0021e	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00221	83 c4 14	 add	 esp, 20			; 00000014H
  00224	eb 51		 jmp	 SHORT $LN5@CGReqLucky@2
$LN1@CGReqLucky@2:

; 21906: 					}
; 21907: 			
; 21908: 					gObj[iIndex].pInventory[n].m_Durability -= LuckyCoinNumber;

  00226	8b 94 16 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+edx+3620]

; 21909: 					GCItemDurSend2(lpObj->m_Index, (BYTE)n, (BYTE)gObj[iIndex].pInventory[n].m_Durability, 0);

  0022d	d9 7d 0e	 fnstcw	 WORD PTR tv441[ebp]
  00230	d8 6c 11 24	 fsubr	 DWORD PTR [ecx+edx+36]
  00234	8d 44 11 24	 lea	 eax, DWORD PTR [ecx+edx+36]
  00238	6a 00		 push	 0
  0023a	d9 18		 fstp	 DWORD PTR [eax]
  0023c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00241	8b 94 06 24 0e
	00 00		 mov	 edx, DWORD PTR [esi+eax+3620]
  00248	0f b7 45 0e	 movzx	 eax, WORD PTR tv441[ebp]
  0024c	d9 44 0a 24	 fld	 DWORD PTR [edx+ecx+36]
  00250	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00255	89 45 f4	 mov	 DWORD PTR tv438[ebp], eax
  00258	d9 6d f4	 fldcw	 WORD PTR tv438[ebp]
  0025b	db 5d f4	 fistp	 DWORD PTR tv436[ebp]
  0025e	8a 45 f4	 mov	 al, BYTE PTR tv436[ebp]
  00261	0f b6 c8	 movzx	 ecx, al
  00264	51		 push	 ecx
  00265	d9 6d 0e	 fldcw	 WORD PTR tv441[ebp]
  00268	57		 push	 edi
  00269	8b 7d f8	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0026c	8b 17		 mov	 edx, DWORD PTR [edi]
  0026e	52		 push	 edx
  0026f	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00274	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@CGReqLucky@2:

; 21910: 					break; //
; 21911: 				}
; 21912: 			}
; 21913: 		}
; 21914: 		LogAddTD("[LuckyCoinEvent] TradeCoin [%s][%s], TradeCoin: %d",gObj[iIndex].AccountID, gObj[iIndex].Name, LuckyCoinNumber);

  00277	8b 45 fc	 mov	 eax, DWORD PTR _LuckyCoinNumber$[ebp]
  0027a	50		 push	 eax
  0027b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00280	8d 4c 06 77	 lea	 ecx, DWORD PTR [esi+eax+119]
  00284	51		 push	 ecx
  00285	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00289	52		 push	 edx
  0028a	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@MMKHBDDM@?$FLLuckyCoinEvent?$FN?5TradeCoin?5?$FL?$CFs?$FN?$FL@
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 21915: 		pLuckyCoinEventItemBoxOpen(lpObj, 237, lpObj->X, lpObj->Y);

  00295	0f b6 87 46 01
	00 00		 movzx	 eax, BYTE PTR [edi+326]
  0029c	0f b6 8f 44 01
	00 00		 movzx	 ecx, BYTE PTR [edi+324]
  002a3	50		 push	 eax
  002a4	51		 push	 ecx
  002a5	68 ed 00 00 00	 push	 237			; 000000edH
  002aa	57		 push	 edi
  002ab	ff 55 f0	 call	 DWORD PTR _pLuckyCoinEventItemBoxOpen$[ebp]
  002ae	83 c4 20	 add	 esp, 32			; 00000020H
  002b1	5b		 pop	 ebx
$LN34@CGReqLucky@2:
  002b2	5e		 pop	 esi
$LN8@CGReqLucky@2:
  002b3	5f		 pop	 edi

; 21916: 	}
; 21917: }

  002b4	8b e5		 mov	 esp, ebp
  002b6	5d		 pop	 ebp
  002b7	c3		 ret	 0
?CGReqLuckyCoinTrade@@YAXPAUPMSG_REQ_TRADE_LUCKYCOIN@@H@Z ENDP ; CGReqLuckyCoinTrade
_TEXT	ENDS
PUBLIC	??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ ; `string'
PUBLIC	??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ ; `string'
PUBLIC	?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; GCMonkMagicAttack
;	COMDAT ??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
CONST	SEGMENT
??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ DB '['
	DB	'0x4A] CGRageAttack() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
CONST	SEGMENT
??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ DB '['
	DB	'0x4A] CGRageAttack() - Invalid Status', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
tv331 = -4						; size = 4
_MagicNumber$ = 8					; size = 2
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; GCMonkMagicAttack, COMDAT

; 22099: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 22100: 	LPOBJ lpObj;
; 22101: 	LPOBJ lpTargetObj;
; 22102: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00004	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00007	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0000b	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  0000f	66 c1 e1 08	 shl	 cx, 8
  00013	53		 push	 ebx
  00014	0f b7 d9	 movzx	 ebx, cx

; 22103: 	CMagicInf* lpMagic;
; 22104: 
; 22105: 
; 22106: 	if( gObj[aIndex].CloseCount >= 0 )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00023	89 75 fc	 mov	 DWORD PTR tv331[ebp], esi
  00026	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	0b da		 or	 ebx, edx
  0002e	80 7e 0a 00	 cmp	 BYTE PTR [esi+10], 0
  00032	0f 8d 3f 02 00
	00		 jge	 $LN22@GCMonkMagi@2

; 22107: 		return;
; 22108: 
; 22109: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);

  00038	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0003c	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00040	66 c1 e2 08	 shl	 dx, 8
  00044	66 0b d0	 or	 dx, ax
  00047	57		 push	 edi
  00048	0f b7 fa	 movzx	 edi, dx

; 22110: 
; 22111: 	if( MagicNumber == 263 || MagicNumber == 559 )

  0004b	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  00050	89 7d 08	 mov	 DWORD PTR _MagicNumber$[ebp], edi
  00053	66 3b fa	 cmp	 di, dx
  00056	0f 84 06 02 00
	00		 je	 $LN19@GCMonkMagi@2
  0005c	b8 2f 02 00 00	 mov	 eax, 559		; 0000022fH
  00061	66 3b f8	 cmp	 di, ax
  00064	0f 84 f8 01 00
	00		 je	 $LN19@GCMonkMagi@2

; 22114: 		return;
; 22115: 	}
; 22116: 
; 22117: 	if( usernumber < 0 || usernumber > OBJMAX-1 )

  0006a	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  00070	0f 87 cc 01 00
	00		 ja	 $LN17@GCMonkMagi@2

; 22120: 		return;
; 22121: 	}
; 22122: 
; 22123: 	if( gObj[aIndex].Live == FALSE || 
; 22124: 		gObj[aIndex].Connected <= PLAYER_LOGGED )

  00076	80 7e 6a 00	 cmp	 BYTE PTR [esi+106], 0
  0007a	0f 84 f6 01 00
	00		 je	 $LN25@GCMonkMagi@2
  00080	83 7e 04 02	 cmp	 DWORD PTR [esi+4], 2
  00084	0f 8e ec 01 00
	00		 jle	 $LN25@GCMonkMagi@2

; 22125: 	{
; 22126: 		return;
; 22127: 	}
; 22128: 
; 22129: 	lpObj = &gObj[aIndex];
; 22130: 	lpTargetObj = &gObj[usernumber];
; 22131: 
; 22132: 	int attackret = gObjCheckAttackArea(aIndex, usernumber);

  0008a	53		 push	 ebx
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  00091	83 c4 08	 add	 esp, 8

; 22133: 
; 22134: 	if( attackret != 0 )

  00094	85 c0		 test	 eax, eax
  00096	74 25		 je	 SHORT $LN12@GCMonkMagi@2

; 22135: 	{
; 22136: 		//LogAddC(2, "[DEBUG] Point 1");
; 22137: 		//LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%d:%d,%d) errortype = %d",
; 22138: 		//	lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, attackret);
; 22139: 
; 22140: 		if( lpObj->Class == 275 )

  00098	b9 13 01 00 00	 mov	 ecx, 275		; 00000113H
  0009d	66 39 8e b8 00
	00 00		 cmp	 WORD PTR [esi+184], cx
  000a4	75 0a		 jne	 SHORT $LN13@GCMonkMagi@2

; 22141: 			lpObj->TargetNumber = -1;

  000a6	83 ca ff	 or	 edx, -1
  000a9	66 89 96 58 04
	00 00		 mov	 WORD PTR [esi+1112], dx
$LN13@GCMonkMagi@2:

; 22142: 		if( bIsIgnorePacketSpeedHackDetect != 0 )

  000b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  000b7	0f 85 b9 01 00
	00		 jne	 $LN25@GCMonkMagi@2
$LN12@GCMonkMagi@2:

; 22143: 			return;
; 22144: 	}
; 22145: 
; 22146: 	if ( lpObj->Type == OBJ_USER )

  000bd	66 83 7e 68 01	 cmp	 WORD PTR [esi+104], 1

; 22147: 	{
; 22148: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  000c2	0f b7 c7	 movzx	 eax, di
  000c5	50		 push	 eax
  000c6	56		 push	 esi
  000c7	0f 85 a2 00 00
	00		 jne	 $LN11@GCMonkMagi@2
  000cd	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000d2	8b f8		 mov	 edi, eax
  000d4	83 c4 08	 add	 esp, 8

; 22149: 
; 22150: 		if ( !lpMagic )

  000d7	85 ff		 test	 edi, edi
  000d9	0f 84 97 01 00
	00		 je	 $LN25@GCMonkMagi@2

; 22151: 			return;
; 22152: 
; 22153: 		if ( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ChangeUP3rd , lpMagic->m_Skill) < 1 )

  000df	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000e2	0f b6 96 bc 00
	00 00		 movzx	 edx, BYTE PTR [esi+188]
  000e9	0f b6 86 bb 00
	00 00		 movzx	 eax, BYTE PTR [esi+187]
  000f0	51		 push	 ecx
  000f1	0f b7 8e b8 00
	00 00		 movzx	 ecx, WORD PTR [esi+184]
  000f8	52		 push	 edx
  000f9	50		 push	 eax
  000fa	51		 push	 ecx
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00100	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00105	83 f8 01	 cmp	 eax, 1
  00108	0f 8c 68 01 00
	00		 jl	 $LN25@GCMonkMagi@2

; 22154: 			return;
; 22155: 
; 22156: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == 0 )

  0010e	8b 96 48 04 00
	00		 mov	 edx, DWORD PTR [esi+1096]
  00114	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00117	52		 push	 edx
  00118	50		 push	 eax
  00119	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0011e	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  00123	85 c0		 test	 eax, eax
  00125	75 17		 jne	 SHORT $LN8@GCMonkMagi@2

; 22157: 		{
; 22158: 			LogAddC(2, "[0x4A] CGRageAttack() - Invalid Status");

  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
  0012c	6a 02		 push	 2
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00134	83 c4 08	 add	 esp, 8
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx

; 22205: }

  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c3		 ret	 0
$LN8@GCMonkMagi@2:

; 22159: 			return;
; 22160: 		}
; 22161: 
; 22162: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  0013e	0f b6 8e 0c 1c
	00 00		 movzx	 ecx, BYTE PTR [esi+7180]
  00145	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00148	51		 push	 ecx
  00149	52		 push	 edx
  0014a	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0014f	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  00154	85 c0		 test	 eax, eax
  00156	79 29		 jns	 SHORT $LN5@GCMonkMagi@2

; 22163: 		{
; 22164: 			LogAddC(2, "[0x4A] CGRageAttack() - Invalid KillCount");

  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
  0015d	6a 02		 push	 2
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00165	83 c4 08	 add	 esp, 8
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx

; 22205: }

  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
$LN11@GCMonkMagi@2:

; 22165: 			return;
; 22166: 		}
; 22167: 	}
; 22168: 	else
; 22169: 	{
; 22170: 		lpMagic = gObjGetMagic(lpObj, MagicNumber);

  0016f	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  00174	8b f8		 mov	 edi, eax
  00176	83 c4 08	 add	 esp, 8

; 22171: 
; 22172: 		if ( !lpMagic )

  00179	85 ff		 test	 edi, edi
  0017b	0f 84 f5 00 00
	00		 je	 $LN25@GCMonkMagi@2
$LN5@GCMonkMagi@2:

; 22173: 			return;
; 22174: 	}
; 22175: 
; 22176: 	if ( !gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill))

  00181	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00184	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00187	51		 push	 ecx
  00188	53		 push	 ebx
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  0018f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00192	85 c0		 test	 eax, eax
  00194	0f 85 88 00 00
	00		 jne	 $LN4@GCMonkMagi@2

; 22177: 	{
; 22178: 		DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  0019a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  001a0	ff d7		 call	 edi

; 22179: 		
; 22180: 		if ( dwTick > (g_iSkillDiatanceKickCheckTime*1000) )

  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3HA ; g_iSkillDiatanceKickCheckTime
  001a8	2b 86 d4 1f 00
	00		 sub	 eax, DWORD PTR [esi+8148]
  001ae	69 c9 e8 03 00
	00		 imul	 ecx, 1000		; 000003e8H
  001b4	3b c1		 cmp	 eax, ecx
  001b6	76 12		 jbe	 SHORT $LN24@GCMonkMagi@2

; 22181: 		{
; 22182: 			lpObj->m_iSkillDistanceErrorCount = 0;

  001b8	c7 86 d0 1f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+8144], 0

; 22183: 			lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  001c2	ff d7		 call	 edi
  001c4	89 86 d4 1f 00
	00		 mov	 DWORD PTR [esi+8148], eax
$LN24@GCMonkMagi@2:

; 22184: 		}
; 22185: 
; 22186: 		lpObj->m_iSkillDistanceErrorCount++;

  001ca	ff 86 d0 1f 00
	00		 inc	 DWORD PTR [esi+8144]
  001d0	8b 86 d0 1f 00
	00		 mov	 eax, DWORD PTR [esi+8144]

; 22187: 
; 22188: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  001d6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  001dc	0f 8e 94 00 00
	00		 jle	 $LN25@GCMonkMagi@2

; 22189: 		{
; 22190: 			if ( g_iSkillDistanceKick )

  001e2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  001e9	74 26		 je	 SHORT $LN1@GCMonkMagi@2

; 22191: 			{
; 22192: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)",
; 22193: 					lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);

  001eb	50		 push	 eax
  001ec	8d 56 77	 lea	 edx, DWORD PTR [esi+119]
  001ef	52		 push	 edx
  001f0	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  001f3	50		 push	 eax
  001f4	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 22194: 
; 22195: 				CloseClient(lpObj->m_Index);

  001ff	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00207	83 c4 14	 add	 esp, 20			; 00000014H
  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi
  0020c	5b		 pop	 ebx

; 22205: }

  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
$LN1@GCMonkMagi@2:
  00211	5f		 pop	 edi

; 22196: 				return;
; 22197: 			}
; 22198: 
; 22199: 			lpObj->m_iSkillDistanceErrorCount=0;

  00212	c7 86 d0 1f 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+8144], 0
  0021c	5e		 pop	 esi
  0021d	5b		 pop	 ebx

; 22205: }

  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c3		 ret	 0
$LN4@GCMonkMagi@2:

; 22200: 		}
; 22201: 
; 22202: 		return;
; 22203: 	}
; 22204: 	GCMonkMagicAttackNumberSend(&gObj[aIndex],MagicNumber,usernumber,TRUE);

  00222	8b 55 08	 mov	 edx, DWORD PTR _MagicNumber$[ebp]
  00225	8b 4d fc	 mov	 ecx, DWORD PTR tv331[ebp]
  00228	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022e	6a 01		 push	 1
  00230	53		 push	 ebx
  00231	52		 push	 edx
  00232	51		 push	 ecx
  00233	e8 00 00 00 00	 call	 ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMonkMagicAttackNumberSend
  00238	83 c4 10	 add	 esp, 16			; 00000010H
  0023b	5f		 pop	 edi
  0023c	5e		 pop	 esi
  0023d	5b		 pop	 ebx

; 22205: }

  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
$LN17@GCMonkMagi@2:

; 22118: 	{
; 22119: 		LogAdd("error :%s %d %d",__FILE__,__LINE__,usernumber);

  00242	53		 push	 ebx
  00243	68 67 56 00 00	 push	 22119			; 00005667H
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0024d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00258	83 c4 10	 add	 esp, 16			; 00000010H
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5b		 pop	 ebx

; 22205: }

  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
$LN19@GCMonkMagi@2:

; 22112: 	{
; 22113: 		GCMonkMagicAttackNumberSend(&gObj[aIndex],MagicNumber,gObj[aIndex].m_wDarkSideTargetList[0],TRUE);

  00262	0f bf 96 28 26
	00 00		 movsx	 edx, WORD PTR [esi+9768]
  00269	6a 01		 push	 1
  0026b	52		 push	 edx
  0026c	57		 push	 edi
  0026d	56		 push	 esi
  0026e	e8 00 00 00 00	 call	 ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMonkMagicAttackNumberSend
  00273	83 c4 10	 add	 esp, 16			; 00000010H
$LN25@GCMonkMagi@2:
  00276	5f		 pop	 edi
$LN22@GCMonkMagi@2:
  00277	5e		 pop	 esi
  00278	5b		 pop	 ebx

; 22205: }

  00279	8b e5		 mov	 esp, ebp
  0027b	5d		 pop	 ebp
  0027c	c3		 ret	 0
?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; GCMonkMagicAttack
_TEXT	ENDS
PUBLIC	??_C@_0CB@MIHIAHOO@You?5need?5minimum?5premium?5level?51@ ; `string'
PUBLIC	?WarehouseChange@@YAXHPAUCHANGEWAREHOUSE@@@Z	; WarehouseChange
EXTRN	?GetCustom@CZtLicense@@QAEHXZ:PROC		; CZtLicense::GetCustom
;	COMDAT ??_C@_0CB@MIHIAHOO@You?5need?5minimum?5premium?5level?51@
CONST	SEGMENT
??_C@_0CB@MIHIAHOO@You?5need?5minimum?5premium?5level?51@ DB 'You need mi'
	DB	'nimum premium level 1', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?WarehouseChange@@YAXHPAUCHANGEWAREHOUSE@@@Z
_TEXT	SEGMENT
_number$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Request$ = 12						; size = 4
?WarehouseChange@@YAXHPAUCHANGEWAREHOUSE@@@Z PROC	; WarehouseChange, COMDAT

; 22516: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 22517: 	if(!g_ZtLicense.CheckUser(eZtUB::MedoniAndrei) && g_ZtLicense.CheckUser(eZtUB::Local) &&  g_ZtLicense.CheckUser(eZtUB::ProtectDebug) &&
; 22518: 	   !g_ZtLicense.CheckUser(eZtUB::Gredy) && !g_ZtLicense.CheckUser(eZtUB::GredyLocal) && !g_ZtLicense.CheckUser(eZtUB::Gredy2) && 
; 22519: 	   !g_ZtLicense.CheckUser(eZtUB::mu4you) && /*!g_ZtLicense.CheckUser(eZtUB::NSGames) &&*/ 
; 22520: 	   !g_ZtLicense.CheckUser(eZtUB::ulasevich) && !g_ZtLicense.CheckUser(eZtUB::ulasevich2))

  00004	6a 32		 push	 50			; 00000032H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0000b	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00010	84 c0		 test	 al, al
  00012	0f 85 96 00 00
	00		 jne	 $LN19@WarehouseC
  00018	6a 00		 push	 0
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0001f	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00024	84 c0		 test	 al, al
  00026	0f 84 82 00 00
	00		 je	 $LN19@WarehouseC
  0002c	6a 4b		 push	 75			; 0000004bH
  0002e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00033	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00038	84 c0		 test	 al, al
  0003a	74 72		 je	 SHORT $LN19@WarehouseC
  0003c	6a 20		 push	 32			; 00000020H
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00043	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00048	84 c0		 test	 al, al
  0004a	75 62		 jne	 SHORT $LN19@WarehouseC
  0004c	6a 21		 push	 33			; 00000021H
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00053	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00058	84 c0		 test	 al, al
  0005a	75 52		 jne	 SHORT $LN19@WarehouseC
  0005c	6a 22		 push	 34			; 00000022H
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00063	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00068	84 c0		 test	 al, al
  0006a	75 42		 jne	 SHORT $LN19@WarehouseC
  0006c	6a 4e		 push	 78			; 0000004eH
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00073	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00078	84 c0		 test	 al, al
  0007a	75 32		 jne	 SHORT $LN19@WarehouseC
  0007c	6a 17		 push	 23			; 00000017H
  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00083	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00088	84 c0		 test	 al, al
  0008a	75 22		 jne	 SHORT $LN19@WarehouseC
  0008c	6a 24		 push	 36			; 00000024H
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00093	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00098	84 c0		 test	 al, al
  0009a	75 12		 jne	 SHORT $LN19@WarehouseC

; 22521: 	{
; 22522: 		if(!g_ZtLicense.GetCustom())

  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000a1	e8 00 00 00 00	 call	 ?GetCustom@CZtLicense@@QAEHXZ ; CZtLicense::GetCustom
  000a6	85 c0		 test	 eax, eax
  000a8	0f 84 68 01 00
	00		 je	 $LN15@WarehouseC
$LN19@WarehouseC:
  000ae	53		 push	 ebx

; 22523: 		{
; 22524: 			return;
; 22525: 		}	
; 22526: 	}
; 22527: 
; 22528: 	if(!OBJMAX_RANGE(aIndex))

  000af	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  000b2	85 db		 test	 ebx, ebx
  000b4	0f 88 5b 01 00
	00		 js	 $LN20@WarehouseC
  000ba	33 c0		 xor	 eax, eax
  000bc	81 fb 97 3a 00
	00		 cmp	 ebx, 14999		; 00003a97H
  000c2	0f 9e c0	 setle	 al
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 48 01 00
	00		 je	 $LN20@WarehouseC

; 22529: 	{
; 22530: 		return;
; 22531: 	}
; 22532: 
; 22533: 	LPOBJ lpObj = &gObj[aIndex];
; 22534: 
; 22535: 	int number = Request->Number;

  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _Request$[ebp]
  000d0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d8	56		 push	 esi
  000d9	8b f3		 mov	 esi, ebx
  000db	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  000e1	57		 push	 edi

; 22536: 
; 22537: 	if(g_ZtLicense.CheckUser(eZtUB::MedoniAndrei))

  000e2	6a 32		 push	 50			; 00000032H
  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  000e9	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  000ec	89 55 fc	 mov	 DWORD PTR _number$[ebp], edx
  000ef	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  000f4	84 c0		 test	 al, al
  000f6	74 78		 je	 SHORT $LN3@WarehouseC

; 22538: 	{
; 22539: 		if(number == 2)

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  000fb	83 f8 02	 cmp	 eax, 2
  000fe	75 22		 jne	 SHORT $LN10@WarehouseC

; 22540: 		{
; 22541: 			if(lpObj->PremiumTimeType < 1)

  00100	83 bf bc 22 00
	00 01		 cmp	 DWORD PTR [edi+8892], 1
  00107	7d 67		 jge	 SHORT $LN3@WarehouseC

; 22542: 			{
; 22543: 				GCServerMsgStringSend("You need minimum premium level 1", lpObj->m_Index, 1);

  00109	8b 07		 mov	 eax, DWORD PTR [edi]
  0010b	6a 01		 push	 1
  0010d	50		 push	 eax
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MIHIAHOO@You?5need?5minimum?5premium?5level?51@
  00113	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 22588: 		return;
; 22589: 	}
; 22590: 	#endif
; 22591: 
; 22592: 	GDGetWarehouseList(aIndex, gObj[aIndex].AccountID, lpObj->WarehouseNumber);

  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx

; 22593: }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN10@WarehouseC:

; 22544: 				return;
; 22545: 			}
; 22546: 		}
; 22547: 		else if(number == 3)

  00122	83 f8 03	 cmp	 eax, 3
  00125	75 22		 jne	 SHORT $LN7@WarehouseC

; 22548: 		{
; 22549: 			if(lpObj->PremiumTimeType < 2)

  00127	83 bf bc 22 00
	00 02		 cmp	 DWORD PTR [edi+8892], 2
  0012e	7d 40		 jge	 SHORT $LN3@WarehouseC

; 22550: 			{
; 22551: 				GCServerMsgStringSend("You need minimum premium level 1", lpObj->m_Index, 1);

  00130	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00132	6a 01		 push	 1
  00134	51		 push	 ecx
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MIHIAHOO@You?5need?5minimum?5premium?5level?51@
  0013a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 22588: 		return;
; 22589: 	}
; 22590: 	#endif
; 22591: 
; 22592: 	GDGetWarehouseList(aIndex, gObj[aIndex].AccountID, lpObj->WarehouseNumber);

  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx

; 22593: }

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
$LN7@WarehouseC:

; 22552: 				return;
; 22553: 			}
; 22554: 		}
; 22555: 		else if(number == 4)

  00149	83 f8 04	 cmp	 eax, 4
  0014c	75 22		 jne	 SHORT $LN3@WarehouseC

; 22556: 		{
; 22557: 			if(lpObj->PremiumTimeType < 3)

  0014e	83 bf bc 22 00
	00 03		 cmp	 DWORD PTR [edi+8892], 3
  00155	7d 19		 jge	 SHORT $LN3@WarehouseC

; 22558: 			{
; 22559: 				GCServerMsgStringSend("You need minimum premium level 1", lpObj->m_Index, 1);

  00157	8b 17		 mov	 edx, DWORD PTR [edi]
  00159	6a 01		 push	 1
  0015b	52		 push	 edx
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MIHIAHOO@You?5need?5minimum?5premium?5level?51@
  00161	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 22588: 		return;
; 22589: 	}
; 22590: 	#endif
; 22591: 
; 22592: 	GDGetWarehouseList(aIndex, gObj[aIndex].AccountID, lpObj->WarehouseNumber);

  00166	83 c4 0c	 add	 esp, 12			; 0000000cH
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx

; 22593: }

  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
$LN3@WarehouseC:

; 22560: 				return;
; 22561: 			}
; 22562: 		}
; 22563: 	}
; 22564: 
; 22565: 	CGWarehouseUseEnd(aIndex);

  00170	53		 push	 ebx
  00171	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd

; 22566: 
; 22567: 	if ( gObj[aIndex].m_ReqWarehouseOpen != false )

  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017b	83 c4 04	 add	 esp, 4
  0017e	80 bc 06 1c 11
	00 00 00	 cmp	 BYTE PTR [esi+eax+4380], 0
  00186	0f 85 87 00 00
	00		 jne	 $LN21@WarehouseC

; 22568: 	{
; 22569: 		return;
; 22570: 	}
; 22571: 		
; 22572: 	gObj[aIndex].m_ReqWarehouseOpen = true;
; 22573: 	lpObj->m_IfState.type = 6;
; 22574: 	lpObj->m_IfState.state = 0;
; 22575: 
; 22576: 	gObj[aIndex].WarehouseCount = 0;
; 22577: 
; 22578: 	lpObj->WarehouseNumber = Request->Number;

  0018c	8b 55 0c	 mov	 edx, DWORD PTR _Request$[ebp]
  0018f	c6 84 06 1c 11
	00 00 01	 mov	 BYTE PTR [esi+eax+4380], 1
  00197	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  0019d	25 83 01 ff ff	 and	 eax, -65149		; ffff0183H
  001a2	0d 80 01 00 00	 or	 eax, 384		; 00000180H
  001a7	89 87 1c 0e 00
	00		 mov	 DWORD PTR [edi+3612], eax
  001ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b3	c6 84 0e 64 0e
	00 00 00	 mov	 BYTE PTR [esi+ecx+3684], 0
  001bb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 22579: 
; 22580: 	lpObj->WareChange = true;
; 22581: 
; 22582: 	WarehouseNumberSend(aIndex);

  001be	53		 push	 ebx
  001bf	89 87 e8 2a 00
	00		 mov	 DWORD PTR [edi+10984], eax
  001c5	c6 87 e5 2a 00
	00 01		 mov	 BYTE PTR [edi+10981], 1
  001cc	e8 00 00 00 00	 call	 ?WarehouseNumberSend@@YAXH@Z ; WarehouseNumberSend

; 22583: 
; 22584: 	#if(DEV_GUILDBANK)
; 22585: 	if(g_GuildBank.m_iEnable == 1 && gObj[aIndex].m_bGuildBank == true)

  001d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d6	83 c4 04	 add	 esp, 4
  001d9	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_GuildBank@@3VCGuildBank@@A, 1
  001e0	75 1c		 jne	 SHORT $LN1@WarehouseC
  001e2	80 bc 06 25 2b
	00 00 01	 cmp	 BYTE PTR [esi+eax+11045], 1
  001ea	75 12		 jne	 SHORT $LN1@WarehouseC

; 22586: 	{
; 22587: 		g_GuildBank.GDGetGuildWarehouseList(aIndex);

  001ec	53		 push	 ebx
  001ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  001f2	e8 00 00 00 00	 call	 ?GDGetGuildWarehouseList@CGuildBank@@QAEXH@Z ; CGuildBank::GDGetGuildWarehouseList
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx

; 22593: }

  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
$LN1@WarehouseC:

; 22588: 		return;
; 22589: 	}
; 22590: 	#endif
; 22591: 
; 22592: 	GDGetWarehouseList(aIndex, gObj[aIndex].AccountID, lpObj->WarehouseNumber);

  001fe	8b 8f e8 2a 00
	00		 mov	 ecx, DWORD PTR [edi+10984]
  00204	51		 push	 ecx
  00205	8d 54 06 6c	 lea	 edx, DWORD PTR [esi+eax+108]
  00209	52		 push	 edx
  0020a	53		 push	 ebx
  0020b	e8 00 00 00 00	 call	 ?GDGetWarehouseList@@YAXHPADH@Z ; GDGetWarehouseList
  00210	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@WarehouseC:
  00213	5f		 pop	 edi
  00214	5e		 pop	 esi
$LN20@WarehouseC:
  00215	5b		 pop	 ebx
$LN15@WarehouseC:

; 22593: }

  00216	8b e5		 mov	 esp, ebp
  00218	5d		 pop	 ebp
  00219	c3		 ret	 0
?WarehouseChange@@YAXHPAUCHANGEWAREHOUSE@@@Z ENDP	; WarehouseChange
_TEXT	ENDS
PUBLIC	??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ ; `string'
PUBLIC	??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@ ; `string'
PUBLIC	??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ ; `string'
PUBLIC	??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@ ; `string'
PUBLIC	??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@ ; `string'
PUBLIC	??_C@_0BB@JFCMJMCM@Block?5Vault?5Item?$AA@	; `string'
PUBLIC	??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@ ; `string'
PUBLIC	??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@ ; `string'
PUBLIC	??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@ ; `string'
PUBLIC	??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@ ; `string'
PUBLIC	??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@ ; `string'
PUBLIC	??_C@_0DB@KDBIJMEN@?$FLWARNING?$FN?$FLMax?5Ext?5Move?$FN?5Item?5NO?5@ ; `string'
PUBLIC	??_C@_0DF@BCBKEBOO@?$FLWARNING?$FN?$FLMax?5Level?5Move?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0CL@LEDDKODE@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Trad@ ; `string'
PUBLIC	??_C@_0CH@PDJNELOM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0CG@NCLKDPAM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0DB@JNEAPMCJ@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ ; `string'
PUBLIC	??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@ ; `string'
PUBLIC	_aIndex$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
EXTRN	?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjInventoryTradeMove
EXTRN	?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeInventoryMove
EXTRN	?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeTradeMove
EXTRN	?SendPeriodItemInfoOnce@CPeriodItemZt@@QAE_NPAUOBJECTSTRUCT@@PAVCItem@@@Z:PROC ; CPeriodItemZt::SendPeriodItemInfoOnce
EXTRN	?CheckVault@CItemMove@@QAE_NH@Z:PROC		; CItemMove::CheckVault
EXTRN	?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z:PROC	; GetItemAttr
;	COMDAT ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
CONST	SEGMENT
??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ DB '['
	DB	'%s][%s] error-L1 : used not Chaosbox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@
CONST	SEGMENT
??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@ DB '['
	DB	'%s][%s] error-L1 : used not DarkTrainerBox', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
CONST	SEGMENT
??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ DB '['
	DB	'%s][%s] error-L1 : used not ChaosBox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@
CONST	SEGMENT
??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@ DB 'Pay WareHo'
	DB	'use Money(In WareHouse) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@
CONST	SEGMENT
??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@ DB 'Pay WareHo'
	DB	'use Money(In Inventory) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFCMJMCM@Block?5Vault?5Item?$AA@
CONST	SEGMENT
??_C@_0BB@JFCMJMCM@Block?5Vault?5Item?$AA@ DB 'Block Vault Item', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@
CONST	SEGMENT
??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@ DB '['
	DB	'%s][%s] error-L1 : used not Trade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@
CONST	SEGMENT
??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@ DB '['
	DB	'%s][%s] error-L3 : SocketItem Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@
CONST	SEGMENT
??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@ DB '['
	DB	'%s][%s] error-L3 : JewelOfHarmony Mixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@
CONST	SEGMENT
??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@ DB '['
	DB	'%s][%s] error-L3 : DarkTrainerBoxMixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@
CONST	SEGMENT
??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@ DB '['
	DB	'%s][%s] error-L3 : CBMixing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KDBIJMEN@?$FLWARNING?$FN?$FLMax?5Ext?5Move?$FN?5Item?5NO?5@
CONST	SEGMENT
??_C@_0DB@KDBIJMEN@?$FLWARNING?$FN?$FLMax?5Ext?5Move?$FN?5Item?5NO?5@ DB '['
	DB	'WARNING][Max Ext Move] Item NO Move Ext >= (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BCBKEBOO@?$FLWARNING?$FN?$FLMax?5Level?5Move?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0DF@BCBKEBOO@?$FLWARNING?$FN?$FLMax?5Level?5Move?$FN?5Item?5N@ DB '['
	DB	'WARNING][Max Level Move] Item NO Move Level >= (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LEDDKODE@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Trad@
CONST	SEGMENT
??_C@_0CL@LEDDKODE@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Trad@ DB '['
	DB	'WARNING][All Item] Item NO Trade, Ps Shop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PDJNELOM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0CH@PDJNELOM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ DB '['
	DB	'WARNING][Serial -1 Item] Item NO Ware', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NCLKDPAM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0CG@NCLKDPAM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ DB '['
	DB	'WARNING][Serial -1 Item] Item NO Mix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JNEAPMCJ@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
CONST	SEGMENT
??_C@_0DB@JNEAPMCJ@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@ DB '['
	DB	'WARNING][Serial -1 Item] Item NO Trade, Ps Shop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
CONST	SEGMENT
??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@ DB '[%s][%d'
	DB	'] error-L3', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z
_TEXT	SEGMENT
_DurTSend$246468 = -308					; size = 4
_DurSSend$246467 = -304					; size = 4
_target$ = -300						; size = 4
_source$ = -296						; size = 4
tv1545 = -292						; size = 4
tv1543 = -292						; size = 4
tv1535 = -292						; size = 4
tv1533 = -292						; size = 4
tv1425 = -292						; size = 4
tv1408 = -288						; size = 4
_result$ = -284						; size = 1
_it_type$ = -284					; size = 4
tv1548 = -282						; size = 2
tv1538 = -282						; size = 2
_lpObj$ = -280						; size = 4
_aIndex$GSCopy$ = -276					; size = 4
_szTemp$246398 = -272					; size = 256
_ItemInfo$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z PROC ; CGInventoryItemMove, COMDAT

; 5773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 5774 : 	BYTE result;
; 5775 : 	BYTE ItemInfo[MAX_ITEM_INFO];
; 5776 : 
; 5777 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00021	8b df		 mov	 ebx, edi
  00023	69 db 50 2b 00
	00		 imul	 ebx, 11088		; 00002b50H
  00029	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  0002c	51		 push	 ecx
  0002d	89 bd ec fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$[ebp], edi
  00033	89 9d e0 fe ff
	ff		 mov	 DWORD PTR tv1408[ebp], ebx
  00039	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 25		 jne	 SHORT $LN143@CGInventor@3
$LN189@CGInventor@3:

; 5778 : 	{
; 5779 : 		::GCItemMoveResultSend(aIndex, -1, 0, ItemInfo);

  00045	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00048	52		 push	 edx
  00049	6a 00		 push	 0
  0004b	68 ff 00 00 00	 push	 255			; 000000ffH
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00056	83 c4 10	 add	 esp, 16			; 00000010H
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN143@CGInventor@3:

; 5780 : 		return;
; 5781 : 	}
; 5782 : 
; 5783 : 	if ( !::gObjIsConnectedGP(aIndex))

  0006a	57		 push	 edi
  0006b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 3c		 jne	 SHORT $LN142@CGInventor@3

; 5784 : 	{
; 5785 : 		LogAddC(2,"[%s][%d] error-L3", __FILE__, __LINE__);

  00077	68 99 16 00 00	 push	 5785			; 00001699H
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
  00086	6a 02		 push	 2
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 5786 : 		::GCItemMoveResultSend(aIndex, -1, 0, ItemInfo);

  0008e	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00091	50		 push	 eax
$LN190@CGInventor@3:
  00092	6a 00		 push	 0
  00094	68 ff 00 00 00	 push	 255			; 000000ffH
  00099	57		 push	 edi
  0009a	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0009f	83 c4 20	 add	 esp, 32			; 00000020H
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	33 cd		 xor	 ecx, ebp
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
$LN142@CGInventor@3:

; 5787 : 		return;
; 5788 : 	}
; 5789 : 
; 5790 : 	LPOBJ lpObj = &gObj[aIndex];

  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5791 : 	int it_type = 0;
; 5792 : 
; 5793 : 	if ( lpObj->m_ReqWarehouseOpen != false )

  000b9	80 bc 0b 1c 11
	00 00 00	 cmp	 BYTE PTR [ebx+ecx+4380], 0
  000c1	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000c4	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax
  000ca	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _it_type$[ebp], 0
  000d4	74 1d		 je	 SHORT $LN141@CGInventor@3

; 5794 : 	{
; 5795 : 		LogAddC(2,"[%s][%d] error-L3", __FILE__, __LINE__);

  000d6	68 a3 16 00 00	 push	 5795			; 000016a3H
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
  000e5	6a 02		 push	 2
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 5796 : 		GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  000ed	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  000f0	52		 push	 edx

; 5797 : 		return;

  000f1	eb 9f		 jmp	 SHORT $LN190@CGInventor@3
$LN141@CGInventor@3:

; 5798 : 	}
; 5799 : 
; 5800 : 	int source = lpMsg->source_item_num;

  000f3	0f b6 5e 04	 movzx	 ebx, BYTE PTR [esi+4]

; 5801 : 	int target = lpMsg->target_item_num;
; 5802 : 
; 5803 : #if(Negative_Number)
; 5804 : 	CItem* BCheckItem = &lpObj->pInventory[source];

  000f7	8b 80 24 0e 00
	00		 mov	 eax, DWORD PTR [eax+3620]
  000fd	0f b6 4e 12	 movzx	 ecx, BYTE PTR [esi+18]
  00101	89 9d d8 fe ff
	ff		 mov	 DWORD PTR _source$[ebp], ebx
  00107	69 db d4 00 00
	00		 imul	 ebx, 212		; 000000d4H
  0010d	03 c3		 add	 eax, ebx

; 5805 : 	//LogAddC(1, "CGInventoryItemMove Item %s (%d) %d -> %d", BCheckItem->GetName(), BCheckItem->m_Number, lpMsg->sFlag, lpMsg->tFlag);
; 5806 : 
; 5807 : 	//==Check Seri -1
; 5808 : 	if ((int)BCheckItem->m_Number < 0)

  0010f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00112	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _target$[ebp], ecx
  00118	89 9d dc fe ff
	ff		 mov	 DWORD PTR tv1425[ebp], ebx
  0011e	0f 8d 85 00 00
	00		 jge	 $LN135@CGInventor@3

; 5809 : 	{
; 5810 : 		if (ZtConfig.CommonServer.MembItemLimit && lpMsg->tFlag == 1 || lpMsg->tFlag == 4) //Cam Giao Dich, Treo Shop

  00124	83 3d 50 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+336, 0
  0012b	74 06		 je	 SHORT $LN137@CGInventor@3
  0012d	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  00131	74 08		 je	 SHORT $LN138@CGInventor@3
$LN137@CGInventor@3:
  00133	8a 4e 11	 mov	 cl, BYTE PTR [esi+17]
  00136	80 f9 04	 cmp	 cl, 4
  00139	75 30		 jne	 SHORT $LN139@CGInventor@3
$LN138@CGInventor@3:

; 5811 : 		{
; 5812 : 			MsgOutput(aIndex, "[WARNING][Serial -1 Item] Item NO Trade, Ps Shop");

  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JNEAPMCJ@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
$LN192@CGInventor@3:
  00140	57		 push	 edi
  00141	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5813 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)& ItemInfo);

  00146	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00149	52		 push	 edx
$LN191@CGInventor@3:
  0014a	6a 00		 push	 0
  0014c	68 ff 00 00 00	 push	 255			; 000000ffH
  00151	57		 push	 edi
  00152	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00157	83 c4 18	 add	 esp, 24			; 00000018H
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN139@CGInventor@3:

; 5814 : 			return;
; 5815 : 		}
; 5816 : 		if (ZtConfig.CommonServer.MembItemMixLimit && lpMsg->tFlag == 3) //Cam Chao Mix

  0016b	83 3d 54 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+340, 0
  00172	74 16		 je	 SHORT $LN136@CGInventor@3
  00174	80 f9 03	 cmp	 cl, 3
  00177	75 11		 jne	 SHORT $LN136@CGInventor@3

; 5817 : 		{
; 5818 : 			MsgOutput(aIndex, "[WARNING][Serial -1 Item] Item NO Mix");

  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NCLKDPAM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
  0017e	57		 push	 edi
  0017f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5819 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)& ItemInfo);

  00184	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00187	50		 push	 eax

; 5820 : 			return;

  00188	eb c0		 jmp	 SHORT $LN191@CGInventor@3
$LN136@CGInventor@3:

; 5821 : 		}
; 5822 : 		if (ZtConfig.CommonServer.MembItemWareLimit && lpMsg->tFlag == 2) //Cam Ware

  0018a	83 3d 58 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+344, 0
  00191	74 16		 je	 SHORT $LN135@CGInventor@3
  00193	80 f9 02	 cmp	 cl, 2
  00196	75 11		 jne	 SHORT $LN135@CGInventor@3

; 5823 : 		{
; 5824 : 			MsgOutput(aIndex, "[WARNING][Serial -1 Item] Item NO Ware");

  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PDJNELOM@?$FLWARNING?$FN?$FLSerial?5?91?5Item?$FN?5Item?5N@
  0019d	57		 push	 edi
  0019e	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5825 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)& ItemInfo);

  001a3	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  001a6	51		 push	 ecx

; 5826 : 			return;

  001a7	eb a1		 jmp	 SHORT $LN191@CGInventor@3
$LN135@CGInventor@3:

; 5827 : 		}
; 5828 : 	}
; 5829 : 	//==Check All Item
; 5830 : 	if (ZtConfig.CommonServer.NorItemLimit && lpMsg->tFlag == 1 || lpMsg->tFlag == 4)

  001a9	83 3d 5c 01 00
	00 00		 cmp	 DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+348, 0
  001b0	74 06		 je	 SHORT $LN132@CGInventor@3
  001b2	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  001b6	74 08		 je	 SHORT $LN133@CGInventor@3
$LN132@CGInventor@3:
  001b8	8a 4e 11	 mov	 cl, BYTE PTR [esi+17]
  001bb	80 f9 04	 cmp	 cl, 4
  001be	75 0a		 jne	 SHORT $LN134@CGInventor@3
$LN133@CGInventor@3:

; 5831 : 	{
; 5832 : 		//LogAddTD("[WARNING][Max Level Sell] Item NO SELL Level >= (%d)", ZtConfig.CommonServer.NorItemLevel);
; 5833 : 		MsgOutput(aIndex, "[WARNING][All Item] Item NO Trade, Ps Shop");

  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LEDDKODE@?$FLWARNING?$FN?$FLAll?5Item?$FN?5Item?5NO?5Trad@

; 5834 : 		::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)& ItemInfo);
; 5835 : 		return;

  001c5	e9 76 ff ff ff	 jmp	 $LN192@CGInventor@3
$LN134@CGInventor@3:

; 5836 : 	}
; 5837 : 	//==Check Item Level Max
; 5838 : 	if ((int)BCheckItem->m_Level >= ZtConfig.CommonServer.NorItemLevel && lpMsg->tFlag >= 1 && lpMsg->tFlag <= 4)

  001ca	0f bf 78 08	 movsx	 edi, WORD PTR [eax+8]
  001ce	8b 15 60 01 00
	00		 mov	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+352
  001d4	3b fa		 cmp	 edi, edx
  001d6	7c 41		 jl	 SHORT $LN131@CGInventor@3
  001d8	80 f9 01	 cmp	 cl, 1
  001db	72 3c		 jb	 SHORT $LN131@CGInventor@3
  001dd	80 f9 04	 cmp	 cl, 4
  001e0	77 37		 ja	 SHORT $LN131@CGInventor@3

; 5839 : 	{
; 5840 : 		//LogAddTD("[WARNING][Max Level Sell] Item NO SELL Level >= (%d)", ZtConfig.CommonServer.NorItemLevel);
; 5841 : 		MsgOutput(aIndex, "[WARNING][Max Level Move] Item NO Move Level >= (%d)", ZtConfig.CommonServer.NorItemLevel);

  001e2	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  001e8	52		 push	 edx
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BCBKEBOO@?$FLWARNING?$FN?$FLMax?5Level?5Move?$FN?5Item?5N@
  001ee	56		 push	 esi
  001ef	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5842 : 		::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)& ItemInfo);

  001f4	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  001f7	50		 push	 eax
  001f8	6a 00		 push	 0
  001fa	68 ff 00 00 00	 push	 255			; 000000ffH
  001ff	56		 push	 esi
  00200	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5926 : 			LogAdd("[%s][%s] error-L1 : used not Chaosbox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00205	83 c4 1c	 add	 esp, 28			; 0000001cH
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  0020b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020e	33 cd		 xor	 ecx, ebp
  00210	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c3		 ret	 0
$LN131@CGInventor@3:

; 5843 : 		return;
; 5844 : 	}
; 5845 : 	//==Check Item Count Exl
; 5846 : 	if (GetExcOptionCount(BCheckItem->m_NewOption) >= ZtConfig.CommonServer.NorItemExt && lpMsg->tFlag >= 1 && lpMsg->tFlag <= 4)

  00219	0f b6 88 97 00
	00 00		 movzx	 ecx, BYTE PTR [eax+151]
  00220	51		 push	 ecx
  00221	e8 00 00 00 00	 call	 ?GetExcOptionCount@@YAEE@Z ; GetExcOptionCount
  00226	0f b6 d0	 movzx	 edx, al
  00229	83 c4 04	 add	 esp, 4
  0022c	3b 15 64 01 00
	00		 cmp	 edx, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+356
  00232	7c 47		 jl	 SHORT $LN130@CGInventor@3
  00234	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00237	3c 01		 cmp	 al, 1
  00239	72 40		 jb	 SHORT $LN130@CGInventor@3
  0023b	3c 04		 cmp	 al, 4
  0023d	77 3c		 ja	 SHORT $LN130@CGInventor@3

; 5847 : 	{
; 5848 : 		//LogAddTD("[WARNING][Max Ext Sell] Item NO SELL Ext >= (%d)", ZtConfig.CommonServer.NorItemLevel);
; 5849 : 		MsgOutput(aIndex, "[WARNING][Max Ext Move] Item NO Move Ext >= (%d)", ZtConfig.CommonServer.NorItemLevel);

  0023f	a1 60 01 00 00	 mov	 eax, DWORD PTR ?ZtConfig@@3VcZtConfigs@@A+352
  00244	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  0024a	50		 push	 eax
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KDBIJMEN@?$FLWARNING?$FN?$FLMax?5Ext?5Move?$FN?5Item?5NO?5@
  00250	56		 push	 esi
  00251	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5850 : 		::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)& ItemInfo);

  00256	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00259	51		 push	 ecx
  0025a	6a 00		 push	 0
  0025c	68 ff 00 00 00	 push	 255			; 000000ffH
  00261	56		 push	 esi
  00262	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5926 : 			LogAdd("[%s][%s] error-L1 : used not Chaosbox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00267	83 c4 1c	 add	 esp, 28			; 0000001cH
  0026a	5f		 pop	 edi
  0026b	5e		 pop	 esi
  0026c	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  0026d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00270	33 cd		 xor	 ecx, ebp
  00272	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00277	8b e5		 mov	 esp, ebp
  00279	5d		 pop	 ebp
  0027a	c3		 ret	 0
$LN130@CGInventor@3:

; 5851 : 		return;
; 5852 : 	}
; 5853 : #endif
; 5854 : 
; 5855 : 	if ( lpMsg->tFlag == 2 || lpMsg->sFlag == 2 )

  0027b	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0027e	3c 02		 cmp	 al, 2
  00280	74 06		 je	 SHORT $LN128@CGInventor@3
  00282	80 7e 03 02	 cmp	 BYTE PTR [esi+3], 2
  00286	75 0a		 jne	 SHORT $LN149@CGInventor@3
$LN128@CGInventor@3:

; 5856 : 	{
; 5857 : 		it_type = 6;

  00288	c7 85 e4 fe ff
	ff 06 00 00 00	 mov	 DWORD PTR _it_type$[ebp], 6
$LN149@CGInventor@3:

; 5858 : 	}
; 5859 : 
; 5860 : 	if ( lpMsg->tFlag == 0 && lpMsg->sFlag == 0 )

  00292	b9 08 00 00 00	 mov	 ecx, 8
  00297	84 c0		 test	 al, al
  00299	75 15		 jne	 SHORT $LN124@CGInventor@3
  0029b	38 46 03	 cmp	 BYTE PTR [esi+3], al
  0029e	75 06		 jne	 SHORT $LN160@CGInventor@3

; 5861 : 	{
; 5862 : 		it_type = 8;

  002a0	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _it_type$[ebp], ecx
$LN160@CGInventor@3:

; 5863 : 	}
; 5864 : 
; 5865 : 	if ( (lpMsg->tFlag == 0 && lpMsg->sFlag == 4) || (lpMsg->tFlag == 4 && lpMsg->sFlag == 0) || (lpMsg->tFlag == 4 && lpMsg->sFlag == 4) )

  002a6	84 c0		 test	 al, al
  002a8	75 06		 jne	 SHORT $LN124@CGInventor@3
  002aa	80 7e 03 04	 cmp	 BYTE PTR [esi+3], 4
  002ae	74 13		 je	 SHORT $LN125@CGInventor@3
$LN124@CGInventor@3:
  002b0	3c 04		 cmp	 al, 4
  002b2	75 15		 jne	 SHORT $LN161@CGInventor@3
  002b4	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  002b8	74 09		 je	 SHORT $LN125@CGInventor@3
  002ba	3a c0		 cmp	 al, al
  002bc	75 0b		 jne	 SHORT $LN161@CGInventor@3
  002be	38 46 03	 cmp	 BYTE PTR [esi+3], al
  002c1	75 06		 jne	 SHORT $LN161@CGInventor@3
$LN125@CGInventor@3:

; 5866 : 	{
; 5867 : 		it_type = 8;

  002c3	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _it_type$[ebp], ecx
$LN161@CGInventor@3:

; 5868 : 	}
; 5869 : 
; 5870 : 	if( (lpMsg->tFlag == lpMsg->sFlag) && (source == target)) //season 3.0 add-on (New-Antihack)

  002c9	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  002cc	75 39		 jne	 SHORT $LN150@CGInventor@3
  002ce	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _source$[ebp]
  002d4	3b 95 d4 fe ff
	ff		 cmp	 edx, DWORD PTR _target$[ebp]
  002da	75 2b		 jne	 SHORT $LN150@CGInventor@3
$LN194@CGInventor@3:

; 5871 : 	{
; 5872 : 		GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  002dc	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  002e2	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  002e5	50		 push	 eax
  002e6	6a 00		 push	 0
  002e8	68 ff 00 00 00	 push	 255			; 000000ffH
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  002f3	83 c4 10	 add	 esp, 16			; 00000010H
  002f6	5f		 pop	 edi
  002f7	5e		 pop	 esi
  002f8	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  002f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fc	33 cd		 xor	 ecx, ebp
  002fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00303	8b e5		 mov	 esp, ebp
  00305	5d		 pop	 ebp
  00306	c3		 ret	 0
$LN150@CGInventor@3:

; 5873 : 		return;
; 5874 : 	}
; 5875 : 
; 5876 : 	 if(THINNAKORN_MAC || g_ZtLicense.CheckUser(eZtUB::Gredy) || g_ZtLicense.CheckUser(eZtUB::GredyLocal) || g_ZtLicense.CheckUser(eZtUB::Gredy2))

  00307	6a 20		 push	 32			; 00000020H
  00309	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  0030e	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00313	84 c0		 test	 al, al
  00315	0f 85 94 00 00
	00		 jne	 $LN151@CGInventor@3
  0031b	6a 21		 push	 33			; 00000021H
  0031d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00322	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  00327	84 c0		 test	 al, al
  00329	0f 85 80 00 00
	00		 jne	 $LN151@CGInventor@3
  0032f	6a 22		 push	 34			; 00000022H
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtLicense@@3VCZtLicense@@A ; g_ZtLicense
  00336	e8 00 00 00 00	 call	 ?CheckUser@CZtLicense@@QAE_NH@Z ; CZtLicense::CheckUser
  0033b	84 c0		 test	 al, al
  0033d	75 70		 jne	 SHORT $LN151@CGInventor@3

; 5877 : 	 {
; 5878 : 
; 5879 : 	 }
; 5880 : 	 else
; 5881 : 	 {
; 5882 : 		if (::gObjCanItemTouch(lpObj, it_type) == FALSE)

  0033f	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _it_type$[ebp]
  00345	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  0034b	52		 push	 edx
  0034c	57		 push	 edi
  0034d	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00352	83 c4 08	 add	 esp, 8
  00355	85 c0		 test	 eax, eax
  00357	75 5c		 jne	 SHORT $LN120@CGInventor@3

; 5883 : 		{
; 5884 : 			if ( lpMsg->sItemInfo[0] == ITEMGET(4,7) || lpMsg->sItemInfo[0] == ITEMGET(4,15) )

  00359	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0035d	3d 07 08 00 00	 cmp	 eax, 2055		; 00000807H
  00362	74 0b		 je	 SHORT $LN116@CGInventor@3
  00364	3d 0f 08 00 00	 cmp	 eax, 2063		; 0000080fH

; 5890 : 				}
; 5891 : 			}
; 5892 : 			else
; 5893 : 			{
; 5894 : 				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 5895 : 				return;

  00369	0f 85 6d ff ff
	ff		 jne	 $LN194@CGInventor@3
$LN116@CGInventor@3:

; 5885 : 			{
; 5886 : 				if ( target >= 12 || source < 12 )

  0036f	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00374	39 85 d4 fe ff
	ff		 cmp	 DWORD PTR _target$[ebp], eax
  0037a	7d 08		 jge	 SHORT $LN114@CGInventor@3
  0037c	39 85 d8 fe ff
	ff		 cmp	 DWORD PTR _source$[ebp], eax
  00382	7d 31		 jge	 SHORT $LN120@CGInventor@3
$LN114@CGInventor@3:

; 5887 : 				{
; 5888 : 					::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00384	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0038a	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  0038d	52		 push	 edx
  0038e	6a 00		 push	 0
  00390	68 ff 00 00 00	 push	 255			; 000000ffH
  00395	50		 push	 eax
  00396	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0039b	83 c4 10	 add	 esp, 16			; 00000010H
  0039e	5f		 pop	 edi
  0039f	5e		 pop	 esi
  003a0	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  003a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a4	33 cd		 xor	 ecx, ebp
  003a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ab	8b e5		 mov	 esp, ebp
  003ad	5d		 pop	 ebp
  003ae	c3		 ret	 0
$LN151@CGInventor@3:

; 5889 : 					return;

  003af	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
$LN120@CGInventor@3:

; 5896 : 			}
; 5897 : 		}
; 5898 : 	 }
; 5899 : 
; 5900 : 	if ( lpObj->DieRegen != FALSE )

  003b5	80 bf a2 03 00
	00 00		 cmp	 BYTE PTR [edi+930], 0
  003bc	74 2b		 je	 SHORT $LN112@CGInventor@3

; 5901 : 	{
; 5902 : 		::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  003be	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  003c4	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  003c7	51		 push	 ecx
  003c8	6a 00		 push	 0
  003ca	68 ff 00 00 00	 push	 255			; 000000ffH
  003cf	52		 push	 edx
  003d0	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  003d5	83 c4 10	 add	 esp, 16			; 00000010H
  003d8	5f		 pop	 edi
  003d9	5e		 pop	 esi
  003da	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  003db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003de	33 cd		 xor	 ecx, ebp
  003e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e5	8b e5		 mov	 esp, ebp
  003e7	5d		 pop	 ebp
  003e8	c3		 ret	 0
$LN112@CGInventor@3:

; 5903 : 		return;
; 5904 : 	}
; 5905 : 
; 5906 : 	ItemInfo[0] = lpMsg->sItemInfo[0];
; 5907 : 	ItemInfo[1] = lpMsg->sItemInfo[1];

  003e9	0f b6 4e 06	 movzx	 ecx, BYTE PTR [esi+6]
  003ed	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]

; 5908 : 	ItemInfo[2] = lpMsg->sItemInfo[2];

  003f1	0f b6 56 07	 movzx	 edx, BYTE PTR [esi+7]
  003f5	88 4d f1	 mov	 BYTE PTR _ItemInfo$[ebp+1], cl

; 5909 : 	ItemInfo[3] = lpMsg->sItemInfo[3];
; 5910 : 	ItemInfo[4] = lpMsg->sItemInfo[4];

  003f8	0f b6 4e 09	 movzx	 ecx, BYTE PTR [esi+9]
  003fc	88 45 f0	 mov	 BYTE PTR _ItemInfo$[ebp], al
  003ff	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  00403	88 55 f2	 mov	 BYTE PTR _ItemInfo$[ebp+2], dl

; 5911 : 	ItemInfo[5] = lpMsg->sItemInfo[5];

  00406	0f b6 56 0a	 movzx	 edx, BYTE PTR [esi+10]
  0040a	88 4d f4	 mov	 BYTE PTR _ItemInfo$[ebp+4], cl

; 5912 : 	ItemInfo[6] = lpMsg->sItemInfo[6];
; 5913 : 
; 5914 : 	//season4 add-on
; 5915 : 	ItemInfo[7] = lpMsg->sItemInfo[7];

  0040d	0f b6 4e 0c	 movzx	 ecx, BYTE PTR [esi+12]
  00411	88 45 f3	 mov	 BYTE PTR _ItemInfo$[ebp+3], al
  00414	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  00418	88 55 f5	 mov	 BYTE PTR _ItemInfo$[ebp+5], dl

; 5916 : 	ItemInfo[8] = lpMsg->sItemInfo[8];

  0041b	0f b6 56 0d	 movzx	 edx, BYTE PTR [esi+13]
  0041f	88 4d f7	 mov	 BYTE PTR _ItemInfo$[ebp+7], cl

; 5917 : 	ItemInfo[9] = lpMsg->sItemInfo[9];
; 5918 : 	ItemInfo[10] = lpMsg->sItemInfo[10];

  00422	0f b6 4e 0f	 movzx	 ecx, BYTE PTR [esi+15]
  00426	88 45 f6	 mov	 BYTE PTR _ItemInfo$[ebp+6], al
  00429	0f b6 46 0e	 movzx	 eax, BYTE PTR [esi+14]
  0042d	88 55 f8	 mov	 BYTE PTR _ItemInfo$[ebp+8], dl

; 5919 : 	ItemInfo[11] = lpMsg->sItemInfo[11];

  00430	0f b6 56 10	 movzx	 edx, BYTE PTR [esi+16]
  00434	88 4d fa	 mov	 BYTE PTR _ItemInfo$[ebp+10], cl

; 5920 : 
; 5921 : 	if ( lpMsg->sFlag == 3 || lpMsg->tFlag == 3 )

  00437	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  0043a	88 45 f9	 mov	 BYTE PTR _ItemInfo$[ebp+9], al
  0043d	88 55 fb	 mov	 BYTE PTR _ItemInfo$[ebp+11], dl
  00440	80 f9 03	 cmp	 cl, 3
  00443	74 06		 je	 SHORT $LN110@CGInventor@3
  00445	80 7e 11 03	 cmp	 BYTE PTR [esi+17], 3
  00449	75 7e		 jne	 SHORT $LN152@CGInventor@3
$LN110@CGInventor@3:

; 5922 : 	{
; 5923 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 7 )

  0044b	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  00451	8b d0		 mov	 edx, eax
  00453	80 e2 03	 and	 dl, 3
  00456	80 fa 01	 cmp	 dl, 1
  00459	0f 82 b5 0c 00
	00		 jb	 $LN108@CGInventor@3
  0045f	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00464	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00469	0f 85 a5 0c 00
	00		 jne	 $LN108@CGInventor@3

; 5927 : 
; 5928 : 			return;
; 5929 : 		}
; 5930 : 
; 5931 : 		if ( lpObj->ChaosLock == TRUE )

  0046f	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00475	83 bf 88 0e 00
	00 01		 cmp	 DWORD PTR [edi+3720], 1
  0047c	75 4b		 jne	 SHORT $LN152@CGInventor@3

; 5932 : 		{
; 5933 : 			LogAddTD("[%s][%s] error-L3 : CBMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0047e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00483	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  00489	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0048d	52		 push	 edx
  0048e	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  00492	50		 push	 eax
  00493	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@
  00498	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5934 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0049e	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  004a4	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  004a7	51		 push	 ecx
  004a8	6a 00		 push	 0
  004aa	68 ff 00 00 00	 push	 255			; 000000ffH
  004af	52		 push	 edx
  004b0	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  004b5	83 c4 1c	 add	 esp, 28			; 0000001cH
  004b8	5f		 pop	 edi
  004b9	5e		 pop	 esi
  004ba	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  004bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004be	33 cd		 xor	 ecx, ebp
  004c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c5	8b e5		 mov	 esp, ebp
  004c7	5d		 pop	 ebp
  004c8	c3		 ret	 0
$LN152@CGInventor@3:

; 5935 : 		
; 5936 : 			return;
; 5937 : 		}
; 5938 : 	}
; 5939 : 
; 5940 : 	if ( lpMsg->sFlag == 5 || lpMsg->tFlag == 5 )

  004c9	80 f9 05	 cmp	 cl, 5
  004cc	74 06		 je	 SHORT $LN105@CGInventor@3
  004ce	80 7e 11 05	 cmp	 BYTE PTR [esi+17], 5
  004d2	75 7e		 jne	 SHORT $LN153@CGInventor@3
$LN105@CGInventor@3:

; 5941 : 	{
; 5942 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 13 )

  004d4	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  004da	8b d0		 mov	 edx, eax
  004dc	80 e2 03	 and	 dl, 3
  004df	80 fa 01	 cmp	 dl, 1
  004e2	0f 82 f9 0b 00
	00		 jb	 $LN103@CGInventor@3
  004e8	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  004ed	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H
  004f2	0f 85 e9 0b 00
	00		 jne	 $LN103@CGInventor@3

; 5948 : 		}
; 5949 : 
; 5950 : 		if ( lpObj->ChaosLock == TRUE )

  004f8	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  004fe	83 bf 88 0e 00
	00 01		 cmp	 DWORD PTR [edi+3720], 1
  00505	75 4b		 jne	 SHORT $LN153@CGInventor@3

; 5951 : 		{
; 5952 : 			LogAddTD("[%s][%s] error-L3 : DarkTrainerBoxMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00507	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0050c	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  00512	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00516	52		 push	 edx
  00517	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0051b	50		 push	 eax
  0051c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@
  00521	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5953 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00527	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0052d	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00530	51		 push	 ecx
  00531	6a 00		 push	 0
  00533	68 ff 00 00 00	 push	 255			; 000000ffH
  00538	52		 push	 edx
  00539	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0053e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00541	5f		 pop	 edi
  00542	5e		 pop	 esi
  00543	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  00544	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00547	33 cd		 xor	 ecx, ebp
  00549	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0054e	8b e5		 mov	 esp, ebp
  00550	5d		 pop	 ebp
  00551	c3		 ret	 0
$LN153@CGInventor@3:

; 5954 : 		
; 5955 : 			return;
; 5956 : 		}
; 5957 : 	}
; 5958 : 
; 5959 : 	if ( lpMsg->sFlag == 6 || lpMsg->sFlag == 7 || lpMsg->sFlag == 8 ||
; 5960 : 		 lpMsg->tFlag == 6 || lpMsg->tFlag == 7 || lpMsg->tFlag == 8 )

  00552	80 f9 06	 cmp	 cl, 6
  00555	74 19		 je	 SHORT $LN100@CGInventor@3
  00557	80 f9 07	 cmp	 cl, 7
  0055a	74 14		 je	 SHORT $LN100@CGInventor@3
  0055c	80 f9 08	 cmp	 cl, 8
  0055f	74 0f		 je	 SHORT $LN100@CGInventor@3
  00561	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00564	3c 06		 cmp	 al, 6
  00566	74 08		 je	 SHORT $LN100@CGInventor@3
  00568	3c 07		 cmp	 al, 7
  0056a	74 04		 je	 SHORT $LN100@CGInventor@3
  0056c	3c 08		 cmp	 al, 8
  0056e	75 7e		 jne	 SHORT $LN154@CGInventor@3
$LN100@CGInventor@3:

; 5961 : 	{
; 5962 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  00570	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  00576	8b d0		 mov	 edx, eax
  00578	80 e2 03	 and	 dl, 3
  0057b	80 fa 01	 cmp	 dl, 1
  0057e	0f 82 2a 0b 00
	00		 jb	 $LN88@CGInventor@3
  00584	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00589	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0058e	0f 85 1a 0b 00
	00		 jne	 $LN88@CGInventor@3

; 5963 : 		{
; 5964 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 5965 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 5966 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 5967 : 
; 5968 : 			return;
; 5969 : 		}
; 5970 : 
; 5971 : 		if ( lpObj->ChaosLock == TRUE )

  00594	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  0059a	83 bf 88 0e 00
	00 01		 cmp	 DWORD PTR [edi+3720], 1
  005a1	75 4b		 jne	 SHORT $LN154@CGInventor@3
$LN188@CGInventor@3:

; 5972 : 		{
; 5973 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing",
; 5974 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  005a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005a8	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  005ae	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  005b2	52		 push	 edx
  005b3	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  005b7	50		 push	 eax
  005b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@
  005bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5975 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  005c3	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  005c9	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  005cc	51		 push	 ecx
  005cd	6a 00		 push	 0
  005cf	68 ff 00 00 00	 push	 255			; 000000ffH
  005d4	52		 push	 edx
  005d5	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  005da	83 c4 1c	 add	 esp, 28			; 0000001cH
  005dd	5f		 pop	 edi
  005de	5e		 pop	 esi
  005df	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  005e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e3	33 cd		 xor	 ecx, ebp
  005e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ea	8b e5		 mov	 esp, ebp
  005ec	5d		 pop	 ebp
  005ed	c3		 ret	 0
$LN154@CGInventor@3:

; 5976 : 
; 5977 : 			return;
; 5978 : 		}
; 5979 : 	}
; 5980 : 
; 5981 : 	if ( lpMsg->sFlag == 9 || lpMsg->tFlag == 9 )

  005ee	80 f9 09	 cmp	 cl, 9
  005f1	74 06		 je	 SHORT $LN95@CGInventor@3
  005f3	80 7e 11 09	 cmp	 BYTE PTR [esi+17], 9
  005f7	75 37		 jne	 SHORT $LN155@CGInventor@3
$LN95@CGInventor@3:

; 5982 : 	{
; 5983 : 		if ( lpObj->m_IfState.use	 < 1 || lpObj->m_IfState.type !=7 )

  005f9	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  005ff	8b d0		 mov	 edx, eax
  00601	80 e2 03	 and	 dl, 3
  00604	80 fa 01	 cmp	 dl, 1
  00607	0f 82 a1 0a 00
	00		 jb	 $LN88@CGInventor@3
  0060d	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00612	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00617	0f 85 91 0a 00
	00		 jne	 $LN88@CGInventor@3

; 5984 : 		{
; 5985 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 5986 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 5987 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 5988 : 
; 5989 : 			return;
; 5990 : 		}
; 5991 : 
; 5992 : 		if ( lpObj->ChaosLock == TRUE )

  0061d	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00623	83 bf 88 0e 00
	00 01		 cmp	 DWORD PTR [edi+3720], 1

; 5993 : 		{
; 5994 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing",
; 5995 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 5996 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 5997 : 
; 5998 : 			return;

  0062a	0f 84 73 ff ff
	ff		 je	 $LN188@CGInventor@3
$LN155@CGInventor@3:

; 5999 : 		}
; 6000 : 	}
; 6001 : 
; 6002 : 	//season4 add-on (socket mix)
; 6003 : 	if( lpMsg->sFlag == 11 ||
; 6004 : 		lpMsg->sFlag == 12 ||
; 6005 : 		lpMsg->sFlag == 13 ||
; 6006 : 		lpMsg->sFlag == 14 ||
; 6007 : 
; 6008 : 		lpMsg->tFlag == 11 ||
; 6009 : 		lpMsg->tFlag == 12 ||
; 6010 : 		lpMsg->tFlag == 13 ||
; 6011 : 		lpMsg->tFlag == 14 )

  00630	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00633	74 22		 je	 SHORT $LN90@CGInventor@3
  00635	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00638	74 1d		 je	 SHORT $LN90@CGInventor@3
  0063a	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  0063d	74 18		 je	 SHORT $LN90@CGInventor@3
  0063f	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00642	74 13		 je	 SHORT $LN90@CGInventor@3
  00644	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00647	3c 0b		 cmp	 al, 11			; 0000000bH
  00649	74 0c		 je	 SHORT $LN90@CGInventor@3
  0064b	3c 0c		 cmp	 al, 12			; 0000000cH
  0064d	74 08		 je	 SHORT $LN90@CGInventor@3
  0064f	3c 0d		 cmp	 al, 13			; 0000000dH
  00651	74 04		 je	 SHORT $LN90@CGInventor@3
  00653	3c 0e		 cmp	 al, 14			; 0000000eH
  00655	75 7e		 jne	 SHORT $LN156@CGInventor@3
$LN90@CGInventor@3:

; 6012 : 	{
; 6013 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  00657	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  0065d	8b d0		 mov	 edx, eax
  0065f	80 e2 03	 and	 dl, 3
  00662	80 fa 01	 cmp	 dl, 1
  00665	0f 82 43 0a 00
	00		 jb	 $LN88@CGInventor@3
  0066b	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00670	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00675	0f 85 33 0a 00
	00		 jne	 $LN88@CGInventor@3

; 6020 : 		}
; 6021 : 
; 6022 : 		if ( lpObj->ChaosLock == TRUE )

  0067b	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  00681	83 bf 88 0e 00
	00 01		 cmp	 DWORD PTR [edi+3720], 1
  00688	75 4b		 jne	 SHORT $LN156@CGInventor@3

; 6023 : 		{
; 6024 : 			LogAddTD("[%s][%s] error-L3 : SocketItem Mixing",
; 6025 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  0068a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0068f	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  00695	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  00699	52		 push	 edx
  0069a	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0069e	50		 push	 eax
  0069f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@
  006a4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6026 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  006aa	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  006b0	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  006b3	51		 push	 ecx
  006b4	6a 00		 push	 0
  006b6	68 ff 00 00 00	 push	 255			; 000000ffH
  006bb	52		 push	 edx
  006bc	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  006c1	83 c4 1c	 add	 esp, 28			; 0000001cH
  006c4	5f		 pop	 edi
  006c5	5e		 pop	 esi
  006c6	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  006c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ca	33 cd		 xor	 ecx, ebp
  006cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d1	8b e5		 mov	 esp, ebp
  006d3	5d		 pop	 ebp
  006d4	c3		 ret	 0
$LN156@CGInventor@3:

; 6027 : 
; 6028 : 			return;
; 6029 : 		}
; 6030 : 	}
; 6031 : 
; 6032 : 	if ( lpMsg->sFlag == 2 || lpMsg->tFlag == 2 )
; 6033 : 	{
; 6034 : //		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 6 )
; 6035 : //		{
; 6036 : //#if(CUSTOM_MULTIWAREHOUSE)
; 6037 : //			if (lpObj->WarehouseNumber < 0 || lpObj->WarehouseNumber > 5  )
; 6038 : //#endif
; 6039 : //			{
; 6040 : //				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 6041 : //				LogAdd("[%s][%s] error-L1 : used not Warehouse", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6042 : //			}
; 6043 : //
; 6044 : //			return;
; 6045 : //		}
; 6046 : 	}
; 6047 : 
; 6048 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 0 )

  006d5	80 f9 01	 cmp	 cl, 1
  006d8	75 55		 jne	 SHORT $LN157@CGInventor@3
  006da	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  006de	75 4f		 jne	 SHORT $LN157@CGInventor@3

; 6049 : 	{
; 6050 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  006e0	8b 87 1c 0e 00
	00		 mov	 eax, DWORD PTR [edi+3612]
  006e6	8b d0		 mov	 edx, eax
  006e8	80 e2 03	 and	 dl, 3
  006eb	3a d1		 cmp	 dl, cl
  006ed	72 0a		 jb	 SHORT $LN82@CGInventor@3
  006ef	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  006f4	83 f8 40	 cmp	 eax, 64			; 00000040H
  006f7	74 36		 je	 SHORT $LN157@CGInventor@3
$LN82@CGInventor@3:

; 6051 : 		{
; 6052 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  006f9	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  006ff	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00702	50		 push	 eax
  00703	6a 00		 push	 0
  00705	68 ff 00 00 00	 push	 255			; 000000ffH
  0070a	51		 push	 ecx
  0070b	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 6053 : 			LogAdd("[%s][%s] error-L1 : used not Trade", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00710	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00715	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  0071b	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0071f	52		 push	 edx
  00720	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  00724	50		 push	 eax
  00725	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@

; 6054 : 
; 6055 : 			return;

  0072a	e9 16 0a 00 00	 jmp	 $LN165@CGInventor@3
$LN157@CGInventor@3:

; 6056 : 		}
; 6057 : 	}
; 6058 : 
; 6059 : 	if ( lpMsg->sFlag == 2 && lpMsg->tFlag == 0 )

  0072f	80 f9 02	 cmp	 cl, 2
  00732	0f 85 3d 01 00
	00		 jne	 $LN147@CGInventor@3
  00738	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  0073c	0f 85 33 01 00
	00		 jne	 $LN147@CGInventor@3

; 6060 : 	{
; 6061 : 		int money = ::GetWarehouseUsedHowMuch(lpObj->Level, lpObj->MLevel, lpObj->WarehousePW);

  00742	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00748	0f bf 88 66 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3686]
  0074f	0f bf 90 d0 00
	00 00		 movsx	 edx, WORD PTR [eax+208]
  00756	0f bf 80 be 00
	00 00		 movsx	 eax, WORD PTR [eax+190]
  0075d	51		 push	 ecx
  0075e	52		 push	 edx
  0075f	50		 push	 eax
  00760	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 6062 : 
; 6063 : 		if ( (lpObj->Money - money ) < 1 && (lpObj->WarehouseMoney - money) < 1)

  00765	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0076b	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [ecx+240]
  00771	8b f8		 mov	 edi, eax
  00773	2b d7		 sub	 edx, edi
  00775	83 c4 0c	 add	 esp, 12			; 0000000cH
  00778	83 fa 01	 cmp	 edx, 1
  0077b	7d 72		 jge	 SHORT $LN158@CGInventor@3
  0077d	8b c1		 mov	 eax, ecx
  0077f	8b 88 6c 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3692]
  00785	2b cf		 sub	 ecx, edi
  00787	83 f9 01	 cmp	 ecx, 1
  0078a	7d 63		 jge	 SHORT $LN158@CGInventor@3

; 6064 : 		{
; 6065 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0078c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00792	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00795	52		 push	 edx
  00796	6a 00		 push	 0
  00798	68 ff 00 00 00	 push	 255			; 000000ffH
  0079d	50		 push	 eax
  0079e	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  007a3	83 c4 10	 add	 esp, 16			; 00000010H

; 6066 : 			char szTemp[256];
; 6067 : 			wsprintf(szTemp, lMsg.Get(MSGGET(6, 69)), money);

  007a6	57		 push	 edi
  007a7	68 45 06 00 00	 push	 1605			; 00000645H
  007ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007b1	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  007b6	50		 push	 eax
  007b7	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$246398[ebp]
  007bd	51		 push	 ecx
  007be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 6068 : 			::GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  007c4	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  007ca	8b 02		 mov	 eax, DWORD PTR [edx]
  007cc	6a 01		 push	 1
  007ce	50		 push	 eax
  007cf	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$246398[ebp]
  007d5	51		 push	 ecx
  007d6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  007db	83 c4 18	 add	 esp, 24			; 00000018H
  007de	5f		 pop	 edi
  007df	5e		 pop	 esi
  007e0	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  007e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007e4	33 cd		 xor	 ecx, ebp
  007e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007eb	8b e5		 mov	 esp, ebp
  007ed	5d		 pop	 ebp
  007ee	c3		 ret	 0
$LN158@CGInventor@3:

; 6069 : 
; 6070 : 			return;
; 6071 : 		}
; 6072 : 
; 6073 : 		if ( ::bCanWarehouseLock == TRUE )

  007ef	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  007f6	75 64		 jne	 SHORT $LN78@CGInventor@3

; 6074 : 		{
; 6075 : 			if ( gObj[aIndex].WarehouseLock == 1 )

  007f8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007fe	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv1408[ebp]
  00804	80 bc 10 68 0e
	00 00 01	 cmp	 BYTE PTR [eax+edx+3688], 1
  0080c	75 4e		 jne	 SHORT $LN78@CGInventor@3

; 6076 : 			{
; 6077 : 				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0080e	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00814	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00817	51		 push	 ecx
  00818	6a 00		 push	 0
  0081a	68 ff 00 00 00	 push	 255			; 000000ffH
  0081f	52		 push	 edx
  00820	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 6078 : 				::GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index, 1);

  00825	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0082b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0082d	83 c4 10	 add	 esp, 16			; 00000010H
  00830	6a 01		 push	 1
  00832	51		 push	 ecx
  00833	68 46 06 00 00	 push	 1606			; 00000646H
  00838	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0083d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00842	50		 push	 eax
  00843	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00848	83 c4 0c	 add	 esp, 12			; 0000000cH
  0084b	5f		 pop	 edi
  0084c	5e		 pop	 esi
  0084d	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  0084e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00851	33 cd		 xor	 ecx, ebp
  00853	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00858	8b e5		 mov	 esp, ebp
  0085a	5d		 pop	 ebp
  0085b	c3		 ret	 0
$LN78@CGInventor@3:

; 6079 : 
; 6080 : 				return;
; 6081 : 			}
; 6082 : 		}
; 6083 : 
; 6084 : 		#if(CUSTOM_ACCOUNT_SECURITY)
; 6085 : 		if(g_AccountSecurity.CheckWerehouse(aIndex) == false)

  0085c	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _aIndex$GSCopy$[ebp]
  00862	57		 push	 edi
  00863	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  00868	e8 00 00 00 00	 call	 ?CheckWerehouse@CAccountSecurity@@QAE_NH@Z ; CAccountSecurity::CheckWerehouse
  0086d	84 c0		 test	 al, al

; 6086 : 		{
; 6087 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 6088 : 			//::GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index, 1);
; 6089 : 			return;

  0086f	0f 84 d0 f7 ff
	ff		 je	 $LN189@CGInventor@3
$LN147@CGInventor@3:

; 6090 : 		}
; 6091 : 		#endif
; 6092 : 	}
; 6093 : 
; 6094 : 	if( it_type != 8 )

  00875	83 bd e4 fe ff
	ff 08		 cmp	 DWORD PTR _it_type$[ebp], 8
  0087c	0f 84 94 00 00
	00		 je	 $LN159@CGInventor@3

; 6095 : 	{
; 6096 : 		int type = (ItemInfo[0] + ((ItemInfo[3] & 0x80 )*2)) + ((ItemInfo[5] & 0xF0)<<5);

  00882	0f b6 45 f5	 movzx	 eax, BYTE PTR _ItemInfo$[ebp+5]
  00886	0f b6 4d f3	 movzx	 ecx, BYTE PTR _ItemInfo$[ebp+3]
  0088a	0f b6 55 f0	 movzx	 edx, BYTE PTR _ItemInfo$[ebp]
  0088e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00893	c1 e0 04	 shl	 eax, 4
  00896	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0089c	03 c1		 add	 eax, ecx
  0089e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]

; 6097 : 		LPITEM_ATTRIBUTE lpItemAttr = GetItemAttr(type);

  008a1	50		 push	 eax
  008a2	e8 00 00 00 00	 call	 ?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z ; GetItemAttr
  008a7	83 c4 04	 add	 esp, 4

; 6098 : 
; 6099 : 		if ( lpItemAttr == NULL )

  008aa	85 c0		 test	 eax, eax

; 6100 : 		{
; 6101 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 6102 : 			return;

  008ac	0f 84 2a fa ff
	ff		 je	 $LN194@CGInventor@3

; 6103 : 		}
; 6104 : 
; 6105 : 		if ( lpItemAttr->QuestItem != false )

  008b2	80 78 60 00	 cmp	 BYTE PTR [eax+96], 0

; 6106 : 		{
; 6107 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 6108 : 			return;

  008b6	0f 85 c8 fa ff
	ff		 jne	 $LN114@CGInventor@3

; 6109 : 		}
; 6110 : 
; 6111 : 		#if(CUSTOM_ITEM_MOVE)
; 6112 : 		if(g_ItemMove.CheckVault(lpObj->pInventory[source].m_Type))

  008bc	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
  008c2	8b 8f 24 0e 00
	00		 mov	 ecx, DWORD PTR [edi+3620]
  008c8	0f bf 54 0b 06	 movsx	 edx, WORD PTR [ebx+ecx+6]
  008cd	52		 push	 edx
  008ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMove@@3VCItemMove@@A ; g_ItemMove
  008d3	e8 00 00 00 00	 call	 ?CheckVault@CItemMove@@QAE_NH@Z ; CItemMove::CheckVault
  008d8	84 c0		 test	 al, al
  008da	74 40		 je	 SHORT $LN73@CGInventor@3

; 6113 : 		{
; 6114 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  008dc	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  008e2	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  008e5	50		 push	 eax
  008e6	6a 00		 push	 0
  008e8	68 ff 00 00 00	 push	 255			; 000000ffH
  008ed	51		 push	 ecx
  008ee	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 6115 : 			GCServerMsgStringSend("Block Vault Item",lpObj->m_Index,1);

  008f3	8b 17		 mov	 edx, DWORD PTR [edi]
  008f5	6a 01		 push	 1
  008f7	52		 push	 edx
  008f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JFCMJMCM@Block?5Vault?5Item?$AA@
  008fd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00902	83 c4 1c	 add	 esp, 28			; 0000001cH
  00905	5f		 pop	 edi
  00906	5e		 pop	 esi
  00907	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  00908	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0090b	33 cd		 xor	 ecx, ebp
  0090d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00912	8b e5		 mov	 esp, ebp
  00914	5d		 pop	 ebp
  00915	c3		 ret	 0
$LN159@CGInventor@3:

; 6116 : 			return;

  00916	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
$LN73@CGInventor@3:

; 6117 : 		}
; 6118 : 		#endif	
; 6119 : 	}
; 6120 : 
; 6121 : 	if ( (lpMsg->sFlag == 0 && lpMsg->tFlag == 0) ||
; 6122 :  		 (lpMsg->sFlag == 2 && lpMsg->tFlag == 0) ||
; 6123 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 2) ||
; 6124 :  		 (lpMsg->sFlag == 2 && lpMsg->tFlag == 2) ||
; 6125 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 3) ||
; 6126 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 5) ||
; 6127 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 6) ||
; 6128 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 7) ||
; 6129 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 8) ||
; 6130 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 9) ||
; 6131 : 		 (lpMsg->sFlag == 9 && lpMsg->tFlag == 9) ||
; 6132 : 		 (lpMsg->sFlag == 9 && lpMsg->tFlag == 0) ||
; 6133 : 
; 6134 : 		 //season4 add-on start
; 6135 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 11) ||
; 6136 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 12) ||
; 6137 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 13) ||
; 6138 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 14) ||
; 6139 : 
; 6140 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 0) ||
; 6141 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 0) ||
; 6142 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 0) ||
; 6143 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 0) ||
; 6144 : 		 //season4 add-on end
; 6145 : 
; 6146 : 		 //1.01.00
; 6147 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 0) ||
; 6148 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 0) ||
; 6149 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 15) ||
; 6150 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 16) ||
; 6151 : 
; 6152 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 10) ||
; 6153 : 		 (lpMsg->sFlag == 10 && lpMsg->tFlag == 10) ||
; 6154 : 		 (lpMsg->sFlag == 10 && lpMsg->tFlag == 0) ||
; 6155 : 
; 6156 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 4) ||
; 6157 : 		 (lpMsg->sFlag == 4 && lpMsg->tFlag == 0) ||
; 6158 : 		 (lpMsg->sFlag == 4 && lpMsg->tFlag == 4) ||
; 6159 : 		 (lpMsg->sFlag == 5 && lpMsg->tFlag == 0) ||
; 6160 : 		 (lpMsg->sFlag == 5 && lpMsg->tFlag == 5) ||
; 6161 : 		 (lpMsg->sFlag == 6 && lpMsg->tFlag == 0) ||
; 6162 : 		 (lpMsg->sFlag == 6 && lpMsg->tFlag == 6) ||
; 6163 : 		 (lpMsg->sFlag == 7 && lpMsg->tFlag == 0) ||
; 6164 : 		 (lpMsg->sFlag == 7 && lpMsg->tFlag == 7) ||
; 6165 : 		 (lpMsg->sFlag == 8 && lpMsg->tFlag == 0) ||
; 6166 : 		 (lpMsg->sFlag == 8 && lpMsg->tFlag == 8) ||
; 6167 : 
; 6168 : 		 //season4 add-on start
; 6169 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 0) ||
; 6170 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 0) ||
; 6171 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 0) ||
; 6172 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 0) ||
; 6173 : 
; 6174 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 11) ||
; 6175 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 12) ||
; 6176 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 13) ||
; 6177 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 14) ||
; 6178 : 		 //season4 add-on end
; 6179 : 
; 6180 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 0) ||
; 6181 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 15) ||
; 6182 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 0) ||
; 6183 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 16) ||
; 6184 : 
; 6185 : 		 (lpMsg->sFlag == 3 && lpMsg->tFlag == 0) ||
; 6186 : 		 (lpMsg->sFlag == 3 && lpMsg->tFlag == 3) )

  0091c	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  0091f	84 c9		 test	 cl, cl
  00921	75 0b		 jne	 SHORT $LN70@CGInventor@3
  00923	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00926	84 c0		 test	 al, al
  00928	0f 84 be 02 00
	00		 je	 $LN71@CGInventor@3
$LN70@CGInventor@3:
  0092e	80 f9 02	 cmp	 cl, 2
  00931	75 0b		 jne	 SHORT $LN69@CGInventor@3
  00933	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00936	84 c0		 test	 al, al
  00938	0f 84 ae 02 00
	00		 je	 $LN71@CGInventor@3
$LN69@CGInventor@3:
  0093e	84 c9		 test	 cl, cl
  00940	75 0b		 jne	 SHORT $LN68@CGInventor@3
  00942	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00945	3c 02		 cmp	 al, 2
  00947	0f 84 9f 02 00
	00		 je	 $LN71@CGInventor@3
$LN68@CGInventor@3:
  0094d	80 f9 02	 cmp	 cl, 2
  00950	75 0b		 jne	 SHORT $LN67@CGInventor@3
  00952	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00955	3a c1		 cmp	 al, cl
  00957	0f 84 8f 02 00
	00		 je	 $LN71@CGInventor@3
$LN67@CGInventor@3:
  0095d	84 c9		 test	 cl, cl
  0095f	75 47		 jne	 SHORT $LN61@CGInventor@3
  00961	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00964	3c 03		 cmp	 al, 3
  00966	0f 84 80 02 00
	00		 je	 $LN71@CGInventor@3
  0096c	84 c9		 test	 cl, cl
  0096e	75 38		 jne	 SHORT $LN61@CGInventor@3
  00970	3c 05		 cmp	 al, 5
  00972	0f 84 74 02 00
	00		 je	 $LN71@CGInventor@3
  00978	84 c9		 test	 cl, cl
  0097a	75 2c		 jne	 SHORT $LN61@CGInventor@3
  0097c	3c 06		 cmp	 al, 6
  0097e	0f 84 68 02 00
	00		 je	 $LN71@CGInventor@3
  00984	84 c9		 test	 cl, cl
  00986	75 20		 jne	 SHORT $LN61@CGInventor@3
  00988	3c 07		 cmp	 al, 7
  0098a	0f 84 5c 02 00
	00		 je	 $LN71@CGInventor@3
  00990	84 c9		 test	 cl, cl
  00992	75 14		 jne	 SHORT $LN61@CGInventor@3
  00994	3c 08		 cmp	 al, 8
  00996	0f 84 50 02 00
	00		 je	 $LN71@CGInventor@3
  0099c	84 c9		 test	 cl, cl
  0099e	75 08		 jne	 SHORT $LN61@CGInventor@3
  009a0	3c 09		 cmp	 al, 9
  009a2	0f 84 44 02 00
	00		 je	 $LN71@CGInventor@3
$LN61@CGInventor@3:
  009a8	80 f9 09	 cmp	 cl, 9
  009ab	75 17		 jne	 SHORT $LN59@CGInventor@3
  009ad	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009b0	3a c1		 cmp	 al, cl
  009b2	0f 84 34 02 00
	00		 je	 $LN71@CGInventor@3
  009b8	3a c9		 cmp	 cl, cl
  009ba	75 08		 jne	 SHORT $LN59@CGInventor@3
  009bc	84 c0		 test	 al, al
  009be	0f 84 28 02 00
	00		 je	 $LN71@CGInventor@3
$LN59@CGInventor@3:
  009c4	84 c9		 test	 cl, cl
  009c6	75 2f		 jne	 SHORT $LN55@CGInventor@3
  009c8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009cb	3c 0b		 cmp	 al, 11			; 0000000bH
  009cd	0f 84 19 02 00
	00		 je	 $LN71@CGInventor@3
  009d3	84 c9		 test	 cl, cl
  009d5	75 20		 jne	 SHORT $LN55@CGInventor@3
  009d7	3c 0c		 cmp	 al, 12			; 0000000cH
  009d9	0f 84 0d 02 00
	00		 je	 $LN71@CGInventor@3
  009df	84 c9		 test	 cl, cl
  009e1	75 14		 jne	 SHORT $LN55@CGInventor@3
  009e3	3c 0d		 cmp	 al, 13			; 0000000dH
  009e5	0f 84 01 02 00
	00		 je	 $LN71@CGInventor@3
  009eb	84 c9		 test	 cl, cl
  009ed	75 08		 jne	 SHORT $LN55@CGInventor@3
  009ef	3c 0e		 cmp	 al, 14			; 0000000eH
  009f1	0f 84 f5 01 00
	00		 je	 $LN71@CGInventor@3
$LN55@CGInventor@3:
  009f7	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  009fa	75 0b		 jne	 SHORT $LN54@CGInventor@3
  009fc	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  009ff	84 c0		 test	 al, al
  00a01	0f 84 e5 01 00
	00		 je	 $LN71@CGInventor@3
$LN54@CGInventor@3:
  00a07	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00a0a	75 0b		 jne	 SHORT $LN53@CGInventor@3
  00a0c	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a0f	84 c0		 test	 al, al
  00a11	0f 84 d5 01 00
	00		 je	 $LN71@CGInventor@3
$LN53@CGInventor@3:
  00a17	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00a1a	75 0b		 jne	 SHORT $LN52@CGInventor@3
  00a1c	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a1f	84 c0		 test	 al, al
  00a21	0f 84 c5 01 00
	00		 je	 $LN71@CGInventor@3
$LN52@CGInventor@3:
  00a27	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00a2a	75 0b		 jne	 SHORT $LN51@CGInventor@3
  00a2c	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a2f	84 c0		 test	 al, al
  00a31	0f 84 b5 01 00
	00		 je	 $LN71@CGInventor@3
$LN51@CGInventor@3:
  00a37	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00a3a	75 0b		 jne	 SHORT $LN50@CGInventor@3
  00a3c	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a3f	84 c0		 test	 al, al
  00a41	0f 84 a5 01 00
	00		 je	 $LN71@CGInventor@3
$LN50@CGInventor@3:
  00a47	80 f9 10	 cmp	 cl, 16			; 00000010H
  00a4a	75 0b		 jne	 SHORT $LN49@CGInventor@3
  00a4c	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a4f	84 c0		 test	 al, al
  00a51	0f 84 95 01 00
	00		 je	 $LN71@CGInventor@3
$LN49@CGInventor@3:
  00a57	84 c9		 test	 cl, cl
  00a59	75 23		 jne	 SHORT $LN46@CGInventor@3
  00a5b	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a5e	3c 0f		 cmp	 al, 15			; 0000000fH
  00a60	0f 84 86 01 00
	00		 je	 $LN71@CGInventor@3
  00a66	84 c9		 test	 cl, cl
  00a68	75 14		 jne	 SHORT $LN46@CGInventor@3
  00a6a	3c 10		 cmp	 al, 16			; 00000010H
  00a6c	0f 84 7a 01 00
	00		 je	 $LN71@CGInventor@3
  00a72	84 c9		 test	 cl, cl
  00a74	75 08		 jne	 SHORT $LN46@CGInventor@3
  00a76	3c 0a		 cmp	 al, 10			; 0000000aH
  00a78	0f 84 6e 01 00
	00		 je	 $LN71@CGInventor@3
$LN46@CGInventor@3:
  00a7e	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00a81	75 17		 jne	 SHORT $LN44@CGInventor@3
  00a83	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00a86	3a c1		 cmp	 al, cl
  00a88	0f 84 5e 01 00
	00		 je	 $LN71@CGInventor@3
  00a8e	3a c9		 cmp	 cl, cl
  00a90	75 08		 jne	 SHORT $LN44@CGInventor@3
  00a92	84 c0		 test	 al, al
  00a94	0f 84 52 01 00
	00		 je	 $LN71@CGInventor@3
$LN44@CGInventor@3:
  00a9a	84 c9		 test	 cl, cl
  00a9c	75 0b		 jne	 SHORT $LN43@CGInventor@3
  00a9e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00aa1	3c 04		 cmp	 al, 4
  00aa3	0f 84 43 01 00
	00		 je	 $LN71@CGInventor@3
$LN43@CGInventor@3:
  00aa9	80 f9 04	 cmp	 cl, 4
  00aac	75 17		 jne	 SHORT $LN41@CGInventor@3
  00aae	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00ab1	84 c0		 test	 al, al
  00ab3	0f 84 33 01 00
	00		 je	 $LN71@CGInventor@3
  00ab9	3a c9		 cmp	 cl, cl
  00abb	75 08		 jne	 SHORT $LN41@CGInventor@3
  00abd	3a c1		 cmp	 al, cl
  00abf	0f 84 27 01 00
	00		 je	 $LN71@CGInventor@3
$LN41@CGInventor@3:
  00ac5	80 f9 05	 cmp	 cl, 5
  00ac8	75 17		 jne	 SHORT $LN39@CGInventor@3
  00aca	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00acd	84 c0		 test	 al, al
  00acf	0f 84 17 01 00
	00		 je	 $LN71@CGInventor@3
  00ad5	3a c9		 cmp	 cl, cl
  00ad7	75 08		 jne	 SHORT $LN39@CGInventor@3
  00ad9	3a c1		 cmp	 al, cl
  00adb	0f 84 0b 01 00
	00		 je	 $LN71@CGInventor@3
$LN39@CGInventor@3:
  00ae1	80 f9 06	 cmp	 cl, 6
  00ae4	75 17		 jne	 SHORT $LN37@CGInventor@3
  00ae6	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00ae9	84 c0		 test	 al, al
  00aeb	0f 84 fb 00 00
	00		 je	 $LN71@CGInventor@3
  00af1	3a c9		 cmp	 cl, cl
  00af3	75 08		 jne	 SHORT $LN37@CGInventor@3
  00af5	3a c1		 cmp	 al, cl
  00af7	0f 84 ef 00 00
	00		 je	 $LN71@CGInventor@3
$LN37@CGInventor@3:
  00afd	80 f9 07	 cmp	 cl, 7
  00b00	75 17		 jne	 SHORT $LN35@CGInventor@3
  00b02	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b05	84 c0		 test	 al, al
  00b07	0f 84 df 00 00
	00		 je	 $LN71@CGInventor@3
  00b0d	3a c9		 cmp	 cl, cl
  00b0f	75 08		 jne	 SHORT $LN35@CGInventor@3
  00b11	3a c1		 cmp	 al, cl
  00b13	0f 84 d3 00 00
	00		 je	 $LN71@CGInventor@3
$LN35@CGInventor@3:
  00b19	80 f9 08	 cmp	 cl, 8
  00b1c	75 17		 jne	 SHORT $LN33@CGInventor@3
  00b1e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b21	84 c0		 test	 al, al
  00b23	0f 84 c3 00 00
	00		 je	 $LN71@CGInventor@3
  00b29	3a c9		 cmp	 cl, cl
  00b2b	75 08		 jne	 SHORT $LN33@CGInventor@3
  00b2d	3a c1		 cmp	 al, cl
  00b2f	0f 84 b7 00 00
	00		 je	 $LN71@CGInventor@3
$LN33@CGInventor@3:
  00b35	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00b38	75 0b		 jne	 SHORT $LN32@CGInventor@3
  00b3a	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b3d	84 c0		 test	 al, al
  00b3f	0f 84 a7 00 00
	00		 je	 $LN71@CGInventor@3
$LN32@CGInventor@3:
  00b45	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00b48	75 0b		 jne	 SHORT $LN31@CGInventor@3
  00b4a	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b4d	84 c0		 test	 al, al
  00b4f	0f 84 97 00 00
	00		 je	 $LN71@CGInventor@3
$LN31@CGInventor@3:
  00b55	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00b58	75 0b		 jne	 SHORT $LN30@CGInventor@3
  00b5a	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b5d	84 c0		 test	 al, al
  00b5f	0f 84 87 00 00
	00		 je	 $LN71@CGInventor@3
$LN30@CGInventor@3:
  00b65	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00b68	75 07		 jne	 SHORT $LN29@CGInventor@3
  00b6a	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b6d	84 c0		 test	 al, al
  00b6f	74 7b		 je	 SHORT $LN71@CGInventor@3
$LN29@CGInventor@3:
  00b71	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00b74	75 07		 jne	 SHORT $LN28@CGInventor@3
  00b76	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b79	3a c1		 cmp	 al, cl
  00b7b	74 6f		 je	 SHORT $LN71@CGInventor@3
$LN28@CGInventor@3:
  00b7d	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00b80	75 07		 jne	 SHORT $LN27@CGInventor@3
  00b82	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b85	3a c1		 cmp	 al, cl
  00b87	74 63		 je	 SHORT $LN71@CGInventor@3
$LN27@CGInventor@3:
  00b89	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00b8c	75 07		 jne	 SHORT $LN26@CGInventor@3
  00b8e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b91	3a c1		 cmp	 al, cl
  00b93	74 57		 je	 SHORT $LN71@CGInventor@3
$LN26@CGInventor@3:
  00b95	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00b98	75 07		 jne	 SHORT $LN25@CGInventor@3
  00b9a	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00b9d	3a c1		 cmp	 al, cl
  00b9f	74 4b		 je	 SHORT $LN71@CGInventor@3
$LN25@CGInventor@3:
  00ba1	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00ba4	75 0f		 jne	 SHORT $LN23@CGInventor@3
  00ba6	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00ba9	84 c0		 test	 al, al
  00bab	74 3f		 je	 SHORT $LN71@CGInventor@3
  00bad	3a c9		 cmp	 cl, cl
  00baf	75 04		 jne	 SHORT $LN23@CGInventor@3
  00bb1	3a c1		 cmp	 al, cl
  00bb3	74 37		 je	 SHORT $LN71@CGInventor@3
$LN23@CGInventor@3:
  00bb5	80 f9 10	 cmp	 cl, 16			; 00000010H
  00bb8	75 0f		 jne	 SHORT $LN21@CGInventor@3
  00bba	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00bbd	84 c0		 test	 al, al
  00bbf	74 2b		 je	 SHORT $LN71@CGInventor@3
  00bc1	3a c9		 cmp	 cl, cl
  00bc3	75 04		 jne	 SHORT $LN21@CGInventor@3
  00bc5	3a c1		 cmp	 al, cl
  00bc7	74 23		 je	 SHORT $LN71@CGInventor@3
$LN21@CGInventor@3:
  00bc9	80 f9 03	 cmp	 cl, 3
  00bcc	0f 85 34 03 00
	00		 jne	 $LN72@CGInventor@3
  00bd2	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00bd5	84 c0		 test	 al, al
  00bd7	74 13		 je	 SHORT $LN71@CGInventor@3
  00bd9	3a c9		 cmp	 cl, cl
  00bdb	0f 85 25 03 00
	00		 jne	 $LN72@CGInventor@3
  00be1	0f b6 c0	 movzx	 eax, al
  00be4	3a c1		 cmp	 al, cl
  00be6	0f 85 1a 03 00
	00		 jne	 $LN72@CGInventor@3
$LN71@CGInventor@3:

; 6187 : 	{
; 6188 : 		BOOL DurSSend;
; 6189 : 		BOOL DurTSend;
; 6190 : 
; 6191 : 		result = gObjInventoryMoveItem(aIndex, source, target, DurSSend, DurTSend, lpMsg->sFlag, lpMsg->tFlag, (LPBYTE)&ItemInfo);

  00bec	8b bd d4 fe ff
	ff		 mov	 edi, DWORD PTR _target$[ebp]
  00bf2	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00bf5	52		 push	 edx
  00bf6	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _source$[ebp]
  00bfc	50		 push	 eax
  00bfd	51		 push	 ecx
  00bfe	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _DurTSend$246468[ebp]
  00c04	50		 push	 eax
  00c05	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00c0b	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _DurSSend$246467[ebp]
  00c11	51		 push	 ecx
  00c12	57		 push	 edi
  00c13	52		 push	 edx
  00c14	50		 push	 eax
  00c15	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  00c1a	8a d8		 mov	 bl, al

; 6192 : 		::GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00c1c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00c22	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  00c25	51		 push	 ecx
  00c26	88 9d e4 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], bl
  00c2c	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _result$[ebp]
  00c32	57		 push	 edi
  00c33	52		 push	 edx
  00c34	50		 push	 eax
  00c35	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00c3a	83 c4 30	 add	 esp, 48			; 00000030H

; 6193 : 
; 6194 : 		if ( DurSSend != FALSE )

  00c3d	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _DurSSend$246467[ebp], 0
  00c44	74 62		 je	 SHORT $LN148@CGInventor@3

; 6195 : 			::GCItemDurSend(aIndex, (BYTE)source, (BYTE)lpObj->pInventory[source].m_Durability, FALSE);

  00c46	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c4c	d9 bd e6 fe ff
	ff		 fnstcw	 WORD PTR tv1548[ebp]
  00c52	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00c58	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv1425[ebp]
  00c5e	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00c62	0f b7 85 e6 fe
	ff ff		 movzx	 eax, WORD PTR tv1548[ebp]
  00c69	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00c6e	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv1545[ebp], eax
  00c74	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _source$[ebp]
  00c7a	6a 00		 push	 0
  00c7c	d9 ad dc fe ff
	ff		 fldcw	 WORD PTR tv1545[ebp]
  00c82	db 9d dc fe ff
	ff		 fistp	 DWORD PTR tv1543[ebp]
  00c88	8a 8d dc fe ff
	ff		 mov	 cl, BYTE PTR tv1543[ebp]
  00c8e	0f b6 d1	 movzx	 edx, cl
  00c91	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00c97	d9 ad e6 fe ff
	ff		 fldcw	 WORD PTR tv1548[ebp]
  00c9d	52		 push	 edx
  00c9e	50		 push	 eax
  00c9f	51		 push	 ecx
  00ca0	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00ca5	83 c4 10	 add	 esp, 16			; 00000010H
$LN148@CGInventor@3:

; 6196 : 
; 6197 : 		if ( DurTSend != FALSE )

  00ca8	83 bd cc fe ff
	ff 00		 cmp	 DWORD PTR _DurTSend$246468[ebp], 0
  00caf	74 5e		 je	 SHORT $LN18@CGInventor@3

; 6198 : 			::GCItemDurSend(aIndex, (BYTE)target, (BYTE)lpObj->pInventory[target].m_Durability, FALSE);

  00cb1	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb7	d9 bd e6 fe ff
	ff		 fnstcw	 WORD PTR tv1538[ebp]
  00cbd	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00cc3	0f b7 85 e6 fe
	ff ff		 movzx	 eax, WORD PTR tv1538[ebp]
  00cca	8b d7		 mov	 edx, edi
  00ccc	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00cd2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00cd7	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv1535[ebp], eax
  00cdd	d9 44 0a 24	 fld	 DWORD PTR [edx+ecx+36]
  00ce1	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00ce7	6a 00		 push	 0
  00ce9	d9 ad dc fe ff
	ff		 fldcw	 WORD PTR tv1535[ebp]
  00cef	db 9d dc fe ff
	ff		 fistp	 DWORD PTR tv1533[ebp]
  00cf5	8a 95 dc fe ff
	ff		 mov	 dl, BYTE PTR tv1533[ebp]
  00cfb	0f b6 c2	 movzx	 eax, dl
  00cfe	50		 push	 eax
  00cff	d9 ad e6 fe ff
	ff		 fldcw	 WORD PTR tv1538[ebp]
  00d05	57		 push	 edi
  00d06	51		 push	 ecx
  00d07	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00d0c	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@CGInventor@3:

; 6199 : 
; 6200 : 		int loc77 = (lpMsg->sItemInfo[0] + ((lpMsg->sItemInfo[3] & 0x80 )*2)) + ((lpMsg->sItemInfo[5] & 0xF0)<<5); 

  00d0f	0f b6 56 0a	 movzx	 edx, BYTE PTR [esi+10]
  00d13	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  00d17	0f b6 4e 05	 movzx	 ecx, BYTE PTR [esi+5]
  00d1b	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00d21	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00d26	c1 e2 04	 shl	 edx, 4
  00d29	03 d0		 add	 edx, eax
  00d2b	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]

; 6201 : 
; 6202 : 		if( loc77 == ITEMGET(14,29)) //season 2.5 add-on

  00d2e	3d 1d 1c 00 00	 cmp	 eax, 7197		; 00001c1dH
  00d33	75 4a		 jne	 SHORT $LN16@CGInventor@3

; 6203 : 		{
; 6204 : 			if( lpObj->pInventory[target].m_Durability == 0.0f && (lpMsg->sFlag == FALSE) && (lpMsg->tFlag == FALSE))

  00d35	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d3b	8b 88 24 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3620]
  00d41	8b d7		 mov	 edx, edi
  00d43	69 d2 d4 00 00
	00		 imul	 edx, 212		; 000000d4H
  00d49	d9 44 0a 24	 fld	 DWORD PTR [edx+ecx+36]
  00d4d	d9 ee		 fldz
  00d4f	da e9		 fucompp
  00d51	df e0		 fnstsw	 ax
  00d53	f6 c4 44	 test	 ah, 68			; 00000044H
  00d56	0f 8a ad 00 00
	00		 jp	 $LN12@CGInventor@3
  00d5c	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00d60	0f 85 a3 00 00
	00		 jne	 $LN12@CGInventor@3
  00d66	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00d6a	0f 85 99 00 00
	00		 jne	 $LN12@CGInventor@3

; 6205 : 			{
; 6206 : 				GCInventoryItemDeleteSend(aIndex,target,0);

  00d70	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  00d76	6a 00		 push	 0
  00d78	57		 push	 edi
  00d79	52		 push	 edx

; 6207 : 			}
; 6208 : 		}
; 6209 : 
; 6210 : 		if( loc77 == ITEMGET(14,110)) //Season 5 DoppelGanger

  00d7a	e9 82 00 00 00	 jmp	 $LN186@CGInventor@3
$LN16@CGInventor@3:
  00d7f	3d 6e 1c 00 00	 cmp	 eax, 7278		; 00001c6eH
  00d84	75 3b		 jne	 SHORT $LN14@CGInventor@3

; 6211 : 		{
; 6212 : 			if( lpObj->pInventory[target].m_Durability == 0.0f && (lpMsg->sFlag == FALSE) && (lpMsg->tFlag == FALSE))

  00d86	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d8c	8b 91 24 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3620]
  00d92	8b c7		 mov	 eax, edi
  00d94	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00d9a	d9 44 10 24	 fld	 DWORD PTR [eax+edx+36]
  00d9e	d9 ee		 fldz
  00da0	da e9		 fucompp
  00da2	df e0		 fnstsw	 ax
  00da4	f6 c4 44	 test	 ah, 68			; 00000044H
  00da7	7a 60		 jp	 SHORT $LN12@CGInventor@3
  00da9	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00dad	75 5a		 jne	 SHORT $LN12@CGInventor@3
  00daf	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00db3	75 54		 jne	 SHORT $LN12@CGInventor@3

; 6213 : 			{
; 6214 : 				GCInventoryItemDeleteSend(aIndex,target,0);

  00db5	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00dbb	6a 00		 push	 0
  00dbd	57		 push	 edi
  00dbe	50		 push	 eax

; 6215 : 			}
; 6216 : 		}
; 6217 : 
; 6218 : 		if( loc77 == ITEMGET(14,101)) //Season 5 ImperialFort

  00dbf	eb 40		 jmp	 SHORT $LN186@CGInventor@3
$LN14@CGInventor@3:
  00dc1	3d 65 1c 00 00	 cmp	 eax, 7269		; 00001c65H
  00dc6	75 41		 jne	 SHORT $LN12@CGInventor@3

; 6219 : 		{
; 6220 : 			if( lpObj->pInventory[target].m_Durability == 0.0f && (lpMsg->sFlag == FALSE) && (lpMsg->tFlag == FALSE))

  00dc8	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00dce	8b 82 24 0e 00
	00		 mov	 eax, DWORD PTR [edx+3620]
  00dd4	8b cf		 mov	 ecx, edi
  00dd6	69 c9 d4 00 00
	00		 imul	 ecx, 212		; 000000d4H
  00ddc	d9 44 01 24	 fld	 DWORD PTR [ecx+eax+36]
  00de0	d9 ee		 fldz
  00de2	da e9		 fucompp
  00de4	df e0		 fnstsw	 ax
  00de6	f6 c4 44	 test	 ah, 68			; 00000044H
  00de9	7a 1e		 jp	 SHORT $LN12@CGInventor@3
  00deb	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00def	75 18		 jne	 SHORT $LN12@CGInventor@3
  00df1	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00df5	75 12		 jne	 SHORT $LN12@CGInventor@3

; 6221 : 			{
; 6222 : 				GCInventoryItemDeleteSend(aIndex,target,0);

  00df7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00dfd	6a 00		 push	 0
  00dff	57		 push	 edi
  00e00	51		 push	 ecx
$LN186@CGInventor@3:
  00e01	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00e06	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@CGInventor@3:

; 6223 : 			}
; 6224 : 		}
; 6225 : 
; 6226 : 		if ( result != 0xFF && lpMsg->sFlag == 2 && lpMsg->tFlag == 0)

  00e09	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00e0c	0f 84 b3 00 00
	00		 je	 $LN8@CGInventor@3
  00e12	80 7e 03 02	 cmp	 BYTE PTR [esi+3], 2
  00e16	0f 85 a9 00 00
	00		 jne	 $LN8@CGInventor@3
  00e1c	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00e20	0f 85 9f 00 00
	00		 jne	 $LN8@CGInventor@3

; 6227 : 		{
; 6228 : 			int money = ::GetWarehouseUsedHowMuch(lpObj->Level, lpObj->MLevel, lpObj->WarehousePW);

  00e26	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00e2c	0f bf 93 66 0e
	00 00		 movsx	 edx, WORD PTR [ebx+3686]
  00e33	0f bf 83 d0 00
	00 00		 movsx	 eax, WORD PTR [ebx+208]
  00e3a	0f bf 8b be 00
	00 00		 movsx	 ecx, WORD PTR [ebx+190]
  00e41	52		 push	 edx
  00e42	50		 push	 eax
  00e43	51		 push	 ecx
  00e44	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 6229 : 
; 6230 : 			if ( (lpObj->Money - money) > 0 )

  00e49	8b bb f0 00 00
	00		 mov	 edi, DWORD PTR [ebx+240]
  00e4f	8b f0		 mov	 esi, eax
  00e51	8b c7		 mov	 eax, edi
  00e53	2b c6		 sub	 eax, esi
  00e55	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e58	85 c0		 test	 eax, eax
  00e5a	7e 28		 jle	 SHORT $LN10@CGInventor@3

; 6231 : 			{
; 6232 : 				int iZen = lpObj->Money;
; 6233 : 				lpObj->Money -= money;
; 6234 : 				GCMoneySend(lpObj->m_Index, lpObj->Money);

  00e5c	8b 13		 mov	 edx, DWORD PTR [ebx]
  00e5e	50		 push	 eax
  00e5f	52		 push	 edx
  00e60	89 83 f0 00 00
	00		 mov	 DWORD PTR [ebx+240], eax
  00e66	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 6235 : 
; 6236 : 				LogAdd("Pay WareHouse Money(In Inventory) : %d - %d = %d", iZen, money, lpObj->Money);

  00e6b	8b 83 f0 00 00
	00		 mov	 eax, DWORD PTR [ebx+240]
  00e71	50		 push	 eax
  00e72	56		 push	 esi
  00e73	57		 push	 edi
  00e74	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@
  00e79	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00e7f	83 c4 18	 add	 esp, 24			; 00000018H
  00e82	eb 41		 jmp	 SHORT $LN8@CGInventor@3
$LN10@CGInventor@3:

; 6237 : 			}
; 6238 : 			else if ( (lpObj->WarehouseMoney - money) > 0 )

  00e84	8b 8b 6c 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3692]
  00e8a	8b c1		 mov	 eax, ecx
  00e8c	2b c6		 sub	 eax, esi
  00e8e	85 c0		 test	 eax, eax
  00e90	7e 33		 jle	 SHORT $LN8@CGInventor@3

; 6239 : 			{
; 6240 : 				int iZen = lpObj->WarehouseMoney;
; 6241 : 				lpObj->WarehouseMoney -= money;
; 6242 : 	
; 6243 : 				LogAdd("Pay WareHouse Money(In WareHouse) : %d - %d = %d", iZen, money, lpObj->WarehouseMoney);

  00e92	50		 push	 eax
  00e93	56		 push	 esi
  00e94	51		 push	 ecx
  00e95	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@
  00e9a	89 83 6c 0e 00
	00		 mov	 DWORD PTR [ebx+3692], eax
  00ea0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 6244 : 
; 6245 : 				GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  00ea6	8b 8b 6c 0e 00
	00		 mov	 ecx, DWORD PTR [ebx+3692]
  00eac	8b 93 f0 00 00
	00		 mov	 edx, DWORD PTR [ebx+240]
  00eb2	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  00eb8	51		 push	 ecx
  00eb9	52		 push	 edx
  00eba	6a 01		 push	 1
  00ebc	50		 push	 eax
  00ebd	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00ec2	83 c4 20	 add	 esp, 32			; 00000020H
$LN8@CGInventor@3:

; 6246 : 			}
; 6247 : 		}
; 6248 : #ifdef PERIOD
; 6249 : 		g_PeriodItemZt.SendPeriodItemInfoOnce(&gObj[aIndex], &lpObj->pInventory[target]);

  00ec5	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _target$[ebp]
  00ecb	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ed1	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  00ed7	03 81 24 0e 00
	00		 add	 eax, DWORD PTR [ecx+3620]
  00edd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemZt@@3VCPeriodItemZt@@A ; g_PeriodItemZt
  00ee2	50		 push	 eax
  00ee3	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv1408[ebp]
  00ee9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00eef	50		 push	 eax
  00ef0	e8 00 00 00 00	 call	 ?SendPeriodItemInfoOnce@CPeriodItemZt@@QAE_NPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CPeriodItemZt::SendPeriodItemInfoOnce
  00ef5	5f		 pop	 edi
  00ef6	5e		 pop	 esi
  00ef7	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  00ef8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00efb	33 cd		 xor	 ecx, ebp
  00efd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f02	8b e5		 mov	 esp, ebp
  00f04	5d		 pop	 ebp
  00f05	c3		 ret	 0
$LN72@CGInventor@3:

; 6250 : #endif
; 6251 : 		return;
; 6252 : 	}
; 6253 : 
; 6254 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 1 )

  00f06	80 f9 01	 cmp	 cl, 1
  00f09	0f 85 47 01 00
	00		 jne	 $LN6@CGInventor@3
  00f0f	38 4e 11	 cmp	 BYTE PTR [esi+17], cl
  00f12	75 46		 jne	 SHORT $LN7@CGInventor@3

; 6255 : 	{
; 6256 : 		result = gObjTradeTradeMove(lpObj, source, target);

  00f14	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _target$[ebp]
  00f1a	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _source$[ebp]
  00f20	56		 push	 esi
  00f21	51		 push	 ecx
  00f22	57		 push	 edi
  00f23	e8 00 00 00 00	 call	 ?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeTradeMove

; 6257 : 		GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00f28	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  00f2e	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00f31	52		 push	 edx
  00f32	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al
  00f38	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _result$[ebp]
  00f3e	56		 push	 esi
  00f3f	50		 push	 eax
  00f40	51		 push	 ecx
  00f41	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00f46	83 c4 1c	 add	 esp, 28			; 0000001cH
  00f49	5f		 pop	 edi
  00f4a	5e		 pop	 esi
  00f4b	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  00f4c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f4f	33 cd		 xor	 ecx, ebp
  00f51	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f56	8b e5		 mov	 esp, ebp
  00f58	5d		 pop	 ebp
  00f59	c3		 ret	 0
$LN7@CGInventor@3:

; 6258 : 		return;
; 6259 : 	}
; 6260 : 
; 6261 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 0 )

  00f5a	80 f9 01	 cmp	 cl, 1
  00f5d	0f 85 f3 00 00
	00		 jne	 $LN6@CGInventor@3
  00f63	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00f67	0f 85 e9 00 00
	00		 jne	 $LN6@CGInventor@3

; 6262 : 	{
; 6263 : 		result = gObjTradeInventoryMove(lpObj, source, target);

  00f6d	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _target$[ebp]
  00f73	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _source$[ebp]
  00f79	56		 push	 esi
  00f7a	52		 push	 edx
  00f7b	57		 push	 edi
  00f7c	e8 00 00 00 00	 call	 ?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeInventoryMove
  00f81	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f84	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al

; 6264 : 
; 6265 : 		if ( result == 0xFF )

  00f8a	3c ff		 cmp	 al, 255			; 000000ffH
  00f8c	0f 85 a7 00 00
	00		 jne	 $LN5@CGInventor@3

; 6266 : 		{
; 6267 : 			GCItemMoveResultSend(aIndex, 0xFF, target, (LPBYTE)&ItemInfo);

  00f92	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00f95	50		 push	 eax
  00f96	56		 push	 esi
  00f97	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  00f9d	68 ff 00 00 00	 push	 255			; 000000ffH
  00fa2	56		 push	 esi
  00fa3	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 6268 : 			CGTradeCancelButtonRecv(aIndex);

  00fa8	56		 push	 esi
  00fa9	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv

; 6276 : 		{
; 6277 : 			lpObj->m_IfState.state = 0;

  00fae	83 a7 1c 0e 00
	00 c3		 and	 DWORD PTR [edi+3612], -61 ; ffffffc3H
  00fb5	83 c4 14	 add	 esp, 20			; 00000014H

; 6278 : 			GCItemListSend(aIndex);

  00fb8	56		 push	 esi
  00fb9	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend

; 6279 : #ifdef PERIOD
; 6280 : 			g_PeriodItemZt.OnRequestPeriodItemList(&gObj[aIndex]);

  00fbe	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  00fc4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fca	83 c4 04	 add	 esp, 4
  00fcd	51		 push	 ecx
  00fce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PeriodItemZt@@3VCPeriodItemZt@@A ; g_PeriodItemZt
  00fd3	e8 00 00 00 00	 call	 ?OnRequestPeriodItemList@CPeriodItemZt@@QAEXPAUOBJECTSTRUCT@@@Z ; CPeriodItemZt::OnRequestPeriodItemList
$LN3@CGInventor@3:

; 6281 : #endif
; 6282 : 		}
; 6283 : 		
; 6284 : 		if ( lpObj->TargetNumber >= 0 )

  00fd8	66 83 bf 58 04
	00 00 00	 cmp	 WORD PTR [edi+1112], 0
  00fe0	0f 8c 68 01 00
	00		 jl	 $LN1@CGInventor@3

; 6285 : 		{
; 6286 : 			lpObj->TradeOk = false;
; 6287 : 			gObj[gObj[aIndex].TargetNumber].TradeOk = false;

  00fe6	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv1408[ebp]
  00fec	c6 87 58 0e 00
	00 00		 mov	 BYTE PTR [edi+3672], 0
  00ff3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ff8	0f bf 8c 02 58
	04 00 00	 movsx	 ecx, WORD PTR [edx+eax+1112]
  01000	69 c9 50 2b 00
	00		 imul	 ecx, 11088		; 00002b50H
  01006	c6 84 01 58 0e
	00 00 00	 mov	 BYTE PTR [ecx+eax+3672], 0

; 6288 : 			GCTradeOkButtonSend(lpObj->TargetNumber, 2);

  0100e	0f bf 97 58 04
	00 00		 movsx	 edx, WORD PTR [edi+1112]
  01015	6a 02		 push	 2
  01017	52		 push	 edx
  01018	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6289 : 			GCTradeOkButtonSend(aIndex, 0);

  0101d	6a 00		 push	 0
  0101f	56		 push	 esi
  01020	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  01025	83 c4 10	 add	 esp, 16			; 00000010H
  01028	5f		 pop	 edi
  01029	5e		 pop	 esi
  0102a	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  0102b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0102e	33 cd		 xor	 ecx, ebp
  01030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01035	8b e5		 mov	 esp, ebp
  01037	5d		 pop	 ebp
  01038	c3		 ret	 0
$LN5@CGInventor@3:

; 6269 : 		}
; 6270 : 		else
; 6271 : 		{
; 6272 : 			GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  01039	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _result$[ebp]
  0103f	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  01042	51		 push	 ecx
  01043	56		 push	 esi
  01044	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$[ebp]
  0104a	52		 push	 edx
  0104b	56		 push	 esi
  0104c	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  01051	83 c4 10	 add	 esp, 16			; 00000010H

; 6273 : 		}
; 6274 : 
; 6275 : 		if ( result == 0xFF )

  01054	eb 82		 jmp	 SHORT $LN3@CGInventor@3
$LN6@CGInventor@3:

; 6290 : 		}
; 6291 : 		return;
; 6292 : 	}
; 6293 : 
; 6294 : 	if ( lpMsg->sFlag == 0 && lpMsg->tFlag == 1 )

  01056	84 c9		 test	 cl, cl
  01058	0f 85 f0 00 00
	00		 jne	 $LN1@CGInventor@3
  0105e	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  01062	0f 85 e6 00 00
	00		 jne	 $LN1@CGInventor@3

; 6295 : 	{
; 6296 : 		result = gObjInventoryTradeMove(lpObj, source, target);

  01068	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _target$[ebp]
  0106e	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _source$[ebp]
  01074	56		 push	 esi
  01075	50		 push	 eax
  01076	57		 push	 edi
  01077	e8 00 00 00 00	 call	 ?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjInventoryTradeMove

; 6297 : 		GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  0107c	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  0107f	51		 push	 ecx
  01080	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al
  01086	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _result$[ebp]
  0108c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  01092	56		 push	 esi
  01093	52		 push	 edx
  01094	50		 push	 eax
  01095	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0109a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0109d	5f		 pop	 edi
  0109e	5e		 pop	 esi
  0109f	5b		 pop	 ebx

; 6298 : 	}
; 6299 : }

  010a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010a3	33 cd		 xor	 ecx, ebp
  010a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010aa	8b e5		 mov	 esp, ebp
  010ac	5d		 pop	 ebp
  010ad	c3		 ret	 0
$LN88@CGInventor@3:

; 6014 : 		{
; 6015 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  010ae	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  010b4	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  010b7	51		 push	 ecx
  010b8	6a 00		 push	 0
  010ba	68 ff 00 00 00	 push	 255			; 000000ffH
  010bf	52		 push	 edx
  010c0	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 6016 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 6017 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);

  010c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010ca	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  010d0	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  010d4	52		 push	 edx
  010d5	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  010d9	50		 push	 eax
  010da	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@

; 6018 : 
; 6019 : 			return;

  010df	eb 64		 jmp	 SHORT $LN165@CGInventor@3
$LN103@CGInventor@3:

; 5943 : 		{
; 5944 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  010e1	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  010e7	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  010ea	51		 push	 ecx
  010eb	6a 00		 push	 0
  010ed	68 ff 00 00 00	 push	 255			; 000000ffH
  010f2	52		 push	 edx
  010f3	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5945 : 			LogAdd("[%s][%s] error-L1 : used not DarkTrainerBox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  010f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010fd	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  01103	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  01107	52		 push	 edx
  01108	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0110c	50		 push	 eax
  0110d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@

; 5946 : 
; 5947 : 			return;

  01112	eb 31		 jmp	 SHORT $LN165@CGInventor@3
$LN108@CGInventor@3:

; 5924 : 		{
; 5925 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  01114	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  0111a	8d 4d f0	 lea	 ecx, DWORD PTR _ItemInfo$[ebp]
  0111d	51		 push	 ecx
  0111e	6a 00		 push	 0
  01120	68 ff 00 00 00	 push	 255			; 000000ffH
  01125	52		 push	 edx
  01126	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5926 : 			LogAdd("[%s][%s] error-L1 : used not Chaosbox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0112b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01130	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  01136	8d 54 01 77	 lea	 edx, DWORD PTR [ecx+eax+119]
  0113a	52		 push	 edx
  0113b	8d 44 01 6c	 lea	 eax, DWORD PTR [ecx+eax+108]
  0113f	50		 push	 eax
  01140	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
$LN165@CGInventor@3:
  01145	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0114b	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@CGInventor@3:

; 6298 : 	}
; 6299 : }

  0114e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01151	5f		 pop	 edi
  01152	5e		 pop	 esi
  01153	33 cd		 xor	 ecx, ebp
  01155	5b		 pop	 ebx
  01156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0115b	8b e5		 mov	 esp, ebp
  0115d	5d		 pop	 ebp
  0115e	c3		 ret	 0
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ENDP ; CGInventoryItemMove
_TEXT	ENDS
PUBLIC	?GCManagerGuildWarSet@@YAXPAD0H@Z		; GCManagerGuildWarSet
; Function compile flags: /Ogtp
;	COMDAT ?GCManagerGuildWarSet@@YAXPAD0H@Z
_TEXT	SEGMENT
_lpNode$ = -4						; size = 4
_GuildName1$ = 8					; size = 4
_GuildName2$ = 12					; size = 4
_type$ = 16						; size = 4
?GCManagerGuildWarSet@@YAXPAD0H@Z PROC			; GCManagerGuildWarSet, COMDAT

; 11813: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11814: 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(GuildName1);

  00004	8b 45 08	 mov	 eax, DWORD PTR _GuildName1$[ebp]
  00007	50		 push	 eax
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0000d	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00012	8b c8		 mov	 ecx, eax
  00014	89 4d fc	 mov	 DWORD PTR _lpNode$[ebp], ecx

; 11815: 
; 11816: 	if ( lpNode == NULL )

  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 7d 00 00
	00		 je	 $LN1@GCManagerG@2

; 11817: 	{
; 11818: 		return;
; 11819: 	}
; 11820: 
; 11821: 	int n=0;

  0001f	56		 push	 esi
  00020	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	57		 push	 edi
  00027	33 ff		 xor	 edi, edi
  00029	83 c6 77	 add	 esi, 119		; 00000077H
  0002c	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  0002f	53		 push	 ebx
$LL9@GCManagerG@2:

; 11822: 	int warmaster = -1;
; 11823: 
; 11824: 	while ( true )
; 11825: 	{
; 11826: 		if ( gObj[n].Type == OBJ_USER )

  00030	66 83 7e f1 01	 cmp	 WORD PTR [esi-15], 1
  00035	75 3b		 jne	 SHORT $LN19@GCManagerG@2

; 11827: 		{
; 11828: 			if ( gObj[n].Connected > PLAYER_LOGGED )

  00037	39 46 8d	 cmp	 DWORD PTR [esi-115], eax
  0003a	7e 36		 jle	 SHORT $LN19@GCManagerG@2

; 11829: 			{
; 11830: 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0003c	8a 1e		 mov	 bl, BYTE PTR [esi]
  0003e	3a 59 2f	 cmp	 bl, BYTE PTR [ecx+47]
  00041	8d 51 2f	 lea	 edx, DWORD PTR [ecx+47]
  00044	75 2c		 jne	 SHORT $LN19@GCManagerG@2

; 11831: 				{
; 11832: 					if ( strcmp(gObj[n].Name, lpNode->Names[0]) == 0 )

  00046	8b ce		 mov	 ecx, esi
$LL15@GCManagerG@2:
  00048	8a 19		 mov	 bl, BYTE PTR [ecx]
  0004a	3a 1a		 cmp	 bl, BYTE PTR [edx]
  0004c	75 18		 jne	 SHORT $LN16@GCManagerG@2
  0004e	84 db		 test	 bl, bl
  00050	74 10		 je	 SHORT $LN17@GCManagerG@2
  00052	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  00055	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00058	75 0c		 jne	 SHORT $LN16@GCManagerG@2
  0005a	03 c8		 add	 ecx, eax
  0005c	03 d0		 add	 edx, eax
  0005e	84 db		 test	 bl, bl
  00060	75 e6		 jne	 SHORT $LL15@GCManagerG@2
$LN17@GCManagerG@2:
  00062	33 c9		 xor	 ecx, ecx
  00064	eb 05		 jmp	 SHORT $LN18@GCManagerG@2
$LN16@GCManagerG@2:
  00066	1b c9		 sbb	 ecx, ecx
  00068	83 d9 ff	 sbb	 ecx, -1
$LN18@GCManagerG@2:
  0006b	85 c9		 test	 ecx, ecx
  0006d	74 14		 je	 SHORT $LN14@GCManagerG@2
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _lpNode$[ebp]
$LN19@GCManagerG@2:

; 11833: 					{
; 11834: 						warmaster = n;
; 11835: 						break;
; 11836: 					}
; 11837: 				}
; 11838: 			}
; 11839: 		}
; 11840: 
; 11841: 		if ( n < OBJMAX-1 )

  00072	81 ff 97 3a 00
	00		 cmp	 edi, 14999		; 00003a97H
  00078	7d 1f		 jge	 SHORT $LN22@GCManagerG@2

; 11842: 		{
; 11843: 			n++;

  0007a	47		 inc	 edi
  0007b	81 c6 50 2b 00
	00		 add	 esi, 11088		; 00002b50H

; 11844: 		}
; 11845: 		else
; 11846: 		{
; 11847: 			break;
; 11848: 		}
; 11849: 	}

  00081	eb ad		 jmp	 SHORT $LL9@GCManagerG@2
$LN14@GCManagerG@2:

; 11850: 
; 11851: 	if ( warmaster >= 1 )

  00083	83 ff 01	 cmp	 edi, 1
  00086	7c 11		 jl	 SHORT $LN22@GCManagerG@2

; 11852: 	{
; 11853: 		::GCGuildWarRequestResult(GuildName2, warmaster, type);

  00088	8b 4d 10	 mov	 ecx, DWORD PTR _type$[ebp]
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _GuildName2$[ebp]
  0008e	51		 push	 ecx
  0008f	57		 push	 edi
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ?GCGuildWarRequestResult@@YAXPADHH@Z ; GCGuildWarRequestResult
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@GCManagerG@2:
  00099	5b		 pop	 ebx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
$LN1@GCManagerG@2:

; 11854: 	}
; 11855: }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?GCManagerGuildWarSet@@YAXPAD0H@Z ENDP			; GCManagerGuildWarSet
_TEXT	ENDS
PUBLIC	??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@ ; `string'
PUBLIC	??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@ ; `string'
PUBLIC	?ProtocolCore@@YAXEPAEHHHH@Z			; ProtocolCore
EXTRN	?ztGCConfigSend@@YAXH@Z:PROC			; ztGCConfigSend
EXTRN	?CGReqGetMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEXPAUPMSG_REQ_MASTERLEVEL_SKILL@@H@Z:PROC ; CMasterLevelSkillTreeSystem::CGReqGetMasterLevelSkill
EXTRN	?gObjMoveDataLoadingOK@@YAXH@Z:PROC		; gObjMoveDataLoadingOK
EXTRN	?DataServerGetCharListRequest@@YAXF@Z:PROC	; DataServerGetCharListRequest
EXTRN	?CGReqItemList@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_ITEM@@H@Z:PROC ; CItemMarket::CGReqItemList
EXTRN	?CGReqItemSell@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_SELL@@H@Z:PROC ; CItemMarket::CGReqItemSell
EXTRN	?CGReqItemBuy@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_BUY@@H@Z:PROC ; CItemMarket::CGReqItemBuy
EXTRN	?g_ItemMarket@@3VCItemMarket@@A:BYTE		; g_ItemMarket
EXTRN	?OpenItem@NewsBoard@@QAEXPAUOBJECTSTRUCT@@PAUNEWS_REQ_NEWS@@@Z:PROC ; NewsBoard::OpenItem
EXTRN	?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; NewsBoard::OpenMain
EXTRN	?g_NewsBoard@@3VNewsBoard@@A:BYTE		; g_NewsBoard
EXTRN	?CGReqPartyMember@CCameraParty@@QAEXPAUPMSG_REQ_PARTY_MEMBER@@H@Z:PROC ; CCameraParty::CGReqPartyMember
EXTRN	?g_CameraParty@@3VCCameraParty@@A:BYTE		; g_CameraParty
EXTRN	?CGReqViewe@CCameraMove@@QAEXPAUPMSG_REQ_CAMERAMOVE_VIEWE@@H@Z:PROC ; CCameraMove::CGReqViewe
EXTRN	?g_CameraMove@@3VCCameraMove@@A:BYTE		; g_CameraMove
EXTRN	?CGReqSelect@CMapTeleport@@QAEXPAUPMSG_REQ_MAPTELEPORT_SELECT@@H@Z:PROC ; CMapTeleport::CGReqSelect
EXTRN	?CGReqData@CMapTeleport@@QAEXPAUPMSG_REQ_MAPTELEPORT_DATA@@H@Z:PROC ; CMapTeleport::CGReqData
EXTRN	?g_MapTeleport@@3VCMapTeleport@@A:BYTE		; g_MapTeleport
EXTRN	?CGRecvValueMenu@ZtUser@@QAEXPAUPMSG_ANS_VALUE_MENU@@H@Z:PROC ; ZtUser::CGRecvValueMenu
EXTRN	?Packet@JewelsBank@@QAEXHPAUPMSG_JEWELBANK@@@Z:PROC ; JewelsBank::Packet
EXTRN	?gJewelsBank@@3VJewelsBank@@A:BYTE		; gJewelsBank
EXTRN	?CGOpenGuildWarehouse@CGuildBank@@QAEXPAUPMSG_GUILD_BANK@@H@Z:PROC ; CGuildBank::CGOpenGuildWarehouse
EXTRN	?RecvConfig@ZtUser@@QAEXPAUCG_MINIMAP_PARTY@@H@Z:PROC ; ZtUser::RecvConfig
EXTRN	?CGCtrlKey@ZtUser@@QAEXHPAUPMSG_CONTROLLER_CTRL@@@Z:PROC ; ZtUser::CGCtrlKey
EXTRN	?InfoRecv@CPickUpItemInfo@@QAEXPAUPMSG_REQ_PICKUP_INFO@@H@Z:PROC ; CPickUpItemInfo::InfoRecv
EXTRN	?g_PickUpItemInfo@@3VCPickUpItemInfo@@A:BYTE	; g_PickUpItemInfo
EXTRN	?CG_AcceptQuest@ZtWinQuestSystem@@QAEXHPAUCG_Accept_Done@@@Z:PROC ; ZtWinQuestSystem::CG_AcceptQuest
EXTRN	?CG_RecvAutoHPClicker@ZtUser@@QAEXPAUPMSG_PROTOCOL_RESULT@@H@Z:PROC ; ZtUser::CG_RecvAutoHPClicker
EXTRN	?CGUserResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_USER_REWARD@@H@Z:PROC ; CReferralSystem::CGUserResult
EXTRN	?CGReqUserInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_USER_INFO@@H@Z:PROC ; CReferralSystem::CGReqUserInfo
EXTRN	?CGMasterResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_MASTER_REWARD@@H@Z:PROC ; CReferralSystem::CGMasterResult
EXTRN	?CGReqMasterInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_MASTER_INFO@@H@Z:PROC ; CReferralSystem::CGReqMasterInfo
EXTRN	?g_ReferralSystem@@3VCReferralSystem@@A:BYTE	; g_ReferralSystem
EXTRN	?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z:PROC ; CAccountSecurity::CGRecvSaveNumber
EXTRN	?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z:PROC ; CAccountSecurity::CGRecvAccountOption
EXTRN	?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z:PROC ; CAccountSecurity::CGRecvSettingPC
EXTRN	?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z:PROC ; CAccountSecurity::CGRecvAccountConnect
EXTRN	?CG_ResultRecv@PKClear@@QAEXHPAUCG_PKCLEAR_RESULT@@@Z:PROC ; PKClear::CG_ResultRecv
EXTRN	?g_PKClear@@3VPKClear@@A:BYTE			; g_PKClear
EXTRN	?CGDialog@ZtTeleportEvo@@QAEXPAUPMSG_CG_DIALOGEVO@@H@Z:PROC ; ZtTeleportEvo::CGDialog
EXTRN	?CGResult@ZtTeleportEvo@@QAEXPAUPMSG_CG_TELEPORTWINRESEVO@@H@Z:PROC ; ZtTeleportEvo::CGResult
EXTRN	?g_ZtTeleportEvo@@3VZtTeleportEvo@@A:BYTE	; g_ZtTeleportEvo
EXTRN	?CGGrandStart@cGrandReset@@QAEXH@Z:PROC		; cGrandReset::CGGrandStart
EXTRN	?CGGrandMenu@cGrandReset@@QAEXH@Z:PROC		; cGrandReset::CGGrandMenu
EXTRN	?gGrandReset@@3VcGrandReset@@A:BYTE		; gGrandReset
EXTRN	?CGResetMenu@cResetSystem@@QAEXH@Z:PROC		; cResetSystem::CGResetMenu
EXTRN	?CGRageReset@cSystemOfRage@@QAEXHPAUPMSG_ANS_RESETRAGE@@@Z:PROC ; cSystemOfRage::CGRageReset
EXTRN	?CGResult@ZtTeleport@@QAEXPAUPMSG_CG_TELEPORTWINRES@@H@Z:PROC ; ZtTeleport::CGResult
EXTRN	?g_ZtTeleport@@3VZtTeleport@@A:BYTE		; g_ZtTeleport
EXTRN	?CGWindowOpen@CAchievements@@QAEXPAUPMSG_CG_ACH_WINOPEN@@H@Z:PROC ; CAchievements::CGWindowOpen
EXTRN	?CGTeleportEvent@CTeamVsTeam@@QAEXH@Z:PROC	; CTeamVsTeam::CGTeleportEvent
EXTRN	?g_TeamVsTeam@@3VCTeamVsTeam@@A:BYTE		; g_TeamVsTeam
EXTRN	?CGHWID@CDungeonSiege@@QAEXPAUPMSG_CG_DUNBEON_SIEGE_HWID@@H@Z:PROC ; CDungeonSiege::CGHWID
EXTRN	?CGDRegSiege@CDungeonSiege@@QAEXH@Z:PROC	; CDungeonSiege::CGDRegSiege
EXTRN	?CGResulInfo@cResetSystem@@QAEXH@Z:PROC		; cResetSystem::CGResulInfo
EXTRN	?gResetSystem@@3VcResetSystem@@A:BYTE		; gResetSystem
EXTRN	?CGNewLeader@PartyClass@@QAEXHPAUGC_PARTYNEWLEADER@@@Z:PROC ; PartyClass::CGNewLeader
EXTRN	?CG_Cheater@AntiCheatPlus@@QAEXPAUPMST_CheaterUser@@H@Z:PROC ; AntiCheatPlus::CG_Cheater
EXTRN	?CG_HddSend@AntiCheatPlus@@QAEXPAUCG_PMSG_HDDKEY@@H@Z:PROC ; AntiCheatPlus::CG_HddSend
EXTRN	?CGChangeClass@cCreditDonate@@QAEXPAUPMSG_CG_CHANGECLASS@@H@Z:PROC ; cCreditDonate::CGChangeClass
EXTRN	?CGResetPoints@ZtUser@@QAEXHPAUPMSG_ADD_POINTSRESET@@@Z:PROC ; ZtUser::CGResetPoints
EXTRN	?CGAddPoints@ZtUser@@QAEXHPAUPMSG_ADD_POINTS@@@Z:PROC ; ZtUser::CGAddPoints
EXTRN	?CGClickOK@CMarriage@@QAEXH@Z:PROC		; CMarriage::CGClickOK
EXTRN	?IndexClose@CMarriage@@QAEXH@Z:PROC		; CMarriage::IndexClose
EXTRN	?g_Marriage@@3VCMarriage@@A:BYTE		; g_Marriage
EXTRN	?Start@OfflineMode@@QAEXPAUCG_OFFMODE_RESULT@@H@Z:PROC ; OfflineMode::Start
EXTRN	?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z:PROC ; CSmithy::CGCreateItem
EXTRN	?g_Smithy@@3VCSmithy@@A:BYTE			; g_Smithy
EXTRN	?CG_ResultRecv@BufferSystem@@QAEXHPAUCG_BuffNpcResult@@@Z:PROC ; BufferSystem::CG_ResultRecv
EXTRN	?g_BufferSystem@@3VBufferSystem@@A:BYTE		; g_BufferSystem
EXTRN	?Search@PersonalShopZt@@QAEXHPAUCG_PersonalPage@@@Z:PROC ; PersonalShopZt::Search
EXTRN	?Search@PartySearch@@QAEXH@Z:PROC		; PartySearch::Search
EXTRN	?CG_RecvPartyUser@PartySearch@@QAEXHPAUCG_PartyRecv@@@Z:PROC ; PartySearch::CG_RecvPartyUser
EXTRN	?CG_RecvInfo@PartySearch@@QAEXHPAUCG_AutoPartyInfo@@@Z:PROC ; PartySearch::CG_RecvInfo
EXTRN	?g_PartySearch@@3VPartySearch@@A:BYTE		; g_PartySearch
EXTRN	?MissionReward@MonsterQuest@@QAEXH@Z:PROC	; MonsterQuest::MissionReward
EXTRN	?gMonsterQuest@@3VMonsterQuest@@A:BYTE		; gMonsterQuest
EXTRN	?SendPartyList@cAutoParty@@QAEXH@Z:PROC		; cAutoParty::SendPartyList
EXTRN	?gAutoParty@@3VcAutoParty@@A:BYTE		; gAutoParty
EXTRN	?RecvPacket@cWinQuestSystem@@QAEXHPAUCGSendQuestResult@@@Z:PROC ; cWinQuestSystem::RecvPacket
EXTRN	?RecvClose@ConnectZt@@QAEXH@Z:PROC		; ConnectZt::RecvClose
EXTRN	?SendLogin@ConnectZt@@QAEXHPAUCONNECTZT_LOGIN@@@Z:PROC ; ConnectZt::SendLogin
EXTRN	?OffExpStart@cOffExp@@QAEXHH@Z:PROC		; cOffExp::OffExpStart
EXTRN	?OffExp@@3VcOffExp@@A:BYTE			; OffExp
EXTRN	?GC_Send@PremiumSystemZt@@QAEXHPAUCG_SEND_OPEND_WIN@@@Z:PROC ; PremiumSystemZt::GC_Send
EXTRN	?CG_RecvBuy@PremiumSystemZt@@QAEXHPAUCG_PREMIUM_BUY@@@Z:PROC ; PremiumSystemZt::CG_RecvBuy
EXTRN	?g_PremiumSystemZt@@3VPremiumSystemZt@@A:BYTE	; g_PremiumSystemZt
EXTRN	?NewShopRecv@@YAXPAUCG_NEW_CASH_SHOP@@H@Z:PROC	; NewShopRecv
EXTRN	?RecvActiveSkill@cSystemOfRage@@QAEXPAUsRageTabSend@@H@Z:PROC ; cSystemOfRage::RecvActiveSkill
EXTRN	?DataRecv@cSystemOfRage@@QAEXPAUClickSend@@H@Z:PROC ; cSystemOfRage::DataRecv
EXTRN	?gSystemOfRage@@3VcSystemOfRage@@A:BYTE		; gSystemOfRage
EXTRN	?SaveMacro@MUHelper@@QAEXHPAUMUHELPER_MACRO_CLIENT@@@Z:PROC ; MUHelper::SaveMacro
EXTRN	?CGReqGensMemberInfo@@YAXPAUPMSG_REQ_GENS_INFO@@H@Z:PROC ; CGReqGensMemberInfo
EXTRN	?CGReqGensReward@@YAXPAUPMSG_GENS_REWARD_CODE@@H@Z:PROC ; CGReqGensReward
EXTRN	?CGReqSecedeGensMember@@YAXPAUPMSG_REQ_SEGEDE_GENS_MEMBER@@H@Z:PROC ; CGReqSecedeGensMember
EXTRN	?CGReqRegGensMember@@YAXPAUPMSG_REQ_REG_GENS_MEMBER@@H@Z:PROC ; CGReqRegGensMember
EXTRN	?EnterEvent@CImperial@@QAE_NF@Z:PROC		; CImperial::EnterEvent
EXTRN	?g_Imperial@@3VCImperial@@A:BYTE		; g_Imperial
EXTRN	?Manager@MUHelper@@QAEXHPAUMUHELPER_REQ_ACTION@@@Z:PROC ; MUHelper::Manager
EXTRN	?g_MUHelper@@3VMUHelper@@A:BYTE			; g_MUHelper
EXTRN	?EnterEvent@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CDoppelGanger::EnterEvent
EXTRN	?g_DoppelGanger@@3VCDoppelGanger@@A:BYTE	; g_DoppelGanger
EXTRN	?RequestStorageItemUse@GameShop@@QAEXHPAUGAMESHOP_REQ_STORAGEITEMUSE@@@Z:PROC ; GameShop::RequestStorageItemUse
EXTRN	?RequestStorage@GameShop@@QAEXHPAUGAMESHOP_REQ_STORAGE@@@Z:PROC ; GameShop::RequestStorage
EXTRN	?RequestItemBuy@GameShop@@QAEXHPAUGAMESHOP_REQ_BUY@@@Z:PROC ; GameShop::RequestItemBuy
EXTRN	?RequestOpenShop@GameShop@@QAEXHPAUGAMESHOP_REQ_OPEN@@@Z:PROC ; GameShop::RequestOpenShop
EXTRN	?RequestPoint@GameShop@@QAEXH@Z:PROC		; GameShop::RequestPoint
EXTRN	?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z:PROC ; FriendRoomInvitationReq
EXTRN	?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z:PROC ; FriendChatRoomCreateReq
EXTRN	?FriendMemoListReq@@YAXH@Z:PROC			; FriendMemoListReq
EXTRN	?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z:PROC ; FriendMemoDelReq
EXTRN	?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z:PROC ; FriendMemoReadReq
EXTRN	?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z:PROC ; FriendMemoSend
EXTRN	?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z:PROC ; FriendStateClientRecv
EXTRN	?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z:PROC ; FriendDelRequest
EXTRN	?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z:PROC ; WaitFriendAddRequest
EXTRN	?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z:PROC ; FriendAddRequest
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?ProtocolCore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAE@Z:PROC ; CDuelManager::ProtocolCore
EXTRN	?g_DuelManager@@3VCDuelManager@@A:BYTE		; g_DuelManager
EXTRN	?SetPartyIndex@PartyClass@@QAEXPAUPMSG_PARTYDELUSER@@H@Z:PROC ; PartyClass::SetPartyIndex
EXTRN	?ItemBuy@CMossMerchant@@QAEXHH@Z:PROC		; CMossMerchant::ItemBuy
EXTRN	?gMossMerchant@@3VCMossMerchant@@A:BYTE		; gMossMerchant
EXTRN	?ChatDataSend@@YAXKPAE@Z:PROC			; ChatDataSend
EXTRN	?GetSerial@NSerialCheck@@QAEHXZ:PROC		; NSerialCheck::GetSerial
EXTRN	?InCheck@NSerialCheck@@QAEHE@Z:PROC		; NSerialCheck::InCheck
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
;	COMDAT ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@
CONST	SEGMENT
??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@ DB 'er'
	DB	'ror-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@
CONST	SEGMENT
??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@ DB 'Er'
	DB	'ror-L1 : Socket Serial %s %d o_serial:%d serial:%d ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ProtocolCore@@YAXEPAEHHHH@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
_aIndex$ = 20						; size = 4
_Encrypt$ = 24						; size = 4
_serial$ = 28						; size = 4
?ProtocolCore@@YAXEPAEHHHH@Z PROC			; ProtocolCore, COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 273  : #ifdef DEBUG_CODE
; 274  : 	LogAddC(2, "protoNum: 0x%X | HEAD: 0x%X 0x%X 0x%X 0x%X WarehouseSave %d",protoNum,aRecv[0],aRecv[1],aRecv[2],aRecv[3],gObj[aIndex].WarehouseSave);
; 275  : #endif
; 276  : 
; 277  : 	//if ( gStalkProtocol )
; 278  : 	//{
; 279  : 	//	if ( gStalkProtocolId[0] == gObj[aIndex].AccountID[0] )
; 280  : 	//	{
; 281  : 	//		if ( gStalkProtocolId[1] == gObj[aIndex].AccountID[1] )
; 282  : 	//		{
; 283  : 	//			if ( !strcmp(gStalkProtocolId, gObj[aIndex].AccountID ) )
; 284  : 	//			{
; 285  : 	//				LogAddHeadHex(gObj[aIndex].AccountID, (char*)aRecv, aLen);
; 286  : 	//			}
; 287  : 	//		}
; 288  : 	//	}
; 289  : 	//}
; 290  : 
; 291  : 	LPOBJ lpObj = &gObj[aIndex];
; 292  : 
; 293  : 	//LogAddC(2, "X: %d = TX: %d | Y: %d = TY: %d",lpObj->X, lpObj->TX, lpObj->Y, lpObj->TY);
; 294  : 
; 295  : 	#if(!ENABLE_INDEV_NETWORK)
; 296  : 	if ( serial >= 0 )

  00003	83 7d 1c 00	 cmp	 DWORD PTR _serial$[ebp], 0
  00007	53		 push	 ebx
  00008	8b 5d 14	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	7c 5b		 jl	 SHORT $LN365@ProtocolCo

; 297  : 	{
; 298  : 		if ( gObj[aIndex].Type == OBJ_USER )

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00014	8b f3		 mov	 esi, ebx
  00016	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  0001c	66 83 7c 06 68
	01		 cmp	 WORD PTR [esi+eax+104], 1
  00022	75 46		 jne	 SHORT $LN365@ProtocolCo

; 299  : 		{
; 300  : 			if ( gNSerialCheck[aIndex].InCheck(serial) == FALSE )

  00024	8b 4d 1c	 mov	 ecx, DWORD PTR _serial$[ebp]
  00027	8d 3c dd 00 00
	00 00		 lea	 edi, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ebx*8]
  0002e	51		 push	 ecx
  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ?InCheck@NSerialCheck@@QAEHE@Z ; NSerialCheck::InCheck
  00036	85 c0		 test	 eax, eax
  00038	75 30		 jne	 SHORT $LN365@ProtocolCo

; 301  : 			{
; 302  : 				LogAdd("Error-L1 : Socket Serial %s %d o_serial:%d serial:%d ", gObj[aIndex].AccountID, protoNum, gNSerialCheck[aIndex].GetSerial(), serial);

  0003a	8b 55 1c	 mov	 edx, DWORD PTR _serial$[ebp]
  0003d	52		 push	 edx
  0003e	8b cf		 mov	 ecx, edi
  00040	e8 00 00 00 00	 call	 ?GetSerial@NSerialCheck@@QAEHXZ ; NSerialCheck::GetSerial
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004b	50		 push	 eax
  0004c	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00050	50		 push	 eax
  00051	8d 54 0e 6c	 lea	 edx, DWORD PTR [esi+ecx+108]
  00055	52		 push	 edx
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 303  : 				CloseClient(aIndex);

  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00067	83 c4 18	 add	 esp, 24			; 00000018H
$LN365@ProtocolCo:

; 304  : 			}
; 305  : 		}
; 306  : 	}
; 307  : 	#endif
; 308  : 
; 309  : 	if ( protoNum == 0xF1 || protoNum == 0xF3 )

  0006a	8b 45 08	 mov	 eax, DWORD PTR _protoNum$[ebp]
  0006d	3c f1		 cmp	 al, 241			; 000000f1H
  0006f	0f 84 15 12 00
	00		 je	 $LN348@ProtocolCo
  00075	3c f3		 cmp	 al, 243			; 000000f3H
  00077	0f 84 0d 12 00
	00		 je	 $LN348@ProtocolCo

; 392  : 							break;
; 393  : 							//
; 394  : 					}
; 395  : 				}
; 396  : 				break;
; 397  : 		}
; 398  : 	}
; 399  : 	else
; 400  : 	{
; 401  : 		LPOBJ lpObj = &gObj[aIndex];

  0007d	8b f3		 mov	 esi, ebx
  0007f	69 f6 50 2b 00
	00		 imul	 esi, 11088		; 00002b50H
  00085	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 402  : 
; 403  : 		//LogAddC(2, "HEAD: %x",protoNum);
; 404  : 				
; 405  : 		switch ( protoNum )

  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  00094	0f 87 be 11 00
	00		 ja	 $LN1@ProtocolCo
  0009a	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN357@ProtocolCo[ecx]
  000a1	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN367@ProtocolCo[edx*4]
$LN315@ProtocolCo:

; 406  : 		{
; 407  : #if(CUSTOM_POSTITEM)
; 408  :             case 0x78:
; 409  :                 pPostItemProc ( ( PMSG_POSTITEM* ) aRecv, aIndex );

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000ab	53		 push	 ebx
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?pPostItemProc@@YAXPAUPMSG_POSTITEM@@F@Z ; pPostItemProc
  000b2	83 c4 08	 add	 esp, 8
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN314@ProtocolCo:

; 410  :                 break;
; 411  : #endif
; 412  : 			case 0x00:
; 413  : 				tempindex = aIndex;
; 414  : 				PChatProc((PMSG_CHATDATA *)aRecv, aIndex);

  000ba	8b 75 0c	 mov	 esi, DWORD PTR _aRecv$[ebp]
  000bd	53		 push	 ebx
  000be	56		 push	 esi
  000bf	89 1d 00 00 00
	00		 mov	 DWORD PTR ?tempindex@@3HA, ebx ; tempindex
  000c5	e8 00 00 00 00	 call	 ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ; PChatProc

; 415  : 				ChatDataSend(aIndex,aRecv);

  000ca	56		 push	 esi
  000cb	53		 push	 ebx
  000cc	e8 00 00 00 00	 call	 ?ChatDataSend@@YAXKPAE@Z ; ChatDataSend
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN313@ProtocolCo:

; 416  : 				break;
; 417  : 			case 0x01:
; 418  : 				CGChatRecv((PMSG_CHATDATA_NUMBER *)aRecv, aIndex);

  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  000dc	53		 push	 ebx
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ; CGChatRecv
  000e3	83 c4 08	 add	 esp, 8
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
$LN312@ProtocolCo:

; 419  : 				break;
; 420  : 			case 0x02:
; 421  : 				CGChatWhisperRecv((PMSG_CHATDATA_WHISPER *)aRecv, aIndex);

  000eb	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  000ee	53		 push	 ebx
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
  000f5	83 c4 08	 add	 esp, 8
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN311@ProtocolCo:

; 422  : 				break;
; 423  : 			case 0x03:
; 424  : 				CGCheckMainRecv((PMSG_CHECK_MAINEXE_RESULT *)aRecv, aIndex);

  000fd	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00100	53		 push	 ebx
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
  00107	83 c4 08	 add	 esp, 8
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
$LN310@ProtocolCo:

; 425  : 				break;
; 426  : 			case 0x0E:
; 427  : 				CGLiveClient((PMSG_CLIENTTIME *)aRecv, aIndex);

  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00112	53		 push	 ebx
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient
  00119	83 c4 08	 add	 esp, 8
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
$LN309@ProtocolCo:

; 428  : 				break;
; 429  : 			case PROTOCOL_MOVE:
; 430  : 				PMoveProc((PMSG_MOVE *)aRecv, aIndex);

  00121	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00124	53		 push	 ebx
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc
  0012b	83 c4 08	 add	 esp, 8
  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
$LN308@ProtocolCo:

; 431  : 				break;
; 432  : 			case PROTOCOL_POSITION:
; 433  : 				RecvPositionSetProc((PMSG_POSISTION_SET *)aRecv, aIndex);

  00133	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00136	53		 push	 ebx
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  0013d	83 c4 08	 add	 esp, 8
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN307@ProtocolCo:

; 434  : 				break;
; 435  : 			case PROTOCOL_ATTACK:
; 436  : 				CGAttack((PMSG_ATTACK *)aRecv, aIndex);	//OK

  00145	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00148	53		 push	 ebx
  00149	51		 push	 ecx
  0014a	e8 00 00 00 00	 call	 ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ; CGAttack
  0014f	83 c4 08	 add	 esp, 8
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
$LN306@ProtocolCo:

; 437  : 				break;
; 438  : 			case 0x18:
; 439  : 				CGActionRecv((PMSG_ACTION *)aRecv, aIndex);

  00157	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0015a	53		 push	 ebx
  0015b	52		 push	 edx
  0015c	e8 00 00 00 00	 call	 ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ; CGActionRecv
  00161	83 c4 08	 add	 esp, 8
  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
$LN305@ProtocolCo:

; 440  : 				break;
; 441  : 			case 0x19:
; 442  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00169	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  0016c	51		 push	 ecx
  0016d	50		 push	 eax
  0016e	53		 push	 ebx
  0016f	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
  00177	85 c0		 test	 eax, eax
  00179	0f 84 a0 12 00
	00		 je	 $LN344@ProtocolCo

; 443  : 				{
; 444  : 					CGMagicAttack((PMSG_MAGICATTACK *)aRecv, aIndex);	//OK

  0017f	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00182	53		 push	 ebx
  00183	52		 push	 edx
  00184	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00189	83 c4 08	 add	 esp, 8
  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
$LN303@ProtocolCo:

; 445  : 				}
; 446  : 				break;
; 447  : 			case 0x1B:
; 448  : 				CGMagicCancel((PMSG_MAGICCANCEL *)aRecv, aIndex);

  00191	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00194	53		 push	 ebx
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 ?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z ; CGMagicCancel
  0019b	83 c4 08	 add	 esp, 8
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
$LN302@ProtocolCo:

; 449  : 				break;
; 450  : 			case 0x1C:
; 451  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  001a3	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  001a6	51		 push	 ecx
  001a7	50		 push	 eax
  001a8	53		 push	 ebx
  001a9	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  001ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b1	85 c0		 test	 eax, eax
  001b3	0f 84 66 12 00
	00		 je	 $LN344@ProtocolCo

; 452  : 				{
; 453  : 					CGTeleportRecv((PMSG_TELEPORT *)aRecv, aIndex);	//OK

  001b9	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  001bc	53		 push	 ebx
  001bd	52		 push	 edx
  001be	e8 00 00 00 00	 call	 ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ; CGTeleportRecv
  001c3	83 c4 08	 add	 esp, 8
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
$LN300@ProtocolCo:

; 454  : 				}
; 455  : 				break;
; 456  : 			case 0xB0:
; 457  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  001cb	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  001ce	51		 push	 ecx
  001cf	50		 push	 eax
  001d0	53		 push	 ebx
  001d1	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d9	85 c0		 test	 eax, eax
  001db	0f 84 3e 12 00
	00		 je	 $LN344@ProtocolCo

; 458  : 				{
; 459  : 					CGTargetTeleportRecv((PMSG_TARGET_TELEPORT *)aRecv, aIndex);

  001e1	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  001e4	53		 push	 ebx
  001e5	52		 push	 edx
  001e6	e8 00 00 00 00	 call	 ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
  001eb	83 c4 08	 add	 esp, 8
  001ee	5f		 pop	 edi
  001ef	5e		 pop	 esi
  001f0	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
$LN298@ProtocolCo:

; 460  : 				}
; 461  : 				break;
; 462  : 			case PROTOCOL_BEATTACK:
; 463  : 				CGBeattackRecv(aRecv, aIndex, FALSE);	//OK

  001f3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001f6	6a 00		 push	 0
  001f8	53		 push	 ebx
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 ?CGBeattackRecv@@YAXPAEHH@Z ; CGBeattackRecv
  001ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
$LN297@ProtocolCo:

; 464  : 				break;
; 465  : 			case 0x1E:
; 466  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00207	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  0020a	51		 push	 ecx
  0020b	50		 push	 eax
  0020c	53		 push	 ebx
  0020d	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
  00215	85 c0		 test	 eax, eax
  00217	0f 84 02 12 00
	00		 je	 $LN344@ProtocolCo

; 467  : 				{
; 468  : 					CGDurationMagicRecv((PMSG_DURATION_MAGIC_RECV *)aRecv, aIndex);	//OK

  0021d	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00220	53		 push	 ebx
  00221	52		 push	 edx
  00222	e8 00 00 00 00	 call	 ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
  00227	83 c4 08	 add	 esp, 8
  0022a	5f		 pop	 edi
  0022b	5e		 pop	 esi
  0022c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0022d	5d		 pop	 ebp
  0022e	c3		 ret	 0
$LN295@ProtocolCo:

; 469  : 				}
; 470  : 				break;
; 471  : 			case 0x22:
; 472  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0022f	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00232	51		 push	 ecx
  00233	50		 push	 eax
  00234	53		 push	 ebx
  00235	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023d	85 c0		 test	 eax, eax
  0023f	0f 84 da 11 00
	00		 je	 $LN344@ProtocolCo

; 473  : 				{
; 474  : 					CGItemGetRequest((PMSG_ITEMGETREQUEST *)aRecv, aIndex);

  00245	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00248	53		 push	 ebx
  00249	52		 push	 edx
  0024a	e8 00 00 00 00	 call	 ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
  0024f	83 c4 08	 add	 esp, 8
  00252	5f		 pop	 edi
  00253	5e		 pop	 esi
  00254	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
$LN293@ProtocolCo:

; 475  : 				}
; 476  : 				break;
; 477  : 			case 0x23:
; 478  : 				CGItemDropRequest((PMSG_ITEMTHROW *)aRecv, aIndex, 0);

  00257	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0025a	6a 00		 push	 0
  0025c	53		 push	 ebx
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH
  00266	5f		 pop	 edi
  00267	5e		 pop	 esi
  00268	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00269	5d		 pop	 ebp
  0026a	c3		 ret	 0
$LN292@ProtocolCo:

; 479  : 				break;
; 480  : 			case 0x24:
; 481  : 				CGInventoryItemMove((PMSG_INVENTORYITEMMOVE *)aRecv, aIndex);

  0026b	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0026e	53		 push	 ebx
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
  00275	83 c4 08	 add	 esp, 8
  00278	5f		 pop	 edi
  00279	5e		 pop	 esi
  0027a	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0027b	5d		 pop	 ebp
  0027c	c3		 ret	 0
$LN291@ProtocolCo:

; 482  : 				break;
; 483  : 			case 0x26:
; 484  : 				CGUseItemRecv((PMSG_USEITEM *)aRecv, aIndex);

  0027d	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00280	53		 push	 ebx
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ; CGUseItemRecv
  00287	83 c4 08	 add	 esp, 8
  0028a	5f		 pop	 edi
  0028b	5e		 pop	 esi
  0028c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0028d	5d		 pop	 ebp
  0028e	c3		 ret	 0
$LN290@ProtocolCo:

; 485  : 				break;
; 486  : 			case 0x30:
; 487  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0028f	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00292	51		 push	 ecx
  00293	50		 push	 eax
  00294	53		 push	 ebx
  00295	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0029a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029d	85 c0		 test	 eax, eax
  0029f	0f 84 7a 11 00
	00		 je	 $LN344@ProtocolCo

; 488  : 				{
; 489  : 					CGTalkRequestRecv((PMSG_TALKREQUEST *)aRecv, aIndex);

  002a5	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  002a8	53		 push	 ebx
  002a9	52		 push	 edx
  002aa	e8 00 00 00 00	 call	 ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ; CGTalkRequestRecv
  002af	83 c4 08	 add	 esp, 8
  002b2	5f		 pop	 edi
  002b3	5e		 pop	 esi
  002b4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
$LN288@ProtocolCo:

; 490  : 				}
; 491  : 				break;
; 492  : 			case 0x31:
; 493  : 				CGCloseWindow(aIndex);

  002b7	53		 push	 ebx
  002b8	e8 00 00 00 00	 call	 ?CGCloseWindow@@YAXH@Z	; CGCloseWindow
  002bd	83 c4 04	 add	 esp, 4
  002c0	5f		 pop	 edi
  002c1	5e		 pop	 esi
  002c2	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  002c3	5d		 pop	 ebp
  002c4	c3		 ret	 0
$LN287@ProtocolCo:

; 494  : 				break;
; 495  : 			case 0x32:
; 496  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  002c5	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  002c8	51		 push	 ecx
  002c9	50		 push	 eax
  002ca	53		 push	 ebx
  002cb	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d3	85 c0		 test	 eax, eax
  002d5	0f 84 44 11 00
	00		 je	 $LN344@ProtocolCo

; 497  : 				{
; 498  : 					if ( lpObj->TargetShopNumber == 492 )

  002db	ba ec 01 00 00	 mov	 edx, 492		; 000001ecH
  002e0	66 39 96 5a 04
	00 00		 cmp	 WORD PTR [esi+1114], dx
  002e7	75 18		 jne	 SHORT $LN285@ProtocolCo

; 499  : 						gMossMerchant.ItemBuy(aIndex,aRecv[3]);

  002e9	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002ec	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002f0	51		 push	 ecx
  002f1	53		 push	 ebx
  002f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMossMerchant@@3VCMossMerchant@@A ; gMossMerchant
  002f7	e8 00 00 00 00	 call	 ?ItemBuy@CMossMerchant@@QAEXHH@Z ; CMossMerchant::ItemBuy
  002fc	5f		 pop	 edi
  002fd	5e		 pop	 esi
  002fe	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  002ff	5d		 pop	 ebp
  00300	c3		 ret	 0
$LN285@ProtocolCo:

; 500  : 					else
; 501  : 						CGBuyRequestRecv((PMSG_BUYREQUEST *)aRecv, aIndex);

  00301	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00304	53		 push	 ebx
  00305	52		 push	 edx
  00306	e8 00 00 00 00	 call	 ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ; CGBuyRequestRecv
  0030b	83 c4 08	 add	 esp, 8
  0030e	5f		 pop	 edi
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00311	5d		 pop	 ebp
  00312	c3		 ret	 0
$LN283@ProtocolCo:

; 502  : 				}
; 503  : 				break;
; 504  : 			case 0x33:
; 505  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00313	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00316	51		 push	 ecx
  00317	50		 push	 eax
  00318	53		 push	 ebx
  00319	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00321	85 c0		 test	 eax, eax
  00323	0f 84 f6 10 00
	00		 je	 $LN344@ProtocolCo

; 506  : 				{
; 507  : 					CGSellRequestRecv((PMSG_SELLREQUEST *)aRecv, aIndex);

  00329	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0032c	53		 push	 ebx
  0032d	52		 push	 edx
  0032e	e8 00 00 00 00	 call	 ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ; CGSellRequestRecv
  00333	83 c4 08	 add	 esp, 8
  00336	5f		 pop	 edi
  00337	5e		 pop	 esi
  00338	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00339	5d		 pop	 ebp
  0033a	c3		 ret	 0
$LN281@ProtocolCo:

; 508  : 				}
; 509  : 				break;
; 510  : 			case 0x34:
; 511  : 				CGModifyRequestItem((PMSG_ITEMDURREPAIR *)aRecv, aIndex);

  0033b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0033e	53		 push	 ebx
  0033f	50		 push	 eax
  00340	e8 00 00 00 00	 call	 ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
  00345	83 c4 08	 add	 esp, 8
  00348	5f		 pop	 edi
  00349	5e		 pop	 esi
  0034a	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0034b	5d		 pop	 ebp
  0034c	c3		 ret	 0
$LN280@ProtocolCo:

; 512  : 				break;
; 513  : 			case 0x36:
; 514  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0034d	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  00350	51		 push	 ecx
  00351	50		 push	 eax
  00352	53		 push	 ebx
  00353	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00358	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035b	85 c0		 test	 eax, eax
  0035d	0f 84 bc 10 00
	00		 je	 $LN344@ProtocolCo

; 515  : 				{
; 516  : 					CGTradeRequestSend((PMSG_TRADE_REQUEST *)aRecv, aIndex);

  00363	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00366	53		 push	 ebx
  00367	52		 push	 edx
  00368	e8 00 00 00 00	 call	 ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
  0036d	83 c4 08	 add	 esp, 8
  00370	5f		 pop	 edi
  00371	5e		 pop	 esi
  00372	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00373	5d		 pop	 ebp
  00374	c3		 ret	 0
$LN278@ProtocolCo:

; 517  : 				}
; 518  : 				break;
; 519  : 			case 0x37:
; 520  : 				CGTradeResponseRecv((PMSG_TRADE_RESPONSE *)aRecv, aIndex);

  00375	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00378	53		 push	 ebx
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
  0037f	83 c4 08	 add	 esp, 8
  00382	5f		 pop	 edi
  00383	5e		 pop	 esi
  00384	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00385	5d		 pop	 ebp
  00386	c3		 ret	 0
$LN277@ProtocolCo:

; 521  : 				break;
; 522  : 			case 0x3A:
; 523  : 				CGTradeMoneyRecv((PMSG_TRADE_GOLD *)aRecv, aIndex);

  00387	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0038a	53		 push	 ebx
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ; CGTradeMoneyRecv
  00391	83 c4 08	 add	 esp, 8
  00394	5f		 pop	 edi
  00395	5e		 pop	 esi
  00396	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00397	5d		 pop	 ebp
  00398	c3		 ret	 0
$LN276@ProtocolCo:

; 524  : 				break;
; 525  : 			case 0x3C:
; 526  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00399	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  0039c	52		 push	 edx
  0039d	50		 push	 eax
  0039e	53		 push	 ebx
  0039f	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  003a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a7	85 c0		 test	 eax, eax
  003a9	0f 84 70 10 00
	00		 je	 $LN344@ProtocolCo

; 527  : 				{
; 528  : 					CGTradeOkButtonRecv((PMSG_TRADE_OKBUTTON *)aRecv, aIndex);

  003af	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003b2	53		 push	 ebx
  003b3	50		 push	 eax
  003b4	e8 00 00 00 00	 call	 ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
  003b9	83 c4 08	 add	 esp, 8
  003bc	5f		 pop	 edi
  003bd	5e		 pop	 esi
  003be	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  003bf	5d		 pop	 ebp
  003c0	c3		 ret	 0
$LN274@ProtocolCo:

; 529  : 				}
; 530  : 				break;
; 531  : 			case 0x3D:
; 532  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  003c1	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  003c4	51		 push	 ecx
  003c5	50		 push	 eax
  003c6	53		 push	 ebx
  003c7	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  003cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003cf	85 c0		 test	 eax, eax
  003d1	0f 84 48 10 00
	00		 je	 $LN344@ProtocolCo

; 533  : 				{
; 534  : 					CGTradeCancelButtonRecv(aIndex);

  003d7	53		 push	 ebx
  003d8	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  003dd	83 c4 04	 add	 esp, 4
  003e0	5f		 pop	 edi
  003e1	5e		 pop	 esi
  003e2	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  003e3	5d		 pop	 ebp
  003e4	c3		 ret	 0
$LN272@ProtocolCo:

; 535  : 				}
; 536  : 				break;
; 537  : 			case 0x3F:
; 538  : 				{
; 539  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 540  : 
; 541  : 					switch ( lpDef->subcode )

  003e5	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003e8	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003ec	49		 dec	 ecx
  003ed	83 f9 05	 cmp	 ecx, 5
  003f0	0f 87 29 10 00
	00		 ja	 $LN344@ProtocolCo
  003f6	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN368@ProtocolCo[ecx*4]
$LN269@ProtocolCo:

; 542  : 					{
; 543  : 						case 0x01:
; 544  : //#if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 545  : 							if(g_PersonalShopZt.Enable)

  003fd	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A, 0

; 546  : 							{
; 547  : 								CGPShopReqSetItemPriceEx((PMSG_REQ_PSHOP_SETITEMPRICE_EX *)aRecv, aIndex);

  00404	53		 push	 ebx
  00405	50		 push	 eax
  00406	74 0d		 je	 SHORT $LN268@ProtocolCo
  00408	e8 00 00 00 00	 call	 ?CGPShopReqSetItemPriceEx@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE_EX@@H@Z ; CGPShopReqSetItemPriceEx
  0040d	83 c4 08	 add	 esp, 8
  00410	5f		 pop	 edi
  00411	5e		 pop	 esi
  00412	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00413	5d		 pop	 ebp
  00414	c3		 ret	 0
$LN268@ProtocolCo:

; 548  : 							}
; 549  : 							else
; 550  : 							{
; 551  : //#else
; 552  : 								CGPShopReqSetItemPrice((PMSG_REQ_PSHOP_SETITEMPRICE *)aRecv, aIndex);

  00415	e8 00 00 00 00	 call	 ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
  0041a	83 c4 08	 add	 esp, 8
  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00420	5d		 pop	 ebp
  00421	c3		 ret	 0
$LN266@ProtocolCo:

; 553  : 							}
; 554  : //#endif
; 555  : 							break;
; 556  : 						case 0x02:
; 557  : 							CGPShopReqOpen((PMSG_REQ_PSHOP_OPEN *)aRecv, aIndex);

  00422	53		 push	 ebx
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ; CGPShopReqOpen
  00429	83 c4 08	 add	 esp, 8
  0042c	5f		 pop	 edi
  0042d	5e		 pop	 esi
  0042e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0042f	5d		 pop	 ebp
  00430	c3		 ret	 0
$LN265@ProtocolCo:

; 558  : 							break;
; 559  : 						case 0x03:
; 560  : 							CGPShopReqClose(aIndex);

  00431	53		 push	 ebx
  00432	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  00437	83 c4 04	 add	 esp, 4
  0043a	5f		 pop	 edi
  0043b	5e		 pop	 esi
  0043c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0043d	5d		 pop	 ebp
  0043e	c3		 ret	 0
$LN264@ProtocolCo:

; 561  : 							break;
; 562  : 						case 0x05:
; 563  : 							CGPShopReqBuyList((PMSG_REQ_BUYLIST_FROM_PSHOP *)aRecv, aIndex);

  0043f	53		 push	 ebx
  00440	50		 push	 eax
  00441	e8 00 00 00 00	 call	 ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
  00446	83 c4 08	 add	 esp, 8
  00449	5f		 pop	 edi
  0044a	5e		 pop	 esi
  0044b	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0044c	5d		 pop	 ebp
  0044d	c3		 ret	 0
$LN263@ProtocolCo:

; 564  : 							break;
; 565  : 						case 0x06:
; 566  : //#if(CUSTOM_PERSONAL_SHOP ==TRUE)
; 567  : 							if(g_PersonalShopZt.Enable)

  0044e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A, 0

; 568  : 							{
; 569  : 								CGPShopReqBuyItemEx((PMSG_REQ_BUYITEM_FROM_PSHOP *)aRecv, aIndex);

  00455	53		 push	 ebx
  00456	50		 push	 eax
  00457	74 0d		 je	 SHORT $LN262@ProtocolCo
  00459	e8 00 00 00 00	 call	 ?CGPShopReqBuyItemEx@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItemEx
  0045e	83 c4 08	 add	 esp, 8
  00461	5f		 pop	 edi
  00462	5e		 pop	 esi
  00463	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00464	5d		 pop	 ebp
  00465	c3		 ret	 0
$LN262@ProtocolCo:

; 570  : 							}
; 571  : 							else
; 572  : 							{
; 573  : //#else
; 574  : 								CGPShopReqBuyItem((PMSG_REQ_BUYITEM_FROM_PSHOP *)aRecv, aIndex);

  00466	e8 00 00 00 00	 call	 ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
  0046b	83 c4 08	 add	 esp, 8
  0046e	5f		 pop	 edi
  0046f	5e		 pop	 esi
  00470	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00471	5d		 pop	 ebp
  00472	c3		 ret	 0
$LN260@ProtocolCo:

; 575  : 							}
; 576  : //#endif						
; 577  : 							break;
; 578  : 					}
; 579  : 				}
; 580  : 				break;
; 581  : 			case 0x40:
; 582  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00473	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  00476	52		 push	 edx
  00477	50		 push	 eax
  00478	53		 push	 ebx
  00479	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0047e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00481	85 c0		 test	 eax, eax
  00483	0f 84 96 0f 00
	00		 je	 $LN344@ProtocolCo

; 583  : 				{
; 584  : 					CGPartyRequestRecv((PMSG_PARTYREQUEST *)aRecv, aIndex);

  00489	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0048c	53		 push	 ebx
  0048d	50		 push	 eax
  0048e	e8 00 00 00 00	 call	 ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
  00493	83 c4 08	 add	 esp, 8
  00496	5f		 pop	 edi
  00497	5e		 pop	 esi
  00498	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00499	5d		 pop	 ebp
  0049a	c3		 ret	 0
$LN258@ProtocolCo:

; 585  : 				}
; 586  : 				break;
; 587  : 			case 0x41:
; 588  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0049b	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  0049e	51		 push	 ecx
  0049f	50		 push	 eax
  004a0	53		 push	 ebx
  004a1	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  004a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a9	85 c0		 test	 eax, eax
  004ab	0f 84 6e 0f 00
	00		 je	 $LN344@ProtocolCo

; 589  : 				{
; 590  : 					CGPartyRequestResultRecv((PMSG_PARTYREQUESTRESULT *)aRecv, aIndex);

  004b1	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  004b4	53		 push	 ebx
  004b5	52		 push	 edx
  004b6	e8 00 00 00 00	 call	 ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
  004bb	83 c4 08	 add	 esp, 8
  004be	5f		 pop	 edi
  004bf	5e		 pop	 esi
  004c0	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  004c1	5d		 pop	 ebp
  004c2	c3		 ret	 0
$LN256@ProtocolCo:

; 591  : 				}
; 592  : 				break;
; 593  : 			case 0x42:
; 594  : 				CGPartyList(aIndex);

  004c3	53		 push	 ebx
  004c4	e8 00 00 00 00	 call	 ?CGPartyList@@YAXH@Z	; CGPartyList
  004c9	83 c4 04	 add	 esp, 4
  004cc	5f		 pop	 edi
  004cd	5e		 pop	 esi
  004ce	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  004cf	5d		 pop	 ebp
  004d0	c3		 ret	 0
$LN255@ProtocolCo:

; 595  : 				break;
; 596  : 			case 0x43:
; 597  : 				if ( PacketCheckTime(&gObj[aIndex]) == TRUE )

  004d1	56		 push	 esi
  004d2	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  004d7	83 c4 04	 add	 esp, 4
  004da	83 f8 01	 cmp	 eax, 1
  004dd	0f 85 3c 0f 00
	00		 jne	 $LN344@ProtocolCo

; 598  : 				{
; 599  : #if(CUSTOM_SAVE_PT==TRUE)
; 600  : 					gParty.SetPartyIndex((PMSG_PARTYDELUSER *)aRecv, aIndex);

  004e3	8b 75 0c	 mov	 esi, DWORD PTR _aRecv$[ebp]
  004e6	53		 push	 ebx
  004e7	56		 push	 esi
  004e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004ed	e8 00 00 00 00	 call	 ?SetPartyIndex@PartyClass@@QAEXPAUPMSG_PARTYDELUSER@@H@Z ; PartyClass::SetPartyIndex

; 601  : #endif
; 602  : 					CGPartyDelUser((PMSG_PARTYDELUSER *)aRecv, aIndex);

  004f2	53		 push	 ebx
  004f3	56		 push	 esi
  004f4	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  004f9	83 c4 08	 add	 esp, 8
  004fc	5f		 pop	 edi
  004fd	5e		 pop	 esi
  004fe	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  004ff	5d		 pop	 ebp
  00500	c3		 ret	 0
$LN253@ProtocolCo:

; 603  : 				}
; 604  : 				break;
; 605  : 			case 0x50:
; 606  : 				CGGuildRequestRecv((PMSG_GUILDJOINQ *)aRecv, aIndex);

  00501	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00504	53		 push	 ebx
  00505	50		 push	 eax
  00506	e8 00 00 00 00	 call	 ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ; CGGuildRequestRecv
  0050b	83 c4 08	 add	 esp, 8
  0050e	5f		 pop	 edi
  0050f	5e		 pop	 esi
  00510	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00511	5d		 pop	 ebp
  00512	c3		 ret	 0
$LN252@ProtocolCo:

; 607  : 				break;
; 608  : 			case 0x51:
; 609  : 				CGGuildRequestResultRecv((PMSG_GUILDQRESULT *)aRecv, aIndex);

  00513	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00516	53		 push	 ebx
  00517	51		 push	 ecx
  00518	e8 00 00 00 00	 call	 ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
  0051d	83 c4 08	 add	 esp, 8
  00520	5f		 pop	 edi
  00521	5e		 pop	 esi
  00522	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00523	5d		 pop	 ebp
  00524	c3		 ret	 0
$LN251@ProtocolCo:

; 610  : 				break;
; 611  : 			case 0x52:
; 612  : 				CGGuildListAll(aIndex);

  00525	53		 push	 ebx
  00526	e8 00 00 00 00	 call	 ?CGGuildListAll@@YAXH@Z	; CGGuildListAll
  0052b	83 c4 04	 add	 esp, 4
  0052e	5f		 pop	 edi
  0052f	5e		 pop	 esi
  00530	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00531	5d		 pop	 ebp
  00532	c3		 ret	 0
$LN250@ProtocolCo:

; 613  : 				break;
; 614  : 			case 0x53:
; 615  : 				CGGuildDelUser((PMSG_GUILDDELUSER *)aRecv, aIndex);

  00533	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00536	53		 push	 ebx
  00537	52		 push	 edx
  00538	e8 00 00 00 00	 call	 ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ; CGGuildDelUser
  0053d	83 c4 08	 add	 esp, 8
  00540	5f		 pop	 edi
  00541	5e		 pop	 esi
  00542	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00543	5d		 pop	 ebp
  00544	c3		 ret	 0
$LN249@ProtocolCo:

; 616  : 				break;
; 617  : 			case 0x54:
; 618  : 				CGGuildMasterAnswerRecv((PMSG_GUILDMASTERANSWER *)aRecv, aIndex);

  00545	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00548	53		 push	 ebx
  00549	50		 push	 eax
  0054a	e8 00 00 00 00	 call	 ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
  0054f	83 c4 08	 add	 esp, 8
  00552	5f		 pop	 edi
  00553	5e		 pop	 esi
  00554	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00555	5d		 pop	 ebp
  00556	c3		 ret	 0
$LN248@ProtocolCo:

; 619  : 				break;
; 620  : 			case 0x55:
; 621  : 				CGGuildMasterInfoSave(aIndex, (PMSG_GUILDINFOSAVE *)aRecv);

  00557	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0055a	51		 push	 ecx
  0055b	53		 push	 ebx
  0055c	e8 00 00 00 00	 call	 ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
  00561	83 c4 08	 add	 esp, 8
  00564	5f		 pop	 edi
  00565	5e		 pop	 esi
  00566	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00567	5d		 pop	 ebp
  00568	c3		 ret	 0
$LN247@ProtocolCo:

; 622  : 				break;
; 623  : 			case 0x57:
; 624  : 				CGGuildMasterCreateCancel(aIndex);

  00569	53		 push	 ebx
  0056a	e8 00 00 00 00	 call	 ?CGGuildMasterCreateCancel@@YAXH@Z ; CGGuildMasterCreateCancel
  0056f	83 c4 04	 add	 esp, 4
  00572	5f		 pop	 edi
  00573	5e		 pop	 esi
  00574	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00575	5d		 pop	 ebp
  00576	c3		 ret	 0
$LN246@ProtocolCo:

; 625  : 				break;
; 626  : 			case 0x61:
; 627  : 				GCGuildWarRequestSendRecv((PMSG_GUILDWARSEND_RESULT *)aRecv, aIndex);

  00577	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0057a	53		 push	 ebx
  0057b	52		 push	 edx
  0057c	e8 00 00 00 00	 call	 ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
  00581	83 c4 08	 add	 esp, 8
  00584	5f		 pop	 edi
  00585	5e		 pop	 esi
  00586	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00587	5d		 pop	 ebp
  00588	c3		 ret	 0
$LN245@ProtocolCo:

; 628  : 				break;
; 629  : 			case 0x66:
; 630  : 				GCGuildViewportInfo((PMSG_REQ_GUILDVIEWPORT *)aRecv, aIndex);

  00589	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0058c	53		 push	 ebx
  0058d	50		 push	 eax
  0058e	e8 00 00 00 00	 call	 ?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ; GCGuildViewportInfo
  00593	83 c4 08	 add	 esp, 8
  00596	5f		 pop	 edi
  00597	5e		 pop	 esi
  00598	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00599	5d		 pop	 ebp
  0059a	c3		 ret	 0
$LN244@ProtocolCo:

; 631  : 				break;
; 632  : 			case 0xB1:
; 633  : 				{
; 634  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 635  : 					
; 636  : 					switch ( lpDef->subcode )

  0059b	8b 75 0c	 mov	 esi, DWORD PTR _aRecv$[ebp]
  0059e	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  005a2	49		 dec	 ecx
  005a3	0f 85 76 0e 00
	00		 jne	 $LN344@ProtocolCo

; 637  : 					{
; 638  : 						case 0x01:
; 639  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  005a9	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  005ac	51		 push	 ecx
  005ad	50		 push	 eax
  005ae	53		 push	 ebx
  005af	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  005b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b7	85 c0		 test	 eax, eax
  005b9	0f 84 60 0e 00
	00		 je	 $LN344@ProtocolCo

; 640  : 							{
; 641  : 								CGReqMapSvrAuth((PMSG_REQ_MAPSERVERAUTH *)aRecv, aIndex);

  005bf	53		 push	 ebx
  005c0	56		 push	 esi
  005c1	e8 00 00 00 00	 call	 ?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ; CGReqMapSvrAuth
  005c6	83 c4 08	 add	 esp, 8
  005c9	5f		 pop	 edi
  005ca	5e		 pop	 esi
  005cb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  005cc	5d		 pop	 ebp
  005cd	c3		 ret	 0
$LN239@ProtocolCo:

; 642  : 							}
; 643  : 							break;
; 644  : 					}
; 645  : 				}
; 646  : 				break;
; 647  : 			case 0xB2:
; 648  : 				{
; 649  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 650  : 
; 651  : 					switch ( lpDef->subcode )

  005ce	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005d1	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  005d5	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  005d8	0f 87 41 0e 00
	00		 ja	 $LN344@ProtocolCo
  005de	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN358@ProtocolCo[ecx]
  005e5	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN369@ProtocolCo[edx*4]
$LN236@ProtocolCo:

; 652  : 					{
; 653  : 						case 0x00:
; 654  : 							CGReqCastleSiegeState((PMSG_REQ_CASTLESIEGESTATE *)aRecv, aIndex);

  005ec	53		 push	 ebx
  005ed	50		 push	 eax
  005ee	e8 00 00 00 00	 call	 ?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ; CGReqCastleSiegeState
  005f3	83 c4 08	 add	 esp, 8
  005f6	5f		 pop	 edi
  005f7	5e		 pop	 esi
  005f8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  005f9	5d		 pop	 ebp
  005fa	c3		 ret	 0
$LN235@ProtocolCo:

; 655  : 							break;
; 656  : 						case 0x01:
; 657  : 							CGReqRegCastleSiege((PMSG_REQ_REGCASTLESIEGE *)aRecv, aIndex);

  005fb	53		 push	 ebx
  005fc	50		 push	 eax
  005fd	e8 00 00 00 00	 call	 ?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ; CGReqRegCastleSiege
  00602	83 c4 08	 add	 esp, 8
  00605	5f		 pop	 edi
  00606	5e		 pop	 esi
  00607	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00608	5d		 pop	 ebp
  00609	c3		 ret	 0
$LN234@ProtocolCo:

; 658  : 							break;
; 659  : 						case 0x02:
; 660  : 							CGReqGiveUpCastleSiege((PMSG_REQ_GIVEUPCASTLESIEGE *)aRecv, aIndex);

  0060a	53		 push	 ebx
  0060b	50		 push	 eax
  0060c	e8 00 00 00 00	 call	 ?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ; CGReqGiveUpCastleSiege
  00611	83 c4 08	 add	 esp, 8
  00614	5f		 pop	 edi
  00615	5e		 pop	 esi
  00616	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00617	5d		 pop	 ebp
  00618	c3		 ret	 0
$LN233@ProtocolCo:

; 661  : 							break;
; 662  : 						case 0x03:
; 663  : 							CGReqGuildRegInfo((PMSG_REQ_GUILDREGINFO *)aRecv, aIndex);

  00619	53		 push	 ebx
  0061a	50		 push	 eax
  0061b	e8 00 00 00 00	 call	 ?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ; CGReqGuildRegInfo
  00620	83 c4 08	 add	 esp, 8
  00623	5f		 pop	 edi
  00624	5e		 pop	 esi
  00625	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00626	5d		 pop	 ebp
  00627	c3		 ret	 0
$LN232@ProtocolCo:

; 664  : 							break;
; 665  : 						case 0x04:
; 666  : 							CGReqRegGuildMark((PMSG_REQ_REGGUILDMARK *)aRecv, aIndex);

  00628	53		 push	 ebx
  00629	50		 push	 eax
  0062a	e8 00 00 00 00	 call	 ?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ; CGReqRegGuildMark
  0062f	83 c4 08	 add	 esp, 8
  00632	5f		 pop	 edi
  00633	5e		 pop	 esi
  00634	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00635	5d		 pop	 ebp
  00636	c3		 ret	 0
$LN231@ProtocolCo:

; 667  : 							break;
; 668  : 						case 0x05:
; 669  : 							CGReqNpcBuy((PMSG_REQ_NPCBUY *)aRecv, aIndex);

  00637	53		 push	 ebx
  00638	50		 push	 eax
  00639	e8 00 00 00 00	 call	 ?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z ; CGReqNpcBuy
  0063e	83 c4 08	 add	 esp, 8
  00641	5f		 pop	 edi
  00642	5e		 pop	 esi
  00643	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00644	5d		 pop	 ebp
  00645	c3		 ret	 0
$LN230@ProtocolCo:

; 670  : 							break;
; 671  : 						case 0x06:
; 672  : 							CGReqNpcRepair((PMSG_REQ_NPCREPAIR *)aRecv, aIndex);

  00646	53		 push	 ebx
  00647	50		 push	 eax
  00648	e8 00 00 00 00	 call	 ?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z ; CGReqNpcRepair
  0064d	83 c4 08	 add	 esp, 8
  00650	5f		 pop	 edi
  00651	5e		 pop	 esi
  00652	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00653	5d		 pop	 ebp
  00654	c3		 ret	 0
$LN229@ProtocolCo:

; 673  : 							break;
; 674  : 						case 0x07:
; 675  : 							CGReqNpcUpgrade((PMSG_REQ_NPCUPGRADE *)aRecv, aIndex);

  00655	53		 push	 ebx
  00656	50		 push	 eax
  00657	e8 00 00 00 00	 call	 ?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ; CGReqNpcUpgrade
  0065c	83 c4 08	 add	 esp, 8
  0065f	5f		 pop	 edi
  00660	5e		 pop	 esi
  00661	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00662	5d		 pop	 ebp
  00663	c3		 ret	 0
$LN228@ProtocolCo:

; 676  : 							break;
; 677  : 						case 0x08:
; 678  : 							CGReqTaxMoneyInfo((PMSG_REQ_TAXMONEYINFO *)aRecv, aIndex);

  00664	53		 push	 ebx
  00665	50		 push	 eax
  00666	e8 00 00 00 00	 call	 ?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ; CGReqTaxMoneyInfo
  0066b	83 c4 08	 add	 esp, 8
  0066e	5f		 pop	 edi
  0066f	5e		 pop	 esi
  00670	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00671	5d		 pop	 ebp
  00672	c3		 ret	 0
$LN227@ProtocolCo:

; 679  : 							break;
; 680  : 						case 0x09:
; 681  : 							CGReqTaxRateChange((PMSG_REQ_TAXRATECHANGE *)aRecv, aIndex);

  00673	53		 push	 ebx
  00674	50		 push	 eax
  00675	e8 00 00 00 00	 call	 ?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ; CGReqTaxRateChange
  0067a	83 c4 08	 add	 esp, 8
  0067d	5f		 pop	 edi
  0067e	5e		 pop	 esi
  0067f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00680	5d		 pop	 ebp
  00681	c3		 ret	 0
$LN226@ProtocolCo:

; 682  : 							break;
; 683  : 						case 0x10:
; 684  : 							CGReqMoneyDrawOut((PMSG_REQ_MONEYDRAWOUT *)aRecv, aIndex);

  00682	53		 push	 ebx
  00683	50		 push	 eax
  00684	e8 00 00 00 00	 call	 ?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ; CGReqMoneyDrawOut
  00689	83 c4 08	 add	 esp, 8
  0068c	5f		 pop	 edi
  0068d	5e		 pop	 esi
  0068e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0068f	5d		 pop	 ebp
  00690	c3		 ret	 0
$LN225@ProtocolCo:

; 685  : 							break;
; 686  : 						case 0x12:
; 687  : 							CGReqCsGateOperate((PMSG_REQ_CSGATEOPERATE *)aRecv, aIndex);

  00691	53		 push	 ebx
  00692	50		 push	 eax
  00693	e8 00 00 00 00	 call	 ?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ; CGReqCsGateOperate
  00698	83 c4 08	 add	 esp, 8
  0069b	5f		 pop	 edi
  0069c	5e		 pop	 esi
  0069d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0069e	5d		 pop	 ebp
  0069f	c3		 ret	 0
$LN224@ProtocolCo:

; 688  : 							break;
; 689  : 						case 0x1B:
; 690  : 							CGReqCsMiniMapData((PMSG_REQ_MINIMAPDATA *)aRecv, aIndex);

  006a0	53		 push	 ebx
  006a1	50		 push	 eax
  006a2	e8 00 00 00 00	 call	 ?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ; CGReqCsMiniMapData
  006a7	83 c4 08	 add	 esp, 8
  006aa	5f		 pop	 edi
  006ab	5e		 pop	 esi
  006ac	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  006ad	5d		 pop	 ebp
  006ae	c3		 ret	 0
$LN223@ProtocolCo:

; 691  : 							break;
; 692  : 						case 0x1C:
; 693  : 							CGReqStopCsMiniMapData((PMSG_REQ_STOPMINIMAPDATA *)aRecv, aIndex);

  006af	53		 push	 ebx
  006b0	50		 push	 eax
  006b1	e8 00 00 00 00	 call	 ?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ; CGReqStopCsMiniMapData
  006b6	83 c4 08	 add	 esp, 8
  006b9	5f		 pop	 edi
  006ba	5e		 pop	 esi
  006bb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  006bc	5d		 pop	 ebp
  006bd	c3		 ret	 0
$LN222@ProtocolCo:

; 694  : 							break;
; 695  : 						case 0x1D:
; 696  : 							CGReqCsSendCommand((PMSG_REQ_CSCOMMAND *)aRecv, aIndex);

  006be	53		 push	 ebx
  006bf	50		 push	 eax
  006c0	e8 00 00 00 00	 call	 ?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ; CGReqCsSendCommand
  006c5	83 c4 08	 add	 esp, 8
  006c8	5f		 pop	 edi
  006c9	5e		 pop	 esi
  006ca	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  006cb	5d		 pop	 ebp
  006cc	c3		 ret	 0
$LN221@ProtocolCo:

; 697  : 							break;
; 698  : 						case 0x1F:
; 699  : 							CGReqCsSetEnterHuntZone((PMSG_REQ_CSHUNTZONEENTER *)aRecv, aIndex);

  006cd	53		 push	 ebx
  006ce	50		 push	 eax
  006cf	e8 00 00 00 00	 call	 ?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ; CGReqCsSetEnterHuntZone
  006d4	83 c4 08	 add	 esp, 8
  006d7	5f		 pop	 edi
  006d8	5e		 pop	 esi
  006d9	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  006da	5d		 pop	 ebp
  006db	c3		 ret	 0
$LN220@ProtocolCo:

; 700  : 							break;
; 701  : 					}
; 702  : 				}
; 703  : 				break;
; 704  : 			case 0xB3:
; 705  : 				CGReqNpcDbList((PMSG_REQ_NPCDBLIST *)aRecv, aIndex);

  006dc	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  006df	53		 push	 ebx
  006e0	50		 push	 eax
  006e1	e8 00 00 00 00	 call	 ?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z ; CGReqNpcDbList
  006e6	83 c4 08	 add	 esp, 8
  006e9	5f		 pop	 edi
  006ea	5e		 pop	 esi
  006eb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  006ec	5d		 pop	 ebp
  006ed	c3		 ret	 0
$LN219@ProtocolCo:

; 706  : 				break;
; 707  : 			case 0xB4:
; 708  : 				CGReqCsRegGuildList((PMSG_REQ_CSREGGUILDLIST *)aRecv, aIndex);

  006ee	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  006f1	53		 push	 ebx
  006f2	51		 push	 ecx
  006f3	e8 00 00 00 00	 call	 ?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ; CGReqCsRegGuildList
  006f8	83 c4 08	 add	 esp, 8
  006fb	5f		 pop	 edi
  006fc	5e		 pop	 esi
  006fd	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  006fe	5d		 pop	 ebp
  006ff	c3		 ret	 0
$LN218@ProtocolCo:

; 709  : 				break;
; 710  : 			case 0xB5:
; 711  : 				CGReqCsAttkGuildList((PMSG_REQ_CSATTKGUILDLIST *)aRecv, aIndex);

  00700	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00703	53		 push	 ebx
  00704	52		 push	 edx
  00705	e8 00 00 00 00	 call	 ?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ; CGReqCsAttkGuildList
  0070a	83 c4 08	 add	 esp, 8
  0070d	5f		 pop	 edi
  0070e	5e		 pop	 esi
  0070f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00710	5d		 pop	 ebp
  00711	c3		 ret	 0
$LN217@ProtocolCo:

; 712  : 				break;
; 713  : 			case 0xB7:
; 714  : 				{
; 715  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 716  : 
; 717  : 					switch ( lpDef->subcode )

  00712	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00715	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00719	48		 dec	 eax
  0071a	74 18		 je	 SHORT $LN214@ProtocolCo
  0071c	83 e8 03	 sub	 eax, 3
  0071f	0f 85 fa 0c 00
	00		 jne	 $LN344@ProtocolCo

; 721  : 							break;
; 722  : 						case 0x04:
; 723  : 							CGReqWeaponDamageValue((PMSG_REQ_WEAPON_DAMAGE_VALUE *)aRecv, aIndex);

  00725	53		 push	 ebx
  00726	51		 push	 ecx
  00727	e8 00 00 00 00	 call	 ?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ; CGReqWeaponDamageValue
  0072c	83 c4 08	 add	 esp, 8
  0072f	5f		 pop	 edi
  00730	5e		 pop	 esi
  00731	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00732	5d		 pop	 ebp
  00733	c3		 ret	 0
$LN214@ProtocolCo:

; 718  : 					{
; 719  : 						case 0x01:
; 720  : 							CGReqWeaponUse((PMSG_REQ_USEWEAPON *)aRecv, aIndex);

  00734	53		 push	 ebx
  00735	51		 push	 ecx
  00736	e8 00 00 00 00	 call	 ?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z ; CGReqWeaponUse
  0073b	83 c4 08	 add	 esp, 8
  0073e	5f		 pop	 edi
  0073f	5e		 pop	 esi
  00740	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00741	5d		 pop	 ebp
  00742	c3		 ret	 0
$LN212@ProtocolCo:

; 724  : 							break;
; 725  : 					}
; 726  : 				}
; 727  : 				break;
; 728  : 			case 0xB9:
; 729  : 				{
; 730  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 731  : 
; 732  : 					switch ( lpDef->subcode )

  00743	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00746	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0074a	83 e8 02	 sub	 eax, 2
  0074d	74 18		 je	 SHORT $LN209@ProtocolCo
  0074f	83 e8 03	 sub	 eax, 3
  00752	0f 85 c7 0c 00
	00		 jne	 $LN344@ProtocolCo

; 736  : 							break;
; 737  : 							//#if(GS_CASTLE==1)
; 738  : 						case 0x05:
; 739  : 							CGReqCastleHuntZoneEntrance((PMSG_REQ_MOVE_TO_CASTLE_HUNTZONE *)aRecv, aIndex);

  00758	53		 push	 ebx
  00759	51		 push	 ecx
  0075a	e8 00 00 00 00	 call	 ?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ; CGReqCastleHuntZoneEntrance
  0075f	83 c4 08	 add	 esp, 8
  00762	5f		 pop	 edi
  00763	5e		 pop	 esi
  00764	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00765	5d		 pop	 ebp
  00766	c3		 ret	 0
$LN209@ProtocolCo:

; 733  : 					{
; 734  : 						case 0x02:
; 735  : 							CGReqGuildMarkOfCastleOwner((PMSG_REQ_GUILDMARK_OF_CASTLEOWNER *)aRecv, aIndex);

  00767	53		 push	 ebx
  00768	51		 push	 ecx
  00769	e8 00 00 00 00	 call	 ?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ; CGReqGuildMarkOfCastleOwner
  0076e	83 c4 08	 add	 esp, 8
  00771	5f		 pop	 edi
  00772	5e		 pop	 esi
  00773	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00774	5d		 pop	 ebp
  00775	c3		 ret	 0
$LN207@ProtocolCo:

; 740  : 							break;
; 741  : 							//#endif
; 742  : 					}
; 743  : 				}
; 744  : 				break;
; 745  : 			case 0xBC:
; 746  : 				{
; 747  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 748  : 
; 749  : 					switch ( lpDef->subcode )

  00776	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00779	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0077d	83 e8 00	 sub	 eax, 0
  00780	74 16		 je	 SHORT $LN204@ProtocolCo
  00782	48		 dec	 eax
  00783	0f 85 96 0c 00
	00		 jne	 $LN344@ProtocolCo

; 753  : 							break;
; 754  : 						case 0x01:
; 755  : 							CGReqJewelUnMix((PMSG_REQ_JEWEL_UNMIX *)aRecv, aIndex);

  00789	53		 push	 ebx
  0078a	51		 push	 ecx
  0078b	e8 00 00 00 00	 call	 ?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ; CGReqJewelUnMix
  00790	83 c4 08	 add	 esp, 8
  00793	5f		 pop	 edi
  00794	5e		 pop	 esi
  00795	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00796	5d		 pop	 ebp
  00797	c3		 ret	 0
$LN204@ProtocolCo:

; 750  : 					{
; 751  : 						case 0x00:
; 752  : 							CGReqJewelMix((PMSG_REQ_JEWEL_MIX *)aRecv, aIndex);

  00798	53		 push	 ebx
  00799	51		 push	 ecx
  0079a	e8 00 00 00 00	 call	 ?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z ; CGReqJewelMix
  0079f	83 c4 08	 add	 esp, 8
  007a2	5f		 pop	 edi
  007a3	5e		 pop	 esi
  007a4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  007a5	5d		 pop	 ebp
  007a6	c3		 ret	 0
$LN202@ProtocolCo:

; 756  : 							break;
; 757  : 					}
; 758  : 				}
; 759  : 				break;
; 760  : 			case 0xBD:
; 761  : 				{
; 762  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 763  : 
; 764  : 					switch ( lpDef->subcode )

  007a7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007aa	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  007ad	84 c9		 test	 cl, cl
  007af	74 2c		 je	 SHORT $LN199@ProtocolCo
  007b1	80 f9 03	 cmp	 cl, 3
  007b4	74 18		 je	 SHORT $LN198@ProtocolCo
  007b6	80 f9 09	 cmp	 cl, 9
  007b9	0f 85 60 0c 00
	00		 jne	 $LN344@ProtocolCo

; 771  : 							break;
; 772  : 						case 0x09:
; 773  : 							CGReqPlusChaosRate((PMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE *)aRecv, aIndex);

  007bf	53		 push	 ebx
  007c0	50		 push	 eax
  007c1	e8 00 00 00 00	 call	 ?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ; CGReqPlusChaosRate
  007c6	83 c4 08	 add	 esp, 8
  007c9	5f		 pop	 edi
  007ca	5e		 pop	 esi
  007cb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  007cc	5d		 pop	 ebp
  007cd	c3		 ret	 0
$LN198@ProtocolCo:

; 768  : 							break;
; 769  : 						case 0x03:
; 770  : 							CGReqAlatrContract((PMSG_REQ_CRYWOLF_ALTAR_CONTRACT *)aRecv, aIndex);

  007ce	53		 push	 ebx
  007cf	50		 push	 eax
  007d0	e8 00 00 00 00	 call	 ?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ; CGReqAlatrContract
  007d5	83 c4 08	 add	 esp, 8
  007d8	5f		 pop	 edi
  007d9	5e		 pop	 esi
  007da	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  007db	5d		 pop	 ebp
  007dc	c3		 ret	 0
$LN199@ProtocolCo:

; 765  : 					{
; 766  : 						case 0x00:
; 767  : 							CGReqCrywolfInfo((PMSG_REQ_CRYWOLF_INFO *)aRecv, aIndex);

  007dd	53		 push	 ebx
  007de	50		 push	 eax
  007df	e8 00 00 00 00	 call	 ?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ; CGReqCrywolfInfo
  007e4	83 c4 08	 add	 esp, 8
  007e7	5f		 pop	 edi
  007e8	5e		 pop	 esi
  007e9	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  007ea	5d		 pop	 ebp
  007eb	c3		 ret	 0
$LN196@ProtocolCo:

; 774  : 							break;
; 775  : 					}
; 776  : 				}
; 777  : 				break;
; 778  : 			case 0xE1:
; 779  : 				CGGuildAssignStatus((PMSG_GUILD_ASSIGN_STATUS_REQ *)aRecv, aIndex);

  007ec	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007ef	53		 push	 ebx
  007f0	50		 push	 eax
  007f1	e8 00 00 00 00	 call	 ?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ; CGGuildAssignStatus
  007f6	83 c4 08	 add	 esp, 8
  007f9	5f		 pop	 edi
  007fa	5e		 pop	 esi
  007fb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  007fc	5d		 pop	 ebp
  007fd	c3		 ret	 0
$LN195@ProtocolCo:

; 780  : 				break;
; 781  : 			case 0xE2:
; 782  : 				CGGuildAssignType((PMSG_GUILD_ASSIGN_TYPE_REQ *)aRecv, aIndex);

  007fe	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00801	53		 push	 ebx
  00802	51		 push	 ecx
  00803	e8 00 00 00 00	 call	 ?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ; CGGuildAssignType
  00808	83 c4 08	 add	 esp, 8
  0080b	5f		 pop	 edi
  0080c	5e		 pop	 esi
  0080d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0080e	5d		 pop	 ebp
  0080f	c3		 ret	 0
$LN194@ProtocolCo:

; 783  : 				break;
; 784  : 			case 0xE5:
; 785  : 				CGRelationShipReqJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ *)aRecv, aIndex);

  00810	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00813	53		 push	 ebx
  00814	52		 push	 edx
  00815	e8 00 00 00 00	 call	 ?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ; CGRelationShipReqJoinBreakOff
  0081a	83 c4 08	 add	 esp, 8
  0081d	5f		 pop	 edi
  0081e	5e		 pop	 esi
  0081f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00820	5d		 pop	 ebp
  00821	c3		 ret	 0
$LN193@ProtocolCo:

; 786  : 				break;
; 787  : 			case 0xE6:
; 788  : 				CGRelationShipAnsJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS *)aRecv, aIndex);

  00822	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00825	53		 push	 ebx
  00826	50		 push	 eax
  00827	e8 00 00 00 00	 call	 ?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ; CGRelationShipAnsJoinBreakOff
  0082c	83 c4 08	 add	 esp, 8
  0082f	5f		 pop	 edi
  00830	5e		 pop	 esi
  00831	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00832	5d		 pop	 ebp
  00833	c3		 ret	 0
$LN192@ProtocolCo:

; 789  : 				break;
; 790  : 			case 0xE9:
; 791  : 				CGUnionList((PMSG_UNIONLIST_REQ *)aRecv, aIndex);

  00834	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00837	53		 push	 ebx
  00838	51		 push	 ecx
  00839	e8 00 00 00 00	 call	 ?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z ; CGUnionList
  0083e	83 c4 08	 add	 esp, 8
  00841	5f		 pop	 edi
  00842	5e		 pop	 esi
  00843	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00844	5d		 pop	 ebp
  00845	c3		 ret	 0
$LN191@ProtocolCo:

; 792  : 				break;
; 793  : 			case 0xEB:
; 794  : 				{
; 795  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 796  : 
; 797  : 					switch ( lpDef->subcode )

  00846	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00849	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0084d	48		 dec	 eax
  0084e	0f 85 cb 0b 00
	00		 jne	 $LN344@ProtocolCo

; 798  : 					{
; 799  : 						case 0x01:
; 800  : 							CGRelationShipReqKickOutUnionMember((PMSG_KICKOUT_UNIONMEMBER_REQ *)aRecv, aIndex);

  00854	53		 push	 ebx
  00855	51		 push	 ecx
  00856	e8 00 00 00 00	 call	 ?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ; CGRelationShipReqKickOutUnionMember
  0085b	83 c4 08	 add	 esp, 8
  0085e	5f		 pop	 edi
  0085f	5e		 pop	 esi
  00860	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00861	5d		 pop	 ebp
  00862	c3		 ret	 0
$LN187@ProtocolCo:

; 801  : 							break;
; 802  : 					}
; 803  : 				}
; 804  : 				break;
; 805  : 			case 0x71:
; 806  : 				GCPingSendRecv((PMSG_PING_RESULT *)aRecv, aIndex);

  00863	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00866	53		 push	 ebx
  00867	52		 push	 edx
  00868	e8 00 00 00 00	 call	 ?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z ; GCPingSendRecv
  0086d	83 c4 08	 add	 esp, 8
  00870	5f		 pop	 edi
  00871	5e		 pop	 esi
  00872	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00873	5d		 pop	 ebp
  00874	c3		 ret	 0
$LN186@ProtocolCo:

; 807  : 				break;
; 808  : 			//case 0x72:
; 809  : 			//	if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )
; 810  : 			//	{
; 811  : 			//		GCPacketCheckSumRecv((PMSG_PACKETCHECKSUM *)aRecv, aIndex);
; 812  : 			//	}
; 813  : 			//	break;
; 814  : 			//case 0x73:
; 815  : 			//	if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )
; 816  : 			//	{
; 817  : 			//		GCNPggCheckSumRecv((PMSG_NPROTECTGGCHECKSUM *)aRecv, aIndex);
; 818  : 			//	}
; 819  : 			//	break;
; 820  : 			case 0x81:
; 821  : 				CGWarehouseMoneyInOut(aIndex, (PMSG_WAREHOUSEMONEYINOUT *)aRecv);

  00875	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00878	50		 push	 eax
  00879	53		 push	 ebx
  0087a	e8 00 00 00 00	 call	 ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
  0087f	83 c4 08	 add	 esp, 8
  00882	5f		 pop	 edi
  00883	5e		 pop	 esi
  00884	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00885	5d		 pop	 ebp
  00886	c3		 ret	 0
$LN185@ProtocolCo:

; 822  : 				break;
; 823  : 			case 0x82:
; 824  : 				CGWarehouseUseEnd(aIndex);

  00887	53		 push	 ebx
  00888	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  0088d	83 c4 04	 add	 esp, 4
  00890	5f		 pop	 edi
  00891	5e		 pop	 esi
  00892	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00893	5d		 pop	 ebp
  00894	c3		 ret	 0
$LN184@ProtocolCo:

; 825  : 				break;
; 826  : 			case 0x83:
; 827  : 				GCWarehouseRecivePassword(aIndex, (PMSG_WAREHOUSEPASSSEND *)aRecv);

  00895	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00898	51		 push	 ecx
  00899	53		 push	 ebx
  0089a	e8 00 00 00 00	 call	 ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
  0089f	83 c4 08	 add	 esp, 8
  008a2	5f		 pop	 edi
  008a3	5e		 pop	 esi
  008a4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  008a5	5d		 pop	 ebp
  008a6	c3		 ret	 0
$LN183@ProtocolCo:

; 828  : 				break;
; 829  : 			case 0x86:
; 830  : 				CGChaosBoxItemMixButtonClick((PMSG_CHAOSMIX *)aRecv, aIndex);

  008a7	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  008aa	53		 push	 ebx
  008ab	52		 push	 edx
  008ac	e8 00 00 00 00	 call	 ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
  008b1	83 c4 08	 add	 esp, 8
  008b4	5f		 pop	 edi
  008b5	5e		 pop	 esi
  008b6	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  008b7	5d		 pop	 ebp
  008b8	c3		 ret	 0
$LN182@ProtocolCo:

; 831  : 				break;
; 832  : 			case 0x87:
; 833  : 				CGChaosBoxUseEnd(aIndex);

  008b9	53		 push	 ebx
  008ba	e8 00 00 00 00	 call	 ?CGChaosBoxUseEnd@@YAXH@Z ; CGChaosBoxUseEnd
  008bf	83 c4 04	 add	 esp, 4
  008c2	5f		 pop	 edi
  008c3	5e		 pop	 esi
  008c4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  008c5	5d		 pop	 ebp
  008c6	c3		 ret	 0
$LN181@ProtocolCo:

; 834  : 				break;
; 835  : 			case 0x8E://SEASON 5 PACKET
; 836  : 				CGMapMoveRecv((PMSG_MAP_MOVE *)aRecv, aIndex);

  008c7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  008ca	53		 push	 ebx
  008cb	50		 push	 eax
  008cc	e8 00 00 00 00	 call	 ?CGMapMoveRecv@@YAXPAUPMSG_MAP_MOVE@@H@Z ; CGMapMoveRecv
  008d1	83 c4 08	 add	 esp, 8
  008d4	5f		 pop	 edi
  008d5	5e		 pop	 esi
  008d6	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  008d7	5d		 pop	 ebp
  008d8	c3		 ret	 0
$LN180@ProtocolCo:

; 837  : 				break;
; 838  : 			case 0x90:
; 839  : 				GCReqmoveDevilSquare((PMSG_REQ_MOVEDEVILSQUARE *)aRecv, aIndex);

  008d9	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  008dc	53		 push	 ebx
  008dd	51		 push	 ecx
  008de	e8 00 00 00 00	 call	 ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
  008e3	83 c4 08	 add	 esp, 8
  008e6	5f		 pop	 edi
  008e7	5e		 pop	 esi
  008e8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  008e9	5d		 pop	 ebp
  008ea	c3		 ret	 0
$LN179@ProtocolCo:

; 840  : 				break;
; 841  : 			case 0x91:
; 842  : 				GCReqDevilSquareRemainTime((PMSG_REQ_DEVILSQUARE_REMAINTIME *)aRecv, aIndex);

  008eb	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  008ee	53		 push	 ebx
  008ef	52		 push	 edx
  008f0	e8 00 00 00 00	 call	 ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
  008f5	83 c4 08	 add	 esp, 8
  008f8	5f		 pop	 edi
  008f9	5e		 pop	 esi
  008fa	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  008fb	5d		 pop	 ebp
  008fc	c3		 ret	 0
$LN178@ProtocolCo:

; 843  : 				break;
; 844  : 			case 0x95:
; 845  : 				GCRegEventChipRecv((PMSG_REGEVENTCHIP *)aRecv, aIndex);

  008fd	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00900	53		 push	 ebx
  00901	50		 push	 eax
  00902	e8 00 00 00 00	 call	 ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
  00907	83 c4 08	 add	 esp, 8
  0090a	5f		 pop	 edi
  0090b	5e		 pop	 esi
  0090c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0090d	5d		 pop	 ebp
  0090e	c3		 ret	 0
$LN177@ProtocolCo:

; 846  : 				break;
; 847  : 			case 0x96:
; 848  : 				GCGetMutoNumRecv((PMSG_GETMUTONUMBER *)aRecv, aIndex);

  0090f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00912	53		 push	 ebx
  00913	51		 push	 ecx
  00914	e8 00 00 00 00	 call	 ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
  00919	83 c4 08	 add	 esp, 8
  0091c	5f		 pop	 edi
  0091d	5e		 pop	 esi
  0091e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0091f	5d		 pop	 ebp
  00920	c3		 ret	 0
$LN176@ProtocolCo:

; 849  : 				break;
; 850  : 			case 0x97:
; 851  : 				GCUseEndEventChipRescv(aIndex);

  00921	53		 push	 ebx
  00922	e8 00 00 00 00	 call	 ?GCUseEndEventChipRescv@@YAXH@Z ; GCUseEndEventChipRescv
  00927	83 c4 04	 add	 esp, 4
  0092a	5f		 pop	 edi
  0092b	5e		 pop	 esi
  0092c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0092d	5d		 pop	 ebp
  0092e	c3		 ret	 0
$LN175@ProtocolCo:

; 852  : 				break;
; 853  : 			case 0x98:
; 854  : 				GCUseRenaChangeZenRecv((PMSG_EXCHANGE_EVENTCHIP *)aRecv, aIndex);

  0092f	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00932	53		 push	 ebx
  00933	52		 push	 edx
  00934	e8 00 00 00 00	 call	 ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
  00939	83 c4 08	 add	 esp, 8
  0093c	5f		 pop	 edi
  0093d	5e		 pop	 esi
  0093e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0093f	5d		 pop	 ebp
  00940	c3		 ret	 0
$LN174@ProtocolCo:

; 855  : 				break;
; 856  : 			case 0x99:
; 857  : 				CGReqMoveOtherServer((PMSG_REQ_MOVE_OTHERSERVER *)aRecv, aIndex);

  00941	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00944	53		 push	 ebx
  00945	50		 push	 eax
  00946	e8 00 00 00 00	 call	 ?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ; CGReqMoveOtherServer
  0094b	83 c4 08	 add	 esp, 8
  0094e	5f		 pop	 edi
  0094f	5e		 pop	 esi
  00950	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00951	5d		 pop	 ebp
  00952	c3		 ret	 0
$LN173@ProtocolCo:

; 858  : 				break;
; 859  : 			case 0xA0:
; 860  : 				CGRequestQuestInfo(aIndex);

  00953	53		 push	 ebx
  00954	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  00959	83 c4 04	 add	 esp, 4
  0095c	5f		 pop	 edi
  0095d	5e		 pop	 esi
  0095e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0095f	5d		 pop	 ebp
  00960	c3		 ret	 0
$LN172@ProtocolCo:

; 861  : 				break;
; 862  : 			case 0xA2:
; 863  : 				CGSetQuestState((PMSG_SETQUEST *)aRecv, aIndex);

  00961	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00964	53		 push	 ebx
  00965	51		 push	 ecx
  00966	e8 00 00 00 00	 call	 ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ; CGSetQuestState
  0096b	83 c4 08	 add	 esp, 8
  0096e	5f		 pop	 edi
  0096f	5e		 pop	 esi
  00970	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00971	5d		 pop	 ebp
  00972	c3		 ret	 0
$LN171@ProtocolCo:

; 864  : 				break;
; 865  : 			case 0xA7:
; 866  : 				CGRequestPetItemCommand((PMSG_REQUEST_PET_ITEM_COMMAND *)aRecv, aIndex);

  00973	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00976	53		 push	 ebx
  00977	52		 push	 edx
  00978	e8 00 00 00 00	 call	 ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
  0097d	83 c4 08	 add	 esp, 8
  00980	5f		 pop	 edi
  00981	5e		 pop	 esi
  00982	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00983	5d		 pop	 ebp
  00984	c3		 ret	 0
$LN170@ProtocolCo:

; 867  : 				break;
; 868  : 			case 0xA9:
; 869  : 				CGRequestPetItemInfo((PMSG_REQUEST_PET_ITEMINFO *)aRecv, aIndex);

  00985	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00988	53		 push	 ebx
  00989	50		 push	 eax
  0098a	e8 00 00 00 00	 call	 ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
  0098f	83 c4 08	 add	 esp, 8
  00992	5f		 pop	 edi
  00993	5e		 pop	 esi
  00994	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00995	5d		 pop	 ebp
  00996	c3		 ret	 0
$LN169@ProtocolCo:

; 870  : 				break;
; 871  : 			case 0xAA:
; 872  : //#if(GS_CASTLE==0)
; 873  : 				g_DuelManager.ProtocolCore(lpObj,aRecv);

  00997	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0099a	51		 push	 ecx
  0099b	56		 push	 esi
  0099c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DuelManager@@3VCDuelManager@@A ; g_DuelManager
  009a1	e8 00 00 00 00	 call	 ?ProtocolCore@CDuelManager@@QAEXPAUOBJECTSTRUCT@@PAE@Z ; CDuelManager::ProtocolCore
  009a6	5f		 pop	 edi
  009a7	5e		 pop	 esi
  009a8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  009a9	5d		 pop	 ebp
  009aa	c3		 ret	 0
$LN168@ProtocolCo:

; 874  : //#else
; 875  : //				MsgNormal(aIndex,"You can't use duel on CS server!");
; 876  : //#endif
; 877  : 				//CGDuelStartRequestRecv((PMSG_REQ_START_DUEL *)aRecv, aIndex);
; 878  : 				break;
; 879  : 			case 0xAB:
; 880  : 				CGDuelEndRequestRecv((PMSG_REQ_END_DUEL *)aRecv, aIndex);

  009ab	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  009ae	53		 push	 ebx
  009af	52		 push	 edx
  009b0	e8 00 00 00 00	 call	 ?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ; CGDuelEndRequestRecv
  009b5	83 c4 08	 add	 esp, 8
  009b8	5f		 pop	 edi
  009b9	5e		 pop	 esi
  009ba	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  009bb	5d		 pop	 ebp
  009bc	c3		 ret	 0
$LN167@ProtocolCo:

; 881  : 				break;
; 882  : 			case 0xAC:
; 883  : 				CGDuelOkRequestRecv((PMSG_ANS_DUEL_OK *)aRecv, aIndex);

  009bd	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  009c0	53		 push	 ebx
  009c1	50		 push	 eax
  009c2	e8 00 00 00 00	 call	 ?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ; CGDuelOkRequestRecv
  009c7	83 c4 08	 add	 esp, 8
  009ca	5f		 pop	 edi
  009cb	5e		 pop	 esi
  009cc	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  009cd	5d		 pop	 ebp
  009ce	c3		 ret	 0
$LN166@ProtocolCo:

; 884  : 				break;
; 885  : 			case 0x9A:
; 886  : 				CGRequestEnterBloodCastle((PMSG_REQ_MOVEBLOODCASTLE*)aRecv, aIndex);

  009cf	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  009d2	53		 push	 ebx
  009d3	51		 push	 ecx
  009d4	e8 00 00 00 00	 call	 ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
  009d9	83 c4 08	 add	 esp, 8
  009dc	5f		 pop	 edi
  009dd	5e		 pop	 esi
  009de	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  009df	5d		 pop	 ebp
  009e0	c3		 ret	 0
$LN164@ProtocolCo:

; 887  : 				break;
; 888  : 			case 0x9B:
; 889  : 				//#error LAcking PACKET HERE
; 890  : 				break;
; 891  : 			case 0x9F:
; 892  : 				CGRequestEventEnterCount((PMSG_REQ_CL_ENTERCOUNT *)aRecv, aIndex);

  009e1	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  009e4	53		 push	 ebx
  009e5	52		 push	 edx
  009e6	e8 00 00 00 00	 call	 ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
  009eb	83 c4 08	 add	 esp, 8
  009ee	5f		 pop	 edi
  009ef	5e		 pop	 esi
  009f0	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  009f1	5d		 pop	 ebp
  009f2	c3		 ret	 0
$LN163@ProtocolCo:

; 893  : 				break;
; 894  : 			case 0x9D:
; 895  : 				CGRequestLottoRegister((PMSG_REQ_2ANV_LOTTO_EVENT *)aRecv, aIndex);

  009f3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  009f6	53		 push	 ebx
  009f7	50		 push	 eax
  009f8	e8 00 00 00 00	 call	 ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
  009fd	83 c4 08	 add	 esp, 8
  00a00	5f		 pop	 edi
  00a01	5e		 pop	 esi
  00a02	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a03	5d		 pop	 ebp
  00a04	c3		 ret	 0
$LN162@ProtocolCo:

; 896  : 				break;
; 897  : 			case 0xAF:
; 898  : 				{
; 899  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 900  : 
; 901  : 					switch ( lpDef->subcode )

  00a05	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a08	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00a0c	48		 dec	 eax
  00a0d	74 16		 je	 SHORT $LN159@ProtocolCo
  00a0f	48		 dec	 eax
  00a10	0f 85 09 0a 00
	00		 jne	 $LN344@ProtocolCo

; 905  : 							break;
; 906  : 						case 0x02:
; 907  : 							CGRequestRepositionUserInChaosCastle((PMSG_REQ_REPOSUSER_IN_CC *)aRecv, aIndex);

  00a16	53		 push	 ebx
  00a17	51		 push	 ecx
  00a18	e8 00 00 00 00	 call	 ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
  00a1d	83 c4 08	 add	 esp, 8
  00a20	5f		 pop	 edi
  00a21	5e		 pop	 esi
  00a22	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a23	5d		 pop	 ebp
  00a24	c3		 ret	 0
$LN159@ProtocolCo:

; 902  : 					{
; 903  : 						case 0x01:
; 904  : 							CGRequestEnterChaosCastle((PMSG_REQ_MOVECHAOSCASTLE *)aRecv, aIndex);

  00a25	53		 push	 ebx
  00a26	51		 push	 ecx
  00a27	e8 00 00 00 00	 call	 ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
  00a2c	83 c4 08	 add	 esp, 8
  00a2f	5f		 pop	 edi
  00a30	5e		 pop	 esi
  00a31	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a32	5d		 pop	 ebp
  00a33	c3		 ret	 0
$LN157@ProtocolCo:

; 908  : 							break;
; 909  : 					}
; 910  : 				}
; 911  : 				break;
; 912  : 			case 0xC0:
; 913  : 				FriendListRequest(aIndex);

  00a34	53		 push	 ebx
  00a35	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  00a3a	83 c4 04	 add	 esp, 4
  00a3d	5f		 pop	 edi
  00a3e	5e		 pop	 esi
  00a3f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a40	5d		 pop	 ebp
  00a41	c3		 ret	 0
$LN156@ProtocolCo:

; 914  : 				break;
; 915  : 			case 0xC1:
; 916  : 				FriendAddRequest((PMSG_FRIEND_ADD_REQ *)aRecv, aIndex);

  00a42	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a45	53		 push	 ebx
  00a46	51		 push	 ecx
  00a47	e8 00 00 00 00	 call	 ?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z ; FriendAddRequest
  00a4c	83 c4 08	 add	 esp, 8
  00a4f	5f		 pop	 edi
  00a50	5e		 pop	 esi
  00a51	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a52	5d		 pop	 ebp
  00a53	c3		 ret	 0
$LN155@ProtocolCo:

; 917  : 				break;
; 918  : 			case 0xC2:
; 919  : 				WaitFriendAddRequest((PMSG_FRIEND_ADD_SIN_RESULT *)aRecv, aIndex);

  00a54	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00a57	53		 push	 ebx
  00a58	52		 push	 edx
  00a59	e8 00 00 00 00	 call	 ?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z ; WaitFriendAddRequest
  00a5e	83 c4 08	 add	 esp, 8
  00a61	5f		 pop	 edi
  00a62	5e		 pop	 esi
  00a63	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a64	5d		 pop	 ebp
  00a65	c3		 ret	 0
$LN154@ProtocolCo:

; 920  : 				break;
; 921  : 			case 0xC3:
; 922  : 				FriendDelRequest((PMSG_FRIEND_DEL_REQ *)aRecv, aIndex);

  00a66	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00a69	53		 push	 ebx
  00a6a	50		 push	 eax
  00a6b	e8 00 00 00 00	 call	 ?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z ; FriendDelRequest
  00a70	83 c4 08	 add	 esp, 8
  00a73	5f		 pop	 edi
  00a74	5e		 pop	 esi
  00a75	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a76	5d		 pop	 ebp
  00a77	c3		 ret	 0
$LN153@ProtocolCo:

; 923  : 				break;
; 924  : 			case 0xC4:
; 925  : 				FriendStateClientRecv((PMSG_FRIEND_STATE_C *)aRecv, aIndex);

  00a78	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a7b	53		 push	 ebx
  00a7c	51		 push	 ecx
  00a7d	e8 00 00 00 00	 call	 ?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z ; FriendStateClientRecv
  00a82	83 c4 08	 add	 esp, 8
  00a85	5f		 pop	 edi
  00a86	5e		 pop	 esi
  00a87	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a88	5d		 pop	 ebp
  00a89	c3		 ret	 0
$LN152@ProtocolCo:

; 926  : 				break;
; 927  : 			case 0xC5:
; 928  : 				FriendMemoSend((PMSG_FRIEND_MEMO *)aRecv, aIndex);

  00a8a	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00a8d	53		 push	 ebx
  00a8e	52		 push	 edx
  00a8f	e8 00 00 00 00	 call	 ?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z ; FriendMemoSend
  00a94	83 c4 08	 add	 esp, 8
  00a97	5f		 pop	 edi
  00a98	5e		 pop	 esi
  00a99	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00a9a	5d		 pop	 ebp
  00a9b	c3		 ret	 0
$LN151@ProtocolCo:

; 929  : 				break;
; 930  : 			case 0xC7:
; 931  : 				FriendMemoReadReq((PMSG_FRIEND_READ_MEMO_REQ *)aRecv, aIndex);

  00a9c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00a9f	53		 push	 ebx
  00aa0	50		 push	 eax
  00aa1	e8 00 00 00 00	 call	 ?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z ; FriendMemoReadReq
  00aa6	83 c4 08	 add	 esp, 8
  00aa9	5f		 pop	 edi
  00aaa	5e		 pop	 esi
  00aab	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00aac	5d		 pop	 ebp
  00aad	c3		 ret	 0
$LN150@ProtocolCo:

; 932  : 				break;
; 933  : 			case 0xC8:
; 934  : 				FriendMemoDelReq((PMSG_FRIEND_MEMO_DEL_REQ *)aRecv, aIndex);

  00aae	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00ab1	53		 push	 ebx
  00ab2	51		 push	 ecx
  00ab3	e8 00 00 00 00	 call	 ?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z ; FriendMemoDelReq
  00ab8	83 c4 08	 add	 esp, 8
  00abb	5f		 pop	 edi
  00abc	5e		 pop	 esi
  00abd	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00abe	5d		 pop	 ebp
  00abf	c3		 ret	 0
$LN149@ProtocolCo:

; 935  : 				break;
; 936  : 			case 0xC9:
; 937  : 				FriendMemoListReq(aIndex);

  00ac0	53		 push	 ebx
  00ac1	e8 00 00 00 00	 call	 ?FriendMemoListReq@@YAXH@Z ; FriendMemoListReq
  00ac6	83 c4 04	 add	 esp, 4
  00ac9	5f		 pop	 edi
  00aca	5e		 pop	 esi
  00acb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00acc	5d		 pop	 ebp
  00acd	c3		 ret	 0
$LN148@ProtocolCo:

; 938  : 				break;
; 939  : 			case 0xCA:
; 940  : 				FriendChatRoomCreateReq((PMSG_FRIEND_ROOMCREATE_REQ *)aRecv, aIndex);

  00ace	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00ad1	53		 push	 ebx
  00ad2	52		 push	 edx
  00ad3	e8 00 00 00 00	 call	 ?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z ; FriendChatRoomCreateReq
  00ad8	83 c4 08	 add	 esp, 8
  00adb	5f		 pop	 edi
  00adc	5e		 pop	 esi
  00add	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ade	5d		 pop	 ebp
  00adf	c3		 ret	 0
$LN147@ProtocolCo:

; 941  : 				break;
; 942  : 			case 0xCB:
; 943  : 				FriendRoomInvitationReq((PMSG_ROOM_INVITATION *)aRecv, aIndex);

  00ae0	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00ae3	53		 push	 ebx
  00ae4	50		 push	 eax
  00ae5	e8 00 00 00 00	 call	 ?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z ; FriendRoomInvitationReq
  00aea	83 c4 08	 add	 esp, 8
  00aed	5f		 pop	 edi
  00aee	5e		 pop	 esi
  00aef	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00af0	5d		 pop	 ebp
  00af1	c3		 ret	 0
$LN146@ProtocolCo:

; 944  : 				break;
; 945  : 				//Season 2.5 add-on
; 946  : 			case 0xD0:
; 947  : 				{
; 948  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 949  : 
; 950  : 					//LogAddC(2, "HEAD: %x, SUB: %x",protoNum, lpDef->subcode);
; 951  : 
; 952  : 					switch ( lpDef->subcode )

  00af2	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00af5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00af9	83 c1 f9	 add	 ecx, -7			; fffffff9H
  00afc	83 f9 09	 cmp	 ecx, 9
  00aff	0f 87 1a 09 00
	00		 ja	 $LN344@ProtocolCo
  00b05	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN359@ProtocolCo[ecx]
  00b0c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN370@ProtocolCo[ecx*4]
$LN141@ProtocolCo:

; 953  : 					{
; 954  : 						case 0x05: //buy
; 955  : 							//CGReqPCBangShopBuy((PMSG_REQ_PCBANG_SHOP_BUY *)aRecv, aIndex);
; 956  : 							break;
; 957  : 						case 0x06: //open
; 958  : 							//CGReqPCBangShopOpen((PMSG_REQ_PCBANG_SHOP_OPEN *)aRecv, aIndex);
; 959  : 							break;
; 960  : 						case 0x07:
; 961  : 							CGReqWerewolfMove((PMSG_REQ_WEREWOLF_MOVE *)aRecv, aIndex);

  00b13	53		 push	 ebx
  00b14	50		 push	 eax
  00b15	e8 00 00 00 00	 call	 ?CGReqWerewolfMove@@YAXPAUPMSG_REQ_WEREWOLF_MOVE@@H@Z ; CGReqWerewolfMove
  00b1a	83 c4 08	 add	 esp, 8
  00b1d	5f		 pop	 edi
  00b1e	5e		 pop	 esi
  00b1f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00b20	5d		 pop	 ebp
  00b21	c3		 ret	 0
$LN140@ProtocolCo:

; 962  : 							break;
; 963  : 						case 0x08:
; 964  : 							CGReqGatekeeperMove((PMSG_REQ_GATEKEEPER_MOVE *)aRecv, aIndex);

  00b22	53		 push	 ebx
  00b23	50		 push	 eax
  00b24	e8 00 00 00 00	 call	 ?CGReqGatekeeperMove@@YAXPAUPMSG_REQ_GATEKEEPER_MOVE@@H@Z ; CGReqGatekeeperMove
  00b29	83 c4 08	 add	 esp, 8
  00b2c	5f		 pop	 edi
  00b2d	5e		 pop	 esi
  00b2e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00b2f	5d		 pop	 ebp
  00b30	c3		 ret	 0
$LN139@ProtocolCo:

; 965  : 							break;
; 966  : 						case 0x10:
; 967  : 							CGReqXMasSetPayItem((PMSG_REQ_XMAS_PAYITEM *)aRecv, aIndex);

  00b31	53		 push	 ebx
  00b32	50		 push	 eax
  00b33	e8 00 00 00 00	 call	 ?CGReqXMasSetPayItem@@YAXPAUPMSG_REQ_XMAS_PAYITEM@@H@Z ; CGReqXMasSetPayItem
  00b38	83 c4 08	 add	 esp, 8
  00b3b	5f		 pop	 edi
  00b3c	5e		 pop	 esi
  00b3d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00b3e	5d		 pop	 ebp
  00b3f	c3		 ret	 0
$LN138@ProtocolCo:

; 968  : 							break;
; 969  : 						case 0x0A:
; 970  : 							CGReqXMasToDeviasMapMove((PMSG_REQ_XMASNPCMAP_MOVE *)aRecv, aIndex);

  00b40	53		 push	 ebx
  00b41	50		 push	 eax
  00b42	e8 00 00 00 00	 call	 ?CGReqXMasToDeviasMapMove@@YAXPAUPMSG_REQ_XMASNPCMAP_MOVE@@H@Z ; CGReqXMasToDeviasMapMove
  00b47	83 c4 08	 add	 esp, 8
  00b4a	5f		 pop	 edi
  00b4b	5e		 pop	 esi
  00b4c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00b4d	5d		 pop	 ebp
  00b4e	c3		 ret	 0
$LN137@ProtocolCo:

; 971  : 							break;
; 972  : 					}
; 973  : 				}
; 974  : 				break;
; 975  : 			case 0xD1:
; 976  : 				{
; 977  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 978  : 
; 979  : 					switch ( lpDef->subcode )

  00b4f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b52	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00b56	83 e8 00	 sub	 eax, 0
  00b59	74 16		 je	 SHORT $LN134@ProtocolCo
  00b5b	48		 dec	 eax
  00b5c	0f 85 bd 08 00
	00		 jne	 $LN344@ProtocolCo

; 983  : 							break;
; 984  : 						case 0x01:
; 985  : 							GCReqEnterKanturuBossMap((PMSG_REQ_ENTER_KANTURU_BOSS_MAP *)aRecv, aIndex);

  00b62	53		 push	 ebx
  00b63	51		 push	 ecx
  00b64	e8 00 00 00 00	 call	 ?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ; GCReqEnterKanturuBossMap
  00b69	83 c4 08	 add	 esp, 8
  00b6c	5f		 pop	 edi
  00b6d	5e		 pop	 esi
  00b6e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00b6f	5d		 pop	 ebp
  00b70	c3		 ret	 0
$LN134@ProtocolCo:

; 980  : 					{
; 981  : 						case 0x00:
; 982  : 							CGReqKanturuStateInfo((PMSG_REQ_KANTURU_STATE_INFO *)aRecv, aIndex);

  00b71	53		 push	 ebx
  00b72	51		 push	 ecx
  00b73	e8 00 00 00 00	 call	 ?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ; CGReqKanturuStateInfo
  00b78	83 c4 08	 add	 esp, 8
  00b7b	5f		 pop	 edi
  00b7c	5e		 pop	 esi
  00b7d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00b7e	5d		 pop	 ebp
  00b7f	c3		 ret	 0
$LN132@ProtocolCo:

; 986  : 							break;
; 987  : 					}
; 988  : 				}
; 989  : 				break;
; 990  : #ifdef OLDCASHSHOP
; 991  : 			case 0xF5:
; 992  : 				{
; 993  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 994  : 
; 995  : 					switch ( lpDef->subcode )
; 996  : 					{
; 997  : 						case 0x01:
; 998  : 							g_CashShop.CGCashShopOpen(lpObj, (PMSG_REQ_CASHSHOPOPEN *)aRecv);
; 999  : 							break;
; 1000 : 						case 0x03:
; 1001 : 							g_CashShop.CGCashPoint(lpObj);
; 1002 : 							break;
; 1003 : 						case 0x05:
; 1004 : 							g_CashShop.GCCashItemListSend(&gObj[aIndex], (PMSG_REQ_CASHITEMLIST *)aRecv);
; 1005 : 							break;
; 1006 : 						case 0x07:
; 1007 : 							g_CashShop.CGCashItemBuy(&gObj[aIndex], (PMSG_REQ_CASHITEM_BUY *)aRecv);
; 1008 : 							break;
; 1009 : 					}
; 1010 : 				}
; 1011 : 				break;
; 1012 : #endif
; 1013 : #ifdef GAMESHOP
; 1014 : 				case 0xD2:	//-> CashShop
; 1015 : 				{
; 1016 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1017 : 					// ----
; 1018 : #if( GAMESHOP_DEBUG == 1 )
; 1019 : 					LogAddC(2, "[DEBUG] [0x%X::0x%X] CashShop request", protoNum, lpDef->subcode);
; 1020 : #endif
; 1021 : 					// ----
; 1022 : 					switch(lpDef->subcode)

  00b80	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00b83	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00b87	49		 dec	 ecx
  00b88	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00b8b	0f 87 8e 08 00
	00		 ja	 $LN344@ProtocolCo
  00b91	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN371@ProtocolCo[ecx*4]
$LN129@ProtocolCo:

; 1023 : 					{
; 1024 : 					case 0x01:
; 1025 : 						{
; 1026 : 							gGameShop.RequestPoint(aIndex);

  00b98	53		 push	 ebx
  00b99	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00b9e	e8 00 00 00 00	 call	 ?RequestPoint@GameShop@@QAEXH@Z ; GameShop::RequestPoint
  00ba3	5f		 pop	 edi
  00ba4	5e		 pop	 esi
  00ba5	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ba6	5d		 pop	 ebp
  00ba7	c3		 ret	 0
$LN128@ProtocolCo:

; 1027 : 							//RequestCashPoint
; 1028 : 							//-> 006b3930
; 1029 : 						}
; 1030 : 						break;
; 1031 : 						// --
; 1032 : 					case 0x02:
; 1033 : 						{
; 1034 : 							gGameShop.RequestOpenShop(aIndex, (GAMESHOP_REQ_OPEN*)aRecv);

  00ba8	50		 push	 eax
  00ba9	53		 push	 ebx
  00baa	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00baf	e8 00 00 00 00	 call	 ?RequestOpenShop@GameShop@@QAEXHPAUGAMESHOP_REQ_OPEN@@@Z ; GameShop::RequestOpenShop
  00bb4	5f		 pop	 edi
  00bb5	5e		 pop	 esi
  00bb6	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00bb7	5d		 pop	 ebp
  00bb8	c3		 ret	 0
$LN127@ProtocolCo:

; 1035 : 							//RequestCashShopOpen
; 1036 : 							//-> 006b3b10
; 1037 : 						}
; 1038 : 						break;
; 1039 : 						// --
; 1040 : 					case 0x03:
; 1041 : 						{
; 1042 : 							gGameShop.RequestItemBuy(aIndex, (GAMESHOP_REQ_BUY*)aRecv);

  00bb9	50		 push	 eax
  00bba	53		 push	 ebx
  00bbb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00bc0	e8 00 00 00 00	 call	 ?RequestItemBuy@GameShop@@QAEXHPAUGAMESHOP_REQ_BUY@@@Z ; GameShop::RequestItemBuy
  00bc5	5f		 pop	 edi
  00bc6	5e		 pop	 esi
  00bc7	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00bc8	5d		 pop	 ebp
  00bc9	c3		 ret	 0
$LN125@ProtocolCo:

; 1043 : 							//RequestBuyItem
; 1044 : 							//-> 006b3d60
; 1045 : 						}
; 1046 : 						break;
; 1047 : 						// --
; 1048 : 					case 0x04:
; 1049 : 						{
; 1050 : 							gGameShop.RequestPoint(aIndex);
; 1051 : 							//RequestCashPoint
; 1052 : 							//-> 006b3d60
; 1053 : 						}
; 1054 : 						break;
; 1055 : 						// --
; 1056 : 					case 0x05:
; 1057 : 						{
; 1058 : 							gGameShop.RequestStorage(aIndex, (GAMESHOP_REQ_STORAGE*)aRecv);

  00bca	50		 push	 eax
  00bcb	53		 push	 ebx
  00bcc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00bd1	e8 00 00 00 00	 call	 ?RequestStorage@GameShop@@QAEXHPAUGAMESHOP_REQ_STORAGE@@@Z ; GameShop::RequestStorage
  00bd6	5f		 pop	 edi
  00bd7	5e		 pop	 esi
  00bd8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00bd9	5d		 pop	 ebp
  00bda	c3		 ret	 0
$LN120@ProtocolCo:

; 1059 : 							//RequestStorageList
; 1060 : 							//-> 006b39b0
; 1061 : 						}
; 1062 : 						break;
; 1063 : 						// --
; 1064 : 					case 0x07:
; 1065 : 						{
; 1066 : 							//RequestGiftCash
; 1067 : 							//-> 006b4350
; 1068 : 						}
; 1069 : 						break;
; 1070 : 						// --
; 1071 : 					case 0x08:
; 1072 : 						{
; 1073 : 							//RequestItemBuyConfirm
; 1074 : 							//-> 006b4450
; 1075 : 						}
; 1076 : 						break;
; 1077 : 						// --
; 1078 : 					case 0x09:
; 1079 : 						{
; 1080 : 							//RequestItemLeftCount
; 1081 : 							//-> 006b44b0
; 1082 : 						}
; 1083 : 						break;
; 1084 : 						// --
; 1085 : 					case 0xA:
; 1086 : 						{
; 1087 : 							//RequestStorageItemThrow
; 1088 : 							//-> 006b4510
; 1089 : 						}
; 1090 : 						break;
; 1091 : 						// --
; 1092 : 					case 0xB:
; 1093 : 						{
; 1094 : 							gGameShop.RequestStorageItemUse(aIndex, (GAMESHOP_REQ_STORAGEITEMUSE*)aRecv);

  00bdb	50		 push	 eax
  00bdc	53		 push	 ebx
  00bdd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGameShop@@3VGameShop@@A ; gGameShop
  00be2	e8 00 00 00 00	 call	 ?RequestStorageItemUse@GameShop@@QAEXHPAUGAMESHOP_REQ_STORAGEITEMUSE@@@Z ; GameShop::RequestStorageItemUse
  00be7	5f		 pop	 edi
  00be8	5e		 pop	 esi
  00be9	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00bea	5d		 pop	 ebp
  00beb	c3		 ret	 0
$LN118@ProtocolCo:

; 1095 : 							//RequestStorageItemUse
; 1096 : 							//-> 006b4600
; 1097 : 						}
; 1098 : 						break;
; 1099 : 						// --
; 1100 : 					case 0x13:
; 1101 : 						{
; 1102 : 							//RequestEventProductList
; 1103 : 							//-> 006b4c20
; 1104 : 
; 1105 : 						}
; 1106 : 						break;
; 1107 : 					}
; 1108 : 				}
; 1109 : 				break;
; 1110 : #endif
; 1111 : 				//illusion temple
; 1112 : 			case 0xBF:
; 1113 : 				{
; 1114 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1115 : 
; 1116 : 					switch ( lpDef->subcode )

  00bec	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00bef	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00bf3	83 f9 51	 cmp	 ecx, 81			; 00000051H
  00bf6	0f 87 23 08 00
	00		 ja	 $LN344@ProtocolCo
  00bfc	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN360@ProtocolCo[ecx]
  00c03	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN372@ProtocolCo[edx*4]
$LN115@ProtocolCo:

; 1117 : 					{
; 1118 : 						case 0x00:
; 1119 : 							CGReqEnterIllusionTemple((PMSG_ANS_ILLUSIONTEMPLE_ENTER *)aRecv, aIndex);

  00c0a	53		 push	 ebx
  00c0b	50		 push	 eax
  00c0c	e8 00 00 00 00	 call	 ?CGReqEnterIllusionTemple@@YAXPAUPMSG_ANS_ILLUSIONTEMPLE_ENTER@@H@Z ; CGReqEnterIllusionTemple
  00c11	83 c4 08	 add	 esp, 8
  00c14	5f		 pop	 edi
  00c15	5e		 pop	 esi
  00c16	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c17	5d		 pop	 ebp
  00c18	c3		 ret	 0
$LN114@ProtocolCo:

; 1120 : 							break;
; 1121 : 						case 0x02:
; 1122 : 							CGReqUseIllusionTempleKillCntSkill((PMSG_USE_ILLUSIONTEMPLE_KILLCOUNT_SKILL *)aRecv, aIndex);

  00c19	53		 push	 ebx
  00c1a	50		 push	 eax
  00c1b	e8 00 00 00 00	 call	 ?CGReqUseIllusionTempleKillCntSkill@@YAXPAUPMSG_USE_ILLUSIONTEMPLE_KILLCOUNT_SKILL@@H@Z ; CGReqUseIllusionTempleKillCntSkill
  00c20	83 c4 08	 add	 esp, 8
  00c23	5f		 pop	 edi
  00c24	5e		 pop	 esi
  00c25	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c26	5d		 pop	 ebp
  00c27	c3		 ret	 0
$LN113@ProtocolCo:

; 1123 : 							break;
; 1124 : 						case 0x05:
; 1125 : 							CGReqIllusionTempleDropReward((PMSG_ILLUSIONTEMPLE_DROP_REWARD *)aRecv, aIndex);

  00c28	53		 push	 ebx
  00c29	50		 push	 eax
  00c2a	e8 00 00 00 00	 call	 ?CGReqIllusionTempleDropReward@@YAXPAUPMSG_ILLUSIONTEMPLE_DROP_REWARD@@H@Z ; CGReqIllusionTempleDropReward
  00c2f	83 c4 08	 add	 esp, 8
  00c32	5f		 pop	 edi
  00c33	5e		 pop	 esi
  00c34	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c35	5d		 pop	 ebp
  00c36	c3		 ret	 0
$LN112@ProtocolCo:

; 1126 : 							break;
; 1127 : 						case 0x0B:
; 1128 : 							CGReqRegLuckyCoinItemCount((PMSG_REQ_REG_LUCKYCOIN *)aRecv, aIndex);

  00c37	53		 push	 ebx
  00c38	50		 push	 eax
  00c39	e8 00 00 00 00	 call	 ?CGReqRegLuckyCoinItemCount@@YAXPAUPMSG_REQ_REG_LUCKYCOIN@@H@Z ; CGReqRegLuckyCoinItemCount
  00c3e	83 c4 08	 add	 esp, 8
  00c41	5f		 pop	 edi
  00c42	5e		 pop	 esi
  00c43	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c44	5d		 pop	 ebp
  00c45	c3		 ret	 0
$LN111@ProtocolCo:

; 1129 : 							break;
; 1130 : 						case 0x0C:
; 1131 : 							CGSearchLuckyCoinItem((PMSG_REQ_SEARCH_LUCKY_COIN *)aRecv, aIndex);

  00c46	53		 push	 ebx
  00c47	50		 push	 eax
  00c48	e8 00 00 00 00	 call	 ?CGSearchLuckyCoinItem@@YAXPAUPMSG_REQ_SEARCH_LUCKY_COIN@@H@Z ; CGSearchLuckyCoinItem
  00c4d	83 c4 08	 add	 esp, 8
  00c50	5f		 pop	 edi
  00c51	5e		 pop	 esi
  00c52	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c53	5d		 pop	 ebp
  00c54	c3		 ret	 0
$LN110@ProtocolCo:

; 1132 : 							break;
; 1133 : 						case 0x0D:
; 1134 : 							CGReqLuckyCoinTrade((PMSG_REQ_TRADE_LUCKYCOIN *)aRecv, aIndex);

  00c55	53		 push	 ebx
  00c56	50		 push	 eax
  00c57	e8 00 00 00 00	 call	 ?CGReqLuckyCoinTrade@@YAXPAUPMSG_REQ_TRADE_LUCKYCOIN@@H@Z ; CGReqLuckyCoinTrade
  00c5c	83 c4 08	 add	 esp, 8
  00c5f	5f		 pop	 edi
  00c60	5e		 pop	 esi
  00c61	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c62	5d		 pop	 ebp
  00c63	c3		 ret	 0
$LN109@ProtocolCo:

; 1135 : 							break;
; 1136 : 							//Season 5.3
; 1137 : 						case 0x17:
; 1138 : 							CGMoveRorenMarket(aIndex);

  00c64	53		 push	 ebx
  00c65	e8 00 00 00 00	 call	 ?CGMoveRorenMarket@@YAXH@Z ; CGMoveRorenMarket
  00c6a	83 c4 04	 add	 esp, 4
  00c6d	5f		 pop	 edi
  00c6e	5e		 pop	 esi
  00c6f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c70	5d		 pop	 ebp
  00c71	c3		 ret	 0
$LN108@ProtocolCo:

; 1139 : 							break;
; 1140 : 						case 0x0E: //Season 5 DoppelGanger
; 1141 : 							g_DoppelGanger.EnterEvent(&gObj[aIndex]);

  00c72	56		 push	 esi
  00c73	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DoppelGanger@@3VCDoppelGanger@@A ; g_DoppelGanger
  00c78	e8 00 00 00 00	 call	 ?EnterEvent@CDoppelGanger@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoppelGanger::EnterEvent
  00c7d	5f		 pop	 edi
  00c7e	5e		 pop	 esi
  00c7f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c80	5d		 pop	 ebp
  00c81	c3		 ret	 0
$LN107@ProtocolCo:

; 1142 : 							break;
; 1143 : 						case 0x20:	//1.01.03
; 1144 : 							CGInventoryEquipment((_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM *)aRecv, aIndex);

  00c82	53		 push	 ebx
  00c83	50		 push	 eax
  00c84	e8 00 00 00 00	 call	 ?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ; CGInventoryEquipment
  00c89	83 c4 08	 add	 esp, 8
  00c8c	5f		 pop	 edi
  00c8d	5e		 pop	 esi
  00c8e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00c8f	5d		 pop	 ebp
  00c90	c3		 ret	 0
$LN106@ProtocolCo:

; 1145 : 							break;
; 1146 : #ifdef MUHELPER
; 1147 : 						case 0x51:
; 1148 : 							g_MUHelper.Manager(aIndex, (MUHELPER_REQ_ACTION*)aRecv);

  00c91	50		 push	 eax
  00c92	53		 push	 ebx
  00c93	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MUHelper@@3VMUHelper@@A ; g_MUHelper
  00c98	e8 00 00 00 00	 call	 ?Manager@MUHelper@@QAEXHPAUMUHELPER_REQ_ACTION@@@Z ; MUHelper::Manager
  00c9d	5f		 pop	 edi
  00c9e	5e		 pop	 esi
  00c9f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ca0	5d		 pop	 ebp
  00ca1	c3		 ret	 0
$LN99@ProtocolCo:

; 1149 : 							break;
; 1150 : #endif
; 1151 : 					}
; 1152 : 				}
; 1153 : 				break;
; 1154 : 			case 0xF6:	//Season 5 Quest
; 1155 : 				{
; 1156 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1157 : 					switch(lpDef->subcode)
; 1158 : 					{
; 1159 : 						case 0x1B:
; 1160 : #ifdef SEASON5_QUEST
; 1161 : 							S5Quest.Info(aIndex);//Click T
; 1162 : #endif
; 1163 : 							break;
; 1164 : 						case 0x30:
; 1165 : #ifdef SEASON5_QUEST
; 1166 : 							S5Quest.NPCQuest(aIndex);//CLick NPC Quest
; 1167 : #endif
; 1168 : 							break;
; 1169 : 						case 0x31:
; 1170 : #ifdef SEASON5_QUEST
; 1171 : 							gObjElfSupportBuff(aIndex);
; 1172 : #endif
; 1173 : 							break;
; 1174 : 					}
; 1175 : 				//	if(aRecv[3] == 0x30)
; 1176 : 				//	{	
; 1177 : 				//		//Request Available Quest List
; 1178 : 				//		g_SQuestSys.SendListNpc(aIndex);
; 1179 : 				//	}
; 1180 : 
; 1181 : 				//	if(aRecv[3] == 0x0A)
; 1182 : 				//	{		
; 1183 : 				//		g_SQuestSys.Accept(aIndex,aRecv);
; 1184 : 				//			//Start Quest
; 1185 : 				//			//g_MUQuest.QuestAccept(aIndex,aRecv);
; 1186 : 				//	}
; 1187 : 				//	if(aRecv[3] == 0x0B)
; 1188 : 				//	{	
; 1189 : 				//		g_SQuestSys.Continue(aIndex,aRecv);
; 1190 : 				//			//Quest Continue or start
; 1191 : 				//		//g_MUQuest.QuestOnGoing(aIndex,aRecv);	
; 1192 : 				//	}
; 1193 : 				//	if(aRecv[3] == 0x1B)
; 1194 : 				//	{
; 1195 : 				//		int QuestIndex = (aRecv[4] + aRecv[5] * 256);
; 1196 : 				//		g_SQuestSys.SendRequirments(aIndex,aRecv,true,QuestIndex);
; 1197 : 				//	}
; 1198 : 				//	if(aRecv[3] == 0x0D)
; 1199 : 				//	{
; 1200 : 				//		g_SQuestSys.Reward(aIndex,aRecv);
; 1201 : 				//	}
; 1202 : 				//	if(aRecv[3] == 0x31)
; 1203 : 				//	{
; 1204 : 				//		if ( lpObj->Level > gMaxElfSoldierBuffLevel )
; 1205 : 				//		{
; 1206 : 				//			GCServerCmd(lpObj->m_Index, 0x0D, 0, 0);
; 1207 : 				//			break;
; 1208 : 				//		}
; 1209 : 				//		BuffEffectC.EnableBuff(lpObj->m_Index, 3, GetTickCount(), (lpObj->Level / 5 +50), (lpObj->Level / 3 +45), 0);
; 1210 : 				//	}
; 1211 : 				//	LogAdd("NEW PROTOCOL F6: %x %x %x %x",aRecv[3],aRecv[4],aRecv[5],aRecv[6]);
; 1212 : 				}
; 1213 : 				break;
; 1214 : 			case 0xF7:	//Season 5 ImperialFort
; 1215 : 				{
; 1216 : #ifdef IMPERIAL_CONFLICT_OLD
; 1217 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1218 : 
; 1219 : 					switch ( lpDef->subcode )

  00ca2	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00ca5	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00ca9	48		 dec	 eax
  00caa	0f 85 6f 07 00
	00		 jne	 $LN344@ProtocolCo

; 1220 : 					{
; 1221 : 						case 0x01:
; 1222 : 							//PMSG_REQ_ENTERZONE * lpMsg = (PMSG_REQ_ENTERZONE*)aRecv;
; 1223 : 							//LogAddC(3, "[DEBUG] %d", lpMsg->btType);
; 1224 : 
; 1225 : 							g_Imperial.EnterEvent(aIndex);

  00cb0	53		 push	 ebx
  00cb1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Imperial@@3VCImperial@@A ; g_Imperial
  00cb6	e8 00 00 00 00	 call	 ?EnterEvent@CImperial@@QAE_NF@Z ; CImperial::EnterEvent
  00cbb	5f		 pop	 edi
  00cbc	5e		 pop	 esi
  00cbd	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00cbe	5d		 pop	 ebp
  00cbf	c3		 ret	 0
$LN95@ProtocolCo:

; 1226 : #endif
; 1227 : #ifdef IMPERIAL_CONFLICT_NEW
; 1228 : 							g_ImperialGuardian.CGEnterPortal(aIndex, 0);
; 1229 : #else
; 1230 : 							break;
; 1231 : 					}
; 1232 : #endif
; 1233 : 				}
; 1234 : 				break;
; 1235 : 			case 0xF8:	//-> Gens System
; 1236 : 				{
; 1237 : 					if(gGENS)

  00cc0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGENS@@3HA, 0 ; gGENS
  00cc7	0f 84 52 07 00
	00		 je	 $LN344@ProtocolCo

; 1238 : 					{
; 1239 : 						PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1240 : 						// ----
; 1241 : 						//LogAddC(2, "[DEBUG] [0x%X::0x%X] Gens System request", protoNum, lpDef->subcode);
; 1242 : 						// ----
; 1243 : 						switch(lpDef->subcode)

  00ccd	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00cd0	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00cd4	49		 dec	 ecx
  00cd5	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00cd8	0f 87 41 07 00
	00		 ja	 $LN344@ProtocolCo
  00cde	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN361@ProtocolCo[ecx]
  00ce5	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN373@ProtocolCo[ecx*4]
$LN91@ProtocolCo:

; 1244 : 						{
; 1245 : 						case 0x01:
; 1246 : 							{
; 1247 : 								CGReqRegGensMember((PMSG_REQ_REG_GENS_MEMBER*)aRecv, aIndex);

  00cec	53		 push	 ebx
  00ced	50		 push	 eax
  00cee	e8 00 00 00 00	 call	 ?CGReqRegGensMember@@YAXPAUPMSG_REQ_REG_GENS_MEMBER@@H@Z ; CGReqRegGensMember
  00cf3	83 c4 08	 add	 esp, 8
  00cf6	5f		 pop	 edi
  00cf7	5e		 pop	 esi
  00cf8	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00cf9	5d		 pop	 ebp
  00cfa	c3		 ret	 0
$LN90@ProtocolCo:

; 1248 : 							}
; 1249 : 							break;
; 1250 : 							// --
; 1251 : 						case 0x03:
; 1252 : 							{
; 1253 : 								CGReqSecedeGensMember((PMSG_REQ_SEGEDE_GENS_MEMBER*)aRecv, aIndex);

  00cfb	53		 push	 ebx
  00cfc	50		 push	 eax
  00cfd	e8 00 00 00 00	 call	 ?CGReqSecedeGensMember@@YAXPAUPMSG_REQ_SEGEDE_GENS_MEMBER@@H@Z ; CGReqSecedeGensMember
  00d02	83 c4 08	 add	 esp, 8
  00d05	5f		 pop	 edi
  00d06	5e		 pop	 esi
  00d07	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d08	5d		 pop	 ebp
  00d09	c3		 ret	 0
$LN89@ProtocolCo:

; 1254 : 							}
; 1255 : 							break;
; 1256 : 							// --
; 1257 : 						case 0x09:
; 1258 : 							{
; 1259 : 								CGReqGensReward((PMSG_GENS_REWARD_CODE*)aRecv, aIndex);

  00d0a	53		 push	 ebx
  00d0b	50		 push	 eax
  00d0c	e8 00 00 00 00	 call	 ?CGReqGensReward@@YAXPAUPMSG_GENS_REWARD_CODE@@H@Z ; CGReqGensReward
  00d11	83 c4 08	 add	 esp, 8
  00d14	5f		 pop	 edi
  00d15	5e		 pop	 esi
  00d16	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d17	5d		 pop	 ebp
  00d18	c3		 ret	 0
$LN88@ProtocolCo:

; 1260 : 							}
; 1261 : 							break;
; 1262 : 							// --
; 1263 : 						case 0x0B:
; 1264 : 							{
; 1265 : 								CGReqGensMemberInfo((PMSG_REQ_GENS_INFO*)aRecv, aIndex);

  00d19	53		 push	 ebx
  00d1a	50		 push	 eax
  00d1b	e8 00 00 00 00	 call	 ?CGReqGensMemberInfo@@YAXPAUPMSG_REQ_GENS_INFO@@H@Z ; CGReqGensMemberInfo
  00d20	83 c4 08	 add	 esp, 8
  00d23	5f		 pop	 edi
  00d24	5e		 pop	 esi
  00d25	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d26	5d		 pop	 ebp
  00d27	c3		 ret	 0
$LN87@ProtocolCo:

; 1266 : 							}
; 1267 : 							break;
; 1268 : 						}
; 1269 : 					}
; 1270 : 				}
; 1271 : 				break;
; 1272 : 			case 0x4A:
; 1273 : 				{
; 1274 : 					GCMonkMagicAttack((PMSG_MAGICATTACK *)aRecv, aIndex);

  00d28	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00d2b	53		 push	 ebx
  00d2c	52		 push	 edx
  00d2d	e8 00 00 00 00	 call	 ?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; GCMonkMagicAttack
  00d32	83 c4 08	 add	 esp, 8
  00d35	5f		 pop	 edi
  00d36	5e		 pop	 esi
  00d37	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d38	5d		 pop	 ebp
  00d39	c3		 ret	 0
$LN86@ProtocolCo:

; 1275 : 				}
; 1276 : 				break;
; 1277 : 			case 0x4B:
; 1278 : 				{
; 1279 : 					GCMonkDarkSideTargetSelect((PMSG_MONK_DARKSIDE_RECV *)aRecv, aIndex);

  00d3a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00d3d	53		 push	 ebx
  00d3e	50		 push	 eax
  00d3f	e8 00 00 00 00	 call	 ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect
  00d44	83 c4 08	 add	 esp, 8
  00d47	5f		 pop	 edi
  00d48	5e		 pop	 esi
  00d49	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d4a	5d		 pop	 ebp
  00d4b	c3		 ret	 0
$LN85@ProtocolCo:

; 1280 : 				}
; 1281 : 				break;
; 1282 : #ifdef MUHELPER
; 1283 : 			case 0xAE:
; 1284 : 				{
; 1285 : 					g_MUHelper.SaveMacro(aIndex, (MUHELPER_MACRO_CLIENT*)aRecv);

  00d4c	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00d4f	51		 push	 ecx
  00d50	53		 push	 ebx
  00d51	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MUHelper@@3VMUHelper@@A ; g_MUHelper
  00d56	e8 00 00 00 00	 call	 ?SaveMacro@MUHelper@@QAEXHPAUMUHELPER_MACRO_CLIENT@@@Z ; MUHelper::SaveMacro
  00d5b	5f		 pop	 edi
  00d5c	5e		 pop	 esi
  00d5d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d5e	5d		 pop	 ebp
  00d5f	c3		 ret	 0
$LN84@ProtocolCo:

; 1286 : 				}
; 1287 : 				break;
; 1288 : #endif
; 1289 : 			case 0xFB:
; 1290 : 				{
; 1291 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1292 : 
; 1293 : 					switch ( lpDef->subcode )

  00d60	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00d63	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00d67	49		 dec	 ecx
  00d68	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  00d6e	0f 87 ab 06 00
	00		 ja	 $LN344@ProtocolCo
  00d74	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN362@ProtocolCo[ecx]
  00d7b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN374@ProtocolCo[edx*4]
$LN81@ProtocolCo:

; 1294 : 					{
; 1295 : 						case 0x01:
; 1296 : 							if(g_ZtLicense.user.Rage)

  00d82	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  00d89	0f 84 90 06 00
	00		 je	 $LN344@ProtocolCo

; 1297 : 							{
; 1298 : 								gSystemOfRage.DataRecv((ClickSend *)aRecv, aIndex);

  00d8f	53		 push	 ebx
  00d90	50		 push	 eax
  00d91	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00d96	e8 00 00 00 00	 call	 ?DataRecv@cSystemOfRage@@QAEXPAUClickSend@@H@Z ; cSystemOfRage::DataRecv
  00d9b	5f		 pop	 edi
  00d9c	5e		 pop	 esi
  00d9d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00d9e	5d		 pop	 ebp
  00d9f	c3		 ret	 0
$LN79@ProtocolCo:

; 1299 : 							}
; 1300 : 							break;
; 1301 : 						case 0x04:
; 1302 : 							if(g_ZtLicense.user.Rage)

  00da0	80 3d cd 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+205, 0
  00da7	0f 84 72 06 00
	00		 je	 $LN344@ProtocolCo

; 1303 : 							{
; 1304 : 								gSystemOfRage.RecvActiveSkill((sRageTabSend *)aRecv, aIndex);

  00dad	53		 push	 ebx
  00dae	50		 push	 eax
  00daf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00db4	e8 00 00 00 00	 call	 ?RecvActiveSkill@cSystemOfRage@@QAEXPAUsRageTabSend@@H@Z ; cSystemOfRage::RecvActiveSkill
  00db9	5f		 pop	 edi
  00dba	5e		 pop	 esi
  00dbb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00dbc	5d		 pop	 ebp
  00dbd	c3		 ret	 0
$LN77@ProtocolCo:

; 1305 : 							}
; 1306 : 							break;
; 1307 : #if(DONATE_SHOP==TRUE)
; 1308 : 						case 0x08:
; 1309 : 							{
; 1310 : 								NewShopRecv((CG_NEW_CASH_SHOP*)aRecv, aIndex);

  00dbe	53		 push	 ebx
  00dbf	50		 push	 eax
  00dc0	e8 00 00 00 00	 call	 ?NewShopRecv@@YAXPAUCG_NEW_CASH_SHOP@@H@Z ; NewShopRecv
  00dc5	83 c4 08	 add	 esp, 8
  00dc8	5f		 pop	 edi
  00dc9	5e		 pop	 esi
  00dca	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00dcb	5d		 pop	 ebp
  00dcc	c3		 ret	 0
$LN76@ProtocolCo:

; 1311 : 							}
; 1312 : 							break;
; 1313 : #endif
; 1314 : #if(CUSTOM_PREMIUM_SYSTEM==TRUE)
; 1315 : 						case 0x09:
; 1316 : 							{
; 1317 : 								//NewShopRecv((CG_NEW_CASH_SHOP*)aRecv, aIndex);
; 1318 : 								g_PremiumSystemZt.CG_RecvBuy(aIndex, (CG_PREMIUM_BUY*) aRecv);

  00dcd	50		 push	 eax
  00dce	53		 push	 ebx
  00dcf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PremiumSystemZt@@3VPremiumSystemZt@@A ; g_PremiumSystemZt
  00dd4	e8 00 00 00 00	 call	 ?CG_RecvBuy@PremiumSystemZt@@QAEXHPAUCG_PREMIUM_BUY@@@Z ; PremiumSystemZt::CG_RecvBuy
  00dd9	5f		 pop	 edi
  00dda	5e		 pop	 esi
  00ddb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ddc	5d		 pop	 ebp
  00ddd	c3		 ret	 0
$LN75@ProtocolCo:

; 1319 : 							}
; 1320 : 							break;
; 1321 : 						case 0x0A:
; 1322 : 							{
; 1323 : 								g_PremiumSystemZt.GC_Send(aIndex, (CG_SEND_OPEND_WIN*) aRecv);

  00dde	50		 push	 eax
  00ddf	53		 push	 ebx
  00de0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PremiumSystemZt@@3VPremiumSystemZt@@A ; g_PremiumSystemZt
  00de5	e8 00 00 00 00	 call	 ?GC_Send@PremiumSystemZt@@QAEXHPAUCG_SEND_OPEND_WIN@@@Z ; PremiumSystemZt::GC_Send
  00dea	5f		 pop	 edi
  00deb	5e		 pop	 esi
  00dec	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ded	5d		 pop	 ebp
  00dee	c3		 ret	 0
$LN74@ProtocolCo:

; 1324 : 							}
; 1325 : 							break;
; 1326 : #endif
; 1327 : 						case 11:
; 1328 : 							OffExp.OffExpStart(aIndex,0);	

  00def	6a 00		 push	 0
  00df1	53		 push	 ebx
  00df2	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  00df7	e8 00 00 00 00	 call	 ?OffExpStart@cOffExp@@QAEXHH@Z ; cOffExp::OffExpStart
  00dfc	5f		 pop	 edi
  00dfd	5e		 pop	 esi
  00dfe	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00dff	5d		 pop	 ebp
  00e00	c3		 ret	 0
$LN73@ProtocolCo:

; 1329 : 							break;
; 1330 : #if(_RECONNECT_)
; 1331 : 						case 12:
; 1332 : 							g_ConnectZt.SendLogin(aIndex, (CONNECTZT_LOGIN*)aRecv);

  00e01	50		 push	 eax
  00e02	53		 push	 ebx
  00e03	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00e08	e8 00 00 00 00	 call	 ?SendLogin@ConnectZt@@QAEXHPAUCONNECTZT_LOGIN@@@Z ; ConnectZt::SendLogin
  00e0d	5f		 pop	 edi
  00e0e	5e		 pop	 esi
  00e0f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e10	5d		 pop	 ebp
  00e11	c3		 ret	 0
$LN72@ProtocolCo:

; 1333 : 							break;
; 1334 : 						case 13:
; 1335 : 							g_ConnectZt.RecvClose(aIndex);

  00e12	53		 push	 ebx
  00e13	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConnectZt@@3VConnectZt@@A ; g_ConnectZt
  00e18	e8 00 00 00 00	 call	 ?RecvClose@ConnectZt@@QAEXH@Z ; ConnectZt::RecvClose
  00e1d	5f		 pop	 edi
  00e1e	5e		 pop	 esi
  00e1f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e20	5d		 pop	 ebp
  00e21	c3		 ret	 0
$LN71@ProtocolCo:

; 1336 : 							break;
; 1337 : #endif
; 1338 : 						case 15:
; 1339 : 							{
; 1340 : 								if(g_ZtLicense.user.WinQuest) gWinQuestSystem.RecvPacket(aIndex, (CGSendQuestResult*)aRecv);

  00e22	80 3d ce 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+206, 0
  00e29	0f 84 f0 05 00
	00		 je	 $LN344@ProtocolCo
  00e2f	50		 push	 eax
  00e30	53		 push	 ebx
  00e31	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWinQuestSystem@@3VcWinQuestSystem@@A ; gWinQuestSystem
  00e36	e8 00 00 00 00	 call	 ?RecvPacket@cWinQuestSystem@@QAEXHPAUCGSendQuestResult@@@Z ; cWinQuestSystem::RecvPacket
  00e3b	5f		 pop	 edi
  00e3c	5e		 pop	 esi
  00e3d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e3e	5d		 pop	 ebp
  00e3f	c3		 ret	 0
$LN69@ProtocolCo:

; 1341 : 							}
; 1342 : 							break;
; 1343 : 						case 16:
; 1344 : 							gAutoParty.SendPartyList(aIndex);

  00e40	53		 push	 ebx
  00e41	b9 00 00 00 00	 mov	 ecx, OFFSET ?gAutoParty@@3VcAutoParty@@A ; gAutoParty
  00e46	e8 00 00 00 00	 call	 ?SendPartyList@cAutoParty@@QAEXH@Z ; cAutoParty::SendPartyList
  00e4b	5f		 pop	 edi
  00e4c	5e		 pop	 esi
  00e4d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e4e	5d		 pop	 ebp
  00e4f	c3		 ret	 0
$LN68@ProtocolCo:

; 1345 : 							break;
; 1346 : 						case 20:
; 1347 : 							{
; 1348 : #ifdef PRIVATE_MODULE
; 1349 : 								if(g_ZtLicense.user.MonsterQuest)

  00e50	80 3d d0 00 00
	00 00		 cmp	 BYTE PTR ?g_ZtLicense@@3VCZtLicense@@A+208, 0
  00e57	0f 84 c2 05 00
	00		 je	 $LN344@ProtocolCo

; 1350 : 								{
; 1351 : 									gMonsterQuest.MissionReward(aIndex);

  00e5d	53		 push	 ebx
  00e5e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMonsterQuest@@3VMonsterQuest@@A ; gMonsterQuest
  00e63	e8 00 00 00 00	 call	 ?MissionReward@MonsterQuest@@QAEXH@Z ; MonsterQuest::MissionReward
  00e68	5f		 pop	 edi
  00e69	5e		 pop	 esi
  00e6a	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e6b	5d		 pop	 ebp
  00e6c	c3		 ret	 0
$LN66@ProtocolCo:

; 1352 : 								}
; 1353 : #endif
; 1354 : 							}
; 1355 : 							break;
; 1356 : #if(CUSTOM_PARTY_SEARCH==TRUE)
; 1357 : 						case 0x1B:
; 1358 : 							{
; 1359 : 								g_PartySearch.CG_RecvInfo(aIndex,(CG_AutoPartyInfo*) aRecv);

  00e6d	50		 push	 eax
  00e6e	53		 push	 ebx
  00e6f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PartySearch@@3VPartySearch@@A ; g_PartySearch
  00e74	e8 00 00 00 00	 call	 ?CG_RecvInfo@PartySearch@@QAEXHPAUCG_AutoPartyInfo@@@Z ; PartySearch::CG_RecvInfo
  00e79	5f		 pop	 edi
  00e7a	5e		 pop	 esi
  00e7b	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e7c	5d		 pop	 ebp
  00e7d	c3		 ret	 0
$LN65@ProtocolCo:

; 1360 : 							}
; 1361 : 							break;
; 1362 : 						case 0x1C:
; 1363 : 							{
; 1364 : 								g_PartySearch.CG_RecvPartyUser(aIndex,(CG_PartyRecv*) aRecv);

  00e7e	50		 push	 eax
  00e7f	53		 push	 ebx
  00e80	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PartySearch@@3VPartySearch@@A ; g_PartySearch
  00e85	e8 00 00 00 00	 call	 ?CG_RecvPartyUser@PartySearch@@QAEXHPAUCG_PartyRecv@@@Z ; PartySearch::CG_RecvPartyUser
  00e8a	5f		 pop	 edi
  00e8b	5e		 pop	 esi
  00e8c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e8d	5d		 pop	 ebp
  00e8e	c3		 ret	 0
$LN64@ProtocolCo:

; 1365 : 							}
; 1366 : 							break;
; 1367 : 						case 0x1D:
; 1368 : 							{
; 1369 : 								g_PartySearch.Search(aIndex);

  00e8f	53		 push	 ebx
  00e90	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PartySearch@@3VPartySearch@@A ; g_PartySearch
  00e95	e8 00 00 00 00	 call	 ?Search@PartySearch@@QAEXH@Z ; PartySearch::Search
  00e9a	5f		 pop	 edi
  00e9b	5e		 pop	 esi
  00e9c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00e9d	5d		 pop	 ebp
  00e9e	c3		 ret	 0
$LN63@ProtocolCo:

; 1370 : 							}
; 1371 : 							break;
; 1372 : #endif
; 1373 : 						case 0x0E:
; 1374 : 							{
; 1375 : //#if(CUSTOM_PERSONAL_SHOP==TRUE)
; 1376 : 								if(g_PersonalShopZt.Enable)

  00e9f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_PersonalShopZt@@3VPersonalShopZt@@A, 0
  00ea6	0f 84 73 05 00
	00		 je	 $LN344@ProtocolCo

; 1377 : 								{
; 1378 : 									g_PersonalShopZt.Search(aIndex, (CG_PersonalPage*) aRecv);

  00eac	50		 push	 eax
  00ead	53		 push	 ebx
  00eae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PersonalShopZt@@3VPersonalShopZt@@A ; g_PersonalShopZt
  00eb3	e8 00 00 00 00	 call	 ?Search@PersonalShopZt@@QAEXHPAUCG_PersonalPage@@@Z ; PersonalShopZt::Search
  00eb8	5f		 pop	 edi
  00eb9	5e		 pop	 esi
  00eba	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ebb	5d		 pop	 ebp
  00ebc	c3		 ret	 0
$LN61@ProtocolCo:

; 1379 : 								}
; 1380 : //#endif
; 1381 : 							}
; 1382 : 							break;
; 1383 : 						case 0x20:
; 1384 : 							{
; 1385 : #if(CUSTOM_NPC_BUFFER==TRUE)
; 1386 : 								g_BufferSystem.CG_ResultRecv(aIndex, (CG_BuffNpcResult*) aRecv);

  00ebd	50		 push	 eax
  00ebe	53		 push	 ebx
  00ebf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BufferSystem@@3VBufferSystem@@A ; g_BufferSystem
  00ec4	e8 00 00 00 00	 call	 ?CG_ResultRecv@BufferSystem@@QAEXHPAUCG_BuffNpcResult@@@Z ; BufferSystem::CG_ResultRecv
  00ec9	5f		 pop	 edi
  00eca	5e		 pop	 esi
  00ecb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ecc	5d		 pop	 ebp
  00ecd	c3		 ret	 0
$LN60@ProtocolCo:

; 1387 : #endif
; 1388 : 							}
; 1389 : 							break;
; 1390 : #if(CUSTOM_SMITHY == TRUE)
; 1391 : 						case 0x21:
; 1392 : 							g_Smithy.CGCreateItem((CG_SmithyCreateItem*) aRecv, aIndex);

  00ece	53		 push	 ebx
  00ecf	50		 push	 eax
  00ed0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Smithy@@3VCSmithy@@A ; g_Smithy
  00ed5	e8 00 00 00 00	 call	 ?CGCreateItem@CSmithy@@QAEXPAUCG_SmithyCreateItem@@H@Z ; CSmithy::CGCreateItem
  00eda	5f		 pop	 edi
  00edb	5e		 pop	 esi
  00edc	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00edd	5d		 pop	 ebp
  00ede	c3		 ret	 0
$LN59@ProtocolCo:

; 1393 : 							break;
; 1394 : #endif
; 1395 : 						case 0x3D:
; 1396 : 							{
; 1397 : #if(OFFLINE_MODE==TRUE)
; 1398 : 								g_OfflineMode.Start((CG_OFFMODE_RESULT*)aRecv, aIndex);

  00edf	53		 push	 ebx
  00ee0	50		 push	 eax
  00ee1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OfflineMode@@3VOfflineMode@@A ; g_OfflineMode
  00ee6	e8 00 00 00 00	 call	 ?Start@OfflineMode@@QAEXPAUCG_OFFMODE_RESULT@@H@Z ; OfflineMode::Start
  00eeb	5f		 pop	 edi
  00eec	5e		 pop	 esi
  00eed	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00eee	5d		 pop	 ebp
  00eef	c3		 ret	 0
$LN58@ProtocolCo:

; 1399 : #endif
; 1400 : 							}
; 1401 : 							break;
; 1402 : #if(CUSTOM_MARRIAGE)
; 1403 : 						case 0x3E:
; 1404 : 							g_Marriage.IndexClose(aIndex);

  00ef0	53		 push	 ebx
  00ef1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Marriage@@3VCMarriage@@A ; g_Marriage
  00ef6	e8 00 00 00 00	 call	 ?IndexClose@CMarriage@@QAEXH@Z ; CMarriage::IndexClose
  00efb	5f		 pop	 edi
  00efc	5e		 pop	 esi
  00efd	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00efe	5d		 pop	 ebp
  00eff	c3		 ret	 0
$LN57@ProtocolCo:

; 1405 : 							break;
; 1406 : 						case 0x3F:
; 1407 : 							g_Marriage.CGClickOK(aIndex);

  00f00	53		 push	 ebx
  00f01	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Marriage@@3VCMarriage@@A ; g_Marriage
  00f06	e8 00 00 00 00	 call	 ?CGClickOK@CMarriage@@QAEXH@Z ; CMarriage::CGClickOK
  00f0b	5f		 pop	 edi
  00f0c	5e		 pop	 esi
  00f0d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f0e	5d		 pop	 ebp
  00f0f	c3		 ret	 0
$LN56@ProtocolCo:

; 1408 : 							break;
; 1409 : #endif
; 1410 : #if(CUSTOM_ADD_POINTS==TRUE)
; 1411 : 						case 0x1A:
; 1412 : 							g_ZtUser.CGAddPoints(aIndex, (PMSG_ADD_POINTS*) aRecv);

  00f10	50		 push	 eax
  00f11	53		 push	 ebx
  00f12	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  00f17	e8 00 00 00 00	 call	 ?CGAddPoints@ZtUser@@QAEXHPAUPMSG_ADD_POINTS@@@Z ; ZtUser::CGAddPoints
  00f1c	5f		 pop	 edi
  00f1d	5e		 pop	 esi
  00f1e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f1f	5d		 pop	 ebp
  00f20	c3		 ret	 0
$LN55@ProtocolCo:

; 1413 : 							break;
; 1414 : #endif
; 1415 : #if(CUSTOM_ADD_POINTS==TRUE)
; 1416 : 						case 0x26:
; 1417 : 							g_ZtUser.CGResetPoints(aIndex, (PMSG_ADD_POINTSRESET*) aRecv);

  00f21	50		 push	 eax
  00f22	53		 push	 ebx
  00f23	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  00f28	e8 00 00 00 00	 call	 ?CGResetPoints@ZtUser@@QAEXHPAUPMSG_ADD_POINTSRESET@@@Z ; ZtUser::CGResetPoints
  00f2d	5f		 pop	 edi
  00f2e	5e		 pop	 esi
  00f2f	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f30	5d		 pop	 ebp
  00f31	c3		 ret	 0
$LN54@ProtocolCo:

; 1418 : 							break;
; 1419 : #endif
; 1420 : 						case 0x41:
; 1421 : 							gCreditDonate.CGChangeClass((PMSG_CG_CHANGECLASS*) aRecv, aIndex);

  00f32	53		 push	 ebx
  00f33	50		 push	 eax
  00f34	b9 00 00 00 00	 mov	 ecx, OFFSET ?gCreditDonate@@3VcCreditDonate@@A ; gCreditDonate
  00f39	e8 00 00 00 00	 call	 ?CGChangeClass@cCreditDonate@@QAEXPAUPMSG_CG_CHANGECLASS@@H@Z ; cCreditDonate::CGChangeClass
  00f3e	5f		 pop	 edi
  00f3f	5e		 pop	 esi
  00f40	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f41	5d		 pop	 ebp
  00f42	c3		 ret	 0
$LN53@ProtocolCo:

; 1422 : 							break;
; 1423 : #if(ANTI_CHEAT_PLUS==TRUE)
; 1424 : 						case 0xFE:
; 1425 : 							{
; 1426 : 								g_AntiCheatPlus.CG_HddSend((CG_PMSG_HDDKEY*) aRecv, aIndex);

  00f43	53		 push	 ebx
  00f44	50		 push	 eax
  00f45	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AntiCheatPlus@@3VAntiCheatPlus@@A ; g_AntiCheatPlus
  00f4a	e8 00 00 00 00	 call	 ?CG_HddSend@AntiCheatPlus@@QAEXPAUCG_PMSG_HDDKEY@@H@Z ; AntiCheatPlus::CG_HddSend
  00f4f	5f		 pop	 edi
  00f50	5e		 pop	 esi
  00f51	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f52	5d		 pop	 ebp
  00f53	c3		 ret	 0
$LN52@ProtocolCo:

; 1427 : 							}
; 1428 : 							break;
; 1429 : 						case 0xFF:
; 1430 : 							{
; 1431 : 								g_AntiCheatPlus.CG_Cheater((PMST_CheaterUser*) aRecv, aIndex);

  00f54	53		 push	 ebx
  00f55	50		 push	 eax
  00f56	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AntiCheatPlus@@3VAntiCheatPlus@@A ; g_AntiCheatPlus
  00f5b	e8 00 00 00 00	 call	 ?CG_Cheater@AntiCheatPlus@@QAEXPAUPMST_CheaterUser@@H@Z ; AntiCheatPlus::CG_Cheater
  00f60	5f		 pop	 edi
  00f61	5e		 pop	 esi
  00f62	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f63	5d		 pop	 ebp
  00f64	c3		 ret	 0
$LN51@ProtocolCo:

; 1432 : 							}
; 1433 : 							break;
; 1434 : #if(ANTI_CHEAT_PLUS_CRC)
; 1435 : 						case 0xFD:
; 1436 : 							g_AntiCheatPlus.CGAnsUpdateFile((PMSG_UPDATEFILE*)aRecv, aIndex);
; 1437 : 							break;
; 1438 : #endif
; 1439 : #endif
; 1440 : #if(CUSTOM_PARTY_LEADER==1)
; 1441 : 						case 0x42:
; 1442 : 							gParty.CGNewLeader(aIndex, (GC_PARTYNEWLEADER*) aRecv);

  00f65	50		 push	 eax
  00f66	53		 push	 ebx
  00f67	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00f6c	e8 00 00 00 00	 call	 ?CGNewLeader@PartyClass@@QAEXHPAUGC_PARTYNEWLEADER@@@Z ; PartyClass::CGNewLeader
  00f71	5f		 pop	 edi
  00f72	5e		 pop	 esi
  00f73	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f74	5d		 pop	 ebp
  00f75	c3		 ret	 0
$LN50@ProtocolCo:

; 1443 : 							break;
; 1444 : #endif
; 1445 : #if(ADD_RESET_WINDOW)
; 1446 : 						case 0x43:
; 1447 : 							gResetSystem.CGResulInfo(aIndex);

  00f76	53		 push	 ebx
  00f77	b9 00 00 00 00	 mov	 ecx, OFFSET ?gResetSystem@@3VcResetSystem@@A ; gResetSystem
  00f7c	e8 00 00 00 00	 call	 ?CGResulInfo@cResetSystem@@QAEXH@Z ; cResetSystem::CGResulInfo
  00f81	5f		 pop	 edi
  00f82	5e		 pop	 esi
  00f83	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f84	5d		 pop	 ebp
  00f85	c3		 ret	 0
$LN49@ProtocolCo:

; 1448 : 							break;
; 1449 : #endif
; 1450 : #if(EVENT_DUNGEON_SIEGE)
; 1451 : 						case 0x44:
; 1452 : 							g_DungeonSiege.CGDRegSiege(aIndex);

  00f86	53		 push	 ebx
  00f87	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  00f8c	e8 00 00 00 00	 call	 ?CGDRegSiege@CDungeonSiege@@QAEXH@Z ; CDungeonSiege::CGDRegSiege
  00f91	5f		 pop	 edi
  00f92	5e		 pop	 esi
  00f93	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00f94	5d		 pop	 ebp
  00f95	c3		 ret	 0
$LN48@ProtocolCo:

; 1453 : 							break;
; 1454 : 						case 0x45:
; 1455 : 							g_DungeonSiege.CGHWID((PMSG_CG_DUNBEON_SIEGE_HWID*)aRecv, aIndex);

  00f96	53		 push	 ebx
  00f97	50		 push	 eax
  00f98	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DungeonSiege@@3VCDungeonSiege@@A ; g_DungeonSiege
  00f9d	e8 00 00 00 00	 call	 ?CGHWID@CDungeonSiege@@QAEXPAUPMSG_CG_DUNBEON_SIEGE_HWID@@H@Z ; CDungeonSiege::CGHWID
  00fa2	5f		 pop	 edi
  00fa3	5e		 pop	 esi
  00fa4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00fa5	5d		 pop	 ebp
  00fa6	c3		 ret	 0
$LN46@ProtocolCo:

; 1456 : 							break;
; 1457 : #endif
; 1458 : 						case 0x71:
; 1459 : 
; 1460 : 							break;
; 1461 : #if(EVENT_TEAM_VS_TEAM==TRUE)
; 1462 : 						case 0x81:
; 1463 : 							g_TeamVsTeam.CGTeleportEvent(aIndex);

  00fa7	53		 push	 ebx
  00fa8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TeamVsTeam@@3VCTeamVsTeam@@A ; g_TeamVsTeam
  00fad	e8 00 00 00 00	 call	 ?CGTeleportEvent@CTeamVsTeam@@QAEXH@Z ; CTeamVsTeam::CGTeleportEvent
  00fb2	5f		 pop	 edi
  00fb3	5e		 pop	 esi
  00fb4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00fb5	5d		 pop	 ebp
  00fb6	c3		 ret	 0
$LN45@ProtocolCo:

; 1464 : 							break;
; 1465 : #endif
; 1466 : #if(SYSTEM_ACHIEVEMENTS)
; 1467 : 						case ACH_PROTOCOL1:
; 1468 : 							g_Achievements.CGWindowOpen((PMSG_CG_ACH_WINOPEN*)aRecv, aIndex);

  00fb7	53		 push	 ebx
  00fb8	50		 push	 eax
  00fb9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Achievements@@3VCAchievements@@A ; g_Achievements
  00fbe	e8 00 00 00 00	 call	 ?CGWindowOpen@CAchievements@@QAEXPAUPMSG_CG_ACH_WINOPEN@@H@Z ; CAchievements::CGWindowOpen
  00fc3	5f		 pop	 edi
  00fc4	5e		 pop	 esi
  00fc5	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00fc6	5d		 pop	 ebp
  00fc7	c3		 ret	 0
$LN44@ProtocolCo:

; 1469 : 							break;
; 1470 : #endif
; 1471 : #if(CUSTOM_ZT_TELEPORT==TRUE)
; 1472 : 						case 0x17:
; 1473 : 							g_ZtTeleport.CGResult((PMSG_CG_TELEPORTWINRES*) aRecv, aIndex);

  00fc8	53		 push	 ebx
  00fc9	50		 push	 eax
  00fca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtTeleport@@3VZtTeleport@@A ; g_ZtTeleport
  00fcf	e8 00 00 00 00	 call	 ?CGResult@ZtTeleport@@QAEXPAUPMSG_CG_TELEPORTWINRES@@H@Z ; ZtTeleport::CGResult
  00fd4	5f		 pop	 edi
  00fd5	5e		 pop	 esi
  00fd6	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00fd7	5d		 pop	 ebp
  00fd8	c3		 ret	 0
$LN43@ProtocolCo:

; 1474 : 							break;
; 1475 : #endif
; 1476 : 						case 0x95:
; 1477 : 							gSystemOfRage.CGRageReset(aIndex, (PMSG_ANS_RESETRAGE*)aRecv);

  00fd9	50		 push	 eax
  00fda	53		 push	 ebx
  00fdb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSystemOfRage@@3VcSystemOfRage@@A ; gSystemOfRage
  00fe0	e8 00 00 00 00	 call	 ?CGRageReset@cSystemOfRage@@QAEXHPAUPMSG_ANS_RESETRAGE@@@Z ; cSystemOfRage::CGRageReset
  00fe5	5f		 pop	 edi
  00fe6	5e		 pop	 esi
  00fe7	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00fe8	5d		 pop	 ebp
  00fe9	c3		 ret	 0
$LN42@ProtocolCo:

; 1478 : 							break;
; 1479 : 						case 0x96:
; 1480 : 							CGDonateItemBuy((PMSG_DONATE_ITEMBUY*) aRecv, aIndex);

  00fea	53		 push	 ebx
  00feb	50		 push	 eax
  00fec	e8 00 00 00 00	 call	 ?CGDonateItemBuy@@YAXPAUPMSG_DONATE_ITEMBUY@@H@Z ; CGDonateItemBuy
  00ff1	83 c4 08	 add	 esp, 8
  00ff4	5f		 pop	 edi
  00ff5	5e		 pop	 esi
  00ff6	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  00ff7	5d		 pop	 ebp
  00ff8	c3		 ret	 0
$LN41@ProtocolCo:

; 1481 : 							break;
; 1482 : 						case 0xA0:
; 1483 : 							gResetSystem.CGResetMenu(aIndex);

  00ff9	53		 push	 ebx
  00ffa	b9 00 00 00 00	 mov	 ecx, OFFSET ?gResetSystem@@3VcResetSystem@@A ; gResetSystem
  00fff	e8 00 00 00 00	 call	 ?CGResetMenu@cResetSystem@@QAEXH@Z ; cResetSystem::CGResetMenu
  01004	5f		 pop	 edi
  01005	5e		 pop	 esi
  01006	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01007	5d		 pop	 ebp
  01008	c3		 ret	 0
$LN40@ProtocolCo:

; 1484 : 							break;
; 1485 : 						case 0xA1:
; 1486 : 							gGrandReset.CGGrandMenu(aIndex);

  01009	53		 push	 ebx
  0100a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGrandReset@@3VcGrandReset@@A ; gGrandReset
  0100f	e8 00 00 00 00	 call	 ?CGGrandMenu@cGrandReset@@QAEXH@Z ; cGrandReset::CGGrandMenu
  01014	5f		 pop	 edi
  01015	5e		 pop	 esi
  01016	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01017	5d		 pop	 ebp
  01018	c3		 ret	 0
$LN39@ProtocolCo:

; 1487 : 							break;
; 1488 : 						case 0xA2:
; 1489 : 							gGrandReset.CGGrandStart(aIndex);

  01019	53		 push	 ebx
  0101a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGrandReset@@3VcGrandReset@@A ; gGrandReset
  0101f	e8 00 00 00 00	 call	 ?CGGrandStart@cGrandReset@@QAEXH@Z ; cGrandReset::CGGrandStart
  01024	5f		 pop	 edi
  01025	5e		 pop	 esi
  01026	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01027	5d		 pop	 ebp
  01028	c3		 ret	 0
$LN38@ProtocolCo:

; 1490 : 							break;
; 1491 : #if(CUSTOM_ZT_TELEPORT_EVO)
; 1492 : 						case 0xA3:
; 1493 : 							g_ZtTeleportEvo.CGResult((PMSG_CG_TELEPORTWINRESEVO*) aRecv, aIndex);

  01029	53		 push	 ebx
  0102a	50		 push	 eax
  0102b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtTeleportEvo@@3VZtTeleportEvo@@A ; g_ZtTeleportEvo
  01030	e8 00 00 00 00	 call	 ?CGResult@ZtTeleportEvo@@QAEXPAUPMSG_CG_TELEPORTWINRESEVO@@H@Z ; ZtTeleportEvo::CGResult
  01035	5f		 pop	 edi
  01036	5e		 pop	 esi
  01037	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01038	5d		 pop	 ebp
  01039	c3		 ret	 0
$LN37@ProtocolCo:

; 1494 : 							break;
; 1495 : 						case 0xA4:
; 1496 : 							g_ZtTeleportEvo.CGDialog((PMSG_CG_DIALOGEVO*) aRecv, aIndex);

  0103a	53		 push	 ebx
  0103b	50		 push	 eax
  0103c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtTeleportEvo@@3VZtTeleportEvo@@A ; g_ZtTeleportEvo
  01041	e8 00 00 00 00	 call	 ?CGDialog@ZtTeleportEvo@@QAEXPAUPMSG_CG_DIALOGEVO@@H@Z ; ZtTeleportEvo::CGDialog
  01046	5f		 pop	 edi
  01047	5e		 pop	 esi
  01048	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01049	5d		 pop	 ebp
  0104a	c3		 ret	 0
$LN36@ProtocolCo:

; 1497 : 							break;
; 1498 : #endif
; 1499 : 						case 0xAF:
; 1500 : 							{
; 1501 : #if(CUSTOM_PKCLEAR_NPC==TRUE)
; 1502 : 								g_PKClear.CG_ResultRecv(aIndex, (CG_PKCLEAR_RESULT*) aRecv);

  0104b	50		 push	 eax
  0104c	53		 push	 ebx
  0104d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PKClear@@3VPKClear@@A ; g_PKClear
  01052	e8 00 00 00 00	 call	 ?CG_ResultRecv@PKClear@@QAEXHPAUCG_PKCLEAR_RESULT@@@Z ; PKClear::CG_ResultRecv
  01057	5f		 pop	 edi
  01058	5e		 pop	 esi
  01059	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0105a	5d		 pop	 ebp
  0105b	c3		 ret	 0
$LN35@ProtocolCo:

; 1503 : #endif
; 1504 : 							}
; 1505 : 							break;
; 1506 : #if(CUSTOM_ACCOUNT_SECURITY)
; 1507 : 						case 0xB0:
; 1508 : 							g_AccountSecurity.CGRecvAccountConnect(aIndex, (PMSG_ANS_ACC_CONNECT*)aRecv);

  0105c	50		 push	 eax
  0105d	53		 push	 ebx
  0105e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  01063	e8 00 00 00 00	 call	 ?CGRecvAccountConnect@CAccountSecurity@@QAEXHPAUPMSG_ANS_ACC_CONNECT@@@Z ; CAccountSecurity::CGRecvAccountConnect
  01068	5f		 pop	 edi
  01069	5e		 pop	 esi
  0106a	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0106b	5d		 pop	 ebp
  0106c	c3		 ret	 0
$LN34@ProtocolCo:

; 1509 : 							break;
; 1510 : 						case 0xB1:
; 1511 : 							g_AccountSecurity.CGRecvSettingPC(aIndex, (PMSG_REQ_ACC_SETTING_PC*)aRecv);

  0106d	50		 push	 eax
  0106e	53		 push	 ebx
  0106f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  01074	e8 00 00 00 00	 call	 ?CGRecvSettingPC@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SETTING_PC@@@Z ; CAccountSecurity::CGRecvSettingPC
  01079	5f		 pop	 edi
  0107a	5e		 pop	 esi
  0107b	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0107c	5d		 pop	 ebp
  0107d	c3		 ret	 0
$LN33@ProtocolCo:

; 1512 : 							break;
; 1513 : 						case 0xB2:
; 1514 : 							g_AccountSecurity.CGRecvAccountOption(aIndex, (PMSG_REQ_ACC_OPTION*)aRecv);

  0107e	50		 push	 eax
  0107f	53		 push	 ebx
  01080	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  01085	e8 00 00 00 00	 call	 ?CGRecvAccountOption@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_OPTION@@@Z ; CAccountSecurity::CGRecvAccountOption
  0108a	5f		 pop	 edi
  0108b	5e		 pop	 esi
  0108c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0108d	5d		 pop	 ebp
  0108e	c3		 ret	 0
$LN32@ProtocolCo:

; 1515 : 							break;
; 1516 : 						case 0xB3:
; 1517 : 							g_AccountSecurity.CGRecvSaveNumber(aIndex, (PMSG_REQ_ACC_SAVENUMBER*)aRecv);

  0108f	50		 push	 eax
  01090	53		 push	 ebx
  01091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AccountSecurity@@3VCAccountSecurity@@A ; g_AccountSecurity
  01096	e8 00 00 00 00	 call	 ?CGRecvSaveNumber@CAccountSecurity@@QAEXHPAUPMSG_REQ_ACC_SAVENUMBER@@@Z ; CAccountSecurity::CGRecvSaveNumber
  0109b	5f		 pop	 edi
  0109c	5e		 pop	 esi
  0109d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0109e	5d		 pop	 ebp
  0109f	c3		 ret	 0
$LN31@ProtocolCo:

; 1518 : 							break;
; 1519 : #endif
; 1520 : 
; 1521 : #if(CUSTOM_REFERAL_SYSTEM)
; 1522 : 						case 0xB5:
; 1523 : 							g_ReferralSystem.CGReqMasterInfo((PMSG_REQ_REFERRAL_MASTER_INFO*)aRecv, aIndex);

  010a0	53		 push	 ebx
  010a1	50		 push	 eax
  010a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  010a7	e8 00 00 00 00	 call	 ?CGReqMasterInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_MASTER_INFO@@H@Z ; CReferralSystem::CGReqMasterInfo
  010ac	5f		 pop	 edi
  010ad	5e		 pop	 esi
  010ae	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  010af	5d		 pop	 ebp
  010b0	c3		 ret	 0
$LN30@ProtocolCo:

; 1524 : 							break;
; 1525 : 						case 0xB6:
; 1526 : 							g_ReferralSystem.CGMasterResult((PMSG_CGREQ_REFERRAL_MASTER_REWARD*)aRecv, aIndex);

  010b1	53		 push	 ebx
  010b2	50		 push	 eax
  010b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  010b8	e8 00 00 00 00	 call	 ?CGMasterResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_MASTER_REWARD@@H@Z ; CReferralSystem::CGMasterResult
  010bd	5f		 pop	 edi
  010be	5e		 pop	 esi
  010bf	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  010c0	5d		 pop	 ebp
  010c1	c3		 ret	 0
$LN29@ProtocolCo:

; 1527 : 							break;
; 1528 : 						case 0xB7:
; 1529 : 							g_ReferralSystem.CGReqUserInfo((PMSG_REQ_REFERRAL_USER_INFO*)aRecv, aIndex);

  010c2	53		 push	 ebx
  010c3	50		 push	 eax
  010c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  010c9	e8 00 00 00 00	 call	 ?CGReqUserInfo@CReferralSystem@@QAEXPAUPMSG_REQ_REFERRAL_USER_INFO@@H@Z ; CReferralSystem::CGReqUserInfo
  010ce	5f		 pop	 edi
  010cf	5e		 pop	 esi
  010d0	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  010d1	5d		 pop	 ebp
  010d2	c3		 ret	 0
$LN28@ProtocolCo:

; 1530 : 							break;
; 1531 : 						case 0xB8:
; 1532 : 							g_ReferralSystem.CGUserResult((PMSG_CGREQ_REFERRAL_USER_REWARD*)aRecv, aIndex);

  010d3	53		 push	 ebx
  010d4	50		 push	 eax
  010d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ReferralSystem@@3VCReferralSystem@@A ; g_ReferralSystem
  010da	e8 00 00 00 00	 call	 ?CGUserResult@CReferralSystem@@QAEXPAUPMSG_CGREQ_REFERRAL_USER_REWARD@@H@Z ; CReferralSystem::CGUserResult
  010df	5f		 pop	 edi
  010e0	5e		 pop	 esi
  010e1	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  010e2	5d		 pop	 ebp
  010e3	c3		 ret	 0
$LN27@ProtocolCo:

; 1533 : 							break;
; 1534 : #endif
; 1535 : 						case 0xBA:
; 1536 : 							g_ZtUser.CG_RecvAutoHPClicker((PMSG_PROTOCOL_RESULT*)aRecv, aIndex);

  010e4	53		 push	 ebx
  010e5	50		 push	 eax
  010e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  010eb	e8 00 00 00 00	 call	 ?CG_RecvAutoHPClicker@ZtUser@@QAEXPAUPMSG_PROTOCOL_RESULT@@H@Z ; ZtUser::CG_RecvAutoHPClicker
  010f0	5f		 pop	 edi
  010f1	5e		 pop	 esi
  010f2	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  010f3	5d		 pop	 ebp
  010f4	c3		 ret	 0
$LN26@ProtocolCo:

; 1537 : 							break;
; 1538 : #if(CUSTOM_ZT_QUEST_SYSTEM==TRUE)
; 1539 : 						case 0x12:
; 1540 : 							{
; 1541 : 								g_ZtWinQuestSystem.CG_AcceptQuest(aIndex, (CG_Accept_Done*) aRecv);

  010f5	50		 push	 eax
  010f6	53		 push	 ebx
  010f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtWinQuestSystem@@3VZtWinQuestSystem@@A ; g_ZtWinQuestSystem
  010fc	e8 00 00 00 00	 call	 ?CG_AcceptQuest@ZtWinQuestSystem@@QAEXHPAUCG_Accept_Done@@@Z ; ZtWinQuestSystem::CG_AcceptQuest
  01101	5f		 pop	 edi
  01102	5e		 pop	 esi
  01103	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01104	5d		 pop	 ebp
  01105	c3		 ret	 0
$LN25@ProtocolCo:

; 1542 : 							}
; 1543 : 							break;
; 1544 : #endif
; 1545 : #if(CUSTOM_PICKUP_ITEM_INFO)
; 1546 : 						case 0xBF:
; 1547 : 							g_PickUpItemInfo.InfoRecv((PMSG_REQ_PICKUP_INFO*)aRecv, aIndex);

  01106	53		 push	 ebx
  01107	50		 push	 eax
  01108	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PickUpItemInfo@@3VCPickUpItemInfo@@A ; g_PickUpItemInfo
  0110d	e8 00 00 00 00	 call	 ?InfoRecv@CPickUpItemInfo@@QAEXPAUPMSG_REQ_PICKUP_INFO@@H@Z ; CPickUpItemInfo::InfoRecv
  01112	5f		 pop	 edi
  01113	5e		 pop	 esi
  01114	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01115	5d		 pop	 ebp
  01116	c3		 ret	 0
$LN24@ProtocolCo:

; 1548 : 							break;
; 1549 : #endif
; 1550 : 						case 0xC1:
; 1551 : 							WarehouseChange(aIndex, (CHANGEWAREHOUSE*)aRecv);

  01117	50		 push	 eax
  01118	53		 push	 ebx
  01119	e8 00 00 00 00	 call	 ?WarehouseChange@@YAXHPAUCHANGEWAREHOUSE@@@Z ; WarehouseChange
  0111e	83 c4 08	 add	 esp, 8
  01121	5f		 pop	 edi
  01122	5e		 pop	 esi
  01123	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01124	5d		 pop	 ebp
  01125	c3		 ret	 0
$LN23@ProtocolCo:

; 1552 : 							break;
; 1553 : 						case 0xC2:
; 1554 : 							CGRecvOffTrade((PMSG_OFFTRADE*)aRecv, aIndex);

  01126	53		 push	 ebx
  01127	50		 push	 eax
  01128	e8 00 00 00 00	 call	 ?CGRecvOffTrade@@YAXPAUPMSG_OFFTRADE@@H@Z ; CGRecvOffTrade
  0112d	83 c4 08	 add	 esp, 8
  01130	5f		 pop	 edi
  01131	5e		 pop	 esi
  01132	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01133	5d		 pop	 ebp
  01134	c3		 ret	 0
$LN22@ProtocolCo:

; 1555 : 							break;
; 1556 : 						#if(CUSTOM_LOTTERY)
; 1557 : 						case 0xD1:
; 1558 : 							g_Lottery.CGLotteryPlay((PMSG_LOTTERY_PLAY*)aRecv, aIndex);
; 1559 : 							break;
; 1560 : 						#endif
; 1561 : #if(ADD_CTRL_KEY)
; 1562 : 						case 0xD3:
; 1563 : 							g_ZtUser.CGCtrlKey(aIndex, (PMSG_CONTROLLER_CTRL*) aRecv);

  01135	50		 push	 eax
  01136	53		 push	 ebx
  01137	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  0113c	e8 00 00 00 00	 call	 ?CGCtrlKey@ZtUser@@QAEXHPAUPMSG_CONTROLLER_CTRL@@@Z ; ZtUser::CGCtrlKey
  01141	5f		 pop	 edi
  01142	5e		 pop	 esi
  01143	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01144	5d		 pop	 ebp
  01145	c3		 ret	 0
$LN21@ProtocolCo:

; 1564 : 							break;
; 1565 : #endif
; 1566 : 						case 0xD7:
; 1567 : 							g_ZtUser.RecvConfig((CG_MINIMAP_PARTY*) aRecv, aIndex);

  01146	53		 push	 ebx
  01147	50		 push	 eax
  01148	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  0114d	e8 00 00 00 00	 call	 ?RecvConfig@ZtUser@@QAEXPAUCG_MINIMAP_PARTY@@H@Z ; ZtUser::RecvConfig
  01152	5f		 pop	 edi
  01153	5e		 pop	 esi
  01154	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01155	5d		 pop	 ebp
  01156	c3		 ret	 0
$LN20@ProtocolCo:

; 1568 : 							break;
; 1569 : 						case 0xD8:
; 1570 : 							g_GuildBank.CGOpenGuildWarehouse((PMSG_GUILD_BANK*)aRecv, aIndex);

  01157	53		 push	 ebx
  01158	50		 push	 eax
  01159	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildBank@@3VCGuildBank@@A ; g_GuildBank
  0115e	e8 00 00 00 00	 call	 ?CGOpenGuildWarehouse@CGuildBank@@QAEXPAUPMSG_GUILD_BANK@@H@Z ; CGuildBank::CGOpenGuildWarehouse
  01163	5f		 pop	 edi
  01164	5e		 pop	 esi
  01165	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01166	5d		 pop	 ebp
  01167	c3		 ret	 0
$LN19@ProtocolCo:

; 1571 : 							break;
; 1572 : 						#if(INTERFACE_JEWELBANK)
; 1573 : 						case 0xDA:
; 1574 : 							gJewelsBank.Packet(aIndex, (PMSG_JEWELBANK*)aRecv);

  01168	50		 push	 eax
  01169	53		 push	 ebx
  0116a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gJewelsBank@@3VJewelsBank@@A ; gJewelsBank
  0116f	e8 00 00 00 00	 call	 ?Packet@JewelsBank@@QAEXHPAUPMSG_JEWELBANK@@@Z ; JewelsBank::Packet
  01174	5f		 pop	 edi
  01175	5e		 pop	 esi
  01176	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01177	5d		 pop	 ebp
  01178	c3		 ret	 0
$LN18@ProtocolCo:

; 1575 : 							break;
; 1576 : 						#endif
; 1577 : 						#if(DEV_PLAYERINFO)
; 1578 : 						case 0xDB:
; 1579 : 							g_ZtUser.RecvInfoPlayer((PMSG_REQ_INFOPLAYER*)aRecv, aIndex);
; 1580 : 							break;
; 1581 : 						#endif
; 1582 : 						#if(CUSTOM_VALUE_MENU)
; 1583 : 						case 0xDE:
; 1584 : 							g_ZtUser.CGRecvValueMenu((PMSG_ANS_VALUE_MENU*)aRecv, aIndex);

  01179	53		 push	 ebx
  0117a	50		 push	 eax
  0117b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ZtUser@@3VZtUser@@A ; g_ZtUser
  01180	e8 00 00 00 00	 call	 ?CGRecvValueMenu@ZtUser@@QAEXPAUPMSG_ANS_VALUE_MENU@@H@Z ; ZtUser::CGRecvValueMenu
  01185	5f		 pop	 edi
  01186	5e		 pop	 esi
  01187	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01188	5d		 pop	 ebp
  01189	c3		 ret	 0
$LN17@ProtocolCo:

; 1585 : 							break;
; 1586 : 						#endif
; 1587 : 						#if(CUSTOM_MAP_TELEPORT)
; 1588 : 						case 0xE1:
; 1589 : 							g_MapTeleport.CGReqData((PMSG_REQ_MAPTELEPORT_DATA*)aRecv, aIndex);

  0118a	53		 push	 ebx
  0118b	50		 push	 eax
  0118c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapTeleport@@3VCMapTeleport@@A ; g_MapTeleport
  01191	e8 00 00 00 00	 call	 ?CGReqData@CMapTeleport@@QAEXPAUPMSG_REQ_MAPTELEPORT_DATA@@H@Z ; CMapTeleport::CGReqData
  01196	5f		 pop	 edi
  01197	5e		 pop	 esi
  01198	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01199	5d		 pop	 ebp
  0119a	c3		 ret	 0
$LN16@ProtocolCo:

; 1590 : 							break;
; 1591 : 						case 0xE2:
; 1592 : 							g_MapTeleport.CGReqSelect((PMSG_REQ_MAPTELEPORT_SELECT*)aRecv, aIndex);

  0119b	53		 push	 ebx
  0119c	50		 push	 eax
  0119d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapTeleport@@3VCMapTeleport@@A ; g_MapTeleport
  011a2	e8 00 00 00 00	 call	 ?CGReqSelect@CMapTeleport@@QAEXPAUPMSG_REQ_MAPTELEPORT_SELECT@@H@Z ; CMapTeleport::CGReqSelect
  011a7	5f		 pop	 edi
  011a8	5e		 pop	 esi
  011a9	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  011aa	5d		 pop	 ebp
  011ab	c3		 ret	 0
$LN15@ProtocolCo:

; 1593 : 							break;
; 1594 : 						#endif
; 1595 : 						#if(FIX_VIEWE_MONSTER)
; 1596 : 						case 0xE5:
; 1597 : 							g_ZtUser.CGReqReViewe((PMSG_REQ_REVIEWE*)aRecv, aIndex);
; 1598 : 							break;
; 1599 : 						#endif
; 1600 : 						#if(CUSTOM_CAMERA_MOVE)
; 1601 : 						case 0xEA:
; 1602 : 							g_CameraMove.CGReqViewe((PMSG_REQ_CAMERAMOVE_VIEWE*)aRecv, aIndex);

  011ac	53		 push	 ebx
  011ad	50		 push	 eax
  011ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CameraMove@@3VCCameraMove@@A ; g_CameraMove
  011b3	e8 00 00 00 00	 call	 ?CGReqViewe@CCameraMove@@QAEXPAUPMSG_REQ_CAMERAMOVE_VIEWE@@H@Z ; CCameraMove::CGReqViewe
  011b8	5f		 pop	 edi
  011b9	5e		 pop	 esi
  011ba	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  011bb	5d		 pop	 ebp
  011bc	c3		 ret	 0
$LN14@ProtocolCo:

; 1603 : 							break;
; 1604 : 						#endif
; 1605 : 						#if(ENABLE_CAMERA_PARTY)
; 1606 : 						case 0xEC:
; 1607 : 							g_CameraParty.CGReqPartyMember((PMSG_REQ_PARTY_MEMBER*)aRecv, aIndex);

  011bd	53		 push	 ebx
  011be	50		 push	 eax
  011bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CameraParty@@3VCCameraParty@@A ; g_CameraParty
  011c4	e8 00 00 00 00	 call	 ?CGReqPartyMember@CCameraParty@@QAEXPAUPMSG_REQ_PARTY_MEMBER@@H@Z ; CCameraParty::CGReqPartyMember
  011c9	5f		 pop	 edi
  011ca	5e		 pop	 esi
  011cb	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  011cc	5d		 pop	 ebp
  011cd	c3		 ret	 0
$LN13@ProtocolCo:

; 1608 : 							break;
; 1609 : 						#endif
; 1610 : 						#if(ENABLE_MULTI_CHAR)
; 1611 : 						case 0xF0:
; 1612 : 							GDCharacterListMultiSend((PMSG_REQ_MULTI_CHAR_RECV*)aRecv, aIndex);
; 1613 : 							break;
; 1614 : 						#endif
; 1615 : 					}
; 1616 : 				}
; 1617 : 				break;
; 1618 : #if(CUSTOM_NEWS==TRUE)
; 1619 : 			case 0xFD:
; 1620 : 				{
; 1621 : 					g_NewsBoard.OpenMain(&gObj[aIndex]);

  011ce	56		 push	 esi
  011cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewsBoard@@3VNewsBoard@@A ; g_NewsBoard
  011d4	e8 00 00 00 00	 call	 ?OpenMain@NewsBoard@@QAEXPAUOBJECTSTRUCT@@@Z ; NewsBoard::OpenMain
  011d9	5f		 pop	 edi
  011da	5e		 pop	 esi
  011db	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  011dc	5d		 pop	 ebp
  011dd	c3		 ret	 0
$LN12@ProtocolCo:

; 1622 : 				}
; 1623 : 				break;
; 1624 : 				// --
; 1625 : 			case 0xFE:
; 1626 : 				{
; 1627 : 					g_NewsBoard.OpenItem(&gObj[aIndex], (NEWS_REQ_NEWS*)aRecv);

  011de	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  011e1	50		 push	 eax
  011e2	56		 push	 esi
  011e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewsBoard@@3VNewsBoard@@A ; g_NewsBoard
  011e8	e8 00 00 00 00	 call	 ?OpenItem@NewsBoard@@QAEXPAUOBJECTSTRUCT@@PAUNEWS_REQ_NEWS@@@Z ; NewsBoard::OpenItem
  011ed	5f		 pop	 edi
  011ee	5e		 pop	 esi
  011ef	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  011f0	5d		 pop	 ebp
  011f1	c3		 ret	 0
$LN11@ProtocolCo:

; 1628 : 				}
; 1629 : 				break;
; 1630 : 				// --
; 1631 : #endif // NEWS_BOARD
; 1632 : 		#if(MOVE_ITEM)
; 1633 : 		case 0x79:
; 1634 : 			CGMoveItemProc((PMSG_MOVEITEM*)lpMsg, aIndex);
; 1635 : 			break;
; 1636 : 		#endif
; 1637 : #if(ENABLE_MOVE_ITEM)
; 1638 : 			case 0x79:
; 1639 : 				switch (aRecv[3])

  011f2	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  011f5	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  011f9	48		 dec	 eax
  011fa	0f 85 1f 02 00
	00		 jne	 $LN344@ProtocolCo

; 1640 : 				{
; 1641 : 				case 0x01:
; 1642 : 					CGMoveItemProc((PMSG_MOVEITEM*)aRecv, aIndex);

  01200	53		 push	 ebx
  01201	51		 push	 ecx
  01202	e8 00 00 00 00	 call	 ?CGMoveItemProc@@YAXPAUPMSG_MOVEITEM@@F@Z ; CGMoveItemProc
  01207	83 c4 08	 add	 esp, 8
  0120a	5f		 pop	 edi
  0120b	5e		 pop	 esi
  0120c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0120d	5d		 pop	 ebp
  0120e	c3		 ret	 0
$LN7@ProtocolCo:

; 1643 : 					break;
; 1644 : 				}
; 1645 : 				break;
; 1646 : #endif
; 1647 : 			#if(DEV_PLAYERSHOP)
; 1648 : 			case 0x80:
; 1649 : 				switch (aRecv[3])

  0120f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01212	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  01216	83 e8 00	 sub	 eax, 0
  01219	74 2c		 je	 SHORT $LN4@ProtocolCo
  0121b	48		 dec	 eax
  0121c	74 18		 je	 SHORT $LN3@ProtocolCo
  0121e	48		 dec	 eax
  0121f	0f 85 fa 01 00
	00		 jne	 $LN344@ProtocolCo

; 1656 : 					break;
; 1657 : 				case 0x02:
; 1658 : 					g_ItemMarket.CGReqItemBuy((PMSG_REQ_MARKET_BUY*) aRecv, aIndex);

  01225	53		 push	 ebx
  01226	51		 push	 ecx
  01227	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMarket@@3VCItemMarket@@A ; g_ItemMarket
  0122c	e8 00 00 00 00	 call	 ?CGReqItemBuy@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_BUY@@H@Z ; CItemMarket::CGReqItemBuy
  01231	5f		 pop	 edi
  01232	5e		 pop	 esi
  01233	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01234	5d		 pop	 ebp
  01235	c3		 ret	 0
$LN3@ProtocolCo:

; 1653 : 					break;
; 1654 : 				case 0x01:
; 1655 : 					g_ItemMarket.CGReqItemSell((PMSG_REQ_MARKET_SELL*) aRecv, aIndex);

  01236	53		 push	 ebx
  01237	51		 push	 ecx
  01238	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMarket@@3VCItemMarket@@A ; g_ItemMarket
  0123d	e8 00 00 00 00	 call	 ?CGReqItemSell@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_SELL@@H@Z ; CItemMarket::CGReqItemSell
  01242	5f		 pop	 edi
  01243	5e		 pop	 esi
  01244	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01245	5d		 pop	 ebp
  01246	c3		 ret	 0
$LN4@ProtocolCo:

; 1650 : 				{
; 1651 : 				case 0x00:
; 1652 : 					g_ItemMarket.CGReqItemList((PMSG_REQ_MARKET_ITEM*) aRecv, aIndex);

  01247	53		 push	 ebx
  01248	51		 push	 ecx
  01249	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemMarket@@3VCItemMarket@@A ; g_ItemMarket
  0124e	e8 00 00 00 00	 call	 ?CGReqItemList@CItemMarket@@QAEXPAUPMSG_REQ_MARKET_ITEM@@H@Z ; CItemMarket::CGReqItemList
  01253	5f		 pop	 edi
  01254	5e		 pop	 esi
  01255	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01256	5d		 pop	 ebp
  01257	c3		 ret	 0
$LN1@ProtocolCo:

; 1659 : 					break;
; 1660 : 				}			
; 1661 : 				break;
; 1662 : 			#endif
; 1663 : 			default:
; 1664 : 				LogAddC(2, "error-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d", gObj[aIndex].AccountID, gObj[aIndex].Name, protoNum, __FILE__, __LINE__, gObj[aIndex].Connected);

  01258	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0125b	52		 push	 edx
  0125c	68 80 06 00 00	 push	 1664			; 00000680H
  01261	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  01266	51		 push	 ecx
  01267	8d 46 77	 lea	 eax, DWORD PTR [esi+119]
  0126a	50		 push	 eax
  0126b	83 c6 6c	 add	 esi, 108		; 0000006cH
  0126e	56		 push	 esi
  0126f	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@
  01274	6a 02		 push	 2
  01276	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1665 : #ifndef DEBUG_CODE
; 1666 : 				#if(!ENABLE_INDEV_NETWORK)
; 1667 : 				CloseClient(aIndex);

  0127c	53		 push	 ebx
  0127d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  01282	83 c4 24	 add	 esp, 36			; 00000024H
  01285	5f		 pop	 edi
  01286	5e		 pop	 esi
  01287	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01288	5d		 pop	 ebp
  01289	c3		 ret	 0
$LN348@ProtocolCo:

; 310  : 	{
; 311  : 		switch ( protoNum )

  0128a	0f b6 c8	 movzx	 ecx, al
  0128d	83 e9 0e	 sub	 ecx, 14			; 0000000eH
  01290	0f 84 64 01 00
	00		 je	 $LN345@ProtocolCo
  01296	81 e9 e3 00 00
	00		 sub	 ecx, 227		; 000000e3H
  0129c	0f 84 bd 00 00
	00		 je	 $LN343@ProtocolCo
  012a2	83 e9 02	 sub	 ecx, 2
  012a5	0f 85 74 01 00
	00		 jne	 $LN344@ProtocolCo

; 350  : 							}
; 351  : 							break;
; 352  : 					}
; 353  : 				}
; 354  : 				break;
; 355  : 			case 0xF3:
; 356  : 				{
; 357  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 358  : 
; 359  : 					switch ( lpDef->subcode )

  012ab	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  012ae	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  012b2	83 f9 52	 cmp	 ecx, 82			; 00000052H
  012b5	0f 87 64 01 00
	00		 ja	 $LN344@ProtocolCo
  012bb	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN363@ProtocolCo[ecx]
  012c2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN375@ProtocolCo[ecx*4]
$LN328@ProtocolCo:

; 360  : 					{
; 361  : 						case 0x00:
; 362  : 							DataServerGetCharListRequest(aIndex);

  012c9	53		 push	 ebx
  012ca	e8 00 00 00 00	 call	 ?DataServerGetCharListRequest@@YAXF@Z ; DataServerGetCharListRequest
  012cf	83 c4 04	 add	 esp, 4
  012d2	5f		 pop	 edi
  012d3	5e		 pop	 esi
  012d4	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  012d5	5d		 pop	 ebp
  012d6	c3		 ret	 0
$LN327@ProtocolCo:

; 363  : 							break;
; 364  : 						case 0x01:
; 365  : 							CGPCharacterCreate((PMSG_CHARCREATE *)aRecv, aIndex);

  012d7	53		 push	 ebx
  012d8	50		 push	 eax
  012d9	e8 00 00 00 00	 call	 ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ; CGPCharacterCreate
  012de	83 c4 08	 add	 esp, 8
  012e1	5f		 pop	 edi
  012e2	5e		 pop	 esi
  012e3	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  012e4	5d		 pop	 ebp
  012e5	c3		 ret	 0
$LN326@ProtocolCo:

; 366  : 							break;
; 367  : 						case 0x02:
; 368  : 							CGPCharDel((PMSG_CHARDELETE *)aRecv, aIndex);

  012e6	53		 push	 ebx
  012e7	50		 push	 eax
  012e8	e8 00 00 00 00	 call	 ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ; CGPCharDel
  012ed	83 c4 08	 add	 esp, 8
  012f0	5f		 pop	 edi
  012f1	5e		 pop	 esi
  012f2	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  012f3	5d		 pop	 ebp
  012f4	c3		 ret	 0
$LN325@ProtocolCo:

; 369  : 							break;
; 370  : 						case 0x03:
; 371  : 							CGPCharacterMapJoinRequest((PMSG_CHARMAPJOIN *)aRecv, aIndex);

  012f5	53		 push	 ebx
  012f6	50		 push	 eax
  012f7	e8 00 00 00 00	 call	 ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
  012fc	83 c4 08	 add	 esp, 8
  012ff	5f		 pop	 edi
  01300	5e		 pop	 esi
  01301	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01302	5d		 pop	 ebp
  01303	c3		 ret	 0
$LN324@ProtocolCo:

; 372  : 							break;
; 373  : 						case 0x06:
; 374  : 							CGLevelUpPointAdd((PMSG_LVPOINTADD *)aRecv, aIndex);

  01304	53		 push	 ebx
  01305	50		 push	 eax
  01306	e8 00 00 00 00	 call	 ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ; CGLevelUpPointAdd
  0130b	83 c4 08	 add	 esp, 8
  0130e	5f		 pop	 edi
  0130f	5e		 pop	 esi
  01310	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01311	5d		 pop	 ebp
  01312	c3		 ret	 0
$LN323@ProtocolCo:

; 375  : 							break;
; 376  : 						case 0x12:
; 377  : 							gObjMoveDataLoadingOK(aIndex);

  01313	53		 push	 ebx
  01314	e8 00 00 00 00	 call	 ?gObjMoveDataLoadingOK@@YAXH@Z ; gObjMoveDataLoadingOK
  01319	83 c4 04	 add	 esp, 4
  0131c	5f		 pop	 edi
  0131d	5e		 pop	 esi
  0131e	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0131f	5d		 pop	 ebp
  01320	c3		 ret	 0
$LN322@ProtocolCo:

; 378  : 							break;
; 379  : 
; 380  : 						case 0x15: //Season4 Add-on
; 381  : 							CGCheckNameRequest((PMSG_REQ_CHARACTER_CHECKNAME *)aRecv, aIndex);

  01321	53		 push	 ebx
  01322	50		 push	 eax
  01323	e8 00 00 00 00	 call	 ?CGCheckNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHECKNAME@@H@Z ; CGCheckNameRequest
  01328	83 c4 08	 add	 esp, 8
  0132b	5f		 pop	 edi
  0132c	5e		 pop	 esi
  0132d	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0132e	5d		 pop	 ebp
  0132f	c3		 ret	 0
$LN321@ProtocolCo:

; 382  : 							break;
; 383  : 						case 0x16: //Season4 Add-on
; 384  : 							CGChangeNameRequest((PMSG_REQ_CHARACTER_CHANGENAME *)aRecv, aIndex);

  01330	53		 push	 ebx
  01331	50		 push	 eax
  01332	e8 00 00 00 00	 call	 ?CGChangeNameRequest@@YAXPAUPMSG_REQ_CHARACTER_CHANGENAME@@H@Z ; CGChangeNameRequest
  01337	83 c4 08	 add	 esp, 8
  0133a	5f		 pop	 edi
  0133b	5e		 pop	 esi
  0133c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0133d	5d		 pop	 ebp
  0133e	c3		 ret	 0
$LN320@ProtocolCo:

; 385  : 							break;
; 386  : 
; 387  : 						case 0x30:
; 388  : 							GCSkillKeyRecv((PMSG_SKILLKEY *)aRecv, aIndex);

  0133f	53		 push	 ebx
  01340	50		 push	 eax
  01341	e8 00 00 00 00	 call	 ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ; GCSkillKeyRecv
  01346	83 c4 08	 add	 esp, 8
  01349	5f		 pop	 edi
  0134a	5e		 pop	 esi
  0134b	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0134c	5d		 pop	 ebp
  0134d	c3		 ret	 0
$LN319@ProtocolCo:

; 389  : 							break;
; 390  : 						case 0x52: //Season3 Add-on
; 391  : 							g_MasterSkillSystem.CGReqGetMasterLevelSkill((PMSG_REQ_MASTERLEVEL_SKILL*)aRecv, aIndex);

  0134e	53		 push	 ebx
  0134f	50		 push	 eax
  01350	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  01355	e8 00 00 00 00	 call	 ?CGReqGetMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEXPAUPMSG_REQ_MASTERLEVEL_SKILL@@H@Z ; CMasterLevelSkillTreeSystem::CGReqGetMasterLevelSkill
  0135a	5f		 pop	 edi
  0135b	5e		 pop	 esi
  0135c	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  0135d	5d		 pop	 ebp
  0135e	c3		 ret	 0
$LN343@ProtocolCo:

; 318  : 				}
; 319  : 				break;
; 320  : 			case 0xF1:
; 321  : 				{
; 322  : 					PMSG_DEFAULT2 * lpMsg2 = (PMSG_DEFAULT2 *)aRecv;
; 323  : 					
; 324  : 					aRecv[1] -= 0x0A;

  0135f	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01362	80 42 01 f6	 add	 BYTE PTR [edx+1], 246	; 000000f6H
  01366	8d 7a 18	 lea	 edi, DWORD PTR [edx+24]
  01369	8d 72 22	 lea	 esi, DWORD PTR [edx+34]

; 325  : 					aLen = aRecv[1];
; 326  : 					for(int i = 24; i<50; i++)
; 327  : 					{
; 328  : 						aRecv[i] = aRecv[i+10];

  0136c	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  01371	f3 a4		 rep movsb

; 329  : 					}
; 330  : 
; 331  : 					switch ( lpMsg2->subcode )

  01373	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  01377	49		 dec	 ecx
  01378	74 56		 je	 SHORT $LN337@ProtocolCo
  0137a	49		 dec	 ecx
  0137b	74 2f		 je	 SHORT $LN335@ProtocolCo
  0137d	49		 dec	 ecx
  0137e	0f 85 9b 00 00
	00		 jne	 $LN344@ProtocolCo

; 344  : 							}
; 345  : 							break;
; 346  : 						case 0x03:
; 347  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01384	8b 55 18	 mov	 edx, DWORD PTR _Encrypt$[ebp]
  01387	52		 push	 edx
  01388	50		 push	 eax
  01389	53		 push	 ebx
  0138a	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0138f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01392	85 c0		 test	 eax, eax
  01394	0f 84 85 00 00
	00		 je	 $LN344@ProtocolCo

; 348  : 							{
; 349  : 								CGClientMsg((PMSG_CLIENTMSG *)aRecv, aIndex);

  0139a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0139d	53		 push	 ebx
  0139e	50		 push	 eax
  0139f	e8 00 00 00 00	 call	 ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ; CGClientMsg
  013a4	83 c4 08	 add	 esp, 8
  013a7	5f		 pop	 edi
  013a8	5e		 pop	 esi
  013a9	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  013aa	5d		 pop	 ebp
  013ab	c3		 ret	 0
$LN335@ProtocolCo:

; 338  : 							}
; 339  : 							break;
; 340  : 						case 0x02:
; 341  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  013ac	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  013af	51		 push	 ecx
  013b0	50		 push	 eax
  013b1	53		 push	 ebx
  013b2	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  013b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  013ba	85 c0		 test	 eax, eax
  013bc	74 61		 je	 SHORT $LN344@ProtocolCo

; 342  : 							{
; 343  : 								CGClientCloseMsg((PMSG_CLIENTCLOSE *)aRecv, aIndex);

  013be	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  013c1	53		 push	 ebx
  013c2	52		 push	 edx
  013c3	e8 00 00 00 00	 call	 ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ; CGClientCloseMsg
  013c8	83 c4 08	 add	 esp, 8
  013cb	5f		 pop	 edi
  013cc	5e		 pop	 esi
  013cd	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  013ce	5d		 pop	 ebp
  013cf	c3		 ret	 0
$LN337@ProtocolCo:

; 332  : 					{
; 333  : 						case 0x01:
; 334  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  013d0	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  013d3	51		 push	 ecx
  013d4	50		 push	 eax
  013d5	53		 push	 ebx
  013d6	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  013db	83 c4 0c	 add	 esp, 12			; 0000000cH
  013de	85 c0		 test	 eax, eax
  013e0	74 3d		 je	 SHORT $LN344@ProtocolCo

; 335  : 							{
; 336  : 								ztGCConfigSend(aIndex);

  013e2	53		 push	 ebx
  013e3	e8 00 00 00 00	 call	 ?ztGCConfigSend@@YAXH@Z	; ztGCConfigSend

; 337  : 								CSPJoinIdPassRequest((PMSG_IDPASS *)aRecv, aIndex);

  013e8	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  013eb	53		 push	 ebx
  013ec	52		 push	 edx
  013ed	e8 00 00 00 00	 call	 ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequest
  013f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  013f5	5f		 pop	 edi
  013f6	5e		 pop	 esi
  013f7	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  013f8	5d		 pop	 ebp
  013f9	c3		 ret	 0
$LN345@ProtocolCo:

; 312  : 		{
; 313  : 			case 0x0E:
; 314  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  013fa	8b 4d 18	 mov	 ecx, DWORD PTR _Encrypt$[ebp]
  013fd	51		 push	 ecx
  013fe	50		 push	 eax
  013ff	53		 push	 ebx
  01400	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01405	83 c4 0c	 add	 esp, 12			; 0000000cH
  01408	85 c0		 test	 eax, eax
  0140a	74 13		 je	 SHORT $LN344@ProtocolCo

; 315  : 				{
; 316  : 					CGLiveClient((PMSG_CLIENTTIME *)aRecv, aIndex);

  0140c	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0140f	53		 push	 ebx
  01410	52		 push	 edx
  01411	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient

; 317  : 					tempindex = aIndex;

  01416	89 1d 00 00 00
	00		 mov	 DWORD PTR ?tempindex@@3HA, ebx ; tempindex
  0141c	83 c4 08	 add	 esp, 8
$LN344@ProtocolCo:
  0141f	5f		 pop	 edi
  01420	5e		 pop	 esi
  01421	5b		 pop	 ebx

; 1668 : #endif
; 1669 : #endif
; 1670 : 		}	
; 1671 : 	}
; 1672 : }

  01422	5d		 pop	 ebp
  01423	c3		 ret	 0
$LN367@ProtocolCo:
  01424	00 00 00 00	 DD	 $LN314@ProtocolCo
  01428	00 00 00 00	 DD	 $LN313@ProtocolCo
  0142c	00 00 00 00	 DD	 $LN312@ProtocolCo
  01430	00 00 00 00	 DD	 $LN311@ProtocolCo
  01434	00 00 00 00	 DD	 $LN310@ProtocolCo
  01438	00 00 00 00	 DD	 $LN307@ProtocolCo
  0143c	00 00 00 00	 DD	 $LN308@ProtocolCo
  01440	00 00 00 00	 DD	 $LN306@ProtocolCo
  01444	00 00 00 00	 DD	 $LN305@ProtocolCo
  01448	00 00 00 00	 DD	 $LN303@ProtocolCo
  0144c	00 00 00 00	 DD	 $LN302@ProtocolCo
  01450	00 00 00 00	 DD	 $LN297@ProtocolCo
  01454	00 00 00 00	 DD	 $LN295@ProtocolCo
  01458	00 00 00 00	 DD	 $LN293@ProtocolCo
  0145c	00 00 00 00	 DD	 $LN292@ProtocolCo
  01460	00 00 00 00	 DD	 $LN291@ProtocolCo
  01464	00 00 00 00	 DD	 $LN290@ProtocolCo
  01468	00 00 00 00	 DD	 $LN288@ProtocolCo
  0146c	00 00 00 00	 DD	 $LN287@ProtocolCo
  01470	00 00 00 00	 DD	 $LN283@ProtocolCo
  01474	00 00 00 00	 DD	 $LN281@ProtocolCo
  01478	00 00 00 00	 DD	 $LN280@ProtocolCo
  0147c	00 00 00 00	 DD	 $LN278@ProtocolCo
  01480	00 00 00 00	 DD	 $LN277@ProtocolCo
  01484	00 00 00 00	 DD	 $LN276@ProtocolCo
  01488	00 00 00 00	 DD	 $LN274@ProtocolCo
  0148c	00 00 00 00	 DD	 $LN272@ProtocolCo
  01490	00 00 00 00	 DD	 $LN260@ProtocolCo
  01494	00 00 00 00	 DD	 $LN258@ProtocolCo
  01498	00 00 00 00	 DD	 $LN256@ProtocolCo
  0149c	00 00 00 00	 DD	 $LN255@ProtocolCo
  014a0	00 00 00 00	 DD	 $LN87@ProtocolCo
  014a4	00 00 00 00	 DD	 $LN86@ProtocolCo
  014a8	00 00 00 00	 DD	 $LN253@ProtocolCo
  014ac	00 00 00 00	 DD	 $LN252@ProtocolCo
  014b0	00 00 00 00	 DD	 $LN251@ProtocolCo
  014b4	00 00 00 00	 DD	 $LN250@ProtocolCo
  014b8	00 00 00 00	 DD	 $LN249@ProtocolCo
  014bc	00 00 00 00	 DD	 $LN248@ProtocolCo
  014c0	00 00 00 00	 DD	 $LN247@ProtocolCo
  014c4	00 00 00 00	 DD	 $LN246@ProtocolCo
  014c8	00 00 00 00	 DD	 $LN245@ProtocolCo
  014cc	00 00 00 00	 DD	 $LN187@ProtocolCo
  014d0	00 00 00 00	 DD	 $LN315@ProtocolCo
  014d4	00 00 00 00	 DD	 $LN11@ProtocolCo
  014d8	00 00 00 00	 DD	 $LN7@ProtocolCo
  014dc	00 00 00 00	 DD	 $LN186@ProtocolCo
  014e0	00 00 00 00	 DD	 $LN185@ProtocolCo
  014e4	00 00 00 00	 DD	 $LN184@ProtocolCo
  014e8	00 00 00 00	 DD	 $LN183@ProtocolCo
  014ec	00 00 00 00	 DD	 $LN182@ProtocolCo
  014f0	00 00 00 00	 DD	 $LN181@ProtocolCo
  014f4	00 00 00 00	 DD	 $LN180@ProtocolCo
  014f8	00 00 00 00	 DD	 $LN179@ProtocolCo
  014fc	00 00 00 00	 DD	 $LN178@ProtocolCo
  01500	00 00 00 00	 DD	 $LN177@ProtocolCo
  01504	00 00 00 00	 DD	 $LN176@ProtocolCo
  01508	00 00 00 00	 DD	 $LN175@ProtocolCo
  0150c	00 00 00 00	 DD	 $LN174@ProtocolCo
  01510	00 00 00 00	 DD	 $LN166@ProtocolCo
  01514	00 00 00 00	 DD	 $LN344@ProtocolCo
  01518	00 00 00 00	 DD	 $LN163@ProtocolCo
  0151c	00 00 00 00	 DD	 $LN164@ProtocolCo
  01520	00 00 00 00	 DD	 $LN173@ProtocolCo
  01524	00 00 00 00	 DD	 $LN172@ProtocolCo
  01528	00 00 00 00	 DD	 $LN171@ProtocolCo
  0152c	00 00 00 00	 DD	 $LN170@ProtocolCo
  01530	00 00 00 00	 DD	 $LN169@ProtocolCo
  01534	00 00 00 00	 DD	 $LN168@ProtocolCo
  01538	00 00 00 00	 DD	 $LN167@ProtocolCo
  0153c	00 00 00 00	 DD	 $LN85@ProtocolCo
  01540	00 00 00 00	 DD	 $LN162@ProtocolCo
  01544	00 00 00 00	 DD	 $LN300@ProtocolCo
  01548	00 00 00 00	 DD	 $LN244@ProtocolCo
  0154c	00 00 00 00	 DD	 $LN239@ProtocolCo
  01550	00 00 00 00	 DD	 $LN220@ProtocolCo
  01554	00 00 00 00	 DD	 $LN219@ProtocolCo
  01558	00 00 00 00	 DD	 $LN218@ProtocolCo
  0155c	00 00 00 00	 DD	 $LN217@ProtocolCo
  01560	00 00 00 00	 DD	 $LN212@ProtocolCo
  01564	00 00 00 00	 DD	 $LN207@ProtocolCo
  01568	00 00 00 00	 DD	 $LN202@ProtocolCo
  0156c	00 00 00 00	 DD	 $LN118@ProtocolCo
  01570	00 00 00 00	 DD	 $LN157@ProtocolCo
  01574	00 00 00 00	 DD	 $LN156@ProtocolCo
  01578	00 00 00 00	 DD	 $LN155@ProtocolCo
  0157c	00 00 00 00	 DD	 $LN154@ProtocolCo
  01580	00 00 00 00	 DD	 $LN153@ProtocolCo
  01584	00 00 00 00	 DD	 $LN152@ProtocolCo
  01588	00 00 00 00	 DD	 $LN151@ProtocolCo
  0158c	00 00 00 00	 DD	 $LN150@ProtocolCo
  01590	00 00 00 00	 DD	 $LN149@ProtocolCo
  01594	00 00 00 00	 DD	 $LN148@ProtocolCo
  01598	00 00 00 00	 DD	 $LN147@ProtocolCo
  0159c	00 00 00 00	 DD	 $LN146@ProtocolCo
  015a0	00 00 00 00	 DD	 $LN137@ProtocolCo
  015a4	00 00 00 00	 DD	 $LN132@ProtocolCo
  015a8	00 00 00 00	 DD	 $LN309@ProtocolCo
  015ac	00 00 00 00	 DD	 $LN298@ProtocolCo
  015b0	00 00 00 00	 DD	 $LN196@ProtocolCo
  015b4	00 00 00 00	 DD	 $LN195@ProtocolCo
  015b8	00 00 00 00	 DD	 $LN194@ProtocolCo
  015bc	00 00 00 00	 DD	 $LN193@ProtocolCo
  015c0	00 00 00 00	 DD	 $LN192@ProtocolCo
  015c4	00 00 00 00	 DD	 $LN191@ProtocolCo
  015c8	00 00 00 00	 DD	 $LN99@ProtocolCo
  015cc	00 00 00 00	 DD	 $LN95@ProtocolCo
  015d0	00 00 00 00	 DD	 $LN84@ProtocolCo
  015d4	00 00 00 00	 DD	 $LN13@ProtocolCo
  015d8	00 00 00 00	 DD	 $LN12@ProtocolCo
  015dc	00 00 00 00	 DD	 $LN1@ProtocolCo
$LN357@ProtocolCo:
  015e0	00		 DB	 0
  015e1	01		 DB	 1
  015e2	02		 DB	 2
  015e3	03		 DB	 3
  015e4	6e		 DB	 110			; 0000006eH
  015e5	6e		 DB	 110			; 0000006eH
  015e6	6e		 DB	 110			; 0000006eH
  015e7	6e		 DB	 110			; 0000006eH
  015e8	6e		 DB	 110			; 0000006eH
  015e9	6e		 DB	 110			; 0000006eH
  015ea	6e		 DB	 110			; 0000006eH
  015eb	6e		 DB	 110			; 0000006eH
  015ec	6e		 DB	 110			; 0000006eH
  015ed	6e		 DB	 110			; 0000006eH
  015ee	04		 DB	 4
  015ef	6e		 DB	 110			; 0000006eH
  015f0	6e		 DB	 110			; 0000006eH
  015f1	05		 DB	 5
  015f2	6e		 DB	 110			; 0000006eH
  015f3	6e		 DB	 110			; 0000006eH
  015f4	6e		 DB	 110			; 0000006eH
  015f5	06		 DB	 6
  015f6	6e		 DB	 110			; 0000006eH
  015f7	6e		 DB	 110			; 0000006eH
  015f8	07		 DB	 7
  015f9	08		 DB	 8
  015fa	6e		 DB	 110			; 0000006eH
  015fb	09		 DB	 9
  015fc	0a		 DB	 10			; 0000000aH
  015fd	6e		 DB	 110			; 0000006eH
  015fe	0b		 DB	 11			; 0000000bH
  015ff	6e		 DB	 110			; 0000006eH
  01600	6e		 DB	 110			; 0000006eH
  01601	6e		 DB	 110			; 0000006eH
  01602	0c		 DB	 12			; 0000000cH
  01603	0d		 DB	 13			; 0000000dH
  01604	0e		 DB	 14			; 0000000eH
  01605	6e		 DB	 110			; 0000006eH
  01606	0f		 DB	 15			; 0000000fH
  01607	6e		 DB	 110			; 0000006eH
  01608	6e		 DB	 110			; 0000006eH
  01609	6e		 DB	 110			; 0000006eH
  0160a	6e		 DB	 110			; 0000006eH
  0160b	6e		 DB	 110			; 0000006eH
  0160c	6e		 DB	 110			; 0000006eH
  0160d	6e		 DB	 110			; 0000006eH
  0160e	6e		 DB	 110			; 0000006eH
  0160f	6e		 DB	 110			; 0000006eH
  01610	10		 DB	 16			; 00000010H
  01611	11		 DB	 17			; 00000011H
  01612	12		 DB	 18			; 00000012H
  01613	13		 DB	 19			; 00000013H
  01614	14		 DB	 20			; 00000014H
  01615	6e		 DB	 110			; 0000006eH
  01616	15		 DB	 21			; 00000015H
  01617	16		 DB	 22			; 00000016H
  01618	6e		 DB	 110			; 0000006eH
  01619	6e		 DB	 110			; 0000006eH
  0161a	17		 DB	 23			; 00000017H
  0161b	6e		 DB	 110			; 0000006eH
  0161c	18		 DB	 24			; 00000018H
  0161d	19		 DB	 25			; 00000019H
  0161e	6e		 DB	 110			; 0000006eH
  0161f	1a		 DB	 26			; 0000001aH
  01620	1b		 DB	 27			; 0000001bH
  01621	1c		 DB	 28			; 0000001cH
  01622	1d		 DB	 29			; 0000001dH
  01623	1e		 DB	 30			; 0000001eH
  01624	6e		 DB	 110			; 0000006eH
  01625	6e		 DB	 110			; 0000006eH
  01626	6e		 DB	 110			; 0000006eH
  01627	6e		 DB	 110			; 0000006eH
  01628	6e		 DB	 110			; 0000006eH
  01629	6e		 DB	 110			; 0000006eH
  0162a	1f		 DB	 31			; 0000001fH
  0162b	20		 DB	 32			; 00000020H
  0162c	6e		 DB	 110			; 0000006eH
  0162d	6e		 DB	 110			; 0000006eH
  0162e	6e		 DB	 110			; 0000006eH
  0162f	6e		 DB	 110			; 0000006eH
  01630	21		 DB	 33			; 00000021H
  01631	22		 DB	 34			; 00000022H
  01632	23		 DB	 35			; 00000023H
  01633	24		 DB	 36			; 00000024H
  01634	25		 DB	 37			; 00000025H
  01635	26		 DB	 38			; 00000026H
  01636	6e		 DB	 110			; 0000006eH
  01637	27		 DB	 39			; 00000027H
  01638	6e		 DB	 110			; 0000006eH
  01639	6e		 DB	 110			; 0000006eH
  0163a	6e		 DB	 110			; 0000006eH
  0163b	6e		 DB	 110			; 0000006eH
  0163c	6e		 DB	 110			; 0000006eH
  0163d	6e		 DB	 110			; 0000006eH
  0163e	6e		 DB	 110			; 0000006eH
  0163f	6e		 DB	 110			; 0000006eH
  01640	6e		 DB	 110			; 0000006eH
  01641	28		 DB	 40			; 00000028H
  01642	6e		 DB	 110			; 0000006eH
  01643	6e		 DB	 110			; 0000006eH
  01644	6e		 DB	 110			; 0000006eH
  01645	6e		 DB	 110			; 0000006eH
  01646	29		 DB	 41			; 00000029H
  01647	6e		 DB	 110			; 0000006eH
  01648	6e		 DB	 110			; 0000006eH
  01649	6e		 DB	 110			; 0000006eH
  0164a	6e		 DB	 110			; 0000006eH
  0164b	6e		 DB	 110			; 0000006eH
  0164c	6e		 DB	 110			; 0000006eH
  0164d	6e		 DB	 110			; 0000006eH
  0164e	6e		 DB	 110			; 0000006eH
  0164f	6e		 DB	 110			; 0000006eH
  01650	6e		 DB	 110			; 0000006eH
  01651	2a		 DB	 42			; 0000002aH
  01652	6e		 DB	 110			; 0000006eH
  01653	6e		 DB	 110			; 0000006eH
  01654	6e		 DB	 110			; 0000006eH
  01655	6e		 DB	 110			; 0000006eH
  01656	6e		 DB	 110			; 0000006eH
  01657	6e		 DB	 110			; 0000006eH
  01658	2b		 DB	 43			; 0000002bH
  01659	2c		 DB	 44			; 0000002cH
  0165a	6e		 DB	 110			; 0000006eH
  0165b	6e		 DB	 110			; 0000006eH
  0165c	6e		 DB	 110			; 0000006eH
  0165d	6e		 DB	 110			; 0000006eH
  0165e	6e		 DB	 110			; 0000006eH
  0165f	6e		 DB	 110			; 0000006eH
  01660	2d		 DB	 45			; 0000002dH
  01661	2e		 DB	 46			; 0000002eH
  01662	2f		 DB	 47			; 0000002fH
  01663	30		 DB	 48			; 00000030H
  01664	6e		 DB	 110			; 0000006eH
  01665	6e		 DB	 110			; 0000006eH
  01666	31		 DB	 49			; 00000031H
  01667	32		 DB	 50			; 00000032H
  01668	6e		 DB	 110			; 0000006eH
  01669	6e		 DB	 110			; 0000006eH
  0166a	6e		 DB	 110			; 0000006eH
  0166b	6e		 DB	 110			; 0000006eH
  0166c	6e		 DB	 110			; 0000006eH
  0166d	6e		 DB	 110			; 0000006eH
  0166e	33		 DB	 51			; 00000033H
  0166f	6e		 DB	 110			; 0000006eH
  01670	34		 DB	 52			; 00000034H
  01671	35		 DB	 53			; 00000035H
  01672	6e		 DB	 110			; 0000006eH
  01673	6e		 DB	 110			; 0000006eH
  01674	6e		 DB	 110			; 0000006eH
  01675	36		 DB	 54			; 00000036H
  01676	37		 DB	 55			; 00000037H
  01677	38		 DB	 56			; 00000038H
  01678	39		 DB	 57			; 00000039H
  01679	3a		 DB	 58			; 0000003aH
  0167a	3b		 DB	 59			; 0000003bH
  0167b	3c		 DB	 60			; 0000003cH
  0167c	6e		 DB	 110			; 0000006eH
  0167d	3d		 DB	 61			; 0000003dH
  0167e	6e		 DB	 110			; 0000006eH
  0167f	3e		 DB	 62			; 0000003eH
  01680	3f		 DB	 63			; 0000003fH
  01681	6e		 DB	 110			; 0000006eH
  01682	40		 DB	 64			; 00000040H
  01683	6e		 DB	 110			; 0000006eH
  01684	6e		 DB	 110			; 0000006eH
  01685	6e		 DB	 110			; 0000006eH
  01686	6e		 DB	 110			; 0000006eH
  01687	41		 DB	 65			; 00000041H
  01688	6e		 DB	 110			; 0000006eH
  01689	42		 DB	 66			; 00000042H
  0168a	43		 DB	 67			; 00000043H
  0168b	44		 DB	 68			; 00000044H
  0168c	45		 DB	 69			; 00000045H
  0168d	6e		 DB	 110			; 0000006eH
  0168e	46		 DB	 70			; 00000046H
  0168f	47		 DB	 71			; 00000047H
  01690	48		 DB	 72			; 00000048H
  01691	49		 DB	 73			; 00000049H
  01692	4a		 DB	 74			; 0000004aH
  01693	4b		 DB	 75			; 0000004bH
  01694	4c		 DB	 76			; 0000004cH
  01695	4d		 DB	 77			; 0000004dH
  01696	6e		 DB	 110			; 0000006eH
  01697	4e		 DB	 78			; 0000004eH
  01698	6e		 DB	 110			; 0000006eH
  01699	4f		 DB	 79			; 0000004fH
  0169a	6e		 DB	 110			; 0000006eH
  0169b	6e		 DB	 110			; 0000006eH
  0169c	50		 DB	 80			; 00000050H
  0169d	51		 DB	 81			; 00000051H
  0169e	6e		 DB	 110			; 0000006eH
  0169f	52		 DB	 82			; 00000052H
  016a0	53		 DB	 83			; 00000053H
  016a1	54		 DB	 84			; 00000054H
  016a2	55		 DB	 85			; 00000055H
  016a3	56		 DB	 86			; 00000056H
  016a4	57		 DB	 87			; 00000057H
  016a5	58		 DB	 88			; 00000058H
  016a6	6e		 DB	 110			; 0000006eH
  016a7	59		 DB	 89			; 00000059H
  016a8	5a		 DB	 90			; 0000005aH
  016a9	5b		 DB	 91			; 0000005bH
  016aa	5c		 DB	 92			; 0000005cH
  016ab	5d		 DB	 93			; 0000005dH
  016ac	6e		 DB	 110			; 0000006eH
  016ad	6e		 DB	 110			; 0000006eH
  016ae	6e		 DB	 110			; 0000006eH
  016af	6e		 DB	 110			; 0000006eH
  016b0	5e		 DB	 94			; 0000005eH
  016b1	5f		 DB	 95			; 0000005fH
  016b2	60		 DB	 96			; 00000060H
  016b3	6e		 DB	 110			; 0000006eH
  016b4	61		 DB	 97			; 00000061H
  016b5	6e		 DB	 110			; 0000006eH
  016b6	6e		 DB	 110			; 0000006eH
  016b7	6e		 DB	 110			; 0000006eH
  016b8	6e		 DB	 110			; 0000006eH
  016b9	6e		 DB	 110			; 0000006eH
  016ba	6e		 DB	 110			; 0000006eH
  016bb	62		 DB	 98			; 00000062H
  016bc	6e		 DB	 110			; 0000006eH
  016bd	6e		 DB	 110			; 0000006eH
  016be	6e		 DB	 110			; 0000006eH
  016bf	6e		 DB	 110			; 0000006eH
  016c0	6e		 DB	 110			; 0000006eH
  016c1	63		 DB	 99			; 00000063H
  016c2	64		 DB	 100			; 00000064H
  016c3	6e		 DB	 110			; 0000006eH
  016c4	6e		 DB	 110			; 0000006eH
  016c5	65		 DB	 101			; 00000065H
  016c6	66		 DB	 102			; 00000066H
  016c7	6e		 DB	 110			; 0000006eH
  016c8	6e		 DB	 110			; 0000006eH
  016c9	67		 DB	 103			; 00000067H
  016ca	6e		 DB	 110			; 0000006eH
  016cb	68		 DB	 104			; 00000068H
  016cc	6e		 DB	 110			; 0000006eH
  016cd	6e		 DB	 110			; 0000006eH
  016ce	6e		 DB	 110			; 0000006eH
  016cf	6e		 DB	 110			; 0000006eH
  016d0	6e		 DB	 110			; 0000006eH
  016d1	6e		 DB	 110			; 0000006eH
  016d2	6e		 DB	 110			; 0000006eH
  016d3	6e		 DB	 110			; 0000006eH
  016d4	6e		 DB	 110			; 0000006eH
  016d5	6e		 DB	 110			; 0000006eH
  016d6	3c		 DB	 60			; 0000003cH
  016d7	69		 DB	 105			; 00000069H
  016d8	6a		 DB	 106			; 0000006aH
  016d9	6e		 DB	 110			; 0000006eH
  016da	6e		 DB	 110			; 0000006eH
  016db	6b		 DB	 107			; 0000006bH
  016dc	6e		 DB	 110			; 0000006eH
  016dd	6c		 DB	 108			; 0000006cH
  016de	6d		 DB	 109			; 0000006dH
  016df	90		 npad	 1
$LN368@ProtocolCo:
  016e0	00 00 00 00	 DD	 $LN269@ProtocolCo
  016e4	00 00 00 00	 DD	 $LN266@ProtocolCo
  016e8	00 00 00 00	 DD	 $LN265@ProtocolCo
  016ec	00 00 00 00	 DD	 $LN344@ProtocolCo
  016f0	00 00 00 00	 DD	 $LN264@ProtocolCo
  016f4	00 00 00 00	 DD	 $LN263@ProtocolCo
$LN369@ProtocolCo:
  016f8	00 00 00 00	 DD	 $LN236@ProtocolCo
  016fc	00 00 00 00	 DD	 $LN235@ProtocolCo
  01700	00 00 00 00	 DD	 $LN234@ProtocolCo
  01704	00 00 00 00	 DD	 $LN233@ProtocolCo
  01708	00 00 00 00	 DD	 $LN232@ProtocolCo
  0170c	00 00 00 00	 DD	 $LN231@ProtocolCo
  01710	00 00 00 00	 DD	 $LN230@ProtocolCo
  01714	00 00 00 00	 DD	 $LN229@ProtocolCo
  01718	00 00 00 00	 DD	 $LN228@ProtocolCo
  0171c	00 00 00 00	 DD	 $LN227@ProtocolCo
  01720	00 00 00 00	 DD	 $LN226@ProtocolCo
  01724	00 00 00 00	 DD	 $LN225@ProtocolCo
  01728	00 00 00 00	 DD	 $LN224@ProtocolCo
  0172c	00 00 00 00	 DD	 $LN223@ProtocolCo
  01730	00 00 00 00	 DD	 $LN222@ProtocolCo
  01734	00 00 00 00	 DD	 $LN221@ProtocolCo
  01738	00 00 00 00	 DD	 $LN344@ProtocolCo
$LN358@ProtocolCo:
  0173c	00		 DB	 0
  0173d	01		 DB	 1
  0173e	02		 DB	 2
  0173f	03		 DB	 3
  01740	04		 DB	 4
  01741	05		 DB	 5
  01742	06		 DB	 6
  01743	07		 DB	 7
  01744	08		 DB	 8
  01745	09		 DB	 9
  01746	10		 DB	 16			; 00000010H
  01747	10		 DB	 16			; 00000010H
  01748	10		 DB	 16			; 00000010H
  01749	10		 DB	 16			; 00000010H
  0174a	10		 DB	 16			; 00000010H
  0174b	10		 DB	 16			; 00000010H
  0174c	0a		 DB	 10			; 0000000aH
  0174d	10		 DB	 16			; 00000010H
  0174e	0b		 DB	 11			; 0000000bH
  0174f	10		 DB	 16			; 00000010H
  01750	10		 DB	 16			; 00000010H
  01751	10		 DB	 16			; 00000010H
  01752	10		 DB	 16			; 00000010H
  01753	10		 DB	 16			; 00000010H
  01754	10		 DB	 16			; 00000010H
  01755	10		 DB	 16			; 00000010H
  01756	10		 DB	 16			; 00000010H
  01757	0c		 DB	 12			; 0000000cH
  01758	0d		 DB	 13			; 0000000dH
  01759	0e		 DB	 14			; 0000000eH
  0175a	10		 DB	 16			; 00000010H
  0175b	0f		 DB	 15			; 0000000fH
$LN370@ProtocolCo:
  0175c	00 00 00 00	 DD	 $LN141@ProtocolCo
  01760	00 00 00 00	 DD	 $LN140@ProtocolCo
  01764	00 00 00 00	 DD	 $LN138@ProtocolCo
  01768	00 00 00 00	 DD	 $LN139@ProtocolCo
  0176c	00 00 00 00	 DD	 $LN344@ProtocolCo
$LN359@ProtocolCo:
  01770	00		 DB	 0
  01771	01		 DB	 1
  01772	04		 DB	 4
  01773	02		 DB	 2
  01774	04		 DB	 4
  01775	04		 DB	 4
  01776	04		 DB	 4
  01777	04		 DB	 4
  01778	04		 DB	 4
  01779	03		 DB	 3
  0177a	8b ff		 npad	 2
$LN371@ProtocolCo:
  0177c	00 00 00 00	 DD	 $LN129@ProtocolCo
  01780	00 00 00 00	 DD	 $LN128@ProtocolCo
  01784	00 00 00 00	 DD	 $LN127@ProtocolCo
  01788	00 00 00 00	 DD	 $LN129@ProtocolCo
  0178c	00 00 00 00	 DD	 $LN125@ProtocolCo
  01790	00 00 00 00	 DD	 $LN344@ProtocolCo
  01794	00 00 00 00	 DD	 $LN344@ProtocolCo
  01798	00 00 00 00	 DD	 $LN344@ProtocolCo
  0179c	00 00 00 00	 DD	 $LN344@ProtocolCo
  017a0	00 00 00 00	 DD	 $LN344@ProtocolCo
  017a4	00 00 00 00	 DD	 $LN120@ProtocolCo
$LN372@ProtocolCo:
  017a8	00 00 00 00	 DD	 $LN115@ProtocolCo
  017ac	00 00 00 00	 DD	 $LN114@ProtocolCo
  017b0	00 00 00 00	 DD	 $LN113@ProtocolCo
  017b4	00 00 00 00	 DD	 $LN112@ProtocolCo
  017b8	00 00 00 00	 DD	 $LN111@ProtocolCo
  017bc	00 00 00 00	 DD	 $LN110@ProtocolCo
  017c0	00 00 00 00	 DD	 $LN108@ProtocolCo
  017c4	00 00 00 00	 DD	 $LN109@ProtocolCo
  017c8	00 00 00 00	 DD	 $LN107@ProtocolCo
  017cc	00 00 00 00	 DD	 $LN106@ProtocolCo
  017d0	00 00 00 00	 DD	 $LN344@ProtocolCo
$LN360@ProtocolCo:
  017d4	00		 DB	 0
  017d5	0a		 DB	 10			; 0000000aH
  017d6	01		 DB	 1
  017d7	0a		 DB	 10			; 0000000aH
  017d8	0a		 DB	 10			; 0000000aH
  017d9	02		 DB	 2
  017da	0a		 DB	 10			; 0000000aH
  017db	0a		 DB	 10			; 0000000aH
  017dc	0a		 DB	 10			; 0000000aH
  017dd	0a		 DB	 10			; 0000000aH
  017de	0a		 DB	 10			; 0000000aH
  017df	03		 DB	 3
  017e0	04		 DB	 4
  017e1	05		 DB	 5
  017e2	06		 DB	 6
  017e3	0a		 DB	 10			; 0000000aH
  017e4	0a		 DB	 10			; 0000000aH
  017e5	0a		 DB	 10			; 0000000aH
  017e6	0a		 DB	 10			; 0000000aH
  017e7	0a		 DB	 10			; 0000000aH
  017e8	0a		 DB	 10			; 0000000aH
  017e9	0a		 DB	 10			; 0000000aH
  017ea	0a		 DB	 10			; 0000000aH
  017eb	07		 DB	 7
  017ec	0a		 DB	 10			; 0000000aH
  017ed	0a		 DB	 10			; 0000000aH
  017ee	0a		 DB	 10			; 0000000aH
  017ef	0a		 DB	 10			; 0000000aH
  017f0	0a		 DB	 10			; 0000000aH
  017f1	0a		 DB	 10			; 0000000aH
  017f2	0a		 DB	 10			; 0000000aH
  017f3	0a		 DB	 10			; 0000000aH
  017f4	08		 DB	 8
  017f5	0a		 DB	 10			; 0000000aH
  017f6	0a		 DB	 10			; 0000000aH
  017f7	0a		 DB	 10			; 0000000aH
  017f8	0a		 DB	 10			; 0000000aH
  017f9	0a		 DB	 10			; 0000000aH
  017fa	0a		 DB	 10			; 0000000aH
  017fb	0a		 DB	 10			; 0000000aH
  017fc	0a		 DB	 10			; 0000000aH
  017fd	0a		 DB	 10			; 0000000aH
  017fe	0a		 DB	 10			; 0000000aH
  017ff	0a		 DB	 10			; 0000000aH
  01800	0a		 DB	 10			; 0000000aH
  01801	0a		 DB	 10			; 0000000aH
  01802	0a		 DB	 10			; 0000000aH
  01803	0a		 DB	 10			; 0000000aH
  01804	0a		 DB	 10			; 0000000aH
  01805	0a		 DB	 10			; 0000000aH
  01806	0a		 DB	 10			; 0000000aH
  01807	0a		 DB	 10			; 0000000aH
  01808	0a		 DB	 10			; 0000000aH
  01809	0a		 DB	 10			; 0000000aH
  0180a	0a		 DB	 10			; 0000000aH
  0180b	0a		 DB	 10			; 0000000aH
  0180c	0a		 DB	 10			; 0000000aH
  0180d	0a		 DB	 10			; 0000000aH
  0180e	0a		 DB	 10			; 0000000aH
  0180f	0a		 DB	 10			; 0000000aH
  01810	0a		 DB	 10			; 0000000aH
  01811	0a		 DB	 10			; 0000000aH
  01812	0a		 DB	 10			; 0000000aH
  01813	0a		 DB	 10			; 0000000aH
  01814	0a		 DB	 10			; 0000000aH
  01815	0a		 DB	 10			; 0000000aH
  01816	0a		 DB	 10			; 0000000aH
  01817	0a		 DB	 10			; 0000000aH
  01818	0a		 DB	 10			; 0000000aH
  01819	0a		 DB	 10			; 0000000aH
  0181a	0a		 DB	 10			; 0000000aH
  0181b	0a		 DB	 10			; 0000000aH
  0181c	0a		 DB	 10			; 0000000aH
  0181d	0a		 DB	 10			; 0000000aH
  0181e	0a		 DB	 10			; 0000000aH
  0181f	0a		 DB	 10			; 0000000aH
  01820	0a		 DB	 10			; 0000000aH
  01821	0a		 DB	 10			; 0000000aH
  01822	0a		 DB	 10			; 0000000aH
  01823	0a		 DB	 10			; 0000000aH
  01824	0a		 DB	 10			; 0000000aH
  01825	09		 DB	 9
  01826	8b ff		 npad	 2
$LN373@ProtocolCo:
  01828	00 00 00 00	 DD	 $LN91@ProtocolCo
  0182c	00 00 00 00	 DD	 $LN90@ProtocolCo
  01830	00 00 00 00	 DD	 $LN89@ProtocolCo
  01834	00 00 00 00	 DD	 $LN88@ProtocolCo
  01838	00 00 00 00	 DD	 $LN344@ProtocolCo
$LN361@ProtocolCo:
  0183c	00		 DB	 0
  0183d	04		 DB	 4
  0183e	01		 DB	 1
  0183f	04		 DB	 4
  01840	04		 DB	 4
  01841	04		 DB	 4
  01842	04		 DB	 4
  01843	04		 DB	 4
  01844	02		 DB	 2
  01845	04		 DB	 4
  01846	03		 DB	 3
  01847	90		 npad	 1
$LN374@ProtocolCo:
  01848	00 00 00 00	 DD	 $LN81@ProtocolCo
  0184c	00 00 00 00	 DD	 $LN79@ProtocolCo
  01850	00 00 00 00	 DD	 $LN77@ProtocolCo
  01854	00 00 00 00	 DD	 $LN76@ProtocolCo
  01858	00 00 00 00	 DD	 $LN75@ProtocolCo
  0185c	00 00 00 00	 DD	 $LN74@ProtocolCo
  01860	00 00 00 00	 DD	 $LN73@ProtocolCo
  01864	00 00 00 00	 DD	 $LN72@ProtocolCo
  01868	00 00 00 00	 DD	 $LN63@ProtocolCo
  0186c	00 00 00 00	 DD	 $LN71@ProtocolCo
  01870	00 00 00 00	 DD	 $LN69@ProtocolCo
  01874	00 00 00 00	 DD	 $LN26@ProtocolCo
  01878	00 00 00 00	 DD	 $LN68@ProtocolCo
  0187c	00 00 00 00	 DD	 $LN44@ProtocolCo
  01880	00 00 00 00	 DD	 $LN56@ProtocolCo
  01884	00 00 00 00	 DD	 $LN66@ProtocolCo
  01888	00 00 00 00	 DD	 $LN65@ProtocolCo
  0188c	00 00 00 00	 DD	 $LN64@ProtocolCo
  01890	00 00 00 00	 DD	 $LN61@ProtocolCo
  01894	00 00 00 00	 DD	 $LN60@ProtocolCo
  01898	00 00 00 00	 DD	 $LN55@ProtocolCo
  0189c	00 00 00 00	 DD	 $LN45@ProtocolCo
  018a0	00 00 00 00	 DD	 $LN59@ProtocolCo
  018a4	00 00 00 00	 DD	 $LN58@ProtocolCo
  018a8	00 00 00 00	 DD	 $LN57@ProtocolCo
  018ac	00 00 00 00	 DD	 $LN54@ProtocolCo
  018b0	00 00 00 00	 DD	 $LN51@ProtocolCo
  018b4	00 00 00 00	 DD	 $LN50@ProtocolCo
  018b8	00 00 00 00	 DD	 $LN49@ProtocolCo
  018bc	00 00 00 00	 DD	 $LN48@ProtocolCo
  018c0	00 00 00 00	 DD	 $LN46@ProtocolCo
  018c4	00 00 00 00	 DD	 $LN43@ProtocolCo
  018c8	00 00 00 00	 DD	 $LN42@ProtocolCo
  018cc	00 00 00 00	 DD	 $LN41@ProtocolCo
  018d0	00 00 00 00	 DD	 $LN40@ProtocolCo
  018d4	00 00 00 00	 DD	 $LN39@ProtocolCo
  018d8	00 00 00 00	 DD	 $LN38@ProtocolCo
  018dc	00 00 00 00	 DD	 $LN37@ProtocolCo
  018e0	00 00 00 00	 DD	 $LN36@ProtocolCo
  018e4	00 00 00 00	 DD	 $LN35@ProtocolCo
  018e8	00 00 00 00	 DD	 $LN34@ProtocolCo
  018ec	00 00 00 00	 DD	 $LN33@ProtocolCo
  018f0	00 00 00 00	 DD	 $LN32@ProtocolCo
  018f4	00 00 00 00	 DD	 $LN31@ProtocolCo
  018f8	00 00 00 00	 DD	 $LN30@ProtocolCo
  018fc	00 00 00 00	 DD	 $LN29@ProtocolCo
  01900	00 00 00 00	 DD	 $LN28@ProtocolCo
  01904	00 00 00 00	 DD	 $LN27@ProtocolCo
  01908	00 00 00 00	 DD	 $LN25@ProtocolCo
  0190c	00 00 00 00	 DD	 $LN24@ProtocolCo
  01910	00 00 00 00	 DD	 $LN23@ProtocolCo
  01914	00 00 00 00	 DD	 $LN22@ProtocolCo
  01918	00 00 00 00	 DD	 $LN21@ProtocolCo
  0191c	00 00 00 00	 DD	 $LN20@ProtocolCo
  01920	00 00 00 00	 DD	 $LN19@ProtocolCo
  01924	00 00 00 00	 DD	 $LN18@ProtocolCo
  01928	00 00 00 00	 DD	 $LN17@ProtocolCo
  0192c	00 00 00 00	 DD	 $LN16@ProtocolCo
  01930	00 00 00 00	 DD	 $LN15@ProtocolCo
  01934	00 00 00 00	 DD	 $LN14@ProtocolCo
  01938	00 00 00 00	 DD	 $LN53@ProtocolCo
  0193c	00 00 00 00	 DD	 $LN52@ProtocolCo
  01940	00 00 00 00	 DD	 $LN344@ProtocolCo
$LN362@ProtocolCo:
  01944	00		 DB	 0
  01945	3e		 DB	 62			; 0000003eH
  01946	3e		 DB	 62			; 0000003eH
  01947	01		 DB	 1
  01948	3e		 DB	 62			; 0000003eH
  01949	3e		 DB	 62			; 0000003eH
  0194a	3e		 DB	 62			; 0000003eH
  0194b	02		 DB	 2
  0194c	03		 DB	 3
  0194d	04		 DB	 4
  0194e	05		 DB	 5
  0194f	06		 DB	 6
  01950	07		 DB	 7
  01951	08		 DB	 8
  01952	09		 DB	 9
  01953	0a		 DB	 10			; 0000000aH
  01954	3e		 DB	 62			; 0000003eH
  01955	0b		 DB	 11			; 0000000bH
  01956	3e		 DB	 62			; 0000003eH
  01957	0c		 DB	 12			; 0000000cH
  01958	3e		 DB	 62			; 0000003eH
  01959	3e		 DB	 62			; 0000003eH
  0195a	0d		 DB	 13			; 0000000dH
  0195b	3e		 DB	 62			; 0000003eH
  0195c	3e		 DB	 62			; 0000003eH
  0195d	0e		 DB	 14			; 0000000eH
  0195e	0f		 DB	 15			; 0000000fH
  0195f	10		 DB	 16			; 00000010H
  01960	11		 DB	 17			; 00000011H
  01961	3e		 DB	 62			; 0000003eH
  01962	3e		 DB	 62			; 0000003eH
  01963	12		 DB	 18			; 00000012H
  01964	13		 DB	 19			; 00000013H
  01965	3e		 DB	 62			; 0000003eH
  01966	3e		 DB	 62			; 0000003eH
  01967	3e		 DB	 62			; 0000003eH
  01968	3e		 DB	 62			; 0000003eH
  01969	14		 DB	 20			; 00000014H
  0196a	15		 DB	 21			; 00000015H
  0196b	3e		 DB	 62			; 0000003eH
  0196c	3e		 DB	 62			; 0000003eH
  0196d	3e		 DB	 62			; 0000003eH
  0196e	3e		 DB	 62			; 0000003eH
  0196f	3e		 DB	 62			; 0000003eH
  01970	3e		 DB	 62			; 0000003eH
  01971	3e		 DB	 62			; 0000003eH
  01972	3e		 DB	 62			; 0000003eH
  01973	3e		 DB	 62			; 0000003eH
  01974	3e		 DB	 62			; 0000003eH
  01975	3e		 DB	 62			; 0000003eH
  01976	3e		 DB	 62			; 0000003eH
  01977	3e		 DB	 62			; 0000003eH
  01978	3e		 DB	 62			; 0000003eH
  01979	3e		 DB	 62			; 0000003eH
  0197a	3e		 DB	 62			; 0000003eH
  0197b	3e		 DB	 62			; 0000003eH
  0197c	3e		 DB	 62			; 0000003eH
  0197d	3e		 DB	 62			; 0000003eH
  0197e	3e		 DB	 62			; 0000003eH
  0197f	3e		 DB	 62			; 0000003eH
  01980	16		 DB	 22			; 00000016H
  01981	17		 DB	 23			; 00000017H
  01982	18		 DB	 24			; 00000018H
  01983	3e		 DB	 62			; 0000003eH
  01984	19		 DB	 25			; 00000019H
  01985	1a		 DB	 26			; 0000001aH
  01986	1b		 DB	 27			; 0000001bH
  01987	1c		 DB	 28			; 0000001cH
  01988	1d		 DB	 29			; 0000001dH
  01989	3e		 DB	 62			; 0000003eH
  0198a	3e		 DB	 62			; 0000003eH
  0198b	3e		 DB	 62			; 0000003eH
  0198c	3e		 DB	 62			; 0000003eH
  0198d	3e		 DB	 62			; 0000003eH
  0198e	3e		 DB	 62			; 0000003eH
  0198f	3e		 DB	 62			; 0000003eH
  01990	3e		 DB	 62			; 0000003eH
  01991	3e		 DB	 62			; 0000003eH
  01992	3e		 DB	 62			; 0000003eH
  01993	3e		 DB	 62			; 0000003eH
  01994	3e		 DB	 62			; 0000003eH
  01995	3e		 DB	 62			; 0000003eH
  01996	3e		 DB	 62			; 0000003eH
  01997	3e		 DB	 62			; 0000003eH
  01998	3e		 DB	 62			; 0000003eH
  01999	3e		 DB	 62			; 0000003eH
  0199a	3e		 DB	 62			; 0000003eH
  0199b	3e		 DB	 62			; 0000003eH
  0199c	3e		 DB	 62			; 0000003eH
  0199d	3e		 DB	 62			; 0000003eH
  0199e	3e		 DB	 62			; 0000003eH
  0199f	3e		 DB	 62			; 0000003eH
  019a0	3e		 DB	 62			; 0000003eH
  019a1	3e		 DB	 62			; 0000003eH
  019a2	3e		 DB	 62			; 0000003eH
  019a3	3e		 DB	 62			; 0000003eH
  019a4	3e		 DB	 62			; 0000003eH
  019a5	3e		 DB	 62			; 0000003eH
  019a6	3e		 DB	 62			; 0000003eH
  019a7	3e		 DB	 62			; 0000003eH
  019a8	3e		 DB	 62			; 0000003eH
  019a9	3e		 DB	 62			; 0000003eH
  019aa	3e		 DB	 62			; 0000003eH
  019ab	3e		 DB	 62			; 0000003eH
  019ac	3e		 DB	 62			; 0000003eH
  019ad	3e		 DB	 62			; 0000003eH
  019ae	3e		 DB	 62			; 0000003eH
  019af	3e		 DB	 62			; 0000003eH
  019b0	3e		 DB	 62			; 0000003eH
  019b1	3e		 DB	 62			; 0000003eH
  019b2	3e		 DB	 62			; 0000003eH
  019b3	3e		 DB	 62			; 0000003eH
  019b4	3e		 DB	 62			; 0000003eH
  019b5	3e		 DB	 62			; 0000003eH
  019b6	3e		 DB	 62			; 0000003eH
  019b7	3e		 DB	 62			; 0000003eH
  019b8	3e		 DB	 62			; 0000003eH
  019b9	3e		 DB	 62			; 0000003eH
  019ba	3e		 DB	 62			; 0000003eH
  019bb	3e		 DB	 62			; 0000003eH
  019bc	3e		 DB	 62			; 0000003eH
  019bd	3e		 DB	 62			; 0000003eH
  019be	3e		 DB	 62			; 0000003eH
  019bf	3e		 DB	 62			; 0000003eH
  019c0	3e		 DB	 62			; 0000003eH
  019c1	3e		 DB	 62			; 0000003eH
  019c2	3e		 DB	 62			; 0000003eH
  019c3	3e		 DB	 62			; 0000003eH
  019c4	1e		 DB	 30			; 0000001eH
  019c5	3e		 DB	 62			; 0000003eH
  019c6	3e		 DB	 62			; 0000003eH
  019c7	3e		 DB	 62			; 0000003eH
  019c8	3e		 DB	 62			; 0000003eH
  019c9	3e		 DB	 62			; 0000003eH
  019ca	3e		 DB	 62			; 0000003eH
  019cb	3e		 DB	 62			; 0000003eH
  019cc	3e		 DB	 62			; 0000003eH
  019cd	3e		 DB	 62			; 0000003eH
  019ce	3e		 DB	 62			; 0000003eH
  019cf	3e		 DB	 62			; 0000003eH
  019d0	3e		 DB	 62			; 0000003eH
  019d1	3e		 DB	 62			; 0000003eH
  019d2	3e		 DB	 62			; 0000003eH
  019d3	3e		 DB	 62			; 0000003eH
  019d4	3e		 DB	 62			; 0000003eH
  019d5	3e		 DB	 62			; 0000003eH
  019d6	3e		 DB	 62			; 0000003eH
  019d7	3e		 DB	 62			; 0000003eH
  019d8	1f		 DB	 31			; 0000001fH
  019d9	20		 DB	 32			; 00000020H
  019da	3e		 DB	 62			; 0000003eH
  019db	3e		 DB	 62			; 0000003eH
  019dc	3e		 DB	 62			; 0000003eH
  019dd	3e		 DB	 62			; 0000003eH
  019de	3e		 DB	 62			; 0000003eH
  019df	3e		 DB	 62			; 0000003eH
  019e0	3e		 DB	 62			; 0000003eH
  019e1	3e		 DB	 62			; 0000003eH
  019e2	3e		 DB	 62			; 0000003eH
  019e3	21		 DB	 33			; 00000021H
  019e4	22		 DB	 34			; 00000022H
  019e5	23		 DB	 35			; 00000023H
  019e6	24		 DB	 36			; 00000024H
  019e7	25		 DB	 37			; 00000025H
  019e8	3e		 DB	 62			; 0000003eH
  019e9	3e		 DB	 62			; 0000003eH
  019ea	3e		 DB	 62			; 0000003eH
  019eb	3e		 DB	 62			; 0000003eH
  019ec	3e		 DB	 62			; 0000003eH
  019ed	3e		 DB	 62			; 0000003eH
  019ee	3e		 DB	 62			; 0000003eH
  019ef	3e		 DB	 62			; 0000003eH
  019f0	3e		 DB	 62			; 0000003eH
  019f1	3e		 DB	 62			; 0000003eH
  019f2	26		 DB	 38			; 00000026H
  019f3	27		 DB	 39			; 00000027H
  019f4	28		 DB	 40			; 00000028H
  019f5	29		 DB	 41			; 00000029H
  019f6	2a		 DB	 42			; 0000002aH
  019f7	3e		 DB	 62			; 0000003eH
  019f8	2b		 DB	 43			; 0000002bH
  019f9	2c		 DB	 44			; 0000002cH
  019fa	2d		 DB	 45			; 0000002dH
  019fb	2e		 DB	 46			; 0000002eH
  019fc	3e		 DB	 62			; 0000003eH
  019fd	2f		 DB	 47			; 0000002fH
  019fe	3e		 DB	 62			; 0000003eH
  019ff	3e		 DB	 62			; 0000003eH
  01a00	3e		 DB	 62			; 0000003eH
  01a01	3e		 DB	 62			; 0000003eH
  01a02	30		 DB	 48			; 00000030H
  01a03	3e		 DB	 62			; 0000003eH
  01a04	31		 DB	 49			; 00000031H
  01a05	32		 DB	 50			; 00000032H
  01a06	3e		 DB	 62			; 0000003eH
  01a07	3e		 DB	 62			; 0000003eH
  01a08	3e		 DB	 62			; 0000003eH
  01a09	3e		 DB	 62			; 0000003eH
  01a0a	3e		 DB	 62			; 0000003eH
  01a0b	3e		 DB	 62			; 0000003eH
  01a0c	3e		 DB	 62			; 0000003eH
  01a0d	3e		 DB	 62			; 0000003eH
  01a0e	3e		 DB	 62			; 0000003eH
  01a0f	3e		 DB	 62			; 0000003eH
  01a10	3e		 DB	 62			; 0000003eH
  01a11	3e		 DB	 62			; 0000003eH
  01a12	3e		 DB	 62			; 0000003eH
  01a13	3e		 DB	 62			; 0000003eH
  01a14	3e		 DB	 62			; 0000003eH
  01a15	3e		 DB	 62			; 0000003eH
  01a16	33		 DB	 51			; 00000033H
  01a17	3e		 DB	 62			; 0000003eH
  01a18	3e		 DB	 62			; 0000003eH
  01a19	3e		 DB	 62			; 0000003eH
  01a1a	34		 DB	 52			; 00000034H
  01a1b	35		 DB	 53			; 00000035H
  01a1c	3e		 DB	 62			; 0000003eH
  01a1d	36		 DB	 54			; 00000036H
  01a1e	3e		 DB	 62			; 0000003eH
  01a1f	3e		 DB	 62			; 0000003eH
  01a20	3e		 DB	 62			; 0000003eH
  01a21	37		 DB	 55			; 00000037H
  01a22	3e		 DB	 62			; 0000003eH
  01a23	3e		 DB	 62			; 0000003eH
  01a24	38		 DB	 56			; 00000038H
  01a25	39		 DB	 57			; 00000039H
  01a26	3e		 DB	 62			; 0000003eH
  01a27	3e		 DB	 62			; 0000003eH
  01a28	3e		 DB	 62			; 0000003eH
  01a29	3e		 DB	 62			; 0000003eH
  01a2a	3e		 DB	 62			; 0000003eH
  01a2b	3e		 DB	 62			; 0000003eH
  01a2c	3e		 DB	 62			; 0000003eH
  01a2d	3a		 DB	 58			; 0000003aH
  01a2e	3e		 DB	 62			; 0000003eH
  01a2f	3b		 DB	 59			; 0000003bH
  01a30	3e		 DB	 62			; 0000003eH
  01a31	3e		 DB	 62			; 0000003eH
  01a32	3e		 DB	 62			; 0000003eH
  01a33	3e		 DB	 62			; 0000003eH
  01a34	3e		 DB	 62			; 0000003eH
  01a35	3e		 DB	 62			; 0000003eH
  01a36	3e		 DB	 62			; 0000003eH
  01a37	3e		 DB	 62			; 0000003eH
  01a38	3e		 DB	 62			; 0000003eH
  01a39	3e		 DB	 62			; 0000003eH
  01a3a	3e		 DB	 62			; 0000003eH
  01a3b	3e		 DB	 62			; 0000003eH
  01a3c	3e		 DB	 62			; 0000003eH
  01a3d	3e		 DB	 62			; 0000003eH
  01a3e	3e		 DB	 62			; 0000003eH
  01a3f	3e		 DB	 62			; 0000003eH
  01a40	3e		 DB	 62			; 0000003eH
  01a41	3c		 DB	 60			; 0000003cH
  01a42	3d		 DB	 61			; 0000003dH
  01a43	90		 npad	 1
$LN375@ProtocolCo:
  01a44	00 00 00 00	 DD	 $LN328@ProtocolCo
  01a48	00 00 00 00	 DD	 $LN327@ProtocolCo
  01a4c	00 00 00 00	 DD	 $LN326@ProtocolCo
  01a50	00 00 00 00	 DD	 $LN325@ProtocolCo
  01a54	00 00 00 00	 DD	 $LN324@ProtocolCo
  01a58	00 00 00 00	 DD	 $LN323@ProtocolCo
  01a5c	00 00 00 00	 DD	 $LN322@ProtocolCo
  01a60	00 00 00 00	 DD	 $LN321@ProtocolCo
  01a64	00 00 00 00	 DD	 $LN320@ProtocolCo
  01a68	00 00 00 00	 DD	 $LN319@ProtocolCo
  01a6c	00 00 00 00	 DD	 $LN344@ProtocolCo
$LN363@ProtocolCo:
  01a70	00		 DB	 0
  01a71	01		 DB	 1
  01a72	02		 DB	 2
  01a73	03		 DB	 3
  01a74	0a		 DB	 10			; 0000000aH
  01a75	0a		 DB	 10			; 0000000aH
  01a76	04		 DB	 4
  01a77	0a		 DB	 10			; 0000000aH
  01a78	0a		 DB	 10			; 0000000aH
  01a79	0a		 DB	 10			; 0000000aH
  01a7a	0a		 DB	 10			; 0000000aH
  01a7b	0a		 DB	 10			; 0000000aH
  01a7c	0a		 DB	 10			; 0000000aH
  01a7d	0a		 DB	 10			; 0000000aH
  01a7e	0a		 DB	 10			; 0000000aH
  01a7f	0a		 DB	 10			; 0000000aH
  01a80	0a		 DB	 10			; 0000000aH
  01a81	0a		 DB	 10			; 0000000aH
  01a82	05		 DB	 5
  01a83	0a		 DB	 10			; 0000000aH
  01a84	0a		 DB	 10			; 0000000aH
  01a85	06		 DB	 6
  01a86	07		 DB	 7
  01a87	0a		 DB	 10			; 0000000aH
  01a88	0a		 DB	 10			; 0000000aH
  01a89	0a		 DB	 10			; 0000000aH
  01a8a	0a		 DB	 10			; 0000000aH
  01a8b	0a		 DB	 10			; 0000000aH
  01a8c	0a		 DB	 10			; 0000000aH
  01a8d	0a		 DB	 10			; 0000000aH
  01a8e	0a		 DB	 10			; 0000000aH
  01a8f	0a		 DB	 10			; 0000000aH
  01a90	0a		 DB	 10			; 0000000aH
  01a91	0a		 DB	 10			; 0000000aH
  01a92	0a		 DB	 10			; 0000000aH
  01a93	0a		 DB	 10			; 0000000aH
  01a94	0a		 DB	 10			; 0000000aH
  01a95	0a		 DB	 10			; 0000000aH
  01a96	0a		 DB	 10			; 0000000aH
  01a97	0a		 DB	 10			; 0000000aH
  01a98	0a		 DB	 10			; 0000000aH
  01a99	0a		 DB	 10			; 0000000aH
  01a9a	0a		 DB	 10			; 0000000aH
  01a9b	0a		 DB	 10			; 0000000aH
  01a9c	0a		 DB	 10			; 0000000aH
  01a9d	0a		 DB	 10			; 0000000aH
  01a9e	0a		 DB	 10			; 0000000aH
  01a9f	0a		 DB	 10			; 0000000aH
  01aa0	08		 DB	 8
  01aa1	0a		 DB	 10			; 0000000aH
  01aa2	0a		 DB	 10			; 0000000aH
  01aa3	0a		 DB	 10			; 0000000aH
  01aa4	0a		 DB	 10			; 0000000aH
  01aa5	0a		 DB	 10			; 0000000aH
  01aa6	0a		 DB	 10			; 0000000aH
  01aa7	0a		 DB	 10			; 0000000aH
  01aa8	0a		 DB	 10			; 0000000aH
  01aa9	0a		 DB	 10			; 0000000aH
  01aaa	0a		 DB	 10			; 0000000aH
  01aab	0a		 DB	 10			; 0000000aH
  01aac	0a		 DB	 10			; 0000000aH
  01aad	0a		 DB	 10			; 0000000aH
  01aae	0a		 DB	 10			; 0000000aH
  01aaf	0a		 DB	 10			; 0000000aH
  01ab0	0a		 DB	 10			; 0000000aH
  01ab1	0a		 DB	 10			; 0000000aH
  01ab2	0a		 DB	 10			; 0000000aH
  01ab3	0a		 DB	 10			; 0000000aH
  01ab4	0a		 DB	 10			; 0000000aH
  01ab5	0a		 DB	 10			; 0000000aH
  01ab6	0a		 DB	 10			; 0000000aH
  01ab7	0a		 DB	 10			; 0000000aH
  01ab8	0a		 DB	 10			; 0000000aH
  01ab9	0a		 DB	 10			; 0000000aH
  01aba	0a		 DB	 10			; 0000000aH
  01abb	0a		 DB	 10			; 0000000aH
  01abc	0a		 DB	 10			; 0000000aH
  01abd	0a		 DB	 10			; 0000000aH
  01abe	0a		 DB	 10			; 0000000aH
  01abf	0a		 DB	 10			; 0000000aH
  01ac0	0a		 DB	 10			; 0000000aH
  01ac1	0a		 DB	 10			; 0000000aH
  01ac2	09		 DB	 9
?ProtocolCore@@YAXEPAEHHHH@Z ENDP			; ProtocolCore
_TEXT	ENDS
PUBLIC	??_C@_06JGBJPOPP@Global?$AA@			; `string'
PUBLIC	??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@		; `string'
EXTRN	_atexit:PROC
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
;	COMDAT ??_C@_06JGBJPOPP@Global?$AA@
CONST	SEGMENT
??_C@_06JGBJPOPP@Global?$AA@ DB 'Global', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
CONST	SEGMENT
??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@ DB '.\LOG\Chat', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_GMChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_GMChatLog@@YAXXZ PROC				; `dynamic initializer for 'g_GMChatLog'', COMDAT

; 177  : CLogToFile g_GMChatLog("Global", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_06JGBJPOPP@Global?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GMChatLog@@3VCLogToFile@@A ; g_GMChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_GMChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_GMChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_GMChatLog@@YAXXZ ENDP				; `dynamic initializer for 'g_GMChatLog''
text$yc	ENDS
PUBLIC	??_C@_04HPGPEKIH@Post?$AA@			; `string'
;	COMDAT ??_C@_04HPGPEKIH@Post?$AA@
CONST	SEGMENT
??_C@_04HPGPEKIH@Post?$AA@ DB 'Post', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_PostLog@@YAXXZ
text$yc	SEGMENT
??__Eg_PostLog@@YAXXZ PROC				; `dynamic initializer for 'g_PostLog'', COMDAT

; 178  : CLogToFile g_PostLog("Post", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_04HPGPEKIH@Post?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PostLog@@3VCLogToFile@@A ; g_PostLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_PostLog@@YAXXZ ; `dynamic atexit destructor for 'g_PostLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_PostLog@@YAXXZ ENDP				; `dynamic initializer for 'g_PostLog''
text$yc	ENDS
PUBLIC	??_C@_04JJKNEHJF@Gens?$AA@			; `string'
;	COMDAT ??_C@_04JJKNEHJF@Gens?$AA@
CONST	SEGMENT
??_C@_04JJKNEHJF@Gens?$AA@ DB 'Gens', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_GensChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_GensChatLog@@YAXXZ PROC				; `dynamic initializer for 'g_GensChatLog'', COMDAT

; 179  : CLogToFile g_GensChatLog("Gens", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_04JJKNEHJF@Gens?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GensChatLog@@3VCLogToFile@@A ; g_GensChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_GensChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_GensChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_GensChatLog@@YAXXZ ENDP				; `dynamic initializer for 'g_GensChatLog''
text$yc	ENDS
PUBLIC	??_C@_05GLCACPFJ@Guild?$AA@			; `string'
;	COMDAT ??_C@_05GLCACPFJ@Guild?$AA@
CONST	SEGMENT
??_C@_05GLCACPFJ@Guild?$AA@ DB 'Guild', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_GuildChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_GuildChatLog@@YAXXZ PROC				; `dynamic initializer for 'g_GuildChatLog'', COMDAT

; 180  : CLogToFile g_GuildChatLog("Guild", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_05GLCACPFJ@Guild?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildChatLog@@3VCLogToFile@@A ; g_GuildChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_GuildChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_GuildChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_GuildChatLog@@YAXXZ ENDP				; `dynamic initializer for 'g_GuildChatLog''
text$yc	ENDS
PUBLIC	??_C@_08BJAGAFLE@Alliance?$AA@			; `string'
;	COMDAT ??_C@_08BJAGAFLE@Alliance?$AA@
CONST	SEGMENT
??_C@_08BJAGAFLE@Alliance?$AA@ DB 'Alliance', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_AllianceChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_AllianceChatLog@@YAXXZ PROC			; `dynamic initializer for 'g_AllianceChatLog'', COMDAT

; 181  : CLogToFile g_AllianceChatLog("Alliance", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_08BJAGAFLE@Alliance?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AllianceChatLog@@3VCLogToFile@@A ; g_AllianceChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_AllianceChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_AllianceChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_AllianceChatLog@@YAXXZ ENDP			; `dynamic initializer for 'g_AllianceChatLog''
text$yc	ENDS
PUBLIC	??_C@_07CFINJGKH@Private?$AA@			; `string'
;	COMDAT ??_C@_07CFINJGKH@Private?$AA@
CONST	SEGMENT
??_C@_07CFINJGKH@Private?$AA@ DB 'Private', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_PrivateChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_PrivateChatLog@@YAXXZ PROC			; `dynamic initializer for 'g_PrivateChatLog'', COMDAT

; 182  : CLogToFile g_PrivateChatLog("Private", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_07CFINJGKH@Private?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PrivateChatLog@@3VCLogToFile@@A ; g_PrivateChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_PrivateChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_PrivateChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_PrivateChatLog@@YAXXZ ENDP			; `dynamic initializer for 'g_PrivateChatLog''
text$yc	ENDS
PUBLIC	??_C@_05IKNCGCHC@Party?$AA@			; `string'
;	COMDAT ??_C@_05IKNCGCHC@Party?$AA@
CONST	SEGMENT
??_C@_05IKNCGCHC@Party?$AA@ DB 'Party', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_PartyChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_PartyChatLog@@YAXXZ PROC				; `dynamic initializer for 'g_PartyChatLog'', COMDAT

; 183  : CLogToFile g_PartyChatLog("Party", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_05IKNCGCHC@Party?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PartyChatLog@@3VCLogToFile@@A ; g_PartyChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_PartyChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_PartyChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_PartyChatLog@@YAXXZ ENDP				; `dynamic initializer for 'g_PartyChatLog''
text$yc	ENDS
PUBLIC	??_C@_05BBOGGNLJ@Other?$AA@			; `string'
;	COMDAT ??_C@_05BBOGGNLJ@Other?$AA@
CONST	SEGMENT
??_C@_05BBOGGNLJ@Other?$AA@ DB 'Other', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__Eg_OtherChatLog@@YAXXZ
text$yc	SEGMENT
??__Eg_OtherChatLog@@YAXXZ PROC				; `dynamic initializer for 'g_OtherChatLog'', COMDAT

; 184  : CLogToFile g_OtherChatLog("Other", ".\\LOG\\Chat", TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DCMGMPLN@?4?2LOG?2Chat?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_05BBOGGNLJ@Other?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OtherChatLog@@3VCLogToFile@@A ; g_OtherChatLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_OtherChatLog@@YAXXZ ; `dynamic atexit destructor for 'g_OtherChatLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_OtherChatLog@@YAXXZ ENDP				; `dynamic initializer for 'g_OtherChatLog''
text$yc	ENDS
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_GMChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_GMChatLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_GMChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GMChatLog@@3VCLogToFile@@A ; g_GMChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_GMChatLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_GMChatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_PostLog@@YAXXZ
text$yd	SEGMENT
??__Fg_PostLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_PostLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PostLog@@3VCLogToFile@@A ; g_PostLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_PostLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_PostLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_GensChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_GensChatLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_GensChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GensChatLog@@3VCLogToFile@@A ; g_GensChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_GensChatLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_GensChatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_GuildChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_GuildChatLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_GuildChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildChatLog@@3VCLogToFile@@A ; g_GuildChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_GuildChatLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_GuildChatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_AllianceChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_AllianceChatLog@@YAXXZ PROC			; `dynamic atexit destructor for 'g_AllianceChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_AllianceChatLog@@3VCLogToFile@@A ; g_AllianceChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_AllianceChatLog@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_AllianceChatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_PrivateChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_PrivateChatLog@@YAXXZ PROC			; `dynamic atexit destructor for 'g_PrivateChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PrivateChatLog@@3VCLogToFile@@A ; g_PrivateChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_PrivateChatLog@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_PrivateChatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_PartyChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_PartyChatLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_PartyChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PartyChatLog@@3VCLogToFile@@A ; g_PartyChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_PartyChatLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_PartyChatLog''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_OtherChatLog@@YAXXZ
text$yd	SEGMENT
??__Fg_OtherChatLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_OtherChatLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_OtherChatLog@@3VCLogToFile@@A ; g_OtherChatLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_OtherChatLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_OtherChatLog''
text$yd	ENDS
PUBLIC	?g_OtherChatLog@@3VCLogToFile@@A		; g_OtherChatLog
PUBLIC	?g_PartyChatLog@@3VCLogToFile@@A		; g_PartyChatLog
PUBLIC	?g_PrivateChatLog@@3VCLogToFile@@A		; g_PrivateChatLog
PUBLIC	?g_AllianceChatLog@@3VCLogToFile@@A		; g_AllianceChatLog
PUBLIC	?g_GuildChatLog@@3VCLogToFile@@A		; g_GuildChatLog
PUBLIC	?g_GensChatLog@@3VCLogToFile@@A			; g_GensChatLog
PUBLIC	?g_PostLog@@3VCLogToFile@@A			; g_PostLog
PUBLIC	?g_GMChatLog@@3VCLogToFile@@A			; g_GMChatLog
_BSS	SEGMENT
?g_OtherChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_OtherChatLog
?g_PartyChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_PartyChatLog
?g_PrivateChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_PrivateChatLog
?g_AllianceChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_AllianceChatLog
?g_GuildChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_GuildChatLog
?g_GensChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_GensChatLog
?g_PostLog@@3VCLogToFile@@A DB 010228H DUP (?)		; g_PostLog
?g_GMChatLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_GMChatLog
_BSS	ENDS
CRT$XCU	SEGMENT
_g_GMChatLog$initializer$ DD FLAT:??__Eg_GMChatLog@@YAXXZ
_g_PostLog$initializer$ DD FLAT:??__Eg_PostLog@@YAXXZ
_g_GensChatLog$initializer$ DD FLAT:??__Eg_GensChatLog@@YAXXZ
_g_GuildChatLog$initializer$ DD FLAT:??__Eg_GuildChatLog@@YAXXZ
_g_AllianceChatLog$initializer$ DD FLAT:??__Eg_AllianceChatLog@@YAXXZ
_g_PrivateChatLog$initializer$ DD FLAT:??__Eg_PrivateChatLog@@YAXXZ
_g_PartyChatLog$initializer$ DD FLAT:??__Eg_PartyChatLog@@YAXXZ
_g_OtherChatLog$initializer$ DD FLAT:??__Eg_OtherChatLog@@YAXXZ
CRT$XCU	ENDS
END
