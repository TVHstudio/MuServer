; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	E:\work\tranet_version\GS\GameServer\zzzmathlib.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?vec3_origin@@3PAMA				; vec3_origin
_BSS	SEGMENT
?vec3_origin@@3PAMA DD 03H DUP (?)			; vec3_origin
_BSS	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	_Q_rint
EXTRN	__fltused:DWORD
EXTRN	_floor:PROC
;	COMDAT __real@3fe0000000000000
; File e:\work\tranet_version\gs\gameserver\zzzmathlib.cpp
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _Q_rint
_TEXT	SEGMENT
tv70 = 8						; size = 4
_in$ = 8						; size = 4
_Q_rint	PROC						; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	return (vec_t)floor (in + 0.5);

  00003	d9 45 08	 fld	 DWORD PTR _in$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  0000f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00012	e8 00 00 00 00	 call	 _floor
  00017	d9 5d 08	 fstp	 DWORD PTR tv70[ebp]
  0001a	83 c4 08	 add	 esp, 8
  0001d	d9 45 08	 fld	 DWORD PTR tv70[ebp]

; 57   : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_Q_rint	ENDP
_TEXT	ENDS
PUBLIC	_VectorMA
; Function compile flags: /Ogtp
;	COMDAT _VectorMA
_TEXT	SEGMENT
_va$ = 8						; size = 4
_scale$ = 12						; size = 4
_vb$ = 16						; size = 4
_vc$ = 20						; size = 4
_VectorMA PROC						; COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   : 	vc[0] = va[0] + scale*vb[0];

  00003	8b 45 10	 mov	 eax, DWORD PTR _vb$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _va$[ebp]
  0000b	d9 45 0c	 fld	 DWORD PTR _scale$[ebp]
  0000e	8b 55 14	 mov	 edx, DWORD PTR _vc$[ebp]
  00011	d9 c0		 fld	 ST(0)
  00013	de ca		 fmulp	 ST(2), ST(0)
  00015	d9 01		 fld	 DWORD PTR [ecx]
  00017	de c2		 faddp	 ST(2), ST(0)
  00019	d9 c9		 fxch	 ST(1)
  0001b	d9 1a		 fstp	 DWORD PTR [edx]

; 62   : 	vc[1] = va[1] + scale*vb[1];

  0001d	d9 40 04	 fld	 DWORD PTR [eax+4]
  00020	d8 c9		 fmul	 ST(0), ST(1)
  00022	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00025	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 63   : 	vc[2] = va[2] + scale*vb[2];

  00028	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0002b	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  0002e	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 64   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_VectorMA ENDP
_TEXT	ENDS
PUBLIC	_CrossProduct
; Function compile flags: /Ogtp
;	COMDAT _CrossProduct
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_cross$ = 16						; size = 4
_CrossProduct PROC					; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];

  00003	8b 45 08	 mov	 eax, DWORD PTR _v1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _v2$[ebp]
  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _cross$[ebp]
  00012	d9 40 08	 fld	 DWORD PTR [eax+8]
  00015	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00018	de e9		 fsubp	 ST(1), ST(0)
  0001a	d9 1a		 fstp	 DWORD PTR [edx]

; 69   : 	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];

  0001c	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001f	d8 09		 fmul	 DWORD PTR [ecx]
  00021	d9 00		 fld	 DWORD PTR [eax]
  00023	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00026	de e9		 fsubp	 ST(1), ST(0)
  00028	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 70   : 	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];

  0002b	d9 00		 fld	 DWORD PTR [eax]
  0002d	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00030	d9 01		 fld	 DWORD PTR [ecx]
  00032	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00035	de e9		 fsubp	 ST(1), ST(0)
  00037	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 71   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_CrossProduct ENDP
_TEXT	ENDS
PUBLIC	__DotProduct
; Function compile flags: /Ogtp
;	COMDAT __DotProduct
_TEXT	SEGMENT
tv156 = 8						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
__DotProduct PROC					; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];

  00003	8b 45 08	 mov	 eax, DWORD PTR _v1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _v2$[ebp]
  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0000f	d9 00		 fld	 DWORD PTR [eax]
  00011	d8 09		 fmul	 DWORD PTR [ecx]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 40 08	 fld	 DWORD PTR [eax+8]
  00018	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0001b	de c1		 faddp	 ST(1), ST(0)
  0001d	d9 5d 08	 fstp	 DWORD PTR tv156[ebp]
  00020	d9 45 08	 fld	 DWORD PTR tv156[ebp]

; 76   : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
__DotProduct ENDP
_TEXT	ENDS
PUBLIC	__VectorSubtract
; Function compile flags: /Ogtp
;	COMDAT __VectorSubtract
_TEXT	SEGMENT
_va$ = 8						; size = 4
_vb$ = 12						; size = 4
_out$ = 16						; size = 4
__VectorSubtract PROC					; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   : 	out[0] = va[0]-vb[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _va$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _vb$[ebp]
  0000b	d8 21		 fsub	 DWORD PTR [ecx]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00010	d9 1a		 fstp	 DWORD PTR [edx]

; 81   : 	out[1] = va[1]-vb[1];

  00012	d9 40 04	 fld	 DWORD PTR [eax+4]
  00015	d8 61 04	 fsub	 DWORD PTR [ecx+4]
  00018	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 82   : 	out[2] = va[2]-vb[2];

  0001b	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001e	d8 61 08	 fsub	 DWORD PTR [ecx+8]
  00021	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 83   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__VectorSubtract ENDP
_TEXT	ENDS
PUBLIC	__VectorAdd
; Function compile flags: /Ogtp
;	COMDAT __VectorAdd
_TEXT	SEGMENT
_va$ = 8						; size = 4
_vb$ = 12						; size = 4
_out$ = 16						; size = 4
__VectorAdd PROC					; COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	out[0] = va[0]+vb[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _va$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _vb$[ebp]
  0000b	d8 01		 fadd	 DWORD PTR [ecx]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00010	d9 1a		 fstp	 DWORD PTR [edx]

; 88   : 	out[1] = va[1]+vb[1];

  00012	d9 40 04	 fld	 DWORD PTR [eax+4]
  00015	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00018	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 89   : 	out[2] = va[2]+vb[2];

  0001b	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001e	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  00021	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 90   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__VectorAdd ENDP
_TEXT	ENDS
PUBLIC	__VectorCopy
; Function compile flags: /Ogtp
;	COMDAT __VectorCopy
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
__VectorCopy PROC					; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   : 	out[0] = in[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0000b	d9 19		 fstp	 DWORD PTR [ecx]

; 95   : 	out[1] = in[1];

  0000d	d9 40 04	 fld	 DWORD PTR [eax+4]
  00010	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 96   : 	out[2] = in[2];

  00013	d9 40 08	 fld	 DWORD PTR [eax+8]
  00016	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 97   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
__VectorCopy ENDP
_TEXT	ENDS
PUBLIC	__VectorScale
; Function compile flags: /Ogtp
;	COMDAT __VectorScale
_TEXT	SEGMENT
_v$ = 8							; size = 4
_scale$ = 12						; size = 4
_out$ = 16						; size = 4
__VectorScale PROC					; COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 101  : 	out[0] = v[0] * scale;

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  0000b	d9 45 0c	 fld	 DWORD PTR _scale$[ebp]
  0000e	d9 c0		 fld	 ST(0)
  00010	de ca		 fmulp	 ST(2), ST(0)
  00012	d9 c9		 fxch	 ST(1)
  00014	d9 19		 fstp	 DWORD PTR [ecx]

; 102  : 	out[1] = v[1] * scale;

  00016	d9 40 04	 fld	 DWORD PTR [eax+4]
  00019	d8 c9		 fmul	 ST(0), ST(1)
  0001b	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 103  : 	out[2] = v[2] * scale;

  0001e	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00021	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 104  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
__VectorScale ENDP
_TEXT	ENDS
PUBLIC	_VectorInverse
; Function compile flags: /Ogtp
;	COMDAT _VectorInverse
_TEXT	SEGMENT
_v$ = 8							; size = 4
_VectorInverse PROC					; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 129  : 	v[0] = -v[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	d9 e0		 fchs
  0000a	d9 18		 fstp	 DWORD PTR [eax]

; 130  : 	v[1] = -v[1];

  0000c	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000f	d9 e0		 fchs
  00011	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 131  : 	v[2] = -v[2];

  00014	d9 40 08	 fld	 DWORD PTR [eax+8]
  00017	d9 e0		 fchs
  00019	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 132  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_VectorInverse ENDP
_TEXT	ENDS
PUBLIC	__real@c7c34f80
PUBLIC	__real@47c34f80
PUBLIC	_ClearBounds
;	COMDAT __real@c7c34f80
CONST	SEGMENT
__real@c7c34f80 DD 0c7c34f80r			; -99999
CONST	ENDS
;	COMDAT __real@47c34f80
CONST	SEGMENT
__real@47c34f80 DD 047c34f80r			; 99999
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _ClearBounds
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_ClearBounds PROC					; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	mins[0] = mins[1] = mins[2] = 99999;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mins$[ebp]
  00006	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@47c34f80
  0000c	d9 50 08	 fst	 DWORD PTR [eax+8]
  0000f	d9 50 04	 fst	 DWORD PTR [eax+4]
  00012	d9 18		 fstp	 DWORD PTR [eax]

; 137  : 	maxs[0] = maxs[1] = maxs[2] = -99999;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _maxs$[ebp]
  00017	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c7c34f80
  0001d	d9 50 08	 fst	 DWORD PTR [eax+8]
  00020	d9 50 04	 fst	 DWORD PTR [eax+4]
  00023	d9 18		 fstp	 DWORD PTR [eax]

; 138  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_ClearBounds ENDP
_TEXT	ENDS
PUBLIC	_AddPointToBounds
; Function compile flags: /Ogtp
;	COMDAT _AddPointToBounds
_TEXT	SEGMENT
_val$ = -4						; size = 4
_v$ = 8							; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_AddPointToBounds PROC					; COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 148  : 		if (val < mins[i])

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR _mins$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  0000b	d9 06		 fld	 DWORD PTR [esi]
  0000d	d9 5d fc	 fstp	 DWORD PTR _val$[ebp]
  00010	d9 45 fc	 fld	 DWORD PTR _val$[ebp]
  00013	d9 01		 fld	 DWORD PTR [ecx]
  00015	d8 d9		 fcomp	 ST(1)
  00017	df e0		 fnstsw	 ax
  00019	f6 c4 41	 test	 ah, 65			; 00000041H
  0001c	75 02		 jne	 SHORT $LN2@AddPointTo

; 149  : 			mins[i] = val;

  0001e	d9 11		 fst	 DWORD PTR [ecx]
$LN2@AddPointTo:

; 150  : 		if (val > maxs[i])

  00020	8b 55 10	 mov	 edx, DWORD PTR _maxs$[ebp]
  00023	d9 02		 fld	 DWORD PTR [edx]
  00025	d8 d9		 fcomp	 ST(1)
  00027	df e0		 fnstsw	 ax
  00029	f6 c4 05	 test	 ah, 5
  0002c	7a 04		 jp	 SHORT $LN24@AddPointTo

; 151  : 			maxs[i] = val;

  0002e	d9 1a		 fstp	 DWORD PTR [edx]
  00030	eb 02		 jmp	 SHORT $LN4@AddPointTo
$LN24@AddPointTo:
  00032	dd d8		 fstp	 ST(0)
$LN4@AddPointTo:

; 142  : 	int		i;
; 143  : 	vec_t	val;
; 144  : 
; 145  : 	for (i=0 ; i<3 ; i++)
; 146  : 	{
; 147  : 		val = v[i];

  00034	d9 46 04	 fld	 DWORD PTR [esi+4]
  00037	d9 5d fc	 fstp	 DWORD PTR _val$[ebp]

; 148  : 		if (val < mins[i])

  0003a	d9 45 fc	 fld	 DWORD PTR _val$[ebp]
  0003d	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00040	d8 d9		 fcomp	 ST(1)
  00042	df e0		 fnstsw	 ax
  00044	f6 c4 41	 test	 ah, 65			; 00000041H
  00047	75 03		 jne	 SHORT $LN15@AddPointTo

; 149  : 			mins[i] = val;

  00049	d9 51 04	 fst	 DWORD PTR [ecx+4]
$LN15@AddPointTo:

; 150  : 		if (val > maxs[i])

  0004c	d9 42 04	 fld	 DWORD PTR [edx+4]
  0004f	d8 d9		 fcomp	 ST(1)
  00051	df e0		 fnstsw	 ax
  00053	f6 c4 05	 test	 ah, 5
  00056	7a 05		 jp	 SHORT $LN30@AddPointTo

; 151  : 			maxs[i] = val;

  00058	d9 5a 04	 fstp	 DWORD PTR [edx+4]
  0005b	eb 02		 jmp	 SHORT $LN16@AddPointTo
$LN30@AddPointTo:
  0005d	dd d8		 fstp	 ST(0)
$LN16@AddPointTo:

; 142  : 	int		i;
; 143  : 	vec_t	val;
; 144  : 
; 145  : 	for (i=0 ; i<3 ; i++)
; 146  : 	{
; 147  : 		val = v[i];

  0005f	d9 46 08	 fld	 DWORD PTR [esi+8]
  00062	5e		 pop	 esi
  00063	d9 5d fc	 fstp	 DWORD PTR _val$[ebp]

; 148  : 		if (val < mins[i])

  00066	d9 45 fc	 fld	 DWORD PTR _val$[ebp]
  00069	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0006c	d8 d9		 fcomp	 ST(1)
  0006e	df e0		 fnstsw	 ax
  00070	f6 c4 41	 test	 ah, 65			; 00000041H
  00073	75 03		 jne	 SHORT $LN18@AddPointTo

; 149  : 			mins[i] = val;

  00075	d9 51 08	 fst	 DWORD PTR [ecx+8]
$LN18@AddPointTo:

; 150  : 		if (val > maxs[i])

  00078	d9 42 08	 fld	 DWORD PTR [edx+8]
  0007b	d8 d9		 fcomp	 ST(1)
  0007d	df e0		 fnstsw	 ax
  0007f	f6 c4 05	 test	 ah, 5
  00082	7a 07		 jp	 SHORT $LN36@AddPointTo

; 151  : 			maxs[i] = val;

  00084	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 152  : 	}
; 153  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN36@AddPointTo:

; 150  : 		if (val > maxs[i])

  0008b	dd d8		 fstp	 ST(0)

; 152  : 	}
; 153  : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
_AddPointToBounds ENDP
_TEXT	ENDS
PUBLIC	_R_ConcatTransforms
; Function compile flags: /Ogtp
;	COMDAT _R_ConcatTransforms
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
_R_ConcatTransforms PROC				; COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
; 218  : 				in1[0][2] * in2[2][0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _in1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _in2$[ebp]
  00009	d9 00		 fld	 DWORD PTR [eax]
  0000b	d8 09		 fmul	 DWORD PTR [ecx]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00010	d9 40 04	 fld	 DWORD PTR [eax+4]
  00013	d8 49 10	 fmul	 DWORD PTR [ecx+16]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 41 20	 fld	 DWORD PTR [ecx+32]
  0001b	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 1a		 fstp	 DWORD PTR [edx]

; 219  : 	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
; 220  : 				in1[0][2] * in2[2][1];

  00022	d9 41 14	 fld	 DWORD PTR [ecx+20]
  00025	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00028	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0002b	d8 08		 fmul	 DWORD PTR [eax]
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 40 08	 fld	 DWORD PTR [eax+8]
  00032	d8 49 24	 fmul	 DWORD PTR [ecx+36]
  00035	de c1		 faddp	 ST(1), ST(0)
  00037	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 221  : 	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
; 222  : 				in1[0][2] * in2[2][2];

  0003a	d9 41 18	 fld	 DWORD PTR [ecx+24]
  0003d	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00040	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00043	d8 08		 fmul	 DWORD PTR [eax]
  00045	de c1		 faddp	 ST(1), ST(0)
  00047	d9 40 08	 fld	 DWORD PTR [eax+8]
  0004a	d8 49 28	 fmul	 DWORD PTR [ecx+40]
  0004d	de c1		 faddp	 ST(1), ST(0)
  0004f	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 223  : 	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +
; 224  : 				in1[0][2] * in2[2][3] + in1[0][3];

  00052	d9 41 1c	 fld	 DWORD PTR [ecx+28]
  00055	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00058	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  0005b	d8 08		 fmul	 DWORD PTR [eax]
  0005d	de c1		 faddp	 ST(1), ST(0)
  0005f	d9 40 08	 fld	 DWORD PTR [eax+8]
  00062	d8 49 2c	 fmul	 DWORD PTR [ecx+44]
  00065	de c1		 faddp	 ST(1), ST(0)
  00067	d8 40 0c	 fadd	 DWORD PTR [eax+12]
  0006a	d9 5a 0c	 fstp	 DWORD PTR [edx+12]

; 225  : 	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
; 226  : 				in1[1][2] * in2[2][0];

  0006d	d9 40 14	 fld	 DWORD PTR [eax+20]
  00070	d8 49 10	 fmul	 DWORD PTR [ecx+16]
  00073	d9 40 10	 fld	 DWORD PTR [eax+16]
  00076	d8 09		 fmul	 DWORD PTR [ecx]
  00078	de c1		 faddp	 ST(1), ST(0)
  0007a	d9 40 18	 fld	 DWORD PTR [eax+24]
  0007d	d8 49 20	 fmul	 DWORD PTR [ecx+32]
  00080	de c1		 faddp	 ST(1), ST(0)
  00082	d9 5a 10	 fstp	 DWORD PTR [edx+16]

; 227  : 	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
; 228  : 				in1[1][2] * in2[2][1];

  00085	d9 40 10	 fld	 DWORD PTR [eax+16]
  00088	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0008b	d9 40 14	 fld	 DWORD PTR [eax+20]
  0008e	d8 49 14	 fmul	 DWORD PTR [ecx+20]
  00091	de c1		 faddp	 ST(1), ST(0)
  00093	d9 40 18	 fld	 DWORD PTR [eax+24]
  00096	d8 49 24	 fmul	 DWORD PTR [ecx+36]
  00099	de c1		 faddp	 ST(1), ST(0)
  0009b	d9 5a 14	 fstp	 DWORD PTR [edx+20]

; 229  : 	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
; 230  : 				in1[1][2] * in2[2][2];

  0009e	d9 40 10	 fld	 DWORD PTR [eax+16]
  000a1	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  000a4	d9 40 14	 fld	 DWORD PTR [eax+20]
  000a7	d8 49 18	 fmul	 DWORD PTR [ecx+24]
  000aa	de c1		 faddp	 ST(1), ST(0)
  000ac	d9 40 18	 fld	 DWORD PTR [eax+24]
  000af	d8 49 28	 fmul	 DWORD PTR [ecx+40]
  000b2	de c1		 faddp	 ST(1), ST(0)
  000b4	d9 5a 18	 fstp	 DWORD PTR [edx+24]

; 231  : 	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +
; 232  : 				in1[1][2] * in2[2][3] + in1[1][3];

  000b7	d9 40 10	 fld	 DWORD PTR [eax+16]
  000ba	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  000bd	d9 40 14	 fld	 DWORD PTR [eax+20]
  000c0	d8 49 1c	 fmul	 DWORD PTR [ecx+28]
  000c3	de c1		 faddp	 ST(1), ST(0)
  000c5	d9 40 18	 fld	 DWORD PTR [eax+24]
  000c8	d8 49 2c	 fmul	 DWORD PTR [ecx+44]
  000cb	de c1		 faddp	 ST(1), ST(0)
  000cd	d8 40 1c	 fadd	 DWORD PTR [eax+28]
  000d0	d9 5a 1c	 fstp	 DWORD PTR [edx+28]

; 233  : 	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
; 234  : 				in1[2][2] * in2[2][0];

  000d3	d9 40 24	 fld	 DWORD PTR [eax+36]
  000d6	d8 49 10	 fmul	 DWORD PTR [ecx+16]
  000d9	d9 01		 fld	 DWORD PTR [ecx]
  000db	d8 48 20	 fmul	 DWORD PTR [eax+32]
  000de	de c1		 faddp	 ST(1), ST(0)
  000e0	d9 40 28	 fld	 DWORD PTR [eax+40]
  000e3	d8 49 20	 fmul	 DWORD PTR [ecx+32]
  000e6	de c1		 faddp	 ST(1), ST(0)
  000e8	d9 5a 20	 fstp	 DWORD PTR [edx+32]

; 235  : 	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
; 236  : 				in1[2][2] * in2[2][1];

  000eb	d9 41 04	 fld	 DWORD PTR [ecx+4]
  000ee	d8 48 20	 fmul	 DWORD PTR [eax+32]
  000f1	d9 40 24	 fld	 DWORD PTR [eax+36]
  000f4	d8 49 14	 fmul	 DWORD PTR [ecx+20]
  000f7	de c1		 faddp	 ST(1), ST(0)
  000f9	d9 40 28	 fld	 DWORD PTR [eax+40]
  000fc	d8 49 24	 fmul	 DWORD PTR [ecx+36]
  000ff	de c1		 faddp	 ST(1), ST(0)
  00101	d9 5a 24	 fstp	 DWORD PTR [edx+36]

; 237  : 	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
; 238  : 				in1[2][2] * in2[2][2];

  00104	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00107	d8 48 20	 fmul	 DWORD PTR [eax+32]
  0010a	d9 40 24	 fld	 DWORD PTR [eax+36]
  0010d	d8 49 18	 fmul	 DWORD PTR [ecx+24]
  00110	de c1		 faddp	 ST(1), ST(0)
  00112	d9 40 28	 fld	 DWORD PTR [eax+40]
  00115	d8 49 28	 fmul	 DWORD PTR [ecx+40]
  00118	de c1		 faddp	 ST(1), ST(0)
  0011a	d9 5a 28	 fstp	 DWORD PTR [edx+40]

; 239  : 	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +
; 240  : 				in1[2][2] * in2[2][3] + in1[2][3];

  0011d	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  00120	d8 48 20	 fmul	 DWORD PTR [eax+32]
  00123	d9 40 24	 fld	 DWORD PTR [eax+36]
  00126	d8 49 1c	 fmul	 DWORD PTR [ecx+28]
  00129	de c1		 faddp	 ST(1), ST(0)
  0012b	d9 40 28	 fld	 DWORD PTR [eax+40]
  0012e	d8 49 2c	 fmul	 DWORD PTR [ecx+44]
  00131	de c1		 faddp	 ST(1), ST(0)
  00133	d8 40 2c	 fadd	 DWORD PTR [eax+44]
  00136	d9 5a 2c	 fstp	 DWORD PTR [edx+44]

; 241  : }

  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
_R_ConcatTransforms ENDP
_TEXT	ENDS
PUBLIC	_VectorRotate
; Function compile flags: /Ogtp
;	COMDAT _VectorRotate
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
_VectorRotate PROC					; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 	out[0] = DotProduct(in1, in2[0]);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _in2$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _in1$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00012	d9 00		 fld	 DWORD PTR [eax]
  00014	d8 09		 fmul	 DWORD PTR [ecx]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0001b	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 1a		 fstp	 DWORD PTR [edx]

; 248  : 	out[1] = DotProduct(in1, in2[1]);

  00022	d9 41 10	 fld	 DWORD PTR [ecx+16]
  00025	d8 08		 fmul	 DWORD PTR [eax]
  00027	d9 41 14	 fld	 DWORD PTR [ecx+20]
  0002a	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00032	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00035	de c1		 faddp	 ST(1), ST(0)
  00037	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 249  : 	out[2] = DotProduct(in1, in2[2]);

  0003a	d9 41 20	 fld	 DWORD PTR [ecx+32]
  0003d	d8 08		 fmul	 DWORD PTR [eax]
  0003f	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00042	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00045	de c1		 faddp	 ST(1), ST(0)
  00047	d9 41 28	 fld	 DWORD PTR [ecx+40]
  0004a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0004d	de c1		 faddp	 ST(1), ST(0)
  0004f	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 250  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_VectorRotate ENDP
_TEXT	ENDS
PUBLIC	_VectorIRotate
; Function compile flags: /Ogtp
;	COMDAT _VectorIRotate
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
_VectorIRotate PROC					; COMDAT

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 256  : 	out[0] = in1[0]*in2[0][0] + in1[1]*in2[1][0] + in1[2]*in2[2][0];

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _in2$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _in1$[ebp]
  00009	d9 41 10	 fld	 DWORD PTR [ecx+16]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00012	d9 00		 fld	 DWORD PTR [eax]
  00014	d8 09		 fmul	 DWORD PTR [ecx]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 41 20	 fld	 DWORD PTR [ecx+32]
  0001b	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 1a		 fstp	 DWORD PTR [edx]

; 257  : 	out[1] = in1[0]*in2[0][1] + in1[1]*in2[1][1] + in1[2]*in2[2][1];

  00022	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00025	d8 08		 fmul	 DWORD PTR [eax]
  00027	d9 41 14	 fld	 DWORD PTR [ecx+20]
  0002a	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00032	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00035	de c1		 faddp	 ST(1), ST(0)
  00037	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 258  : 	out[2] = in1[0]*in2[0][2] + in1[1]*in2[1][2] + in1[2]*in2[2][2];

  0003a	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0003d	d8 08		 fmul	 DWORD PTR [eax]
  0003f	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00042	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00045	de c1		 faddp	 ST(1), ST(0)
  00047	d9 41 28	 fld	 DWORD PTR [ecx+40]
  0004a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0004d	de c1		 faddp	 ST(1), ST(0)
  0004f	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 259  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_VectorIRotate ENDP
_TEXT	ENDS
PUBLIC	_VectorTranslate
; Function compile flags: /Ogtp
;	COMDAT _VectorTranslate
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
_VectorTranslate PROC					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  : 	out[0] = in1[0] + in2[0][3];

  00003	8b 45 0c	 mov	 eax, DWORD PTR _in2$[ebp]
  00006	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _in1$[ebp]
  0000c	d8 01		 fadd	 DWORD PTR [ecx]
  0000e	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00011	d9 1a		 fstp	 DWORD PTR [edx]

; 265  : 	out[1] = in1[1] + in2[1][3];

  00013	d9 40 1c	 fld	 DWORD PTR [eax+28]
  00016	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00019	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 266  : 	out[2] = in1[2] + in2[2][3];

  0001c	d9 40 2c	 fld	 DWORD PTR [eax+44]
  0001f	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  00022	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 267  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_VectorTranslate ENDP
_TEXT	ENDS
PUBLIC	_VectorTransform
; Function compile flags: /Ogtp
;	COMDAT _VectorTransform
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
_VectorTransform PROC					; COMDAT

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 	out[0] = DotProduct(in1, in2[0]) + in2[0][3];

  00003	8b 45 0c	 mov	 eax, DWORD PTR _in2$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _in1$[ebp]
  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00012	d9 01		 fld	 DWORD PTR [ecx]
  00014	d8 08		 fmul	 DWORD PTR [eax]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001b	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d8 40 0c	 fadd	 DWORD PTR [eax+12]
  00023	d9 1a		 fstp	 DWORD PTR [edx]

; 272  : 	out[1] = DotProduct(in1, in2[1]) +	in2[1][3];

  00025	d9 40 10	 fld	 DWORD PTR [eax+16]
  00028	d8 09		 fmul	 DWORD PTR [ecx]
  0002a	d9 40 14	 fld	 DWORD PTR [eax+20]
  0002d	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00030	de c1		 faddp	 ST(1), ST(0)
  00032	d9 40 18	 fld	 DWORD PTR [eax+24]
  00035	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00038	de c1		 faddp	 ST(1), ST(0)
  0003a	d8 40 1c	 fadd	 DWORD PTR [eax+28]
  0003d	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 273  : 	out[2] = DotProduct(in1, in2[2]) +	in2[2][3];

  00040	d9 40 20	 fld	 DWORD PTR [eax+32]
  00043	d8 09		 fmul	 DWORD PTR [ecx]
  00045	d9 40 24	 fld	 DWORD PTR [eax+36]
  00048	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0004b	de c1		 faddp	 ST(1), ST(0)
  0004d	d9 40 28	 fld	 DWORD PTR [eax+40]
  00050	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00053	de c1		 faddp	 ST(1), ST(0)
  00055	d8 40 2c	 fadd	 DWORD PTR [eax+44]
  00058	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 274  : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_VectorTransform ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	_QuaternionMatrix
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _QuaternionMatrix
_TEXT	SEGMENT
_quaternion$ = 8					; size = 4
_matrix$ = 12						; size = 4
_QuaternionMatrix PROC					; COMDAT

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 302  : 
; 303  : 	matrix[0][0] = 1.0 - 2.0 * quaternion[1] * quaternion[1] - 2.0 * quaternion[2] * quaternion[2];

  00003	8b 45 08	 mov	 eax, DWORD PTR _quaternion$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _matrix$[ebp]
  0000c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  00012	dc c9		 fmul	 ST(1), ST(0)
  00014	d9 40 04	 fld	 DWORD PTR [eax+4]
  00017	de ca		 fmulp	 ST(2), ST(0)
  00019	d9 e8		 fld1
  0001b	d9 c0		 fld	 ST(0)
  0001d	de e3		 fsubrp	 ST(3), ST(0)
  0001f	d9 40 08	 fld	 DWORD PTR [eax+8]
  00022	d8 ca		 fmul	 ST(0), ST(2)
  00024	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00027	de eb		 fsubp	 ST(3), ST(0)
  00029	d9 ca		 fxch	 ST(2)
  0002b	d9 19		 fstp	 DWORD PTR [ecx]

; 304  : 	matrix[1][0] = 2.0 * quaternion[0] * quaternion[1] + 2.0 * quaternion[3] * quaternion[2];

  0002d	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00030	d8 c9		 fmul	 ST(0), ST(1)
  00032	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00035	d9 00		 fld	 DWORD PTR [eax]
  00037	d8 ca		 fmul	 ST(0), ST(2)
  00039	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0003c	de c1		 faddp	 ST(1), ST(0)
  0003e	d9 59 10	 fstp	 DWORD PTR [ecx+16]

; 305  : 	matrix[2][0] = 2.0 * quaternion[0] * quaternion[2] - 2.0 * quaternion[3] * quaternion[1];

  00041	d9 00		 fld	 DWORD PTR [eax]
  00043	d8 c9		 fmul	 ST(0), ST(1)
  00045	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00048	d9 40 0c	 fld	 DWORD PTR [eax+12]
  0004b	d8 ca		 fmul	 ST(0), ST(2)
  0004d	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00050	de e9		 fsubp	 ST(1), ST(0)
  00052	d9 59 20	 fstp	 DWORD PTR [ecx+32]

; 306  : 
; 307  : 	matrix[0][1] = 2.0 * quaternion[0] * quaternion[1] - 2.0 * quaternion[3] * quaternion[2];

  00055	d9 00		 fld	 DWORD PTR [eax]
  00057	d8 c9		 fmul	 ST(0), ST(1)
  00059	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0005c	d9 40 0c	 fld	 DWORD PTR [eax+12]
  0005f	d8 ca		 fmul	 ST(0), ST(2)
  00061	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00064	de e9		 fsubp	 ST(1), ST(0)
  00066	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 308  : 	matrix[1][1] = 1.0 - 2.0 * quaternion[0] * quaternion[0] - 2.0 * quaternion[2] * quaternion[2];

  00069	d9 00		 fld	 DWORD PTR [eax]
  0006b	d8 c9		 fmul	 ST(0), ST(1)
  0006d	d8 08		 fmul	 DWORD PTR [eax]
  0006f	d8 ea		 fsubr	 ST(0), ST(2)
  00071	d9 40 08	 fld	 DWORD PTR [eax+8]
  00074	d8 ca		 fmul	 ST(0), ST(2)
  00076	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00079	de e9		 fsubp	 ST(1), ST(0)
  0007b	d9 59 14	 fstp	 DWORD PTR [ecx+20]

; 309  : 	matrix[2][1] = 2.0 * quaternion[1] * quaternion[2] + 2.0 * quaternion[3] * quaternion[0];

  0007e	d9 40 04	 fld	 DWORD PTR [eax+4]
  00081	d8 c9		 fmul	 ST(0), ST(1)
  00083	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00086	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00089	d8 ca		 fmul	 ST(0), ST(2)
  0008b	d8 08		 fmul	 DWORD PTR [eax]
  0008d	de c1		 faddp	 ST(1), ST(0)
  0008f	d9 59 24	 fstp	 DWORD PTR [ecx+36]

; 310  : 
; 311  : 	matrix[0][2] = 2.0 * quaternion[0] * quaternion[2] + 2.0 * quaternion[3] * quaternion[1];

  00092	d9 00		 fld	 DWORD PTR [eax]
  00094	d8 c9		 fmul	 ST(0), ST(1)
  00096	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00099	d9 40 0c	 fld	 DWORD PTR [eax+12]
  0009c	d8 ca		 fmul	 ST(0), ST(2)
  0009e	d8 48 04	 fmul	 DWORD PTR [eax+4]
  000a1	de c1		 faddp	 ST(1), ST(0)
  000a3	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 312  : 	matrix[1][2] = 2.0 * quaternion[1] * quaternion[2] - 2.0 * quaternion[3] * quaternion[0];

  000a6	d9 40 04	 fld	 DWORD PTR [eax+4]
  000a9	d8 c9		 fmul	 ST(0), ST(1)
  000ab	d8 48 08	 fmul	 DWORD PTR [eax+8]
  000ae	d9 40 0c	 fld	 DWORD PTR [eax+12]
  000b1	d8 ca		 fmul	 ST(0), ST(2)
  000b3	d8 08		 fmul	 DWORD PTR [eax]
  000b5	de e9		 fsubp	 ST(1), ST(0)
  000b7	d9 59 18	 fstp	 DWORD PTR [ecx+24]

; 313  : 	matrix[2][2] = 1.0 - 2.0 * quaternion[0] * quaternion[0] - 2.0 * quaternion[1] * quaternion[1];

  000ba	d9 00		 fld	 DWORD PTR [eax]
  000bc	d8 c9		 fmul	 ST(0), ST(1)
  000be	d8 08		 fmul	 DWORD PTR [eax]
  000c0	de ea		 fsubp	 ST(2), ST(0)
  000c2	d8 48 04	 fmul	 DWORD PTR [eax+4]
  000c5	d8 48 04	 fmul	 DWORD PTR [eax+4]
  000c8	de e9		 fsubp	 ST(1), ST(0)
  000ca	d9 59 28	 fstp	 DWORD PTR [ecx+40]

; 314  : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_QuaternionMatrix ENDP
_TEXT	ENDS
PUBLIC	_fabsf
; Function compile flags: /Ogtp
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 395  :         {return ((float)fabs((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	_acosf
EXTRN	__CIacos:PROC
; Function compile flags: /Ogtp
;	COMDAT _acosf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 400  :         {return ((float)acos((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIacos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_acosf	ENDP
_TEXT	ENDS
PUBLIC	_cosf
EXTRN	__CIcos:PROC
; Function compile flags: /Ogtp
;	COMDAT _cosf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIcos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	_sinf
EXTRN	__CIsin:PROC
; Function compile flags: /Ogtp
;	COMDAT _sinf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsin
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?acos@@YAMM@Z					; acos
; Function compile flags: /Ogtp
;	COMDAT ?acos@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?acos@@YAMM@Z PROC					; acos, COMDAT

; 502  :         {return (acosf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIacos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?acos@@YAMM@Z ENDP					; acos
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
; Function compile flags: /Ogtp
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 512  :         {return (cosf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIcos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
PUBLIC	?fabs@@YAMM@Z					; fabs
; Function compile flags: /Ogtp
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 518  :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv131[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv131[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
PUBLIC	?sin@@YAMM@Z					; sin
; Function compile flags: /Ogtp
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 538  :         {return (sinf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsin
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	_GetSquare
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\zzzmathlib.cpp
;	COMDAT _GetSquare
_TEXT	SEGMENT
tv74 = 8						; size = 4
_value$ = 8						; size = 4
_GetSquare PROC						; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	return sqrt(value);

  00003	d9 45 08	 fld	 DWORD PTR _value$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv74[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv74[ebp]

; 41   : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_GetSquare ENDP
_TEXT	ENDS
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	_VectorCompare
;	COMDAT __real@3f50624dd2f1a9fc
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\zzzmathlib.cpp
CONST	ENDS
;	COMDAT _VectorCompare
_TEXT	SEGMENT
tv281 = -4						; size = 4
tv274 = -4						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_VectorCompare PROC					; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 45   : 	int		i;
; 46   : 	
; 47   : 	for (i=0 ; i<3 ; i++)

  00004	8b 55 0c	 mov	 edx, DWORD PTR _v2$[ebp]
  00007	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3f50624dd2f1a9fc
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _v1$[ebp]
  00011	33 c9		 xor	 ecx, ecx
  00013	2b f2		 sub	 esi, edx
$LN4@VectorComp:

; 48   : 		if (fabs(v1[i]-v2[i]) > EQUAL_EPSILON)

  00015	d9 04 16	 fld	 DWORD PTR [esi+edx]
  00018	d8 22		 fsub	 DWORD PTR [edx]
  0001a	d9 5d fc	 fstp	 DWORD PTR tv281[ebp]
  0001d	d9 45 fc	 fld	 DWORD PTR tv281[ebp]
  00020	d9 e1		 fabs
  00022	d9 5d fc	 fstp	 DWORD PTR tv274[ebp]
  00025	d9 45 fc	 fld	 DWORD PTR tv274[ebp]
  00028	d8 d9		 fcomp	 ST(1)
  0002a	df e0		 fnstsw	 ax
  0002c	f6 c4 41	 test	 ah, 65			; 00000041H
  0002f	74 15		 je	 SHORT $LN16@VectorComp

; 45   : 	int		i;
; 46   : 	
; 47   : 	for (i=0 ; i<3 ; i++)

  00031	41		 inc	 ecx
  00032	83 c2 04	 add	 edx, 4
  00035	83 f9 03	 cmp	 ecx, 3
  00038	7c db		 jl	 SHORT $LN4@VectorComp
  0003a	dd d8		 fstp	 ST(0)

; 50   : 			
; 51   : 	return true;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	5e		 pop	 esi

; 52   : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN16@VectorComp:

; 48   : 		if (fabs(v1[i]-v2[i]) > EQUAL_EPSILON)

  00046	dd d8		 fstp	 ST(0)

; 49   : 			return false;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 52   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_VectorCompare ENDP
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	_VectorNormalize
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _VectorNormalize
_TEXT	SEGMENT
tv470 = 8						; size = 4
tv466 = 8						; size = 4
_length$ = 8						; size = 4
_v$ = 8							; size = 4
_VectorNormalize PROC					; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  00007	d9 06		 fld	 DWORD PTR [esi]

; 108  : 	int		i;
; 109  : 	float	length;
; 110  : 
; 111  : if ( fabs(v[1] - 0.000215956) < 0.0001)
; 112  : i=1;
; 113  : 
; 114  : 	length = 0;
; 115  : 	for (i=0 ; i< 3 ; i++)
; 116  : 		length += v[i]*v[i];
; 117  : 	length = GetSquare (length);

  00009	51		 push	 ecx
  0000a	d9 46 04	 fld	 DWORD PTR [esi+4]
  0000d	d9 46 08	 fld	 DWORD PTR [esi+8]
  00010	d9 c2		 fld	 ST(2)
  00012	de cb		 fmulp	 ST(3), ST(0)
  00014	d9 ca		 fxch	 ST(2)
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@0000000000000000
  0001c	d9 5d 08	 fstp	 DWORD PTR tv470[ebp]
  0001f	d9 c0		 fld	 ST(0)
  00021	de c9		 fmulp	 ST(1), ST(0)
  00023	d8 45 08	 fadd	 DWORD PTR tv470[ebp]
  00026	d9 5d 08	 fstp	 DWORD PTR tv466[ebp]
  00029	d9 c0		 fld	 ST(0)
  0002b	de c9		 fmulp	 ST(1), ST(0)
  0002d	d8 45 08	 fadd	 DWORD PTR tv466[ebp]
  00030	d9 5d 08	 fstp	 DWORD PTR _length$[ebp]
  00033	d9 45 08	 fld	 DWORD PTR _length$[ebp]
  00036	d9 1c 24	 fstp	 DWORD PTR [esp]
  00039	e8 00 00 00 00	 call	 _GetSquare
  0003e	d9 5d 08	 fstp	 DWORD PTR _length$[ebp]
  00041	83 c4 04	 add	 esp, 4

; 118  : 	if (length == 0)

  00044	d9 45 08	 fld	 DWORD PTR _length$[ebp]
  00047	d9 c0		 fld	 ST(0)
  00049	d9 ee		 fldz
  0004b	d9 c0		 fld	 ST(0)
  0004d	dd ea		 fucomp	 ST(2)
  0004f	df e0		 fnstsw	 ax
  00051	dd d9		 fstp	 ST(1)
  00053	f6 c4 44	 test	 ah, 68			; 00000044H
  00056	7a 05		 jp	 SHORT $LN24@VectorNorm
  00058	dd d9		 fstp	 ST(1)
  0005a	5e		 pop	 esi

; 123  : 
; 124  : 	return length;
; 125  : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN24@VectorNorm:

; 118  : 	if (length == 0)

  0005d	dd d8		 fstp	 ST(0)

; 119  : 		return 0;
; 120  : 		
; 121  : 	for (i=0 ; i< 3 ; i++)
; 122  : 		v[i] /= length;	

  0005f	d9 06		 fld	 DWORD PTR [esi]
  00061	d8 f1		 fdiv	 ST(0), ST(1)
  00063	d9 1e		 fstp	 DWORD PTR [esi]
  00065	d9 46 04	 fld	 DWORD PTR [esi+4]
  00068	d8 f1		 fdiv	 ST(0), ST(1)
  0006a	d9 5e 04	 fstp	 DWORD PTR [esi+4]
  0006d	d9 46 08	 fld	 DWORD PTR [esi+8]
  00070	d8 f1		 fdiv	 ST(0), ST(1)
  00072	d9 5e 08	 fstp	 DWORD PTR [esi+8]
  00075	5e		 pop	 esi

; 123  : 
; 124  : 	return length;
; 125  : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_VectorNormalize ENDP
_TEXT	ENDS
PUBLIC	__real@3f91df46a0000000
PUBLIC	_AngleMatrix
;	COMDAT __real@3f91df46a0000000
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@3f91df46a0000000 DQ 03f91df46a0000000r	; 0.0174533
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\zzzmathlib.cpp
CONST	ENDS
;	COMDAT _AngleMatrix
_TEXT	SEGMENT
tv347 = -24						; size = 8
tv329 = -24						; size = 8
_sy$ = -20						; size = 4
_cy$ = -16						; size = 4
_cp$ = -12						; size = 4
tv309 = -8						; size = 4
_sr$ = -8						; size = 4
tv340 = -4						; size = 4
tv324 = -4						; size = 4
_sp$ = -4						; size = 4
tv333 = 8						; size = 4
tv317 = 8						; size = 4
tv302 = 8						; size = 4
_cr$ = 8						; size = 4
_angle$ = 8						; size = 4
_angles$ = 8						; size = 4
_matrix$ = 12						; size = 4
_AngleMatrix PROC					; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 157  : 	float		angle;
; 158  : 	float		sr, sp, sy, cr, cp, cy;
; 159  : 	
; 160  : 	angle = angles[2] * (Q_PI*2 / 360);

  00007	8b 75 08	 mov	 esi, DWORD PTR _angles$[ebp]
  0000a	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00013	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 161  : 	sy = (float)sin(angle);

  00016	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00019	e8 00 00 00 00	 call	 __CIsin
  0001e	d9 5d fc	 fstp	 DWORD PTR tv340[ebp]
  00021	d9 45 fc	 fld	 DWORD PTR tv340[ebp]
  00024	d9 5d ec	 fstp	 DWORD PTR _sy$[ebp]

; 162  : 	cy = (float)cos(angle);

  00027	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  0002a	e8 00 00 00 00	 call	 __CIcos
  0002f	d9 5d 08	 fstp	 DWORD PTR tv333[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv333[ebp]
  00035	d9 5d f0	 fstp	 DWORD PTR _cy$[ebp]

; 163  : 	angle = angles[1] * (Q_PI*2 / 360);

  00038	d9 46 04	 fld	 DWORD PTR [esi+4]
  0003b	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00041	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 164  : 	sp = (float)sin(angle);

  00044	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00047	e8 00 00 00 00	 call	 __CIsin
  0004c	d9 5d fc	 fstp	 DWORD PTR tv324[ebp]
  0004f	d9 45 fc	 fld	 DWORD PTR tv324[ebp]
  00052	d9 5d fc	 fstp	 DWORD PTR _sp$[ebp]

; 165  : 	cp = (float)cos(angle);

  00055	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00058	e8 00 00 00 00	 call	 __CIcos
  0005d	d9 5d 08	 fstp	 DWORD PTR tv317[ebp]
  00060	d9 45 08	 fld	 DWORD PTR tv317[ebp]
  00063	d9 5d f4	 fstp	 DWORD PTR _cp$[ebp]

; 166  : 	angle = angles[0] * (Q_PI*2 / 360);

  00066	d9 06		 fld	 DWORD PTR [esi]
  00068	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  0006e	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 167  : 	sr = (float)sin(angle);

  00071	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00074	e8 00 00 00 00	 call	 __CIsin
  00079	d9 5d f8	 fstp	 DWORD PTR tv309[ebp]
  0007c	d9 45 f8	 fld	 DWORD PTR tv309[ebp]
  0007f	d9 5d f8	 fstp	 DWORD PTR _sr$[ebp]

; 168  : 	cr = (float)cos(angle);

  00082	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00085	e8 00 00 00 00	 call	 __CIcos
  0008a	d9 5d 08	 fstp	 DWORD PTR tv302[ebp]
  0008d	d9 45 08	 fld	 DWORD PTR tv302[ebp]

; 169  : 
; 170  : 	// matrix = (Z * Y) * X
; 171  : 	matrix[0][0] = cp*cy;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _matrix$[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _cr$[ebp]
  00096	d9 45 f4	 fld	 DWORD PTR _cp$[ebp]
  00099	d9 c0		 fld	 ST(0)
  0009b	d9 45 f0	 fld	 DWORD PTR _cy$[ebp]
  0009e	d9 c0		 fld	 ST(0)
  000a0	de ca		 fmulp	 ST(2), ST(0)
  000a2	d9 c9		 fxch	 ST(1)
  000a4	d9 18		 fstp	 DWORD PTR [eax]

; 172  : 	matrix[1][0] = cp*sy;

  000a6	d9 c1		 fld	 ST(1)
  000a8	d9 45 ec	 fld	 DWORD PTR _sy$[ebp]
  000ab	d9 c0		 fld	 ST(0)
  000ad	de ca		 fmulp	 ST(2), ST(0)
  000af	d9 c9		 fxch	 ST(1)
  000b1	d9 58 10	 fstp	 DWORD PTR [eax+16]

; 173  : 	matrix[2][0] = -sp;

  000b4	d9 45 fc	 fld	 DWORD PTR _sp$[ebp]
  000b7	d9 c0		 fld	 ST(0)
  000b9	d9 e0		 fchs
  000bb	d9 58 20	 fstp	 DWORD PTR [eax+32]

; 174  : 	matrix[0][1] = sr*sp*cy+cr*-sy;

  000be	d9 45 f8	 fld	 DWORD PTR _sr$[ebp]
  000c1	d9 c0		 fld	 ST(0)
  000c3	de ca		 fmulp	 ST(2), ST(0)
  000c5	d9 c9		 fxch	 ST(1)
  000c7	dd 55 e8	 fst	 QWORD PTR tv329[ebp]
  000ca	d8 cb		 fmul	 ST(0), ST(3)
  000cc	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000cf	d9 c0		 fld	 ST(0)
  000d1	d8 cc		 fmul	 ST(0), ST(4)
  000d3	de ea		 fsubp	 ST(2), ST(0)
  000d5	d9 c9		 fxch	 ST(1)
  000d7	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 175  : 	matrix[1][1] = sr*sp*sy+cr*cy;

  000da	d9 c0		 fld	 ST(0)
  000dc	d8 cc		 fmul	 ST(0), ST(4)
  000de	d9 c3		 fld	 ST(3)
  000e0	dc 4d e8	 fmul	 QWORD PTR tv329[ebp]
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d9 58 14	 fstp	 DWORD PTR [eax+20]

; 176  : 	matrix[2][1] = sr*cp;

  000e8	d9 c1		 fld	 ST(1)
  000ea	d8 cd		 fmul	 ST(0), ST(5)
  000ec	d9 58 24	 fstp	 DWORD PTR [eax+36]

; 177  : 	matrix[0][2] = (cr*sp*cy+-sr*-sy);

  000ef	d9 c0		 fld	 ST(0)
  000f1	d8 4d fc	 fmul	 DWORD PTR _sp$[ebp]
  000f4	5e		 pop	 esi
  000f5	dd 55 e8	 fst	 QWORD PTR tv347[ebp]
  000f8	d8 cc		 fmul	 ST(0), ST(4)
  000fa	d9 c3		 fld	 ST(3)
  000fc	d9 e0		 fchs
  000fe	d8 cb		 fmul	 ST(0), ST(3)
  00100	de e9		 fsubp	 ST(1), ST(0)
  00102	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 178  : 	matrix[1][2] = (cr*sp*sy+-sr*cy);

  00105	d9 ca		 fxch	 ST(2)
  00107	dc 4d e8	 fmul	 QWORD PTR tv347[ebp]
  0010a	d9 c9		 fxch	 ST(1)
  0010c	de cb		 fmulp	 ST(3), ST(0)
  0010e	de e2		 fsubrp	 ST(2), ST(0)
  00110	d9 c9		 fxch	 ST(1)
  00112	d9 58 18	 fstp	 DWORD PTR [eax+24]

; 179  : 	matrix[2][2] = cr*cp;

  00115	de c9		 fmulp	 ST(1), ST(0)
  00117	d9 58 28	 fstp	 DWORD PTR [eax+40]

; 180  : 	matrix[0][3] = 0.0;

  0011a	d9 ee		 fldz
  0011c	d9 50 0c	 fst	 DWORD PTR [eax+12]

; 181  : 	matrix[1][3] = 0.0;

  0011f	d9 50 1c	 fst	 DWORD PTR [eax+28]

; 182  : 	matrix[2][3] = 0.0;

  00122	d9 58 2c	 fstp	 DWORD PTR [eax+44]

; 183  : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_AngleMatrix ENDP
_TEXT	ENDS
PUBLIC	_AngleIMatrix
; Function compile flags: /Ogtp
;	COMDAT _AngleIMatrix
_TEXT	SEGMENT
tv347 = -24						; size = 8
tv329 = -24						; size = 8
_sy$ = -20						; size = 4
_cy$ = -16						; size = 4
_cp$ = -12						; size = 4
tv309 = -8						; size = 4
_sr$ = -8						; size = 4
tv340 = -4						; size = 4
tv324 = -4						; size = 4
_sp$ = -4						; size = 4
tv333 = 8						; size = 4
tv317 = 8						; size = 4
tv302 = 8						; size = 4
_cr$ = 8						; size = 4
_angle$ = 8						; size = 4
_angles$ = 8						; size = 4
_matrix$ = 12						; size = 4
_AngleIMatrix PROC					; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 187  : 	float		angle;
; 188  : 	float		sr, sp, sy, cr, cp, cy;
; 189  : 	
; 190  : 	angle = angles[2] * (Q_PI*2 / 360);

  00007	8b 75 08	 mov	 esi, DWORD PTR _angles$[ebp]
  0000a	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00013	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 191  : 	sy = (float)sin(angle);

  00016	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00019	e8 00 00 00 00	 call	 __CIsin
  0001e	d9 5d fc	 fstp	 DWORD PTR tv340[ebp]
  00021	d9 45 fc	 fld	 DWORD PTR tv340[ebp]
  00024	d9 5d ec	 fstp	 DWORD PTR _sy$[ebp]

; 192  : 	cy = (float)cos(angle);

  00027	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  0002a	e8 00 00 00 00	 call	 __CIcos
  0002f	d9 5d 08	 fstp	 DWORD PTR tv333[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv333[ebp]
  00035	d9 5d f0	 fstp	 DWORD PTR _cy$[ebp]

; 193  : 	angle = angles[1] * (Q_PI*2 / 360);

  00038	d9 46 04	 fld	 DWORD PTR [esi+4]
  0003b	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00041	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 194  : 	sp = (float)sin(angle);

  00044	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00047	e8 00 00 00 00	 call	 __CIsin
  0004c	d9 5d fc	 fstp	 DWORD PTR tv324[ebp]
  0004f	d9 45 fc	 fld	 DWORD PTR tv324[ebp]
  00052	d9 5d fc	 fstp	 DWORD PTR _sp$[ebp]

; 195  : 	cp = (float)cos(angle);

  00055	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00058	e8 00 00 00 00	 call	 __CIcos
  0005d	d9 5d 08	 fstp	 DWORD PTR tv317[ebp]
  00060	d9 45 08	 fld	 DWORD PTR tv317[ebp]
  00063	d9 5d f4	 fstp	 DWORD PTR _cp$[ebp]

; 196  : 	angle = angles[0] * (Q_PI*2 / 360);

  00066	d9 06		 fld	 DWORD PTR [esi]
  00068	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  0006e	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 197  : 	sr = (float)sin(angle);

  00071	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00074	e8 00 00 00 00	 call	 __CIsin
  00079	d9 5d f8	 fstp	 DWORD PTR tv309[ebp]
  0007c	d9 45 f8	 fld	 DWORD PTR tv309[ebp]
  0007f	d9 5d f8	 fstp	 DWORD PTR _sr$[ebp]

; 198  : 	cr = (float)cos(angle);

  00082	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00085	e8 00 00 00 00	 call	 __CIcos
  0008a	d9 5d 08	 fstp	 DWORD PTR tv302[ebp]
  0008d	d9 45 08	 fld	 DWORD PTR tv302[ebp]

; 199  : 
; 200  : 	// matrix = (Z * Y) * X
; 201  : 	matrix[0][0] = cp*cy;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _matrix$[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _cr$[ebp]
  00096	d9 45 f4	 fld	 DWORD PTR _cp$[ebp]
  00099	d9 c0		 fld	 ST(0)
  0009b	d9 45 f0	 fld	 DWORD PTR _cy$[ebp]
  0009e	d9 c0		 fld	 ST(0)
  000a0	de ca		 fmulp	 ST(2), ST(0)
  000a2	d9 c9		 fxch	 ST(1)
  000a4	d9 18		 fstp	 DWORD PTR [eax]

; 202  : 	matrix[0][1] = cp*sy;

  000a6	d9 c1		 fld	 ST(1)
  000a8	d9 45 ec	 fld	 DWORD PTR _sy$[ebp]
  000ab	d9 c0		 fld	 ST(0)
  000ad	de ca		 fmulp	 ST(2), ST(0)
  000af	d9 c9		 fxch	 ST(1)
  000b1	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 203  : 	matrix[0][2] = -sp;

  000b4	d9 45 fc	 fld	 DWORD PTR _sp$[ebp]
  000b7	d9 c0		 fld	 ST(0)
  000b9	d9 e0		 fchs
  000bb	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 204  : 	matrix[1][0] = sr*sp*cy+cr*-sy;

  000be	d9 45 f8	 fld	 DWORD PTR _sr$[ebp]
  000c1	d9 c0		 fld	 ST(0)
  000c3	de ca		 fmulp	 ST(2), ST(0)
  000c5	d9 c9		 fxch	 ST(1)
  000c7	dd 55 e8	 fst	 QWORD PTR tv329[ebp]
  000ca	d8 cb		 fmul	 ST(0), ST(3)
  000cc	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000cf	d9 c0		 fld	 ST(0)
  000d1	d8 cc		 fmul	 ST(0), ST(4)
  000d3	de ea		 fsubp	 ST(2), ST(0)
  000d5	d9 c9		 fxch	 ST(1)
  000d7	d9 58 10	 fstp	 DWORD PTR [eax+16]

; 205  : 	matrix[1][1] = sr*sp*sy+cr*cy;

  000da	d9 c0		 fld	 ST(0)
  000dc	d8 cc		 fmul	 ST(0), ST(4)
  000de	d9 c3		 fld	 ST(3)
  000e0	dc 4d e8	 fmul	 QWORD PTR tv329[ebp]
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d9 58 14	 fstp	 DWORD PTR [eax+20]

; 206  : 	matrix[1][2] = sr*cp;

  000e8	d9 c1		 fld	 ST(1)
  000ea	d8 cd		 fmul	 ST(0), ST(5)
  000ec	d9 58 18	 fstp	 DWORD PTR [eax+24]

; 207  : 	matrix[2][0] = (cr*sp*cy+-sr*-sy);

  000ef	d9 c0		 fld	 ST(0)
  000f1	d8 4d fc	 fmul	 DWORD PTR _sp$[ebp]
  000f4	5e		 pop	 esi
  000f5	dd 55 e8	 fst	 QWORD PTR tv347[ebp]
  000f8	d8 cc		 fmul	 ST(0), ST(4)
  000fa	d9 c3		 fld	 ST(3)
  000fc	d9 e0		 fchs
  000fe	d8 cb		 fmul	 ST(0), ST(3)
  00100	de e9		 fsubp	 ST(1), ST(0)
  00102	d9 58 20	 fstp	 DWORD PTR [eax+32]

; 208  : 	matrix[2][1] = (cr*sp*sy+-sr*cy);

  00105	d9 ca		 fxch	 ST(2)
  00107	dc 4d e8	 fmul	 QWORD PTR tv347[ebp]
  0010a	d9 c9		 fxch	 ST(1)
  0010c	de cb		 fmulp	 ST(3), ST(0)
  0010e	de e2		 fsubrp	 ST(2), ST(0)
  00110	d9 c9		 fxch	 ST(1)
  00112	d9 58 24	 fstp	 DWORD PTR [eax+36]

; 209  : 	matrix[2][2] = cr*cp;

  00115	de c9		 fmulp	 ST(1), ST(0)
  00117	d9 58 28	 fstp	 DWORD PTR [eax+40]

; 210  : 	matrix[0][3] = 0.0;

  0011a	d9 ee		 fldz
  0011c	d9 50 0c	 fst	 DWORD PTR [eax+12]

; 211  : 	matrix[1][3] = 0.0;

  0011f	d9 50 1c	 fst	 DWORD PTR [eax+28]

; 212  : 	matrix[2][3] = 0.0;

  00122	d9 58 2c	 fstp	 DWORD PTR [eax+44]

; 213  : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_AngleIMatrix ENDP
_TEXT	ENDS
PUBLIC	_AngleQuaternion
; Function compile flags: /Ogtp
;	COMDAT _AngleQuaternion
_TEXT	SEGMENT
_sy$ = -20						; size = 4
_cy$ = -16						; size = 4
_cp$ = -12						; size = 4
tv72 = -8						; size = 4
_sr$ = -8						; size = 4
tv282 = -4						; size = 4
tv267 = -4						; size = 4
_sp$ = -4						; size = 4
tv275 = 8						; size = 4
tv260 = 8						; size = 4
tv177 = 8						; size = 4
_cr$ = 8						; size = 4
_angle$ = 8						; size = 4
_angles$ = 8						; size = 4
_quaternion$ = 12					; size = 4
_AngleQuaternion PROC					; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 280  : 	float		angle;
; 281  : 	float		sr, sp, sy, cr, cp, cy;
; 282  : 
; 283  : 	// FIXME: rescale the inputs to 1/2 angle
; 284  : 	angle = (float)angles[2] * 0.5;

  00007	8b 75 08	 mov	 esi, DWORD PTR _angles$[ebp]
  0000a	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00013	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 285  : 	sy = (float)sin(angle);

  00016	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00019	e8 00 00 00 00	 call	 __CIsin
  0001e	d9 5d fc	 fstp	 DWORD PTR tv282[ebp]
  00021	d9 45 fc	 fld	 DWORD PTR tv282[ebp]
  00024	d9 5d ec	 fstp	 DWORD PTR _sy$[ebp]

; 286  : 	cy = (float)cos(angle);

  00027	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  0002a	e8 00 00 00 00	 call	 __CIcos
  0002f	d9 5d 08	 fstp	 DWORD PTR tv275[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv275[ebp]
  00035	d9 5d f0	 fstp	 DWORD PTR _cy$[ebp]

; 287  : 	angle = angles[1] * 0.5;

  00038	d9 46 04	 fld	 DWORD PTR [esi+4]
  0003b	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00041	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 288  : 	sp = (float)sin(angle);

  00044	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00047	e8 00 00 00 00	 call	 __CIsin
  0004c	d9 5d fc	 fstp	 DWORD PTR tv267[ebp]
  0004f	d9 45 fc	 fld	 DWORD PTR tv267[ebp]
  00052	d9 5d fc	 fstp	 DWORD PTR _sp$[ebp]

; 289  : 	cp = (float)cos(angle);

  00055	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00058	e8 00 00 00 00	 call	 __CIcos
  0005d	d9 5d 08	 fstp	 DWORD PTR tv260[ebp]
  00060	d9 45 08	 fld	 DWORD PTR tv260[ebp]
  00063	d9 5d f4	 fstp	 DWORD PTR _cp$[ebp]

; 290  : 	angle = angles[0] * 0.5;

  00066	d9 06		 fld	 DWORD PTR [esi]
  00068	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  0006e	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 291  : 	sr = (float)sin(angle);

  00071	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00074	e8 00 00 00 00	 call	 __CIsin
  00079	d9 5d f8	 fstp	 DWORD PTR tv72[ebp]
  0007c	d9 45 f8	 fld	 DWORD PTR tv72[ebp]
  0007f	d9 5d f8	 fstp	 DWORD PTR _sr$[ebp]

; 292  : 	cr = (float)cos(angle);

  00082	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00085	e8 00 00 00 00	 call	 __CIcos
  0008a	d9 5d 08	 fstp	 DWORD PTR tv177[ebp]
  0008d	d9 45 08	 fld	 DWORD PTR tv177[ebp]

; 293  : 
; 294  : 	quaternion[0] = sr*cp*cy-cr*sp*sy; // X

  00090	8b 45 0c	 mov	 eax, DWORD PTR _quaternion$[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _cr$[ebp]
  00096	5e		 pop	 esi
  00097	d9 45 f8	 fld	 DWORD PTR _sr$[ebp]
  0009a	d9 c0		 fld	 ST(0)
  0009c	d9 45 f4	 fld	 DWORD PTR _cp$[ebp]
  0009f	d9 c0		 fld	 ST(0)
  000a1	de ca		 fmulp	 ST(2), ST(0)
  000a3	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000a6	d8 4d fc	 fmul	 DWORD PTR _sp$[ebp]
  000a9	d9 45 f0	 fld	 DWORD PTR _cy$[ebp]
  000ac	d9 c0		 fld	 ST(0)
  000ae	d8 cc		 fmul	 ST(0), ST(4)
  000b0	d9 45 ec	 fld	 DWORD PTR _sy$[ebp]
  000b3	d9 c0		 fld	 ST(0)
  000b5	d8 cc		 fmul	 ST(0), ST(4)
  000b7	de ea		 fsubp	 ST(2), ST(0)
  000b9	d9 c9		 fxch	 ST(1)
  000bb	d9 18		 fstp	 DWORD PTR [eax]

; 295  : 	quaternion[1] = cr*sp*cy+sr*cp*sy; // Y

  000bd	d9 c1		 fld	 ST(1)
  000bf	de cb		 fmulp	 ST(3), ST(0)
  000c1	d9 c0		 fld	 ST(0)
  000c3	de cd		 fmulp	 ST(5), ST(0)
  000c5	d9 ca		 fxch	 ST(2)
  000c7	de c4		 faddp	 ST(4), ST(0)
  000c9	d9 cb		 fxch	 ST(3)
  000cb	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 296  : 	quaternion[2] = cr*cp*sy-sr*sp*cy; // Z

  000ce	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000d1	de ca		 fmulp	 ST(2), ST(0)
  000d3	d9 45 fc	 fld	 DWORD PTR _sp$[ebp]
  000d6	de cc		 fmulp	 ST(4), ST(0)
  000d8	d9 c0		 fld	 ST(0)
  000da	d8 ca		 fmul	 ST(0), ST(2)
  000dc	d9 c3		 fld	 ST(3)
  000de	d8 cd		 fmul	 ST(0), ST(5)
  000e0	de e9		 fsubp	 ST(1), ST(0)
  000e2	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 297  : 	quaternion[3] = cr*cp*cy+sr*sp*sy; // W

  000e5	de cb		 fmulp	 ST(3), ST(0)
  000e7	de c9		 fmulp	 ST(1), ST(0)
  000e9	de c1		 faddp	 ST(1), ST(0)
  000eb	d9 58 0c	 fstp	 DWORD PTR [eax+12]

; 298  : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
_AngleQuaternion ENDP
_TEXT	ENDS
PUBLIC	__real@400921fb60000000
PUBLIC	__real@3e45798ee2308c3a
PUBLIC	_QuaternionSlerp
;	COMDAT __real@400921fb60000000
; File d:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@400921fb60000000 DQ 0400921fb60000000r	; 3.14159
CONST	ENDS
;	COMDAT __real@3e45798ee2308c3a
CONST	SEGMENT
__real@3e45798ee2308c3a DQ 03e45798ee2308c3ar	; 1e-008
; Function compile flags: /Ogtp
; File e:\work\tranet_version\gs\gameserver\zzzmathlib.cpp
CONST	ENDS
;	COMDAT _QuaternionSlerp
_TEXT	SEGMENT
_sinom$ = -4						; size = 4
tv1775 = 8						; size = 4
tv1771 = 8						; size = 4
tv1767 = 8						; size = 4
tv1753 = 8						; size = 4
tv1749 = 8						; size = 4
tv1745 = 8						; size = 4
tv1717 = 8						; size = 4
tv1710 = 8						; size = 4
_sclp$ = 8						; size = 4
_cosom$ = 8						; size = 4
_b$ = 8							; size = 4
_p$ = 8							; size = 4
tv1699 = 12						; size = 4
tv1693 = 12						; size = 4
_sclq$ = 12						; size = 4
_omega$ = 12						; size = 4
_a$ = 12						; size = 4
_q$ = 12						; size = 4
_t$ = 16						; size = 4
_qt$ = 20						; size = 4
_QuaternionSlerp PROC					; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00008	d9 06		 fld	 DWORD PTR [esi]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _q$[ebp]
  0000e	d8 27		 fsub	 DWORD PTR [edi]
  00010	d9 46 04	 fld	 DWORD PTR [esi+4]
  00013	d8 67 04	 fsub	 DWORD PTR [edi+4]
  00016	d9 46 08	 fld	 DWORD PTR [esi+8]
  00019	d8 67 08	 fsub	 DWORD PTR [edi+8]
  0001c	d9 46 0c	 fld	 DWORD PTR [esi+12]
  0001f	d8 67 0c	 fsub	 DWORD PTR [edi+12]

; 318  : 	int i;
; 319  : 	float omega, cosom, sinom, sclp, sclq;
; 320  : 
; 321  : 	// decide if one of the quaternions is backwards
; 322  : 	float a = 0;
; 323  : 	float b = 0;
; 324  : 	for (i = 0; i < 4; i++) {
; 325  : 		a += (p[i]-q[i])*(p[i]-q[i]);

  00022	d9 c3		 fld	 ST(3)
  00024	de cc		 fmulp	 ST(4), ST(0)
  00026	d9 ee		 fldz
  00028	dc c4		 fadd	 ST(4), ST(0)
  0002a	d9 cc		 fxch	 ST(4)
  0002c	d9 5d 08	 fstp	 DWORD PTR tv1775[ebp]
  0002f	d9 45 08	 fld	 DWORD PTR tv1775[ebp]
  00032	d9 c3		 fld	 ST(3)
  00034	de cc		 fmulp	 ST(4), ST(0)
  00036	de c3		 faddp	 ST(3), ST(0)
  00038	d9 ca		 fxch	 ST(2)
  0003a	d9 5d 08	 fstp	 DWORD PTR tv1771[ebp]
  0003d	d9 c0		 fld	 ST(0)
  0003f	de c9		 fmulp	 ST(1), ST(0)
  00041	d8 45 08	 fadd	 DWORD PTR tv1771[ebp]
  00044	d9 5d 08	 fstp	 DWORD PTR tv1767[ebp]
  00047	d9 c0		 fld	 ST(0)
  00049	de c9		 fmulp	 ST(1), ST(0)
  0004b	d8 45 08	 fadd	 DWORD PTR tv1767[ebp]
  0004e	d9 5d 0c	 fstp	 DWORD PTR _a$[ebp]
  00051	d9 06		 fld	 DWORD PTR [esi]
  00053	d8 07		 fadd	 DWORD PTR [edi]
  00055	d9 46 04	 fld	 DWORD PTR [esi+4]
  00058	d8 47 04	 fadd	 DWORD PTR [edi+4]
  0005b	d9 46 08	 fld	 DWORD PTR [esi+8]
  0005e	d8 47 08	 fadd	 DWORD PTR [edi+8]
  00061	d9 46 0c	 fld	 DWORD PTR [esi+12]
  00064	d8 47 0c	 fadd	 DWORD PTR [edi+12]

; 326  : 		b += (p[i]+q[i])*(p[i]+q[i]);

  00067	d9 c3		 fld	 ST(3)
  00069	de cc		 fmulp	 ST(4), ST(0)
  0006b	d9 cb		 fxch	 ST(3)
  0006d	de c4		 faddp	 ST(4), ST(0)
  0006f	d9 cb		 fxch	 ST(3)
  00071	d9 5d 08	 fstp	 DWORD PTR tv1753[ebp]
  00074	d9 c0		 fld	 ST(0)
  00076	de c9		 fmulp	 ST(1), ST(0)
  00078	d8 45 08	 fadd	 DWORD PTR tv1753[ebp]
  0007b	d9 5d 08	 fstp	 DWORD PTR tv1749[ebp]
  0007e	d9 45 08	 fld	 DWORD PTR tv1749[ebp]
  00081	d9 c2		 fld	 ST(2)
  00083	de cb		 fmulp	 ST(3), ST(0)
  00085	de c2		 faddp	 ST(2), ST(0)
  00087	d9 c9		 fxch	 ST(1)
  00089	d9 5d 08	 fstp	 DWORD PTR tv1745[ebp]
  0008c	d9 c0		 fld	 ST(0)
  0008e	de c9		 fmulp	 ST(1), ST(0)
  00090	d8 45 08	 fadd	 DWORD PTR tv1745[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _b$[ebp]

; 327  : 	}
; 328  : 	if (a > b) {

  00096	d9 45 0c	 fld	 DWORD PTR _a$[ebp]
  00099	d9 45 08	 fld	 DWORD PTR _b$[ebp]
  0009c	de d9		 fcompp
  0009e	df e0		 fnstsw	 ax
  000a0	f6 c4 05	 test	 ah, 5
  000a3	7a 1e		 jp	 SHORT $LN45@Quaternion

; 329  : 		for (i = 0; i < 4; i++) {
; 330  : 			q[i] = -q[i];

  000a5	d9 07		 fld	 DWORD PTR [edi]
  000a7	d9 e0		 fchs
  000a9	d9 1f		 fstp	 DWORD PTR [edi]
  000ab	d9 47 04	 fld	 DWORD PTR [edi+4]
  000ae	d9 e0		 fchs
  000b0	d9 5f 04	 fstp	 DWORD PTR [edi+4]
  000b3	d9 47 08	 fld	 DWORD PTR [edi+8]
  000b6	d9 e0		 fchs
  000b8	d9 5f 08	 fstp	 DWORD PTR [edi+8]
  000bb	d9 47 0c	 fld	 DWORD PTR [edi+12]
  000be	d9 e0		 fchs
  000c0	d9 5f 0c	 fstp	 DWORD PTR [edi+12]
$LN45@Quaternion:

; 331  : 		}
; 332  : 	}
; 333  : 
; 334  : 	cosom = p[0]*q[0] + p[1]*q[1] + p[2]*q[2] + p[3]*q[3];

  000c3	d9 46 04	 fld	 DWORD PTR [esi+4]
  000c6	d8 4f 04	 fmul	 DWORD PTR [edi+4]
  000c9	d9 06		 fld	 DWORD PTR [esi]
  000cb	d8 0f		 fmul	 DWORD PTR [edi]
  000cd	de c1		 faddp	 ST(1), ST(0)
  000cf	d9 46 08	 fld	 DWORD PTR [esi+8]
  000d2	d8 4f 08	 fmul	 DWORD PTR [edi+8]
  000d5	de c1		 faddp	 ST(1), ST(0)
  000d7	d9 46 0c	 fld	 DWORD PTR [esi+12]
  000da	d8 4f 0c	 fmul	 DWORD PTR [edi+12]
  000dd	de c1		 faddp	 ST(1), ST(0)
  000df	d9 5d 08	 fstp	 DWORD PTR _cosom$[ebp]

; 335  : 
; 336  : 	if ((1.0 + cosom) > 0.00000001) {

  000e2	d9 45 08	 fld	 DWORD PTR _cosom$[ebp]
  000e5	d9 c0		 fld	 ST(0)
  000e7	d9 e8		 fld1
  000e9	dc c1		 fadd	 ST(1), ST(0)
  000eb	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3e45798ee2308c3a
  000f1	d8 d2		 fcom	 ST(2)
  000f3	df e0		 fnstsw	 ax
  000f5	dd da		 fstp	 ST(2)
  000f7	f6 c4 05	 test	 ah, 5
  000fa	0f 8a be 00 00
	00		 jp	 $LN60@Quaternion

; 337  : 		if ((1.0 - cosom) > 0.00000001) {

  00100	d9 c2		 fld	 ST(2)
  00102	d8 e9		 fsubr	 ST(0), ST(1)
  00104	d8 da		 fcomp	 ST(2)
  00106	df e0		 fnstsw	 ax
  00108	dd d9		 fstp	 ST(1)
  0010a	f6 c4 41	 test	 ah, 65			; 00000041H
  0010d	75 52		 jne	 SHORT $LN63@Quaternion
  0010f	dd d8		 fstp	 ST(0)

; 338  : 			omega = acos( cosom );

  00111	e8 00 00 00 00	 call	 __CIacos
  00116	d9 5d 08	 fstp	 DWORD PTR tv1717[ebp]
  00119	d9 45 08	 fld	 DWORD PTR tv1717[ebp]
  0011c	d9 5d 0c	 fstp	 DWORD PTR _omega$[ebp]

; 339  : 			sinom = sin( omega );

  0011f	d9 45 0c	 fld	 DWORD PTR _omega$[ebp]
  00122	e8 00 00 00 00	 call	 __CIsin
  00127	d9 5d 08	 fstp	 DWORD PTR tv1710[ebp]
  0012a	d9 45 08	 fld	 DWORD PTR tv1710[ebp]
  0012d	d9 5d fc	 fstp	 DWORD PTR _sinom$[ebp]

; 340  : 			sclp = sin( (1.0 - t)*omega) / sinom;

  00130	d9 45 10	 fld	 DWORD PTR _t$[ebp]
  00133	d9 e8		 fld1
  00135	de e1		 fsubrp	 ST(1), ST(0)
  00137	d8 4d 0c	 fmul	 DWORD PTR _omega$[ebp]
  0013a	e8 00 00 00 00	 call	 __CIsin
  0013f	d8 75 fc	 fdiv	 DWORD PTR _sinom$[ebp]
  00142	d9 5d 08	 fstp	 DWORD PTR _sclp$[ebp]

; 341  : 			sclq = sin( t*omega ) / sinom;

  00145	d9 45 0c	 fld	 DWORD PTR _omega$[ebp]
  00148	d8 4d 10	 fmul	 DWORD PTR _t$[ebp]
  0014b	d9 5d 0c	 fstp	 DWORD PTR tv1699[ebp]
  0014e	d9 45 0c	 fld	 DWORD PTR tv1699[ebp]
  00151	e8 00 00 00 00	 call	 __CIsin
  00156	d9 5d 0c	 fstp	 DWORD PTR tv1693[ebp]
  00159	d9 45 0c	 fld	 DWORD PTR tv1693[ebp]
  0015c	d8 75 fc	 fdiv	 DWORD PTR _sinom$[ebp]

; 342  : 		}
; 343  : 		else {

  0015f	eb 0e		 jmp	 SHORT $LN65@Quaternion
$LN63@Quaternion:

; 337  : 		if ((1.0 - cosom) > 0.00000001) {

  00161	dd d9		 fstp	 ST(1)

; 344  : 			sclp = 1.0 - t;

  00163	d9 45 10	 fld	 DWORD PTR _t$[ebp]
  00166	d9 c0		 fld	 ST(0)
  00168	de ea		 fsubp	 ST(2), ST(0)
  0016a	d9 c9		 fxch	 ST(1)
  0016c	d9 5d 08	 fstp	 DWORD PTR _sclp$[ebp]
$LN65@Quaternion:

; 345  : 			sclq = t;

  0016f	d9 5d 0c	 fstp	 DWORD PTR _sclq$[ebp]

; 346  : 		}
; 347  : 		for (i = 0; i < 4; i++) {
; 348  : 			qt[i] = sclp * p[i] + sclq * q[i];

  00172	8b 45 14	 mov	 eax, DWORD PTR _qt$[ebp]
  00175	d9 06		 fld	 DWORD PTR [esi]
  00177	d9 45 08	 fld	 DWORD PTR _sclp$[ebp]
  0017a	d9 c0		 fld	 ST(0)
  0017c	de ca		 fmulp	 ST(2), ST(0)
  0017e	d9 07		 fld	 DWORD PTR [edi]
  00180	d9 45 0c	 fld	 DWORD PTR _sclq$[ebp]
  00183	d9 c0		 fld	 ST(0)
  00185	de ca		 fmulp	 ST(2), ST(0)
  00187	d9 cb		 fxch	 ST(3)
  00189	de c1		 faddp	 ST(1), ST(0)
  0018b	d9 18		 fstp	 DWORD PTR [eax]
  0018d	d9 47 04	 fld	 DWORD PTR [edi+4]
  00190	d8 ca		 fmul	 ST(0), ST(2)
  00192	d9 46 04	 fld	 DWORD PTR [esi+4]
  00195	d8 ca		 fmul	 ST(0), ST(2)
  00197	de c1		 faddp	 ST(1), ST(0)
  00199	d9 58 04	 fstp	 DWORD PTR [eax+4]
  0019c	d9 47 08	 fld	 DWORD PTR [edi+8]
  0019f	d8 ca		 fmul	 ST(0), ST(2)
  001a1	d9 46 08	 fld	 DWORD PTR [esi+8]
  001a4	d8 ca		 fmul	 ST(0), ST(2)
  001a6	de c1		 faddp	 ST(1), ST(0)
  001a8	d9 58 08	 fstp	 DWORD PTR [eax+8]
  001ab	d9 47 0c	 fld	 DWORD PTR [edi+12]
  001ae	5f		 pop	 edi
  001af	de ca		 fmulp	 ST(2), ST(0)
  001b1	d8 4e 0c	 fmul	 DWORD PTR [esi+12]
  001b4	5e		 pop	 esi
  001b5	de c1		 faddp	 ST(1), ST(0)
  001b7	d9 58 0c	 fstp	 DWORD PTR [eax+12]

; 360  : 		}
; 361  : 	}
; 362  : }

  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c3		 ret	 0
$LN60@Quaternion:

; 349  : 		}
; 350  : 	}
; 351  : 	else {
; 352  : 		qt[0] = -p[1];

  001be	8b 7d 14	 mov	 edi, DWORD PTR _qt$[ebp]
  001c1	dd da		 fstp	 ST(2)
  001c3	dd d8		 fstp	 ST(0)
  001c5	d9 46 04	 fld	 DWORD PTR [esi+4]
  001c8	d9 e0		 fchs
  001ca	d9 1f		 fstp	 DWORD PTR [edi]

; 353  : 		qt[1] = p[0];

  001cc	d9 06		 fld	 DWORD PTR [esi]
  001ce	d9 5f 04	 fstp	 DWORD PTR [edi+4]

; 354  : 		qt[2] = -p[3];

  001d1	d9 46 0c	 fld	 DWORD PTR [esi+12]
  001d4	d9 e0		 fchs
  001d6	d9 5f 08	 fstp	 DWORD PTR [edi+8]

; 355  : 		qt[3] = p[2];

  001d9	d9 46 08	 fld	 DWORD PTR [esi+8]
  001dc	d9 5f 0c	 fstp	 DWORD PTR [edi+12]

; 356  : 		sclp = sin( (1.0 - t) * 0.5 * Q_PI);

  001df	d8 65 10	 fsub	 DWORD PTR _t$[ebp]
  001e2	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  001e8	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@400921fb60000000
  001ee	e8 00 00 00 00	 call	 __CIsin
  001f3	d9 5d 08	 fstp	 DWORD PTR _sclp$[ebp]

; 357  : 		sclq = sin( t * 0.5 * Q_PI);

  001f6	d9 45 10	 fld	 DWORD PTR _t$[ebp]
  001f9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  001ff	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@400921fb60000000
  00205	e8 00 00 00 00	 call	 __CIsin
  0020a	d9 5d 0c	 fstp	 DWORD PTR _sclq$[ebp]

; 358  : 		for (i = 0; i < 3; i++) {
; 359  : 			qt[i] = sclp * p[i] + sclq * qt[i];

  0020d	d9 06		 fld	 DWORD PTR [esi]
  0020f	d9 45 08	 fld	 DWORD PTR _sclp$[ebp]
  00212	d9 c0		 fld	 ST(0)
  00214	de ca		 fmulp	 ST(2), ST(0)
  00216	d9 07		 fld	 DWORD PTR [edi]
  00218	d9 45 0c	 fld	 DWORD PTR _sclq$[ebp]
  0021b	d9 c0		 fld	 ST(0)
  0021d	de ca		 fmulp	 ST(2), ST(0)
  0021f	d9 cb		 fxch	 ST(3)
  00221	de c1		 faddp	 ST(1), ST(0)
  00223	d9 1f		 fstp	 DWORD PTR [edi]
  00225	d9 47 04	 fld	 DWORD PTR [edi+4]
  00228	d8 ca		 fmul	 ST(0), ST(2)
  0022a	d9 46 04	 fld	 DWORD PTR [esi+4]
  0022d	d8 ca		 fmul	 ST(0), ST(2)
  0022f	de c1		 faddp	 ST(1), ST(0)
  00231	d9 5f 04	 fstp	 DWORD PTR [edi+4]
  00234	d8 4e 08	 fmul	 DWORD PTR [esi+8]
  00237	d9 47 08	 fld	 DWORD PTR [edi+8]
  0023a	de ca		 fmulp	 ST(2), ST(0)
  0023c	de c1		 faddp	 ST(1), ST(0)
  0023e	d9 5f 08	 fstp	 DWORD PTR [edi+8]
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi

; 360  : 		}
; 361  : 	}
; 362  : }

  00243	8b e5		 mov	 esp, ebp
  00245	5d		 pop	 ebp
  00246	c3		 ret	 0
_QuaternionSlerp ENDP
_TEXT	ENDS
PUBLIC	_FaceNormalize
; Function compile flags: /Ogtp
;	COMDAT _FaceNormalize
_TEXT	SEGMENT
tv301 = -4						; size = 4
tv294 = -4						; size = 4
_nx$ = 8						; size = 4
_v1$ = 8						; size = 4
_ny$ = 12						; size = 4
_v2$ = 12						; size = 4
_nz$ = 16						; size = 4
_v3$ = 16						; size = 4
_Normal$ = 20						; size = 4
_FaceNormalize PROC					; COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 366  :     float nx,ny,nz;
; 367  :     nx = (v2[1]-v1[1]) * (v3[2]-v1[2]) - (v3[1]-v1[1]) * (v2[2]-v1[2]);

  00004	8b 45 08	 mov	 eax, DWORD PTR _v1$[ebp]
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _v2$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR _v3$[ebp]
  0000d	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00010	d8 60 04	 fsub	 DWORD PTR [eax+4]
  00013	d9 42 08	 fld	 DWORD PTR [edx+8]
  00016	d8 60 08	 fsub	 DWORD PTR [eax+8]
  00019	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0001c	d8 60 08	 fsub	 DWORD PTR [eax+8]
  0001f	d9 42 04	 fld	 DWORD PTR [edx+4]
  00022	d8 60 04	 fsub	 DWORD PTR [eax+4]
  00025	d9 c2		 fld	 ST(2)
  00027	d8 cc		 fmul	 ST(0), ST(4)
  00029	d9 c1		 fld	 ST(1)
  0002b	d8 cb		 fmul	 ST(0), ST(3)
  0002d	de e9		 fsubp	 ST(1), ST(0)
  0002f	d9 5d 08	 fstp	 DWORD PTR _nx$[ebp]

; 368  :     ny = (v2[2]-v1[2]) * (v3[0]-v1[0]) - (v3[2]-v1[2]) * (v2[0]-v1[0]);

  00032	d9 02		 fld	 DWORD PTR [edx]
  00034	d8 20		 fsub	 DWORD PTR [eax]
  00036	d9 01		 fld	 DWORD PTR [ecx]
  00038	d8 20		 fsub	 DWORD PTR [eax]
  0003a	d9 c1		 fld	 ST(1)
  0003c	de cc		 fmulp	 ST(4), ST(0)
  0003e	d9 c0		 fld	 ST(0)
  00040	de cd		 fmulp	 ST(5), ST(0)
  00042	d9 cb		 fxch	 ST(3)
  00044	de e4		 fsubrp	 ST(4), ST(0)
  00046	d9 cb		 fxch	 ST(3)
  00048	d9 5d 0c	 fstp	 DWORD PTR _ny$[ebp]

; 369  :     nz = (v2[0]-v1[0]) * (v3[1]-v1[1]) - (v3[0]-v1[0]) * (v2[1]-v1[1]);

  0004b	de c9		 fmulp	 ST(1), ST(0)
  0004d	d9 c9		 fxch	 ST(1)
  0004f	de ca		 fmulp	 ST(2), ST(0)
  00051	de e1		 fsubrp	 ST(1), ST(0)
  00053	d9 5d 10	 fstp	 DWORD PTR _nz$[ebp]

; 370  :     double dot = sqrt(nx*nx+ny*ny+nz*nz);

  00056	d9 45 0c	 fld	 DWORD PTR _ny$[ebp]
  00059	d9 45 08	 fld	 DWORD PTR _nx$[ebp]
  0005c	d9 45 10	 fld	 DWORD PTR _nz$[ebp]
  0005f	d9 c1		 fld	 ST(1)
  00061	de ca		 fmulp	 ST(2), ST(0)
  00063	d9 c2		 fld	 ST(2)
  00065	de cb		 fmulp	 ST(3), ST(0)
  00067	d9 c9		 fxch	 ST(1)
  00069	de c2		 faddp	 ST(2), ST(0)
  0006b	dc c8		 fmul	 ST(0), ST(0)
  0006d	de c1		 faddp	 ST(1), ST(0)
  0006f	d9 5d fc	 fstp	 DWORD PTR tv301[ebp]
  00072	d9 45 fc	 fld	 DWORD PTR tv301[ebp]
  00075	e8 00 00 00 00	 call	 __CIsqrt
  0007a	d9 5d fc	 fstp	 DWORD PTR tv294[ebp]
  0007d	d9 45 fc	 fld	 DWORD PTR tv294[ebp]

; 371  : 	if(dot == 0) return;

  00080	d9 c0		 fld	 ST(0)
  00082	d9 ee		 fldz
  00084	da e9		 fucompp
  00086	df e0		 fnstsw	 ax
  00088	f6 c4 44	 test	 ah, 68			; 00000044H
  0008b	7b 1c		 jnp	 SHORT $LN9@FaceNormal

; 372  : 	Normal[0] = (nx/dot);

  0008d	d9 45 08	 fld	 DWORD PTR _nx$[ebp]
  00090	8b 45 14	 mov	 eax, DWORD PTR _Normal$[ebp]
  00093	d8 f1		 fdiv	 ST(0), ST(1)
  00095	d9 18		 fstp	 DWORD PTR [eax]

; 373  : 	Normal[1] = (ny/dot);

  00097	d9 45 0c	 fld	 DWORD PTR _ny$[ebp]
  0009a	d8 f1		 fdiv	 ST(0), ST(1)
  0009c	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 374  : 	Normal[2] = (nz/dot);

  0009f	d8 7d 10	 fdivr	 DWORD PTR _nz$[ebp]
  000a2	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 375  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN9@FaceNormal:

; 374  : 	Normal[2] = (nz/dot);

  000a9	dd d8		 fstp	 ST(0)

; 375  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_FaceNormalize ENDP
_TEXT	ENDS
PUBLIC	_VectorLength
; Function compile flags: /Ogtp
;	COMDAT _VectorLength
_TEXT	SEGMENT
tv331 = -4						; size = 4
tv326 = -4						; size = 4
_length$ = -4						; size = 4
_v$ = 8							; size = 4
_VectorLength PROC					; COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00007	d9 00		 fld	 DWORD PTR [eax]

; 26   : 	int		i;
; 27   : 	float	length;
; 28   : 	
; 29   : 	length = 0;
; 30   : 	for (i=0 ; i< 3 ; i++)
; 31   : 		length += v[i]*v[i];
; 32   : 	length = GetSquare (length);

  00009	51		 push	 ecx
  0000a	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000d	d9 40 08	 fld	 DWORD PTR [eax+8]
  00010	d9 c2		 fld	 ST(2)
  00012	de cb		 fmulp	 ST(3), ST(0)
  00014	d9 ca		 fxch	 ST(2)
  00016	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@0000000000000000
  0001c	d9 5d fc	 fstp	 DWORD PTR tv331[ebp]
  0001f	d9 c0		 fld	 ST(0)
  00021	de c9		 fmulp	 ST(1), ST(0)
  00023	d8 45 fc	 fadd	 DWORD PTR tv331[ebp]
  00026	d9 5d fc	 fstp	 DWORD PTR tv326[ebp]
  00029	d9 c0		 fld	 ST(0)
  0002b	de c9		 fmulp	 ST(1), ST(0)
  0002d	d8 45 fc	 fadd	 DWORD PTR tv326[ebp]
  00030	d9 5d fc	 fstp	 DWORD PTR _length$[ebp]
  00033	d9 45 fc	 fld	 DWORD PTR _length$[ebp]
  00036	d9 1c 24	 fstp	 DWORD PTR [esp]
  00039	e8 00 00 00 00	 call	 _GetSquare
  0003e	83 c4 04	 add	 esp, 4

; 33   : 
; 34   : 	return length;
; 35   : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_VectorLength ENDP
_TEXT	ENDS
END
